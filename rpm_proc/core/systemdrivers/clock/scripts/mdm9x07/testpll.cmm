
;============================================================================
;
; *************** THIS SCRIPT WAS AUTOGENERATED ****************
;
; TARGET
;
;
; SCRIPT
;   TESTPLL.CMM
;
; GENERAL DESCRIPTION
;   This script can be used to lookup PLL config/status/frequency values.
;
; FUNCTIONS
;   N/A
;
;    Copyright (c) 2014 by QUALCOMM Technologies Inc.  All Rights Reserved.
;============================================================================


;-----------------------------------------------------------------------------
; Local variables
;-----------------------------------------------------------------------------

local &subscript
local &pre_div
local &post_div
local &access_mode

; PLLs available in this version of the script
local &pll0
local &pll1
local &pll2
local &pll3
local &pll4


;-----------------------------------------------------------------------------
; Go initialize constants
;-----------------------------------------------------------------------------

goto Init_Constants
Init_Constants_Done:


;-----------------------------------------------------------------------------
; Parse commandline arguments
;-----------------------------------------------------------------------------

; These arguments are passed in from testclock.cmm to enable a PLL
&testpll_cmd_arg0=""
&testpll_cmd_arg1=""

ENTRY &testpll_cmd_arg0 &testpll_cmd_arg1

if ("&testpll_cmd_arg0"=="on")||("&testpll_cmd_arg0"=="off")
(
  &pll_on_off_choice="&testpll_cmd_arg0"
  &pll_name_choice="&testpll_cmd_arg1"
  
  gosub Enable_Disable_PLL
  
  ; Nothing else to be done
  goto SCRIPT_END
)

;-----------------------------------------------------------------------------
; Define the window
;-----------------------------------------------------------------------------

&subscript=0

ENTRY &subscript

if "&subscript"==""
(
  AREA.RESet
  WINPOS 0. 0. 50% 100%
  AREA.Create PLL 150. 1000.
  AREA.view PLL
)

AREA.Select PLL
AREA.Clear PLL


;-----------------------------------------------------------------------------
; Error handler
;-----------------------------------------------------------------------------

on ERROR gosub
(
  print "An Error has Occurred"
  
  return
)


;-----------------------------------------------------------------------------
; Main Menu
;-----------------------------------------------------------------------------

print ""
print ""
print "[------------------------------------------------- TEST PLL TOOL -------------------------------------------------]"
print ""


Help:

  print "1: Configurations"
  print "2: Votes"
  print "3: Register Dump"
  print "4: Configure PLLs         [beta]"
  print "5: Turn PLLs on/off       [beta]"
  print "6: Route PLLs to test pad [beta]"
  print ""
  print "x: Exit"
  print ""


Main_Menu:

  print "Enter option (? for help):"
  enter &choice
  print "&choice"

  if "&choice"=="?"
  (
    goto Help
  )
  else if "&choice"=="x"
  (
    if "&subscript"==""
    (
      AREA.CLEAR CLOCK
      AREA.RESET
      WINCLEAR
      term.close 
    )
    
    enddo (0==0)
  )
  else if &choice==1
  (
    gosub Display_Configurations
  )
  else if &choice==2
  (
    gosub Display_Votes
  )
  else if &choice==3
  (
    gosub Display_Dump
  )
  else if &choice==4
  (
    gosub Configure_PLL_Enter
  )
  else if &choice==5
  (
    gosub Enable_Disable_PLL_Enter
  )
  else if &choice==6
  (
    gosub Route_PLL_To_Pad
  )
  else
  (
    print "Invalid selection"
  )

GOTO Main_Menu



;-----------------------------------------------------------------------------
; Initialize constants
;-----------------------------------------------------------------------------

Init_Constants:

  ; Access mode
  &access_mode="a"

  ; L, M, N, ALPHA, ALPHA_U mask values
  &HWIO_PLL_L_VAL_MASK=0xFF
  &HWIO_PLL_M_VAL_MASK=0x7FFFF
  &HWIO_PLL_N_VAL_MASK=0x7FFFF
  &HWIO_PLL_ALPHA_VAL_MASK=0xFFFFFFFF
  &HWIO_PLL_ALPHA_U_VAL_MASK=0xFF

  ; PLL vote registers
  &HWIO_GCC_APCS_GPLL_ENA_VOTE_ADDR=0x61845000
  &HWIO_GCC_APCS_HYP_GPLL_ENA_VOTE_ADDR=0x61861000
  &HWIO_GCC_APCS_TZ_GPLL_ENA_VOTE_ADDR=0x61813010
  &HWIO_GCC_MSS_Q6_GPLL_ENA_VOTE_ADDR=0x6181b000
  &HWIO_GCC_RPM_GPLL_ENA_VOTE_ADDR=0x61836000
  &HWIO_GCC_SPARE_GPLL_ENA_VOTE_ADDR=0x61800000
  

  ; GPLL0 registers
  &HWIO_GCC_GPLL0_MODE_ADDR=0x61821000
  &HWIO_GCC_GPLL0_L_VAL_ADDR=0x61821004
  &HWIO_GCC_GPLL0_ALPHA_VAL_ADDR=0x61821008
  &HWIO_GCC_GPLL0_ALPHA_VAL_U_ADDR=0x6182100c
  &HWIO_GCC_GPLL0_USER_CTL_ADDR=0x61821010
  &HWIO_GCC_GPLL0_USER_CTL_U_ADDR=0x61821014
  &HWIO_GCC_GPLL0_CONFIG_CTL_ADDR=0x61821018
  &HWIO_GCC_GPLL0_TEST_CTL_ADDR=0x6182101c
  &HWIO_GCC_GPLL0_TEST_CTL_U_ADDR=0x61821020
  &HWIO_GCC_GPLL0_STATUS_ADDR=0x61821024

  ; GPLL1 registers
  &HWIO_GCC_GPLL1_MODE_ADDR=0x61820000
  &HWIO_GCC_GPLL1_L_VAL_ADDR=0x61820004
  &HWIO_GCC_GPLL1_M_VAL_ADDR=0x61820008
  &HWIO_GCC_GPLL1_N_VAL_ADDR=0x6182000c
  &HWIO_GCC_GPLL1_USER_CTL_ADDR=0x61820010
  &HWIO_GCC_GPLL1_CONFIG_CTL_ADDR=0x61820014
  &HWIO_GCC_GPLL1_TEST_CTL_ADDR=0x61820018
  &HWIO_GCC_GPLL1_STATUS_ADDR=0x6182001c
  
  ; GPLL2 registers
  &HWIO_GCC_GPLL2_MODE_ADDR=0x61825000
  &HWIO_GCC_GPLL2_L_VAL_ADDR=0x61825004
  &HWIO_GCC_GPLL2_ALPHA_VAL_ADDR=0x61825008
  &HWIO_GCC_GPLL2_ALPHA_VAL_U_ADDR=0x6182500c
  &HWIO_GCC_GPLL2_USER_CTL_ADDR=0x61825010
  &HWIO_GCC_GPLL2_USER_CTL_U_ADDR=0x61825014
  &HWIO_GCC_GPLL2_CONFIG_CTL_ADDR=0x61825018
  &HWIO_GCC_GPLL2_TEST_CTL_ADDR=0x6182501c
  &HWIO_GCC_GPLL2_TEST_CTL_U_ADDR=0x61825020
  &HWIO_GCC_GPLL2_STATUS_ADDR=0x61825024

  &HWIO_GCC_BIMC_PLL_MODE_ADDR=0x61823000
  &HWIO_GCC_BIMC_PLL_L_VAL_ADDR=0x61823004
  &HWIO_GCC_BIMC_PLL_ALPHA_VAL_ADDR=0x61823008
  &HWIO_GCC_BIMC_PLL_ALPHA_VAL_U_ADDR=0x6182300c
  &HWIO_GCC_BIMC_PLL_USER_CTL_ADDR=0x61823010
  &HWIO_GCC_BIMC_PLL_USER_CTL_U_ADDR=0x61823014
  &HWIO_GCC_BIMC_PLL_CONFIG_CTL_ADDR=0x61823018
  &HWIO_GCC_BIMC_PLL_TEST_CTL_ADDR=0x6182301c
  &HWIO_GCC_BIMC_PLL_TEST_CTL_U_ADDR=0x61823020
  &HWIO_GCC_BIMC_PLL_STATUS_ADDR=0x61823024

  ; WCNPLL regiuters
  ;&HWIO_WCSS_A_PMU_PLL_MODE_ADDR=0x6a21b1c0
  ;&HWIO_WCSS_A_PMU_PLL_L_VAL_ADDR=0x6a21b1c4
  ;&HWIO_WCSS_A_PMU_PLL_M_VAL_ADDR=0x6a21b1c8
  ;&HWIO_WCSS_A_PMU_PLL_N_VAL_ADDR=0x6a21b1cc
  ;&HWIO_WCSS_A_PMU_PLL_USER_CTL_ADDR=0x6a21b1d0
  ;&HWIO_WCSS_A_PMU_PLL_CONFIG_CTL_ADDR=0x6a21b1d4
  ;&HWIO_WCSS_A_PMU_PLL_TEST_CTL_ADDR=0x6a21b1d8
  ;&HWIO_WCSS_A_PMU_PLL_STATUS_ADDR=0x6a21b1dc

  ; MPLL1 registers
  &HWIO_MSS_MPLL1_MODE_ADDR=0x64181020
  &HWIO_MSS_MPLL1_L_VAL_ADDR=0x64181024
  &HWIO_MSS_MPLL1_M_VAL_ADDR=0x64181028
  &HWIO_MSS_MPLL1_N_VAL_ADDR=0x6418102c
  &HWIO_MSS_MPLL1_USER_CTL_ADDR=0x64181030
  &HWIO_MSS_MPLL1_CONFIG_CTL_ADDR=0x64181034
  &HWIO_MSS_MPLL1_TEST_CTL_ADDR=0x64181038
  &HWIO_MSS_MPLL1_STATUS_ADDR=0x6418103c

  ;&HWIO_MSS_MPLL2_MODE_ADDR=0x64181040
  ;&HWIO_MSS_MPLL2_L_VAL_ADDR=0x64181044
  ;&HWIO_MSS_MPLL2_M_VAL_ADDR=0x64181048
  ;&HWIO_MSS_MPLL2_N_VAL_ADDR=0x6418104c
  ;&HWIO_MSS_MPLL2_USER_CTL_ADDR=0x64181050
  ;&HWIO_MSS_MPLL2_CONFIG_CTL_ADDR=0x64181054
  ;&HWIO_MSS_MPLL2_TEST_CTL_ADDR=0x64181058
  ;&HWIO_MSS_MPLL2_STATUS_ADDR=0x6418105c
  
  ; A7SSPLL registers  
  ;&HWIO_APCS_SH_PLL_MODE_ADDR=0x6b016000
  ;&HWIO_APCS_SH_PLL_L_VAL_ADDR=0x6b016004
  ;&HWIO_APCS_SH_PLL_M_VAL_ADDR=0x6b016008
  ;&HWIO_APCS_SH_PLL_N_VAL_ADDR=0x6b01600c
  ;&HWIO_APCS_SH_PLL_USER_CTL_ADDR=0x6b016010
  ;&HWIO_APCS_SH_PLL_CONFIG_CTL_ADDR=0x6b016014
  ;&HWIO_APCS_SH_PLL_TEST_CTL_ADDR=0x6b016018
  ;&HWIO_APCS_SH_PLL_STATUS_ADDR=0x6b01601c
  
    ; APCS_CPU_PLL registers
  &HWIO_APCS_CPU_PLL_MODE_ADDR=0x6B008018
  &HWIO_APCS_CPU_PLL_L_VAL_ADDR=0x6B00801C
  &HWIO_APCS_CPU_PLL_ALPHA_VAL_ADDR=0x6B008020
  &HWIO_APCS_CPU_PLL_ALPHA_VAL_U_ADDR=0x6B008024
  &HWIO_APCS_CPU_PLL_USER_CTL_ADDR=0x6B008028
  &HWIO_APCS_CPU_PLL_USER_CTL_U_ADDR=0x6B00802C
  &HWIO_APCS_CPU_PLL_CONFIG_CTL_ADDR=0x6B008030
  &HWIO_APCS_CPU_PLL_TEST_CTL_ADDR=0x6B008034
  &HWIO_APCS_CPU_PLL_TEST_CTL_U_ADDR=0x6B008038
  &HWIO_APCS_CPU_PLL_STATUS_ADDR=0x6B00803C

  goto Init_Constants_Done


;-----------------------------------------------------------------------------
; Calculate Pre-div and Post-Div for SR PLLs; where
; Pre-Div  [14:12]
; Post-Div [9:8]
;-----------------------------------------------------------------------------

Calculate_Pre_Post_Div_SR:

  if (&user_ctl_val&0x7000)==0x0000
    &pre_div=1
  else if (&user_ctl_val&0x7000)==0x1000
    &pre_div=2
  else if (&user_ctl_val&0x7000)==0x2000
    &pre_div=3
  else if (&user_ctl_val&0x7000)==0x3000
    &pre_div=4
  else if (&user_ctl_val&0x7000)==0x4000
    &pre_div=5
  else if (&user_ctl_val&0x7000)==0x5000
    &pre_div=6
  else if (&user_ctl_val&0x7000)==0x6000
    &pre_div=7
  else
    &pre_div=8

  if (&user_ctl_val&0x300)==0x000
    &post_div=1
  else if (&user_ctl_val&0x300)==0x100
    &post_div=2
  else
    &post_div=4

  return


;-----------------------------------------------------------------------------
; Calculate Pre-div and Post-Div for SR2/HF PLLs; where
; Pre-Div  [12]
; Post-Div [9:8]
;-----------------------------------------------------------------------------

Calculate_Pre_Post_Div_SR2_HF:

  if (&user_ctl_val&0x1000)==0x0000
    &pre_div=1
  else
    &pre_div=2

  if (&user_ctl_val&0x300)==0x000
    &post_div=1
  else if (&user_ctl_val&0x300)==0x100
    &post_div=2
  else
    &post_div=4

  return


;-----------------------------------------------------------------------------
; Calculate Pre-div and Post-Div for STROMER PLLs; where
; Pre-Div  [??]
; Post-Div [??]
;-----------------------------------------------------------------------------

Calculate_Pre_Post_Div_STROMER:

  if (&user_ctl_val&0x7000)==0x1000
    &pre_div=2
  else
    &pre_div=1
  
  if (&user_ctl_val&0xF00)==0x100
    &post_div=2
  else if (&user_ctl_val&0xF00)==0x300
    &post_div=4
  else if (&user_ctl_val&0xF00)==0x700
    &post_div=8
  else if (&user_ctl_val&0xF00)==0xF00
    &post_div=16
  else
    &post_div=1

  return



;-----------------------------------------------------------------------------
; Display the PLL settings
;-----------------------------------------------------------------------------

Display_PLL:

  ENTRY &pll_name &pll_num &pll_type &mode_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg &user_ctl_reg &status_reg

  local &mode_val
  local &l_val
  local &alpha_val
  local &alpha_u_val
  local &m_val
  local &n_val
  local &user_ctl_val
  local &user_ctl_u_val
  local &status_val
  local &pll_state
  local &pll_votable
  local &pll_main
  local &pll_test
  local &pll_aux
  local &pll_aux2
  local &pll_early
  local &clk_ref
  local &pll_freq
  local &alpha_combined_hex
  local &alpha_divisor
  local &alpha_float
  local &pll_num_formatted
  local &pll_name_formatted

  &mode_val=data.long(&access_mode:&mode_reg)
  &l_val=data.long(&access_mode:&l_reg)&(&HWIO_PLL_L_VAL_MASK)

  ; Get alpha values for Stromer PLLs
  if ("&pll_type"=="stromer_pll")
  (
    &alpha_val=data.long(&access_mode:&alpha_reg)&(&HWIO_PLL_ALPHA_VAL_MASK)
    &alpha_u_val=data.long(&access_mode:&alpha_u_reg)&(&HWIO_PLL_ALPHA_U_VAL_MASK)
  )

  ; Get m/n values for sr/sr2 PLLs
  else if ("&pll_type"=="sr_pll")||("&pll_type"=="sr2_pll")
  (
    &m_val=data.long(&access_mode:&m_reg)&(&HWIO_PLL_M_VAL_MASK)
    &n_val=data.long(&access_mode:&n_reg)&(&HWIO_PLL_N_VAL_MASK)

    if &n_val==0
      &n_val=1
  )

  &status_val=data.long(&access_mode:&status_reg)
  &user_ctl_val=data.long(&access_mode:&user_ctl_reg)

 if ("&pll_type"=="stromer_pll")
 (
  if (&mode_val&0x100000)==0x100000      ; FSM enabled on stromer pll
  (
    if (&mode_val&0x40000000)==0x40000000
      &pll_state="ON "
    else
      &pll_state="OFF"
  )
  else                                   ; FSM disabled on stromer pll
  (
    if (&mode_val&0x7)==0x7
      &pll_state="ON "
    else
      &pll_state="OFF"
  )
 )
 else
 (
  if (&mode_val&0x100000)==0x100000      ; FSM enabled on sr/sr2 pll
  (
    if (&status_val&0x20000)==0x20000
      &pll_state="ON "
    else
      &pll_state="OFF"
  )
  else                                   ; FSM disabled on sr/sr2 pll
  (
    if (&mode_val&0x7)==0x7
      &pll_state="ON "
    else
      &pll_state="OFF"
  )
 )

  ; Check for FSM mode
  if (&mode_val&0x100000)==0x100000
    &pll_votable="YES"
  else
    &pll_votable="NO "

  ; Check for test output
  if (&user_ctl_val&0x10)==0x10
    &pll_test="ON "
  else
    &pll_test="OFF"

  ; Check for early output
  if (&user_ctl_val&0x08)==0x08
    &pll_early="ON "
  else
    &pll_early="OFF"

  ; Check for aux2 output
  if (&user_ctl_val&0x04)==0x04
    &pll_aux2="ON "
  else
    &pll_aux2="OFF"

  ; Check for aux output
  if (&user_ctl_val&0x02)==0x02
    &pll_aux="ON "
  else
    &pll_aux="OFF"

 ; Check for main output
  if (&user_ctl_val&0x01)==0x01
    &pll_main="ON "
  else
    &pll_main="OFF"

  &clk_ref=19.2

  ; Check pre-div and post-div
  if ("&pll_type"=="sr_pll")
  (
    gosub Calculate_Pre_Post_Div_SR
  )
  else if ("&pll_type"=="sr2_pll")
  (
    gosub Calculate_Pre_Post_Div_SR2_HF
  )
  else if ("&pll_type"=="stromer_pll")
  (
    gosub Calculate_Pre_Post_Div_STROMER
  )

  ; Calculate the PLL frequency based on PLL type.
  if ("&pll_type"=="stromer_pll")
  (
    ; Combine alpha lower + upper
    &alpha_combined_hex=&alpha_val+(&alpha_u_val<<32.)
    &alpha_float=(&alpha_combined_hex*1.0)/((1<<40.)*1.0)

    &pll_freq=FORMAT.FLOAT(10, 6, (&clk_ref/&pre_div)*((&l_val+&alpha_float)/&post_div))
  )
  else if ("&pll_type"=="sr_pll")||("&pll_type"=="sr2_pll")||("&pll_type"=="hf_pll")
  (
    &pll_freq=FORMAT.FLOAT(10, 6, (&clk_ref*&l_val+&clk_ref*&m_val/&n_val)/&pre_div/&post_div)
  )

  ; Format the pll num and name strings
  ;&pll_num_formatted=FORMAT.DECIMAL(2., &pll_num)
  &pll_num_formatted=&pll_num

  ;&pll_name_formatted=STRING.CUT("        ", STRING.LEN("&pll_name"))
  ;&pll_name_formatted="&pll_name&pll_name_formatted"
  &pll_name_formatted=&pll_name

  print "&pll_num_formatted  &pll_name_formatted    &pll_state        &pll_votable        &pll_main        &pll_test        &pll_aux        &pll_aux2        &pll_early  &pll_freq"

  return


;-----------------------------------------------------------------------------
; Format dump registers 
;-----------------------------------------------------------------------------

Format_Dump_Registers:

  ENTRY &num &use &mode_reg &user_ctl_reg &user_ctl_u_reg &config_ctl_reg &test_ctl_reg &test_ctl_u_reg &status_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg

  local &mode_val
  local &user_ctl_val
  local &user_ctl_u_val
  local &config_ctl_val
  local &test_ctl_val
  local &test_ctl_u_val
  local &status_val
  local &l_val
  local &alpha_val
  local &alpha_u_val
  local &m_val
  local &n_val
  local &left_width
  local &temp_string
  local &temp_string_formatted

  ; Format PLL num and use
  &num=FORMAT.DECIMAL(0x2, &num)

  ; Format mode
  &mode_val=FORMAT.HEX(0x8, data.long(&access_mode:&mode_reg))
  &mode_reg=FORMAT.HEX(0x9, &mode_reg)

  ; Format l 
  &l_val=FORMAT.HEX(0x8, data.long(&access_mode:&l_reg))
  &l_reg=FORMAT.HEX(0x9, &l_reg)

  ; Format alpha if the register address is not zero
  if (&alpha_reg!=0)
  (
    &alpha_val=FORMAT.HEX(0x8, data.long(&access_mode:&alpha_reg))
    &alpha_reg=FORMAT.HEX(0x9, &alpha_reg)
  )

  ; Format alpha_u if the register address is not zero
  if (&alpha_u_reg!=0)
  (
    &alpha_u_val=FORMAT.HEX(0x8, data.long(&access_mode:&alpha_u_reg))
    &alpha_u_reg=FORMAT.HEX(0x9, &alpha_u_reg)
  )

  ; Format m if the register address is not zero
  if (&m_reg!=0)
  (
    &m_val=FORMAT.HEX(0x8, data.long(&access_mode:&m_reg))
    &m_reg=FORMAT.HEX(0x9, &m_reg)
  )

  ; Format n if the register address is not zero
  if (&n_reg!=0)
  (
    &n_val=FORMAT.HEX(0x8, data.long(&access_mode:&n_reg))
    &n_reg=FORMAT.HEX(0x9, &n_reg)
  )

  ; Format user_ctl
  &user_ctl_val=FORMAT.HEX(0x8, data.long(&access_mode:&user_ctl_reg))
  &user_ctl_reg=FORMAT.HEX(0x9, &user_ctl_reg)

  ; Format user_ctl_u if the register address is not zero
  if (&user_ctl_u_reg!=0)
  (
    &user_ctl_u_val=FORMAT.HEX(0x8, data.long(&access_mode:&user_ctl_u_reg))
    &user_ctl_u_reg=FORMAT.HEX(0x9, &user_ctl_u_reg)
  )

  ; Format config_ctl
  &config_ctl_val=FORMAT.HEX(0x8, data.long(&access_mode:&config_ctl_reg))
  &config_ctl_reg=FORMAT.HEX(0x9, &config_ctl_reg)

  ; Format test_ctl
  &test_ctl_val=FORMAT.HEX(0x8, data.long(&access_mode:&test_ctl_reg))
  &test_ctl_reg=FORMAT.HEX(0x9, &test_ctl_reg)

  ; Format test_ctl_u if the register address is not zero
  if (&test_ctl_u_reg!=0)
  (
    &test_ctl_u_val=FORMAT.HEX(0x8, data.long(&access_mode:&test_ctl_u_reg))
    &test_ctl_u_reg=FORMAT.HEX(0x9, &test_ctl_u_reg)
  )

  ; Format status
  &status_val=FORMAT.HEX(0x8, data.long(&access_mode:&status_reg))
  &status_reg=FORMAT.HEX(0x9, &status_reg)

  &left_width="                                     "

  print "__________________________________________________________________"
  &temp_string="[PLL&num : &use]"
  &temp_string_formatted=STRING.CUT("&left_width", STRING.LEN("&temp_string"))
  &temp_string_formatted="&temp_string&temp_string_formatted"
  print "&temp_string_formatted | |     Address : Value"

  &temp_string="MODE"
  &temp_string_formatted=STRING.CUT("&left_width", STRING.LEN("&temp_string"))
  &temp_string_formatted="&temp_string_formatted&temp_string"
  print "&temp_string_formatted | | 0x&mode_reg : 0x&mode_val"

  &temp_string="L"
  &temp_string_formatted=STRING.CUT("&left_width", STRING.LEN("&temp_string"))
  &temp_string_formatted="&temp_string_formatted&temp_string"
  print "&temp_string_formatted | | 0x&l_reg : 0x&l_val"

  if (&alpha_reg!=0)
  (
    &temp_string="ALPHA"
    &temp_string_formatted=STRING.CUT("&left_width", STRING.LEN("&temp_string"))
    &temp_string_formatted="&temp_string_formatted&temp_string"
    print "&temp_string_formatted | | 0x&alpha_reg : 0x&alpha_val"
  )

  if (&alpha_u_reg!=0)
  (
    &temp_string="ALPHA_U"
    &temp_string_formatted=STRING.CUT("&left_width", STRING.LEN("&temp_string"))
    &temp_string_formatted="&temp_string_formatted&temp_string"
    print "&temp_string_formatted | | 0x&alpha_u_reg : 0x&alpha_u_val"
  )

  if (&m_reg!=0)
  (
    &temp_string="M"
    &temp_string_formatted=STRING.CUT("&left_width", STRING.LEN("&temp_string"))
    &temp_string_formatted="&temp_string_formatted&temp_string"
    print "&temp_string_formatted | | 0x&m_reg : 0x&m_val"
  )

  if (&n_reg!=0)
  (
    &temp_string="N"
    &temp_string_formatted=STRING.CUT("&left_width", STRING.LEN("&temp_string"))
    &temp_string_formatted="&temp_string_formatted&temp_string"
    print "&temp_string_formatted | | 0x&n_reg : 0x&n_val"
  )

  &temp_string="USER_CTL"
  &temp_string_formatted=STRING.CUT("&left_width", STRING.LEN("&temp_string"))
  &temp_string_formatted="&temp_string_formatted&temp_string"
  print "&temp_string_formatted | | 0x&user_ctl_reg : 0x&user_ctl_val"

  if (&user_ctl_u_reg!=0)
  (
    &temp_string="USER_CTL_U"
    &temp_string_formatted=STRING.CUT("&left_width", STRING.LEN("&temp_string"))
    &temp_string_formatted="&temp_string_formatted&temp_string"
    print "&temp_string_formatted | | 0x&user_ctl_u_reg : 0x&user_ctl_u_val"
  )

  &temp_string="CONFIG_CTL"
  &temp_string_formatted=STRING.CUT("&left_width", STRING.LEN("&temp_string"))
  &temp_string_formatted="&temp_string_formatted&temp_string"
  print "&temp_string_formatted | | 0x&config_ctl_reg : 0x&config_ctl_val"

  &temp_string="TEST_CTL"
  &temp_string_formatted=STRING.CUT("&left_width", STRING.LEN("&temp_string"))
  &temp_string_formatted="&temp_string_formatted&temp_string"
  print "&temp_string_formatted | | 0x&test_ctl_reg : 0x&test_ctl_val"

  if (&test_ctl_u_reg!=0)
  (
    &temp_string="TEST_CTL_U"
    &temp_string_formatted=STRING.CUT("&left_width", STRING.LEN("&temp_string"))
    &temp_string_formatted="&temp_string_formatted&temp_string"
    print "&temp_string_formatted | | 0x&test_ctl_u_reg : 0x&test_ctl_u_val"
  )

  &temp_string="STATUS"
  &temp_string_formatted=STRING.CUT("&left_width", STRING.LEN("&temp_string"))
  &temp_string_formatted="&temp_string_formatted&temp_string"
  print "&temp_string_formatted | | 0x&status_reg : 0x&status_val"

  return


;-----------------------------------------------------------------------
; Display Configurations
;-----------------------------------------------------------------------

Display_Configurations:

  local &pll_name
  local &pll_num
  local &pll_type
  local &l_reg
  local &m_reg
  local &n_reg
  local &alpha_reg
  local &alpha_u_reg
  local &mode_reg
  local &user_ctl_reg
  local &status_reg

  print "PLL            USE                   STATE     VOTABLE   MAIN_OUT   TEST_OUT    AUX_OUT   AUX2_OUT   EARLY_OUT   CALC FREQ (MHz)"
  print "--- ------------------------------   -----     -------   --------   --------    -------   --------   ---------   ---------------"


  &pll_name="GPLL0                       "
  &pll_num="0  "
  &pll_type="stromer_pll"
  &mode_reg=&HWIO_GCC_GPLL0_MODE_ADDR
  &l_reg=&HWIO_GCC_GPLL0_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_reg=&HWIO_GCC_GPLL0_USER_CTL_ADDR
  &status_reg=&HWIO_GCC_GPLL0_STATUS_ADDR


  &alpha_reg=&HWIO_GCC_GPLL0_ALPHA_VAL_ADDR
  &alpha_u_reg=&HWIO_GCC_GPLL0_ALPHA_VAL_U_ADDR
  &user_ctl_u_reg=&HWIO_GCC_GPLL0_USER_CTL_U_ADDR
  gosub Display_PLL "&pll_name" "&pll_num" &pll_type &mode_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg &user_ctl_reg &status_reg


  &pll_name="GPLL1                       "
  &pll_num="1  "
  &pll_type="sr_pll"
  &mode_reg=&HWIO_GCC_GPLL1_MODE_ADDR
  &l_reg=&HWIO_GCC_GPLL1_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_reg=&HWIO_GCC_GPLL1_USER_CTL_ADDR
  &status_reg=&HWIO_GCC_GPLL1_STATUS_ADDR


  &m_reg=&HWIO_GCC_GPLL1_M_VAL_ADDR
  &n_reg=&HWIO_GCC_GPLL1_N_VAL_ADDR
  gosub Display_PLL "&pll_name" "&pll_num" &pll_type &mode_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg &user_ctl_reg &status_reg


  &pll_name="GPLL2                       "
  &pll_num="2  "
  &pll_type="stromer_pll"
  &mode_reg=&HWIO_GCC_GPLL2_MODE_ADDR
  &l_reg=&HWIO_GCC_GPLL2_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_reg=&HWIO_GCC_GPLL2_USER_CTL_ADDR
  &status_reg=&HWIO_GCC_GPLL2_STATUS_ADDR


  &alpha_reg=&HWIO_GCC_GPLL2_ALPHA_VAL_ADDR
  &alpha_u_reg=&HWIO_GCC_GPLL2_ALPHA_VAL_U_ADDR
  &user_ctl_u_reg=&HWIO_GCC_GPLL2_USER_CTL_U_ADDR
  gosub Display_PLL "&pll_name" "&pll_num" &pll_type &mode_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg &user_ctl_reg &status_reg

  &pll_name="BIMCPLL                     "
  &pll_num="3  "
  &pll_type="stromer_pll"
  &mode_reg=&HWIO_GCC_BIMC_PLL_MODE_ADDR
  &l_reg=&HWIO_GCC_BIMC_PLL_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_reg=&HWIO_GCC_BIMC_PLL_USER_CTL_ADDR
  &status_reg=&HWIO_GCC_BIMC_PLL_STATUS_ADDR


  &alpha_reg=&HWIO_GCC_BIMC_PLL_ALPHA_VAL_ADDR
  &alpha_u_reg=&HWIO_GCC_BIMC_PLL_ALPHA_VAL_U_ADDR
  &user_ctl_u_reg=&HWIO_GCC_BIMC_PLL_USER_CTL_U_ADDR
  gosub Display_PLL "&pll_name" "&pll_num" &pll_type &mode_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg &user_ctl_reg &status_reg

  &pll_name="APCS_CPU_PLL                 "
  &pll_num="4  "
  &pll_type="stromer_pll"
  &mode_reg=&HWIO_APCS_CPU_PLL_MODE_ADDR
  &l_reg=&HWIO_APCS_CPU_PLL_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_reg=&HWIO_APCS_CPU_PLL_USER_CTL_ADDR
  &status_reg=&HWIO_APCS_CPU_PLL_STATUS_ADDR

  &alpha_reg=&HWIO_APCS_CPU_PLL_ALPHA_VAL_ADDR
  &alpha_u_reg=&HWIO_APCS_CPU_PLL_ALPHA_VAL_U_ADDR
  &user_ctl_u_reg=&HWIO_APCS_CPU_PLL_USER_CTL_U_ADDR
  gosub Display_PLL "&pll_name" "&pll_num" &pll_type &mode_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg &user_ctl_reg &status_reg

  &pll_name="MPLL1                       "
  &pll_num="6  "
  &pll_type="sr2_pll"
  &mode_reg=&HWIO_MSS_MPLL1_MODE_ADDR
  &l_reg=&HWIO_MSS_MPLL1_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_reg=&HWIO_MSS_MPLL1_USER_CTL_ADDR
  &status_reg=&HWIO_MSS_MPLL1_STATUS_ADDR


  &m_reg=&HWIO_MSS_MPLL1_M_VAL_ADDR
  &n_reg=&HWIO_MSS_MPLL1_N_VAL_ADDR
  gosub Display_PLL "&pll_name" "&pll_num" &pll_type &mode_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg &user_ctl_reg &status_reg

  print " "
  print " "

  return


;-----------------------------------------------------------------------------
; Display the dump of mode/status registers.
;-----------------------------------------------------------------------------

Display_Dump:

  local &mode_reg
  local &user_ctl_reg
  local &user_ctl_u_reg
  local &config_ctl_reg
  local &test_ctl_reg
  local &test_ctl_u_reg
  local &status_reg

  ; Display the PLL mode, status, user, and test registers.

  &mode_reg=&HWIO_GCC_GPLL0_MODE_ADDR
  &status_reg=&HWIO_GCC_GPLL0_STATUS_ADDR
  &user_ctl_reg=&HWIO_GCC_GPLL0_USER_CTL_ADDR
  &config_ctl_reg=&HWIO_GCC_GPLL0_CONFIG_CTL_ADDR
  &test_ctl_reg=&HWIO_GCC_GPLL0_TEST_CTL_ADDR
  &l_reg=&HWIO_GCC_GPLL0_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_u_reg=0
  &test_ctl_u_reg=0
  &alpha_reg=&HWIO_GCC_GPLL0_ALPHA_VAL_ADDR
  &alpha_u_reg=&HWIO_GCC_GPLL0_ALPHA_VAL_U_ADDR
  &user_ctl_u_reg=&HWIO_GCC_GPLL0_USER_CTL_U_ADDR
  &test_ctl_u_reg=&HWIO_GCC_GPLL0_TEST_CTL_U_ADDR
  gosub Format_Dump_Registers   0. GPLL0                        &mode_reg &user_ctl_reg &user_ctl_u_reg &config_ctl_reg &test_ctl_reg &test_ctl_u_reg &status_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg

  &mode_reg=&HWIO_GCC_GPLL1_MODE_ADDR
  &status_reg=&HWIO_GCC_GPLL1_STATUS_ADDR
  &user_ctl_reg=&HWIO_GCC_GPLL1_USER_CTL_ADDR
  &config_ctl_reg=&HWIO_GCC_GPLL1_CONFIG_CTL_ADDR
  &test_ctl_reg=&HWIO_GCC_GPLL1_TEST_CTL_ADDR
  &l_reg=&HWIO_GCC_GPLL1_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_u_reg=0
  &test_ctl_u_reg=0
  &m_reg=&HWIO_GCC_GPLL1_M_VAL_ADDR
  &n_reg=&HWIO_GCC_GPLL1_N_VAL_ADDR
  gosub Format_Dump_Registers   1. GPLL1                        &mode_reg &user_ctl_reg &user_ctl_u_reg &config_ctl_reg &test_ctl_reg &test_ctl_u_reg &status_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg

  &mode_reg=&HWIO_GCC_GPLL2_MODE_ADDR
  &status_reg=&HWIO_GCC_GPLL2_STATUS_ADDR
  &user_ctl_reg=&HWIO_GCC_GPLL2_USER_CTL_ADDR
  &config_ctl_reg=&HWIO_GCC_GPLL2_CONFIG_CTL_ADDR
  &test_ctl_reg=&HWIO_GCC_GPLL2_TEST_CTL_ADDR
  &l_reg=&HWIO_GCC_GPLL2_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_u_reg=0
  &test_ctl_u_reg=0
  &alpha_reg=&HWIO_GCC_GPLL2_ALPHA_VAL_ADDR
  &alpha_u_reg=&HWIO_GCC_GPLL2_ALPHA_VAL_U_ADDR
  &user_ctl_u_reg=&HWIO_GCC_GPLL2_USER_CTL_U_ADDR
  &test_ctl_u_reg=&HWIO_GCC_GPLL2_TEST_CTL_U_ADDR
  gosub Format_Dump_Registers   2. GPLL2                        &mode_reg &user_ctl_reg &user_ctl_u_reg &config_ctl_reg &test_ctl_reg &test_ctl_u_reg &status_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg

  &mode_reg=&HWIO_GCC_BIMC_PLL_MODE_ADDR
  &status_reg=&HWIO_GCC_BIMC_PLL_STATUS_ADDR
  &user_ctl_reg=&HWIO_GCC_BIMC_PLL_USER_CTL_ADDR
  &config_ctl_reg=&HWIO_GCC_BIMC_PLL_CONFIG_CTL_ADDR
  &test_ctl_reg=&HWIO_GCC_BIMC_PLL_TEST_CTL_ADDR
  &l_reg=&HWIO_GCC_BIMC_PLL_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_u_reg=0
  &test_ctl_u_reg=0
  &alpha_reg=&HWIO_GCC_BIMC_PLL_ALPHA_VAL_ADDR
  &alpha_u_reg=&HWIO_GCC_BIMC_PLL_ALPHA_VAL_U_ADDR
  &user_ctl_u_reg=&HWIO_GCC_BIMC_PLL_USER_CTL_U_ADDR
  &test_ctl_u_reg=&HWIO_GCC_BIMC_PLL_TEST_CTL_U_ADDR
  gosub Format_Dump_Registers   3. BIMC_PLL                        &mode_reg &user_ctl_reg &user_ctl_u_reg &config_ctl_reg &test_ctl_reg &test_ctl_u_reg &status_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg

  &mode_reg=&HWIO_APCS_CPU_PLL_MODE_ADDR
  &status_reg=&HWIO_APCS_CPU_PLL_STATUS_ADDR
  &user_ctl_reg=&HWIO_APCS_CPU_PLL_USER_CTL_ADDR
  &config_ctl_reg=&HWIO_APCS_CPU_PLL_CONFIG_CTL_ADDR
  &test_ctl_reg=&HWIO_APCS_CPU_PLL_TEST_CTL_ADDR
  &l_reg=&HWIO_APCS_CPU_PLL_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_u_reg=0
  &test_ctl_u_reg=0
  &m_reg=&HWIO_APCS_CPU_PLL_M_VAL_ADDR
  &n_reg=&HWIO_APCS_CPU_PLL_N_VAL_ADDR
  gosub Format_Dump_Registers   4. APCS_CPU_PLL                        &mode_reg &user_ctl_reg &user_ctl_u_reg &config_ctl_reg &test_ctl_reg &test_ctl_u_reg &status_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg

  
  &mode_reg=&HWIO_MSS_MPLL1_MODE_ADDR
  &status_reg=&HWIO_MSS_MPLL1_STATUS_ADDR
  &user_ctl_reg=&HWIO_MSS_MPLL1_USER_CTL_ADDR
  &config_ctl_reg=&HWIO_MSS_MPLL1_CONFIG_CTL_ADDR
  &test_ctl_reg=&HWIO_MSS_MPLL1_TEST_CTL_ADDR
  &l_reg=&HWIO_MSS_MPLL1_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_u_reg=0
  &test_ctl_u_reg=0
  &m_reg=&HWIO_MSS_MPLL1_M_VAL_ADDR
  &n_reg=&HWIO_MSS_MPLL1_N_VAL_ADDR
  gosub Format_Dump_Registers   6. MPLL1                        &mode_reg &user_ctl_reg &user_ctl_u_reg &config_ctl_reg &test_ctl_reg &test_ctl_u_reg &status_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg

  print "" 
  print "" 
    
  return


;-----------------------------------------------------------------------
; Get votes for GCC's
;-----------------------------------------------------------------------

Get_PLL_Vote_GCC:

  ENTRY &vote_reg

  &temp_reg=data.long(&access_mode:&vote_reg)

  if (&temp_reg&0x8)==0x8
    &pll3="Y"
  else
    &pll3=" "

  if (&temp_reg&0x4)==0x4
    &pll4="Y"
  else
    &pll4=" "

  if (&temp_reg&0x2)==0x2
    &pll2="Y"
  else
    &pll2=" "

  if (&temp_reg&0x1)==0x1
    &pll1="Y"
  else
    &pll1=" "

  return


;-----------------------------------------------------------------------
; Display PLL vote headline
;-----------------------------------------------------------------------

Display_PLL_Vote:
  
  print "&image |  &pll1  |  &pll2  |  &pll3  |  &pll4  |   "

  return


;-----------------------------------------------------------------------
; Reset PLL votes
;-----------------------------------------------------------------------

Reset_PLL_Votes:

  &pll1=" "
  &pll2=" "
  &pll3=" "
  &pll4=" "


  return


;-----------------------------------------------------------------------
; Display PLL voting table
;-----------------------------------------------------------------------

Display_Votes:

  local &vote_reg

  print " _____________       _____ _____ _____ _____    "
  print "|\            \    |\     \     \     \     \   "
  print "| \            \   | \  1  \  2  \  3  \  4  \  "
  print "|  \____________\__|  \_____\_____\_____\_____\ "
  print "|  |            |  |  |     |     |     |     | "


  ; Display APCS_HYP votes
  gosub Reset_PLL_Votes
  &image="|\ |  APCS_HYP  |  |\"

  ; Get APCS_HYP votes on GCC's
  &vote_reg=&HWIO_GCC_APCS_HYP_GPLL_ENA_VOTE_ADDR
  gosub Get_PLL_Vote_GCC &vote_reg

  gosub Display_PLL_Vote

  print "| \|____________|__| \|_____|_____|_____|_____| "
  print "|  |            |  |  |     |     |     |     | "
  

  ; Display MSS votes
  gosub Reset_PLL_Votes
  &image="|\ |  MSS       |  |\"

  ; Get MSS votes on GCC's
  &vote_reg=&HWIO_GCC_MSS_Q6_GPLL_ENA_VOTE_ADDR
  gosub Get_PLL_Vote_GCC &vote_reg

  gosub Display_PLL_Vote

  print "| \|____________|__| \|_____|_____|_____|_____| "
  print "|  |            |  |  |     |     |     |     | "


  ; Display SPARE votes
  gosub Reset_PLL_Votes
  &image="|\ |  SPARE     |  |\"

  ; Get SPARE votes on GCC's
  &vote_reg=&HWIO_GCC_SPARE_GPLL_ENA_VOTE_ADDR
  gosub Get_PLL_Vote_GCC &vote_reg

  gosub Display_PLL_Vote

  print "| \|____________|__| \|_____|_____|_____|_____| "
  print "|  |            |  |  |     |     |     |     | "


  ; Display APCS_TZ votes
  gosub Reset_PLL_Votes
  &image="|\ |  APCS_TZ   |  |\"

  ; Get APCS_TZ votes on GCC's
  &vote_reg=&HWIO_GCC_APCS_TZ_GPLL_ENA_VOTE_ADDR
  gosub Get_PLL_Vote_GCC &vote_reg

  gosub Display_PLL_Vote

  print "| \|____________|__| \|_____|_____|_____|_____| "
  print "|  |            |  |  |     |     |     |     | "


  ; Display APCS votes
  gosub Reset_PLL_Votes
  &image="|\ |  APCS      |  |\"

  ; Get APCS votes on GCC's
  &vote_reg=&HWIO_GCC_APCS_GPLL_ENA_VOTE_ADDR
  gosub Get_PLL_Vote_GCC &vote_reg

  gosub Display_PLL_Vote

  print "| \|____________|__| \|_____|_____|_____|_____| "
  print "|  |            |  |  |     |     |     |     | "


  ; Display RPM votes
  gosub Reset_PLL_Votes
  &image="|\ |  RPM       |  |\"

  ; Get RPM votes on GCC's
  &vote_reg=&HWIO_GCC_RPM_GPLL_ENA_VOTE_ADDR
  gosub Get_PLL_Vote_GCC &vote_reg

  gosub Display_PLL_Vote

  print "| \|____________|__| \|_____|_____|_____|_____| "
  print "|  |            |  |  |     |     |     |     | "


  print "" 
  print "" 
    
  return


;-----------------------------------------------------------------------
; Configure a PLL - Wrapper
;-----------------------------------------------------------------------

Configure_PLL_Enter:

  &pll_name_choice=""
  gosub Configure_PLL

  return


;-----------------------------------------------------------------------
; Configure SR / SR2 / Stromer PLLs.
; Note:
;-----------------------------------------------------------------------
          
Generic_PLL_Configure:

  ENTRY &mode_reg &user_reg &prediv &postdiv &l_reg &l_val &alpha_reg &alpha_val &alpha_u_reg &alpha_u_val &m_reg &m_val &n_reg &n_val &is_votable &pll_type

  &HWIO_PLL_VOTE_FSM_ENA_MASK=0x100000
  &HWIO_PLL_VOTE_FSM_RESET_MASK=0x200000

  &HWIO_PLL_BIAS_COUNT_MASK=0xfc000
  &HWIO_PLL_LOCK_COUNT_MASK=0x3f00

  &HWIO_PLL_BIAS_COUNT_VAL=(0x1<<0xe)
  &HWIO_PLL_LOCK_COUNT_VAL=0x0

  &HWIO_PLL_ALPHA_EN_MASK=0x1000000
  &HWIO_PLL_VCO_SEL_MASK=0x300000
  &HWIO_PLL_PRE_DIV_RATIO_MASK=0x7000
  &HWIO_PLL_POST_DIV_RATIO_MASK=0xf00

  &HWIO_PLL_VOTE_FSM_ENA_SHIFT=0x14
  &HWIO_PLL_ALPHA_EN_SHIFT=0x18
  &HWIO_PLL_VCO_SEL_SHIFT=0x14
  &HWIO_PLL_PRE_DIV_RATIO_SHIFT=0xc
  &HWIO_PLL_POST_DIV_RATIO_SHIFT=0x8

  local &mode_val
  local &user_val
  local &is_fsm_mode_enabled

  &is_fsm_mode_enabled=0x0
  ;data.set &access_mode:&mode_reg %long 0x0

  &mode_val=data.long(&access_mode:&mode_reg)

  if (&is_votable==0x1)
  (
    ; Disable FSM mode
    if (&mode_val&(&HWIO_PLL_VOTE_FSM_ENA_MASK))==&HWIO_PLL_VOTE_FSM_ENA_MASK
    (
      &is_fsm_mode_enabled=0x1
      &mode_val=&mode_val&~(&HWIO_PLL_VOTE_FSM_ENA_MASK)
      data.set &access_mode:&mode_reg %long &mode_val
    )
  )

  ; Set L
  data.set &access_mode:&l_reg %long &l_val

  ; Set ALPHA if register is non-zero
  if (&alpha_reg!=0)
  (
    data.set &access_mode:&alpha_reg %long &alpha_val
  )

  ; Set ALPHA_U if register is non-zero
  if (&alpha_u_reg!=0)
  (
    data.set &access_mode:&alpha_u_reg %long &alpha_u_val
  )

  ; Set M if register is non-zero
  if (&m_reg!=0)
  (
    data.set &access_mode:&m_reg %long &m_val
  )

  ; Set N if register is non-zero
  if (&n_reg!=0)
  (
    data.set &access_mode:&n_reg %long &n_val
  )

  ; Clear fields in user control register
  &user_val=data.long(&access_mode:&user_reg)
  &user_val=&user_val&~((&HWIO_PLL_ALPHA_EN_MASK)|(&HWIO_PLL_VCO_SEL_MASK)|(&HWIO_PLL_PRE_DIV_RATIO_MASK)|(&HWIO_PLL_POST_DIV_RATIO_MASK))

  ; Set fields in user control register
  &user_val=&user_val|(0x2<<&HWIO_PLL_VCO_SEL_SHIFT)
  &user_val=&user_val|((&prediv-1)<<&HWIO_PLL_PRE_DIV_RATIO_SHIFT)
  &user_val=&user_val|((&postdiv-1)<<&HWIO_PLL_POST_DIV_RATIO_SHIFT)

  if (&alpha_val!=0)||(&alpha_u_val!=0)
  (
    &user_val=&user_val|(&HWIO_PLL_ALPHA_EN_MASK)
  )

  ; Program the user control register
  data.set &access_mode:&user_reg %long &user_val


  if (&is_votable==0x1)
  (
    ; Put the FSM in reset
    &mode_val=&mode_val|(&HWIO_PLL_VOTE_FSM_RESET_MASK)
    data.set &access_mode:&mode_reg %long &mode_val

    ; Set the lock and bias
    &mode_val=&mode_val&~((&HWIO_PLL_BIAS_COUNT_MASK)|(&HWIO_PLL_LOCK_COUNT_MASK))
    &mode_val=&mode_val|(&HWIO_PLL_BIAS_COUNT_VAL)
    &mode_val=&mode_val|(&HWIO_PLL_LOCK_COUNT_VAL)

    ; Enable the FSM
    &mode_val=&mode_val|(&HWIO_PLL_VOTE_FSM_ENA_MASK)

    ; Program the mode register
    data.set &access_mode:&mode_reg %long &mode_val

    ; Take the FSM out of reset
    &mode_val=&mode_val&~(&HWIO_PLL_VOTE_FSM_RESET_MASK)
    data.set &access_mode:&mode_reg %long &mode_val
  )

  return


;-----------------------------------------------------------------------
; Configure a PLL
;-----------------------------------------------------------------------

Configure_PLL:

  local &pll_name_choice

  ; Prompt user to choose PLL if choice not passed in via commandline
  if ("&pll_name_choice"=="")
  (
    print "Available PLLs are: "

  print "  GPLL0                GPLL1                       GPLL2                       BIMC_PLL                    "
  
  print "  APCS_CPU_PLL          MPLL1                    "

    print ""
    print "Enter PLL: "
    enter &pll_name_choice
  )

  if ("&pll_name_choice"=="GPLL0")
  (
    &mode_reg=&HWIO_GCC_GPLL0_MODE_ADDR
    &user_reg=&HWIO_GCC_GPLL0_USER_CTL_ADDR

    &l_reg=&HWIO_GCC_GPLL0_L_VAL_ADDR
    &l_val=0x001F

    &prediv=0x0001
    &postdiv=0x0001

    &alpha_reg=0
    &alpha_val=0x0

    &alpha_u_reg=0
    &alpha_u_val=0x0

    &m_reg=0
    &m_val=0x0

    &n_reg=0
    &n_val=0x0

    &is_votable=0x1
    &pll_type="stromer_pll"

  &alpha_reg=&HWIO_GCC_GPLL0_ALPHA_VAL_ADDR
    &alpha_val=0x00000000
  &alpha_u_reg=&HWIO_GCC_GPLL0_ALPHA_VAL_U_ADDR
    &alpha_u_val=0x40
    gosub Generic_PLL_Configure &mode_reg &user_reg &prediv &postdiv &l_reg &l_val &alpha_reg &alpha_val &alpha_u_reg &alpha_u_val &m_reg &m_val &n_reg &n_val &is_votable &pll_type

    print "Configured GPLL0 "
    print ""

    return
  )

  if ("&pll_name_choice"=="GPLL1")
  (
    &mode_reg=&HWIO_GCC_GPLL1_MODE_ADDR
    &user_reg=&HWIO_GCC_GPLL1_USER_CTL_ADDR

    &l_reg=&HWIO_GCC_GPLL1_L_VAL_ADDR
    &l_val=0x0020

    &prediv=0x0001
    &postdiv=0x0001

    &alpha_reg=0
    &alpha_val=0x0

    &alpha_u_reg=0
    &alpha_u_val=0x0

    &m_reg=0
    &m_val=0x0

    &n_reg=0
    &n_val=0x0

    &is_votable=0x1
    &pll_type="sr_pll"

  &m_reg=&HWIO_GCC_GPLL1_M_VAL_ADDR
    &alpha_val=0x00000000
  &n_reg=&HWIO_GCC_GPLL1_N_VAL_ADDR
    &alpha_u_val=0x00
    gosub Generic_PLL_Configure &mode_reg &user_reg &prediv &postdiv &l_reg &l_val &alpha_reg &alpha_val &alpha_u_reg &alpha_u_val &m_reg &m_val &n_reg &n_val &is_votable &pll_type

    print "Configured GPLL1 "
    print ""

    return
  )

  if ("&pll_name_choice"=="GPLL2")
  (
    &mode_reg=&HWIO_GCC_GPLL2_MODE_ADDR
    &user_reg=&HWIO_GCC_GPLL2_USER_CTL_ADDR

    &l_reg=&HWIO_GCC_GPLL2_L_VAL_ADDR
    &l_val=0x002A

    &prediv=0x0001
    &postdiv=0x0001

    &alpha_reg=0
    &alpha_val=0x0

    &alpha_u_reg=0
    &alpha_u_val=0x0

    &m_reg=0
    &m_val=0x0

    &n_reg=0
    &n_val=0x0

    &is_votable=0x1
    &pll_type="stromer_pll"

  &alpha_reg=&HWIO_GCC_GPLL2_ALPHA_VAL_ADDR
    &alpha_val=0xAAAAAAAA
  &alpha_u_reg=&HWIO_GCC_GPLL2_ALPHA_VAL_U_ADDR
    &alpha_u_val=0x1A
    gosub Generic_PLL_Configure &mode_reg &user_reg &prediv &postdiv &l_reg &l_val &alpha_reg &alpha_val &alpha_u_reg &alpha_u_val &m_reg &m_val &n_reg &n_val &is_votable &pll_type

    print "Configured GPLL2 "
    print ""

    return
  )

  if ("&pll_name_choice"=="BIMC_PLL")
  (
    &mode_reg=&HWIO_GCC_BIMC_PLL_MODE_ADDR
    &user_reg=&HWIO_GCC_BIMC_PLL_USER_CTL_ADDR

    &l_reg=&HWIO_GCC_BIMC_PLL_L_VAL_ADDR
    &l_val=0x0036

    &prediv=0x0001
    &postdiv=0x0001

    &alpha_reg=0
    &alpha_val=0x0

    &alpha_u_reg=0
    &alpha_u_val=0x0

    &m_reg=0
    &m_val=0x0

    &n_reg=0
    &n_val=0x0

    &is_votable=0x1
    &pll_type="stromer_pll"

  &alpha_reg=&HWIO_GCC_BIMC_PLL_ALPHA_VAL_ADDR
    &alpha_val=0x00000000
  &alpha_u_reg=&HWIO_GCC_BIMC_PLL_ALPHA_VAL_U_ADDR
    &alpha_u_val=0x00
    gosub Generic_PLL_Configure &mode_reg &user_reg &prediv &postdiv &l_reg &l_val &alpha_reg &alpha_val &alpha_u_reg &alpha_u_val &m_reg &m_val &n_reg &n_val &is_votable &pll_type

    print "Configured BIMC_PLL "
    print ""

    return
  )

  if ("&pll_name_choice"=="APCS_CPU_PLL")
  (
    &mode_reg=&HWIO_APCS_CPU_PLL_MODE_ADDR
    &user_reg=&HWIO_APCS_CPU_PLL_USER_CTL_ADDR

    &l_reg=&HWIO_APCS_CPU_PLL_L_VAL_ADDR
    &l_val=0x0020

    &prediv=0x0001
    &postdiv=0x0001

    &alpha_reg=0
    &alpha_val=0x0

    &alpha_u_reg=0
    &alpha_u_val=0x0

    &m_reg=0
    &m_val=0x0

    &n_reg=0
    &n_val=0x0

    &is_votable=0x1
    &pll_type="stromer_pll"

  &alpha_reg=&HWIO_APCS_CPU_PLL_ALPHA_VAL_ADDR
    &alpha_val=0x00000000
  &alpha_u_reg=&HWIO_APCS_CPU_PLL_ALPHA_VAL_U_ADDR
    &alpha_u_val=0x00
    gosub Generic_PLL_Configure &mode_reg &user_reg &prediv &postdiv &l_reg &l_val &alpha_reg &alpha_val &alpha_u_reg &alpha_u_val &m_reg &m_val &n_reg &n_val &is_votable &pll_type

    print "Configured APCS_CPU_PLL "
    print ""

    return
  )
  
 
  if ("&pll_name_choice"=="GPLL1")
  (
    &mode_reg=&HWIO_MSS_MPLL1_MODE_ADDR
    &user_reg=&HWIO_MSS_MPLL1_USER_CTL_ADDR

    &l_reg=&HWIO_MSS_MPLL1_L_VAL_ADDR
    &l_val=0x0020

    &prediv=0x0001
    &postdiv=0x0001

    &alpha_reg=0
    &alpha_val=0x0

    &alpha_u_reg=0
    &alpha_u_val=0x0

    &m_reg=0
    &m_val=0x0

    &n_reg=0
    &n_val=0x0

    &is_votable=0x1
    &pll_type="sr_pll"

  &m_reg=&HWIO_MSS_MPLL1_M_VAL_ADDR
    &alpha_val=0x00000000
  &n_reg=&HWIO_MSS_MPLL1_N_VAL_ADDR
    &alpha_u_val=0x00
    gosub Generic_PLL_Configure &mode_reg &user_reg &prediv &postdiv &l_reg &l_val &alpha_reg &alpha_val &alpha_u_reg &alpha_u_val &m_reg &m_val &n_reg &n_val &is_votable &pll_type

    print "Configured MPLL1 "
    print ""

    return
  )
  
  ; PLL name did not match
  return


;-----------------------------------------------------------------------
; Enable or Disable a PLL - Wrapper
;-----------------------------------------------------------------------

Enable_Disable_PLL_Enter:

  &pll_name_choice=""
  gosub Enable_Disable_PLL

  return


;-----------------------------------------------------------------------
; Enable SR / SR2 / Stromer PLLs.
; Note: This function turns on the PLLs from OFF state.
;-----------------------------------------------------------------------
          
Generic_PLL_Enable:

  ENTRY &mode_reg &status_reg

  ; Return if PLL is already locked
  if (data.long(&access_mode:&status_reg)&0x10000)==0x10000
  (
    return
  )

  ; Put the PLL in reset
  &mode_val=data.long(&access_mode:&mode_reg)
  &mode_val=&mode_val&~(0x00000001|0x00000002|0x00000004)
  data.set &access_mode:&mode_reg %long &mode_val

  if ("&pll_type"=="sr_pll")
  (
    ; Deassert reset and bypass
    &mode_val=&mode_val|0x00000004|0x00000002
    data.set &access_mode:&mode_reg %long &mode_val
  )
  else if ("&pll_type"=="sr2_pll")||("&pll_type"=="stromer_pll")
  (
    ; Deassert bypass
    &mode_val=&mode_val|0x00000002
    data.set &access_mode:&mode_reg %long &mode_val

    ; Wait for PLL to initialize
    ; The actual PLL Init time is 5us, but T32 does not seem to allow this small value
    wait 1.ms
    
    ; Deassert reset
    &mode_val=&mode_val|0x00000004
    data.set &access_mode:&mode_reg %long &mode_val
  )
  
  ; Wait for PLL to warm up
  ; The actual PLL warm-up time is 50us, but T32 does not seem to allow this small value
  wait 1.ms
  
  ; Wait for PLL to lock
  while (data.long(&access_mode:&mode_reg)&0x80000000)==0x0
  (
  )
  
  ; Assert outctrl
  &mode_val=&mode_val|0x00000001
  data.set &access_mode:&mode_reg %long &mode_val

  return


;-----------------------------------------------------------------------
; Disable PLL
;-----------------------------------------------------------------------
                
Generic_PLL_Disable:

  ENTRY &mode_reg

  ; Put the PLL in reset
  &mode_val=data.long(&access_mode:&mode_reg)
  &mode_val=&mode_val&~(0x00000001|0x00000002|0x00000004)
  data.set &access_mode:&mode_reg %LONG &mode_val
  
  return


;-----------------------------------------------------------------------
; Enable or Disable a PLL
;-----------------------------------------------------------------------

Enable_Disable_PLL:

  local &pll_name_choice
  local &pll_on_off_choice

  print "Warning: PLL must already be configured, or the script will hang while waiting for the PLL to lock."
  print ""

  ; Prompt user to choose PLL if choice not passed in via commandline
  if ("&pll_name_choice"=="")
  (
    print "Available PLLs are: "

  print "  GPLL0                GPLL1                       GPLL2                       BIMC_PLL                    "
  
  print "  APCS_CPU_PLL         MPLL1                    "
  
    print ""
    print "Enter PLL: "
    enter &pll_name_choice
    
    print "Enter on/off: "
    enter &pll_on_off_choice
  )

  print "PLL: " "&pll_name_choice" "."

  
  ; Votable PLLs

  if ("&pll_name_choice"=="GPLL0")
  (
    &vote_reg=0
    &mode_reg=&HWIO_GCC_GPLL0_MODE_ADDR
    &mode_val=data.long(&access_mode:&mode_reg)
    &status_reg=&HWIO_GCC_GPLL0_STATUS_ADDR
    &pll_sel=0x1

    ; this votable PLL is in FSM mode
    if (&mode_val&0x100000)==0x100000
    (
      print "This source is votable. Which processor do you want to vote from? Choices are: "
      print "[  APCS  APCS_HYP  APCS_TZ  MSS  RPM  SPARE  ]"

      print ""
      print "Enter your choice: "
      enter &subsystem

      if ("&subsystem"=="APCS")
      (
        &vote_reg=&HWIO_GCC_APCS_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="APCS_HYP")
      (
        &vote_reg=&HWIO_GCC_APCS_HYP_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="APCS_TZ")
      (
        &vote_reg=&HWIO_GCC_APCS_TZ_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="MSS")
      (
        &vote_reg=&HWIO_GCC_MSS_Q6_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="RPM")
      (
        &vote_reg=&HWIO_GCC_RPM_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="SPARE")
      (
        &vote_reg=&HWIO_GCC_SPARE_GPLL_ENA_VOTE_ADDR
      )
      else
      (
        print "Invalid selection."
        print ""
        goto Enable_Disable_PLL
      )

      if ("&pll_on_off_choice"=="on")
      (
        data.set &access_mode:&vote_reg %long (data.long(&access_mode:&vote_reg)|(&pll_sel))
      )
      else
      (
        data.set &access_mode:&vote_reg %long (data.long(&access_mode:&vote_reg)&~(&pll_sel))
      )

    )
    ; this PLL supports HW voting, but is currently in legacy mode
    else
    (
      if ("&pll_on_off_choice"=="on")
      (
        gosub Generic_PLL_Enable &mode_reg &status_reg
      )
      else
      (
        gosub Generic_PLL_Disable &mode_reg
      )
    )

    print "Turned GPLL0 " "&pll_on_off_choice" "."
    print ""

    return
  )


  if ("&pll_name_choice"=="GPLL1")
  (
    &vote_reg=0
    &mode_reg=&HWIO_GCC_GPLL1_MODE_ADDR
    &mode_val=data.long(&access_mode:&mode_reg)
    &status_reg=&HWIO_GCC_GPLL1_STATUS_ADDR
    &pll_sel=0x2

    ; this votable PLL is in FSM mode
    if (&mode_val&0x100000)==0x100000
    (
      print "This source is votable. Which processor do you want to vote from? Choices are: "
      print "[  APCS  APCS_HYP  APCS_TZ  MSS  RPM  SPARE  ]"

      print ""
      print "Enter your choice: "
      enter &subsystem

      if ("&subsystem"=="APCS")
      (
        &vote_reg=&HWIO_GCC_APCS_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="APCS_HYP")
      (
        &vote_reg=&HWIO_GCC_APCS_HYP_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="APCS_TZ")
      (
        &vote_reg=&HWIO_GCC_APCS_TZ_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="MSS")
      (
        &vote_reg=&HWIO_GCC_MSS_Q6_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="RPM")
      (
        &vote_reg=&HWIO_GCC_RPM_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="SPARE")
      (
        &vote_reg=&HWIO_GCC_SPARE_GPLL_ENA_VOTE_ADDR
      )
      else
      (
        print "Invalid selection."
        print ""
        goto Enable_Disable_PLL
      )

      if ("&pll_on_off_choice"=="on")
      (
        data.set &access_mode:&vote_reg %long (data.long(&access_mode:&vote_reg)|(&pll_sel))
      )
      else
      (
        data.set &access_mode:&vote_reg %long (data.long(&access_mode:&vote_reg)&~(&pll_sel))
      )

    )
    ; this PLL supports HW voting, but is currently in legacy mode
    else
    (
      if ("&pll_on_off_choice"=="on")
      (
        gosub Generic_PLL_Enable &mode_reg &status_reg
      )
      else
      (
        gosub Generic_PLL_Disable &mode_reg
      )
    )

    print "Turned GPLL1 " "&pll_on_off_choice" "."
    print ""

    return
  )

  if ("&pll_name_choice"=="GPLL2")
  (
    &vote_reg=0
    &mode_reg=&HWIO_GCC_GPLL2_MODE_ADDR
    &mode_val=data.long(&access_mode:&mode_reg)
    &status_reg=&HWIO_GCC_GPLL2_STATUS_ADDR
    &pll_sel=0x4

    ; this votable PLL is in FSM mode
    if (&mode_val&0x100000)==0x100000
    (
      print "This source is votable. Which processor do you want to vote from? Choices are: "
      print "[  APCS  APCS_HYP  APCS_TZ  MSS  RPM  SPARE  ]"

      print ""
      print "Enter your choice: "
      enter &subsystem

      if ("&subsystem"=="APCS")
      (
        &vote_reg=&HWIO_GCC_APCS_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="APCS_HYP")
      (
        &vote_reg=&HWIO_GCC_APCS_HYP_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="APCS_TZ")
      (
        &vote_reg=&HWIO_GCC_APCS_TZ_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="MSS")
      (
        &vote_reg=&HWIO_GCC_MSS_Q6_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="RPM")
      (
        &vote_reg=&HWIO_GCC_RPM_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="SPARE")
      (
        &vote_reg=&HWIO_GCC_SPARE_GPLL_ENA_VOTE_ADDR
      )
      else
      (
        print "Invalid selection."
        print ""
        goto Enable_Disable_PLL
      )

      if ("&pll_on_off_choice"=="on")
      (
        data.set &access_mode:&vote_reg %long (data.long(&access_mode:&vote_reg)|(&pll_sel))
      )
      else
      (
        data.set &access_mode:&vote_reg %long (data.long(&access_mode:&vote_reg)&~(&pll_sel))
      )

    )
    ; this PLL supports HW voting, but is currently in legacy mode
    else
    (
      if ("&pll_on_off_choice"=="on")
      (
        gosub Generic_PLL_Enable &mode_reg &status_reg
      )
      else
      (
        gosub Generic_PLL_Disable &mode_reg
      )
    )

    print "Turned GPLL2 " "&pll_on_off_choice" "."
    print ""

    return
  )

 if ("&pll_name_choice"=="BIMC_PLL")
  (
    &vote_reg=0
    &mode_reg=&HWIO_GCC_BIMC_PLL_MODE_ADDR
    &mode_val=data.long(&access_mode:&mode_reg)
    &status_reg=&HWIO_GCC_BIMC_PLL_STATUS_ADDR
    &pll_sel=0x2

    ; this votable PLL is in FSM mode
    if (&mode_val&0x100000)==0x100000
    (
      print "This source is votable. Which processor do you want to vote from? Choices are: "
      print "[  APCS  APCS_HYP  APCS_TZ  MSS  RPM  SPARE  ]"

      print ""
      print "Enter your choice: "
      enter &subsystem

      if ("&subsystem"=="APCS")
      (
        &vote_reg=&HWIO_GCC_APCS_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="APCS_HYP")
      (
        &vote_reg=&HWIO_GCC_APCS_HYP_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="APCS_TZ")
      (
        &vote_reg=&HWIO_GCC_APCS_TZ_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="MSS")
      (
        &vote_reg=&HWIO_GCC_MSS_Q6_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="RPM")
      (
        &vote_reg=&HWIO_GCC_RPM_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="SPARE")
      (
        &vote_reg=&HWIO_GCC_SPARE_GPLL_ENA_VOTE_ADDR
      )
      else
      (
        print "Invalid selection."
        print ""
        goto Enable_Disable_PLL
      )

      if ("&pll_on_off_choice"=="on")
      (
        data.set &access_mode:&vote_reg %long (data.long(&access_mode:&vote_reg)|(&pll_sel))
      )
      else
      (
        data.set &access_mode:&vote_reg %long (data.long(&access_mode:&vote_reg)&~(&pll_sel))
      )

    )
    ; this PLL supports HW voting, but is currently in legacy mode
    else
    (
      if ("&pll_on_off_choice"=="on")
      (
        gosub Generic_PLL_Enable &mode_reg &status_reg
      )
      else
      (
        gosub Generic_PLL_Disable &mode_reg
      )
    )

    print "Turned BIMC_PLL " "&pll_on_off_choice" "."
    print ""

    return
  )
  
  if ("&pll_name_choice"=="APCS_CPU_PLL")
  (
    &vote_reg=0
    &mode_reg=&HWIO_APCS_CPU_PLL_MODE_ADDR
    &mode_val=data.long(&access_mode:&mode_reg)
    &status_reg=&HWIO_APCS_CPU_PLL_STATUS_ADDR
    &pll_sel=0x2

    ; this votable PLL is in FSM mode
    if (&mode_val&0x100000)==0x100000
    (
      print "This source is votable. Which processor do you want to vote from? Choices are: "
      print "[  APCS  APCS_HYP  APCS_TZ  MSS  RPM  SPARE  ]"

      print ""
      print "Enter your choice: "
      enter &subsystem

      if ("&subsystem"=="APCS")
      (
        &vote_reg=&HWIO_GCC_APCS_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="APCS_HYP")
      (
        &vote_reg=&HWIO_GCC_APCS_HYP_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="APCS_TZ")
      (
        &vote_reg=&HWIO_GCC_APCS_TZ_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="MSS")
      (
        &vote_reg=&HWIO_GCC_MSS_Q6_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="RPM")
      (
        &vote_reg=&HWIO_GCC_RPM_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="SPARE")
      (
        &vote_reg=&HWIO_GCC_SPARE_GPLL_ENA_VOTE_ADDR
      )
      else
      (
        print "Invalid selection."
        print ""
        goto Enable_Disable_PLL
      )

      if ("&pll_on_off_choice"=="on")
      (
        data.set &access_mode:&vote_reg %long (data.long(&access_mode:&vote_reg)|(&pll_sel))
      )
      else
      (
        data.set &access_mode:&vote_reg %long (data.long(&access_mode:&vote_reg)&~(&pll_sel))
      )

    )
    ; this PLL supports HW voting, but is currently in legacy mode
    else
    (
      if ("&pll_on_off_choice"=="on")
      (
        gosub Generic_PLL_Enable &mode_reg &status_reg
      )
      else
      (
        gosub Generic_PLL_Disable &mode_reg
      )
    )

    print "Turned APCS_CPU_PLL " "&pll_on_off_choice" "."
    print ""

    return
  )
  
  if ("&pll_name_choice"=="MPLL1")
  (
    &vote_reg=0
    &mode_reg=&HWIO_MSS_MPLL1_MODE_ADDR
    &mode_val=data.long(&access_mode:&mode_reg)
    &status_reg=&HWIO_MSS_MPLL1_STATUS_ADDR
    &pll_sel=0x2

    ; this votable PLL is in FSM mode
    if (&mode_val&0x100000)==0x100000
    (
      print "This source is votable. Which processor do you want to vote from? Choices are: "
      print "[  APCS  APCS_HYP  APCS_TZ  MSS  RPM  SPARE  ]"

      print ""
      print "Enter your choice: "
      enter &subsystem

      if ("&subsystem"=="APCS")
      (
        &vote_reg=&HWIO_GCC_APCS_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="APCS_HYP")
      (
        &vote_reg=&HWIO_GCC_APCS_HYP_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="APCS_TZ")
      (
        &vote_reg=&HWIO_GCC_APCS_TZ_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="MSS")
      (
        &vote_reg=&HWIO_GCC_MSS_Q6_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="RPM")
      (
        &vote_reg=&HWIO_GCC_RPM_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="SPARE")
      (
        &vote_reg=&HWIO_GCC_SPARE_GPLL_ENA_VOTE_ADDR
      )
      else
      (
        print "Invalid selection."
        print ""
        goto Enable_Disable_PLL
      )

      if ("&pll_on_off_choice"=="on")
      (
        data.set &access_mode:&vote_reg %long (data.long(&access_mode:&vote_reg)|(&pll_sel))
      )
      else
      (
        data.set &access_mode:&vote_reg %long (data.long(&access_mode:&vote_reg)&~(&pll_sel))
      )

    )
    ; this PLL supports HW voting, but is currently in legacy mode
    else
    (
      if ("&pll_on_off_choice"=="on")
      (
        gosub Generic_PLL_Enable &mode_reg &status_reg
      )
      else
      (
        gosub Generic_PLL_Disable &mode_reg
      )
    )

    print "Turned MPLL1 " "&pll_on_off_choice" "."
    print ""

    return
  )
  
  ; PLL name did not match
  return


;-----------------------------------------------------------------------
; Route PLL to PLLTEST_PAD 
;-----------------------------------------------------------------------

Route_PLL_To_Pad:

  local &pll_name_choice
  local &plltest_pad_field_val
  local &user_ctl_reg
  local &test_ctl_u_reg
  local &user_ctl_val
  local &test_ctl_u_val

  ; Prompt user to choose PLL if choice not passed in via commandline
  if ("&pll_name_choice"=="")
  (
    print "Available PLLs are: "

  print "  GPLL0                GPLL1                       GPLL2                       BIMC_PLL                    "
  
  print "  APCS_CPU_PLL          MPLL1                    "

    print ""
    print "Enter PLL: "
    enter &pll_name_choice
  )

  &plltest_pad_field_val=0x0
  &user_ctl_reg=0x0
  &test_ctl_u_reg=0x0

  if ("&pll_name_choice"=="GPLL0")
  (
    &plltest_pad_field_val=0x1
    &user_ctl_reg=&HWIO_GCC_GPLL0_USER_CTL_ADDR

  &test_ctl_u_reg=&HWIO_GCC_GPLL0_TEST_CTL_U_ADDR
    ; Enable test output in the PLL's user control register
    &user_ctl_val=data.long(&access_mode:&user_ctl_reg)
    &user_ctl_val=&user_ctl_val|0x10
    data.set &access_mode:&user_ctl_reg %long &user_ctl_val

    ; Enable test output in the PLL's test control upper register if available
    if (&test_ctl_u_reg!=0x0)
    (
      &test_ctl_u_val=data.long(&access_mode:&test_ctl_u_reg)
      &test_ctl_u_val=&test_ctl_u_val|0x6
      data.set &access_mode:&test_ctl_u_reg %long &test_ctl_u_val
    )

  )

  if ("&pll_name_choice"=="GPLL1")
  (
    &plltest_pad_field_val=0x2
    &user_ctl_reg=&HWIO_GCC_GPLL1_USER_CTL_ADDR

    ; Enable test output in the PLL's user control register
    &user_ctl_val=data.long(&access_mode:&user_ctl_reg)
    &user_ctl_val=&user_ctl_val|0x10
    data.set &access_mode:&user_ctl_reg %long &user_ctl_val

    ; Enable test output in the PLL's test control upper register if available
    if (&test_ctl_u_reg!=0x0)
    (
      &test_ctl_u_val=data.long(&access_mode:&test_ctl_u_reg)
      &test_ctl_u_val=&test_ctl_u_val|0x6
      data.set &access_mode:&test_ctl_u_reg %long &test_ctl_u_val
    )

  )

  if ("&pll_name_choice"=="BIMC_PLL")
  (
    &plltest_pad_field_val=0x4
    &user_ctl_reg=&HWIO_GCC_BIMC_PLL_USER_CTL_ADDR

  &test_ctl_u_reg=&HWIO_GCC_BIMC_PLL_TEST_CTL_U_ADDR
    ; Enable test output in the PLL's user control register
    &user_ctl_val=data.long(&access_mode:&user_ctl_reg)
    &user_ctl_val=&user_ctl_val|0x10
    data.set &access_mode:&user_ctl_reg %long &user_ctl_val

    ; Enable test output in the PLL's test control upper register if available
    if (&test_ctl_u_reg!=0x0)
    (
      &test_ctl_u_val=data.long(&access_mode:&test_ctl_u_reg)
      &test_ctl_u_val=&test_ctl_u_val|0x6
      data.set &access_mode:&test_ctl_u_reg %long &test_ctl_u_val
    )

  )

  if ("&pll_name_choice"=="GPLL2")
  (
    &plltest_pad_field_val=0x3
    &user_ctl_reg=&HWIO_GCC_GPLL2_USER_CTL_ADDR

  &test_ctl_u_reg=&HWIO_GCC_GPLL2_TEST_CTL_U_ADDR
    ; Enable test output in the PLL's user control register
    &user_ctl_val=data.long(&access_mode:&user_ctl_reg)
    &user_ctl_val=&user_ctl_val|0x10
    data.set &access_mode:&user_ctl_reg %long &user_ctl_val

    ; Enable test output in the PLL's test control upper register if available
    if (&test_ctl_u_reg!=0x0)
    (
      &test_ctl_u_val=data.long(&access_mode:&test_ctl_u_reg)
      &test_ctl_u_val=&test_ctl_u_val|0x6
      data.set &access_mode:&test_ctl_u_reg %long &test_ctl_u_val
    )

  )
  
  if ("&pll_name_choice"=="APCS_CPU_PLL")
  (
    &plltest_pad_field_val=0x2
    &user_ctl_reg=&HWIO_APCS_CPU_PLL_USER_CTL_ADDR

    ; Enable test output in the PLL's user control register
    &user_ctl_val=data.long(&access_mode:&user_ctl_reg)
    &user_ctl_val=&user_ctl_val|0x10
    data.set &access_mode:&user_ctl_reg %long &user_ctl_val

    ; Enable test output in the PLL's test control upper register if available
    if (&test_ctl_u_reg!=0x0)
    (
      &test_ctl_u_val=data.long(&access_mode:&test_ctl_u_reg)
      &test_ctl_u_val=&test_ctl_u_val|0x6
      data.set &access_mode:&test_ctl_u_reg %long &test_ctl_u_val
    )

  )
  
  
  if ("&pll_name_choice"=="MPLL1")
  (
    &plltest_pad_field_val=0x2
    &user_ctl_reg=&HWIO_MSS_MPLL1_USER_CTL_ADDR

    ; Enable test output in the PLL's user control register
    &user_ctl_val=data.long(&access_mode:&user_ctl_reg)
    &user_ctl_val=&user_ctl_val|0x10
    data.set &access_mode:&user_ctl_reg %long &user_ctl_val

    ; Enable test output in the PLL's test control upper register if available
    if (&test_ctl_u_reg!=0x0)
    (
      &test_ctl_u_val=data.long(&access_mode:&test_ctl_u_reg)
      &test_ctl_u_val=&test_ctl_u_val|0x6
      data.set &access_mode:&test_ctl_u_reg %long &test_ctl_u_val
    )

  )

  if (&user_ctl_reg!=0x0)&&(&plltest_pad_field_val!=0x0)
  (
    ; Get the PLLTEST_PAD register
    &plltest_pad_reg=0x187400c
    &plltest_pad_val=data.long(&access_mode:&plltest_pad_reg)

    ; Clear the source selection field
    &plltest_pad_val=&plltest_pad_val&~(0x1F<<0x0)

    ; Set CORE_OE
    &plltest_pad_val=&plltest_pad_val|0x1000

    ; Write to the testpad's source selection field
    &plltest_pad_val=&plltest_pad_val|((&plltest_pad_field_val&0x1F)<<0x0)
    data.set &access_mode:&plltest_pad_reg %long &plltest_pad_val
  )
  else
  (
    print "Invalid source."
  )

  return
