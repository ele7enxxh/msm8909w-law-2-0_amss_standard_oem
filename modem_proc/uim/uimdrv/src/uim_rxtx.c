/*============================================================================
  FILE:         uim_rxtx.c

  OVERVIEW:
   This module acts as an interface between UIM driver and UART. This Module
   processes the various interrupts generated by UART. It is the interface to
   read and write data from/to UART FIFO.

  EXTERNALIZED FUNCTIONS:
    uim_tx
    interface to write data bytes to TX FIFO.

  DEPENDENCIES: N/A

                Copyright (c) 2014 QUALCOMM Technologies, Inc(QTI).
                All Rights Reserved.
                QUALCOMM Technologies Confidential and Proprietary
============================================================================*/

/*============================================================================
  EDIT HISTORY FOR MODULE

  This section contains comments describing changes made to the module.
  Notice that changes are listed in reverse chronological order.  Please
  use ISO format for dates.

$Header: //commercial/MPSS.JO.2.0.c1.4/Main/modem_proc/uim/uimdrv/src/uim_rxtx.c#1 $
$DateTime: 2016/12/13 08:00:05 $
$Author: mplcsds1 $

when          who        what, where, why
--------      ----       ---------------------------------------------------------
11/23/15      ll         Remove the uart reset in hw wwt timeout handler
06/30/15      na         Releasing critical section when command pointer is NULL
06/29/15      na         Masking of UART interrupts if error is notified to its client
10/01/14      ll         KW errors
09/18/14      akv        UIMDRV UT enhancements
05/29/14      ks         Fixing issue with contention on AHB bus
05/23/14      ks         Enabling software command response timer
04/15/14      ks         Reverting the changes of CR556030 that introduced sw wwr
04/06/14      ks         Introducing software wwt running parallel to h/w wwt
03/03/14      ks         Triggering recovery upon recepiton of even
                         single RX break error
02/27/14      sam        1. Processing TX-comp after checking for RX-BRK
                         2. Correctly updating the global 'total_bytes_read'
                         3. modified the names of local variable
02/20/14      ak         Fix compile errors due to strict compiler on 9x35
01/25/14      sam        Initial Revision
============================================================================*/
#include "uimdrv_msg.h"
#include "uimglobals.h"
#include "uimdrv.h"
#include "uim_rxstates.h"
#include "uimdrv_uartdm.h"


/*===========================================================================
  I N T E R N A L  F U N C T I O N S  P R O T O T Y P E S
===========================================================================*/

static boolean uim_handle_wwt_int
(
  uim_instance_global_type *uim_ptr,
  dword *status_ptr,
  dword *interrupt_ptr,
  dword *no_of_bytes_received_ptr
);

static boolean uim_handle_rxbreak_int
(
  uim_instance_global_type *uim_ptr,
  dword *status_ptr,
  dword *interrupt_ptr,
  dword *no_of_bytes_received_ptr
);

static boolean uim_handle_rxstale_int
(
  uim_instance_global_type *uim_ptr,
  dword *status_ptr,
  dword *interrupt_ptr,
  dword *no_of_bytes_received_ptr
);

static boolean uim_handle_rxlev_int
(
  uim_instance_global_type *uim_ptr,
  dword *status_ptr,
  dword *interrupt_ptr,
  dword *no_of_bytes_received_ptr
);

static boolean uim_handle_txready_int
(
  uim_instance_global_type *uim_ptr,
  dword *status_ptr,
  dword *interrupt_ptr,
  dword *no_of_bytes_received_ptr
);

static boolean uim_handle_txlev_int
(
  uim_instance_global_type *uim_ptr,
  dword *status_ptr,
  dword *interrupt_ptr,
  dword *no_of_bytes_received_ptr
);

static boolean uim_handle_txcomp_int
(
  uim_instance_global_type *uim_ptr,
  dword *status_ptr,
  dword *interrupt_ptr,
  dword *no_of_bytes_received_ptr
);

typedef boolean (*uim_int_handler_type)
(
  uim_instance_global_type *uim_ptr,
  dword *status_ptr,
  dword *interrupt_ptr,
  dword *no_of_bytes_received_ptr
);

typedef struct
{
  dword interrupt;
  uim_int_handler_type handler;
}uim_int_map_type;

static uim_int_map_type uim_int_map[] =
{
  {MSMU_ISR_WWT, uim_handle_wwt_int},
  {MSMU_ISR_RXBREAK, uim_handle_rxbreak_int},
  {MSMU_ISR_TX_COMP, uim_handle_txcomp_int},
  {MSMU_ISR_RXSTALE, uim_handle_rxstale_int},
  {MSMU_ISR_RXLEV, uim_handle_rxlev_int},
  {MSMU_ISR_TX_READY, uim_handle_txready_int},
  {MSMU_ISR_TXLEV, uim_handle_txlev_int},
};

boolean uim_interrupt_handler
(
  uim_instance_global_type *uim_ptr,
  dword *status_ptr,
  dword *interrupt_ptr,
  dword *no_of_bytes_received_ptr
);

static boolean uim_process_sr
(
  uim_instance_global_type *uim_ptr,
  dword *status_ptr
);


boolean uim_process_uart_status
(
  uim_instance_global_type *uim_ptr,
  dword *status_ptr,
  dword *interrupt_ptr,
  dword *no_of_bytes_received_ptr
);

void uim_read_rx_fifo
(
  uim_instance_global_type *uim_ptr,
  dword isr,
  dword *no_of_bytes_received_ptr
);

void uim_uart_process_error
(
  uim_instance_global_type *uim_ptr
);

boolean uim_process_overrun_status
(
  uim_instance_global_type *uim_ptr
);

boolean uim_process_parity_status
(
  uim_instance_global_type *uim_ptr
);

extern void uim_tx
(
  unsigned char            *buffer_ptr,
  int                       size,
  uim_instance_global_type *uim_ptr
);


/**
 * This function is called when to write bytes into TX FIFO to be sent to card
 *
 *@param  buffer   Pointer to the buffer thath needs to be written to TX FIFO
 *@param  size     Size of the data to be written to TX FIFO
 *@param uim_ptr   Pointer to the UIM instance specific globals.
 */

void uim_tx
(
  unsigned char            *buffer_ptr,
  int                       size,
  uim_instance_global_type *uim_ptr
)
{

  int i =0;
  unsigned char mul =0, rem=0;
  unsigned int y = 0;

  if(size <= 0)
  {
    UIMDRV_MSG_ERR_0(uim_ptr->id,"Invalid size of data while writing to UART");
    return;
  }

  /* FEATURE_UIM_UART_DM_BUS_CONTENTION_FIX
     If UIM tries to write to NO_CHARS_FOR_TX register and
     immediately afterwards to the TX register, these 2 commands
     could be written to UART_DM as a burst on its AHB bus.
     causing the 2nd command’s data (first 4 bytes) to be left out of the FIFO.
     Hence UIM needs to read one byte before writing again causing the burst of
     writes to be broken into single writes */
  (void)UIM_GET_NUM_CHARS_TO_SEND_SLOT(uim_ptr);

  if(uim_nv_is_feature_enabled(UIMDRV_FEATURE_DEBUG_LOG,
                               uim_ptr) == TRUE)
  {
    for(i=0; i<size; i++)
    {
      uim_log_put_byte(UIM_LOG_TX_DATA, buffer_ptr[i], uim_ptr);
    }
    uim_log_put_last_byte(uim_ptr);
  }

  mul = size/4;
  rem = size%4;

  /* This adds 100usec delay ro be sure there is no contention on AHB bus */
  uim_clk_busy_wait(100);

  /* Send that many words */
  if(mul > 0)
  {
    for (i=0; i<mul; i++)
    {
      y = (buffer_ptr[i*4+3] << 24) | (buffer_ptr[i*4+2] << 16) | (buffer_ptr[i*4+1] << 8) | (buffer_ptr[i*4]);
      UIM_SEND_TX_FIFO_SLOT(uim_ptr,y);
    }
  }

  /* Send the remaining bytes packed as a word */
  if(rem > 0)
  {
    y = 0;
    for(i=0; i<rem; i++)
    {
      y += (buffer_ptr[4*mul+i] << (8*i));
    }
    UIM_SEND_TX_FIFO_SLOT(uim_ptr,y);
  }

  return;
} /*end uim_tx */

/**
 *This is the Rx ISR for the UART used to communicate with the UIM. This ISR
 *handles ALL (receive and transmit) operations of the UIM interface.  It
 *handles transmitting because the Rx and Tx lines are shared.  The receiver
 *is placed in sample mode while transmitting.  This allows the ISR to handle
 *the re-transmit scheme of the UIM.
 *
 *@param uim_ptr        Pointer to the UIM instance specific globals.
 */
void uim_rx_isr
(
  uim_instance_global_type *uim_ptr
)
{

  boolean process_rxstate = FALSE;
  dword status      = 0;  /* Holds the UART status */
  dword interrupt = 0; /* Holds the UART ISR status */
  dword no_of_bytes_received = 0;
  boolean rx_evt_cb_err;

  if(uim_ptr == NULL)
  {
    UIM_MSG_ERR_0("UIM_RX_ISR fired with invalid instance");
    return;
  }

  RETURN_IF_INSTANCE_INVALID(uim_ptr->id);

  /*entering critical section*/
  UIM_ENTER_CRIT_SECTION(&uim_ptr->crit_sect.clk_ctl, uim_ptr);

  /*if clock to UART is turned dont process the interrupt*/
  if ( !UIM_IS_UIM_CLK_ON(uim_ptr) )
  {
    UIM_TCXO_MUST_BE_ON_SLOT(uim_ptr);
    uim_uart_process_error(uim_ptr);
    UIMDRV_MSG_HIGH_0(uim_ptr->id,"UIM voted for clock-off and an interrupt is received");
    UIM_LEAVE_CRIT_SECTION(&uim_ptr->crit_sect.clk_ctl, uim_ptr);
    return;
  }
  if(NULL == uim_ptr->command.cmd_ptr)
  {

   /* Mask all interrupts from UART. */
    UIM_PRG_IMR_SLOT(uim_ptr, MSMU_IMR_MASK_ALL );
   /* Reset the UART receiver and disable */
    UIM_RESET_RX_SLOT (uim_ptr);
    UIM_MSG_ERR_0("UIM_RX_ISR cmd_ptr is null, masking interrupts");
    UIM_LEAVE_CRIT_SECTION(&uim_ptr->crit_sect.clk_ctl, uim_ptr);
    return;
  }
  process_rxstate = uim_interrupt_handler(uim_ptr, &status, &interrupt, &no_of_bytes_received);

  if (process_rxstate == TRUE)
  {
    rx_evt_cb_err = uimdrv_rx_event_cb(uim_ptr, interrupt, status, uim_ptr->card_cmd.uart_rx_buf, no_of_bytes_received);
    memset(uim_ptr->card_cmd.uart_rx_buf, 0x00, sizeof(uim_ptr->card_cmd.uart_rx_buf));
    if (rx_evt_cb_err)
    {
      UIMDRV_MSG_ERR_0(uim_ptr->id,"RX_state_machine returned error");
    }
  }

  UIM_LEAVE_CRIT_SECTION(&uim_ptr->crit_sect.clk_ctl, uim_ptr);
  return;
} /* end uim_rx_isr */


/**
 * This function is called by the interrupt handler to read Data from RXFIFO
 *
 * @param uim_ptr                      Pointer to the UIM instance specific globals.
 * @param isr                          Interrupt recieved.
 * @param no_of_bytes_received         Pointer to the size of bytes read from uart.
 */
void uim_read_rx_fifo
(
  uim_instance_global_type *uim_ptr,
  dword  isr,
  dword *no_of_bytes_received_ptr
 )
{
  int length;
  dword uart_status;
  int i=0;

  if(isr == MSMU_ISR_RXSTALE)
  {
    *no_of_bytes_received_ptr = UIM_GET_NUM_BYTES_IN_RX_SLOT(uim_ptr) - uim_ptr->card_cmd.total_bytes_read;
  }
  if (isr == MSMU_ISR_RXLEV)
  {
    *no_of_bytes_received_ptr = (4 * MSMU_DEF_RFWR_VAL);
  }
  if (*no_of_bytes_received_ptr % 4)
  {
    length = (*no_of_bytes_received_ptr/4) + 1;
  }
  else
  {
    length = *no_of_bytes_received_ptr/4;
  }

  for(uart_status = UIM_READ_STATUS_SLOT(uim_ptr); ((uart_status & MSMU_SR_RXRDY) && (length > 0)) ; length--)
  {
    uim_ptr->card_cmd.uart_rx_buf[i++] = UIM_GET_RX_WORD_SLOT(uim_ptr);
  }
  uim_ptr->card_cmd.total_bytes_read += *no_of_bytes_received_ptr;
  return;
} /* end uim_read_rx_fifo */


/**
 * This function is called to reset the UART and mask all interrupts in case of any error.
 *
 * @param uim_ptr       Pointer to the UIM instance specific globals.
 */
void uim_uart_process_error
(
  uim_instance_global_type *uim_ptr
)
{
  uim_reset_receiver (uim_ptr);
  uim_reset_uart_slot(uim_ptr);
  UIM_PRG_IMR_SLOT(uim_ptr, MSMU_IMR_MASK_ALL );
  uim_clear_cmd_rsp_timer(uim_ptr);
  uim_ptr->card_cmd.overrun_error_count = 0;
  uim_ptr->card_cmd.parity_error_count = 0;
  uim_ptr->rxtx_state_machine.rx_state = UIM_RX_PROCESS_IDLE;
  uim_ptr->rxtx_state_machine.rx_sub_state = UIM_RX_PROCESS_IDLE;
  memset(uim_ptr->card_cmd.uart_rx_buf, 0x00, sizeof(uim_ptr->card_cmd.uart_rx_buf));
} /* end uim_uart_process_error */

/**
 * This function is called by the UART RXTX module when it would
 * like to notify UIMDRV of any event that it has just
 * processed.
 *
 * @param uim_ptr              Pointer to the UIM instance specific globals.
 * @param status               Pointer to status, to be update based on the status register.
 * @return rx_state_process    Indication if it is required to read from RX-FIFO.
 */
static boolean uim_process_sr
(
  uim_instance_global_type *uim_ptr,
  dword *status_ptr
)
{
  dword uart_status = UIM_READ_STATUS_SLOT(uim_ptr);
  if (uart_status & (MSMU_SR_OVR_ERR))
  {
    *status_ptr = MSMU_SR_OVR_ERR;
    return uim_process_overrun_status(uim_ptr);
  }
  else if (uart_status & MSMU_SR_PF_ERR)
  {
    *status_ptr = MSMU_SR_PF_ERR;
    return uim_process_parity_status(uim_ptr);
  }
  else
  {
    if (!uim_ptr->flag.max_overrun_error &&
        !uim_ptr->flag.max_rx_break_error &&
        !uim_ptr->flag.max_parity_error)
    {
      /* Clear the timer signal in case it has already been set */
      (void) rex_clr_sigs( uim_ptr->tcb_ptr, UIM_CMD_RSP_TIMEOUT_SIG );
    }
    /* Reset the error counts */
    uim_ptr->card_cmd.parity_error_count = 0;
    uim_ptr->card_cmd.overrun_error_count = 0;

    if (uim_ptr->rxtx_state_machine.rx_state != UIM_RX_PROCESS_IDLE)
    {
      /* On receiving a valid byte, while not in idle state, reset the
       * idle state error counters
       */
      uim_ptr->card_cmd.idle_parity_error_count = 0;
      uim_ptr->card_cmd.idle_rx_break_error_count= 0;
      uim_ptr->card_cmd.idle_overrun_error_count = 0;
    }
    return TRUE;
  }
} /*end uim_process_sr */

/**
 * This function is called to handle the WWT timeout interrupt
 *
 * @param uim_ptr             Pointer to the UIM instance specific globals.
 * @param *status             Pointer to variable storing UARTDM status.
 * @param *interrupt          Pointer to variable storing the interrupt received,
                              to be update to WWT interrupt.
 * @return rx_state_process   Indication if rx_state processing is required.
 */
static boolean uim_handle_wwt_int
(
  uim_instance_global_type *uim_ptr,
  dword *status_ptr,
  dword *interrupt_ptr,
  dword *no_of_bytes_received_ptr
)
{
  *interrupt_ptr = MSMU_ISR_WWT;
  /* Disable WWT counter */
  uim_uartdm_disable_wwt_counter(uim_ptr);
  /* clear WWT interrupt status */
  uim_uartdm_clear_wwt_int_status(uim_ptr);
  /* Clearing software work waiting timer as well */
  (void) rex_clr_timer( &uim_ptr->command.cmd_rsp_timer);
  /* Process command response timeout */
  uim_cmd_rsp_timer_expiry_cb((unsigned long)uim_ptr);
  return FALSE;
} /* end uim_handle_wwt_int */

/**
 * This function is called to handle the RX-Break interrupt
 *
 * @param uim_ptr             Pointer to the UIM instance specific globals.
 * @param *status             Pointer to variable storing UARTDM status.
 * @param *interrupt          Pointer to variable storing the interrupt received,
                              to be update to RX-break interrupt.
 * @return rx_state_process   Indication if rx_state processing is required.
 */
static boolean uim_handle_rxbreak_int
(
  uim_instance_global_type *uim_ptr,
  dword *status_ptr,
  dword *interrupt_ptr,
  dword *no_of_bytes_received_ptr
)
{
  *interrupt_ptr = MSMU_ISR_RXBREAK;
  *status_ptr = MSMU_SR_RXBREAK;
  /* Increment the total rx_break error counter */
  uim_ptr->debug.tot_rx_break_error_count++;

  if (uim_ptr->rxtx_state_machine.rx_state == UIM_RX_PROCESS_IDLE)
  {
    if (uim_ptr->setting.config_params.future_use[UIM_RFU_INDEX_BOOLEAN_FLAGS] &	UIM_RFU_MASK_DO_NOT_IGNORE_RX_BREAK_IN_IDLE)
    {
      uim_uart_process_error(uim_ptr);
      if(TRUE == uim_ptr->flag.command_in_progress)
      {
        uim_force_recovery(uim_ptr);
      }
    }
    else
    {
      uim_ptr->card_cmd.idle_rx_break_error_count++;
    }
    return FALSE;
  }

  uim_uart_process_error(uim_ptr);
  /* Let the task know there were too many rx break errors */
  uim_ptr->flag.max_rx_break_error = TRUE;
  (void) rex_set_sigs( uim_ptr->tcb_ptr, UIM_CMD_RSP_TIMEOUT_SIG);
  UIMDRV_MSG_ERR_0(uim_ptr->id,"Received Rx break error, setting timeout signal");

  return FALSE;
} /* end uim_handle_rxbreak_int */

/**
 * This function is called to handle the UART Overrun Status
 *
 * @param uim_ptr             Pointer to the UIM instance specific globals.
 * @return rx_state_process   Indication if it is required to read from RX-FIFO.
 */
boolean uim_process_overrun_status
(
  uim_instance_global_type *uim_ptr
)
{
  boolean ret_value=FALSE;
  /* increment the total overrun error count variable */
  uim_ptr->debug.tot_overrun_error_count++;

  /* Reset the error status.  At this point, we probably lost some
	 of the bytes that we are supposed to receive.	Let us
	 receive all the bytes that the card has to send and
	 re-try the command
  */
  UIM_RESET_ERR_SLOT(uim_ptr);
  if (uim_ptr->rxtx_state_machine.rx_state == UIM_RX_PROCESS_IDLE)
  {
    UIMDRV_MSG_ERR_0(uim_ptr->id,"Overrun error in IDLE");
    /* Increment the idle overrun error count */

    uim_ptr->card_cmd.idle_overrun_error_count++;
    return FALSE;
  }

  if (uim_ptr->card_cmd.overrun_error_count == UIM_MAX_OVERRUN_ERR_COUNT)
  {
    uim_uart_process_error(uim_ptr);
    uim_ptr->flag.max_overrun_error = TRUE;
    (void) rex_set_sigs( uim_ptr->tcb_ptr, UIM_CMD_RSP_TIMEOUT_SIG );
    ret_value=FALSE;
  }
  else
  {
    /* If in idle state, we want to ignore any overrun errors */
    ++uim_ptr->card_cmd.overrun_error_count;
    /* Set the state to Overrun state */

    /* Set the flag */
    uim_ptr->flag.overrun_error = TRUE;

    ret_value=FALSE;
  } /* max overrun error */
  return ret_value;
} /* end uim_process_overrun_status */

/**
 * This function is called to handle the Parity status
 *
 * @param uim_ptr             Pointer to the UIM instance specific globals.
 * @return rx_state_process   Indication if it is required to read from RX-FIFO.
 */
boolean uim_process_parity_status
(
  uim_instance_global_type *uim_ptr
)
{
  boolean ret_value=FALSE;
  /* Increment the total parity error counter */
  uim_ptr->debug.tot_parity_error_count++;
  if (uim_ptr->rxtx_state_machine.rx_state == UIM_RX_PROCESS_IDLE)
  {
    UIMDRV_MSG_ERR_0(uim_ptr->id,"parity error in IDLE");
    uim_uart_process_error(uim_ptr);
    if(TRUE == uim_ptr->flag.command_in_progress)
    {
      uim_force_recovery(uim_ptr);
    }
    return FALSE;
  }

  if ( ( uim_ptr->card_cmd.parity_error_count == UIM_MAX_PARITY_ERR_COUNT(uim_ptr) )
#ifdef FEATURE_UIM_T_1_SUPPORT
        && (UIM_T_0_PROTOCOL == uim_ptr->state.operating_protocol)
#endif /* FEATURE_UIM_T_1_SUPPORT */
      )
  {
    /* Let the task know there were too many parity errors */
    uim_ptr->flag.max_parity_error = TRUE;

    uim_uart_process_error(uim_ptr);

    (void) rex_set_sigs( uim_ptr->tcb_ptr, UIM_CMD_RSP_TIMEOUT_SIG );

    /* Reset the UART receiver (switches to idle state) */
    UIMDRV_MSG_ERR_0(uim_ptr->id,"Maxed the parity error count");
    ret_value = FALSE;
  }
  else
  {
    ++uim_ptr->card_cmd.parity_error_count;
    ret_value = TRUE;
  } /* Not in idle state */
  return ret_value;
} /* uim_process_parity_status */

/**
 * This function is called to handle the RXSTALE interrupt
 *
 * @param uim_ptr             Pointer to the UIM instance specific globals.
 * @param *status             Pointer to variable storing UARTDM status.
 * @param *interrupt          Pointer to variable storing the interrupt received,
                              to be update to RXSTALE interrupt.
 * @return rx_state_process   Indicating if rx_state processing is required.
 */
static boolean uim_handle_rxstale_int
(
  uim_instance_global_type *uim_ptr,
  dword *status_ptr,
  dword *interrupt_ptr,
  dword *no_of_bytes_received_ptr
)
{
  *interrupt_ptr = MSMU_ISR_RXSTALE;
  *status_ptr = MSMU_SR_RXRDY;
  UIM_CLEAR_RX_STALE_INT_SLOT(uim_ptr);
  if(uim_process_sr(uim_ptr, status_ptr))
  {
    uim_read_rx_fifo(uim_ptr, MSMU_ISR_RXSTALE, no_of_bytes_received_ptr);
    return TRUE;
  }
  else
  {
    return FALSE;
  }
} /* end uim_handle_rxstale_int */

/**
 * This function is called to handle the RXLEV interrupt
 *
 * @param uim_ptr               Pointer to the UIM instance specific globals.
 * @param *status               Pointer to variable storing UARTDM status.
 * @param *interrupt            Pointer to variable storing the interrupt received,
                                to be update to RXLEV interrupt.
 * @return rx_state_process     Indicating if rx_state processing is required.
 */
static boolean uim_handle_rxlev_int
(
  uim_instance_global_type *uim_ptr,
  dword *status_ptr,
  dword *interrupt_ptr,
  dword *no_of_bytes_received_ptr
)
{
  *interrupt_ptr = MSMU_ISR_RXLEV;
  *status_ptr = MSMU_SR_RXRDY;

  if(uim_process_sr(uim_ptr, status_ptr))
  {
    uim_read_rx_fifo(uim_ptr, MSMU_ISR_RXLEV, no_of_bytes_received_ptr);
    return TRUE;
  }
  else
  {
    return FALSE;
  }
} /* end uim_handle_rxlev_int */

/**
 * This function is called to handle the TXRDY interrupt
 *
 * @param uim_ptr              Pointer to the UIM instance specific globals.
 * @param *status              Pointer to variable storing UARTDM status.
 * @param *interrupt           Pointer to variable storing the interrupt received,
                               to be update to TXRDY interrupt.
 * @return rx_state_process    Indication if rx_state processing is required.
 */
static boolean uim_handle_txready_int
(
  uim_instance_global_type *uim_ptr,
  dword *status_ptr,
  dword *interrupt_ptr,
  dword *no_of_bytes_received_ptr
)
{
  *interrupt_ptr = MSMU_ISR_TX_READY;
  *status_ptr = MSMU_SR_RXRDY;
  UIM_CLEAR_TX_READY_INT_SLOT(uim_ptr);
  if(uim_process_sr(uim_ptr, status_ptr))
  {
    return TRUE;
  }
  else
  {
    return FALSE;
  }
} /*end uim_handle_txready_int*/

/**
 * This function is called to handle the TXLEV interrupt
 *
 * @param uim_ptr              Pointer to the UIM instance specific globals.
 * @param *status              Pointer to variable storing UARTDM status.
 * @param *interrupt           Pointer to variable storing the interrupt received,
                               to be update to TXLEV interrupt.
 * @return rx_state_process    Indicating if rx_state processing is required.
 */
static boolean uim_handle_txlev_int
(
  uim_instance_global_type *uim_ptr,
  dword *status_ptr,
  dword *interrupt_ptr,
  dword *no_of_bytes_received_ptr
)
{
  *interrupt_ptr = MSMU_ISR_TXLEV;
  *status_ptr = MSMU_SR_RXRDY;

  if(uim_process_sr(uim_ptr, status_ptr))
  {
    return TRUE;
  }
  else
  {
    return FALSE;
  }
} /*end uim_handle_txlev_int*/

/**
 * This function is called to handle the TXCOM interrupt
 *
 * @param uim_ptr              Pointer to the UIM instance specific globals.
 * @param *status              Pointer to variable storing UARTDM status .
 * @param *interrupt           Pointer to variable storing the interrupt received,
                               to be update to TXCOM interrupt.
 * @return rx_state_process    Indicating if rx_state processing is required.
 */
static boolean uim_handle_txcomp_int
(
  uim_instance_global_type *uim_ptr,
  dword *status_ptr,
  dword *interrupt_ptr,
  dword *no_of_bytes_received_ptr
)
{
  *interrupt_ptr = MSMU_ISR_TX_COMP;
  *status_ptr = MSMU_SR_RXRDY;
  UIM_CLEAR_TX_COMP_INT_SLOT(uim_ptr);
  if(uim_process_sr(uim_ptr, status_ptr))
  {
    return TRUE;
  }
  else
  {
    return FALSE;
  }
}/*end uim_handle_txcomp_int*/

/**
 * This function is called to invoke the interrupt handler based on misr register
 *
 * @param uim_ptr              Pointer to the UIM instance specific globals.
 * @param *status              Pointer to variable storing UARTDM status.
 * @param *interrupt           Pointer to variable storing the interrupt received,
                               to be update based on the interrupt processed.
 * @return rx_state_process    Indicating if rx_state processing is required.
 */
boolean uim_interrupt_handler
(
  uim_instance_global_type *uim_ptr,
  dword *status_ptr,
  dword *interrupt_ptr,
  dword *no_of_bytes_received_ptr
)

{
  int i = 0;
  dword uart_misr_status = UIM_READ_MISR_SLOT(uim_ptr);
  boolean ret_value = FALSE;

  for (i=0;i<ARR_SIZE(uim_int_map);i++)
  {
    if (uart_misr_status & uim_int_map[i].interrupt)
    {
      ret_value= uim_int_map[i].handler(uim_ptr, status_ptr, interrupt_ptr, no_of_bytes_received_ptr);
      if (!(uim_int_map[i].interrupt == MSMU_ISR_WWT))
      {
	   uim_ptr->card_cmd.uart_dm_interrupt_wait_count = 0;
      }
      break;
    }
  }
  return ret_value;
}/*end uim_interrupt_handler*/


