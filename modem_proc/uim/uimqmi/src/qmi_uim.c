/*===========================================================================

                         Q M I _ U I M . C

DESCRIPTION

 The Data Services Qualcomm MSM Interface Device Management Services source
 file.

Copyright (c) 2010-2016 QUALCOMM Technologies, Inc(QTI).
All Rights Reserved.
QUALCOMM Technologies Confidential and Proprietary
===========================================================================*/
/*===========================================================================

                      EDIT HISTORY FOR FILE

  $Header: //commercial/MPSS.JO.2.0.c1.4/Main/modem_proc/uim/uimqmi/src/qmi_uim.c#1 $ $DateTime: 2016/12/13 08:00:05 $ $Author: mplcsds1 $

when        who    what, where, why
--------    ---    ----------------------------------------------------------
10/14/16    bcho   Added support for ICCID simlock
10/25/16    dd     Added support for auto reg SMS when ESN is changed
10/19/16    ar     Add support for configuring HTTP stack via LPA EFS item
09/12/16    ar     Initialize token_info
09/06/16    ar     Handle QMI UIM SEARCH RECORD pending request
08/31/16    ar     Addition of QMI_UIM_SEARCH_RECORD interface
08/31/16    ar     Optimize eUICC logic for non-spec compliant card
08/18/16    vdc    Added support for simlock single lock
08/04/16    ar     Query internally for profile info in case of add profile
07/14/16    ar     Check Blacklist based on AID source
07/11/16    ar     Add ISDR-AID in Whitelist/Blacklist as per new NV
06/28/16    vdc    Derive SPN feature while retrieving number of retries
06/17/16    vdc    Added support for SPN based SIMLOCK feature
05/26/16    sp     F3 logging improvements
05/16/16    ar     Fixing KW issue (FALSE POSITIVE)
05/06/16    sp     Remove Excessive F3's
05/05/16    vdc    Send control key presence in get config presence
04/29/16    gm     Error code for card not supporting select by partial AID
04/11/16    ar     Changes for LPA support
02/22/16    bcho   Graceful handling of NULL resp_ptr in simlock callback
02/02/16    vdc    Fix restrictions of AUTH command for different contexts
11/16/15    lm     Fix compilation error in personalization
11/16/15    vdc    Send app state as PERSO when device is set in emergency mode
11/16/15    ar     Use Silent PIN1 NV as enabled if it is not set in efs
09/25/15    vr     Added support for ERA-GLONASS
09/07/15    bcho   Migrate to mcfg EFS wrappers
08/27/15    vdc    Do not retry service registration if it fails once
08/20/15    at     Replacement of Secapis to use a derived key & HMAC
08/10/15    stv    To send temporary unlock status indication
07/01/15    bcho   Fix enabling a lock with more than 20 codes of lock data
07/08/15    bcho   Redundant checks for SIMLOCK
06/09/15    vdc    Fill IMPI file info while sending GBA IMPI read req
05/26/15    vr     Don't send perso ind if there is no perso state change
05/18/15    tkl    Moved request_id up to callback function
05/15/15    vv     Support for RSU
05/15/15    vdc    Send SAP disconnected ind if card is removed
05/14/15    ar     Support for terminate_app TLV in qmi_uim_close_session
05/11/15    vdc    Enhance parsing logic for black/white list for bootstrapping
05/08/15    vdc    Open ISIM session while bootstrapping if not opened
05/05/15    ar     Handle back-to-back power_up/down req gracefully
04/30/15    vdc    Added support for APN for bootstrapping
05/01/15    tkl    Restricted the use of Auth request for GBA security context
05/01/15    tl     Change IMPI domain from ics to ims for spec compliance
05/01/15    tl     Add support for GBA cancel
05/01/15    vdc    Allow bootstrapping with empty NAF id
05/01/15    vdc    Added support for QMI UIM GBA
04/17/15    at     Updating the QMI perso state correctly when blocked
03/25/15    stv    API to block card status events
03/19/15    at     Adding an optional TLV to reactivate the perso feature
03/11/15    vv     Added support for new perso status
03/04/15    vdc    Set SAP enabled flag to FALSE when SAP is disconnected
02/27/15    vdc    Send correct sap status while doing connect and disconnect
02/03/15    xj     Add USB UICC and SAP CLIENT supported interface
12/18/14    yt     Update RESET refresh handling for non-prov/card sessions
12/16/14    av     Apply auth restr via NV for IIC only if USIM is selected
11/26/14    av     Change default value of NV 70284 to allow GSM auth
11/14/14    tkl    Added check for UIMI_MAX_CLIDS
11/14/14    yt     Send refresh start indication for card slot sessions
11/14/14    hh     Fix compilation warnings
11/13/14    bcho   Send Refresh indication to all in Refresh Reset start stage
11/10/14    yt     Return status words of original PIN OP
11/07/14    lxu    Set default AUTH retrictions to RESTRICTIONS_II_CLA
11/03/14    lxu    Only reject ICC authenticate command with CLA 0xA0
10/29/14    tl     Add extra comparison in diag access check callback
10/29/14    ar     Deregister files with MMGSDI on QMI UIM client de-register
10/21/14    vv     Add support for late simlock config registration
10/16/14    vv     Fix sending extra resp for simlock configuration req
10/14/14    tl     Fix compiler error
10/10/14    tkl    Fix KW error
10/10/14    vv     Fix a merge error
10/10/14    vv     Add support for remote simlock configuration
10/08/14    vdc    Added support for UICC activation status indication
09/30/14    vv     Add support for emergency only command
09/30/14    kk     Enhancements to NV handling
09/29/14    vv     Added support for the remote SFS
09/29/14    av     Featurize all QMI messages
09/29/14    vdc    Send no effect resp when card is powered up for power up cmd
09/25/14    tl     Add support for secure read
09/19/14    kk     Move refresh event info to heap
09/17/14    tl     Add support for perso and deperso secure
09/17/14    vr     Correction in heap variable created in stack reduction
09/17/14    hh     Moved qmi_uim_global_ptr from heap to static global variable
09/11/14    hh     Call rex_undef_timer() when timer is no longer needed
09/09/14    vr     Reduce stack usage
09/03/14    tl     Update app state when perso lock event sent during sub ready
08/29/14    at     Sending response for QMI_UIM_SUPPLY_VOLTAGE
08/29/14    tl     Add support for supply voltage command and indication
08/12/14    yt     Return status words for QMI_UIM_SEND_STATUS
08/11/14    tkl    Added SSM support for restricted NV
08/07/14    hh     Ignore b7 in CLA byte for SEND_APDU_REQ
08/07/14    yt     Fix array bound checking
08/05/14    hh     Added support to retrieve supported proactive commands
07/25/14    vv     Added support for perso command
07/22/14    at     Fix error in ISIM Auth response for different contexts
07/22/14    tkl    Setup diag access check cb for QMI CAT NV
07/08/14    vv     Fix for compiler warnings
06/30/14    vv     Remove Perso code
06/26/14    vv     Fix compiler issue due to missing featurization
06/17/14    vv     Support for slot parameter in deperso command
06/12/14    av     Enhance GET_SERVICE_STATUS to accomodate all service numbers
05/22/14    tl     Added support for recovery complete indications
05/13/14    vv     Fix compiler errors
05/13/14    vdc    Support for reduced card status indications
05/12/14    df     Add QMI support for STATUS cmd
04/22/14    at     Critical KW fixes
04/15/14    vv     Fix crash in unlock msg response processing
03/27/14    tkl    Added checks for client validity
03/27/14    at     Fix for sending refresh reset to non-prov session clients
03/27/14    at     Usage of common QMI APIs from DS header
03/26/14    tl     SIM Lock secondary revisions
03/18/14    tl     Introduce new SIM Lock feature
03/14/14    lj     Support for the updated AUTH restrictions EFS item
03/12/14    yt     Check for NULL response pointer
03/12/14    gm     Moved qmi_uim_state to heap
03/06/14    yt     Allow close session response for invalid session id
03/06/14    gm     Moved to new API for client alloc/dealloc result
02/25/14    yt     Support for QMI_UIM_RESELCT_REQ
02/24/14    at     Support for read transparent long indication
02/24/14    av     Do not rely on UIMI_CMD_MAX when traversing through cmd cb
02/20/14    at     Fix to clean up non-prov session id used for refresh
01/28/14    df     Use q_cnt() instead directly accessing cnt
01/22/13    vs     Fix delayed access for non-prov sessions
01/15/14    ar     Changed MSG_ERROR to UIM_MSG_ERR
01/15/14    ar     Added handler for MMGSDI_SESSION_LEGAL_SUBSCRIPTION_EVT
01/10/14    df     Use v2.0 diag macros
12/24/13    am     Add NV protection to Recovery API
12/21/13    am     Introduce recovery API
12/16/13    yt     Support for ISIM AUTH in HTTP digest security context
12/13/13    tkl    Clean up non-prov session regardless of APDU restrictions
12/09/13    spo    Fix for handling auth request for USIM and ISIM
12/04/13    at     Handling MMGSDI card error code NO_PROTOCOL_AT_CARD_PUP
11/26/13    vdc    Remove triple SIM feature while powering up the card
11/25/13    tkl    Added API for Increase
11/22/13    tl     Update perso retries in app state ready
11/14/13    df     Correct buffer size calculation
11/08/13    tkl    Check for client validity in non-prov session close
11/12/13    vdc    Handle errors in QMI UIM initialization gracefully
10/27/13    df     Add handling for card error type MMGSDI_CARD_ERR_SAP_CONNECTED
10/21/13    yt     Add error checking for command APDUs
10/18/13    vv     Send session closed ind. for the prov. session on the slot
10/09/13    at     Support for the updated APDU restrictions EFS item
10/04/13    vv     Added API to return se13 table release date and source
09/23/13    df     Support for SIM busy
09/16/13    yt     Remove redundant code
09/09/13    yt     Add check for MMGSDI_NON_PROV_SESSION_SLOT_3
09/04/13    at     Keep APDU channel info when open channel response is pending
09/02/13    df     Ensure channel is shared for empty AIDs
08/26/13    at     Check for client validity in session open/close callbacks
08/08/13    ks     Support for subscription manager
07/31/13    yt     QMI_UIM_GET_LABEL should return error for zero-length AID
07/26/13    tkl    Add NV support for enabling use of SMS-PP envelope command
07/25/13    yt     Respond to REFRESH events for APDU sessions
07/24/13    at     Adding pending request for non-prov sessions in linked list
07/15/13    yt     Postpone sending card indications until slot session is ready
07/15/13    av     Introduction of new NULL_BYTES card error type
07/10/13    vdc    Added support for missing instances of triple sim
07/02/13    yt     Dynamically allocate slot and app data
06/24/13    kb     Added QMI malloc and free wrapper functions
06/21/13    kk     Updated support for triple sim
06/20/13    yt     Extract slot id from session changed event payload
06/18/13    vv     Request PIN status only if app is present in global app list
06/13/13    yt     Fix compiler warning
05/21/13    vv     Extend session closed indication for all sessions
05/21/13    tkl    Fix KW errors
05/18/13    spo    Replaced instances of memcpy with memscpy
05/15/13    bcho   Handle Refresh 3G Session Reset as NAA APP Reset with FCN
04/30/13    vv     Reset upin state and retries count upon card error
04/30/13    tl     Return card result to client for pin operations
04/29/13    av     Fix null pointer usage in execute_open_session_for_apdu
04/08/13    at     Added 2 more EFS files into the Diag-restricted list
03/14/13    tl     Allow authentication with non-prov app if SIM locked
02/27/13    yt     Support for MMGSDI_NOT_SUPPORTED return type
02/22/13    yt     Support for slot 3
02/20/13    at     Protect security-related EFS files from Diag access
02/19/13    av     Merge mmgsi,gstk,qmiuim/cat conf files to mmgsdi.conf
02/14/13    tl     Move QMI UIM to MMGSDI context from QMI modem context
02/12/13    at     Added support for file status TLV
02/07/13    yt     Support for activation/deactivation of EFs
02/04/13    at     Fetch NV 4398 from MMGSDI cache
02/04/13    at     Updating Sec APIs to include SSID & CID
01/23/13    at     Reverting the MMGSDI NV cache read operation
01/03/12    abg    Removed blocking NV read operation
12/27/12    av     Block RUN GSM ALGO via send APDU and via uim_qmi_authenticate
12/13/12    at     Correcting 2 TLV types for read transparent indication
12/12/12    av     Fixed compiler critical warnings
12/11/12    vv     Fixed critical KW warnings
12/06/12    yt     Block AUTH request if app state is illegal or perso
11/09/12    yt     Move QMI UIM to UIM heap
11/02/12    yt     Add support for ACL in SET and GET SERVICE STATUS commands
10/21/12    av     Update conf file only if necessary
10/17/12    shr    Added support to drop MMGSDI responses and pending commands
                   when client corresponding to the request is no longer valid
10/16/12    at     Send error reponse for multiple read records if applicable
10/04/12    at     Switch QMI_UIM to use mmgsdi_session_open_ext
10/01/12    yt     Remove limitation on the num of client-registered refresh files
09/18/12    at     Updated error code for deactivating a prov session if
                   already deactivated
09/07/12    at     Removal of private DS functions and headers
09/07/12    tl     Added support for SGLTE dual slots
09/05/12    at     Updated error code for close channel when not open
08/31/12    vv     Send channel close indication based on NV config
08/29/12    at     Optional TLV in SAP connection req to check for active calls
08/29/12    spo    Allow close of session only if AID length is greater than 1
08/28/12    spo    Added support for Session Closed Indication
08/17/12    spo    Fixed length of IMSI before decrypt
08/16/12    at     New command handling for QMI_UIM_REFRESH_REGISTER_ALL
08/16/12    tl     Add session close without app termination functionality
07/30/12    yt     Return appropriate error type for open session failure
07/20/12    at     Check for sub_ok TLV value in QMI_UIM_SUBSCRIPTION_OK
07/13/12    at     Dynamic allocation of APDU channel info in global
06/19/12    at     Fix to clean the client queues before cl_id is deallocated
06/05/12    vv     Set appropriate error when a PIN1 operation is unsupported
06/04/12    at     Fix reachable assert in qmi_uim_refresh_create_deregister_list
05/23/12    hn     Enable 1-byte alignment packing on Windows environment
05/18/12    at     Send refresh indication end stage for App Reset
05/18/12    vv     Fixed incrementing the application index
05/17/12    vv     Update PIN retries and state after a PIN operation
05/14/12    at     Add new TLV to QMI_UIM_GET_CARD_STATUS command
05/10/12    nmb    Correct dangling pointer when deallocating clients
04/17/12    at     Support for opening a non prov session with empty AID
04/16/12    at     Decode extended logical channels correctly for APDU rejection
04/12/12    at     Sending correct value in Result TLV for QMI_UIM_AUTHENTICATE
04/11/12    at     Indication support for sending long APDUs
04/05/12    at     Reject commands on logical channel not opened by the client
04/02/12    vv     Set appropriate error when a PIN2 operation is unsupported
03/26/12    tl     Updated incorrect pointer in MMGSDI_SAP_CARD_READER_STATUS_CNF case
03/26/12    nmb    Enable Secure Channel perso
03/22/12    bcho   Perso status WAIT FOR EXTERNAL PERSO, PERSO FAILURE handled
03/12/12    vv     Send appropriate error in ISIM auth response
03/09/12    vv     Send one indication after a PIN operation
03/08/12    at     Proper cleanup during REFRESH RESET & card error events
03/05/12    tkl    MPSS/QMI support interfaces logging
03/02/12    vv     Added optional TLV in send APDU request
03/02/12    vv     Added support for querying ESN status
03/02/12    at     Change to not send mmgsdi_card_pup if it is already up
03/02/12    at     Minor changes while reading apdu_security_aid_list
02/29/12    at     Check of whitelist/blacklist when opening a logical channel
02/28/12    yt     Fixed compilation error
02/28/12    yt     Limit length of response for READ_TRANSPARENT to 4096 bytes
02/28/12    nb     Support for new API to open session with MF
02/23/12    nmb    QMI QMUX Transition
02/23/12    at     Block APDUs on channels not opened by the client
02/23/12    av     Cleaned up remaining always on features
02/22/12    vv     Send PIN events in case of a decrease in PIN retries count
02/16/12    at     Block SAP APDU command that selects a non-telecom app
02/08/12    at     Block certain APDUs in send APDU command,
                   Added support for NV apdu_security_restrictions
01/27/12    at     Cleanup PIN states after UICC App reset refresh
01/26/12    vv     Fixed error code when PIN2 enabling/disabling is unsupported
01/03/12    nb     Added optional TLV for QMI configuration
12/21/11    nmb    Secure channel perso for apps
12/21/11    bcho   Legacy GSDI removal updates
12/20/11    hn     Add support for off-target testing
12/15/11    nb     Added handling of new card error code
12/05/11    vv     Update PIN information for all apps after PIN error
11/15/11    vv     Reset PIN states in case of deactivation
11/11/11    vv     Update PINs state in sub ready evt if PIN evts are missed
11/01/11    at     Skip perso indication to client if perso is disabled
10/28/11    yt     Return DEVICE_NOT_READY when session id is not available
10/24/11    at     Updated the minor version for QMI_UIM service
10/13/11    nb     Added handling of CARD_REMOVED
10/12/11    at     Handling intermediate get response in SAP commands
10/05/11    yt     Added support for refresh of non provisioning sessions
                   Removed flag to indicate if TLV is mandatory or optional
10/05/11    nb     Differentiate SAP Connect rejection due to active call
09/26/11    nmb    Maintain command buffers internally
09/16/11    yt     Added optional TLV for status of hot swap switch
08/26/11    at     Fixed KW critical warnings
08/18/11    at     Update app state when deactivated in session changed evt
08/16/11    at     Indication support for various commands
08/11/11    nmb    Expanded logical channels
08/05/11    vv     Added support for updating ISIM PIN status
08/03/11    mib    Added featurization for encryption functions
08/01/11    at     Support for keyref_id TLV in PIN commands
08/01/11    at     Support for using session id on an open channel id
08/01/11    vs     Fixed cnf deep copy pointer logic
08/01/11    vs     Support app selection with FCI via logical channel operation
07/11/11    yt     Handle error cases for Authentication failure
06/27/11    at     Added support for get ATR command
06/16/11    at     Send SAP indication on card error/removed
06/10/11    at     NV support for silent PIN1 verification
06/10/11    kk     Fixed compilation error
06/01/11    kk     Handling for card_pup failure
05/13/11    nmb    Added support for ISIM GBA Authentication
04/28/11    mib    Fixed crash due to invalid free reading multiple records
04/27/11    vs     Free user data in case sub ok req fails to get queued
04/26/11    vs     Support for subscription ok request
04/14/11    mib    Zero of allocated dynamic userdata for callbacks
04/07/11    mib    Added support to read multiple records at the same time
04/01/11    mib    Changed TLV for the encrypted PIN passed for verify
03/30/11    at     Fixed compiler warnings
03/30/11    yt     Send indication only if PIN/PUK retries are not exhausted
03/25/11    at     Support for dynamic allocation of userdata if needed
03/09/11    at     Added support for PIN1 encryption/decryption
03/07/11    at     Updating PIN retry counters properly on change pin event
03/03/11    mib    Added support to manage logical channels to send APDUs
03/01/11    at     Added support for SAP request & indication
02/10/11    mib    Fixed parsing of TLVs for Send APDU request
01/12/11    mib    Added support for CSIM file paths
01/04/11    mib    Added support for Compute IP Authentication
12/20/10    at     Added support for SAP connection request
12/17/10    mib    Split APDU request into two TLVs
12/14/10    mib    No perso retries for some error codes
12/08/10    at     Added support for send apdu request
12/09/10    mib    Fixed ASSERT in case of failure to open session
12/07/10    mib    Register for refresh even if 0 files are passed
12/07/10    at     Added new function for handling card removed event
12/05/10    mib    Fixed write record for cyclic files
11/08/10    mib    Fixed update of number of perso retries
11/02/10    mib    Check presence of optional TLV to activate a session
10/29/10    tkl    Return PIN2 restriction when set service failed
10/22/10    mib    Added support for get configuration request
10/22/10    mib    Check if client is still valid during async response
10/12/10    mib    Support for refresh by path
10/05/10    mib    Fixed number of perso retries
09/27/10    mib    Handling of session event for ILLEGAL
09/20/10    mib    Fixed no response for power up without card
09/17/10    mib    Fixed assert in get_label with slot 2 when not present
09/09/10    tkl    Fixed pin state change after PIN unblocked & changed.
09/09/10    mib    Fixed Klocwork warning
09/07/10    yt     Added support for Run CAVE and ISIM authentication context
08/21/10    mib    Fixed check condition during INIT+FCN refresh
                   Update app state during refresh and perso.
08/19/10    mib    Added check if client wants to vote for refresh
                   Added indipendent refresh state for each session
08/19/10    mib    Added support for POSSIBLY_REMOVED error code
08/12/10    mib    Fixed duplication of TLV data when opening a session
08/05/10    tkl    QMI UIM & QMI CAT split from data package
08/03/10    tkl    Updated card error event between power up without card and
                   card removal.
08/03/10    mib    Better handling of Perso error codes
08/02/10    mib    Send indication when card error changes
07/30/10    tkl    Fixed app state changed for after PIN unblocked.
07/26/10    mib    No effect for second event registration
07/26/10    mib    Return permanently blocked when PIN is blocked
07/26/10    yt     Updated request parameters for get_file_attr for MF or DF
07/16/10    mib    Updated number of PIN retries after confirmation
07/16/10    mib    Fixed error code for get_label when card is missing
07/14/10    yt     Process session open for nonprov apps based on client id
07/14/10    mib    Fixed critical Lint warning
07/08/10    mib    Updated minor revision number
07/07/10    yt     Added support for changing provisioning session
07/07/10    mib    Fixed compilation warning
06/25/10    mib    Restored open of 1X primary session only in parallel
06/24/10    tkl    Added checking of gw & 1x pri session id for deperso and
                   added activate session when process susbcription ready
06/21/10    mib    Opening default sessions in sequence
06/17/10    tkl    Fixed refresh registration when file id enum not found
06/16/10    mib    Added support for hidden key
06/11/10    mib    Fixed Lint warnings
06/08/10    mib    Pass card status in write response, in case of error
06/08/10    mib    Fixed TLV id for refresh indication
06/07/10    mib    Added support for GET LABEL and SESSION CHANGE requests
06/02/10    mib    Changed mapping of MMGSDI_INCORRECT_PARAMS. Reset card
                   error value when card is present
05/31/10    mib    Added storage of application label
05/24/10    mib    Modified mechanism to retrieve FDN status.
                   Process client id in QMI context.
05/20/10    tkl    Drop refresh callback for QMI power up operation
05/05/10    mib    Improved mechanism to pass TLV id for responses
04/13/10    mib    Fixed Klocwork issues
04/06/10    mib    Added support for authenticate and close session.
                   Changed TLV ids for consistency with other QMI services
01/11/10    mib    Initial Revision.
===========================================================================*/

/*===========================================================================

                          INCLUDE FILES FOR MODULE

===========================================================================*/
#include "uim_variation.h"
#include "comdef.h"
#include "customer.h"

#include "nv.h"
#include "uim_msg.h"
#include "err.h"
#include "amssassert.h"
#include "intconv.h"
#include "fs_lib.h"
#include "fs_public.h"
#include "ps_in.h"
#include "fs_diag_access.h"
#include "fs_stdlib.h"
#include <stringl/stringl.h>

#include "qmi_framework.h"
#include "qmi_svc_utils.h"
#include "modem_mem.h"
#include "secapi_util.h"
#include "mmgsdilib.h"
#include "mmgsdisessionlib.h"
#include "mmgsdisessionlib_v.h"
#include "mmgsdilib_p.h"
#include "qmi_uim_internal.h"
#include "qmi_uim_parsing.h"
#include "qmi_uim_cat_common.h"
#include "qmi_uim_encryption.h"
#include "ds_qmi_fw_common.h"
#include "qmi_uim.h"
#include "uim_p.h"
#include "qmi_cat.h"
#include "uimsub_manager.h"
#include "simlock_common.h"
#include "simlock_modem_lib.h"
#include "simlock_modem_p.h"
#include "gstk_exp_v.h"
#include "uim_common_efs.h"

#include "qmi_si.h"
#include "qmi_idl_lib.h"
#include "user_identity_module_v01.h"
#include "user_identity_module_impl_v01.h"

#ifdef FEATURE_UIM_SSM
#include "ssm.h"
#endif /* FEATURE_UIM_SSM */

/* These includes need to always be at bottom - offtarget use only */
#ifdef FEATURE_UIM_TEST_FRAMEWORK
#error code not present
#endif /* FEATURE_UIM_TEST_FRAMEWORK */

/*===========================================================================

                            CONSTANT DEFINITIONS

===========================================================================*/

/*---------------------------------------------------------------------------
  Service management
---------------------------------------------------------------------------*/
#define UIMI_MAX_CLIDS                (QMI_FRAMEWORK_SVC_MAX_CLIENTS - 1)
#define UIMI_INVALID_INSTANCE         (-1)
#define UIMI_RETRY_INTERVAL           (75)

/*---------------------------------------------------------------------------
  Major and Minor Version Nos for UIM
---------------------------------------------------------------------------*/
#define UIMI_BASE_VER_MAJOR           (1)
#define UIMI_BASE_VER_MINOR           (48)

#define UIMI_ADDENDUM_VER_MAJOR       (0)
#define UIMI_ADDENDUM_VER_MINOR       (0)

/*---------------------------------------------------------------------------
  Macro used in command handlers (common)
---------------------------------------------------------------------------*/
#define CHECK_RETVAL()  if (FALSE == retval) { dsm_free_packet(&response); \
                                               return NULL; }

/*---------------------------------------------------------------------------
  Defines to be used for MMGSDI
---------------------------------------------------------------------------*/
#define UIM_INVALID_CLIENT_ID         (0)
#define UIM_INVALID_SESSION_ID        (0)
#define UIM_FAKE_SESSION_ID           (0xFFFFFFFF)
#define UIM_INVALID_APP_INDEX         (0xFFFF)

/*---------------------------------------------------------------------------
  Defines to be used for refresh
---------------------------------------------------------------------------*/
#define UIM_REFRESH_MAX_CLIENTS       (UIMI_MAX_CLIDS)
#define UIM_REFRESH_PROV_COUNT        (9)
#define UIM_REFRESH_NON_PROV_COUNT    (6)
#define UIM_REFRESH_SESSION_COUNT     (UIM_REFRESH_PROV_COUNT + UIM_REFRESH_NON_PROV_COUNT)

/*---------------------------------------------------------------------------
  Defines to be used for non provisioning applications
---------------------------------------------------------------------------*/
#define UIM_MAX_NON_PROV_SESSIONS     (3)
#define UIM_MAX_NON_PROV_CLIENTS      (UIMI_MAX_CLIDS)

/*---------------------------------------------------------------------------
  Defines to be used for channels to stream APDUs
---------------------------------------------------------------------------*/
#define UIM_MAX_APDU_CHANNEL_COUNT (QMI_UIM_MAX_CARD_COUNT * 20)

/*---------------------------------------------------------------------------
  Defines to be used for opening sessions
---------------------------------------------------------------------------*/
#define UIM_SESSION_OPEN_DEFAULT      (0x00)
#define UIM_SESSION_OPEN_IMPLICIT     (0x01)
#define UIM_SESSION_OPEN_APDU         (0x02)

/*---------------------------------------------------------------------------
  Define with number of maximum MMGSDI functions in parallel
---------------------------------------------------------------------------*/
#define QMI_UIM_MAX_PARALLEL_CMD      (5)

/*---------------------------------------------------------------------------
  Define SSM access values
---------------------------------------------------------------------------*/
#define QMI_UIM_SSM_CMD_DISALLOW      (1)
#define QMI_UIM_SSM_KEY_NUM           (1)

/* First argument passed to ssm_get_perm, reflects the total num of
   arguments passed to it */
#define QMI_UIM_SSM_NUM_ARGS          (QMI_UIM_SSM_KEY_NUM + 2)

/* item # for restricted NV */
#define QMI_UIM_NV_NUM_HALT_SUB_NV_PATH           (65954)
#define QMI_UIM_NV_NUM_ENCRYPT_SUB_OK_NV_PATH     (67285)
#define QMI_UIM_NV_NUM_CONFIG_APDU_SEC_RESTR      (67312)
#define QMI_UIM_NV_NUM_CONFIG_APDU_SEC_AID_LIST   (67317)
#define QMI_UIM_NV_NUM_CONFIG_SAP_SEC_RESTR       (70283)
#define QMI_UIM_NV_NUM_CONFIG_AUTH_SEC_RESTR      (70284)
#define QMI_UIM_NV_NUM_CATI_BLOCK_SMS_PP_ENV      (71557)
#define QMI_UIM_NV_NUM_CONFIG_SILENT_RECOVERY     (72534)

/*---------------------------------------------------------------------------
  Size of remaining encryped read request header RFUs
---------------------------------------------------------------------------*/
#define QMI_UIM_ENCRYPTED_READ_RSP_HEADER_RFU     (6)

/*---------------------------------------------------------------------------
  Macro used to free userdata in case of error
---------------------------------------------------------------------------*/
#define QMI_UIM_FREE_USERDATA_IF_ERROR(mmgsdi_status, cb_userdata_ptr)  \
            if (mmgsdi_status != MMGSDI_SUCCESS)                        \
            {                                                           \
              qmi_uim_free_cb_userdata(cb_userdata_ptr);                \
              cb_userdata_ptr = NULL;                                   \
            }

/*---------------------------------------------------------------------------
  Macro used to free userdata in case of error
---------------------------------------------------------------------------*/
#define QMI_UIM_LPA_FREE_USERDATA_IF_ERROR(lpa_status, cb_userdata_ptr)  \
            if (lpa_status != LPA_SUCCESS)                               \
            {                                                            \
              qmi_uim_free_cb_userdata(cb_userdata_ptr);                 \
              cb_userdata_ptr = NULL;                                    \
            }

/*---------------------------------------------------------------------------
  Macro used to free userdata in case of error
---------------------------------------------------------------------------*/
#define QMI_UIM_SIMLOCK_FREE_USERDATA_IF_ERROR(simlock_status, cb_userdata_ptr)  \
            if (simlock_status != SIMLOCK_SUCCESS)                               \
            {                                                                    \
              qmi_uim_free_cb_userdata(cb_userdata_ptr);                         \
              cb_userdata_ptr = NULL;                                            \
            }

/*---------------------------------------------------------------------------
  Macros used to validate the SP in command buffer or return if NULL.
  The second macro also frees the QMI response before returning.
---------------------------------------------------------------------------*/
#define QMI_UIM_VALIDATE_SP_IN_CMD_BUF(cmd_buf_p)                         \
            if (cmd_buf_p->x_p == NULL || cmd_buf_p->x_p->cl_sp == NULL)  \
            {                                                             \
              UIM_MSG_HIGH_0("Transaction ptr or client state pointer is NULL"); \
              return;                                                     \
            }

#define QMI_UIM_VALIDATE_SP_IN_CMD_BUF_FREE_RESPONSE(cmd_buf_p, response) \
            if (cmd_buf_p->x_p == NULL || cmd_buf_p->x_p->cl_sp == NULL)  \
            {                                                             \
              UIM_MSG_HIGH_0("Transaction ptr or client state pointer is NULL"); \
              dsm_free_packet(&response);                                 \
              return;                                                     \
            }

/*---------------------------------------------------------------------------
  Macro used to validate if cmd_buf_p is valid for a response. Free userdata
  pointer & returns if NULL
---------------------------------------------------------------------------*/
#define QMI_UIM_VALIDATE_CMD_BUF_IN_USERDATA(cb_userdata_ptr)             \
            if ((!cb_userdata_ptr->ind_token.is_valid) &&                 \
                (cb_userdata_ptr->cmd_buf_ptr == NULL))                   \
            {                                                             \
              UIM_MSG_HIGH_0("Null cmd_buf ptr for response");            \
              qmi_uim_free_cb_userdata(cb_userdata_ptr);                  \
              return;                                                     \
            }

/*---------------------------------------------------------------------------
  Macro used to free the command buffer
---------------------------------------------------------------------------*/
#define QMI_UIM_FREE_CMD_BUF(cmd_buf_p)                                   \
            if (cmd_buf_p != NULL)                                        \
            {                                                             \
              ds_qmi_fw_free_cmd_buf( &cmd_buf_p );                       \
            }


/*---------------------------------------------------------------------------
  Macro used to check FDN status in the service table
---------------------------------------------------------------------------*/
#define QMI_UIM_FDN_AVAILABLE_IN_ICC    0x10
#define QMI_UIM_FDN_AVAILABLE_IN_UICC   0x02

/*---------------------------------------------------------------------------
  Length of authentication data for CAVE algorithm
---------------------------------------------------------------------------*/
#define QMI_UIM_CAVE_AUTH_DATA_LEN      0x11

/*---------------------------------------------------------------------------
  Maximum length of a record
---------------------------------------------------------------------------*/
#define QMI_UIM_MAX_RECORD_LEN          255

/*---------------------------------------------------------------------------
  Maximum number of records in a file
---------------------------------------------------------------------------*/
#define QMI_UIM_MAX_NUM_RECORD          254

/*---------------------------------------------------------------------------
  First record number
---------------------------------------------------------------------------*/
#define QMI_UIM_RECORD_1                1

/*---------------------------------------------------------------------------
  Values used in SAP response
---------------------------------------------------------------------------*/
#define QMI_UIM_INS_BYTE_GET_RESPONSE       0xC0
#define QMI_UIM_PROCEDURE_BYTE_SW1_NORMAL   0x61
#define QMI_UIM_PROCEDURE_BYTE_SW2_ZERO     0x00

/*---------------------------------------------------------------------------
  Values used in APDU check
---------------------------------------------------------------------------*/
#define QMI_UIM_APDU_INS_BYTE_MANAGE_CHANNEL            0x70
#define QMI_UIM_APDU_INS_BYTE_SELECT_FILE               0xA4
#define QMI_UIM_APDU_P1_BYTE_SELECT_DF_NAME             0x04
#define QMI_UIM_APDU_INS_BYTE_AUTHENTICATE              0x88
#define QMI_UIM_APDU_P2_BYTE_USIM_AUTHENTICATE_GSM_ALGO 0x80
#define QMI_UIM_APDU_CLA_BYTE_ICC                       0xA0


/*---------------------------------------------------------------------------
  Maximum length of data that QMI UIM can return for READ_TRANSPARENT_REQ
---------------------------------------------------------------------------*/
#define QMI_UIM_READ_TRANSPARENT_MAX_LEN  4096

/*---------------------------------------------------------------------------
  Maximum length of increase data
---------------------------------------------------------------------------*/
#define QMI_UIM_MAX_INCREASE_DATA  127

/*---------------------------------------------------------------------------
  Maximum length of data that QMI UIM can return for additional records
  in READ_RECORD_REQ
---------------------------------------------------------------------------*/
#define QMI_UIM_READ_ADDITIONAL_RECORDS_MAX_LEN  4096

/*---------------------------------------------------------------------------
  AID details in NV apdu_security_aid_list
---------------------------------------------------------------------------*/
#define QMI_UIM_APDU_SEC_NV_MAX_AID_ENTRIES    (30)
#define QMI_UIM_APDU_SEC_NV_MAX_AID_LEN        (16)

/*---------------------------------------------------------------------------
  Value used when sending long APDU response
---------------------------------------------------------------------------*/
#define QMI_UIM_APDU_RESP_MAX_DATA_LEN        (1024)

/*---------------------------------------------------------------------------
  Value used for EFS directory list
---------------------------------------------------------------------------*/
#define QMI_UIM_EFS_DIRECTORY_LIST_SIZE       (3)

/*---------------------------------------------------------------------------
  Convert upper case alphabet to lower case alphabet
---------------------------------------------------------------------------*/
#define QMI_UIM_LOWER_CASE(x)  ((x >= 'A' && x <= 'Z') ? (x - 'A' + 'a') : x)

/*---------------------------------------------------------------------------
  Length of IMSI digits data
---------------------------------------------------------------------------*/
#define QMI_UIM_IMSI_DIGIT_LEN                 (15)

/*---------------------------------------------------------------------------
  Start position of MCC and MNC
---------------------------------------------------------------------------*/
#define QMI_UIM_MNC_START_POS                  (8)
#define QMI_UIM_MCC_START_POS                  (15)

/*---------------------------------------------------------------------------
  IMSI lower & upper byte mask
---------------------------------------------------------------------------*/
#define QMI_UIM_IMSI_LOW_BYTE_MASK             0x0F
#define QMI_UIM_IMSI_HIGH_BYTE_MASK            0xF0

/*---------------------------------------------------------------------------
  IMPI NAI tag
---------------------------------------------------------------------------*/
#define QMI_UIM_IMPI_NAI_TAG                   (0x80)
#define QMI_UIM_IMPI_MAX                       (255)

/*===========================================================================

                                DATA TYPES

===========================================================================*/

/*---------------------------------------------------------------------------
  List of files a client has registered for refresh
---------------------------------------------------------------------------*/
typedef struct refresh_files_list
{
  mmgsdi_session_id_type             session_id;
  mmgsdi_path_type                   file;
  struct refresh_files_list        * next_ptr;
}qmi_uim_refresh_file_node_type;

/*---------------------------------------------------------------------------
  QMI UIM instance state definition & UIM client state definition
---------------------------------------------------------------------------*/
typedef struct
{
  qmi_common_client_state_type       common; // must be first since we alias
  int16                              instance;
  int16                              service_id;
  struct
  {
    qmi_uim_registration_event_type  reg_event_type;
    boolean                          sap_intermediate_get_resp;
    uint32                           refresh_notify_mask;
    boolean                          refresh_vote;
    uint16                           refresh_num_files;
    qmi_uim_refresh_file_node_type * refresh_files_list;
    uint32                           refresh_all_notify_mask;
    boolean                          card_status_ind_postponed;
    boolean                          supply_voltage_pending_ack[QMI_UIM_MAX_CARD_COUNT];
    boolean                          add_profile_requested;
  }uim_info;
} qmi_uimi_client_state_type;

/*---------------------------------------------------------------------------
  Watermark queue to hold deferred responses
---------------------------------------------------------------------------*/
typedef struct
{
  qmi_common_svc_state_type    common; // must be first since we alias
  qmi_uimi_client_state_type * client[UIMI_MAX_CLIDS];
  uint32                       client_reg_count[UIMI_MAX_CLIDS];
} qmi_uimi_state_type;

typedef enum
{
  UIMI_CMD_VAL_RESET                       = 0x0000,
  UIMI_CMD_VAL_READ_TRANSPARENT            = 0x0020,
  UIMI_CMD_VAL_READ_RECORD                 = 0x0021,
  UIMI_CMD_VAL_WRITE_TRANSPARENT           = 0x0022,
  UIMI_CMD_VAL_WRITE_RECORD                = 0x0023,
  UIMI_CMD_VAL_GET_FILE_ATTRIBUTES         = 0x0024,
  UIMI_CMD_VAL_SET_PIN_PROTECTION          = 0x0025,
  UIMI_CMD_VAL_VERIFY_PIN                  = 0x0026,
  UIMI_CMD_VAL_UNBLOCK_PIN                 = 0x0027,
  UIMI_CMD_VAL_CHANGE_PIN                  = 0x0028,
  UIMI_CMD_VAL_DEPERSONALIZATION           = 0x0029,
  UIMI_CMD_VAL_REFRESH_REGISTER            = 0x002A,
  UIMI_CMD_VAL_REFRESH_OK                  = 0x002B,
  UIMI_CMD_VAL_REFRESH_COMPLETE            = 0x002C,
  UIMI_CMD_VAL_REFRESH_GET_LAST_EVENT      = 0x002D,
  UIMI_CMD_VAL_EVENT_REG                   = 0x002E,
  UIMI_CMD_VAL_GET_CARD_STATUS             = 0x002F,
  UIMI_CMD_VAL_POWER_DOWN                  = 0x0030,
  UIMI_CMD_VAL_POWER_UP                    = 0x0031,
  UIMI_CMD_VAL_CARD_STATUS_IND             = 0x0032,
  UIMI_CMD_VAL_REFRESH_IND                 = 0x0033,
  UIMI_CMD_VAL_AUTHENTICATE                = 0x0034,
  UIMI_CMD_VAL_CLOSE_SESSION               = 0x0035,
  UIMI_CMD_VAL_GET_SERVICE_STATUS          = 0x0036,
  UIMI_CMD_VAL_SET_SERVICE_STATUS          = 0x0037,
  UIMI_CMD_VAL_CHANGE_PROVISIONING_SESSION = 0x0038,
  UIMI_CMD_VAL_GET_LABEL                   = 0x0039,
  UIMI_CMD_VAL_GET_CONFIGURATION           = 0x003A,
  UIMI_CMD_VAL_SEND_APDU                   = 0x003B,
  UIMI_CMD_VAL_SAP_CONNECTION              = 0x003C,
  UIMI_CMD_VAL_SAP_REQUEST                 = 0x003D,
  UIMI_CMD_VAL_SAP_CONNECTION_IND          = 0x003E,
  UIMI_CMD_VAL_LOGICAL_CHANNEL             = 0x003F,
  UIMI_CMD_VAL_SUBSCRIPTION_OK_REQ         = 0x0040,
  UIMI_CMD_VAL_GET_ATR                     = 0x0041,
  UIMI_CMD_VAL_OPEN_LOGICAL_CHANNEL        = 0x0042,
  UIMI_CMD_VAL_SESSION_CLOSED_IND          = 0x0043,
  UIMI_CMD_VAL_REFRESH_REGISTER_ALL        = 0x0044,
  UIMI_CMD_VAL_SET_FILE_STATUS             = 0x0045,
  UIMI_CMD_VAL_SWITCH_SLOT                 = 0x0046,
  UIMI_CMD_VAL_GET_SLOTS_STATUS            = 0x0047,
  UIMI_CMD_VAL_SLOTS_STATUS_IND            = 0x0048,
  UIMI_CMD_VAL_READ_TRANSPARENT_LONG_IND   = 0x0049,
  UIMI_CMD_VAL_SIM_BUSY_IND                = 0x004A,
  UIMI_CMD_VAL_GET_PLMN_NAME_TABLE_INFO    = 0x004B,
  UIMI_CMD_VAL_PERSONALIZATION             = 0x004C,
  UIMI_CMD_VAL_INCREASE                    = 0x004D,
  UIMI_CMD_VAL_RECOVERY                    = 0x004E,
  UIMI_CMD_VAL_RESELECT                    = 0x004F,
  UIMI_CMD_VAL_RECOVERY_COMPLETE_IND       = 0x0050,
  UIMI_CMD_VAL_SEND_STATUS                 = 0x0051,
  UIMI_CMD_VAL_GET_SIM_PROFILE             = 0x0052,
  UIMI_CMD_VAL_SET_SIM_PROFILE             = 0x0053,
  UIMI_CMD_VAL_SUPPLY_VOLTAGE              = 0x0054,
  UIMI_CMD_VAL_CARD_ACTIVATION_STATUS_IND  = 0x0055,
  UIMI_CMD_VAL_DEPERSONALIZATION_SECURE    = 0x0056,
  UIMI_CMD_VAL_PERSONALIZATION_SECURE      = 0x0057,
  UIMI_CMD_VAL_EMERGENCY_ONLY              = 0x0058,
  UIMI_CMD_VAL_SIMLOCK_CONFIGURATION       = 0x0059,
  UIMI_CMD_VAL_GBA                         = 0x005A,
  UIMI_CMD_VAL_GET_GBA_IMPI                = 0x005B,
  UIMI_CMD_VAL_SEARCH_RECORD               = 0x005C,
  UIMI_CMD_VAL_REMOTE_UNLOCK               = 0x005D,
  UIMI_CMD_VAL_VERIFY_IMSI                 = 0x005E,
  UIMI_CMD_VAL_TEMPORARY_UNLOCK_STATUS_IND = 0x005F,
  UIMI_CMD_VAL_GET_PROFILE_INFO            = QMI_UIM_GET_PROFILE_INFO_REQ_V01,
  UIMI_CMD_VAL_GET_EID                     = QMI_UIM_GET_EID_REQ_V01,
  UIMI_CMD_VAL_DELETE_PROFILE              = QMI_UIM_DELETE_PROFILE_REQ_V01,
  UIMI_CMD_VAL_EUICC_MEMORY_RESET          = QMI_UIM_EUICC_MEMORY_RESET_REQ_V01,
  UIMI_CMD_VAL_ADD_PROFILE                 = QMI_UIM_ADD_PROFILE_REQ_V01,
  UIMI_CMD_VAL_ADD_PROFILE_IND             = QMI_UIM_ADD_PROFILE_IND_V01,
  UIMI_CMD_VAL_UPDATE_NICKNAME             = QMI_UIM_UPDATE_PROFILE_NICKNAME_REQ_V01,

  /* QC EXTERNAL QMI COMMAND RANGE IS 0x0000 - 0x5555.
     Add the next external QMI Command here */

  /* VENDOR SPECIFIC QMI COMMAND RANGE IS 0x5556 - 0xAAAA.
     IMPORTANT!
     Add the vendor specific QMI Commands within this range only to avoid
     conflicts with QC QMI commands that would get released in future */

  /* RESERVED QC QMI COMMAND RANGE IS 0xAAAB - 0xFFFE
     Internal QMI Commands must be added in DECREASING ORDER from Below */
  UIMI_CMD_VAL_WIDTH                  = 0xFFFF
} qmi_uimi_cmd_val_e_type;


/*===========================================================================

                               INTERNAL DATA

===========================================================================*/

/*---------------------------------------------------------------------------
  Possible refresh states
---------------------------------------------------------------------------*/
typedef enum
{
  UIM_REFRESH_STATE_IDLE               = 0,
  UIM_REFRESH_STATE_WAIT_FOR_OK        = 1,
  UIM_REFRESH_STATE_WAIT_FOR_COMPLETE  = 2
} qmi_uimi_refresh_state_type;

/*---------------------------------------------------------------------------
  AID list types
---------------------------------------------------------------------------*/
typedef enum
{
  UIM_AID_LIST_WHITE_LIST              = 0,
  UIM_AID_LIST_BLACK_LIST              = 1
} qmi_uimi_aid_list_type;

/*---------------------------------------------------------------------------
  Type of QMI UIM messages posted to DCC task
---------------------------------------------------------------------------*/
typedef enum
{
  QMI_UIM_MESSAGE_EVENT,
  QMI_UIM_MESSAGE_CNF,
  QMI_UIM_MESSAGE_PHYSICAL_SLOTS_STATUS,
  QMI_UIM_MESSAGE_ALLOC_CLID,
  QMI_UIM_MESSAGE_DEALLOC_CLID,
  QMI_UIM_MESSAGE_FRAMEWORK_CMD,
  QMI_UIM_MESSAGE_RECOVERY_CB,
  QMI_UIM_MESSAGE_SIMLOCK_CB,
  QMI_UIM_MESSAGE_RECOVERY_COMPLETE_IND,
  QMI_UIM_MESSAGE_SUPPLY_VOLTAGE_IND,
  QMI_UIM_MESSAGE_SIMLOCK_REMOTE_SFS_CB,
  QMI_UIM_MESSAGE_OTASP_STATUS_IND,
  QMI_UIM_MESSAGE_SIMLOCK_SET_REMOTE_SFS_CB,
  QMI_UIM_MESSAGE_GBA_CB,
  QMI_UIM_MESSAGE_REMOTE_UNLOCK_CB,
  QMI_UIM_MESSAGE_SIMLOCK_TEMPORARY_UNLOCK_CB,
  QMI_UIM_MESSAGE_LPA_CB,
  QMI_UIM_MESSAGE_LPA_EVENT,
  QMI_UIM_MESSAGE_LPA_PROFILE_INFO_CB
} qmi_uim_message_enum_type;

/*---------------------------------------------------------------------------
  Values used in APDU security restrictions EFS item
---------------------------------------------------------------------------*/
typedef enum
{
  QMI_UIM_APDU_SEC_RESTRICTIONS_NONE   = 0,
  QMI_UIM_APDU_SEC_RESTRICTIONS_ALL    = 1,
  QMI_UIM_APDU_SEC_RESTRICTIONS_II_CLA = 2
} qmi_uim_apdu_sec_restr_type;

/*---------------------------------------------------------------------------
  Values used in AUTH security restrictions EFS item
---------------------------------------------------------------------------*/
typedef enum
{
  QMI_UIM_AUTH_SEC_RESTRICTIONS_NONE   = 0,
  QMI_UIM_AUTH_SEC_RESTRICTIONS_ALL    = 1,
  QMI_UIM_AUTH_SEC_RESTRICTIONS_II_CLA = 2
} qmi_uim_auth_sec_restr_type;

/*---------------------------------------------------------------------------
  Values describe the level of encryption
---------------------------------------------------------------------------*/
typedef enum
{
  QMI_UIM_NO_ENCRYPTION         = 0,
  QMI_UIM_DATA_ONLY_ENCRYPTION  = 1,
  QMI_UIM_COMPLETE_ENCRYPTION   = 2
} qmi_uim_requested_encrytion_type;

/*---------------------------------------------------------------------------
  Type of QMI UIM PUP request state
     QMI_UIM_PUP_NOT_IN_PROGRESS:    No power_up is in progress
     QMI_UIM_PUP_MMGSDI_RSP_PENDING: Power_up req sent to MMGSDI and waiting
                                     for first rsp from MMGSDI
     QMI_UIM_PUP_RSP_SENT_TO_CLIENT: Rsp sent to QMI UIM client as part of first
                                     rsp from MMGSDI. Now, we need to drop second
                                     rsp from MMGSDI.
     QMI_UIM_PUP_CLIENT_RSP_PENDING: No rsp sent to client as part of first rsp
                                     from MMGSDI. Rsp will be send to client as
                                     part of second rsp from MMGSDI.
---------------------------------------------------------------------------*/
typedef enum {
  QMI_UIM_PUP_NOT_IN_PROGRESS                    = 0,
  QMI_UIM_PUP_MMGSDI_RSP_PENDING                 = 1,
  QMI_UIM_PUP_RSP_SENT_TO_CLIENT                 = 2,
  QMI_UIM_PUP_CLIENT_RSP_PENDING                 = 3
} qmi_uim_pup_state_enum_type;

/*---------------------------------------------------------------------------
  Structure for QMI UIM messages
---------------------------------------------------------------------------*/
typedef struct
{
  /* This needs to be in first position */
  q_link_type                                     link_next;

  qmi_uim_message_enum_type                       message_type;

  union
  {
    struct
    {
      mmgsdi_return_enum_type                     status;
      mmgsdi_cnf_enum_type                        cnf_type;
      mmgsdi_cnf_type                             cnf_value;
    }                                             cnf;
    struct
    {
      mmgsdi_event_data_type                      evt;
    }                                             event;
    struct
    {
      qmi_framework_common_msg_hdr_type           cmd_hdr;
    }                                             clid_cb;
    struct
    {
      qmi_framework_msg_hdr_type                  cmd_hdr;
      dsm_item_type                             * sdu;
    }                                             framework_cmd;
    struct
    {
      uint8                                       num_slots;
      uim_phy_slot_status_type                  * slot_status_ptr;
    }                                             physical_slots_info;
    struct
    {
      uim_slot_type                               slot;
      const void                                * user_data;
    }                                             recovery_data;
    struct
    {
      simlock_result_enum_type                    status;
      simlock_message_response_data_type          data;
      const void                                * user_data_ptr;
    }                                             simlock;
    struct
    {
      uim_slot_type                               slot;
    }                                             recovery_ind;
    struct
    {
      uim_slot_type                               slot;
      uimdrv_qmi_indications_type                 ldo_state;
      uimdrv_qmi_power_management_callback_type   uim_callback;
    }                                             supply_voltage;
    struct
    {
      simlock_file_operation_enum_type            operation;
      simlock_token_id_type                       request_token_id;
      simlock_file_type                           file;
      simlock_data_type                           simlock_data;
      simlock_remote_sfs_response_cb_type         simlock_resp_cb;
    }                                             simlock_remote_sfs_req;
    struct
    {
      gstk_slot_id_enum_type                      slot;
      gstk_otasp_act_status_enum_type             status;
    }                                             otasp_status_ind;
    struct
    {
      simlock_result_enum_type                    status;
      const void                                * user_data_ptr;
    }                                             simlock_set_remote_sfs_resp;
    struct
    {
      gba_result_enum_type                        status;
      gba_response_data_type                      cnf_value;
      const void                                * user_data_ptr;
    }                                             gba_cnf;
    struct
    {
      simlock_result_enum_type                    status;
      simlock_data_type                           key_data;
      const void                                * user_data_ptr;
    }                                             remote_unlock_resp;
    struct
    {
      lpa_result_enum_type                        status;
      lpa_response_data_type                      cnf_value;
      void                                      * user_data_ptr;
    }                                             lpa_cnf;
    struct
    {
      lpa_event_data_type                         evt;
      lpa_result_enum_type                        status;
    }                                             lpa_evt;
  }                                               data;
} qmi_uim_message_type;

/*---------------------------------------------------------------------------
  Pending request info for non provisioning sessions
---------------------------------------------------------------------------*/
typedef struct qmi_uimi_pending_request_type
{
  qmi_uimi_cmd_val_e_type                 command_id;
  uint8                                   tlv_data_count;
  qmi_uim_tlv_item_type *                 tlv_data_ptr;
  void *                                  cmd_buf_ptr;
  uint8                                   clid;
  uint32                                  client_reg_count;
  struct qmi_uimi_pending_request_type  * next_ptr;
} qmi_uimi_pending_request_type;

/*---------------------------------------------------------------------------
  Token information extracted from a command
---------------------------------------------------------------------------*/
typedef struct
{
  boolean                    is_valid;
  uint32                     token;
} qmi_uimi_ind_token_info_type;

/*---------------------------------------------------------------------------
  Userdata used for MMGSDI functions
---------------------------------------------------------------------------*/
typedef struct
{
  boolean                               in_use;
  boolean                               is_dynamic;
  qmi_uimi_cmd_val_e_type               request_id;
  qmi_uimi_ind_token_info_type          ind_token;
  uint8                                 clid;
  uint32                                client_reg_count;
  void *                                cmd_buf_ptr;
  /* this structure can be expanded with input parameters
     required at the end. Right now, this is not necessary */
  union
  {
    struct
    {
      qmi_uim_requested_encrytion_type  encryption_status;
      mmgsdi_session_type_enum_type     session_type;
      mmgsdi_access_type                file_access;
    }                                   read_transparent;
    struct
    {
      mmgsdi_access_type                file_access;
      mmgsdi_rec_num_type               first_record;
      uint16                            total_records;
      uint16                            read_records;
      qmi_uim_additional_records_type * records_cnf;
    }                                   read_record;
    struct
    {
      mmgsdi_access_type                file_access;
      mmgsdi_rec_num_type               record;
      mmgsdi_write_data_type            data;
    }                                   write_record;
    struct
    {
      mmgsdi_access_type                file_access;
    }                                   get_file_attributes;
    struct
    {
      uint8                             pin1_length;
      uint8                             pin1_value[QMI_UIM_TLV_MAX_PIN_LEN];
    }                                   pin_operation;
    struct
    {
      boolean                           hidden_key;
      boolean                           index_in_dir;
      mmgsdi_service_enum_type          service_id;
    }                                   get_service_status;
    struct
    {
      boolean                           automatic_selection_status;
      boolean                           personalization_status;
      boolean                           halt_subscription_status;
      boolean                           usb_uicc_supported_status;
      boolean                           sap_client_supported_status;
      boolean                           automatic_selection;
      mmgsdi_perso_feature_ind_type     feature_ind;
      mmgsdi_perso_dck_retries_type     retries;
      mmgsdi_perso_dck_retries_type     unblock_retries;
      boolean                           halt_subscription;
      boolean                           usb_uicc_supported;
      boolean                           sap_client_supported;
    }                                   get_configuration;
    struct
    {
      uint8                             ins_value;
    }                                   sap_request;
    struct
    {
      uint8                             channel_index;
      uint8                             session_open_type;
      mmgsdi_session_type_enum_type     session_type;
    }                                   session_open_request;
    struct
    {
      uint8                             channel_index;
    }                                   session_close_request;
    struct
    {
      simlock_category_enum_type        category;
      simlock_slot_enum_type            slot;
      simlock_result_enum_type          result;
      uint32                            num_retries;
      boolean                           ck_present;
      uint16                            request_id;
    }                                   simlock_unlock;
    struct
    {
      boolean                           ck_present;
      uint16                            request_id;
      simlock_slot_enum_type            slot;
      simlock_ck_data_type              ck;
      uint8                             total_list_cnt;
      uint8                             next_list_to_lock;
      simlock_category_data_type      * code_ptr;
    }                                   simlock_lock;
    struct
    {
      qmi_uim_auth_context_type         auth_context;
    }                                   authenticate;
    struct
    {
      uint16                            request_id;
    }                                   simlock_set_device_mode;
    struct
    {
      uint16                            request_id;
    }                                   simlock_set_remote_sfs;
    struct
    {
      uint8                             channel_index;
    }                                   reselect_request;
    struct
    {
      gba_naf_fqdn_type                 fqdn_data;
    }                                   gba;
    struct
    {
      mmgsdi_slot_id_enum_type          slot;
      boolean                           is_profile_query;
    }                                   lpa;
  }                                     data;
} qmi_uimi_userdata_type;

/*---------------------------------------------------------------------------
  Cache with record type used for write record
---------------------------------------------------------------------------*/
typedef struct qmi_uimi_file_record_type
{
  mmgsdi_session_id_type             session_id;
  mmgsdi_access_type                 file_access;
  mmgsdi_file_structure_enum_type    record_type;
  struct qmi_uimi_file_record_type * next_ptr;
} qmi_uimi_file_record_type;

/*---------------------------------------------------------------------------
  AID value and source
---------------------------------------------------------------------------*/
typedef struct
{
  mmgsdi_static_data_type  aid;
  boolean                  from_efs;
} qmi_uim_aid_entry_type;

/*---------------------------------------------------------------------------
  Whitelist/blacklist details used for APDU security
---------------------------------------------------------------------------*/
typedef struct
{
  qmi_uimi_aid_list_type           aid_list_type;
  uint16                           aid_count;
  qmi_uim_aid_entry_type         * aid_list_ptr;
} qmi_uimi_apdu_sec_aid_info;

/*---------------------------------------------------------------------------
  Channel details for Send APDU
---------------------------------------------------------------------------*/
typedef struct
{
  mmgsdi_session_id_type           mmgsdi_session_id;
  mmgsdi_slot_id_enum_type         slot;
  uint8                            logical_channel;
  mmgsdi_static_data_type          aid;
  qmi_uimi_client_state_type     * opening_cl_sp;
} apdu_channel_info;

/* -----------------------------------------------------------------------------
   STRUCTURE:    QMI_UIM_IMSI_DIGITS_DATA_TYPE

   DESCRIPTION:        Structure containing IMSI digits data
     imsi_digits_len:  Data length
     imsi_digits:      IMSI data in BCD format
-------------------------------------------------------------------------------*/
typedef struct{
  uint8   imsi_digits_len;
  uint8   imsi_digits[QMI_UIM_IMSI_DIGIT_LEN];
} qmi_uim_imsi_digits_data_type;

/* ----------------------------------------------------------------------------
   STRUCTURE:      QMI_UIM_IMPI_TYPE

   DESCRIPTION:    Structure which stores the IMPI data.
     data_len:     Data length of IMPI data
     data:         IMPI data
-------------------------------------------------------------------------------*/
typedef struct {
  uint8  data_len;
  uint8  data[QMI_UIM_IMPI_MAX];
} qmi_uim_impi_type;

/*---------------------------------------------------------------------------
  Card update required type used for card status indications
---------------------------------------------------------------------------*/
typedef struct
{
  boolean card_update_required;
  boolean reduced_card_update_required;
} qmi_uim_card_update_required_type;

typedef struct
{
  mmgsdi_profile_id_enum_type      profile_id;
  lpa_profile_info_type            profile_info;
} qmi_uim_euicc_profile_info_type;

/*---------------------------------------------------------------------------
  Global data for QMI UIM module
---------------------------------------------------------------------------*/
typedef struct
{
  /* Indicates if the global variable has been initialized or not */
  boolean                              init;
  /* MMGSDI client and session ids */
  mmgsdi_client_id_type                mmgsdi_client_id;
  mmgsdi_session_id_type               mmgsdi_gw_session_id[QMI_UIM_MAX_PROV_SESSIONS];
  mmgsdi_session_id_type               mmgsdi_1x_session_id[QMI_UIM_MAX_PROV_SESSIONS];
  mmgsdi_session_id_type               mmgsdi_card_slot_session_id[QMI_UIM_MAX_CARD_SESSIONS];
  /* Non provisioning session ids */
  struct
  {
    boolean                            init;
    mmgsdi_session_id_type             mmgsdi_session_id;
    mmgsdi_session_type_enum_type      session_type;
    mmgsdi_static_data_type            aid;
    qmi_uimi_pending_request_type    * pending_req_ptr;
    /* Client Info */
    struct
    {
      /* Number of clients linked to the non-prov. session */
      uint16                           client_count;
      /* Client state pointers of all clients linked to the session */
      qmi_uimi_client_state_type *     opening_cl_sp[UIM_MAX_NON_PROV_CLIENTS];
    }                                  client_info;
  }                                    non_prov_session[UIM_MAX_NON_PROV_SESSIONS];
  /* Refresh details (for each slot) */
  struct
  {
    qmi_uimi_refresh_state_type        state;
    boolean                            ok_to_init;
    boolean                            complete;
    uint16                             client_count;
    qmi_uimi_client_state_type *       client_list[UIM_REFRESH_MAX_CLIENTS];
    struct
    {
      mmgsdi_session_id_type           session_id;
      mmgsdi_refresh_evt_info_type    *event_ptr;
    }                                  cache;
  }                                    refresh_info[UIM_REFRESH_SESSION_COUNT];
  /* Channel details for Send APDU */
  apdu_channel_info                  * apdu_channel[UIM_MAX_APDU_CHANNEL_COUNT];
  /* Session ids for non prov sessions */
  mmgsdi_session_id_type               non_prov_refresh_session_id[UIM_REFRESH_NON_PROV_COUNT];
  /* SAP details */
  struct
  {
    boolean                            is_enabled;
    mmgsdi_sap_state_enum_type         sap_state;
  }                                    sap_info[QMI_UIM_MAX_CARD_COUNT];
  /* APDU security AID list details for APDU security */
  qmi_uimi_apdu_sec_aid_info           apdu_sec_aid_info;
  /* Card state */
  qmi_uim_card_state                   card_state;
  /* Card state validity status */
  boolean                              card_state_valid[QMI_UIM_MAX_CARD_COUNT];
  /* Card is eUICC or not */
  boolean                              is_euicc_card[QMI_UIM_MAX_CARD_COUNT];
  /* Cache with record type */
  qmi_uimi_file_record_type *          record_cache_ptr;
  /* Power up commands */
  qmi_uim_pup_state_enum_type          power_up_state[QMI_UIM_MAX_CARD_COUNT];
  /* Token value for long APDU Response/Indication */
  uint32                               apdu_response_token;
  /* Token value for long read data Response/Indication */
  uint32                               long_read_response_token;
  /* Data for MMGSDI callbacks */
  qmi_uimi_userdata_type               cb_userdata[QMI_UIM_MAX_PARALLEL_CMD];
  /* Indicates if silent PIN1 verification is supported */
  boolean                              silent_pin1_supported;
  /* Indicates if APDU security restriction is supported */
  qmi_uim_apdu_sec_restr_type          apdu_sec_restr_value;
  /* Indicates close logical channel indication preference */
  boolean                              close_channel_sync;
  /* Indicates if AUTHENTICATE security restriction is supported */
  qmi_uim_auth_sec_restr_type          auth_sec_restr_value;
  /* Indicates if SAP security restriction is supported */
  boolean                              sap_sec_restr_supported;
  /* Indicates if the provisioning is auto or manual*/
  boolean                              automatic_provisioning;
  /* Stores QMI_UIM's EFS directory name */
  char                               * efs_directory_list[QMI_UIM_EFS_DIRECTORY_LIST_SIZE];
  /* Indicates if the card status indications are to be block */
  boolean                            block_card_status_ind;
  /* Stores status of all physical slots */
  struct
  {
    uint8                              num_slots;
    uim_phy_slot_status_type         * slot_status_ptr;
  }                                    physical_slots_info;
  /* Message queue */
  q_type                               qmi_uim_q;
#ifdef FEATURE_UIM_SSM
  /* SSM info indicates SSM client id and status */
  struct
  {
    uint32                             qmi_uim_ssm_id;
    ssm_err_t                          qmi_uim_ssm_init_err;
  }                                    ssm_info;
#endif /* FEATURE_UIM_SSM */
  /* Stores the supply voltage callback for each slot to notify drivers
     it can proceed with power down */
  uimdrv_qmi_power_management_callback_type
                                       supply_voltage_cb[QMI_UIM_MAX_CARD_COUNT];

  /* Indicates simlock mode preference */
  qmi_uim_simlock_status_waiting_for_valid_card_type
                                       simlock_status_for_valid_card;

#ifdef FEATURE_SIMLOCK
  /* Stores the remote SFS response callback to notify
     simlock task about the pending read/write request */
  simlock_remote_sfs_response_cb_type  simlock_remote_sfs_operation_resp_cb;

  /* Stores the simlock slot policy */
  simlock_slot_policy_enum_type        simlock_slot_policy;

  /* Stores the status if a temporary unlock is runnning for
     a given personalization feature for all slots.*/
  boolean                              temp_unlock_info[QMI_UIM_MAX_CARD_COUNT][QMI_UIM_MAX_NUMBER_PERSO_FEATURES];
#endif /* FEATURE_SIMLOCK */

    /* Info about the eUICC profiles */
  qmi_uim_euicc_profile_info_type     *qmi_uim_euicc_profile_data_ptr[QMI_UIM_MAX_CARD_COUNT][QMI_UIM_PROFILES_MAX_V01];
} qmi_uim_global_type;

static qmi_uim_global_type          qmi_uim_global_var = {FALSE};
static qmi_uim_global_type  * const qmi_uim_global_ptr = &qmi_uim_global_var;

typedef struct
{
  char *    nv_filename ;
  uint32    nv_item;
}qmi_uim_restricted_nv_files_type;

const static qmi_uim_restricted_nv_files_type  qmi_uim_restricted_nv_files[] =
{
  {UIM_COMMON_EFS_PATH_MMGSDI_HALT_SUB,                         QMI_UIM_NV_NUM_HALT_SUB_NV_PATH},
  {UIM_COMMON_EFS_PATH_MMGSDI_ENCRYPT_SUB,                      QMI_UIM_NV_NUM_ENCRYPT_SUB_OK_NV_PATH},
  {UIM_COMMON_EFS_PATH_UIMQMI_QMI_UIM_CONFIG_APDU_SEC_RESTR,    QMI_UIM_NV_NUM_CONFIG_APDU_SEC_RESTR},
  {UIM_COMMON_EFS_PATH_UIMQMI_QMI_UIM_CONFIG_APDU_SEC_AID_LIST, QMI_UIM_NV_NUM_CONFIG_APDU_SEC_AID_LIST},
  {UIM_COMMON_EFS_PATH_UIMQMI_QMI_UIM_CONFIG_SAP_SEC_RESTR,     QMI_UIM_NV_NUM_CONFIG_SAP_SEC_RESTR},
  {UIM_COMMON_EFS_PATH_UIMQMI_QMI_UIM_CONFIG_AUTH_SEC_RESTR,    QMI_UIM_NV_NUM_CONFIG_AUTH_SEC_RESTR},
  {UIM_COMMON_EFS_PATH_UIMQMI_QMI_CAT_BLOCK_SMS_PP_ENV,         QMI_UIM_NV_NUM_CATI_BLOCK_SMS_PP_ENV},
  {UIM_COMMON_EFS_PATH_UIMQMI_QMI_UIM_CONFIG_SILENT_RECOVERY,   QMI_UIM_NV_NUM_CONFIG_SILENT_RECOVERY}
};

/*---------------------------------------------------------------------------
  QMI service command handlers
  forward declarations & cmd handler dispatch table definition
---------------------------------------------------------------------------*/
static dsm_item_type* qmi_uimi_reset(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_read_transparent(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_read_record(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_write_transparent(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_write_record(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_get_file_attributes(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_set_pin_protection(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_verify_pin(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_unblock_pin(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_change_pin(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_depersonalization(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_refresh_register(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_refresh_ok(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_refresh_complete(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_refresh_get_last_event(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_event_reg(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_get_card_status(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_power_down(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_power_up(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_authenticate(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_close_session(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_get_service_status(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_set_service_status(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_change_provisioning_session(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_get_label(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_get_configuration(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_send_apdu(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_sap_connection(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_sap_request(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_logical_channel(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_subscription_ok(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_get_atr(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_open_logical_channel(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_refresh_register_all(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_set_file_status(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_switch_slot(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_get_slots_status(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_get_plmn_name_table_info(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_personalization(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_increase(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_recovery(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_reselect(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_send_status(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_get_sim_profile(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_set_sim_profile(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_supply_voltage(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_depersonalization_secure(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_personalization_secure(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_emergency_only(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_simlock_configuration(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_gba(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_get_gba_impi(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_remote_unlock(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_verify_imsi(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_get_eid(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_delete_profile(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_euicc_memory_reset(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_add_profile(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_update_profile_nickname(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_get_profile_info(void*, void*, void*, dsm_item_type **);
static dsm_item_type* qmi_uimi_search_record(void*, void*, void*, dsm_item_type **);

#define UIM_HDLR(a,b)  QMI_SVC_HDLR( (uint16)a, (qmi_svc_hdlr_ftype)b )

static qmi_svc_cmd_hdlr_type  qmi_uimi_cmd_callbacks[] =
{
  UIM_HDLR( UIMI_CMD_VAL_RESET,                       qmi_uimi_reset),
  UIM_HDLR( UIMI_CMD_VAL_READ_TRANSPARENT,            qmi_uimi_read_transparent),
  UIM_HDLR( UIMI_CMD_VAL_READ_RECORD,                 qmi_uimi_read_record),
  UIM_HDLR( UIMI_CMD_VAL_WRITE_TRANSPARENT,           qmi_uimi_write_transparent),
  UIM_HDLR( UIMI_CMD_VAL_WRITE_RECORD,                qmi_uimi_write_record),
  UIM_HDLR( UIMI_CMD_VAL_GET_FILE_ATTRIBUTES,         qmi_uimi_get_file_attributes),
  UIM_HDLR( UIMI_CMD_VAL_SET_PIN_PROTECTION,          qmi_uimi_set_pin_protection),
  UIM_HDLR( UIMI_CMD_VAL_VERIFY_PIN,                  qmi_uimi_verify_pin),
  UIM_HDLR( UIMI_CMD_VAL_UNBLOCK_PIN,                 qmi_uimi_unblock_pin),
  UIM_HDLR( UIMI_CMD_VAL_CHANGE_PIN,                  qmi_uimi_change_pin),
  UIM_HDLR( UIMI_CMD_VAL_DEPERSONALIZATION,           qmi_uimi_depersonalization),
  UIM_HDLR( UIMI_CMD_VAL_REFRESH_REGISTER,            qmi_uimi_refresh_register),
  UIM_HDLR( UIMI_CMD_VAL_REFRESH_OK,                  qmi_uimi_refresh_ok),
  UIM_HDLR( UIMI_CMD_VAL_REFRESH_COMPLETE,            qmi_uimi_refresh_complete),
  UIM_HDLR( UIMI_CMD_VAL_REFRESH_GET_LAST_EVENT,      qmi_uimi_refresh_get_last_event),
  UIM_HDLR( UIMI_CMD_VAL_EVENT_REG,                   qmi_uimi_event_reg),
  UIM_HDLR( UIMI_CMD_VAL_GET_CARD_STATUS,             qmi_uimi_get_card_status),
  UIM_HDLR( UIMI_CMD_VAL_POWER_DOWN,                  qmi_uimi_power_down),
  UIM_HDLR( UIMI_CMD_VAL_POWER_UP,                    qmi_uimi_power_up),
  UIM_HDLR( UIMI_CMD_VAL_AUTHENTICATE,                qmi_uimi_authenticate),
  UIM_HDLR( UIMI_CMD_VAL_CLOSE_SESSION,               qmi_uimi_close_session),
  UIM_HDLR( UIMI_CMD_VAL_GET_SERVICE_STATUS,          qmi_uimi_get_service_status),
  UIM_HDLR( UIMI_CMD_VAL_SET_SERVICE_STATUS,          qmi_uimi_set_service_status),
  UIM_HDLR( UIMI_CMD_VAL_CHANGE_PROVISIONING_SESSION, qmi_uimi_change_provisioning_session),
  UIM_HDLR( UIMI_CMD_VAL_GET_LABEL,                   qmi_uimi_get_label),
  UIM_HDLR( UIMI_CMD_VAL_GET_CONFIGURATION,           qmi_uimi_get_configuration),
  UIM_HDLR( UIMI_CMD_VAL_SEND_APDU,                   qmi_uimi_send_apdu),
  UIM_HDLR( UIMI_CMD_VAL_SAP_CONNECTION,              qmi_uimi_sap_connection),
  UIM_HDLR( UIMI_CMD_VAL_SAP_REQUEST,                 qmi_uimi_sap_request),
  UIM_HDLR( UIMI_CMD_VAL_LOGICAL_CHANNEL,             qmi_uimi_logical_channel),
  UIM_HDLR( UIMI_CMD_VAL_SUBSCRIPTION_OK_REQ,         qmi_uimi_subscription_ok),
  UIM_HDLR( UIMI_CMD_VAL_GET_ATR,                     qmi_uimi_get_atr),
  UIM_HDLR( UIMI_CMD_VAL_OPEN_LOGICAL_CHANNEL,        qmi_uimi_open_logical_channel),
  UIM_HDLR( UIMI_CMD_VAL_REFRESH_REGISTER_ALL,        qmi_uimi_refresh_register_all),
  UIM_HDLR( UIMI_CMD_VAL_SET_FILE_STATUS,             qmi_uimi_set_file_status),
  UIM_HDLR( UIMI_CMD_VAL_SWITCH_SLOT,                 qmi_uimi_switch_slot),
  UIM_HDLR( UIMI_CMD_VAL_GET_SLOTS_STATUS,            qmi_uimi_get_slots_status),
  UIM_HDLR( UIMI_CMD_VAL_GET_PLMN_NAME_TABLE_INFO,    qmi_uimi_get_plmn_name_table_info),
  UIM_HDLR( UIMI_CMD_VAL_PERSONALIZATION,             qmi_uimi_personalization),
  UIM_HDLR( UIMI_CMD_VAL_INCREASE,                    qmi_uimi_increase),
  UIM_HDLR( UIMI_CMD_VAL_RECOVERY,                    qmi_uimi_recovery),
  UIM_HDLR( UIMI_CMD_VAL_RESELECT,                    qmi_uimi_reselect),
  UIM_HDLR( UIMI_CMD_VAL_SEND_STATUS,                 qmi_uimi_send_status),
  UIM_HDLR( UIMI_CMD_VAL_GET_SIM_PROFILE,             qmi_uimi_get_sim_profile),
  UIM_HDLR( UIMI_CMD_VAL_SET_SIM_PROFILE,             qmi_uimi_set_sim_profile),
  UIM_HDLR( UIMI_CMD_VAL_SUPPLY_VOLTAGE,              qmi_uimi_supply_voltage),
  UIM_HDLR( UIMI_CMD_VAL_DEPERSONALIZATION_SECURE,    qmi_uimi_depersonalization_secure),
  UIM_HDLR( UIMI_CMD_VAL_PERSONALIZATION_SECURE,      qmi_uimi_personalization_secure),
  UIM_HDLR( UIMI_CMD_VAL_EMERGENCY_ONLY,              qmi_uimi_emergency_only),
  UIM_HDLR( UIMI_CMD_VAL_SIMLOCK_CONFIGURATION,       qmi_uimi_simlock_configuration),
  UIM_HDLR( UIMI_CMD_VAL_GBA,                         qmi_uimi_gba),
  UIM_HDLR( UIMI_CMD_VAL_GET_GBA_IMPI,                qmi_uimi_get_gba_impi),
  UIM_HDLR( UIMI_CMD_VAL_REMOTE_UNLOCK,               qmi_uimi_remote_unlock),
  UIM_HDLR( UIMI_CMD_VAL_VERIFY_IMSI,                 qmi_uimi_verify_imsi),
  UIM_HDLR( UIMI_CMD_VAL_GET_EID,                     qmi_uimi_get_eid),
  UIM_HDLR( UIMI_CMD_VAL_DELETE_PROFILE,              qmi_uimi_delete_profile),
  UIM_HDLR( UIMI_CMD_VAL_EUICC_MEMORY_RESET,          qmi_uimi_euicc_memory_reset),
  UIM_HDLR( UIMI_CMD_VAL_ADD_PROFILE,                 qmi_uimi_add_profile),
  UIM_HDLR( UIMI_CMD_VAL_UPDATE_NICKNAME,             qmi_uimi_update_profile_nickname),
  UIM_HDLR( UIMI_CMD_VAL_GET_PROFILE_INFO,            qmi_uimi_get_profile_info),
  UIM_HDLR( UIMI_CMD_VAL_SEARCH_RECORD,               qmi_uimi_search_record)
  /* NOTE: When adding an item to this table, also add it to
qmi_uim_is_command_disabled() */
};


/*---------------------------------------------------------------------------
  QMI instance configurations
---------------------------------------------------------------------------*/
static qmi_uimi_state_type           *qmi_uim_state_ptr = NULL;

/* Prototype of MMGSDI callback function */
static void qmi_uimi_mmgsdi_callback(mmgsdi_return_enum_type status,
                                     mmgsdi_cnf_enum_type    cnf_type,
                                     const mmgsdi_cnf_type  *cnf_ptr);

/* Prototype of SIM Lock callback function */
void qmi_uimi_simlock_callback (
  simlock_result_enum_type                    status,
  const simlock_message_response_data_type  * resp_ptr,
  const void                                * user_data_ptr
);

/* Prototype of UIM recovery callback function */
static void qmi_uimi_recovery_callback(uim_slot_type                     slot,
                                       const void                       *user_data,
                                       uimdrv_recovery_stage_enum_type   recovery_stage);

/* Prototype of GBA callback function */
static void qmi_uimi_gba_callback(
  gba_result_enum_type          status,
  uint32                        request_id,
  const gba_response_data_type *cnf_ptr,
  const void                   *user_data_ptr
);

/* Prototype of LPA callback function */
static void qmi_uimi_lpa_callback
(
  lpa_result_enum_type          status,
  const lpa_response_data_type *cnf_ptr,
  void                         *user_data_ptr
);

/* Prototype of MMGSDI event function */
static void qmi_uim_mmgsdi_evt_cback(const mmgsdi_event_data_type * event);

/* Prototype of LPA event function */
static void qmi_uim_lpa_event_callback(lpa_result_enum_type status, const lpa_event_data_type * event_ptr);

#ifdef FEATURE_UIM_SSM
/* Prototype of SSM callback function */
static void qmi_uim_ssm_cback(ssm_err_t err);
#endif /* FEATURE_UIM_SSM */

/* Prototype of QMI UIM generic message processing */
static void qmi_uim_process_message(void);

/* Prototypes of QMI UIM Framework communication */
static boolean qmi_uimi_send_response(qmi_cmd_buf_type *cmd_buf_p,
                                      dsm_item_type    *msg_ptr);

static boolean qmi_uimi_send_indication(uint8           client_id,
                                        uint16          cmd_type,
                                        dsm_item_type  *ind);

#ifdef FEATURE_UIM_DS_SUBSCRIPTION_MANAGER
/* Prototype for UIMDRV callback for slots related communication */
static void qmi_uim_notify_slots_status_cb(uint8                           num_physical_slots,
                                           const uim_phy_slot_status_type *physical_slot_status);

#endif

/* Prototype of SIM Lock remote SFS callback function */
static simlock_result_enum_type qmi_uim_simlock_remote_sfs_cb (
                                        simlock_file_operation_enum_type              operation,
                                        simlock_file_type                             file,
                                        simlock_token_id_type                         token,
                                        const simlock_data_type                    *  simlock_data_ptr,
                                        simlock_remote_sfs_response_cb_type           simlock_resp_cb);

#ifdef FEATURE_GSTK
/* Prototype of GSTK OTASP registration callback function */
static void qmi_uimi_otasp_reg_callback(
  gstk_status_enum_type      gstk_reg_status,
  gstk_client_ref_data_type  user_data
);

/* Prototype of GSTK OTASP status callback function */
static void qmi_uimi_otasp_status_callback(
  gstk_slot_id_enum_type       slot,
  gstk_otasp_act_status_enum_type  status
);
#endif /* FEATURE_GSTK */

/* Prototype of SIM Lock callback function */
static void qmi_uimi_simlock_set_remote_sfs_callback (
  simlock_result_enum_type                    status,
  const void                                * user_data_ptr
);

/* Prototype of remote unlock callback function */
static void qmi_uimi_remote_unlock_callback (
  simlock_result_enum_type                    status,
  const simlock_data_type                     resp_data,
  const void                                * user_data_ptr
);

/* Prototype of simlock temporary unlock callback function */
static void qmi_uimi_simlock_temporary_unlock_callback
(
  simlock_result_enum_type                    status,
  const simlock_message_response_data_type  * resp_ptr,
  const void                                * user_data_ptr
);

/*===========================================================================

                             EXTERNAL FUNCTIONS

===========================================================================*/

/*===========================================================================
FUNCTION QMI_UIM_DIAG_ACCESS_CHECK_CB()

DESCRIPTION
  This function is called by the Diag module as a result of any Diag access
  of the QMI_UIM EFS directory. It is initially registered with Diag for
  knowing the access of QMI_UIM EFS directory.

PARAMETERS
  file_name_ptr: Name of the file that needs to be permitted
  op_type      : File operation type

RETURN VALUE
  TRUE:  If we want to allow access
  FALSE: If we want to reject access

DEPENDENCIES
  QMI UIM service must be registered with Diag module via
  diag_fs_register_access_check API.

SIDE EFFECTS
  None

===========================================================================*/
static boolean qmi_uim_diag_access_check_cb
(
  char      * file_name_ptr,
  uint32      op_type
)
{
  uint16                       filename_length = 0;
  uint8                        nv_file_count   = 0;
  uint8                        i               = 0;
  uint32                       nv_item         = 0;
#ifdef FEATURE_UIM_SSM
  ssm_perm_data_t              ssm_perm        = QMI_UIM_SSM_CMD_DISALLOW;
  ssm_err_t                    ssm_err         = E_SSM_SUCCESS;
#else
  mmgsdi_return_enum_type      mmgsdi_status   = MMGSDI_ERROR;
  mmgsdi_cached_nv_item_data   cached_nv_item;
#endif /* FEATURE_UIM_SSM */
  char                       * path_buf_ptr    = NULL;
  char                       * input_path_ptr  = NULL;

  UIM_MSG_HIGH_0("qmi_uim_diag_access_check_cb");
  ASSERT(qmi_uim_global_ptr != NULL);

  if (file_name_ptr == NULL)
  {
    /* Not sure what the file is, so allow this diag request */
    UIM_MSG_HIGH_0("file_name_ptr is NULL");
    return TRUE;
  }

  MSG_SPRINTF_2( MSG_SSID_DFLT, MSG_LEGACY_HIGH,
                 "Access request to NV file: %s, op_type: 0x%x",
                 file_name_ptr, op_type);

  /* The conditions for rejecting are these:
     1. File name is of interest to us
     2. Operation is one of write, delete, rename, chmod
     3. Device is not in FTM mode */

  nv_file_count = sizeof(qmi_uim_restricted_nv_files) / sizeof(qmi_uim_restricted_nv_files_type);

  path_buf_ptr = (char*)uimqmi_malloc(FS_DIAG_ACCESS_PATH_MAX+1);
  if (path_buf_ptr == NULL)
  {
    return FALSE;
  }

  /* efs_realpath() will return NULL upon error but an error can mean a number
     of things, for example, if it is not able to find the file path specified
     in the efs which is not really an error in this case. Even in case of error
     however, the second parameter will return the parsed file path or at least
     the best it was able to do until it ran into an error. For our purposes we
     can ignore the return value because the subsequent comparisons will fail
     anyways if the path was not parsed correctly. */
  (void)efs_realpath (file_name_ptr, path_buf_ptr);

  filename_length = (uint16)strnlen(path_buf_ptr, FS_DIAG_ACCESS_PATH_MAX);

  input_path_ptr = (char*)uimqmi_malloc(filename_length+1);
  if (input_path_ptr == NULL)
  {
    uimqmi_free(path_buf_ptr);
    return FALSE;
  }

  (void)memscpy(input_path_ptr,
                filename_length+1,
                path_buf_ptr,
                filename_length+1);

  for (i = 0; i < nv_file_count; i++)
  {
    memset(path_buf_ptr, 0x00, (FS_DIAG_ACCESS_PATH_MAX+1));
    (void)efs_realpath (qmi_uim_restricted_nv_files[i].nv_filename, path_buf_ptr);

    if (filename_length == (uint16)strnlen(path_buf_ptr, FS_DIAG_ACCESS_PATH_MAX) &&
        (memcmp((void*)path_buf_ptr,
                (void*)input_path_ptr,
                filename_length) == 0))
    {
      /* found index */
      nv_item = qmi_uim_restricted_nv_files[i].nv_item;
      break;
    }
  }

  uimqmi_free(path_buf_ptr);
  path_buf_ptr = NULL;
  uimqmi_free(input_path_ptr);
  input_path_ptr = NULL;

  if (i >= nv_file_count )
  {
    /* File name is not of interest to us, allow access */
    return TRUE;
  }

  if ( (op_type == DIAG_FS_CHECK_OPEN) ||
       (op_type == DIAG_FS_CHECK_DISP_DIRS) ||
       (op_type == DIAG_FS_CHECK_DISP_FILES) ||
       (op_type == DIAG_FS_CHECK_ITERATE) ||
       (op_type == DIAG_FS_CHECK_READ) ||
       (op_type == DIAG_FS_CHECK_GET_ATTRIB) ||
       (op_type == DIAG_FS_CHECK_CLOSE) ||
       (op_type == DIAG_FS_CHECK_OPENDIR) ||
       (op_type == DIAG_FS_CHECK_READDIR) ||
       (op_type == DIAG_FS_CHECK_CLOSEDIR) ||
       (op_type == DIAG_FS_CHECK_STAT) ||
       (op_type == DIAG_FS_CHECK_LSTAT) ||
       (op_type == DIAG_FS_CHECK_FSTAT) ||
       (op_type == DIAG_FS_CHECK_STATFS) ||
       (op_type == DIAG_FS_CHECK_ACCESS))
  {
    /* Allow access */
    return TRUE;
  }

#ifdef FEATURE_UIM_SSM
  if( qmi_uim_global_ptr->ssm_info.qmi_uim_ssm_init_err != E_SSM_SUCCESS )
  {
    UIM_MSG_HIGH_1("SSM init error: 0x%x",
                   qmi_uim_global_ptr->ssm_info.qmi_uim_ssm_init_err);
    return FALSE;
  }

  ssm_err = ssm_get_perm(&ssm_perm,
                         QMI_UIM_SSM_NUM_ARGS,
                         qmi_uim_global_ptr->ssm_info.qmi_uim_ssm_id,
                         nv_item);

  if ( ssm_err != E_SSM_SUCCESS )
  {
    UIM_MSG_HIGH_1("Failed to get ssm perm 0x%x", ssm_err);
    return FALSE;
  }

  if (ssm_perm == QMI_UIM_SSM_CMD_DISALLOW)
  {
    UIM_MSG_HIGH_1("SSM returned deny access to NV file %d", nv_item);
    return FALSE;
  }
#else
  /* Check if FTM mode is enabled  */
  memset(&cached_nv_item, 0, sizeof(mmgsdi_cached_nv_item_data));
  cached_nv_item.nv_item_enum            = MMGSDI_NV_FTM_MODE_I;
  mmgsdi_status = mmgsdi_get_cached_nv_item(&cached_nv_item);

  UIM_MSG_HIGH_1("ftm_mode value: 0x%x", cached_nv_item.nv_item_data.ftm_mode);

  if ((mmgsdi_status == MMGSDI_SUCCESS) &&
      (cached_nv_item.nv_item_data.ftm_mode == 0x00))
  {
    UIM_MSG_HIGH_0("Denying access to the EFS file");
    return FALSE;
  }
#endif /* FEATURE_UIM_SSM */

  return TRUE;
} /* qmi_uim_diag_access_check_cb */


/*===========================================================================
  FUNCTION QMI_UIM_IS_EUICC_CARD

  DESCRIPTION
    Determine whether the card is eUICC or not

  PARAMETERS
    mmgsdi slot

  RETURN VALUE
    boolean vaue

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_uim_is_euicc_card
(
  mmgsdi_slot_id_enum_type   mmgsdi_slot
)
{
  qmi_error_e_type               errval          = QMI_ERR_NONE;
  uint8                          slot_index      = 0;

  errval = uimqmi_mmgsdi_slot_to_slot_index(mmgsdi_slot, &slot_index);
  if (errval != QMI_ERR_NONE        ||
      qmi_uim_global_ptr == NULL    ||
      qmi_uim_global_ptr->is_euicc_card[slot_index] == FALSE)
  {
    return FALSE;
  }
  return TRUE;
} /* qmi_uim_is_euicc_card */


/*===========================================================================
  FUNCTION QMI_UIM_EFS_READ_FILE

  DESCRIPTION
    Generic function called by QMI UIM to read a file from EFS. This function
    will validate the input parameters and return the EFS data requested.

  PARAMETERS
    file_name_ptr: Name of the file that needs to be read.
    data_len_ptr : Data length of the read file.

  DEPENDENCIES
    None

  RETURN VALUE
    pointer of the buffer where the EFS data is read. Otherwise, return  NULL
    if any failure in opening or reading the file from EFS.

  SIDE EFFECTS
    None
===========================================================================*/
static char * qmi_uim_efs_read_file
(
  const char  * file_name_ptr,
  uint32      * data_len_ptr
)
{
  struct fs_stat   file_stat       = {0};
  int              file_descriptor = 0;
  char           * file_buffer_ptr = NULL;

  if(file_name_ptr == NULL || data_len_ptr == NULL)
  {
    return NULL;
  }

  if(efs_stat(file_name_ptr, &file_stat) != 0 || file_stat.st_size == 0)
  {
    UIM_MSG_LOW_0("efs_stat procedure failed");
    return NULL;
  }

  /* Allocate memory for file buffer */
  file_buffer_ptr = (char *)uimqmi_malloc(file_stat.st_size);
  if(file_buffer_ptr == NULL)
  {
    return NULL;
  }

  /* Open the file in EFS for Read Only */
  file_descriptor = efs_open(file_name_ptr, O_RDONLY);

  if(file_descriptor < 0)
  {
    UIM_MSG_LOW_0("efs_open procedure failed ");
    uimqmi_free(file_buffer_ptr);
    return NULL;
  }

  /* Read the file into buffer provided */
  if (efs_read(file_descriptor, file_buffer_ptr, file_stat.st_size) !=
       file_stat.st_size)
  {
    UIM_MSG_LOW_0("efs_read procedure failed ");
    uimqmi_free(file_buffer_ptr);
    (void)efs_close(file_descriptor);
    return NULL;
  }

  *data_len_ptr = (uint32)file_stat.st_size;

  /* Close the file */
  (void)efs_close(file_descriptor);

  return file_buffer_ptr;
}  /* qmi_uim_efs_read_file */


/*===========================================================================
  FUNCTION QMI_UIM_ENCRYPT_KS_NAF_REQUIRED()

  DESCRIPTION
    Reads the FQDN entries from the white / black list in the EFS. If white
    list is not available then we fallback to read FQDN entries in the black
    list. This list (white / black) of FQDN entries are checked against the
    input FQDN data and if it matches with any of the entry then encryption of
    ks_naf is done in the response.

  PARAMETERS
    req_fqdn_data_ptr: FQDN data pointer

  RETURN VALUE
    Boolean that indicates whether encryption is required for ks_naf
      TRUE: Encryption is required for ks_naf.
      FALSE: No encryption is done.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_uim_encrypt_ks_naf_required
(
  gba_naf_fqdn_type  * req_fqdn_data_ptr
)
{
  uint16   fqdn_buf_index                  = 0;
  char   * fqdn_list_file_data_ptr         = NULL;
  uint32   efs_data_len                    = 0;
  boolean  result                          = TRUE;
  boolean  is_white_list                   = TRUE;

  if(req_fqdn_data_ptr == NULL)
  {
    return FALSE;
  }

  /* Read the FQDN list file as follows:
     1) Check if white list FQDN file is present in the EFS.
     2) If the white list FQDN file is not present then try to read the black
        list FQDN from the EFS.
     3) If the black list FQDN read also fails then return FALSE as no FQDN
        list is available & encryption of ks_naf is not required */
  fqdn_list_file_data_ptr = qmi_uim_efs_read_file(QMI_UIM_CONFIG_GBA_FQDN_WHITE_LIST,
                                                  &efs_data_len);
  if(fqdn_list_file_data_ptr == NULL)
  {
    UIM_MSG_MED_0("White list FQDN is not available. Falling back to Black list FQDN");

    fqdn_list_file_data_ptr = qmi_uim_efs_read_file(QMI_UIM_CONFIG_GBA_FQDN_BLACK_LIST,
                                                    &efs_data_len);
    if(fqdn_list_file_data_ptr == NULL)
    {
      UIM_MSG_HIGH_0("No FQDN list is available");
      return FALSE;
    }

    /* As white list is not available and we are successful in reading black
       list we make is_white_list to FALSE  & result re-initialized to FALSE.
       If FQDN entry does not match with any FQDN in black list then we return
       this result (FALSE) and we don't encrypt ks_naf */
    is_white_list = FALSE;
    result = FALSE;
  }

  /* Convert the requested FQDN to lower case */
  for (fqdn_buf_index = 0; fqdn_buf_index < req_fqdn_data_ptr->data_len; fqdn_buf_index++)
  {
    req_fqdn_data_ptr->data[fqdn_buf_index] =
      QMI_UIM_LOWER_CASE(req_fqdn_data_ptr->data[fqdn_buf_index]);
  }

  /* Convert the FQDN buffer to lower case */
  for(fqdn_buf_index = 0; fqdn_buf_index < efs_data_len; fqdn_buf_index++)
  {
    fqdn_list_file_data_ptr[fqdn_buf_index] =
      QMI_UIM_LOWER_CASE(fqdn_list_file_data_ptr[fqdn_buf_index]);
  }

  /* Parse the FQDN data */
  fqdn_buf_index = 0;
  while(fqdn_buf_index < efs_data_len)
  {
    uint8   fqdn_start_index = fqdn_buf_index;
    uint8   fqdn_end_index   = fqdn_buf_index;
    uint16  fqdn_len         = 0;

    while(fqdn_end_index < efs_data_len &&
          fqdn_list_file_data_ptr[fqdn_end_index] != ';')
    {
      fqdn_end_index++;
    }

    /* If there is no FQDN entry between two delimiters(;;) then we continue
       to next FQDN entry */
    if(fqdn_end_index == fqdn_buf_index)
    {
      fqdn_buf_index++;
      continue;
    }

    /* update the fqdn_buf_index to point to next FQDN entry in the EFS buffer */
    fqdn_buf_index = fqdn_end_index + 1;

    /* Update the fqdn_end_index to last character of the FQDN entry */
    fqdn_end_index--;

    /* Skip leading spaces if any */
    while(fqdn_list_file_data_ptr[fqdn_start_index] == ' ' &&
          fqdn_start_index < fqdn_end_index)
    {
      fqdn_start_index++;
    }

    /* Skip trailing spaces if any */
    while(fqdn_list_file_data_ptr[fqdn_end_index] == ' ' &&
          fqdn_end_index > fqdn_start_index)
    {
      fqdn_end_index--;
    }

    /* When there are only spaces in FQDN entry then goto next FQDN entry*/
    if(fqdn_start_index == fqdn_end_index &&
       fqdn_list_file_data_ptr[fqdn_start_index] == ' ')
    {
      continue;
    }

    fqdn_len = fqdn_end_index - fqdn_start_index + 1;

    if(req_fqdn_data_ptr->data_len == fqdn_len &&
       memcmp(req_fqdn_data_ptr->data, &fqdn_list_file_data_ptr[fqdn_start_index], fqdn_len) == 0)
    {
      /* FQDN has matched. If the list is white list then return FALSE and
         if it is black list then send TRUE to send encrypted ks_naf */
      if(is_white_list)
      {
        result = FALSE;
      }
      else
      {
        result = TRUE;
      }
      break;
    }
  }

  uimqmi_free(fqdn_list_file_data_ptr);

  return result;
} /* qmi_uim_encrypt_ks_naf_required */


/*===========================================================================
  FUNCTION QMI_UIM_READ_CONFIGURATION_APDU_AID_LIST()

  DESCRIPTION
    Reads the configuration value for APDU security AID list from the EFS.
    This is the default value set based on what is read:
    1. If NV item is not present - empty black list is assumed
    2. Invalid value for type - empty black list is assumed

  PARAMETERS
    apdu_sec_aid_info_ptr: Pointer to the APDU security AID info

  RETURN VALUE
    Boolean that indicates successful read or failure

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_uim_read_configuration_apdu_aid_list
(
  qmi_uimi_apdu_sec_aid_info * apdu_sec_aid_info_ptr
)
{
  uint16                   i                                    = 0;
  uint16                   j                                    = 0;
  uint16                   offset                               = 0;
  uint8                    aid_len                              = 0;
  uint8                  * aid_list_file_data_ptr               = NULL;
  uint16                   aid_list_file_data_len               = 0;
  uint32                   alloc_size                           = 0;
  uint8           isdr_aid_initials[]                           = {0xA0, 0x00, 0x00, 0x05,
                                                                   0x59, 0x10, 0x10};
  qmi_uimi_aid_list_type   isdr_add_in_list                     = UIM_AID_LIST_WHITE_LIST;
  uint8                    lpa_ap_support_nv_content[UIM_COMMON_LPA_EFS_ITEM_LEN]
                                                                = {0};

  ASSERT(apdu_sec_aid_info_ptr);

  if (qmi_uim_global_ptr == NULL)
  {
    return FALSE;
  }

  /* Default values if NV item is not present - empty black list */
  apdu_sec_aid_info_ptr->aid_count     = 0;
  apdu_sec_aid_info_ptr->aid_list_ptr  = NULL;
  apdu_sec_aid_info_ptr->aid_list_type = UIM_AID_LIST_BLACK_LIST;

  /* This is the max length that is supported in the NV item file:
     type (uint8) + list_size (uint8) + max AID entries times each entry
     In NV, each AID entry can hold a max of QMI_UIM_APDU_SEC_NV_MAX_AID_LEN bytes */
  aid_list_file_data_len = sizeof(uint8) + sizeof(uint8) +
    (QMI_UIM_APDU_SEC_NV_MAX_AID_ENTRIES * (sizeof(uint8) + QMI_UIM_APDU_SEC_NV_MAX_AID_LEN));

  /* Allocate sufficient memory for the file contents */
  aid_list_file_data_ptr = uimqmi_malloc(aid_list_file_data_len);
  if (aid_list_file_data_ptr == NULL)
  {
    return FALSE;
  }

  memset(aid_list_file_data_ptr, 0, aid_list_file_data_len);

  /* Read the file. If read fails, means there is no list present.
     We need to block ISDR-AID from AP if the NV 73849 byte 2
     is not set */
  if (uim_common_efs_read(
        UIM_COMMON_EFS_UIMQMI_QMI_UIM_CONFIG_APDU_SEC_AID_LIST,
        UIM_COMMON_EFS_ITEM_FILE_TYPE,
        UIM_COMMON_EFS_DEVICE,
        aid_list_file_data_ptr,
        aid_list_file_data_len)!= UIM_COMMON_EFS_SUCCESS)
  {
    UIM_MSG_ERR_0( "Error in efs_get for APDU security AID list");
    uimqmi_free(aid_list_file_data_ptr);
    aid_list_file_data_ptr = NULL;
    apdu_sec_aid_info_ptr->aid_list_type = UIM_AID_LIST_BLACK_LIST;
    isdr_add_in_list = UIM_AID_LIST_BLACK_LIST;
  }
  else
  {
    /* Start parsing & update the global */
    UIM_MSG_HIGH_2( "APDU security AID list type: 0x%x, list count: 0x%x",
                    *aid_list_file_data_ptr,
                    *(aid_list_file_data_ptr + 1));
    switch(*aid_list_file_data_ptr)
    {
      case 0:
        apdu_sec_aid_info_ptr->aid_list_type = UIM_AID_LIST_WHITE_LIST;
        break;
      case 1:
        apdu_sec_aid_info_ptr->aid_list_type = UIM_AID_LIST_BLACK_LIST;
        break;
      default:
        uimqmi_free(aid_list_file_data_ptr);
        return FALSE;
    }

    /* Second byte has the number of AID entries */
    apdu_sec_aid_info_ptr->aid_count = *(aid_list_file_data_ptr + 1);

    if (apdu_sec_aid_info_ptr->aid_count == 0)
    {
      uimqmi_free(aid_list_file_data_ptr);
      aid_list_file_data_ptr = NULL;

      /* Since the list count is 0, if it is Blacklist
         then add ISDR-AID to the blacklist */
      if (apdu_sec_aid_info_ptr->aid_list_type == UIM_AID_LIST_BLACK_LIST)
      {
        isdr_add_in_list = UIM_AID_LIST_BLACK_LIST;
      }
      else
      {
        return FALSE;
      }
    }
  }

  /* Allocate memory based on the number of AID entries. 1 extra entry space
     is allocated for ISD-R in case of Blacklist because access to ISD-R is
     only through LPA module. Add ISD-R AID in Blacklist explicitly.
     ISD-R AID: A0 00 00 05 59 10 10 FF FF FF FF 89 00 00 01 00 */
  alloc_size = apdu_sec_aid_info_ptr->aid_count * sizeof(qmi_uim_aid_entry_type);

  /* Check LPA support EFS. Byte 2 determines whether LPA functionality
     is controlled by APPs or not. If yes, then ISDR needs to be added
     in Whitelist. If No, then ISDR needs to be added in Blacklist */
  if ((uim_common_efs_read(UIM_COMMON_EFS_LPA_SUPPORT,
                            UIM_COMMON_EFS_ITEM_FILE_TYPE,
                            UIM_COMMON_EFS_CONTEXT_0,
                           (uint8 *)lpa_ap_support_nv_content,
                           sizeof(lpa_ap_support_nv_content)) == UIM_COMMON_EFS_SUCCESS) &&
       lpa_ap_support_nv_content[UIM_COMMON_LPA_EFS_ITEM_LPA_ON_AP_OR_MODEM_INDEX] != 0x00)
  {
    isdr_add_in_list  = UIM_AID_LIST_WHITE_LIST;
  }
  else
  {
    isdr_add_in_list  = UIM_AID_LIST_BLACK_LIST;
  }

  if ((apdu_sec_aid_info_ptr->aid_list_type == UIM_AID_LIST_BLACK_LIST &&
       isdr_add_in_list == UIM_AID_LIST_BLACK_LIST)                         ||
      (apdu_sec_aid_info_ptr->aid_list_type == UIM_AID_LIST_WHITE_LIST &&
       isdr_add_in_list == UIM_AID_LIST_WHITE_LIST))
  {
    alloc_size += sizeof(qmi_uim_aid_entry_type);
  }

  if (alloc_size == 0)
  {
    return FALSE;
  }

  apdu_sec_aid_info_ptr->aid_list_ptr = uimqmi_malloc(alloc_size);

  if (apdu_sec_aid_info_ptr->aid_list_ptr == NULL)
  {
    uimqmi_free(aid_list_file_data_ptr);
    apdu_sec_aid_info_ptr->aid_count     = 0;
    return FALSE;
  }

  memset(apdu_sec_aid_info_ptr->aid_list_ptr, 0, alloc_size);

  /* If aid_count retrieved from EFS is non-zero then only add the AIDs
     else directly add the ISDR-AID to blacklist/whitelist */
  if (apdu_sec_aid_info_ptr->aid_count > 0 &&
      aid_list_file_data_ptr != NULL)
  {
    offset = QMI_UIM_APDU_SEC_NV_MAX_AID_LEN + sizeof(aid_len);

    /* Parse & fill up each AID entry, 2nd byte onwards must have the AID entries */
    for (i = 2, j = 0;
           (i + offset) <= aid_list_file_data_len && j < apdu_sec_aid_info_ptr->aid_count;
         i += offset)
    {
      aid_len = *(aid_list_file_data_ptr + i);

      /* Check individual AID length & skip it in case of incorrect length */
        if (aid_len > 0 && aid_len <= MMGSDI_MAX_AID_LEN)
      {
        apdu_sec_aid_info_ptr->aid_list_ptr[j].aid.data_len = aid_len;
        (void)memscpy((void*)apdu_sec_aid_info_ptr->aid_list_ptr[j].aid.data_ptr,
                      sizeof(apdu_sec_aid_info_ptr->aid_list_ptr[j].aid.data_ptr),
               (void*)(aid_list_file_data_ptr + i + sizeof(aid_len)),
                      apdu_sec_aid_info_ptr->aid_list_ptr[j].aid.data_len);

        apdu_sec_aid_info_ptr->aid_list_ptr[j].from_efs = TRUE;
        j++;
      }
      else
      {
        break;
      }
    }
  }

  if ((apdu_sec_aid_info_ptr->aid_list_type == UIM_AID_LIST_BLACK_LIST &&
         isdr_add_in_list == UIM_AID_LIST_BLACK_LIST)                         ||
        (apdu_sec_aid_info_ptr->aid_list_type == UIM_AID_LIST_WHITE_LIST &&
         isdr_add_in_list == UIM_AID_LIST_WHITE_LIST))
  {
    apdu_sec_aid_info_ptr->aid_list_ptr[j].aid.data_len = sizeof(isdr_aid_initials);
    (void)memscpy((void *)apdu_sec_aid_info_ptr->aid_list_ptr[j].aid.data_ptr,
                  sizeof(apdu_sec_aid_info_ptr->aid_list_ptr[j].aid.data_ptr),
                  (void *)isdr_aid_initials,
                  sizeof(isdr_aid_initials));
    apdu_sec_aid_info_ptr->aid_list_ptr[j].from_efs = FALSE;

    apdu_sec_aid_info_ptr->aid_count++;
  }

  return TRUE;
} /* qmi_uim_read_configuration_apdu_aid_list */


/*===========================================================================
  FUNCTION QMI_UIM_READ_CONFIGURATION()

  DESCRIPTION
    Reads the configuration value for silent PIN1 verification from the EFS.
    If NV item is not present or has an invalid value, we do silent PIN1
    verification by default.

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_read_configuration
(
  boolean                                            * silent_pin1_supported_ptr,
  qmi_uim_apdu_sec_restr_type                        * apdu_sec_value_ptr,
  qmi_uimi_apdu_sec_aid_info                         * apdu_sec_aid_info_ptr,
  boolean                                            * close_channel_ind_pref_ptr,
  qmi_uim_auth_sec_restr_type                        * auth_sec_restr_value_ptr,
  boolean                                            * sap_sec_restr_supported_ptr,
  qmi_uim_simlock_status_waiting_for_valid_card_type * simlock_status_for_valid_card_ptr
)
{
  uim_common_efs_status_enum_type status        = UIM_COMMON_EFS_ERROR;
  uint8                           value         = 0;
  uint8                           success_count = 0;

  ASSERT(silent_pin1_supported_ptr);
  ASSERT(apdu_sec_value_ptr);
  ASSERT(close_channel_ind_pref_ptr);
  ASSERT(auth_sec_restr_value_ptr);
  ASSERT(sap_sec_restr_supported_ptr);
  ASSERT(simlock_status_for_valid_card_ptr);

  /* Set default values */
  *silent_pin1_supported_ptr         = TRUE;
  *apdu_sec_value_ptr                = QMI_UIM_APDU_SEC_RESTRICTIONS_ALL;
  *close_channel_ind_pref_ptr        = FALSE;
#ifdef FEATURE_CUST_1
  *auth_sec_restr_value_ptr          = QMI_UIM_AUTH_SEC_RESTRICTIONS_NONE;
#else
  *auth_sec_restr_value_ptr          = QMI_UIM_AUTH_SEC_RESTRICTIONS_II_CLA;
#endif /* FEATURE_CUST_1 */
  *sap_sec_restr_supported_ptr       = TRUE;
#ifdef FEATURE_SIMLOCK
  *simlock_status_for_valid_card_ptr = QMI_UIM_SIMLOCK_STATUS_DEFAULT;
#endif /* FEATURE_SIMLOCK */

  /* Retrieve PIN1 configuration from NV file */
  status = uim_common_efs_read(
             UIM_COMMON_EFS_UIMQMI_QMI_UIM_CONFIG_SILENT_PIN1_FILE,
             UIM_COMMON_EFS_ITEM_FILE_TYPE,
             UIM_COMMON_EFS_DEVICE,
             &value,
             sizeof(uint8));
  if (status == UIM_COMMON_EFS_SUCCESS)
  {
    success_count++;

    switch(value)
    {
      case 0:
        *silent_pin1_supported_ptr = FALSE;
        break;
      case 1:
      default:
        /* Nothing to do */
        break;
    }
  }

  /* Retrieve APDU security restrictions value from NV file */
  status = uim_common_efs_read(
             UIM_COMMON_EFS_UIMQMI_QMI_UIM_CONFIG_APDU_SEC_RESTR,
             UIM_COMMON_EFS_ITEM_FILE_TYPE,
             UIM_COMMON_EFS_DEVICE,
             &value,
             sizeof(uint8));
  if (status == UIM_COMMON_EFS_SUCCESS)
  {
    success_count++;

    switch(value)
    {
      case 0:
        *apdu_sec_value_ptr = QMI_UIM_APDU_SEC_RESTRICTIONS_NONE;
        break;
      case 1:
        *apdu_sec_value_ptr = QMI_UIM_APDU_SEC_RESTRICTIONS_ALL;
        break;
      case 2:
        *apdu_sec_value_ptr = QMI_UIM_APDU_SEC_RESTRICTIONS_II_CLA;
        break;
      default:
        /* Nothing to do, default value is all restrictions */
        break;
    }
  }

  /* Retrieve APDU security AID list info from NV file */
  if (qmi_uim_read_configuration_apdu_aid_list(apdu_sec_aid_info_ptr))
  {
    success_count++;
  }

  /* Retrieve close channel indication preference from NV file */
  status = uim_common_efs_read(
             UIM_COMMON_EFS_UIMQMI_QMI_UIM_CONFIG_CLOSE_CHANNEL_SYNC,
             UIM_COMMON_EFS_ITEM_FILE_TYPE,
             UIM_COMMON_EFS_DEVICE,
             &value,
             sizeof(uint8));
  if (status == UIM_COMMON_EFS_SUCCESS)
  {
    success_count++;

    switch(value)
    {
      case 1:
        *close_channel_ind_pref_ptr = TRUE;
        break;
      case 0:
      default:
        /* Nothing to do */
        break;
    }
  }

  /* Retrieve AUTHENTICATE security restrictions value from NV file */
  status = uim_common_efs_read(
             UIM_COMMON_EFS_UIMQMI_QMI_UIM_CONFIG_AUTH_SEC_RESTR,
             UIM_COMMON_EFS_ITEM_FILE_TYPE,
             UIM_COMMON_EFS_DEVICE,
             &value,
             sizeof(uint8));
  if (status == UIM_COMMON_EFS_SUCCESS)
  {
    success_count++;

    switch(value)
    {
      case 0:
        *auth_sec_restr_value_ptr = QMI_UIM_AUTH_SEC_RESTRICTIONS_NONE;
        break;
      case 1:
        *auth_sec_restr_value_ptr = QMI_UIM_AUTH_SEC_RESTRICTIONS_ALL;
        break;
      case 2:
        *auth_sec_restr_value_ptr = QMI_UIM_AUTH_SEC_RESTRICTIONS_II_CLA;
        break;
      default:
        /* Nothing to do */
        break;
    }
  }

  /* Retrieve SAP security restrictions value from NV file */
  status = uim_common_efs_read(
             UIM_COMMON_EFS_UIMQMI_QMI_UIM_CONFIG_SAP_SEC_RESTR,
             UIM_COMMON_EFS_ITEM_FILE_TYPE,
             UIM_COMMON_EFS_DEVICE,
             &value,
             sizeof(uint8));
  if (status == UIM_COMMON_EFS_SUCCESS)
  {
    success_count++;

    switch(value)
    {
      case 0:
        *sap_sec_restr_supported_ptr = FALSE;
        break;
      case 1:
      default:
        /* Nothing to do */
        break;
    }
  }

#ifdef FEATURE_SIMLOCK
  /* Retrieve simlock mode value from NV file */
  status = uim_common_efs_read(
             UIM_COMMON_EFS_UIMQMI_QMI_UIM_SIMLOCK_STATUS_WAITING_FOR_VALID_CARD,
             UIM_COMMON_EFS_ITEM_FILE_TYPE,
             UIM_COMMON_EFS_DEVICE,
             &value,
             sizeof(uint8));

  if (status == UIM_COMMON_EFS_SUCCESS)
  {
    success_count++;
    switch(value)
    {
      case 0:
         break;
      case 1:
        *simlock_status_for_valid_card_ptr =
             QMI_UIM_SIMLOCK_DISPLAY_FOR_VALID_CARD_ON_ANY_SLOT_POLICY;
        break;
      default:
        /* Nothing to do */
        break;
    }
  }
#endif /* FEATURE_SIMLOCK */

  UIM_MSG_HIGH_6("Silent PIN1 verification configuration: 0x%x,"
                 "APDU security restrictions configuration: 0x%x,"
                 "Close channel sync preference: 0x%x,"
                 "AUTHENTICATE security restrictions configuration: 0x%x,"
                 "SAP security restrictions configuration: 0x%x"
                 "SIMLOCK status for valid card: 0x%x",
                 *silent_pin1_supported_ptr,
                 *apdu_sec_value_ptr,
                 *close_channel_ind_pref_ptr,
                 *auth_sec_restr_value_ptr,
                 *sap_sec_restr_supported_ptr,
                 *simlock_status_for_valid_card_ptr);

  /* If none of the configuration files were read, it's possible that the directory
     is completely missing... in this case, create it */
  if (success_count == 0)
  {
    uint32                          size       = 0;

    UIM_MSG_HIGH_0( "All configuration files missing");

    /* Create directory for the config file */
    if (uim_common_efs_get_dir_stat(
          UIM_COMMON_EFS_MODEM_CONFIG_DIR1,
          &size) != UIM_COMMON_EFS_SUCCESS)
    {
      (void)uim_common_efs_create_dir(UIM_COMMON_EFS_MODEM_CONFIG_DIR1, 0777);
      (void)uim_common_efs_create_dir(UIM_COMMON_EFS_UIMQMI_QMI_CONFIG_DIR2, 0777);
      (void)uim_common_efs_create_dir(UIM_COMMON_EFS_UIMQMI_QMI_UIM_CONFIG_DIR4, 0777);
    }
    else if (uim_common_efs_get_dir_stat(
          UIM_COMMON_EFS_UIMQMI_QMI_CONFIG_DIR2,
          &size) != UIM_COMMON_EFS_SUCCESS)
    {
      (void)uim_common_efs_create_dir(UIM_COMMON_EFS_UIMQMI_QMI_CONFIG_DIR2, 0777);
      (void)uim_common_efs_create_dir(UIM_COMMON_EFS_UIMQMI_QMI_UIM_CONFIG_DIR4, 0777);
    }
    else if (uim_common_efs_get_dir_stat(
          UIM_COMMON_EFS_UIMQMI_QMI_UIM_CONFIG_DIR4,
          &size) != UIM_COMMON_EFS_SUCCESS)
    {
      (void)uim_common_efs_create_dir(UIM_COMMON_EFS_UIMQMI_QMI_UIM_CONFIG_DIR4, 0777);
    }
  }
} /* qmi_uim_read_configuration */


#ifdef FEATURE_UIM_SSM
/*===========================================================================
  FUNCTION QMI_UIM_SSM_INIT()

  DESCRIPTION
  To register with the Security Services Module.  SSM may access filesystem
  during registration, so ssm_client_init_func() may return
  'E_SSM_CLIENT_INIT_IN_PROCESS' immediately.  QMI UIM will be notified when
  initialization is complete via the qmi_uim_ssm_cback() callback, by returing
  'E_SSM_SUCCESS' or some error code.

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_ssm_init
(
   void
)
{
  /* qmi_uim_ssm_id : uint32 :: Always returns a valid client id, whether
  initialization was succesful or not. It is recommended that clients
  check the return value of this init call before using client id.

  With fallback buffer == NULL, ssm client initialization returns
  error unless a valid ssm permission file for current ssm mode exists.
  QMI UIM blocks NV update if ssm client is not ready.

  For QMI UIM, SSM will look for ssm_uim_<mode_num>.ssm

  Following is an example of perm file to allow permission for QMI UIM
  restricted NVs:
  "65954|65954|0|67285|67285|0|67312|67312|0|67317|67317|0|70283|70284|0|71557|71557|0|"
  */
  ssm_err_t    ssm_err = E_SSM_CLIENT_NOT_INITIALIZED;

  ssm_err = ssm_client_init_func( "ssm_uim",
                                  QMI_UIM_SSM_KEY_NUM,
                                  QMI_UIM_SSM_CMD_DISALLOW,
                                  SSM_UINT32,
                                  qmi_uim_ssm_cback,
                                  &(qmi_uim_global_ptr->ssm_info.qmi_uim_ssm_id),
                                  NULL,
                                  0);

  if( (ssm_err != E_SSM_SUCCESS) &&
      (ssm_err != E_SSM_CLIENT_INIT_IN_PROCESS) )
  {
    UIM_MSG_ERR_1("SSM Initialization Failed 0x%x", ssm_err);
  }
} /* qmi_uim_ssm_init */
#endif /* FEATURE_UIM_SSM */


/*===========================================================================
  FUNCTION QMI_UIM_SERVICE_INITIALIZE()

  DESCRIPTION
    Initializes the QMI UIM module. This function is executed only once,
    at the very beginning.

  PARAMETERS
    None

  RETURN VALUE
    Boolean to indicate success or failure

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_uim_service_initialize
(
  void
)
{
  uim_hw_slot_info_type        slot_info;
  qmi_uim_card_info_type     * temp_card_info_ptr = NULL;
  mmgsdi_cached_nv_item_data   cached_nv_item;
  uint16                       i                  = 0;
  mmgsdi_return_enum_type      mmgsdi_status      = MMGSDI_SUCCESS;

#ifdef FEATURE_GSTK
  gstk_status_enum_type        gstk_status        = GSTK_STATUS_MAX;
#endif /* FEATURE_GSTK */

  memset(&cached_nv_item, 0, sizeof(cached_nv_item));

  if (qmi_uim_global_ptr == NULL)
  {
  /* QMI UIM global variable expected to be allocated in the pre_init phase,
     so it should be present now. */
    return FALSE;
  }

  if (qmi_uim_global_ptr->card_state.num_slots > 0)
  {
    /* This indicates that function was already executed before, which is not allowed. */
    return FALSE;
  }

  /* Get count of available slots */
  memset(&slot_info, 0x00, sizeof(slot_info));
  slot_info = uim_get_hw_slot_info();
  for (i = 0; i < UIM_MAX_NUMBER_INSTANCES &&
              qmi_uim_global_ptr->card_state.num_slots < QMI_UIM_MAX_CARD_COUNT; i++)
  {
    if((slot_info.slot_status[i].slot_available) &&
       (slot_info.slot_status[i].slot_enabled))
    {
      qmi_uim_global_ptr->card_state.num_slots++;
    }
  }

  if(qmi_uim_global_ptr->card_state.num_slots == 0)
  {
    UIM_MSG_ERR_0("Number of available slots reported is zero");
    return FALSE;
  }

  /* Allocate memory for all slots combined and the divide it into chunks
     for each slot. */
  temp_card_info_ptr = (qmi_uim_card_info_type *)uimqmi_malloc(
                         qmi_uim_global_ptr->card_state.num_slots * sizeof(qmi_uim_card_info_type));
  if (temp_card_info_ptr == NULL)
  {
    UIM_MSG_ERR_0("Failed to allocate memory for all the slots");
    return FALSE;
  }
  memset(temp_card_info_ptr,
         0x00,
         qmi_uim_global_ptr->card_state.num_slots * sizeof(qmi_uim_card_info_type));

  for (i = 0; i < qmi_uim_global_ptr->card_state.num_slots &&
              i < QMI_UIM_MAX_CARD_COUNT; i++)
  {
    qmi_uim_global_ptr->card_state.card[i] = temp_card_info_ptr + i;
  }

  /* Get a MMGSDI client id */
  mmgsdi_status = mmgsdi_client_id_and_evt_reg(
                        qmi_uim_mmgsdi_evt_cback,
                        qmi_uimi_mmgsdi_callback,
                        (mmgsdi_client_data_type)NULL);
  if (MMGSDI_SUCCESS != mmgsdi_status)
  {
    UIM_MSG_ERR_0("QMI-UIM:Unable to get a client id");
    return FALSE;
  }

#ifdef FEATURE_GSTK
  /* Register with GSTK ot get OTASP status updates */
  gstk_status = gstk_otasp_status_reg(0,
                                      qmi_uimi_otasp_reg_callback,
                                      qmi_uimi_otasp_status_callback);
  if(gstk_status != GSTK_SUCCESS)
  {
    UIM_MSG_ERR_1("QMI-UIM:Unable to register with GSTK for OTASP: 0x%x", gstk_status);
  }
#endif /* FEATURE_GSTK */

  /* Read configuration for silent PIN1 verification & APDU security restrictions*/
  qmi_uim_read_configuration(&qmi_uim_global_ptr->silent_pin1_supported,
                             &qmi_uim_global_ptr->apdu_sec_restr_value,
                             &qmi_uim_global_ptr->apdu_sec_aid_info,
                             &qmi_uim_global_ptr->close_channel_sync,
                             &qmi_uim_global_ptr->auth_sec_restr_value,
                             &qmi_uim_global_ptr->sap_sec_restr_supported,
                             &qmi_uim_global_ptr->simlock_status_for_valid_card);

  /* Retrieve the value fo NV item: 04398 to determine auto/manual selection of apps
     If the read of NV item from cache fails then we default to auto provisioning */
  cached_nv_item.nv_item_enum = MMGSDI_NV_UIM_SELECT_DEFAULT_USIM_APP_I;
  mmgsdi_status = mmgsdi_get_cached_nv_item(&cached_nv_item);
  if (mmgsdi_status == MMGSDI_SUCCESS)
  {
    qmi_uim_global_ptr->automatic_provisioning =
      cached_nv_item.nv_item_data.uim_select_default_usim_app;
  }
  else
  {
    qmi_uim_global_ptr->automatic_provisioning = TRUE;
  }

#ifdef FEATURE_UIM_SSM
  /* Initialize SSM globals */
  qmi_uim_global_ptr->ssm_info.qmi_uim_ssm_init_err = E_SSM_CLIENT_NOT_INITIALIZED;
  /* Initialize SSM module for restricted NV checks */
  qmi_uim_ssm_init();
#endif /* FEATURE_UIM_SSM */

#ifdef FEATURE_SIMLOCK
  /* Initialize SIMLOCK globals */
  qmi_uim_global_ptr->simlock_remote_sfs_operation_resp_cb = NULL;
  qmi_uim_global_ptr->simlock_slot_policy = SIMLOCK_SLOT_POLICY_SAME_ON_ALL_SLOTS;
  memset(&qmi_uim_global_ptr->temp_unlock_info,
         0x00,
         sizeof(qmi_uim_global_ptr->temp_unlock_info));

  if (qmi_uim_global_ptr->simlock_status_for_valid_card ==
          QMI_UIM_SIMLOCK_DISPLAY_FOR_VALID_CARD_ON_ANY_SLOT_POLICY)
  {
    (void)simlock_get_status(qmi_uimi_simlock_temporary_unlock_callback,
                             NULL);
  }
#endif /* FEATURE_SIMLOCK */

  /* Try to setup Diag access check callback */
  qmi_uim_global_ptr->efs_directory_list[0] = UIM_COMMON_EFS_PATH_MODEM_QMI_UIM_CONFIG_DIR4;
  qmi_uim_global_ptr->efs_directory_list[1] = UIM_COMMON_EFS_PATH_MODEM_UIM_MMGSDI_CONFIG_DIR;
  qmi_uim_global_ptr->efs_directory_list[2] = UIM_COMMON_EFS_PATH_MODEM_QMI_CAT_CONFIG_DIR3;
  diag_fs_register_access_check((const char **)qmi_uim_global_ptr->efs_directory_list,
                                QMI_UIM_EFS_DIRECTORY_LIST_SIZE,
                                qmi_uim_diag_access_check_cb);

  qmi_uim_global_ptr->physical_slots_info.num_slots = 0;
#ifdef FEATURE_UIM_DS_SUBSCRIPTION_MANAGER
  /* Register a callback with drivers for receiving status change of
     physical slots. If it fails, do not continue with any further
     communication with drivers for subscription manager */
  if(UIM_PASS == uim_sm_card_slot_status_evt_reg_sync(qmi_uim_notify_slots_status_cb))
  {
    /* Get number of physical slots from drivers */
    qmi_uim_global_ptr->physical_slots_info.num_slots = uim_sm_get_num_physical_slots_sync();
    /* Allocate the physical slot status data on the heap */
    if(qmi_uim_global_ptr->physical_slots_info.num_slots > 0)
    {
      qmi_uim_global_ptr->physical_slots_info.slot_status_ptr =
        (uim_phy_slot_status_type*)modem_mem_alloc(
                                    qmi_uim_global_ptr->physical_slots_info.num_slots * sizeof(uim_phy_slot_status_type),
                                    MODEM_MEM_CLIENT_UIM);

      if(qmi_uim_global_ptr->physical_slots_info.slot_status_ptr != NULL)
      {
        memset(qmi_uim_global_ptr->physical_slots_info.slot_status_ptr,
               0,
               qmi_uim_global_ptr->physical_slots_info.num_slots * sizeof(uim_phy_slot_status_type));
      }

      /* Get physical slots status from uimdrv into our global */
      (void) uim_sm_get_logical_slot_status_sync(&qmi_uim_global_ptr->physical_slots_info.num_slots,
                                                 qmi_uim_global_ptr->physical_slots_info.slot_status_ptr);
    }
  }
  else
  {
    /* Do not return FALSE here since this is not severe enough to flag that
       the overall QMI UIM init has failed.. only subscription manager
       functionality won't be available */
    UIM_MSG_ERR_0("Error registering with drivers: subscription manager unavailable!");
  }
#endif /* FEATURE_UIM_DS_SUBSCRIPTION_MANAGER */

  return TRUE;
} /* qmi_uim_service_initialize */


/*===========================================================================
QMI_UIM_SIG_HANDLER

DESCRIPTION
  QMI UIM signal handler for MMGSDI task signals

PARAMETERS
  None.

  Returns TRUE if signal should be cleared from the set signal mask,
  FALSE if further signal processing is needed and hence signal
  should not be cleared.
===========================================================================*/
boolean qmi_uim_sig_handler
(
  void
)
{
  ASSERT(qmi_uim_global_ptr != NULL);

  qmi_uim_process_message();

  /* This signal is set asyncronously however the framework handles
     concurrency issues so no need to worry about it here */
  if (q_cnt(&qmi_uim_global_ptr->qmi_uim_q) == 0)
  {
    return TRUE;
  }

  return FALSE;
} /* qmi_uim_sig_handler */


/*===========================================================================
  FUNCTION QMI_UIM_CREATE_MESSAGE

  DESCRIPTION
    Allocates the memory for a QMI UIM message and initializes it.

  PARAMETERS
    message_type: QMI UIM message type

  RETURN VALUE
    Pointer to the allocated message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_uim_message_type * qmi_uim_create_message
(
  qmi_uim_message_enum_type message_type
)
{
  qmi_uim_message_type * msg_ptr = NULL;

  msg_ptr = uimqmi_malloc(sizeof(qmi_uim_message_type));
  if (msg_ptr != NULL)
  {
    memset(msg_ptr, 0, sizeof(qmi_uim_message_type));
    msg_ptr->message_type = message_type;
  }
  else
  {
    UIM_MSG_ERR_0("Error allocating memory for QMI UIM message");
  }

  return msg_ptr;
} /* qmi_uim_create_message */


/*===========================================================================
  FUNCTION QMI_UIM_POST_MESSAGE

  DESCRIPTION
    Adds a message to the QMI UIM queue and posts an event to DCC task,
    so that it can be processed later in the right context.

  PARAMETERS
    uim_message_ptr: QMI UIM message

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_post_message
(
  qmi_uim_message_type * uim_message_ptr
)
{
  ASSERT(uim_message_ptr    != NULL);
  ASSERT(qmi_uim_global_ptr != NULL);

  /* Add the message to the MMGSDI queue */
  q_put(&qmi_uim_global_ptr->qmi_uim_q, &uim_message_ptr->link_next);

  /* Enable the MMGSDI task sig to process in MMGSDI context*/
  mmgsdi_set_qmi_uim_sig();
} /* qmi_uim_post_message */


/*===========================================================================
  FUNCTION QMI_UIMI_ALLOC_CLID

  DESCRIPTION
    Allocate client command from the framework.  Post a message
    to handle the allocation in MMGSDI context.

  PARAMETERS
    svc_common_hdr : framework service header

  RETURN VALUE
    True : Message posted successfully
    False: Allocation error

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_uimi_alloc_clid
(
  qmi_framework_common_msg_hdr_type * svc_common_hdr
)
{
  qmi_uim_message_type * msg_ptr = NULL;

  ASSERT(svc_common_hdr);

  UIM_MSG_HIGH_1("Incoming Client allocation for instance:0x%x",
                 svc_common_hdr->qmi_instance);

  msg_ptr = qmi_uim_create_message(QMI_UIM_MESSAGE_ALLOC_CLID);

  if (msg_ptr != NULL)
  {
    msg_ptr->data.clid_cb.cmd_hdr = *svc_common_hdr;

    /* Send command to be processed in MMGSDI context */
    qmi_uim_post_message(msg_ptr);
    msg_ptr = NULL;
  }
  else
  {
    return FALSE;
  }
  return TRUE;
} /* qmi_uimi_alloc_clid */


/*===========================================================================
  FUNCTION QMI_UIMI_DEALLOC_CLID

  DESCRIPTION
    Deallocate client command from the framework.  Post a message
    to handle the operation in MMGSDI context.

  PARAMETERS
    svc_common_hdr : framework service header

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_dealloc_clid
(
  qmi_framework_common_msg_hdr_type * svc_common_hdr
)
{
  qmi_uim_message_type * msg_ptr = NULL;

  ASSERT(svc_common_hdr);

  UIM_MSG_HIGH_1("Incoming Client deallocation for instance:0x%x",
                 svc_common_hdr->qmi_instance);

  msg_ptr = qmi_uim_create_message(QMI_UIM_MESSAGE_DEALLOC_CLID);

  if (msg_ptr != NULL)
  {
    msg_ptr->data.clid_cb.cmd_hdr = *svc_common_hdr;

    /* Send command to be processed in MMGSDI context */
    qmi_uim_post_message(msg_ptr);
    msg_ptr = NULL;
  }
  else
  {
    UIM_MSG_ERR_0("Could not allocate QMI UIM CB MESSAGE");
  }
} /* qmi_uimi_dealloc_clid */


/*===========================================================================
  FUNCTION QMI_UIMI_INIT_CBACK

  DESCRIPTION
    Callback for the qmi framework registration.

  PARAMETERS
    num_instances : The number of qmi_uim instances

  RETURN VALUE
    None

  DEPENDENCIES
    Must have registered with the qmi framework

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_init_cback
(
  uint16 num_instances
)
{
  /* Nothing to do here. Callback required by qmi_framework_reg_service() */
  UIM_MSG_HIGH_1("qmi_uimi_init_cback instances:0x%x", num_instances);
} /* qmi_uimi_init_cback */


/*===========================================================================
  FUNCTION QMI_UIMI_CMD_HDLR

  DESCRIPTION
    Function to route external commands sent to QMI_UIM service
    to the appropriate internal service handling routine.

  PARAMETERS
    msg_hdr  : CMD data including hdr packaged by qmi framework
    sdu      : Incoming request
===========================================================================*/
static void qmi_uimi_cmd_hdlr
(
  qmi_framework_msg_hdr_type * msg_hdr_ptr,
  dsm_item_type             ** sdu
)
{
  qmi_uim_message_type       *qmi_uim_message_ptr = NULL;

  ASSERT(msg_hdr_ptr);
  ASSERT(sdu);

  qmi_uim_message_ptr = qmi_uim_create_message(QMI_UIM_MESSAGE_FRAMEWORK_CMD);

  if(qmi_uim_message_ptr == NULL)
  {
    dsm_free_packet(sdu);
  }
  else
  {
    qmi_uim_message_ptr->data.framework_cmd.cmd_hdr = *msg_hdr_ptr;
    qmi_uim_message_ptr->data.framework_cmd.sdu     = *sdu;

    qmi_uim_post_message(qmi_uim_message_ptr);
    qmi_uim_message_ptr = NULL;
  }
} /* qmi_uimi_cmd_hdlr */


/*===========================================================================
  FUNCTION QMI_UIM_INIT_PRE_STARTUP()

  DESCRIPTION
    Initializes the QMI UIM global variables and register with MMGSDI

  PARAMETERS
    void

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_uim_init_pre_startup
(
  void
)
{
  uint16  i = 0;

  if(qmi_uim_state_ptr == NULL)
  {
    /*Allocate state variable for QMI_UIM clients*/
    qmi_uim_state_ptr = uimqmi_malloc(sizeof(qmi_uimi_state_type));
    ASSERT(qmi_uim_state_ptr != NULL);
    memset(qmi_uim_state_ptr, 0, sizeof(qmi_uimi_state_type));
  }

  ASSERT(qmi_uim_global_ptr != NULL);

  /* Initialize qmi_uim_global_type if not initialized yet */
  if (FALSE == qmi_uim_global_ptr->init)
  {
    memset(qmi_uim_global_ptr, 0, sizeof(qmi_uim_global_type));

    /* Initialization of client id and session ids */
    qmi_uim_global_ptr->mmgsdi_client_id                 = UIM_INVALID_CLIENT_ID;
    for (i = 0; i < QMI_UIM_MAX_CARD_SESSIONS; i++)
    {
      qmi_uim_global_ptr->mmgsdi_card_slot_session_id[i] = UIM_INVALID_SESSION_ID;
    }

    /* Initialization of session ids for non prov applications */
    for (i = 0; i < UIM_MAX_NON_PROV_SESSIONS; i++)
    {
      qmi_uim_global_ptr->non_prov_session[i].init              = FALSE;
      qmi_uim_global_ptr->non_prov_session[i].mmgsdi_session_id = UIM_INVALID_SESSION_ID;
    }
    for (i = 0; i < UIM_REFRESH_NON_PROV_COUNT; i++)
    {
      qmi_uim_global_ptr->non_prov_refresh_session_id[i]        = UIM_INVALID_SESSION_ID;
    }

    /* Initialization of indexes to provisioning app */
    for (i = 0; i < QMI_UIM_MAX_PROV_SESSIONS; i++)
    {
      qmi_uim_global_ptr->mmgsdi_gw_session_id[i] = UIM_INVALID_SESSION_ID;
      qmi_uim_global_ptr->mmgsdi_1x_session_id[i] = UIM_INVALID_SESSION_ID;
      qmi_uim_global_ptr->card_state.index_gw[i]  = UIM_INVALID_APP_INDEX;
      qmi_uim_global_ptr->card_state.index_1x[i]  = UIM_INVALID_APP_INDEX;
    }

    /* Initialize SAP info */
    for (i = 0; i < QMI_UIM_MAX_CARD_COUNT; i++)
    {
      qmi_uim_global_ptr->sap_info[i].is_enabled = FALSE;
      qmi_uim_global_ptr->sap_info[i].sap_state  = MMGSDI_SAP_DISCONNECTED;
    }

    /* Initialize message queue */
    (void) q_init(&qmi_uim_global_ptr->qmi_uim_q);

    qmi_uim_global_ptr->init = TRUE;
  }
} /* qmi_uim_init_pre_startup() */


/*===========================================================================
  FUNCTION QMI_UIM_INIT_POST_STARTUP()

  DESCRIPTION
    Registers the QMI UIM service to the QMI framework to initalize
    the service.

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_uim_init_post_startup
(
  void
)
{
  qmi_framework_err_e_type      errval       = QMI_FRAMEWORK_ERR_NONE;
  qmi_framework_svc_config_type qmi_uim_cfg;
  qmi_idl_service_object_type   svc_obj;

  memset(&qmi_uim_cfg, 0, sizeof(qmi_uim_cfg));

  UIM_MSG_HIGH_0("qmi_uim_init_post_startup");

  /* Initialize global data
     We must do this now before we register for service because
     at the time of the reg_service_cb we need to have the
     internal qmi_message q initialized */
  if(qmi_uim_service_initialize() == FALSE)
  {
    return;
  }

  qmi_uim_cfg.base_version.major     = UIMI_BASE_VER_MAJOR;
  qmi_uim_cfg.base_version.minor     = UIMI_BASE_VER_MINOR;

  qmi_uim_cfg.addendum_version.major = UIMI_ADDENDUM_VER_MAJOR;
  qmi_uim_cfg.addendum_version.minor = UIMI_ADDENDUM_VER_MINOR;

  qmi_uim_cfg.cbs.alloc_clid         = qmi_uimi_alloc_clid;
  qmi_uim_cfg.cbs.dealloc_clid       = qmi_uimi_dealloc_clid;
  qmi_uim_cfg.cbs.init_cback         = qmi_uimi_init_cback;
  qmi_uim_cfg.cbs.cmd_hdlr           = qmi_uimi_cmd_hdlr;

  errval = qmi_framework_reg_service(QMUX_SERVICE_UIM, &qmi_uim_cfg);
  if (errval != QMI_FRAMEWORK_ERR_NONE)
  {
    UIM_MSG_ERR_1("Could not register QMI UIM with QMI Framework - errval:0x%x",
                  errval);
    return;
  }

  /* register for MPSS/QMI support interfaces logging */
  svc_obj =  uim_get_service_object_v01();
  (void) qmi_si_register_object ( svc_obj,
                                  0, /* Service Instance */
                                  uim_get_service_impl_v01() );
} /* qmi_uim_init_post_startup() */


/*===========================================================================
  FUNCTION QMI_UIM_GET_MESSAGE

  DESCRIPTION
    Retrieve a message from the QMI UIM queue

  PARAMETERS
    None

  RETURN VALUE
    Pointer to the message extracted from the queue

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_uim_message_type * qmi_uim_get_message
(
  void
)
{
  qmi_uim_message_type * uim_message_ptr = NULL;

  ASSERT(qmi_uim_global_ptr != NULL);

  if (q_cnt(&qmi_uim_global_ptr->qmi_uim_q) > 0)
  {
    uim_message_ptr = (qmi_uim_message_type*)q_get(&qmi_uim_global_ptr->qmi_uim_q);
  }
  return uim_message_ptr;
} /* qmi_uim_get_message */


/*===========================================================================
  FUNCTION QMI_UIM_CHECK_CLID()

  DESCRIPTION
    To validate if the passed client id is stil valid within the passed UIM
    service state ptr

  PARAMETERS
    clid   : Client ID

  RETURN VALUE
    TRUE if successful, else FALSE

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_uim_check_clid
(
  uint8                         clid,
  uint32                        client_reg_count
)
{
  int    client_index = 0;

  ASSERT(qmi_uim_state_ptr);

  for(client_index = 0; client_index < (int)UIMI_MAX_CLIDS; client_index++)
  {
    if ((qmi_uim_state_ptr->client[client_index] != NULL) &&
        (qmi_uim_state_ptr->client[client_index]->common.clid == clid))
    {
      if(qmi_uim_state_ptr->client_reg_count[client_index] == client_reg_count)
      {
        return TRUE;
      }
      else
      {
        UIM_MSG_HIGH_3("Client reg. count mismatch: 0x%x and 0x%x on clid",
                       client_reg_count,
                       qmi_uim_state_ptr->client_reg_count[client_index],
                       clid);

        return FALSE;
      }
    }
  }

  UIM_MSG_HIGH_1("Invalid clid: 0x%x", clid);

  return FALSE;
} /* qmi_uim_check_clid() */


/*===========================================================================
  FUNCTION QMI_UIM_DEEP_COPY()

  DESCRIPTION
    This function allocates memory and duplicates the content of a buffer.
    This is a utility function to make deep copies.

  PARAMETERS
    dest : pointer to the destination buffer. Output value.
    src  : pointer to the source buffer
    size : size of the source buffer

  RETURN VALUE
    None. Errors are ignored.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_deep_copy
(
  void       ** dest,
  const void  * src,
  uint32        size
)
{
  if (dest != NULL)
  {
    *dest = NULL;
    if (src != NULL && size > 0)
    {
      *dest = uimqmi_malloc(size);
      if (*dest != NULL)
      {
        (void)memscpy(*dest, size, src, size);
      }
    }
  }
} /* qmi_uim_deep_copy */


/*===========================================================================
  FUNCTION QMI_UIM_CNF_DEEP_COPY()

  DESCRIPTION
    This function makes a deep copy of the mmgsdi_cnf_type pointer
    passed from MMGSDI to QMI and is required to pass the command in the
    QMI context.

  PARAMETERS

  RETURN VALUE
    None.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_cnf_deep_copy
(
  mmgsdi_cnf_enum_type    cnf_type,
  mmgsdi_cnf_type        *cnf_dst_ptr,
  const mmgsdi_cnf_type  *cnf_src_ptr
)
{
  const mmgsdi_file_security_access_type* sec_src = NULL;
  mmgsdi_file_security_access_type* sec_dst = NULL;

  if (cnf_dst_ptr == NULL ||
      cnf_src_ptr == NULL)
  {
    return;
  }

  memset(cnf_dst_ptr, 0, sizeof(mmgsdi_cnf_type));

  switch(cnf_type)
  {
    case MMGSDI_CLIENT_ID_AND_EVT_REG_CNF:
      (void)memscpy(&cnf_dst_ptr->client_id_and_evt_reg_cnf,
                    sizeof(mmgsdi_client_id_and_evt_reg_cnf_type),
                    &cnf_src_ptr->client_id_and_evt_reg_cnf,
                    sizeof(mmgsdi_client_id_and_evt_reg_cnf_type));
      break;

    case MMGSDI_SESSION_OPEN_EXT_CNF:
      (void)memscpy(&cnf_dst_ptr->session_open_ext_cnf,
                    sizeof(mmgsdi_session_open_ext_cnf_type),
                    &cnf_src_ptr->session_open_ext_cnf,
                    sizeof(mmgsdi_session_open_ext_cnf_type));
      /* Deep copy of cnf data only in case of success */
      if (cnf_src_ptr->session_open_ext_cnf.response_header.mmgsdi_status == MMGSDI_SUCCESS)
      {
        qmi_uim_deep_copy(
         (void**)&cnf_dst_ptr->session_open_ext_cnf.session_info_ptr,
         (void*)cnf_src_ptr->session_open_ext_cnf.session_info_ptr,
         cnf_src_ptr->session_open_ext_cnf.num_sessions * sizeof(mmgsdi_session_open_info_type));
      }
      else
      {
        cnf_dst_ptr->session_open_ext_cnf.session_info_ptr = NULL;
      }
      break;

    case MMGSDI_SESSION_OPEN_WITH_SELECT_RSP_CNF:
      (void)memscpy(&cnf_dst_ptr->session_open_with_sel_rsp_cnf,
                    sizeof(mmgsdi_session_open_with_sel_rsp_cnf_type),
                    &cnf_src_ptr->session_open_with_sel_rsp_cnf,
                    sizeof(mmgsdi_session_open_with_sel_rsp_cnf_type));
      if (cnf_src_ptr->session_open_with_sel_rsp_cnf.response_header.mmgsdi_status == MMGSDI_SUCCESS)
      {
        qmi_uim_deep_copy(
          (void**)&cnf_dst_ptr->session_open_with_sel_rsp_cnf.select_rsp.data_ptr,
          (void*)cnf_src_ptr->session_open_with_sel_rsp_cnf.select_rsp.data_ptr,
          (uint32)cnf_src_ptr->session_open_with_sel_rsp_cnf.select_rsp.data_len);
      }
      else
      {
        cnf_dst_ptr->session_open_with_sel_rsp_cnf.select_rsp.data_ptr = NULL;
      }
      break;

    case MMGSDI_SESSION_OPEN_WITH_MF_CNF:
      (void)memscpy(&cnf_dst_ptr->session_open_with_mf_cnf,
                    sizeof(mmgsdi_session_open_with_mf_cnf_type),
                    &cnf_src_ptr->session_open_with_mf_cnf,
                    sizeof(mmgsdi_session_open_with_mf_cnf_type));
      break;

    case MMGSDI_SESSION_CLOSE_CNF:
      (void)memscpy(&cnf_dst_ptr->session_close_cnf,
                    sizeof(mmgsdi_session_close_cnf_type),
                    &cnf_src_ptr->session_close_cnf,
                    sizeof(mmgsdi_session_close_cnf_type));
      break;

    case MMGSDI_READ_CNF:
      (void)memscpy(&cnf_dst_ptr->read_cnf,
                    sizeof(mmgsdi_read_cnf_type),
                    &cnf_src_ptr->read_cnf,
                    sizeof(mmgsdi_read_cnf_type));
      /* Deep copy of read data only in case of success */
      if (cnf_src_ptr->read_cnf.response_header.mmgsdi_status == MMGSDI_SUCCESS)
      {
        qmi_uim_deep_copy(
          (void**)&cnf_dst_ptr->read_cnf.read_data.data_ptr,
          (void*)cnf_src_ptr->read_cnf.read_data.data_ptr,
          (uint32)cnf_src_ptr->read_cnf.read_data.data_len);
      }
      else
      {
        cnf_dst_ptr->read_cnf.read_data.data_ptr = NULL;
      }
      break;

    case MMGSDI_WRITE_CNF:
      (void)memscpy(&cnf_dst_ptr->write_cnf,
                    sizeof(mmgsdi_write_cnf_type),
                    &cnf_src_ptr->write_cnf,
                    sizeof(mmgsdi_write_cnf_type));
      break;

    case MMGSDI_GET_FILE_ATTR_CNF:
      (void)memscpy(&cnf_dst_ptr->get_file_attr_cnf,
                    sizeof(mmgsdi_get_file_attr_cnf_type),
                    &cnf_src_ptr->get_file_attr_cnf,
                    sizeof(mmgsdi_get_file_attr_cnf_type));
      /* Deep copy only in case of success */
      if (cnf_src_ptr->get_file_attr_cnf.response_header.mmgsdi_status == MMGSDI_SUCCESS)
      {
        /* Deep copy of raw data */
        qmi_uim_deep_copy(
          (void**)&cnf_dst_ptr->get_file_attr_cnf.raw_file_attr_data.data_ptr,
          (void*)cnf_src_ptr->get_file_attr_cnf.raw_file_attr_data.data_ptr,
          (uint32)cnf_src_ptr->get_file_attr_cnf.raw_file_attr_data.data_len);
        /* Deep copy of security attributes */
        switch (cnf_src_ptr->get_file_attr_cnf.file_attrib.file_type)
        {
          case MMGSDI_TRANSPARENT_FILE:
            sec_src = &cnf_src_ptr->get_file_attr_cnf.file_attrib.file_info.transparent_file.file_security;
            sec_dst = &cnf_dst_ptr->get_file_attr_cnf.file_attrib.file_info.transparent_file.file_security;
            break;
          case MMGSDI_LINEAR_FIXED_FILE:
            sec_src = &cnf_src_ptr->get_file_attr_cnf.file_attrib.file_info.linear_fixed_file.file_security;
            sec_dst = &cnf_dst_ptr->get_file_attr_cnf.file_attrib.file_info.linear_fixed_file.file_security;
            break;
          case MMGSDI_CYCLIC_FILE:
            sec_src = &cnf_src_ptr->get_file_attr_cnf.file_attrib.file_info.cyclic_file.file_security;
            sec_dst = &cnf_dst_ptr->get_file_attr_cnf.file_attrib.file_info.cyclic_file.file_security;
            break;
          default:
            break;
        }
        if (sec_src != NULL && sec_dst != NULL)
        {
          qmi_uim_deep_copy(
             (void**)&sec_dst->read.protection_pin_ptr,
             (void*)sec_src->read.protection_pin_ptr,
             (uint32)(sec_src->read.num_protection_pin) * sizeof(mmgsdi_pin_enum_type) );
          qmi_uim_deep_copy(
             (void**)&sec_dst->write.protection_pin_ptr,
             (void*)sec_src->write.protection_pin_ptr,
             (uint32)(sec_src->write.num_protection_pin) * sizeof(mmgsdi_pin_enum_type) );
          qmi_uim_deep_copy(
             (void**)&sec_dst->increase.protection_pin_ptr,
             (void*)sec_src->increase.protection_pin_ptr,
             (uint32)(sec_src->increase.num_protection_pin) * sizeof(mmgsdi_pin_enum_type) );
          qmi_uim_deep_copy(
             (void**)&sec_dst->invalidate_deactivate.protection_pin_ptr,
             (void*)sec_src->invalidate_deactivate.protection_pin_ptr,
             (uint32)(sec_src->invalidate_deactivate.num_protection_pin) * sizeof(mmgsdi_pin_enum_type) );
          qmi_uim_deep_copy(
             (void**)&sec_dst->rehabilitate_activate.protection_pin_ptr,
             (void*)sec_src->rehabilitate_activate.protection_pin_ptr,
             (uint32)(sec_src->rehabilitate_activate.num_protection_pin) * sizeof(mmgsdi_pin_enum_type) );
        }
      }
      else
      {
        cnf_dst_ptr->get_file_attr_cnf.raw_file_attr_data.data_ptr = NULL;
      }
      break;

    case MMGSDI_CARD_PDOWN_CNF:
      (void)memscpy(&cnf_dst_ptr->card_pdown_cnf,
                    sizeof(mmgsdi_card_pdown_cnf_type),
                    &cnf_src_ptr->card_pdown_cnf,
                    sizeof(mmgsdi_card_pdown_cnf_type));
      break;

    case MMGSDI_CARD_PUP_CNF:
      (void)memscpy(&cnf_dst_ptr->card_pup_cnf,
                    sizeof(mmgsdi_card_pup_cnf_type),
                    &cnf_src_ptr->card_pup_cnf,
                    sizeof(mmgsdi_card_pup_cnf_type));
      break;

    case MMGSDI_REFRESH_CNF:
      (void)memscpy(&cnf_dst_ptr->refresh_cnf,
                    sizeof(mmgsdi_refresh_cnf_type),
             &cnf_src_ptr->refresh_cnf,
             sizeof(mmgsdi_refresh_cnf_type));
      break;

    case MMGSDI_PIN_OPERATION_CNF:
      (void)memscpy(&cnf_dst_ptr->pin_operation_cnf,
                    sizeof(mmgsdi_pin_operation_cnf_type),
                    &cnf_src_ptr->pin_operation_cnf,
                    sizeof(mmgsdi_pin_operation_cnf_type));
      break;

    case MMGSDI_RUN_CAVE_CNF:
      (void)memscpy(&cnf_dst_ptr->run_cave_cnf,
                    sizeof(mmgsdi_run_cave_cnf_type),
                    &cnf_src_ptr->run_cave_cnf,
                    sizeof(mmgsdi_run_cave_cnf_type));
      break;

    case MMGSDI_SESSION_RUN_GSM_ALGO_CNF:
      (void)memscpy(&cnf_dst_ptr->session_run_gsm_algo_cnf,
                    sizeof(mmgsdi_session_run_gsm_algo_cnf_type),
                    &cnf_src_ptr->session_run_gsm_algo_cnf,
                    sizeof(mmgsdi_session_run_gsm_algo_cnf_type));
      break;

    case MMGSDI_ISIM_AUTH_CNF:
      (void)memscpy(&cnf_dst_ptr->isim_auth_cnf,
                    sizeof(mmgsdi_isim_auth_cnf_type),
                    &cnf_src_ptr->isim_auth_cnf,
                    sizeof(mmgsdi_isim_auth_cnf_type));
      qmi_uim_deep_copy(
        (void**)&cnf_dst_ptr->isim_auth_cnf.res.data_ptr,
        (void*)cnf_src_ptr->isim_auth_cnf.res.data_ptr,
        (uint32)cnf_src_ptr->isim_auth_cnf.res.data_len);
      qmi_uim_deep_copy(
        (void**)&cnf_dst_ptr->isim_auth_cnf.ck.data_ptr,
        (void*)cnf_src_ptr->isim_auth_cnf.ck.data_ptr,
        (uint32)cnf_src_ptr->isim_auth_cnf.ck.data_len);
      qmi_uim_deep_copy(
        (void**)&cnf_dst_ptr->isim_auth_cnf.ik.data_ptr,
        (void*)cnf_src_ptr->isim_auth_cnf.ik.data_ptr,
        (uint32)cnf_src_ptr->isim_auth_cnf.ik.data_len);
      qmi_uim_deep_copy(
        (void**)&cnf_dst_ptr->isim_auth_cnf.auts.data_ptr,
        (void*)cnf_src_ptr->isim_auth_cnf.auts.data_ptr,
        (uint32)cnf_src_ptr->isim_auth_cnf.auts.data_len);
      break;

    case MMGSDI_USIM_AUTH_CNF:
      (void)memscpy(&cnf_dst_ptr->usim_auth_cnf,
                    sizeof(mmgsdi_usim_auth_cnf_type),
                    &cnf_src_ptr->usim_auth_cnf,
                    sizeof(mmgsdi_usim_auth_cnf_type));
      qmi_uim_deep_copy(
        (void**)&cnf_dst_ptr->usim_auth_cnf.auth_response.data_ptr,
        (void*)cnf_src_ptr->usim_auth_cnf.auth_response.data_ptr,
        (uint32)cnf_src_ptr->usim_auth_cnf.auth_response.data_len);
      break;

    case MMGSDI_COMPUTE_IP_AUTH_CNF:
      (void)memscpy(&cnf_dst_ptr->compute_ip_cnf,
                    sizeof(mmgsdi_compute_ip_auth_cnf_type),
                    &cnf_src_ptr->compute_ip_cnf,
                    sizeof(mmgsdi_compute_ip_auth_cnf_type));
      qmi_uim_deep_copy(
        (void**)&cnf_dst_ptr->compute_ip_cnf.cmpt_ip_response_data.data_ptr,
        (void*)cnf_src_ptr->compute_ip_cnf.cmpt_ip_response_data.data_ptr,
        (uint32)cnf_src_ptr->compute_ip_cnf.cmpt_ip_response_data.data_len);
      break;

    case MMGSDI_SESSION_ENABLE_SERVICE_CNF:
      (void)memscpy(&cnf_dst_ptr->session_enable_service_cnf,
                    sizeof(mmgsdi_session_enable_service_cnf_type),
                    &cnf_src_ptr->session_enable_service_cnf,
                    sizeof(mmgsdi_session_enable_service_cnf_type));
      break;

    case MMGSDI_SESSION_DISABLE_SERVICE_CNF:
      (void)memscpy(&cnf_dst_ptr->session_disable_service_cnf,
                    sizeof(mmgsdi_session_disable_service_cnf_type),
                    &cnf_src_ptr->session_disable_service_cnf,
                    sizeof(mmgsdi_session_disable_service_cnf_type));
      break;

    case MMGSDI_SRV_AVAILABLE_CNF:
      (void)memscpy(&cnf_dst_ptr->srv_available_cnf,
                    sizeof(mmgsdi_srv_available_cnf_type),
                    &cnf_src_ptr->srv_available_cnf,
                    sizeof(mmgsdi_srv_available_cnf_type));
      break;

    case MMGSDI_SESSION_GET_APP_CAPABILITIES_CNF:
      (void)memscpy(&cnf_dst_ptr->session_app_capabilities_cnf,
                    sizeof(mmgsdi_session_app_capabilities_cnf_type),
                    &cnf_src_ptr->session_app_capabilities_cnf,
                    sizeof(mmgsdi_session_app_capabilities_cnf_type));
      break;

    case MMGSDI_GET_ALL_PIN_STATUS_CNF:
      (void)memscpy(&cnf_dst_ptr->get_all_pin_status_cnf,
                    sizeof(mmgsdi_get_all_pin_status_cnf_type),
                    &cnf_src_ptr->get_all_pin_status_cnf,
                    sizeof(mmgsdi_get_all_pin_status_cnf_type));
      break;

    case MMGSDI_SESSION_ACTIVATE_OR_SWITCH_PROVISIONING_CNF:
      (void)memscpy(&cnf_dst_ptr->session_activate_or_switch_provisioning_cnf,
                    sizeof(mmgsdi_session_act_or_switch_prov_cnf_type),
                    &cnf_src_ptr->session_activate_or_switch_provisioning_cnf,
                    sizeof(mmgsdi_session_act_or_switch_prov_cnf_type));
      break;

    case MMGSDI_SESSION_DEACTIVATE_CNF:
      (void)memscpy(&cnf_dst_ptr->session_deactivate_cnf,
                    sizeof(mmgsdi_session_deactivate_cnf_type),
                    &cnf_src_ptr->session_deactivate_cnf,
                    sizeof(mmgsdi_session_deactivate_cnf_type));
      break;

    case MMGSDI_SEND_APDU_EXT_CNF:
      (void)memscpy(&cnf_dst_ptr->send_apdu_ext_cnf,
                    sizeof(mmgsdi_send_apdu_ext_cnf_type),
                    &cnf_src_ptr->send_apdu_ext_cnf,
                    sizeof(mmgsdi_send_apdu_ext_cnf_type));
      /* Deep copy of APDU response data only in case of success */
      if (cnf_src_ptr->send_apdu_ext_cnf.response_header.mmgsdi_status == MMGSDI_SUCCESS)
      {
        qmi_uim_deep_copy(
          (void**)&cnf_dst_ptr->send_apdu_ext_cnf.apdu_data.data_ptr,
          (void*)cnf_src_ptr->send_apdu_ext_cnf.apdu_data.data_ptr,
          (uint32)cnf_src_ptr->send_apdu_ext_cnf.apdu_data.data_len);
      }
      else
      {
        cnf_dst_ptr->send_apdu_ext_cnf.apdu_data.data_ptr = NULL;
      }
      break;

    case MMGSDI_SAP_CONNECT_CNF:
      (void)memscpy(&cnf_dst_ptr->sap_connect_cnf,
                    sizeof(mmgsdi_sap_connect_cnf_type),
                    &cnf_src_ptr->sap_connect_cnf,
                    sizeof(mmgsdi_sap_connect_cnf_type));
      break;

    case MMGSDI_SAP_DISCONNECT_CNF:
      (void)memscpy(&cnf_dst_ptr->sap_disconnect_cnf,
                    sizeof(mmgsdi_sap_disconnect_cnf_type),
                    &cnf_src_ptr->sap_disconnect_cnf,
                    sizeof(mmgsdi_sap_disconnect_cnf_type));
      break;

    case MMGSDI_SAP_GET_ATR_CNF:
      (void)memscpy(&cnf_dst_ptr->sap_get_atr_cnf,
                    sizeof(mmgsdi_sap_get_atr_cnf_type),
                    &cnf_src_ptr->sap_get_atr_cnf,
                    sizeof(mmgsdi_sap_get_atr_cnf_type));
      /* Deep copy of ATR response data only in case of success */
      if (cnf_src_ptr->sap_get_atr_cnf.response_header.mmgsdi_status == MMGSDI_SUCCESS)
      {
        qmi_uim_deep_copy(
          (void**)&cnf_dst_ptr->sap_get_atr_cnf.atr_data.data_ptr,
          (void*)cnf_src_ptr->sap_get_atr_cnf.atr_data.data_ptr,
          (uint32)cnf_src_ptr->sap_get_atr_cnf.atr_data.data_len);
      }
      else
      {
        cnf_dst_ptr->sap_get_atr_cnf.atr_data.data_ptr = NULL;
      }
      break;

    case MMGSDI_SAP_SEND_APDU_CNF:
      (void)memscpy(&cnf_dst_ptr->sap_send_apdu_cnf,
                    sizeof(mmgsdi_sap_send_apdu_cnf_type),
                    &cnf_src_ptr->sap_send_apdu_cnf,
                    sizeof(mmgsdi_sap_send_apdu_cnf_type));
      /* Deep copy of APDU response data only in case of success */
      if (cnf_src_ptr->sap_send_apdu_cnf.response_header.mmgsdi_status == MMGSDI_SUCCESS)
      {
        qmi_uim_deep_copy(
          (void**)&cnf_dst_ptr->sap_send_apdu_cnf.apdu_data.data_ptr,
          (void*)cnf_src_ptr->sap_send_apdu_cnf.apdu_data.data_ptr,
          (uint32)cnf_src_ptr->sap_send_apdu_cnf.apdu_data.data_len);
      }
      else
      {
        cnf_dst_ptr->sap_send_apdu_cnf.apdu_data.data_ptr = NULL;
      }
      break;

    case MMGSDI_SAP_POWER_ON_CNF:
      (void)memscpy(&cnf_dst_ptr->sap_power_on_cnf,
                    sizeof(mmgsdi_sap_power_on_cnf_type),
                    &cnf_src_ptr->sap_power_on_cnf,
                    sizeof(mmgsdi_sap_power_on_cnf_type));
      break;

    case MMGSDI_SAP_POWER_OFF_CNF:
      (void)memscpy(&cnf_dst_ptr->sap_power_off_cnf,
                    sizeof(mmgsdi_sap_power_off_cnf_type),
                    &cnf_src_ptr->sap_power_off_cnf,
                    sizeof(mmgsdi_sap_power_off_cnf_type));
      break;

    case MMGSDI_SAP_RESET_CNF:
      (void)memscpy(&cnf_dst_ptr->sap_reset_cnf,
                    sizeof(mmgsdi_sap_reset_cnf_type),
                    &cnf_src_ptr->sap_reset_cnf,
                    sizeof(mmgsdi_sap_reset_cnf_type));
      break;

    case MMGSDI_SAP_CARD_READER_STATUS_CNF:
      (void)memscpy(&cnf_dst_ptr->sap_card_reader_status_cnf,
                    sizeof(mmgsdi_sap_card_reader_status_cnf_type),
                    &cnf_src_ptr->sap_card_reader_status_cnf,
                    sizeof(mmgsdi_sap_card_reader_status_cnf_type));
      /* Deep copy of Card reader status data only in case of success */
      if (cnf_src_ptr->sap_card_reader_status_cnf.response_header.mmgsdi_status == MMGSDI_SUCCESS)
      {
        qmi_uim_deep_copy(
          (void**)&cnf_dst_ptr->sap_card_reader_status_cnf.card_reader_status_data.data_ptr,
          (void*)cnf_src_ptr->sap_card_reader_status_cnf.card_reader_status_data.data_ptr,
          (uint32)cnf_src_ptr->sap_card_reader_status_cnf.card_reader_status_data.data_len);
      }
      else
      {
        cnf_dst_ptr->sap_card_reader_status_cnf.card_reader_status_data.data_ptr = NULL;
      }
      break;

    case MMGSDI_SESSION_SUBSCRIPTION_OK_CNF:
      (void)memscpy(&cnf_dst_ptr->session_subscription_ok_cnf,
                    sizeof(mmgsdi_session_subscription_ok_cnf_type),
                    &cnf_src_ptr->session_subscription_ok_cnf,
                    sizeof(mmgsdi_session_subscription_ok_cnf_type));
      break;

    case MMGSDI_GET_ATR_CNF:
      (void)memscpy(&cnf_dst_ptr->get_atr_cnf,
                    sizeof(mmgsdi_get_atr_cnf_type),
                    &cnf_src_ptr->get_atr_cnf,
                    sizeof(mmgsdi_get_atr_cnf_type));
      /* Deep copy of ATR response data only in case of success */
      if (cnf_src_ptr->get_atr_cnf.response_header.mmgsdi_status == MMGSDI_SUCCESS)
      {
        qmi_uim_deep_copy(
          (void**)&cnf_dst_ptr->get_atr_cnf.atr_data.data_ptr,
          (void*)cnf_src_ptr->get_atr_cnf.atr_data.data_ptr,
          (uint32)cnf_src_ptr->get_atr_cnf.atr_data.data_len);
      }
      else
      {
        cnf_dst_ptr->get_atr_cnf.atr_data.data_ptr = NULL;
      }
      break;

    case MMGSDI_INVALIDATE_CNF:
      (void)memscpy(&cnf_dst_ptr->invalidate_cnf,
                    sizeof(mmgsdi_invalidate_cnf_type),
                    &cnf_src_ptr->invalidate_cnf,
                    sizeof(mmgsdi_invalidate_cnf_type));
      break;

    case MMGSDI_REHABILITATE_CNF:
      (void)memscpy(&cnf_dst_ptr->rehab_cnf,
                    sizeof(mmgsdi_rehabilitate_cnf_type),
                    &cnf_src_ptr->rehab_cnf,
                    sizeof(mmgsdi_rehabilitate_cnf_type));
      break;

    case MMGSDI_INCREASE_CNF:
      (void)memscpy(&cnf_dst_ptr->increase_cnf,
                    sizeof(mmgsdi_increase_cnf_type),
                    &cnf_src_ptr->increase_cnf,
                    sizeof(mmgsdi_increase_cnf_type));
      /* Deep copy of increase data only in case of success */
      if (cnf_src_ptr->increase_cnf.response_header.mmgsdi_status == MMGSDI_SUCCESS)
      {
        qmi_uim_deep_copy(
          (void**)&cnf_dst_ptr->increase_cnf.increased_data.data_ptr,
          (void*)cnf_src_ptr->increase_cnf.increased_data.data_ptr,
          (uint32)cnf_src_ptr->increase_cnf.increased_data.data_len);
      }
      else
      {
        cnf_dst_ptr->increase_cnf.increased_data.data_ptr = NULL;
      }
      break;

    case MMGSDI_SESSION_SELECT_AID_CNF:
      (void)memscpy(&cnf_dst_ptr->session_select_aid_cnf,
                    sizeof(mmgsdi_session_select_aid_cnf_type),
                    &cnf_src_ptr->session_select_aid_cnf,
                    sizeof(mmgsdi_session_select_aid_cnf_type));
      if (cnf_src_ptr->session_select_aid_cnf.response_header.mmgsdi_status == MMGSDI_SUCCESS)
      {
        qmi_uim_deep_copy(
          (void**)&cnf_dst_ptr->session_select_aid_cnf.select_rsp.data_ptr,
          (void*)cnf_src_ptr->session_select_aid_cnf.select_rsp.data_ptr,
          (uint32)cnf_src_ptr->session_select_aid_cnf.select_rsp.data_len);
      }
      else
      {
        cnf_dst_ptr->session_select_aid_cnf.select_rsp.data_ptr = NULL;
      }
      break;

    case MMGSDI_CARD_STATUS_CNF:
      (void)memscpy(&cnf_dst_ptr->status_cnf,
                    sizeof(mmgsdi_status_cnf_type),
                    &cnf_src_ptr->status_cnf,
                    sizeof(mmgsdi_status_cnf_type));
      if (cnf_src_ptr->status_cnf.response_header.mmgsdi_status == MMGSDI_SUCCESS)
      {
        qmi_uim_deep_copy(
          (void**)&cnf_dst_ptr->status_cnf.status_data.data_ptr,
          (void*)cnf_src_ptr->status_cnf.status_data.data_ptr,
          (uint32)cnf_src_ptr->status_cnf.status_data.data_len);
      }
      else
      {
        cnf_dst_ptr->status_cnf.status_data.data_ptr = NULL;
      }
      break;

    case MMGSDI_GET_SIM_PROFILE_CNF:
      memscpy(&cnf_dst_ptr->get_sim_profile_cnf,
              sizeof(cnf_dst_ptr->get_sim_profile_cnf),
              &cnf_src_ptr->get_sim_profile_cnf,
              sizeof(mmgsdi_get_sim_profile_cnf_type));
      break;

    case MMGSDI_SET_SIM_PROFILE_CNF:
      memscpy(&cnf_dst_ptr->set_sim_profile_cnf,
              sizeof(cnf_dst_ptr->set_sim_profile_cnf),
              &cnf_src_ptr->set_sim_profile_cnf,
              sizeof(mmgsdi_set_sim_profile_cnf_type));
      break;

    case MMGSDI_SEARCH_CNF:
      (void)memscpy(&cnf_dst_ptr->search_cnf,
                    sizeof(mmgsdi_search_cnf_type),
                    &cnf_src_ptr->search_cnf,
                    sizeof(mmgsdi_search_cnf_type));
      /* Deep copy of search data only in case of success */
      if (cnf_src_ptr->search_cnf.response_header.mmgsdi_status == MMGSDI_SUCCESS)
      {
        qmi_uim_deep_copy(
          (void**)&cnf_dst_ptr->search_cnf.searched_record_nums.data_ptr,
          (void*)cnf_src_ptr->search_cnf.searched_record_nums.data_ptr,
          (uint32)cnf_src_ptr->search_cnf.searched_record_nums.data_len);
      }
      else
      {
        cnf_dst_ptr->search_cnf.searched_record_nums.data_ptr = NULL;
      }
      break;

    default:
      /* Nothing to do. This case should not happen! */
      break;
  }
} /* qmi_uim_cnf_deep_copy */


/*===========================================================================
  FUNCTION QMI_UIM_CNF_FREE_COPY()

  DESCRIPTION
    This function frees the memory that was prevously allocated when a deep
    copy of data inside the reponse was performed in MMGSDI callback.

  PARAMETERS

  RETURN VALUE
    None.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_cnf_free_copy
(
  mmgsdi_cnf_enum_type    cnf_type,
  mmgsdi_cnf_type        *cnf_ptr
)
{
  mmgsdi_file_security_access_type* sec_ptr = NULL;

  switch(cnf_type)
  {
    case MMGSDI_READ_CNF:
      if (cnf_ptr->read_cnf.read_data.data_ptr != NULL)
      {
        uimqmi_free(cnf_ptr->read_cnf.read_data.data_ptr);
      }
      break;

    case MMGSDI_GET_FILE_ATTR_CNF:
      if (cnf_ptr->get_file_attr_cnf.raw_file_attr_data.data_ptr != NULL)
      {
        uimqmi_free(cnf_ptr->get_file_attr_cnf.raw_file_attr_data.data_ptr);
      }
      switch (cnf_ptr->get_file_attr_cnf.file_attrib.file_type)
      {
        case MMGSDI_TRANSPARENT_FILE:
          sec_ptr = &cnf_ptr->get_file_attr_cnf.file_attrib.file_info.transparent_file.file_security;
          break;
        case MMGSDI_LINEAR_FIXED_FILE:
          sec_ptr = &cnf_ptr->get_file_attr_cnf.file_attrib.file_info.linear_fixed_file.file_security;
          break;
        case MMGSDI_CYCLIC_FILE:
          sec_ptr = &cnf_ptr->get_file_attr_cnf.file_attrib.file_info.cyclic_file.file_security;
          break;
        default:
          break;
      }
      if (sec_ptr != NULL)
      {
        if (sec_ptr->read.protection_pin_ptr)
        {
          uimqmi_free(sec_ptr->read.protection_pin_ptr);
        }
        if (sec_ptr->write.protection_pin_ptr)
        {
          uimqmi_free(sec_ptr->write.protection_pin_ptr);
        }
        if (sec_ptr->increase.protection_pin_ptr)
        {
          uimqmi_free(sec_ptr->increase.protection_pin_ptr);
        }
        if (sec_ptr->invalidate_deactivate.protection_pin_ptr)
        {
          uimqmi_free(sec_ptr->invalidate_deactivate.protection_pin_ptr);
        }
        if (sec_ptr->rehabilitate_activate.protection_pin_ptr)
        {
          uimqmi_free(sec_ptr->rehabilitate_activate.protection_pin_ptr);
        }
      }
      break;

    case MMGSDI_ISIM_AUTH_CNF:
      if (cnf_ptr->isim_auth_cnf.res.data_ptr != NULL)
      {
          uimqmi_free(cnf_ptr->isim_auth_cnf.res.data_ptr);
      }
      if (cnf_ptr->isim_auth_cnf.ck.data_ptr != NULL)
      {
          uimqmi_free(cnf_ptr->isim_auth_cnf.ck.data_ptr);
      }
      if (cnf_ptr->isim_auth_cnf.ik.data_ptr != NULL)
      {
          uimqmi_free(cnf_ptr->isim_auth_cnf.ik.data_ptr);
      }
      if (cnf_ptr->isim_auth_cnf.auts.data_ptr != NULL)
      {
          uimqmi_free(cnf_ptr->isim_auth_cnf.auts.data_ptr);
      }
      break;

    case MMGSDI_USIM_AUTH_CNF:
      if (cnf_ptr->usim_auth_cnf.auth_response.data_ptr != NULL)
      {
          uimqmi_free(cnf_ptr->usim_auth_cnf.auth_response.data_ptr);
      }
      break;

    case MMGSDI_COMPUTE_IP_AUTH_CNF:
      if (cnf_ptr->compute_ip_cnf.cmpt_ip_response_data.data_ptr != NULL)
      {
          uimqmi_free(cnf_ptr->compute_ip_cnf.cmpt_ip_response_data.data_ptr);
      }
      break;

    case MMGSDI_SEND_APDU_EXT_CNF:
      if (cnf_ptr->send_apdu_ext_cnf.apdu_data.data_ptr != NULL)
      {
          uimqmi_free(cnf_ptr->send_apdu_ext_cnf.apdu_data.data_ptr);
      }
      break;

    case MMGSDI_SAP_GET_ATR_CNF:
      if (cnf_ptr->sap_get_atr_cnf.atr_data.data_ptr != NULL)
      {
          uimqmi_free(cnf_ptr->sap_get_atr_cnf.atr_data.data_ptr);
      }
      break;

    case MMGSDI_SAP_SEND_APDU_CNF:
      if (cnf_ptr->sap_send_apdu_cnf.apdu_data.data_ptr != NULL)
      {
        uimqmi_free(cnf_ptr->sap_send_apdu_cnf.apdu_data.data_ptr);
      }
      break;

    case MMGSDI_SAP_CARD_READER_STATUS_CNF:
      if (cnf_ptr->sap_card_reader_status_cnf.card_reader_status_data.data_ptr != NULL)
      {
          uimqmi_free(cnf_ptr->sap_card_reader_status_cnf.card_reader_status_data.data_ptr);
      }
      break;

    case MMGSDI_GET_ATR_CNF:
      if (cnf_ptr->get_atr_cnf.atr_data.data_ptr != NULL)
      {
          uimqmi_free(cnf_ptr->get_atr_cnf.atr_data.data_ptr);
      }
      break;

    case MMGSDI_SESSION_OPEN_WITH_SELECT_RSP_CNF:
      if (cnf_ptr->session_open_with_sel_rsp_cnf.select_rsp.data_ptr != NULL)
      {
          uimqmi_free(cnf_ptr->session_open_with_sel_rsp_cnf.select_rsp.data_ptr);
      }
      break;

    case MMGSDI_SESSION_OPEN_EXT_CNF:
      if (cnf_ptr->session_open_ext_cnf.session_info_ptr != NULL)
      {
          uimqmi_free(cnf_ptr->session_open_ext_cnf.session_info_ptr);
      }
      break;

    case MMGSDI_INCREASE_CNF:
      if (cnf_ptr->increase_cnf.increased_data.data_ptr != NULL)
      {
        uimqmi_free(cnf_ptr->increase_cnf.increased_data.data_ptr);
      }
      break;

    case MMGSDI_SESSION_SELECT_AID_CNF:
      if (cnf_ptr->session_select_aid_cnf.select_rsp.data_ptr != NULL)
      {
        uimqmi_free(cnf_ptr->session_select_aid_cnf.select_rsp.data_ptr);
      }
      break;

    case MMGSDI_CARD_STATUS_CNF:
      if (cnf_ptr->status_cnf.status_data.data_ptr != NULL)
      {
        uimqmi_free(cnf_ptr->status_cnf.status_data.data_ptr);
      }
      break;

    case MMGSDI_SEARCH_CNF:
      if (cnf_ptr->search_cnf.searched_record_nums.data_ptr != NULL)
      {
        uimqmi_free(cnf_ptr->search_cnf.searched_record_nums.data_ptr);
      }

    default:
      /* Other requests don't need to free because they did not
         make allocations during the copy */
      break;
  }
} /* qmi_uim_cnf_free_copy */


/*===========================================================================
  FUNCTION QMI_UIM_EVENT_DEEP_COPY()

  DESCRIPTION
    This function makes a deep copy of the mmgsdi_event_data_type pointer
    passed from MMGSDI to QMI and is required to pass the event in the
    QMI context.

  PARAMETERS

  RETURN VALUE
    None.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_event_deep_copy
(
  mmgsdi_event_data_type        *event_dst_ptr,
  const mmgsdi_event_data_type  *event_src_ptr
)
{
  ASSERT(event_src_ptr);
  ASSERT(event_dst_ptr);

  /* Events can be simply memcpy'ed */
  (void)memscpy(event_dst_ptr,
                sizeof(mmgsdi_event_data_type),
         event_src_ptr,
         sizeof(mmgsdi_event_data_type));

  /* A deep copy is required for the REFRESH event, so
     handle it in special way. */
  if (event_src_ptr->evt == MMGSDI_REFRESH_EVT)
  {
    qmi_uim_deep_copy(
       (void**)&event_dst_ptr->data.refresh.refresh_files.file_list_ptr,
       (void*)event_src_ptr->data.refresh.refresh_files.file_list_ptr,
       event_src_ptr->data.refresh.refresh_files.num_files * sizeof(mmgsdi_file_enum_type));
    qmi_uim_deep_copy(
       (void**)&event_dst_ptr->data.refresh.refresh_files.file_path_ptr,
       (void*)event_src_ptr->data.refresh.refresh_files.file_path_ptr,
       event_src_ptr->data.refresh.refresh_files.file_path_len);
    memset(&event_dst_ptr->data.refresh.plmn_list, 0, sizeof(mmgsdi_data_type));
  }
} /* qmi_uim_event_deep_copy */


/*===========================================================================
  FUNCTION QMI_UIM_EVENT_FREE_COPY()

  DESCRIPTION
    This function makes a deep copy of the mmgsdi_cnf_type pointer
    passed from MMGSDI to QMI and is required to pass the command in the
    QMI context.

  PARAMETERS

  RETURN VALUE
    None.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_event_free_copy
(
  mmgsdi_event_data_type * event_ptr
)
{
  ASSERT(event_ptr);

  /* Refresh is the only case that requires deep copy and needs
     to be freed */
  if (event_ptr->evt == MMGSDI_REFRESH_EVT)
  {
    if (event_ptr->data.refresh.refresh_files.file_list_ptr != NULL)
    {
      uimqmi_free(event_ptr->data.refresh.refresh_files.file_list_ptr);
      event_ptr->data.refresh.refresh_files.file_list_ptr = NULL;
    }
    if (event_ptr->data.refresh.refresh_files.file_path_ptr != NULL)
    {
      uimqmi_free(event_ptr->data.refresh.refresh_files.file_path_ptr);
      event_ptr->data.refresh.refresh_files.file_path_ptr = NULL;
    }
  }
} /* qmi_uim_event_free_copy */


/*===========================================================================
  FUNCTION QMI_UIM_GET_CB_USERDATA

  DESCRIPTION
    To obtain the structure used for MMGSDI callbacks

  PARAMETERS
    request_id             : Type of the request
    cmd_buf_ptr            : QMI command buffer required for response
    token_ptr              : pointer to token info sent by client
    clid                   : Client id of the control point

  RETURN VALUE
    qmi_uimi_userdata_type : Poiner to the structure used for userdata

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_uimi_userdata_type* qmi_uim_get_cb_userdata
(
  qmi_uimi_cmd_val_e_type    request_id,
  qmi_cmd_buf_type         * cmd_buf_ptr,
  const uint32             * token_ptr,
  uint8                      clid
)
{
  uint16                    i            = 0;
  qmi_uimi_userdata_type  * userdata_ptr = NULL;

  ASSERT(qmi_uim_global_ptr);
  ASSERT(qmi_uim_state_ptr);

  if (clid == QMI_SVC_CLID_UNUSED || clid > UIMI_MAX_CLIDS)
  {
    UIM_MSG_ERR_1("Invalid Client ID: 0x%x", clid);
    return NULL;
  }

  for (i = 0; i < QMI_UIM_MAX_PARALLEL_CMD; i++)
  {
    if (!qmi_uim_global_ptr->cb_userdata[i].in_use)
    {
      userdata_ptr = &qmi_uim_global_ptr->cb_userdata[i];
      memset(userdata_ptr, 0, sizeof(qmi_uimi_userdata_type));

      /* Exit loop soon after an unused userdata member is found */
      break;
    }
  }

  /* Allocate dynamically if no free member in array */
  if (userdata_ptr == NULL)
  {
    userdata_ptr = uimqmi_malloc(sizeof(qmi_uimi_userdata_type));
    if (userdata_ptr == NULL)
    {
      UIM_MSG_ERR_0("Dynamic allocation of userdata buffer failed for MMGSDI function");
      return NULL;
    }

    memset(userdata_ptr, 0, sizeof(qmi_uimi_userdata_type));
    userdata_ptr->is_dynamic  = TRUE;
  }

  /* Update parameters */
  userdata_ptr->in_use           = TRUE;
  userdata_ptr->request_id       = request_id;
  userdata_ptr->cmd_buf_ptr      = cmd_buf_ptr;
  userdata_ptr->clid             = clid;
  userdata_ptr->client_reg_count = qmi_uim_state_ptr->client_reg_count[userdata_ptr->clid - 1];

  if (token_ptr)
  {
    userdata_ptr->ind_token.token    = *token_ptr;
    userdata_ptr->ind_token.is_valid = TRUE;
  }

  return userdata_ptr;
} /* qmi_uim_get_cb_userdata */


/*===========================================================================
  FUNCTION QMI_UIM_FREE_CB_USERDATA

  DESCRIPTION
    To free the structure passed as user data while invoking APIs.
    It is safe to call it from different task context when API callback is hit.

  PARAMETERS
    request_id             : Type of the request
    cmd_buf_ptr            : QMI command buffer required for response

  RETURN VALUE
    qmi_uimi_userdata_type : Poiner to the structure used for userdata

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_free_cb_userdata
(
  qmi_uimi_userdata_type*  cb_userdata_ptr
)
{
  if (cb_userdata_ptr != NULL)
  {
    /* Free memory specific for each request id */
    switch(cb_userdata_ptr->request_id)
    {
      case UIMI_CMD_VAL_READ_RECORD:
        if (cb_userdata_ptr->data.read_record.records_cnf != NULL)
        {
          uint16   i = 0;
          for (i = 0; i < cb_userdata_ptr->data.read_record.read_records; i++)
          {
            /* Need to loop only thru the records that were read (successfully or not) */
            if (cb_userdata_ptr->data.read_record.records_cnf[i].read_data.data_ptr)
            {
              uimqmi_free(cb_userdata_ptr->data.read_record.records_cnf[i].read_data.data_ptr);
              cb_userdata_ptr->data.read_record.records_cnf[i].read_data.data_ptr = NULL;
            }
          }
              uimqmi_free(cb_userdata_ptr->data.read_record.records_cnf);
          cb_userdata_ptr->data.read_record.records_cnf = NULL;
        }
        break;
      case UIMI_CMD_VAL_WRITE_RECORD:
        if (cb_userdata_ptr->data.write_record.data.data_ptr != NULL)
        {
              uimqmi_free(cb_userdata_ptr->data.write_record.data.data_ptr);
          cb_userdata_ptr->data.write_record.data.data_ptr = NULL;
        }
        break;
      case UIMI_CMD_VAL_PERSONALIZATION:
      case UIMI_CMD_VAL_PERSONALIZATION_SECURE:
        if(cb_userdata_ptr->data.simlock_lock.code_ptr != NULL)
        {
          uimqmi_free(cb_userdata_ptr->data.simlock_lock.code_ptr);
          cb_userdata_ptr->data.simlock_lock.code_ptr = NULL;
        }
        break;
      default:
        /* Nothing to free */
        break;
    }

    /* We free if it is a dynamically allocated pointer, else we only clear it */
    if(cb_userdata_ptr->is_dynamic)
    {
      memset(cb_userdata_ptr, 0, sizeof(qmi_uimi_userdata_type));
      uimqmi_free(cb_userdata_ptr);
      cb_userdata_ptr = NULL;
    }
    else
    {
      memset(cb_userdata_ptr, 0, sizeof(qmi_uimi_userdata_type));
    }
  }
} /* qmi_uim_free_cb_userdata */


/*===========================================================================
  FUNCTION QMI_UIM_SAME_FILE

  DESCRIPTION
    Compares to files passed by path.

  PARAMETERS
    file1         : first file
    file2         : second file

  RETURN VALUE
    boolean       : Indicates if the two files are the same

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_uim_same_file
(
  mmgsdi_path_type         file1,
  mmgsdi_path_type         file2
)
{
  if (file1.path_len > 0 &&
      file1.path_len <= MMGSDI_MAX_PATH_LEN &&
      file1.path_len == file2.path_len)
  {
    if (memcmp(file1.path_buf, file2.path_buf, file1.path_len * sizeof(uint16)) == 0)
    {
      return TRUE;
    }
  }
  return FALSE;
} /* qmi_uim_same_file */


/*===========================================================================
  FUNCTION QMI_UIM_CHECK_CACHED_RECORD_TYPE

  DESCRIPTION
    This function checks the cached type of a record file.

  PARAMETERS
    session_id             : Session id
    file                   : Path of the file
    record_type_ptr        : Output value with type of the record file

  RETURN VALUE
    boolean                : Indicates if the file was found in the cache

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_uim_check_cached_record_type
(
  mmgsdi_session_id_type             session_id,
  mmgsdi_access_type                 file_access,
  mmgsdi_file_structure_enum_type *  record_type_ptr
)
{
  qmi_uimi_file_record_type * current_ptr  = NULL;

  ASSERT(qmi_uim_global_ptr);
  ASSERT(record_type_ptr);

  current_ptr = qmi_uim_global_ptr->record_cache_ptr;
  while (current_ptr != NULL)
  {
    if (current_ptr->session_id == session_id &&
        current_ptr->file_access.access_method == file_access.access_method)
    {
      if ((file_access.access_method == MMGSDI_EF_ENUM_ACCESS &&
           current_ptr->file_access.file.file_enum == file_access.file.file_enum) ||
          (file_access.access_method == MMGSDI_BY_PATH_ACCESS &&
           qmi_uim_same_file(current_ptr->file_access.file.path_type, file_access.file.path_type)))
      {
        *record_type_ptr = current_ptr->record_type;
        return TRUE;
      }
    }

    current_ptr = current_ptr->next_ptr;
  }

  /* File not found in the cache */
  return FALSE;
} /* qmi_uim_check_cached_record_type */


/*===========================================================================
  FUNCTION QMI_UIM_CACHE_RECORD_TYPE

  DESCRIPTION
    This function add a record type to the cache: this is used for write
    operations, where we need to know if the file is cyclic or linear-fixed.

  PARAMETERS
    session_id             : Session id
    file                   : Path of the file
    record_type            : Type of the record file

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_cache_record_type
(
  mmgsdi_session_id_type             session_id,
  mmgsdi_access_type                 file_access,
  mmgsdi_file_structure_enum_type    record_type
)
{
  mmgsdi_file_structure_enum_type prev_record_type = MMGSDI_LINEAR_FIXED_FILE;
  qmi_uimi_file_record_type *     current_ptr      = NULL;

  ASSERT(qmi_uim_global_ptr);

  /* Cache only cyclic and linear fixed files */
  if (record_type != MMGSDI_LINEAR_FIXED_FILE &&
      record_type != MMGSDI_CYCLIC_FILE)
  {
    return;
  }

  /* Cache only files in provisioning sessions and card sessions */
  if (session_id != qmi_uim_global_ptr->mmgsdi_gw_session_id[0] &&
      session_id != qmi_uim_global_ptr->mmgsdi_gw_session_id[1] &&
      session_id != qmi_uim_global_ptr->mmgsdi_gw_session_id[2] &&
      session_id != qmi_uim_global_ptr->mmgsdi_1x_session_id[0] &&
      session_id != qmi_uim_global_ptr->mmgsdi_1x_session_id[1] &&
      session_id != qmi_uim_global_ptr->mmgsdi_1x_session_id[2] &&
      session_id != qmi_uim_global_ptr->mmgsdi_card_slot_session_id[0] &&
      session_id != qmi_uim_global_ptr->mmgsdi_card_slot_session_id[1] &&
      session_id != qmi_uim_global_ptr->mmgsdi_card_slot_session_id[2])
  {
    return;
  }

  /* Cache only access by enum or by path */
  if (file_access.access_method != MMGSDI_EF_ENUM_ACCESS &&
      file_access.access_method != MMGSDI_BY_PATH_ACCESS)
  {
    return;
  }

  if (qmi_uim_check_cached_record_type(session_id, file_access, &prev_record_type))
  {
    UIM_MSG_HIGH_1("Record type already in cache, type = 0x%x",
                   prev_record_type);
    return;
  }

  /* File is not in the cache and needs to be added */
  current_ptr = uimqmi_malloc(sizeof(qmi_uimi_file_record_type));
  if (current_ptr != NULL)
  {
    memset(current_ptr, 0, sizeof(qmi_uimi_file_record_type));

    /* Populate values of new item of cache */
    current_ptr->session_id = session_id;
    current_ptr->record_type = record_type;
    (void)memscpy(&current_ptr->file_access, sizeof(mmgsdi_access_type),
                  &file_access, sizeof(mmgsdi_access_type));

    /* Add new node on top of the list */
    current_ptr->next_ptr = qmi_uim_global_ptr->record_cache_ptr;
    qmi_uim_global_ptr->record_cache_ptr = current_ptr;

    UIM_MSG_HIGH_0("Added record type to the cache");
  }
} /* qmi_uim_cache_record_type */


/*===========================================================================
  FUNCTION QMI_UIM_REMOVE_CACHED_RECORD_TYPE

  DESCRIPTION
    This function removes all the items of record type for a specific session.

  PARAMETERS
    session_id             : Session id

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_remove_cached_record_type
(
  mmgsdi_session_id_type             session_id
)
{
  qmi_uimi_file_record_type * current_ptr  = NULL;
  qmi_uimi_file_record_type * previous_ptr = NULL;

  ASSERT(qmi_uim_global_ptr);

  UIM_MSG_HIGH_0("Removing all cached record types for session");

  current_ptr = qmi_uim_global_ptr->record_cache_ptr;
  while (current_ptr != NULL)
  {
    if (current_ptr->session_id == session_id)
    {
      /* Remove item from the cache */
      if (previous_ptr != NULL)
      {
        previous_ptr->next_ptr = current_ptr->next_ptr;
        uimqmi_free(current_ptr);
        current_ptr = previous_ptr->next_ptr;
      }
      else
      {
        qmi_uim_global_ptr->record_cache_ptr = current_ptr->next_ptr;
        uimqmi_free(current_ptr);
        current_ptr = qmi_uim_global_ptr->record_cache_ptr;
      }
    }
    else
    {
      /* Go to the next item */
      previous_ptr = current_ptr;
      current_ptr  = current_ptr->next_ptr;
    }
  }
} /* qmi_uim_remove_cached_record_type */


/*===========================================================================
  FUNCTION QMI_UIM_CONVERT_MMGSDI_STATUS_TO_ERRVAL

  DESCRIPTION
    To obtain QMI client-specific error message from MMGSDI error message

  PARAMETERS
    mmgsdi_status   : MMGSDI return value

  RETURN VALUE
    errval          : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_convert_mmgsdi_status_to_errval
(
  mmgsdi_return_enum_type mmgsdi_status
)
{
  qmi_error_e_type errval  = QMI_ERR_INTERNAL;

  switch(mmgsdi_status)
  {
    case MMGSDI_SUCCESS:
      errval = QMI_ERR_NONE;
      break;

    case MMGSDI_WARNING_NO_INFO_GIVEN:
    case MMGSDI_INCOMPAT_PIN_STATUS:
    case MMGSDI_PERSO_CHECK_FAILED:
      errval = QMI_ERR_NO_EFFECT;
      break;

    case MMGSDI_INCORRECT_CODE:
    case MMGSDI_PERSO_INVALID_CK:
      errval = QMI_ERR_INCORRECT_PIN;
      break;

    case MMGSDI_CODE_BLOCKED:
    case MMGSDI_PERSO_CK_BLOCKED:
      errval = QMI_ERR_PIN_BLOCKED;
      break;

    case MMGSDI_CODE_PERM_BLOCKED:
      errval = QMI_ERR_PIN_PERM_BLOCKED;
      break;

    case MMGSDI_PIN_NOT_INITIALIZED:
      errval = QMI_ERR_SIM_NOT_INITIALIZED;
      break;

    case MMGSDI_ACCESS_DENIED:
      errval = QMI_ERR_ACCESS_DENIED;
      break;

    case MMGSDI_NOT_FOUND:
      errval = QMI_ERR_SIM_FILE_NOT_FOUND;
      break;

    case MMGSDI_INCORRECT_PARAMS:
      errval = QMI_ERR_INTERNAL;
      break;

    case MMGSDI_AUTH_ERROR_GSM_CNTXT_NOT_SUP:
    case MMGSDI_AUTH_ERROR_INCORRECT_MAC:
    case MMGSDI_AUTH_FAIL:
    case MMGSDI_AUTS_FAIL:
      errval = QMI_ERR_AUTHENTICATION_FAILED;
      break;

    case MMGSDI_MULTI_PROFILE_NO_EFFECT:
      errval = QMI_ERR_NO_EFFECT;
      break;

    case MMGSDI_MULTI_PROFILE_NOT_SUPPORTED:
      errval = QMI_ERR_NOT_SUPPORTED;
      break;

    default:
      errval = QMI_ERR_INTERNAL;
  }

  if(mmgsdi_status != MMGSDI_SUCCESS )
  {
    UIM_MSG_HIGH_1("Received mmgsdi_status 0x%x", mmgsdi_status);
  }

  return errval;
} /* qmi_uim_convert_mmgsdi_status_to_errval() */


/*===========================================================================
  FUNCTION QMI_UIM_CONVERT_GBA_STATUS_TO_ERRVAL

  DESCRIPTION
    To obtain QMI client-specific error message from GBA error message

  PARAMETERS
    gba_status   : GBA return value

  RETURN VALUE
    errval       : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_convert_gba_status_to_errval
(
  gba_result_enum_type gba_status
)
{
  qmi_error_e_type errval  = QMI_ERR_INTERNAL;

  UIM_MSG_HIGH_1("Received gba_status 0x%x", gba_status);

  switch(gba_status)
  {
    case GBA_SUCCESS:
      errval = QMI_ERR_NONE;
      break;

    case GBA_GENERIC_ERROR:
    case GBA_SIM_ERROR:
      errval = QMI_ERR_INTERNAL;
      break;

    case GBA_INCORRECT_PARAMS:
      errval = QMI_ERR_INVALID_ARG;
      break;

    case GBA_TIMEOUT:
      errval = QMI_ERR_ABORTED;
      break;

     case GBA_AUTH_FAILURE:
     case GBA_SERVER_ERROR:
      errval = QMI_ERR_AUTHENTICATION_FAILED;
      break;

    case GBA_MEMORY_ERROR_HEAP_EXHAUSTED:
      errval = QMI_ERR_NO_MEMORY;
      break;

    case GBA_SIM_NOT_READY:
      errval = QMI_ERR_DEVICE_NOT_READY;
      break;

    case GBA_UNSUPPORTED:
      errval = QMI_ERR_NOT_SUPPORTED;
      break;

    default:
      errval = QMI_ERR_INTERNAL;
      break;
  }

  return errval;
} /* qmi_uim_convert_gba_status_to_errval() */


/*===========================================================================
  FUNCTION QMI_UIM_CONVERT_SIMLOCK_STATUS_TO_ERRVAL

  DESCRIPTION
    To obtain QMI client-specific error message from SIM Lock error message

  PARAMETERS
    simlock_status  : SIM Lock return value

  RETURN VALUE
    errval          : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_convert_simlock_status_to_errval
(
  simlock_result_enum_type simlock_status
)
{
  qmi_error_e_type errval  = QMI_ERR_INTERNAL;

  UIM_MSG_HIGH_1("Received simlock_status 0x%x", simlock_status);

  switch(simlock_status)
  {
    case SIMLOCK_SUCCESS:
      errval = QMI_ERR_NONE;
      break;

    case SIMLOCK_INVALID_STATE:
      errval = QMI_ERR_NO_EFFECT;
      break;

    case SIMLOCK_INCORRECT_KEY:
      errval = QMI_ERR_INCORRECT_PIN;
      break;

    case SIMLOCK_MAX_RETRIES_REACHED:
      errval = QMI_ERR_PIN_PERM_BLOCKED;
      break;

    case SIMLOCK_INCORRECT_PARAMS:
      errval = QMI_ERR_MALFORMED_MSG;
      break;

    case SIMLOCK_UNSUPPORTED:
      errval = QMI_ERR_NOT_SUPPORTED;
      break;

    default:
      UIM_MSG_HIGH_0("Unhandled simlock_status received");
      errval = QMI_ERR_INTERNAL;
  }

  return errval;
} /* qmi_uim_convert_simlock_status_to_errval() */


/*===========================================================================
  FUNCTION QMI_UIM_CONVERT_LPA_STATUS_TO_ERRVAL

  DESCRIPTION
    To obtain QMI client-specific error message from LPA error message

  PARAMETERS
    lpa_status   : LPA return value

  RETURN VALUE
    errval       : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_convert_lpa_status_to_errval
(
  lpa_result_enum_type lpa_status
)
{
  qmi_error_e_type errval  = QMI_ERR_INTERNAL;

  UIM_MSG_HIGH_1("Received lpa_status 0x%x", lpa_status);

  switch(lpa_status)
  {
    case LPA_SUCCESS:
      errval = QMI_ERR_NONE;
      break;

    case LPA_ERROR_PROFILE_NOT_IN_DISABLED_STATE:
    case LPA_ERROR_PROFILE_NOT_IN_ENABLED_STATE:
      errval = QMI_ERR_NO_EFFECT;
      break;

    case LPA_ERROR_HEAP_EXHAUSTED:
      errval = QMI_ERR_NO_MEMORY;
      break;

    case LPA_ERROR_PROFILE_NOT_FOUND:
      errval = QMI_ERR_INVALID_PROFILE;
      break;

    case LPA_ERROR_NETWORK:
      errval = QMI_ERR_NETWORK_NOT_READY;
      break;

    case LPA_ERROR_SIM_NOT_READY:
      errval = QMI_ERR_SIM_NOT_INITIALIZED;
      break;

    case LPA_ERROR_CONFIRMATION_CODE_REQUIRED:
      errval = QMI_ERR_INFO_UNAVAILABLE;
      break;

    default:
      errval = QMI_ERR_INTERNAL;
      break;
  }

  return errval;
} /* qmi_uim_convert_lpa_status_to_errval */


/*===========================================================================
  FUNCTION QMI_UIM_CONVERT_MMGSDI_SLOT_TO_LPA_SLOT

  DESCRIPTION
    To obtain LPA slot type from MMGSDI slot type

  PARAMETERS
    lpa_status   : LPA return value

  RETURN VALUE
    errval       : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_convert_mmgsdi_slot_to_lpa_slot
(
  mmgsdi_slot_id_enum_type          mmgsdi_slot,
  lpa_slot_id_enum_type            *lpa_slot_ptr
)
{
  if(lpa_slot_ptr == NULL)
  {
    return QMI_ERR_INTERNAL;
  }

  switch(mmgsdi_slot)
  {
    case MMGSDI_SLOT_1:
      *lpa_slot_ptr = LPA_SLOT_1;
      break;

    case MMGSDI_SLOT_2:
      *lpa_slot_ptr = LPA_SLOT_2;
      break;

    default:
      return QMI_ERR_INVALID_ARG;
  }

  return QMI_ERR_NONE;
} /* qmi_uim_convert_mmgsdi_slot_to_lpa_slot */


/*===========================================================================
  FUNCTION QMI_UIM_CONVERT_MMGSDI_SESSION_TO_GBA_SESSION

  DESCRIPTION
    Convert MMGSDI session type to GBA session type.

  PARAMETERS
    mmgsdi_session_type  : MMGSDI session type
    gba_session_type_ptr : GBA session type

  RETURN VALUE
    errval               : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_convert_mmgsdi_session_to_gba_session
(
  mmgsdi_session_type_enum_type   mmgsdi_session_type,
  gba_session_type               *gba_session_type_ptr
)
{
  if(gba_session_type_ptr == NULL)
  {
    return QMI_ERR_INTERNAL;
  }

  switch(mmgsdi_session_type)
  {
    case MMGSDI_GW_PROV_PRI_SESSION:
      *gba_session_type_ptr = GBA_3GPP_PROV_SESSION_PRI;
      break;

    case MMGSDI_GW_PROV_SEC_SESSION:
      *gba_session_type_ptr = GBA_3GPP_PROV_SESSION_SEC;
      break;

    case MMGSDI_NON_PROV_SESSION_SLOT_1:
      *gba_session_type_ptr = GBA_NON_PROV_SESSION_SLOT_1;
      break;

    case MMGSDI_NON_PROV_SESSION_SLOT_2:
      *gba_session_type_ptr = GBA_NON_PROV_SESSION_SLOT_2;
      break;

    default:
      UIM_MSG_ERR_1("session type not supported: 0x%x", mmgsdi_session_type);
      return QMI_ERR_INVALID_ARG;
  }

  return QMI_ERR_NONE;
} /* qmi_uim_convert_mmgsdi_session_to_gba_session */


/*===========================================================================
  FUNCTION QMI_UIM_SESSION_TYPE_TO_SESSION_ID

  DESCRIPTION
    Convert a session type and AID in the corresponding session id.

  PARAMETERS
    session_id_ptr : Output parameter with session id
    session_info   : session type
    aid            : AID value

  RETURN VALUE
    errval         : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_session_type_to_session_id
(
  mmgsdi_session_id_type *        session_id_ptr,
  mmgsdi_session_type_enum_type   session_type,
  mmgsdi_static_data_type         aid
)
{
  uint16  i  = 0;

  ASSERT(session_id_ptr);
  ASSERT(qmi_uim_global_ptr);

  /* Initialize output value */
  *session_id_ptr = UIM_INVALID_SESSION_ID;

  switch(session_type)
  {
    case MMGSDI_GW_PROV_PRI_SESSION:
      *session_id_ptr = qmi_uim_global_ptr->mmgsdi_gw_session_id[0];
      break;

    case MMGSDI_1X_PROV_PRI_SESSION:
      *session_id_ptr = qmi_uim_global_ptr->mmgsdi_1x_session_id[0];
      break;

    case MMGSDI_GW_PROV_SEC_SESSION:
      *session_id_ptr = qmi_uim_global_ptr->mmgsdi_gw_session_id[1];
      break;

    case MMGSDI_1X_PROV_SEC_SESSION:
      *session_id_ptr = qmi_uim_global_ptr->mmgsdi_1x_session_id[1];
      break;

    case MMGSDI_GW_PROV_TER_SESSION:
      *session_id_ptr = qmi_uim_global_ptr->mmgsdi_gw_session_id[2];
      break;

    case MMGSDI_1X_PROV_TER_SESSION:
      *session_id_ptr = qmi_uim_global_ptr->mmgsdi_1x_session_id[2];
      break;

    case MMGSDI_CARD_SESSION_SLOT_1:
      *session_id_ptr = qmi_uim_global_ptr->mmgsdi_card_slot_session_id[0];
      break;

    case MMGSDI_CARD_SESSION_SLOT_2:
      *session_id_ptr = qmi_uim_global_ptr->mmgsdi_card_slot_session_id[1];
      break;

    case MMGSDI_CARD_SESSION_SLOT_3:
      *session_id_ptr = qmi_uim_global_ptr->mmgsdi_card_slot_session_id[2];
      break;

    case MMGSDI_NON_PROV_SESSION_SLOT_1:
    case MMGSDI_NON_PROV_SESSION_SLOT_2:
    case MMGSDI_NON_PROV_SESSION_SLOT_3:
      if (aid.data_len == QMI_UIM_TLV_CHANNEL_ID_LEN)
      {
        mmgsdi_slot_id_enum_type slot = MMGSDI_SLOT_1;
        if(session_type == MMGSDI_NON_PROV_SESSION_SLOT_1)
        {
          slot = MMGSDI_SLOT_1;
        }
        else if(session_type == MMGSDI_NON_PROV_SESSION_SLOT_2)
        {
          slot = MMGSDI_SLOT_2;
        }
        else
        {
          slot = MMGSDI_SLOT_3;
        }

        /* AID length is 1 for a session TLV that is overloaded with channel id, so check
           apdu_channel info for session_id */
        for (i = 0; i < UIM_MAX_APDU_CHANNEL_COUNT; i++)
        {
          if (qmi_uim_global_ptr->apdu_channel[i] &&
              qmi_uim_global_ptr->apdu_channel[i]->slot == slot &&
              qmi_uim_global_ptr->apdu_channel[i]->logical_channel == aid.data_ptr[0])
          {
            *session_id_ptr = qmi_uim_global_ptr->apdu_channel[i]->mmgsdi_session_id;
            break;
          }
        }
      }
      else if (aid.data_len <= MMGSDI_MAX_AID_LEN)
      {
        /* For all other AID length, check non_prov_session info */
        for (i = 0; i < UIM_MAX_NON_PROV_SESSIONS; i++)
        {
          if (qmi_uim_global_ptr->non_prov_session[i].init &&
              qmi_uim_global_ptr->non_prov_session[i].session_type == session_type)
          {
            if ((qmi_uim_global_ptr->non_prov_session[i].aid.data_len == 0 &&
                 aid.data_len == 0)||
                (qmi_uim_global_ptr->non_prov_session[i].aid.data_len > 0 &&
              qmi_uim_global_ptr->non_prov_session[i].aid.data_len == aid.data_len &&
                 memcmp( (void*)qmi_uim_global_ptr->non_prov_session[i].aid.data_ptr,
                        (void*)aid.data_ptr,
                         int32touint32(aid.data_len) ) == 0))
            {
              *session_id_ptr = qmi_uim_global_ptr->non_prov_session[i].mmgsdi_session_id;
              break;
            }
          }
        }
      }
      else
      {
        UIM_MSG_ERR_1("Unexpected aid length: 0x%x", aid.data_len);
        return QMI_ERR_INTERNAL;
      }
      break;

    default:
      UIM_MSG_ERR_1("Invalid session type: 0x%x", session_type);
      return QMI_ERR_INTERNAL;
  }

  /* Even if the session was found, it might be not initialized yet.
     Check the value before continuing */
  if (*session_id_ptr == UIM_INVALID_SESSION_ID)
  {
    UIM_MSG_ERR_1("Session not ready: 0x%x", session_type);
    if(session_type != MMGSDI_NON_PROV_SESSION_SLOT_1 &&
       session_type != MMGSDI_NON_PROV_SESSION_SLOT_2 &&
       session_type != MMGSDI_NON_PROV_SESSION_SLOT_3)
    {
      return QMI_ERR_DEVICE_NOT_READY;
    }
    return QMI_ERR_INTERNAL;
  }

  return QMI_ERR_NONE;
} /* qmi_uim_session_type_to_session_id */


/*===========================================================================
  FUNCTION QMI_UIM_SESSION_ID_TO_SESSION_TYPE

  DESCRIPTION
    Convert a session id in the corresponding session type and AID.

  PARAMETERS
    session_type_ptr : Output parameter with session type
    aid_ptr          : Output parameter with AID
    session_id       : session id

  RETURN VALUE
    errval           : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_session_id_to_session_type
(
  mmgsdi_session_type_enum_type * session_type_ptr,
  mmgsdi_static_data_type *       aid_ptr,
  mmgsdi_session_id_type          session_id
)
{
  uint16            i       = 0;
  qmi_error_e_type  result  = QMI_ERR_NONE;

  ASSERT(session_type_ptr);
  ASSERT(aid_ptr);
  ASSERT(qmi_uim_global_ptr);

  /* Initialize AID */
  memset(aid_ptr, 0, sizeof(mmgsdi_static_data_type));

  if (session_id == qmi_uim_global_ptr->mmgsdi_gw_session_id[0])
  {
    *session_type_ptr = MMGSDI_GW_PROV_PRI_SESSION;
  }
  else if (session_id == qmi_uim_global_ptr->mmgsdi_1x_session_id[0])
  {
    *session_type_ptr = MMGSDI_1X_PROV_PRI_SESSION;
  }
  else if (session_id == qmi_uim_global_ptr->mmgsdi_gw_session_id[1])
  {
    *session_type_ptr = MMGSDI_GW_PROV_SEC_SESSION;
  }
  else if (session_id == qmi_uim_global_ptr->mmgsdi_1x_session_id[1])
  {
    *session_type_ptr = MMGSDI_1X_PROV_SEC_SESSION;
  }
  else if (session_id == qmi_uim_global_ptr->mmgsdi_gw_session_id[2])
  {
    *session_type_ptr = MMGSDI_GW_PROV_TER_SESSION;
  }
  else if (session_id == qmi_uim_global_ptr->mmgsdi_1x_session_id[2])
  {
    *session_type_ptr = MMGSDI_1X_PROV_TER_SESSION;
  }
  else if (session_id == qmi_uim_global_ptr->mmgsdi_card_slot_session_id[0])
  {
    *session_type_ptr = MMGSDI_CARD_SESSION_SLOT_1;
  }
  else if (session_id == qmi_uim_global_ptr->mmgsdi_card_slot_session_id[1])
  {
    *session_type_ptr = MMGSDI_CARD_SESSION_SLOT_2;
  }
  else if (session_id == qmi_uim_global_ptr->mmgsdi_card_slot_session_id[2])
  {
    *session_type_ptr = MMGSDI_CARD_SESSION_SLOT_3;
  }
  else
  {
    /* Default to error case */
    result = QMI_ERR_INTERNAL;

    /* Check if it's a non provisioning session id */
    for (i = 0; i < UIM_MAX_NON_PROV_SESSIONS; i++)
    {
      if (qmi_uim_global_ptr->non_prov_session[i].init &&
          qmi_uim_global_ptr->non_prov_session[i].mmgsdi_session_id == session_id)
      {
        *session_type_ptr = qmi_uim_global_ptr->non_prov_session[i].session_type;
        (void)memscpy(aid_ptr,
                      sizeof(mmgsdi_static_data_type),
               &qmi_uim_global_ptr->non_prov_session[i].aid,
               sizeof(mmgsdi_static_data_type));

        result = QMI_ERR_NONE;
        break;
      }
    }
  }

  if (result != QMI_ERR_NONE)
  {
    UIM_MSG_ERR_1("Session id to session type: invalid session id: 0x%x",
                  session_id);
  }

  return result;
} /* qmi_uim_session_id_to_session_type */


/*===========================================================================
  FUNCTION QMI_UIM_SESSION_TYPE_TO_CARD_TYPE

  DESCRIPTION
    Convert a session type and AID in the corresponding card type.

  PARAMETERS
    card_type_ptr : Output parameter with card type
    session_info  : session type
    aid           : AID value

  RETURN VALUE
    errval         : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_session_type_to_card_type
(
  mmgsdi_app_enum_type *          card_type_ptr,
  mmgsdi_session_type_enum_type   session_type,
  mmgsdi_static_data_type         aid
)
{
  uint16                   i     = 0;
  uint16                   index = UIM_INVALID_APP_INDEX;
  mmgsdi_slot_id_enum_type slot  = MMGSDI_SLOT_1;

  ASSERT(card_type_ptr);
  ASSERT(qmi_uim_global_ptr);

  /* Initialize output value */
  *card_type_ptr = MMGSDI_APP_NONE;

  switch(session_type)
  {
    case MMGSDI_GW_PROV_PRI_SESSION:
      index = qmi_uim_global_ptr->card_state.index_gw[0];
      break;

    case MMGSDI_1X_PROV_PRI_SESSION:
      index = qmi_uim_global_ptr->card_state.index_1x[0];
      break;

    case MMGSDI_GW_PROV_SEC_SESSION:
      index = qmi_uim_global_ptr->card_state.index_gw[1];
      break;

    case MMGSDI_1X_PROV_SEC_SESSION:
      index = qmi_uim_global_ptr->card_state.index_1x[1];
      break;

    case MMGSDI_GW_PROV_TER_SESSION:
      index = qmi_uim_global_ptr->card_state.index_gw[2];
      break;

    case MMGSDI_1X_PROV_TER_SESSION:
      index = qmi_uim_global_ptr->card_state.index_1x[2];
      break;

    case MMGSDI_CARD_SESSION_SLOT_1:
    case MMGSDI_CARD_SESSION_SLOT_2:
    case MMGSDI_CARD_SESSION_SLOT_3:
      if(session_type == MMGSDI_CARD_SESSION_SLOT_1)
      {
        slot = MMGSDI_SLOT_1;
      }
      else if(session_type == MMGSDI_CARD_SESSION_SLOT_2)
      {
        slot = MMGSDI_SLOT_2;
      }
      else
      {
        slot = MMGSDI_SLOT_3;
      }

      for (i = 0; i < qmi_uim_global_ptr->card_state.num_apps &&
                  i < QMI_UIM_MAX_APP_COUNT; i++)
      {
        if (qmi_uim_global_ptr->card_state.application[i] != NULL &&
            qmi_uim_global_ptr->card_state.application[i]->slot == slot)
        {
          index = i;
          break;
        }
      }
      break;

    case MMGSDI_NON_PROV_SESSION_SLOT_1:
    case MMGSDI_NON_PROV_SESSION_SLOT_2:
    case MMGSDI_NON_PROV_SESSION_SLOT_3:
      if(session_type == MMGSDI_NON_PROV_SESSION_SLOT_1)
      {
        slot = MMGSDI_SLOT_1;
      }
      else if(session_type == MMGSDI_NON_PROV_SESSION_SLOT_2)
      {
        slot = MMGSDI_SLOT_2;
      }
      else
      {
        slot = MMGSDI_SLOT_3;
      }

      for (i = 0; i < qmi_uim_global_ptr->card_state.num_apps &&
                  i < QMI_UIM_MAX_APP_COUNT; i++)
      {
        if (qmi_uim_global_ptr->card_state.application[i] != NULL &&
            qmi_uim_global_ptr->card_state.application[i]->slot == slot &&
            qmi_uim_global_ptr->card_state.application[i]->aid.data_len == aid.data_len)
        {
          if (memcmp(qmi_uim_global_ptr->card_state.application[i]->aid.data_ptr,
                     aid.data_ptr,
                     (uint32)aid.data_len) == 0)
          {
            index = i;
            break;
          }
        }
      }
      break;

    default:
      UIM_MSG_ERR_1("Invalid session type: 0x%x", session_type);
      return QMI_ERR_INTERNAL;
  }

  /* Check if the index is valid */
  if (index >= qmi_uim_global_ptr->card_state.num_apps ||
      index >= QMI_UIM_MAX_APP_COUNT ||
      qmi_uim_global_ptr->card_state.application[index] == NULL)
  {
    UIM_MSG_ERR_1("Invalid index: 0x%x", index);
    return QMI_ERR_INTERNAL;
  }

  /* Check if type is valid */
  if (qmi_uim_global_ptr->card_state.application[index]->app_type != MMGSDI_APP_SIM &&
      qmi_uim_global_ptr->card_state.application[index]->app_type != MMGSDI_APP_RUIM &&
      qmi_uim_global_ptr->card_state.application[index]->app_type != MMGSDI_APP_USIM &&
      qmi_uim_global_ptr->card_state.application[index]->app_type != MMGSDI_APP_CSIM)
  {
    UIM_MSG_ERR_1("Invalid card type: 0x%x",
                  qmi_uim_global_ptr->card_state.application[index]->app_type);
    return QMI_ERR_INTERNAL;
  }

  *card_type_ptr = qmi_uim_global_ptr->card_state.application[index]->app_type;
  return QMI_ERR_NONE;
} /* qmi_uim_session_type_to_card_type */


/*===========================================================================
  FUNCTION QMI_UIM_SESSION_ID_TO_SLOT

  DESCRIPTION
    Convert a session id in the corresponding slot.

  PARAMETERS
    slot_ptr      : Output parameter with slot value
    session_id    : session id

  RETURN VALUE
    errval        : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_session_id_to_slot
(
  mmgsdi_slot_id_enum_type * slot_ptr,
  mmgsdi_session_id_type     session_id
)
{
  uint16 i     = 0;
  uint16 index = UIM_INVALID_APP_INDEX;

  ASSERT(slot_ptr);
  ASSERT(qmi_uim_global_ptr);

  for (i = 0; i < QMI_UIM_MAX_PROV_SESSIONS; i++)
  {
    if (session_id == qmi_uim_global_ptr->mmgsdi_gw_session_id[i])
    {
      index = qmi_uim_global_ptr->card_state.index_gw[i];
      break;
    }
    else if (session_id == qmi_uim_global_ptr->mmgsdi_1x_session_id[i])
    {
      index = qmi_uim_global_ptr->card_state.index_1x[i];
      break;
    }
  }

  if (index == UIM_INVALID_APP_INDEX)
  {
    for (i = 0; i < QMI_UIM_MAX_CARD_SESSIONS; i++)
    {
      if (session_id == qmi_uim_global_ptr->mmgsdi_card_slot_session_id[i])
      {
        switch (i)
        {
          case 0:
            *slot_ptr = MMGSDI_SLOT_1;
            return QMI_ERR_NONE;
          case 1:
            *slot_ptr = MMGSDI_SLOT_2;
            return QMI_ERR_NONE;
          case 2:
            *slot_ptr = MMGSDI_SLOT_3;
            return QMI_ERR_NONE;
          default:
            return QMI_ERR_INTERNAL;
        }
      }
    }

    /* Check if it's a non provisioning session id */
    for (i = 0; i < UIM_MAX_NON_PROV_SESSIONS; i++)
    {
      if (qmi_uim_global_ptr->non_prov_session[i].init &&
          qmi_uim_global_ptr->non_prov_session[i].mmgsdi_session_id == session_id)
      {
        switch (qmi_uim_global_ptr->non_prov_session[i].session_type)
        {
          case MMGSDI_NON_PROV_SESSION_SLOT_1:
            *slot_ptr = MMGSDI_SLOT_1;
            return QMI_ERR_NONE;

          case MMGSDI_NON_PROV_SESSION_SLOT_2:
            *slot_ptr = MMGSDI_SLOT_2;
            return QMI_ERR_NONE;

          case MMGSDI_NON_PROV_SESSION_SLOT_3:
            *slot_ptr = MMGSDI_SLOT_3;
            return QMI_ERR_NONE;

          default:
            /* Nothing to do */
            break;
        }
      }
    }

    /* Check if the session id belongs to an APDU session */
    for (i = 0; i < UIM_MAX_APDU_CHANNEL_COUNT; i++)
    {
      if (qmi_uim_global_ptr->apdu_channel[i] != NULL &&
          qmi_uim_global_ptr->apdu_channel[i]->mmgsdi_session_id == session_id)
      {
        *slot_ptr = qmi_uim_global_ptr->apdu_channel[i]->slot;
        return QMI_ERR_NONE;
      }
    }

    UIM_MSG_HIGH_1("Session id to slot: invalid session id: 0x%x", session_id);
    return QMI_ERR_INTERNAL;
  }

  /* We arrive here in case of provisioning application.
     Check index value. */
  if (index == UIM_INVALID_APP_INDEX ||
      index >= qmi_uim_global_ptr->card_state.num_apps ||
      index >= QMI_UIM_MAX_APP_COUNT ||
      qmi_uim_global_ptr->card_state.application[index] == NULL)
  {
    UIM_MSG_ERR_1("Invalid index for slot conversion: 0x%x", index);
    return QMI_ERR_INTERNAL;
  }

  *slot_ptr = qmi_uim_global_ptr->card_state.application[index]->slot;
  return QMI_ERR_NONE;
} /* qmi_uim_session_id_to_slot */


/*===========================================================================
  FUNCTION QMI_UIM_CARD_PROTOCOL()

  DESCRIPTION
    Utility function to find out if the card is ICC or UICC.

  PARAMETERS
    slot                       : slot

  RETURN VALUE
    mmgsdi_protocol_enum_type  : Whether the card is ICC or UICC

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static mmgsdi_protocol_enum_type qmi_uim_card_protocol
(
  mmgsdi_slot_id_enum_type  slot
)
{
  uint16   index            = 0;
  boolean  unknown_uicc_app = FALSE;

  ASSERT(qmi_uim_global_ptr);

  if (slot != MMGSDI_SLOT_1 &&
      slot != MMGSDI_SLOT_2 &&
      slot != MMGSDI_SLOT_3)
  {
    UIM_MSG_ERR_1("Invalid slot id: 0x%x", slot);
    return MMGSDI_NO_PROTOCOL;
  }

  for (index = 0; index < qmi_uim_global_ptr->card_state.num_apps &&
                  index < QMI_UIM_MAX_APP_COUNT; index++)
  {
    if (qmi_uim_global_ptr->card_state.application[index] != NULL &&
        qmi_uim_global_ptr->card_state.application[index]->slot == slot)
    {
      if (qmi_uim_global_ptr->card_state.application[index]->app_type == MMGSDI_APP_SIM ||
          qmi_uim_global_ptr->card_state.application[index]->app_type == MMGSDI_APP_RUIM)
      {
        return MMGSDI_ICC;
      }
      else if (qmi_uim_global_ptr->card_state.application[index]->app_type == MMGSDI_APP_USIM ||
               qmi_uim_global_ptr->card_state.application[index]->app_type == MMGSDI_APP_CSIM)
      {
        return MMGSDI_UICC;
      }
      else if (qmi_uim_global_ptr->card_state.application[index]->app_type == MMGSDI_APP_UNKNOWN)
      {
        unknown_uicc_app = TRUE;
      }
    }
  }

  /* no known GW or 1X apps but there is unknown uicc app, must be UICC card */
  if (unknown_uicc_app == TRUE)
  {
    return MMGSDI_UICC;
  }

  /* no known GW or 1X application or unknown app, return error for now */
  UIM_MSG_HIGH_0("Found neither any known GW/1X application nor unknown UICC app");
  return MMGSDI_NO_PROTOCOL;
} /* qmi_uim_card_protocol */


/*===========================================================================
  FUNCTION QMI_UIM_SESSION_ID_TO_REFRESH_INDEX

  DESCRIPTION
    Convert a session id into an index used for refresh.

  PARAMETERS
    refresh_index : output parameter with refresh index
    session_id    : session id

  RETURN VALUE
    errval        : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_session_id_to_refresh_index
(
  uint16                 * refresh_index_ptr,
  mmgsdi_session_id_type   session_id
)
{
  uint16                         i            = 0;
  qmi_error_e_type               result       = QMI_ERR_NONE;
  mmgsdi_session_type_enum_type  session_type = MMGSDI_GW_PROV_PRI_SESSION;
  mmgsdi_static_data_type        aid;

  memset(&aid, 0, sizeof(mmgsdi_static_data_type));

  ASSERT(refresh_index_ptr != NULL);
  ASSERT(qmi_uim_global_ptr != NULL);

  /* Convert session id in session type */
  result = qmi_uim_session_id_to_session_type(&session_type,
                                              &aid,
                                              session_id);
  if (result != QMI_ERR_NONE)
  {
    return result;
  }

  /* Convert session type into refresh index */
  switch(session_type)
  {
    case MMGSDI_GW_PROV_PRI_SESSION:
      *refresh_index_ptr = 0;
      return QMI_ERR_NONE;
    case MMGSDI_1X_PROV_PRI_SESSION:
      *refresh_index_ptr = 1;
      return QMI_ERR_NONE;
    case MMGSDI_GW_PROV_SEC_SESSION:
      *refresh_index_ptr = 2;
      return QMI_ERR_NONE;
    case MMGSDI_1X_PROV_SEC_SESSION:
      *refresh_index_ptr = 3;
      return QMI_ERR_NONE;
    case MMGSDI_GW_PROV_TER_SESSION:
      *refresh_index_ptr = 4;
      return QMI_ERR_NONE;
    case MMGSDI_1X_PROV_TER_SESSION:
      *refresh_index_ptr = 5;
      return QMI_ERR_NONE;
    case MMGSDI_CARD_SESSION_SLOT_1:
      *refresh_index_ptr = 6;
      return QMI_ERR_NONE;
    case MMGSDI_CARD_SESSION_SLOT_2:
      *refresh_index_ptr = 7;
      return QMI_ERR_NONE;
    case MMGSDI_CARD_SESSION_SLOT_3:
      *refresh_index_ptr = 8;
      return QMI_ERR_NONE;
    case MMGSDI_NON_PROV_SESSION_SLOT_1:
    case MMGSDI_NON_PROV_SESSION_SLOT_2:
    case MMGSDI_NON_PROV_SESSION_SLOT_3:
      /* Search if this session id was already used */
      for (i = 0; i < UIM_REFRESH_NON_PROV_COUNT; i++)
      {
        if (qmi_uim_global_ptr->non_prov_refresh_session_id[i] == session_id)
        {
          *refresh_index_ptr = UIM_REFRESH_PROV_COUNT + i;
          return QMI_ERR_NONE;
        }
      }
      /* Find a slot for this new session id */
      for (i = 0; i < UIM_REFRESH_NON_PROV_COUNT; i++)
      {
        if (qmi_uim_global_ptr->non_prov_refresh_session_id[i] == UIM_INVALID_SESSION_ID)
        {
          qmi_uim_global_ptr->non_prov_refresh_session_id[i] = session_id;
          *refresh_index_ptr = UIM_REFRESH_PROV_COUNT + i;
          return QMI_ERR_NONE;
        }
      }
      break;
    default:
      break;
  }

  return QMI_ERR_INTERNAL;
} /* qmi_uim_session_id_to_refresh_index */


/*===========================================================================
  FUNCTION QMI_UIM_MMGDSI_SLOT_ID_TO_UIM_SLOT_ID()

  DESCRIPTION
    Converts MMGSDI slot id to UIM slot id.

  PARAMETERS
    mmgsdi_slot_id : MMGSDI slot id
    uim_slot_id    : output parameter containing UIM slot id

  RETURN VALUE
    QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_mmgsdi_slot_id_to_uim_slot_id
(
  mmgsdi_slot_id_enum_type  mmgsdi_slot_id,
  uim_slot_type            *uim_slot_id
)
{
  ASSERT(uim_slot_id);

  switch(mmgsdi_slot_id)
  {
    case MMGSDI_SLOT_1:
      *uim_slot_id = UIM_SLOT_1;
      break;

    case MMGSDI_SLOT_2:
      *uim_slot_id = UIM_SLOT_2;
      break;

    case MMGSDI_SLOT_3:
      *uim_slot_id = UIM_SLOT_3;
      break;

    default:
      UIM_MSG_ERR_1("Invalid slot: 0x%x", mmgsdi_slot_id);
      *uim_slot_id = UIM_SLOT_NONE;
      return QMI_ERR_INTERNAL;
  }

  return QMI_ERR_NONE;
} /* qmi_uim_mmgsdi_slot_id_to_uim_slot_id */


/*===========================================================================
  FUNCTION QMI_UIM_UIM_SLOT_ID_TO_MMGSDI_SLOT_ID()

  DESCRIPTION
    Converts UIM slot id to MMGSDI slot id.

  PARAMETERS
    uim_slot_id         : UIM slot id
    mmgsdi_slot_id_ptr  : output parameter containing MMGSDI slot id

  RETURN VALUE
    QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_uim_slot_id_to_mmgsdi_slot_id
(
  uim_slot_type             uim_slot_id,
  mmgsdi_slot_id_enum_type *mmgsdi_slot_id_ptr
)
{
  ASSERT(mmgsdi_slot_id_ptr);

  switch(uim_slot_id)
  {
    case UIM_SLOT_1:
      *mmgsdi_slot_id_ptr = MMGSDI_SLOT_1;
      break;

    case UIM_SLOT_2:
      *mmgsdi_slot_id_ptr = MMGSDI_SLOT_2;
      break;

    case UIM_SLOT_3:
      *mmgsdi_slot_id_ptr = MMGSDI_SLOT_3;
      break;

    default:
      UIM_MSG_ERR_1("Invalid slot: 0x%x", uim_slot_id);
      *mmgsdi_slot_id_ptr = MMGSDI_MAX_SLOT_ID_ENUM;
      return QMI_ERR_INTERNAL;
  }

  return QMI_ERR_NONE;
} /* qmi_uim_uim_slot_id_to_mmgsdi_slot_id */


/*===========================================================================
  FUNCTION QMI_UIM_MMGDSI_SLOT_ID_TO_SIMLOCK_SLOT_ID()

  DESCRIPTION
    Converts MMGSDI slot id to SIMLOCK slot id.

  PARAMETERS
    mmgsdi_slot_id       : MMGSDI slot id
    simlock_slot_id_ptr  : output parameter containing SIMLOCK slot id

  RETURN VALUE
    QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_mmgsdi_slot_id_to_simlock_slot_id
(
  mmgsdi_slot_id_enum_type   mmgsdi_slot_id,
  simlock_slot_enum_type   * simlock_slot_id_ptr
)
{
  ASSERT(simlock_slot_id_ptr);

  switch(mmgsdi_slot_id)
  {
    case MMGSDI_SLOT_1:
      *simlock_slot_id_ptr = SIMLOCK_SLOT_1;
      break;

    case MMGSDI_SLOT_2:
      *simlock_slot_id_ptr = SIMLOCK_SLOT_2;
      break;

    case MMGSDI_SLOT_3:
      *simlock_slot_id_ptr = SIMLOCK_SLOT_3;
      break;

    default:
      UIM_MSG_ERR_1("Invalid slot: 0x%x", mmgsdi_slot_id);
      *simlock_slot_id_ptr = SIMLOCK_SLOT_NUM;
      return QMI_ERR_INTERNAL;
  }

  return QMI_ERR_NONE;
} /* qmi_uim_mmgsdi_slot_id_to_simlock_slot_id */


/*===========================================================================
  FUNCTION QMI_UIM_SIMLOCK_SLOT_ID_TO_MMGSDI_SLOT_ID()

  DESCRIPTION
    Converts SIMLOCK slot id to MMGSDI slot id.

  PARAMETERS
    simock_slot_id     : SIMLOCK slot id
    mmgsdi_slot_id_ptr : output parameter containing MMGSDI slot id

  RETURN VALUE
    QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_simlock_slot_id_to_mmgsdi_slot_id
(
  simlock_slot_enum_type      simock_slot_id,
  mmgsdi_slot_id_enum_type  * mmgsdi_slot_id_ptr
)
{
  ASSERT(mmgsdi_slot_id_ptr);

  switch(simock_slot_id)
  {
    case SIMLOCK_SLOT_1:
      *mmgsdi_slot_id_ptr = MMGSDI_SLOT_1;
      break;

    case SIMLOCK_SLOT_2:
      *mmgsdi_slot_id_ptr = MMGSDI_SLOT_2;
      break;

    case SIMLOCK_SLOT_3:
      *mmgsdi_slot_id_ptr = MMGSDI_SLOT_3;
      break;

    default:
      UIM_MSG_ERR_1("Invalid slot: 0x%x", simock_slot_id);
      *mmgsdi_slot_id_ptr = MMGSDI_MAX_SLOT_ID_ENUM;
      return QMI_ERR_INTERNAL;
  }

  return QMI_ERR_NONE;
} /* qmi_uim_simlock_slot_id_to_mmgsdi_slot_id */


/*===========================================================================
  FUNCTION QMI_UIM_SLOT_INDEX_TO_MMGSDI_SLOT()

  DESCRIPTION
    Determines the MMGSDI slot id from the slot index

  PARAMETERS
    slot_index          : slot index
    mmgsdi_slot_ptr     : output parameter containing MMGSDI slot id

  RETURN VALUE
    QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_slot_index_to_mmgsdi_slot
(
  uint8                              slot_index,
  mmgsdi_slot_id_enum_type          *mmgsdi_slot_ptr
)
{
  ASSERT(mmgsdi_slot_ptr);

  switch(slot_index)
  {
    case 0:
      *mmgsdi_slot_ptr = MMGSDI_SLOT_1;
      break;

    case 1:
      *mmgsdi_slot_ptr = MMGSDI_SLOT_2;
      break;

    case 2:
      *mmgsdi_slot_ptr = MMGSDI_SLOT_3;
      break;

    default:
      UIM_MSG_ERR_1("Invalid slot index: 0x%x", slot_index);
      return QMI_ERR_INTERNAL;
  }

  return QMI_ERR_NONE;
}/* qmi_uim_slot_index_to_mmgsdi_slot */


/*===========================================================================
  FUNCTION QMI_UIM_GSTK_SLOT_ID_TO_MMGSDI_SLOT_ID()

  DESCRIPTION
    Converts GSTK slot id to MMGSDI slot id.

  PARAMETERS
    gstk_slot_id        : GSTK slot id
    mmgsdi_slot_id_ptr  : output parameter containing MMGSDI slot id

  RETURN VALUE
    QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_gstk_slot_id_to_mmgsdi_slot_id
(
  gstk_slot_id_enum_type     gstk_slot_id,
  mmgsdi_slot_id_enum_type  *mmgsdi_slot_id_ptr
)
{
  switch(gstk_slot_id)
  {
    case GSTK_SLOT_1:
      *mmgsdi_slot_id_ptr = MMGSDI_SLOT_1;
      break;

    case GSTK_SLOT_2:
      *mmgsdi_slot_id_ptr = MMGSDI_SLOT_2;
      break;

    case GSTK_SLOT_3:
      *mmgsdi_slot_id_ptr = MMGSDI_SLOT_3;
      break;

    default:
      UIM_MSG_ERR_1("Invalid slot: 0x%x", gstk_slot_id);
      *mmgsdi_slot_id_ptr = MMGSDI_MAX_SLOT_ID_ENUM;
      return QMI_ERR_INTERNAL;
  }

  return QMI_ERR_NONE;
} /* qmi_uim_gstk_slot_id_to_mmgsdi_slot_id */


/*===========================================================================
  FUNCTION QMI_UIM_MMGSDI_SLOT_TO_SLOT_INDEX()

  DESCRIPTION
    Determines the slot index from the MMGSDI slot id

  PARAMETERS
    mmgsdi_slot_id      : MMGSDI slot id
    slot_index_ptr      : output parameter containing slot index

  RETURN VALUE
    QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_mmgsdi_slot_to_slot_index
(
  mmgsdi_slot_id_enum_type      mmgsdi_slot_id,
  uint8                        *slot_index_ptr
)
{
  ASSERT(slot_index_ptr);

  switch(mmgsdi_slot_id)
  {
    case MMGSDI_SLOT_1:
      *slot_index_ptr = 0;
      break;

    case MMGSDI_SLOT_2:
      *slot_index_ptr = 1;
      break;

    case MMGSDI_SLOT_3:
      *slot_index_ptr = 2;
      break;

    default:
      UIM_MSG_ERR_1("Invalid slot: 0x%x", mmgsdi_slot_id);
      return QMI_ERR_INTERNAL;
  }

  return QMI_ERR_NONE;
}/* qmi_uim_mmgsdi_slot_to_slot_index */


/*===========================================================================
  FUNCTION QMI_UIM_GET_ICCID_FROM_EUICC_PROFILE_ID()

  DESCRIPTION
    Retrieve ICCID from eUICC profile_id

  PARAMETERS
    profile_id        : QMI UIM profile id
    mmgsdi_slot       : MMGSDI Slot

  RETURN VALUE
    Profile info pointer

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_uim_euicc_profile_info_type* qmi_uim_get_iccid_from_euicc_profile_id
(
  mmgsdi_profile_id_enum_type   profile_id,
  mmgsdi_slot_id_enum_type      mmgsdi_slot
)
{
  uint8             profile_index = 0;
  uint8             slot_index    = 0;
  qmi_error_e_type  errval        = QMI_ERR_NONE;

  UIM_MSG_HIGH_2("Inside qmi_uim_get_iccid_from_euicc_profile_id, profile_id=0x%x,mmgsdi_slot_id=0x%x", profile_id, mmgsdi_slot);

  ASSERT(qmi_uim_global_ptr);

  errval = uimqmi_mmgsdi_slot_to_slot_index(mmgsdi_slot,
                                            &slot_index);
  if (errval != QMI_ERR_NONE || slot_index >= QMI_UIM_MAX_CARD_COUNT)
  {
    return NULL;
  }

  for (profile_index = 0; profile_index < QMI_UIM_PROFILES_MAX_V01; profile_index++)
  {
    if (qmi_uim_global_ptr->qmi_uim_euicc_profile_data_ptr[slot_index][profile_index] != NULL)
    {
      UIM_MSG_HIGH_3("qmi_uim_global_ptr->qmi_uim_euicc_profile_data_ptr[%d][%d]->profile_id", slot_index, profile_index, 
                     qmi_uim_global_ptr->qmi_uim_euicc_profile_data_ptr[slot_index][profile_index]->profile_id);
      UIM_MSG_HIGH_3("qmi_uim_global_ptr->qmi_uim_euicc_profile_data_ptr[%d][%d]->profile_info.iccid.data_len", slot_index, profile_index,
                     qmi_uim_global_ptr->qmi_uim_euicc_profile_data_ptr[slot_index][profile_index]->profile_info.iccid.data_len);
      if (qmi_uim_global_ptr->qmi_uim_euicc_profile_data_ptr[slot_index][profile_index]->profile_id == profile_id &&
          qmi_uim_global_ptr->qmi_uim_euicc_profile_data_ptr[slot_index][profile_index]->profile_info.iccid.data_len > 0)
      {
        return qmi_uim_global_ptr->qmi_uim_euicc_profile_data_ptr[slot_index][profile_index];
      }
    }
  }

  UIM_MSG_HIGH_0("qmi_uim_get_iccid_from_euicc_profile_id no ICCID match");
  return NULL;
} /* qmi_uim_get_iccid_from_euicc_profile_id */


/*===========================================================================
  FUNCTION QMI_UIM_CLEAR_PROFILE_INFO()

  DESCRIPTION
    Clear all the profiles data for that slot from QMI UIM cache

  PARAMETERS
    slot_index

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_clear_profile_info
(
  mmgsdi_slot_id_enum_type   mmgsdi_slot
)
{
  uint8            profile_index = 0;
  uint8            slot_index    = 0;
  qmi_error_e_type errval        = QMI_ERR_NONE;

  ASSERT(qmi_uim_global_ptr);

  UIM_MSG_HIGH_1("qmi_uim_clear_profile_info for mmgsdi_slot=0x%x",
                 mmgsdi_slot);
  errval = uimqmi_mmgsdi_slot_to_slot_index(mmgsdi_slot, &slot_index);
  if (errval != QMI_ERR_NONE || slot_index >= QMI_UIM_MAX_CARD_COUNT)
  {
    return;
  }

  for (profile_index = 0; profile_index < QMI_UIM_PROFILES_MAX_V01; profile_index++)
  {
    if (qmi_uim_global_ptr->qmi_uim_euicc_profile_data_ptr[slot_index][profile_index] != NULL)
    {
       UIM_MSG_HIGH_2("Clearing qmi_uim_global_ptr->qmi_uim_euicc_profile_data_ptr[%d][%d]",
                       slot_index, profile_index);
      if (qmi_uim_global_ptr->qmi_uim_euicc_profile_data_ptr[slot_index][profile_index]->profile_info.icon.data_ptr != NULL)
      {
        uimqmi_free(qmi_uim_global_ptr->qmi_uim_euicc_profile_data_ptr[slot_index][profile_index]->profile_info.icon.data_ptr);
        qmi_uim_global_ptr->qmi_uim_euicc_profile_data_ptr[slot_index][profile_index]->profile_info.icon.data_ptr = NULL;
      }
      uimqmi_free(qmi_uim_global_ptr->qmi_uim_euicc_profile_data_ptr[slot_index][profile_index]);
      qmi_uim_global_ptr->qmi_uim_euicc_profile_data_ptr[slot_index][profile_index] = NULL;
    }
  }
} /* qmi_uim_clear_profile_info */


/*===========================================================================
  FUNCTION QMI_UIM_COPY_EUICC_PROFILE_INFO()

  DESCRIPTION
    Copy all the profiles data received from LPA module

  PARAMETERS
    get_profiles_info_resp_ptr : result of LPA operation

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_copy_euicc_profile_info
(
  const lpa_get_profiles_info_resp_type    * get_profiles_info_resp_ptr,
  mmgsdi_slot_id_enum_type                   mmgsdi_slot
)
{
  uint8                            num_profiles     = MIN (get_profiles_info_resp_ptr->num_profiles, QMI_UIM_PROFILES_MAX_V01);
  uint8                            slot_index       = 0;
  uint8                            profile_index    = 0;
  mmgsdi_profile_id_enum_type      profile_id       = MMGSDI_PROFILE_NOT_APPLICABLE;

  ASSERT(qmi_uim_global_ptr);

  /* Clear the old data before copying the new data in global */
  qmi_uim_clear_profile_info(mmgsdi_slot);

  if (uimqmi_mmgsdi_slot_to_slot_index(mmgsdi_slot, &slot_index) != QMI_ERR_NONE)
  {
    return;
  }

  for (profile_index = 0; profile_index < num_profiles; profile_index++)
  {
    profile_id = qmi_uim_get_profile_id_from_index(profile_index);
    if (profile_id == MMGSDI_PROFILE_NOT_APPLICABLE)
    {
      return;
    }
    qmi_uim_global_ptr->qmi_uim_euicc_profile_data_ptr[slot_index][profile_index] =
            (qmi_uim_euicc_profile_info_type *)uimqmi_malloc(sizeof(qmi_uim_euicc_profile_info_type));
    if (qmi_uim_global_ptr->qmi_uim_euicc_profile_data_ptr[slot_index][profile_index] == NULL)
    {
      return;
    }
    qmi_uim_global_ptr->qmi_uim_euicc_profile_data_ptr[slot_index][profile_index]->profile_id =
          profile_id;

    qmi_uim_global_ptr->qmi_uim_euicc_profile_data_ptr[slot_index][profile_index]->profile_info =
            get_profiles_info_resp_ptr->profile_info[profile_index];

    uimqmi_deep_copy((void **)&qmi_uim_global_ptr->qmi_uim_euicc_profile_data_ptr[slot_index][profile_index]->profile_info.icon.data_ptr,
                     (const void*)get_profiles_info_resp_ptr->profile_info[profile_index].icon.data_ptr,
                     (uint32)get_profiles_info_resp_ptr->profile_info[profile_index].icon.data_len);
  }
} /* qmi_uim_copy_euicc_profile_info */


/*===========================================================================
  FUNCTION QMI_UIM_QUERY_EUICC_PROFILE_INFO

  DESCRIPTION
    Query LPA module about the profile data

  PARAMETERS
    mmgsdi_slot
    userdata

  RETURN VALUE
    qmi_error_e_type

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_query_euicc_profile_info
(
  qmi_uimi_userdata_type       * cb_userdata_ptr
)
{
  lpa_result_enum_type       lpa_status      = LPA_SUCCESS;
  lpa_slot_id_enum_type      lpa_slot        = LPA_SLOT_1;
  qmi_error_e_type           errval          = QMI_ERR_NONE;
  
  if (cb_userdata_ptr == NULL)
  {
    return QMI_ERR_INTERNAL;
  }

  errval = qmi_uim_convert_mmgsdi_slot_to_lpa_slot(cb_userdata_ptr->data.lpa.slot,
                                                   &lpa_slot);
  if (errval != QMI_ERR_NONE)
  {
    return errval;
  }

  lpa_status = lpa_get_profiles_info(lpa_slot,
                                     qmi_uimi_lpa_callback,
                                     cb_userdata_ptr);

  return qmi_uim_convert_lpa_status_to_errval(lpa_status);
} /* qmi_uim_query_euicc_profile_info */


/*===========================================================================
  FUNCTION QMI_UIM_ALL_REG_CLIENTS_ACK_VCC_DEACTIVATION()

  DESCRIPTION
    Indicates whether all registered clients have acknowledged Vcc
    power down.

  PARAMETERS
    slot_id : MMGSDI slot id

  RETURN VALUE
    qmi_error_e_type

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_all_reg_clients_ack_vcc_deactivation
(
  mmgsdi_slot_id_enum_type  mmgsdi_slot
)
{
  uint8             i          = 0;
  uint8             slot_idx   = 0;
  uim_slot_type     uim_slot   = UIM_SLOT_NONE;
  qmi_error_e_type  errval     = QMI_ERR_NONE;

  errval = qmi_uim_mmgsdi_slot_to_slot_index(mmgsdi_slot,
                                             &slot_idx);
  if (errval != QMI_ERR_NONE)
  {
    return errval;
  }

  for (i = 0; i < UIMI_MAX_CLIDS; i++)
  {
    if(qmi_uim_state_ptr->client[i] &&
       qmi_uim_state_ptr->client[i]->uim_info.supply_voltage_pending_ack[slot_idx] == TRUE)
    {
      return QMI_ERR_NONE;
    }
  }

  errval = qmi_uim_mmgsdi_slot_id_to_uim_slot_id(mmgsdi_slot,
                                                 &uim_slot);
  if (errval != QMI_ERR_NONE)
  {
    return errval;
  }

  /* Send acknowledgement back to UIM drivers notifying them that all
     clients have notified with ok to proceed with Vcc power down */
  if (qmi_uim_global_ptr->supply_voltage_cb[slot_idx])
  {
    qmi_uim_global_ptr->supply_voltage_cb[slot_idx](uim_slot, UIMDRV_LDO_AWAITING_DEACTIVATION_IND_ACK);
  }

  /* After notifying UIM drivers we need to clear the saved supply voltage acknowledgement
     callback indicating that the indication for Vcc deactivate has been acknowledged. */
  qmi_uim_global_ptr->supply_voltage_cb[slot_idx] = NULL;

  return QMI_ERR_NONE;
} /* qmi_uim_all_reg_clients_ack_vcc_deactivation */


/*===========================================================================
  FUNCTION QMI_UIM_REGISTER_FOR_REMOTE_SFS_OPERATION()

  DESCRIPTION
    This function registers the QMI UIM callback with the simlock, so the
    remote SFS operations can be performed.

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_register_for_remote_sfs_operation
(
  void
)
{
  /* Register for events from SIM Lock task */
  (void)simlock_register_remote_sfs_operation(SIMLOCK_REGISTER,
                                              qmi_uim_simlock_remote_sfs_cb);
} /* qmi_uim_register_for_remote_sfs_operation */


/*===========================================================================
  FUNCTION QMI_UIM_CHECK_AND_DEREGISTER_REMOTE_SFS_OPERATION()

  DESCRIPTION
    This function deregisters the QMI UIM callback with the simlock.

  PARAMETERS
    client_id  : Client id of the registered client

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_check_and_deregister_remote_sfs_operation
(
  uint16  client_id
)
{
  uint8                              i               = 0;
  qmi_uimi_client_state_type       * cl_sp           = NULL;

  if((qmi_uim_state_ptr == NULL) ||
     (client_id == QMI_SVC_CLID_UNUSED))
  {
    return;
  }

  for(i = 0; i < UIMI_MAX_CLIDS; i++)
  {
    cl_sp = (qmi_uimi_client_state_type*)qmi_uim_state_ptr->client[i];
    if((cl_sp == NULL) ||
       (cl_sp->common.clid == QMI_SVC_CLID_UNUSED))
    {
      continue;
    }

    if(cl_sp->common.clid == client_id)
    {
      continue;
    }

    /* If there is at least one client who registered for remote SFS
       events, do not de-register with simlock */
    if(cl_sp->uim_info.reg_event_type.simlock_remote_sfs_events)
    {
      return;
    }
  }

  /* Deregister for events from SIM Lock task */
  (void)simlock_register_remote_sfs_operation(SIMLOCK_DEREGISTER,
                                              NULL);
} /* qmi_uim_check_and_deregister_remote_sfs_operation */


/*===========================================================================
  FUNCTION QMI_UIM_IS_APDU_SESSION

  DESCRIPTION
    Check if the given session id belongs to an APDU session

  PARAMETERS
    session_id    : session id

  RETURN VALUE
    boolean       : indicates if the session id belongs to an APDU session

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_uim_is_apdu_session
(
  mmgsdi_session_id_type   session_id
)
{
  uint8 i = 0;

  for (i = 0; i < UIM_MAX_APDU_CHANNEL_COUNT; i++)
  {
    if (qmi_uim_global_ptr->apdu_channel[i] != NULL &&
        qmi_uim_global_ptr->apdu_channel[i]->mmgsdi_session_id == session_id)
    {
      return TRUE;
    }
  }

  return FALSE;
} /* qmi_uim_is_apdu_session */


/*===========================================================================
  FUNCTION qmi_uim_refresh_clients_count

  DESCRIPTION
    Returns the total number of clients interested in the refresh
    of one specific file

  PARAMETERS
    session_id    : session id
    file          : file

  RETURN VALUE
    uint16        : Total number of clients

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static uint16 qmi_uim_refresh_clients_count
(
  mmgsdi_session_id_type   session_id,
  mmgsdi_path_type         file
)
{
  uint8                            j                = 0;
  uint16                           result           = 0;
  qmi_uimi_client_state_type     * cl_sp            = NULL;
  qmi_uim_refresh_file_node_type * refresh_file_ptr = NULL;

  ASSERT(qmi_uim_state_ptr);

  /* Loop thru all clients */
  for (j = 0; j < UIMI_MAX_CLIDS; j++)
  {
    cl_sp = (qmi_uimi_client_state_type*)qmi_uim_state_ptr->client[j];
    if (cl_sp == NULL)
    {
      continue;
    }

    /* Loop thru all files of the client */
    refresh_file_ptr = cl_sp->uim_info.refresh_files_list;
    while(refresh_file_ptr != NULL)
    {
      if (qmi_uim_same_file(refresh_file_ptr->file, file) &&
          refresh_file_ptr->session_id == session_id)
      {
        result++;
        break;
      }
      refresh_file_ptr = refresh_file_ptr->next_ptr;
    }
  }

  return result;
} /* qmi_uim_refresh_clients_count */


/*===========================================================================
  FUNCTION QMI_UIM_REFRESH_CREATE_DEREGISTER_LIST

  DESCRIPTION
    Creates a list of files to deregister. The list is composed by all
    those files that are present only in this client and are not present
    in the new file list.

  PARAMETERS
    client_sp           : pointer to client state
    session_id          : session id
    num_files           : number of files in the new file list
    file_list_ptr       : new file list
    deregister_list_ptr : output parameter with list of files to deregister

  RETURN VALUE
    errval          : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_refresh_create_deregister_list
(
  const qmi_uimi_client_state_type * client_sp,
  mmgsdi_session_id_type             session_id,
  const qmi_uim_files_list_type    * file_list_ptr,
  mmgsdi_refresh_file_list_type *    deregister_list_ptr
)
{
  uint32                           j                    = 0;
  uint32                           deregister_list_size = 0;
  qmi_uim_refresh_file_node_type * refresh_file_ptr     = NULL;

  ASSERT (client_sp);
  ASSERT (deregister_list_ptr);

  /* Memset the output parameter */
  memset(deregister_list_ptr, 0, sizeof(mmgsdi_refresh_file_list_type));

  /* Check if at least one file was previously registered: otherwise
     there is nothing to do! */
  if (client_sp->uim_info.refresh_num_files == 0)
  {
    return QMI_ERR_NONE;
  }

  /* Allocate memory: worst case is all files need to be deregistered */
  deregister_list_size =
    client_sp->uim_info.refresh_num_files * MMGSDI_MAX_PATH_LEN * sizeof(uint16);
  deregister_list_ptr->file_path_ptr = uimqmi_malloc(deregister_list_size);
  if (deregister_list_ptr->file_path_ptr == NULL)
  {
    return QMI_ERR_NO_MEMORY;
  }

  /* Loop thru all the existing files of this client */
  refresh_file_ptr = client_sp->uim_info.refresh_files_list;
  while(refresh_file_ptr != NULL)
  {
    boolean present_in_file_list    = FALSE;
    uint16  count                   = 0;

    if (refresh_file_ptr->session_id != session_id)
    {
      /* this file belongs to a different session: nothing to do */
      refresh_file_ptr = refresh_file_ptr->next_ptr;
      continue;
    }

    /* Check if this file is in the new list */
    while (file_list_ptr != NULL)
    {
      if (file_list_ptr->file.access_method == MMGSDI_BY_PATH_ACCESS &&
          qmi_uim_same_file(refresh_file_ptr->file, file_list_ptr->file.file.path_type))
      {
        present_in_file_list = TRUE;
        break;
      }
      file_list_ptr = file_list_ptr->next_ptr;
    }

    /* If the file is present in the new list, skip it */
    if (present_in_file_list)
    {
      refresh_file_ptr = refresh_file_ptr->next_ptr;
      continue;
    }

    /* Count number of clients registered for this file */
    count = qmi_uim_refresh_clients_count(
                           session_id,
                           refresh_file_ptr->file);

    /* If count is 1, it means that this is the only client that is registered
       for refresh for this specific file. In this case, since the client is no
       longer interested in the file, we need to deregister it */
    if (count == 1 &&
        (deregister_list_ptr->file_path_len +
           2*refresh_file_ptr->file.path_len) < deregister_list_size)
    {
      for (j = 0; j < refresh_file_ptr->file.path_len &&
                  j < MMGSDI_MAX_PATH_LEN; j++)
      {
        deregister_list_ptr->file_path_ptr[deregister_list_ptr->file_path_len++] =
          (refresh_file_ptr->file.path_buf[j] >> 8) & 0xFF;
        deregister_list_ptr->file_path_ptr[deregister_list_ptr->file_path_len++] =
          (refresh_file_ptr->file.path_buf[j]) & 0xFF;
      }
    }

    refresh_file_ptr = refresh_file_ptr->next_ptr;
  }

  /* If no file needs to be deregistered, we can immediately
     free the memory */
  if (deregister_list_ptr->file_path_len == 0)
  {
    uimqmi_free(deregister_list_ptr->file_path_ptr);
    deregister_list_ptr->file_path_ptr = NULL;
  }

  return QMI_ERR_NONE;
} /* qmi_uim_refresh_create_deregister_list */


/*===========================================================================
  FUNCTION QMI_UIM_REFRESH_CREATE_REGISTER_LIST

  DESCRIPTION
    Creates a list of files to register. The list is composed by all
    those files that are present in the new list and that no client
    is currently registered to.

  PARAMETERS
    session_id        : session id
    num_files         : number of files in the new file list
    file_list_ptr     : new file list
    register_list_ptr : output parameter with list of files to register

  RETURN VALUE
    errval          : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_refresh_create_register_list
(
  mmgsdi_session_id_type            session_id,
  const qmi_uim_files_list_type   * file_list_ptr,
  mmgsdi_refresh_file_list_type *   register_list_ptr
)
{
  uint16                          num_files   = 0;
  const qmi_uim_files_list_type * current_ptr = NULL;

  ASSERT (register_list_ptr);

  /* Memset the output parameter */
  memset(register_list_ptr, 0, sizeof(mmgsdi_refresh_file_list_type));

  /* Check if new list is empty: in this case, there is nothing to do! */
  if (file_list_ptr == NULL)
  {
    return QMI_ERR_NONE;
  }

  /* Count the number of files in the list */
  current_ptr = file_list_ptr;
  while (current_ptr != NULL)
  {
    num_files++;
    current_ptr = current_ptr->next_ptr;
  }

  /* Allocate memory: worst case is all files need to be registered */
  register_list_ptr->file_path_ptr = uimqmi_malloc(
            num_files * MMGSDI_MAX_PATH_LEN * sizeof(uint16));
  if (register_list_ptr->file_path_ptr == NULL)
  {
    return QMI_ERR_NO_MEMORY;
  }

  /* Loop thru all the existing files of this client */
  while (file_list_ptr != NULL)
  {
    uint16 count = 0;

    /* Verify that access is by path */
    if (file_list_ptr->file.access_method != MMGSDI_BY_PATH_ACCESS)
    {
      file_list_ptr = file_list_ptr->next_ptr;
      continue;
    }

    /* Count number of clients registered for this file */
    count = qmi_uim_refresh_clients_count(session_id,
                                          file_list_ptr->file.file.path_type);

    /* If count is 0, it means that no client is registered. In this
       case, we need to register it */
    if (count == 0)
    {
      mmgsdi_len_type i = 0;
      for (i = 0; i < file_list_ptr->file.file.path_type.path_len &&
                  i < MMGSDI_MAX_PATH_LEN; i++)
      {
        register_list_ptr->file_path_ptr[register_list_ptr->file_path_len++] =
          (file_list_ptr->file.file.path_type.path_buf[i] >> 8) & 0xFF;
        register_list_ptr->file_path_ptr[register_list_ptr->file_path_len++] =
          (file_list_ptr->file.file.path_type.path_buf[i]) & 0xFF;
      }
    }

    file_list_ptr = file_list_ptr->next_ptr;
  }

  /* If no file needs to be registered, we can immediately
     free the memory */
  if (register_list_ptr->file_path_len == 0)
  {
    uimqmi_free(register_list_ptr->file_path_ptr);
    register_list_ptr->file_path_ptr = NULL;
  }

  return QMI_ERR_NONE;
} /* qmi_uim_refresh_create_register_list */


/*===========================================================================
  FUNCTION QMI_UIM_REMOVE_CLIENT_REFRESH_FILES

  DESCRIPTION
    Removes all the files of a specific session type from the list of
    refresh files of a given client.

  PARAMETERS
    client_sp       : pointer to client state
    session_id      : session id

  RETURN VALUE
    errval          : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_remove_client_refresh_files
(
  qmi_uimi_client_state_type *     client_sp,
  mmgsdi_session_id_type           session_id
)
{
  qmi_uim_refresh_file_node_type * curr_file_ptr = NULL;
  qmi_uim_refresh_file_node_type * prev_file_ptr = NULL;

  ASSERT(client_sp);

  curr_file_ptr = client_sp->uim_info.refresh_files_list;

  /* Remove matching items from the linked list */
  while(curr_file_ptr != NULL)
  {
    if (curr_file_ptr->session_id == session_id)
    {
      if(prev_file_ptr == NULL)
      {
        /* remove from the head of the list */
        client_sp->uim_info.refresh_files_list = curr_file_ptr->next_ptr;
        uimqmi_free(curr_file_ptr);
        curr_file_ptr = client_sp->uim_info.refresh_files_list;
      }
      else
      {
        /* remove from middle or the tail of the list */
        prev_file_ptr->next_ptr = curr_file_ptr->next_ptr;
        uimqmi_free(curr_file_ptr);
        curr_file_ptr = prev_file_ptr->next_ptr;
      }
      client_sp->uim_info.refresh_num_files--;
    }
    else
    {
      /* maintain pointer to the previous node (to be used while freeing the
         last node) */
      prev_file_ptr = curr_file_ptr;
      curr_file_ptr = curr_file_ptr->next_ptr;
    }
  }

  return QMI_ERR_NONE;
} /* qmi_uim_remove_client_refresh_files */


/*===========================================================================
  FUNCTION QMI_UIM_ADD_CLIENT_REFRESH_FILES

  DESCRIPTION
    Add the files of a list into the list of refresh files of a given client.

  PARAMETERS
    client_sp       : pointer to client state
    session_id      : session id
    num_files       : number of files in the file list
    file_list_ptr   : list of files to be added

  RETURN VALUE
    errval          : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_add_client_refresh_files
(
  qmi_uimi_client_state_type *      client_sp,
  mmgsdi_session_id_type            session_id,
  const qmi_uim_files_list_type   * file_list_ptr
)
{
  qmi_uim_refresh_file_node_type * new_file_ptr      = NULL;
  qmi_uim_refresh_file_node_type * last_file_ptr     = NULL;

  ASSERT(client_sp);

  if(client_sp->uim_info.refresh_num_files > 0)
  {
    last_file_ptr = client_sp->uim_info.refresh_files_list;
  }

  while(last_file_ptr != NULL && last_file_ptr->next_ptr != NULL)
  {
    last_file_ptr = last_file_ptr->next_ptr;
  }

  /* Copy list from TLV into this client */
  while (file_list_ptr != NULL)
  {
    /* Add only files successfully converted into enum */
    if (file_list_ptr->file.access_method == MMGSDI_BY_PATH_ACCESS)
    {
      new_file_ptr = (qmi_uim_refresh_file_node_type *)uimqmi_malloc(
                        sizeof(qmi_uim_refresh_file_node_type));
      if(new_file_ptr == NULL)
      {
        UIM_MSG_ERR_0("unable to allocate memory");
        return QMI_ERR_NO_MEMORY;
      }

      memset(new_file_ptr, 0x00, sizeof(qmi_uim_refresh_file_node_type));

      new_file_ptr->session_id = session_id;
      (void)memscpy(&new_file_ptr->file,
                    sizeof(mmgsdi_path_type),
             &file_list_ptr->file.file.path_type,
             sizeof(mmgsdi_path_type));

      if(last_file_ptr == NULL)
      {
        client_sp->uim_info.refresh_files_list = new_file_ptr;
        last_file_ptr = new_file_ptr;
      }
      else
      {
        last_file_ptr->next_ptr = new_file_ptr;
        last_file_ptr = last_file_ptr->next_ptr;
      }
      client_sp->uim_info.refresh_num_files++;
    }

    file_list_ptr = file_list_ptr->next_ptr;
  }

  return QMI_ERR_NONE;
} /* qmi_uim_add_client_refresh_files */


/*===========================================================================
  FUNCTION QMI_UIM_FILE_PRESENT_IN_FCN_LIST

  DESCRIPTION
    Check if a file is present in the file list received in the refresh event
    from MMGSDI in path format.

  PARAMETERS
    file            : file to be checked
    file_list_ptr   : array with file list
    file_list_len   : size in bytes of file list

  RETURN VALUE
    boolean         : indicates if the file is present

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_uim_file_present_in_fcn_list
(
  mmgsdi_path_type   file,
  const uint8      * file_list_ptr,
  uint32             file_list_len
)
{
  uint8 i            = 0;
  uint8 sequence_len = 0;
  uint8 sequence_val[MMGSDI_MAX_PATH_LEN * 2];

  ASSERT(file.path_len <= MMGSDI_MAX_PATH_LEN);

  if (file_list_ptr == NULL || file_list_len == 0)
  {
    return FALSE;
  }

  /* Calculate size of sequence of bytes to search in the event */
  memset(&sequence_val, 0, sizeof(sequence_val));
  sequence_len = (uint8)(file.path_len * sizeof(uint16));
  ASSERT(sequence_len <= MMGSDI_MAX_PATH_LEN * 2);

  if (sequence_len > file_list_len)
  {
    /* No need to continue checking */
    return FALSE;
  }

  /* Compose file path as sequence of bytes */
  for (i = 0; i < file.path_len; i++)
  {
    sequence_val[i * 2] =
      (uint8)((file.path_buf[i] >> 8) & 0xFF);
    sequence_val[(i * 2) + 1] =
      (uint8)(file.path_buf[i] & 0xFF);
  }

  for (i = 0; i <= file_list_len - sequence_len; i++)
  {
    if (memcmp(&file_list_ptr[i],
               sequence_val,
               sequence_len) == 0)
    {
      return TRUE;
    }
  }

  return FALSE;
} /* qmi_uim_file_present_in_fcn_list */


/*===========================================================================
  FUNCTION QMI_UIM_CLEAN_UP_REFRESH_EVT_INFO

  DESCRIPTION
    Cleans up refresh evt info if available

  PARAMETERS
     refresh_index    : index to the refresh cache

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_clean_up_refresh_evt_info
(
  uint16 refresh_index
)
{
  ASSERT(refresh_index < UIM_REFRESH_SESSION_COUNT);

  /* Clear the old cache */
  if (qmi_uim_global_ptr->refresh_info[refresh_index].cache.event_ptr != NULL)
  {
    /* Clear the old file info cache */
    if (qmi_uim_global_ptr->refresh_info[refresh_index].cache.event_ptr->refresh_files.file_path_ptr != NULL)
    {
      uimqmi_free(qmi_uim_global_ptr->refresh_info[refresh_index].cache.event_ptr->refresh_files.file_path_ptr);
      qmi_uim_global_ptr->refresh_info[refresh_index].cache.event_ptr->refresh_files.file_path_ptr = NULL;
    }

    /* Clear the old event cache */
    uimqmi_free(qmi_uim_global_ptr->refresh_info[refresh_index].cache.event_ptr);
    qmi_uim_global_ptr->refresh_info[refresh_index].cache.event_ptr = NULL;
  }
  memset(&qmi_uim_global_ptr->refresh_info[refresh_index].cache,
         0,
         sizeof(qmi_uim_global_ptr->refresh_info[refresh_index].cache));
}/* qmi_uim_clean_up_refresh_evt_info */


/*===========================================================================
  FUNCTION QMI_UIM_CACHE_REFRESH_EVENT

  DESCRIPTION
    Caches the refresh event to be fetched later.

  PARAMETERS
    session_id      : session id
    refresh_evt_ptr : refresh event

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_cache_refresh_event
(
  mmgsdi_session_id_type               session_id,
  const mmgsdi_refresh_evt_info_type * refresh_evt_ptr
)
{
  uint16                         refresh_index   = 0;
  mmgsdi_refresh_evt_info_type * event_cache_ptr = NULL;

  ASSERT(refresh_evt_ptr);
  ASSERT(qmi_uim_global_ptr);

  /* Retrieve session index for the refresh */
  if (qmi_uim_session_id_to_refresh_index(&refresh_index, session_id) != QMI_ERR_NONE)
  {
    UIM_MSG_ERR_1("Impossible to convert session id (0x%x) into refresh index",
                  session_id);
    return QMI_ERR_INTERNAL;
  }
  ASSERT(refresh_index < UIM_REFRESH_SESSION_COUNT);

  qmi_uim_clean_up_refresh_evt_info(refresh_index);

  /* Copy session id */
  qmi_uim_global_ptr->refresh_info[refresh_index].cache.session_id = session_id;

  qmi_uim_global_ptr->refresh_info[refresh_index].cache.event_ptr =
    uimqmi_malloc(sizeof(mmgsdi_refresh_evt_info_type));

  if (qmi_uim_global_ptr->refresh_info[refresh_index].cache.event_ptr != NULL)
  {
    event_cache_ptr = qmi_uim_global_ptr->refresh_info[refresh_index].cache.event_ptr;

    /* Copy refresh event */
    (void)memscpy(event_cache_ptr, sizeof(mmgsdi_refresh_evt_info_type),
                  refresh_evt_ptr, sizeof(mmgsdi_refresh_evt_info_type));

    /* Deep copy of file list */
    if (refresh_evt_ptr->refresh_files.file_path_ptr != NULL &&
        refresh_evt_ptr->refresh_files.file_path_len > 0)
    {
      uint32 size = refresh_evt_ptr->refresh_files.file_path_len;

      event_cache_ptr->refresh_files.file_path_ptr =
                              uimqmi_malloc(size);

      if (event_cache_ptr->refresh_files.file_path_ptr != NULL)
      {
        (void)memscpy(event_cache_ptr->refresh_files.file_path_ptr,
                      size,
                      refresh_evt_ptr->refresh_files.file_path_ptr,
                      size);
      }
    }
    else
    {
      event_cache_ptr->refresh_files.file_path_len = 0;
      event_cache_ptr->refresh_files.file_path_ptr = NULL;
    }
  }
  else
  {
    return QMI_ERR_NO_MEMORY;
  }

  return QMI_ERR_NONE;
} /* qmi_uim_cache_refresh_event */


/*===========================================================================
  FUNCTION QMI_UIM_SEND_SESSION_TYPE_BASED_REFRESH_IND

  DESCRIPTION
    Compose the list of clients for specific session type interested in the
    refresh indication for the refresh event received from the modem and sends
    the indication.

  PARAMETERS
    session_id      : session id
    refresh_evt_ptr : refresh event

  RETURN VALUE
    uint16          : number of sent indications

  DEPENDENCIES
    None

  SIDE EFFECTS
    Overwrites the table of services interested in the indication
    in the global variable.
===========================================================================*/
static uint16 qmi_uim_send_session_type_based_refresh_ind
(
  mmgsdi_session_id_type               session_id,
  const mmgsdi_refresh_evt_info_type * refresh_evt_ptr
)
{
  uint8                            j                = 0;
  qmi_uimi_client_state_type *     cl_sp            = NULL;
  uint16                           refresh_index    = 0;
  uint32                           notify_mask      = 0;
  mmgsdi_session_type_enum_type    session_type     = MMGSDI_MAX_SESSION_TYPE_ENUM;
  mmgsdi_static_data_type          aid              = { 0, };
  qmi_uim_refresh_file_node_type * refresh_file_ptr = NULL;

  ASSERT(refresh_evt_ptr);
  ASSERT(qmi_uim_global_ptr);
  ASSERT(qmi_uim_state_ptr);

  /* Retrieve session index for the refresh */
  if (qmi_uim_session_id_to_refresh_index(&refresh_index, session_id) != QMI_ERR_NONE)
  {
    UIM_MSG_ERR_1("Impossible to convert session id (0x%x) into refresh index",
                  session_id);
    return 0;
  }
  ASSERT(refresh_index < UIM_REFRESH_SESSION_COUNT);

  /* Empty the current list of clients */
  qmi_uim_global_ptr->refresh_info[refresh_index].client_count = 0;
  memset(qmi_uim_global_ptr->refresh_info[refresh_index].client_list,
         0,
         sizeof(qmi_uim_global_ptr->refresh_info[refresh_index].client_list));

  /* Convert session id into session type + AID */
  if (qmi_uim_session_id_to_session_type(&session_type, &aid, session_id) != QMI_ERR_NONE)
  {
    UIM_MSG_ERR_0("Error converting session id into session type");
    return 0;
  }

  /* Calculate the refresh mask */
  notify_mask = 1 << refresh_index;

  /* Loop thru all clients */
  for (j = 0; j < UIMI_MAX_CLIDS; j++)
  {
    boolean send_event = FALSE;

    cl_sp = (qmi_uimi_client_state_type*)qmi_uim_state_ptr->client[j];
    if (cl_sp == NULL)
    {
      continue;
    }

    /* Continue with the next client if both the masks are not set */
    if (((cl_sp->uim_info.refresh_notify_mask & notify_mask) == 0) &&
        ((cl_sp->uim_info.refresh_all_notify_mask & notify_mask) == 0))
    {
      continue;
    }

    /* For FCN mode, check are done as follows:
       1. For clients who have specified the files, match file path against the list.
       2. For clients interested in all files, match against the session type only.
       For all other modes, include all clients interested in the refresh */
    if (refresh_evt_ptr->mode == MMGSDI_REFRESH_NAA_FCN &&
        ((cl_sp->uim_info.refresh_all_notify_mask & notify_mask) == 0) &&
        ((cl_sp->uim_info.refresh_notify_mask & notify_mask) != 0))
    {
      refresh_file_ptr = cl_sp->uim_info.refresh_files_list;

      while(refresh_file_ptr != NULL && !send_event)
      {
        /* Check if the file is for this session */
        if (refresh_file_ptr->session_id != session_id)
        {
          refresh_file_ptr = refresh_file_ptr->next_ptr;
          continue;
        }

        if (qmi_uim_file_present_in_fcn_list(
               refresh_file_ptr->file,
               refresh_evt_ptr->refresh_files.file_path_ptr,
               refresh_evt_ptr->refresh_files.file_path_len))
        {
          send_event = TRUE;
          break;
        }

        refresh_file_ptr = refresh_file_ptr->next_ptr;
      }
    }
    else
    {
      send_event = TRUE;
    }

    /* Check if the client decided to vote */
    if (refresh_evt_ptr->stage == MMGSDI_REFRESH_STAGE_WAIT_FOR_OK_TO_INIT ||
        refresh_evt_ptr->stage == MMGSDI_REFRESH_STAGE_WAIT_FOR_OK_TO_FCN)
    {
      if (cl_sp->uim_info.refresh_vote == FALSE)
      {
        send_event = FALSE;
      }
    }

    /* Send the indication */
    if (send_event &&
        qmi_uim_global_ptr->refresh_info[refresh_index].client_count < (uint16)UIM_REFRESH_MAX_CLIENTS)
    {
      dsm_item_type *   indication  = NULL;

      UIM_MSG_HIGH_1("Sending refresh indication (cl_id=0x%x)", j);

      /* Prepare TLV with refresh indication */
      if (qmi_uim_response_refresh_event(
                       UIMI_TLV_RESP_TAG_OPTIONAL_1,
                       &indication,
                       session_type,
                       &aid,
                       refresh_evt_ptr))
      {
        /* Send indication to the client */
       (void)qmi_uimi_send_indication(cl_sp->common.clid,
                                      (uint16)UIMI_CMD_VAL_REFRESH_IND,
                                      indication);

        /* Add client to the global list */
        qmi_uim_global_ptr->refresh_info[refresh_index].client_list[qmi_uim_global_ptr->refresh_info[refresh_index].client_count] = cl_sp;
        qmi_uim_global_ptr->refresh_info[refresh_index].client_count++;
      }
      else
      {
        /* Ignore error... there is nothing we can do about it.
           The event will not be delivered to the client */
        UIM_MSG_ERR_0("Error sending refresh indication");
        dsm_free_packet(&indication);
      }
    }
  }

  /* Cache of refresh event */
  if (qmi_uim_global_ptr->refresh_info[refresh_index].client_count > 0)
  {
    (void)qmi_uim_cache_refresh_event(session_id, refresh_evt_ptr);
  }

  UIM_MSG_HIGH_1("Refresh indication sent to 0x%x clients",
                 qmi_uim_global_ptr->refresh_info[refresh_index].client_count);

  return qmi_uim_global_ptr->refresh_info[refresh_index].client_count;
}/* qmi_uim_send_session_type_based_refresh_ind */


/*===========================================================================
  FUNCTION QMI_UIM_SEND_REFRESH_IND

  DESCRIPTION
    Compose the list of clients interested in the refresh indication
    for the specific refresh event received from the modem and sends the
    indication.

  PARAMETERS
    session_id      : session id
    refresh_evt_ptr : refresh event

  RETURN VALUE
    uint16          : number of sent indications

  DEPENDENCIES
    None

  SIDE EFFECTS
    Overwrites the table of services interested in the indication
    in the global variable.
===========================================================================*/
static uint16 qmi_uim_send_refresh_ind
(
  mmgsdi_session_id_type               session_id,
  const mmgsdi_refresh_evt_info_type * refresh_evt_ptr
)
{
  uint8                            prov_index       = 0;
  uint8                            card_index       = 0;
  uint8                            non_prov_index   = 0;
  mmgsdi_slot_id_enum_type         refresh_slot_id  = MMGSDI_MAX_SLOT_ID_ENUM;
  mmgsdi_slot_id_enum_type         slot_id          = MMGSDI_MAX_SLOT_ID_ENUM;
  mmgsdi_session_type_enum_type    session_type     = MMGSDI_MAX_SESSION_TYPE_ENUM;
  uint16                           ind_count        = 0;

  ASSERT(refresh_evt_ptr);
  ASSERT(qmi_uim_global_ptr);

  /* Send Refresh indication to all clients who access the sessions, tied to
     slot where Refresh Reset is trigerred, irrespective of their session type
     when refresh stage is START */
  if((refresh_evt_ptr->mode == MMGSDI_REFRESH_RESET ||
      refresh_evt_ptr->mode == MMGSDI_REFRESH_RESET_AUTO) &&
     refresh_evt_ptr->stage == MMGSDI_REFRESH_STAGE_START)
  {
    /* first get the slot id for session id, retrieve all provisioning
       session ids on that slot and send refresh indication to clients who
       access that type of prov sessions */
    if (qmi_uim_session_id_to_slot(&refresh_slot_id, session_id) != QMI_ERR_NONE)
    {
      UIM_MSG_ERR_1("Error converting session id (0x%x) into corresponding slot",
                  session_id);
      return 0;
    }

    for (prov_index = 0; prov_index < QMI_UIM_MAX_PROV_SESSIONS; prov_index++)
    {
      if (qmi_uim_session_id_to_slot(&slot_id, qmi_uim_global_ptr->mmgsdi_gw_session_id[prov_index]) == QMI_ERR_NONE)
      {
        if(refresh_slot_id == slot_id)
        {
          ind_count += qmi_uim_send_session_type_based_refresh_ind(
                         qmi_uim_global_ptr->mmgsdi_gw_session_id[prov_index],
                         refresh_evt_ptr);
        }
      }
    }

    for (prov_index = 0; prov_index < QMI_UIM_MAX_PROV_SESSIONS; prov_index++)
    {
      if (qmi_uim_session_id_to_slot(&slot_id, qmi_uim_global_ptr->mmgsdi_1x_session_id[prov_index]) == QMI_ERR_NONE)
      {
        if(refresh_slot_id == slot_id)
        {
          ind_count += qmi_uim_send_session_type_based_refresh_ind(
                         qmi_uim_global_ptr->mmgsdi_1x_session_id[prov_index],
                         refresh_evt_ptr);
        }
      }
    }

    /* Send the START indication to clients registered for card slot sessions. */
    if ((qmi_uim_mmgsdi_slot_to_slot_index(refresh_slot_id, &card_index) == QMI_ERR_NONE) &&
        (qmi_uim_global_ptr->mmgsdi_card_slot_session_id[card_index] == session_id))
    {
      ind_count += qmi_uim_send_session_type_based_refresh_ind(
                     qmi_uim_global_ptr->mmgsdi_card_slot_session_id[card_index],
                     refresh_evt_ptr);
    }

    /* Before we clean up the AID in case of refresh reset, we also need to
       send indications to clients registered for non-prov sessions on that slot */
    switch(refresh_slot_id)
    {
      case MMGSDI_SLOT_1:
        session_type = MMGSDI_NON_PROV_SESSION_SLOT_1;
        break;
      case MMGSDI_SLOT_2:
        session_type = MMGSDI_NON_PROV_SESSION_SLOT_2;
        break;
      case MMGSDI_SLOT_3:
        session_type = MMGSDI_NON_PROV_SESSION_SLOT_3;
        break;
      default:
        return ind_count;
    }

    for (non_prov_index = 0; non_prov_index < UIM_MAX_NON_PROV_SESSIONS; non_prov_index++)
    {
      if ((qmi_uim_global_ptr->non_prov_session[non_prov_index].init) &&
          (qmi_uim_global_ptr->non_prov_session[non_prov_index].session_type      == session_type) &&
          (qmi_uim_global_ptr->non_prov_session[non_prov_index].mmgsdi_session_id != session_id) &&
          (qmi_uim_global_ptr->non_prov_session[non_prov_index].mmgsdi_session_id != UIM_INVALID_SESSION_ID))
      {
        uint16 refresh_index = 0;

        /* Also on the particular refresh index */
        if (qmi_uim_session_id_to_refresh_index(
              &refresh_index,
              qmi_uim_global_ptr->non_prov_session[non_prov_index].mmgsdi_session_id) != QMI_ERR_NONE)
        {
          UIM_MSG_ERR_1("Impossible to convert session id (0x%x) into refresh index",
                        qmi_uim_global_ptr->non_prov_session[non_prov_index].mmgsdi_session_id);
          continue;
        }

        ASSERT(refresh_index < UIM_REFRESH_SESSION_COUNT);

        if (qmi_uim_global_ptr->refresh_info[refresh_index].state == UIM_REFRESH_STATE_IDLE ||
            qmi_uim_global_ptr->refresh_info[refresh_index].state == UIM_REFRESH_STATE_WAIT_FOR_OK)
        {
          ind_count += qmi_uim_send_session_type_based_refresh_ind(
                         qmi_uim_global_ptr->non_prov_session[non_prov_index].mmgsdi_session_id,
                         refresh_evt_ptr);
        }
      }
    }
  }
  else
  {
    ind_count = qmi_uim_send_session_type_based_refresh_ind(
                  session_id,
                  refresh_evt_ptr);
  }

  return ind_count;
} /* qmi_uim_send_refresh_ind */


/*===========================================================================
  FUNCTION QMI_UIM_UPDATE_PIN_ID()

  DESCRIPTION
    Updates the passed PIN ID pointer with the appropriate enum value after
    validating PIN ID & the Key reference.

  PARAMETERS
    pin_id_ptr       : input/output pointer to pin id
    keyref_id        : input key reference id

  RETURN VALUE
    errval           : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_update_pin_id
(
  mmgsdi_pin_enum_type                 * pin_id_ptr,
  qmi_uim_pin_keyref_id_type             keyref_id
)
{
  ASSERT(pin_id_ptr);

  if ((*pin_id_ptr != MMGSDI_PIN1) && (*pin_id_ptr != MMGSDI_PIN2))
  {
    UIM_MSG_ERR_1("QMI_UIM invalid pin id: 0x%x", *pin_id_ptr);
    return QMI_ERR_INVALID_PINID;
  }

  /* Map appropriate PIN enum type */
  switch (keyref_id)
  {
    case QMI_UIM_PIN_KEYREF_ID_APPL_1:
      *pin_id_ptr = (*pin_id_ptr == MMGSDI_PIN1) ?
        MMGSDI_KEY_REF_PIN_APPL_1 : MMGSDI_KEY_REF_SEC_PIN_APPL_1;
      break;
    case QMI_UIM_PIN_KEYREF_ID_APPL_2:
      *pin_id_ptr = (*pin_id_ptr == MMGSDI_PIN1) ?
        MMGSDI_KEY_REF_PIN_APPL_2 : MMGSDI_KEY_REF_SEC_PIN_APPL_2;
      break;
    case QMI_UIM_PIN_KEYREF_ID_APPL_3:
      *pin_id_ptr = (*pin_id_ptr == MMGSDI_PIN1) ?
        MMGSDI_KEY_REF_PIN_APPL_3 : MMGSDI_KEY_REF_SEC_PIN_APPL_3;
      break;
    case QMI_UIM_PIN_KEYREF_ID_APPL_4:
      *pin_id_ptr = (*pin_id_ptr == MMGSDI_PIN1) ?
        MMGSDI_KEY_REF_PIN_APPL_4 : MMGSDI_KEY_REF_SEC_PIN_APPL_4;
      break;
    case QMI_UIM_PIN_KEYREF_ID_APPL_5:
      *pin_id_ptr = (*pin_id_ptr == MMGSDI_PIN1) ?
        MMGSDI_KEY_REF_PIN_APPL_5 : MMGSDI_KEY_REF_SEC_PIN_APPL_5;
      break;
    case QMI_UIM_PIN_KEYREF_ID_APPL_6:
      *pin_id_ptr = (*pin_id_ptr == MMGSDI_PIN1) ?
        MMGSDI_KEY_REF_PIN_APPL_6 : MMGSDI_KEY_REF_SEC_PIN_APPL_6;
      break;
    case QMI_UIM_PIN_KEYREF_ID_APPL_7:
      *pin_id_ptr = (*pin_id_ptr == MMGSDI_PIN1) ?
        MMGSDI_KEY_REF_PIN_APPL_7 : MMGSDI_KEY_REF_SEC_PIN_APPL_7;
      break;
    case QMI_UIM_PIN_KEYREF_ID_APPL_8:
      *pin_id_ptr = (*pin_id_ptr == MMGSDI_PIN1) ?
        MMGSDI_KEY_REF_PIN_APPL_8 : MMGSDI_KEY_REF_SEC_PIN_APPL_8;
      break;
    default:
      UIM_MSG_ERR_1("QMI_UIM invalid key reference id: 0x%x", keyref_id);
      return QMI_ERR_INVALID_ARG;
  }
  return QMI_ERR_NONE;
} /* qmi_uim_update_pin_id */


/*===========================================================================
  FUNCTION QMI_UIM_READ_IMSI_FOR_SESSION_ID()

  DESCRIPTION
    Reads the IMSI from the card for the specified Session_ID

  PARAMETERS
    session_id       : Session ID
    imsi_ptr         : Pointer for IMSI data

  RETURN VALUE
    errval           : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_read_imsi_for_session_id
(
  mmgsdi_session_id_type session_id,
  qmi_uim_imsi_type*     imsi_ptr
)
{
  mmgsdi_file_enum_type         file_name        = MMGSDI_MAX_FILE_ENUM;
  mmgsdi_app_enum_type          app_type         = MMGSDI_APP_NONE;
  mmgsdi_session_type_enum_type session_type     = MMGSDI_MAX_SESSION_TYPE_ENUM;
  mmgsdi_return_enum_type       mmgsdi_status    = MMGSDI_ERROR;
  qmi_error_e_type              result           = QMI_ERR_INTERNAL;
  mmgsdi_static_data_type       aid              = { 0, };
  mmgsdi_data_type              mmgsdi_imsi_data = { 0, NULL};

  ASSERT(imsi_ptr);

  /* Get the session type in order to get the app_type for the IMSI file read */
  result = qmi_uim_session_id_to_session_type(&session_type, &aid, session_id);
  if(result != QMI_ERR_NONE)
  {
    return result;
  }

  /* Use the session type to get the app_type for the IMSI file read */
  result = qmi_uim_session_type_to_card_type(&app_type, session_type, aid);
  if(result != QMI_ERR_NONE)
  {
    return result;
  }

  switch(app_type)
  {
    case MMGSDI_APP_SIM:
      file_name = MMGSDI_GSM_IMSI;
      break;
    case MMGSDI_APP_RUIM:
      file_name = MMGSDI_CDMA_IMSI_M;
      break;
    case MMGSDI_APP_USIM:
      file_name = MMGSDI_USIM_IMSI;
      break;
    case MMGSDI_APP_CSIM:
      file_name = MMGSDI_CSIM_IMSI_M;
      break;
    default:
      return QMI_ERR_INTERNAL;
  }

  mmgsdi_status = mmgsdi_session_read_cache_file_size(session_id, file_name,
                                                      &mmgsdi_imsi_data.data_len);

  imsi_ptr->len = (uint8)mmgsdi_imsi_data.data_len;

  if(mmgsdi_status != MMGSDI_SUCCESS || imsi_ptr->len > sizeof(imsi_ptr->imsi))
  {
    UIM_MSG_ERR_2("Error in IMSI length. mmgsdi_status:0x%x len:0x%x",
                  mmgsdi_status, imsi_ptr->len);
    return QMI_ERR_INTERNAL;
  }

  mmgsdi_imsi_data.data_ptr = imsi_ptr->imsi;

  mmgsdi_status = mmgsdi_session_read_cache(session_id, file_name, mmgsdi_imsi_data);

  if(mmgsdi_status == MMGSDI_SUCCESS)
  {
    return QMI_ERR_NONE;
  }

  return QMI_ERR_INTERNAL;
} /* qmi_uim_read_imsi_for_session_id */


/*===========================================================================
  FUNCTION QMI_UIM_CONVERT_IMSI_TO_DIGITS()

  DESCRIPTION
    Convert IMSI from qmi_uim_imsi_type to qmi_uim_imsi_digits_data_type

  PARAMETERS
    imsi_data_ptr : value of IMSI in qmi_uim_imsi_type format
    imsi_digit_ptr: value of IMSI in qmi_uim_imsi_digits_data_type format

  RETURN VALUE
    errval        : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_convert_imsi_to_digits
(
  const qmi_uim_imsi_type        *imsi_data_ptr,
  qmi_uim_imsi_digits_data_type  *imsi_digit_ptr
)
{
  uint8    i = 0;

  if(imsi_data_ptr == NULL ||
     imsi_digit_ptr == NULL ||
     ((imsi_data_ptr->imsi[0] + 1) != imsi_data_ptr->len) ||
    ((imsi_data_ptr->imsi[0] * 2) - 1 > sizeof(imsi_digit_ptr->imsi_digits)))
  {
    return QMI_ERR_INTERNAL;
  }

  imsi_digit_ptr->imsi_digits_len = 0;
  memset(&imsi_digit_ptr->imsi_digits[0], 0xF, sizeof(imsi_digit_ptr->imsi_digits));

  /* -----------------------------------------------------------
    Parse MCC from the IMSI:
    B0     B1    B2   B3   B4    B5    B6     B7      B8
    LEN  D1PB   D3D2 D5D4 D7D6  D9D8 D11D10 D13D12  D15D14
  -------------------------------------------------------------*/
  for(i = 0; i < imsi_data_ptr->imsi[0] - 1; i++)
  {
    imsi_digit_ptr->imsi_digits[i * 2] = imsi_data_ptr->imsi[i + 1] & QMI_UIM_IMSI_HIGH_BYTE_MASK;
    imsi_digit_ptr->imsi_digits[i * 2] >>= 4;
    imsi_digit_ptr->imsi_digits_len++;
    imsi_digit_ptr->imsi_digits[i * 2 + 1] = imsi_data_ptr->imsi[i + 2] & QMI_UIM_IMSI_LOW_BYTE_MASK;
    imsi_digit_ptr->imsi_digits_len++;
  }

  /* Check if last digit of IMSI is valid */
  if((imsi_data_ptr->imsi[imsi_data_ptr->imsi[0]] & QMI_UIM_IMSI_HIGH_BYTE_MASK) !=
       QMI_UIM_IMSI_HIGH_BYTE_MASK)
  {
    imsi_digit_ptr->imsi_digits[i * 2] =
      imsi_data_ptr->imsi[imsi_data_ptr->imsi[0]] & QMI_UIM_IMSI_HIGH_BYTE_MASK;
    imsi_digit_ptr->imsi_digits[i * 2] >>= 4;
    imsi_digit_ptr->imsi_digits_len++;
  }

  /* Convert the IMSI into digits format */
  for(i = 0; i < imsi_digit_ptr->imsi_digits_len; i++)
  {
    imsi_digit_ptr->imsi_digits[i] += '0';
  }

  return QMI_ERR_NONE;
} /* qmi_uim_convert_imsi_to_digits */


/*===========================================================================
  FUNCTION QMI_UIM_PREPARE_IMPI_FROM_IMSI

  DESCRIPTION
    Prepare IMPI From USIM IMSI

  PARAMETERS
    imsi_digit_ptr : value of imsi in a gba_imsi_data_type digit format
    impi_data_ptr : IMPI after conversion from IMSI
    mnc_length: MNC length

  RETURN VALUE
    qmi_error_e_type

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_prepare_impi_from_imsi(
  const qmi_uim_imsi_digits_data_type  *imsi_digit_ptr,
  qmi_uim_impi_type                    *impi_data_ptr,
  uint8                                 mnc_length
)
{
  const char  impi_suffix[]    = "@ims.mnc000.mcc000.3gppnetwork.org";

  if(imsi_digit_ptr == NULL ||
     impi_data_ptr == NULL ||
     imsi_digit_ptr->imsi_digits_len > QMI_UIM_IMSI_DIGIT_LEN)
  {
    UIM_MSG_ERR_0("Invalid input parameters");
    return QMI_ERR_INTERNAL;
  }

  /* Process IMSI */
  /* For example if the IMSI is 234150999999999 (MCC = 234, MNC = 15), the
     private user identity then takes the form
     234150999999999@ims.mnc015.mcc234.3gppnetwork.org as specified in TS.23.003
     section 13. */
  (void)memscpy(impi_data_ptr->data,
                sizeof(impi_data_ptr->data),
                imsi_digit_ptr->imsi_digits,
                imsi_digit_ptr->imsi_digits_len);

  impi_data_ptr->data_len = imsi_digit_ptr->imsi_digits_len;

  (void)memscpy(impi_data_ptr->data + impi_data_ptr->data_len,
                QMI_UIM_IMPI_MAX - impi_data_ptr->data_len,
                impi_suffix,
                strlen(impi_suffix));

  /*Update MNC */
  if(mnc_length == 3)
  {
    impi_data_ptr->data[impi_data_ptr->data_len + QMI_UIM_MNC_START_POS]     =
      impi_data_ptr->data[3];
    impi_data_ptr->data[impi_data_ptr->data_len + QMI_UIM_MNC_START_POS + 1] =
      impi_data_ptr->data[4];
    impi_data_ptr->data[impi_data_ptr->data_len + QMI_UIM_MNC_START_POS + 2] =
      impi_data_ptr->data[5];
  }
  else
  {
    impi_data_ptr->data[impi_data_ptr->data_len + QMI_UIM_MNC_START_POS]     = '0';
    impi_data_ptr->data[impi_data_ptr->data_len + QMI_UIM_MNC_START_POS + 1] =
      impi_data_ptr->data[3];
    impi_data_ptr->data[impi_data_ptr->data_len + QMI_UIM_MNC_START_POS + 2] =
      impi_data_ptr->data[4];
  }

  /* Update MCC */
  impi_data_ptr->data[impi_data_ptr->data_len + QMI_UIM_MCC_START_POS]     =
    impi_data_ptr->data[0];
  impi_data_ptr->data[impi_data_ptr->data_len + QMI_UIM_MCC_START_POS + 1] =
    impi_data_ptr->data[1];
  impi_data_ptr->data[impi_data_ptr->data_len + QMI_UIM_MCC_START_POS + 2] =
    impi_data_ptr->data[2];

  impi_data_ptr->data_len += strlen(impi_suffix);

  return QMI_ERR_NONE;
}/* qmi_uim_prepare_impi_from_imsi */


/*===========================================================================
  FUNCTION QMI_UIM_REMOVE_CL_SP_FROM_NON_PROV_SESSION_INDEX()

  DESCRIPTION
    Removes the passed in client state pointer from the non-prov. session
    index requested (in the global array).

  PARAMETERS
    index  : non-prov. session index in the global array
    cl_sp  : client state pointer

  RETURN VALUE
    errval : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_remove_cl_sp_from_non_prov_session_index
(
  uint16                       index,
  qmi_uimi_client_state_type * client_sp
)
{
  uint16                       cl_sp_index = 0;

  ASSERT(index < UIM_MAX_NON_PROV_SESSIONS);
  ASSERT(qmi_uim_global_ptr);

  if(client_sp == NULL)
  {
    return QMI_ERR_INVALID_ARG;
  }

  /* Go through the cl_sp array, check if passed in cl_sp is already present,
     and also find any empty slot */
  for(cl_sp_index = 0;
      cl_sp_index < (uint16)UIM_MAX_NON_PROV_CLIENTS;
      cl_sp_index++)
  {
    if (qmi_uim_global_ptr->non_prov_session[index].client_info.opening_cl_sp[cl_sp_index] ==
        client_sp)
    {
      /* Remove the cl_sp */
      qmi_uim_global_ptr->non_prov_session[index].client_info.opening_cl_sp[cl_sp_index] =
        NULL;
      /* Decrement the Client count */
      qmi_uim_global_ptr->non_prov_session[index].client_info.client_count--;
      break;
    }
  }

  return QMI_ERR_NONE;
} /* qmi_uim_remove_cl_sp_from_non_prov_session_index */


/*===========================================================================
  FUNCTION QMI_UIM_ADD_CL_SP_TO_NON_PROV_SESSION_INDEX()

  DESCRIPTION
    Adds the passed in client state pointer to the non-prov. session
    index requested (in the global array).

    The cl_sp is not added if already present or if there are no
    slots available in the non-prov. session index.

  PARAMETERS
    index      : non-prov. session index in the global array
    client_sp  : client state pointer

  RETURN VALUE
    errval         : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_add_cl_sp_to_non_prov_session_index
(
  uint16                       index,
  qmi_uimi_client_state_type * client_sp
)
{
  uint16                       cl_sp_index = 0;
  uint16                       empty_index = UIM_MAX_NON_PROV_CLIENTS;

  ASSERT(index < UIM_MAX_NON_PROV_SESSIONS);
  ASSERT(qmi_uim_global_ptr);

  if(client_sp == NULL)
  {
    return QMI_ERR_INVALID_ARG;
  }

  /* Go through the cl_sp array, check if passed in cl_sp is already present,
     and also find any empty slot */
  for(cl_sp_index = 0;
      cl_sp_index < (uint16)UIM_MAX_NON_PROV_CLIENTS;
      cl_sp_index++)
  {
    if ((qmi_uim_global_ptr->non_prov_session[index].client_info.opening_cl_sp[cl_sp_index] == NULL) &&
        (empty_index == UIM_MAX_NON_PROV_CLIENTS))
    {
      /* Empty slot found */
      empty_index = cl_sp_index;
    }

    /* If cl_sp already present, return */
    if (qmi_uim_global_ptr->non_prov_session[index].client_info.opening_cl_sp[cl_sp_index] ==
         client_sp)
    {
      return QMI_ERR_NONE;
    }
  }

  /* Index should be valid... otherwise it means that we didn't find
     the corresponding cl_sp and the array is also full */
  if (empty_index == UIM_MAX_NON_PROV_CLIENTS)
  {
    UIM_MSG_ERR_3("Cannot add cl_sp: 0x%x to non-prov. session index: 0x%x, session ID: 0x%x",
                  client_sp,
                  index,
                  qmi_uim_global_ptr->non_prov_session[index].mmgsdi_session_id);
    return QMI_ERR_NO_MEMORY;
  }

  /* Store the cl_sp */
  qmi_uim_global_ptr->non_prov_session[index].client_info.opening_cl_sp[empty_index] =
    client_sp;
  /* Increment the Client count */
  qmi_uim_global_ptr->non_prov_session[index].client_info.client_count++;

  return QMI_ERR_NONE;
} /* qmi_uim_add_cl_sp_to_non_prov_session_index */


/*===========================================================================
  FUNCTION QMI_UIM_UPDATE_NON_PROV_SESSION_CL_SP()

  DESCRIPTION
    Extracts the Session Info from the passed in TLV list, and if it is a
    non-prov. session already present in the global array, then the
    passed in cl_sp is associated with the session.

  PARAMETERS
    tlv_data_ptr   : pointer to list of TLVs
    tlv_data_count : number of TLVs
    client_sp      : client state pointer

  RETURN VALUE
    errval         : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_update_non_prov_session_cl_sp
(
  qmi_uim_tlv_item_type      * tlv_data_ptr,
  uint8                        tlv_data_count,
  qmi_uimi_client_state_type * client_sp
)
{
  uint16                                 i               = 0;
  qmi_uim_tlv_session_information_type * tlv_session_ptr = NULL;

  ASSERT(tlv_data_ptr);
  ASSERT(tlv_data_count > 0);
  ASSERT(qmi_uim_global_ptr);

  if(client_sp == NULL)
  {
    UIM_MSG_ERR_0("NULL client_sp");
    return QMI_ERR_INVALID_ARG;
  }

  /* Find session information in the TLVs */
  for (i = 0; i < tlv_data_count; i++)
  {
    if (tlv_data_ptr[i].type == UIMI_TLV_TYPE_SESSION_INFORMATION &&
        tlv_data_ptr[i].present)
    {
      tlv_session_ptr = &tlv_data_ptr[i].data.session_information;
      break;
    }
  }
  if (tlv_session_ptr == NULL)
  {
    UIM_MSG_ERR_0("No session information in TLV");
    return QMI_ERR_INTERNAL;
  }

  /* Verify session type is non provisioning */
  if (tlv_session_ptr->session_type != MMGSDI_NON_PROV_SESSION_SLOT_1 &&
      tlv_session_ptr->session_type != MMGSDI_NON_PROV_SESSION_SLOT_2 &&
      tlv_session_ptr->session_type != MMGSDI_NON_PROV_SESSION_SLOT_3)
  {
    return QMI_ERR_NONE;
  }

  /* Check if the requested non provisioning session is already available
     in the global array */
  for (i = 0; i < UIM_MAX_NON_PROV_SESSIONS; i++)
  {
    if (qmi_uim_global_ptr->non_prov_session[i].init &&
        qmi_uim_global_ptr->non_prov_session[i].session_type == tlv_session_ptr->session_type &&
        qmi_uim_global_ptr->non_prov_session[i].aid.data_len > 0 &&
        qmi_uim_global_ptr->non_prov_session[i].aid.data_len == tlv_session_ptr->aid.data_len)
    {
      /* Add cl_sp to the non-prov. session */
      if (memcmp((void*)qmi_uim_global_ptr->non_prov_session[i].aid.data_ptr,
                 (void*)tlv_session_ptr->aid.data_ptr,
                 int32touint32(tlv_session_ptr->aid.data_len)) == 0)
      {
        return qmi_uim_add_cl_sp_to_non_prov_session_index(i, client_sp);
      }
    }
  }
  return QMI_ERR_NONE;
} /* qmi_uim_update_non_prov_session_cl_sp */


/*===========================================================================
  FUNCTION QMI_UIM_REMOVE_REFRESH_REGISTRATION()

  DESCRIPTION
    Removes data about refresh registration for a non provisioning session.

  PARAMETERS
    session_id  : session id

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_remove_refresh_registration
(
  mmgsdi_session_id_type   session_id
)
{
  uint16                       i                      = 0;
  qmi_uimi_client_state_type * cl_sp                  = NULL;
  uint16                       refresh_index          = 0;
  uint32                       notify_mask            = 0;
  uint8                        non_prov_refresh_index = 0;

  ASSERT(qmi_uim_global_ptr);
  ASSERT(qmi_uim_state_ptr);

  if (qmi_uim_session_id_to_refresh_index(&refresh_index, session_id) != QMI_ERR_NONE)
  {
    /* The session id was not used for refresh... nothing to do */
    return;
  }
  ASSERT(refresh_index < UIM_REFRESH_SESSION_COUNT);

  /* Calculate the notify mask */
  notify_mask = 1 << refresh_index;

  for (i = 0; i < UIMI_MAX_CLIDS; i++)
  {
    cl_sp = (qmi_uimi_client_state_type*)qmi_uim_state_ptr->client[i];
    if ( cl_sp != NULL )
    {
      /* remove the notify flag for this session id */
      cl_sp->uim_info.refresh_notify_mask = (cl_sp->uim_info.refresh_notify_mask & (~notify_mask));

      /* Remove the notify all flag for this session id */
      cl_sp->uim_info.refresh_all_notify_mask = (cl_sp->uim_info.refresh_all_notify_mask & (~notify_mask));

      /* Remove files for this session from the list of files that each client
         registered */
      (void)qmi_uim_remove_client_refresh_files(cl_sp, session_id);
    }
  }

  /* Clean the non-prov session id that is used for refresh */
  if (refresh_index >= UIM_REFRESH_PROV_COUNT)
  {
    non_prov_refresh_index = refresh_index - UIM_REFRESH_PROV_COUNT;
    qmi_uim_global_ptr->non_prov_refresh_session_id[non_prov_refresh_index] =
      UIM_INVALID_SESSION_ID;
  }
} /* qmi_uim_remove_refresh_registration */

#ifdef FEATURE_UIM_DS_SUBSCRIPTION_MANAGER
/*===========================================================================
FUNCTION QMI_UIM_IS_PHYSICAL_SLOT_ACTIVE_FOR_LOGICAL_SLOT()

DESCRIPTION
  Figures out if for the logical slot, the physical slot is active or not.

PARAMETERS
  uim_slot_type        : logical slot id
  uim_slot_type        : physical slot id

RETURN VALUE
  None

DEPENDENCIES
  QMI UIM service must be initialized and registered with Framework

SIDE EFFECTS
  None

===========================================================================*/
static boolean qmi_uim_is_physical_slot_active_for_logical_slot
(
  uim_slot_type                   logical_slot_id,
  uim_slot_type                   physical_slot_id
)
{
  uint8 slot_idx = 0;

  ASSERT(qmi_uim_global_ptr != NULL);

  /* Convert slot to index */
  switch (physical_slot_id)
  {
    case UIM_SLOT_1:
      slot_idx = 0;
      break;
    case UIM_SLOT_2:
      slot_idx = 1;
      break;
    default:
      return FALSE;
  }

  if(slot_idx < qmi_uim_global_ptr->physical_slots_info.num_slots &&
     qmi_uim_global_ptr->physical_slots_info.slot_status_ptr != NULL &&
     qmi_uim_global_ptr->physical_slots_info.slot_status_ptr[slot_idx].logical_slot == logical_slot_id &&
     qmi_uim_global_ptr->physical_slots_info.slot_status_ptr[slot_idx].activity_status == UIM_SLOT_STATE_ACTIVE)
  {
    return TRUE;
  }

  return FALSE;
} /* qmi_uim_is_physical_slot_active_for_logical_slot() */
#endif

/*===========================================================================
FUNCTION QMI_UIM_STORE_PHYSICAL_SLOTS_STATUS()

DESCRIPTION
  Copies the physical slots status from the passed-in parameter to the
  QMI UIM global for physical slots status.

PARAMETERS
  uint8                   : number of physical slots supported
  uim_phy_slot_status_type: status of the physical slots

RETURN VALUE
  TRUE                    : Global updated with latest physical slots info
  FALSE                   : Otherwise

DEPENDENCIES
  QMI UIM service must be initialized and registered with Framework

SIDE EFFECTS
  None

===========================================================================*/
static boolean qmi_uim_store_physical_slots_status
(
  uint8                           num_physical_slots,
  const uim_phy_slot_status_type *physical_slot_status_ptr
)
{
  uint8         index           = 0;
  boolean       is_info_updated = FALSE;

  ASSERT(qmi_uim_global_ptr != NULL);

  /* If number of slots QMI UIM received by calling get_num_physical_slots
     during power up is not same as number of physical slots mentioned in
     the uimdrv callback here, there's a serious problem */
  if(qmi_uim_global_ptr->physical_slots_info.slot_status_ptr == NULL ||
     qmi_uim_global_ptr->physical_slots_info.num_slots == 0 ||
     physical_slot_status_ptr == NULL ||
     num_physical_slots != qmi_uim_global_ptr->physical_slots_info.num_slots)
  {
    UIM_MSG_ERR_0("qmi_uim_store_physical_slots_status: slots validation error");
    return FALSE;
  }

  /* Overwrite the qmi uim global ptr for physical slots status info with
     latest info */
  for(index = 0; index < qmi_uim_global_ptr->physical_slots_info.num_slots && index < UIM_NUM_PHY_SLOTS; index ++)
  {
    /* Do not update the card hotswap status if it has not changed since last
       time we updated it (to CARD_INSERTED or CARD_REMOVED) */
    if(physical_slot_status_ptr[index].card_presence_status != UIM_CARD_UNCHANGED &&
       qmi_uim_global_ptr->physical_slots_info.slot_status_ptr[index].card_presence_status !=
         physical_slot_status_ptr[index].card_presence_status)
    {
      qmi_uim_global_ptr->physical_slots_info.slot_status_ptr[index].card_presence_status =
        physical_slot_status_ptr[index].card_presence_status;
      is_info_updated = TRUE;
    }
    if(qmi_uim_global_ptr->physical_slots_info.slot_status_ptr[index].activity_status !=
         physical_slot_status_ptr[index].activity_status)
    {
      qmi_uim_global_ptr->physical_slots_info.slot_status_ptr[index].activity_status =
        physical_slot_status_ptr[index].activity_status;
      is_info_updated = TRUE;
    }
    if(qmi_uim_global_ptr->physical_slots_info.slot_status_ptr[index].logical_slot !=
         physical_slot_status_ptr[index].logical_slot)
    {
      qmi_uim_global_ptr->physical_slots_info.slot_status_ptr[index].logical_slot =
        physical_slot_status_ptr[index].logical_slot;
      is_info_updated = TRUE;
    }
    if(qmi_uim_global_ptr->physical_slots_info.slot_status_ptr[index].iccid_len !=
         physical_slot_status_ptr[index].iccid_len ||
       memcmp(qmi_uim_global_ptr->physical_slots_info.slot_status_ptr[index].iccid,
              physical_slot_status_ptr[index].iccid,
              physical_slot_status_ptr[index].iccid_len) != 0)
    {
      qmi_uim_global_ptr->physical_slots_info.slot_status_ptr[index].iccid_len =
          physical_slot_status_ptr[index].iccid_len;
      (void)memscpy(qmi_uim_global_ptr->physical_slots_info.slot_status_ptr[index].iccid,
                    sizeof(qmi_uim_global_ptr->physical_slots_info.slot_status_ptr[index].iccid),
                    physical_slot_status_ptr[index].iccid,
                    physical_slot_status_ptr[index].iccid_len);
      is_info_updated = TRUE;
    }
  }

  return is_info_updated;
} /* qmi_uim_store_physical_slots_status() */


/*===========================================================================
  FUNCTION QMI_UIM_SEND_APDU_SESSION_CLOSED_IND()

  DESCRIPTION
    This function sends a Session Closed Indication indication to the
    client that has opened the APDU Session.

  PARAMETERS
    index : apdu session index in the global array
    cause : Cause for session closure

  RETURN VALUE
    None.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_send_apdu_session_closed_ind
(
  uint16                                 index,
  mmgsdi_session_closed_cause_enum_type  cause
)
{
  dsm_item_type              * indication = NULL;
  qmi_uimi_client_state_type * client_sp  = NULL;
  mmgsdi_slot_id_enum_type     slot       = MMGSDI_MAX_SLOT_ID_ENUM;
  uint8                        channel_id = 0;

  ASSERT(qmi_uim_global_ptr);

  if(index >= UIM_MAX_APDU_CHANNEL_COUNT)
  {
    UIM_MSG_ERR_1("Invalid apdu session index: 0x%x, cannot send session closed evt",
                  index);
    return;
  }

  client_sp = qmi_uim_global_ptr->apdu_channel[index]->opening_cl_sp;

  /* Check if the Client state is valid */
  if(client_sp == NULL)
  {
    return;
  }

  /* Retrieve the slot, channel info and cause - to be sent as part of the Session
     Closed event */
  slot = qmi_uim_global_ptr->apdu_channel[index]->slot;
  channel_id = qmi_uim_global_ptr->apdu_channel[index]->logical_channel;

  /* Insert channel ID in TLV */
  if (FALSE == qmi_uim_response_logical_channel(
                 UIMI_TLV_RESP_TAG_OPTIONAL_2,
                 &indication,
                 channel_id))
  {
    /* Ignore error... there is nothing we can do about it.
       The event will not be delivered to the client */
    dsm_free_packet(&indication);
    return;
  }

  /* Insert card slot in TLV */
  if (FALSE == qmi_uim_response_slot(
                   UIMI_TLV_TAG_MANDATORY_1,
                   &indication,
                   slot))
  {
    /* Ignore error... there is nothing we can do about it.
       The event will not be delivered to the client */
    dsm_free_packet(&indication);
    return;
  }

  /* Insert the cause in the TLV. Indication is sent
     even if the cause TLV is not inserted */
  (void)qmi_uim_response_session_closed_cause(
                   UIMI_TLV_RESP_TAG_OPTIONAL_4,
                   &indication,
                   cause);


  /* Send indication to the client */
  (void)qmi_uimi_send_indication(client_sp->common.clid,
                                 (uint16)UIMI_CMD_VAL_SESSION_CLOSED_IND,
                                 indication);

} /* qmi_uim_send_apdu_session_closed_ind */


/*===========================================================================
  FUNCTION QMI_UIM_REMOVE_APDU_SESSION()

  DESCRIPTION
    Removes a non provisioning session previously opened to stream APDUs
    from the global array

  PARAMETERS
    session_id           :  session id
    send_ind             :  Specify if a QMI_UIM_SESSION_CLOSED_IND needs to
                            be sent to the client that has opened the session
                            (TRUE) or not (FALSE)
    session_closed_cause : Cause for session closure

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_remove_apdu_session
(
  mmgsdi_session_id_type                session_id,
  boolean                               send_ind,
  mmgsdi_session_closed_cause_enum_type session_closed_cause
)
{
  uint16  i  = 0;

  ASSERT(qmi_uim_global_ptr);

  for (i = 0; i < UIM_MAX_APDU_CHANNEL_COUNT; i++)
  {
    if (qmi_uim_global_ptr->apdu_channel[i] &&
        qmi_uim_global_ptr->apdu_channel[i]->mmgsdi_session_id == session_id)
    {
      /* Send Session Closed Indication to Client */
      if(send_ind)
      {
        qmi_uim_send_apdu_session_closed_ind(i, session_closed_cause);
      }

      /* Remove refresh data of the non prov session */
      qmi_uim_remove_refresh_registration(session_id);

      /* Free channel info. Skip if a response is pending to a client because
         this info is needed during the open session callback */
      if (qmi_uim_global_ptr->apdu_channel[i]->mmgsdi_session_id ==
          UIM_INVALID_SESSION_ID)
      {
        UIM_MSG_HIGH_1("Skipping removal of APDU channel info at index: %d",
                       i);
      }
      else
      {
        uimqmi_free(qmi_uim_global_ptr->apdu_channel[i]);
        qmi_uim_global_ptr->apdu_channel[i] = NULL;
      }

      break;
    }
  }
} /* qmi_uim_remove_apdu_session */


/*===========================================================================
  FUNCTION QMI_UIM_EXECUTE_READ_TRANSPARENT()

  DESCRIPTION
    Reads the content of a transparent file on the card

  PARAMETERS
    command_id        : command id
    session_id        : session id
    file_access       : file to be read
    offset            : offset in the file
    length            : length to be read
    encryption_status : requested encrption type
    token_ptr         : token pointer
    cmd_buf_ptr       : userdata
    clid              : client id of the control point

  RETURN VALUE
    errval      : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_execute_read_transparent
(
  qmi_uimi_cmd_val_e_type             command_id,
  mmgsdi_session_id_type              session_id,
  mmgsdi_access_type                  file_access,
  mmgsdi_offset_type                  offset,
  mmgsdi_len_type                     length,
  qmi_uim_requested_encrytion_type    encryption_status,
  const uint32                      * token_ptr,
  void *                              cmd_buf_ptr,
  uint8                               clid
)
{
  qmi_error_e_type               errval            = QMI_ERR_NONE;
  mmgsdi_return_enum_type        mmgsdi_status     = MMGSDI_SUCCESS;
  qmi_uimi_userdata_type*        cb_userdata_ptr   = NULL;
  mmgsdi_session_type_enum_type  session_type      = MMGSDI_MAX_SESSION_TYPE_ENUM;
  mmgsdi_static_data_type        aid               = { 0, };
  mmgsdi_access_type             path_file_access  = file_access;

  /* Try to convert path into enum. At this point
     we can ignore errors and proceed with access by path */
  if (qmi_uim_session_id_to_session_type(&session_type, &aid, session_id) == QMI_ERR_NONE)
  {
    (void)qmi_uim_convert_file_access_method(&file_access,
                                             MMGSDI_EF_ENUM_ACCESS,
                                             session_type);
  }

  if (encryption_status == QMI_UIM_COMPLETE_ENCRYPTION &&
      (session_type != MMGSDI_GW_PROV_PRI_SESSION &&
       session_type != MMGSDI_1X_PROV_PRI_SESSION &&
       session_type != MMGSDI_GW_PROV_SEC_SESSION &&
       session_type != MMGSDI_1X_PROV_SEC_SESSION &&
       session_type != MMGSDI_GW_PROV_TER_SESSION &&
       session_type != MMGSDI_1X_PROV_TER_SESSION))
  {
    UIM_MSG_ERR_1("Only support provisioning sessions for complete read encryption: 0x%x",
                  session_type);
    return QMI_ERR_INVALID_ARG;
  }

  /* Create userdata */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(command_id,
                                            cmd_buf_ptr,
                                            token_ptr,
                                            clid);
  if (cb_userdata_ptr == NULL)
  {
    return QMI_ERR_NO_MEMORY;
  }
  cb_userdata_ptr->data.read_transparent.encryption_status = encryption_status;
  cb_userdata_ptr->data.read_transparent.file_access = path_file_access;
  cb_userdata_ptr->data.read_transparent.session_type = session_type;

  /* Execute MMGSDI read transparent */
  mmgsdi_status = mmgsdi_session_read_transparent(
                        session_id,
                        file_access,
                        offset,
                        length,
                        qmi_uimi_mmgsdi_callback,
                        (mmgsdi_client_data_type)cb_userdata_ptr );

  /* Free userdata in case of error */
  QMI_UIM_FREE_USERDATA_IF_ERROR(mmgsdi_status, cb_userdata_ptr);

  /* Convert MMGSDI status in QMI code */
  errval = qmi_uim_convert_mmgsdi_status_to_errval(mmgsdi_status);

  return errval;
} /* qmi_uim_execute_read_transparent */


/*===========================================================================
  FUNCTION QMI_UIM_EXECUTE_READ_RECORD()

  DESCRIPTION
    Reads the content of a cyclic or linear fixed file on the card

  PARAMETERS
    session_id   : session id
    file_access  : file to be read
    first_record : first record in the file
    last_record  : last record in the file
    length       : length to be read
    cmd_buf_ptr  : userdata
    clid         : client id of the control point

  RETURN VALUE
    errval      : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_execute_read_record
(
  mmgsdi_session_id_type  session_id,
  mmgsdi_access_type      file_access,
  mmgsdi_rec_num_type     first_record,
  mmgsdi_rec_num_type     last_record,
  mmgsdi_len_type         length,
  const uint32          * token_ptr,
  void *                  cmd_buf_ptr,
  uint8                   clid
)
{
  qmi_error_e_type               errval          = QMI_ERR_NONE;
  mmgsdi_return_enum_type        mmgsdi_status   = MMGSDI_SUCCESS;
  qmi_uimi_userdata_type*        cb_userdata_ptr = NULL;
  mmgsdi_session_type_enum_type  session_type    = MMGSDI_MAX_SESSION_TYPE_ENUM;
  mmgsdi_static_data_type        aid             = { 0, };

  /* Validate the last record */
  if (last_record < first_record ||
      first_record > QMI_UIM_MAX_RECORD_LEN ||
      last_record > QMI_UIM_MAX_RECORD_LEN)
  {
    UIM_MSG_ERR_2("Last record (0x%x) smaller than first record(0x%x)",
                  last_record, first_record);
    return QMI_ERR_INVALID_ARG;
  }

  /* Try to convert path into enum. At this point
     we can ignore errors and proceed with access by path */
  if (qmi_uim_session_id_to_session_type(&session_type, &aid, session_id) == QMI_ERR_NONE)
  {
    (void)qmi_uim_convert_file_access_method(&file_access,
                                             MMGSDI_EF_ENUM_ACCESS,
                                             session_type);
  }

  /* Create userdata */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_READ_RECORD,
                                            cmd_buf_ptr,
                                            token_ptr,
                                            clid);
  if (cb_userdata_ptr == NULL)
  {
    return QMI_ERR_NO_MEMORY;
  }

  /* Store data about records to read */
  (void)memscpy(&cb_userdata_ptr->data.read_record.file_access,
                sizeof(mmgsdi_access_type),
         &file_access,
         sizeof(mmgsdi_access_type));
  cb_userdata_ptr->data.read_record.first_record  = first_record;
  cb_userdata_ptr->data.read_record.total_records = (uint16)(last_record - first_record) + 1;
  cb_userdata_ptr->data.read_record.read_records  = 0;

  /* In case of multiple records, allocate memory for all the results */
  if (last_record > first_record)
  {
    uint32 size = cb_userdata_ptr->data.read_record.total_records *
                  sizeof(qmi_uim_additional_records_type);

    cb_userdata_ptr->data.read_record.records_cnf =
      (qmi_uim_additional_records_type *)uimqmi_malloc(size);
    if (cb_userdata_ptr->data.read_record.records_cnf == NULL)
    {
      qmi_uim_free_cb_userdata(cb_userdata_ptr);
      return QMI_ERR_NO_MEMORY;
    }
    memset(cb_userdata_ptr->data.read_record.records_cnf, 0, size);
  }

  /* Execute MMGSDI read record */
  mmgsdi_status = mmgsdi_session_read_record(
                        session_id,
                        file_access,
                        first_record,
                        length,
                        qmi_uimi_mmgsdi_callback,
                        (mmgsdi_client_data_type)cb_userdata_ptr );

  /* Free userdata in case of error */
  QMI_UIM_FREE_USERDATA_IF_ERROR(mmgsdi_status, cb_userdata_ptr);

  /* Convert MMGSDI status in QMI code */
  errval = qmi_uim_convert_mmgsdi_status_to_errval(mmgsdi_status);

  return errval;
} /* qmi_uim_execute_read_record */


/*===========================================================================
  FUNCTION QMI_UIM_EXECUTE_WRITE_TRANSPARENT()

  DESCRIPTION
    Writes the content of a transparent file on the card

  PARAMETERS
    session_id  : session id
    file_access : file to be read
    record      : record in the file
    length      : length to be read
    cmd_buf_ptr : userdata
    clid        : client id of the control point

  RETURN VALUE
    errval      : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_execute_write_transparent
(
  mmgsdi_session_id_type  session_id,
  mmgsdi_access_type      file_access,
  mmgsdi_offset_type      offset,
  mmgsdi_write_data_type  data,
  const uint32          * token_ptr,
  void *                  cmd_buf_ptr,
  uint8                   clid
)
{
  qmi_error_e_type               errval          = QMI_ERR_NONE;
  mmgsdi_return_enum_type        mmgsdi_status   = MMGSDI_SUCCESS;
  qmi_uimi_userdata_type*        cb_userdata_ptr = NULL;
  mmgsdi_session_type_enum_type  session_type    = MMGSDI_MAX_SESSION_TYPE_ENUM;
  mmgsdi_static_data_type        aid             = { 0, };

  /* Try to convert path into enum. At this point
     we can ignore errors and proceed with access by path */
  if (qmi_uim_session_id_to_session_type(&session_type, &aid, session_id) == QMI_ERR_NONE)
  {
    (void)qmi_uim_convert_file_access_method(&file_access,
                                             MMGSDI_EF_ENUM_ACCESS,
                                             session_type);
  }

  /* Create userdata */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_WRITE_TRANSPARENT,
                                            cmd_buf_ptr,
                                            token_ptr,
                                            clid);
  if (cb_userdata_ptr == NULL)
  {
    return QMI_ERR_NO_MEMORY;
  }

  /* Execute MMGSDI write transparent */
  mmgsdi_status = mmgsdi_session_write_transparent(
                        session_id,
                        file_access,
                        offset,
                        data,
                        qmi_uimi_mmgsdi_callback,
                        (mmgsdi_client_data_type)cb_userdata_ptr );

  /* Free userdata in case of error */
  QMI_UIM_FREE_USERDATA_IF_ERROR(mmgsdi_status, cb_userdata_ptr);

  /* Convert MMGSDI status in QMI code */
  errval = qmi_uim_convert_mmgsdi_status_to_errval(mmgsdi_status);

  return errval;
} /* qmi_uim_execute_write_transparent */


/*===========================================================================
  FUNCTION QMI_UIM_EXECUTE_WRITE_RECORD()

  DESCRIPTION
    Writes a record on a cyclic or linear fixed file on the card

  PARAMETERS
    session_id  : session id
    file_access : file to be read
    record      : record in the file
    length      : length to be read
    cmd_buf_ptr : userdata
    clid        : client id of the control point

  RETURN VALUE
    errval      : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_execute_write_record
(
  mmgsdi_session_id_type  session_id,
  mmgsdi_access_type      file_access,
  mmgsdi_rec_num_type     record,
  mmgsdi_write_data_type  data,
  const uint32          * token_ptr,
  void *                  cmd_buf_ptr,
  uint8                   clid
)
{
  qmi_error_e_type                 errval          = QMI_ERR_NONE;
  mmgsdi_return_enum_type          mmgsdi_status   = MMGSDI_SUCCESS;
  mmgsdi_file_structure_enum_type  file_type       = MMGSDI_LINEAR_FIXED_FILE;
  qmi_uimi_userdata_type*          cb_userdata_ptr = NULL;
  mmgsdi_session_type_enum_type    session_type    = MMGSDI_MAX_SESSION_TYPE_ENUM;
  mmgsdi_static_data_type          aid             = { 0, };

  /* Try to convert path into enum. At this point
     we can ignore errors and proceed with access by path */
  if (qmi_uim_session_id_to_session_type(&session_type, &aid, session_id) == QMI_ERR_NONE)
  {
    (void)qmi_uim_convert_file_access_method(&file_access,
                                             MMGSDI_EF_ENUM_ACCESS,
                                             session_type);
  }

  /* Create userdata */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_WRITE_RECORD,
                                            cmd_buf_ptr,
                                            token_ptr,
                                            clid);
  if (cb_userdata_ptr == NULL)
  {
    return QMI_ERR_NO_MEMORY;
  }

  /* Duplicate the details of operation */
  (void)memscpy(&cb_userdata_ptr->data.write_record.file_access,
                sizeof(mmgsdi_access_type),
         &file_access,
         sizeof(mmgsdi_access_type));
  cb_userdata_ptr->data.write_record.record        = record;
  cb_userdata_ptr->data.write_record.data.data_len = data.data_len;
  qmi_uim_deep_copy((void**)&cb_userdata_ptr->data.write_record.data.data_ptr,
                    (void*)data.data_ptr,
                    (uint32)data.data_len);

  /* Verify the data was correctly deep-copied */
  if (cb_userdata_ptr->data.write_record.data.data_ptr == NULL)
  {
    qmi_uim_free_cb_userdata(cb_userdata_ptr);
    cb_userdata_ptr = NULL;
    return QMI_ERR_NO_MEMORY;
  }

  /* Check if the file format is known */
  if (qmi_uim_check_cached_record_type(session_id,
                                       file_access,
                                       &file_type))
  {
    UIM_MSG_HIGH_1("Write record: type is known (0x%x)", file_type);

    /* Execute MMGSDI write record */
    mmgsdi_status = mmgsdi_session_write_record(
                          session_id,
                          file_access,
                          file_type,
                          record,
                          data,
                          qmi_uimi_mmgsdi_callback,
                          (mmgsdi_client_data_type)cb_userdata_ptr );
  }
  else
  {
    UIM_MSG_HIGH_0("Write record: type unknown, get file atteributes first");

    /* Execute MMGSDI get file attributes */
    mmgsdi_status = mmgsdi_session_get_file_attr(
                        session_id,
                        file_access,
                        qmi_uimi_mmgsdi_callback,
                        (mmgsdi_client_data_type)cb_userdata_ptr );
  }

  /* Free userdata in case of error */
  QMI_UIM_FREE_USERDATA_IF_ERROR(mmgsdi_status, cb_userdata_ptr);

  /* Convert MMGSDI status in QMI code */
  errval = qmi_uim_convert_mmgsdi_status_to_errval(mmgsdi_status);

  return errval;
} /* qmi_uim_execute_write_record */


/*===========================================================================
  FUNCTION QMI_UIM_EXECUTE_GET_FILE_ATTRIBUTES()

  DESCRIPTION
    Get file attributes of a file on the card

  PARAMETERS
    session_id  : session id
    file_access : file to be read
    record      : record in the file
    length      : length to be read
    cmd_buf_ptr : userdata
    clid        : client id of the control point

  RETURN VALUE
    errval      : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_execute_get_file_attributes
(
  mmgsdi_session_id_type  session_id,
  mmgsdi_access_type      file_access,
  const uint32          * token_ptr,
  void *                  cmd_buf_ptr,
  uint8                   clid
)
{
  qmi_error_e_type               errval          = QMI_ERR_NONE;
  mmgsdi_return_enum_type        mmgsdi_status   = MMGSDI_SUCCESS;
  qmi_uimi_userdata_type*        cb_userdata_ptr = NULL;
  mmgsdi_session_type_enum_type  session_type    = MMGSDI_MAX_SESSION_TYPE_ENUM;
  mmgsdi_static_data_type        aid             = { 0, };

  /* Try to convert path into enum. At this point
     we can ignore errors and proceed with access by path */
  if (qmi_uim_session_id_to_session_type(&session_type, &aid, session_id) == QMI_ERR_NONE)
  {
    (void)qmi_uim_convert_file_access_method(&file_access,
                                             MMGSDI_EF_ENUM_ACCESS,
                                             session_type);
  }

  /* Populate access parameters in case of DF or MF */
  if(file_access.access_method == MMGSDI_BY_PATH_ACCESS &&
     file_access.file.path_type.path_len <= MMGSDI_MAX_PATH_LEN &&
     file_access.file.path_type.path_len > 1 &&
     file_access.file.path_type.path_buf[file_access.file.path_type.path_len - 1] == 0xFFFF)
  {
    file_access.access_method = MMGSDI_DF_ENUM_ACCESS;

    switch(file_access.file.path_type.path_buf[file_access.file.path_type.path_len - 2])
    {
      case 0x3F00:
        file_access.file.df_enum = MMGSDI_MF_DIR;
        break;
      case 0x7F20:
        file_access.file.df_enum = MMGSDI_GSM_DIR;
        break;
      case 0x7F10:
        file_access.file.df_enum = MMGSDI_TELECOM_DIR;
        break;
      case 0x7FFF:
        file_access.file.df_enum = MMGSDI_LAST_SEL_ADF_DIR;
        break;
      case 0x7F21:
        file_access.file.df_enum = MMGSDI_DCS1800_DIR;
        break;
      case 0x7F25:
        file_access.file.df_enum = MMGSDI_RUIM_DIR;
        break;
      default:
        UIM_MSG_ERR_1("Invalid MF or DF (0x%x) in file access path",
                      file_access.file.path_type.path_buf[file_access.file.path_type.path_len - 2]);
        return QMI_ERR_INTERNAL;
    }
  }

  /* Create userdata */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_GET_FILE_ATTRIBUTES,
                                            cmd_buf_ptr,
                                            token_ptr,
                                            clid);
  if (cb_userdata_ptr == NULL)
  {
    return QMI_ERR_NO_MEMORY;
  }

  /* Copy file path into the userdata */
  (void)memscpy(&cb_userdata_ptr->data.get_file_attributes.file_access,
                sizeof(mmgsdi_access_type),
         &file_access,
         sizeof(mmgsdi_access_type));

  /* Execute MMGSDI get file attributes */
  mmgsdi_status = mmgsdi_session_get_file_attr(
                        session_id,
                        file_access,
                        qmi_uimi_mmgsdi_callback,
                        (mmgsdi_client_data_type)cb_userdata_ptr );

  /* Free userdata in case of error */
  QMI_UIM_FREE_USERDATA_IF_ERROR(mmgsdi_status, cb_userdata_ptr);

  /* Convert MMGSDI status in QMI code */
  errval = qmi_uim_convert_mmgsdi_status_to_errval(mmgsdi_status);

  return errval;
} /* qmi_uim_execute_get_file_attributes */


/*===========================================================================
  FUNCTION QMI_UIM_EXECUTE_SET_PIN_PROTECTION()

  DESCRIPTION
    Enable / Disable the pin on the card

  PARAMETERS
    session_id   : session id
    pin_enable   : indicate if PIN needs to be enabled or disabled
    pin_id       : PIN id
    pin_data     : PIN value
    cmd_buf_ptr  : userdata
    clid         : client id of the control point

  RETURN VALUE
    errval       : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_execute_set_pin_protection
(
  mmgsdi_session_id_type  session_id,
  boolean                 pin_enable,
  mmgsdi_pin_enum_type    pin_id,
  mmgsdi_data_type        pin_data,
  const uint32          * token_ptr,
  void *                  cmd_buf_ptr,
  uint8                   clid
)
{
  qmi_error_e_type          errval          = QMI_ERR_NONE;
  mmgsdi_return_enum_type   mmgsdi_status   = MMGSDI_SUCCESS;
  qmi_uimi_userdata_type*   cb_userdata_ptr = NULL;

  ASSERT(qmi_uim_global_ptr != NULL);

  /* Create userdata */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_SET_PIN_PROTECTION,
                                            cmd_buf_ptr,
                                            token_ptr,
                                            clid);
  if (cb_userdata_ptr == NULL)
  {
    return QMI_ERR_NO_MEMORY;
  }

  /* Execute MMGSDI function (enable or disable) */
  if (pin_enable)
  {
    mmgsdi_status = mmgsdi_session_enable_pin(
                        session_id,
                        pin_id,
                        pin_data,
                        qmi_uimi_mmgsdi_callback,
                        (mmgsdi_client_data_type)cb_userdata_ptr );

    /* Store the PIN to encrypt it later */
    if (qmi_uim_global_ptr->silent_pin1_supported &&
        mmgsdi_status == MMGSDI_SUCCESS &&
        pin_id == MMGSDI_PIN1 &&
        pin_data.data_len > 0 && pin_data.data_len <= QMI_UIM_TLV_MAX_PIN_LEN &&
        pin_data.data_ptr != NULL)
    {
      cb_userdata_ptr->data.pin_operation.pin1_length = pin_data.data_len;
      (void)memscpy(cb_userdata_ptr->data.pin_operation.pin1_value,
                    sizeof(cb_userdata_ptr->data.pin_operation.pin1_value),
             pin_data.data_ptr,
             pin_data.data_len);
    }
  }
  else
  {
    mmgsdi_status = mmgsdi_session_disable_pin(
                        session_id,
                        pin_id,
                        MMGSDI_PIN_NOT_REPLACED_BY_UNIVERSAL,
                        pin_data,
                        qmi_uimi_mmgsdi_callback,
                        (mmgsdi_client_data_type)cb_userdata_ptr );
  }

  /* Free userdata in case of error */
  QMI_UIM_FREE_USERDATA_IF_ERROR(mmgsdi_status, cb_userdata_ptr);

  /* Convert MMGSDI status in QMI code */
  errval = qmi_uim_convert_mmgsdi_status_to_errval(mmgsdi_status);

  return errval;
} /* qmi_uim_execute_set_pin_protection */


/*===========================================================================
  FUNCTION QMI_UIM_EXECUTE_VERIFY_PIN()

  DESCRIPTION
    Verify the PIN

  PARAMETERS
    session_id   : session id
    pin_id       : PIN id
    pin_data     : PIN value
    is_encrypted : PIN value is encrypted or not
    cmd_buf_ptr  : userdata
    clid         : client id of the control point

  RETURN VALUE
    errval       : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_execute_verify_pin
(
  mmgsdi_session_id_type  session_id,
  mmgsdi_pin_enum_type    pin_id,
  mmgsdi_data_type        pin_data,
  boolean                 is_encrypted,
  const uint32          * token_ptr,
  void *                  cmd_buf_ptr,
  uint8                   clid
)
{
  qmi_error_e_type          errval                = QMI_ERR_NONE;
  mmgsdi_return_enum_type   mmgsdi_status         = MMGSDI_SUCCESS;
  qmi_uimi_userdata_type*   cb_userdata_ptr       = NULL;

  ASSERT(qmi_uim_global_ptr != NULL);

  /* Perform a check on the PIN value */
  if (!qmi_uim_check_pin_digits(pin_data))
  {
    return QMI_ERR_INCORRECT_PIN;
  }

  /* Create userdata */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_VERIFY_PIN,
                                            cmd_buf_ptr,
                                            token_ptr,
                                            clid);
  if (cb_userdata_ptr == NULL)
  {
    return QMI_ERR_NO_MEMORY;
  }

  /* Execute MMGSDI verify PIN */
  mmgsdi_status = mmgsdi_session_verify_pin(
                        session_id,
                        pin_id,
                        pin_data,
                        qmi_uimi_mmgsdi_callback,
                        (mmgsdi_client_data_type)cb_userdata_ptr );

  /* Store the PIN to encrypt it later */
  if (qmi_uim_global_ptr->silent_pin1_supported &&
      mmgsdi_status == MMGSDI_SUCCESS &&
      pin_id == MMGSDI_PIN1 &&
      pin_data.data_len > 0 && pin_data.data_len <= QMI_UIM_TLV_MAX_PIN_LEN &&
      pin_data.data_ptr != NULL &&
      !is_encrypted)
  {
    cb_userdata_ptr->data.pin_operation.pin1_length = pin_data.data_len;
    (void)memscpy(cb_userdata_ptr->data.pin_operation.pin1_value,
                  sizeof(cb_userdata_ptr->data.pin_operation.pin1_value),
                  pin_data.data_ptr,
                  pin_data.data_len);
  }

  /* Free userdata in case of error */
  QMI_UIM_FREE_USERDATA_IF_ERROR(mmgsdi_status, cb_userdata_ptr);

  /* Convert MMGSDI status in QMI code */
  errval = qmi_uim_convert_mmgsdi_status_to_errval(mmgsdi_status);

  return errval;
} /* qmi_uim_execute_verify_pin */


/*===========================================================================
  FUNCTION QMI_UIM_EXECUTE_UNBLOCK_PIN()

  DESCRIPTION
    Unblocks the PIN

  PARAMETERS
    session_id   : session id
    pin_id       : PIN id
    puk_data     : PUK value
    pin_data     : new PIN value
    cmd_buf_ptr  : userdata
    clid         : client id of the control point

  RETURN VALUE
    errval       : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_execute_unblock_pin
(
  mmgsdi_session_id_type  session_id,
  mmgsdi_pin_enum_type    pin_id,
  mmgsdi_data_type        puk_data,
  mmgsdi_data_type        pin_data,
  const uint32          * token_ptr,
  void *                  cmd_buf_ptr,
  uint8                   clid
)
{
  qmi_error_e_type          errval          = QMI_ERR_NONE;
  mmgsdi_return_enum_type   mmgsdi_status   = MMGSDI_SUCCESS;
  qmi_uimi_userdata_type*   cb_userdata_ptr = NULL;

  ASSERT(qmi_uim_global_ptr != NULL);

  /* Create userdata */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_UNBLOCK_PIN,
                                            cmd_buf_ptr,
                                            token_ptr,
                                            clid);
  if (cb_userdata_ptr == NULL)
  {
    return QMI_ERR_NO_MEMORY;
  }

  /* Execute MMGSDI unblock PIN */
  mmgsdi_status = mmgsdi_session_unblock_pin(
                        session_id,
                        pin_id,
                        puk_data,
                        pin_data,
                        qmi_uimi_mmgsdi_callback,
                        (mmgsdi_client_data_type)cb_userdata_ptr );

  /* Store the PIN to encrypt it later */
  if (qmi_uim_global_ptr->silent_pin1_supported &&
      mmgsdi_status == MMGSDI_SUCCESS &&
      pin_id == MMGSDI_PIN1 &&
      pin_data.data_len > 0 && pin_data.data_len <= QMI_UIM_TLV_MAX_PIN_LEN &&
      pin_data.data_ptr != NULL)
  {
    cb_userdata_ptr->data.pin_operation.pin1_length = pin_data.data_len;
    (void)memscpy(cb_userdata_ptr->data.pin_operation.pin1_value,
                  sizeof(cb_userdata_ptr->data.pin_operation.pin1_value),
           pin_data.data_ptr,
           pin_data.data_len);
  }

  /* Free userdata in case of error */
  QMI_UIM_FREE_USERDATA_IF_ERROR(mmgsdi_status, cb_userdata_ptr);

  /* Convert MMGSDI status in QMI code */
  errval = qmi_uim_convert_mmgsdi_status_to_errval(mmgsdi_status);

  return errval;
} /* qmi_uim_execute_unblock_pin */


/*===========================================================================
  FUNCTION QMI_UIM_EXECUTE_CHANGE_PIN()

  DESCRIPTION
    Changes the PIN

  PARAMETERS
    session_id   : session id
    pin_id       : PIN id
    old_pin_data : old PIN value
    new_pin_data : new PIN value
    cmd_buf_ptr  : userdata
    clid         : client id of the control point

  RETURN VALUE
    errval       : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_execute_change_pin
(
  mmgsdi_session_id_type  session_id,
  mmgsdi_pin_enum_type    pin_id,
  mmgsdi_data_type        old_pin_data,
  mmgsdi_data_type        new_pin_data,
  const uint32          * token_ptr,
  void *                  cmd_buf_ptr,
  uint8                   clid
)
{
  qmi_error_e_type          errval          = QMI_ERR_NONE;
  mmgsdi_return_enum_type   mmgsdi_status   = MMGSDI_SUCCESS;
  qmi_uimi_userdata_type*   cb_userdata_ptr = NULL;

  ASSERT(qmi_uim_global_ptr != NULL);

  /* Create userdata */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_CHANGE_PIN,
                                            cmd_buf_ptr,
                                            token_ptr,
                                            clid);
  if (cb_userdata_ptr == NULL)
  {
    return QMI_ERR_NO_MEMORY;
  }

  /* Execute MMGSDI change PIN */
  mmgsdi_status = mmgsdi_session_change_pin(
                        session_id,
                        pin_id,
                        old_pin_data,
                        new_pin_data,
                        qmi_uimi_mmgsdi_callback,
                        (mmgsdi_client_data_type)cb_userdata_ptr );

  /* Store the PIN to encrypt it later */
  if (qmi_uim_global_ptr->silent_pin1_supported &&
      mmgsdi_status == MMGSDI_SUCCESS &&
      pin_id == MMGSDI_PIN1 &&
      new_pin_data.data_len > 0 && new_pin_data.data_len <= QMI_UIM_TLV_MAX_PIN_LEN &&
      new_pin_data.data_ptr != NULL)
  {
    cb_userdata_ptr->data.pin_operation.pin1_length = new_pin_data.data_len;
    (void)memscpy(cb_userdata_ptr->data.pin_operation.pin1_value,
                  sizeof(cb_userdata_ptr->data.pin_operation.pin1_value),
           new_pin_data.data_ptr,
           new_pin_data.data_len);
  }

  /* Free userdata in case of error */
  QMI_UIM_FREE_USERDATA_IF_ERROR(mmgsdi_status, cb_userdata_ptr);

  /* Convert MMGSDI status in QMI code */
  errval = qmi_uim_convert_mmgsdi_status_to_errval(mmgsdi_status);

  return errval;
} /* qmi_uim_execute_change_pin */


/*===========================================================================
  FUNCTION QMI_UIM_EXECUTE_AUTHENTICATE()

  DESCRIPTION
    Executes the authentication algorithm on the card

  PARAMETERS
    session_id      : session id
    auth_context    : authentication context
    authenticate    : data for authenticate command
    cmd_buf_ptr     : userdata
    clid            : client id of the control point

  RETURN VALUE
    errval      : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_execute_authenticate
(
  mmgsdi_session_id_type    session_id,
  qmi_uim_auth_context_type auth_context,
  mmgsdi_data_type          authenticate_data,
  const uint32            * token_ptr,
  void *                    cmd_buf_ptr,
  uint8                     clid
)
{
  qmi_error_e_type                   errval          = QMI_ERR_NONE;
  mmgsdi_return_enum_type            mmgsdi_status   = MMGSDI_SUCCESS;
  qmi_uimi_userdata_type*            cb_userdata_ptr = NULL;
  mmgsdi_session_type_enum_type      session_type    = MMGSDI_MAX_SESSION_TYPE_ENUM;
  qmi_error_e_type                   result          = QMI_ERR_INTERNAL;
  mmgsdi_static_data_type            aid;

  memset(&aid, 0, sizeof(mmgsdi_static_data_type));

  /* Get session type from Session Id*/
  result = qmi_uim_session_id_to_session_type(&session_type, &aid, session_id);
  if(result != QMI_ERR_NONE)
  {
    UIM_MSG_ERR_0("Error converting session id into session type");
    return result;
  }

  /* Create userdata */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_AUTHENTICATE,
                                            cmd_buf_ptr,
                                            token_ptr,
                                            clid);
  if (cb_userdata_ptr == NULL)
  {
    return QMI_ERR_NO_MEMORY;
  }

  /* Update the context */
  cb_userdata_ptr->data.authenticate.auth_context = auth_context;

  /* Execute MMGSDI authenticate */
  switch(auth_context)
  {
    case QMI_UIM_AUTH_CONTEXT_RUN_GSM_ALGO:
      mmgsdi_status = mmgsdi_session_run_gsm_algo(
                        session_id,
                        authenticate_data,
                        qmi_uimi_mmgsdi_callback,
                        (mmgsdi_client_data_type)cb_userdata_ptr );
      break;

    case QMI_UIM_AUTH_CONTEXT_RUN_CAVE_ALGO:
      if(authenticate_data.data_len == QMI_UIM_CAVE_AUTH_DATA_LEN &&
         authenticate_data.data_ptr != NULL)
      {
        mmgsdi_cave_rand_type_type         rand_type       = 0;
        mmgsdi_cave_rand_chal_type         rand_chal       = 0;
        mmgsdi_cave_dig_len_type           dig_len         = 0;
        mmgsdi_cave_digits_type            digits          = {0};
        mmgsdi_cave_process_control_type   process_control = 0;
        mmgsdi_cave_esn_type               esn             = {0};

        /* Parse parameters for CAVE algorithm as per 3GPP2 C.S0023-C Section 4 */
        rand_type = (mmgsdi_cave_rand_type_type)authenticate_data.data_ptr[0];
        rand_chal = (mmgsdi_cave_rand_chal_type)((uint32)rand_chal |
                                                 authenticate_data.data_ptr[1]);
        rand_chal = (mmgsdi_cave_rand_chal_type)((uint32)rand_chal << 8);
        rand_chal = (mmgsdi_cave_rand_chal_type)((uint32)rand_chal |
                                                 authenticate_data.data_ptr[2]);
        rand_chal = (mmgsdi_cave_rand_chal_type)((uint32)rand_chal << 8);
        rand_chal = (mmgsdi_cave_rand_chal_type)((uint32)rand_chal |
                                                 authenticate_data.data_ptr[3]);
        rand_chal = (mmgsdi_cave_rand_chal_type)((uint32)rand_chal << 8);
        rand_chal = (mmgsdi_cave_rand_chal_type)((uint32)rand_chal |
                                                 authenticate_data.data_ptr[4]);

        dig_len   = (mmgsdi_cave_dig_len_type)authenticate_data.data_ptr[5];
        digits[0] = authenticate_data.data_ptr[6];
        digits[1] = authenticate_data.data_ptr[7];
        digits[2] = authenticate_data.data_ptr[8];

        process_control = (mmgsdi_cave_process_control_type)authenticate_data.data_ptr[9];

        esn[0] = esn[0] | authenticate_data.data_ptr[10];
        esn[0] = esn[0] << 8;
        esn[0] = esn[0] | authenticate_data.data_ptr[11];
        esn[0] = esn[0] << 8;
        esn[0] = esn[0] | authenticate_data.data_ptr[12];
        esn[1] = esn[1] | authenticate_data.data_ptr[13];
        esn[1] = esn[1] << 8;
        esn[1] = esn[1] | authenticate_data.data_ptr[14];
        esn[1] = esn[1] << 8;
        esn[1] = esn[1] | authenticate_data.data_ptr[15];
        esn[1] = esn[1] << 8;
        esn[1] = esn[1] | authenticate_data.data_ptr[16];

        mmgsdi_status = mmgsdi_session_run_cave_algo(
                          session_id,
                          rand_type,
                          rand_chal,
                          dig_len,
                          digits,
                          process_control,
                          esn,
                          qmi_uimi_mmgsdi_callback,
                          (mmgsdi_client_data_type)cb_userdata_ptr );
      }
      else
      {
        UIM_MSG_ERR_1("Incorrect auth_data len : 0x%x",
                      authenticate_data.data_len);
        mmgsdi_status = MMGSDI_INCORRECT_PARAMS;
      }
      break;

    case QMI_UIM_AUTH_CONTEXT_GSM_SECURITY:
      mmgsdi_status = mmgsdi_session_usim_authenticate(
                        session_id,
                        MMGSDI_AUTN_USIM_GSM_CONTEXT,
                        authenticate_data,
                        qmi_uimi_mmgsdi_callback,
                        (mmgsdi_client_data_type)cb_userdata_ptr );
      break;

    case QMI_UIM_AUTH_CONTEXT_3G_SECURITY:
      mmgsdi_status = mmgsdi_session_usim_authenticate(
                        session_id,
                        MMGSDI_AUTN_USIM_3G_CONTEXT,
                        authenticate_data,
                        qmi_uimi_mmgsdi_callback,
                        (mmgsdi_client_data_type)cb_userdata_ptr );
      break;

    case QMI_UIM_AUTH_CONTEXT_IMS_AKA_SECURITY:
      mmgsdi_status = mmgsdi_session_isim_authenticate(
                        session_id,
                        authenticate_data,
                        qmi_uimi_mmgsdi_callback,
                        (mmgsdi_client_data_type)cb_userdata_ptr );
      break;

    case QMI_UIM_AUTH_CONTEXT_GBA_BOOTSTRAPPING_SECURITY:
      if(session_type == MMGSDI_GW_PROV_PRI_SESSION ||
         session_type == MMGSDI_GW_PROV_SEC_SESSION ||
         session_type == MMGSDI_GW_PROV_TER_SESSION ||
         qmi_uim_is_usim_aid(&aid, FALSE))
      {
        mmgsdi_status = mmgsdi_session_uicc_authenticate(
                          session_id,
                          MMGSDI_AUTN_USIM_GBA_BOOTSTRAPPING_CONTEXT,
                          authenticate_data,
                          qmi_uimi_mmgsdi_callback,
                          (mmgsdi_client_data_type)cb_userdata_ptr );
      }
      else if(qmi_uim_is_isim_aid(&aid))
      {
        mmgsdi_status = mmgsdi_session_uicc_authenticate(
                          session_id,
                          MMGSDI_AUTN_ISIM_GBA_BOOTSTRAPPING_CONTEXT,
                          authenticate_data,
                          qmi_uimi_mmgsdi_callback,
                          (mmgsdi_client_data_type)cb_userdata_ptr );
      }
      else
      {
        mmgsdi_status = MMGSDI_ERROR;
      }
      break;

    case QMI_UIM_AUTH_CONTEXT_GBA_NAF_DERIVATION_SECURITY:
      if(session_type == MMGSDI_GW_PROV_PRI_SESSION ||
         session_type == MMGSDI_GW_PROV_SEC_SESSION ||
         session_type == MMGSDI_GW_PROV_TER_SESSION ||
         qmi_uim_is_usim_aid(&aid, FALSE))
      {
        mmgsdi_status = mmgsdi_session_uicc_authenticate(
                          session_id,
                          MMGSDI_AUTN_USIM_GBA_NAF_DERIVATION_CONTEXT,
                          authenticate_data,
                          qmi_uimi_mmgsdi_callback,
                          (mmgsdi_client_data_type)cb_userdata_ptr );
      }
      else if(qmi_uim_is_isim_aid(&aid))
      {
        mmgsdi_status = mmgsdi_session_uicc_authenticate(
                          session_id,
                          MMGSDI_AUTN_ISIM_GBA_NAF_DERIVATION_CONTEXT,
                          authenticate_data,
                          qmi_uimi_mmgsdi_callback,
                          (mmgsdi_client_data_type)cb_userdata_ptr );
      }
      else
      {
        mmgsdi_status = MMGSDI_ERROR;
      }
      break;

    case QMI_UIM_AUTH_CONTEXT_COMPUTE_IP_CHAP:
      if(authenticate_data.data_len > 2 &&
         authenticate_data.data_len <= MMGSDI_MAX_3GPD_CHAP_CHALLENGE_LENGTH + 2 &&
         authenticate_data.data_ptr != NULL)
      {
        mmgsdi_compute_ip_data_type compute_ip_data;
        memset(&compute_ip_data, 0, sizeof(mmgsdi_compute_ip_data_type));

        /* Parse parameters as per 3GPP2 C.S0023-D Section 4.8.1 */
        compute_ip_data.operation_type = MMGSDI_CMPT_IP_SIP_CHAP;
        compute_ip_data.data.sip_chap_data.chap_id =
          authenticate_data.data_ptr[0];
        compute_ip_data.data.sip_chap_data.nai_entry_index =
          authenticate_data.data_ptr[1];
        compute_ip_data.data.sip_chap_data.chap_challenge_length =
          (mmgsdi_len_type)(authenticate_data.data_len - 2);
        (void)memscpy(compute_ip_data.data.sip_chap_data.chap_challenge,
                      sizeof(compute_ip_data.data.sip_chap_data.chap_challenge),
               &authenticate_data.data_ptr[2],
               authenticate_data.data_len - 2);

        mmgsdi_status = mmgsdi_session_compute_ip_auth(
                          session_id,
                          compute_ip_data,
                          qmi_uimi_mmgsdi_callback,
                          (mmgsdi_client_data_type)cb_userdata_ptr );
      }
      else
      {
        UIM_MSG_ERR_1("Incorrect auth_data len : 0x%x",
                      authenticate_data.data_len);
        mmgsdi_status = MMGSDI_INCORRECT_PARAMS;
      }
      break;

    case QMI_UIM_AUTH_CONTEXT_COMPUTE_IP_MN_HA:
      if(authenticate_data.data_len > 1 &&
         authenticate_data.data_len <= MMGSDI_MAX_3GPD_MN_HA_REG_DATA_LENGTH + 1 &&
         authenticate_data.data_ptr != NULL)
      {
        mmgsdi_compute_ip_data_type compute_ip_data;
        memset(&compute_ip_data, 0, sizeof(mmgsdi_compute_ip_data_type));

        /* Parse parameters as per 3GPP2 C.S0023-D Section 4.8.1 */
        compute_ip_data.operation_type = MMGSDI_CMPT_IP_MIP_MN_HA;
        compute_ip_data.data.mn_ha_data.nai_entry_index =
          authenticate_data.data_ptr[0];
        compute_ip_data.data.mn_ha_data.registration_data_length =
          (mmgsdi_len_type)(authenticate_data.data_len - 1);
        compute_ip_data.data.mn_ha_data.registration_data_ptr =
          &authenticate_data.data_ptr[1];

        mmgsdi_status = mmgsdi_session_compute_ip_auth(
                          session_id,
                          compute_ip_data,
                          qmi_uimi_mmgsdi_callback,
                          (mmgsdi_client_data_type)cb_userdata_ptr );
      }
      else
      {
        UIM_MSG_ERR_1("Incorrect auth_data len : 0x%x",
                      authenticate_data.data_len);
        mmgsdi_status = MMGSDI_INCORRECT_PARAMS;
      }
      break;

    case QMI_UIM_AUTH_CONTEXT_COMPUTE_IP_MIP_RRQ:
      if(authenticate_data.data_len > 0 &&
         authenticate_data.data_len <= MMGSDI_MAX_3GPD_HASH_RRQ_DATA_LENGTH &&
         authenticate_data.data_ptr != NULL)
      {
        mmgsdi_compute_ip_data_type compute_ip_data;
        memset(&compute_ip_data, 0, sizeof(mmgsdi_compute_ip_data_type));

        /* Parse parameters as per 3GPP2 C.S0023-D Section 4.8.1 */
        compute_ip_data.operation_type = MMGSDI_CMPT_IP_MIP_RRQ;
        compute_ip_data.data.rrq_data.rrq_data_length =
          (mmgsdi_len_type)authenticate_data.data_len;
        compute_ip_data.data.rrq_data.rrq_data_ptr =
          &authenticate_data.data_ptr[0];

        mmgsdi_status = mmgsdi_session_compute_ip_auth(
                          session_id,
                          compute_ip_data,
                          qmi_uimi_mmgsdi_callback,
                          (mmgsdi_client_data_type)cb_userdata_ptr );
      }
      else
      {
        UIM_MSG_ERR_1("Incorrect auth_data len : 0x%x",
                      authenticate_data.data_len);
        mmgsdi_status = MMGSDI_INCORRECT_PARAMS;
      }
      break;

    case QMI_UIM_AUTH_CONTEXT_COMPUTE_IP_MN_AAA:
      if(authenticate_data.data_len > 1 &&
         authenticate_data.data_len <= MMGSDI_3GPD_MAX_MIP_CHALLENGE_LENGTH + 1 &&
         authenticate_data.data_ptr != NULL)
      {
        mmgsdi_compute_ip_data_type compute_ip_data;
        memset(&compute_ip_data, 0, sizeof(mmgsdi_compute_ip_data_type));

        /* Parse parameters as per 3GPP2 C.S0023-D Section 4.8.1 */
        compute_ip_data.operation_type = MMGSDI_CMPT_IP_MIP_MN_AAA;
        compute_ip_data.data.mn_aaa_data.nai_entry_index =
          authenticate_data.data_ptr[0];
        compute_ip_data.data.mn_aaa_data.challenge_length =
          (mmgsdi_len_type)(authenticate_data.data_len - 1);
        compute_ip_data.data.mn_aaa_data.challenge_ptr =
          &authenticate_data.data_ptr[1];

        mmgsdi_status = mmgsdi_session_compute_ip_auth(
                          session_id,
                          compute_ip_data,
                          qmi_uimi_mmgsdi_callback,
                          (mmgsdi_client_data_type)cb_userdata_ptr );
      }
      else
      {
        UIM_MSG_ERR_1("Incorrect auth_data len : 0x%x",
                      authenticate_data.data_len);
        mmgsdi_status = MMGSDI_INCORRECT_PARAMS;
      }
      break;

    case QMI_UIM_AUTH_CONTEXT_COMPUTE_IP_HRPD_ACCESS:
      if(authenticate_data.data_len > 1 &&
         authenticate_data.data_len <= MMGSDI_MAX_HRPD_CHAP_CHALLENGE_LENGTH + 1 &&
         authenticate_data.data_ptr != NULL)
      {
        mmgsdi_compute_ip_data_type compute_ip_data;
        memset(&compute_ip_data, 0, sizeof(mmgsdi_compute_ip_data_type));

        /* Parse parameters as per 3GPP2 C.S0023-D Section 4.8.1 */
        compute_ip_data.operation_type = MMGSDI_CMPT_IP_HRPD_CHAP;
        compute_ip_data.data.hrpd_chap_data.chap_id = authenticate_data.data_ptr[0];
        compute_ip_data.data.hrpd_chap_data.chap_challenge_length =
          (mmgsdi_len_type)(authenticate_data.data_len - 1);
        compute_ip_data.data.hrpd_chap_data.chap_challenge_ptr =
          &authenticate_data.data_ptr[1];

        mmgsdi_status = mmgsdi_session_compute_ip_auth(
                          session_id,
                          compute_ip_data,
                          qmi_uimi_mmgsdi_callback,
                          (mmgsdi_client_data_type)cb_userdata_ptr );
      }
      else
      {
        UIM_MSG_ERR_1("Incorrect auth_data len : 0x%x",
                      authenticate_data.data_len);
        mmgsdi_status = MMGSDI_INCORRECT_PARAMS;
      }
      break;

    case QMI_UIM_AUTH_CONTEXT_HTTP_DIGEST_SECURITY:
      mmgsdi_status = mmgsdi_session_uicc_authenticate(
                          session_id,
                          MMGSDI_AUTN_ISIM_HTTP_DIGEST_CONTEXT,
                          authenticate_data,
                          qmi_uimi_mmgsdi_callback,
                          (mmgsdi_client_data_type)cb_userdata_ptr );
      break;

    default:
      UIM_MSG_ERR_1("Unsupported security context: 0x%x", auth_context);
      mmgsdi_status = MMGSDI_NOT_SUPPORTED;
  }

  /* Free userdata in case of error */
  QMI_UIM_FREE_USERDATA_IF_ERROR(mmgsdi_status, cb_userdata_ptr);

  /* Convert MMGSDI status in QMI code */
  errval = qmi_uim_convert_mmgsdi_status_to_errval(mmgsdi_status);

  return errval;
} /* qmi_uim_execute_authenticate */


/*===========================================================================
  FUNCTION QMI_UIM_EXECUTE_REFRESH_REGISTER()

  DESCRIPTION
    Registers for refresh

  PARAMETERS
    session_id        : session id
    register_op       : registration or deregistration operation
    vote_for_init     : vote for init
    list_of_files_ptr : list of files
    cmd_buf_ptr       : userdata

  RETURN VALUE
    errval       : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_execute_refresh_register
(
  mmgsdi_session_id_type       session_id,
  boolean                      register_op,
  boolean                      vote_for_init,
  qmi_uim_files_list_type *    list_of_files_ptr,
  qmi_cmd_buf_type *           cmd_buf_ptr
)
{
  uint16                         refresh_index     = 0;
  uint32                         notify_mask       = 0;
  mmgsdi_return_enum_type        mmgsdi_status     = MMGSDI_SUCCESS;
  qmi_uimi_client_state_type *   client_sp         = NULL;
  qmi_error_e_type               errval            = QMI_ERR_NONE;
  mmgsdi_refresh_file_list_type  register_list     = { 0, NULL, NULL, 0};
  mmgsdi_refresh_file_list_type  deregister_list   = { 0, NULL, NULL, 0};

  /* Validate the command buffer to make sure the client is still there */
  ASSERT(cmd_buf_ptr);
  if (cmd_buf_ptr->x_p == NULL || cmd_buf_ptr->x_p->cl_sp == NULL)
  {
    UIM_MSG_HIGH_0("Transaction ptr or client state pointer is NULL");
    return QMI_ERR_INTERNAL;
  }

  /* Extract client sp */
  client_sp = (qmi_uimi_client_state_type *) cmd_buf_ptr->x_p->cl_sp;

  /* In case of deregistration from events, set forcely vote_for_init to
     FALSE and number of files to 0 and continue normally. In this way,
     files will be removed from MMGSDI */
  if (register_op == FALSE)
  {
    vote_for_init = FALSE;
    list_of_files_ptr = NULL;
  }

  /* Calculate the refresh index */
  errval = qmi_uim_session_id_to_refresh_index(&refresh_index, session_id);
  if (errval != QMI_ERR_NONE)
  {
    UIM_MSG_ERR_1("Impossible to convert session id (0x%x) into refresh index",
                  session_id);
    goto return_result;
  }
  ASSERT(refresh_index < UIM_REFRESH_SESSION_COUNT);

  /* Calculate the refresh mask */
  notify_mask = 1 << refresh_index;

  /* Store the indication on refresh events */
  if (register_op)
  {
    client_sp->uim_info.refresh_notify_mask = (client_sp->uim_info.refresh_notify_mask | notify_mask);
  }
  else
  {
    client_sp->uim_info.refresh_notify_mask = (client_sp->uim_info.refresh_notify_mask & (~notify_mask));
  }

  /* Create list of files to deregister for refresh. This list
     is composed by the files that only this client is monitoring
     and are not in the new list */
  errval = qmi_uim_refresh_create_deregister_list(
              client_sp,
              session_id,
              list_of_files_ptr,
              &deregister_list);
  if (errval != QMI_ERR_NONE)
  {
    goto return_result;
  }

  /* Create list of files to register for refresh. This list
     is composed by the files that are in the new list and that
     no client is currently monitoring */
  errval = qmi_uim_refresh_create_register_list(
              session_id,
              list_of_files_ptr,
              &register_list);
  if (errval != QMI_ERR_NONE)
  {
    goto return_result;
  }

  /* Remove old list of files of this client for this session type */
  errval = qmi_uim_remove_client_refresh_files(
                client_sp,
                session_id);
  if (errval != QMI_ERR_NONE)
  {
    goto return_result;
  }

  /* Copy new list of files into this client */
  errval = qmi_uim_add_client_refresh_files(
              client_sp,
              session_id,
              list_of_files_ptr);
  if (errval != QMI_ERR_NONE)
  {
    goto return_result;
  }

  /* Store the vote for init flag: this is done at the end, after verifying that
     lists of files could be handled successfully. */
  client_sp->uim_info.refresh_vote = vote_for_init;

  /* Deregister for refresh. Ignore errors in this commands because if a file is
     not correctly deregistered, nothing happens. */
  if (deregister_list.file_path_len > 0 && deregister_list.file_path_ptr != NULL)
  {
    mmgsdi_status = mmgsdi_session_deregister_for_refresh(
                          session_id,
                          deregister_list,
                          FALSE,
                          qmi_uimi_mmgsdi_callback,
                          (mmgsdi_client_data_type)NULL );
    UIM_MSG_HIGH_1("Deregister for refresh: 0x%x", mmgsdi_status);
    /* Ignore the error in the deregistration.... if this fails, it is not
       critical and we can continue */
  }
  else
  {
    UIM_MSG_HIGH_0("Deregister for refresh: no file to deregister");
  }

  /* Register for refresh. Passing NULL as userdata because we're sending
     the response immediately, without waiting the callback from MMGSDI. */
  if (register_list.file_path_len > 0 && register_list.file_path_ptr != NULL)
  {
    mmgsdi_status = mmgsdi_session_register_for_refresh(
                          session_id,
                          register_list,
                          TRUE,
                          qmi_uimi_mmgsdi_callback,
                          (mmgsdi_client_data_type)NULL );
  }
  else if (register_op)
  {
    /* We still need to register for refresh in order to receive INIT events
       if incoming req is for registration. Pass ICCID as a fake file. */
    uint8                          file_iccid[]       = { 0x3F, 0x00, 0x2F, 0xE2 };
    mmgsdi_refresh_file_list_type  fake_register_list = { 0, NULL, NULL, 0};

    fake_register_list.file_path_len = sizeof(file_iccid);
    fake_register_list.file_path_ptr = file_iccid;

    mmgsdi_status = mmgsdi_session_register_for_refresh(
                          session_id,
                          fake_register_list,
                          TRUE,
                          qmi_uimi_mmgsdi_callback,
                          (mmgsdi_client_data_type)NULL );
  }

  /* Convert MMGSDI status in QMI code */
  errval = qmi_uim_convert_mmgsdi_status_to_errval(mmgsdi_status);

return_result:
  /* Free allocated memory */
  if (register_list.file_path_ptr)
  {
    uimqmi_free(register_list.file_path_ptr);
    register_list.file_path_ptr = NULL;
  }
  if (deregister_list.file_path_ptr)
  {
    uimqmi_free(deregister_list.file_path_ptr);
    deregister_list.file_path_ptr = NULL;
  }

  return errval;
} /* qmi_uim_execute_refresh_register */


/*===========================================================================
  FUNCTION QMI_UIM_EXECUTE_GET_STATUS_FDN()

  DESCRIPTION
    Gets the fdn status

  PARAMETERS
    session_type        : session type
    cmd_buf_ptr         : userdata
    clid                : client id of the control point

  RETURN VALUE
    errval      : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_execute_get_status_fdn
(
  mmgsdi_session_type_enum_type  session_type,
  void *                         cmd_buf_ptr,
  uint8                          clid
)
{
  qmi_error_e_type            errval           = QMI_ERR_NONE;
  mmgsdi_session_id_type      session_id       = UIM_INVALID_SESSION_ID;
  mmgsdi_return_enum_type     mmgsdi_status    = MMGSDI_SUCCESS;
  mmgsdi_app_enum_type        card_type        = MMGSDI_APP_NONE;
  mmgsdi_service_enum_type    service_id       = MMGSDI_NONE;
  qmi_uimi_userdata_type   *  cb_userdata_ptr  = NULL;
  mmgsdi_static_data_type     aid;

  memset(&aid, 0, sizeof(mmgsdi_static_data_type));

  /* Only provisioning sessions are supported */
  if (session_type != MMGSDI_GW_PROV_PRI_SESSION &&
      session_type != MMGSDI_1X_PROV_PRI_SESSION &&
      session_type != MMGSDI_GW_PROV_SEC_SESSION &&
      session_type != MMGSDI_1X_PROV_SEC_SESSION &&
      session_type != MMGSDI_GW_PROV_TER_SESSION &&
      session_type != MMGSDI_1X_PROV_TER_SESSION)
  {
    UIM_MSG_ERR_1("Impossible to get service status for a non provisioning session: 0x%x",
                  session_type);
    return QMI_ERR_INTERNAL;
  }

  /* Retrieve session id */
  errval = qmi_uim_session_type_to_session_id(&session_id,
                                              session_type,
                                              aid);
  if (errval != QMI_ERR_NONE)
  {
    return errval;
  }

  /* Retrieve card type */
  errval = qmi_uim_session_type_to_card_type(
                           &card_type,
                           session_type,
                           aid);
  if (errval != QMI_ERR_NONE)
  {
    return errval;
  }

  /* Calculate service id */
  switch(card_type)
  {
    case MMGSDI_APP_SIM:
      service_id = MMGSDI_GSM_SRV_FDN;
      break;
    case MMGSDI_APP_RUIM:
      service_id = MMGSDI_CDMA_SRV_FDN;
      break;
    case MMGSDI_APP_USIM:
      service_id = MMGSDI_USIM_SRV_FDN;
      break;
    case MMGSDI_APP_CSIM:
      service_id = MMGSDI_CSIM_SRV_FDN;
      break;
    default:
      UIM_MSG_ERR_1("Unsupported card type: 0x%x", card_type);
      return QMI_ERR_INTERNAL;
  }

  /* Create userdata */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_GET_SERVICE_STATUS,
                                            cmd_buf_ptr,
                                            NULL,
                                            clid);
  if (cb_userdata_ptr == NULL)
  {
    return QMI_ERR_NO_MEMORY;
  }

  cb_userdata_ptr->data.get_service_status.service_id = service_id;

  /* Get service status from MMGSDI */
  mmgsdi_status = mmgsdi_session_is_service_available(
                                session_id,
                                service_id,
                                qmi_uimi_mmgsdi_callback,
                                (mmgsdi_client_data_type)cb_userdata_ptr);

  /* Free userdata in case of error */
  QMI_UIM_FREE_USERDATA_IF_ERROR(mmgsdi_status, cb_userdata_ptr);

  /* Convert MMGSDI status in QMI code */
  errval = qmi_uim_convert_mmgsdi_status_to_errval(mmgsdi_status);

  return errval;
} /* qmi_uim_execute_get_status_fdn */


/*===========================================================================
  FUNCTION QMI_UIM_EXECUTE_GET_STATUS_HIDDEN_KEY_AND_INDEX()

  DESCRIPTION
    Gets the fdn status

  PARAMETERS
    hidden_key          : hidden key is required
    index_in_dir        : index in dir is required
    session_type        : session type
    cmd_buf_ptr         : userdata
    clid                : client id of the control point

  RETURN VALUE
    errval      : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_execute_get_status_hidden_key_and_index
(
  boolean                        hidden_key,
  boolean                        index_in_dir,
  mmgsdi_session_type_enum_type  session_type,
  void *                         cmd_buf_ptr,
  uint8                          clid
)
{
  qmi_error_e_type            errval           = QMI_ERR_NONE;
  mmgsdi_session_id_type      session_id       = UIM_INVALID_SESSION_ID;
  mmgsdi_return_enum_type     mmgsdi_status    = MMGSDI_SUCCESS;
  qmi_uimi_userdata_type   *  cb_userdata_ptr  = NULL;
  mmgsdi_static_data_type     aid;

  memset(&aid, 0, sizeof(mmgsdi_static_data_type));

  /* Verify that at least one parameter is requested */
  if (hidden_key == FALSE && index_in_dir == FALSE)
  {
    return QMI_ERR_INTERNAL;
  }

  /* Only provisioning sessions are supported */
  if (session_type != MMGSDI_GW_PROV_PRI_SESSION &&
      session_type != MMGSDI_1X_PROV_PRI_SESSION &&
      session_type != MMGSDI_GW_PROV_SEC_SESSION &&
      session_type != MMGSDI_1X_PROV_SEC_SESSION &&
      session_type != MMGSDI_GW_PROV_TER_SESSION &&
      session_type != MMGSDI_1X_PROV_TER_SESSION)
  {
    UIM_MSG_ERR_1("Impossible to get hidden key for a non provisioning session: 0x%x",
                  session_type);
    return QMI_ERR_INTERNAL;
  }

  /* Retrieve session id */
  errval = qmi_uim_session_type_to_session_id(&session_id,
                                              session_type,
                                              aid);
  if (errval != QMI_ERR_NONE)
  {
    return errval;
  }

  /* Create userdata */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_GET_SERVICE_STATUS,
                                            cmd_buf_ptr,
                                            NULL,
                                            clid);
  if (cb_userdata_ptr == NULL)
  {
    return QMI_ERR_NO_MEMORY;
  }

  /* Set values in userdata */
  cb_userdata_ptr->data.get_service_status.hidden_key   = hidden_key;
  cb_userdata_ptr->data.get_service_status.index_in_dir = index_in_dir;

  /* Get service status from MMGSDI */
  mmgsdi_status = mmgsdi_session_get_all_pin_status(
                                session_id,
                                qmi_uimi_mmgsdi_callback,
                                (mmgsdi_client_data_type)cb_userdata_ptr);

  /* Free userdata in case of error */
  QMI_UIM_FREE_USERDATA_IF_ERROR(mmgsdi_status, cb_userdata_ptr);

  /* Convert MMGSDI status in QMI code */
  errval = qmi_uim_convert_mmgsdi_status_to_errval(mmgsdi_status);

  return errval;
} /* qmi_uim_execute_get_status_hidden_key_and_index */


/*===========================================================================
  FUNCTION QMI_UIM_EXECUTE_GET_STATUS_ESN()

  DESCRIPTION
    Gets the ESN status

  PARAMETERS
    session_type        : session type
    esn_status_ptr      : Output parameter with ESN status

  RETURN VALUE
    errval      : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_execute_get_status_esn
(
  mmgsdi_session_type_enum_type  session_type,
  mmgsdi_esn_me_change_enum_type *esn_status_ptr
)
{
  qmi_error_e_type                   errval       = QMI_ERR_NONE;
  mmgsdi_session_id_type             session_id   = UIM_INVALID_SESSION_ID;
  mmgsdi_esn_me_change_enum_type     esn_status   = MMGSDI_ESN_ME_NO_CHANGE;
  mmgsdi_slot_id_enum_type           slot         = MMGSDI_SLOT_1;
  mmgsdi_static_data_type            aid;

  memset(&aid, 0, sizeof(mmgsdi_static_data_type));

  /* Only 1x provisioning sessions are supported */
  if ((session_type != MMGSDI_1X_PROV_PRI_SESSION) &&
      (session_type != MMGSDI_1X_PROV_SEC_SESSION))
  {
    UIM_MSG_ERR_1("ESN status request is invalid for non-1x provisioning"
                  " session: 0x%x", session_type);
    return QMI_ERR_INTERNAL;
  }

  /* Retrieve session id */
  errval = qmi_uim_session_type_to_session_id(&session_id,
                                              session_type,
                                              aid);
  if (errval != QMI_ERR_NONE)
  {
    return errval;
  }

  /* Retrieve the slot */
  errval = qmi_uim_session_id_to_slot(&slot, session_id);
  if (errval != QMI_ERR_NONE)
  {
    return errval;
  }

  /* Get ESN status from MMGSDI */
  esn_status = mmgsdi_get_esn_me_change_flag(slot);
  if (esn_status == MMGSDI_ESN_ME_CHANGE_NOT_SUPPORTED ||
      esn_status == MMGSDI_ESN_ME_UNKNOWN)
  {
    return QMI_ERR_INTERNAL;
  }
  else
  {
    *esn_status_ptr = esn_status;
  }

  return QMI_ERR_NONE;
} /* qmi_uim_execute_get_status_esn */


/*===========================================================================
  FUNCTION QMI_UIM_EXECUTE_GET_STATUS_ACL()

  DESCRIPTION
    Gets the ACL status

  PARAMETERS
    session_type        : session type
    cmd_buf_ptr         : userdata
    clid                : client id of the control point

  RETURN VALUE
    errval      : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_execute_get_status_acl
(
  mmgsdi_session_type_enum_type  session_type,
  void *                         cmd_buf_ptr,
  uint8                          clid
)
{
  qmi_error_e_type            errval           = QMI_ERR_NONE;
  mmgsdi_session_id_type      session_id       = UIM_INVALID_SESSION_ID;
  mmgsdi_return_enum_type     mmgsdi_status    = MMGSDI_SUCCESS;
  mmgsdi_app_enum_type        card_type        = MMGSDI_APP_NONE;
  mmgsdi_service_enum_type    service_id       = MMGSDI_NONE;
  qmi_uimi_userdata_type   *  cb_userdata_ptr  = NULL;
  mmgsdi_static_data_type     aid;

  memset(&aid, 0, sizeof(mmgsdi_static_data_type));

  /* Only provisioning sessions are supported */
  if (session_type != MMGSDI_GW_PROV_PRI_SESSION &&
      session_type != MMGSDI_1X_PROV_PRI_SESSION &&
      session_type != MMGSDI_GW_PROV_SEC_SESSION &&
      session_type != MMGSDI_1X_PROV_SEC_SESSION &&
      session_type != MMGSDI_GW_PROV_TER_SESSION &&
      session_type != MMGSDI_1X_PROV_TER_SESSION )
  {
    UIM_MSG_ERR_1("Impossible to get service status for a non provisioning session: 0x%x",
                  session_type);
    return QMI_ERR_INTERNAL;
  }

  /* Retrieve session id */
  errval = qmi_uim_session_type_to_session_id(&session_id,
                                              session_type,
                                              aid);
  if (errval != QMI_ERR_NONE)
  {
    return errval;
  }

  /* Retrieve card type */
  errval = qmi_uim_session_type_to_card_type(
                           &card_type,
                           session_type,
                           aid);
  if (errval != QMI_ERR_NONE)
  {
    return errval;
  }

  /* Calculate service id */
  switch(card_type)
  {
    case MMGSDI_APP_USIM:
      service_id = MMGSDI_USIM_SRV_ACL;
      break;
    default:
      UIM_MSG_ERR_1("Unsupported card type: 0x%x", card_type);
      return QMI_ERR_INTERNAL;
  }

  /* Create userdata */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_GET_SERVICE_STATUS,
                                            cmd_buf_ptr,
                                            NULL,
                                            clid);
  if (cb_userdata_ptr == NULL)
  {
    return QMI_ERR_NO_MEMORY;
  }

  cb_userdata_ptr->data.get_service_status.service_id = service_id;

  /* Get service status from MMGSDI */
  mmgsdi_status = mmgsdi_session_is_service_available(
                                session_id,
                                service_id,
                                qmi_uimi_mmgsdi_callback,
                                (mmgsdi_client_data_type)cb_userdata_ptr);

  /* Free userdata in case of error */
  QMI_UIM_FREE_USERDATA_IF_ERROR(mmgsdi_status, cb_userdata_ptr);

  /* Convert MMGSDI status in QMI code */
  errval = qmi_uim_convert_mmgsdi_status_to_errval(mmgsdi_status);

  return errval;
} /* qmi_uim_execute_get_status_acl */


/*===========================================================================
  FUNCTION QMI_UIM_EXECUTE_GET_SERVICE_STATUS()

  DESCRIPTION
    Gets the service availability status

  PARAMETERS
    session_type          : session type
    service_number        : service number per the spec
    service_available_ptr : service available or not

  RETURN VALUE
    errval      : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_execute_get_service_status
(
  mmgsdi_session_type_enum_type  session_type,
  uint8                          service_number,
  boolean                       *service_available_ptr
)
{
  qmi_error_e_type            errval           = QMI_ERR_NONE;
  mmgsdi_session_id_type      session_id       = UIM_INVALID_SESSION_ID;
  mmgsdi_return_enum_type     mmgsdi_status    = MMGSDI_SUCCESS;
  mmgsdi_app_enum_type        card_type        = MMGSDI_APP_NONE;
  mmgsdi_static_data_type     aid;
  mmgsdi_data_type            service_table_data;
  mmgsdi_file_enum_type       file_name        = MMGSDI_MAX_FILE_ENUM;

  memset(&aid, 0, sizeof(mmgsdi_static_data_type));
  memset(&service_table_data, 0, sizeof(mmgsdi_data_type));

  ASSERT(service_available_ptr);

  *service_available_ptr = FALSE;

  /* Service number must be greater than 0 */
  if(service_number == 0)
  {
    UIM_MSG_ERR_1("Invalid Service Request 0x%x", service_number);
    errval = QMI_ERR_INVALID_ARG;
    goto send_result;
  }

  /* Only provisioning sessions are supported */
  if (session_type != MMGSDI_GW_PROV_PRI_SESSION &&
      session_type != MMGSDI_1X_PROV_PRI_SESSION &&
      session_type != MMGSDI_GW_PROV_SEC_SESSION &&
      session_type != MMGSDI_1X_PROV_SEC_SESSION &&
      session_type != MMGSDI_GW_PROV_TER_SESSION &&
      session_type != MMGSDI_1X_PROV_TER_SESSION )
  {
    UIM_MSG_ERR_1("Impossible to get service status for a non provisioning session: 0x%x",
                  session_type);
    errval = QMI_ERR_INTERNAL;
    goto send_result;
  }

  /* Retrieve session id */
  errval = qmi_uim_session_type_to_session_id(&session_id,
                                              session_type,
                                              aid);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* Retrieve card type */
  errval = qmi_uim_session_type_to_card_type(
                           &card_type,
                           session_type,
                           aid);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* Calculate service id based on the MMGSDI EF service enums */
  switch(card_type)
  {
    case MMGSDI_APP_RUIM:
      file_name = MMGSDI_CDMA_SVC_TABLE;
      break;
    case MMGSDI_APP_SIM:
      file_name = MMGSDI_GSM_SST;
      break;
    case MMGSDI_APP_USIM:
      file_name = MMGSDI_USIM_UST;
      break;
    case MMGSDI_APP_CSIM:
      file_name = MMGSDI_CSIM_CST;
      break;
    default:
      UIM_MSG_ERR_1("Unsupported card type: 0x%x", card_type);
      errval = QMI_ERR_INTERNAL;
      goto send_result;
  }

  /* Execute MMGSDI cache read */
  mmgsdi_status = mmgsdi_session_read_cache_file_size(session_id,
                                                      file_name,
                                                      &service_table_data.data_len);
  /* Service table must be at least one byte long per the spec */
  if(mmgsdi_status != MMGSDI_SUCCESS || service_table_data.data_len < 1)
  {
    UIM_MSG_ERR_2("Invalid service table length. mmgsdi_status:0x%x len:0x%x",
                  mmgsdi_status, service_table_data.data_len);
    errval = QMI_ERR_INTERNAL;
    goto send_result;
  }

  service_table_data.data_ptr = uimqmi_malloc(service_table_data.data_len);
  if(service_table_data.data_ptr == NULL)
  {
    UIM_MSG_ERR_0("QMI-UIM: No memory for service table data");
    errval = QMI_ERR_NO_MEMORY;
    goto send_result;
  }

  mmgsdi_status = mmgsdi_session_read_cache(session_id,
                                            file_name,
                                            service_table_data);
  if(mmgsdi_status != MMGSDI_SUCCESS)
  {
    UIM_MSG_ERR_0("Error reading service table");
    errval = QMI_ERR_INTERNAL;
    goto send_result;
  }

  if((card_type == MMGSDI_APP_USIM ||
      card_type == MMGSDI_APP_CSIM) &&
      service_number <= service_table_data.data_len * 8)
  {
    /* We have the raw data from UICC service table. Lets check if the service number
       in question is marked as available per that raw data. for UICC, one bit is
       dedicated to each service, indicating if the service is available. As can be
       inferred from above, for ICC, each bytes contains status of 8 services hence
       the division and modulo performed by 8 below. */
    if(((service_table_data.data_ptr[(service_number - 1) / 8] >> (service_number - 1) % 8) & 0x1) == 0x1)
    {
      *service_available_ptr = TRUE;
    }
  }
  else if((card_type == MMGSDI_APP_SIM ||
           card_type == MMGSDI_APP_RUIM) &&
           service_number <= service_table_data.data_len * 4)
  {
    /* We have the raw data from ICC service table. Lets check if the service number
       in question is marked as available per that raw data. For ICC, two bits are
       dedicated to every service, one indicating if the service is available and the
       other one indicating if it is enabled. Only if both bits are set, we mark the
       service as available. As can be inferred from above, for ICC, each bytes
       contains status of 4 services hence the division and module performed by 4 below. */
    if(((service_table_data.data_ptr[(service_number - 1) / 4] >> ((service_number - 1) % 4) * 2) & 0x3) == 0x3)
    {
      *service_available_ptr = TRUE;
    }
  }

send_result:
  /* Free allocated memory */
  if (service_table_data.data_ptr)
  {
    uimqmi_free(service_table_data.data_ptr);
    service_table_data.data_ptr = NULL;
  }

  return errval;
} /* qmi_uim_execute_get_service_status */


/*===========================================================================
  FUNCTION QMI_UIM_EXECUTE_OPEN_SESSION_FOR_APDU()

  DESCRIPTION
    Open a non provisioning session to stream APDUs

  PARAMETERS
    slot                : slot id
    aid                 : AID of the application
    sel_rsp_type        : format of select response
    cmd_buf_ptr         : userdata
    select_mf           : If MF is to be selected after
                          opening the session
    clid                : client id of the control point

  RETURN VALUE
    errval      : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_execute_open_session_for_apdu
(
  mmgsdi_slot_id_enum_type     slot,
  mmgsdi_static_data_type      aid,
  mmgsdi_select_rsp_enum_type  sel_rsp_type,
  void *                       cmd_buf_ptr,
  boolean                      select_mf,
  uint8                        clid
)
{
  uint16                           i                 = 0;
  qmi_error_e_type                 errval            = QMI_ERR_NONE;
  mmgsdi_return_enum_type          mmgsdi_status     = MMGSDI_SUCCESS;
  uint16                           channel_index     = UIM_INVALID_APP_INDEX;
  qmi_uimi_userdata_type         * cb_userdata_ptr   = NULL;
  mmgsdi_app_select_with_rsp_type  app_info;

  ASSERT(qmi_uim_global_ptr != NULL);

  /* Check command buffer before dereferencing */
  if (cmd_buf_ptr == NULL || ((qmi_cmd_buf_type *)cmd_buf_ptr)->x_p == NULL)
  {
    UIM_MSG_HIGH_0("Command buffer ptr or Transaction ptr is NULL");
    return QMI_ERR_INTERNAL;
  }

  /* Compose app info */
  memset(&app_info, 0, sizeof(mmgsdi_app_select_with_rsp_type));
  app_info.exclusive_channel    = TRUE;
  app_info.app_id_data.data_len = aid.data_len;
  app_info.app_id_data.data_ptr = aid.data_ptr;
  app_info.select_rsp_type      = sel_rsp_type;

  /* Find a free index in the table */
  for (i = 0; i < UIM_MAX_APDU_CHANNEL_COUNT; i++)
  {
    if (qmi_uim_global_ptr->apdu_channel[i] == NULL)
    {
      /* Allocate the buffer for the channel */
      qmi_uim_global_ptr->apdu_channel[i] = (apdu_channel_info*)uimqmi_malloc(
                                                sizeof(apdu_channel_info));
      if (qmi_uim_global_ptr->apdu_channel[i] == NULL)
      {
        UIM_MSG_ERR_1("Could not allocate memory for apdu_channel[%d]", i);
        return QMI_ERR_NO_MEMORY;
      }

      channel_index = i;

      /* Initialize the buffer */
      memset(qmi_uim_global_ptr->apdu_channel[i], 0, sizeof(apdu_channel_info));
      qmi_uim_global_ptr->apdu_channel[i]->mmgsdi_session_id  = UIM_INVALID_SESSION_ID;
      qmi_uim_global_ptr->apdu_channel[i]->slot               = slot;
      (void)memscpy(&qmi_uim_global_ptr->apdu_channel[i]->aid,
                    sizeof(qmi_uim_global_ptr->apdu_channel[i]->aid),
                    &aid,
                    sizeof(aid));
      qmi_uim_global_ptr->apdu_channel[i]->opening_cl_sp      =
          (qmi_uimi_client_state_type *)((qmi_cmd_buf_type *)cmd_buf_ptr)->x_p->cl_sp;
      break;
    }
  }
  if (channel_index == UIM_INVALID_APP_INDEX)
  {
    return QMI_ERR_NO_MEMORY;
  }

  /* Create userdata. Note: since request id is not used in the callback,
     it is set to UIMI_CMD_VAL_OPEN_LOGICAL_CHANNEL */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_OPEN_LOGICAL_CHANNEL,
                                            cmd_buf_ptr,
                                            NULL,
                                            clid);
  if (cb_userdata_ptr == NULL)
  {
    uimqmi_free(qmi_uim_global_ptr->apdu_channel[channel_index]);
    qmi_uim_global_ptr->apdu_channel[channel_index] = NULL;
    return QMI_ERR_NO_MEMORY;
  }

  /* Update user data with necessary info */
  cb_userdata_ptr->data.session_open_request.channel_index = (uint8)channel_index;
  cb_userdata_ptr->data.session_open_request.session_open_type = UIM_SESSION_OPEN_APDU;
  switch(slot)
  {
    case MMGSDI_SLOT_1:
      cb_userdata_ptr->data.session_open_request.session_type = MMGSDI_NON_PROV_SESSION_SLOT_1;
      break;
    case MMGSDI_SLOT_2:
      cb_userdata_ptr->data.session_open_request.session_type = MMGSDI_NON_PROV_SESSION_SLOT_2;
      break;
    case MMGSDI_SLOT_3:
      cb_userdata_ptr->data.session_open_request.session_type = MMGSDI_NON_PROV_SESSION_SLOT_3;
      break;
    default:
      qmi_uim_free_cb_userdata(cb_userdata_ptr);
      uimqmi_free(qmi_uim_global_ptr->apdu_channel[channel_index]);
      qmi_uim_global_ptr->apdu_channel[channel_index] = NULL;
      return QMI_ERR_INTERNAL;
  }

  if(!select_mf)
  {
    /* Open the logical channel with exclusive priviledges */
    mmgsdi_status = mmgsdi_session_open_with_select_rsp(
                        qmi_uim_global_ptr->mmgsdi_client_id,
                        slot,
                        app_info,
                        qmi_uim_mmgsdi_evt_cback,
                        qmi_uimi_mmgsdi_callback,
                        (mmgsdi_client_data_type)cb_userdata_ptr);
  }
  else
  {
    /* Open the logical channel with MF selected */
    mmgsdi_status = mmgsdi_session_open_with_mf(
                        qmi_uim_global_ptr->mmgsdi_client_id,
                        slot,
                        qmi_uim_mmgsdi_evt_cback,
                        qmi_uimi_mmgsdi_callback,
                        (mmgsdi_client_data_type)cb_userdata_ptr);
  }

  /* Store the information for the response and set the index to init */
  if (MMGSDI_SUCCESS != mmgsdi_status)
  {
    uimqmi_free(qmi_uim_global_ptr->apdu_channel[channel_index]);
    qmi_uim_global_ptr->apdu_channel[channel_index] = NULL;
  }

  /* Free userdata in case of error */
  QMI_UIM_FREE_USERDATA_IF_ERROR(mmgsdi_status, cb_userdata_ptr);

  errval = qmi_uim_convert_mmgsdi_status_to_errval(mmgsdi_status);

  return errval;
} /* qmi_uim_execute_open_session_for_apdu */


/*===========================================================================
  FUNCTION QMI_UIM_EXECUTE_CLOSE_SESSION_FOR_APDU()

  DESCRIPTION
    Close a non provisioning session to stream APDUs

  PARAMETERS
    slot                : slot id
    channel id          : channel id
    cl_sp               : client state pointer
    cmd_buf_ptr         : pointer to command buffer
    clid                : client id of the control point

  RETURN VALUE
    errval      : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_execute_close_session_for_apdu
(
  mmgsdi_slot_id_enum_type     slot,
  uint8                        logical_channel,
  boolean                      terminate,
  qmi_uimi_client_state_type * cl_sp,
  void *                       cmd_buf_ptr,
  uint8                        clid
)
{
  uint16                         i                 = 0;
  qmi_error_e_type               errval            = QMI_ERR_NONE;
  mmgsdi_return_enum_type        mmgsdi_status     = MMGSDI_SUCCESS;
  uint16                         channel_index     = UIM_INVALID_APP_INDEX;
  qmi_uimi_userdata_type       * cb_userdata_ptr   = NULL;

  ASSERT(qmi_uim_global_ptr != NULL);

  /* Find the index */
  for (i = 0; i < UIM_MAX_APDU_CHANNEL_COUNT; i++)
  {
    if (qmi_uim_global_ptr->apdu_channel[i] &&
        qmi_uim_global_ptr->apdu_channel[i]->logical_channel == logical_channel &&
        qmi_uim_global_ptr->apdu_channel[i]->slot == slot)
    {
      channel_index = i;
      break;
    }
  }
  if (channel_index == UIM_INVALID_APP_INDEX)
  {
    return QMI_ERR_INVALID_ARG;
  }

  /* Check if the logical channel to be closed belongs to requesting client */
  if (qmi_uim_global_ptr->apdu_sec_restr_value != QMI_UIM_APDU_SEC_RESTRICTIONS_NONE)
  {
    /* Check if incoming clid matches with the one allocated for the logical channel */
    if (qmi_uim_global_ptr->apdu_channel[channel_index]->opening_cl_sp != cl_sp)
    {
      UIM_MSG_ERR_0("ADPU rejected due to security restrictions: logical_channel doesnt belong to client");
      return QMI_ERR_ACCESS_DENIED;
    }
  }

  /* Create userdata */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_LOGICAL_CHANNEL,
                                            cmd_buf_ptr, NULL, clid);
  if (cb_userdata_ptr == NULL)
  {
    return QMI_ERR_NO_MEMORY;
  }

  /* Update user data with channel index */
  cb_userdata_ptr->data.session_close_request.channel_index = (uint8)channel_index;

  mmgsdi_status = mmgsdi_session_close_terminate(
                            qmi_uim_global_ptr->apdu_channel[channel_index]->mmgsdi_session_id,
                            terminate,
                            qmi_uimi_mmgsdi_callback,
                            (mmgsdi_client_data_type)cb_userdata_ptr);
  if((mmgsdi_status != MMGSDI_SUCCESS) ||
     (qmi_uim_global_ptr->close_channel_sync))
  {
    errval = qmi_uim_convert_mmgsdi_status_to_errval(mmgsdi_status);

    /* Regardless of result, free the information in the table */
    qmi_uim_remove_apdu_session(
            qmi_uim_global_ptr->apdu_channel[channel_index]->mmgsdi_session_id, TRUE,
            MMGSDI_SESSION_CLOSED_CAUSE_CLIENT_REQUEST);
  }

  /* Free userdata in case of error */
  QMI_UIM_FREE_USERDATA_IF_ERROR(mmgsdi_status, cb_userdata_ptr);

  return errval;
} /* qmi_uim_execute_close_session_for_apdu */


/*===========================================================================
  FUNCTION QMI_UIM_EXECUTE_REFRESH_REGISTER_ALL()

  DESCRIPTION
    Registers for refresh

  PARAMETERS
    session_id        : session id
    register_op       : registration or deregistration operation
    vote_for_init     : vote for init
    cmd_buf_ptr       : userdata

  RETURN VALUE
    errval       : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_execute_refresh_register_all
(
  mmgsdi_session_id_type       session_id,
  boolean                      register_op,
  boolean                      vote_for_init,
  qmi_cmd_buf_type *           cmd_buf_ptr
)
{
  uint16                         refresh_index     = 0;
  uint32                         notify_mask       = 0;
  mmgsdi_return_enum_type        mmgsdi_status     = MMGSDI_SUCCESS;
  qmi_uimi_client_state_type *   client_sp         = NULL;
  qmi_error_e_type               errval            = QMI_ERR_NONE;

  /* Validate the command buffer to make sure the client is still there */
  ASSERT(cmd_buf_ptr);
  if (cmd_buf_ptr->x_p == NULL || cmd_buf_ptr->x_p->cl_sp == NULL)
  {
    UIM_MSG_HIGH_0("Transaction ptr or client state pointer is NULL");
    return QMI_ERR_INTERNAL;
  }

  /* Extract client sp */
  client_sp = (qmi_uimi_client_state_type *) cmd_buf_ptr->x_p->cl_sp;

  /* In case of deregistration from events, set vote_for_init to FALSE */
  if (register_op == FALSE)
  {
    vote_for_init = FALSE;
  }

  /* Calculate the refresh index */
  errval = qmi_uim_session_id_to_refresh_index(&refresh_index, session_id);
  if (errval != QMI_ERR_NONE)
  {
    UIM_MSG_ERR_1("Impossible to convert session id (0x%x) into refresh index",
                  session_id);
    return errval;
  }
  ASSERT(refresh_index < UIM_REFRESH_SESSION_COUNT);

  /* Calculate the refresh mask */
  notify_mask = 1 << refresh_index;

  /* Store the indication on refresh events */
  if (register_op)
  {
    if (client_sp->uim_info.refresh_all_notify_mask & notify_mask)
    {
      UIM_MSG_ERR_1("Already registered for session id (0x%x)", session_id);
      return QMI_ERR_NO_EFFECT;
    }

    /* Update the mask for registration */
    client_sp->uim_info.refresh_all_notify_mask = (client_sp->uim_info.refresh_all_notify_mask | notify_mask);
  }
  else
  {
    if (!(client_sp->uim_info.refresh_all_notify_mask & notify_mask))
    {
      UIM_MSG_ERR_1("Already deregistered for session id (0x%x)", session_id);
      return QMI_ERR_NO_EFFECT;
    }

    /* Update the mask for deregistration */
    client_sp->uim_info.refresh_all_notify_mask = (client_sp->uim_info.refresh_all_notify_mask & (~notify_mask));
  }

  /* Store the vote for init & registration flags */
  client_sp->uim_info.refresh_vote  = vote_for_init;

  /* Process the registration for refresh. Passing NULL as userdata because we're sending
     the response immediately, without waiting the callback from MMGSDI. */
  mmgsdi_status = mmgsdi_session_register_all_for_refresh(
                          session_id,
                          register_op,
                          vote_for_init,
                          qmi_uimi_mmgsdi_callback,
                          (mmgsdi_client_data_type)NULL );

  /* Convert MMGSDI status in QMI code */
  errval = qmi_uim_convert_mmgsdi_status_to_errval(mmgsdi_status);
  return errval;
} /* qmi_uim_execute_refresh_register_all */


/*===========================================================================
  FUNCTION QMI_UIM_EXECUTE_SET_SERVICE_STATUS()

  DESCRIPTION
    Enables/disables a service.

  PARAMETERS
    cmd_buf_ptr       : userdata
    session_type      : session type
    tlv_type          : type of service being enabled/disabled
    service_status    : enable or disable
    clid              : client id of the control point

  RETURN VALUE
    errval       : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_execute_set_service_status
(
  void                          * cmd_buf_ptr,
  mmgsdi_session_type_enum_type   session_type,
  uint8                           tlv_type,
  boolean                         service_status,
  uint8                           clid
)
{
  mmgsdi_return_enum_type        mmgsdi_status   = MMGSDI_ERROR;
  mmgsdi_service_enum_type       service_id      = MMGSDI_NONE;
  qmi_error_e_type               errval          = QMI_ERR_NONE;
  qmi_uimi_userdata_type *       cb_userdata_ptr = NULL;
  mmgsdi_app_enum_type           card_type       = MMGSDI_APP_NONE;
  mmgsdi_session_id_type         session_id      = UIM_INVALID_SESSION_ID;
  mmgsdi_static_data_type        aid;

  memset(&aid, 0, sizeof(mmgsdi_static_data_type));

  /* Retrieve session id: currently support only provisioning sessions */
  if (session_type == MMGSDI_GW_PROV_PRI_SESSION ||
      session_type == MMGSDI_1X_PROV_PRI_SESSION ||
      session_type == MMGSDI_GW_PROV_SEC_SESSION ||
      session_type == MMGSDI_1X_PROV_SEC_SESSION ||
      session_type == MMGSDI_GW_PROV_TER_SESSION ||
      session_type == MMGSDI_1X_PROV_TER_SESSION)
  {
    errval = qmi_uim_session_type_to_session_id(&session_id,
                                                session_type,
                                                aid);
    if (errval != QMI_ERR_NONE)
    {
      return errval;
    }
  }
  else
  {
    UIM_MSG_ERR_1("Impossible to set service status for a non provisioning session: 0x%x",
                  session_type);
    return QMI_ERR_INTERNAL;
  }

  /* Retrieve card type */
  errval = qmi_uim_session_type_to_card_type(
                             &card_type,
                             session_type,
                             aid);
  if (errval != QMI_ERR_NONE)
  {
    return errval;
  }

  /* Retrieve service id */
  if (tlv_type == UIMI_TLV_TYPE_SET_FDN_STATUS)
  {
    switch(card_type)
    {
      case MMGSDI_APP_SIM:
        service_id = MMGSDI_GSM_SRV_FDN;
        break;
      case MMGSDI_APP_RUIM:
        service_id = MMGSDI_CDMA_SRV_FDN;
        break;
      case MMGSDI_APP_USIM:
        service_id = MMGSDI_USIM_SRV_FDN;
        break;
      case MMGSDI_APP_CSIM:
        service_id = MMGSDI_CSIM_SRV_FDN;
        break;
      default:
        UIM_MSG_ERR_1("Unsupported card type: 0x%x", card_type);
        return QMI_ERR_INTERNAL;
    }
  }
  else if (tlv_type == UIMI_TLV_TYPE_SET_ACL_STATUS)
  {
    switch (card_type)
    {
       case MMGSDI_APP_USIM:
         service_id = MMGSDI_USIM_SRV_ACL;
         break;
       default:
         UIM_MSG_ERR_1("Unsupported card type for ACL service: 0x%x",
                       card_type);
         return QMI_ERR_INTERNAL;
    }
  }
  else
  {
    return QMI_ERR_INTERNAL;
  }

  /* Create userdata */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_SET_SERVICE_STATUS,
                                            cmd_buf_ptr,
                                            NULL,
                                            clid);
  if (cb_userdata_ptr == NULL)
  {
    return QMI_ERR_NO_MEMORY;
  }

  /* Enable or disable FDN */
  if (service_status)
  {
    mmgsdi_status = mmgsdi_session_enable_service(
                                  session_id,
                                  service_id,
                                  qmi_uimi_mmgsdi_callback,
                                  (mmgsdi_client_data_type)cb_userdata_ptr);
  }
  else
  {
    mmgsdi_status = mmgsdi_session_disable_service(
                                  session_id,
                                  service_id,
                                  qmi_uimi_mmgsdi_callback,
                                  (mmgsdi_client_data_type)cb_userdata_ptr);
  }

  /* Free userdata in case of error */
  QMI_UIM_FREE_USERDATA_IF_ERROR(mmgsdi_status, cb_userdata_ptr);

  /* Convert MMGSDI status in QMI code */
  errval = qmi_uim_convert_mmgsdi_status_to_errval(mmgsdi_status);

  return errval;
} /* qmi_uim_execute_set_service_status */


/*===========================================================================
  FUNCTION QMI_UIM_EXECUTE_SET_FILE_STATUS()

  DESCRIPTION
    Activates/deactivates a file.

  PARAMETERS
    session_id        : session id
    file_access       : file id and path
    file_status       : enable or disable
    cmd_buf_ptr       : userdata
    clid              : client id of the control point

  RETURN VALUE
    errval       : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_execute_set_file_status
(
  mmgsdi_session_id_type          session_id,
  mmgsdi_access_type              file_access,
  qmi_uim_file_status_type        file_status,
  void                          * cmd_buf_ptr,
  uint8                           clid
)
{
  mmgsdi_return_enum_type        mmgsdi_status   = MMGSDI_ERROR;
  mmgsdi_slot_id_enum_type       slot            = MMGSDI_MAX_SLOT_ID_ENUM;
  mmgsdi_protocol_enum_type      card_protocol   = MMGSDI_MAX_PROTOCOL_ENUM;
  qmi_error_e_type               errval          = QMI_ERR_INTERNAL;
  mmgsdi_session_type_enum_type  session_type    = MMGSDI_MAX_SESSION_TYPE_ENUM;
  qmi_uimi_userdata_type *       cb_userdata_ptr = NULL;
  mmgsdi_static_data_type        aid;

  errval = qmi_uim_session_id_to_slot(&slot,
                                      session_id);
  if (errval != QMI_ERR_NONE)
  {
    return errval;
  }

  card_protocol = qmi_uim_card_protocol(slot);
  if (card_protocol != MMGSDI_UICC)
  {
    UIM_MSG_ERR_1("QMI_UIM_SET_FILE_STATUS not supported for protocol 0x%x",
                  card_protocol);
    return QMI_ERR_NO_EFFECT;
  }

  /* Try to convert path into enum. At this point
     we can ignore errors and proceed with access by path */
  memset(&aid, 0x00, sizeof(aid));
  if (qmi_uim_session_id_to_session_type(&session_type, &aid, session_id) == QMI_ERR_NONE)
  {
    (void)qmi_uim_convert_file_access_method(&file_access,
                                             MMGSDI_EF_ENUM_ACCESS,
                                             session_type);
  }

  /* Create userdata */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_SET_FILE_STATUS,
                                            cmd_buf_ptr,
                                            NULL,
                                            clid);
  if (cb_userdata_ptr == NULL)
  {
    return QMI_ERR_NO_MEMORY;
  }

  if (file_status == QMI_UIM_FILE_STATUS_ACTIVATED)
  {
    mmgsdi_status = mmgsdi_session_activate_file(
                      session_id,
                      file_access,
                      qmi_uimi_mmgsdi_callback,
                      (mmgsdi_client_data_type)cb_userdata_ptr);
  }
  else
  {
    mmgsdi_status = mmgsdi_session_deactivate_file(
                      session_id,
                      file_access,
                      qmi_uimi_mmgsdi_callback,
                      (mmgsdi_client_data_type)cb_userdata_ptr);
  }

  errval = qmi_uim_convert_mmgsdi_status_to_errval(mmgsdi_status);

  return errval;
} /* qmi_uim_execute_set_file_status */


/*===========================================================================
  FUNCTION QMI_UIM_EXECUTE_INCREASE()

  DESCRIPTION
    Increase a record on a cyclic or linear fixed file on the card

  PARAMETERS
    session_id  : session id
    file_access : file to be increased
    data        : increase data
    token_ptr   : pointer to token info sent by client
    cmd_buf_ptr : userdata
    clid        : client id of the control point

  RETURN VALUE
    errval      : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_execute_increase
(
  mmgsdi_session_id_type     session_id,
  mmgsdi_access_type         file_access,
  mmgsdi_increase_data_type  data,
  const uint32             * token_ptr,
  void *                     cmd_buf_ptr,
  uint8                      clid
)
{
  qmi_error_e_type               errval          = QMI_ERR_NONE;
  mmgsdi_return_enum_type        mmgsdi_status   = MMGSDI_SUCCESS;
  qmi_uimi_userdata_type*        cb_userdata_ptr = NULL;
  mmgsdi_session_type_enum_type  session_type    = MMGSDI_MAX_SESSION_TYPE_ENUM;
  mmgsdi_static_data_type        aid             = { 0, };

  /* Try to convert path into enum. At this point
     we can ignore errors and proceed with access by path */
  if (qmi_uim_session_id_to_session_type(&session_type, &aid, session_id) == QMI_ERR_NONE)
  {
    (void)qmi_uim_convert_file_access_method(&file_access,
                                             MMGSDI_EF_ENUM_ACCESS,
                                             session_type);
  }

  /* Create userdata */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_INCREASE,
                                            cmd_buf_ptr,
                                            token_ptr,
                                            clid);
  if (cb_userdata_ptr == NULL)
  {
    return QMI_ERR_NO_MEMORY;
  }

  /* Execute MMGSDI read transparent */
  mmgsdi_status = mmgsdi_session_increase(
                        session_id,
                        file_access,
                        data,
                        qmi_uimi_mmgsdi_callback,
                        (mmgsdi_client_data_type)cb_userdata_ptr );

  /* Free userdata in case of error */
  QMI_UIM_FREE_USERDATA_IF_ERROR(mmgsdi_status, cb_userdata_ptr);

  /* Convert MMGSDI status in QMI code */
  errval = qmi_uim_convert_mmgsdi_status_to_errval(mmgsdi_status);

  return errval;
} /* qmi_uim_execute_increase */


/*===========================================================================
  FUNCTION QMI_UIM_EXECUTE_STATUS()

  DESCRIPTION
    Send STATUS command.

  PARAMETERS
    session_id  : session id
    status_mode : Mode in STATUS command
    status_resp : Response requested from STATUS command.
    cmd_buf_ptr : userdata
    clid        : client id of the control point

  RETURN VALUE
    errval      : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_execute_status
(
  mmgsdi_session_id_type            session_id,
  mmgsdi_status_me_app_enum_type    status_mode,
  mmgsdi_status_ret_data_enum_type  status_resp,
  void                             *cmd_buf_ptr,
  uint8                             clid
)
{
  qmi_error_e_type         errval          = QMI_ERR_NONE;
  mmgsdi_return_enum_type  mmgsdi_status   = MMGSDI_SUCCESS;
  qmi_uimi_userdata_type  *cb_userdata_ptr = NULL;

  /* Create userdata */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_SEND_STATUS,
                                            cmd_buf_ptr,
                                            NULL,
                                            clid);
  if (cb_userdata_ptr == NULL)
  {
    return QMI_ERR_NO_MEMORY;
  }

  mmgsdi_status = mmgsdi_session_send_card_status(
                                     session_id,
                                     status_mode,
                                     status_resp,
                                     qmi_uimi_mmgsdi_callback,
                                     (mmgsdi_client_data_type)cb_userdata_ptr);

  /* Free userdata in case of error */
  QMI_UIM_FREE_USERDATA_IF_ERROR(mmgsdi_status, cb_userdata_ptr);

  /* Convert MMGSDI status in QMI code */
  errval = qmi_uim_convert_mmgsdi_status_to_errval(mmgsdi_status);

  return errval;
} /* qmi_uim_execute_status */


/*===========================================================================
  FUNCTION QMI_UIM_EXECUTE_SEARCH_RECORD()

  DESCRIPTION
    Send SEARCH command to MMGSDI.

  PARAMETERS
    session_id       : session id
    file_access      : file to be read
    search_direction : direction in which we need to perform search
    first_record     : first record in the file
    search_patern    : pattern of data that need to be searched
    token_ptr        : token data
    cmd_buf_ptr      : userdata
    clid             : client id of the control point

  RETURN VALUE
    errval      : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_execute_search_record
(
  mmgsdi_session_id_type            session_id,
  mmgsdi_access_type                file_access,
  mmgsdi_search_data_type           search_pattern,
  mmgsdi_rec_num_type               first_record,
  mmgsdi_search_direction_enum_type search_direction,
  const uint32                    * token_ptr,
  void *                            cmd_buf_ptr,
  uint8                             clid
)
{
  qmi_error_e_type               errval          = QMI_ERR_NONE;
  mmgsdi_return_enum_type        mmgsdi_status   = MMGSDI_SUCCESS;
  qmi_uimi_userdata_type*        cb_userdata_ptr = NULL;
  mmgsdi_session_type_enum_type  session_type    = MMGSDI_MAX_SESSION_TYPE_ENUM;
  mmgsdi_static_data_type        aid             = { 0, };
  mmgsdi_search_offset_data_type enhanced_search_offset_data;

  /* Validate the first record */
  if (first_record < 1 || first_record > QMI_UIM_MAX_NUM_RECORD ||
      search_pattern.data_len > QMI_UIM_MAX_RECORD_LEN)
  {
    UIM_MSG_ERR_2("First record number(0x%x) is invalid or pattern length (0x%x) exceeds record length",
                  first_record, search_pattern.data_len);
    return QMI_ERR_INVALID_ARG;
  }

  /* Initialize dummy enhanced_search_offset_data to pass in MMGSDI API call */
  memset (&enhanced_search_offset_data, 0x00,
          sizeof(mmgsdi_search_offset_data_type));

  /* Try to convert path into enum. At this point
     we can ignore errors and proceed with access by path */
  if (qmi_uim_session_id_to_session_type(&session_type, &aid, session_id) == QMI_ERR_NONE)
  {
    (void)qmi_uim_convert_file_access_method(&file_access,
                                             MMGSDI_EF_ENUM_ACCESS,
                                             session_type);
  }

  /* Create userdata */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_SEARCH_RECORD,
                                            cmd_buf_ptr,
                                            token_ptr,
                                            clid);
  if (cb_userdata_ptr == NULL)
  {
    return QMI_ERR_NO_MEMORY;
  }

  /* Execute MMGSDI search */
  mmgsdi_status = mmgsdi_session_search(
                        session_id,
                        file_access,
                        MMGSDI_UICC_SIMPLE_SEARCH,
                        first_record,
                        search_direction,
                        enhanced_search_offset_data,
                        search_pattern,
                        qmi_uimi_mmgsdi_callback,
                        (mmgsdi_client_data_type)cb_userdata_ptr );

  /* Free userdata in case of error */
  QMI_UIM_FREE_USERDATA_IF_ERROR(mmgsdi_status, cb_userdata_ptr);

  /* Convert MMGSDI status in QMI code */
  errval = qmi_uim_convert_mmgsdi_status_to_errval(mmgsdi_status);

  return errval;
}/* qmi_uim_execute_search_record */


/*===========================================================================
  FUNCTION QMI_UIM_DUPLICATE_TLV_DATA()

  DESCRIPTION
    Duplicate an array of TLV data making sure that internal pointers
    are correctly re-mapped and ownership of external pointers is
    transfered to the destination, zeroing the source.

  PARAMETERS
    dest_ptr       : array of destination TLV data
    src_ptr        : array of source TLV data
    tlv_data_count : size of array of TLV data

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_duplicate_tlv_data
(
  qmi_uim_tlv_item_type * dest_ptr,
  uint32                  dest_size,
  qmi_uim_tlv_item_type * src_ptr,
  uint8                   count
)
{
  uint8  i  = 0;

  ASSERT(dest_ptr != NULL);
  ASSERT(src_ptr != NULL);
  ASSERT(count > 0);

  /* Memcpy the entire TLV array */
  (void)memscpy(dest_ptr,
                dest_size,
                src_ptr,
                count * sizeof(qmi_uim_tlv_item_type));

  /* Zero the source TLV. Ownership of pointers was passed to the
     destination and need to avoid invalid pointers around */
  memset(src_ptr, 0, count * sizeof(qmi_uim_tlv_item_type));

  /* Take care of internal pointers, where memory was not allocated separately.
     They need to be updated to point to the new location */
  for (i = 0; i < count; i++)
  {
    switch(dest_ptr[i].type)
    {
      case UIMI_TLV_TYPE_SET_PIN_PROTECTION:
        dest_ptr[i].data.set_pin_protection.pin_data.data_ptr =
          dest_ptr[i].data.set_pin_protection.pin_value;
        break;
      case UIMI_TLV_TYPE_VERIFY_PIN:
        dest_ptr[i].data.verify_pin.pin_data.data_ptr =
          dest_ptr[i].data.verify_pin.pin_value;
        break;
      case UIMI_TLV_TYPE_UNBLOCK_PIN:
        dest_ptr[i].data.unblock_pin.puk_data.data_ptr =
          dest_ptr[i].data.unblock_pin.puk_value;
        dest_ptr[i].data.unblock_pin.pin_data.data_ptr =
          dest_ptr[i].data.unblock_pin.pin_value;
        break;
      case UIMI_TLV_TYPE_CHANGE_PIN:
        dest_ptr[i].data.change_pin.old_pin_data.data_ptr =
          dest_ptr[i].data.change_pin.old_pin_value;
        dest_ptr[i].data.change_pin.new_pin_data.data_ptr =
          dest_ptr[i].data.change_pin.new_pin_value;
        break;
      case UIMI_TLV_TYPE_DECRYPTED_PIN:
        dest_ptr[i].data.decrypted_pin.decrypted_pin_data.data_ptr =
          dest_ptr[i].data.decrypted_pin.decrypted_pin_value;
        break;
      default:
        /* Nothing to do for this TLV */
        break;
    }
  }
} /* qmi_uim_duplicate_tlv_data */


/*===========================================================================
  FUNCTION QMI_UIM_ADD_AID()

  DESCRIPTION
    Utility function to add an application

  PARAMETERS
    aid_ptr  : pointer to AID + application type
    slot     : slot

  RETURN VALUE
    uint16: indicates the index of the application. The function
            return UIM_INVALID_APP_INDEX if the application could not
            be added

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static uint16 qmi_uim_add_aid
(
  const mmgsdi_aid_type*   aid_ptr,
  mmgsdi_slot_id_enum_type slot
)
{
  uint16 index = 0;

  ASSERT(aid_ptr);
  ASSERT(qmi_uim_global_ptr);

  /* Check slot */
  if (slot != MMGSDI_SLOT_1 && slot != MMGSDI_SLOT_2 && slot != MMGSDI_SLOT_3)
  {
    UIM_MSG_ERR_1("Invalid slot to add application: 0x%x", slot);
    return UIM_INVALID_APP_INDEX;
  }

  /* Check if there is space */
  if (qmi_uim_global_ptr->card_state.num_apps >= QMI_UIM_MAX_APP_COUNT)
  {
    UIM_MSG_ERR_0("No space to add application");
    return UIM_INVALID_APP_INDEX;
  }

  index = qmi_uim_global_ptr->card_state.num_apps;

  /* Make sure the index is not already used */
  if (qmi_uim_global_ptr->card_state.application[index] != NULL)
  {
    UIM_MSG_ERR_1("Index 0x%x already in use", index);
    return UIM_INVALID_APP_INDEX;
  }

  qmi_uim_global_ptr->card_state.application[index] = (qmi_uim_app_info_type *)uimqmi_malloc(
                                                        sizeof(qmi_uim_app_info_type));
  if (qmi_uim_global_ptr->card_state.application[index] == NULL)
  {
    UIM_MSG_ERR_1("Could not allocate memory for application at index 0x%x",
                  index);
    return UIM_INVALID_APP_INDEX;
  }

  memset(qmi_uim_global_ptr->card_state.application[index],
         0x00,
         sizeof(qmi_uim_app_info_type));

  /* Copy AID value */
  (void)memscpy(&qmi_uim_global_ptr->card_state.application[index]->aid,
                sizeof(mmgsdi_static_data_type),
         &aid_ptr->aid,
         sizeof(mmgsdi_static_data_type));

  /* Copy label value: label used only for USIM and CSIM */
  if (aid_ptr->app_type == MMGSDI_APP_USIM ||
      aid_ptr->app_type == MMGSDI_APP_CSIM)
  {
    (void)memscpy(&qmi_uim_global_ptr->card_state.application[index]->label,
                  sizeof(mmgsdi_static_data_type),
           &aid_ptr->label,
           sizeof(mmgsdi_static_data_type));
  }
  else
  {
    memset(&qmi_uim_global_ptr->card_state.application[index]->label,
           0,
           sizeof(mmgsdi_static_data_type));
  }

  /* Copy app type and slot */
  qmi_uim_global_ptr->card_state.application[index]->app_type      = aid_ptr->app_type;
  qmi_uim_global_ptr->card_state.application[index]->slot          = slot;

  /* Initialize other states with generic values */
  qmi_uim_global_ptr->card_state.application[index]->app_state     = QMI_UIM_APP_STATE_DETECTED;
  qmi_uim_global_ptr->card_state.application[index]->perso_state   = QMI_UIM_PERSO_STATE_UNKNOWN;
  qmi_uim_global_ptr->card_state.application[index]->perso_feature = MMGSDI_MAX_PERSO_FEATURE_ENUM;

  qmi_uim_global_ptr->card_state.num_apps++;

  return index;
} /* qmi_uim_add_aid */


/*===========================================================================
  FUNCTION QMI_UIM_FIND_AID()

  DESCRIPTION
    Utility function to locate the application with the specified AID

  PARAMETERS
    aid_ptr  : pointer to AID + application type
    slot     : slot

  RETURN VALUE
    uint16: indicates the index of the application. The function
            return UIM_INVALID_APP_INDEX if the application is not
            found

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static uint16 qmi_uim_find_aid
(
  const mmgsdi_aid_type *  aid_ptr,
  mmgsdi_slot_id_enum_type slot
)
{
  uint16 index;

  ASSERT(aid_ptr);
  ASSERT(qmi_uim_global_ptr);

  if (aid_ptr->aid.data_len > MMGSDI_MAX_AID_LEN)
  {
    return UIM_INVALID_APP_INDEX;
  }

  for (index = 0; index < qmi_uim_global_ptr->card_state.num_apps &&
                  index < QMI_UIM_MAX_APP_COUNT; index++)
  {
    if (qmi_uim_global_ptr->card_state.application[index] != NULL &&
        qmi_uim_global_ptr->card_state.application[index]->app_type == aid_ptr->app_type &&
        qmi_uim_global_ptr->card_state.application[index]->slot == slot &&
        qmi_uim_global_ptr->card_state.application[index]->aid.data_len == aid_ptr->aid.data_len)
    {
      if (aid_ptr->aid.data_len == 0)
      {
        return index;
      }
      if (memcmp( (void*)qmi_uim_global_ptr->card_state.application[index]->aid.data_ptr,
                  (void*)aid_ptr->aid.data_ptr,
                  int32touint32(aid_ptr->aid.data_len) ) == 0)
      {
        return index;
      }
    }
  }

  return UIM_INVALID_APP_INDEX;
} /* qmi_uim_find_aid */


/*===========================================================================
  FUNCTION QMI_UIM_REMOVE_AID()

  DESCRIPTION
    Utility function to remove an application

  PARAMETERS
    aid_ptr  : pointer to AID + application type
    slot     : slot

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_remove_aid
(
  const mmgsdi_aid_type*   aid_ptr,
  mmgsdi_slot_id_enum_type slot
)
{
  uint16 j     = 0;
  uint16 index = 0;

  ASSERT(aid_ptr);
  ASSERT(qmi_uim_global_ptr);

  index = qmi_uim_find_aid(aid_ptr, slot);

  if (index == UIM_INVALID_APP_INDEX ||
      index >= qmi_uim_global_ptr->card_state.num_apps ||
      qmi_uim_global_ptr->card_state.application[index] == NULL)
  {
    /* Application does not exist: immediately return */
    return;
  }

  /* Free info of the app which needs to be removed */
  uimqmi_free(qmi_uim_global_ptr->card_state.application[index]);
  qmi_uim_global_ptr->card_state.application[index] = NULL;

  /* Shift all applications in the table */
  for (j = index; j < qmi_uim_global_ptr->card_state.num_apps - 1 &&
                  j < QMI_UIM_MAX_APP_COUNT - 1; j++)
  {
    qmi_uim_global_ptr->card_state.application[j] =
      qmi_uim_global_ptr->card_state.application[j + 1];
    qmi_uim_global_ptr->card_state.application[j + 1] = NULL;
  }

  /* Decrease number of apps */
  qmi_uim_global_ptr->card_state.num_apps--;

  for (j = 0; j < QMI_UIM_MAX_PROV_SESSIONS; j++)
  {
    /* Update index of GW provisioning app */
    if (qmi_uim_global_ptr->card_state.index_gw[j] == index)
    {
      qmi_uim_global_ptr->card_state.index_gw[j] = UIM_INVALID_APP_INDEX;
    }
    else if (qmi_uim_global_ptr->card_state.index_gw[j] > index &&
             qmi_uim_global_ptr->card_state.index_gw[j] < QMI_UIM_MAX_APP_COUNT)
    {
      qmi_uim_global_ptr->card_state.index_gw[j]--;
    }
    else
    {
      /* Nothing to do */
    }

    /* Update index of 1X provisioning app */
    if (qmi_uim_global_ptr->card_state.index_1x[j] == index)
    {
      qmi_uim_global_ptr->card_state.index_1x[j] = UIM_INVALID_APP_INDEX;
    }
    else if (qmi_uim_global_ptr->card_state.index_1x[j] > index &&
             qmi_uim_global_ptr->card_state.index_1x[j] < QMI_UIM_MAX_APP_COUNT)
    {
      qmi_uim_global_ptr->card_state.index_1x[j]--;
    }
    else
    {
      /* Nothing to do */
    }
  }
} /* qmi_uim_remove_aid */


/*===========================================================================
  FUNCTION QMI_UIM_REMOVE_ALL_AID_IN_SLOT()

  DESCRIPTION
    Utility function to remove all applications for a specific slot

  PARAMETERS
    slot     : slot

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_remove_all_aid_in_slot
(
  mmgsdi_slot_id_enum_type slot
)
{
  uint16 i  =  0;

  while(i < qmi_uim_global_ptr->card_state.num_apps && i < QMI_UIM_MAX_APP_COUNT)
  {
    if (qmi_uim_global_ptr->card_state.application[i] != NULL &&
        qmi_uim_global_ptr->card_state.application[i]->slot == slot)
    {
      mmgsdi_aid_type   aid_value = { MMGSDI_APP_NONE };

      aid_value.app_type = qmi_uim_global_ptr->card_state.application[i]->app_type;
      (void)memscpy(&aid_value.aid,
                    sizeof(mmgsdi_static_data_type),
             &qmi_uim_global_ptr->card_state.application[i]->aid,
             sizeof(mmgsdi_static_data_type));

      qmi_uim_remove_aid(&aid_value, slot);
    }
    else
    {
      i++;
    }
  }
} /* qmi_uim_remove_all_aid_in_slot */


/*===========================================================================
  FUNCTION QMI_UIM_OPEN_SESSION()

  DESCRIPTION
    Opens a new non provisioning session on the fly and enqueues
    the command in the list of the session, so it can be executed
    later on, when the session is successfully opened.

  PARAMETERS
    command_id     : command id
    tlv_data_ptr   : pointer to list of TLVs
    tlv_data_count : number of TLVs
    cmd_buf_ptr    : userdata of the command

  RETURN VALUE
    errval         : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_open_session
(
  qmi_uimi_cmd_val_e_type            command_id,
  qmi_uim_tlv_item_type            * tlv_data_ptr,
  uint8                              tlv_data_count,
  void                             * cmd_buf_ptr,
  qmi_uimi_client_state_type       * cl_sp
)
{
  uint16                                 i               = 0;
  uint16                                 non_prov_index  = UIM_INVALID_APP_INDEX;
  qmi_uim_tlv_session_information_type * tlv_session_ptr = NULL;
  qmi_uimi_pending_request_type        * request_ptr     = NULL;
  qmi_uimi_pending_request_type        * current_ptr     = NULL;
  qmi_uimi_userdata_type               * cb_userdata_ptr = NULL;

  ASSERT(tlv_data_ptr);
  ASSERT(tlv_data_count > 0);
  ASSERT(qmi_uim_global_ptr);
  ASSERT(cl_sp);
  ASSERT(qmi_uim_state_ptr);

  /* Find session information in the TLVs */
  for (i = 0; i < tlv_data_count; i++)
  {
    if (tlv_data_ptr[i].type == UIMI_TLV_TYPE_SESSION_INFORMATION &&
        tlv_data_ptr[i].present)
    {
      tlv_session_ptr = &tlv_data_ptr[i].data.session_information;
      break;
    }
  }
  if (tlv_session_ptr == NULL)
  {
    UIM_MSG_ERR_0("No session information in TLV");
    return QMI_ERR_INTERNAL;
  }

  /* Check AID validity */
  if(tlv_session_ptr->aid.data_len == QMI_UIM_TLV_CHANNEL_ID_LEN)
  {
    UIM_MSG_ERR_1("Invalid AID length: 0x%x, cannot open session",
                  tlv_session_ptr->aid.data_len);
    return QMI_ERR_INVALID_ARG;
  }

  /* Verify session type is non provisioning */
  if ((tlv_session_ptr->session_type != MMGSDI_NON_PROV_SESSION_SLOT_1 &&
       tlv_session_ptr->session_type != MMGSDI_NON_PROV_SESSION_SLOT_2 &&
       tlv_session_ptr->session_type != MMGSDI_NON_PROV_SESSION_SLOT_3) ||
      tlv_session_ptr->aid.data_len > MMGSDI_MAX_AID_LEN)
  {
    UIM_MSG_ERR_1("Impossible to open a non prov session of type 0x%x",
                  tlv_session_ptr->session_type);
    return QMI_ERR_INTERNAL;
  }

  /* Check if a non provisioning session is already opening or find an
     empty slot to add this new session */
  non_prov_index = UIM_INVALID_APP_INDEX;
  for (i = 0; i < UIM_MAX_NON_PROV_SESSIONS; i++)
  {
    if (!qmi_uim_global_ptr->non_prov_session[i].init &&
        non_prov_index == UIM_INVALID_APP_INDEX)
    {
      /* Empty slot found. Keep searching */
      non_prov_index = i;
    }

    if (qmi_uim_global_ptr->non_prov_session[i].init &&
        qmi_uim_global_ptr->non_prov_session[i].session_type == tlv_session_ptr->session_type)
    {
      if ((qmi_uim_global_ptr->non_prov_session[i].aid.data_len == 0 &&
           tlv_session_ptr->aid.data_len == 0)||
          (qmi_uim_global_ptr->non_prov_session[i].aid.data_len > 0 &&
           qmi_uim_global_ptr->non_prov_session[i].aid.data_len == tlv_session_ptr->aid.data_len &&
           memcmp( (void*)qmi_uim_global_ptr->non_prov_session[i].aid.data_ptr,
                  (void*)tlv_session_ptr->aid.data_ptr,
                          int32touint32(tlv_session_ptr->aid.data_len) ) == 0))
      {
        /* Make sure the non-provisioning session is still opening. This
           is done by verifying the session id */
        if (qmi_uim_global_ptr->non_prov_session[i].mmgsdi_session_id != UIM_INVALID_SESSION_ID)
        {
          UIM_MSG_ERR_0("Non prov session already exists");
          return QMI_ERR_INTERNAL;
        }

        /* Matching non provisioning session found. Break. */
        UIM_MSG_HIGH_0("Found opening non prov session");
        non_prov_index = i;
        break;
      }
    }
  }

  /* Index should be valid... otherwise it means that we didn't find
     the corresponding session and the array is also full */
  if (non_prov_index == UIM_INVALID_APP_INDEX)
  {
    UIM_MSG_ERR_0("Impossible to open a non prov session");
    return QMI_ERR_NO_MEMORY;
  }

  /* If non provisioning session does not exist yet, open now */
  if (!qmi_uim_global_ptr->non_prov_session[non_prov_index].init)
  {
    mmgsdi_return_enum_type          mmgsdi_status = MMGSDI_SUCCESS;
    mmgsdi_app_select_with_rsp_type  app_info;
    mmgsdi_slot_id_enum_type         slot = MMGSDI_SLOT_1;

    if(tlv_session_ptr->session_type == MMGSDI_NON_PROV_SESSION_SLOT_1)
    {
      slot = MMGSDI_SLOT_1;
    }
    else if(tlv_session_ptr->session_type == MMGSDI_NON_PROV_SESSION_SLOT_2)
    {
      slot = MMGSDI_SLOT_2;
    }
    else
    {
      slot = MMGSDI_SLOT_3;
    }

    /* Create userdata. Note: since request id is not used in the callback,
       it is set to UIMI_CMD_VAL_WIDTH */
    cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_OPEN_LOGICAL_CHANNEL,
                                              cmd_buf_ptr,
                                              NULL,
                                              cl_sp->common.clid);
    if (cb_userdata_ptr == NULL)
    {
      return QMI_ERR_NO_MEMORY;
    }

    /* Update userdata with necessary info */
    cb_userdata_ptr->data.session_open_request.channel_index     = (uint8)non_prov_index;
    cb_userdata_ptr->data.session_open_request.session_open_type = UIM_SESSION_OPEN_IMPLICIT;
    cb_userdata_ptr->data.session_open_request.session_type      = tlv_session_ptr->session_type;

    /* Compose app info */
    memset(&app_info, 0, sizeof(mmgsdi_app_select_with_rsp_type));
    app_info.exclusive_channel    = FALSE;
    app_info.app_id_data.data_len = tlv_session_ptr->aid.data_len;
    app_info.app_id_data.data_ptr = tlv_session_ptr->aid.data_ptr;
    app_info.select_rsp_type      = MMGSDI_SELECT_RSP_FCP;

    mmgsdi_status = mmgsdi_session_open_with_select_rsp(
                       qmi_uim_global_ptr->mmgsdi_client_id,
                       slot,
                       app_info,
                       qmi_uim_mmgsdi_evt_cback,
                       qmi_uimi_mmgsdi_callback,
                       (mmgsdi_client_data_type)cb_userdata_ptr);

    /* Free userdata in case of error */
    QMI_UIM_FREE_USERDATA_IF_ERROR(mmgsdi_status, cb_userdata_ptr);

    if (mmgsdi_status != MMGSDI_SUCCESS)
    {
      qmi_error_e_type errval =
         qmi_uim_convert_mmgsdi_status_to_errval(mmgsdi_status);

      UIM_MSG_ERR_1("Error opening non prov session: 0x%x", mmgsdi_status);
      return errval;
    }

    /* Initialize the values */
    qmi_uim_global_ptr->non_prov_session[non_prov_index].init = TRUE;
    qmi_uim_global_ptr->non_prov_session[non_prov_index].mmgsdi_session_id = UIM_INVALID_SESSION_ID;
    qmi_uim_global_ptr->non_prov_session[non_prov_index].session_type = tlv_session_ptr->session_type;
    (void)memscpy(&qmi_uim_global_ptr->non_prov_session[non_prov_index].aid,
                  sizeof(mmgsdi_static_data_type),
           &tlv_session_ptr->aid,
           sizeof(mmgsdi_static_data_type));
  }

  /* Associate the Client with the requested Session */
  (void)qmi_uim_update_non_prov_session_cl_sp(
          tlv_data_ptr,
          tlv_data_count,
          cl_sp);

  /* Allocate memory for the new node to be added */
  request_ptr = uimqmi_malloc(sizeof(qmi_uimi_pending_request_type));
  if (request_ptr == NULL)
  {
    UIM_MSG_ERR_0("No memory to allocate pending request node");
    return QMI_ERR_NO_MEMORY;
  }

  memset(request_ptr, 0, sizeof(qmi_uimi_pending_request_type));

  /* Allocate memory to duplicate TLV data for the non provisioning session */
  request_ptr->tlv_data_ptr = uimqmi_malloc(
                                tlv_data_count * sizeof(qmi_uim_tlv_item_type));
  if (request_ptr->tlv_data_ptr == NULL)
  {
    UIM_MSG_ERR_0("No memory to duplicate TLV");
    uimqmi_free(request_ptr);
    return QMI_ERR_NO_MEMORY;
  }

  /* Add the new node to the global linked list. If list already has elements,
     iterate to end of the list to insert the new node */
  current_ptr = qmi_uim_global_ptr->non_prov_session[non_prov_index].pending_req_ptr;
  if (current_ptr == NULL)
  {
    qmi_uim_global_ptr->non_prov_session[non_prov_index].pending_req_ptr = request_ptr;
  }
  else
  {
    /* Iterate to the last node & insert */
    while (current_ptr->next_ptr != NULL)
    {
      current_ptr = current_ptr->next_ptr;
    }
    current_ptr->next_ptr = request_ptr;
  }

  /* Duplicate TLV data: this also takes care of zeroing the source
     to avoid invalid pointers around */
  request_ptr->tlv_data_count = tlv_data_count;
  request_ptr->command_id     = command_id;
  request_ptr->cmd_buf_ptr    = cmd_buf_ptr;
  request_ptr->clid           = cl_sp->common.clid;
  request_ptr->client_reg_count =
     qmi_uim_state_ptr->client_reg_count[request_ptr->clid - 1];

  qmi_uim_duplicate_tlv_data(request_ptr->tlv_data_ptr,
                             tlv_data_count * sizeof(qmi_uim_tlv_item_type),
                             tlv_data_ptr,
                             tlv_data_count);

  return QMI_ERR_NONE;
} /* qmi_uim_open_session */


/*===========================================================================
  FUNCTION QMI_UIM_IS_PROVISIONING_APP_INDEX()

  DESCRIPTION
    Checks if the given index is associated with a provisioning application

  PARAMETERS
    index : index of application

  RETURN VALUE
    TRUE  : If the index is associated with prov app
    FALSE : If the index is not associated with prov app

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_uim_is_provisioning_app_index
(
  uint16 index
)
{
  uint8   i      = 0;
  boolean result = FALSE;

  ASSERT(qmi_uim_global_ptr);

  for (i = 0; i < QMI_UIM_MAX_PROV_SESSIONS; i++)
  {
    if (index == qmi_uim_global_ptr->card_state.index_gw[i] ||
        index == qmi_uim_global_ptr->card_state.index_1x[i])
    {
      result = TRUE;
      break;
    }
  }

  return result;
} /* qmi_uim_is_provisioning_app_index */


/*===========================================================================
  FUNCTION QMI_UIM_CHECK_NON_PROV_AUTH()

  DESCRIPTION
    Checks if there are provisioning applications active and
    valid for authentication on the same slot as non-provisioning
    application requesting authentication

  PARAMETERS
    slot_id : slot of the calling non-prov application

  RETURN VALUE
    TRUE  : proceed with non-prov authentication
    FALSE : deny authentication as provisioning session is blocking

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_uim_check_non_prov_auth
(
  mmgsdi_slot_id_enum_type slot_id
)
{
  /* Initalize to TRUE in case no provisioned application is
     present then proceed with authentication */
  boolean non_prov_auth_pass = TRUE;
  uint8   i                  = 0;

  ASSERT(qmi_uim_global_ptr);

  for (i = 0;  i < qmi_uim_global_ptr->card_state.num_apps &&
       i < QMI_UIM_MAX_APP_COUNT; i++)
  {
    if (qmi_uim_global_ptr->card_state.application[i] != NULL &&
        qmi_uim_global_ptr->card_state.application[i]->slot == slot_id &&
        qmi_uim_is_provisioning_app_index(i) != FALSE)
    {
      if((qmi_uim_global_ptr->card_state.application[i]->app_state !=
          QMI_UIM_APP_STATE_ILLEGAL) &&
         (qmi_uim_global_ptr->card_state.application[i]->app_state !=
          QMI_UIM_APP_STATE_PERSO))
      {
        /* If at least one valid provisioning application exists on the slot
           then continue with authentication */
        return TRUE;
      }
      non_prov_auth_pass = FALSE;
    }
  }

  return non_prov_auth_pass;
} /* qmi_uim_check_non_prov_auth */


/*===========================================================================
  FUNCTION QMI_UIM_AUTH_ALLOWED_IN_APP_STATE

  DESCRIPTION
    Check if authentication request is allowed in the current app state.

  PARAMETERS
    session_type  : session type

  RETURN VALUE
    boolean       : TRUE if authentication is allowed

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_uim_auth_allowed_in_app_state
(
  mmgsdi_session_type_enum_type   session_type
)
{
  uint16 index = UIM_INVALID_APP_INDEX;

  ASSERT(qmi_uim_global_ptr);

  switch(session_type)
  {
    case MMGSDI_GW_PROV_PRI_SESSION:
      index = qmi_uim_global_ptr->card_state.index_gw[0];
      break;

    case MMGSDI_1X_PROV_PRI_SESSION:
      index = qmi_uim_global_ptr->card_state.index_1x[0];
      break;

    case MMGSDI_GW_PROV_SEC_SESSION:
      index = qmi_uim_global_ptr->card_state.index_gw[1];
      break;

    case MMGSDI_1X_PROV_SEC_SESSION:
      index = qmi_uim_global_ptr->card_state.index_1x[1];
      break;

    case MMGSDI_GW_PROV_TER_SESSION:
      index = qmi_uim_global_ptr->card_state.index_gw[2];
      break;

    case MMGSDI_1X_PROV_TER_SESSION:
      index = qmi_uim_global_ptr->card_state.index_1x[2];
      break;

    case MMGSDI_NON_PROV_SESSION_SLOT_1:
      return qmi_uim_check_non_prov_auth(MMGSDI_SLOT_1);

    case MMGSDI_NON_PROV_SESSION_SLOT_2:
      return qmi_uim_check_non_prov_auth(MMGSDI_SLOT_2);

    case MMGSDI_NON_PROV_SESSION_SLOT_3:
      return qmi_uim_check_non_prov_auth(MMGSDI_SLOT_3);

    default:
      return FALSE;
  }

  /* Check if the index is valid */
  if (index >= qmi_uim_global_ptr->card_state.num_apps ||
      index >= QMI_UIM_MAX_APP_COUNT ||
      qmi_uim_global_ptr->card_state.application[index] == NULL)
  {
    UIM_MSG_ERR_1("Invalid index: 0x%x", index);
    return FALSE;
  }

  if((qmi_uim_global_ptr->card_state.application[index]->app_state ==
      QMI_UIM_APP_STATE_ILLEGAL) ||
     (qmi_uim_global_ptr->card_state.application[index]->app_state ==
      QMI_UIM_APP_STATE_PERSO))
  {
    return FALSE;
  }

  return TRUE;
} /* qmi_uim_auth_allowed_in_app_state */


/*===========================================================================
  FUNCTION QMI_UIM_UPDATE_PIN_STATE()

  DESCRIPTION
    Updates the PIN state after a PIN operation for the application
    used for the operation.

  PARAMETERS
    pin                 : PIN id to be updated
    pin_status          : PIN status
    upin_replace_status : PIN1 replacement status
    app_index           : index of application to be updated
    card_index          : card index to be updated

  RETURN VALUE
    TRUE   : Indicates there is an update
    FALSE  : Indicates no updates

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_uim_update_pin_state
(
  mmgsdi_pin_enum_type         pin,
  mmgsdi_pin_status_enum_type  pin_status,
  mmgsdi_pin_replace_enum_type upin_replace_status,
  uint16                       app_index,
  uint8                        card_index
)
{
  boolean  result                               = FALSE;
  boolean  update_state[QMI_UIM_MAX_APP_COUNT]  = {FALSE};
  int      i                                    = 0;

  ASSERT(qmi_uim_global_ptr);

  UIM_MSG_HIGH_0("qmi_uim_update_pin_state");

  if (pin == MMGSDI_PIN1)
  {
    if (app_index < QMI_UIM_MAX_APP_COUNT &&
        app_index < qmi_uim_global_ptr->card_state.num_apps &&
        qmi_uim_global_ptr->card_state.application[app_index] != NULL)
    {
      mmgsdi_pin_status_enum_type new_pin1_state =
               qmi_uim_global_ptr->card_state.application[app_index]->pin1_state;

      /* PIN state */
      if(pin_status == MMGSDI_PIN_UNBLOCKED)
      {
        new_pin1_state = MMGSDI_PIN_ENABLED_VERIFIED;
      }
      else if (pin_status == MMGSDI_PIN_CHANGED)
      {
        if (qmi_uim_global_ptr->card_state.application[app_index]->pin1_state ==
            MMGSDI_PIN_ENABLED_NOT_VERIFIED)
        {
          new_pin1_state = MMGSDI_PIN_ENABLED_VERIFIED;
        }
      }
      else if (pin_status == MMGSDI_PIN_RETRY_COUNT_DECREASED)
      {
        /* Indicates a decrease in retry count */
      }
      else
      {
        new_pin1_state = pin_status;
      }

      /* Indicates a change in PIN1 state */
      if (new_pin1_state !=
          qmi_uim_global_ptr->card_state.application[app_index]->pin1_state)
      {
        qmi_uim_global_ptr->card_state.application[app_index]->pin1_state = new_pin1_state;

        /* Mark result as true (update) */
        result = TRUE;
      }

      /* Universal PIN boolean */
      if (upin_replace_status == MMGSDI_PIN_REPLACED_BY_UNIVERSAL)
      {
        qmi_uim_global_ptr->card_state.application[app_index]->upin = TRUE;
      }
      else
      {
        qmi_uim_global_ptr->card_state.application[app_index]->upin = FALSE;
        /* update state from PIN event */
        update_state[app_index] = TRUE;
      }
    }
  }

  if (pin == MMGSDI_PIN2)
  {
    if (app_index < QMI_UIM_MAX_APP_COUNT &&
        app_index < qmi_uim_global_ptr->card_state.num_apps &&
        qmi_uim_global_ptr->card_state.application[app_index] != NULL)
    {
      mmgsdi_pin_status_enum_type new_pin2_state =
              qmi_uim_global_ptr->card_state.application[app_index]->pin2_state;

      /* PIN state */
      if(pin_status == MMGSDI_PIN_UNBLOCKED)
      {
        new_pin2_state = MMGSDI_PIN_ENABLED_VERIFIED;
      }
      else if (pin_status == MMGSDI_PIN_CHANGED)
      {
        if (qmi_uim_global_ptr->card_state.application[app_index]->pin2_state ==
            MMGSDI_PIN_ENABLED_NOT_VERIFIED)
        {
          new_pin2_state = MMGSDI_PIN_ENABLED_VERIFIED;
        }
      }
      else if (pin_status == MMGSDI_PIN_RETRY_COUNT_DECREASED)
      {
        /* Indicates a decrease in retry count */
      }
      else
      {
        new_pin2_state = pin_status;
      }

      /* Indicates a change in PIN2 state */
      if (new_pin2_state !=
          qmi_uim_global_ptr->card_state.application[app_index]->pin2_state)
      {
        qmi_uim_global_ptr->card_state.application[app_index]->pin2_state = new_pin2_state;

        /* Mark result as true (update) */
        result = TRUE;
      }
    }
  }

  if (pin == MMGSDI_UNIVERSAL_PIN)
  {
    if (card_index < QMI_UIM_MAX_CARD_COUNT &&
        card_index < qmi_uim_global_ptr->card_state.num_slots &&
        qmi_uim_global_ptr->card_state.card[card_index] != NULL)
    {
      mmgsdi_pin_status_enum_type new_upin_state =
            qmi_uim_global_ptr->card_state.card[card_index]->upin_state;

      /* PIN state */
      if(pin_status == MMGSDI_PIN_UNBLOCKED)
      {
        new_upin_state = MMGSDI_PIN_ENABLED_VERIFIED;
      }
      else if (pin_status == MMGSDI_PIN_CHANGED)
      {
        if (qmi_uim_global_ptr->card_state.card[card_index]->upin_state ==
            MMGSDI_PIN_ENABLED_NOT_VERIFIED)
        {
          new_upin_state = MMGSDI_PIN_ENABLED_VERIFIED;
        }
      }
      else if (pin_status == MMGSDI_PIN_RETRY_COUNT_DECREASED)
      {
        /* Indicates a decrease in retry count */
      }
      else
      {
        new_upin_state = pin_status;
      }

      /* Indicates a change in UPIN state */
      if (new_upin_state !=
          qmi_uim_global_ptr->card_state.card[card_index]->upin_state)
      {
        qmi_uim_global_ptr->card_state.card[card_index]->upin_state = new_upin_state;

        /* Mark result as true (update) */
        result = TRUE;
      }
    } /* card_index < QMI_UIM_MAX_CARD_COUNT */

    /* List of applications to update */
    for (i = 0; i < qmi_uim_global_ptr->card_state.num_apps &&
                i < QMI_UIM_MAX_APP_COUNT; i++)
    {
      if (qmi_uim_global_ptr->card_state.application[i] != NULL &&
          qmi_uim_global_ptr->card_state.application[i]->upin)
      {
        /* Update state from PIN event */
        update_state[i] = TRUE;
      }
    }
  }

  /* Update state of applications based on PIN event */
  for (i = 0; i < qmi_uim_global_ptr->card_state.num_apps &&
              i < QMI_UIM_MAX_APP_COUNT; i++)
  {
    if (qmi_uim_global_ptr->card_state.application[i] == NULL)
    {
      continue;
    }

    if (update_state[i] == FALSE)
    {
      continue;
    }

    /* Update the app state for prov apps only */
    if (qmi_uim_is_provisioning_app_index(i) == FALSE)
    {
      continue;
    }

    switch(pin_status)
    {
      case MMGSDI_PIN_STATUS_NOT_INITIALIZED:
      case MMGSDI_PIN_DISABLED:
      case MMGSDI_PIN_ENABLED_VERIFIED:
      case MMGSDI_PIN_UNBLOCKED:
      case MMGSDI_PIN_CHANGED:
        /* We transition to PERSO state after PIN states, only if PIN
           was required. There might be cases where the event is received
           after initialization is completed. */
        if (qmi_uim_global_ptr->card_state.application[i]->app_state == QMI_UIM_APP_STATE_PIN_REQUIRED ||
            qmi_uim_global_ptr->card_state.application[i]->app_state == QMI_UIM_APP_STATE_PUK1_REQUIRED)
        {
          if(qmi_uim_global_ptr->card_state.application[i]->perso_state == QMI_UIM_PERSO_STATE_READY)
          {
            qmi_uim_global_ptr->card_state.application[i]->app_state = QMI_UIM_APP_STATE_READY;
          }
          else
          {
            qmi_uim_global_ptr->card_state.application[i]->app_state = QMI_UIM_APP_STATE_PERSO;
          }
          result = TRUE;
        }
        break;

      case MMGSDI_PIN_ENABLED_NOT_VERIFIED:
        if (qmi_uim_global_ptr->card_state.application[i]->app_state != QMI_UIM_APP_STATE_PIN_REQUIRED)
        {
          qmi_uim_global_ptr->card_state.application[i]->app_state = QMI_UIM_APP_STATE_PIN_REQUIRED;
          result = TRUE;
        }
        break;

      case MMGSDI_PIN_BLOCKED:
        if (qmi_uim_global_ptr->card_state.application[i]->app_state != QMI_UIM_APP_STATE_PUK1_REQUIRED)
        {
          qmi_uim_global_ptr->card_state.application[i]->app_state = QMI_UIM_APP_STATE_PUK1_REQUIRED;
          result = TRUE;
        }
        break;

      case MMGSDI_PIN_PERM_BLOCKED:
        if (qmi_uim_global_ptr->card_state.application[i]->app_state != QMI_UIM_APP_STATE_BLOCKED)
        {
          qmi_uim_global_ptr->card_state.application[i]->app_state = QMI_UIM_APP_STATE_BLOCKED;
          result = TRUE;
        }
        break;

      case MMGSDI_PIN_RETRY_COUNT_DECREASED:
      default:
        break;
    }
  }

  return result;
} /* qmi_uim_update_pin_state */


/*===========================================================================
  FUNCTION QMI_UIM_UPDATE_PIN1_OTHER_APPS()

  DESCRIPTION
    Updates the number of PIN1 retries and state in the global card status
    after a PIN operation for other applications, other than the one
    used for the operation. This is required in case 2 or more applications
    are sharing the same PIN.

  PARAMETERS
    pin_info_ptr  : PIN info ptr
    slot          : slot id
    updated_index : index of application already updated

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_update_pin1_other_apps
(
  const mmgsdi_pin_info_type * pin_info_ptr,
  mmgsdi_slot_id_enum_type     slot,
  uint16                       updated_index
)
{
  uint16                       i                                   = 0;
  uint16                       index                               = 0;
  uint8                        card_index                          = 0;
  uint16                       num_app                             = 0;
  mmgsdi_app_info_type       * app_info_ptr                        = NULL;
  mmgsdi_return_enum_type      mmgsdi_status                       = MMGSDI_SUCCESS;
  mmgsdi_available_apps_type * available_apps_ptr                  = NULL;

  ASSERT(pin_info_ptr);
  ASSERT(qmi_uim_global_ptr);

  /* This function is only for PIN1 */
  if (pin_info_ptr->pin_id != MMGSDI_PIN1)
  {
    return;
  }

  /* Check total number of applications on the slot: if there is only 1 application
     this function is useless and we can immediately return */
  for (i = 0; i < qmi_uim_global_ptr->card_state.num_apps &&
              i < QMI_UIM_MAX_APP_COUNT; i++)
  {
    if (qmi_uim_global_ptr->card_state.application[i] != NULL &&
        qmi_uim_global_ptr->card_state.application[i]->slot == slot)
    {
      num_app++;
    }
  }
  if (num_app <= 1)
  {
    return;
  }

  UIM_MSG_HIGH_0("Retrieving other apps to update PIN retries");

  /* Allocate memory for available apps pointer */
  available_apps_ptr = (mmgsdi_available_apps_type *)uimqmi_malloc(
                            sizeof(mmgsdi_available_apps_type));

  if(available_apps_ptr == NULL)
  {
    return;
  }

  /* Retrieve status of all available apps */
  mmgsdi_status = mmgsdi_get_all_available_apps_sync(qmi_uim_global_ptr->mmgsdi_client_id,
                                                     available_apps_ptr);
  if (mmgsdi_status != MMGSDI_SUCCESS)
  {
    UIM_MSG_ERR_1("Error retrieving app status: 0x%x", mmgsdi_status);
    uimqmi_free(available_apps_ptr);
    available_apps_ptr = NULL;
    return;
  }

  /* Retrieve information for the corresponding slot */
  switch (slot)
  {
    case MMGSDI_SLOT_1:
      num_app      = (uint16)available_apps_ptr->card1_num_app;
      app_info_ptr = available_apps_ptr->card1_app_info;
      break;
   case MMGSDI_SLOT_2:
     num_app      = (uint16)available_apps_ptr->card2_num_app;
     app_info_ptr = available_apps_ptr->card2_app_info;
     break;
   case MMGSDI_SLOT_3:
     num_app      = (uint16)available_apps_ptr->card3_num_app;
     app_info_ptr = available_apps_ptr->card3_app_info;
     break;
    default:
      UIM_MSG_ERR_1("Invalid slot id: 0x%x", slot);
      uimqmi_free(available_apps_ptr);
      available_apps_ptr = NULL;
      return;
  }

  if (num_app > MMGSDI_MAX_APP_INFO)
  {
    UIM_MSG_ERR_1("Invalid number of applications: 0x%x", num_app);
    uimqmi_free(available_apps_ptr);
    available_apps_ptr = NULL;
    return;
  }

  if (app_info_ptr == NULL)
  {
    UIM_MSG_ERR_0("Invalid app info");
    uimqmi_free(available_apps_ptr);
    available_apps_ptr = NULL;
    return;
  }

  if (qmi_uim_mmgsdi_slot_to_slot_index(slot,
                                        &card_index) != QMI_ERR_NONE)
  {
    uimqmi_free(available_apps_ptr);
    available_apps_ptr = NULL;
    return;
  }

  if (card_index >= QMI_UIM_MAX_CARD_COUNT ||
      card_index > qmi_uim_global_ptr->card_state.num_slots)
  {
    uimqmi_free(available_apps_ptr);
    available_apps_ptr = NULL;
    return;
  }

  /* Loop thru all applications in QMI */
  for (i = 0; i < num_app; i++)
  {
    /* Verify that number of retries for the application is valid */
    if (!app_info_ptr[i].pin1.valid_num_retries &&
        !app_info_ptr[i].pin1.valid_num_unblock_retries)
    {
      continue;
    }

    /* Find the application in QMI table */
    index = qmi_uim_find_aid(&app_info_ptr[i].app_data, slot);

    /* Verify that index is valid and is not the same index that we have already updated
       processing the result of the operation */
    if (index == UIM_INVALID_APP_INDEX ||
        index >= qmi_uim_global_ptr->card_state.num_apps ||
        index == updated_index ||
        qmi_uim_global_ptr->card_state.application[index] == NULL)
    {
      continue;
    }

    UIM_MSG_HIGH_1("Updating PIN information for app: 0x%x", index);

    (void)qmi_uim_update_pin_state(app_info_ptr[i].pin1.pin_id,
                                   app_info_ptr[i].pin1.status,
                                   app_info_ptr[i].pin1.pin_replacement,
                                   index,
                                   card_index);

    /* Update the number of retries, if needed */
    if(app_info_ptr[i].pin1.valid_num_retries)
    {
      qmi_uim_global_ptr->card_state.application[index]->pin1_num_retries =
        (uint8)app_info_ptr[i].pin1.num_retries;
    }
    if(app_info_ptr[i].pin1.valid_num_unblock_retries)
    {
      qmi_uim_global_ptr->card_state.application[index]->puk1_num_retries =
        (uint8)app_info_ptr[i].pin1.num_unblock_retries;
    }
  }

  uimqmi_free(available_apps_ptr);
  available_apps_ptr = NULL;
} /* qmi_uim_update_pin1_other_apps */


/*===========================================================================
  FUNCTION QMI_UIM_UPDATE_PIN_RETRIES_AND_STATE()

  DESCRIPTION
    Updates the number of PIN retries and state in the global card status after
    a PIN operation

  PARAMETERS
    pin_cnf_ptr : PIN operation confirmation

  RETURN VALUE
    Boolean indicating if there was an update

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_uim_update_pin_retries_and_state
(
  const mmgsdi_pin_operation_cnf_type * pin_cnf_ptr
)
{
  boolean result     = FALSE;
  uint16  app_index  = UIM_INVALID_APP_INDEX;
  uint8   slot_idx   = 0;

  ASSERT(pin_cnf_ptr);
  ASSERT(qmi_uim_global_ptr);

  /* PIN1 and PIN2 */
  if (pin_cnf_ptr->pin_info.pin_id == MMGSDI_PIN1 ||
      pin_cnf_ptr->pin_info.pin_id == MMGSDI_PIN2)
  {
    uint8                  i          = 0;
    mmgsdi_session_id_type session_id = pin_cnf_ptr->response_header.session_id;

    /* Find the provisioning application index for the session id */
    for (i = 0; i < QMI_UIM_MAX_PROV_SESSIONS; i++)
    {
      if (session_id == qmi_uim_global_ptr->mmgsdi_gw_session_id[i])
      {
        app_index = qmi_uim_global_ptr->card_state.index_gw[i];
        break;
      }
      else if (session_id == qmi_uim_global_ptr->mmgsdi_1x_session_id[i])
      {
        app_index = qmi_uim_global_ptr->card_state.index_1x[i];
        break;
      }
    }

    if (app_index < qmi_uim_global_ptr->card_state.num_apps &&
        app_index < QMI_UIM_MAX_APP_COUNT &&
        qmi_uim_global_ptr->card_state.application[app_index] != NULL)
    {
      UIM_MSG_HIGH_2("Updating PIN retries - index: 0x%x, id: 0x%x",
                     app_index, pin_cnf_ptr->pin_info.pin_id);

      /* Update PIN1 */
      if (pin_cnf_ptr->pin_info.pin_id == MMGSDI_PIN1 &&
          !qmi_uim_global_ptr->card_state.application[app_index]->upin)
      {
        if ((pin_cnf_ptr->pin_info.valid_num_retries) &&
            (qmi_uim_global_ptr->card_state.application[app_index]->pin1_num_retries !=
             (uint8)pin_cnf_ptr->pin_info.num_retries))
        {
          qmi_uim_global_ptr->card_state.application[app_index]->pin1_num_retries =
            (uint8)pin_cnf_ptr->pin_info.num_retries;
          result = TRUE;
        }
        if ((pin_cnf_ptr->pin_info.valid_num_unblock_retries) &&
            (qmi_uim_global_ptr->card_state.application[app_index]->puk1_num_retries !=
             (uint8)pin_cnf_ptr->pin_info.num_unblock_retries))
        {
          qmi_uim_global_ptr->card_state.application[app_index]->puk1_num_retries =
            (uint8)pin_cnf_ptr->pin_info.num_unblock_retries;
          result = TRUE;
        }
      }
      /* Update PIN2 */
      if (pin_cnf_ptr->pin_info.pin_id == MMGSDI_PIN2)
      {
        if ((pin_cnf_ptr->pin_info.valid_num_retries) &&
            (qmi_uim_global_ptr->card_state.application[app_index]->pin2_num_retries !=
             (uint8)pin_cnf_ptr->pin_info.num_retries))
        {
          qmi_uim_global_ptr->card_state.application[app_index]->pin2_num_retries =
            (uint8)pin_cnf_ptr->pin_info.num_retries;
          result = TRUE;
        }
        if ((pin_cnf_ptr->pin_info.valid_num_unblock_retries) &&
            (qmi_uim_global_ptr->card_state.application[app_index]->puk2_num_retries !=
             (uint8)pin_cnf_ptr->pin_info.num_unblock_retries))
        {
          qmi_uim_global_ptr->card_state.application[app_index]->puk2_num_retries =
            (uint8)pin_cnf_ptr->pin_info.num_unblock_retries;
          result = TRUE;
        }
      }
    }

    /* Other applications on the card might share the same PIN. Update the PIN
       retries and state for these applications as well. No need to set result,
       as it would have been set already for the current application, if needed. */
    if (pin_cnf_ptr->pin_info.pin_id == MMGSDI_PIN1)
    {
      qmi_uim_update_pin1_other_apps(&pin_cnf_ptr->pin_info,
                                     pin_cnf_ptr->response_header.slot_id,
                                     app_index);
    }
  }

  /* Unversal PIN */
  if (pin_cnf_ptr->pin_info.pin_id == MMGSDI_UNIVERSAL_PIN)
  {
    if (qmi_uim_mmgsdi_slot_to_slot_index(pin_cnf_ptr->response_header.slot_id,
                                          &slot_idx) != QMI_ERR_NONE)
    {
      return FALSE;
    }

    if(slot_idx >= QMI_UIM_MAX_CARD_COUNT ||
       slot_idx >= qmi_uim_global_ptr->card_state.num_slots ||
       qmi_uim_global_ptr->card_state.card[slot_idx] == NULL)
    {
      return FALSE;
    }

    UIM_MSG_HIGH_1("Updating UPIN retries - slot: 0x%x", slot_idx);

    /* Update UPIN retries for the card */
    if ((pin_cnf_ptr->pin_info.valid_num_retries) &&
        (qmi_uim_global_ptr->card_state.card[slot_idx]->upin_num_retries !=
         (uint8)pin_cnf_ptr->pin_info.num_retries))
    {
      qmi_uim_global_ptr->card_state.card[slot_idx]->upin_num_retries =
        (uint8)pin_cnf_ptr->pin_info.num_retries;
      result = TRUE;
    }
    if ((pin_cnf_ptr->pin_info.valid_num_unblock_retries) &&
        (qmi_uim_global_ptr->card_state.card[slot_idx]->upuk_num_retries !=
         (uint8)pin_cnf_ptr->pin_info.num_unblock_retries))
    {
      qmi_uim_global_ptr->card_state.card[slot_idx]->upuk_num_retries =
        (uint8)pin_cnf_ptr->pin_info.num_unblock_retries;
      result = TRUE;
    }
  }

  /* Update the PIN state for this app */
  if (qmi_uim_update_pin_state(pin_cnf_ptr->pin_info.pin_id,
                               pin_cnf_ptr->pin_info.status,
                               pin_cnf_ptr->pin_info.pin_replacement,
                               app_index, slot_idx))
  {
    result = TRUE;
  }

  return result;
} /* qmi_uim_update_pin_retries_and_state */


/*===========================================================================
  FUNCTION QMI_UIM_CONVERT_SIMLOCK_CATEGORY()

  DESCRIPTION
    Converts the SIM Lock category to MMGSDI feature type

  PARAMETERS
    category    : simlock category
    feature_ptr : response mmgsdi category

  RETURN VALUE
    TRUE on success. FALSE on failure

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_uim_convert_simlock_category
(
  simlock_category_enum_type        simlock_category,
  mmgsdi_perso_feature_enum_type  * mmgsdi_category_ptr
)
{
  ASSERT(mmgsdi_category_ptr);

  switch (simlock_category)
  {
    case SIMLOCK_CATEGORY_3GPP_NW:
      *mmgsdi_category_ptr = MMGSDI_PERSO_NW;
      break;
    case SIMLOCK_CATEGORY_3GPP_NS:
      *mmgsdi_category_ptr = MMGSDI_PERSO_NS;
      break;
    case SIMLOCK_CATEGORY_3GPP_SP:
      *mmgsdi_category_ptr = MMGSDI_PERSO_SP;
      break;
    case SIMLOCK_CATEGORY_3GPP_CP:
      *mmgsdi_category_ptr = MMGSDI_PERSO_CP;
      break;
    case SIMLOCK_CATEGORY_3GPP_SPN:
      *mmgsdi_category_ptr = MMGSDI_PERSO_SPN;
      break;
    case SIMLOCK_CATEGORY_3GPP_ICCID:
      *mmgsdi_category_ptr = MMGSDI_PERSO_ICCID;
      break;
    case SIMLOCK_CATEGORY_3GPP_SIM:
      *mmgsdi_category_ptr = MMGSDI_PERSO_SIM;
      break;
    case SIMLOCK_CATEGORY_3GPP2_NW_TYPE1:
      *mmgsdi_category_ptr = MMGSDI_PERSO_RUIM_NW1;
      break;
    case SIMLOCK_CATEGORY_3GPP2_NW_TYPE2:
      *mmgsdi_category_ptr = MMGSDI_PERSO_RUIM_NW2;
      break;
    case SIMLOCK_CATEGORY_3GPP2_HRPD:
      *mmgsdi_category_ptr = MMGSDI_PERSO_RUIM_HRPD;
      break;
    case SIMLOCK_CATEGORY_3GPP2_SP:
      *mmgsdi_category_ptr = MMGSDI_PERSO_RUIM_SP;
      break;
    case SIMLOCK_CATEGORY_3GPP2_CP:
      *mmgsdi_category_ptr = MMGSDI_PERSO_RUIM_CP;
      break;
    case SIMLOCK_CATEGORY_3GPP2_RUIM:
      *mmgsdi_category_ptr = MMGSDI_PERSO_RUIM_RUIM;
      break;
    default:
      UIM_MSG_ERR_1("Invalid SIM Lock category: 0x%x", simlock_category);
      *mmgsdi_category_ptr = MMGSDI_MAX_PERSO_FEATURE_ENUM;
      return FALSE;
  }

  return TRUE;
} /* qmi_uim_convert_simlock_category */


/*===========================================================================
  FUNCTION QMI_UIM_UPDATE_SIMLOCK_RETRIES()

  DESCRIPTION
    Updates the number of SIM Lock retries in the global card status after
    a failed perso operation

  PARAMETERS
    category    : category to update retries
    slot        : slot id corresponding to unlock request
    slot_policy : the current slot policy of the simlock
    retries     : new number of retries

  RETURN VALUE
    Boolean indicating if there was an update

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_uim_update_simlock_retries
(
  simlock_category_enum_type      category,
  simlock_slot_enum_type          slot,
  simlock_slot_policy_enum_type   slot_policy,
  uint32                          retries
)
{
  uint16                           i                 = 0;
  boolean                          result            = FALSE;
  mmgsdi_slot_id_enum_type         mmgsdi_slot_id    = MMGSDI_SLOT_1;
  mmgsdi_perso_feature_enum_type   feature           = MMGSDI_MAX_PERSO_FEATURE_ENUM;

  ASSERT(qmi_uim_global_ptr != NULL);

  UIM_MSG_MED_2("qmi_uim_update_simlock_retries, slot: 0x%x, slot_policy: 0x%x",
                slot, slot_policy);

  result = qmi_uim_convert_simlock_category(category, &feature);
  if (result == FALSE)
  {
    return result;
  }

  if(qmi_uim_simlock_slot_id_to_mmgsdi_slot_id(slot, &mmgsdi_slot_id) != QMI_ERR_NONE)
  {
    return FALSE;
  }

  for (i = 0; i < qmi_uim_global_ptr->card_state.num_apps &&
              i < QMI_UIM_MAX_APP_COUNT; i++)
  {
    if (qmi_uim_global_ptr->card_state.application[i] != NULL &&
        (qmi_uim_global_ptr->card_state.application[i]->app_state ==
          QMI_UIM_APP_STATE_PERSO ||
         qmi_uim_global_ptr->card_state.application[i]->app_state ==
          QMI_UIM_APP_STATE_READY) &&
        qmi_uim_global_ptr->card_state.application[i]->perso_feature == feature)
    {
      /* In this case, it is possible that each slot has a different
         lock configuration. So only apps belonging to a slot on which
         the unlock operation was performed are updated */
      if(slot_policy == SIMLOCK_SLOT_POLICY_UNIQUE_FOR_EACH_SLOT &&
         qmi_uim_global_ptr->card_state.application[i]->slot != mmgsdi_slot_id)
      {
        continue;
      }

      /* Update global status */
      if (qmi_uim_global_ptr->card_state.application[i]->perso_retries != retries)
      {
        qmi_uim_global_ptr->card_state.application[i]->perso_retries = retries;
        result = TRUE;
      }
    }
  }

  return result;
} /* qmi_uim_update_simlock_retries */


/*===========================================================================
  FUNCTION QMI_UIM_UPDATE_CARD_STATUS_VALIDITY()

  DESCRIPTION
    Updates the card status validity flag as a result of any of the incoming
     events from MMGSDI.

  PARAMETERS
    event_ptr : pointer to the event data

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_uim_update_card_status_validity
(
  const mmgsdi_event_data_type * event_ptr
)
{
  uint8                       slot_idx    = 0;
  boolean                     result      = FALSE;
  mmgsdi_slot_id_enum_type    mmsgdi_slot = MMGSDI_SLOT_1;

  ASSERT(event_ptr);
  ASSERT(qmi_uim_global_ptr);

  switch (event_ptr->evt)
  {
    case MMGSDI_CARD_INSERTED_EVT:
      mmsgdi_slot = event_ptr->data.card_inserted.slot;
      break;
    case MMGSDI_SESSION_CHANGED_EVT:
      mmsgdi_slot = event_ptr->data.session_changed.app_info.slot;
      break;
    case MMGSDI_PIN1_EVT:
    case MMGSDI_PIN2_EVT:
    case MMGSDI_UNIVERSAL_PIN_EVT:
      mmsgdi_slot = event_ptr->data.pin.slot;
      break;
    case MMGSDI_CARD_ERROR_EVT:
      mmsgdi_slot = event_ptr->data.card_error.slot;
      break;
    case MMGSDI_CARD_REMOVED_EVT:
      mmsgdi_slot = event_ptr->data.card_removed.slot;
      break;
    case MMGSDI_SUBSCRIPTION_READY_EVT:
      qmi_uim_session_id_to_slot(&mmsgdi_slot, event_ptr->session_id);
      break;
    default:
      /* Unhandled events are not used for checking validity */
      UIM_MSG_HIGH_1( "Unhandled Event 0x%x\n", event_ptr->evt);
      return FALSE;
  }

  if (qmi_uim_mmgsdi_slot_to_slot_index(mmsgdi_slot,
                                        &slot_idx) != QMI_ERR_NONE)
  {
    return FALSE;
  }

  if(slot_idx >= QMI_UIM_MAX_CARD_COUNT ||
     slot_idx >= qmi_uim_global_ptr->card_state.num_slots)
  {
    return FALSE;
  }

  /* Update the card status validity status */
  if (!qmi_uim_global_ptr->card_state_valid[slot_idx])
  {
    qmi_uim_global_ptr->card_state_valid[slot_idx] = TRUE;
    result = TRUE;
  }

  return result;
} /* qmi_uim_update_card_status_validity */


/*===========================================================================
  FUNCTION QMI_UIM_SEND_CARD_STATUS_INDICATION()

  DESCRIPTION
    This function sends a card status indication to a specific client

  PARAMETERS

  RETURN VALUE
    None.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_send_card_status_indication
(
  uint8                 clid,
  boolean               legacy_card_status,
  boolean               extended_card_status
)
{
  dsm_item_type* indication = NULL;

  ASSERT(clid != QMI_SVC_CLID_UNUSED);
  ASSERT(qmi_uim_global_ptr);

  /* Insert legacy card status item in TLV */
  if (legacy_card_status)
  {
    if (FALSE == qmi_uim_response_card_status(
                   UIMI_TLV_RESP_TAG_OPTIONAL_1,
                   &indication,
                   &qmi_uim_global_ptr->card_state))
    {
      /* Ignore error... there is nothing we can do about it.
         The event will not be delivered to the client */
      dsm_free_packet(&indication);
      return;
    }

    /* Insert the card status validity TLV */
    if (FALSE == qmi_uim_response_card_status_validity(
                   UIMI_TLV_RESP_TAG_OPTIONAL_2,
                   &indication,
                   (QMI_UIM_LEGACY_MAX_CARD_COUNT < qmi_uim_global_ptr->card_state.num_slots) ?
                    QMI_UIM_LEGACY_MAX_CARD_COUNT : qmi_uim_global_ptr->card_state.num_slots,
                   qmi_uim_global_ptr->card_state_valid))
    {
      UIM_MSG_HIGH_0("Error in constructing card_status_validity TLV");
    }
  }

  /* Insert extended card status item in TLV */
  if (extended_card_status)
  {
    if (FALSE == qmi_uim_response_extended_card_status(
                     UIMI_TLV_RESP_TAG_OPTIONAL_3,
                     &indication,
                     &qmi_uim_global_ptr->card_state,
                     sizeof(qmi_uim_global_ptr->card_state_valid),
                     qmi_uim_global_ptr->card_state_valid))
    {
      /* Ignore error... there is nothing we can do about it.
         The event will not be delivered to the client */
      dsm_free_packet(&indication);
      return;
    }
  }

  /* Send indication to the client */
  (void)qmi_uimi_send_indication(clid,
                                 (uint16)UIMI_CMD_VAL_CARD_STATUS_IND,
                                 indication);
} /* qmi_uim_send_card_status_indication */


/*===========================================================================
  FUNCTION QMI_UIM_SEND_CARD_STATUS_INDICATION_TO_ALL()

  DESCRIPTION
    This function sends a card status indication to all QMI_UIM clients

  PARAMETERS
    legacy_card_status_update      : if the indication should be sent only to
                                     clients registered for legacy card status
    send_only_to_postponed_clients : if the indication should be sent only to
                                     clients for which it was postponed earlier
    reduced_card_update_required   : if the indication should be sent only to
                                     clients registered for reduced card status indications

  RETURN VALUE
    None.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_send_card_status_indication_to_all
(
  boolean  legacy_card_status_update,
  boolean  send_only_to_postponed_clients,
  boolean  reduced_card_update_required
)
{
  uint8                       j     = 0;
  qmi_uimi_client_state_type* cl_sp = NULL;
  boolean                     legacy_card_status   = FALSE;
  boolean                     extended_card_status = FALSE;

  ASSERT(qmi_uim_global_ptr);

  if(qmi_uim_state_ptr == NULL)
  {
    return;
  }

  if (qmi_uim_global_ptr->block_card_status_ind)
  {
    UIM_MSG_HIGH_0("All card status indications are blocked");
    return;
  }

  for (j = 0; j < UIMI_MAX_CLIDS; j++)
  {
    legacy_card_status   = FALSE;
    extended_card_status = FALSE;

    cl_sp = (qmi_uimi_client_state_type*)qmi_uim_state_ptr->client[j];
    if(cl_sp == NULL)
    {
      continue;
    }
    if (cl_sp->uim_info.reg_event_type.card_status &&
         legacy_card_status_update )
    {
      legacy_card_status = TRUE;
    }
    if (cl_sp->uim_info.reg_event_type.extended_card_status)
    {
      extended_card_status = TRUE;
    }
    if ( cl_sp->common.clid != QMI_SVC_CLID_UNUSED &&
        (extended_card_status || legacy_card_status) )
    {
      if (qmi_uim_global_ptr->mmgsdi_card_slot_session_id[2] ==
          UIM_INVALID_SESSION_ID)
      {
        /* Postpone sending indication until card slot 3 (last card session
           to be opened) session id is valid. This ensures that card status
           indications are not sent to clients with card state PRESENT and
           clients don't send commands for card slot sessions when the sessions
           are not avaiable. */
        cl_sp->uim_info.card_status_ind_postponed = TRUE;
        UIM_MSG_HIGH_1("Postponing indication for client 0x%x",
                       cl_sp->common.clid);
        continue;
      }
      if (send_only_to_postponed_clients &&
          cl_sp->uim_info.card_status_ind_postponed == FALSE)
      {
        /* Send card status indication only to clients for which it was
           postponed earlier. */
        continue;
      }

      /* If the client registers for reduced card status indications and if
         this indication is not in the reduced set then dont send the indication
         to the client */
      if(cl_sp->uim_info.reg_event_type.reduced_card_status_events &&
         reduced_card_update_required == FALSE)
      {
        continue;
      }

      qmi_uim_send_card_status_indication(cl_sp->common.clid,
                                          legacy_card_status,
                                          extended_card_status);
    }
  }
} /* qmi_uim_send_card_status_indication_to_all */


/*===========================================================================
  FUNCTION QMI_UIM_SEND_SAP_STATUS_INDICATION()

  DESCRIPTION
    This function sends a SAP status indication to a specific client

  PARAMETERS
    clid   : Client ID
    slot   : Card slot

  RETURN VALUE
    None.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_send_sap_status_indication
(
  uint8                         clid,
  mmgsdi_slot_id_enum_type      slot
)
{
  dsm_item_type* indication = NULL;
  uint8          slot_idx   = 0;

  ASSERT(clid != QMI_SVC_CLID_UNUSED);
  ASSERT(qmi_uim_global_ptr);

  if (qmi_uim_mmgsdi_slot_to_slot_index(slot,
                                        &slot_idx) != QMI_ERR_NONE)
  {
    return;
  }

  if(slot_idx >= QMI_UIM_MAX_CARD_COUNT ||
     slot_idx >= qmi_uim_global_ptr->card_state.num_slots)
  {
    UIM_MSG_ERR_1("Invalid slot : 0x%x", slot);
    return;
  }

  /* Insert sap state & slot item in TLV */
  if (FALSE == qmi_uim_response_sap_event(
                   UIMI_TLV_RESP_TAG_OPTIONAL_1,
                   &indication,
                   qmi_uim_global_ptr->sap_info[slot_idx].is_enabled,
                   qmi_uim_global_ptr->sap_info[slot_idx].sap_state,
                   slot))
  {
    /* Ignore error... there is nothing we can do about it.
       The event will not be delivered to the client */
    dsm_free_packet(&indication);
    return;
  }

  /* Send indication to the client */
  (void)qmi_uimi_send_indication(clid,
                                 (uint16)UIMI_CMD_VAL_SAP_CONNECTION_IND,
                                 indication);
} /* qmi_uim_send_sap_status_indication */


/*===========================================================================
  FUNCTION QMI_UIM_SEND_SAP_STATUS_INDICATION_TO_ALL()

  DESCRIPTION
    This function sends a SAP status indication to all QMI_UIM clients

  PARAMETERS
    slot_id : Card slot

  RETURN VALUE
    None.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_send_sap_status_indication_to_all
(
  mmgsdi_slot_id_enum_type    slot_id
)
{
  uint8                         j           = 0;
  qmi_uimi_client_state_type  * cl_sp       = NULL;

  if(qmi_uim_state_ptr == NULL)
  {
    return;
  }

  for (j = 0; j < UIMI_MAX_CLIDS; j++)
  {
    cl_sp = (qmi_uimi_client_state_type*)qmi_uim_state_ptr->client[j];

    if ( cl_sp != NULL &&
         cl_sp->common.clid != QMI_SVC_CLID_UNUSED &&
         cl_sp->uim_info.reg_event_type.sap_events )
    {
      /* Send indication to specific client */
      qmi_uim_send_sap_status_indication(cl_sp->common.clid,
                                         slot_id);
    }
  }
} /* qmi_uim_send_sap_status_indication_to_all */


/*===========================================================================
  FUNCTION QMI_UIM_SEND_SIM_BUSY_INDICATION()

  DESCRIPTION
    This function sends a sim busy indication to a specific client.

  PARAMETERS
    clid   : Client ID

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_send_sim_busy_indication
(
  uint8                         clid
)
{
  dsm_item_type* indication = NULL;

  ASSERT(clid != QMI_SVC_CLID_UNUSED);
  ASSERT(qmi_uim_global_ptr);

  /* Insert sim busy state in TLV */
  if (FALSE == qmi_uim_response_sim_busy(
                   UIMI_TLV_RESP_TAG_OPTIONAL_1,
                   &indication,
                   &qmi_uim_global_ptr->card_state))
  {
    /* Ignore error... there is nothing we can do about it.
       The event will not be delivered to the client */
    dsm_free_packet(&indication);
    return;
  }

  /* Send indication to the client */
  (void)qmi_uimi_send_indication(clid,
                                 (uint16)UIMI_CMD_VAL_SIM_BUSY_IND,
                                 indication);
} /* qmi_uim_send_sim_busy_indication */


/*===========================================================================
  FUNCTION QMI_UIM_SEND_SIM_BUSY_INDICATION_TO_ALL()

  DESCRIPTION
    This function sends a sim busy indication to all QMI_UIM clients who have
    registered for sim busy indications.

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_send_sim_busy_indication_to_all
(
  void
)
{
  uint8                         j           = 0;
  qmi_uimi_client_state_type  * cl_sp       = NULL;

  if(qmi_uim_state_ptr == NULL)
  {
    return;
  }

  for (j = 0; j < UIMI_MAX_CLIDS; j++)
  {
    cl_sp = (qmi_uimi_client_state_type*)qmi_uim_state_ptr->client[j];

    /* Send sim busy if client requested for them during client registration
       (saved in reg_for_sim_busy_events flag) */
    if ( cl_sp != NULL &&
         cl_sp->common.clid != QMI_SVC_CLID_UNUSED &&
         cl_sp->uim_info.reg_event_type.sim_busy_events )
    {
      qmi_uim_send_sim_busy_indication(cl_sp->common.clid);
    }
  }
} /* qmi_uim_send_sim_busy_indication_to_all */


/*===========================================================================
  FUNCTION QMI_UIM_SEND_NON_PROV_SESSION_CLOSED_IND()

  DESCRIPTION
    This function sends a Session Closed Indication indication to the
    requested client ID.

  PARAMETERS
    clid    : Client ID
    slot_id : MMGSDI slot information
    aid_ptr : AID information

  RETURN VALUE
    None.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_send_non_prov_session_closed_ind
(
  uint8                                   clid,
  mmgsdi_slot_id_enum_type                slot,
  const mmgsdi_static_data_type         * aid_ptr,
  mmgsdi_session_closed_cause_enum_type   cause
)
{
  dsm_item_type * indication = NULL;

  ASSERT(clid != QMI_SVC_CLID_UNUSED);
  ASSERT(qmi_uim_global_ptr);
  ASSERT(aid_ptr);

  /* Insert the AID in the TLV */
  if (FALSE == qmi_uim_response_aid(
                 UIMI_TLV_RESP_TAG_OPTIONAL_1,
                 &indication,
                 aid_ptr))
  {
    /* Ignore error... there is nothing we can do about it.
       The event will not be delivered to the client */
    dsm_free_packet(&indication);
    return;
  }

  /* Insert card slot in TLV */
  if (FALSE == qmi_uim_response_slot(
                   UIMI_TLV_TAG_MANDATORY_1,
                   &indication,
                   slot))
  {
    /* Ignore error... there is nothing we can do about it.
       The event will not be delivered to the client */
    dsm_free_packet(&indication);
    return;
  }

  /* Insert the cause in the TLV. Indication is sent event
     if the cause TLV is not inserted */
  (void)qmi_uim_response_session_closed_cause(
                   UIMI_TLV_RESP_TAG_OPTIONAL_4,
                   &indication,
                   cause);

  /* Send indication to the client */
  (void)qmi_uimi_send_indication(clid,
                                 (uint16)UIMI_CMD_VAL_SESSION_CLOSED_IND,
                                 indication);
} /* qmi_uim_send_non_prov_session_closed_ind */


/*===========================================================================
  FUNCTION QMI_UIM_SEND_NON_PROV_SESSION_CLOSED_IND_TO_ALL()

  DESCRIPTION
    This function sends a Session Closed Indication indication to all clients
    which are associated with the non-prov. session being closed.

  PARAMETERS
    index : non-prov. session index in the global array
    cause : Cause for session closure

  RETURN VALUE
    None.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_send_non_prov_session_closed_ind_to_all
(
  uint16                                index,
  mmgsdi_session_closed_cause_enum_type cause
)
{
  uint16                          i            = 0;
  mmgsdi_slot_id_enum_type        slot         = MMGSDI_MAX_SLOT_ID_ENUM;
  qmi_uimi_client_state_type    * client_sp    = NULL;
  uint16                          client_count = 0;
  const mmgsdi_static_data_type * aid_ptr      = NULL;

  ASSERT(qmi_uim_global_ptr);

  if(index >= UIM_MAX_NON_PROV_SESSIONS)
  {
    return;
  }

  /* Retrieve the AID and slot info - to be sent as part of the Session
     Closed event */
  aid_ptr = &qmi_uim_global_ptr->non_prov_session[index].aid;

  switch(qmi_uim_global_ptr->non_prov_session[index].session_type)
  {
    case MMGSDI_NON_PROV_SESSION_SLOT_1:
      slot = MMGSDI_SLOT_1;
      break;
    case MMGSDI_NON_PROV_SESSION_SLOT_2:
      slot = MMGSDI_SLOT_2;
      break;
    case MMGSDI_NON_PROV_SESSION_SLOT_3:
      slot = MMGSDI_SLOT_3;
      break;
    default:
      return;
  }

  client_count = qmi_uim_global_ptr->non_prov_session[index].client_info.client_count;

  for (i = 0;
       (i < (uint16)UIM_MAX_NON_PROV_CLIENTS) && (client_count > 0);
       i++)
  {
    client_sp = qmi_uim_global_ptr->non_prov_session[index].client_info.opening_cl_sp[i];

    /* Check if the Client state is valid */
    if(client_sp == NULL)
    {
      continue;
    }

    client_count--;

    if (client_sp->common.clid != QMI_SVC_CLID_UNUSED)
    {
      /* Send indication to specific client */
      qmi_uim_send_non_prov_session_closed_ind(client_sp->common.clid,
                                               slot,
                                               aid_ptr,
                                               cause);
    }
  }
} /* qmi_uim_send_non_prov_session_closed_ind_to_all */


/*===========================================================================
  FUNCTION QMI_UIM_SEND_PROV_SESSION_CLOSED_IND()

  DESCRIPTION
    This function sends a Session Closed Indication indication to the
    requested client ID.

  PARAMETERS
    clid         : Client ID
    slot_id      : MMGSDI slot information
    session_type : Type of prov session
    cause        : Cause for session closure

  RETURN VALUE
    None.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_send_prov_session_closed_ind
(
  uint8                                  clid,
  mmgsdi_slot_id_enum_type               slot,
  mmgsdi_session_type_enum_type          session_type,
  mmgsdi_session_closed_cause_enum_type  cause
)
{
  dsm_item_type * indication = NULL;

  ASSERT(clid != QMI_SVC_CLID_UNUSED);
  ASSERT(qmi_uim_global_ptr);

  /* Insert card slot in TLV */
  if (FALSE == qmi_uim_response_slot(
                   UIMI_TLV_TAG_MANDATORY_1,
                   &indication,
                   slot))
  {
    /* Ignore error... there is nothing we can do about it.
       The event will not be delivered to the client */
    dsm_free_packet(&indication);
    return;
  }

  /* Insert the session in the TLV */
  if (FALSE == qmi_uim_response_session_type(
                 UIMI_TLV_RESP_TAG_OPTIONAL_3,
                 &indication,
                 session_type))
  {
    /* Ignore error... there is nothing we can do about it.
       The event will not be delivered to the client */
    dsm_free_packet(&indication);
    return;
  }

  /* Insert the cause in the TLV */
  if (FALSE == qmi_uim_response_session_closed_cause(
                 UIMI_TLV_RESP_TAG_OPTIONAL_4,
                 &indication,
                 cause))
  {
    /* Ignore error... there is nothing we can do about it.
       The event will not be delivered to the client */
    dsm_free_packet(&indication);
    return;
  }

  /* Insert the file_id in the TLV */
  if (FALSE == qmi_uim_response_session_closed_file_id(
                 UIMI_TLV_RESP_TAG_OPTIONAL_5,
                 &indication,
                 cause))
  {
    /* Ignore error... there is nothing we can do about it.
       The event will not be delivered to the client */
    dsm_free_packet(&indication);
    return;
  }

  /* Send indication to the client */
  (void)qmi_uimi_send_indication(clid,
                                 (uint16)UIMI_CMD_VAL_SESSION_CLOSED_IND,
                                 indication);
} /* qmi_uim_send_prov_session_closed_ind */


/*===========================================================================
  FUNCTION QMI_UIM_SEND_PROV_SESSION_CLOSED_IND_TO_ALL()

  DESCRIPTION
    This function sends a Session Closed Indication to all clients, who have
    registered for a provisioning session closed event

  PARAMETERS
    session_id : Session id associated with the prov. session
    slot       : MMGSDI slot information
    cause      : Cause for the session closure

  RETURN VALUE
    None.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_send_prov_session_closed_ind_to_all
(
  mmgsdi_session_id_type                session_id,
  mmgsdi_slot_id_enum_type              slot,
  mmgsdi_session_closed_cause_enum_type cause
)
{
  uint16                          i            = 0;
  qmi_uimi_client_state_type    * client_sp    = NULL;
  mmgsdi_session_type_enum_type   session_type = MMGSDI_GW_PROV_PRI_SESSION;
  qmi_error_e_type                result       = QMI_ERR_NONE;
  mmgsdi_static_data_type         aid;

  ASSERT(qmi_uim_state_ptr);

  memset(&aid, 0, sizeof(mmgsdi_static_data_type));

  /* Convert session id in session type */
  result = qmi_uim_session_id_to_session_type(&session_type,
                                              &aid,
                                              session_id);
  if (result != QMI_ERR_NONE)
  {
    return;
  }

  for (i = 0; i < UIMI_MAX_CLIDS; i++)
  {
    client_sp = (qmi_uimi_client_state_type*)qmi_uim_state_ptr->client[i];
    if(client_sp == NULL)
    {
      continue;
    }

    if ((client_sp->common.clid != QMI_SVC_CLID_UNUSED) &&
        (client_sp->uim_info.reg_event_type.prov_session_close_event))
    {
       /* Send indication to specific client */
       qmi_uim_send_prov_session_closed_ind(client_sp->common.clid,
                                            slot,
                                            session_type,
                                            cause);
    }
  }
} /* qmi_uim_send_prov_session_closed_ind_to_all */


/*===========================================================================
  FUNCTION QMI_UIM_SEND_SESSION_CLOSED_FOR_SESSIONS_ON_SLOT()

  DESCRIPTION
    This function sends a Session Closed Indication indication to all clients
    which are associated with all the sessions being closed for a slot

  PARAMETERS
    slot       : MMGSDI slot information
    cause      : Cause for the session closure

  RETURN VALUE
    None.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_send_session_closed_indication_for_sessions_on_slot
(
  mmgsdi_slot_id_enum_type               slot_id,
  mmgsdi_session_closed_cause_enum_type  cause
)
{
  uint16                         i                     = 0;
  mmgsdi_session_type_enum_type  non_prov_session_type = MMGSDI_NON_PROV_SESSION_SLOT_1;
  mmgsdi_slot_id_enum_type       prov_session_slot_id  = MMGSDI_SLOT_1;
  qmi_error_e_type               result                = QMI_ERR_NONE;

  ASSERT(qmi_uim_global_ptr);

  switch(slot_id)
  {
    case MMGSDI_SLOT_1:
      non_prov_session_type = MMGSDI_NON_PROV_SESSION_SLOT_1;
      break;
    case MMGSDI_SLOT_2:
      non_prov_session_type = MMGSDI_NON_PROV_SESSION_SLOT_2;
      break;
    case MMGSDI_SLOT_3:
      non_prov_session_type = MMGSDI_NON_PROV_SESSION_SLOT_3;
      break;
    default:
      return;
  }

  for (i = 0; i < QMI_UIM_MAX_PROV_SESSIONS; i++)
  {
    if(qmi_uim_global_ptr->mmgsdi_gw_session_id[i] != UIM_INVALID_SESSION_ID)
    {
      result = qmi_uim_session_id_to_slot(&prov_session_slot_id,
                                          qmi_uim_global_ptr->mmgsdi_gw_session_id[i]);
      if ((result == QMI_ERR_NONE) &&
          (prov_session_slot_id == slot_id))
      {
        qmi_uim_send_prov_session_closed_ind_to_all(
                      qmi_uim_global_ptr->mmgsdi_gw_session_id[i],
                      slot_id, cause);
      }
    }

    if(qmi_uim_global_ptr->mmgsdi_1x_session_id[i] != UIM_INVALID_SESSION_ID)
    {
      result = qmi_uim_session_id_to_slot(&prov_session_slot_id,
                                          qmi_uim_global_ptr->mmgsdi_1x_session_id[i]);
      if ((result == QMI_ERR_NONE) &&
          (prov_session_slot_id == slot_id))
      {
        qmi_uim_send_prov_session_closed_ind_to_all(
                      qmi_uim_global_ptr->mmgsdi_1x_session_id[i],
                      slot_id, cause);
      }
    }
  }

  for (i = 0; i < UIM_MAX_NON_PROV_SESSIONS; i++)
  {
    if (qmi_uim_global_ptr->non_prov_session[i].init &&
        qmi_uim_global_ptr->non_prov_session[i].mmgsdi_session_id != UIM_INVALID_SESSION_ID &&
        qmi_uim_global_ptr->non_prov_session[i].session_type == non_prov_session_type)
    {
      qmi_uim_send_non_prov_session_closed_ind_to_all(i, cause);
    }
  }

  for (i = 0; i < UIM_MAX_APDU_CHANNEL_COUNT; i++)
  {
    if (qmi_uim_global_ptr->apdu_channel[i] &&
        qmi_uim_global_ptr->apdu_channel[i]->slot == slot_id &&
        qmi_uim_global_ptr->apdu_channel[i]->mmgsdi_session_id != UIM_INVALID_SESSION_ID)
    {
      qmi_uim_send_apdu_session_closed_ind(i, cause);
    }
  }
}/* qmi_uim_send_session_closed_indication_for_sessions_on_slot */


/*===========================================================================
  FUNCTION QMI_UIM_SEND_SLOTS_STATUS_INDICATION()

  DESCRIPTION
    This function sends a slots status indication to a specific client

  PARAMETERS
    clid: ClientID

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_send_slots_status_indication
(
  uint8                 clid
)
{
  dsm_item_type* indication = NULL;

  ASSERT(clid != QMI_SVC_CLID_UNUSED);
  ASSERT(qmi_uim_global_ptr);

  /* Insert slots status item in TLV */
  if (FALSE == qmi_uim_response_physical_slots_status(
                 UIMI_TLV_RESP_TAG_OPTIONAL_1,
                 &indication,
                 qmi_uim_global_ptr->physical_slots_info.slot_status_ptr,
                 qmi_uim_global_ptr->physical_slots_info.num_slots))
  {
    /* Ignore error... there is nothing we can do about it.
       The event will not be delivered to the client */
    dsm_free_packet(&indication);
    return;
  }

  /* Send indication to the client */
  (void)qmi_uimi_send_indication(clid,
                                 (uint16)UIMI_CMD_VAL_SLOTS_STATUS_IND,
                                 indication);
} /* qmi_uim_send_slots_status_indication */


/*===========================================================================
  FUNCTION QMI_UIM_SEND_SLOTS_STATUS_INDICATION_TO_ALL()

  DESCRIPTION
    This function sends a slots status indication to all QMI_UIM clients

  PARAMETERS

  RETURN VALUE
    None.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_send_slots_status_indication_to_all
(
  void
)
{
  uint8                       j                       = 0;
  qmi_uimi_client_state_type* cl_sp                   = NULL;

  if(qmi_uim_state_ptr == NULL)
  {
    return;
  }

  for (j = 0; j < UIMI_MAX_CLIDS; j++)
  {
    cl_sp = (qmi_uimi_client_state_type*)qmi_uim_state_ptr->client[j];
    if (cl_sp != NULL &&
        cl_sp->common.clid != QMI_SVC_CLID_UNUSED &&
        cl_sp->uim_info.reg_event_type.physical_slots_status)
    {
      /* Send indication to specific client */
      qmi_uim_send_slots_status_indication(cl_sp->common.clid);
    }
  }
} /* qmi_uim_send_slots_status_indication_to_all */


/*===========================================================================
  FUNCTION QMI_UIM_SEND_RECOVERY_COMPLETE_INDICATION()

  DESCRIPTION
    This function sends a recovery complete indication to a specific client.

  PARAMETERS
    clid   : Client ID
    slot   : Slot of cooresponding of recovery

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_send_recovery_complete_indication
(
  uint8                         clid,
  mmgsdi_slot_id_enum_type      slot
)
{
  dsm_item_type               * indication   = NULL;

  ASSERT(clid != QMI_SVC_CLID_UNUSED);
  ASSERT(qmi_uim_global_ptr);

  /* Insert recovery slot in TLV */
  if (FALSE == qmi_uim_response_slot(
                   UIMI_TLV_IND_TAG_MANDATORY_1,
                   &indication,
                   slot))
  {
    /* Ignore error... there is nothing we can do about it.
       The event will not be delivered to the client */
    dsm_free_packet(&indication);
    return;
  }

  /* Send indication to the client */
  (void)qmi_uimi_send_indication(clid,
                                 (uint16)UIMI_CMD_VAL_RECOVERY_COMPLETE_IND,
                                 indication);
} /* qmi_uim_send_recovery_complete_indication */


/*===========================================================================
  FUNCTION QMI_UIM_SEND_RECOVERY_COMPLETE_INDICATION_TO_ALL()

  DESCRIPTION
    This function processes the recovery complete indication from UIM drivers.
    It passes indicates that recovery has completed successfully to all registered
    QMI clients.

  PARAMETERS
    slot : slot in which the recovery was performed

  RETURN VALUE
    None

  DEPENDENCIES
    QMI UIM must already have been initialized and registered with Framework

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_send_recovery_complete_indication_to_all
(
  mmgsdi_slot_id_enum_type  slot
)
{
  uint8                         i           = 0;
  qmi_uimi_client_state_type  * cl_sp       = NULL;

  UIM_MSG_HIGH_1("qmi_uim_send_recovery_complete_indication_to_all: slot = 0x%x",
                 slot);

  if(qmi_uim_state_ptr == NULL)
  {
    return;
  }

  for (i = 0; i < UIMI_MAX_CLIDS; i++)
  {
    cl_sp = (qmi_uimi_client_state_type*)qmi_uim_state_ptr->client[i];

    /* Send recovery complete indication if client requested for them
       during client registration (saved in reg_for_recovery_complete_event flag) */
    if ( cl_sp != NULL &&
         cl_sp->common.clid != QMI_SVC_CLID_UNUSED &&
         cl_sp->uim_info.reg_event_type.recovery_complete_event )
    {
      qmi_uim_send_recovery_complete_indication(cl_sp->common.clid, slot);
    }
  }
} /* qmi_uim_send_recovery_complete_indication_to_all */


/*===========================================================================
  FUNCTION QMI_UIM_PROCESS_RECOVERY_COMPLETE()

  DESCRIPTION
    This function processes the recovery complete indication from UIM drivers.
    It passes indicates that recovery has completed successfully to all registered
    QMI clients and QMI CAT.

  PARAMETERS
    slot : slot in which the recovery was performed

  RETURN VALUE
    None

  DEPENDENCIES
    QMI UIM must already have been initialized and registered with Framework

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_process_recovery_complete
(
  uim_slot_type        slot
)
{
  mmgsdi_slot_id_enum_type      mmgsdi_slot = MMGSDI_MAX_SLOT_ID_ENUM;

  UIM_MSG_HIGH_1("qmi_uim_process_recovery_complete: uim slot = 0x%x", slot);

  if(qmi_uim_state_ptr == NULL)
  {
    return;
  }

  /* Convert uim_slot_type to mmgsdi_slot_id_enum_type */
  if(qmi_uim_uim_slot_id_to_mmgsdi_slot_id(slot, &mmgsdi_slot) != QMI_ERR_NONE)
  {
    return;
  }

  /* Notify QMI CAT */
  qmi_cat_recovery_complete(mmgsdi_slot);

  /* Notify QMI UIM clients */
  qmi_uim_send_recovery_complete_indication_to_all(mmgsdi_slot);
} /* qmi_uim_process_recovery_complete */


/*===========================================================================
  FUNCTION QMI_UIM_SEND_ACTIVATION_STATUS_INDICATION()

  DESCRIPTION
    This function sends card activation status indication to a specific client.

  PARAMETERS
    clid              : Client ID
    mmgsdi_slot       : Slot of cooresponding of recovery
    gstk_otasp_status : Status of OTASP activation from GSTK

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_send_activation_status_indication
(
  uint8                         clid,
  mmgsdi_slot_id_enum_type      mmgsdi_slot,
  gstk_otasp_act_status_enum_type   gstk_otasp_status
)
{
  dsm_item_type               * indication   = NULL;

  ASSERT(clid != QMI_SVC_CLID_UNUSED);
  ASSERT(qmi_uim_global_ptr);

  /* Insert OTASP activation slot in TLV */
  if (FALSE == qmi_uim_response_slot(
                   UIMI_TLV_IND_TAG_MANDATORY_1,
                   &indication,
                   mmgsdi_slot))
  {
    /* Ignore error... there is nothing we can do about it.
       The event will not be delivered to the client */
    dsm_free_packet(&indication);
    return;
  }

  /* Insert OTASP status in TLV */
  if (FALSE == qmi_uim_response_activation_status(
                   UIMI_TLV_IND_TAG_MANDATORY_2,
                   &indication,
                   gstk_otasp_status))
  {
    /* Ignore error... there is nothing we can do about it.
       The event will not be delivered to the client */
    dsm_free_packet(&indication);
    return;
  }

  /* Send indication to the client */
  (void)qmi_uimi_send_indication(clid,
                                 (uint16)UIMI_CMD_VAL_CARD_ACTIVATION_STATUS_IND,
                                 indication);
} /* qmi_uim_send_activation_status_indication */


/*===========================================================================
  FUNCTION QMI_UIM_SEND_ACTIVATION_STATUS_INDICATION_TO_ALL()

  DESCRIPTION
    This function indicates card activation status to all registered QMI clients.

  PARAMETERS
     uim_message_ptr : message to the internal qmi_uim_message
                      containing an external command

  RETURN VALUE
    None

  DEPENDENCIES
    QMI UIM must already have been initialized and registered with Framework

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_send_activation_status_indication_to_all
(
  mmgsdi_slot_id_enum_type      mmgsdi_slot,
  gstk_otasp_act_status_enum_type   gstk_otasp_status
)
{
  uint8                        client_index = 0;
  qmi_uimi_client_state_type  *cl_sp        = NULL;

  UIM_MSG_HIGH_0("qmi_uim_send_activation_status_indication_to_all");

  for (client_index = 0; client_index < UIMI_MAX_CLIDS; client_index++)
  {
    cl_sp = (qmi_uimi_client_state_type*)qmi_uim_state_ptr->client[client_index];

    /* Send OTASP status indication if client requested for them
       during client registration */
    if ( cl_sp != NULL &&
         cl_sp->common.clid != QMI_SVC_CLID_UNUSED &&
         cl_sp->uim_info.reg_event_type.reg_for_activation_status_event)
    {
      qmi_uim_send_activation_status_indication(cl_sp->common.clid,
                                                mmgsdi_slot,
                                                gstk_otasp_status);
    }
  }
} /* qmi_uim_send_activation_status_indication_to_all */


/*===========================================================================
  FUNCTION QMI_UIM_PROCESS_OTASP_STATUS_INDICATION

  DESCRIPTION
    This function processes the OTASP status indication from GSTK. It indicates
    that the card activation status to all registered QMI clients.

  PARAMETERS
     uim_message_ptr : message to the internal qmi_uim_message
                      containing an external command

  RETURN VALUE
    None

  DEPENDENCIES
    QMI UIM must already have been initialized and registered with Framework

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_process_otasp_status_indication
(
  qmi_uim_message_type * uim_message_ptr
)
{
  mmgsdi_slot_id_enum_type     mmgsdi_slot  = MMGSDI_MAX_SLOT_ID_ENUM;

  UIM_MSG_HIGH_0("qmi_uim_process_otasp_status_indication");

  ASSERT(uim_message_ptr);

  if(qmi_uim_gstk_slot_id_to_mmgsdi_slot_id(uim_message_ptr->data.otasp_status_ind.slot,
                                            &mmgsdi_slot) != QMI_ERR_NONE)
  {
    return;
  }

  qmi_uim_send_activation_status_indication_to_all(mmgsdi_slot,
                                                   uim_message_ptr->data.otasp_status_ind.status);
} /* qmi_uim_process_otasp_status_indication */


/*===========================================================================
  FUNCTION QMI_UIM_SEND_SUPPLY_VOLTAGE_INDICATION()

  DESCRIPTION
    This function sends a supply voltage indication to a specific client.

  PARAMETERS
    clid      : Client ID
    slot      : Slot of cooresponding supply voltage change
    ldo_state : Current LDO state to be notified

  RETURN VALUE
    qmi_error_e_type

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_send_supply_voltage_indication
(
  uint8                           clid,
  mmgsdi_slot_id_enum_type        mmgsdi_slot,
  uimdrv_qmi_indications_type     ldo_state
)
{
  dsm_item_type               * indication   = NULL;

  ASSERT(clid != QMI_SVC_CLID_UNUSED);
  ASSERT(qmi_uim_global_ptr);

  /* Insert slot in TLV */
  if (FALSE == qmi_uim_response_slot(
                   UIMI_TLV_IND_TAG_MANDATORY_1,
                   &indication,
                   mmgsdi_slot))
  {
    /* Ignore error... there is nothing we can do about it.
       The event will not be delivered to the client */
    dsm_free_packet(&indication);
    return QMI_ERR_INTERNAL;
  }

  /* Insert ldo_state in TLV */
  if (FALSE == qmi_uim_response_vcc_state(
                   UIMI_TLV_IND_TAG_MANDATORY_2,
                   &indication,
                   ldo_state))
  {
    /* Ignore error... there is nothing we can do about it.
       The event will not be delivered to the client */
    dsm_free_packet(&indication);
    return QMI_ERR_INTERNAL;
  }

  /* Send indication to the client */
  if(FALSE == qmi_uimi_send_indication(clid,
                                       (uint16)UIMI_CMD_VAL_SUPPLY_VOLTAGE,
                                       indication))
  {
    return QMI_ERR_INTERNAL;
  }

  return QMI_ERR_NONE;
} /* qmi_uim_send_supply_voltage_indication */


/*===========================================================================
  FUNCTION QMI_UIM_SEND_SUPPLY_VOLTAGE_INDICATION_TO_ALL()

  DESCRIPTION
    This function will send the supply voltage indication to all registered
    clients.

  PARAMETERS
    uim_message_ptr: QMI UIM message

  RETURN VALUE
    None

  DEPENDENCIES
    QMI UIM must already have been initialized and registered with Framework

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_send_supply_voltage_indication_to_all
(
  const qmi_uim_message_type * uim_message_ptr
)
{
  uint8                                         i                = 0;
  qmi_uimi_client_state_type                  * cl_sp            = NULL;
  uint8                                         slot_idx         = 0;
  mmgsdi_slot_id_enum_type                      mmgsdi_slot      = MMGSDI_MAX_SLOT_ID_ENUM;
  qmi_error_e_type                              errval           = QMI_ERR_NONE;

  if(qmi_uim_state_ptr == NULL ||
     uim_message_ptr == NULL)
  {
    return;
  }

  UIM_MSG_HIGH_1("qmi_uim_send_supply_voltage_indication_to_all: slot = 0x%x",
                 uim_message_ptr->data.supply_voltage.slot);

  errval = qmi_uim_uim_slot_id_to_mmgsdi_slot_id(uim_message_ptr->data.supply_voltage.slot,
                                                 &mmgsdi_slot);
  if (errval != QMI_ERR_NONE)
  {
    return;
  }

  if (qmi_uim_mmgsdi_slot_to_slot_index(mmgsdi_slot,
                                        &slot_idx) != QMI_ERR_NONE)
  {
    return;
  }

  switch (uim_message_ptr->data.supply_voltage.ldo_state)
  {
    case UIMDRV_LDO_ACTIVATED_IND:
      qmi_uim_global_ptr->supply_voltage_cb[slot_idx] = NULL;
      break;
    case UIMDRV_LDO_AWAITING_DEACTIVATION_IND:
      qmi_uim_global_ptr->supply_voltage_cb[slot_idx] =
        uim_message_ptr->data.supply_voltage.uim_callback;
      break;
    default:
      UIM_MSG_ERR_1("Invalid LDO state: 0x%x",
                    uim_message_ptr->data.supply_voltage.ldo_state);
      return;
  }

  /* After saving the supply voltage callback, we need to clear the supply voltage acknowledgement
     bit indicating that none of the clients have sent acknowledgments just in case accidentally
     any client did not vote in the previous Vcc deactivation. */
  for (i = 0; i < UIMI_MAX_CLIDS; i++)
  {
    cl_sp = (qmi_uimi_client_state_type*)qmi_uim_state_ptr->client[i];
    if(cl_sp == NULL)
    {
      continue;
    }

    cl_sp->uim_info.supply_voltage_pending_ack[slot_idx] = FALSE;

    /* Send supply voltage indication if client requested for them during client event
       registration (saved in reg_event_type.supply_voltage_events flag) */
    if ( cl_sp->common.clid != QMI_SVC_CLID_UNUSED &&
         cl_sp->uim_info.reg_event_type.supply_voltage_events)
    {
      errval = qmi_uim_send_supply_voltage_indication(
                   cl_sp->common.clid,
                   mmgsdi_slot,
                   uim_message_ptr->data.supply_voltage.ldo_state);

      if(uim_message_ptr->data.supply_voltage.ldo_state == UIMDRV_LDO_AWAITING_DEACTIVATION_IND &&
         errval == QMI_ERR_NONE)
      {
        cl_sp->uim_info.supply_voltage_pending_ack[slot_idx] = TRUE;
      }
    }
  }
} /* qmi_uim_send_supply_voltage_indication_to_all */


/*===========================================================================
  FUNCTION QMI_UIM_SIMLOCK_SEND_REMOTE_SFS_OPERATION_INDICATION()

  DESCRIPTION
    This function sends a simlock operation indication to a specific client.

  PARAMETERS
    clid           : Client ID
    uim_message_ptr: QMI UIM message

  RETURN VALUE
    qmi_error_e_type

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_simlock_send_remote_sfs_operation_indication
(
  uint8                           clid,
  const qmi_uim_message_type    * uim_message_ptr
)
{
  dsm_item_type               * indication   = NULL;

  ASSERT(clid != QMI_SVC_CLID_UNUSED);
  ASSERT(uim_message_ptr);

  /* Insert the indication payload in TLV */
  if (FALSE == qmi_uim_simlock_remote_sfs_encrypted_ind(
                   UIMI_CMD_VAL_SIMLOCK_CONFIGURATION,
                   uim_message_ptr->data.simlock_remote_sfs_req.operation,
                   uim_message_ptr->data.simlock_remote_sfs_req.request_token_id,
                   uim_message_ptr->data.simlock_remote_sfs_req.file,
                   uim_message_ptr->data.simlock_remote_sfs_req.simlock_data,
                   &indication))
  {
    /* Ignore error... there is nothing we can do about it.
       The event will not be delivered to the client */
    dsm_free_packet(&indication);
    return QMI_ERR_INTERNAL;
  }

  /* Send indication to the client */
  if(FALSE == qmi_uimi_send_indication(clid,
                                       (uint16)UIMI_CMD_VAL_SIMLOCK_CONFIGURATION,
                                       indication))
  {
    return QMI_ERR_INTERNAL;
  }

  return QMI_ERR_NONE;
} /* qmi_uim_simlock_send_remote_sfs_operation_indication */


/*===========================================================================
  FUNCTION QMI_UIM_SIMLOCK_SEND_REMOTE_SFS_OPERATION_INDICATION_TO_ALL()

  DESCRIPTION
    This function will send the simlock data operation indication to all
    registered clients.

  PARAMETERS
    uim_message_ptr: QMI UIM message

  RETURN VALUE
    TRUE  : If indication is sent to at least one client
    FALSE : If otherwise

  DEPENDENCIES
    QMI UIM must already have been initialized and registered with Framework

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_uim_simlock_send_remote_sfs_operation_indication_to_all
(
  const qmi_uim_message_type * uim_message_ptr
)
{
  uint8                              i               = 0;
  qmi_uimi_client_state_type       * cl_sp           = NULL;
  qmi_error_e_type                   errval          = QMI_ERR_NONE;
  boolean                            indication_sent = FALSE;

  if((qmi_uim_state_ptr == NULL) ||
     (uim_message_ptr == NULL))
  {
    return FALSE;
  }

  UIM_MSG_HIGH_0("qmi_uim_simlock_send_remote_sfs_operation_indication_to_all");

  for (i = 0; i < UIMI_MAX_CLIDS; i++)
  {
    cl_sp = (qmi_uimi_client_state_type*)qmi_uim_state_ptr->client[i];
    if(cl_sp == NULL)
    {
      continue;
    }

    /* Send simlock remote SFS indication if client requested for them during client event
       registration (saved in reg_event_type.simlock_remote_sfs_events flag) */
    if (cl_sp->common.clid != QMI_SVC_CLID_UNUSED &&
        cl_sp->uim_info.reg_event_type.simlock_remote_sfs_events)
    {
      errval = qmi_uim_simlock_send_remote_sfs_operation_indication(
                   cl_sp->common.clid,
                   uim_message_ptr);
      if ((errval == QMI_ERR_NONE) &&
          (!indication_sent))
      {
        indication_sent = TRUE;
      }
    }
  }

  return indication_sent;
} /* qmi_uim_simlock_send_remote_sfs_operation_indication_to_all */


/*===========================================================================
  FUNCTION QMI_UIM_CHECK_AND_UPDATE_IF_SEND_TEMPORARY_UNLOCK_STATUS_CHANGED()

  DESCRIPTION
    This function will check if the temporary unlock status is changed.
        It compares the temporary unlock status received from SIMLOCK against the one
        maintained at QMI UIM.If atleast a single feature's temporary unlock status is
    changed then this function would return TRUE.Also, it would update the QMI UIM
    global maintaining the temp unlock status.

  PARAMETERS
    get_status_resp_ptr  : Pointer to the get status response received from SIMLOCK

  RETURN VALUE
    TRUE  : If status is changed
    FALSE : If otherwise

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_uim_check_and_update_if_simlock_temporary_unlock_status_changed(
  const simlock_get_status_msg_resp_type  *get_status_ptr
)
{
  boolean          send_ind     = FALSE;
  uint8            i            = 0;
  uint8            j            = 0;
  uint8            slot_cnt     = 0;

  ASSERT(get_status_ptr);

  slot_cnt = MIN(qmi_uim_global_ptr->card_state.num_slots, QMI_UIM_MAX_CARD_COUNT);

  for (i = 0;
       i < SIMLOCK_SLOT_COUNT_MAX && i < slot_cnt;
       i++)
  {
    /* Check the features that are active and insert the
       corresponding feature id and time left in the TLV data */
    for(j = 0;
        j < SIMLOCK_CATEGORY_COUNT_MAX && j < QMI_UIM_MAX_NUMBER_PERSO_FEATURES;
        j++)
    {
      if ((get_status_ptr->lock_info[i].category_info[j].category_status) &&
          (get_status_ptr->remaining_time.duration[i][j] > 0))
      {
        if(qmi_uim_global_ptr->temp_unlock_info[i][j] == FALSE)
        {
          /* A new feature is found to be temporarily unlocked.
             Need to send indication to client */
            send_ind = TRUE;
            qmi_uim_global_ptr->temp_unlock_info[i][j] = TRUE;
          }
        }
      else
      {
        if(qmi_uim_global_ptr->temp_unlock_info[i][j])
        {
          /* Temporary unlock for a feature seem to be expired.
             Need to send indication to client */
            send_ind = TRUE;
            qmi_uim_global_ptr->temp_unlock_info[i][j] = FALSE;
        }
      }
    }
  }

  UIM_MSG_MED_1("qmi_uim_check_and_update_if_simlock_temporary_unlock_status_changed "
                "send_ind is 0x%x", send_ind);

  return TRUE;
}/* qmi_uim_check_and_update_if_simlock_temporary_unlock_status_changed */


/*===========================================================================
  FUNCTION QMI_UIM_SEND_TEMPORARY_UNLOCK_INDICATION()

  DESCRIPTION
    This function sends a temporary unlock  indication to a specific client.

  PARAMETERS
    clid           : Client ID
    uim_message_ptr: QMI UIM message

  RETURN VALUE
    qmi_error_e_type

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_send_temporary_unlock_indication
(
  uint8                                    clid,
  const simlock_get_status_msg_resp_type  *get_status_ptr
)
{
  dsm_item_type               * indication = NULL;

  ASSERT(clid != QMI_SVC_CLID_UNUSED);
  ASSERT(get_status_ptr);

  /* Insert the indication payload in TLV */
  if (FALSE == qmi_uim_response_temporary_unlock_status(UIMI_TLV_IND_TAG_MANDATORY_1,
                                                        &indication,
                                                        get_status_ptr,
                                                        qmi_uim_global_ptr->card_state.num_slots))
  {
    /* Ignore error... there is nothing we can do about it.
       The event will not be delivered to the client */
    UIM_MSG_MED_1("qmi_uim_response_temporary_unlock_status failed. No ind sent to client 0x%x", clid);
    dsm_free_packet(&indication);
    return QMI_ERR_INTERNAL;
  }

  /* Send indication to the client */
  if(FALSE == qmi_uimi_send_indication(clid,
                                       (uint16)UIMI_CMD_VAL_TEMPORARY_UNLOCK_STATUS_IND,
                                       indication))
  {
    return QMI_ERR_INTERNAL;
  }

  return QMI_ERR_NONE;
} /* qmi_uim_send_temporary_unlock_indication */


/*===========================================================================
  FUNCTION QMI_UIM_SEND_TEMPORARY_UNLOCK_INDICATION_TO_ALL()

  DESCRIPTION
    This function will send the temporary unlock indication to all
    registered clients.

  PARAMETERS
    get_status_ptr: Pointer to get status response received from SIMLOCK

  RETURN VALUE
    None

  DEPENDENCIES
    QMI UIM must already have been initialized and registered with Framework

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_send_temporary_unlock_indication_to_all
(
  const simlock_get_status_msg_resp_type *get_status_ptr
)
{
  uint8                              i               = 0;
  qmi_uimi_client_state_type       * cl_sp           = NULL;
  qmi_error_e_type                   errval          = QMI_ERR_NONE;

  if(qmi_uim_state_ptr == NULL ||
     get_status_ptr == NULL)
  {
    return;
  }

  UIM_MSG_HIGH_0("NEW STV qmi_uim_send_temporary_unlock_indication_to_all");

  for (i = 0; i < UIMI_MAX_CLIDS; i++)
  {
    cl_sp = (qmi_uimi_client_state_type*)qmi_uim_state_ptr->client[i];
    if(cl_sp == NULL)
    {
      continue;
    }

    /* Send temporary unlock indication if client requested for them during client event
       registration (saved in reg_event_type.simlock_temp_unlock_status flag) */
    if (cl_sp->common.clid != QMI_SVC_CLID_UNUSED &&
        cl_sp->uim_info.reg_event_type.simlock_temp_unlock_status)
    {
      errval = qmi_uim_send_temporary_unlock_indication(
                   cl_sp->common.clid,
                   get_status_ptr);
      }
    }
} /* qmi_uim_send_temporary_unlock_indication_to_all */


/*===========================================================================
  FUNCTION QMI_UIM_INTERNAL_ERROR_RESP()

  DESCRIPTION
    Composes the error response with internal error code. This function
    is used only to send internal errors in asynchronous case. In most
    cases, the handler of each MMGSDI confirmation takes care of it,
    but this function is useful in case there is an error opening a non
    provisioning sessions: in this case, the intended MMGSDI function
    (read, write, PIN,...) is not executed at all because the session
    does not exists, but a response to QMI client is still required.

  PARAMETERS
    cmd_buf_ptr : pointer to command buffer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_internal_error_resp
(
  qmi_cmd_buf_type *  cmd_buf_ptr
)
{
  dsm_item_type *         response  = NULL;
  boolean                 retval    = TRUE;

  ASSERT(cmd_buf_ptr);

  QMI_UIM_VALIDATE_SP_IN_CMD_BUF(cmd_buf_ptr);

  /* Insert result item in the TLV */
  retval = qmi_svc_put_result_tlv(&response, QMI_RESULT_FAILURE, QMI_ERR_INTERNAL);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    ds_qmi_fw_free_cmd_buf( &cmd_buf_ptr );
    return;
  }

  /* Send response */
  if (FALSE == qmi_uimi_send_response(cmd_buf_ptr,
                                      response))
  {
    UIM_MSG_HIGH_0("Unable to send internal error response");
    dsm_free_packet(&response);
  }
} /* qmi_uim_internal_error_resp */


/*===========================================================================
  FUNCTION QMI_UIM_INTERNAL_SUCCESS_RESP()

  DESCRIPTION
    Composes the success response for those commands that only require
    the status in the response and no other TLVs. This function
    is used only to send success in asynchronous case. In most
    cases, the handler of each MMGSDI confirmation takes care of it,
    but this function is useful in case there is an error opening a non
    provisioning sessions.

  PARAMETERS
    cmd_buf_ptr : pointer to command buffer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_internal_success_resp
(
  qmi_cmd_buf_type *  cmd_buf_ptr
)
{
  dsm_item_type *         response  = NULL;
  boolean                 retval    = TRUE;

  ASSERT(cmd_buf_ptr);

  QMI_UIM_VALIDATE_SP_IN_CMD_BUF(cmd_buf_ptr);

  /* Insert result item in the TLV */
  retval = qmi_svc_put_result_tlv(&response, QMI_RESULT_SUCCESS, QMI_ERR_NONE);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    ds_qmi_fw_free_cmd_buf( &cmd_buf_ptr );
    return;
  }

  /* Send response */
  if (FALSE == qmi_uimi_send_response(cmd_buf_ptr,
                                      response))
  {
    UIM_MSG_HIGH_0("Unable to send internal success response");
    dsm_free_packet(&response);
  }
} /* qmi_uim_internal_success_resp */


/*===========================================================================
  FUNCTION QMI_UIM_PENDING_REQ_ERROR_IND()

  DESCRIPTION
    Composes the error indications for those commands that are pending an
    indication but could not be processed for some reason and hence we
    need to send an error indication to the client

  PARAMETERS
    request_ptr : pointer to the pending request type

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_pending_req_error_ind (
  const qmi_uimi_pending_request_type    * request_ptr
)
{
  uint8                           i                        = 0;
  qmi_uim_tlv_uint32_type       * ind_token_ptr            = NULL;
  dsm_item_type                 * response_ptr             = NULL;

  ASSERT(request_ptr != NULL);

  /* Find the token that came as part of the request */
  for (i = 0; i < request_ptr->tlv_data_count; i++)
  {
    if (!request_ptr->tlv_data_ptr[i].present)
    {
      continue;
    }

    switch (request_ptr->tlv_data_ptr[i].type)
    {
      case UIMI_TLV_TYPE_IND_TOKEN:
        ind_token_ptr = &request_ptr->tlv_data_ptr[i].data.ind_token;
        break;
      default:
        break;
    }
  }

  if (ind_token_ptr == NULL)
  {
    UIM_MSG_LOW_0("Could not find token, not sending indication");
    return;
  }

  if (FALSE == qmi_uim_response_ind_token(UIMI_TLV_IND_TAG_MANDATORY_1,
                                          &response_ptr,
                                          ind_token_ptr->value))
  {
    UIM_MSG_LOW_0("Could not insert ind_token TLV, not sending indication");
    dsm_free_packet(&response_ptr);
    return;
  }

  if (FALSE == qmi_svc_put_result_tlv(&response_ptr,
                                      QMI_RESULT_FAILURE,
                                      QMI_ERR_INTERNAL))
  {
    dsm_free_packet(&response_ptr);
    return;
  }

  if (FALSE == qmi_uimi_send_indication(request_ptr->clid,
                                       (uint16)request_ptr->command_id,
                                       response_ptr))
  {
    UIM_MSG_LOW_0("Unable to send error indication for pending req");
    dsm_free_packet(&response_ptr);
  }
} /* qmi_uim_pending_req_error_ind */


/*===========================================================================
  FUNCTION QMI_UIM_EXECUTE_PENDING_REQUEST()

  DESCRIPTION
    Executes a specific pending requests for a non provisionin application.

  PARAMETERS
    request_ptr : pointer to the pending request
    session_id  : session id

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_execute_pending_request
(
  const qmi_uimi_pending_request_type * request_ptr,
  mmgsdi_session_id_type                session_id
)
{
  uint8                                      i                        = 0;
  qmi_error_e_type                           errval                   = QMI_ERR_NONE;
  qmi_uim_requested_encrytion_type           encryption_status        = QMI_UIM_NO_ENCRYPTION;
  mmgsdi_access_type                         mmgsdi_access;
  qmi_uim_tlv_file_id_type *                 file_id_ptr              = NULL;
  qmi_uim_tlv_read_transparent_type *        read_transparent_ptr     = NULL;
  qmi_uim_tlv_read_record_type *             read_record_ptr          = NULL;
  qmi_uim_tlv_write_transparent_type *       write_transparent_ptr    = NULL;
  qmi_uim_tlv_write_record_type *            write_record_ptr         = NULL;
  qmi_uim_tlv_set_pin_protection_type *      set_pin_protection_ptr   = NULL;
  qmi_uim_tlv_verify_pin_type *              verify_pin_ptr           = NULL;
  qmi_uim_tlv_unblock_pin_type *             unblock_pin_ptr          = NULL;
  qmi_uim_tlv_change_pin_type *              change_pin_ptr           = NULL;
  qmi_uim_tlv_authenticate_type *            authenticate_ptr         = NULL;
  qmi_uim_tlv_decrypted_pin_type *           decrypted_pin_ptr        = NULL;
  qmi_uim_tlv_read_record_last_type *        read_record_last_ptr     = NULL;
  qmi_uim_tlv_uint32_type *                  ind_token_ptr            = NULL;
  qmi_uim_tlv_register_refresh_type *        register_refresh_ptr     = NULL;
  qmi_uim_tlv_boolean_type *                 encrypted_ptr            = NULL;
  qmi_uim_tlv_boolean_type *                 register_refresh_all_ptr = NULL;
  qmi_uim_tlv_boolean_type *                 vote_for_init_ptr        = NULL;
  qmi_uim_tlv_file_status_type *             file_status_ptr          = NULL;
  qmi_uim_tlv_increase_type *                increase_ptr             = NULL;
  qmi_uim_tlv_status_cmd_mode_type *         status_mode_ptr          = NULL;
  qmi_uim_tlv_status_cmd_resp_type *         status_resp_ptr          = NULL;
  qmi_uim_tlv_boolean_type *                 encrypted_ext_ptr        = NULL;
  qmi_uim_tlv_search_pattern_type *          search_pattern_ptr       = NULL;
  qmi_uim_tlv_search_data_type *             search_data_ptr          = NULL;

  ASSERT(request_ptr);
  ASSERT(request_ptr->tlv_data_ptr);
  ASSERT(request_ptr->tlv_data_count > 0);

  /* Find the TLVs. Let's consider only those that we strictly need
     and ignore the others */
  for (i = 0; i < request_ptr->tlv_data_count; i++)
  {
    /* Skip TLVs that were not present in the request */
    if (!request_ptr->tlv_data_ptr[i].present)
    {
      continue;
    }

    switch (request_ptr->tlv_data_ptr[i].type)
    {
      case UIMI_TLV_TYPE_SESSION_INFORMATION:
        /* We can ignore session information, because we already have the
           session id */
        break;
      case UIMI_TLV_TYPE_FILE_ID:
        file_id_ptr = &request_ptr->tlv_data_ptr[i].data.file_id;
        break;
      case UIMI_TLV_TYPE_READ_TRANSPARENT:
        read_transparent_ptr = &request_ptr->tlv_data_ptr[i].data.read_transparent;
        break;
      case UIMI_TLV_TYPE_READ_RECORD:
        read_record_ptr = &request_ptr->tlv_data_ptr[i].data.read_record;
        break;
      case UIMI_TLV_TYPE_WRITE_TRANSPARENT:
        write_transparent_ptr = &request_ptr->tlv_data_ptr[i].data.write_transparent;
        break;
      case UIMI_TLV_TYPE_WRITE_RECORD:
        write_record_ptr = &request_ptr->tlv_data_ptr[i].data.write_record;
        break;
      case UIMI_TLV_TYPE_SET_PIN_PROTECTION:
        set_pin_protection_ptr = &request_ptr->tlv_data_ptr[i].data.set_pin_protection;
        break;
      case UIMI_TLV_TYPE_VERIFY_PIN:
        verify_pin_ptr = &request_ptr->tlv_data_ptr[i].data.verify_pin;
        break;
      case UIMI_TLV_TYPE_UNBLOCK_PIN:
        unblock_pin_ptr = &request_ptr->tlv_data_ptr[i].data.unblock_pin;
        break;
      case UIMI_TLV_TYPE_CHANGE_PIN:
        change_pin_ptr = &request_ptr->tlv_data_ptr[i].data.change_pin;
        break;
      case UIMI_TLV_TYPE_AUTHENTICATE:
        authenticate_ptr = &request_ptr->tlv_data_ptr[i].data.authenticate;
        break;
      case UIMI_TLV_TYPE_DECRYPTED_PIN:
        decrypted_pin_ptr = &request_ptr->tlv_data_ptr[i].data.decrypted_pin;
        break;
      case UIMI_TLV_TYPE_READ_RECORD_LAST:
        read_record_last_ptr = &request_ptr->tlv_data_ptr[i].data.read_record_last;
        break;
      case UIMI_TLV_TYPE_IND_TOKEN:
        ind_token_ptr = &request_ptr->tlv_data_ptr[i].data.ind_token;
        break;
      case UIMI_TLV_TYPE_REGISTER_REFRESH:
        register_refresh_ptr = &request_ptr->tlv_data_ptr[i].data.register_refresh;
        break;
      case UIMI_TLV_TYPE_ENCRYPTED:
        encrypted_ptr = &request_ptr->tlv_data_ptr[i].data.encrypted;
        break;
      case UIMI_TLV_TYPE_REGISTER_FOR_REFRESH:
        register_refresh_all_ptr = &request_ptr->tlv_data_ptr[i].data.refresh_registration;;
        break;
      case UIMI_TLV_TYPE_REFRESH_VOTE_FOR_INIT:
        vote_for_init_ptr = &request_ptr->tlv_data_ptr[i].data.refresh_vote_for_init;;
        break;
      case UIMI_TLV_TYPE_FILE_STATUS:
        file_status_ptr = &request_ptr->tlv_data_ptr[i].data.file_status;
        break;
      case UIMI_TLV_TYPE_INCREASE:
        increase_ptr = &request_ptr->tlv_data_ptr[i].data.increase_data;
        break;
      case UIMI_TLV_TYPE_STATUS_CMD_MODE:
        status_mode_ptr = &request_ptr->tlv_data_ptr[i].data.status_cmd_mode;
        break;
      case UIMI_TLV_TYPE_STATUS_CMD_RESP:
        status_resp_ptr = &request_ptr->tlv_data_ptr[i].data.status_cmd_resp;
        break;
      case UIMI_TLV_TYPE_ENCRYPTED_EXT:
        encrypted_ext_ptr = &request_ptr->tlv_data_ptr[i].data.encrypted_ext;
        break;
      case UIMI_TLV_TYPE_SEARCH_PATTERN:
        search_pattern_ptr = &request_ptr->tlv_data_ptr[i].data.search_pattern;
        break;
      case UIMI_TLV_TYPE_SEARCH_DATA:
        search_data_ptr = &request_ptr->tlv_data_ptr[i].data.search_data;
        break;
      default:
        /* Ignore other tags */
        break;
    }
  }

  UIM_MSG_HIGH_1("Execute pending request: 0x%x", request_ptr->command_id);

  switch(request_ptr->command_id)
  {
    case UIMI_CMD_VAL_READ_TRANSPARENT:
      ASSERT(file_id_ptr);
      ASSERT(read_transparent_ptr);

      /* We cannot process both partial encryption and complete encryption read requests */
      if(encrypted_ext_ptr && encrypted_ptr)
      {
        errval = QMI_ERR_MALFORMED_MSG;
        break;
      }

      if (encrypted_ptr && encrypted_ptr->value)
      {
        encryption_status = QMI_UIM_DATA_ONLY_ENCRYPTION;
      }
      else if (encrypted_ext_ptr && encrypted_ext_ptr->value)
      {
        encryption_status = QMI_UIM_COMPLETE_ENCRYPTION;
      }

      errval = qmi_uim_execute_read_transparent(
                         request_ptr->command_id,
                         session_id,
                         file_id_ptr->file_access,
                         read_transparent_ptr->offset,
                         read_transparent_ptr->length,
                         encryption_status,
                         ind_token_ptr ? &ind_token_ptr->value : NULL,
                         request_ptr->cmd_buf_ptr,
                         request_ptr->clid);
      break;

    case UIMI_CMD_VAL_READ_RECORD:
      ASSERT(file_id_ptr);
      ASSERT(read_record_ptr);

      errval = qmi_uim_execute_read_record(
                         session_id,
                         file_id_ptr->file_access,
                         read_record_ptr->record,
                         (read_record_last_ptr != NULL) ?
                           read_record_last_ptr->last_record :
                           read_record_ptr->record,
                         read_record_ptr->length,
                         ind_token_ptr ? &ind_token_ptr->value : NULL,
                         request_ptr->cmd_buf_ptr,
                         request_ptr->clid);
      break;

    case UIMI_CMD_VAL_WRITE_TRANSPARENT:
      ASSERT(file_id_ptr);
      ASSERT(write_transparent_ptr);

      errval = qmi_uim_execute_write_transparent(
                         session_id,
                         file_id_ptr->file_access,
                         write_transparent_ptr->offset,
                         write_transparent_ptr->data,
                         ind_token_ptr ? &ind_token_ptr->value : NULL,
                         request_ptr->cmd_buf_ptr,
                         request_ptr->clid);
      break;

    case UIMI_CMD_VAL_WRITE_RECORD:
      ASSERT(file_id_ptr);
      ASSERT(write_record_ptr);

      errval = qmi_uim_execute_write_record(
                         session_id,
                         file_id_ptr->file_access,
                         write_record_ptr->record,
                         write_record_ptr->data,
                         ind_token_ptr ? &ind_token_ptr->value : NULL,
                         request_ptr->cmd_buf_ptr,
                         request_ptr->clid);
      break;

    case UIMI_CMD_VAL_GET_FILE_ATTRIBUTES:
      ASSERT(file_id_ptr);

      errval = qmi_uim_execute_get_file_attributes(
                         session_id,
                         file_id_ptr->file_access,
                         ind_token_ptr ? &ind_token_ptr->value : NULL,
                         request_ptr->cmd_buf_ptr,
                         request_ptr->clid);
      break;

    case UIMI_CMD_VAL_SET_PIN_PROTECTION:
      ASSERT(set_pin_protection_ptr);

      errval = qmi_uim_execute_set_pin_protection(
                         session_id,
                         set_pin_protection_ptr->pin_enable,
                         set_pin_protection_ptr->pin_id,
                         set_pin_protection_ptr->pin_data,
                         ind_token_ptr ? &ind_token_ptr->value : NULL,
                         request_ptr->cmd_buf_ptr,
                         request_ptr->clid);
      break;

    case UIMI_CMD_VAL_VERIFY_PIN:
      ASSERT(verify_pin_ptr);

      errval = qmi_uim_execute_verify_pin(
                         session_id,
                         verify_pin_ptr->pin_id,
                         (decrypted_pin_ptr != NULL && qmi_uim_global_ptr->silent_pin1_supported) ?
                           decrypted_pin_ptr->decrypted_pin_data :
                           verify_pin_ptr->pin_data,
                         (decrypted_pin_ptr != NULL && qmi_uim_global_ptr->silent_pin1_supported) ?
                           TRUE : FALSE,
                         ind_token_ptr ? &ind_token_ptr->value : NULL,
                         request_ptr->cmd_buf_ptr,
                         request_ptr->clid);
      break;

    case UIMI_CMD_VAL_UNBLOCK_PIN:
      ASSERT(unblock_pin_ptr);

      errval = qmi_uim_execute_unblock_pin(
                         session_id,
                         unblock_pin_ptr->pin_id,
                         unblock_pin_ptr->puk_data,
                         unblock_pin_ptr->pin_data,
                         ind_token_ptr ? &ind_token_ptr->value : NULL,
                         request_ptr->cmd_buf_ptr,
                         request_ptr->clid);
      break;

    case UIMI_CMD_VAL_CHANGE_PIN:
      ASSERT(change_pin_ptr);

      errval = qmi_uim_execute_change_pin(
                         session_id,
                         change_pin_ptr->pin_id,
                         change_pin_ptr->old_pin_data,
                         change_pin_ptr->new_pin_data,
                         ind_token_ptr ? &ind_token_ptr->value : NULL,
                         request_ptr->cmd_buf_ptr,
                         request_ptr->clid);
      break;

    case UIMI_CMD_VAL_AUTHENTICATE:
      ASSERT(authenticate_ptr);

      errval = qmi_uim_execute_authenticate(
                         session_id,
                         authenticate_ptr->auth_context,
                         authenticate_ptr->auth_data,
                         ind_token_ptr ? &ind_token_ptr->value : NULL,
                         request_ptr->cmd_buf_ptr,
                         request_ptr->clid);
      break;

    case UIMI_CMD_VAL_REFRESH_REGISTER:
      ASSERT(register_refresh_ptr);

      errval = qmi_uim_execute_refresh_register(
                         session_id,
                         register_refresh_ptr->register_op,
                         register_refresh_ptr->vote_for_init,
                         register_refresh_ptr->file_list_ptr,
                         request_ptr->cmd_buf_ptr);
      /* Register for refresh requires an immediate response also in
         case of success. The error case is already handled below */
      if (errval == QMI_ERR_NONE)
      {
        qmi_uim_internal_success_resp(request_ptr->cmd_buf_ptr);
        return;
      }
      break;

    case UIMI_CMD_VAL_REFRESH_REGISTER_ALL:
      ASSERT(register_refresh_all_ptr);
      ASSERT(vote_for_init_ptr);

      errval = qmi_uim_execute_refresh_register_all(
                            session_id,
                            register_refresh_all_ptr->value,
                            vote_for_init_ptr->value,
                            request_ptr->cmd_buf_ptr);
      /* Register for refresh all requires an immediate response also in
         case of success. The error case is already handled below */
      if (errval == QMI_ERR_NONE)
      {
        qmi_uim_internal_success_resp(request_ptr->cmd_buf_ptr);
        return;
      }
      break;

    case UIMI_CMD_VAL_SET_FILE_STATUS:
      ASSERT(file_id_ptr);
      ASSERT(file_status_ptr);

      errval = qmi_uim_execute_set_file_status(session_id,
                                               file_id_ptr->file_access,
                                               file_status_ptr->file_status,
                                               request_ptr->cmd_buf_ptr,
                                               request_ptr->clid);
      break;

    case UIMI_CMD_VAL_INCREASE:
      ASSERT(file_id_ptr);
      ASSERT(increase_ptr);

      errval = qmi_uim_execute_increase(
                         session_id,
                         file_id_ptr->file_access,
                         increase_ptr->data,
                         ind_token_ptr ? &ind_token_ptr->value : NULL,
                         request_ptr->cmd_buf_ptr,
                         request_ptr->clid);
      break;

    case UIMI_CMD_VAL_SEND_STATUS:
      /* No ASSERT required */
      errval = qmi_uim_execute_status(session_id,
                                      (status_mode_ptr != NULL) ?
                                        status_mode_ptr->mode :
                                        MMGSDI_STATUS_APP_NO_INDICATION,
                                      (status_resp_ptr != NULL) ?
                                        status_resp_ptr->resp :
                                        MMGSDI_STATUS_NO_DATA,
                                      request_ptr->cmd_buf_ptr,
                                      request_ptr->clid);
      break;

    case UIMI_CMD_VAL_GET_GBA_IMPI:
      if (encrypted_ptr && encrypted_ptr->value)
      {
        encryption_status = QMI_UIM_DATA_ONLY_ENCRYPTION;
      }

      memset(&mmgsdi_access, 0x00, sizeof(mmgsdi_access));

      /* Read EF IMPI */
      mmgsdi_access.access_method = MMGSDI_EF_ENUM_ACCESS;
      mmgsdi_access.file.file_enum = MMGSDI_ISIM_IMPI;

      errval = qmi_uim_execute_read_transparent(
                         request_ptr->command_id,
                         session_id,
                         mmgsdi_access,
                         0,
                         0,
                         encryption_status,
                         NULL,
                         request_ptr->cmd_buf_ptr,
                         request_ptr->clid);
      break;

    case UIMI_CMD_VAL_SEARCH_RECORD:
      ASSERT(file_id_ptr);
      ASSERT(search_pattern_ptr);

      errval = qmi_uim_execute_search_record(
                       session_id,
                       file_id_ptr->file_access,
                       search_pattern_ptr->pattern,
                       (search_data_ptr != NULL) ?
                         search_data_ptr->first_record_num : QMI_UIM_RECORD_1,
                       (search_data_ptr != NULL) ?
                         search_data_ptr->direction : MMGSDI_SEARCH_FORWARD_FROM_REC_NUM,
                       ind_token_ptr ? &ind_token_ptr->value : NULL,
                       request_ptr->cmd_buf_ptr,
                       request_ptr->clid);
      break;

    default:
      /* We should not receive any other command than in the
         list above. Anyway, handle that command sending an
         internal error */
      errval = QMI_ERR_INTERNAL;
      break;
  }

  /* In case of error, send response. In case of success, this will be
     done in the MMGSDI callback */
  if (errval != QMI_ERR_NONE)
  {
    UIM_MSG_ERR_2("Operation 0x%x on non prov application failed: 0x%x",
                  request_ptr->command_id, errval);
    if (request_ptr->cmd_buf_ptr != NULL)
    {
      qmi_uim_internal_error_resp(request_ptr->cmd_buf_ptr);
    }
    else
    {
      qmi_uim_pending_req_error_ind(request_ptr);
    }
  }
} /* qmi_uim_execute_pending_request */


/*===========================================================================
  FUNCTION QMI_UIM_EXECUTE_ALL_PENDING_REQUESTS()

  DESCRIPTION
    Executes all pending requests for a non provisionin application. The
    function might be used also to send the ERROR_INTERNAL code to the
    application, when required.

  PARAMETERS
    session_id  : session id
    execute     : specify if the request needs to be executes (TRUE)
                  or simply deleted (FALSE)

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_execute_all_pending_requests
(
  mmgsdi_session_id_type  session_id,
  boolean                 execute

)
{
  uint16                          i           = 0;
  uint16                          index       = UIM_INVALID_APP_INDEX;
  qmi_uimi_pending_request_type * next_ptr    = NULL;
  qmi_uimi_pending_request_type * current_ptr = NULL;

  ASSERT(qmi_uim_global_ptr);

  /* Find the non provisioning application with the given
     session id */
  for (i = 0; i < UIM_MAX_NON_PROV_SESSIONS; i++)
  {
    if (qmi_uim_global_ptr->non_prov_session[i].init &&
        qmi_uim_global_ptr->non_prov_session[i].mmgsdi_session_id == session_id)
    {
      index = i;
      break;
    }
  }

  if (index == UIM_INVALID_APP_INDEX)
  {
    UIM_MSG_ERR_1("Unable to execute pending requests for session id 0x%x",
                  session_id);
    return;
  }

  /* Set the global list head pointer to NULL */
  current_ptr = qmi_uim_global_ptr->non_prov_session[index].pending_req_ptr;
  qmi_uim_global_ptr->non_prov_session[index].pending_req_ptr = NULL;

  /* Loop thru all the pending requests & free the nodes */
  while (current_ptr != NULL)
  {
    /* First check if the requested client is still valid, the pending request
       is dropped if the Client ID is no longer valid */
    if (TRUE == qmi_uim_check_clid(
                  current_ptr->clid,
                  current_ptr->client_reg_count))
    {
      if (execute)
      {
        qmi_uim_execute_pending_request(current_ptr, session_id);
      }
      else
      {
        /* Send internal error for the pending request */
        qmi_cmd_buf_type* cmd_buf_ptr = (qmi_cmd_buf_type*)current_ptr->cmd_buf_ptr;
        if (cmd_buf_ptr)
        {
          qmi_uim_internal_error_resp(cmd_buf_ptr);
        }
        else
        {
          qmi_uim_pending_req_error_ind(current_ptr);
        }
      }
    }

    /* Free the TLV */
    if (current_ptr->tlv_data_ptr != NULL)
    {
      qmi_uim_free_tlv_content(current_ptr->tlv_data_ptr,
                               current_ptr->tlv_data_count);

      uimqmi_free(current_ptr->tlv_data_ptr);
      current_ptr->tlv_data_ptr = NULL;
    }

    /* Remove the current node & move to the next node */
    next_ptr = current_ptr->next_ptr;
    uimqmi_free(current_ptr);
    current_ptr = next_ptr;
  }
} /* qmi_uim_execute_all_pending_requests */


/*===========================================================================
  FUNCTION QMI_UIM_REMOVE_NON_PROVISIONING_SESSION()

  DESCRIPTION
    Removes a non provisioning session from the global array, cancelling
    all the pending requests.

  PARAMETERS
    session_id           : session id
    send_ind             : Specify if a QMI_UIM_SESSION_CLOSED_IND needs to be sent
                           to the clients accessing the session (TRUE) or not (FALSE)
    session_closed_cause : Cause for session closure

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_remove_non_provisioning_session
(
  mmgsdi_session_id_type                session_id,
  boolean                               send_ind,
  mmgsdi_session_closed_cause_enum_type session_closed_cause
)
{
  uint16  i  = 0;

  ASSERT(qmi_uim_global_ptr);

  for (i = 0; i < UIM_MAX_NON_PROV_SESSIONS; i++)
  {
    if (qmi_uim_global_ptr->non_prov_session[i].init &&
        qmi_uim_global_ptr->non_prov_session[i].mmgsdi_session_id == session_id)
    {
      /* Remove refresh data of the non prov session */
      qmi_uim_remove_refresh_registration(session_id);

      /* Complete pending requests */
      qmi_uim_execute_all_pending_requests(session_id, FALSE);

      /* Send Session Closed Indication to Clients */
      if(send_ind)
      {
        qmi_uim_send_non_prov_session_closed_ind_to_all(i, session_closed_cause);
      }

      /* Clear session */
      memset(&qmi_uim_global_ptr->non_prov_session[i],
             0,
             sizeof(qmi_uim_global_ptr->non_prov_session[i]));

      qmi_uim_global_ptr->non_prov_session[i].init = FALSE;
      qmi_uim_global_ptr->non_prov_session[i].mmgsdi_session_id = UIM_INVALID_SESSION_ID;

      break;
    }
  }
} /* qmi_uim_remove_non_provisioning_session */


/*===========================================================================
  FUNCTION QMI_UIM_REMOVE_NON_PROVISIONING_AND_APDU_SESSION()

  DESCRIPTION
    Removes all non provisioning sessions info previously opened that belong
    to the provided slot from the global array.

  PARAMETERS
    slot_id  : slot id

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_remove_non_provisioning_and_apdu_session
(
  mmgsdi_slot_id_enum_type      slot_id
)
{
  uint16                          i            = 0;
  mmgsdi_session_type_enum_type   session_type = MMGSDI_MAX_SESSION_TYPE_ENUM;

  ASSERT(qmi_uim_global_ptr);

  /* Check slot id */
  switch(slot_id)
  {
    case MMGSDI_SLOT_1:
      session_type = MMGSDI_NON_PROV_SESSION_SLOT_1;
      break;
    case MMGSDI_SLOT_2:
      session_type = MMGSDI_NON_PROV_SESSION_SLOT_2;
      break;
    case MMGSDI_SLOT_3:
      session_type = MMGSDI_NON_PROV_SESSION_SLOT_3;
      break;
    default:
      UIM_MSG_ERR_1("Invalid slot id for removal: 0x%x", slot_id);
      return;
  }

  /* Clear info of all non-provisioning sessions that belongs to the slot */
  for (i = 0; i < UIM_MAX_NON_PROV_SESSIONS; i++)
  {
    if (qmi_uim_global_ptr->non_prov_session[i].init &&
        qmi_uim_global_ptr->non_prov_session[i].session_type == session_type)
    {
      /* QMI_UIM_SESSION_CLOSED_IND shall not be sent out since the session
         clean-up was not trigerred by an MMGSDI_SESSION_CLOSE_EVT */
      qmi_uim_remove_non_provisioning_session(
          qmi_uim_global_ptr->non_prov_session[i].mmgsdi_session_id,
          FALSE,
          MMGSDI_SESSION_CLOSED_CAUSE_UNKNOWN);
    }
  }

  /* Clear info of all APDU sessions that belongs to the slot */
  for (i = 0; i < UIM_MAX_APDU_CHANNEL_COUNT; i++)
  {
    if (qmi_uim_global_ptr->apdu_channel[i] &&
        qmi_uim_global_ptr->apdu_channel[i]->slot == slot_id)
    {
      /* QMI_UIM_SESSION_CLOSED_IND shall not be sent out since the session
         clean-up was not trigerred by an MMGSDI_SESSION_CLOSE_EVT */
      qmi_uim_remove_apdu_session(
          qmi_uim_global_ptr->apdu_channel[i]->mmgsdi_session_id,
          FALSE,
          MMGSDI_SESSION_CLOSED_CAUSE_UNKNOWN);
    }
  }
} /* qmi_uim_remove_non_provisioning_and_apdu_session */


/*===========================================================================
  FUNCTION QMI_UIM_GET_HALT_SUBSCRIPTION_VALUE

  DESCRIPTION
    Fetches the halt subscription config value from EFS. If config file is
    not found, a default value of FALSE is returned.

  PARAMETERS
    None

  RETURN VALUE
    boolean          : TRUE if the config value was 1, FALSE in all
                       other cases

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_uim_get_halt_subscription_value
(
  void
)
{
  boolean    halt_sub_config        = FALSE;

  if (uim_common_efs_read(
        UIM_COMMON_EFS_MMGSDI_HALT_SUBSCRIPTION,
        UIM_COMMON_EFS_ITEM_FILE_TYPE,
        UIM_COMMON_EFS_DEVICE,
        &halt_sub_config,
        sizeof(boolean)) != UIM_COMMON_EFS_SUCCESS)
  {
    UIM_MSG_HIGH_0("Halt subscription config file not found,default to FALSE");
    return FALSE;
  }

  UIM_MSG_HIGH_1("Halt subscription config set to 0x%x", halt_sub_config);

  return halt_sub_config ? TRUE : FALSE;
} /* qmi_uim_get_halt_subscription_value */


/*===========================================================================
  FUNCTION QMI_UIM_GET_ENCRYPTED_SUB_OK_VALUE

  DESCRIPTION
    Fetches the encrypted sub ok config value from EFS. If config file is
    not found, a default value of FALSE is returned.

  PARAMETERS
    None

  RETURN VALUE
    boolean          : TRUE if the config value was 1, FALSE in all
                       other cases

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_uim_get_encrypted_sub_ok_value
(
  void
)
{
  boolean    encrypt_sub_ok       = FALSE;

  /* Get halt subscription config value from EFS */
  if (uim_common_efs_read(
        UIM_COMMON_EFS_MMGSDI_ENCRYPT_SUB_OK,
        UIM_COMMON_EFS_ITEM_FILE_TYPE,
        UIM_COMMON_EFS_DEVICE,
        &encrypt_sub_ok,
        sizeof(boolean)) != UIM_COMMON_EFS_SUCCESS)
  {
    UIM_MSG_HIGH_0("Encrypted sub_ok config file not found,default to FALSE");
    return FALSE;
  }

  UIM_MSG_HIGH_1("Encrypted sub_ok config set to 0x%x", encrypt_sub_ok);

  return encrypt_sub_ok ? TRUE : FALSE;
} /* qmi_uim_get_encrypted_sub_ok_value */


/*===========================================================================
  FUNCTION QMI_UIM_IS_REQUEST_REJECTED()

  DESCRIPTION
    If APDU security restrictions are enabled on the device, this function
    checks the incoming request to determine if it should be rejected. It
    will be rejected if the logical channel in request doesnt belongs to the
    requesting client.

  PARAMETERS
    session_type   : session type
    aid            : AID value
    cl_sp          : Client state pointer

  RETURN VALUE
    Boolean indicating if the request is to be rejected or not.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_uim_is_request_rejected
(
  mmgsdi_session_type_enum_type   session_type,
  mmgsdi_static_data_type         aid,
  qmi_uimi_client_state_type    * cl_sp
)
{
  uint16                    i               = 0;
  uint16                    channel_index   = UIM_INVALID_APP_INDEX;
  mmgsdi_slot_id_enum_type  slot            = MMGSDI_SLOT_1;

  ASSERT(qmi_uim_global_ptr);

  if (qmi_uim_global_ptr->apdu_sec_restr_value == QMI_UIM_APDU_SEC_RESTRICTIONS_NONE)
  {
    return FALSE;
  }

  /* Validate session type & channel id length */
  if ((session_type != MMGSDI_NON_PROV_SESSION_SLOT_1) &&
      (session_type != MMGSDI_NON_PROV_SESSION_SLOT_2) &&
      (session_type != MMGSDI_NON_PROV_SESSION_SLOT_3))
  {
    return FALSE;
  }

  if (aid.data_len != QMI_UIM_TLV_CHANNEL_ID_LEN)
  {
    return FALSE;
  }

  UIM_MSG_HIGH_1("logical_channel: 0x%x", aid.data_ptr[0]);

  /* Check if the logical channel belongs to requesting client */
  switch(session_type)
  {
    case MMGSDI_NON_PROV_SESSION_SLOT_1:
      slot = MMGSDI_SLOT_1;
      break;
    case MMGSDI_NON_PROV_SESSION_SLOT_2:
      slot = MMGSDI_SLOT_2;
      break;
    case MMGSDI_NON_PROV_SESSION_SLOT_3:
      slot = MMGSDI_SLOT_3;
      break;
    default:
      return FALSE;
  }

  /* If any match is found, the request is OK to proceed */
  for (i = 0; i < UIM_MAX_APDU_CHANNEL_COUNT; i++)
  {
    if (qmi_uim_global_ptr->apdu_channel[i] &&
        qmi_uim_global_ptr->apdu_channel[i]->slot == slot &&
        qmi_uim_global_ptr->apdu_channel[i]->logical_channel == aid.data_ptr[0] &&
        qmi_uim_global_ptr->apdu_channel[i]->opening_cl_sp == cl_sp)
    {
      channel_index = i;
      break;
    }
  }
  if (channel_index == UIM_INVALID_APP_INDEX)
  {
    UIM_MSG_ERR_0("Request rejected due to security restrictions: logical channel doesnt belong to client");
    return TRUE;
  }

  return FALSE;
} /* qmi_uim_is_request_rejected */


/*===========================================================================
  FUNCTION QMI_UIM_IS_APDU_REQUEST_REJECTED()

  DESCRIPTION
    If APDU security restrictions are enabled on the device, this function
    parses the incoming APDU request and checks the below criteria to
    determine if it should be rejected:
    1. if it is either a MANAGE CHANNEL or
    2. a SELECT  using the DF name (P1 = 0x04) request or
    3. logical channel in request doesnt belongs to the requesting client

  PARAMETERS
    slot_id             : Slot id
    apdu_data           : Incoming APDU request
    logical_ch_tlv_ptr  : Logical channel TLV pointer
    cl_sp               : Client state pointer

  RETURN VALUE
    Boolean indicating if the request is to be rejected or not.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_uim_is_apdu_request_rejected
(
  mmgsdi_slot_id_enum_type      slot,
  mmgsdi_send_apdu_data_type    apdu_data,
  qmi_uim_tlv_item_type       * logical_ch_tlv_ptr,
  qmi_uimi_client_state_type  * cl_sp
)
{
  uint16                    i               = 0;
  uint8                     logical_channel = 0;
  uint16                    channel_index   = UIM_INVALID_APP_INDEX;

  ASSERT(qmi_uim_global_ptr);
  ASSERT(logical_ch_tlv_ptr);

  if ((apdu_data.data_ptr == NULL) || (apdu_data.data_len < 4))
  {
    UIM_MSG_ERR_0("ADPU rejected due to invalid size");
    return TRUE;
  }

  /* Get the logical channel on which this APDU is being intended
     to be sent */
  if (logical_ch_tlv_ptr->present)
  {
    logical_channel = logical_ch_tlv_ptr->data.logical_channel.logical_channel;
  }
  else
  {
    /* Handle coding of extended logical channels also */
    if(apdu_data.data_ptr[0] & 0x40)
    {
      logical_channel = (apdu_data.data_ptr[0] & 0x0F) + 4;
    }
    else
    {
      logical_channel = apdu_data.data_ptr[0] & 0x03;
    }
  }

  UIM_MSG_HIGH_1("logical_channel: 0x%x", logical_channel);

  /* Block AUTHENTICATE APDUs based on authenticate security restrictions */
  if (apdu_data.data_ptr[1] == QMI_UIM_APDU_INS_BYTE_AUTHENTICATE)
  {
    boolean                   reject_apdu     = FALSE;
    mmgsdi_protocol_enum_type card_protocol   = qmi_uim_card_protocol(slot);
    boolean                   is_usim_channel = FALSE;

    /* Loop through the channels opened for apdu streaming and see if there
       is any USIM opened on the channel on which this APDU is intended to
       be sent. If there is a USIM on this channel, and if the APDU is a
       AUTH APDU, and NV is set to 2, block the APDU for non prop II CLA */
    for (i = 0; i < UIM_MAX_APDU_CHANNEL_COUNT; i++)
    {
      if (qmi_uim_global_ptr->apdu_channel[i] &&
          qmi_uim_global_ptr->apdu_channel[i]->slot == slot &&
          qmi_uim_global_ptr->apdu_channel[i]->logical_channel == logical_channel)
      {
        if (qmi_uim_is_usim_aid(&(qmi_uim_global_ptr->apdu_channel[i]->aid), TRUE))
        {
          is_usim_channel = TRUE;
        }
        break;
      }
    }

    switch(card_protocol)
    {
      case MMGSDI_ICC:
        /* For ICC cards, block RUN GSM algorithm/RUN CAVE*/
        if (apdu_data.data_ptr[0] == QMI_UIM_APDU_CLA_BYTE_ICC)
        {
          if (qmi_uim_global_ptr->auth_sec_restr_value == QMI_UIM_AUTH_SEC_RESTRICTIONS_ALL ||
              qmi_uim_global_ptr->auth_sec_restr_value == QMI_UIM_AUTH_SEC_RESTRICTIONS_II_CLA)
          {
            reject_apdu = TRUE;
          }
        }
        /* Some ICC card works like UICC card which can perform command with 0x0X or 0x8X CLA,
           we should have the same restrictions for ICC as UICC's. */
        else if (apdu_data.data_ptr[3] == QMI_UIM_APDU_P2_BYTE_USIM_AUTHENTICATE_GSM_ALGO)
        {
          if (qmi_uim_global_ptr->auth_sec_restr_value == QMI_UIM_AUTH_SEC_RESTRICTIONS_ALL ||
              (qmi_uim_global_ptr->auth_sec_restr_value == QMI_UIM_AUTH_SEC_RESTRICTIONS_II_CLA &&
               !(apdu_data.data_ptr[0] & 0x80) &&
               is_usim_channel))
          {
            reject_apdu = TRUE;
          }
        }
        break;

      case MMGSDI_UICC:
        /* For UICC card, reject only when context is GSM algorithm */
        if (apdu_data.data_ptr[3] == QMI_UIM_APDU_P2_BYTE_USIM_AUTHENTICATE_GSM_ALGO)
        {
          if (qmi_uim_global_ptr->auth_sec_restr_value == QMI_UIM_AUTH_SEC_RESTRICTIONS_ALL ||
              (qmi_uim_global_ptr->auth_sec_restr_value == QMI_UIM_AUTH_SEC_RESTRICTIONS_II_CLA &&
               !(apdu_data.data_ptr[0] & 0x80) &&
               is_usim_channel))
          {
            reject_apdu = TRUE;
          }
        }
        break;

      default:
        /* Error case, reject the APDU */
        reject_apdu = TRUE;
        break;
    }
    if (reject_apdu)
    {
      UIM_MSG_ERR_0("ADPU rejected due to security restrictions");
      return TRUE;
    }
  }

  /* If no APDU security restrictions, nothing to check */
  if (qmi_uim_global_ptr->apdu_sec_restr_value == QMI_UIM_APDU_SEC_RESTRICTIONS_NONE)
  {
    return FALSE;
  }

  /* If APDU security restrictions are set for only Inter Industry CLA, check the
     CLA b8 to allow non-inter industry CLAs:
     Byte 1: CLA - bit 8 set to 1 is a proprietary class (Per Spec ISO 7816-5) */
  if ((qmi_uim_global_ptr->apdu_sec_restr_value == QMI_UIM_APDU_SEC_RESTRICTIONS_II_CLA) &&
      (apdu_data.data_ptr[0] & 0x80))
  {
    return FALSE;
  }

  /*  Check these criteria to see if it needs to be rejected:
      1. Byte 2: INS - MANAGE CHANNEL or SELECT
      2. Byte 3: P1  - 0x04, if INS is SELECT
  */
  if ((apdu_data.data_ptr[1] == QMI_UIM_APDU_INS_BYTE_MANAGE_CHANNEL) ||
      ((apdu_data.data_ptr[1] == QMI_UIM_APDU_INS_BYTE_SELECT_FILE) &&
       (apdu_data.data_ptr[2] == QMI_UIM_APDU_P1_BYTE_SELECT_DF_NAME)))
  {
    UIM_MSG_ERR_2("ADPU rejected due to security restrictions, INS byte: 0x%x, P1 byte: 0x%x",
                  apdu_data.data_ptr[1], apdu_data.data_ptr[2]);
    return TRUE;
  }

  /* Next check if the logical channel belongs to requesting client */
  /* If any match is found, the request is OK to proceed */
  for (i = 0; i < UIM_MAX_APDU_CHANNEL_COUNT; i++)
  {
    if (qmi_uim_global_ptr->apdu_channel[i] &&
        qmi_uim_global_ptr->apdu_channel[i]->slot == slot &&
        qmi_uim_global_ptr->apdu_channel[i]->logical_channel == logical_channel &&
        qmi_uim_global_ptr->apdu_channel[i]->opening_cl_sp == cl_sp)
    {
      channel_index = i;
      break;
    }
  }
  if (channel_index == UIM_INVALID_APP_INDEX)
  {
    UIM_MSG_ERR_0("ADPU rejected due to security restrictions: logical_channel doesnt belong to client");
    return TRUE;
  }

  return FALSE;
} /* qmi_uim_is_apdu_request_rejected */


/*===========================================================================
  FUNCTION QMI_UIM_IS_SAP_REQUEST_REJECTED()

  DESCRIPTION
    If APDU security restrictions are enabled on the device, this function
    parses the incoming SAP APDU request and checks if it is a SELECT command
    using the DF name (P1 = 0x04) and specifying AID of a non-telecom
    application. Access to such non-3GPP/2 RIDs are rejected.

  PARAMETERS
    apdu_data  : Incoming SAP APDU request

  RETURN VALUE
    Boolean indicating if the request is to be rejected or not.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_uim_is_sap_request_rejected
(
  mmgsdi_send_apdu_data_type    apdu_data
)
{
  const uint8 rid_value_3gpp[]  =  { 0xA0, 0x00, 0x00, 0x00, 0x87 };
  const uint8 rid_value_3gpp2[] =  { 0xA0, 0x00, 0x00, 0x03, 0x43 };

  ASSERT(qmi_uim_global_ptr);

  /* If no APDU security restrictions, nothing to check */
  if (qmi_uim_global_ptr->apdu_sec_restr_value == QMI_UIM_APDU_SEC_RESTRICTIONS_NONE)
  {
    return FALSE;
  }

  /* Check these bytes:
     Byte 2: INS
     Byte 3: P1
     Bytes 6 through 10: RID (first 5 bytes of AID), if needed
  */
  if ((apdu_data.data_ptr != NULL) &&
      (apdu_data.data_len >= 3))
  {
    if ((apdu_data.data_ptr[1] == QMI_UIM_APDU_INS_BYTE_SELECT_FILE) &&
        (apdu_data.data_ptr[2] == QMI_UIM_APDU_P1_BYTE_SELECT_DF_NAME))
    {
      /* Reject if it is an attempt to provide a truncated AID < 5 bytes */
      if (apdu_data.data_len < 10)
      {
        UIM_MSG_ERR_1("ADPU rejected due to security restrictions: data_len: 0x%x",
                      apdu_data.data_len);
        return TRUE;
      }
      /* Also reject if an RID other than 3GPP or 3GPP2 is provided */
      if ((memcmp(&apdu_data.data_ptr[5], rid_value_3gpp, sizeof(rid_value_3gpp)) != 0) &&
          (memcmp(&apdu_data.data_ptr[5], rid_value_3gpp2, sizeof(rid_value_3gpp2)) != 0))
      {
        UIM_MSG_ERR_0("ADPU rejected due to security restrictions: restricted AID");
        return TRUE;
      }
    }
  }

  return FALSE;
} /* qmi_uim_is_sap_request_rejected */


/*===========================================================================
  FUNCTION QMI_UIM_IS_LOGICAL_CHANNEL_REQUEST_REJECTED()

  DESCRIPTION
    If APDU security restrictions are enabled on the device, this function
    parses the incoming request for opening of logical channels and checks
    if the application is restricted or not. Access to the input AID is
    granted or denied based on the NV values of blacklist/whitelist.

  PARAMETERS
    input_aid  : Incoming AID

  RETURN VALUE
    Boolean indicating if the request is to be rejected or not.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_uim_is_logical_channel_request_rejected
(
  mmgsdi_static_data_type    input_aid
)
{
  uint16                    i                = 0;
  boolean                   is_rejected      = TRUE;
  qmi_uim_aid_entry_type  * temp_aid_ptr     = NULL;

  ASSERT(qmi_uim_global_ptr);

  if (qmi_uim_global_ptr->apdu_sec_restr_value == QMI_UIM_APDU_SEC_RESTRICTIONS_NONE)
  {
    return FALSE;
  }

  /* Sanity check */
  if ((input_aid.data_len < 0) ||
      (input_aid.data_len > (int32)sizeof(input_aid.data_ptr)))
  {
    UIM_MSG_ERR_1("Request to select AID rejected: Invalid AID length: 0x%x",
                  input_aid.data_len);
    return TRUE;
  }

  /* Input APDU can be empty only in case of empty blacklist */
  if ((input_aid.data_len == 0) &&
      (qmi_uim_global_ptr->apdu_sec_aid_info.aid_list_type == UIM_AID_LIST_WHITE_LIST))
  {
    UIM_MSG_ERR_0("Request to select AID rejected: Empty AID not allowed");
    return TRUE;
  }

  temp_aid_ptr = qmi_uim_global_ptr->apdu_sec_aid_info.aid_list_ptr;

  /* First check what type of AID list we read from NV */
  if (qmi_uim_global_ptr->apdu_sec_aid_info.aid_list_type == UIM_AID_LIST_BLACK_LIST)
  {
    /* For an empty blacklist, all AIDs are allowed */
    is_rejected  = FALSE;

    /* Loop through the blacklist of AIDs to check these rules:
       1. If AID from EFS, then partial/exact AID matches, requested AID is rejected
       2. If AID is added by QMI UIM, then allow the partial AID only.
       3. If requested AID doesnt match any of the blacklisted AIDs, it is allowed
       4. Empty blacklist means all AIDs are allowed
    */
    for (i = 0;
         (i < qmi_uim_global_ptr->apdu_sec_aid_info.aid_count) && (temp_aid_ptr != NULL);
         i++, temp_aid_ptr++)
    {
      /* First check which of the AIDs is shorter, since we need to
         account for partial AID selection */
      uint16 shortest_aid_len = (uint16)(input_aid.data_len <= temp_aid_ptr->aid.data_len ?
                                          input_aid.data_len : temp_aid_ptr->aid.data_len);

      if (temp_aid_ptr->from_efs == FALSE &&
          temp_aid_ptr->aid.data_len > input_aid.data_len)
      {
        continue;
      }
      if (memcmp(input_aid.data_ptr, temp_aid_ptr->aid.data_ptr, shortest_aid_len) == 0)
      {
        /* Found a match, reject it */
        UIM_MSG_ERR_0("Request to select AID rejected: AID blacklisted");
        return TRUE;
      }
    }
    UIM_MSG_HIGH_0("Request to select AID accepted: AID not blacklisted");
  }
  else if (qmi_uim_global_ptr->apdu_sec_aid_info.aid_list_type == UIM_AID_LIST_WHITE_LIST)
  {
    /* For an empty whitelist, any AID is not allowed */
    is_rejected = TRUE;

    /* Loop through the blacklist of AIDs to check these rules:
       1. If exact AID matches or partial match with shorter whitelisted AID, it is allowed
       2. If anything else, it is rejected (no partial matches with shorter requested AID)
       3. Empty whitelist means any AID is rejected
    */
    for (i = 0;
         (i < qmi_uim_global_ptr->apdu_sec_aid_info.aid_count) && (temp_aid_ptr != NULL);
         i++, temp_aid_ptr++)
    {
      if (input_aid.data_len >= temp_aid_ptr->aid.data_len)
      {
        if (memcmp(input_aid.data_ptr, temp_aid_ptr->aid.data_ptr, temp_aid_ptr->aid.data_len) == 0)
        {
          UIM_MSG_HIGH_0("Request to select AID accepted: AID whitelisted");
          return FALSE;
        }
      }
    }
    UIM_MSG_ERR_0("Request to select AID rejected: AID not whitelisted");
  }

  return is_rejected;
} /* qmi_uim_is_logical_channel_request_rejected */


/*===========================================================================
  FUNCTION QMI_UIM_INIT_CLIENT_STATE()

  DESCRIPTION
    Initializes the state of a specific QMI UIM client. This function is
    executed at client id deallocation and after a reset command.

  PARAMETERS
    cl_sp : service provided client state pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_init_client_state
(
  qmi_uimi_client_state_type * cl_sp
)
{
  uint16                     i             = 0;
  mmgsdi_slot_id_enum_type   mmgsdi_slot   = MMGSDI_MAX_SLOT_ID_ENUM;
  qmi_error_e_type           errval        = QMI_ERR_INTERNAL;

  ASSERT(cl_sp);
  ASSERT(qmi_uim_global_ptr);

  /* If this client is the last registered client
     for the remote SFS events, then deregister with simlock */
  if(cl_sp->uim_info.reg_event_type.simlock_remote_sfs_events)
  {
    qmi_uim_check_and_deregister_remote_sfs_operation(cl_sp->common.clid);
  }

  memset(&(cl_sp->uim_info.reg_event_type),
         0,
         sizeof(cl_sp->uim_info.reg_event_type));

  cl_sp->uim_info.sap_intermediate_get_resp     = FALSE;
  cl_sp->uim_info.refresh_notify_mask           = 0;
  cl_sp->uim_info.refresh_vote                  = FALSE;
  cl_sp->uim_info.refresh_num_files             = 0;
  cl_sp->uim_info.refresh_all_notify_mask       = 0;
  cl_sp->uim_info.card_status_ind_postponed     = FALSE;

  while(cl_sp->uim_info.refresh_files_list != NULL)
  {
    qmi_uim_refresh_file_node_type  * refresh_file_ptr =
      cl_sp->uim_info.refresh_files_list;
    cl_sp->uim_info.refresh_files_list = refresh_file_ptr->next_ptr;
    uimqmi_free(refresh_file_ptr);
  }

  /* Remove client references to non-prov. sessions opened */
  for (i = 0; i < UIM_MAX_NON_PROV_SESSIONS; i++)
  {
    if (qmi_uim_global_ptr->non_prov_session[i].init)
    {
      (void)qmi_uim_remove_cl_sp_from_non_prov_session_index(i, cl_sp);
    }
  }

  /* If security restrictions are not enforced, nothing else to do */
  if (qmi_uim_global_ptr->apdu_sec_restr_value == QMI_UIM_APDU_SEC_RESTRICTIONS_NONE)
  {
    return;
  }

  /* Close the client's logical channel, if any & clean up */
  for (i = 0; i < UIM_MAX_APDU_CHANNEL_COUNT; i++)
  {
    if (qmi_uim_global_ptr->apdu_channel[i] &&
        qmi_uim_global_ptr->apdu_channel[i]->opening_cl_sp == cl_sp)
    {
      mmgsdi_session_close(qmi_uim_global_ptr->apdu_channel[i]->mmgsdi_session_id,
                           qmi_uimi_mmgsdi_callback,
                           (mmgsdi_client_data_type)NULL);
      /* Regardless of result, free the information in the table */
      qmi_uim_remove_apdu_session(
          qmi_uim_global_ptr->apdu_channel[i]->mmgsdi_session_id, FALSE,
          MMGSDI_SESSION_CLOSED_CAUSE_UNKNOWN);
    }
  }

  /* Check to make sure this was not the last client to ack, if so notify
     drivers to proceed with power down. */
  for (i = 0; i < QMI_UIM_MAX_CARD_COUNT; i++)
  {
    if (cl_sp->uim_info.supply_voltage_pending_ack[i])
    {
      cl_sp->uim_info.supply_voltage_pending_ack[i] = FALSE;

      errval = qmi_uim_slot_index_to_mmgsdi_slot(i,
                                                 &mmgsdi_slot);
      if (errval != QMI_ERR_NONE)
      {
        continue;
      }

      (void)qmi_uim_all_reg_clients_ack_vcc_deactivation(mmgsdi_slot);
    }
  }
} /* qmi_uim_init_client_state */


/*===========================================================================
  FUNCTION QMI_UIMI_RESET_CLIENT()

  DESCRIPTION
    Resets the state for the given client

  PARAMETERS
    cl_sp :  client state pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_reset_client
(
  qmi_uimi_client_state_type * cl_sp
)
{
  ASSERT(cl_sp);

  ds_qmi_fw_common_reset_client((qmi_common_client_state_type *)cl_sp);
  qmi_uim_init_client_state(cl_sp);
} /* qmi_uimi_reset_client() */


/*===========================================================================
  FUNCTION QMI_UIMI_POPULATE_RESPONSE()

  DESCRIPTION
    Populates the response TLV

  PARAMETERS
    qmi_err      :  status of QMI operation
    token_valid  :  if valid token is passed
    token        :  value of token
    token_tlv_id :  ID of response TLV

  RETURN VALUE
    Pointer to the response data

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_populate_response
(
  qmi_error_e_type  errval,
  boolean           token_valid,
  uint32            token,
  byte              token_tlv_id
)
{
  dsm_item_type      * response = NULL;
  boolean              retval   = FALSE;

  /* In case of error, send immediate ERROR response. In case of success,
     send immediate SUCCESS response with token for clients requesting indication and
     send PENDING response for all other client requests */
  if (errval == QMI_ERR_NONE)
  {
    if (!token_valid)
    {
      return QMI_SVC_RESPONSE_PENDING;
    }
    else
    {
      UIM_MSG_HIGH_0("Sending token TLV");

      /* Insert indication token TLV in response */
      if (FALSE == qmi_uim_response_ind_token(
                       token_tlv_id,
                       &response,
                       token))
      {
        errval = QMI_ERR_NO_MEMORY;
        dsm_free_packet(&response);
      }
    }
  }

  retval = qmi_svc_put_result_tlv(
             &response,
             (errval != QMI_ERR_NONE) ? QMI_RESULT_FAILURE : QMI_RESULT_SUCCESS,
             errval);

  CHECK_RETVAL();

  return response;
} /* qmi_uimi_populate_response */


/*===========================================================================
  FUNCTION QMI_UIMI_POPULATE_ENCRYPTED_RESPONSE()

  DESCRIPTION
    Populates the encrypted response TLV

  PARAMETERS
    errval   : status of QMI operation
    cmd_id   : command
    req_id   : request id from client

  RETURN VALUE
    Pointer to the response data

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_populate_encrypted_response
(
  qmi_error_e_type                   errval,
  qmi_uimi_cmd_val_e_type            cmd_id,
  uint16                             req_id
)
{
  qmi_error_e_type     error               = QMI_ERR_NONE;
  dsm_item_type      * response            = NULL;
  boolean              retval              = FALSE;

  /* Build the result and encrypt the data and populatate the output sdu */
  error = qmi_uim_response_encrypted_status(UIMI_TLV_RESP_TAG_OPTIONAL_1,
                                            cmd_id,
                                            req_id,
                                            errval,
                                            &response);
  if(error != QMI_ERR_NONE)
  {
    /* Even if encrypted status fails, continue with sending
       response back to client so they are at least notified. */
    UIM_MSG_HIGH_0("failed to build and encrypt response");
  }

  retval = qmi_svc_put_result_tlv(
             &response,
             (errval != QMI_ERR_NONE) ? QMI_RESULT_FAILURE : QMI_RESULT_SUCCESS,
             errval);

  CHECK_RETVAL();

  return response;
} /* qmi_uimi_populate_encrypted_response */


/*===========================================================================
  FUNCTION QMI_UIM_GBA_GET_IMPI_FROM_USIM()

  DESCRIPTION
    Provides the IMPI data from the USIM application

  PARAMETERS
    tlv_session_info_ptr: Session Information TLV pointer
    impi_data_pptr      : Pointer to a pointer of IMPI data

  RETURN VALUE
    QMI_ERR_NONE on success. Other error code on failure

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_gba_get_impi_from_usim
(
  qmi_uim_tlv_session_information_type   *tlv_session_info_ptr,
  qmi_uim_impi_type                     **impi_data_pptr
)
{
  qmi_error_e_type                errval           = QMI_ERR_NONE;
  mmgsdi_slot_id_enum_type        slot_id          = MMGSDI_MAX_SLOT_ID_ENUM;
  mmgsdi_protocol_enum_type       card_protocol    = MMGSDI_NO_PROTOCOL;
  qmi_uim_imsi_type               imsi_data        = {0, };
  qmi_uim_imsi_digits_data_type   imsi_digits_data = {0, };
  mmgsdi_read_data_type           read_data        = {0, NULL};
  uint8                           ad_data[4]       = {0};
  mmgsdi_return_enum_type         mmgsdi_status    = MMGSDI_SUCCESS;
  mmgsdi_session_id_type          session_id       = UIM_INVALID_SESSION_ID;

  if(impi_data_pptr == NULL || tlv_session_info_ptr == NULL)
  {
    return QMI_ERR_INTERNAL;
  }

  /* Retrieve session id */
  errval = qmi_uim_session_type_to_session_id(&session_id,
                                              tlv_session_info_ptr->session_type,
                                              tlv_session_info_ptr->aid);
  if (errval != QMI_ERR_NONE)
  {
    return errval;
  }

  errval = qmi_uim_session_id_to_slot(&slot_id,
                                      session_id);
  if(errval != QMI_ERR_NONE)
  {
    return errval;
  }

  card_protocol = qmi_uim_card_protocol(slot_id);
  if(card_protocol != MMGSDI_UICC)
  {
    UIM_MSG_ERR_1("QMI_UIM_GET_GBA_IMPI is not supported for protocol 0x%x",
                  card_protocol);
    return QMI_ERR_NOT_SUPPORTED;
  }

  /* Read the IMSI from MMGSDI */
  errval = qmi_uim_read_imsi_for_session_id(session_id, &imsi_data);
  if(errval != QMI_ERR_NONE)
  {
    UIM_MSG_ERR_0("Could not read IMSI");
    return errval;
  }

  /* Convert IMSI data in to IMSI digits format */
  errval = qmi_uim_convert_imsi_to_digits(&imsi_data, &imsi_digits_data);
  if (errval != QMI_ERR_NONE)
  {
    return errval;
  }

  /* Read USIM AD to get the number of digits in MNC */
  read_data.data_ptr = ad_data;
  read_data.data_len = 0x04;

  mmgsdi_status = mmgsdi_session_read_cache(session_id,
                                            MMGSDI_USIM_AD,
                                            read_data);
  if (mmgsdi_status != MMGSDI_SUCCESS ||
      (ad_data[3] != 0x02 && ad_data[3] != 0x03))
  {
    return QMI_ERR_INTERNAL;
  }

  *impi_data_pptr = (qmi_uim_impi_type *)uimqmi_malloc(sizeof(qmi_uim_impi_type));
  if(*impi_data_pptr == NULL)
  {
    return QMI_ERR_NO_MEMORY;
  }

  /* Prepare the IMPI from IMSI according to section 13.3 in 3GPP TS.23.003 */
  errval = qmi_uim_prepare_impi_from_imsi(&imsi_digits_data, *impi_data_pptr, ad_data[3]);
  if(errval != QMI_ERR_NONE)
  {
    uimqmi_free(*impi_data_pptr);
    *impi_data_pptr = NULL;
  }

  return errval;
} /* qmi_uim_gba_get_impi_from_usim */


/*===========================================================================
  FUNCTION QMI_UIM_GBA_GET_IMPI_FROM_ISIM()

  DESCRIPTION
    Provides the IMPI data from the ISIM application

  PARAMETERS
    tlv_data_ptr   : Pointer to TLV data
    tlv_data_count : Count of TLV data
    cmd_buf_ptr    : Pointer to command buffer
    cl_sp          : Client data pointer

  RETURN VALUE
    QMI_ERR_NONE on success. Other error code on failure

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_gba_get_impi_from_isim
(
  qmi_uim_tlv_item_type       * tlv_data_ptr,
  uint8                         tlv_data_count,
  void                        * cmd_buf_ptr,
  qmi_uimi_client_state_type  * cl_sp
)
{
  qmi_error_e_type         errval     = QMI_ERR_NONE;
  mmgsdi_session_id_type   session_id = UIM_INVALID_SESSION_ID;

  ASSERT(tlv_data_count >= 2);

  if(tlv_data_ptr == NULL)
  {
    return QMI_ERR_INTERNAL;
  }

  /* Retrieve session id */
  errval = qmi_uim_session_type_to_session_id(&session_id,
                                              tlv_data_ptr[0].data.session_information.session_type,
                                              tlv_data_ptr[0].data.session_information.aid);
  if (errval != QMI_ERR_NONE)
  {
    if(errval == QMI_ERR_DEVICE_NOT_READY)
    {
      return errval;
    }

    /* Try to open session */
    errval = qmi_uim_open_session(UIMI_CMD_VAL_GET_GBA_IMPI,
                                  tlv_data_ptr,
                                  tlv_data_count,
                                  cmd_buf_ptr,
                                  cl_sp);
  }
  else
  {
    qmi_uim_requested_encrytion_type encryption_status = QMI_UIM_NO_ENCRYPTION;
    mmgsdi_access_type               mmgsdi_access;

    memset(&mmgsdi_access, 0x00, sizeof(mmgsdi_access));

    if(tlv_data_ptr[1].data.encrypted.value)
    {
      encryption_status = QMI_UIM_DATA_ONLY_ENCRYPTION;
    }

    /* Read EF IMPI */
    mmgsdi_access.access_method = MMGSDI_EF_ENUM_ACCESS;
    mmgsdi_access.file.file_enum = MMGSDI_ISIM_IMPI;

    errval = qmi_uim_execute_read_transparent(
                            UIMI_CMD_VAL_GET_GBA_IMPI,
                            session_id,
                            mmgsdi_access,
                            0,
                            0,
                            encryption_status,
                            NULL,
                            cmd_buf_ptr,
                            ((qmi_uimi_client_state_type *)cl_sp)->common.clid);

    /* Associate the Client with the requested Session (if it is a
       non-prov. Session) */
    if(errval == QMI_ERR_NONE)
    {
      (void)qmi_uim_update_non_prov_session_cl_sp(tlv_data_ptr,
                                                  tlv_data_count,
                                                  cl_sp);
    }
  }

  return errval;
} /* qmi_uim_gba_get_impi_from_isim */


/*===========================================================================

                             HANDLER FUNCTIONS

===========================================================================*/


/*===========================================================================
  FUNCTION QMI_UIMI_RESET()

  DESCRIPTION
    Reset the issuing client's UIM state

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_reset
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *      response = NULL;
  boolean              retval   = FALSE;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  /* Reset the client's state */
  qmi_uimi_reset_client(cl_sp);

  /* Build the response from back to front
     No error possible in reset, so result is success */
  retval = qmi_svc_put_result_tlv(&response,
                                  QMI_RESULT_SUCCESS,
                                  QMI_ERR_NONE);
  CHECK_RETVAL();

  return response;
} /* qmi_uimi_reset */


/*===========================================================================
  FUNCTION QMI_UIMI_READ_TRANSPARENT()

  DESCRIPTION
    Reads the content of a transparent file on the card

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_read_transparent
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type                  errval          = QMI_ERR_NONE;
  mmgsdi_session_id_type            session_id      = UIM_INVALID_SESSION_ID;
  qmi_uimi_ind_token_info_type      token_info      = {FALSE, 0};
  qmi_uim_tlv_item_type             tlv_data[6];
  qmi_uim_requested_encrytion_type  encrypt_status  = QMI_UIM_NO_ENCRYPTION;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(tlv_data, 0, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_SESSION_INFORMATION;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;
  tlv_data[1].type      = UIMI_TLV_TYPE_FILE_ID;
  tlv_data[1].tag       = UIMI_TLV_TAG_MANDATORY_2;
  tlv_data[2].type      = UIMI_TLV_TYPE_READ_TRANSPARENT;
  tlv_data[2].tag       = UIMI_TLV_TAG_MANDATORY_3;
  tlv_data[3].type      = UIMI_TLV_TYPE_IND_TOKEN;
  tlv_data[3].tag       = UIMI_TLV_TAG_OPTIONAL_1;
  tlv_data[4].type      = UIMI_TLV_TYPE_ENCRYPTED;
  tlv_data[4].tag       = UIMI_TLV_TAG_OPTIONAL_2;
  tlv_data[5].type      = UIMI_TLV_TYPE_ENCRYPTED_EXT;
  tlv_data[5].tag       = UIMI_TLV_TAG_OPTIONAL_3;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 6);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  if (tlv_data[2].data.read_transparent.length > QMI_UIM_READ_TRANSPARENT_MAX_LEN)
  {
    errval = QMI_ERR_INSUFFICIENT_RESOURCES;
    goto send_result;
  }

  /* Check if request needs to be rejected due to security restrictions */
  if (qmi_uim_is_request_rejected(tlv_data[0].data.session_information.session_type,
                                  tlv_data[0].data.session_information.aid,
                                  cl_sp))
  {
    errval = QMI_ERR_ACCESS_DENIED;
    goto send_result;
  }

  /* We cannot process both data only encryption and complete ecryption read requests */
  if(tlv_data[4].present && tlv_data[5].present)
  {
    errval = QMI_ERR_MALFORMED_MSG;
    goto send_result;
  }

  if (tlv_data[4].present && tlv_data[4].data.encrypted.value)
  {
    encrypt_status = QMI_UIM_DATA_ONLY_ENCRYPTION;
  }
  else if (tlv_data[5].present && tlv_data[5].data.encrypted_ext.value)
  {
    encrypt_status = QMI_UIM_COMPLETE_ENCRYPTION;
  }

  /* Update token info */
  token_info.is_valid = tlv_data[3].present;
  token_info.token = tlv_data[3].data.ind_token.value;

  /* Retrieve session id */
  errval = qmi_uim_session_type_to_session_id(&session_id,
                                              tlv_data[0].data.session_information.session_type,
                                              tlv_data[0].data.session_information.aid);

  if (errval != QMI_ERR_NONE)
  {
    if(errval == QMI_ERR_DEVICE_NOT_READY)
    {
      goto send_result;
    }

    /* Try to open session */
    errval = qmi_uim_open_session(UIMI_CMD_VAL_READ_TRANSPARENT,
                                  tlv_data, 4,
                                  token_info.is_valid ? NULL : cmd_buf_p,
                                  cl_sp);
  }
  else
  {
    /* Execute MMGSDI function */
    errval = qmi_uim_execute_read_transparent(
                            UIMI_CMD_VAL_READ_TRANSPARENT,
                            session_id,
                            tlv_data[1].data.file_id.file_access,
                            tlv_data[2].data.read_transparent.offset,
                            tlv_data[2].data.read_transparent.length,
                            encrypt_status,
                            token_info.is_valid ? &token_info.token : NULL,
                            token_info.is_valid ? NULL : cmd_buf_p,
                            ((qmi_uimi_client_state_type *)cl_sp)->common.clid);

    /* Associate the Client with the requested Session (if it is a
       non-prov. Session) */
    if(errval == QMI_ERR_NONE)
    {
      (void)qmi_uim_update_non_prov_session_cl_sp(tlv_data,
                                                  4,
                                                  cl_sp);
    }
  }

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(tlv_data, 6);

  return qmi_uimi_populate_response(errval,
                                    token_info.is_valid,
                                    token_info.token,
                                    UIMI_TLV_RESP_TAG_OPTIONAL_3);
} /* qmi_uimi_read_transparent() */


/*===========================================================================
  FUNCTION QMI_UIMI_READ_RECORD()

  DESCRIPTION
    Reads a record from a cyclic or linear fixed file on the card

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_read_record
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type               errval        = QMI_ERR_NONE;
  mmgsdi_session_id_type         session_id    = UIM_INVALID_SESSION_ID;
  qmi_uimi_ind_token_info_type   token_info    = {FALSE, 0};
  qmi_uim_tlv_item_type          tlv_data[5];

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(tlv_data, 0, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_SESSION_INFORMATION;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;
  tlv_data[1].type      = UIMI_TLV_TYPE_FILE_ID;
  tlv_data[1].tag       = UIMI_TLV_TAG_MANDATORY_2;
  tlv_data[2].type      = UIMI_TLV_TYPE_READ_RECORD;
  tlv_data[2].tag       = UIMI_TLV_TAG_MANDATORY_3;
  tlv_data[3].type      = UIMI_TLV_TYPE_READ_RECORD_LAST;
  tlv_data[3].tag       = UIMI_TLV_TAG_OPTIONAL_1;
  tlv_data[4].type      = UIMI_TLV_TYPE_IND_TOKEN;
  tlv_data[4].tag       = UIMI_TLV_TAG_OPTIONAL_2;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 5);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* Check if request needs to be rejected due to security restrictions */
  if (qmi_uim_is_request_rejected(tlv_data[0].data.session_information.session_type,
                                  tlv_data[0].data.session_information.aid,
                                  cl_sp))
  {
    errval = QMI_ERR_ACCESS_DENIED;
    goto send_result;
  }

  /* Update token info */
  token_info.is_valid = tlv_data[4].present;
  token_info.token = tlv_data[4].data.ind_token.value;

  /* Retrieve session id */
  errval = qmi_uim_session_type_to_session_id(&session_id,
                                              tlv_data[0].data.session_information.session_type,
                                              tlv_data[0].data.session_information.aid);

  if (errval != QMI_ERR_NONE)
  {
    if(errval == QMI_ERR_DEVICE_NOT_READY)
    {
      goto send_result;
    }

    /* Try to open session */
    errval = qmi_uim_open_session(UIMI_CMD_VAL_READ_RECORD,
                                  tlv_data, 5,
                                  token_info.is_valid ? NULL : cmd_buf_p,
                                  cl_sp);
  }
  else
  {
    /* Execute MMGSDI function */
    errval = qmi_uim_execute_read_record(
                            session_id,
                            tlv_data[1].data.file_id.file_access,
                            tlv_data[2].data.read_record.record,
                            (tlv_data[3].present) ?
                              tlv_data[3].data.read_record_last.last_record :
                              tlv_data[2].data.read_record.record,
                            tlv_data[2].data.read_record.length,
                            token_info.is_valid ? &token_info.token : NULL,
                            token_info.is_valid ? NULL : cmd_buf_p,
                            ((qmi_uimi_client_state_type *)cl_sp)->common.clid);

    /* Associate the Client with the requested Session (if it is a
       non-prov. Session) */
    if(errval == QMI_ERR_NONE)
    {
      (void)qmi_uim_update_non_prov_session_cl_sp(tlv_data,
                                                  5,
                                                  cl_sp);
    }
  }

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(tlv_data, 5);

  return qmi_uimi_populate_response(errval,
                                    token_info.is_valid,
                                    token_info.token,
                                    UIMI_TLV_RESP_TAG_OPTIONAL_4);
} /* qmi_uimi_read_record() */


/*===========================================================================
  FUNCTION QMI_UIMI_WRITE_TRANSPARENT()

  DESCRIPTION
    Writes the content of a transparent file on the card

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_write_transparent
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type               errval        = QMI_ERR_NONE;
  mmgsdi_session_id_type         session_id    = UIM_INVALID_SESSION_ID;
  qmi_uimi_ind_token_info_type   token_info    = {FALSE, 0};
  qmi_uim_tlv_item_type          tlv_data[4];

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(tlv_data, 0, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_SESSION_INFORMATION;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;
  tlv_data[1].type      = UIMI_TLV_TYPE_FILE_ID;
  tlv_data[1].tag       = UIMI_TLV_TAG_MANDATORY_2;
  tlv_data[2].type      = UIMI_TLV_TYPE_WRITE_TRANSPARENT;
  tlv_data[2].tag       = UIMI_TLV_TAG_MANDATORY_3;
  tlv_data[3].type      = UIMI_TLV_TYPE_IND_TOKEN;
  tlv_data[3].tag       = UIMI_TLV_TAG_OPTIONAL_1;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 4);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* Check if request needs to be rejected due to security restrictions */
  if (qmi_uim_is_request_rejected(tlv_data[0].data.session_information.session_type,
                                  tlv_data[0].data.session_information.aid,
                                  cl_sp))
  {
    errval = QMI_ERR_ACCESS_DENIED;
    goto send_result;
  }

  /* Update token info */
  token_info.is_valid = tlv_data[3].present;
  token_info.token = tlv_data[3].data.ind_token.value;

  /* Retrieve session id */
  errval = qmi_uim_session_type_to_session_id(&session_id,
                                              tlv_data[0].data.session_information.session_type,
                                              tlv_data[0].data.session_information.aid);

  if (errval != QMI_ERR_NONE)
  {
    if(errval == QMI_ERR_DEVICE_NOT_READY)
    {
      goto send_result;
    }

    /* Try to open session */
    errval = qmi_uim_open_session(UIMI_CMD_VAL_WRITE_TRANSPARENT,
                                  tlv_data, 4,
                                  token_info.is_valid ? NULL : cmd_buf_p,
                                  cl_sp);
  }
  else
  {
    /* Execute MMGSDI function */
    errval = qmi_uim_execute_write_transparent(
                            session_id,
                            tlv_data[1].data.file_id.file_access,
                            tlv_data[2].data.write_transparent.offset,
                            tlv_data[2].data.write_transparent.data,
                            token_info.is_valid ? &token_info.token : NULL,
                            token_info.is_valid ? NULL : cmd_buf_p,
                            ((qmi_uimi_client_state_type *)cl_sp)->common.clid);

    /* Associate the Client with the requested Session (if it is a
       non-prov. Session) */
    if(errval == QMI_ERR_NONE)
    {
      (void)qmi_uim_update_non_prov_session_cl_sp(tlv_data,
                                                  4,
                                                  cl_sp);
    }
  }

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(tlv_data, 4);

  return qmi_uimi_populate_response(errval,
                                    token_info.is_valid,
                                    token_info.token,
                                    UIMI_TLV_RESP_TAG_OPTIONAL_2);
} /* qmi_uimi_write_transparent() */


/*===========================================================================
  FUNCTION QMI_UIMI_WRITE_RECORD()

  DESCRIPTION
    Writes a record on a cyclic or linear fixed file on the card

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_write_record
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type               errval        = QMI_ERR_NONE;
  mmgsdi_session_id_type         session_id    = UIM_INVALID_SESSION_ID;
  qmi_uimi_ind_token_info_type   token_info    = {FALSE, 0};
  qmi_uim_tlv_item_type          tlv_data[4];

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(tlv_data, 0, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_SESSION_INFORMATION;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;
  tlv_data[1].type      = UIMI_TLV_TYPE_FILE_ID;
  tlv_data[1].tag       = UIMI_TLV_TAG_MANDATORY_2;
  tlv_data[2].type      = UIMI_TLV_TYPE_WRITE_RECORD;
  tlv_data[2].tag       = UIMI_TLV_TAG_MANDATORY_3;
  tlv_data[3].type      = UIMI_TLV_TYPE_IND_TOKEN;
  tlv_data[3].tag       = UIMI_TLV_TAG_OPTIONAL_1;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 4);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* Check if request needs to be rejected due to security restrictions */
  if (qmi_uim_is_request_rejected(tlv_data[0].data.session_information.session_type,
                                  tlv_data[0].data.session_information.aid,
                                  cl_sp))
  {
    errval = QMI_ERR_ACCESS_DENIED;
    goto send_result;
  }

  /* Update token info */
  token_info.is_valid = tlv_data[3].present;
  token_info.token = tlv_data[3].data.ind_token.value;

  /* Retrieve session id */
  errval = qmi_uim_session_type_to_session_id(&session_id,
                                              tlv_data[0].data.session_information.session_type,
                                              tlv_data[0].data.session_information.aid);

  if (errval != QMI_ERR_NONE)
  {
    if(errval == QMI_ERR_DEVICE_NOT_READY)
    {
      goto send_result;
    }

    /* Try to open session */
    errval = qmi_uim_open_session(UIMI_CMD_VAL_WRITE_RECORD,
                                  tlv_data, 4,
                                  token_info.is_valid ? NULL : cmd_buf_p,
                                  cl_sp);
  }
  else
  {
    /* Execute MMGSDI function */
    errval = qmi_uim_execute_write_record(
                            session_id,
                            tlv_data[1].data.file_id.file_access,
                            tlv_data[2].data.write_record.record,
                            tlv_data[2].data.write_record.data,
                            token_info.is_valid ? &token_info.token : NULL,
                            token_info.is_valid ? NULL : cmd_buf_p,
                            ((qmi_uimi_client_state_type *)cl_sp)->common.clid);

    /* Associate the Client with the requested Session (if it is a
       non-prov. Session) */
    if(errval == QMI_ERR_NONE)
    {
      (void)qmi_uim_update_non_prov_session_cl_sp(tlv_data,
                                                  4,
                                                  cl_sp);
    }
  }

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(tlv_data, 4);

  return qmi_uimi_populate_response(errval,
                                    token_info.is_valid,
                                    token_info.token,
                                    UIMI_TLV_RESP_TAG_OPTIONAL_2);
} /* qmi_uimi_write_record() */


/*===========================================================================
  FUNCTION QMI_UIMI_GET_FILE_ATTRIBUTES()

  DESCRIPTION
    Get file attributes of a file on the card

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_get_file_attributes
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type               errval        = QMI_ERR_NONE;
  mmgsdi_session_id_type         session_id    = UIM_INVALID_SESSION_ID;
  qmi_uimi_ind_token_info_type   token_info    = {FALSE, 0};
  qmi_uim_tlv_item_type          tlv_data[3];

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(tlv_data, 0, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_SESSION_INFORMATION;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;
  tlv_data[1].type      = UIMI_TLV_TYPE_FILE_ID;
  tlv_data[1].tag       = UIMI_TLV_TAG_MANDATORY_2;
  tlv_data[2].type      = UIMI_TLV_TYPE_IND_TOKEN;
  tlv_data[2].tag       = UIMI_TLV_TAG_OPTIONAL_1;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 3);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* Check if request needs to be rejected due to security restrictions */
  if (qmi_uim_is_request_rejected(tlv_data[0].data.session_information.session_type,
                                  tlv_data[0].data.session_information.aid,
                                  cl_sp))
  {
    errval = QMI_ERR_ACCESS_DENIED;
    goto send_result;
  }

  /* Update token info */
  token_info.is_valid = tlv_data[2].present;
  token_info.token = tlv_data[2].data.ind_token.value;

  /* Retrieve session id */
  errval = qmi_uim_session_type_to_session_id(&session_id,
                                              tlv_data[0].data.session_information.session_type,
                                              tlv_data[0].data.session_information.aid);

  if (errval != QMI_ERR_NONE)
  {
    if(errval == QMI_ERR_DEVICE_NOT_READY)
    {
      goto send_result;
    }

    /* Try to open session */
    errval = qmi_uim_open_session(UIMI_CMD_VAL_GET_FILE_ATTRIBUTES,
                                  tlv_data, 3,
                                  token_info.is_valid ? NULL : cmd_buf_p,
                                  cl_sp);
  }
  else
  {
    /* Execute MMGSDI function */
    errval = qmi_uim_execute_get_file_attributes(
                            session_id,
                            tlv_data[1].data.file_id.file_access,
                            token_info.is_valid ? &token_info.token : NULL,
                            token_info.is_valid ? NULL : cmd_buf_p,
                            ((qmi_uimi_client_state_type *)cl_sp)->common.clid);

    /* Associate the Client with the requested Session (if it is a
       non-prov. Session) */
    if(errval == QMI_ERR_NONE)
    {
      (void)qmi_uim_update_non_prov_session_cl_sp(tlv_data,
                                                  3,
                                                  cl_sp);
    }
  }

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(tlv_data, 3);

  return qmi_uimi_populate_response(errval,
                                    token_info.is_valid,
                                    token_info.token,
                                    UIMI_TLV_RESP_TAG_OPTIONAL_3);
} /* qmi_uimi_get_file_attributes() */


/*===========================================================================
  FUNCTION QMI_UIMI_SET_PIN_PROTECTION()

  DESCRIPTION
    Enable / Disable the pin on the card

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_set_pin_protection
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type               errval        = QMI_ERR_NONE;
  mmgsdi_session_id_type         session_id    = UIM_INVALID_SESSION_ID;
  qmi_uimi_ind_token_info_type   token_info    = {FALSE, 0};
  qmi_uim_tlv_item_type          tlv_data[4];

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(tlv_data, 0, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_SESSION_INFORMATION;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;
  tlv_data[1].type      = UIMI_TLV_TYPE_SET_PIN_PROTECTION;
  tlv_data[1].tag       = UIMI_TLV_TAG_MANDATORY_2;
  tlv_data[2].type      = UIMI_TLV_TYPE_PIN_KEYREF_ID;
  tlv_data[2].tag       = UIMI_TLV_TAG_OPTIONAL_1;
  tlv_data[3].type      = UIMI_TLV_TYPE_IND_TOKEN;
  tlv_data[3].tag       = UIMI_TLV_TAG_OPTIONAL_2;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 4);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* Check if request needs to be rejected due to security restrictions */
  if (qmi_uim_is_request_rejected(tlv_data[0].data.session_information.session_type,
                                  tlv_data[0].data.session_information.aid,
                                  cl_sp))
  {
    errval = QMI_ERR_ACCESS_DENIED;
    goto send_result;
  }

  /* Update token info */
  token_info.is_valid = tlv_data[3].present;
  token_info.token = tlv_data[3].data.ind_token.value;

  /* If keyref_id TLV is present, map to appropriate MMGSDI pin_id */
  if (tlv_data[2].present)
  {
    errval = qmi_uim_update_pin_id(&tlv_data[1].data.set_pin_protection.pin_id,
                                   tlv_data[2].data.pin_keyref_id.keyref_id);
    if (errval != QMI_ERR_NONE)
    {
      goto send_result;
    }
  }

  /* Retrieve session id */
  errval = qmi_uim_session_type_to_session_id(&session_id,
                                              tlv_data[0].data.session_information.session_type,
                                              tlv_data[0].data.session_information.aid);

  if (errval != QMI_ERR_NONE)
  {
    if(errval == QMI_ERR_DEVICE_NOT_READY)
    {
      goto send_result;
    }

    /* Try to open session: valid for all PINs except hidden key */
    if (tlv_data[1].data.verify_pin.pin_id != MMGSDI_HIDDENKEY)
    {
      errval = qmi_uim_open_session(UIMI_CMD_VAL_SET_PIN_PROTECTION,
                                    tlv_data, 4,
                                    token_info.is_valid ? NULL : cmd_buf_p,
                                    cl_sp);
    }
  }
  else
  {
    /* Execute MMGSDI function */
    errval = qmi_uim_execute_set_pin_protection(
                            session_id,
                            tlv_data[1].data.set_pin_protection.pin_enable,
                            tlv_data[1].data.set_pin_protection.pin_id,
                            tlv_data[1].data.set_pin_protection.pin_data,
                            token_info.is_valid ? &token_info.token : NULL,
                            token_info.is_valid ? NULL : cmd_buf_p,
                            ((qmi_uimi_client_state_type *)cl_sp)->common.clid);

    /* Associate the Client with the requested Session (if it is a
       non-prov. Session) */
    if(errval == QMI_ERR_NONE)
    {
      (void)qmi_uim_update_non_prov_session_cl_sp(tlv_data,
                                                  4,
                                                  cl_sp);
    }
  }

send_result:
  /* Free the buffer used for data: this also clears the PIN
     information for security reason */
  qmi_uim_free_tlv_content(tlv_data, 4);

  return qmi_uimi_populate_response(errval,
                                    token_info.is_valid,
                                    token_info.token,
                                    UIMI_TLV_RESP_TAG_OPTIONAL_3);
} /* qmi_uimi_set_pin_protection() */


/*===========================================================================
  FUNCTION QMI_UIMI_VERIFY_PIN()

  DESCRIPTION
    Verify the PIN

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_verify_pin
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type               errval        = QMI_ERR_NONE;
  mmgsdi_session_id_type         session_id    = UIM_INVALID_SESSION_ID;
  qmi_uimi_ind_token_info_type   token_info    = {FALSE, 0};
  qmi_uim_tlv_item_type          tlv_data[5];

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(tlv_data, 0, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_SESSION_INFORMATION;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;
  tlv_data[1].type      = UIMI_TLV_TYPE_VERIFY_PIN;
  tlv_data[1].tag       = UIMI_TLV_TAG_MANDATORY_2;
  tlv_data[2].type      = UIMI_TLV_TYPE_DECRYPTED_PIN;
  tlv_data[2].tag       = UIMI_TLV_TAG_OPTIONAL_1;
  tlv_data[3].type      = UIMI_TLV_TYPE_PIN_KEYREF_ID;
  tlv_data[3].tag       = UIMI_TLV_TAG_OPTIONAL_2;
  tlv_data[4].type      = UIMI_TLV_TYPE_IND_TOKEN;
  tlv_data[4].tag       = UIMI_TLV_TAG_OPTIONAL_3;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 5);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* Check if request needs to be rejected due to security restrictions */
  if (qmi_uim_is_request_rejected(tlv_data[0].data.session_information.session_type,
                                  tlv_data[0].data.session_information.aid,
                                  cl_sp))
  {
    errval = QMI_ERR_ACCESS_DENIED;
    goto send_result;
  }

  /* Update token info */
  token_info.is_valid = tlv_data[4].present;
  token_info.token = tlv_data[4].data.ind_token.value;

  /* If keyref_id TLV is present, map to appropriate MMGSDI pin_id */
  if (tlv_data[3].present)
  {
    errval = qmi_uim_update_pin_id(&tlv_data[1].data.verify_pin.pin_id,
                                   tlv_data[3].data.pin_keyref_id.keyref_id);
    if (errval != QMI_ERR_NONE)
    {
      goto send_result;
    }
  }

  /* Retrieve session id */
  errval = qmi_uim_session_type_to_session_id(&session_id,
                                              tlv_data[0].data.session_information.session_type,
                                              tlv_data[0].data.session_information.aid);

  if (errval != QMI_ERR_NONE)
  {
    if(errval == QMI_ERR_DEVICE_NOT_READY)
    {
      goto send_result;
    }

    /* Try to open session: valid for all PINs except hidden key */
    if (tlv_data[1].data.verify_pin.pin_id != MMGSDI_HIDDENKEY)
    {
      errval = qmi_uim_open_session(UIMI_CMD_VAL_VERIFY_PIN,
                                    tlv_data, 5,
                                    token_info.is_valid ? NULL : cmd_buf_p,
                                    cl_sp);
    }
  }
  else
  {
    /* Execute MMGSDI function */
    errval = qmi_uim_execute_verify_pin(
                            session_id,
                            tlv_data[1].data.verify_pin.pin_id,
                            (tlv_data[2].present && qmi_uim_global_ptr->silent_pin1_supported) ?
                              tlv_data[2].data.decrypted_pin.decrypted_pin_data :
                              tlv_data[1].data.verify_pin.pin_data,
                            (tlv_data[2].present && qmi_uim_global_ptr->silent_pin1_supported) ?
                              TRUE : FALSE,
                            token_info.is_valid ? &token_info.token : NULL,
                            token_info.is_valid ? NULL : cmd_buf_p,
                            ((qmi_uimi_client_state_type *)cl_sp)->common.clid);

    /* Associate the Client with the requested Session (if it is a
       non-prov. Session) */
    if(errval == QMI_ERR_NONE)
    {
      (void)qmi_uim_update_non_prov_session_cl_sp(tlv_data,
                                                  5,
                                                  cl_sp);
    }
  }

send_result:
  /* Free the buffer used for data: this also clears the PIN
     information for security reason */
  qmi_uim_free_tlv_content(tlv_data, 5);

  return qmi_uimi_populate_response(errval,
                                    token_info.is_valid,
                                    token_info.token,
                                    UIMI_TLV_RESP_TAG_OPTIONAL_3);
} /* qmi_uimi_verify_pin() */


/*===========================================================================
  FUNCTION QMI_UIMI_UNBLOCK_PIN()

  DESCRIPTION
    Unblocks the PIN

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_unblock_pin
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type               errval        = QMI_ERR_NONE;
  mmgsdi_session_id_type         session_id    = UIM_INVALID_SESSION_ID;
  qmi_uimi_ind_token_info_type   token_info    = {FALSE, 0};
  qmi_uim_tlv_item_type          tlv_data[4];

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(tlv_data, 0, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_SESSION_INFORMATION;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;
  tlv_data[1].type      = UIMI_TLV_TYPE_UNBLOCK_PIN;
  tlv_data[1].tag       = UIMI_TLV_TAG_MANDATORY_2;
  tlv_data[2].type      = UIMI_TLV_TYPE_PIN_KEYREF_ID;
  tlv_data[2].tag       = UIMI_TLV_TAG_OPTIONAL_1;
  tlv_data[3].type      = UIMI_TLV_TYPE_IND_TOKEN;
  tlv_data[3].tag       = UIMI_TLV_TAG_OPTIONAL_2;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 4);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* Check if request needs to be rejected due to security restrictions */
  if (qmi_uim_is_request_rejected(tlv_data[0].data.session_information.session_type,
                                  tlv_data[0].data.session_information.aid,
                                  cl_sp))
  {
    errval = QMI_ERR_ACCESS_DENIED;
    goto send_result;
  }

  /* Update token info */
  token_info.is_valid = tlv_data[3].present;
  token_info.token = tlv_data[3].data.ind_token.value;

  /* If keyref_id TLV is present, map to appropriate MMGSDI pin_id */
  if (tlv_data[2].present)
  {
    errval = qmi_uim_update_pin_id(&tlv_data[1].data.unblock_pin.pin_id,
                                   tlv_data[2].data.pin_keyref_id.keyref_id);
    if (errval != QMI_ERR_NONE)
    {
      goto send_result;
    }
  }

  /* Retrieve session id */
  errval = qmi_uim_session_type_to_session_id(&session_id,
                                              tlv_data[0].data.session_information.session_type,
                                              tlv_data[0].data.session_information.aid);

  if (errval != QMI_ERR_NONE)
  {
    if(errval == QMI_ERR_DEVICE_NOT_READY)
    {
      goto send_result;
    }

    /* Try to open session */
    errval = qmi_uim_open_session(UIMI_CMD_VAL_UNBLOCK_PIN,
                                  tlv_data, 4,
                                  token_info.is_valid ? NULL : cmd_buf_p,
                                  cl_sp);
  }
  else
  {
    /* Execute MMGSDI function */
    errval = qmi_uim_execute_unblock_pin(
                            session_id,
                            tlv_data[1].data.unblock_pin.pin_id,
                            tlv_data[1].data.unblock_pin.puk_data,
                            tlv_data[1].data.unblock_pin.pin_data,
                            token_info.is_valid ? &token_info.token : NULL,
                            token_info.is_valid ? NULL : cmd_buf_p,
                            ((qmi_uimi_client_state_type *)cl_sp)->common.clid);

    /* Associate the Client with the requested Session (if it is a
       non-prov. Session) */
    if(errval == QMI_ERR_NONE)
    {
      (void)qmi_uim_update_non_prov_session_cl_sp(tlv_data,
                                                  4,
                                                  cl_sp);
    }
  }

send_result:
  /* Free the buffer used for data: this also clears the PIN
     information for security reason */
  qmi_uim_free_tlv_content(tlv_data, 4);

  return qmi_uimi_populate_response(errval,
                                    token_info.is_valid,
                                    token_info.token,
                                    UIMI_TLV_RESP_TAG_OPTIONAL_3);
} /* qmi_uimi_unblock_pin() */


/*===========================================================================
  FUNCTION QMI_UIMI_CHANGE_PIN()

  DESCRIPTION
    Changes the PIN

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_change_pin
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type               errval        = QMI_ERR_NONE;
  mmgsdi_session_id_type         session_id    = UIM_INVALID_SESSION_ID;
  qmi_uimi_ind_token_info_type   token_info    = {FALSE, 0};
  qmi_uim_tlv_item_type          tlv_data[4];

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(tlv_data, 0, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_SESSION_INFORMATION;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;
  tlv_data[1].type      = UIMI_TLV_TYPE_CHANGE_PIN;
  tlv_data[1].tag       = UIMI_TLV_TAG_MANDATORY_2;
  tlv_data[2].type      = UIMI_TLV_TYPE_PIN_KEYREF_ID;
  tlv_data[2].tag       = UIMI_TLV_TAG_OPTIONAL_1;
  tlv_data[3].type      = UIMI_TLV_TYPE_IND_TOKEN;
  tlv_data[3].tag       = UIMI_TLV_TAG_OPTIONAL_2;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 4);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* Check if request needs to be rejected due to security restrictions */
  if (qmi_uim_is_request_rejected(tlv_data[0].data.session_information.session_type,
                                  tlv_data[0].data.session_information.aid,
                                  cl_sp))
  {
    errval = QMI_ERR_ACCESS_DENIED;
    goto send_result;
  }

  /* Update token info */
  token_info.is_valid = tlv_data[3].present;
  token_info.token = tlv_data[3].data.ind_token.value;

  /* If keyref_id TLV is present, map to appropriate MMGSDI pin_id */
  if (tlv_data[2].present)
  {
    errval = qmi_uim_update_pin_id(&tlv_data[1].data.change_pin.pin_id,
                                   tlv_data[2].data.pin_keyref_id.keyref_id);
    if (errval != QMI_ERR_NONE)
    {
      goto send_result;
    }
  }

  /* Retrieve session id */
  errval = qmi_uim_session_type_to_session_id(&session_id,
                                              tlv_data[0].data.session_information.session_type,
                                              tlv_data[0].data.session_information.aid);

  if (errval != QMI_ERR_NONE)
  {
    if(errval == QMI_ERR_DEVICE_NOT_READY)
    {
      goto send_result;
    }

    /* Try to open session: valid for all PINs except hidden key */
    if (tlv_data[1].data.verify_pin.pin_id != MMGSDI_HIDDENKEY)
    {
      errval = qmi_uim_open_session(UIMI_CMD_VAL_CHANGE_PIN,
                                    tlv_data, 4,
                                    token_info.is_valid ? NULL : cmd_buf_p,
                                    cl_sp);
    }
  }
  else
  {
    /* Execute MMGSDI function */
    errval = qmi_uim_execute_change_pin(
                            session_id,
                            tlv_data[1].data.change_pin.pin_id,
                            tlv_data[1].data.change_pin.old_pin_data,
                            tlv_data[1].data.change_pin.new_pin_data,
                            token_info.is_valid ? &token_info.token : NULL,
                            token_info.is_valid ? NULL : cmd_buf_p,
                            ((qmi_uimi_client_state_type *)cl_sp)->common.clid);

    /* Associate the Client with the requested Session (if it is a
       non-prov. Session) */
    if(errval == QMI_ERR_NONE)
    {
      (void)qmi_uim_update_non_prov_session_cl_sp(tlv_data,
                                                  4,
                                                  cl_sp);
    }
  }

send_result:
  /* Free the buffer used for data: this also clears the PIN
     information for security reason */
  qmi_uim_free_tlv_content(tlv_data, 4);

  return qmi_uimi_populate_response(errval,
                                    token_info.is_valid,
                                    token_info.token,
                                    UIMI_TLV_RESP_TAG_OPTIONAL_3);
} /* qmi_uimi_change_pin() */


/*===========================================================================
  FUNCTION QMI_UIMI_DEPERSONALIZATION()

  DESCRIPTION
    Deactivates or Unblocks depersonalization

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_depersonalization
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type                     errval          = QMI_ERR_NONE;
  qmi_uimi_userdata_type*              cb_userdata_ptr = NULL;
  qmi_uim_tlv_item_type                tlv_data[2];
  simlock_result_enum_type             simlock_status  = SIMLOCK_SUCCESS;
  simlock_unlock_device_msg_req_type   unlock_msg;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);
  ASSERT(qmi_uim_global_ptr);

  memset(tlv_data, 0, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_DEPERSONALIZATION;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;
  tlv_data[1].type      = UIMI_TLV_TYPE_SLOT;
  tlv_data[1].tag       = UIMI_TLV_TAG_OPTIONAL_1;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 2);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  memset(&unlock_msg, 0x00, sizeof(unlock_msg));

  unlock_msg.category = tlv_data[0].data.depersonalization.category;
  unlock_msg.ck       = tlv_data[0].data.depersonalization.ck;

  if (tlv_data[1].present)
  {
    if(qmi_uim_mmgsdi_slot_id_to_simlock_slot_id(tlv_data[1].data.slot.slot,
                                                 &unlock_msg.slot) != QMI_ERR_NONE)
    {
      errval = QMI_ERR_INTERNAL;
      goto send_result;
    }
  }
  else
  {
    /* default to slot-1 */
    unlock_msg.slot = SIMLOCK_SLOT_1;
  }

  /* Create userdata */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_DEPERSONALIZATION,
                                            cmd_buf_p,
                                            NULL,
                                            ((qmi_uimi_client_state_type *)cl_sp)->common.clid);
  if (cb_userdata_ptr == NULL)
  {
    errval = QMI_ERR_NO_MEMORY;
    goto send_result;
  }

  cb_userdata_ptr->data.simlock_unlock.category      = unlock_msg.category;
  cb_userdata_ptr->data.simlock_unlock.slot          = unlock_msg.slot;
  cb_userdata_ptr->data.simlock_unlock.ck_present    = TRUE;
  /* Set request id to dummy value as it will not be used for regular depersonalization */
  cb_userdata_ptr->data.simlock_unlock.request_id    = 0;

  /* Unlock the SIM */
  simlock_status = simlock_unlock(unlock_msg,
                                  qmi_uimi_simlock_callback,
                                  cb_userdata_ptr);

  /* Free userdata in case of error */
  QMI_UIM_SIMLOCK_FREE_USERDATA_IF_ERROR(simlock_status, cb_userdata_ptr);

  /* Convert MMGSDI status into QMI err code */
  errval = qmi_uim_convert_simlock_status_to_errval(simlock_status);

send_result:
  /* Free the buffer used for data: this also clears the CK
     information for security reason */
  qmi_uim_free_tlv_content(tlv_data, 2);

  return qmi_uimi_populate_response(errval,
                                    FALSE,
                                    0,
                                    0);
} /* qmi_uimi_depersonalization() */


/*===========================================================================
  FUNCTION qmi_uimi_event_reg()

  DESCRIPTION
    Registers for card events

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_event_reg
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type             errval     = QMI_ERR_NONE;
  dsm_item_type *              response   = NULL;
  boolean                      retval     = TRUE;
  qmi_result_e_type            result     = QMI_RESULT_SUCCESS;
  qmi_uimi_client_state_type * client_sp  = NULL;
  uint8                        changes    = 0;
  qmi_uim_tlv_item_type        tlv_data[1];

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(tlv_data, 0, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_EVENT_REG;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 1);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* Update registration flag for this client. */
  client_sp = (qmi_uimi_client_state_type *) cl_sp;
  if (client_sp->uim_info.reg_event_type.card_status != tlv_data[0].data.event_reg.card_status)
  {
    client_sp->uim_info.reg_event_type.card_status = tlv_data[0].data.event_reg.card_status;
    changes++;
  }
  if (client_sp->uim_info.reg_event_type.sap_events != tlv_data[0].data.event_reg.sap_events)
  {
    client_sp->uim_info.reg_event_type.sap_events = tlv_data[0].data.event_reg.sap_events;
    changes++;
  }
  if (client_sp->uim_info.reg_event_type.extended_card_status != tlv_data[0].data.event_reg.extended_card_status)
  {
    client_sp->uim_info.reg_event_type.extended_card_status = tlv_data[0].data.event_reg.extended_card_status;
    changes++;
  }
  if(client_sp->uim_info.reg_event_type.prov_session_close_event != tlv_data[0].data.event_reg.provisioning_session_close_event)
  {
    client_sp->uim_info.reg_event_type.prov_session_close_event = tlv_data[0].data.event_reg.provisioning_session_close_event;
    changes++;
  }
  if (client_sp->uim_info.reg_event_type.physical_slots_status != tlv_data[0].data.event_reg.physical_slots_status)
  {
    client_sp->uim_info.reg_event_type.physical_slots_status = tlv_data[0].data.event_reg.physical_slots_status;
    changes++;
  }
  if(client_sp->uim_info.reg_event_type.sim_busy_events != tlv_data[0].data.event_reg.sim_busy_events)
  {
    client_sp->uim_info.reg_event_type.sim_busy_events = tlv_data[0].data.event_reg.sim_busy_events;
    changes++;
  }
  if(client_sp->uim_info.reg_event_type.reduced_card_status_events != tlv_data[0].data.event_reg.reduced_card_status_events)
  {
    client_sp->uim_info.reg_event_type.reduced_card_status_events = tlv_data[0].data.event_reg.reduced_card_status_events;
    changes++;
  }
  if(client_sp->uim_info.reg_event_type.recovery_complete_event != tlv_data[0].data.event_reg.recovery_complete_event)
  {
    client_sp->uim_info.reg_event_type.recovery_complete_event = tlv_data[0].data.event_reg.recovery_complete_event;
    changes++;
  }
  if(client_sp->uim_info.reg_event_type.supply_voltage_events != tlv_data[0].data.event_reg.supply_voltage_events)
  {
    client_sp->uim_info.reg_event_type.supply_voltage_events = tlv_data[0].data.event_reg.supply_voltage_events;
    changes++;
  }
  if(client_sp->uim_info.reg_event_type.reg_for_activation_status_event != tlv_data[0].data.event_reg.activation_status_event)
  {
    client_sp->uim_info.reg_event_type.reg_for_activation_status_event = tlv_data[0].data.event_reg.activation_status_event;
    changes++;
  }
  if(client_sp->uim_info.reg_event_type.simlock_remote_sfs_events != tlv_data[0].data.event_reg.simlock_remote_sfs_events)
  {
    client_sp->uim_info.reg_event_type.simlock_remote_sfs_events = tlv_data[0].data.event_reg.simlock_remote_sfs_events;
    changes++;

    /* A client registered for remote SFS events. So register with
       simlock for performing remote SFS operation */
    if (tlv_data[0].data.event_reg.simlock_remote_sfs_events)
    {
      qmi_uim_register_for_remote_sfs_operation();
    }
    else
    {
      qmi_uim_check_and_deregister_remote_sfs_operation(client_sp->common.clid);
    }
  }
  if(client_sp->uim_info.reg_event_type.simlock_temp_unlock_status != tlv_data[0].data.event_reg.simlock_temp_unlock_status)
  {
    client_sp->uim_info.reg_event_type.simlock_temp_unlock_status = tlv_data[0].data.event_reg.simlock_temp_unlock_status;
    changes++;
  }

  /* Check if something was updated */
  if (changes == 0)
  {
    UIM_MSG_HIGH_0("Event reg: no effect");
    errval = QMI_ERR_NO_EFFECT;
  }

  /* Compose response payload */
  if (FALSE == qmi_uim_response_event_reg(
                  UIMI_TLV_RESP_TAG_OPTIONAL_1,
                  &response,
                  client_sp->uim_info.reg_event_type))
  {
    errval = QMI_ERR_NO_MEMORY;
    dsm_free_packet(&response);
  }

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(tlv_data, 1);

  /* Send the response */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  CHECK_RETVAL();

  return response;
} /* qmi_uimi_event_reg() */


/*===========================================================================
  FUNCTION qmi_uimi_get_card_status()

  DESCRIPTION
    Get current card events

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_get_card_status
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type     errval        = QMI_ERR_NONE;
  dsm_item_type *      response      = NULL;
  boolean              retval        = TRUE;
  qmi_result_e_type    result        = QMI_RESULT_SUCCESS;
  uint8                slot          = 0;
  uint8                rt_status_len = 0;
  uim_rt_status_enum   uim_rt_status[QMI_UIM_MAX_CARD_COUNT];
  qmi_uim_tlv_item_type tlv_data[1];

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);
  ASSERT(qmi_uim_global_ptr);

  memset(tlv_data, 0, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_EXTENDED_CARD_STATUS;
  tlv_data[0].tag       = UIMI_TLV_TAG_OPTIONAL_1;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 1);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  for (slot = 0; slot < QMI_UIM_MAX_CARD_COUNT; slot++)
  {
    uim_rt_status[slot] = UIM_RT_STATUS_UNKNOWN;
    if (slot < qmi_uim_global_ptr->card_state.num_slots)
    {
      uim_rt_status[slot] = uim_get_rt_status((uim_slot_type)(UIM_SLOT_1 + slot));
    }
  }

  if (tlv_data[0].present &&
      tlv_data[0].data.extended_card_status.value)
  {
    /* Insert extended card status item in TLV */
    if (FALSE == qmi_uim_response_extended_card_status(UIMI_TLV_RESP_TAG_OPTIONAL_4,
                                                       &response,
                                                       &qmi_uim_global_ptr->card_state,
                                                       sizeof(qmi_uim_global_ptr->card_state_valid),
                                                       qmi_uim_global_ptr->card_state_valid))
    {
      errval = QMI_ERR_NO_MEMORY;
      dsm_free_packet(&response);
    }

    /* Insert status of hot swap switch in TLV */
    rt_status_len = (QMI_UIM_MAX_CARD_COUNT < qmi_uim_global_ptr->card_state.num_slots) ?
                      QMI_UIM_MAX_CARD_COUNT : qmi_uim_global_ptr->card_state.num_slots;
    if (FALSE == qmi_uim_response_hot_swap_status(UIMI_TLV_RESP_TAG_OPTIONAL_5,
                                                  &response,
                                                  TRUE,
                                                  rt_status_len,
                                                  uim_rt_status))
    {
      UIM_MSG_HIGH_0("Error in constructing hot_swap_status; ignoring TLV");
    }
  }
  else
  {
    /* Insert legacy card status item in TLV */
    if (FALSE == qmi_uim_response_card_status(UIMI_TLV_RESP_TAG_OPTIONAL_1,
                                              &response,
                                              &qmi_uim_global_ptr->card_state))
    {
      errval = QMI_ERR_NO_MEMORY;
      dsm_free_packet(&response);
    }

    /* Insert status of hot swap switch in TLV */
    rt_status_len = (QMI_UIM_LEGACY_MAX_CARD_COUNT < qmi_uim_global_ptr->card_state.num_slots) ?
                      QMI_UIM_LEGACY_MAX_CARD_COUNT : qmi_uim_global_ptr->card_state.num_slots;
    if (FALSE == qmi_uim_response_hot_swap_status(UIMI_TLV_RESP_TAG_OPTIONAL_2,
                                                  &response,
                                                  FALSE,
                                                  rt_status_len,
                                                  uim_rt_status))
    {
      UIM_MSG_HIGH_0("Error in constructing hot_swap_status; ignoring TLV");
    }

    /* Insert the card status validity TLV */
    if (FALSE == qmi_uim_response_card_status_validity(
                   UIMI_TLV_RESP_TAG_OPTIONAL_3,
                   &response,
                   (QMI_UIM_LEGACY_MAX_CARD_COUNT < qmi_uim_global_ptr->card_state.num_slots) ?
                    QMI_UIM_LEGACY_MAX_CARD_COUNT : qmi_uim_global_ptr->card_state.num_slots,
                   qmi_uim_global_ptr->card_state_valid))
    {
      UIM_MSG_HIGH_0("Error in constructing card_status_validity TLV");
    }
  }

  /* Insert the sim busy TLV */
  if (FALSE == qmi_uim_response_sim_busy(
                 UIMI_TLV_RESP_TAG_OPTIONAL_6,
                 &response,
                 &qmi_uim_global_ptr->card_state))
  {
    UIM_MSG_HIGH_0("Error in constructing sim_busy TLV");
  }

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(tlv_data, 1);

  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  CHECK_RETVAL();

  return response;
} /* qmi_uimi_get_card_status() */


/*===========================================================================
  FUNCTION QMI_UIMI_REFRESH_REGISTER()

  DESCRIPTION
    Register for refresh. This function sends immediately the response to
    the application, even if MMGSDI still needs to process it. This is
    consistent with all other refresh commands.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_uimi_refresh_register
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *                response        = NULL;
  qmi_error_e_type               errval          = QMI_ERR_NONE;
  qmi_result_e_type              result          = QMI_RESULT_SUCCESS;
  boolean                        retval          = TRUE;
  mmgsdi_session_id_type         session_id      = UIM_INVALID_SESSION_ID;
  boolean                        opening_session = FALSE;
  qmi_uim_tlv_item_type          tlv_data[2];

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(tlv_data, 0, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_SESSION_INFORMATION;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;
  tlv_data[1].type      = UIMI_TLV_TYPE_REGISTER_REFRESH;
  tlv_data[1].tag       = UIMI_TLV_TAG_MANDATORY_2;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 2);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* Make sure that we are not using an APDU session */
  if ((tlv_data[0].data.session_information.session_type == MMGSDI_NON_PROV_SESSION_SLOT_1 ||
       tlv_data[0].data.session_information.session_type == MMGSDI_NON_PROV_SESSION_SLOT_2 ||
       tlv_data[0].data.session_information.session_type == MMGSDI_NON_PROV_SESSION_SLOT_3) &&
       tlv_data[0].data.session_information.aid.data_len == QMI_UIM_TLV_CHANNEL_ID_LEN)
  {
    errval = QMI_ERR_INVALID_ARG;
    goto send_result;
  }

  /* Retrieve session id */
  errval = qmi_uim_session_type_to_session_id(&session_id,
                                              tlv_data[0].data.session_information.session_type,
                                              tlv_data[0].data.session_information.aid);

  if (errval != QMI_ERR_NONE)
  {
    if(errval == QMI_ERR_DEVICE_NOT_READY)
    {
      goto send_result;
    }

    /* Try to open session */
    errval = qmi_uim_open_session(UIMI_CMD_VAL_REFRESH_REGISTER,
                                  tlv_data, 2,
                                  cmd_buf_p, cl_sp);
    if (errval == QMI_ERR_NONE)
    {
      opening_session = TRUE;
    }
  }
  else
  {
    /* Execute MMGSDI function */
    errval = qmi_uim_execute_refresh_register(
                            session_id,
                            tlv_data[1].data.register_refresh.register_op,
                            tlv_data[1].data.register_refresh.vote_for_init,
                            tlv_data[1].data.register_refresh.file_list_ptr,
                            (qmi_cmd_buf_type *) cmd_buf_p);

    /* Associate the Client with the requested Session (if it is a
       non-prov. Session) */
    if(errval == QMI_ERR_NONE)
    {
      (void)qmi_uim_update_non_prov_session_cl_sp(tlv_data,
                                                  2,
                                                  cl_sp);
    }
  }

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(tlv_data, 2);

  if (opening_session)
  {
    return QMI_SVC_RESPONSE_PENDING;
  }

  /* Send result */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  CHECK_RETVAL();

  return response;
} /* qmi_uimi_refresh_register() */


/*===========================================================================
  FUNCTION QMI_UIMI_REFRESH_OK()

  DESCRIPTION
    Vote for refresh

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_uimi_refresh_ok
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  uint16                         i               = 0;
  dsm_item_type *                response        = NULL;
  qmi_error_e_type               errval          = QMI_ERR_NONE;
  qmi_result_e_type              result          = QMI_RESULT_SUCCESS;
  boolean                        retval          = TRUE;
  mmgsdi_session_id_type         session_id      = UIM_INVALID_SESSION_ID;
  uint16                         refresh_index   = 0;
  mmgsdi_return_enum_type        mmgsdi_status   = MMGSDI_SUCCESS;
  qmi_uimi_client_state_type *   client_sp       = NULL;
  boolean                        right_to_vote   = FALSE;
  qmi_uim_tlv_item_type          tlv_data[2];

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);
  ASSERT(qmi_uim_global_ptr);

  memset(tlv_data, 0, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_SESSION_INFORMATION;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;
  tlv_data[1].type      = UIMI_TLV_TYPE_OK_FOR_REFRESH;
  tlv_data[1].tag       = UIMI_TLV_TAG_MANDATORY_2;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 2);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* Retrieve session id */
  errval = qmi_uim_session_type_to_session_id(&session_id,
                                              tlv_data[0].data.session_information.session_type,
                                              tlv_data[0].data.session_information.aid);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* Retrieve session index for the refresh */
  errval = qmi_uim_session_id_to_refresh_index(&refresh_index, session_id);
  if (errval != QMI_ERR_NONE)
  {
    UIM_MSG_ERR_1("Impossible to convert session id (0x%x) into refresh index",
                  session_id);
    goto send_result;
  }
  ASSERT(refresh_index < UIM_REFRESH_SESSION_COUNT);

  /* Check current refresh state */
  if (qmi_uim_global_ptr->refresh_info[refresh_index].state != UIM_REFRESH_STATE_WAIT_FOR_OK)
  {
    UIM_MSG_ERR_1("Cannot vote for refresh in this state: 0x%x",
                  qmi_uim_global_ptr->refresh_info[refresh_index].state);
    errval = QMI_ERR_INTERNAL;
    goto send_result;
  }

  /* Check count of clients that need to vote */
  if (qmi_uim_global_ptr->refresh_info[refresh_index].client_count == 0)
  {
    UIM_MSG_ERR_0("No client is expected to vote");
    errval = QMI_ERR_INTERNAL;
    goto send_result;
  }

  /* Check if this client has right to vote, and in case
     remove it from the list */
  client_sp = (qmi_uimi_client_state_type *) cl_sp;
  for (i = 0; i < (uint16)UIM_REFRESH_MAX_CLIENTS; i++)
  {
    if (qmi_uim_global_ptr->refresh_info[refresh_index].client_list[i] == client_sp)
    {
      right_to_vote = TRUE;
      qmi_uim_global_ptr->refresh_info[refresh_index].client_list[i] = NULL;
      break;
    }
  }
  if (!right_to_vote)
  {
    UIM_MSG_ERR_0("This client does not have the right to vote");
    errval = QMI_ERR_INTERNAL;
    goto send_result;
  }

  /* Store vote in global */
  if (!tlv_data[1].data.ok_to_refresh.value)
  {
    qmi_uim_global_ptr->refresh_info[refresh_index].ok_to_init = FALSE;
  }

  /* Decrease counter of missing clients */
  qmi_uim_global_ptr->refresh_info[refresh_index].client_count--;

  if (qmi_uim_global_ptr->refresh_info[refresh_index].client_count == 0)
  {
    UIM_MSG_HIGH_1("QMI_UIM: all clients have voted. Result = 0x%x",
                   qmi_uim_global_ptr->refresh_info[refresh_index].ok_to_init);

    /* Call MMGSDI APIs to vote */
    mmgsdi_status = mmgsdi_session_ok_to_refresh(
                                session_id,
                                qmi_uim_global_ptr->refresh_info[refresh_index].ok_to_init,
                                qmi_uimi_mmgsdi_callback,
                                (mmgsdi_client_data_type)NULL );

    /* Convert MMGSDI status in QMI code */
    errval = qmi_uim_convert_mmgsdi_status_to_errval(mmgsdi_status);
  }
  else
  {
    UIM_MSG_HIGH_1("QMI_UIM: 0x%x clients still need to vote",
                   qmi_uim_global_ptr->refresh_info[refresh_index].client_count);
    errval = QMI_ERR_NONE;
  }

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(tlv_data, 2);

  /* Send result */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  CHECK_RETVAL();

  return response;
} /* qmi_uimi_refresh_ok() */


/*===========================================================================
  FUNCTION QMI_UIMI_REFRESH_COMPLETE()

  DESCRIPTION
    Refresh complete

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_uimi_refresh_complete
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  uint16                         i                 = 0;
  dsm_item_type *                response          = NULL;
  qmi_error_e_type               errval            = QMI_ERR_NONE;
  qmi_result_e_type              result            = QMI_RESULT_SUCCESS;
  boolean                        retval            = TRUE;
  mmgsdi_session_id_type         session_id        = UIM_INVALID_SESSION_ID;
  uint16                         refresh_index     = 0;
  mmgsdi_return_enum_type        mmgsdi_status     = MMGSDI_SUCCESS;
  qmi_uimi_client_state_type *   client_sp         = NULL;
  boolean                        right_to_complete = FALSE;
  qmi_uim_tlv_item_type          tlv_data[2];

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);
  ASSERT(qmi_uim_global_ptr);

  memset(tlv_data, 0, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_SESSION_INFORMATION;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;
  tlv_data[1].type      = UIMI_TLV_TYPE_REFRESH_COMPLETE;
  tlv_data[1].tag       = UIMI_TLV_TAG_MANDATORY_2;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 2);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* Retrieve session id */
  errval = qmi_uim_session_type_to_session_id(&session_id,
                                              tlv_data[0].data.session_information.session_type,
                                              tlv_data[0].data.session_information.aid);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* Retrieve session index for the refresh */
  errval = qmi_uim_session_id_to_refresh_index(&refresh_index, session_id);
  if (errval != QMI_ERR_NONE)
  {
    UIM_MSG_ERR_1("Impossible to convert session id (0x%x) into refresh index",
                  session_id);
    goto send_result;
  }
  ASSERT(refresh_index < UIM_REFRESH_SESSION_COUNT);

  /* Check current refresh state */
  if (qmi_uim_global_ptr->refresh_info[refresh_index].state != UIM_REFRESH_STATE_WAIT_FOR_COMPLETE)
  {
    UIM_MSG_ERR_1("Cannot complete refresh in this state: 0x%x",
                  qmi_uim_global_ptr->refresh_info[refresh_index].state);
    errval = QMI_ERR_INTERNAL;
    goto send_result;
  }

  /* Check count of clients that need to complete */
  if (qmi_uim_global_ptr->refresh_info[refresh_index].client_count == 0)
  {
    UIM_MSG_ERR_0("No client is expected to complete refresh");
    errval = QMI_ERR_INTERNAL;
    goto send_result;
  }

  /* Check if this client has right to complete, and in case
     remove it from the list */
  client_sp = (qmi_uimi_client_state_type *) cl_sp;
  for (i = 0; i < (uint16)UIM_REFRESH_MAX_CLIENTS; i++)
  {
    if (qmi_uim_global_ptr->refresh_info[refresh_index].client_list[i] == client_sp)
    {
      right_to_complete = TRUE;
      qmi_uim_global_ptr->refresh_info[refresh_index].client_list[i] = NULL;
      break;
    }
  }
  if (!right_to_complete)
  {
    UIM_MSG_ERR_0("This client does not have the right to complete");
    errval = QMI_ERR_INTERNAL;
    goto send_result;
  }

  /* Store success in global */
  if (!tlv_data[1].data.refresh_complete.value)
  {
    qmi_uim_global_ptr->refresh_info[refresh_index].complete = FALSE;
  }

  /* For now, ignore the client list and assume that each completing client
     has the right to do it */
  qmi_uim_global_ptr->refresh_info[refresh_index].client_count--;

  if (qmi_uim_global_ptr->refresh_info[refresh_index].client_count == 0)
  {
    UIM_MSG_HIGH_1("QMI_UIM: all clients have completed. Result = 0x%x",
                   qmi_uim_global_ptr->refresh_info[refresh_index].complete);

    /* Call MMGSDI APIs to vote */
    mmgsdi_status = mmgsdi_session_refresh_complete(
                                session_id,
                                qmi_uim_global_ptr->refresh_info[refresh_index].complete,
                                qmi_uimi_mmgsdi_callback,
                                (mmgsdi_client_data_type)NULL );

    /* Convert MMGSDI status in QMI code */
    errval = qmi_uim_convert_mmgsdi_status_to_errval(mmgsdi_status);
  }
  else
  {
    UIM_MSG_HIGH_1("QMI_UIM: 0x%x clients still need to complete refresh",
                   qmi_uim_global_ptr->refresh_info[refresh_index].client_count);
    errval = QMI_ERR_NONE;
  }

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(tlv_data, 2);

  /* Send result */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  CHECK_RETVAL();

  return response;
} /* qmi_uimi_refresh_complete() */


/*===========================================================================
  FUNCTION QMI_UIMI_REFRESH_GET_LAST_EVENT()

  DESCRIPTION
    Get the last refresh event

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_uimi_refresh_get_last_event
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *                response        = NULL;
  qmi_error_e_type               errval          = QMI_ERR_NONE;
  qmi_result_e_type              result          = QMI_RESULT_SUCCESS;
  boolean                        retval          = TRUE;
  mmgsdi_session_id_type         session_id      = UIM_INVALID_SESSION_ID;
  uint16                         refresh_index   = 0;
  qmi_uim_tlv_item_type          tlv_data[1];

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);
  ASSERT(qmi_uim_global_ptr);

  memset(tlv_data, 0, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_SESSION_INFORMATION;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 1);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* Retrieve session id */
  errval = qmi_uim_session_type_to_session_id(&session_id,
                                              tlv_data[0].data.session_information.session_type,
                                              tlv_data[0].data.session_information.aid);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* Retrieve session index for the refresh */
  errval = qmi_uim_session_id_to_refresh_index(&refresh_index, session_id);
  if (errval != QMI_ERR_NONE)
  {
    UIM_MSG_ERR_1("Impossible to convert session id (0x%x) into refresh index",
                  session_id);
    goto send_result;
  }
  ASSERT(refresh_index < UIM_REFRESH_SESSION_COUNT);

  /* Check if refresh event is cached */
  if (qmi_uim_global_ptr->refresh_info[refresh_index].cache.event_ptr == NULL)
  {
    UIM_MSG_ERR_0("No refresh event is cached");
    errval = QMI_ERR_INTERNAL;
    goto send_result;
  }

  /* Check if session type is matching */
  if (session_id != qmi_uim_global_ptr->refresh_info[refresh_index].cache.session_id)
  {
    UIM_MSG_ERR_2("Session id is not matching: 0x%x != 0x%x",
                  session_id,
                  qmi_uim_global_ptr->refresh_info[refresh_index].cache.session_id);
    errval = QMI_ERR_INTERNAL;
    goto send_result;
  }

  /* Compose the response */
  if (FALSE == qmi_uim_response_refresh_event(
                         UIMI_TLV_RESP_TAG_OPTIONAL_1,
                         &response,
                         tlv_data[0].data.session_information.session_type,
                         &tlv_data[0].data.session_information.aid,
                         qmi_uim_global_ptr->refresh_info[refresh_index].cache.event_ptr))
  {
    errval = QMI_ERR_NO_MEMORY;
    dsm_free_packet(&response);
  }

  /* In all cases, keep the event in the cache, as it might be fetched by
     other clients later. */

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(tlv_data, 1);

  /* Send result */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  CHECK_RETVAL();

  return response;
} /* qmi_uimi_refresh_get_last_event() */


/*===========================================================================
  FUNCTION QMI_UIMI_POWER_DOWN()

  DESCRIPTION
    Power down the card

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_uimi_power_down
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type            errval          = QMI_ERR_NONE;
  mmgsdi_return_enum_type     mmgsdi_status   = MMGSDI_SUCCESS;
  qmi_uimi_userdata_type*     cb_userdata_ptr = NULL;
  qmi_uim_tlv_item_type       tlv_data[1];

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);
  ASSERT(qmi_uim_global_ptr);

  memset(tlv_data, 0, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_SLOT;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 1);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* Create userdata */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_POWER_DOWN,
                                            cmd_buf_p,
                                            NULL,
                                            ((qmi_uimi_client_state_type *)cl_sp)->common.clid);
  if (cb_userdata_ptr == NULL)
  {
    errval = QMI_ERR_NO_MEMORY;
    goto send_result;
  }

  /* Execute MMGSDI function to power down */
  mmgsdi_status = mmgsdi_card_pdown(
                        qmi_uim_global_ptr->mmgsdi_client_id,
                        tlv_data[0].data.slot.slot,
                        qmi_uimi_mmgsdi_callback,
                        MMGSDI_CARD_POWER_DOWN_NOTIFY_GSDI,
                        (mmgsdi_client_data_type)cb_userdata_ptr );

  /* Free userdata in case of error */
  QMI_UIM_FREE_USERDATA_IF_ERROR(mmgsdi_status, cb_userdata_ptr);

  /* Convert MMGSDI status to QMI err code */
  errval = qmi_uim_convert_mmgsdi_status_to_errval(mmgsdi_status);

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(tlv_data, 1);

  return qmi_uimi_populate_response(errval,
                                    FALSE,
                                    0,
                                    0);
} /* qmi_uimi_power_down() */


/*===========================================================================
  FUNCTION QMI_UIMI_POWER_UP()

  DESCRIPTION
    Power up the card

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_uimi_power_up
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type            errval          = QMI_ERR_NONE;
  mmgsdi_return_enum_type     mmgsdi_status   = MMGSDI_SUCCESS;
  uint8                       slot_idx        = 0;
  qmi_uimi_userdata_type*     cb_userdata_ptr = NULL;
  uim_slot_type               uim_slot        = UIM_SLOT_NONE;
  qmi_uim_tlv_item_type       tlv_data[2];

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);
  ASSERT(qmi_uim_global_ptr);

  memset(tlv_data, 0, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_SLOT;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;
  tlv_data[1].type      = UIMI_TLV_TYPE_IGNORE_HOTSWAP_SWITCH;
  tlv_data[1].tag       = UIMI_TLV_TAG_OPTIONAL_1;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 2);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  if (qmi_uim_mmgsdi_slot_to_slot_index(tlv_data[0].data.slot.slot,
                                        &slot_idx) != QMI_ERR_NONE)
  {
    errval = QMI_ERR_INTERNAL;
    goto send_result;
  }

  if(qmi_uim_mmgsdi_slot_id_to_uim_slot_id(tlv_data[0].data.slot.slot,
                                           &uim_slot) != QMI_ERR_NONE)
  {
    errval = QMI_ERR_INTERNAL;
    goto send_result;
  }

  if(slot_idx >= QMI_UIM_MAX_CARD_COUNT ||
     slot_idx >= qmi_uim_global_ptr->card_state.num_slots ||
     qmi_uim_global_ptr->card_state.card[slot_idx] == NULL)
  {
    errval = QMI_ERR_INTERNAL;
    goto send_result;
  }

  if(tlv_data[1].present &&
     tlv_data[1].data.ignore_hotswap_switch.value)
  {
    uim_disable_hotswap_interrupt(uim_slot);
  }

  /* Check if power up is already in progress */
  if (qmi_uim_global_ptr->power_up_state[slot_idx] != QMI_UIM_PUP_NOT_IN_PROGRESS)
  {
    UIM_MSG_ERR_2("Power up in progress with pup state 0x%x for slot 0x%x",
                  qmi_uim_global_ptr->power_up_state[slot_idx], slot_idx);
    errval = QMI_ERR_INTERNAL;
    goto send_result;
  }

  /* Check if card is already powered up. Returning NO_EFFECT might be
     misleading here as there is no guarentee that card will power up correctly */
  if (qmi_uim_global_ptr->card_state.card[slot_idx]->card_state == QMI_UIM_CARD_STATE_PRESENT)
  {
    UIM_MSG_HIGH_1( "Card is already powered up for slot 0x%x", slot_idx);
    errval = QMI_ERR_NO_EFFECT;
    goto send_result;
  }

  /* Create userdata */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_POWER_UP,
                                            cmd_buf_p,
                                            NULL,
                                            ((qmi_uimi_client_state_type *)cl_sp)->common.clid);
  if (cb_userdata_ptr == NULL)
  {
    errval = QMI_ERR_NO_MEMORY;
    goto send_result;
  }

  /* Execute MMGSDI function to power up */
  mmgsdi_status = mmgsdi_card_pup(
                        qmi_uim_global_ptr->mmgsdi_client_id,
                        tlv_data[0].data.slot.slot,
                        qmi_uimi_mmgsdi_callback,
                        MMGSDI_CARD_POWER_UP_INITIAL_PUP,
                        (mmgsdi_client_data_type)cb_userdata_ptr );

  /* Free userdata in case of error */
  QMI_UIM_FREE_USERDATA_IF_ERROR(mmgsdi_status, cb_userdata_ptr);

  /* Mark power up in progress */
  if (mmgsdi_status == MMGSDI_SUCCESS)
  {
    qmi_uim_global_ptr->power_up_state[slot_idx] = QMI_UIM_PUP_MMGSDI_RSP_PENDING;
  }

  /* Convert MMGSDI status to QMI err code */
  errval = qmi_uim_convert_mmgsdi_status_to_errval(mmgsdi_status);

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(tlv_data, 2);

  return qmi_uimi_populate_response(errval,
                                    FALSE,
                                    0,
                                    0);
} /* qmi_uimi_power_up() */


/*===========================================================================
  FUNCTION QMI_UIMI_AUTHENTICATE()

  DESCRIPTION
    Executes the authentication algorithm on the card

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_authenticate
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type               errval        = QMI_ERR_NONE;
  mmgsdi_session_id_type         session_id    = UIM_INVALID_SESSION_ID;
  qmi_uimi_ind_token_info_type   token_info    = {FALSE, 0};
  struct fs_stat                 file_stat     = {0};
  qmi_uim_tlv_item_type          tlv_data[3];

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(tlv_data, 0, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_SESSION_INFORMATION;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;
  tlv_data[1].type      = UIMI_TLV_TYPE_AUTHENTICATE;
  tlv_data[1].tag       = UIMI_TLV_TAG_MANDATORY_2;
  tlv_data[2].type      = UIMI_TLV_TYPE_IND_TOKEN;
  tlv_data[2].tag       = UIMI_TLV_TAG_OPTIONAL_1;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 3);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* Check if request needs to be rejected due to security restrictions */
  if ((tlv_data[1].data.authenticate.auth_context == UIM_AUTH_CONTEXT_RUN_GSM_ALG_V01 ||
       tlv_data[1].data.authenticate.auth_context == UIM_AUTH_CONTEXT_GSM_SEC_V01 ||
       tlv_data[1].data.authenticate.auth_context == UIM_AUTH_CONTEXT_RUN_CAVE_ALG_V01) &&
      (qmi_uim_global_ptr->auth_sec_restr_value == QMI_UIM_AUTH_SEC_RESTRICTIONS_ALL ||
       qmi_uim_global_ptr->auth_sec_restr_value == QMI_UIM_AUTH_SEC_RESTRICTIONS_II_CLA))
  {
    errval = QMI_ERR_ACCESS_DENIED;
    goto send_result;
  }

  /* In case of NAF derivation context, if FQDN white list or black list file is
     present then reject the request.This prevents a client from performing NAF
     derivation from AP, when this might be restricted to TZ only */
  if(tlv_data[1].data.authenticate.auth_context == UIM_AUTH_CONTEXT_GBA_SEC_NAF_DERIVATION_V01 &&
     (efs_stat(QMI_UIM_CONFIG_GBA_FQDN_WHITE_LIST, &file_stat) == 0 ||
      efs_stat(QMI_UIM_CONFIG_GBA_FQDN_BLACK_LIST, &file_stat) == 0))
  {
    errval = QMI_ERR_ACCESS_DENIED;
    goto send_result;
  }

  if(qmi_uim_is_request_rejected(tlv_data[0].data.session_information.session_type,
                                 tlv_data[0].data.session_information.aid,
                                 cl_sp))
  {
    errval = QMI_ERR_ACCESS_DENIED;
    goto send_result;
  }

  /* Update token info */
  token_info.is_valid = tlv_data[2].present;
  token_info.token = tlv_data[2].data.ind_token.value;

  /* Block request if authentication is allowed for the app for this session */
  if(!qmi_uim_auth_allowed_in_app_state(tlv_data[0].data.session_information.session_type))
  {
    errval = QMI_ERR_ACCESS_DENIED;
    goto send_result;
  }

  /* Retrieve session id */
  errval = qmi_uim_session_type_to_session_id(&session_id,
                                              tlv_data[0].data.session_information.session_type,
                                              tlv_data[0].data.session_information.aid);

  if (errval != QMI_ERR_NONE)
  {
    if(errval == QMI_ERR_DEVICE_NOT_READY)
    {
      goto send_result;
    }

    /* Try to open session */
    errval = qmi_uim_open_session(UIMI_CMD_VAL_AUTHENTICATE,
                                  tlv_data, 3,
                                  token_info.is_valid ? NULL : cmd_buf_p,
                                  cl_sp);
  }
  else
  {
    /* Execute MMGSDI function */
    errval = qmi_uim_execute_authenticate(
                            session_id,
                            tlv_data[1].data.authenticate.auth_context,
                            tlv_data[1].data.authenticate.auth_data,
                            token_info.is_valid ? &token_info.token : NULL,
                            token_info.is_valid ? NULL : cmd_buf_p,
                            ((qmi_uimi_client_state_type *)cl_sp)->common.clid);

    /* Associate the Client with the requested Session (if it is a
       non-prov. Session) */
    if(errval == QMI_ERR_NONE)
    {
      (void)qmi_uim_update_non_prov_session_cl_sp(tlv_data,
                                                  3,
                                                  cl_sp);
    }
  }

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(tlv_data, 3);

  return qmi_uimi_populate_response(errval,
                                    token_info.is_valid,
                                    token_info.token,
                                    UIMI_TLV_RESP_TAG_OPTIONAL_3);
} /* qmi_uimi_authenticate() */


/*===========================================================================
  FUNCTION QMI_UIMI_CLOSE_SESSION()

  DESCRIPTION
    Closes a non provisioning session

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_close_session
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *                response      = NULL;
  qmi_error_e_type               errval        = QMI_ERR_NONE;
  qmi_result_e_type              result        = QMI_RESULT_SUCCESS;
  boolean                        retval        = TRUE;
  mmgsdi_session_id_type         session_id    = UIM_INVALID_SESSION_ID;
  mmgsdi_return_enum_type        mmgsdi_status = MMGSDI_SUCCESS;
  boolean                        terminate_app = FALSE;
  qmi_uim_tlv_item_type          tlv_data[2];

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(tlv_data, 0, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_SESSION_INFORMATION;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;
  tlv_data[1].type      = UIMI_TLV_TYPE_TERMINATE_APP;
  tlv_data[1].tag       = UIMI_TLV_TAG_OPTIONAL_1;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 2);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* Check AID validity */
  if(tlv_data[0].data.session_information.aid.data_len == QMI_UIM_TLV_CHANNEL_ID_LEN)
  {
    UIM_MSG_ERR_1("Invalid AID length: 0x%x, cannot close session",
                  tlv_data[0].data.session_information.aid.data_len);
    errval = QMI_ERR_INVALID_ARG;
    goto send_result;
  }

  /* Check if request needs to be rejected due to security restrictions */
  if (qmi_uim_is_request_rejected(tlv_data[0].data.session_information.session_type,
                                  tlv_data[0].data.session_information.aid,
                                  cl_sp))
  {
    errval = QMI_ERR_ACCESS_DENIED;
    goto send_result;
  }

  /* Retrieve session id: only non provisining sessions can be closed */
  if (tlv_data[0].data.session_information.session_type == MMGSDI_NON_PROV_SESSION_SLOT_1 ||
      tlv_data[0].data.session_information.session_type == MMGSDI_NON_PROV_SESSION_SLOT_2 ||
      tlv_data[0].data.session_information.session_type == MMGSDI_NON_PROV_SESSION_SLOT_3)
  {
    errval = qmi_uim_session_type_to_session_id(&session_id,
                                                tlv_data[0].data.session_information.session_type,
                                                tlv_data[0].data.session_information.aid);
    if (errval != QMI_ERR_NONE)
    {
      /* Update the error code if there is no need to send close channel */
      errval = QMI_ERR_NO_EFFECT;
      goto send_result;
    }
  }
  else
  {
    UIM_MSG_ERR_1("Impossible to close a provisioning session: 0x%x",
                  tlv_data[0].data.session_information.session_type);
    errval = QMI_ERR_INTERNAL;
    goto send_result;
  }

  /* If the terminate_application TLV is missing, then terminate the app
     only if App is USIM/CSIM/ISIM */
  if (tlv_data[1].present)
  {
    terminate_app = tlv_data[1].data.terminate_app.value;
  }
  else
  {
    if (tlv_data[0].data.session_information.aid.data_len > 0)
    {
      if ((qmi_uim_is_usim_aid(&(tlv_data[0].data.session_information.aid), FALSE)) ||
          (qmi_uim_is_csim_aid(&(tlv_data[0].data.session_information.aid), FALSE)) ||
          (qmi_uim_is_isim_aid(&(tlv_data[0].data.session_information.aid))))
      {
        terminate_app = TRUE;
      }
    }
  }

  /* Close the session */
  mmgsdi_status = mmgsdi_session_close_terminate(session_id,
                                                 terminate_app,
                                                 qmi_uimi_mmgsdi_callback,
                                                 (mmgsdi_client_data_type)NULL);

  /* Immediately remove the session from the array.
     QMI_UIM_SESSION_CLOSED_IND shall not be sent out since the session
     clean-up was not trigerred by an MMGSDI_SESSION_CLOSE_EVT */
  qmi_uim_remove_non_provisioning_session(session_id, FALSE,
                                          MMGSDI_SESSION_CLOSED_CAUSE_UNKNOWN);

  /* Convert MMGSDI status in QMI code */
  errval = qmi_uim_convert_mmgsdi_status_to_errval(mmgsdi_status);

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(tlv_data, 2);

  /* Send result */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  CHECK_RETVAL();

  return response;
} /* qmi_uimi_close_session() */


/*===========================================================================
  FUNCTION QMI_UIMI_GET_SERVICE_STATUS()

  DESCRIPTION
    Get the status of services on the card

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_get_service_status
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *             response          = NULL;
  qmi_error_e_type            errval            = QMI_ERR_NONE;
  boolean                     retval            = TRUE;
  uint16                      request_count     = 0;
  qmi_uim_tlv_item_type       tlv_data[3];

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(tlv_data, 0, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_SESSION_INFORMATION;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;
  tlv_data[1].type      = UIMI_TLV_TYPE_CAPABILITIES_MASK;
  tlv_data[1].tag       = UIMI_TLV_TAG_MANDATORY_2;
  tlv_data[2].type      = UIMI_TLV_TYPE_SERVICE_NUMBER;
  tlv_data[2].tag       = UIMI_TLV_TAG_OPTIONAL_1;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 3);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* Check if request needs to be rejected due to security restrictions */
  if (qmi_uim_is_request_rejected(tlv_data[0].data.session_information.session_type,
                                  tlv_data[0].data.session_information.aid,
                                  cl_sp))
  {
    errval = QMI_ERR_ACCESS_DENIED;
    goto send_result;
  }

  /* Check number of requests: right now one and only one
     service can be requested */
  request_count = (tlv_data[1].data.capabilities_mask.fdn_status ? 1 : 0) +
                  (tlv_data[1].data.capabilities_mask.hidden_key_status ? 1 : 0) +
                  (tlv_data[1].data.capabilities_mask.index_in_dir ? 1 : 0) +
                  (tlv_data[1].data.capabilities_mask.esn_me_status ? 1 : 0) +
                  (tlv_data[1].data.capabilities_mask.acl_status ? 1 : 0) +
                  (tlv_data[1].data.capabilities_mask.service_status ? 1 : 0);
  if (request_count != 1)
  {
    UIM_MSG_ERR_1("Invalid number of requested services: 0x%x", request_count);
    errval = QMI_ERR_INTERNAL;
    goto send_result;
  }

  /* FDN status */
  if (tlv_data[1].data.capabilities_mask.fdn_status)
  {
    errval = qmi_uim_execute_get_status_fdn(
                   tlv_data[0].data.session_information.session_type,
                   cmd_buf_p,
                   ((qmi_uimi_client_state_type *)cl_sp)->common.clid);
  }

  /* Hidden key status */
  if (tlv_data[1].data.capabilities_mask.hidden_key_status ||
      tlv_data[1].data.capabilities_mask.index_in_dir)
  {
    errval = qmi_uim_execute_get_status_hidden_key_and_index(
                   tlv_data[1].data.capabilities_mask.hidden_key_status,
                   tlv_data[1].data.capabilities_mask.index_in_dir,
                   tlv_data[0].data.session_information.session_type,
                   cmd_buf_p,
                   ((qmi_uimi_client_state_type *)cl_sp)->common.clid);
  }

  /* ESN status */
  if (tlv_data[1].data.capabilities_mask.esn_me_status)
  {
    mmgsdi_esn_me_change_enum_type esn_status  = MMGSDI_ESN_ME_NO_CHANGE;
    qmi_result_e_type              result      = QMI_RESULT_SUCCESS;

    errval = qmi_uim_execute_get_status_esn(
                   tlv_data[0].data.session_information.session_type, &esn_status);
    if (errval == QMI_ERR_NONE)
    {
      /* Free the buffer used for data */
      qmi_uim_free_tlv_content(tlv_data, 3);

      if (FALSE == qmi_uim_response_esn_status(UIMI_TLV_RESP_TAG_OPTIONAL_4,
                                               &response, esn_status))
      {
        errval = QMI_ERR_NO_MEMORY;
        dsm_free_packet(&response);
      }

      /* Insert result item in the TLV */
      result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                        : QMI_RESULT_FAILURE);

      retval = qmi_svc_put_result_tlv(&response, result, errval);
      CHECK_RETVAL();

      return response;
    }
  }

  /* ACL status */
  if (tlv_data[1].data.capabilities_mask.acl_status)
  {
    errval = qmi_uim_execute_get_status_acl(
                   tlv_data[0].data.session_information.session_type,
                   cmd_buf_p,
                   ((qmi_uimi_client_state_type *)cl_sp)->common.clid);
  }

  /* Service status */
  if (tlv_data[1].data.capabilities_mask.service_status)
  {
    boolean                     service_available = FALSE;
    qmi_result_e_type           result            = QMI_RESULT_SUCCESS;

    if(!tlv_data[2].present)
    {
      errval = QMI_ERR_MISSING_ARG;
      goto send_result;
    }
    /* Retrieve the service availability status synchronously and send the
       response synchronously */
    errval = qmi_uim_execute_get_service_status(
                   tlv_data[0].data.session_information.session_type,
                   tlv_data[2].data.service_number.service_number,
                   &service_available);
    if (errval == QMI_ERR_NONE)
    {
      /* Free the buffer used for data */
      qmi_uim_free_tlv_content(tlv_data, 3);

      if (FALSE == qmi_uim_response_boolean(
                         UIMI_TLV_RESP_TAG_OPTIONAL_6,
                         &response,
                         service_available))
      {
        errval = QMI_ERR_NO_MEMORY;
        dsm_free_packet(&response);
      }

      /* Insert result item in the TLV */
      result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                        : QMI_RESULT_FAILURE);

      retval = qmi_svc_put_result_tlv(&response, result, errval);
      CHECK_RETVAL();

      return response;
    }
  }

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(tlv_data, 3);

  return qmi_uimi_populate_response(errval,
                                    FALSE,
                                    0,
                                    0);
} /* qmi_uimi_get_service_status() */


/*===========================================================================
  FUNCTION QMI_UIMI_SET_SERVICE_STATUS()

  DESCRIPTION
    Set the status of services on the card

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_set_service_status
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type               errval          = QMI_ERR_NONE;
  qmi_uim_tlv_item_type          tlv_data[3];

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(tlv_data, 0, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_SESSION_INFORMATION;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;
  tlv_data[1].type      = UIMI_TLV_TYPE_SET_FDN_STATUS;
  tlv_data[1].tag       = UIMI_TLV_TAG_OPTIONAL_1;
  tlv_data[2].type      = UIMI_TLV_TYPE_SET_ACL_STATUS;
  tlv_data[2].tag       = UIMI_TLV_TAG_OPTIONAL_2;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 3);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* Verify that one and only one service is present */
  if ((tlv_data[1].present && tlv_data[2].present) ||
      (!tlv_data[1].present && !tlv_data[2].present))
  {
    UIM_MSG_ERR_0("Exactly one service can be enabled/disabled at a time");
    errval = QMI_ERR_INTERNAL;
    goto send_result;
  }

  /* FDN status */
  if (tlv_data[1].present)
  {
    errval = qmi_uim_execute_set_service_status(
                             cmd_buf_p,
                             tlv_data[0].data.session_information.session_type,
                             UIMI_TLV_TYPE_SET_FDN_STATUS,
                             tlv_data[1].data.set_fdn_status.value,
                             ((qmi_uimi_client_state_type *)cl_sp)->common.clid);

    if (errval != QMI_ERR_NONE)
    {
      goto send_result;
    }
  }

  /* ACL status */
  if (tlv_data[2].present)
  {
    errval = qmi_uim_execute_set_service_status(
                             cmd_buf_p,
                             tlv_data[0].data.session_information.session_type,
                             UIMI_TLV_TYPE_SET_ACL_STATUS,
                             tlv_data[2].data.set_acl_status.value,
                             ((qmi_uimi_client_state_type *)cl_sp)->common.clid);

    if (errval != QMI_ERR_NONE)
    {
      goto send_result;
    }
  }

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(tlv_data, 3);

  return qmi_uimi_populate_response(errval,
                                    FALSE,
                                    0,
                                    0);
} /* qmi_uimi_set_service_status() */


/*===========================================================================
  FUNCTION QMI_UIMI_CHANGE_PROVISIONING_SESSION()

  DESCRIPTION
    Change a provisioning session on the card

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_change_provisioning_session
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  mmgsdi_return_enum_type      mmgsdi_status   = MMGSDI_SUCCESS;
  mmgsdi_session_id_type       session_id      = UIM_INVALID_SESSION_ID;
  qmi_uimi_userdata_type*      cb_userdata_ptr = NULL;
  qmi_error_e_type             errval          = QMI_ERR_NONE;
  qmi_uim_tlv_item_type        tlv_data[2];
  mmgsdi_data_type             app_id_data;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(tlv_data, 0, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_SESSION_CHANGE;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;
  tlv_data[1].type      = UIMI_TLV_TYPE_APPLICATION_INFORMATION;
  tlv_data[1].tag       = UIMI_TLV_TAG_OPTIONAL_1;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 2);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* Retrieve session id: supports only provisioning sessions */
  if (tlv_data[0].data.session_information.session_type == MMGSDI_GW_PROV_PRI_SESSION ||
      tlv_data[0].data.session_information.session_type == MMGSDI_1X_PROV_PRI_SESSION ||
      tlv_data[0].data.session_information.session_type == MMGSDI_GW_PROV_SEC_SESSION ||
      tlv_data[0].data.session_information.session_type == MMGSDI_1X_PROV_SEC_SESSION ||
      tlv_data[0].data.session_information.session_type == MMGSDI_GW_PROV_TER_SESSION ||
      tlv_data[0].data.session_information.session_type == MMGSDI_1X_PROV_TER_SESSION)
  {
    errval = qmi_uim_session_type_to_session_id(&session_id,
                                                tlv_data[0].data.session_information.session_type,
                                                tlv_data[1].data.application_information.aid);
    if (errval != QMI_ERR_NONE)
    {
      goto send_result;
    }
  }
  else
  {
    UIM_MSG_ERR_1("Impossible to change a non provisioning session: 0x%x",
                  tlv_data[0].data.session_information.session_type);
    errval = QMI_ERR_INTERNAL;
    goto send_result;
  }

  /* In case of activation, the optional TLV with Application information
     must be present */
  if (tlv_data[0].data.session_change.activate &&
      !tlv_data[1].present)
  {
    UIM_MSG_ERR_0("Missing TLV with application information");
    errval = QMI_ERR_MISSING_ARG;
    goto send_result;
  }

  /* In case of de-activation, update error code if the request is to
     deactivate a prov session that is is already deactivated */
  if (!tlv_data[0].data.session_change.activate)
  {
    mmgsdi_static_data_type  aid        = { 0, };
    mmgsdi_app_enum_type     card_type  = MMGSDI_APP_NONE;

    /* This function returns an error if any prov session index was invalid */
    if (qmi_uim_session_type_to_card_type(&card_type,
                                          tlv_data[0].data.session_information.session_type,
                                          aid) != QMI_ERR_NONE)
    {
      UIM_MSG_ERR_1("Session inactive for prov session: 0x%x",
                    tlv_data[0].data.session_information.session_type);
      errval = QMI_ERR_NO_EFFECT;
      goto send_result;
    }
  }

  /* Create userdata */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_CHANGE_PROVISIONING_SESSION,
                                            cmd_buf_p,
                                            NULL,
                                            ((qmi_uimi_client_state_type *)cl_sp)->common.clid);
  if (cb_userdata_ptr == NULL)
  {
    errval = QMI_ERR_NO_MEMORY;
    goto send_result;
  }

  if(tlv_data[0].data.session_change.activate)
  {
    memset(&app_id_data, 0, sizeof(mmgsdi_data_type));
    if(tlv_data[1].data.application_information.aid.data_len > 0)
    {
      app_id_data.data_len = tlv_data[1].data.application_information.aid.data_len;
      app_id_data.data_ptr = tlv_data[1].data.application_information.aid.data_ptr;
    }

    /* Execute MMGSDI activate or switch provisioning */
    mmgsdi_status = mmgsdi_session_activate_or_switch_provisioning(
                                  session_id,
                                  tlv_data[1].data.application_information.slot,
                                  app_id_data,
                                  qmi_uimi_mmgsdi_callback,
                                  (mmgsdi_client_data_type)cb_userdata_ptr );
  }
  else
  {
    /* Execute MMGSDI deactivate provisioning */
    mmgsdi_status = mmgsdi_session_deactivate_provisioning(
                                  session_id,
                                  qmi_uimi_mmgsdi_callback,
                                  (mmgsdi_client_data_type)cb_userdata_ptr );
  }

  /* Free userdata in case of error */
  QMI_UIM_FREE_USERDATA_IF_ERROR(mmgsdi_status, cb_userdata_ptr);

  /* Convert MMGSDI status in QMI code */
  errval = qmi_uim_convert_mmgsdi_status_to_errval(mmgsdi_status);

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(tlv_data, 2);

  return qmi_uimi_populate_response(errval,
                                    FALSE,
                                    0,
                                    0);
} /* qmi_uimi_change_provisioning_session */


/*===========================================================================
  FUNCTION QMI_UIMI_GET_LABEL()

  DESCRIPTION
    Retrieve the label of an application on a UICC card

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_get_label
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  uint16                       i          = 0;
  uint16                       app_index  = UIM_INVALID_APP_INDEX;
  qmi_error_e_type             errval     = QMI_ERR_NONE;
  dsm_item_type *              response   = NULL;
  boolean                      retval     = TRUE;
  qmi_result_e_type            result     = QMI_RESULT_SUCCESS;
  uint8                        slot_idx   = 0;
  qmi_uim_tlv_item_type        tlv_data[1];

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);
  ASSERT(qmi_uim_global_ptr);

  memset(tlv_data, 0, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_APPLICATION_INFORMATION;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 1);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  if (qmi_uim_mmgsdi_slot_to_slot_index(tlv_data[0].data.application_information.slot,
                                        &slot_idx) != QMI_ERR_NONE)
  {
    errval = QMI_ERR_INTERNAL;
    goto send_result;
  }

  if(slot_idx >= QMI_UIM_MAX_CARD_COUNT ||
     slot_idx >= qmi_uim_global_ptr->card_state.num_slots ||
     qmi_uim_global_ptr->card_state.card[slot_idx] == NULL)
  {
    errval = QMI_ERR_INTERNAL;
    goto send_result;
  }

  if (tlv_data[0].data.application_information.aid.data_len == 0)
  {
    errval = QMI_ERR_INVALID_ARG;
    goto send_result;
  }

  /* Check card status */
  if (qmi_uim_global_ptr->card_state.card[slot_idx]->card_state != QMI_UIM_CARD_STATE_PRESENT)
  {
    UIM_MSG_ERR_1("Invalid card status: 0x%x",
                  qmi_uim_global_ptr->card_state.card[slot_idx]->card_state);
    errval = QMI_ERR_INTERNAL;
    goto send_result;
  }

  /* Search matching application. Cannot use qmi_uim_find_aid() because
     we don't know the app type */
  for (i = 0; i < qmi_uim_global_ptr->card_state.num_apps &&
              i < QMI_UIM_MAX_APP_COUNT; i++)
  {
    if (qmi_uim_global_ptr->card_state.application[i] != NULL &&
        qmi_uim_global_ptr->card_state.application[i]->slot ==
            tlv_data[0].data.application_information.slot &&
        qmi_uim_global_ptr->card_state.application[i]->aid.data_len ==
            tlv_data[0].data.application_information.aid.data_len)
    {
      if (memcmp( (void*)qmi_uim_global_ptr->card_state.application[i]->aid.data_ptr,
                  (void*)tlv_data[0].data.application_information.aid.data_ptr,
                  int32touint32(tlv_data[0].data.application_information.aid.data_len) ) == 0)
      {
        app_index = i;
        break;
      }
    }
  }

  if (app_index != UIM_INVALID_APP_INDEX)
  {
    /* Matching application was found */
    if (FALSE == qmi_uim_response_label(
                    UIMI_TLV_RESP_TAG_OPTIONAL_1,
                    &response,
                    &qmi_uim_global_ptr->card_state.application[app_index]->label))
    {
      errval = QMI_ERR_NO_MEMORY;
      dsm_free_packet(&response);
    }
  }
  else
  {
    /* Application was not found */
    errval = QMI_ERR_INVALID_ARG;
  }

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(tlv_data, 1);

  /* Send the response */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  CHECK_RETVAL();

  return response;
} /* qmi_uimi_get_label */


/*===========================================================================
  FUNCTION QMI_UIMI_GET_CONFIGURATION()

  DESCRIPTION
    Retrieve the UIM configuration

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_get_configuration
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type             errval                = QMI_ERR_NONE;
  boolean                      retval                = TRUE;
  mmgsdi_return_enum_type      mmgsdi_status         = MMGSDI_SUCCESS;
  qmi_uimi_userdata_type*      cb_userdata_ptr       = NULL;
  qmi_uim_tlv_item_type        tlv_data[1];
  dsm_item_type              * response              = NULL;
  qmi_result_e_type            result                = QMI_RESULT_SUCCESS;
  mmgsdi_cached_nv_item_data   cached_nv_item;
  simlock_result_enum_type     simlock_status        = SIMLOCK_SUCCESS;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);
  ASSERT(qmi_uim_global_ptr);

  memset(&cached_nv_item, 0, sizeof(mmgsdi_cached_nv_item_data));
  memset(tlv_data, 0, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_CONFIGURATION_MASK;
  tlv_data[0].tag       = UIMI_TLV_TAG_OPTIONAL_1;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 1);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* Create userdata */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_GET_CONFIGURATION,
                                            cmd_buf_p,
                                            NULL,
                                            ((qmi_uimi_client_state_type *)cl_sp)->common.clid);
  if (cb_userdata_ptr == NULL)
  {
    errval = QMI_ERR_NO_MEMORY;
    goto send_result;
  }

  if(tlv_data[0].present)
  {
    cb_userdata_ptr->data.get_configuration.automatic_selection_status  =
                     tlv_data[0].data.configuration_mask.automatic_selection;
    cb_userdata_ptr->data.get_configuration.personalization_status      =
                     tlv_data[0].data.configuration_mask.personalization_status;
    cb_userdata_ptr->data.get_configuration.halt_subscription_status    =
                     tlv_data[0].data.configuration_mask.halt_subscription_status;
    cb_userdata_ptr->data.get_configuration.usb_uicc_supported_status   =
                     tlv_data[0].data.configuration_mask.usb_uicc_supported_status;
    cb_userdata_ptr->data.get_configuration.sap_client_supported_status =
                     tlv_data[0].data.configuration_mask.sap_client_supported_status;
  }
  else
  {
    cb_userdata_ptr->data.get_configuration.automatic_selection_status  = TRUE;
    cb_userdata_ptr->data.get_configuration.personalization_status      = TRUE;
    cb_userdata_ptr->data.get_configuration.halt_subscription_status    = TRUE;
    cb_userdata_ptr->data.get_configuration.usb_uicc_supported_status   = TRUE;
    cb_userdata_ptr->data.get_configuration.sap_client_supported_status = TRUE;
  }

  /* Initialize automatic selection to TRUE: this is the value in case
     NV item does not exist */
  cb_userdata_ptr->data.get_configuration.automatic_selection = TRUE;

  if(cb_userdata_ptr->data.get_configuration.automatic_selection_status)
  {
    /* If configuration mask is not present or if mask is present and info is requested
       Retrieve the NV item for automatic selection using MMGSDI APIs directly */
    cached_nv_item.nv_item_enum = MMGSDI_NV_UIM_SELECT_DEFAULT_USIM_APP_I;
    mmgsdi_status = mmgsdi_get_cached_nv_item(&cached_nv_item);
    if (mmgsdi_status == MMGSDI_SUCCESS &&
        cached_nv_item.nv_item_data.uim_select_default_usim_app == FALSE)
    {
      cb_userdata_ptr->data.get_configuration.automatic_selection = FALSE;
    }
  }

  /* Initialize halt subscription to FALSE: this is the value in case
     the config file in EFS does not exist */
  cb_userdata_ptr->data.get_configuration.halt_subscription = FALSE;
  if(cb_userdata_ptr->data.get_configuration.halt_subscription_status)
  {
    /* If configuration mask is not present or if mask is present and info is requested */
    /* Get halt subscription config value from EFS */
    /* Get halt subscription config value from EFS */
    cb_userdata_ptr->data.get_configuration.halt_subscription =
         qmi_uim_get_halt_subscription_value();
  }

  /* Initialize USB UICC supported variable to FALSE */
  cb_userdata_ptr->data.get_configuration.usb_uicc_supported = FALSE;
  if(cb_userdata_ptr->data.get_configuration.usb_uicc_supported_status)
  {
    cb_userdata_ptr->data.get_configuration.usb_uicc_supported =
        uim_is_usb_uicc_supported();
  }

  /* Initialize SAP CLIENT supported variable to FALSE */
  cb_userdata_ptr->data.get_configuration.sap_client_supported = FALSE;
  if(cb_userdata_ptr->data.get_configuration.sap_client_supported_status)
  {
    cb_userdata_ptr->data.get_configuration.sap_client_supported =
        uim_is_sap_client_supported();
  }

  if(cb_userdata_ptr->data.get_configuration.personalization_status)
  {
    /* If configuration mask is not present or if mask is present and info is requested */
    /* Get perso indicators. We can use any session for this operation */
    /* Check if we have a valid session ID */
    if (qmi_uim_global_ptr->mmgsdi_gw_session_id[0] == UIM_INVALID_SESSION_ID)
    {
      errval = QMI_ERR_DEVICE_NOT_READY;
    }
    else
    {
      simlock_status = simlock_get_status(qmi_uimi_simlock_callback,
                                          cb_userdata_ptr);

      if(simlock_status != SIMLOCK_SUCCESS)
      {
        /* Convert MMGSDI status in QMI code */
        errval = qmi_uim_convert_simlock_status_to_errval(simlock_status);
      }
      else
      {
        return QMI_SVC_RESPONSE_PENDING;
      }
    }
  }

  /* If configuration mask is present and personalisation data is not requested then
     response can be posted here itself */
  if(cb_userdata_ptr->data.get_configuration.automatic_selection_status)
  {
    if (FALSE == qmi_uim_response_boolean(
                    UIMI_TLV_RESP_TAG_OPTIONAL_1,
                    &response,
                    cb_userdata_ptr->data.get_configuration.automatic_selection))
    {
      errval = QMI_ERR_NO_MEMORY;
      qmi_uim_free_cb_userdata(cb_userdata_ptr);
      goto send_result;
    }
  }

  if(cb_userdata_ptr->data.get_configuration.halt_subscription_status)
  {
    /* Insert TLV with halt subscription configuration */
    if (FALSE == qmi_uim_response_boolean(
                      UIMI_TLV_RESP_TAG_OPTIONAL_3,
                      &response,
                      cb_userdata_ptr->data.get_configuration.halt_subscription))
    {
      errval = QMI_ERR_NO_MEMORY;
      qmi_uim_free_cb_userdata(cb_userdata_ptr);
      goto send_result;
    }
  }

send_result:
  /* Free userdata */
  qmi_uim_free_cb_userdata(cb_userdata_ptr);
  cb_userdata_ptr = NULL;

  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  CHECK_RETVAL();

  return response;
} /* qmi_uimi_get_configuration */


/*===========================================================================
  FUNCTION QMI_UIMI_SEND_APDU()

  DESCRIPTION
    Send an APDU to the card

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_send_apdu
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  uint16                               i               = 0;
  qmi_error_e_type                     errval          = QMI_ERR_NONE;
  mmgsdi_return_enum_type              mmgsdi_status   = MMGSDI_SUCCESS;
  qmi_uimi_userdata_type*              cb_userdata_ptr = NULL;
  mmgsdi_send_apdu_options_enum_type   apdu_option     = MMGSDI_SEND_APDU_RETURN_IMPLICIT_STATUS_WORDS;
  uint16                               channel_index   = UIM_INVALID_APP_INDEX;
  qmi_uim_tlv_item_type                tlv_data[4];

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);
  ASSERT(qmi_uim_global_ptr);

  memset(tlv_data, 0, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_SLOT;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;
  tlv_data[1].type      = UIMI_TLV_TYPE_APDU_REQUEST;
  tlv_data[1].tag       = UIMI_TLV_TAG_MANDATORY_2;
  tlv_data[2].type      = UIMI_TLV_TYPE_LOGICAL_CHANNEL;
  tlv_data[2].tag       = UIMI_TLV_TAG_OPTIONAL_1;
  tlv_data[3].type      = UIMI_TLV_TYPE_SKIP_PROCEDURE_BYTES;
  tlv_data[3].tag       = UIMI_TLV_TAG_OPTIONAL_2;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 4);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* Create userdata */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_SEND_APDU,
                                            cmd_buf_p,
                                            NULL,
                                            ((qmi_uimi_client_state_type *)cl_sp)->common.clid);
  if (cb_userdata_ptr == NULL)
  {
    errval = QMI_ERR_NO_MEMORY;
    goto send_result;
  }

  /* Handle the optional channel id */
  if (tlv_data[2].present)
  {
    /* Check if the channel id is valid */
    for (i = 0; i < UIM_MAX_APDU_CHANNEL_COUNT; i++)
    {
      if (qmi_uim_global_ptr->apdu_channel[i] &&
          qmi_uim_global_ptr->apdu_channel[i]->slot == tlv_data[0].data.slot.slot &&
          qmi_uim_global_ptr->apdu_channel[i]->logical_channel == tlv_data[2].data.logical_channel.logical_channel)
      {
        channel_index = i;
        break;
      }
    }
    if (channel_index == UIM_INVALID_APP_INDEX)
    {
      errval = QMI_ERR_INVALID_ARG;
      qmi_uim_free_cb_userdata(cb_userdata_ptr);
      cb_userdata_ptr = NULL;
      goto send_result;
    }

    /* Insert channel id in the APDU */
    if (tlv_data[1].data.send_apdu.apdu_data.data_len > 0 &&
        tlv_data[1].data.send_apdu.apdu_data.data_ptr != NULL)
    {
      if(tlv_data[2].data.logical_channel.logical_channel < 4)
      {
        /* For logical channel number from 0 to 3, b7 of CLA byte should be 0 */
        tlv_data[1].data.send_apdu.apdu_data.data_ptr[0] &= 0xBC;
        /* After clearing the two lowest bits. Set the channel */
        tlv_data[1].data.send_apdu.apdu_data.data_ptr[0] |=
          tlv_data[2].data.logical_channel.logical_channel;
      }
      else
      {
        tlv_data[1].data.send_apdu.apdu_data.data_ptr[0] &= 0xF0;
        /* Extended channels 4 - 19 are represented 0000 - 1111
           in the lower byte of the class byte.
           After clearing the four lowest bits set the channel
           equal to the channel id - the offset(4) and set b7 of
           the class byte to indicate extended logical channels */
        tlv_data[1].data.send_apdu.apdu_data.data_ptr[0] |=
          (tlv_data[2].data.logical_channel.logical_channel - 4) | 0x40;
      }
    }
  }

  /* Check if APDU security restrictions are enforced */
  if (qmi_uim_is_apdu_request_rejected(tlv_data[0].data.slot.slot,
                                       tlv_data[1].data.send_apdu.apdu_data,
                                       &tlv_data[2],
                                       cl_sp))
  {
    mmgsdi_status = MMGSDI_ACCESS_DENIED;
  }
  else
  {
    /* Check if optional skip procedure bytes TLV is present */
    if (tlv_data[3].present)
    {
      if (tlv_data[3].data.skip_procedure_bytes.value)
      {
        apdu_option = MMGSDI_SEND_APDU_NO_IMPLICIT_STATUS_WORDS;
      }
      else
      {
        apdu_option = MMGSDI_SEND_APDU_RETURN_IMPLICIT_STATUS_WORDS;
      }
    }

    /* Call MMGSDI function to send APDU */
    mmgsdi_status = mmgsdi_send_apdu_ext(qmi_uim_global_ptr->mmgsdi_client_id,
                                         tlv_data[0].data.slot.slot,
                                         tlv_data[1].data.send_apdu.apdu_data,
                                         apdu_option,
                                         qmi_uimi_mmgsdi_callback,
                                         (mmgsdi_client_data_type)cb_userdata_ptr);
  }

  /* Free userdata in case of error */
  QMI_UIM_FREE_USERDATA_IF_ERROR(mmgsdi_status, cb_userdata_ptr);

  /* Convert MMGSDI status in QMI code */
  errval = qmi_uim_convert_mmgsdi_status_to_errval(mmgsdi_status);
  if (mmgsdi_status == MMGSDI_INCORRECT_PARAMS)
  {
    errval = QMI_ERR_INVALID_ARG;
  }

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(tlv_data, 4);

  return qmi_uimi_populate_response(errval,
                                    FALSE,
                                    0,
                                    0);
} /* qmi_uimi_send_apdu */


/*===========================================================================
  FUNCTION QMI_UIMI_SAP_CONNECTION()

  DESCRIPTION
    Send connection related SAP commands to the card

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_sap_connection
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type                errval          = QMI_ERR_NONE;
  dsm_item_type *                 response        = NULL;
  boolean                         retval          = TRUE;
  qmi_result_e_type               result          = QMI_RESULT_SUCCESS;
  mmgsdi_return_enum_type         mmgsdi_status   = MMGSDI_SUCCESS;
  uint8                           slot_idx        = 0;
  qmi_uim_sap_connection_op_type  op_type         = QMI_UIM_SAP_CONNECTION_OP_CHECK_STATUS;
  qmi_uimi_userdata_type*         cb_userdata_ptr = NULL;
  qmi_uim_tlv_item_type           tlv_data[4];

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);
  ASSERT(qmi_uim_global_ptr);

  memset(tlv_data, 0, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_SAP_CONNECT;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;
  tlv_data[1].type      = UIMI_TLV_TYPE_SAP_DISCONNECT_MODE;
  tlv_data[1].tag       = UIMI_TLV_TAG_OPTIONAL_1;
  tlv_data[2].type      = UIMI_TLV_TYPE_SAP_INTERMEDIATE_GET_RESP;
  tlv_data[2].tag       = UIMI_TLV_TAG_OPTIONAL_2;
  tlv_data[3].type      = UIMI_TLV_TYPE_SAP_CONNECTION_CONDITION;
  tlv_data[3].tag       = UIMI_TLV_TAG_OPTIONAL_3;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 4);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  if (qmi_uim_mmgsdi_slot_to_slot_index(tlv_data[0].data.sap_connection.slot,
                                        &slot_idx) != QMI_ERR_NONE)
  {
    errval = QMI_ERR_INVALID_ARG;
    goto send_result;
  }

  if(slot_idx >= QMI_UIM_MAX_CARD_COUNT ||
     slot_idx >= qmi_uim_global_ptr->card_state.num_slots)
  {
    errval = QMI_ERR_INVALID_ARG;
    goto send_result;
  }

  op_type = tlv_data[0].data.sap_connection.connect;

  /* Check to see if SAP connect is blocked/disabled based on the NV */
  if (qmi_uim_global_ptr->sap_sec_restr_supported &&
      op_type == QMI_UIM_SAP_CONNECTION_OP_CONNECT)
  {
    errval = QMI_ERR_ACCESS_DENIED;
    UIM_MSG_ERR_0("SAP request rejected due to security restrictions");
    goto send_result;
  }

  /* Create userdata */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_SAP_CONNECTION,
                                            cmd_buf_p,
                                            NULL,
                                            ((qmi_uimi_client_state_type *)cl_sp)->common.clid);
  if (cb_userdata_ptr == NULL)
  {
    errval = QMI_ERR_NO_MEMORY;
    goto send_result;
  }

  /* Perform respective connection operation */
  switch (op_type)
  {
    case QMI_UIM_SAP_CONNECTION_OP_DISCONNECT:
      /* Call MMGSDI function to disconnect */
      if (qmi_uim_global_ptr->sap_info[slot_idx].is_enabled)
      {
        mmgsdi_status = mmgsdi_sap_disconnect(
                              qmi_uim_global_ptr->mmgsdi_client_id,
                              tlv_data[0].data.sap_connection.slot,
                              MMGSDIBT_SERVER,
                              tlv_data[1].data.sap_disconnect_mode.mode,
                              qmi_uimi_mmgsdi_callback,
                              (mmgsdi_client_data_type)cb_userdata_ptr);
        /* Convert MMGSDI status in QMI code */
        errval = qmi_uim_convert_mmgsdi_status_to_errval(mmgsdi_status);

        /* Send SAP indication with disconnected successfully to the client if
           the queuing of the SAP disconnect is successful. We do this as it
           is not expected that the SAP disconnection would fail. This allows
           to better handle the card error event and disconnection CNF from MMGSDI */
        if(errval == QMI_ERR_NONE)
        {
          /* Simulate SAP state as DISCONNECTED and send the SAP indication
             to all the SAP registered clients */
          qmi_uim_global_ptr->sap_info[slot_idx].sap_state = MMGSDI_SAP_DISCONNECTED;
          qmi_uim_send_sap_status_indication_to_all(tlv_data[0].data.sap_connection.slot);

          /* Set is_enabled flag to FALSE after sending SAP disconnected
             indication to clients */
          qmi_uim_global_ptr->sap_info[slot_idx].is_enabled = FALSE;
        }
      }
      else
      {
        errval = QMI_ERR_NO_EFFECT;
        mmgsdi_status = MMGSDI_ERROR;
      }
      break;

    case QMI_UIM_SAP_CONNECTION_OP_CONNECT:
      /* Call MMGSDI function to connect */
      if (!qmi_uim_global_ptr->sap_info[slot_idx].is_enabled)
      {
        /* We use the condition from connection condtion TLV, if present.
           If TLV is not present, we default to either voice or data */
        mmgsdi_sap_conn_condition_enum_type conn_condition =
          tlv_data[3].present ? tlv_data[3].data.sap_connection_condtion.condition :
                                MMGSDI_SAP_CONN_COND_BLOCK_VOICE_OR_DATA;

        /* Get client state pointer */
        qmi_uimi_client_state_type * client_sp = (qmi_uimi_client_state_type *) cl_sp;

        mmgsdi_status = mmgsdi_sap_connect_ext(
                            qmi_uim_global_ptr->mmgsdi_client_id,
                            tlv_data[0].data.sap_connection.slot,
                            MMGSDIBT_SERVER,
                            conn_condition,
                            qmi_uimi_mmgsdi_callback,
                            (mmgsdi_client_data_type)cb_userdata_ptr);
        /* Convert MMGSDI status in QMI code */
        errval = qmi_uim_convert_mmgsdi_status_to_errval(mmgsdi_status);

        /* Update userdata with the intermediate get response info */
        if (tlv_data[2].present && (errval == QMI_ERR_NONE))
        {
          client_sp->uim_info.sap_intermediate_get_resp =
            tlv_data[2].data.sap_intermediate_get_resp.value;
        }
        else
        {
          client_sp->uim_info.sap_intermediate_get_resp = FALSE;
        }
      }
      else
      {
        errval = QMI_ERR_NO_EFFECT;
        mmgsdi_status = MMGSDI_ERROR;
      }
      break;

    case QMI_UIM_SAP_CONNECTION_OP_CHECK_STATUS:
      /* Send a synchronous reponse for check status */
      if (FALSE == qmi_uim_response_sap_state(
                      UIMI_TLV_RESP_TAG_OPTIONAL_1,
                      &response,
                      qmi_uim_global_ptr->sap_info[slot_idx].is_enabled,
                      qmi_uim_global_ptr->sap_info[slot_idx].sap_state))
      {
        errval = QMI_ERR_NO_MEMORY;
        dsm_free_packet(&response);
      }
      /* Fake setting just to make sure cb_userdata_ptr is cleaned */
      mmgsdi_status = MMGSDI_ERROR;
      break;

    default:
      /* At this point, this shouldnt happen */
      mmgsdi_status = MMGSDI_ERROR;
      errval = QMI_ERR_INVALID_ARG;
      break;
  }

  /* Free userdata in case of error */
  QMI_UIM_FREE_USERDATA_IF_ERROR(mmgsdi_status, cb_userdata_ptr);

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(tlv_data, 4);

  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);

  /* Only successful connect/disconnect requests have pending response */
  if ((errval == QMI_ERR_NONE) &&
      (op_type != QMI_UIM_SAP_CONNECTION_OP_CHECK_STATUS))
  {
    return QMI_SVC_RESPONSE_PENDING;
  }

  retval = qmi_svc_put_result_tlv(&response, result, errval);
  CHECK_RETVAL();

  return response;
} /* qmi_uimi_sap_connection */


/*===========================================================================
  FUNCTION QMI_UIMI_SAP_REQUEST()

  DESCRIPTION
    Send various SAP requests to the card

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_sap_request
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type                errval          = QMI_ERR_NONE;
  mmgsdi_return_enum_type         mmgsdi_status   = MMGSDI_SUCCESS;
  uint8                           slot_idx        = 0;
  int32                           channel_id      = 0;
  qmi_uimi_userdata_type*         cb_userdata_ptr = NULL;
  qmi_uim_tlv_item_type           tlv_data[2];

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);
  ASSERT(qmi_uim_global_ptr);

  memset(tlv_data, 0, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_SAP_REQUEST;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;
  tlv_data[1].type      = UIMI_TLV_TYPE_APDU_REQUEST;
  tlv_data[1].tag       = UIMI_TLV_TAG_OPTIONAL_1;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 2);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  if (qmi_uim_mmgsdi_slot_to_slot_index(tlv_data[0].data.sap_request.slot,
                                        &slot_idx) != QMI_ERR_NONE)
  {
    errval = QMI_ERR_INVALID_ARG;
    goto send_result;
  }

  if(slot_idx >= QMI_UIM_MAX_CARD_COUNT ||
     slot_idx >= qmi_uim_global_ptr->card_state.num_slots)
  {
    errval = QMI_ERR_INVALID_ARG;
    goto send_result;
  }

  /* Continue only if SAP connection is up */
  if (!qmi_uim_global_ptr->sap_info[slot_idx].is_enabled)
  {
    errval = QMI_ERR_INTERNAL;
    goto send_result;
  }

  /* Error if no send_apdu TLV present for send APDU request */
  if((tlv_data[0].data.sap_request.request == QMI_UIM_SAP_REQUEST_SEND_APDU) &&
     (!tlv_data[1].present))
  {
    UIM_MSG_ERR_0("send APDU request requires send_apdu TLV");
    errval = QMI_ERR_MISSING_ARG;
    goto send_result;
  }

  /* Create userdata */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_SAP_REQUEST,
                                            cmd_buf_p,
                                            NULL,
                                            ((qmi_uimi_client_state_type *)cl_sp)->common.clid);
  if (cb_userdata_ptr == NULL)
  {
    errval = QMI_ERR_NO_MEMORY;
    goto send_result;
  }

  /* Perform respective request operation */
  switch (tlv_data[0].data.sap_request.request)
  {
    case QMI_UIM_SAP_REQUEST_GET_ATR:
      mmgsdi_status = mmgsdi_sap_get_atr(
                        qmi_uim_global_ptr->mmgsdi_client_id,
                        tlv_data[0].data.sap_request.slot,
                        qmi_uimi_mmgsdi_callback,
                        (mmgsdi_client_data_type)cb_userdata_ptr);
      break;
    case QMI_UIM_SAP_REQUEST_SEND_APDU:
      /* Check if SAP request is restricted */
      if (qmi_uim_is_sap_request_rejected(tlv_data[1].data.send_apdu.apdu_data))
      {
        mmgsdi_status = MMGSDI_ACCESS_DENIED;
      }
      else
      {
        mmgsdi_status = mmgsdi_sap_send_apdu(
                          qmi_uim_global_ptr->mmgsdi_client_id,
                          tlv_data[0].data.sap_request.slot,
                          channel_id,
                          tlv_data[1].data.send_apdu.apdu_data,
                          qmi_uimi_mmgsdi_callback,
                          (mmgsdi_client_data_type)cb_userdata_ptr);

        /* Also save the INS byte if needed in userdata */
        if ((tlv_data[1].data.send_apdu.apdu_data.data_ptr) &&
            (tlv_data[1].data.send_apdu.apdu_data.data_len >= 2))
        {
          cb_userdata_ptr->data.sap_request.ins_value =
              tlv_data[1].data.send_apdu.apdu_data.data_ptr[1];
        }
      }
      break;
    case QMI_UIM_SAP_REQUEST_SIM_POWER_OFF:
      mmgsdi_status = mmgsdi_sap_power_off(
                        qmi_uim_global_ptr->mmgsdi_client_id,
                        tlv_data[0].data.sap_request.slot,
                        MMGSDIBT_SERVER,
                        qmi_uimi_mmgsdi_callback,
                        (mmgsdi_client_data_type)cb_userdata_ptr);
      break;
    case QMI_UIM_SAP_REQUEST_SIM_POWER_ON:
      mmgsdi_status = mmgsdi_sap_power_on(
                        qmi_uim_global_ptr->mmgsdi_client_id,
                        tlv_data[0].data.sap_request.slot,
                        MMGSDIBT_SERVER,
                        qmi_uimi_mmgsdi_callback,
                        (mmgsdi_client_data_type)cb_userdata_ptr);
      break;
    case QMI_UIM_SAP_REQUEST_SIM_RESET:
      mmgsdi_status = mmgsdi_sap_reset(
                        qmi_uim_global_ptr->mmgsdi_client_id,
                        tlv_data[0].data.sap_request.slot,
                        MMGSDIBT_SERVER,
                        qmi_uimi_mmgsdi_callback,
                        (mmgsdi_client_data_type)cb_userdata_ptr);
      break;
    case QMI_UIM_SAP_REQUEST_CARD_READER_STATUS:
      mmgsdi_status = mmgsdi_sap_card_reader_status(
                        qmi_uim_global_ptr->mmgsdi_client_id,
                        tlv_data[0].data.sap_request.slot,
                        MMGSDIBT_SERVER,
                        qmi_uimi_mmgsdi_callback,
                        (mmgsdi_client_data_type)cb_userdata_ptr);
      break;
    default:
      /* At this point, this shouldnt happen */
      mmgsdi_status = MMGSDI_ERROR;
      break;
  }

  /* Convert MMGSDI status in QMI code */
  errval = qmi_uim_convert_mmgsdi_status_to_errval(mmgsdi_status);

  /* Free userdata in case of error */
  QMI_UIM_FREE_USERDATA_IF_ERROR(mmgsdi_status, cb_userdata_ptr);

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(tlv_data, 2);

  return qmi_uimi_populate_response(errval,
                                    FALSE,
                                    0,
                                    0);
} /* qmi_uimi_sap_request */


/*===========================================================================
  FUNCTION QMI_UIMI_LOGICAL_CHANNEL()

  DESCRIPTION
    Open and closes a logical channel on the UICC card

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_logical_channel
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type             errval          = QMI_ERR_NONE;
  dsm_item_type *              response        = NULL;
  qmi_result_e_type            result          = QMI_RESULT_SUCCESS;
  boolean                      retval          = TRUE;
  boolean                      respond_now     = FALSE;
  qmi_uim_tlv_item_type        tlv_data[5];
  mmgsdi_select_rsp_enum_type  sel_rsp_type    = MMGSDI_SELECT_RSP_FCP;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);
  ASSERT(qmi_uim_global_ptr);

  memset(tlv_data, 0, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_SLOT;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;
  tlv_data[1].type      = UIMI_TLV_TYPE_AID;
  tlv_data[1].tag       = UIMI_TLV_TAG_OPTIONAL_1;
  tlv_data[2].type      = UIMI_TLV_TYPE_LOGICAL_CHANNEL;
  tlv_data[2].tag       = UIMI_TLV_TAG_OPTIONAL_2;
  tlv_data[3].type      = UIMI_TLV_TYPE_FILE_CONTROL_INFO;
  tlv_data[3].tag       = UIMI_TLV_TAG_OPTIONAL_3;
  tlv_data[4].type      = UIMI_TLV_TYPE_TERMINATE_APP;
  tlv_data[4].tag       = UIMI_TLV_TAG_OPTIONAL_4;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 5);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* Check that only one of the first two optional TLVs is present */
  if ((!tlv_data[1].present && !tlv_data[2].present) ||
      (tlv_data[1].present && tlv_data[2].present))
  {
    errval = QMI_ERR_INVALID_ARG;
    goto send_result;
  }

  /* Open logical channel */
  if (tlv_data[1].present)
  {
    /* Check if request needs to be rejected due to security restrictions */
    if (qmi_uim_is_logical_channel_request_rejected(tlv_data[1].data.aid.aid))
    {
      errval = QMI_ERR_ACCESS_DENIED;
    }
    else
    {
      if (tlv_data[3].present)
      {
        sel_rsp_type = tlv_data[3].data.file_control_info.fci_type;
      }

      errval = qmi_uim_execute_open_session_for_apdu(
                           tlv_data[0].data.slot.slot,
                           tlv_data[1].data.aid.aid,
                           sel_rsp_type,
                           cmd_buf_p,
                           FALSE,
                           ((qmi_uimi_client_state_type *)cl_sp)->common.clid);
    }
  }

  /* Close logical channel */
  if (tlv_data[2].present)
  {
    boolean terminate_app = TRUE;
    if(tlv_data[4].present)
    {
      terminate_app = tlv_data[4].data.terminate_app.value;
    }
    errval = qmi_uim_execute_close_session_for_apdu(
                         tlv_data[0].data.slot.slot,
                         tlv_data[2].data.logical_channel.logical_channel,
                         terminate_app,
                         cl_sp,
                         cmd_buf_p,
                         ((qmi_uimi_client_state_type *)cl_sp)->common.clid);

    /* For close channel, respond based on NV configuration */
    respond_now = qmi_uim_global_ptr->close_channel_sync;
  }

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(tlv_data, 5);

  if (errval == QMI_ERR_NONE && respond_now == FALSE)
  {
    return QMI_SVC_RESPONSE_PENDING;
  }

  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  CHECK_RETVAL();

  return response;
} /* qmi_uimi_logical_channel */


/*===========================================================================
  FUNCTION QMI_UIMI_SUBSCRIPTION_OK()

  DESCRIPTION
    Indicate OK or not OK to publish subscription to a provisioing application

  PARAMETERS
    sp          : service provided state pointer
    cmd_buf_ptr : ptr to cmd buffer
    cl_sp       : client state pointer
    sdu_in      : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_subscription_ok
(
  void *            sp,
  void *            cmd_buf_ptr,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type               errval                = QMI_ERR_NONE;
  mmgsdi_session_id_type         session_id            = UIM_INVALID_SESSION_ID;
  mmgsdi_return_enum_type        mmgsdi_status         = MMGSDI_ERROR;
  qmi_uim_tlv_item_type          tlv_data[3];
  qmi_uimi_userdata_type*        cb_userdata_ptr       = NULL;
  qmi_uim_imsi_type              imsi_data             = {0, };

  ASSERT(sp);
  ASSERT(cmd_buf_ptr);
  ASSERT(cl_sp);
  ASSERT(sdu_in);
  ASSERT(qmi_uim_global_ptr);

  memset(tlv_data, 0x00, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_SESSION_INFORMATION;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;
  tlv_data[1].type      = UIMI_TLV_TYPE_SUBSCRIPTION_OK;
  tlv_data[1].tag       = UIMI_TLV_TAG_MANDATORY_2;
  tlv_data[2].type      = UIMI_TLV_TYPE_DECRYPTED_IMSI;
  tlv_data[2].tag       = UIMI_TLV_TAG_OPTIONAL_1;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 3);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  if (qmi_uim_get_halt_subscription_value() == FALSE)
  {
    UIM_MSG_HIGH_0("SUB OK req not supported.Halt sub config set to FALSE");
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
    goto send_result;
  }
  else
  {
    UIM_MSG_HIGH_0("SUB OK req supported");
  }

  /* Only provisioning sessions are supported */
  if (tlv_data[0].data.session_information.session_type != MMGSDI_GW_PROV_PRI_SESSION &&
      tlv_data[0].data.session_information.session_type != MMGSDI_1X_PROV_PRI_SESSION &&
      tlv_data[0].data.session_information.session_type != MMGSDI_GW_PROV_SEC_SESSION &&
      tlv_data[0].data.session_information.session_type != MMGSDI_1X_PROV_SEC_SESSION &&
      tlv_data[0].data.session_information.session_type != MMGSDI_GW_PROV_TER_SESSION &&
      tlv_data[0].data.session_information.session_type != MMGSDI_1X_PROV_TER_SESSION )
  {
    UIM_MSG_ERR_1("Impossible to send SUB OK for a non provisioning session: 0x%x",
                  tlv_data[0].data.session_information.session_type);
    errval = QMI_ERR_INVALID_ARG;
    goto send_result;
  }

  /* Retrieve session id */
  errval = qmi_uim_session_type_to_session_id(&session_id,
                                              tlv_data[0].data.session_information.session_type,
                                              tlv_data[0].data.session_information.aid);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* Check the UIM configuration support for Trust Zone sub ok requests by
     getting encrypted IMSI required for sub ok value from EFS */
  if(qmi_uim_get_encrypted_sub_ok_value() && tlv_data[1].data.ok_for_subscription.value)
  {
    if(!tlv_data[2].present)
    {
      UIM_MSG_HIGH_0("SUB OK requires encrypted IMSI but none was supplied with request");
      errval = QMI_ERR_MISSING_ARG;
      goto send_result;
    }

    /* Read the IMSI through MMGSDI to compare to the encrypted IMSI */
    errval = qmi_uim_read_imsi_for_session_id(session_id, &imsi_data);
    if(errval != QMI_ERR_NONE)
    {
      UIM_MSG_ERR_0("Could not read IMSI for encrypted sub ok");
      goto send_result;
    }

    if(tlv_data[2].data.decrypted_imsi.imsi_data.len != imsi_data.len ||
       memcmp(tlv_data[2].data.decrypted_imsi.imsi_data.imsi, imsi_data.imsi, imsi_data.len) != 0)
    {
      UIM_MSG_HIGH_0("Decrypted IMSI does not match card");
      errval = QMI_ERR_AUTHENTICATION_FAILED;
      goto send_result;
    }
    UIM_MSG_MED_0("Decrypted IMSI matches card. Proceed with sub ok");
  }

  /* Create userdata */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_SUBSCRIPTION_OK_REQ,
                                            cmd_buf_ptr,
                                            NULL,
                                            ((qmi_uimi_client_state_type *)cl_sp)->common.clid);
  if (cb_userdata_ptr == NULL)
  {
    errval = QMI_ERR_NO_MEMORY;
    goto send_result;
  }

  /* Call MMGSDI API session subscription OK */
  mmgsdi_status = mmgsdi_session_subscription_ok(
                              session_id,
                              tlv_data[1].data.ok_for_subscription.value,
                              qmi_uimi_mmgsdi_callback,
                              (mmgsdi_client_data_type)cb_userdata_ptr);

  /* Free userdata in case of error */
  QMI_UIM_FREE_USERDATA_IF_ERROR(mmgsdi_status, cb_userdata_ptr);

  /* Convert MMGSDI status in QMI code */
  errval = qmi_uim_convert_mmgsdi_status_to_errval(mmgsdi_status);

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(tlv_data, 3);

  return qmi_uimi_populate_response(errval,
                                    FALSE,
                                    0,
                                    0);
} /* qmi_uimi_subscription_ok() */


/*===========================================================================
  FUNCTION QMI_UIMI_GET_ATR()

  DESCRIPTION
    Retrieves the ATR of a specific card

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_get_atr
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type                errval          = QMI_ERR_NONE;
  mmgsdi_return_enum_type         mmgsdi_status   = MMGSDI_SUCCESS;
  qmi_uimi_userdata_type*         cb_userdata_ptr = NULL;
  mmgsdi_option_type              mmgsdi_option   = {0, NULL};
  qmi_uim_tlv_item_type           tlv_data[1];

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);
  ASSERT(qmi_uim_global_ptr);

  memset(tlv_data, 0, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_SLOT;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 1);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* Create userdata */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_GET_ATR,
                                            cmd_buf_p,
                                            NULL,
                                            ((qmi_uimi_client_state_type *)cl_sp)->common.clid);
  if (cb_userdata_ptr == NULL)
  {
    errval = QMI_ERR_NO_MEMORY;
    goto send_result;
  }

  /* Execute MMGSDI function to get the ATR */
  mmgsdi_status = mmgsdi_get_atr(
                    qmi_uim_global_ptr->mmgsdi_client_id,
                    tlv_data[0].data.slot.slot,
                    mmgsdi_option,
                    qmi_uimi_mmgsdi_callback,
                    (mmgsdi_client_data_type)cb_userdata_ptr );

  /* Convert MMGSDI status in QMI code */
  errval = qmi_uim_convert_mmgsdi_status_to_errval(mmgsdi_status);

  /* Free userdata in case of error */
  QMI_UIM_FREE_USERDATA_IF_ERROR(mmgsdi_status, cb_userdata_ptr);

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(tlv_data, 1);

  return qmi_uimi_populate_response(errval,
                                    FALSE,
                                    0,
                                    0);
} /* qmi_uimi_get_atr */


/*===========================================================================
  FUNCTION QMI_UIMI_OPEN_LOGICAL_CHANNEL()

  DESCRIPTION
    This function opens a logical channel to an application on a UICC card,
    with the specified AID value. The logical channel is exclusive for the
    control point and is not shared with any other client. The logical channel
    can be used to stream APDUs without interfering with the logical channels
    used by the modem or by other clients. The channel ID can be used in the
    QMI_UIM_SEND_APDU request to send the APDU on the logical channel.

    If the optional TLV with the AID is missing, the logical channel is created
    without selecting any application.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
  static dsm_item_type * qmi_uimi_open_logical_channel
  (
    void *            sp,
    void *            cmd_buf_p,
    void *            cl_sp,
    dsm_item_type **  sdu_in
  )
  {
    qmi_error_e_type             errval          = QMI_ERR_NONE;
    dsm_item_type *              response        = NULL;
    qmi_result_e_type            result          = QMI_RESULT_SUCCESS;
    boolean                      retval          = TRUE;
    qmi_uim_tlv_item_type        tlv_data[3];
    mmgsdi_select_rsp_enum_type  sel_rsp_type    = MMGSDI_SELECT_RSP_FCP;

    ASSERT(sp);
    ASSERT(cmd_buf_p);
    ASSERT(cl_sp);
    ASSERT(sdu_in);
    ASSERT(qmi_uim_global_ptr);

    memset(tlv_data, 0, sizeof(tlv_data));
    tlv_data[0].type      = UIMI_TLV_TYPE_SLOT;
    tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;
    tlv_data[1].type      = UIMI_TLV_TYPE_AID;
    tlv_data[1].tag       = UIMI_TLV_TAG_OPTIONAL_1;
    tlv_data[2].type      = UIMI_TLV_TYPE_FILE_CONTROL_INFO;
    tlv_data[2].tag       = UIMI_TLV_TAG_OPTIONAL_2;

    /* Parse TLV */
    errval = qmi_uim_parse_request(sdu_in, tlv_data, 3);
    if (errval != QMI_ERR_NONE)
    {
      goto send_result;
    }

    /* Check if request needs to be rejected due to security restrictions */
    if (qmi_uim_is_logical_channel_request_rejected(tlv_data[1].data.aid.aid))
    {
      errval = QMI_ERR_ACCESS_DENIED;
      goto send_result;
    }

    /* Open logical channel - This API cannot be used to close session */
    if (tlv_data[2].present)
    {
      sel_rsp_type = tlv_data[2].data.file_control_info.fci_type;
    }

    /* If AID is missing the session open is intended to select MF */
    errval = qmi_uim_execute_open_session_for_apdu(
                         tlv_data[0].data.slot.slot,
                         tlv_data[1].data.aid.aid,
                         sel_rsp_type,
                         cmd_buf_p,
                         (tlv_data[1].present == FALSE) ? TRUE : FALSE,
                         ((qmi_uimi_client_state_type *)cl_sp)->common.clid);

send_result:
    /* Free the buffer used for data */
    qmi_uim_free_tlv_content(tlv_data, 3);

    if (errval == QMI_ERR_NONE)
    {
      return QMI_SVC_RESPONSE_PENDING;
    }

    result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                     : QMI_RESULT_FAILURE);
    retval = qmi_svc_put_result_tlv(&response, result, errval);
    CHECK_RETVAL();

    return response;
} /* qmi_uimi_open_logical_channel */


/*===========================================================================
  FUNCTION QMI_UIMI_REFRESH_REGISTER_ALL()

  DESCRIPTION
    Register for refresh of all files. This function sends immediately the
    response to the client, even if MMGSDI still needs to process it. This
    is consistent with all other refresh commands.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_uimi_refresh_register_all
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *                response        = NULL;
  qmi_error_e_type               errval          = QMI_ERR_NONE;
  qmi_result_e_type              result          = QMI_RESULT_SUCCESS;
  boolean                        retval          = TRUE;
  mmgsdi_session_id_type         session_id      = UIM_INVALID_SESSION_ID;
  boolean                        opening_session = FALSE;
  qmi_uim_tlv_item_type          tlv_data[3];

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(tlv_data, 0, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_SESSION_INFORMATION;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;
  tlv_data[1].type      = UIMI_TLV_TYPE_REGISTER_FOR_REFRESH;
  tlv_data[1].tag       = UIMI_TLV_TAG_MANDATORY_2;
  tlv_data[2].type      = UIMI_TLV_TYPE_REFRESH_VOTE_FOR_INIT;
  tlv_data[2].tag       = UIMI_TLV_RESP_TAG_OPTIONAL_1;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 3);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* Make sure that we are not using an APDU session */
  if ((tlv_data[0].data.session_information.session_type == MMGSDI_NON_PROV_SESSION_SLOT_1 ||
       tlv_data[0].data.session_information.session_type == MMGSDI_NON_PROV_SESSION_SLOT_2 ||
       tlv_data[0].data.session_information.session_type == MMGSDI_NON_PROV_SESSION_SLOT_3) &&
       tlv_data[0].data.session_information.aid.data_len == QMI_UIM_TLV_CHANNEL_ID_LEN)
  {
    errval = QMI_ERR_INVALID_ARG;
    goto send_result;
  }

  /* Retrieve session id */
  errval = qmi_uim_session_type_to_session_id(&session_id,
                                              tlv_data[0].data.session_information.session_type,
                                              tlv_data[0].data.session_information.aid);

  if (errval != QMI_ERR_NONE)
  {
    if(errval == QMI_ERR_DEVICE_NOT_READY)
    {
      goto send_result;
    }

    /* Try to open session */
    errval = qmi_uim_open_session(UIMI_CMD_VAL_REFRESH_REGISTER_ALL,
                                  tlv_data, 3,
                                  cmd_buf_p, cl_sp);
    if (errval == QMI_ERR_NONE)
    {
      opening_session = TRUE;
    }
  }
  else
  {
    /* Execute MMGSDI function. If vote for init TLV is absent,
       we default the vote to FALSE */
    errval = qmi_uim_execute_refresh_register_all(
                            session_id,
                            tlv_data[1].data.refresh_registration.value,
                            tlv_data[2].present ? tlv_data[2].data.refresh_vote_for_init.value : FALSE,
                            (qmi_cmd_buf_type *) cmd_buf_p);
  }

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(tlv_data, 3);

  if (opening_session)
  {
    return QMI_SVC_RESPONSE_PENDING;
  }

  /* Send result */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  CHECK_RETVAL();

  return response;
} /* qmi_uimi_refresh_register_all() */


/*===========================================================================
  FUNCTION QMI_UIMI_SET_FILE_STATUS()

  DESCRIPTION
    Activate or deactivate a file.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_uimi_set_file_status
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *                response        = NULL;
  qmi_error_e_type               errval          = QMI_ERR_NONE;
  qmi_result_e_type              result          = QMI_RESULT_SUCCESS;
  boolean                        retval          = TRUE;
  mmgsdi_session_id_type         session_id      = UIM_INVALID_SESSION_ID;
  qmi_uim_tlv_item_type          tlv_data[3];

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(tlv_data, 0, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_SESSION_INFORMATION;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;
  tlv_data[1].type      = UIMI_TLV_TYPE_FILE_ID;
  tlv_data[1].tag       = UIMI_TLV_TAG_MANDATORY_2;
  tlv_data[2].type      = UIMI_TLV_TYPE_FILE_STATUS;
  tlv_data[2].tag       = UIMI_TLV_TAG_MANDATORY_3;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 3);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* Retrieve session id */
  errval = qmi_uim_session_type_to_session_id(&session_id,
                                              tlv_data[0].data.session_information.session_type,
                                              tlv_data[0].data.session_information.aid);

  if (errval != QMI_ERR_NONE)
  {
    if(errval == QMI_ERR_DEVICE_NOT_READY)
    {
      goto send_result;
    }

    /* Try to open session */
    errval = qmi_uim_open_session(UIMI_CMD_VAL_SET_FILE_STATUS,
                                  tlv_data, 3,
                                  cmd_buf_p, cl_sp);
  }
  else
  {
    /* Execute MMGSDI function */
    errval = qmi_uim_execute_set_file_status(
                            session_id,
                            tlv_data[1].data.file_id.file_access,
                            tlv_data[2].data.file_status.file_status,
                            cmd_buf_p,
                            ((qmi_uimi_client_state_type *)cl_sp)->common.clid);

    /* Associate the Client with the requested Session (if it is a
       non-prov. Session) */
    if(errval == QMI_ERR_NONE)
    {
      (void)qmi_uim_update_non_prov_session_cl_sp(tlv_data,
                                                  3,
                                                  cl_sp);
    }
  }

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(tlv_data, 3);

  if (errval == QMI_ERR_NONE)
  {
    return QMI_SVC_RESPONSE_PENDING;
  }

  /* Send result */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  CHECK_RETVAL();

  return response;
} /* qmi_uimi_set_file_status() */


/*===========================================================================
  FUNCTION qmi_uimi_get_slots_status()

  DESCRIPTION
    Get current physical slots status

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    QMI UIM service must be initialized and registered with Framework

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_get_slots_status
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type           errval                   = QMI_ERR_NONE;
  dsm_item_type *            response                 = NULL;
  boolean                    retval                   = TRUE;
  qmi_result_e_type          result                   = QMI_RESULT_SUCCESS;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);
  ASSERT(qmi_uim_global_ptr);

#ifdef FEATURE_UIM_DS_SUBSCRIPTION_MANAGER
  if(qmi_uim_global_ptr->physical_slots_info.num_slots == 0||
     qmi_uim_global_ptr->physical_slots_info.slot_status_ptr == NULL)
  {
    /* If QMI UIM never registered with drivers for slots status or if
       or if the number of physical slots reported by drivers is zero,
       return error to user */
    errval = QMI_ERR_INTERNAL;
    goto send_result;
  }

  /* Insert physical slots status data from the global into the response TLV */
  if (FALSE == qmi_uim_response_physical_slots_status(UIMI_TLV_RESP_TAG_OPTIONAL_1,
                                                      &response,
                                                      qmi_uim_global_ptr->physical_slots_info.slot_status_ptr,
                                                      qmi_uim_global_ptr->physical_slots_info.num_slots))
  {
    errval = QMI_ERR_INTERNAL;
    dsm_free_packet(&response);
  }
#else
  errval = QMI_ERR_NOT_SUPPORTED;
#endif /* FEATURE_UIM_DS_SUBSCRIPTION_MANAGER */

#ifdef FEATURE_UIM_DS_SUBSCRIPTION_MANAGER
send_result:
#endif
  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  CHECK_RETVAL();

  return response;
} /* qmi_uimi_get_slots_status() */


/*===========================================================================
  FUNCTION QMI_UIMI_SWITCH_SLOT()

  DESCRIPTION
    Switches the physical slot tied to current logical slot such that the
    current logical slot now maps to the physical slot mentioned in the request

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_uimi_switch_slot
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *             response        = NULL;
  qmi_error_e_type            errval          = QMI_ERR_INTERNAL;
  boolean                     retval          = TRUE;
  qmi_uim_tlv_item_type       tlv_data[2];
  uim_slot_type               uim_log_slot    = UIM_SLOT_NONE;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);
  ASSERT(qmi_uim_global_ptr);

  memset(tlv_data, 0, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_SLOT;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;
  tlv_data[1].type      = UIMI_TLV_TYPE_PHYSICAL_SLOT;
  tlv_data[1].tag       = UIMI_TLV_TAG_MANDATORY_2;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 2);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  if(qmi_uim_mmgsdi_slot_id_to_uim_slot_id(tlv_data[0].data.slot.slot,
                                           &uim_log_slot) != QMI_ERR_NONE)
  {
    errval = QMI_ERR_NOT_SUPPORTED;
    goto send_result;
  }

#ifdef FEATURE_UIM_DS_SUBSCRIPTION_MANAGER
  /* If the physical slot that is requested to be switched to or to be
     activated is already active, return */
  if(TRUE == qmi_uim_is_physical_slot_active_for_logical_slot(uim_log_slot,
                                                              tlv_data[1].data.physical_slot.slot))
  {
    errval = QMI_ERR_NO_EFFECT;
    goto send_result;
  }

  /* Execute UIMDRV function to switch the slot */
  if(UIM_PASS != uim_sm_switch_slot(uim_log_slot,
                                    tlv_data[1].data.physical_slot.slot))
  {
    errval = QMI_ERR_INTERNAL;
  }
#else
  errval = QMI_ERR_NOT_SUPPORTED;
  goto send_result;
#endif /* FEATURE_UIM_DS_SUBSCRIPTION_MANAGER */

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(tlv_data, 2);

  retval = qmi_svc_put_result_tlv(
             &response,
             (errval != QMI_ERR_NONE) ? QMI_RESULT_FAILURE : QMI_RESULT_SUCCESS,
             errval);
  CHECK_RETVAL();

  return response;
} /* qmi_uimi_switch_slot() */


/*===========================================================================
  FUNCTION qmi_uimi_get_plmn_name_table_info()

  DESCRIPTION
    Gets the SE13 Table Release Date and Source

  PARAMETERS

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    QMI UIM service must be initialized and registered with Framework

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_get_plmn_name_table_info
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type                   errval      = QMI_ERR_NONE;
  dsm_item_type *                    response    = NULL;
  boolean                            retval      = TRUE;
  qmi_result_e_type                  result      = QMI_RESULT_SUCCESS;
  mmgsdi_se13_table_details_info     se13_table_details_info;

  memset(&se13_table_details_info, 0x00, sizeof(mmgsdi_se13_table_details_info));

  if(MMGSDI_SUCCESS == mmgsdi_get_se13_table_release_info(&se13_table_details_info))
  {
    if (FALSE == qmi_uim_response_se13_table_release_date(UIMI_TLV_RESP_TAG_OPTIONAL_1,
                                                          &response,
                                                          &se13_table_details_info))
    {
      errval = QMI_ERR_INTERNAL;
      dsm_free_packet(&response);
    }

    if (FALSE == qmi_uim_response_se13_table_release_source(UIMI_TLV_RESP_TAG_OPTIONAL_2,
                                                            &response,
                                                            &se13_table_details_info))
    {
      errval = QMI_ERR_INTERNAL;
      dsm_free_packet(&response);
    }
  }
  else
  {
    errval = QMI_ERR_INTERNAL;
  }

  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  CHECK_RETVAL();

  return response;
} /* qmi_uimi_get_plmn_name_table_info */


/*===========================================================================
  FUNCTION QMI_UIMI_INCREASE()

  DESCRIPTION
    Increase the file on the card

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_increase
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type               errval        = QMI_ERR_NONE;
  mmgsdi_session_id_type         session_id    = UIM_INVALID_SESSION_ID;
  qmi_uimi_ind_token_info_type   token_info    = {FALSE, 0};
  qmi_uim_tlv_item_type          tlv_data[4];

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(tlv_data, 0, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_SESSION_INFORMATION;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;
  tlv_data[1].type      = UIMI_TLV_TYPE_FILE_ID;
  tlv_data[1].tag       = UIMI_TLV_TAG_MANDATORY_2;
  tlv_data[2].type      = UIMI_TLV_TYPE_INCREASE;
  tlv_data[2].tag       = UIMI_TLV_TAG_MANDATORY_3;
  tlv_data[3].type      = UIMI_TLV_TYPE_IND_TOKEN;
  tlv_data[3].tag       = UIMI_TLV_TAG_OPTIONAL_1;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 4);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* Check if request needs to be rejected due to security restrictions */
  if (qmi_uim_is_request_rejected(tlv_data[0].data.session_information.session_type,
                                  tlv_data[0].data.session_information.aid,
                                  cl_sp))
  {
    errval = QMI_ERR_ACCESS_DENIED;
    goto send_result;
  }

  /* Update token info */
  token_info.is_valid = tlv_data[3].present;
  token_info.token = tlv_data[3].data.ind_token.value;

  /* Retrieve session id */
  errval = qmi_uim_session_type_to_session_id(&session_id,
                                              tlv_data[0].data.session_information.session_type,
                                              tlv_data[0].data.session_information.aid);

  if (errval != QMI_ERR_NONE)
  {
    if(errval == QMI_ERR_DEVICE_NOT_READY)
    {
      goto send_result;
    }

    /* Try to open session */
    errval = qmi_uim_open_session(UIMI_CMD_VAL_INCREASE,
                                  tlv_data, 4,
                                  token_info.is_valid ? NULL : cmd_buf_p,
                                  cl_sp);
  }
  else
  {
    /* Execute MMGSDI function */
    errval = qmi_uim_execute_increase(
                            session_id,
                            tlv_data[1].data.file_id.file_access,
                            tlv_data[2].data.increase_data.data,
                            token_info.is_valid ? &token_info.token : NULL,
                            token_info.is_valid ? NULL : cmd_buf_p,
                            ((qmi_uimi_client_state_type *)cl_sp)->common.clid);

    /* Associate the Client with the requested Session (if it is a
       non-prov. Session) */
    if(errval == QMI_ERR_NONE)
    {
      (void)qmi_uim_update_non_prov_session_cl_sp(tlv_data,
                                                  4,
                                                  cl_sp);
    }
  }

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(tlv_data, 4);

  return qmi_uimi_populate_response(errval,
                                    token_info.is_valid,
                                    token_info.token,
                                    UIMI_TLV_RESP_TAG_OPTIONAL_3);
} /* qmi_uimi_increase() */


/*===========================================================================
  FUNCTION QMI_UIMI_RECOVERY()

  DESCRIPTION
    Recovers the card information

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_recovery
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type               errval          = QMI_ERR_NONE;
  uim_return_type                uim_status      = UIM_GENERIC_ERROR;
  qmi_uim_tlv_item_type          tlv_data[1];
  uim_slot_type                  slot            = UIM_SLOT_NONE;
  qmi_uimi_userdata_type*        cb_userdata_ptr = NULL;
  uint8                          recovery_flag   = 0;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(tlv_data, 0, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_SLOT;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 1);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  if(qmi_uim_mmgsdi_slot_id_to_uim_slot_id(tlv_data[0].data.slot.slot,
                                           &slot) != QMI_ERR_NONE)
  {
    errval = QMI_ERR_INVALID_ARG;
    goto send_result;
  }

  if (uim_common_efs_read(
        UIM_COMMON_EFS_UIMQMI_QMI_UIM_CONFIG_SILENT_RECOVERY,
        UIM_COMMON_EFS_ITEM_FILE_TYPE,
        UIM_COMMON_EFS_DEVICE,
        &recovery_flag,
        sizeof(recovery_flag)) != UIM_COMMON_EFS_SUCCESS)
  {
    UIM_MSG_HIGH_0("Failed to read recovery configuration from NV");
    recovery_flag = FALSE;
  }

  if (recovery_flag == FALSE)
  {
    UIM_MSG_HIGH_0("External recovery not allowed");
    errval = QMI_ERR_NOT_SUPPORTED;
    goto send_result;
  }

  /* Create userdata */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_RECOVERY,
                                            cmd_buf_p,
                                            NULL,
                                            ((qmi_uimi_client_state_type *)cl_sp)->common.clid);
  if (cb_userdata_ptr == NULL)
  {
    errval = QMI_ERR_NO_MEMORY;
    goto send_result;
  }

  uim_status = uim_trigger_silent_recovery(slot,
                                           cb_userdata_ptr,
                                           qmi_uimi_recovery_callback);

  if (uim_status != UIM_SUCCESS)
  {
    qmi_uim_free_cb_userdata(cb_userdata_ptr);
    cb_userdata_ptr = NULL;
    errval = QMI_ERR_INTERNAL;
  }

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(tlv_data, 1);

  return qmi_uimi_populate_response(errval, FALSE, 0, 0);
} /* qmi_uimi_recovery */


/*===========================================================================
  FUNCTION QMI_UIMI_RESELECT()

  DESCRIPTION
    Reselects an AID on the given channel

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_reselect
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type               errval          = QMI_ERR_NONE;
  mmgsdi_return_enum_type        mmgsdi_status   = MMGSDI_ERROR;
  qmi_uim_tlv_item_type          tlv_data[3];
  qmi_uimi_userdata_type*        cb_userdata_ptr = NULL;
  uint8                          i               = 0;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(tlv_data, 0, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_SLOT;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;
  tlv_data[1].type      = UIMI_TLV_TYPE_LOGICAL_CHANNEL;
  tlv_data[1].tag       = UIMI_TLV_TAG_MANDATORY_2;
  tlv_data[2].type      = UIMI_TLV_TYPE_SELECT_MODE;
  tlv_data[2].tag       = UIMI_TLV_TAG_MANDATORY_3;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 3);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  if (tlv_data[2].data.select_mode.mode != MMGSDI_SELECT_MODE_NEXT)
  {
    errval = QMI_ERR_NOT_SUPPORTED;
    goto send_result;
  }

  for (i = 0; i < UIM_MAX_APDU_CHANNEL_COUNT; i++)
  {
    if (qmi_uim_global_ptr->apdu_channel[i] != NULL &&
        qmi_uim_global_ptr->apdu_channel[i]->slot ==
          tlv_data[0].data.slot.slot &&
        qmi_uim_global_ptr->apdu_channel[i]->logical_channel ==
          tlv_data[1].data.logical_channel.logical_channel &&
        qmi_uim_global_ptr->apdu_channel[i]->mmgsdi_session_id !=
         UIM_INVALID_SESSION_ID)
    {
      break;
    }
  }

  if (i == UIM_MAX_APDU_CHANNEL_COUNT)
  {
    errval = QMI_ERR_INVALID_ARG;
    goto send_result;
  }

  if (qmi_uim_global_ptr->apdu_sec_restr_value != QMI_UIM_APDU_SEC_RESTRICTIONS_NONE &&
      qmi_uim_global_ptr->apdu_channel[i]->opening_cl_sp->common.clid !=
          ((qmi_uimi_client_state_type *)cl_sp)->common.clid)
  {
    errval = QMI_ERR_ACCESS_DENIED;
    goto send_result;
  }

  /* Create userdata */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_RESELECT,
                                            cmd_buf_p,
                                            NULL,
                                            ((qmi_uimi_client_state_type *)cl_sp)->common.clid);
  if (cb_userdata_ptr == NULL)
  {
    errval = QMI_ERR_NO_MEMORY;
    goto send_result;
  }

  /* Pack the channel index that can later be retrieve to updated the AID
     (in the global for this apdu_channel) returned by the card in SELECT
     response */
  cb_userdata_ptr->data.reselect_request.channel_index = i;

  mmgsdi_status = mmgsdi_session_reselect_aid(qmi_uim_global_ptr->apdu_channel[i]->mmgsdi_session_id,
                                              tlv_data[2].data.select_mode.mode,
                                              qmi_uimi_mmgsdi_callback,
                                              (mmgsdi_client_data_type)cb_userdata_ptr);

  /* Free userdata in case of error */
  QMI_UIM_FREE_USERDATA_IF_ERROR(mmgsdi_status, cb_userdata_ptr);

  /* Convert MMGSDI status in QMI code */
  errval = qmi_uim_convert_mmgsdi_status_to_errval(mmgsdi_status);

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(tlv_data, 3);

  return qmi_uimi_populate_response(errval, FALSE, 0, 0);
} /* qmi_uimi_reselect */


/*===========================================================================
  FUNCTION QMI_UIMI_SEND_STATUS()

  DESCRIPTION
    Sends the status command.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_send_status
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type                 errval          = QMI_ERR_NONE;
  qmi_uim_tlv_item_type            tlv_data[3];
  mmgsdi_session_id_type           session_id;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(tlv_data, 0, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_SESSION_INFORMATION;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;
  tlv_data[1].type      = UIMI_TLV_TYPE_STATUS_CMD_MODE;
  tlv_data[1].tag       = UIMI_TLV_TAG_OPTIONAL_1;
  tlv_data[2].type      = UIMI_TLV_TYPE_STATUS_CMD_RESP;
  tlv_data[2].tag       = UIMI_TLV_TAG_OPTIONAL_2;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 3);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* Retrieve session id */
  errval = qmi_uim_session_type_to_session_id(&session_id,
                                              tlv_data[0].data.session_information.session_type,
                                              tlv_data[0].data.session_information.aid);
  if (errval != QMI_ERR_NONE)
  {
    if(errval == QMI_ERR_DEVICE_NOT_READY)
    {
      goto send_result;
    }

    /* Try to open session */
    errval = qmi_uim_open_session(UIMI_CMD_VAL_SEND_STATUS,
                                  tlv_data,
                                  3,
                                  cmd_buf_p,
                                  cl_sp);
  }
  else
  {
    /* Execute MMGSDI function */
    errval = qmi_uim_execute_status(
                            session_id,
                            (tlv_data[1].present) ?
                              tlv_data[1].data.status_cmd_mode.mode :
                              MMGSDI_STATUS_APP_NO_INDICATION,
                            (tlv_data[2].present) ?
                              tlv_data[2].data.status_cmd_resp.resp :
                              MMGSDI_STATUS_NO_DATA,
                            cmd_buf_p,
                            ((qmi_uimi_client_state_type *)cl_sp)->common.clid);

    /* Associate the Client with the requested Session (if it is a
       non-prov. Session) */
    if(errval == QMI_ERR_NONE)
    {
      (void)qmi_uim_update_non_prov_session_cl_sp(tlv_data,
                                                  3,
                                                  cl_sp);
    }
  }

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(tlv_data, 3);

  return qmi_uimi_populate_response(errval, FALSE, 0, 0);
} /* qmi_uimi_send_status */


/*===========================================================================
  FUNCTION QMI_UIMI_PERSONALIZATION()

  DESCRIPTION
    Activates the personalization of the device to a particular lock feature.
    Only one feature can be activated at a time

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_personalization
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type                     errval             = QMI_ERR_NONE;
  qmi_uimi_userdata_type  *            cb_userdata_ptr    = NULL;
  simlock_result_enum_type             simlock_status     = SIMLOCK_GENERIC_ERROR;
  simlock_slot_enum_type               simlock_slot       = SIMLOCK_SLOT_1;
  uint8                                index              = 0;
  uint8                                code_index         = 0;
  qmi_uim_tlv_item_type                tlv_data[15];
  uint8                                loop_cnt           = 0;
  uint8                                table_indexes[]    = {1, 2, 3, 4, 5, 6, 7, 8, 13, 14};

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);
  ASSERT(qmi_uim_global_ptr);

  memset(tlv_data, 0, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_PERSONALIZATION;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;
  tlv_data[1].type      = UIMI_TLV_TYPE_GW_NW_PERSO_CODE;
  tlv_data[1].tag       = UIMI_TLV_TAG_OPTIONAL_1;
  tlv_data[2].type      = UIMI_TLV_TYPE_GW_NS_PERSO_CODE;
  tlv_data[2].tag       = UIMI_TLV_TAG_OPTIONAL_2;
  tlv_data[3].type      = UIMI_TLV_TYPE_GW_SP_PERSO_CODE;
  tlv_data[3].tag       = UIMI_TLV_TAG_OPTIONAL_3;
  tlv_data[4].type      = UIMI_TLV_TYPE_GW_CP_PERSO_CODE;
  tlv_data[4].tag       = UIMI_TLV_TAG_OPTIONAL_4;
  tlv_data[5].type      = UIMI_TLV_TYPE_GW_SIM_PERSO_CODE;
  tlv_data[5].tag       = UIMI_TLV_TAG_OPTIONAL_5;
  tlv_data[6].type      = UIMI_TLV_TYPE_1X_NW_TYPE1_PERSO_CODE;
  tlv_data[6].tag       = UIMI_TLV_TAG_OPTIONAL_6;
  tlv_data[7].type      = UIMI_TLV_TYPE_1X_NW_TYPE2_PERSO_CODE;
  tlv_data[7].tag       = UIMI_TLV_TAG_OPTIONAL_7;
  tlv_data[8].type      = UIMI_TLV_TYPE_1X_RUIM_PERSO_CODE;
  tlv_data[8].tag       = UIMI_TLV_TAG_OPTIONAL_8;
  tlv_data[9].type      = UIMI_TLV_TYPE_SLOT;
  tlv_data[9].tag       = UIMI_TLV_TAG_OPTIONAL_9;
  tlv_data[10].type     = UIMI_TLV_TYPE_PERSO_ITERATION_CNT;
  tlv_data[10].tag      = UIMI_TLV_TAG_OPTIONAL_10;
  tlv_data[11].type     = UIMI_TLV_TYPE_PERSO_UNLOCK_RETRIES_CNT;
  tlv_data[11].tag      = UIMI_TLV_TAG_OPTIONAL_11;
  tlv_data[12].type     = UIMI_TLV_TYPE_PERSO_REACTIVATE_FEATURE;
  tlv_data[12].tag      = UIMI_TLV_TAG_OPTIONAL_12;
  tlv_data[13].type     = UIMI_TLV_TYPE_GW_SPN_PERSO_CODE;
  tlv_data[13].tag      = UIMI_TLV_TAG_OPTIONAL_16;
  tlv_data[14].type     = UIMI_TLV_TYPE_GW_ICCID_PERSO_CODE;
  tlv_data[14].tag      = UIMI_TLV_TAG_OPTIONAL_20;

  /* Parse TLVs */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 15);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* Create userdata */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_PERSONALIZATION,
                                            cmd_buf_p,
                                            NULL,
                                            ((qmi_uimi_client_state_type *)cl_sp)->common.clid);
  if (cb_userdata_ptr == NULL)
  {
    errval = QMI_ERR_NO_MEMORY;
    goto send_result;
  }

  /* Extract slot if present */
  if(tlv_data[9].present)
  {
    if(qmi_uim_mmgsdi_slot_id_to_simlock_slot_id(tlv_data[9].data.slot.slot,
                                                 &simlock_slot) != QMI_ERR_NONE)
    {
      errval = QMI_ERR_INTERNAL;
      goto send_result;
    }
  }

  /* Check what all optional perso data TLVs were received */
  for(loop_cnt = 0; loop_cnt < sizeof(table_indexes); loop_cnt++)
  {
    index = table_indexes[loop_cnt];
    if(!tlv_data[index].present)
    {
      continue;
    }

    if(code_index != 0)
    {
      errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
      goto send_result;
    }

    code_index = index;
  }

#ifdef FEATURE_QMI_UIM_PERSONALIZATION
  /* If personalization is allowed, we can either:
     Activate SIMLock - by receiving only 1 Lock code TLV per request, or
     Re-activate SIMLock - by receiving a reactivate TLV & no Lock code TLVs */
  if ((code_index != 0 && tlv_data[12].present) ||
      (code_index == 0 && !tlv_data[12].present))
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
    goto send_result;
  }
#else
  /* If personalization is not allowed, we can only do a Relock functionality
     by receiving a reactivate TLV & no Lock code TLVs */
  if (code_index != 0 || !tlv_data[12].present)
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
    goto send_result;
  }
#endif /* FEATURE_QMI_UIM_PERSONALIZATION */

  /* Unless the perso feature is defined, this request is unsupported */
  errval = QMI_ERR_NOT_SUPPORTED;

  if (tlv_data[12].present)
  {
    simlock_relock_device_msg_req_type   relock_msg;

    memset(&relock_msg, 0x00, sizeof(simlock_relock_device_msg_req_type));

    relock_msg.ck            = tlv_data[0].data.personalization_ck.ck;
    relock_msg.slot          = simlock_slot;
    relock_msg.category_type = tlv_data[12].data.personalization_reactivate.category;

    /* Send the relock API call */
    simlock_status = simlock_relock(relock_msg,
                                    qmi_uimi_simlock_callback,
                                    cb_userdata_ptr);

    /* Convert MMGSDI status into QMI err code */
    errval = qmi_uim_convert_simlock_status_to_errval(simlock_status);
  }
#ifdef FEATURE_QMI_UIM_PERSONALIZATION
  else
  {
    simlock_set_lock_ck_msg_req_type     lock_ck_msg;

    memset(&lock_ck_msg, 0x00, sizeof(simlock_set_lock_ck_msg_req_type));

    lock_ck_msg.ck          = tlv_data[0].data.personalization_ck.ck;
    (void)memscpy(&lock_ck_msg.category,
                  sizeof(simlock_category_data_type),
                  tlv_data[code_index].data.personalization_code.code_ptr,
                  sizeof(simlock_category_data_type));
    lock_ck_msg.auto_lock   = FALSE;
    lock_ck_msg.blacklist   = FALSE;
    lock_ck_msg.slot        = simlock_slot;

    /* If the TLV is missing, the SIMLock engine sets a default
       value to the iteration count */
    if(tlv_data[10].present)
    {
      lock_ck_msg.iteration_cnt = tlv_data[10].data.personalization_iteration_cnt.value;
    }

    /* If the TLV is missing, unlimited number of unlock retry
       attempts are allowed */
    if(tlv_data[11].present)
    {
      lock_ck_msg.num_retries_max  = tlv_data[11].data.personalization_retries_cnt.value;
    }

    /* Set request id to dummy value as it will not be used for regular personalization */
    cb_userdata_ptr->data.simlock_lock.ck_present           = TRUE;

    /* Set request id to dummy value as it will not be used for regular personalization */
    cb_userdata_ptr->data.simlock_lock.request_id = 0;
    cb_userdata_ptr->data.simlock_lock.total_list_cnt       = tlv_data[code_index].data.personalization_code.num_of_lists;
    cb_userdata_ptr->data.simlock_lock.slot                 = lock_ck_msg.slot;
    cb_userdata_ptr->data.simlock_lock.ck                   = tlv_data[0].data.personalization_ck.ck;

    /* The lock codes contained in zeroth list are locked here. So
       mark the next list to lock as 1 */
    cb_userdata_ptr->data.simlock_lock.next_list_to_lock    = 1;

    /* Save the lock code data pointer */
    cb_userdata_ptr->data.simlock_lock.code_ptr             = tlv_data[code_index].data.personalization_code.code_ptr;

    /* set the original pointer to NULL */
    tlv_data[code_index].data.personalization_code.code_ptr = NULL;

    /* lock the SIM */
    simlock_status = simlock_ck_lock(lock_ck_msg,
                                     qmi_uimi_simlock_callback,
                                     cb_userdata_ptr);

    /* Convert MMGSDI status into QMI err code */
    errval = qmi_uim_convert_simlock_status_to_errval(simlock_status);
  }
#endif /* FEATURE_QMI_UIM_PERSONALIZATION */

send_result:
  /* Free the buffer used for data: this also clears the CK
     information for security reason */
  qmi_uim_free_tlv_content(tlv_data, 15);

  /* Free userdata in case of error */
  QMI_UIM_SIMLOCK_FREE_USERDATA_IF_ERROR(simlock_status, cb_userdata_ptr);

  return qmi_uimi_populate_response(errval, FALSE, 0, 0);
} /* qmi_uimi_personalization() */


/*===========================================================================
  FUNCTION QMI_UIMI_SUPPLY_VOLTAGE()

  DESCRIPTION
    Marks that the client has acknowledged the supply voltage indication
    and once all clients have responded, notifies uimdrv to proceed with
    Vcc deactivation.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_supply_voltage
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type                            errval             = QMI_ERR_NONE;
  qmi_uim_tlv_item_type                       tlv_data[1];
  uim_slot_type                               uim_slot           = UIM_SLOT_NONE;
  uint8                                       slot_idx           = 0;
  dsm_item_type *                             response           = NULL;
  qmi_result_e_type                           result             = QMI_RESULT_SUCCESS;
  boolean                                     retval             = FALSE;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(tlv_data, 0, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_SLOT;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 1);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  errval = qmi_uim_mmgsdi_slot_id_to_uim_slot_id(tlv_data[0].data.slot.slot,
                                                 &uim_slot);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  errval = qmi_uim_mmgsdi_slot_to_slot_index(tlv_data[0].data.slot.slot,
                                             &slot_idx);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  if (!((qmi_uimi_client_state_type*)cl_sp)->uim_info.supply_voltage_pending_ack[slot_idx])
  {
    UIM_MSG_ERR_0("Client is not pending any supply voltage acknowledgement");
    errval = QMI_ERR_DEVICE_NOT_READY;
    goto send_result;
  }

  ((qmi_uimi_client_state_type*)cl_sp)->uim_info.supply_voltage_pending_ack[slot_idx] = FALSE;

  /* Only send acknowledgement to UIM drivers once all registered clients have responded
     with their acknowledgements */
  errval = qmi_uim_all_reg_clients_ack_vcc_deactivation(tlv_data[0].data.slot.slot);

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(tlv_data, 1);

  /* Send the response */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  CHECK_RETVAL();

  return response;
} /* qmi_uimi_supply_voltage */


/*===========================================================================
  FUNCTION QMI_UIMI_DEPERSONALIZATION_SECURE()

  DESCRIPTION
    Deactivates personalization of the device to a particular lock feature
    without passing in a CK. The input TLV is encrypted and must be decrypted
    before processing to insure a safe connection with client.
    Only deactivation of an activated feature is allowed.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_depersonalization_secure
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type                       errval             = QMI_ERR_NONE;
  qmi_uimi_userdata_type  *              cb_userdata_ptr    = NULL;
  simlock_result_enum_type               simlock_status     = SIMLOCK_SUCCESS;
  uint16                                 request_id         = 0;
  simlock_unlock_device_msg_req_type     unlock_msg;
  simlock_temporary_unlock_msg_req_type  temp_unlock_msg;
  qmi_uim_tlv_item_type                  tlv_data;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(&tlv_data, 0, sizeof(tlv_data));
  tlv_data.type      = UIMI_TLV_TYPE_DECRYPTED_DEPERSO_SECURE;
  tlv_data.tag       = UIMI_TLV_TAG_MANDATORY_1;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, &tlv_data, 1);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* This is required to make sure that TLV was originated for this specific request. */
  if(tlv_data.data.decrypted_deperso_secure.header.cmd_id != UIMI_CMD_VAL_DEPERSONALIZATION_SECURE)
  {
    UIM_MSG_ERR_0("QMI-UIM: decrypt request failed");
    errval = QMI_ERR_MALFORMED_MSG;
    goto send_result;
  }

  /* Retrieve the request_id from the request */
  request_id = tlv_data.data.decrypted_deperso_secure.header.request_id;

  /* Create userdata */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_DEPERSONALIZATION_SECURE,
                                            cmd_buf_p,
                                            NULL,
                                            ((qmi_uimi_client_state_type *)cl_sp)->common.clid);
  if (cb_userdata_ptr == NULL)
  {
    errval = QMI_ERR_NO_MEMORY;
    goto send_result;
  }

  cb_userdata_ptr->data.simlock_unlock.ck_present    = FALSE;
  cb_userdata_ptr->data.simlock_unlock.request_id    = request_id;
  cb_userdata_ptr->data.simlock_unlock.category      = tlv_data.data.decrypted_deperso_secure.category_type;
  cb_userdata_ptr->data.simlock_unlock.slot          = tlv_data.data.decrypted_deperso_secure.slot;

  switch (tlv_data.data.decrypted_deperso_secure.operation)
  {
    case QMI_UIM_DEPERSO_UNLOCK_WITHOUT_CK:
      memset(&unlock_msg, 0x00, sizeof(unlock_msg));
      memset(unlock_msg.ck.simlock_ck_data, 0x00, sizeof(unlock_msg.ck.simlock_ck_data));
      unlock_msg.ck.simlock_ck_length = 0;

      unlock_msg.category = tlv_data.data.decrypted_deperso_secure.category_type;
      unlock_msg.slot = tlv_data.data.decrypted_deperso_secure.slot;

      simlock_status = simlock_unlock_trusted(unlock_msg,
                                              qmi_uimi_simlock_callback,
                                              cb_userdata_ptr);
      break;

    case QMI_UIM_DEPERSO_TEMP_UNLOCK_ENABLE:
    case QMI_UIM_DEPERSO_TEMP_UNLOCK_DISABLE:
      memset(&temp_unlock_msg, 0x00, sizeof(temp_unlock_msg));

      if (tlv_data.data.decrypted_deperso_secure.operation == QMI_UIM_DEPERSO_TEMP_UNLOCK_ENABLE)
      {
        temp_unlock_msg.temporary_unlock_type = SIMLOCK_TEMPORARY_UNLOCK_SET;
      }
      else
      {
        temp_unlock_msg.temporary_unlock_type = SIMLOCK_TEMPORARY_UNLOCK_UNSET;
      }

      temp_unlock_msg.category = tlv_data.data.decrypted_deperso_secure.category_type;
      temp_unlock_msg.slot = tlv_data.data.decrypted_deperso_secure.slot;
      temp_unlock_msg.duration = tlv_data.data.decrypted_deperso_secure.duration;

      simlock_status = simlock_temporary_unlock(&temp_unlock_msg,
                                                qmi_uimi_simlock_callback,
                                                cb_userdata_ptr);
      break;

    default:
      UIM_MSG_ERR_1("Invalid deperso secure operation: 0x%x",
                    tlv_data.data.decrypted_deperso_secure.operation);
      simlock_status = SIMLOCK_INCORRECT_PARAMS;
      break;
  }

  /* Free userdata in case of error */
  QMI_UIM_SIMLOCK_FREE_USERDATA_IF_ERROR(simlock_status, cb_userdata_ptr);

  /* Convert MMGSDI status into QMI err code */
  errval = qmi_uim_convert_simlock_status_to_errval(simlock_status);

send_result:
  /* Free the buffer used for data: this also clears the CK
     information for security reason */
  qmi_uim_free_tlv_content(&tlv_data, 1);

  if (errval == QMI_ERR_NONE)
  {
    return QMI_SVC_RESPONSE_PENDING;
  }

  return qmi_uimi_populate_encrypted_response(errval,
                                              UIMI_CMD_VAL_DEPERSONALIZATION_SECURE,
                                              request_id);
} /* qmi_uimi_depersonalization_secure() */


/*===========================================================================
  FUNCTION QMI_UIMI_PERSONALIZATION_SECURE()

  DESCRIPTION
    Activates the personalization of the device to a particular lock feature
    without passing in a CK. The input TLV is encrypted and must be decrypted
    before processing to insure a safe connection with client.

    Only one feature can be activated at a time.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_personalization_secure
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type                      errval                     = QMI_ERR_NONE;
  qmi_uimi_userdata_type  *             cb_userdata_ptr            = NULL;
  simlock_result_enum_type              simlock_status             = SIMLOCK_SUCCESS;
  uint16                                request_id                 = 0;
  simlock_set_lock_ck_msg_req_type      lock_msg;
  qmi_uim_tlv_item_type                 tlv_data;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(&tlv_data, 0, sizeof(tlv_data));
  tlv_data.type      = UIMI_TLV_TYPE_DECRYPTED_PERSO_SECURE;
  tlv_data.tag       = UIMI_TLV_TAG_MANDATORY_1;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, &tlv_data, 1);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* This is required to make sure that TLV was originated for this specific request */
  if(tlv_data.data.decrypted_perso_secure.header.cmd_id != UIMI_CMD_VAL_PERSONALIZATION_SECURE)
  {
    UIM_MSG_ERR_1("Invalid command id: 0x%x", tlv_data.data.decrypted_perso_secure.header.cmd_id);
    errval = QMI_ERR_MALFORMED_MSG;
    goto send_result;
  }

  /* Retrieve the request_id from the request */
  request_id = tlv_data.data.decrypted_perso_secure.header.request_id;

  if (tlv_data.data.decrypted_perso_secure.code_ptr == NULL)
  {
    UIM_MSG_ERR_0("Invalid category data");
    errval = QMI_ERR_INTERNAL;
    goto send_result;
  }

  memset(&lock_msg, 0x00, sizeof(simlock_set_lock_ck_msg_req_type));

  /* Set default lock values */
  lock_msg.auto_lock        = FALSE;
  lock_msg.blacklist        = FALSE;

  /* Set iteration count and number of max retries to 0 since there is
     no chance of unlock failure as there is no CK */
  lock_msg.iteration_cnt    = 0;
  lock_msg.num_retries_max  = 0;
  lock_msg.slot = tlv_data.data.decrypted_perso_secure.slot;
  lock_msg.category = *tlv_data.data.decrypted_perso_secure.code_ptr;

  memset(lock_msg.ck.simlock_ck_data, 0x00, sizeof(lock_msg.ck.simlock_ck_data));
  lock_msg.ck.simlock_ck_length = 0;

  /* Create userdata */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_PERSONALIZATION_SECURE,
                                            cmd_buf_p,
                                            NULL,
                                            ((qmi_uimi_client_state_type *)cl_sp)->common.clid);
  if (cb_userdata_ptr == NULL)
  {
    errval = QMI_ERR_NO_MEMORY;
    goto send_result;
  }

  /* save information in the user data */
  cb_userdata_ptr->data.simlock_lock.request_id = request_id;
  cb_userdata_ptr->data.simlock_lock.ck_present = FALSE;
  cb_userdata_ptr->data.simlock_lock.total_list_cnt       = tlv_data.data.decrypted_perso_secure.num_of_lists;
  cb_userdata_ptr->data.simlock_lock.slot                 = tlv_data.data.decrypted_perso_secure.slot;

  memset(cb_userdata_ptr->data.simlock_lock.ck.simlock_ck_data, 0x00, SIMLOCK_CK_MAX);
  cb_userdata_ptr->data.simlock_lock.ck.simlock_ck_length = 0;

  /* The lock codes contained in zeroth list are locked here. So
     mark the next list to lock as 1 */
  cb_userdata_ptr->data.simlock_lock.next_list_to_lock    = 1;

  /* Save the lock code data pointer */
  cb_userdata_ptr->data.simlock_lock.code_ptr             = tlv_data.data.decrypted_perso_secure.code_ptr;

  /* set the original pointer to NULL */
  tlv_data.data.decrypted_perso_secure.code_ptr           = NULL;

  simlock_status = simlock_ck_lock(lock_msg,
                                   qmi_uimi_simlock_callback,
                                   cb_userdata_ptr);

  /* Free userdata in case of error */
  QMI_UIM_SIMLOCK_FREE_USERDATA_IF_ERROR(simlock_status, cb_userdata_ptr);

  /* Convert MMGSDI status into QMI err code */
  errval = qmi_uim_convert_simlock_status_to_errval(simlock_status);

send_result:
  /* Free the buffer used for data: this also clears the CK
     information for security reason */
  qmi_uim_free_tlv_content(&tlv_data, 1);

  if (errval == QMI_ERR_NONE)
  {
    return QMI_SVC_RESPONSE_PENDING;
  }

  return qmi_uimi_populate_encrypted_response(errval,
                                              UIMI_CMD_VAL_PERSONALIZATION_SECURE,
                                              request_id);
} /* qmi_uimi_personalization_secure */


/*===========================================================================
  FUNCTION QMI_UIMI_EMERGENCY_ONLY()

  DESCRIPTION
    Sets the device in a emergency only or normal operation mode. The input
    TLV is encrypted and must be decrypted before processing to insure a safe
    connection with client.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_emergency_only
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type                       errval             = QMI_ERR_NONE;
  qmi_uimi_userdata_type  *              cb_userdata_ptr    = NULL;
  simlock_result_enum_type               simlock_status     = SIMLOCK_SUCCESS;
  uint16                                 request_id         = 0;
  simlock_set_device_mode_msg_req_type   device_mode_msg;
  qmi_uim_tlv_item_type                  tlv_data;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(&tlv_data, 0, sizeof(tlv_data));
  tlv_data.type      = UIMI_TLV_TYPE_DECRYPTED_EMERGENCY_ONLY;
  tlv_data.tag       = UIMI_TLV_TAG_MANDATORY_1;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, &tlv_data, 1);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* This is required to make sure that TLV was originated for this specific request. */
  if(tlv_data.data.decrypted_emergency_only.header.cmd_id != UIMI_CMD_VAL_EMERGENCY_ONLY)
  {
    UIM_MSG_ERR_0("QMI-UIM: decrypt request failed");
    errval = QMI_ERR_MALFORMED_MSG;
    goto send_result;
  }

  memset(&device_mode_msg, 0x00, sizeof(simlock_set_device_mode_msg_req_type));

  /* Retrieve the mode and request_id from the request */
  device_mode_msg.mode = tlv_data.data.decrypted_emergency_only.device_mode;
  request_id           = tlv_data.data.decrypted_emergency_only.header.request_id;

  /* Create userdata */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_EMERGENCY_ONLY,
                                            cmd_buf_p,
                                            NULL,
                                            ((qmi_uimi_client_state_type *)cl_sp)->common.clid);
  if (cb_userdata_ptr == NULL)
  {
    errval = QMI_ERR_NO_MEMORY;
    goto send_result;
  }

  /* save information in the user data */
  cb_userdata_ptr->data.simlock_set_device_mode.request_id = request_id;

  simlock_status = simlock_set_device_operation_mode(device_mode_msg,
                                                     qmi_uimi_simlock_callback,
                                                     cb_userdata_ptr);

  /* Free userdata in case of error */
  QMI_UIM_SIMLOCK_FREE_USERDATA_IF_ERROR(simlock_status, cb_userdata_ptr);

  /* Convert MMGSDI status into QMI err code */
  errval = qmi_uim_convert_simlock_status_to_errval(simlock_status);

send_result:
  /* Free the buffer used for data: this also clears the CK
     information for security reason */
  qmi_uim_free_tlv_content(&tlv_data, 1);

  if (errval == QMI_ERR_NONE)
  {
    return QMI_SVC_RESPONSE_PENDING;
  }

  return qmi_uimi_populate_encrypted_response(errval,
                                              UIMI_CMD_VAL_EMERGENCY_ONLY,
                                              request_id);
} /* qmi_uimi_emergency_only */


/*===========================================================================
  FUNCTION QMI_UIMI_SIMLOCK_CONFIGURATION()

  DESCRIPTION
    Response to a simlock operation request sent via the indication to the
    client. The input TLV is encrypted and must be decrypted before
    processing to insure a safe connection with client.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_simlock_configuration
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type                       errval             = QMI_ERR_NONE;
  qmi_uimi_userdata_type  *              cb_userdata_ptr    = NULL;
  simlock_result_enum_type               simlock_status     = SIMLOCK_SUCCESS;
  qmi_uim_simlock_config_operation_type  operation_type     = QMI_UIM_SIMLOCK_CONFIG_OPERATION_READ;
  uint16                                 request_id         = 0;
  qmi_uim_tlv_item_type                  tlv_data;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(&tlv_data, 0, sizeof(tlv_data));
  tlv_data.type      = UIMI_TLV_TYPE_DECRYPTED_SIMLOCK_CONFIG;
  tlv_data.tag       = UIMI_TLV_TAG_MANDATORY_1;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, &tlv_data, 1);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* This is required to make sure that TLV was originated for this specific request */
  if(tlv_data.data.decrypted_simlock_config.header.cmd_id != UIMI_CMD_VAL_SIMLOCK_CONFIGURATION)
  {
    UIM_MSG_ERR_1("Invalid command id: 0x%x", tlv_data.data.decrypted_simlock_config.header.cmd_id);
    errval = QMI_ERR_MALFORMED_MSG;
    goto send_result;
  }

  /* Retrieve the operation and request_id from the request */
  operation_type = tlv_data.data.decrypted_simlock_config.operation;
  request_id     = tlv_data.data.decrypted_simlock_config.header.request_id;

  /* If the operation is enable or disable remote SFS, call the
     simlock API */
  if((operation_type == QMI_UIM_SIMLOCK_CONFIG_OPERATION_ENABLE_REMOTE_SFS) ||
     (operation_type == QMI_UIM_SIMLOCK_CONFIG_OPERATION_DISABLE_REMOTE_SFS))
  {
    /* Create userdata */
    cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_SIMLOCK_CONFIGURATION,
                                              cmd_buf_p,
                                              NULL,
                                              ((qmi_uimi_client_state_type *)cl_sp)->common.clid);
    if (cb_userdata_ptr == NULL)
    {
      errval = QMI_ERR_NO_MEMORY;
      goto send_result;
    }

    /* save information in the user data */
    cb_userdata_ptr->data.simlock_set_remote_sfs.request_id = request_id;

    simlock_status = simlock_set_remote_sfs(tlv_data.data.decrypted_simlock_config.operation_type.remote_sfs_operation,
                                            qmi_uimi_simlock_set_remote_sfs_callback,
                                            cb_userdata_ptr);

    /* Free userdata in case of error */
    QMI_UIM_SIMLOCK_FREE_USERDATA_IF_ERROR(simlock_status, cb_userdata_ptr);

    /* Convert MMGSDI status into QMI err code */
    errval = qmi_uim_convert_simlock_status_to_errval(simlock_status);
  }

  /* If the operation is read/write simlock data in remote SFS, call the
     simlock response cb */
  if(operation_type == QMI_UIM_SIMLOCK_CONFIG_OPERATION_READ)
  {
    if(qmi_uim_global_ptr->simlock_remote_sfs_operation_resp_cb != NULL)
    {
      qmi_uim_global_ptr->simlock_remote_sfs_operation_resp_cb(tlv_data.data.decrypted_simlock_config.operation_type.sfs_read_operation.result,
                                                               request_id,
                                                               &tlv_data.data.decrypted_simlock_config.operation_type.sfs_read_operation.data);
      qmi_uim_global_ptr->simlock_remote_sfs_operation_resp_cb = NULL;
    }
    else
    {
      /* A NULL callback indicates that the modem is not
         expecting this message. So return an error */
      errval = QMI_ERR_INVALID_OPERATION;
    }
  }
  else if(operation_type == QMI_UIM_SIMLOCK_CONFIG_OPERATION_WRITE)
  {
     if(qmi_uim_global_ptr->simlock_remote_sfs_operation_resp_cb != NULL)
    {
      qmi_uim_global_ptr->simlock_remote_sfs_operation_resp_cb(tlv_data.data.decrypted_simlock_config.operation_type.sfs_write_operation.result,
                                                               request_id,
                                                               NULL);
      qmi_uim_global_ptr->simlock_remote_sfs_operation_resp_cb = NULL;
    }
    else
    {
      /* A NULL callback indicates that the modem is not
         expecting this message. So return an error */
      errval = QMI_ERR_INVALID_OPERATION;
    }
  }

send_result:
  /* Free the buffer used for data: this also clears the read data
     information for security reason */
  qmi_uim_free_tlv_content(&tlv_data, 1);

  if ((errval == QMI_ERR_NONE) &&
      (operation_type == QMI_UIM_SIMLOCK_CONFIG_OPERATION_ENABLE_REMOTE_SFS ||
       operation_type == QMI_UIM_SIMLOCK_CONFIG_OPERATION_DISABLE_REMOTE_SFS))
  {
    return QMI_SVC_RESPONSE_PENDING;
  }

  return qmi_uimi_populate_encrypted_response(errval,
                                              UIMI_CMD_VAL_SIMLOCK_CONFIGURATION,
                                              request_id);
} /* qmi_uimi_simlock_configuration */


/*===========================================================================
  FUNCTION QMI_UIMI_GBA()

  DESCRIPTION
    Performs GBA authentication

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_gba
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type               errval              = QMI_ERR_NONE;
  qmi_uimi_userdata_type*        cb_userdata_ptr     = NULL;
  gba_result_enum_type           gba_result          = GBA_SUCCESS;
  boolean                        gba_force_bootstrap = FALSE;
  gba_session_type               gba_session_type    = GBA_SESSION_MAX;
  qmi_uimi_ind_token_info_type   token_info          = {FALSE, 0};
  qmi_uim_tlv_item_type          tlv_data[5];
  gba_aid_type                   app_id_data;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(tlv_data, 0, sizeof(tlv_data));
  memset(&app_id_data, 0, sizeof(gba_aid_type));

  tlv_data[0].type      = UIMI_TLV_TYPE_SESSION_INFORMATION;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;
  tlv_data[1].type      = UIMI_TLV_TYPE_NAF_ID;
  tlv_data[1].tag       = UIMI_TLV_TAG_MANDATORY_2;
  tlv_data[2].type      = UIMI_TLV_TYPE_FORCE_BOOTSTRAPPING;
  tlv_data[2].tag       = UIMI_TLV_TAG_OPTIONAL_1;
  tlv_data[3].type      = UIMI_TLV_TYPE_IND_TOKEN;
  tlv_data[3].tag       = UIMI_TLV_TAG_OPTIONAL_2;
  tlv_data[4].type      = UIMI_TLV_TYPE_ACCESS_POINT_NAME;
  tlv_data[4].tag       = UIMI_TLV_TAG_OPTIONAL_3;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 5);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  errval = qmi_uim_convert_mmgsdi_session_to_gba_session(
             tlv_data[0].data.session_information.session_type,
             &gba_session_type);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  if(tlv_data[0].data.session_information.aid.data_len > 0 &&
     tlv_data[0].data.session_information.aid.data_len <= sizeof(app_id_data.data))
  {
    app_id_data.data_len = tlv_data[0].data.session_information.aid.data_len;
    (void)memscpy(app_id_data.data,
                  sizeof(app_id_data.data),
                  tlv_data[0].data.session_information.aid.data_ptr,
                  tlv_data[0].data.session_information.aid.data_len);
  }

  if(tlv_data[2].present)
  {
    gba_force_bootstrap = tlv_data[2].data.gba_force_bootstrapping.value;
  }

  /* Update token info */
  token_info.is_valid = tlv_data[3].present;
  token_info.token = tlv_data[3].data.ind_token.value;

  /* Create userdata */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_GBA,
                                            token_info.is_valid ? NULL : cmd_buf_p,
                                            token_info.is_valid ? &token_info.token : NULL,
                                            ((qmi_uimi_client_state_type *)cl_sp)->common.clid);
  if (cb_userdata_ptr == NULL)
  {
    errval = QMI_ERR_NO_MEMORY;
    goto send_result;
  }

  /* Store FQDN to check against the list of white list / black list FQDNs to
     encrypt ks_naf */
  cb_userdata_ptr->data.gba.fqdn_data = tlv_data[1].data.gba_naf_id.naf_id_ptr->fqdn;

  gba_result = gba_bootstrap(tlv_data[1].data.gba_naf_id.naf_id_ptr,
                             gba_session_type,
                             &app_id_data,
                             gba_force_bootstrap,
                             NULL,
                             (tlv_data[4].present) ?
                               tlv_data[4].data.apn.apn_data_ptr: NULL,
                             qmi_uimi_gba_callback,
                             cb_userdata_ptr);

  errval = qmi_uim_convert_gba_status_to_errval(gba_result);

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(tlv_data, 5);

  return qmi_uimi_populate_response(errval,
                                    token_info.is_valid,
                                    token_info.token,
                                    UIMI_TLV_RESP_TAG_OPTIONAL_6);
} /* qmi_uimi_gba */


/*===========================================================================
  FUNCTION QMI_UIMI_GET_GBA_IMPI()

  DESCRIPTION
    Retrieves the IMPI used for GBA corresponding to the session

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_get_gba_impi
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type                errval           = QMI_ERR_NONE;
  dsm_item_type                 * response         = NULL;
  boolean                         retval           = TRUE;
  qmi_result_e_type               result           = QMI_RESULT_SUCCESS;
  qmi_uim_impi_type             * impi_data_ptr    = NULL;
  qmi_uim_tlv_item_type           tlv_data[2];

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(tlv_data, 0, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_SESSION_INFORMATION;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;
  tlv_data[1].type      = UIMI_TLV_TYPE_ENCRYPTED;
  tlv_data[1].tag       = UIMI_TLV_TAG_OPTIONAL_1;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 2);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  switch(tlv_data[0].data.session_information.session_type)
  {
    case MMGSDI_GW_PROV_PRI_SESSION:
    case MMGSDI_GW_PROV_SEC_SESSION:
      errval = qmi_uim_gba_get_impi_from_usim(&tlv_data[0].data.session_information,
                                              &impi_data_ptr);
      if(errval != QMI_ERR_NONE || impi_data_ptr == NULL)
      {
        goto send_result;
      }
      break;

    case MMGSDI_NON_PROV_SESSION_SLOT_1:
    case MMGSDI_NON_PROV_SESSION_SLOT_2:
      if(qmi_uim_is_isim_aid(&tlv_data[0].data.session_information.aid))
      {
        errval = qmi_uim_gba_get_impi_from_isim(tlv_data,
                                                2,
                                                cmd_buf_p,
                                                cl_sp);
        if(errval != QMI_ERR_NONE)
        {
          goto send_result;
        }
      }
      else
      {
        errval = QMI_ERR_INTERNAL;
        goto send_result;
      }

      /* Free the buffer used for data and wait for asynchronous response for
         IMPI read, so returning */
      qmi_uim_free_tlv_content(tlv_data, 2);
      return QMI_SVC_RESPONSE_PENDING;

    default:
      UIM_MSG_ERR_1("QMI_UIM_GET_GBA_IMPI is not supported, session: 0x%x",
                     tlv_data[0].data.session_information.session_type);
      errval = QMI_ERR_NOT_SUPPORTED;
      goto send_result;
  }

  if (impi_data_ptr == NULL)
  {
    errval = QMI_ERR_INTERNAL;
    goto send_result;
  }

  /* Check whether IMPI data should be encrypted */
  if(tlv_data[1].data.encrypted.value)
  {
    mmgsdi_data_type    impi_enc_data        = {0, NULL};
    mmgsdi_data_type    impi_data            = {0, NULL};

    impi_data.data_ptr = impi_data_ptr->data;
    impi_data.data_len = impi_data_ptr->data_len;

    if(qmi_uim_encrypt_payload(impi_data, &impi_enc_data))
    {
      if(FALSE == qmi_uim_response_generic_payload_16bit(
                   UIMI_TLV_RESP_TAG_OPTIONAL_2,
                   &response,
                   impi_enc_data,
                   TRUE))
      {
        dsm_free_packet(&response);
        errval = QMI_ERR_NO_MEMORY;
      }
    }
    else
    {
      errval = QMI_ERR_INTERNAL;
    }
  }
  else
  {
    mmgsdi_data_type impi_data = {0, NULL};

    impi_data.data_ptr = (uint8 *)impi_data_ptr->data;
    impi_data.data_len = impi_data_ptr->data_len;

    if(FALSE == qmi_uim_response_generic_payload_8bit(
                   UIMI_TLV_RESP_TAG_OPTIONAL_1,
                   &response,
                   impi_data,
                   TRUE))
    {
      errval = QMI_ERR_NO_MEMORY;
      dsm_free_packet(&response);
    }
  }

  /* Free IMPI data pointer */
  uimqmi_free(impi_data_ptr);
  impi_data_ptr = NULL;

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(tlv_data, 2);

  /* Send the response */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  CHECK_RETVAL();

  return response;
} /* qmi_uimi_get_gba_impi */


/*===========================================================================
  FUNCTION QMI_UIMI_REMOTE_UNLOCK()

  DESCRIPTION
    Provides the key in the encrypted format or applies the simlock 
    configuration data provided as the input.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type *  qmi_uimi_remote_unlock
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type                errval           = QMI_ERR_NONE;
  simlock_result_enum_type        simlock_status   = SIMLOCK_SUCCESS;
  qmi_uimi_userdata_type      *   cb_userdata_ptr  = NULL;
  qmi_uim_tlv_item_type           tlv_data;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(&tlv_data, 0, sizeof(tlv_data));
  tlv_data.type      = UIMI_TLV_TYPE_REMOTE_UNLOCK_CONFIG;
  tlv_data.tag       = UIMI_TLV_TAG_OPTIONAL_1;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, &tlv_data, 1);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* Create userdata */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_REMOTE_UNLOCK,
                                            cmd_buf_p,
                                            NULL,
                                            ((qmi_uimi_client_state_type *)cl_sp)->common.clid);
  if (cb_userdata_ptr == NULL)
  {
    errval = QMI_ERR_NO_MEMORY;
    goto send_result;
  }

  if(tlv_data.present)
  {
    if((tlv_data.data.remote_unlock_config.config_data.data_len > 0) &&
       (tlv_data.data.remote_unlock_config.config_data.data_ptr != NULL))
    {
      simlock_status = simlock_rsu_set_configuration(tlv_data.data.remote_unlock_config.config_data,
                                                     qmi_uimi_remote_unlock_callback,
                                                     cb_userdata_ptr);
    }
    else
    {
      simlock_status = SIMLOCK_INCORRECT_PARAMS;
    }
  }
  else
  {
    simlock_status = simlock_rsu_get_encrypted_key(qmi_uimi_remote_unlock_callback,
                                                   cb_userdata_ptr);
  }

  /* Convert simlock status into QMI err code */
  errval = qmi_uim_convert_simlock_status_to_errval(simlock_status);

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(&tlv_data, 1);

  return qmi_uimi_populate_response(errval, FALSE, 0, 0);
} /* qmi_uimi_remote_unlock */


/*===========================================================================
  FUNCTION QMI_UIMI_VERIFY_IMSI()

  DESCRIPTION
    Verifies that subscription related to IMSI is validated by SIMLOCK or not.
    If optional IMSI TLV is not present, it verifies the IMSI of all active
    provisioning sessions and returns an error if any of them is not verified.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type *  qmi_uimi_verify_imsi
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type                errval                 = QMI_ERR_NONE;
  dsm_item_type                 * response               = NULL;
  qmi_result_e_type               result                 = QMI_RESULT_SUCCESS;
  boolean                         retval                 = TRUE;
  simlock_result_enum_type        simlock_status         = SIMLOCK_SUCCESS;
  uint8                           loop_index             = 0;
  uint8                           index                  = 0;
  qmi_uim_imsi_type               imsi_data              = {0, };
  simlock_imsi_type               simlock_imsi           = {0, };
  qmi_uim_tlv_item_type           tlv_data;
  uint16                          *session_index_array[] = {qmi_uim_global_ptr->card_state.index_gw,
                                                            qmi_uim_global_ptr->card_state.index_1x};
  mmgsdi_session_id_type          *session_id_array[]    = {qmi_uim_global_ptr->mmgsdi_gw_session_id,
                                                            qmi_uim_global_ptr->mmgsdi_1x_session_id};

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(&tlv_data, 0, sizeof(tlv_data));
  tlv_data.type      = UIMI_TLV_TYPE_IMSI;
  tlv_data.tag       = UIMI_TLV_TAG_OPTIONAL_1;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, &tlv_data, 1);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  if(tlv_data.present)
  {
    if(tlv_data.data.imsi.imsi_data.imsi_len > 0)
    {
      simlock_status = simlock_verify_imsi(tlv_data.data.imsi.imsi_data);
    }
    else
    {
      simlock_status = SIMLOCK_INCORRECT_PARAMS;
    }
  }
  else
  {
    /* Read IMSI for all active subscriptions synchronously and verify IMSI
       is validated by SIMLOCK module or not */
    for(loop_index = 0;
        loop_index < sizeof(session_index_array) / sizeof(session_index_array[0]);
        loop_index++)
    {
      for (index = 0; index < QMI_UIM_MAX_PROV_SESSIONS; index++)
      {
        if (session_index_array[loop_index][index] != 0xFFFF)
        {
          errval = qmi_uim_read_imsi_for_session_id(session_id_array[loop_index][index],
                                                    &imsi_data);
          /* It is possible that IMSI data is not cached yet for subscription
             i.e. it gets stuck because of enabled PIN1. This also means that
             SIMLOCK algo is not run for that subscription. For such scenario we
             should not assume that IMSI is not valid; just continue to verify
             IMSI of next active subscription */
          if(errval != QMI_ERR_NONE)
          {
            continue;
          }

          simlock_imsi.imsi_len = imsi_data.len;
          (void)memscpy(simlock_imsi.imsi, sizeof(simlock_imsi.imsi), imsi_data.imsi, imsi_data.len);

          simlock_status = simlock_verify_imsi(simlock_imsi);
          if(simlock_status != SIMLOCK_SUCCESS)
          {
            UIM_MSG_ERR_2("Invalid IMSI for session at index 0x%x, 0x%x",
                          loop_index, index);
            break;
          }
        }
      }

      /*If any of the IMSI is not valid, break the loop */
      if(simlock_status != SIMLOCK_SUCCESS)
      {
        break;
      }
    }
  }

  /* If SIMLOCK module returns generic error, map it to INVALID ID */
  if(simlock_status == SIMLOCK_GENERIC_ERROR)
  {
    errval = QMI_ERR_INVALID_ID;
  }
  else
  {
    errval = qmi_uim_convert_simlock_status_to_errval(simlock_status);
  }

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(&tlv_data, 1);

  /* Send the response */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  CHECK_RETVAL();

  return response;
} /* qmi_uimi_verify_imsi */


/*===========================================================================
  FUNCTION QMI_UIMI_SEARCH_RECORD()

  DESCRIPTION
    Search a pattern in records of a cyclic or linear fixed file on the card

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_search_record
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type               errval        = QMI_ERR_NONE;
  mmgsdi_session_id_type         session_id    = UIM_INVALID_SESSION_ID;
  qmi_uimi_ind_token_info_type   token_info    = {FALSE, 0};
  qmi_uim_tlv_item_type          tlv_data[5];

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(tlv_data, 0, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_SESSION_INFORMATION;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;
  tlv_data[1].type      = UIMI_TLV_TYPE_FILE_ID;
  tlv_data[1].tag       = UIMI_TLV_TAG_MANDATORY_2;
  tlv_data[2].type      = UIMI_TLV_TYPE_SEARCH_PATTERN;
  tlv_data[2].tag       = UIMI_TLV_TAG_MANDATORY_3;
  tlv_data[3].type      = UIMI_TLV_TYPE_SEARCH_DATA;
  tlv_data[3].tag       = UIMI_TLV_TAG_OPTIONAL_1;
  tlv_data[4].type      = UIMI_TLV_TYPE_IND_TOKEN;
  tlv_data[4].tag       = UIMI_TLV_TAG_OPTIONAL_2;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 5);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* Check if request needs to be rejected due to security restrictions */
  if (qmi_uim_is_request_rejected(tlv_data[0].data.session_information.session_type,
                                  tlv_data[0].data.session_information.aid,
                                  cl_sp))
  {
    errval = QMI_ERR_ACCESS_DENIED;
    goto send_result;
  }
  
  /* Update token info */
  memset(&token_info, 0, sizeof(qmi_uimi_ind_token_info_type));
  token_info.is_valid = tlv_data[4].present;
  token_info.token = tlv_data[4].data.ind_token.value;
  
  /* Retrieve session id */
  errval = qmi_uim_session_type_to_session_id(&session_id,
                                              tlv_data[0].data.session_information.session_type,
                                              tlv_data[0].data.session_information.aid);

  if (errval != QMI_ERR_NONE)
  {
    if(errval == QMI_ERR_DEVICE_NOT_READY)
    {
      goto send_result;
    }

    /* Try to open session */
    errval = qmi_uim_open_session(UIMI_CMD_VAL_SEARCH_RECORD,
                                  tlv_data, 5,
                                  token_info.is_valid ? NULL : cmd_buf_p,
                                  cl_sp);
  }
  else
  {
    /* Execute MMGSDI function */
    errval = qmi_uim_execute_search_record(
                            session_id,
                            tlv_data[1].data.file_id.file_access,
                            tlv_data[2].data.search_pattern.pattern,
                            (tlv_data[3].present) ?
                              tlv_data[3].data.search_data.first_record_num :
                              QMI_UIM_RECORD_1,
                            (tlv_data[3].present) ?
                              tlv_data[3].data.search_data.direction :
                              MMGSDI_SEARCH_FORWARD_FROM_REC_NUM,
                            token_info.is_valid ? &token_info.token : NULL,
                            token_info.is_valid ? NULL : cmd_buf_p,
                            ((qmi_uimi_client_state_type *)cl_sp)->common.clid);

    /* Associate the Client with the requested Session (if it is a
       non-prov. Session) */
    if(errval == QMI_ERR_NONE)
    {
      (void)qmi_uim_update_non_prov_session_cl_sp(tlv_data,
                                                  5,
                                                  cl_sp);
    }
  }

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(tlv_data, 5);

  return qmi_uimi_populate_response(errval,
                                    token_info.is_valid,
                                    token_info.token,
                                    UIMI_TLV_RESP_TAG_OPTIONAL_3);
}/* qmi_uimi_search_record */


/*===========================================================================
  FUNCTION QMI_UIMI_GET_EID()

  DESCRIPTION
    Get the eUICC ID for that Slot. The command will go to LPA in all cases
    even if card is not marked as eUICC and LPA needs to reject it.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_get_eid
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type               errval          = QMI_ERR_NONE;
  lpa_result_enum_type           lpa_status      = LPA_SUCCESS;
  qmi_uimi_userdata_type*        cb_userdata_ptr = NULL;
  qmi_uim_tlv_item_type          tlv_data[1];
  lpa_slot_id_enum_type          lpa_slot        = LPA_SLOT_1;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(tlv_data, 0, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_SLOT;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 1);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  errval = qmi_uim_convert_mmgsdi_slot_to_lpa_slot(tlv_data[0].data.slot.slot,
                                                   &lpa_slot);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* Create userdata */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_GET_EID,
                                            cmd_buf_p,
                                            NULL,
                                            ((qmi_uimi_client_state_type *)cl_sp)->common.clid);
  if (cb_userdata_ptr == NULL)
  {
    errval = QMI_ERR_NO_MEMORY;
    goto send_result;
  }

  cb_userdata_ptr->data.lpa.slot = tlv_data[0].data.slot.slot;

  /* Execute LPA function to get EID */
  lpa_status = lpa_get_eid(lpa_slot,
                           qmi_uimi_lpa_callback,
                           cb_userdata_ptr);

  /* Free userdata in case of error */
  QMI_UIM_LPA_FREE_USERDATA_IF_ERROR(lpa_status, cb_userdata_ptr);

  /* Convert LPA status to QMI err code */
  errval = qmi_uim_convert_lpa_status_to_errval(lpa_status);

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(tlv_data, 1);

  return qmi_uimi_populate_response(errval,
                                    FALSE,
                                    0,
                                    0);
}/* qmi_uimi_get_eid */


/*===========================================================================
  FUNCTION QMI_UIMI_DELETE_PROFILE()

  DESCRIPTION
    Delete the requested profile from card. The command will go to LPA in all
    cases even if card is not marked as eUICC and LPA needs to reject it.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_delete_profile
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type                 errval           = QMI_ERR_NONE;
  lpa_result_enum_type             lpa_status       = LPA_SUCCESS;
  qmi_uimi_userdata_type*          cb_userdata_ptr  = NULL;
  qmi_uim_tlv_item_type            tlv_data[2];
  lpa_slot_id_enum_type            lpa_slot         = LPA_SLOT_1;
  qmi_uim_euicc_profile_info_type *profile_info_ptr = NULL;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(tlv_data, 0, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_SLOT;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;
  tlv_data[1].type      = UIMI_TLV_TYPE_PROFILE_ID;
  tlv_data[1].tag       = UIMI_TLV_TAG_MANDATORY_2;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 2);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  profile_info_ptr = qmi_uim_get_iccid_from_euicc_profile_id(tlv_data[1].data.sim_profile.profile_id,
                                                             tlv_data[0].data.slot.slot);
  if (profile_info_ptr == NULL)
  {
    errval = QMI_ERR_INVALID_ARG;
    goto send_result;
  }

  errval = qmi_uim_convert_mmgsdi_slot_to_lpa_slot(tlv_data[0].data.slot.slot,
                                                   &lpa_slot);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* Create userdata */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_DELETE_PROFILE,
                                            cmd_buf_p,
                                            NULL,
                                            ((qmi_uimi_client_state_type *)cl_sp)->common.clid);
  if (cb_userdata_ptr == NULL)
  {
    errval = QMI_ERR_NO_MEMORY;
    goto send_result;
  }

  cb_userdata_ptr->data.lpa.slot = tlv_data[0].data.slot.slot;

  /* Execute LPA function to delete profile */
  lpa_status = lpa_delete_profile(lpa_slot,
                                  profile_info_ptr->profile_info.iccid,
                                  qmi_uimi_lpa_callback,
                                  cb_userdata_ptr);

  /* Free userdata in case of error */
  QMI_UIM_LPA_FREE_USERDATA_IF_ERROR(lpa_status, cb_userdata_ptr);

  /* Convert LPA status to QMI err code */
  errval = qmi_uim_convert_lpa_status_to_errval(lpa_status);

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(tlv_data, 2);

  return qmi_uimi_populate_response(errval,
                                    FALSE,
                                    0,
                                    0);
}/* qmi_uimi_delete_profile */


/*===========================================================================
  FUNCTION QMI_UIMI_EUICC_MEMORY_RESET()

  DESCRIPTION
    Reset the eUICC memory for that Slot. The command will go to LPA in all
    cases even if card is not marked as eUICC and LPA needs to reject it.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_euicc_memory_reset
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type               errval          = QMI_ERR_NONE;
  lpa_result_enum_type           lpa_status      = LPA_SUCCESS;
  qmi_uimi_userdata_type*        cb_userdata_ptr = NULL;
  qmi_uim_tlv_item_type          tlv_data[1];
  lpa_slot_id_enum_type          lpa_slot        = LPA_SLOT_1;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(tlv_data, 0, sizeof(tlv_data));
  tlv_data[0].type      = UIMI_TLV_TYPE_SLOT;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 1);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  errval = qmi_uim_convert_mmgsdi_slot_to_lpa_slot(tlv_data[0].data.slot.slot,
                                                   &lpa_slot);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* Create userdata */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_EUICC_MEMORY_RESET,
                                            cmd_buf_p,
                                            NULL,
                                            ((qmi_uimi_client_state_type *)cl_sp)->common.clid);
  if (cb_userdata_ptr == NULL)
  {
    errval = QMI_ERR_NO_MEMORY;
    goto send_result;
  }

  cb_userdata_ptr->data.lpa.slot = tlv_data[0].data.slot.slot;

  /* Execute LPA function to reset eUICC card */
  lpa_status = lpa_card_memory_reset(lpa_slot,
                                     qmi_uimi_lpa_callback,
                                     cb_userdata_ptr);

  /* Free userdata in case of error */
  QMI_UIM_LPA_FREE_USERDATA_IF_ERROR(lpa_status, cb_userdata_ptr);

  /* Convert MMGSDI status to QMI err code */
  errval = qmi_uim_convert_lpa_status_to_errval(lpa_status);

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(tlv_data, 1);

  return qmi_uimi_populate_response(errval,
                                    FALSE,
                                    0,
                                    0);
}/* qmi_uimi_euicc_memory_reset */


/*===========================================================================
  FUNCTION QMI_UIMI_UPDATE_PROFILE_NICKNAME()

  DESCRIPTION
    Updates the nickname of requested profile. The command will go to LPA in
    all cases even if card is not marked as eUICC and LPA needs to reject it.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_update_profile_nickname
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type                 errval           = QMI_ERR_NONE;
  lpa_result_enum_type             lpa_status       = LPA_SUCCESS;
  qmi_uimi_userdata_type*          cb_userdata_ptr  = NULL;
  qmi_uim_tlv_item_type            tlv_data[3];
  lpa_name_type                    nickname_data    = {0, {0}};
  lpa_slot_id_enum_type            lpa_slot         = LPA_SLOT_1;
  qmi_uim_euicc_profile_info_type *profile_info_ptr = NULL;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(tlv_data, 0, sizeof(tlv_data));

  tlv_data[0].type      = UIMI_TLV_TYPE_SLOT;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;
  tlv_data[1].type      = UIMI_TLV_TYPE_PROFILE_ID;
  tlv_data[1].tag       = UIMI_TLV_TAG_MANDATORY_2;
  tlv_data[2].type      = UIMI_TLV_TYPE_EUICC_PROFILE_NAME;
  tlv_data[2].tag       = UIMI_TLV_TAG_OPTIONAL_1;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 3);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  if (tlv_data[2].present)
  {
    nickname_data.name_len = tlv_data[2].data.euicc_name.euicc_name_data.name_len;
    memscpy(nickname_data.name, sizeof(nickname_data.name),
            tlv_data[2].data.euicc_name.euicc_name_data.name,
            tlv_data[2].data.euicc_name.euicc_name_data.name_len);
  }

  profile_info_ptr = qmi_uim_get_iccid_from_euicc_profile_id(tlv_data[1].data.sim_profile.profile_id,
                                                             tlv_data[0].data.slot.slot);
  if (profile_info_ptr == NULL)
  {
    errval = QMI_ERR_INVALID_ARG;
    goto send_result;
  }

  errval = qmi_uim_convert_mmgsdi_slot_to_lpa_slot(tlv_data[0].data.slot.slot,
                                                   &lpa_slot);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* Create userdata */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_UPDATE_NICKNAME,
                                            cmd_buf_p,
                                            NULL,
                                            ((qmi_uimi_client_state_type *)cl_sp)->common.clid);
  if (cb_userdata_ptr == NULL)
  {
    errval = QMI_ERR_NO_MEMORY;
    goto send_result;
  }

  cb_userdata_ptr->data.lpa.slot = tlv_data[0].data.slot.slot;

  /* Execute LPA function to update profile nickname */
  lpa_status = lpa_add_or_update_profile_nickname(lpa_slot,
                                                  profile_info_ptr->profile_info.iccid,
                                                  nickname_data,
                                                  qmi_uimi_lpa_callback,
                                                  cb_userdata_ptr);

  /* Free userdata in case of error */
  QMI_UIM_LPA_FREE_USERDATA_IF_ERROR(lpa_status, cb_userdata_ptr);

  /* Convert LPA status to QMI err code */
  errval = qmi_uim_convert_lpa_status_to_errval(lpa_status);

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(tlv_data, 3);

  return qmi_uimi_populate_response(errval,
                                    FALSE,
                                    0,
                                    0);
}/* qmi_uimi_update_profile_nickname */


/*===========================================================================
  FUNCTION QMI_UIMI_GET_PROFILE_INFO()

  DESCRIPTION
    Provide the complete info of the requested profile. The command
    will go to LPA in all cases even if card is not marked as eUICC
    and LPA needs to reject it.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_get_profile_info
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type                 errval           = QMI_ERR_NONE;
  qmi_uim_tlv_item_type            tlv_data[2];
  dsm_item_type *                  response         = NULL;
  boolean                          retval           = TRUE;
  qmi_result_e_type                result           = QMI_RESULT_SUCCESS;
  mmgsdi_data_type                 lpa_profile_data = {0, NULL};
  qmi_uim_euicc_profile_info_type *profile_info_ptr = NULL;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(tlv_data, 0, sizeof(tlv_data));

  tlv_data[0].type      = UIMI_TLV_TYPE_SLOT;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;
  tlv_data[1].type      = UIMI_TLV_TYPE_PROFILE_ID;
  tlv_data[1].tag       = UIMI_TLV_TAG_MANDATORY_2;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 2);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  profile_info_ptr = qmi_uim_get_iccid_from_euicc_profile_id( tlv_data[1].data.sim_profile.profile_id,
                                                              tlv_data[0].data.slot.slot);
  if (profile_info_ptr == NULL)
  {
    errval = QMI_ERR_INVALID_ARG;
    goto send_result;
  }

  /* Insert eUICC profile ICCID info in TLV */
  if (profile_info_ptr->profile_info.iccid.data_len > 0)
  {
    lpa_profile_data.data_len = profile_info_ptr->profile_info.iccid.data_len;
    lpa_profile_data.data_ptr = (uint8 *)profile_info_ptr->profile_info.iccid.data;

    if(FALSE == qmi_uim_response_generic_payload_8bit(
                   UIMI_TLV_RESP_TAG_OPTIONAL_1,
                   &response,
                   lpa_profile_data,
                   FALSE))
    {
      errval = QMI_ERR_NO_MEMORY;
      dsm_free_packet(&response);
      goto send_result;
    }
  }

  /* Insert eUICC profile state info in TLV */
  if (FALSE == qmi_uim_response_profile_state(UIMI_TLV_RESP_TAG_OPTIONAL_2,
                                              &response,
                                              profile_info_ptr->profile_info.state))
  {
    UIM_MSG_LOW_0("Error in constructing profile state tlv");
  }

  /* Insert eUICC profile nickname info in TLV */
  if (profile_info_ptr->profile_info.nickname.name_len > 0)
  {
    lpa_profile_data.data_len = profile_info_ptr->profile_info.nickname.name_len;
    lpa_profile_data.data_ptr = (uint8 *)profile_info_ptr->profile_info.nickname.name;

    if(FALSE == qmi_uim_response_generic_payload_8bit(
                   UIMI_TLV_RESP_TAG_OPTIONAL_3,
                   &response,
                   lpa_profile_data,
                   FALSE))
    {
      UIM_MSG_LOW_0("Error in constructing profile nickname tlv");
    }
  }

  /* Insert eUICC profile service provider name info in TLV */
  if (profile_info_ptr->profile_info.spn.name_len > 0)
  {
    lpa_profile_data.data_len = profile_info_ptr->profile_info.spn.name_len;
    lpa_profile_data.data_ptr = (uint8 *)profile_info_ptr->profile_info.spn.name;

    if(FALSE == qmi_uim_response_generic_payload_8bit(
                   UIMI_TLV_RESP_TAG_OPTIONAL_4,
                   &response,
                   lpa_profile_data,
                   FALSE))
    {
      UIM_MSG_LOW_0("Error in constructing profile spn name tlv");
    }
  }

  /* Insert eUICC profile name info in TLV */
  if (profile_info_ptr->profile_info.name.name_len > 0)
  {
    lpa_profile_data.data_len = profile_info_ptr->profile_info.name.name_len;
    lpa_profile_data.data_ptr = (uint8 *)profile_info_ptr->profile_info.name.name;

    if(FALSE == qmi_uim_response_generic_payload_8bit(
                   UIMI_TLV_RESP_TAG_OPTIONAL_5,
                   &response,
                   lpa_profile_data,
                   FALSE))
    {
      UIM_MSG_LOW_0("Error in constructing profile name tlv");
    }
  }

  /* Insert eUICC profile icon info in TLV */
  if (profile_info_ptr->profile_info.icon.data_len > 0)
  {
    /* Insert eUICC profile icon type info in TLV */
    if (qmi_uim_response_profile_icon_type(UIMI_TLV_RESP_TAG_OPTIONAL_6,
                                           &response,
                                           profile_info_ptr->profile_info.icon_type))
    {
      lpa_profile_data.data_len = profile_info_ptr->profile_info.icon.data_len;
      lpa_profile_data.data_ptr = profile_info_ptr->profile_info.icon.data_ptr;
      
      if(FALSE == qmi_uim_response_generic_payload_16bit(
                     UIMI_TLV_RESP_TAG_OPTIONAL_7,
                     &response,
                     lpa_profile_data,
                     FALSE))
      {
        UIM_MSG_LOW_0("Error in constructing Icon tlv");
      }
    }
  }

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(tlv_data, 2);

  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  CHECK_RETVAL();

  return response;
}/* qmi_uimi_get_profile_info */


/*===========================================================================
  FUNCTION QMI_UIMI_ADD_PROFILE()

  DESCRIPTION
    Add a new profile in card. The command will go to LPA in all cases
    even if card is not marked as eUICC and LPA needs to reject it.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_add_profile
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type               errval          = QMI_ERR_NONE;
  lpa_result_enum_type           lpa_status      = LPA_SUCCESS;
  qmi_uimi_userdata_type*        cb_userdata_ptr = NULL;
  qmi_uim_tlv_item_type          tlv_data[3];
  lpa_data_type                  activation_code;
  lpa_data_type                  confirmation_code;
  lpa_slot_id_enum_type          lpa_slot        = LPA_SLOT_1;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(tlv_data, 0x00, sizeof(tlv_data));
  memset(&activation_code, 0x00, sizeof(lpa_data_type));
  memset(&confirmation_code, 0x00, sizeof(lpa_data_type));

  tlv_data[0].type      = UIMI_TLV_TYPE_SLOT;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;
  tlv_data[1].type      = UIMI_TLV_TYPE_EUICC_DOWNLOAD_CODE;
  tlv_data[1].tag       = UIMI_TLV_TAG_MANDATORY_2;
  tlv_data[2].type      = UIMI_TLV_TYPE_EUICC_CONFIRMATION_CODE;
  tlv_data[2].tag       = UIMI_TLV_TAG_OPTIONAL_1;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 3);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  errval = qmi_uim_convert_mmgsdi_slot_to_lpa_slot(tlv_data[0].data.slot.slot,
                                                   &lpa_slot);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* Create userdata */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_ADD_PROFILE,
                                            cmd_buf_p,
                                            NULL,
                                            ((qmi_uimi_client_state_type *)cl_sp)->common.clid);
  if (cb_userdata_ptr == NULL)
  {
    errval = QMI_ERR_NO_MEMORY;
    goto send_result;
  }

  cb_userdata_ptr->data.lpa.slot = tlv_data[0].data.slot.slot;

  activation_code.data_len = tlv_data[1].data.euicc_download_code.code.data_len;
  activation_code.data_ptr = tlv_data[1].data.euicc_download_code.code.data_ptr;

  if (tlv_data[2].present)
  {
    confirmation_code.data_len = tlv_data[2].data.euicc_download_code.code.data_len;
    confirmation_code.data_ptr = tlv_data[2].data.euicc_download_code.code.data_ptr;
  }

  /* Execute LPA function to add a new profile */
  lpa_status = lpa_add_profile(lpa_slot,
                               activation_code,
                               confirmation_code,
                               qmi_uimi_lpa_callback,
                               qmi_uim_lpa_event_callback,
                               cb_userdata_ptr);

  if (lpa_status == LPA_SUCCESS)
  {
    /* Set the flag so that download progress indication will be sent
       only to this client */
    ((qmi_uimi_client_state_type *)cl_sp)->uim_info.add_profile_requested = TRUE;
  }

  /* Free userdata in case of error */
  QMI_UIM_LPA_FREE_USERDATA_IF_ERROR(lpa_status, cb_userdata_ptr);

  /* Convert LPA status to QMI err code */
  errval = qmi_uim_convert_lpa_status_to_errval(lpa_status);

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(tlv_data, 3);

  return qmi_uimi_populate_response(errval,
                                    FALSE,
                                    0,
                                    0);
}/* qmi_uimi_add_profile */


/*===========================================================================

                             EVENT FUNCTIONS

===========================================================================*/


/*===========================================================================
  FUNCTION QMI_UIM_UTIL_IS_SIMLOCK_STATUS_FOR_VALID_CARD_ENABLED()

  DESCRIPTION
    This function checks the simlock NV and slot policy to determine if
    the criteria is satisifed for simlock status update for valid card.

  PARAMETERS
    None

  RETURN VALUE
    Boolean indicating if criteria is staisifed or not.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
boolean qmi_uim_util_is_simlock_status_for_valid_card_enabled
(
  void
)
{
#ifdef FEATURE_SIMLOCK
  /* criteria is staisifed if simlock NV for simlock staus for valid card is
     enabled for multisim target, and slot_policy is for valid card on any slot */

  if((qmi_uim_global_ptr->simlock_status_for_valid_card ==
       QMI_UIM_SIMLOCK_DISPLAY_FOR_VALID_CARD_ON_ANY_SLOT_POLICY) &&
     (qmi_uim_global_ptr->simlock_slot_policy ==
       SIMLOCK_SLOT_POLICY_VALID_CARD_MUST_ON_ANY_SLOT))
  {
    return TRUE;
  }
#endif /* FEATURE_SIMLOCK*/

  return FALSE;
} /* qmi_uim_util_is_simlock_status_for_valid_card_enabled */


/*===========================================================================
  FUNCTION QMI_UIM_UPDATE_CARD_STATUS_BY_REFRESH_EVT

  DESCRIPTION
    Updates the status of the card when a refresh is started

  PARAMETERS
    session_id      : session id
    refresh_evt_ptr : refresh event

  RETURN VALUE
    uint16          : number of sent indications

  DEPENDENCIES
    None

  SIDE EFFECTS
    Overwrites the table of services interested in the indication
    in the global variable.
===========================================================================*/
static void qmi_uim_update_card_status_by_refresh_evt
(
  const mmgsdi_refresh_evt_info_type * refresh_evt_ptr
)
{
  uint16    app_index          = UIM_INVALID_APP_INDEX;

  ASSERT(qmi_uim_global_ptr);
  ASSERT(refresh_evt_ptr != NULL);
  ASSERT(refresh_evt_ptr->stage == MMGSDI_REFRESH_STAGE_START);

  switch(refresh_evt_ptr->mode)
  {
    case MMGSDI_REFRESH_RESET:
    case MMGSDI_REFRESH_RESET_AUTO:
      qmi_uim_remove_all_aid_in_slot(refresh_evt_ptr->slot);
      qmi_uim_remove_non_provisioning_and_apdu_session(refresh_evt_ptr->slot);
      break;

    case MMGSDI_REFRESH_NAA_INIT:
    case MMGSDI_REFRESH_NAA_INIT_FCN:
    case MMGSDI_REFRESH_NAA_INIT_FULL_FCN:
      app_index = qmi_uim_find_aid(&refresh_evt_ptr->aid, refresh_evt_ptr->slot);
      if (app_index < QMI_UIM_MAX_APP_COUNT &&
          qmi_uim_global_ptr->card_state.application[app_index] != NULL)
      {
        qmi_uim_global_ptr->card_state.application[app_index]->app_state = QMI_UIM_APP_STATE_DETECTED;
        qmi_uim_global_ptr->card_state.application[app_index]->perso_state = QMI_UIM_PERSO_STATE_UNKNOWN;
      }
      break;

    case MMGSDI_REFRESH_NAA_APP_RESET:
    case MMGSDI_REFRESH_3G_SESSION_RESET:
      app_index = qmi_uim_find_aid(&refresh_evt_ptr->aid, refresh_evt_ptr->slot);
      if (app_index < QMI_UIM_MAX_APP_COUNT &&
          qmi_uim_global_ptr->card_state.application[app_index] != NULL)
      {
        qmi_uim_global_ptr->card_state.application[app_index]->app_state = QMI_UIM_APP_STATE_DETECTED;
        qmi_uim_global_ptr->card_state.application[app_index]->perso_state = QMI_UIM_PERSO_STATE_UNKNOWN;
        qmi_uim_global_ptr->card_state.application[app_index]->pin1_state = MMGSDI_PIN_STATUS_NOT_INITIALIZED;
        qmi_uim_global_ptr->card_state.application[app_index]->pin1_num_retries = 0;
        qmi_uim_global_ptr->card_state.application[app_index]->puk1_num_retries = 0;
        qmi_uim_global_ptr->card_state.application[app_index]->pin2_state = MMGSDI_PIN_STATUS_NOT_INITIALIZED;
        qmi_uim_global_ptr->card_state.application[app_index]->pin2_num_retries = 0;
        qmi_uim_global_ptr->card_state.application[app_index]->puk2_num_retries = 0;
      }
      break;

    default:
      /* Nothing to do */
      break;
  }
} /* qmi_uim_update_card_status_by_refresh_evt */


/*===========================================================================
  FUNCTION QMI_UIM_PROCESS_CARD_INSERTED_EVT()

  DESCRIPTION
    This function processes the card inserted event from MMGSDI

  PARAMETERS
    card_inserted_evt_ptr            : pointer to event

  RETURN VALUE
    qmi_uim_card_update_required_type : status of card update required booleans

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_uim_card_update_required_type qmi_uim_process_card_inserted_evt
(
  const mmgsdi_card_inserted_evt_info_type * card_inserted_evt_ptr
)
{
  qmi_uim_card_update_required_type result           = {FALSE, FALSE};
  uint16                            i                = 0;
  uint8                             card_index       = 0;
  boolean                           prov_app_present = FALSE;

  UIM_MSG_HIGH_0("qmi_uim_process_card_inserted_evt");

  ASSERT(card_inserted_evt_ptr);
  ASSERT(qmi_uim_global_ptr);

  if (qmi_uim_mmgsdi_slot_to_slot_index(card_inserted_evt_ptr->slot,
                                        &card_index) != QMI_ERR_NONE)
  {
    return result;
  }

  if(card_index >= QMI_UIM_MAX_CARD_COUNT ||
     card_index >= qmi_uim_global_ptr->card_state.num_slots ||
     qmi_uim_global_ptr->card_state.card[card_index] == NULL)
  {
    return result;
  }

  /* Update card state */
  if (qmi_uim_global_ptr->card_state.card[card_index]->card_state != QMI_UIM_CARD_STATE_PRESENT)
  {
    qmi_uim_global_ptr->card_state.card[card_index]->card_state = QMI_UIM_CARD_STATE_PRESENT;
    qmi_uim_global_ptr->card_state.card[card_index]->card_error = QMI_UIM_CARD_ERROR_UNKNOWN;
    result.card_update_required = TRUE;
  }

  /* Card inserted implies end of sim busy so clear the sim busy flag for this slot */
  qmi_uim_global_ptr->card_state.card[card_index]->sim_busy = FALSE;

  /* Remove applications on that slot... they should be already zero */
  qmi_uim_remove_all_aid_in_slot(card_inserted_evt_ptr->slot);

  qmi_uim_global_ptr->is_euicc_card[card_index] = card_inserted_evt_ptr->is_euicc;

  /* There is no need to check qmi_uim_is_euicc_card because it is possible
     that eUICC was removed and the new card is a normal card. Profile info
     was anyways cleared during card removed handling but to be on safe side,
     we need to clear the profile data here also */
  qmi_uim_clear_profile_info(card_inserted_evt_ptr->slot);

  /* If card is eUICC, then cache the profile information as profile_id
     to ICC-ID mapping is required for any LPA operation. We are doing
     this at card_inserted so that during handling of LPA request response
     will be quick  */
  do
  {
    if (qmi_uim_global_ptr->is_euicc_card[card_index])
    {
      lpa_result_enum_type       lpa_status      = LPA_SUCCESS;
      lpa_slot_id_enum_type      lpa_slot        = LPA_SLOT_1;
      qmi_error_e_type           errval          = QMI_ERR_NONE;
      qmi_uimi_userdata_type *   cb_userdata_ptr = NULL;
  
      errval = qmi_uim_convert_mmgsdi_slot_to_lpa_slot(card_inserted_evt_ptr->slot,
                                                       &lpa_slot);
      if (errval != QMI_ERR_NONE)
      {
        break;
      }

      cb_userdata_ptr = uimqmi_malloc(sizeof(qmi_uimi_userdata_type));
      if (cb_userdata_ptr == NULL)
      {
        break;
      }

      memset(cb_userdata_ptr, 0, sizeof(qmi_uimi_userdata_type));
      cb_userdata_ptr->is_dynamic                = TRUE;
      cb_userdata_ptr->in_use                    = TRUE;
      cb_userdata_ptr->data.lpa.slot             = card_inserted_evt_ptr->slot;
      cb_userdata_ptr->data.lpa.is_profile_query = TRUE;

      lpa_status = lpa_get_profiles_info(lpa_slot,
                                         qmi_uimi_lpa_callback,
                                         cb_userdata_ptr);
      UIM_MSG_HIGH_1("Internally triggered get_profile_info result: 0x%x", lpa_status);
    }
  }while(0);

  /* Add applications to the global structure */
  for (i = 0; i < card_inserted_evt_ptr->num_aids_avail && i < MMGSDI_MAX_APP_INFO; i++)
  {
    if (qmi_uim_add_aid(&card_inserted_evt_ptr->aid_info[i],
                        card_inserted_evt_ptr->slot) != UIM_INVALID_APP_INDEX)
    {
      result.card_update_required = TRUE;

      /* If there is at least 1 prov app then we dont require to send the
         reduced card status indication */
      if(card_inserted_evt_ptr->aid_info[i].app_type == MMGSDI_APP_SIM ||
         card_inserted_evt_ptr->aid_info[i].app_type == MMGSDI_APP_RUIM ||
         card_inserted_evt_ptr->aid_info[i].app_type == MMGSDI_APP_USIM ||
         card_inserted_evt_ptr->aid_info[i].app_type == MMGSDI_APP_CSIM)
      {
        prov_app_present = TRUE;
      }
    }
  }

  /* we send the status change indication to the client if
     1) Card update is required.
     2) No app / no prov app is present in EF DIR or provisioning is manual
     to select the app(s) for activation */
  if(result.card_update_required &&
     (!prov_app_present || !qmi_uim_global_ptr->automatic_provisioning))
  {
    result.reduced_card_update_required = TRUE;
  }

  return result;
} /* qmi_uim_process_card_inserted_evt() */


/*===========================================================================
  FUNCTION QMI_UIM_PROCESS_SESSION_CHANGED_EVT()

  DESCRIPTION
    This function processes the session changed event from MMGSDI

  PARAMETERS
    session_id                       : session id information
    session_changed_evt_ptr          : pointer to event

  RETURN VALUE
    qmi_uim_card_update_required_type : status of card update required booleans

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_uim_card_update_required_type qmi_uim_process_session_changed_evt
(
  mmgsdi_session_id_type                       session_id,
  const mmgsdi_session_changed_evt_info_type * session_changed_evt_ptr
)
{
  uint8                             card_index     = 0;
  uint16                            session_index  = 0;
  uint16                            index          = 0;
  uint16                            app_index      = UIM_INVALID_APP_INDEX;
  uint16                            refresh_index  = 0;
  uint16*                           prov_index_ptr = NULL;
  boolean                           app_present    = FALSE;
  qmi_uim_card_update_required_type result         = {FALSE, FALSE};

  UIM_MSG_HIGH_0("qmi_uim_process_session_changed_evt");

  ASSERT(session_changed_evt_ptr);
  ASSERT(qmi_uim_global_ptr);

  if (qmi_uim_mmgsdi_slot_to_slot_index(session_changed_evt_ptr->app_info.slot,
                                        &card_index) != QMI_ERR_NONE)
  {
    return result;
  }

  if(card_index >= QMI_UIM_MAX_CARD_COUNT ||
     card_index >= qmi_uim_global_ptr->card_state.num_slots ||
     qmi_uim_global_ptr->card_state.card[card_index] == NULL)
  {
    return result;
  }

  /* Update card state, find or add aid on in case of activation */
  if (session_changed_evt_ptr->activated)
  {
    if (qmi_uim_global_ptr->card_state.card[card_index]->card_state != QMI_UIM_CARD_STATE_PRESENT)
    {
      qmi_uim_global_ptr->card_state.card[card_index]->card_state = QMI_UIM_CARD_STATE_PRESENT;
      qmi_uim_global_ptr->card_state.card[card_index]->card_error = QMI_UIM_CARD_ERROR_UNKNOWN;
      result.card_update_required = TRUE;
    }
  }

  /* Actions to perform in case of session being de-activated */
  if (!session_changed_evt_ptr->activated)
  {
    /* Clear the refresh status for the session */
    if (qmi_uim_session_id_to_refresh_index(&refresh_index, session_id) == QMI_ERR_NONE)
    {
      ASSERT(refresh_index < UIM_REFRESH_SESSION_COUNT);

      qmi_uim_clean_up_refresh_evt_info(refresh_index);
      memset(&qmi_uim_global_ptr->refresh_info[refresh_index],
             0,
             sizeof(qmi_uim_global_ptr->refresh_info[refresh_index]));
    }

    /* Remove cached record types */
    qmi_uim_remove_cached_record_type(session_id);
  }

  /* Find the AID in the card state structure or add it */
  app_index = qmi_uim_find_aid(&session_changed_evt_ptr->app_info.app_data,
                               session_changed_evt_ptr->app_info.slot);

  /* Add application if not found, only if this is an activated case */
  if (app_index == UIM_INVALID_APP_INDEX &&
      session_changed_evt_ptr->activated)
  {
    app_index = qmi_uim_add_aid(&session_changed_evt_ptr->app_info.app_data,
                                session_changed_evt_ptr->app_info.slot);
  }

  /* Check index */
  if (app_index == UIM_INVALID_APP_INDEX ||
      qmi_uim_global_ptr->card_state.application[app_index] == NULL)
  {
    UIM_MSG_ERR_0("Impossible to find/add application");
    return result;
  }

  /* Reset the App state in case of deactivation */
  if ((!session_changed_evt_ptr->activated) &&
      (qmi_uim_global_ptr->card_state.application[app_index]->app_state != QMI_UIM_APP_STATE_DETECTED))
  {
    qmi_uim_global_ptr->card_state.application[app_index]->app_state   = QMI_UIM_APP_STATE_DETECTED;
    qmi_uim_global_ptr->card_state.application[app_index]->perso_state = QMI_UIM_PERSO_STATE_UNKNOWN;
    result.card_update_required = TRUE;
  }

  /* Update the PINs state in case of deactivation */
  if (!session_changed_evt_ptr->activated)
  {
    qmi_uim_global_ptr->card_state.application[app_index]->pin1_state =
     MMGSDI_PIN_STATUS_NOT_INITIALIZED;
    qmi_uim_global_ptr->card_state.application[app_index]->pin1_num_retries = 0;
    qmi_uim_global_ptr->card_state.application[app_index]->puk1_num_retries = 0;

    qmi_uim_global_ptr->card_state.application[app_index]->pin2_state =
      MMGSDI_PIN_STATUS_NOT_INITIALIZED;
    qmi_uim_global_ptr->card_state.application[app_index]->pin2_num_retries = 0;
    qmi_uim_global_ptr->card_state.application[app_index]->puk2_num_retries = 0;

    qmi_uim_global_ptr->card_state.application[app_index]->upin = FALSE;
  }

  /* Find the index for this session id: handle only
     provisioning sessions */
  for (session_index = 0; session_index < QMI_UIM_MAX_PROV_SESSIONS; session_index++)
  {
    if (session_id == qmi_uim_global_ptr->mmgsdi_gw_session_id[session_index])
    {
      prov_index_ptr = &qmi_uim_global_ptr->card_state.index_gw[session_index];
      break;
    }
    else if (session_id == qmi_uim_global_ptr->mmgsdi_1x_session_id[session_index])
    {
      prov_index_ptr = &qmi_uim_global_ptr->card_state.index_1x[session_index];
      break;
    }
  }

  /* Update the subscription app index */
  if (prov_index_ptr != NULL)
  {
    uint16 old_value = *prov_index_ptr;

    if (session_changed_evt_ptr->activated)
    {
      *prov_index_ptr = app_index;
    }
    else
    {
      *prov_index_ptr = UIM_INVALID_APP_INDEX;
    }

    if (*prov_index_ptr != old_value)
    {
      result.card_update_required = TRUE;
    }
  }

  if(!result.card_update_required)
  {
    return result;
  }

  /* For reduced card status indications:
     1) In case of manual provisioning: QMI UIM sends out the indication once it receives the
        session changed event (irrespective of app type / activation status).
     2) In case of auto provisioning:
        a) If QMI UIM receives session changed event with activation status as deactivated then
           it sends the card status indication (irrespective of app type)
        b) If QMI UIM receives session changed event for app type SIM/USIM with activation status
           as activated then it will wait for the RUIM's/CSIM's session changed event (if RUIM/CSIM
           app is available  in the card) with successful activation before sending the reduced card
           status indication.
        c) If QMI UIM receives session changed event for app type RUIM/CSIM with activation status
           as activated then it will wait for the SIM's/USIM's session changed event (if SIM/USIM
           app is available  in the card) with successful activation before sending the reduced card
           status indication.
        d) If QMI UIM received session changed event with activation status as activated for SIM/USIM
           app and dont receive subsequent session changed event for RUIM/CSIM app then it will not
           send the reduced card status indication. SIM/USIM app will continue its initialization sequence
           and the indication will be postponed until next card status indication. This is a know limitation
           and this is a corner case where the probability of seeing this in practical scenarios is very less */

  if(!session_changed_evt_ptr->activated)
  {
    qmi_uim_send_prov_session_closed_ind_to_all(session_id,
                                                session_changed_evt_ptr->app_info.slot,
                                                session_changed_evt_ptr->cause);
    result.reduced_card_update_required = TRUE;
  }
  else
  {
    if(qmi_uim_global_ptr->automatic_provisioning)
    {
      if(session_changed_evt_ptr->app_info.app_data.app_type == MMGSDI_APP_USIM ||
         session_changed_evt_ptr->app_info.app_data.app_type == MMGSDI_APP_SIM)
      {
        for(app_index = 0; app_index < qmi_uim_global_ptr->card_state.num_apps; app_index++)
        {
          if((qmi_uim_global_ptr->card_state.application[app_index]->app_type == MMGSDI_APP_CSIM ||
              qmi_uim_global_ptr->card_state.application[app_index]->app_type == MMGSDI_APP_RUIM) &&
             qmi_uim_global_ptr->card_state.application[app_index]->slot == session_changed_evt_ptr->app_info.slot)
          {
            for(session_index = 0; session_index < QMI_UIM_MAX_PROV_SESSIONS; session_index++)
            {
              index = qmi_uim_global_ptr->card_state.index_1x[session_index];
              if(index != UIM_INVALID_APP_INDEX &&
                 index < qmi_uim_global_ptr->card_state.num_apps &&
                 qmi_uim_global_ptr->card_state.application[index]->slot == session_changed_evt_ptr->app_info.slot)
              {
                result.reduced_card_update_required = TRUE;
                return result;
              }
            }
            app_present = TRUE;
            break;
          }
        }
        if(!app_present)
        {
          result.reduced_card_update_required = TRUE;
        }
      }
      else if(session_changed_evt_ptr->app_info.app_data.app_type == MMGSDI_APP_CSIM ||
              session_changed_evt_ptr->app_info.app_data.app_type == MMGSDI_APP_RUIM)
      {
        for(app_index = 0; app_index < qmi_uim_global_ptr->card_state.num_apps; app_index++)
        {
          if((qmi_uim_global_ptr->card_state.application[app_index]->app_type == MMGSDI_APP_USIM ||
              qmi_uim_global_ptr->card_state.application[app_index]->app_type == MMGSDI_APP_SIM) &&
             qmi_uim_global_ptr->card_state.application[app_index]->slot == session_changed_evt_ptr->app_info.slot)
          {
            for(session_index = 0; session_index < QMI_UIM_MAX_PROV_SESSIONS; session_index++)
            {
              index = qmi_uim_global_ptr->card_state.index_gw[session_index];
              if(index != UIM_INVALID_APP_INDEX &&
                 index < qmi_uim_global_ptr->card_state.num_apps &&
                 qmi_uim_global_ptr->card_state.application[index]->slot == session_changed_evt_ptr->app_info.slot)
              {
                result.reduced_card_update_required = TRUE;
                return result;
              }
            }
            app_present = TRUE;
            break;
          }
        }
        if(!app_present)
        {
          result.reduced_card_update_required = TRUE;
        }
      }
    }
    else
    {
      result.reduced_card_update_required = TRUE;
    }
  }

  return result;
} /* qmi_uim_process_session_changed_evt() */


/*===========================================================================
  FUNCTION QMI_UIM_PROCESS_PIN_EVTS()

  DESCRIPTION
    This function processes the PIN events from MMGSDI

  PARAMETERS
    evt_enum                          : event type
    pin_evt_ptr                       : pointer to event

  RETURN VALUE
    qmi_uim_card_update_required_type : status of card update required booleans

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_uim_card_update_required_type qmi_uim_process_pin_evts
(
  mmgsdi_events_enum_type          evt_enum,
  const mmgsdi_pin_evt_info_type * pin_evt_ptr
)
{
  uint16                            i           = 0;
  uint16                            app_index   = UIM_INVALID_APP_INDEX;
  uint8                             card_index  = 0;
  qmi_uim_card_update_required_type result      = {FALSE, FALSE};

  UIM_MSG_HIGH_0("qmi_uim_process_pin_evts");

  ASSERT(pin_evt_ptr);
  ASSERT(qmi_uim_global_ptr);

  if (pin_evt_ptr->pin_info.status == MMGSDI_PIN_NOT_FOUND)
  {
    UIM_MSG_HIGH_1("qmi_uim_process_pin_evts: ignore PIN evt %d",
                   pin_evt_ptr->pin_info.status);
    return result;
  }

  if (qmi_uim_mmgsdi_slot_to_slot_index(pin_evt_ptr->slot,
                                        &card_index) != QMI_ERR_NONE)
  {
    return result;
  }

  if(card_index >= QMI_UIM_MAX_CARD_COUNT ||
     card_index >= qmi_uim_global_ptr->card_state.num_slots ||
     qmi_uim_global_ptr->card_state.card[card_index] == NULL)
  {
    return result;
  }

  /* Update card state */
  qmi_uim_global_ptr->card_state.card[card_index]->card_state = QMI_UIM_CARD_STATE_PRESENT;
  qmi_uim_global_ptr->card_state.card[card_index]->card_error = QMI_UIM_CARD_ERROR_UNKNOWN;

  switch (evt_enum)
  {
    case MMGSDI_PIN1_EVT:
      for (i = 0; i < pin_evt_ptr->num_aids && i < MMGSDI_MAX_APP_INFO; i++)
      {
        /* Update all the apps that are using this PIN1 */
        app_index = qmi_uim_find_aid(&pin_evt_ptr->aid_type[i], pin_evt_ptr->slot);
        if (app_index < QMI_UIM_MAX_APP_COUNT &&
            qmi_uim_global_ptr->card_state.application[app_index] != NULL)
        {
          if (qmi_uim_update_pin_state(pin_evt_ptr->pin_info.pin_id,
                                       pin_evt_ptr->pin_info.status,
                                       pin_evt_ptr->pin_info.pin_replacement,
                                       app_index, card_index))
          {
            result.card_update_required = TRUE;
          }

          /* Number of retries */
          if ((pin_evt_ptr->pin_info.valid_num_retries) &&
              (qmi_uim_global_ptr->card_state.application[app_index]->pin1_num_retries !=
              (uint8)pin_evt_ptr->pin_info.num_retries))
          {
            qmi_uim_global_ptr->card_state.application[app_index]->pin1_num_retries =
              (uint8)pin_evt_ptr->pin_info.num_retries;

            /* Mark card update required as true (update) */
            result.card_update_required = TRUE;
          }
          if ((pin_evt_ptr->pin_info.valid_num_unblock_retries) &&
              (qmi_uim_global_ptr->card_state.application[app_index]->puk1_num_retries !=
              (uint8)pin_evt_ptr->pin_info.num_unblock_retries))
          {
            qmi_uim_global_ptr->card_state.application[app_index]->puk1_num_retries =
              (uint8)pin_evt_ptr->pin_info.num_unblock_retries;

            /* Mark card update required as true (update) */
            result.card_update_required = TRUE;
          }

          /* Update PIN1 retries and state of all the apps sharing PIN1 */
          qmi_uim_update_pin1_other_apps(&pin_evt_ptr->pin_info,
                                         pin_evt_ptr->slot,
                                         app_index);

          /* QMI UIM sends the reduced card status indication if
             1) PIN1 is not replaced by UPIN
             1) card update is required and
             2) App state is Ready / Illegal.
             3) PIN1 state is not disabed and not enabled verified.*/
          if((result.card_update_required) &&
             (qmi_uim_global_ptr->card_state.application[app_index]->upin == FALSE) &&
             (qmi_uim_global_ptr->card_state.application[app_index]->app_state == QMI_UIM_APP_STATE_READY ||
              qmi_uim_global_ptr->card_state.application[app_index]->app_state == QMI_UIM_APP_STATE_ILLEGAL ||
              (!(qmi_uim_global_ptr->card_state.application[app_index]->pin1_state == MMGSDI_PIN_DISABLED ||
                 qmi_uim_global_ptr->card_state.application[app_index]->pin1_state == MMGSDI_PIN_ENABLED_VERIFIED))))
          {
            result.reduced_card_update_required = TRUE;
          }
        }
      }
      break;

    case MMGSDI_PIN2_EVT:
      /* Each PIN2 can be associated with 1 app only */
      if (pin_evt_ptr->num_aids == 1)
      {
        app_index = qmi_uim_find_aid(&pin_evt_ptr->aid_type[i], pin_evt_ptr->slot);
        if (app_index < QMI_UIM_MAX_APP_COUNT &&
            qmi_uim_global_ptr->card_state.application[app_index] != NULL)
        {
          if (qmi_uim_update_pin_state(pin_evt_ptr->pin_info.pin_id,
                                       pin_evt_ptr->pin_info.status,
                                       pin_evt_ptr->pin_info.pin_replacement,
                                       app_index, card_index))
          {
            result.card_update_required = TRUE;
          }

          /* Number of retries */
          if ((pin_evt_ptr->pin_info.valid_num_retries) &&
              (qmi_uim_global_ptr->card_state.application[app_index]->pin2_num_retries !=
              (uint8)pin_evt_ptr->pin_info.num_retries))
          {
            qmi_uim_global_ptr->card_state.application[app_index]->pin2_num_retries =
              (uint8)pin_evt_ptr->pin_info.num_retries;

            /* Mark card update required as true (update) */
            result.card_update_required = TRUE;
          }
          if ((pin_evt_ptr->pin_info.valid_num_unblock_retries) &&
              (qmi_uim_global_ptr->card_state.application[app_index]->puk2_num_retries !=
              (uint8)pin_evt_ptr->pin_info.num_unblock_retries))
          {
            qmi_uim_global_ptr->card_state.application[app_index]->puk2_num_retries =
              (uint8)pin_evt_ptr->pin_info.num_unblock_retries;

            /* Mark card update required as true (update) */
            result.card_update_required = TRUE;
          }

          /* If card update is required and app state is ready / illegal then QMI UIM will send the reduced card indication */
          if(result.card_update_required &&
             (qmi_uim_global_ptr->card_state.application[app_index]->app_state == QMI_UIM_APP_STATE_READY ||
              qmi_uim_global_ptr->card_state.application[app_index]->app_state == QMI_UIM_APP_STATE_ILLEGAL))
          {
            result.reduced_card_update_required = TRUE;
          }
        }
      }
      else
      {
        UIM_MSG_ERR_1("Invalid number of applications for PIN2 event (0x%x)",
                      pin_evt_ptr->num_aids);
      }
      break;

    case MMGSDI_UNIVERSAL_PIN_EVT:
      if (qmi_uim_update_pin_state(pin_evt_ptr->pin_info.pin_id,
                                   pin_evt_ptr->pin_info.status,
                                   pin_evt_ptr->pin_info.pin_replacement,
                                   app_index, card_index))
      {
        result.card_update_required = TRUE;
      }

      /* Number of retries */
      if ((pin_evt_ptr->pin_info.valid_num_retries) &&
          (qmi_uim_global_ptr->card_state.card[card_index]->upin_num_retries !=
          (uint8)pin_evt_ptr->pin_info.num_retries))
      {
        qmi_uim_global_ptr->card_state.card[card_index]->upin_num_retries =
          (uint8)pin_evt_ptr->pin_info.num_retries;

        /* Mark card update required as true (update) */
        result.card_update_required = TRUE;
      }
      if ((pin_evt_ptr->pin_info.valid_num_unblock_retries) &&
          (qmi_uim_global_ptr->card_state.card[card_index]->upuk_num_retries !=
          (uint8)pin_evt_ptr->pin_info.num_unblock_retries))
      {
        qmi_uim_global_ptr->card_state.card[card_index]->upuk_num_retries =
          (uint8)pin_evt_ptr->pin_info.num_unblock_retries;

        /* Mark card update required as true (update) */
        result.card_update_required = TRUE;
      }

      if(result.card_update_required)
      {
        for (i = 0; i < pin_evt_ptr->num_aids && i < MMGSDI_MAX_APP_INFO; i++)
        {
          app_index = qmi_uim_find_aid(&pin_evt_ptr->aid_type[i], pin_evt_ptr->slot);

          /* QMI UIM sends the reduced card status indication if
             1) PIN1 is replaced by UPIN and
             2) The card update is required and
             3) app state is ready or illegal or
             4) UPIN state is  not disabed and not enabled verified */
          if ((app_index < QMI_UIM_MAX_APP_COUNT) &&
              (qmi_uim_global_ptr->card_state.application[app_index] != NULL) &&
              (qmi_uim_global_ptr->card_state.application[app_index]->upin) &&
              (qmi_uim_global_ptr->card_state.application[app_index]->app_state == QMI_UIM_APP_STATE_READY ||
               qmi_uim_global_ptr->card_state.application[app_index]->app_state == QMI_UIM_APP_STATE_ILLEGAL ||
               (!(qmi_uim_global_ptr->card_state.card[card_index]->upin_state == MMGSDI_PIN_DISABLED ||
                  qmi_uim_global_ptr->card_state.card[card_index]->upin_state == MMGSDI_PIN_ENABLED_VERIFIED))))
          {
            result.reduced_card_update_required = TRUE;
          }
        }
      }
      break;

    default:
      UIM_MSG_ERR_1("Incorrect PIN event: 0x%x", evt_enum);
      return result;
  }

  return result;
} /* qmi_uim_process_pin_evts() */


/*===========================================================================
  FUNCTION QMI_UIM_PROCESS_PERSO_EVT()

  DESCRIPTION
    This function processes the PERSO events from MMGSDI

  PARAMETERS
    perso_evt_ptr : pointer to event

  RETURN VALUE
    qmi_uim_card_update_required_type : status of card update required booleans

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_uim_card_update_required_type qmi_uim_process_perso_evt
(
  mmgsdi_session_id_type             session_id,
  const mmgsdi_perso_evt_info_type * perso_evt_ptr
)
{
  uint16                            prov_app_index = UIM_INVALID_APP_INDEX;
  qmi_uim_card_update_required_type result         = {FALSE, FALSE};
  uint8                             session_index  = 0;

  UIM_MSG_HIGH_0("qmi_uim_process_perso_evt");

  ASSERT(perso_evt_ptr);
  ASSERT(qmi_uim_global_ptr);

  /* Find the provisioning application index for the session id */
  for (session_index = 0; session_index < QMI_UIM_MAX_PROV_SESSIONS; session_index++)
  {
    if (session_id == qmi_uim_global_ptr->mmgsdi_gw_session_id[session_index])
    {
      prov_app_index = qmi_uim_global_ptr->card_state.index_gw[session_index];
      break;
    }
    else if (session_id == qmi_uim_global_ptr->mmgsdi_1x_session_id[session_index])
    {
      prov_app_index = qmi_uim_global_ptr->card_state.index_1x[session_index];
      break;
    }
  }

  /* Check index */
  if (prov_app_index >= QMI_UIM_MAX_APP_COUNT ||
      qmi_uim_global_ptr->card_state.application[prov_app_index] == NULL)
  {
    UIM_MSG_ERR_0("Could not find provisioning application");
    return result;
  }

  /* Update app status: perso event can be received only when PIN is
     already verified. During refresh, it is possible that app state
     is back to detected. */
  if (qmi_uim_global_ptr->card_state.application[prov_app_index]->app_state < QMI_UIM_APP_STATE_PERSO)
  {
    qmi_uim_global_ptr->card_state.application[prov_app_index]->app_state = QMI_UIM_APP_STATE_PERSO;
    result.card_update_required = TRUE;
    result.reduced_card_update_required = TRUE;
  }

  /* Update perso status */
  switch(perso_evt_ptr->status)
  {
    case MMGSDI_PERSO_STATUS_DONE:
      /* Dont send the reduced card status indication if the PERSO state is done */
      result.reduced_card_update_required = FALSE;
      if (qmi_uim_global_ptr->card_state.application[prov_app_index]->perso_state !=
             QMI_UIM_PERSO_STATE_READY)
      {
        qmi_uim_global_ptr->card_state.application[prov_app_index]->perso_state =
          QMI_UIM_PERSO_STATE_READY;
        result.card_update_required = TRUE;
      }
      break;

    case MMGSDI_PERSO_STATUS_WAIT_FOR_EXT_PERSO:
      if (qmi_uim_global_ptr->card_state.application[prov_app_index]->perso_state !=
        QMI_UIM_PERSO_STATE_READY)
      {
        qmi_uim_global_ptr->card_state.application[prov_app_index]->perso_state =
          QMI_UIM_PERSO_STATE_READY;
        result.card_update_required = TRUE;
      }
      /* Perform app state transition once app is locked after app state ready. */
      if (qmi_uim_global_ptr->card_state.application[prov_app_index]->app_state == QMI_UIM_APP_STATE_READY)
      {
        qmi_uim_global_ptr->card_state.application[prov_app_index]->app_state = QMI_UIM_APP_STATE_PERSO;
        result.reduced_card_update_required = TRUE;
      }
      break;

    case MMGSDI_PERSO_STATUS_LOCKED:
      if (qmi_uim_global_ptr->card_state.application[prov_app_index]->perso_state !=
            QMI_UIM_PERSO_STATE_CODE_REQUIRED)
      {
        qmi_uim_global_ptr->card_state.application[prov_app_index]->perso_state =
          QMI_UIM_PERSO_STATE_CODE_REQUIRED;
        result.card_update_required = TRUE;
      }
      /* Perform app state transition once app is locked after app state ready. */
      if (qmi_uim_global_ptr->card_state.application[prov_app_index]->app_state == QMI_UIM_APP_STATE_READY)
      {
        qmi_uim_global_ptr->card_state.application[prov_app_index]->app_state = QMI_UIM_APP_STATE_PERSO;
        result.reduced_card_update_required = TRUE;
      }
      break;

    case MMGSDI_PERSO_STATUS_BLOCKED:
      if (qmi_uim_global_ptr->card_state.application[prov_app_index]->perso_state !=
            QMI_UIM_PERSO_STATE_PERM_BLOCKED)
      {
        qmi_uim_global_ptr->card_state.application[prov_app_index]->perso_state =
          QMI_UIM_PERSO_STATE_PERM_BLOCKED;
        result.reduced_card_update_required = TRUE;
        result.card_update_required = TRUE;
      }
      break;

    case MMGSDI_PERSO_STATUS_IN_PROGRESS:
      /* Dont send the reduced card status indication if the PERSO state is in progress */
      result.reduced_card_update_required = FALSE;
      if (qmi_uim_global_ptr->card_state.application[prov_app_index]->perso_state !=
            QMI_UIM_PERSO_STATE_IN_PROGRESS)
      {
        qmi_uim_global_ptr->card_state.application[prov_app_index]->perso_state =
          QMI_UIM_PERSO_STATE_IN_PROGRESS;
      }

      /* Perform app state transition after device is set in emergency mode. */
      if (qmi_uim_global_ptr->card_state.application[prov_app_index]->app_state == QMI_UIM_APP_STATE_READY)
      {
        qmi_uim_global_ptr->card_state.application[prov_app_index]->app_state = QMI_UIM_APP_STATE_PERSO;
        result.reduced_card_update_required = TRUE;
        result.card_update_required = TRUE;
      }
      break;

    default:
      UIM_MSG_ERR_1("Invalid perso state: 0x%x", perso_evt_ptr->status);
      return result;
  }

  /* Update other perso fields */
  if (qmi_uim_global_ptr->card_state.application[prov_app_index]->perso_retries !=
         (uint8)perso_evt_ptr->num_retries)
  {
    qmi_uim_global_ptr->card_state.application[prov_app_index]->perso_retries =
      (uint8)perso_evt_ptr->num_retries;
    result.card_update_required = TRUE;
  }

   if (qmi_uim_global_ptr->card_state.application[prov_app_index]->perso_unblock_retries !=
          (uint8)perso_evt_ptr->num_unblock_retries)
  {
    qmi_uim_global_ptr->card_state.application[prov_app_index]->perso_unblock_retries =
      (uint8)perso_evt_ptr->num_unblock_retries;
    result.card_update_required = TRUE;
  }

  if (qmi_uim_global_ptr->card_state.application[prov_app_index]->perso_feature !=
          perso_evt_ptr->feature)
  {
    qmi_uim_global_ptr->card_state.application[prov_app_index]->perso_feature =
      perso_evt_ptr->feature;
    result.card_update_required = TRUE;
  }

  return result;
} /* qmi_uim_process_perso_evt() */


/*===========================================================================
  FUNCTION QMI_UIM_PROCESS_SIM_BUSY_EVT()

  DESCRIPTION
    This function processes the sim busy event from MMGSDI. It passes the
    sim_busy state (TRUE / FALSE) to all QMI clients.

  PARAMETERS
    slot     : Card slot
    sim_busy : Indicates if SIM is busy or not.

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_process_sim_busy_evt
(
  mmgsdi_slot_id_enum_type        slot,
  boolean                         sim_busy
)
{
  uint8  card_index  = 0;

  UIM_MSG_HIGH_2("qmi_uim_process_sim_busy_evt: slot = 0x%x, sim_busy = 0x%x",
                 slot, sim_busy);

  ASSERT(qmi_uim_global_ptr);

  if (qmi_uim_mmgsdi_slot_to_slot_index(slot,
                                        &card_index) != QMI_ERR_NONE)
  {
    return;
  }

  if(card_index >= QMI_UIM_MAX_CARD_COUNT ||
     card_index >= qmi_uim_global_ptr->card_state.num_slots ||
     qmi_uim_global_ptr->card_state.card[card_index] == NULL)
  {
    UIM_MSG_ERR_1("Invalid card_index: 0x%x", card_index);
    return;
  }

  /* MMGSDI only sends sim busy events if there has been a change in the sim
     busy state of one of the slots. Regardless, here we re-confirm there has been
     a change. */
  if (sim_busy != qmi_uim_global_ptr->card_state.card[card_index]->sim_busy)
  {
    /* Sim busy state changed so update internal variables and inform
       the QMI clients who, during QMI_UIM_EVT_REG, asked to be notified
       of sim busy events */
    qmi_uim_global_ptr->card_state.card[card_index]->sim_busy = sim_busy;

    qmi_uim_send_sim_busy_indication_to_all();
  }
} /* qmi_uim_process_sim_busy_evt() */


/*===========================================================================
  FUNCTION QMI_UIM_PROCESS_CARD_ERROR_EVT()

  DESCRIPTION
    This function processes the card error event from MMGSDI

  PARAMETERS
    error_info     : error type
    slot           : card slot

  RETURN VALUE
    Boolean indicating if update is required.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_uim_process_card_error_evt
(
  mmgsdi_card_err_info_enum_type  error_info,
  mmgsdi_slot_id_enum_type        slot
)
{
  uint8                                 card_index     = 0;
  qmi_uim_card_error_type               new_card_error = QMI_UIM_CARD_ERROR_UNKNOWN;
  boolean                               result         = FALSE;
  mmgsdi_session_closed_cause_enum_type cause          = MMGSDI_SESSION_CLOSED_CAUSE_UNKNOWN;

  ASSERT(qmi_uim_global_ptr);

  UIM_MSG_HIGH_2("qmi_uim_process_card_error_evt: slot = 0x%x, cause = 0x%x",
                 slot, error_info);

  if (qmi_uim_mmgsdi_slot_to_slot_index(slot,
                                        &card_index) != QMI_ERR_NONE)
  {
    return FALSE;
  }

  if(card_index >= QMI_UIM_MAX_CARD_COUNT ||
     card_index >= qmi_uim_global_ptr->card_state.num_slots ||
     qmi_uim_global_ptr->card_state.card[card_index] == NULL)
  {
    return FALSE;
  }

  /* Update error indication for the card */
  switch(error_info)
  {
    case MMGSDI_CARD_ERR_PWR_DN_CMD_NOTIFY:
      new_card_error = QMI_UIM_CARD_ERROR_POWER_DOWN;
      break;

    case MMGSDI_CARD_ERR_POLL_ERROR:
      new_card_error = QMI_UIM_CARD_ERROR_POLL_ERROR;
      break;

    case MMGSDI_CARD_ERR_NO_ATR_RCVD_AT_MAX_VOLT:
    case MMGSDI_CARD_ERR_NO_ATR_RCVD_AFTER_RESET:
    case MMGSDI_CARD_ERR_CORRUPT_ATR_RCVD_MAX_TIMES:
    case MMGSDI_CARD_ERR_NO_PROTOCOL_AT_CARD_PUP:
      /* To distingish between card removal & power up without card */
      if(qmi_uim_global_ptr->card_state.card[card_index]->card_state == QMI_UIM_CARD_STATE_PRESENT)
      {
        new_card_error = QMI_UIM_CARD_ERROR_UNKNOWN_POSSIBLY_REMOVED;
      }
      else
      {
        new_card_error = QMI_UIM_CARD_ERROR_NO_ATR_RECEIVED;
      }
      break;

    case MMGSDI_CARD_ERR_VOLT_MISMATCH:
      new_card_error = QMI_UIM_CARD_ERROR_VOLT_MISMATCH;
      break;

    case MMGSDI_CARD_ERR_MAXED_PARITY_ERROR:
    case MMGSDI_CARD_ERR_MAXED_RX_BREAK_ERR:
    case MMGSDI_CARD_ERR_MAXED_OVERRUN_ERR:
    case MMGSDI_CARD_ERR_MAX_PARITY_IN_PASSIVE:
    case MMGSDI_CARD_ERR_MAX_RXBRK_IN_PASSIVE:
    case MMGSDI_CARD_ERR_MAX_OVERRUN_IN_PASSIVE:
      new_card_error = QMI_UIM_CARD_ERROR_PARITY_ERROR;
      break;

    case MMGSDI_CARD_ERR_TECHNICAL_PROBLEM:
      new_card_error = QMI_UIM_CARD_ERROR_CODE_SIM_TECHNICAL_PROBLEMS;
      break;

    case MMGSDI_CARD_ERR_NULL_BYTES:
      new_card_error = QMI_UIM_CARD_ERROR_NULL_BYTES;
      break;

    case MMGSDI_CARD_ERR_SAP_CONNECTED:
      new_card_error = QMI_UIM_CARD_ERROR_SAP_CONNECTED;
      break;

    case MMGSDI_CARD_ERR_UNKNOWN_ERROR:
    default:
      new_card_error = QMI_UIM_CARD_ERROR_UNKNOWN;
      break;
  }

  /* Update card error information */
  if (new_card_error != qmi_uim_global_ptr->card_state.card[card_index]->card_error)
  {
    qmi_uim_global_ptr->card_state.card[card_index]->card_error = new_card_error;
    result = TRUE;
  }

  /* Update card status */
  if (qmi_uim_global_ptr->card_state.card[card_index]->card_state != QMI_UIM_CARD_STATE_ERROR)
  {
    qmi_uim_global_ptr->card_state.card[card_index]->card_state = QMI_UIM_CARD_STATE_ERROR;
    result = TRUE;
  }

  /* Card error implies end of sim busy so clear the sim busy flag for this slot */
  qmi_uim_global_ptr->card_state.card[card_index]->sim_busy = FALSE;

  /* Reset the UPIN state and retries */
  qmi_uim_global_ptr->card_state.card[card_index]->upin_state = MMGSDI_PIN_STATUS_NOT_INITIALIZED;
  qmi_uim_global_ptr->card_state.card[card_index]->upin_num_retries = 0;
  qmi_uim_global_ptr->card_state.card[card_index]->upuk_num_retries = 0;

  if (result)
  {
    if(error_info == MMGSDI_CARD_ERR_PWR_DN_CMD_NOTIFY)
    {
      cause = MMGSDI_SESSION_CLOSED_CAUSE_CARD_POWER_DOWN;
    }
    else if (error_info == MMGSDI_CARD_ERR_PWR_DN_PERSO_ERR)
    {
      cause = MMGSDI_SESSION_CLOSED_CAUSE_PERSO_OPERATION_FAIL;
    }
    else
    {
      cause = MMGSDI_SESSION_CLOSED_CAUSE_CARD_ERROR;
    }

    /* Send the session closed indication to all session on slot */
    qmi_uim_send_session_closed_indication_for_sessions_on_slot(slot, cause);
  }

  /* Wipe out information about applications on that slot */
  qmi_uim_remove_all_aid_in_slot(slot);

  /* Cleat the flag as card state is error */
  qmi_uim_global_ptr->is_euicc_card[card_index] = FALSE;

  /* Clear the profiles data as part of card_error */
  qmi_uim_clear_profile_info(slot);

  /* Clear non-prov & APDU session info for that slot */
  qmi_uim_remove_non_provisioning_and_apdu_session(slot);

  return result;
} /* qmi_uim_process_card_error_evt() */


/*===========================================================================
  FUNCTION QMI_UIM_PROCESS_CARD_REMOVED_EVT()

  DESCRIPTION
    This function processes the card removed event from MMGSDI

  PARAMETERS
    slot           : card slot

  RETURN VALUE
    Boolean indicating if update is required.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_uim_process_card_removed_evt
(
  mmgsdi_slot_id_enum_type        slot
)
{
  uint8                     card_index     = 0;
  boolean                   result         = FALSE;

  ASSERT(qmi_uim_global_ptr);

  UIM_MSG_HIGH_0("qmi_uim_process_card_removed_evt");

  if (qmi_uim_mmgsdi_slot_to_slot_index(slot,
                                        &card_index) != QMI_ERR_NONE)
  {
    return FALSE;
  }

  if(card_index >= QMI_UIM_MAX_CARD_COUNT ||
     card_index >= qmi_uim_global_ptr->card_state.num_slots ||
     qmi_uim_global_ptr->card_state.card[card_index] == NULL)
  {
    return FALSE;
  }

  /* Update card status */
  if (qmi_uim_global_ptr->card_state.card[card_index]->card_state != QMI_UIM_CARD_STATE_ABSENT)
  {
    qmi_uim_global_ptr->card_state.card[card_index]->card_state = QMI_UIM_CARD_STATE_ABSENT;
    qmi_uim_global_ptr->card_state.card[card_index]->card_error = QMI_UIM_CARD_ERROR_UNKNOWN;
    result = TRUE;
  }

  /* Card removed implies end of sim busy so clear the sim busy flag for this slot */
  qmi_uim_global_ptr->card_state.card[card_index]->sim_busy = FALSE;

  /* Reset the UPIN state and retries */
  qmi_uim_global_ptr->card_state.card[card_index]->upin_state = MMGSDI_PIN_STATUS_NOT_INITIALIZED;
  qmi_uim_global_ptr->card_state.card[card_index]->upin_num_retries = 0;
  qmi_uim_global_ptr->card_state.card[card_index]->upuk_num_retries = 0;

  if (result)
  {
    /* Send the session closed indication to all session on slot */
    qmi_uim_send_session_closed_indication_for_sessions_on_slot(slot,
                                                                MMGSDI_SESSION_CLOSED_CAUSE_CARD_REMOVED);
  }

  /* Wipe out information about applications on that slot */
  qmi_uim_remove_all_aid_in_slot(slot);

  /* Cleat the flag as card is removed */
  qmi_uim_global_ptr->is_euicc_card[card_index] = FALSE;

  /* Clear the profiles data as part of card removal */
  qmi_uim_clear_profile_info(slot);

  /* Clear non-prov & APDU session info for that slot */
  qmi_uim_remove_non_provisioning_and_apdu_session(slot);

  return result;
} /* qmi_uim_process_card_removed_evt() */


/*===========================================================================
  FUNCTION QMI_UIM_PROCESS_MANAGE_ILLEGAL_CARD_EVT()

  DESCRIPTION
    This function processes the legal and illegal card events from MMGSDI

  PARAMETERS
    session_id             : session id
    legal_status           : status of card illegal or legal

  RETURN VALUE
    Boolean indicating if update is required.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_uim_process_manage_illegal_card_evt
(
  mmgsdi_session_id_type                session_id,
  mmgsdi_session_app_legal_status_type  legal_status
)
{
  uint16 prov_app_index = UIM_INVALID_APP_INDEX;
  uint8  i              = 0;

  ASSERT(qmi_uim_global_ptr);

  UIM_MSG_HIGH_1("qmi_uim_process_manage_illegal_card_evt with legal_status as 0x%x",
                 legal_status);

  /* Find the provisioning application index for the session id */
  for (i = 0; i < QMI_UIM_MAX_PROV_SESSIONS; i++)
  {
    if (session_id == qmi_uim_global_ptr->mmgsdi_gw_session_id[i])
    {
      prov_app_index = qmi_uim_global_ptr->card_state.index_gw[i];
      break;
    }
    else if (session_id == qmi_uim_global_ptr->mmgsdi_1x_session_id[i])
    {
      prov_app_index = qmi_uim_global_ptr->card_state.index_1x[i];
      break;
    }
  }

  /* Check index */
  if (prov_app_index >= QMI_UIM_MAX_APP_COUNT ||
      qmi_uim_global_ptr->card_state.application[prov_app_index] == NULL)
  {
    UIM_MSG_ERR_0("Could not find application index for the session id");
    return FALSE;
  }

  switch(legal_status)
  {
    case MMGSDI_SESSION_APP_IS_ILLEGAL:
      /* Check if the app state is already ILLEGAL: in this case,
         there is nothing to do */
      if (qmi_uim_global_ptr->card_state.application[prov_app_index]->app_state == QMI_UIM_APP_STATE_ILLEGAL)
      {
        return FALSE;
      }
      /* Update application status */
      qmi_uim_global_ptr->card_state.application[prov_app_index]->app_state = QMI_UIM_APP_STATE_ILLEGAL;
      return TRUE;

    case MMGSDI_SESSION_APP_IS_LEGAL:
      /* Check if the app state is not illegal: in this case, there is nothing to do */
      if (qmi_uim_global_ptr->card_state.application[prov_app_index]->app_state != QMI_UIM_APP_STATE_ILLEGAL)
      {
        return FALSE;
      }
      /* Update application status */
      qmi_uim_global_ptr->card_state.application[prov_app_index]->app_state = QMI_UIM_APP_STATE_READY;
      return TRUE;

    default:
      UIM_MSG_ERR_0("Invalid legal status");
      break;
  }
  return FALSE;
} /* qmi_uim_process_manage_illegal_card_evt() */


/*===========================================================================
  FUNCTION QMI_UIM_PROCESS_SUBSCRIPTION_READY_EVT()

  DESCRIPTION
    This function processes the subscription ready event
    from MMGSDI

  PARAMETERS
    subscription_ready_evt_ptr: pointer to event

  RETURN VALUE
    Boolean indicating if update is required.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_uim_process_subscription_ready_evt
(
  mmgsdi_session_id_type                          session_id,
  const mmgsdi_subscription_ready_evt_info_type * subscription_ready_evt_ptr
)
{
  uint8                                 card_index             = 0;
  uint16                                app_index              = 0;
  boolean                               result                 = FALSE;
  qmi_uim_card_update_required_type     session_changed_result = {FALSE, FALSE};
  mmgsdi_session_changed_evt_info_type  session_changed;

  ASSERT(subscription_ready_evt_ptr);
  ASSERT(qmi_uim_global_ptr);

  /* Process session changed event again to avoid client getting
     subscription_ready_evt without session_changed_evt */
  memset(&session_changed, 0, sizeof(mmgsdi_session_changed_evt_info_type));
  session_changed.activated = TRUE;

  (void)memscpy(&session_changed.app_info,
                sizeof(session_changed.app_info),
                &subscription_ready_evt_ptr->app_info,
                sizeof(mmgsdi_app_info_type));

  session_changed_result = qmi_uim_process_session_changed_evt(session_id,
                                                               &session_changed);
  result = session_changed_result.card_update_required;

  if (qmi_uim_mmgsdi_slot_to_slot_index(subscription_ready_evt_ptr->app_info.slot,
                                        &card_index) != QMI_ERR_NONE)
  {
    return result;
  }

  if(card_index >= QMI_UIM_MAX_CARD_COUNT ||
     card_index >= qmi_uim_global_ptr->card_state.num_slots ||
     qmi_uim_global_ptr->card_state.card[card_index] == NULL)
  {
    return result;
  }

  /* Update card state */
  if (qmi_uim_global_ptr->card_state.card[card_index]->card_state != QMI_UIM_CARD_STATE_PRESENT)
  {
    qmi_uim_global_ptr->card_state.card[card_index]->card_state = QMI_UIM_CARD_STATE_PRESENT;
    qmi_uim_global_ptr->card_state.card[card_index]->card_error = QMI_UIM_CARD_ERROR_UNKNOWN;
    result = TRUE;
  }

  /* Find the AID in the card state structure or add it */
  app_index = qmi_uim_find_aid(&subscription_ready_evt_ptr->app_info.app_data,
                               subscription_ready_evt_ptr->app_info.slot);
  if (app_index == UIM_INVALID_APP_INDEX)
  {
    app_index = qmi_uim_add_aid(&subscription_ready_evt_ptr->app_info.app_data,
                                subscription_ready_evt_ptr->app_info.slot);
  }

  /* Check index */
  if (app_index == UIM_INVALID_APP_INDEX ||
      qmi_uim_global_ptr->card_state.application[app_index] == NULL)
  {
    UIM_MSG_ERR_0("Impossible to find/add application");
    return result;
  }

  qmi_uim_global_ptr->card_state.application[app_index]->app_state   = QMI_UIM_APP_STATE_READY;
  qmi_uim_global_ptr->card_state.application[app_index]->perso_state = QMI_UIM_PERSO_STATE_READY;

  /* In case QMI UIM misses PIN events (from mmgsdi), possibly due to
     QMI taking long time to initialize and/or open the sessions, PINs state
     is updated here */

  /* PIN1 state */
  if (qmi_uim_global_ptr->card_state.application[app_index]->pin1_state !=
      subscription_ready_evt_ptr->app_info.pin1.status)
  {
    qmi_uim_global_ptr->card_state.application[app_index]->pin1_state =
        subscription_ready_evt_ptr->app_info.pin1.status;

    /* Number of retries */
    if (subscription_ready_evt_ptr->app_info.pin1.valid_num_retries)
    {
      qmi_uim_global_ptr->card_state.application[app_index]->pin1_num_retries =
        (uint8)subscription_ready_evt_ptr->app_info.pin1.num_retries;
    }
    if (subscription_ready_evt_ptr->app_info.pin1.valid_num_unblock_retries)
    {
      qmi_uim_global_ptr->card_state.application[app_index]->puk1_num_retries =
        (uint8)subscription_ready_evt_ptr->app_info.pin1.num_unblock_retries;
    }

    /* Universal PIN boolean */
    if (subscription_ready_evt_ptr->app_info.pin1.pin_replacement == MMGSDI_PIN_REPLACED_BY_UNIVERSAL)
    {
      qmi_uim_global_ptr->card_state.application[app_index]->upin = TRUE;
    }
    else
    {
      qmi_uim_global_ptr->card_state.application[app_index]->upin = FALSE;
    }
  }

  /* PIN2 state */
  if (qmi_uim_global_ptr->card_state.application[app_index]->pin2_state !=
      subscription_ready_evt_ptr->app_info.pin2.status)
  {
    qmi_uim_global_ptr->card_state.application[app_index]->pin2_state =
      subscription_ready_evt_ptr->app_info.pin2.status;

    /* Number of retries */
    if (subscription_ready_evt_ptr->app_info.pin2.valid_num_retries)
    {
      qmi_uim_global_ptr->card_state.application[app_index]->pin2_num_retries =
        (uint8)subscription_ready_evt_ptr->app_info.pin2.num_retries;
    }
    if (subscription_ready_evt_ptr->app_info.pin2.valid_num_unblock_retries)
    {
      qmi_uim_global_ptr->card_state.application[app_index]->puk2_num_retries =
        (uint8)subscription_ready_evt_ptr->app_info.pin2.num_unblock_retries;
    }
  }

  /* Universal PIN state */
  if ((qmi_uim_global_ptr->card_state.card[card_index]->upin_state !=
       subscription_ready_evt_ptr->app_info.universal_pin.status) &&
      (subscription_ready_evt_ptr->app_info.pin1.pin_replacement ==
       MMGSDI_PIN_REPLACED_BY_UNIVERSAL))

  {
    qmi_uim_global_ptr->card_state.card[card_index]->upin_state =
        subscription_ready_evt_ptr->app_info.universal_pin.status;

    /* Number of retries */
    if (subscription_ready_evt_ptr->app_info.universal_pin.valid_num_retries)
    {
      qmi_uim_global_ptr->card_state.card[card_index]->upin_num_retries =
        (uint8)subscription_ready_evt_ptr->app_info.universal_pin.num_retries;
    }
    if (subscription_ready_evt_ptr->app_info.universal_pin.valid_num_unblock_retries)
    {
      qmi_uim_global_ptr->card_state.card[card_index]->upuk_num_retries =
        (uint8)subscription_ready_evt_ptr->app_info.universal_pin.num_unblock_retries;
    }
  }

  return TRUE;
} /* qmi_uim_process_subscription_ready_evt() */


/*===========================================================================
  FUNCTION QMI_UIM_PROCESS_SESSION_CLOSED_EVT()

  DESCRIPTION
    This function processes the session closed events from MMGSDI

  PARAMETERS
    session_id     : session id
    close_evt_ptr  : pointer to event

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_process_session_closed_evt
(
  mmgsdi_session_id_type                     session_id,
  const mmgsdi_session_close_evt_info_type * close_evt_ptr
)
{
  ASSERT(close_evt_ptr);

  /* We can receive the session closed event only for non
     provisioning sessions */
  UIM_MSG_HIGH_1("close event for the session: 0x%x", session_id);

  /* Clean up global info belonging to the non prov session and send out
     QMI_UIM_SESSION_CLOSED_IND to the clients linked to the session.
     In case of card error or refresh reset, session info may have been
     already cleaned */
  qmi_uim_remove_non_provisioning_session(session_id, TRUE, close_evt_ptr->cause);
  qmi_uim_remove_apdu_session(session_id, TRUE, close_evt_ptr->cause);
} /* qmi_uim_process_session_closed_evt */


/*===========================================================================
  FUNCTION QMI_UIM_PROCESS_REFRESH_EVT()

  DESCRIPTION
    This function processes the refresh events from MMGSDI

  PARAMETERS
    session_id     : session id
    refresh_evt_ptr: pointer to event

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_process_refresh_evt
(
  mmgsdi_session_id_type               session_id,
  const mmgsdi_refresh_evt_info_type * refresh_evt_ptr
)
{
  mmgsdi_slot_id_enum_type   slot            = MMGSDI_SLOT_1;
  uint16                     refresh_index   = 0;
  boolean                    is_apdu_session = FALSE;
  uint8                      card_index      = 0;

  ASSERT(refresh_evt_ptr);
  ASSERT(qmi_uim_global_ptr);

  UIM_MSG_HIGH_3("Refresh event: stage=0x%x, mode=0x%x, slot=0x%x",
                 refresh_evt_ptr->stage,
                 refresh_evt_ptr->mode,
                 refresh_evt_ptr->slot);

  /* Retrieve the slot id and slot index */
  if (qmi_uim_session_id_to_slot(&slot, session_id) != QMI_ERR_NONE)
  {
    UIM_MSG_ERR_1("Impossible to convert session id (0x%x) into slot",
                  session_id);
    return;
  }

  if (uimqmi_mmgsdi_slot_to_slot_index(slot,
                                       &card_index) != QMI_ERR_NONE)
  {
    return;
  }

  /* Retrieve session index for the refresh */
  if (qmi_uim_session_id_to_refresh_index(&refresh_index, session_id) != QMI_ERR_NONE)
  {
    is_apdu_session = qmi_uim_is_apdu_session(session_id);
    if (!is_apdu_session)
    {
      UIM_MSG_ERR_1("Impossible to convert session id (0x%x) into refresh index",
                    session_id);
      return;
    }
  }
  ASSERT(refresh_index < UIM_REFRESH_SESSION_COUNT);

  UIM_MSG_HIGH_2("Refresh event: slot=0x%x, refresh_index=0x%x",
                 slot, refresh_index);

  switch(refresh_evt_ptr->stage)
  {
    case MMGSDI_REFRESH_STAGE_WAIT_FOR_OK_TO_INIT:
    case MMGSDI_REFRESH_STAGE_WAIT_FOR_OK_TO_FCN:
       /* Vote yes for APDU sessions and return without sending indication */
      if (is_apdu_session)
      {
        (void)mmgsdi_session_ok_to_refresh(
                             session_id,
                             TRUE,
                             qmi_uimi_mmgsdi_callback,
                             (mmgsdi_client_data_type)NULL );
        break;
      }

      /* Check refresh state */
      if (qmi_uim_global_ptr->refresh_info[refresh_index].state != UIM_REFRESH_STATE_IDLE &&
          qmi_uim_global_ptr->refresh_info[refresh_index].state != UIM_REFRESH_STATE_WAIT_FOR_OK)
      {
        UIM_MSG_ERR_1("Refresh event: cannot process event in current state (0x%x)",
                      qmi_uim_global_ptr->refresh_info[refresh_index].state);
        return;
      }

      /* Compose list of clients for refresh and send indication */
      (void)qmi_uim_send_refresh_ind(session_id, refresh_evt_ptr);

      /* Set ok flag to TRUE... we will set to false only if one
         client votes false */
      qmi_uim_global_ptr->refresh_info[refresh_index].ok_to_init = TRUE;

      /* If no client is interested, immediately vote */
      if (qmi_uim_global_ptr->refresh_info[refresh_index].client_count == 0)
      {
        (void)mmgsdi_session_ok_to_refresh(
                             session_id,
                             TRUE,
                             qmi_uimi_mmgsdi_callback,
                             (mmgsdi_client_data_type)NULL );
      }

      /* Update refresh state */
      qmi_uim_global_ptr->refresh_info[refresh_index].state = UIM_REFRESH_STATE_WAIT_FOR_OK;
      break;

    case MMGSDI_REFRESH_STAGE_START:
      /* Send refresh complete for APDU sessions and return without sending
         indication */
      if (is_apdu_session)
      {
        (void)mmgsdi_session_refresh_complete(
                      session_id,
                      TRUE,
                      qmi_uimi_mmgsdi_callback,
                      (mmgsdi_client_data_type)NULL );
        break;
      }

      /* Check refresh state */
      if (qmi_uim_global_ptr->refresh_info[refresh_index].state != UIM_REFRESH_STATE_IDLE &&
          qmi_uim_global_ptr->refresh_info[refresh_index].state != UIM_REFRESH_STATE_WAIT_FOR_OK)
      {
        UIM_MSG_ERR_1("Refresh event: cannot process event in current state (0x%x)",
                      qmi_uim_global_ptr->refresh_info[refresh_index].state);
        return;
      }

      /* Compose list of clients for refresh and send indication */
      (void)qmi_uim_send_refresh_ind(session_id, refresh_evt_ptr);

      /* Set complete flag to TRUE... we will set to false only if one
         client passes false */
      qmi_uim_global_ptr->refresh_info[refresh_index].complete = TRUE;

      /* If no client is interested, immediately send completed */
      if (qmi_uim_global_ptr->refresh_info[refresh_index].client_count == 0)
      {
        (void)mmgsdi_session_refresh_complete(
                      session_id,
                      TRUE,
                      qmi_uimi_mmgsdi_callback,
                      (mmgsdi_client_data_type)NULL );
      }

      /* Send the session closed indication */
      if ((refresh_evt_ptr->mode == MMGSDI_REFRESH_RESET) ||
          (refresh_evt_ptr->mode == MMGSDI_REFRESH_RESET_AUTO))
      {
        /* Cleat the flag as refresh RESET is triggered */
        qmi_uim_global_ptr->is_euicc_card[card_index] = FALSE;

        /* Clear all the profile info stored for eUICC profiles */
        qmi_uim_clear_profile_info(slot);

        qmi_uim_send_prov_session_closed_ind_to_all(session_id, slot,
                                                    MMGSDI_SESSION_CLOSED_CAUSE_REFRESH);
      }

      /* Update card status based on refresh event */
      qmi_uim_update_card_status_by_refresh_evt(refresh_evt_ptr);

      /* Update refresh state */
      qmi_uim_global_ptr->refresh_info[refresh_index].state = UIM_REFRESH_STATE_WAIT_FOR_COMPLETE;
      break;

    case MMGSDI_REFRESH_STAGE_END_SUCCESS:
    case MMGSDI_REFRESH_STAGE_END_FAILED:
      if (is_apdu_session)
      {
        /* Nothing to do for APDU sessions */
        break;
      }

      if (qmi_uim_global_ptr->refresh_info[refresh_index].state != UIM_REFRESH_STATE_WAIT_FOR_OK &&
          qmi_uim_global_ptr->refresh_info[refresh_index].state != UIM_REFRESH_STATE_WAIT_FOR_COMPLETE &&
          refresh_evt_ptr->mode != MMGSDI_REFRESH_NAA_APP_RESET &&
          refresh_evt_ptr->mode != MMGSDI_REFRESH_3G_SESSION_RESET)
      {
        UIM_MSG_ERR_1("Refresh event: cannot process event in current state (0x%x)",
                      qmi_uim_global_ptr->refresh_info[refresh_index].state);
        return;
      }

      /* Compose list of clients for refresh and send indication */
      (void)qmi_uim_send_refresh_ind(session_id, refresh_evt_ptr);

      /* Update refresh state */
      qmi_uim_clean_up_refresh_evt_info(refresh_index);
      memset(&qmi_uim_global_ptr->refresh_info[refresh_index],
             0,
             sizeof(qmi_uim_global_ptr->refresh_info[refresh_index]));
      qmi_uim_global_ptr->refresh_info[refresh_index].state = UIM_REFRESH_STATE_IDLE;
      break;

    default:
      /* Ingore other stages... nothing to do! */
      break;
  }
} /* qmi_uim_process_refresh_evt */


/*===========================================================================
  FUNCTION QMI_UIM_PROCESS_SAP_EVT()

  DESCRIPTION
    This function processes the SAP events from MMGSDI

  PARAMETERS
    event_ptr: pointer to event

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_uim_process_sap_evt
(
  const mmgsdi_event_data_type * event_ptr
)
{
  boolean                       result      = FALSE;
  uint8                         slot_idx    = 0;
  mmgsdi_slot_id_enum_type      slot        = MMGSDI_SLOT_1;
  mmgsdi_sap_state_enum_type    sap_state   = MMGSDI_MAX_SAP_STATE_ENUM;

  ASSERT(event_ptr);
  ASSERT(qmi_uim_global_ptr);

  switch (event_ptr->evt)
  {
    case MMGSDI_SAP_CONNECT_EVT:
      slot = event_ptr->data.sap_connect.slot;
      sap_state = event_ptr->data.sap_connect.connect_state;
      break;
    case MMGSDI_SAP_DISCONNECT_EVT:
      slot = event_ptr->data.sap_disconnect.slot;
      sap_state = event_ptr->data.sap_disconnect.disconnect_state;
      break;
    case MMGSDI_CARD_ERROR_EVT:
      slot = event_ptr->data.card_error.slot;
      break;
    case MMGSDI_CARD_REMOVED_EVT:
      slot = event_ptr->data.card_removed.slot;
      break;
    default:
      UIM_MSG_HIGH_1("Unhandled SAP event: 0x%x", event_ptr->evt);
      return result;
  }

  UIM_MSG_HIGH_3("Event: 0x%x, slot=0x%x, sap state=0x%x",
                 event_ptr->evt, slot, sap_state);

  if (qmi_uim_mmgsdi_slot_to_slot_index(slot,
                                        &slot_idx) != QMI_ERR_NONE)
  {
    return result;
  }

  if(slot_idx >= QMI_UIM_MAX_CARD_COUNT ||
     slot_idx >= qmi_uim_global_ptr->card_state.num_slots)
  {
    return result;
  }

  switch (event_ptr->evt)
  {
    case MMGSDI_SAP_CONNECT_EVT:
    case MMGSDI_SAP_DISCONNECT_EVT:
      /* Update global SAP state */
      if (qmi_uim_global_ptr->sap_info[slot_idx].sap_state != sap_state)
      {
        result = TRUE;
        qmi_uim_global_ptr->sap_info[slot_idx].sap_state = sap_state;

        /* After connection errors have been posted to clients, we reset our flag */
        if (sap_state == MMGSDI_SAP_CONNECTING ||
            sap_state == MMGSDI_SAP_CONNECTED  ||
            sap_state == MMGSDI_SAP_DISCONNECTING)
        {
          qmi_uim_global_ptr->sap_info[slot_idx].is_enabled = TRUE;
        }
        else
        {
          qmi_uim_global_ptr->sap_info[slot_idx].is_enabled = FALSE;
        }
      }
      break;
    case MMGSDI_CARD_ERROR_EVT:
    case MMGSDI_CARD_REMOVED_EVT:
      /* Send SAP disconnect indication only if we are connected and the card
         error info is not due to SAP connected */
      if ((qmi_uim_global_ptr->sap_info[slot_idx].sap_state == MMGSDI_SAP_CONNECTING ||
           qmi_uim_global_ptr->sap_info[slot_idx].sap_state == MMGSDI_SAP_CONNECTED ||
           qmi_uim_global_ptr->sap_info[slot_idx].sap_state == MMGSDI_SAP_DISCONNECTING) &&
          qmi_uim_global_ptr->sap_info[slot_idx].is_enabled                              &&
          event_ptr->data.card_error.info != MMGSDI_CARD_ERR_SAP_CONNECTED)
      {
        /* Update global SAP state and send the indication*/
        qmi_uim_global_ptr->sap_info[slot_idx].sap_state = MMGSDI_SAP_DISCONNECTED;
        qmi_uim_send_sap_status_indication_to_all(slot);

        /* Update is_enabled global after sending SAP indication */
        qmi_uim_global_ptr->sap_info[slot_idx].is_enabled = FALSE;
      }
      break;
    default:
      UIM_MSG_HIGH_1("Unhandled event: 0x%x", event_ptr->evt);
      break;
  }

  return result;
} /* qmi_uim_process_sap_evt */


/*===========================================================================
  FUNCTION QMI_UIM_PROCESS_TEMPORARY_UNLOCK_EVT()

  DESCRIPTION
    This function processes the Temporary unlock event from MMGSDI

  PARAMETERS
    evt_ptr  : Contains the event information sent by MMGSDI

  RETURN VALUE
    void

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_process_temporary_unlock_event(
  const mmgsdi_event_data_type *evt_ptr
)
{
  simlock_result_enum_type   simlock_status = SIMLOCK_GENERIC_ERROR;

  if(evt_ptr == NULL ||
     evt_ptr->evt != MMGSDI_PERSO_TEMPORARY_UNLOCK_EVT)
  {
    return;
  }

  UIM_MSG_MED_2("qmi_uim_process_temporary_unlock_event slot 0x%x feature 0x%x",
                 evt_ptr->data.perso_temp_unlock.slot_id,
                 evt_ptr->data.perso_temp_unlock.feature);

  /* Get the current lock status from SIMLOCK */
  simlock_status = simlock_get_status(qmi_uimi_simlock_temporary_unlock_callback,
                                      NULL);
  if(SIMLOCK_SUCCESS != simlock_status)
  {
    UIM_MSG_MED_1("Failed to queue simlock get status command 0x%x", simlock_status);
  }
} /* qmi_uim_process_temporary_unlock_event */


/*===========================================================================
  FUNCTION QMI_UIMI_GET_SIM_PROFILE()

  DESCRIPTION
    Retrieves the profile information supported by the card

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_get_sim_profile
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type            errval          = QMI_ERR_NONE;
  mmgsdi_return_enum_type     mmgsdi_status   = MMGSDI_SUCCESS;
  qmi_uimi_userdata_type*     cb_userdata_ptr = NULL;
  qmi_uim_tlv_item_type       tlv_data[1];
  lpa_result_enum_type        lpa_status      = LPA_SUCCESS;
  lpa_slot_id_enum_type       lpa_slot        = LPA_SLOT_1;
  uint8                       slot_index      = 0;
  dsm_item_type *             response        = NULL;
  qmi_result_e_type           result          = QMI_RESULT_SUCCESS;
  boolean                     retval          = TRUE;
  uint8                       profile_index   = 0;
  boolean                     response_pending             = FALSE;
  uint32                      file_size                    = 0;
  boolean                     multi_profile_config_present = FALSE;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);
  ASSERT(qmi_uim_global_ptr);

  memset(tlv_data, 0, sizeof(tlv_data));

  tlv_data[0].type      = UIMI_TLV_TYPE_SLOT;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 1);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  errval = uimqmi_mmgsdi_slot_to_slot_index(tlv_data[0].data.slot.slot,
                                            &slot_index);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  /* Create userdata */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_GET_SIM_PROFILE,
                                            cmd_buf_p,
                                            NULL,
                                            ((qmi_uimi_client_state_type *)cl_sp)->common.clid);
  if (cb_userdata_ptr == NULL)
  {
    errval = QMI_ERR_NO_MEMORY;
    goto send_result;
  }

  if (uim_common_efs_get_file_size(UIM_COMMON_EFS_MMGSDI_MULTI_PROFILE_FILE,
                                   UIM_COMMON_EFS_CONTEXT_0,
                                   &file_size) == UIM_COMMON_EFS_SUCCESS)
  {
    multi_profile_config_present = TRUE;
  }

  /* If ATR says that card is eUICC or ERA-GLONASS config file is absent
     then it is not a ERA-GLONASS card. So, proceed with LPA handling */
  if (qmi_uim_is_euicc_card(tlv_data[0].data.slot.slot) ||
      tlv_data[0].data.slot.slot != MMGSDI_SLOT_1 ||
      multi_profile_config_present == FALSE)
  {
    /* If profile data is already available then send response from buffer
       otherwise send request to LPA. Check data for profile_index 0, if cache
       is available, then first entry should be valid */
    if (qmi_uim_global_ptr->qmi_uim_euicc_profile_data_ptr[slot_index][profile_index] == NULL)
    {
      errval = qmi_uim_convert_mmgsdi_slot_to_lpa_slot(tlv_data[0].data.slot.slot,
                                                       &lpa_slot);
      if (errval != QMI_ERR_NONE)
      {
        goto send_result;
      }

      cb_userdata_ptr->data.lpa.slot = tlv_data[0].data.slot.slot;

      lpa_status = lpa_get_profiles_info(lpa_slot,
                                         qmi_uimi_lpa_callback,
                                         cb_userdata_ptr);

      /* Convert LPA status in QMI code */
      errval = qmi_uim_convert_lpa_status_to_errval(lpa_status);
      if (errval == QMI_ERR_NONE)
      {
        response_pending = TRUE;
      }
    }
    else
    {
      lpa_get_profiles_info_resp_type *get_profiles_info_resp_ptr = NULL;

      get_profiles_info_resp_ptr = (lpa_get_profiles_info_resp_type *)uimqmi_malloc(sizeof(lpa_get_profiles_info_resp_type));
      if (get_profiles_info_resp_ptr == NULL)
      {
        errval = QMI_ERR_NO_MEMORY;
        goto send_result;
      }

      for (profile_index = 0; profile_index < QMI_UIM_PROFILES_MAX_V01; profile_index++)
      {
        if(qmi_uim_global_ptr->qmi_uim_euicc_profile_data_ptr[slot_index][profile_index] == NULL)
        {
          break;
        }
        get_profiles_info_resp_ptr->profile_info[profile_index] =
          qmi_uim_global_ptr->qmi_uim_euicc_profile_data_ptr[slot_index][profile_index]->profile_info;
        get_profiles_info_resp_ptr->num_profiles++;
      }

      /* Insert profile info TLV*/
      if (FALSE == qmi_uim_response_get_euicc_profile_info(
                              UIMI_TLV_RESP_TAG_OPTIONAL_1,
                              &response,
                              (const lpa_get_profiles_info_resp_type*)get_profiles_info_resp_ptr))
      {
        errval = QMI_ERR_NO_MEMORY;
        dsm_free_packet(&response);
      }
      uimqmi_free(get_profiles_info_resp_ptr);
    }
  }
  else
  {
    /* Execute MMGSDI function to get sim profile */
    mmgsdi_status = mmgsdi_get_sim_profile(
                      qmi_uim_global_ptr->mmgsdi_client_id,
                      tlv_data[0].data.slot.slot,
                      qmi_uimi_mmgsdi_callback,
                      (mmgsdi_client_data_type)cb_userdata_ptr );

    /* Convert MMGSDI status in QMI code */
    errval = qmi_uim_convert_mmgsdi_status_to_errval(mmgsdi_status);
    if (errval == QMI_ERR_NONE)
    {
      response_pending = TRUE;
    }
  }

  /* Free userdata in case of error */
  QMI_UIM_FREE_USERDATA_IF_ERROR(mmgsdi_status, cb_userdata_ptr);

send_result:
  qmi_uim_free_tlv_content(tlv_data, 1);

  if (response_pending)
  {
    return QMI_SVC_RESPONSE_PENDING;
  }
  /* Free userdata */
  qmi_uim_free_cb_userdata(cb_userdata_ptr);
  cb_userdata_ptr = NULL;

  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  CHECK_RETVAL();

  return response;
} /* qmi_uimi_get_sim_profile */


/*===========================================================================
  FUNCTION QMI_UIMI_SET_SIM_PROFILE()

  DESCRIPTION
    Switches the profile in the card

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_uimi_set_sim_profile
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type                  errval           = QMI_ERR_NONE;
  mmgsdi_return_enum_type           mmgsdi_status    = MMGSDI_SUCCESS;
  qmi_uimi_userdata_type*           cb_userdata_ptr  = NULL;
  qmi_uim_tlv_item_type             tlv_data[3];
  lpa_result_enum_type              lpa_status       = LPA_SUCCESS;
  lpa_slot_id_enum_type             lpa_slot         = LPA_SLOT_1;
  qmi_uim_euicc_profile_info_type  *profile_info_ptr = NULL;
  uint8                             slot_index       = 0;
  boolean                           multi_profile_config_present = FALSE;
  uint32                            file_size                    = 0;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);
  ASSERT(qmi_uim_global_ptr);

  memset(tlv_data, 0, sizeof(tlv_data));

  tlv_data[0].type      = UIMI_TLV_TYPE_SLOT;
  tlv_data[0].tag       = UIMI_TLV_TAG_MANDATORY_1;
  tlv_data[1].type      = UIMI_TLV_TYPE_PROFILE_ID;
  tlv_data[1].tag       = UIMI_TLV_TAG_MANDATORY_2;
  tlv_data[2].type      = UIMI_TLV_TYPE_SET_UNSET_PROFILE;
  tlv_data[2].tag       = UIMI_TLV_TAG_OPTIONAL_1;

  /* Parse TLV */
  errval = qmi_uim_parse_request(sdu_in, tlv_data, 3);
  if (errval != QMI_ERR_NONE)
  {
    UIM_MSG_HIGH_1("qmi_uimi_set_sim_profile: parse_request returned:0x%x", errval);
    goto send_result;
  }

  errval = uimqmi_mmgsdi_slot_to_slot_index(tlv_data[0].data.slot.slot,
                                            &slot_index);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

  if (uim_common_efs_get_file_size(UIM_COMMON_EFS_MMGSDI_MULTI_PROFILE_FILE,
                                   UIM_COMMON_EFS_CONTEXT_0,
                                   &file_size) == UIM_COMMON_EFS_SUCCESS)
  {
    multi_profile_config_present = TRUE;
  }

  /* If ATR says that card is eUICC or ERA-GLONASS config file is absent
     then it is not a ERA-GLONASS card. So, proceed with LPA handling */
  if (qmi_uim_is_euicc_card(tlv_data[0].data.slot.slot)||
      tlv_data[0].data.slot.slot != MMGSDI_SLOT_1 ||
      multi_profile_config_present == FALSE)
  {
    errval = qmi_uim_convert_mmgsdi_slot_to_lpa_slot(tlv_data[0].data.slot.slot,
                                                     &lpa_slot);
  if (errval != QMI_ERR_NONE)
  {
    goto send_result;
  }

    profile_info_ptr = qmi_uim_get_iccid_from_euicc_profile_id(tlv_data[1].data.sim_profile.profile_id,
                                                               tlv_data[0].data.slot.slot);
    if (profile_info_ptr == NULL)
    {
      errval = QMI_ERR_INVALID_ARG;
      goto send_result;
    }
  }

  /* Create userdata */
  cb_userdata_ptr = qmi_uim_get_cb_userdata(UIMI_CMD_VAL_SET_SIM_PROFILE,
                                            cmd_buf_p,
                                            NULL,
                                            ((qmi_uimi_client_state_type *)cl_sp)->common.clid);
  if (cb_userdata_ptr == NULL)
  {
    errval = QMI_ERR_NO_MEMORY;
    goto send_result;
  }

  /* If ATR says that card is eUICC or ERA-GLONASS config file is absent
     then it is not a ERA-GLONASS card. So, proceed with LPA handling */
  if ((qmi_uim_is_euicc_card(tlv_data[0].data.slot.slot)||
       tlv_data[0].data.slot.slot != MMGSDI_SLOT_1 ||
       multi_profile_config_present == FALSE) &&
      profile_info_ptr)
  {
    cb_userdata_ptr->data.lpa.slot = tlv_data[0].data.slot.slot;

    if (!tlv_data[2].present || tlv_data[2].data.set_unset_profile.value)
    {
      lpa_status = lpa_enable_profile(lpa_slot,
                                      profile_info_ptr->profile_info.iccid,
                                      qmi_uimi_lpa_callback,
                                      cb_userdata_ptr);
    }
    else
    {
      lpa_status = lpa_disable_profile(lpa_slot,
                                       profile_info_ptr->profile_info.iccid,
                                       qmi_uimi_lpa_callback,
                                       cb_userdata_ptr);
    }

    /* Convert LPA status in QMI code */
    errval = qmi_uim_convert_lpa_status_to_errval(lpa_status);
  
    /* Free userdata in case of error */
    QMI_UIM_LPA_FREE_USERDATA_IF_ERROR(lpa_status, cb_userdata_ptr);
  }
  else
  {
    /* Execute MMGSDI function to set SIM profile */
    mmgsdi_status = mmgsdi_set_sim_profile(
                      qmi_uim_global_ptr->mmgsdi_client_id,
                      tlv_data[0].data.slot.slot,
                      tlv_data[1].data.sim_profile.profile_id,
                      qmi_uimi_mmgsdi_callback,
                      (mmgsdi_client_data_type)cb_userdata_ptr);

    /* Convert MMGSDI status in QMI code */
    errval = qmi_uim_convert_mmgsdi_status_to_errval(mmgsdi_status);

    /* Free userdata in case of error */
    QMI_UIM_FREE_USERDATA_IF_ERROR(mmgsdi_status, cb_userdata_ptr);
  }

send_result:
  /* Free the buffer used for data */
  qmi_uim_free_tlv_content(tlv_data, 3);

  return qmi_uimi_populate_response(errval,
                                    FALSE,
                                    0,
                                    0);
} /* qmi_uimi_set_sim_profile */


/*===========================================================================

                             RESPONSE FUNCTIONS

===========================================================================*/


/*===========================================================================
  FUNCTION QMI_UIM_CLIENT_ID_EVT_REG_CONF()

  DESCRIPTION
    Handles the confirmation of client id and event registration command.

  PARAMETERS
    status            : status of MMGSDI operation
    client_id_cnf_ptr : result of MMGSDI operation

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    It's executed in the MMGSDI context, directly after the callback
===========================================================================*/
static void qmi_uim_client_id_evt_reg_conf
(
  mmgsdi_return_enum_type                       status,
  const mmgsdi_client_id_and_evt_reg_cnf_type * client_id_cnf_ptr
)
{
  uint8   i                 = 0;
  uint32  session_type_mask = 0;

  ASSERT(client_id_cnf_ptr);
  ASSERT(qmi_uim_global_ptr);

  if (status != MMGSDI_SUCCESS ||
      client_id_cnf_ptr->response_header.mmgsdi_status != MMGSDI_SUCCESS)
  {
    UIM_MSG_ERR_0("Error opening a MMGSDI client id");
    ASSERT(0);
  }

  /* Store the client id */
  qmi_uim_global_ptr->mmgsdi_client_id =
    client_id_cnf_ptr->response_header.client_id;

  /* Open the first 2 provisioning sessions, so they will be ready in short
     time. Use the userdata field to differentiate. Additional sessions
     will be opened in sequence to avoid flooding MMGSDI queue */

  /* Include masks of all the 6 types */
  session_type_mask = MMGSDI_GW_PROV_PRI_SESSION_MASK |
                      MMGSDI_GW_PROV_SEC_SESSION_MASK |
                      MMGSDI_GW_PROV_TER_SESSION_MASK |
                      MMGSDI_1X_PROV_PRI_SESSION_MASK |
                      MMGSDI_1X_PROV_SEC_SESSION_MASK |
                      MMGSDI_1X_PROV_TER_SESSION_MASK |
                      MMGSDI_CARD_SESSION_SLOT_1_MASK |
                      MMGSDI_CARD_SESSION_SLOT_2_MASK |
                      MMGSDI_CARD_SESSION_SLOT_3_MASK;

  status = mmgsdi_session_open_ext(
               qmi_uim_global_ptr->mmgsdi_client_id,
               session_type_mask,
               qmi_uim_mmgsdi_evt_cback,
               0,
               qmi_uimi_mmgsdi_callback,
               0);

  if (status != MMGSDI_SUCCESS)
  {
    UIM_MSG_ERR_1("Error opening sessions!! (0x%x)", status);

    for (i = 0; i < QMI_UIM_MAX_PROV_SESSIONS; i++)
    {
      qmi_uim_global_ptr->mmgsdi_gw_session_id[i]        = UIM_INVALID_SESSION_ID;
      qmi_uim_global_ptr->mmgsdi_1x_session_id[i]        = UIM_INVALID_SESSION_ID;
    }
    for (i = 0; i < QMI_UIM_MAX_CARD_SESSIONS; i++)
    {
      qmi_uim_global_ptr->mmgsdi_card_slot_session_id[i] = UIM_INVALID_SESSION_ID;
    }
  }
} /* qmi_uim_client_id_evt_reg_conf */


/*===========================================================================
  FUNCTION QMI_UIM_CLIENT_OPEN_SESSION_IMPLICIT_CONF()

  DESCRIPTION
    Handles the confirmation of open session command for the non provisioning
    sessions open by default by QMI UIM when an operation on these sessions
    is required (for example, file access).

  PARAMETERS
    status               : status of MMGSDI operation
    session_type         : session type
    index                : index in the array of non provisioning sessions
    session_id           : MMGSDI session id

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_client_open_session_implicit_conf
(
  mmgsdi_return_enum_type              status,
  mmgsdi_session_type_enum_type        session_type,
  uint8                                index,
  mmgsdi_session_id_type               session_id
)
{
  ASSERT(qmi_uim_global_ptr);

  if (session_type != MMGSDI_NON_PROV_SESSION_SLOT_1 &&
      session_type != MMGSDI_NON_PROV_SESSION_SLOT_2 &&
      session_type != MMGSDI_NON_PROV_SESSION_SLOT_3)
  {
    UIM_MSG_ERR_1("Invalid session type (0x%x) for implicit type",
                  session_type);
    return;
  }

  ASSERT(index < UIM_MAX_NON_PROV_SESSIONS);

  if (!qmi_uim_global_ptr->non_prov_session[index].init ||
      qmi_uim_global_ptr->non_prov_session[index].session_type != session_type)
  {
    UIM_MSG_ERR_1("Non-provisioning session not initialized for index 0x%x",
                  index);
    return;
  }

  if (status == MMGSDI_SUCCESS)
  {
    /* Store the session id */
    qmi_uim_global_ptr->non_prov_session[index].mmgsdi_session_id = session_id;

    /* Request the PIN status only if this application is one of the
       applications in the global applications list */
    if (qmi_uim_global_ptr->non_prov_session[index].aid.data_len > 0)
    {
      mmgsdi_aid_type          aid_value = { MMGSDI_APP_NONE };
      mmgsdi_slot_id_enum_type slot      = MMGSDI_SLOT_1;
      uint16                   app_index = UIM_INVALID_APP_INDEX;
      qmi_error_e_type         errval    = QMI_ERR_NONE;

      aid_value.app_type = MMGSDI_APP_UNKNOWN;

      (void)memscpy(&aid_value.aid,
                    sizeof(mmgsdi_static_data_type),
                    &qmi_uim_global_ptr->non_prov_session[index].aid,
                    sizeof(mmgsdi_static_data_type));

      /* Retrieve the slot */
      errval = qmi_uim_session_id_to_slot(&slot, session_id);
      if (errval == QMI_ERR_NONE)
      {
        app_index = qmi_uim_find_aid(&aid_value, slot);
        if (app_index != UIM_INVALID_APP_INDEX)
        {
          /* Get pin status from MMGSDI */
          status = mmgsdi_session_get_all_pin_status(
                                     session_id,
                                     qmi_uimi_mmgsdi_callback,
                                     (mmgsdi_client_data_type)NULL );
          if (status != MMGSDI_SUCCESS)
          {
            UIM_MSG_ERR_1("Error: mmgsdi_session_get_all_pin_status,0x%x",
                          status);
          }
        }
      }
    }

    /* Execute all pending requests */
    qmi_uim_execute_all_pending_requests(session_id, TRUE);
  }
  else
  {
    /* Use a fake session id */
    qmi_uim_global_ptr->non_prov_session[index].mmgsdi_session_id = UIM_FAKE_SESSION_ID;

    /* Remove non provisioning session.
       QMI_UIM_SESSION_CLOSED_IND shall not be sent out since the session
       clean-up was not trigerred by an MMGSDI_SESSION_CLOSE_EVT */
    qmi_uim_remove_non_provisioning_session(UIM_FAKE_SESSION_ID, FALSE,
                                            MMGSDI_SESSION_CLOSED_CAUSE_UNKNOWN);
  }
} /* qmi_uim_client_open_session_implicit_conf */


/*===========================================================================
  FUNCTION QMI_UIM_CLIENT_OPEN_SESSION_APDU_CONF()

  DESCRIPTION
    Handles the confirmation of open session command related to
    logical channel operations

  PARAMETERS
    status               : status of MMGSDI operation
    index                : index of the APDU channel array
    open_session_cnf_ptr : result of MMGSDI operation
    clid                 : Client ID
    client_reg_count     : Total number of registered clients
    cmd_buf_p            : Pointer to the original command  buffer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_client_open_session_apdu_conf
(
  mmgsdi_return_enum_type                           status,
  uint8                                             index,
  const mmgsdi_session_open_with_sel_rsp_cnf_type * open_session_cnf_ptr,
  uint8                                             clid,
  uint32                                            client_reg_count,
  qmi_cmd_buf_type                                * cmd_buf_p
)
{
  dsm_item_type *          response        = NULL;
  qmi_error_e_type         errval          = QMI_ERR_NONE;
  qmi_result_e_type        result          = QMI_RESULT_SUCCESS;
  boolean                  retval          = TRUE;

  ASSERT(open_session_cnf_ptr);
  ASSERT(qmi_uim_global_ptr);
  ASSERT(index < UIM_MAX_APDU_CHANNEL_COUNT);

  if (!qmi_uim_global_ptr->apdu_channel[index] ||
      qmi_uim_global_ptr->apdu_channel[index]->mmgsdi_session_id !=
        UIM_INVALID_SESSION_ID)
  {
    UIM_MSG_ERR_1("Non-provisioning session not initialized for index 0x%x",
                  index);
    return;
  }

  if (cmd_buf_p == NULL)
  {
    UIM_MSG_HIGH_0("Null cmd_buf ptr in response");
    uimqmi_free(qmi_uim_global_ptr->apdu_channel[index]);
    qmi_uim_global_ptr->apdu_channel[index] = NULL;
    return;
  }

  /* Check if the requested client is still valid */
  if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
  {
    UIM_MSG_HIGH_0("Invalid Client, not sending response");
    uimqmi_free(qmi_uim_global_ptr->apdu_channel[index]);
    qmi_uim_global_ptr->apdu_channel[index] = NULL;
    return;
  }

  /* Validate the SP in command buffer */
  if (cmd_buf_p->x_p == NULL || cmd_buf_p->x_p->cl_sp == NULL)
  {
    UIM_MSG_HIGH_0("Transaction ptr or client state pointer is NULL");
    uimqmi_free(qmi_uim_global_ptr->apdu_channel[index]);
    qmi_uim_global_ptr->apdu_channel[index] = NULL;
    return;
  }

  if (status == MMGSDI_SUCCESS)
  {
    UIM_MSG_HIGH_0("Session open to app for APDU transaction");

    qmi_uim_global_ptr->apdu_channel[index]->mmgsdi_session_id =
      open_session_cnf_ptr->session_id;
    qmi_uim_global_ptr->apdu_channel[index]->logical_channel   =
      (uint8)open_session_cnf_ptr->channel_id;

    /* It is possible that the original open channel request was sent
       with a partial AID to MMGSDI. If the open channel request was
       sent expecting a FCP response in the session open response,
       and a non-zero AID is present in the response, update the
       AID for the index */
    if (open_session_cnf_ptr->select_rsp_type == MMGSDI_SELECT_RSP_FCP &&
        open_session_cnf_ptr->app_info.aid.data_len > 0 &&
        open_session_cnf_ptr->app_info.aid.data_len < MMGSDI_MAX_AID_LEN)
    {
      (void)memscpy(&qmi_uim_global_ptr->apdu_channel[index]->aid,
                    sizeof(qmi_uim_global_ptr->apdu_channel[index]->aid),
                    &open_session_cnf_ptr->app_info.aid,
                    sizeof(open_session_cnf_ptr->app_info.aid));
    }

    if (FALSE == qmi_uim_response_logical_channel(
                   UIMI_TLV_RESP_TAG_OPTIONAL_1,
                   &response,
                   (uint8)open_session_cnf_ptr->channel_id))
    {
      errval = QMI_ERR_NO_MEMORY;
      dsm_free_packet(&response);
      goto send_result;
    }

    if (FALSE == qmi_uim_response_card_result(
                   UIMI_TLV_RESP_TAG_OPTIONAL_2,
                   &response,
                   open_session_cnf_ptr->response_header.status_word))
    {
      errval = QMI_ERR_NO_MEMORY;
      dsm_free_packet(&response);
      goto send_result;
    }

    if (FALSE == qmi_uim_response_generic_payload_8bit(
                   UIMI_TLV_RESP_TAG_OPTIONAL_3,
                   &response,
                   open_session_cnf_ptr->select_rsp,
                   FALSE))
    {
      errval = QMI_ERR_NO_MEMORY;
      dsm_free_packet(&response);
    }
  }
  else
  {
    /* Free the item in the table */
    uimqmi_free(qmi_uim_global_ptr->apdu_channel[index]);
    qmi_uim_global_ptr->apdu_channel[index] = NULL;

    UIM_MSG_ERR_3("Session open failure, status=0x%x, sw1=0x%x, sw2=0x%x",
                  status,
                  open_session_cnf_ptr->response_header.status_word.sw1,
                  open_session_cnf_ptr->response_header.status_word.sw2);

    if (status == MMGSDI_SELECT_AID_FAILED)
    {
      UIM_MSG_ERR_0("Session open failed due to SELECT AID failure");

      errval = QMI_ERR_SIM_FILE_NOT_FOUND;

      if (FALSE == qmi_uim_response_card_result(
                     UIMI_TLV_RESP_TAG_OPTIONAL_2,
                     &response,
                     open_session_cnf_ptr->response_header.status_word))
      {
        errval = QMI_ERR_NO_MEMORY;
        dsm_free_packet(&response);
      }
    }
    else if (status == MMGSDI_MANAGE_CHANNEL_FAILED)
    {
      UIM_MSG_ERR_0("Session open failed due to MANAGE CHANNEL failure");

      errval = QMI_ERR_INSUFFICIENT_RESOURCES;

      if (FALSE == qmi_uim_response_card_result(
                     UIMI_TLV_RESP_TAG_OPTIONAL_2,
                     &response,
                     open_session_cnf_ptr->response_header.status_word))
      {
        errval = QMI_ERR_NO_MEMORY;
        dsm_free_packet(&response);
      }
    }
    else if (status == MMGSDI_APP_NOT_SHAREABLE)
    {
      UIM_MSG_ERR_0("Session open failed because app is not shareable");

      errval = QMI_ERR_INCOMPATIBLE_STATE;

      if (FALSE == qmi_uim_response_card_result(
                     UIMI_TLV_RESP_TAG_OPTIONAL_2,
                     &response,
                     open_session_cnf_ptr->response_header.status_word))
      {
        errval = QMI_ERR_NO_MEMORY;
        dsm_free_packet(&response);
      }
    }
    else
    {
      errval = QMI_ERR_INTERNAL;
    }
  }

send_result:
  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    ds_qmi_fw_free_cmd_buf( &cmd_buf_p );
    return;
  }

  /* Send response */
  if (FALSE == qmi_uimi_send_response(cmd_buf_p,
                                      response))
  {
    UIM_MSG_HIGH_0("Unable to send response for open session operation");
    dsm_free_packet(&response);
  }
} /* qmi_uim_client_open_session_apdu_conf */


/*===========================================================================
  FUNCTION QMI_UIM_CLIENT_OPEN_SESSION_WITH_SELECT_RSP_CONF()

  DESCRIPTION
    Handles the confirmation of open session command related to
    logical channel operations

  PARAMETERS
    status               : status of MMGSDI operation
    open_session_cnf_ptr : result of MMGSDI operation

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_client_open_session_with_select_rsp_conf
(
  mmgsdi_return_enum_type                           status,
  const mmgsdi_session_open_with_sel_rsp_cnf_type * open_session_cnf_ptr
)
{
  uint8                          index             = 0;
  uint8                          session_open_type = 0;
  uint8                          clid              = QMI_SVC_CLID_UNUSED;
  uint32                         client_reg_count  = 0;
  qmi_cmd_buf_type *             cmd_buf_p         = NULL;
  qmi_uimi_userdata_type       * cb_userdata_ptr   = NULL;
  mmgsdi_session_type_enum_type  session_type      = MMGSDI_MAX_SESSION_TYPE_ENUM;

  ASSERT(open_session_cnf_ptr);

  /* Retrieve userdata */
  cb_userdata_ptr =
    (qmi_uimi_userdata_type*)open_session_cnf_ptr->response_header.client_data;
  if (cb_userdata_ptr == NULL)
  {
    UIM_MSG_HIGH_0("Null userdata ptr in response");
    return;
  }

  /* Retrieve info */
  clid              = cb_userdata_ptr->clid;
  client_reg_count  = cb_userdata_ptr->client_reg_count;
  cmd_buf_p         = cb_userdata_ptr->cmd_buf_ptr;
  index             = cb_userdata_ptr->data.session_open_request.channel_index;
  session_open_type = cb_userdata_ptr->data.session_open_request.session_open_type;
  session_type      = cb_userdata_ptr->data.session_open_request.session_type;

  /* Free userdata */
  qmi_uim_free_cb_userdata(cb_userdata_ptr);
  cb_userdata_ptr = NULL;

  UIM_MSG_HIGH_3("Open session with select rsp conf: status = 0x%x, open type = 0x%x, index = 0x%x",
                 status, session_open_type, index);

  switch(session_open_type)
  {
    case UIM_SESSION_OPEN_IMPLICIT:
      qmi_uim_client_open_session_implicit_conf(status,
                                                session_type,
                                                index,
                                                open_session_cnf_ptr->session_id);
      break;

    case UIM_SESSION_OPEN_APDU:
      qmi_uim_client_open_session_apdu_conf(status,
                                            index,
                                            open_session_cnf_ptr,
                                            clid,
                                            client_reg_count,
                                            cmd_buf_p);
      break;

    default:
      UIM_MSG_ERR_1("Invalid session open type = 0x%x", session_open_type);
      break;
  }
} /* qmi_uim_client_open_session_with_select_rsp_conf */


/*===========================================================================
  FUNCTION QMI_UIM_CLIENT_OPEN_SESSION_EXT_CONF()

  DESCRIPTION
    Handles the confirmation of open session ext command.

  PARAMETERS
    status                   : status of MMGSDI operation
    open_session_ext_cnf_ptr : result of MMGSDI operation

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_client_open_session_ext_conf
(
  mmgsdi_return_enum_type                  status,
  const mmgsdi_session_open_ext_cnf_type * open_session_ext_cnf_ptr
)
{
  uint8 index = 0;

  ASSERT(open_session_ext_cnf_ptr);

  if (status != MMGSDI_SUCCESS ||
      open_session_ext_cnf_ptr->response_header.mmgsdi_status != MMGSDI_SUCCESS)
  {
    UIM_MSG_ERR_1("Error opening MMGSDI session ids, status = 0x%x", status);
    return;
  }

  if (open_session_ext_cnf_ptr->session_info_ptr == NULL)
  {
    UIM_MSG_ERR_0("NULL session_info_ptr, not updating");
    return;
  }

  /* Store the session id that were opened */
  for (index = 0; index < open_session_ext_cnf_ptr->num_sessions; index++)
  {
    mmgsdi_session_type_enum_type session_type =
      open_session_ext_cnf_ptr->session_info_ptr[index].session_type;
    mmgsdi_session_id_type session_id =
      open_session_ext_cnf_ptr->session_info_ptr[index].session_id;

    switch (session_type)
    {
      case MMGSDI_GW_PROV_PRI_SESSION:
        qmi_uim_global_ptr->mmgsdi_gw_session_id[0] = session_id;
        break;

      case MMGSDI_1X_PROV_PRI_SESSION:
        qmi_uim_global_ptr->mmgsdi_1x_session_id[0] = session_id;
        break;

      case MMGSDI_GW_PROV_SEC_SESSION:
        qmi_uim_global_ptr->mmgsdi_gw_session_id[1] = session_id;
        break;

      case MMGSDI_1X_PROV_SEC_SESSION:
        qmi_uim_global_ptr->mmgsdi_1x_session_id[1] = session_id;
        break;

      case MMGSDI_GW_PROV_TER_SESSION:
        qmi_uim_global_ptr->mmgsdi_gw_session_id[2] = session_id;
        break;

      case MMGSDI_1X_PROV_TER_SESSION:
        qmi_uim_global_ptr->mmgsdi_1x_session_id[2] = session_id;
        break;

      case MMGSDI_CARD_SESSION_SLOT_1:
        qmi_uim_global_ptr->mmgsdi_card_slot_session_id[0] = session_id;
        break;

      case MMGSDI_CARD_SESSION_SLOT_2:
        qmi_uim_global_ptr->mmgsdi_card_slot_session_id[1] = session_id;
        break;

      case MMGSDI_CARD_SESSION_SLOT_3:
        qmi_uim_global_ptr->mmgsdi_card_slot_session_id[2] = session_id;
        break;

      default:
        UIM_MSG_ERR_1("Invalid session type (0x%x)", session_type);
        break;
    }
  }

  /* Send indication to clients if it was postponed earlier */
  qmi_uim_send_card_status_indication_to_all(TRUE, TRUE, TRUE);
} /* qmi_uim_client_open_session_ext_conf */


/*===========================================================================
  FUNCTION QMI_UIM_CLIENT_OPEN_SESSION_WITH_MF_CONF()

  DESCRIPTION
    Handles the confirmation of open session with MF command.

  PARAMETERS
    status                  : status of MMGSDI operation
    open_session_mf_cnf_ptr : result of MMGSDI operation

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_client_open_session_with_mf_conf
(
  mmgsdi_return_enum_type                      status,
  const mmgsdi_session_open_with_mf_cnf_type * open_session_mf_cnf_ptr
)
{
  uint8                         index             = 0;
  qmi_cmd_buf_type *            cmd_buf_p         = NULL;
  dsm_item_type *               response          = NULL;
  qmi_error_e_type              errval            = QMI_ERR_NONE;
  qmi_result_e_type             result            = QMI_RESULT_SUCCESS;
  boolean                       retval            = TRUE;
  uint8                         clid              = QMI_SVC_CLID_UNUSED;
  uint32                        client_reg_count  = 0;
  qmi_uimi_userdata_type      * cb_userdata_ptr   = NULL;

  ASSERT(open_session_mf_cnf_ptr);
  ASSERT(qmi_uim_global_ptr);

  if (status != MMGSDI_SUCCESS)
  {
    UIM_MSG_ERR_1("Error opening a MMGSDI session id, type = 0x%x",
                  open_session_mf_cnf_ptr->response_header.client_data);
  }

  /* Retrieve userdata */
  cb_userdata_ptr =
    (qmi_uimi_userdata_type*)open_session_mf_cnf_ptr->response_header.client_data;
  if (cb_userdata_ptr == NULL)
  {
    UIM_MSG_HIGH_0("Null userdata ptr in response");
    return;
  }

  /* Retrieve info */
  clid             = cb_userdata_ptr->clid;
  client_reg_count = cb_userdata_ptr->client_reg_count;
  cmd_buf_p        = cb_userdata_ptr->cmd_buf_ptr;
  index            = cb_userdata_ptr->data.session_open_request.channel_index;

  /* Free userdata */
  qmi_uim_free_cb_userdata(cb_userdata_ptr);
  cb_userdata_ptr = NULL;

  UIM_MSG_HIGH_1("Open confirmation: index = 0x%x", index);

  ASSERT(index < UIM_MAX_APDU_CHANNEL_COUNT);

  if (!qmi_uim_global_ptr->apdu_channel[index] ||
       qmi_uim_global_ptr->apdu_channel[index]->mmgsdi_session_id != UIM_INVALID_SESSION_ID)
  {
    UIM_MSG_ERR_1("Non-provisioning session not initialized for index 0x%x",
                  index);
    return;
  }

  if (cmd_buf_p == NULL)
  {
    UIM_MSG_HIGH_0("Null cmd_buf ptr in response");
    uimqmi_free(qmi_uim_global_ptr->apdu_channel[index]);
    qmi_uim_global_ptr->apdu_channel[index] = NULL;
    return;
  }

  /* Check if the requested client is still valid */
  if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
  {
    UIM_MSG_HIGH_0("Invalid Client, not sending indication or response");
    uimqmi_free(qmi_uim_global_ptr->apdu_channel[index]);
    qmi_uim_global_ptr->apdu_channel[index] = NULL;
    return;
  }

  /* Validate the SP in command buffer */
  if (cmd_buf_p->x_p == NULL || cmd_buf_p->x_p->cl_sp == NULL)
  {
    UIM_MSG_HIGH_0("Transaction ptr or client state pointer is NULL");
    uimqmi_free(qmi_uim_global_ptr->apdu_channel[index]);
    qmi_uim_global_ptr->apdu_channel[index] = NULL;
    return;
  }

  if (status == MMGSDI_SUCCESS)
  {
    UIM_MSG_HIGH_0("Session open to MF for APDU transaction");

    qmi_uim_global_ptr->apdu_channel[index]->mmgsdi_session_id = open_session_mf_cnf_ptr->session_id;
    qmi_uim_global_ptr->apdu_channel[index]->logical_channel   = (uint8)open_session_mf_cnf_ptr->channel_id;

    if (FALSE == qmi_uim_response_logical_channel(
                   UIMI_TLV_RESP_TAG_OPTIONAL_1,
                   &response,
                   (uint8)open_session_mf_cnf_ptr->channel_id))
    {
      errval = QMI_ERR_NO_MEMORY;
      dsm_free_packet(&response);
      goto send_result;
    }

    if (FALSE == qmi_uim_response_card_result(
                   UIMI_TLV_RESP_TAG_OPTIONAL_2,
                   &response,
                   open_session_mf_cnf_ptr->response_header.status_word))
    {
      errval = QMI_ERR_NO_MEMORY;
      dsm_free_packet(&response);
    }
  }
  else
  {
    /* Free the item in the table */
    uimqmi_free(qmi_uim_global_ptr->apdu_channel[index]);
    qmi_uim_global_ptr->apdu_channel[index] = NULL;

    UIM_MSG_ERR_3("Session open failure, status=0x%x, sw1=0x%x, sw2=0x%x",
                  status,
                  open_session_mf_cnf_ptr->response_header.status_word.sw1,
                  open_session_mf_cnf_ptr->response_header.status_word.sw2);

    if (status == MMGSDI_MANAGE_CHANNEL_FAILED)
    {
      UIM_MSG_ERR_0("Session open failed due to MANAGE CHANNEL failure");
      errval = QMI_ERR_INSUFFICIENT_RESOURCES;
      if (FALSE == qmi_uim_response_card_result(
                     UIMI_TLV_RESP_TAG_OPTIONAL_2,
                     &response,
                     open_session_mf_cnf_ptr->response_header.status_word))
      {
        errval = QMI_ERR_NO_MEMORY;
        dsm_free_packet(&response);
      }
    }
    else
    {
      errval = QMI_ERR_INTERNAL;
    }
  }

  send_result:
    /* Insert result item in the TLV */
    result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                     : QMI_RESULT_FAILURE);
    retval = qmi_svc_put_result_tlv(&response, result, errval);
    if (FALSE == retval)
    {
      dsm_free_packet(&response);
      ds_qmi_fw_free_cmd_buf( &cmd_buf_p );
      return;
    }

    /* Send response */
    if (FALSE == qmi_uimi_send_response(cmd_buf_p,
                                        response))
    {
      UIM_MSG_HIGH_0("Unable to send response for open session operation");
      dsm_free_packet(&response);
    }
} /* qmi_uim_client_open_session_with_mf_conf */


/*===========================================================================
  FUNCTION QMI_UIM_CLIENT_CLOSE_SESSION_RESP()

  DESCRIPTION
    Handles the confirmation of close session command.

  PARAMETERS
    status                : status of MMGSDI operation
    close_session_cnf_ptr : result of MMGSDI operation

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_client_close_session_resp
(
  mmgsdi_return_enum_type               status,
  const mmgsdi_session_close_cnf_type * close_session_cnf_ptr
)
{
  qmi_cmd_buf_type *         cmd_buf_p        = NULL;
  dsm_item_type *            response         = NULL;
  qmi_error_e_type           errval           = QMI_ERR_NONE;
  qmi_result_e_type          result           = QMI_RESULT_SUCCESS;
  boolean                    retval           = TRUE;
  uint8                      index            = 0;
  uint8                      clid             = QMI_SVC_CLID_UNUSED;
  uint32                     client_reg_count = 0;
  qmi_uimi_userdata_type   * cb_userdata_ptr  = NULL;

  ASSERT( qmi_uim_global_ptr );
  ASSERT( close_session_cnf_ptr );

  UIM_MSG_HIGH_1("Session close confirmation. Status = 0x%x", status);

  /* Retrieve userdata */
  cb_userdata_ptr =
    (qmi_uimi_userdata_type*)close_session_cnf_ptr->response_header.client_data;
  if (cb_userdata_ptr == NULL)
  {
    UIM_MSG_HIGH_0("Null userdata ptr in response");
    return;
  }

  /* Retrieve info */
  clid             = cb_userdata_ptr->clid;
  client_reg_count = cb_userdata_ptr->client_reg_count;
  cmd_buf_p        = cb_userdata_ptr->cmd_buf_ptr;
  index            = cb_userdata_ptr->data.session_close_request.channel_index;

  /* Free userdata */
  qmi_uim_free_cb_userdata(cb_userdata_ptr);
  cb_userdata_ptr = NULL;

  /* Check the close channel indication preference set in NV */
  if(qmi_uim_global_ptr->close_channel_sync)
  {
    /* No need to do any processing on the close CNF because
       response to application was sent synchronously */
    return;
  }

  ASSERT(index < UIM_MAX_APDU_CHANNEL_COUNT);

  if (cmd_buf_p == NULL)
  {
    UIM_MSG_HIGH_0("Null cmd_buf ptr in response");
    return;
  }

  /* Check if the requested client is still valid */
  if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
  {
    UIM_MSG_HIGH_0("Invalid Client, not sending indication or response");
    return;
  }

  QMI_UIM_VALIDATE_SP_IN_CMD_BUF(cmd_buf_p);

  if (status != MMGSDI_SUCCESS)
  {
    /* Convert MMGSDI into QMI error code */
    errval = qmi_uim_convert_mmgsdi_status_to_errval(status);
  }

  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    ds_qmi_fw_free_cmd_buf( &cmd_buf_p );
    return;
  }

  /* Send response */
  if (FALSE == qmi_uimi_send_response(cmd_buf_p,
                                      response))
  {
    UIM_MSG_HIGH_0("Unable to send response for open session operation");
    dsm_free_packet(&response);
  }

  /* Free the information in the table and send the
     indication */
  if (qmi_uim_global_ptr->apdu_channel[index] != NULL &&
      qmi_uim_global_ptr->apdu_channel[index]->mmgsdi_session_id != UIM_INVALID_SESSION_ID)
  {
    qmi_uim_remove_apdu_session(
              qmi_uim_global_ptr->apdu_channel[index]->mmgsdi_session_id, TRUE,
              MMGSDI_SESSION_CLOSED_CAUSE_CLIENT_REQUEST);
  }
  else
  {
    UIM_MSG_ERR_1("Non-provisioning session not initialized for index 0x%x",
                  index);
  }
} /* qmi_uim_client_close_session_resp */


/*===========================================================================
  FUNCTION QMI_UIMI_READ_ADDITIONAL_RECORDS()

  DESCRIPTION
    Checks if additional records need to be read and, in case, starts
    reading the next record.

  PARAMETERS
    cb_userdata_ptr : userdata (already extracted from confirmation)
    status          : status of MMGSDI operation
    read_cnf_ptr    : result of MMGSDI operation

  RETURN VALUE
    qmi_error_e_type: error code for the result of reading additional
                      records

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uimi_read_additional_records
(
  qmi_uimi_userdata_type     * cb_userdata_ptr,
  mmgsdi_return_enum_type      status,
  const mmgsdi_read_cnf_type * read_cnf_ptr
)
{
  uint16                   index          = 0;
  uint32                   total_read_len = 0;
  mmgsdi_return_enum_type  mmgsdi_status  = MMGSDI_SUCCESS;

  UIM_MSG_HIGH_0("Read additional records");

  ASSERT( read_cnf_ptr );
  ASSERT( cb_userdata_ptr );
  ASSERT( cb_userdata_ptr->data.read_record.records_cnf );

  if (cb_userdata_ptr->data.read_record.read_records >=
      cb_userdata_ptr->data.read_record.total_records)
  {
    UIM_MSG_ERR_0("Too many records were read");
    return QMI_ERR_INTERNAL;
  }

  index = cb_userdata_ptr->data.read_record.read_records;

  /* Store the current record */
  cb_userdata_ptr->data.read_record.records_cnf[index].mmgsdi_status = status;
  cb_userdata_ptr->data.read_record.records_cnf[index].status_word =
    read_cnf_ptr->response_header.status_word;
  if (status == MMGSDI_SUCCESS)
  {
    cb_userdata_ptr->data.read_record.records_cnf[index].read_data.data_len =
      read_cnf_ptr->read_data.data_len;
    qmi_uim_deep_copy(
      (void**)&cb_userdata_ptr->data.read_record.records_cnf[index].read_data.data_ptr,
      (void*)read_cnf_ptr->read_data.data_ptr,
      (uint32)read_cnf_ptr->read_data.data_len);
  }

  /* Increase number of read records */
  cb_userdata_ptr->data.read_record.read_records++;

  /* We need to abort further record reads if read length exceeds max allocated per IDL */
  total_read_len = (cb_userdata_ptr->data.read_record.total_records - 1) *
                     read_cnf_ptr->read_data.data_len;
  if (total_read_len > QMI_UIM_READ_ADDITIONAL_RECORDS_MAX_LEN)
  {
    UIM_MSG_ERR_1("Total length of record read request exceeds defined: 0x%x",
                  total_read_len);
    return QMI_ERR_INSUFFICIENT_RESOURCES;
  }

  /* Start reading the next record, if needed */
  if (status == MMGSDI_SUCCESS &&
      cb_userdata_ptr->data.read_record.read_records <
      cb_userdata_ptr->data.read_record.total_records)
  {
    mmgsdi_rec_num_type next_record = cb_userdata_ptr->data.read_record.first_record +
                                      cb_userdata_ptr->data.read_record.read_records;

    UIM_MSG_HIGH_1("Ready to read the next record: 0x%x", next_record);

    /* Start a new read */
    mmgsdi_status = mmgsdi_session_read_record(
                          read_cnf_ptr->response_header.session_id,
                          cb_userdata_ptr->data.read_record.file_access,
                          next_record,
                          read_cnf_ptr->read_data.data_len,
                          qmi_uimi_mmgsdi_callback,
                          (mmgsdi_client_data_type)cb_userdata_ptr );

    /* In case of success, return */
    if (mmgsdi_status == MMGSDI_SUCCESS)
    {
      return QMI_ERR_NONE;
    }
    UIM_MSG_ERR_0("Error to read next record");
  }

  return QMI_ERR_INTERNAL;
} /* qmi_uimi_read_additional_records */


/*===========================================================================
  FUNCTION  QMI_UIM_SEND_LONG_READ_IND()

  DESCRIPTION
    Responsible for sending the read transparent long indications.

  PARAMETERS
    clid                : Client ID
    encrypted           : Pointer to output encrypted message
    status_word         : Status word bytes
    read_data           : Read data from MMGSDI

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_send_long_read_ind
(
  uint8                              clid,
  qmi_uim_requested_encrytion_type   encryption_status,
  mmgsdi_sw_type                     status_word,
  mmgsdi_data_type                   in_read_data
)
{
  uint16                i                   = 0;
  uint16                offset              = 0;
  uint16                num_of_chunks       = 0;
  uint16                total_len           = 0;
  boolean               needs_encryption    = FALSE;
  mmgsdi_data_type      encrypted_read_data = { 0, NULL };

  if ((in_read_data.data_len == 0) || (in_read_data.data_ptr == NULL))
  {
    return;
  }

  /* Encrypt the data if needs to be */
  if (encryption_status == QMI_UIM_DATA_ONLY_ENCRYPTION)
  {
    needs_encryption = qmi_uim_encrypt_payload(in_read_data,
                                               &encrypted_read_data);
  }
  else if (encryption_status == QMI_UIM_COMPLETE_ENCRYPTION)
  {
    UIM_MSG_HIGH_0("Complete read encryption is not supported for long read indications");
    return;
  }

  /* Update total length & calculate number of chunks needed */
  total_len     = needs_encryption ? (uint16)encrypted_read_data.data_len :
                    (uint16)in_read_data.data_len;
  num_of_chunks = (total_len - 1) / QMI_UIM_READ_TRANSPARENT_MAX_LEN + 1;

  /* Send one chunk of read response per indication until entire data is sent */
  for (i = 0; i < num_of_chunks && offset < total_len; i++)
  {
    dsm_item_type         * indication = NULL;
    mmgsdi_data_type        read_data  = { 0, NULL };

    /* Update data pointer & length that is used for the chunk */
    read_data.data_ptr = offset +
      (needs_encryption ? encrypted_read_data.data_ptr : in_read_data.data_ptr);
    read_data.data_len = ((total_len - offset) > QMI_UIM_READ_TRANSPARENT_MAX_LEN) ?
                           QMI_UIM_READ_TRANSPARENT_MAX_LEN : (total_len - offset) ;

    UIM_MSG_HIGH_3("Sending read transparent in Long Indication, chunk[0x%x], offset: 0x%x, data_len: 0x%x",
                   i, offset, read_data.data_len);

    /* Construct the TLVs - Long response chunk TLV, card result TLV &
       Encryption TLV */
    if ((FALSE == qmi_uim_response_long_response_chunk(
                    UIMI_TLV_TAG_MANDATORY_1,
                    &indication,
                    qmi_uim_global_ptr->long_read_response_token,
                    total_len,
                    offset,
                    read_data)) ||
        (FALSE == qmi_uim_response_card_result(
                    UIMI_TLV_RESP_TAG_OPTIONAL_1,
                    &indication,
                    status_word)) ||
        (needs_encryption && (FALSE == qmi_uim_response_boolean(
                                         UIMI_TLV_RESP_TAG_OPTIONAL_2,
                                         &indication,
                                         TRUE))))
    {
      /* Clean up allocated buffers & return */
      UIM_MSG_HIGH_0("Unable to construct TLVs");
      dsm_free_packet(&indication);
      break;
    }

    /* Send indication to the client */
    if (FALSE == qmi_uimi_send_indication(clid,
                                          (uint16)UIMI_CMD_VAL_READ_TRANSPARENT_LONG_IND,
                                          indication))
    {
      UIM_MSG_HIGH_0("Unable to send indication for read transparent");
      dsm_free_packet(&indication);
    }

    /* Jump to the next chunk */
    offset += read_data.data_len;
  }

  /* Clean up encrypted buffer if allocated */
  if (encrypted_read_data.data_ptr)
  {
    uimqmi_free(encrypted_read_data.data_ptr);
    encrypted_read_data.data_ptr = NULL;
  }
} /* qmi_uim_send_long_read_ind */


/*===========================================================================
  FUNCTION  QMI_UIM_ENCRYPT_READ_RSP()

  DESCRIPTION
    Encrypts a read resp using Trust Zone application APIs

  PARAMETERS
    read_data     : The data to be encrypted
    resposne_pptr : Pointer to command response pointer

  RETURN VALUE
    errval        : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_encrypt_read_rsp
(
  mmgsdi_data_type         read_data,
  dsm_item_type         ** response_pptr,
  boolean                  is_indication
)
{
  boolean               encryption_used     = TRUE;
  mmgsdi_data_type      encrypted_read_data = { 0, NULL };
  qmi_error_e_type      errval              = QMI_ERR_NONE;

  encryption_used = qmi_uim_encrypt_payload(read_data,
                                            &encrypted_read_data);

  if (FALSE == qmi_uim_response_generic_payload_16bit(
                 UIMI_TLV_RESP_TAG_OPTIONAL_2,
                 response_pptr,
                 encryption_used ? encrypted_read_data : read_data,
                 TRUE) ||
      FALSE == qmi_uim_response_boolean(
                is_indication ? UIMI_TLV_RESP_TAG_OPTIONAL_3 : UIMI_TLV_RESP_TAG_OPTIONAL_4,
                response_pptr,
                encryption_used))
  {
    dsm_free_packet(response_pptr);
    errval = QMI_ERR_NO_MEMORY;
  }

  if(encrypted_read_data.data_ptr != NULL)
  {
    uimqmi_free(encrypted_read_data.data_ptr);
    encrypted_read_data.data_ptr = NULL;
  }
  return errval;
} /* qmi_uim_encrypt_read_rsp */


/*===========================================================================
  FUNCTION QMI_UIM_CONVERT_MMGSDI_SESSION_TYPE_TO_TLV

  DESCRIPTION
    Converts the MMGSDI session type to a TLV byte.

  PARAMETERS
    mmgsdi_session_type     : mmgsdi session type
    tlv_session_type_ptr    : return tlv session type

  RETURN VALUE
    errval          : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_convert_mmgsdi_session_type_to_tlv
(
  mmgsdi_session_type_enum_type     mmgsdi_session_type,
  uint8                           * tlv_session_type_ptr
)
{
  ASSERT(tlv_session_type_ptr);

  switch (mmgsdi_session_type)
  {
    case MMGSDI_GW_PROV_PRI_SESSION:
      *tlv_session_type_ptr = 0;
      break;
    case MMGSDI_1X_PROV_PRI_SESSION:
      *tlv_session_type_ptr = 1;
      break;
    case MMGSDI_GW_PROV_SEC_SESSION:
      *tlv_session_type_ptr = 2;
      break;
    case MMGSDI_1X_PROV_SEC_SESSION:
      *tlv_session_type_ptr = 3;
      break;
    case MMGSDI_NON_PROV_SESSION_SLOT_1:
      *tlv_session_type_ptr = 4;
      break;
    case MMGSDI_NON_PROV_SESSION_SLOT_2:
      *tlv_session_type_ptr = 5;
      break;
    case MMGSDI_CARD_SESSION_SLOT_1:
      *tlv_session_type_ptr = 6;
      break;
    case MMGSDI_CARD_SESSION_SLOT_2:
      *tlv_session_type_ptr = 7;
      break;
    case MMGSDI_GW_PROV_TER_SESSION:
      *tlv_session_type_ptr = 10;
      break;
    case MMGSDI_1X_PROV_TER_SESSION:
      *tlv_session_type_ptr = 11;
      break;
    case MMGSDI_NON_PROV_SESSION_SLOT_3:
      *tlv_session_type_ptr = 16;
      break;
    case MMGSDI_CARD_SESSION_SLOT_3:
      *tlv_session_type_ptr = 19;
      break;
    default:
      UIM_MSG_ERR_1("QMI_UIM invalid session type: 0x%x",
                    mmgsdi_session_type);
      return QMI_ERR_INVALID_ARG;
  }

  return QMI_ERR_NONE;
} /* qmi_uim_convert_mmgsdi_session_type_to_tlv */


/*===========================================================================
  FUNCTION  QMI_UIM_COMPLETE_ENCRYPT_READ_RSP()

  DESCRIPTION
    Encrypts complete read resp using Trust Zone application APIs

  PARAMETERS
    cmd_id        : Command to be saved in request header
    session_type  : Session type
    file_access   : File access
    data          : The data to be encrypted
    resposne_pptr : Pointer to command response pointer
    is_indication : Is indication pending

  RETURN VALUE
    errval        : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_uim_complete_encrypt_read_rsp
(
  qmi_uimi_cmd_val_e_type           cmd_id,
  mmgsdi_session_type_enum_type     session_type,
  mmgsdi_access_type                file_access,
  mmgsdi_data_type                  read_data,
  dsm_item_type                  ** response_pptr,
  boolean                           is_indication
)
{
  boolean               encryption_used     = TRUE;
  mmgsdi_data_type      decrypted_data      = { 0, NULL };
  mmgsdi_data_type      encrypted_data      = { 0, NULL };
  qmi_error_e_type      errval              = QMI_ERR_NONE;

  PACKED struct PACKED_POST
  {
    uint16    cmd_id;
    uint8     rfu[QMI_UIM_ENCRYPTED_READ_RSP_HEADER_RFU];
    uint8     session_type;
    uint16    file_id;
    uint8     path_len;
    uint8     path_buf[MMGSDI_MAX_PATH_LEN * 2];
    uint16    data_len;
  } fixed_data;

  if (read_data.data_len > QMI_UIM_READ_TRANSPARENT_MAX_LEN ||
      read_data.data_len <= 0 ||
      read_data.data_ptr == NULL)
  {
    UIM_MSG_ERR_1("Invalid read data, data length: 0x%x", read_data.data_len);
    return QMI_ERR_INTERNAL;
  }

  if (file_access.access_method != MMGSDI_BY_PATH_ACCESS ||
      file_access.file.path_type.path_len > MMGSDI_MAX_PATH_LEN)
  {
    UIM_MSG_ERR_2("Invalid file path length: 0x%x or access method: 0x%x",
                  file_access.file.path_type.path_len,
                  file_access.access_method);
    return QMI_ERR_INTERNAL;
  }

  memset(&fixed_data, 0x00, sizeof(fixed_data));

  fixed_data.cmd_id = cmd_id;

  errval = qmi_uim_convert_mmgsdi_session_type_to_tlv(
                session_type,
                &fixed_data.session_type);
  if (errval != QMI_ERR_NONE)
  {
    return errval;
  }

  fixed_data.file_id = file_access.file.path_type.path_buf[file_access.file.path_type.path_len - 1];
  fixed_data.path_len = file_access.file.path_type.path_len * 2;

  (void)memscpy((void*)fixed_data.path_buf,
                sizeof(fixed_data.path_buf),
                (void*)file_access.file.path_type.path_buf,
                fixed_data.path_len);

  fixed_data.data_len = (uint16)read_data.data_len;

  decrypted_data.data_len = sizeof(fixed_data) + read_data.data_len;
  decrypted_data.data_ptr = uimqmi_malloc(decrypted_data.data_len);
  if (decrypted_data.data_ptr == NULL)
  {
    UIM_MSG_ERR_0( "Error allocating memory for decrypted data");
    return QMI_ERR_NO_MEMORY;
  }

  /* copy the fixed data including the request header, session type,
     file access data and data length. */
  (void)memscpy((void*)decrypted_data.data_ptr,
                sizeof(fixed_data),
                (void*)&fixed_data,
                sizeof(fixed_data));

  /* copy the variable file data */
  (void)memscpy((void*)(decrypted_data.data_ptr + sizeof(fixed_data)),
                read_data.data_len,
                (void*)read_data.data_ptr,
                read_data.data_len);

  encryption_used = qmi_uim_encrypt_payload(decrypted_data,
                                            &encrypted_data);

  if (encryption_used &&
      FALSE == qmi_uim_response_generic_payload_16bit(
                 UIMI_TLV_RESP_TAG_OPTIONAL_7,
                 response_pptr,
                 encrypted_data,
                 TRUE))
  {
    dsm_free_packet(response_pptr);
    errval = QMI_ERR_NO_MEMORY;
  }

  uimqmi_free(decrypted_data.data_ptr);
  decrypted_data.data_ptr = NULL;

  return errval;
} /* qmi_uim_complete_encrypt_read_rsp */


/*===========================================================================
  FUNCTION QMI_UIMI_READ_IMPI_RESP()

  DESCRIPTION
    Handle the response for read transparent of IMPI file

  PARAMETERS
    status       : status of MMGSDI operation
    read_cnf_ptr : result of MMGSDI operation

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_read_impi_resp
(
  mmgsdi_return_enum_type      status,
  const mmgsdi_read_cnf_type * read_cnf_ptr
)
{
  qmi_uimi_userdata_type           * cb_userdata_ptr    = NULL;
  uint8                              clid               = QMI_SVC_CLID_UNUSED;
  uint32                             client_reg_count   = 0;
  qmi_cmd_buf_type                 * cmd_buf_p          = NULL;
  qmi_uim_requested_encrytion_type   encryption_status  = FALSE;
  qmi_result_e_type                  result             = QMI_RESULT_SUCCESS;
  boolean                            retval             = TRUE;
  qmi_error_e_type                   errval             = QMI_ERR_NONE;
  dsm_item_type *                    response           = NULL;

  UIM_MSG_HIGH_0("Sending response for read of IMPI");

  ASSERT(read_cnf_ptr);

  /* Retrieve userdata */
  cb_userdata_ptr = (qmi_uimi_userdata_type*)read_cnf_ptr->response_header.client_data;
  if (cb_userdata_ptr == NULL)
  {
    UIM_MSG_HIGH_0("Null userdata ptr in response");
    return;
  }

  /* Retrieve info */
  clid                = cb_userdata_ptr->clid;
  client_reg_count    = cb_userdata_ptr->client_reg_count;
  cmd_buf_p           = (qmi_cmd_buf_type*)cb_userdata_ptr->cmd_buf_ptr;
  encryption_status   = cb_userdata_ptr->data.read_transparent.encryption_status;
  QMI_UIM_VALIDATE_CMD_BUF_IN_USERDATA(cb_userdata_ptr);

  /* Free userdata */
  qmi_uim_free_cb_userdata(cb_userdata_ptr);
  cb_userdata_ptr = NULL;

  /* First check if the requested client is still valid */
  if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
  {
    UIM_MSG_HIGH_0("Invalid Client, not sending indication or response");
    return;
  }

  if(status == MMGSDI_SUCCESS)
  {
    mmgsdi_data_type impi_data = {0, NULL};

    if(read_cnf_ptr->read_data.data_len > QMI_UIM_IMPI_MAX ||
       read_cnf_ptr->read_data.data_len < 3 ||
       read_cnf_ptr->read_data.data_ptr[0] != QMI_UIM_IMPI_NAI_TAG ||
       read_cnf_ptr->read_data.data_ptr[1] == 0x00)
    {
      UIM_MSG_ERR_3("Invalid data received for EF IMPI len: 0x%x, data[0]: 0x%x, data[1]: 0x%x",
                    read_cnf_ptr->read_data.data_len,
                    read_cnf_ptr->read_data.data_ptr[0],
                    read_cnf_ptr->read_data.data_ptr[1]);
      errval = QMI_ERR_INTERNAL;
      goto send_result;
    }

    /* process IMPI data and parse the TLV */
    if(read_cnf_ptr->read_data.data_ptr[1] > (read_cnf_ptr->read_data.data_len - 2))
    {
      errval = QMI_ERR_INTERNAL;
      goto send_result;
    }

    impi_data.data_ptr = read_cnf_ptr->read_data.data_ptr + 2;
    impi_data.data_len = read_cnf_ptr->read_data.data_ptr[1];

    /* Check whether IMPI data should be encrypted */
    if(encryption_status == QMI_UIM_DATA_ONLY_ENCRYPTION)
    {
      mmgsdi_data_type   impi_enc_data   = {0, NULL};

      if(qmi_uim_encrypt_payload(impi_data, &impi_enc_data))
      {
        if(FALSE == qmi_uim_response_generic_payload_16bit(
                     UIMI_TLV_RESP_TAG_OPTIONAL_2,
                     &response,
                     impi_enc_data,
                     TRUE))
        {
          dsm_free_packet(&response);
          errval = QMI_ERR_NO_MEMORY;
        }
      }
      else
      {
        errval = QMI_ERR_INTERNAL;
      }
    }
    else if(encryption_status == QMI_UIM_NO_ENCRYPTION)
    {
      if(FALSE == qmi_uim_response_generic_payload_8bit(
                     UIMI_TLV_RESP_TAG_OPTIONAL_1,
                     &response,
                     impi_data,
                     TRUE))
      {
        errval = QMI_ERR_NO_MEMORY;
        dsm_free_packet(&response);
      }
    }
    else
    {
      UIM_MSG_HIGH_1("Other encryption status is not expected: 0x%x", encryption_status);
      errval = QMI_ERR_INTERNAL;
    }
  }
  else
  {
    /* Convert MMGSDI status to QMI err code */
    errval = qmi_uim_convert_mmgsdi_status_to_errval(status);
  }

send_result:
  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    QMI_UIM_FREE_CMD_BUF(cmd_buf_p);
    return;
  }

  retval = qmi_uimi_send_response(cmd_buf_p,
                                  response);
  if (FALSE == retval)
  {
    UIM_MSG_HIGH_0("Unable to send response for read operation");
    dsm_free_packet(&response);
    QMI_UIM_FREE_CMD_BUF(cmd_buf_p);
  }
} /* qmi_uimi_read_impi_resp */


/*===========================================================================
  FUNCTION QMI_UIMI_READ_RESP()

  DESCRIPTION
    Composes either the response or indication for the read transparent or
    record function

  PARAMETERS
    status       : status of MMGSDI operation
    read_cnf_ptr : result of MMGSDI operation

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_read_resp
(
  mmgsdi_return_enum_type      status,
  const mmgsdi_read_cnf_type * read_cnf_ptr
)
{
  qmi_cmd_buf_type *                cmd_buf_p          = NULL;
  qmi_uimi_userdata_type *          cb_userdata_ptr    = NULL;
  dsm_item_type *                   response           = NULL;
  qmi_error_e_type                  errval             = QMI_ERR_NONE;
  qmi_result_e_type                 result             = QMI_RESULT_SUCCESS;
  boolean                           retval             = TRUE;
  mmgsdi_return_enum_type           first_read_status  = MMGSDI_SUCCESS;
  mmgsdi_sw_type                    first_status_word  = { FALSE, 0, 0 };
  mmgsdi_data_type                  first_read_data    = { 0, NULL };
  boolean                           ind_required       = FALSE;
  boolean                           long_ind_required  = FALSE;
  qmi_uim_requested_encrytion_type  encryption_status  = FALSE;
  uint8                             clid               = QMI_SVC_CLID_UNUSED;
  qmi_error_e_type                  multiple_rec_res   = QMI_ERR_NONE;
  uint32                            client_reg_count   = 0;
  qmi_uimi_cmd_val_e_type           cmd_id             = UIMI_CMD_VAL_WIDTH;

  UIM_MSG_HIGH_0("Sending response for read");

  ASSERT( read_cnf_ptr );

  /* Retrieve userdata */
  cb_userdata_ptr = (qmi_uimi_userdata_type*)read_cnf_ptr->response_header.client_data;
  if (cb_userdata_ptr == NULL)
  {
    UIM_MSG_HIGH_0("Null userdata ptr in response");
    return;
  }

  /* Retrieve info */
  clid                = cb_userdata_ptr->clid;
  client_reg_count    = cb_userdata_ptr->client_reg_count;
  cmd_id              = cb_userdata_ptr->request_id;
  cmd_buf_p           = (qmi_cmd_buf_type*)cb_userdata_ptr->cmd_buf_ptr;
  encryption_status   = cb_userdata_ptr->data.read_transparent.encryption_status;
  QMI_UIM_VALIDATE_CMD_BUF_IN_USERDATA(cb_userdata_ptr);

  /* First check if the requested client is still valid */
  if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
  {
    UIM_MSG_HIGH_0("Invalid Client, not sending indication or response");
    qmi_uim_free_cb_userdata(cb_userdata_ptr);
    return;
  }

  /* Check if the operation included the read of multiple records */
  if (cmd_id == UIMI_CMD_VAL_READ_RECORD &&
      cb_userdata_ptr->data.read_record.total_records > 1)
  {
    multiple_rec_res = qmi_uimi_read_additional_records(cb_userdata_ptr,
                                                        status,
                                                        read_cnf_ptr);
    if (multiple_rec_res == QMI_ERR_NONE)
    {
      /* If a new read was started, we can immediately return */
      return;
    }
    UIM_MSG_ERR_0("No new records to read");
  }

  if (cmd_id == UIMI_CMD_VAL_READ_RECORD &&
      cb_userdata_ptr->data.read_record.total_records > 1)
  {
    ASSERT(cb_userdata_ptr->data.read_record.records_cnf);

    first_read_status  = cb_userdata_ptr->data.read_record.records_cnf[0].mmgsdi_status;
    first_status_word  = cb_userdata_ptr->data.read_record.records_cnf[0].status_word;
    first_read_data    = cb_userdata_ptr->data.read_record.records_cnf[0].read_data;
  }
  else
  {
    first_read_status           = status;
    first_status_word           = read_cnf_ptr->response_header.status_word;
    first_read_data.data_ptr    = read_cnf_ptr->read_data.data_ptr;
    first_read_data.data_len    = read_cnf_ptr->read_data.data_len;
  }

  /* Check if an indication needs to be sent instead of a response */
  ind_required = cb_userdata_ptr->ind_token.is_valid;
  if (ind_required)
  {
    if (FALSE == qmi_uim_response_ind_token(UIMI_TLV_IND_TAG_MANDATORY_1,
                                            &response,
                                            cb_userdata_ptr->ind_token.token))
    {
      UIM_MSG_ERR_0("Could not insert ind_token TLV, not sending indication");
      qmi_uim_free_cb_userdata(cb_userdata_ptr);
      dsm_free_packet(&response);
      return;
    }
  }

  /* Insert card result in the TLV: this is always present */
  if (qmi_uim_response_card_result(UIMI_TLV_RESP_TAG_OPTIONAL_1,
                                   &response,
                                   first_status_word))
  {
    /* Insert read result in the TLV: only in case of success */
    if (first_read_status == MMGSDI_SUCCESS)
    {
      /* If length of the data read as part of multiple records is more than
         4096 bytes, return QMI_ERR_INSUFFICIENT_RESOURCES */
      if(cmd_id == UIMI_CMD_VAL_READ_RECORD &&
         multiple_rec_res == QMI_ERR_INSUFFICIENT_RESOURCES)
      {
        errval = QMI_ERR_INSUFFICIENT_RESOURCES;
        goto send_result;
      }

      /* If length of the data read from the card is more than 4096 bytes,
         return QMI_ERR_INSUFFICIENT_RESOURCES along with total length of the
         file */
      if(cmd_id == UIMI_CMD_VAL_READ_TRANSPARENT &&
         first_read_data.data_len > QMI_UIM_READ_TRANSPARENT_MAX_LEN)
      {
        /* Include the File length TLV */
        if(qmi_uim_response_file_length(
             ind_required ? UIMI_TLV_RESP_TAG_OPTIONAL_4 : UIMI_TLV_RESP_TAG_OPTIONAL_5,
             &response,
             (uint16)first_read_data.data_len))
        {
          errval = QMI_ERR_INSUFFICIENT_RESOURCES;

          /* Include the Long data token. Note that if the inclusion of this
             TLV fails, Long Indication message will not be sent and also
             there is no need to free the response pointer */
          qmi_uim_global_ptr->long_read_response_token++;
          long_ind_required = qmi_uim_response_ind_token(
            ind_required ? UIMI_TLV_RESP_TAG_OPTIONAL_5 : UIMI_TLV_RESP_TAG_OPTIONAL_6,
            &response,
            qmi_uim_global_ptr->long_read_response_token);
        }
        else
        {
          errval = QMI_ERR_NO_MEMORY;
          dsm_free_packet(&response);
        }
        goto send_result;
      }

      /* Check if the read is transparent and the result should be
         encrypted before it is returned */
      if(cmd_id == UIMI_CMD_VAL_READ_TRANSPARENT &&
         encryption_status == QMI_UIM_DATA_ONLY_ENCRYPTION)
      {
        mmgsdi_data_type             read_data    = { 0, NULL };

        read_data.data_ptr = read_cnf_ptr->read_data.data_ptr;
        read_data.data_len = read_cnf_ptr->read_data.data_len;

        errval = qmi_uim_encrypt_read_rsp(read_data,
                                          &response,
                                          ind_required);
      }
      else if(cmd_id == UIMI_CMD_VAL_READ_TRANSPARENT &&
              encryption_status == QMI_UIM_COMPLETE_ENCRYPTION)
      {
        errval = qmi_uim_complete_encrypt_read_rsp(cmd_id,
                                                   cb_userdata_ptr->data.read_transparent.session_type,
                                                   cb_userdata_ptr->data.read_transparent.file_access,
                                                   read_cnf_ptr->read_data,
                                                   &response,
                                                   ind_required);
      }
      else
      {
        if (FALSE == qmi_uim_response_generic_payload_16bit(UIMI_TLV_RESP_TAG_OPTIONAL_2,
                                                            &response,
                                                            first_read_data,
                                                            TRUE))
        {
          errval = QMI_ERR_NO_MEMORY;
          dsm_free_packet(&response);
        }
      }

      /* Append data for additional records (if needed) */
      if (cmd_id == UIMI_CMD_VAL_READ_RECORD &&
          cb_userdata_ptr->data.read_record.total_records > 1 &&
          cb_userdata_ptr->data.read_record.read_records > 1)
      {
        /* This is an optional TLV... we can ignore the error */
        (void)qmi_uim_response_read_additional_records_result(
                 UIMI_TLV_RESP_TAG_OPTIONAL_3,
                 &response,
                 cb_userdata_ptr->data.read_record.read_records,
                 cb_userdata_ptr->data.read_record.records_cnf);
      }
    }
    else
    {
      /* Convert MMGSDI status to QMI err code */
      errval = qmi_uim_convert_mmgsdi_status_to_errval(first_read_status);
      if (first_read_status == MMGSDI_NOT_SUPPORTED)
      {
        errval = QMI_ERR_NOT_PROVISIONED;
      }
    }
  }
  else
  {
    errval = QMI_ERR_NO_MEMORY;
    dsm_free_packet(&response);
  }

send_result:
  /* Free userdata */
  qmi_uim_free_cb_userdata(cb_userdata_ptr);
  cb_userdata_ptr = NULL;

  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    QMI_UIM_FREE_CMD_BUF(cmd_buf_p);
    return;
  }

  /* Send response or indication */
  if (ind_required)
  {
    retval = qmi_uimi_send_indication(clid,
                                      (uint16)cmd_id,
                                      response);
  }
  else
  {
    retval = qmi_uimi_send_response(cmd_buf_p,
                                    response);
  }
  if (FALSE == retval)
  {
    UIM_MSG_HIGH_0("Unable to send response for read operation");
    dsm_free_packet(&response);
    QMI_UIM_FREE_CMD_BUF(cmd_buf_p);
  }

  /* Send Long Indication if needed */
  if (long_ind_required)
  {
    qmi_uim_send_long_read_ind(clid,
                               encryption_status,
                               first_status_word,
                               first_read_data);
  }
} /* qmi_uimi_read_resp */


/*===========================================================================
  FUNCTION QMI_UIMI_WRITE_RESP()

  DESCRIPTION
    Composes either the response or indication for the write transparent or
    record function

  PARAMETERS
    status        : status of MMGSDI operation
    write_cnf_ptr : result of MMGSDI operation

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_write_resp
(
  mmgsdi_return_enum_type       status,
  const mmgsdi_write_cnf_type * write_cnf_ptr
)
{
  qmi_cmd_buf_type *       cmd_buf_p        = NULL;
  qmi_uimi_userdata_type * cb_userdata_ptr  = NULL;
  dsm_item_type *          response         = NULL;
  qmi_error_e_type         errval           = QMI_ERR_NONE;
  qmi_result_e_type        result           = QMI_RESULT_SUCCESS;
  boolean                  retval           = TRUE;
  boolean                  ind_required     = FALSE;
  uint8                    clid             = QMI_SVC_CLID_UNUSED;
  qmi_uimi_cmd_val_e_type  request_id       = UIMI_CMD_VAL_WIDTH;
  uint32                   client_reg_count = 0;

  UIM_MSG_HIGH_0("Sending response for write");

  ASSERT( write_cnf_ptr );

  /* Retrieve userdata */
  cb_userdata_ptr = (qmi_uimi_userdata_type*)write_cnf_ptr->response_header.client_data;
  if (cb_userdata_ptr == NULL)
  {
    UIM_MSG_HIGH_0("Null userdata ptr in response");
    return;
  }

  /* Retrieve info */
  clid             = cb_userdata_ptr->clid;
  client_reg_count = cb_userdata_ptr->client_reg_count;
  request_id       = cb_userdata_ptr->request_id;
  cmd_buf_p        = (qmi_cmd_buf_type*)cb_userdata_ptr->cmd_buf_ptr;
  QMI_UIM_VALIDATE_CMD_BUF_IN_USERDATA(cb_userdata_ptr);

  /* First check if the requested client is still valid */
  if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
  {
    UIM_MSG_HIGH_0("Invalid Client, not sending indication or response");
    qmi_uim_free_cb_userdata(cb_userdata_ptr);
    return;
  }

  /* Check if an indication needs to be sent instead of a response */
  ind_required = cb_userdata_ptr->ind_token.is_valid;
  if (ind_required)
  {
    if (FALSE == qmi_uim_response_ind_token(UIMI_TLV_IND_TAG_MANDATORY_1,
                                            &response,
                                            cb_userdata_ptr->ind_token.token))
    {
      UIM_MSG_ERR_0("Could not insert ind_token TLV, not sending indication");
      qmi_uim_free_cb_userdata(cb_userdata_ptr);
      dsm_free_packet(&response);
      return;
    }
  }

  /* Insert card result in the TLV */
  if (qmi_uim_response_card_result(UIMI_TLV_RESP_TAG_OPTIONAL_1,
                                   &response,
                                   write_cnf_ptr->response_header.status_word))
  {
    /* Convert MMGSDI status to QMI err code */
    errval = qmi_uim_convert_mmgsdi_status_to_errval(status);
    if (status == MMGSDI_NOT_SUPPORTED)
    {
      errval = QMI_ERR_NOT_PROVISIONED;
    }
  }
  else
  {
    errval = QMI_ERR_NO_MEMORY;
    dsm_free_packet(&response);
  }

  /* Free userdata */
  qmi_uim_free_cb_userdata(cb_userdata_ptr);
  cb_userdata_ptr = NULL;

  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    QMI_UIM_FREE_CMD_BUF(cmd_buf_p);
    return;
  }

  /* Send response or indication */
  if (ind_required)
  {
    retval = qmi_uimi_send_indication(clid,
                                     (uint16)request_id,
                                     response);
  }
  else
  {
    retval = qmi_uimi_send_response(cmd_buf_p,
                                    response);
  }
  if (FALSE == retval)
  {
    UIM_MSG_HIGH_0("Unable to send response for write operation");
    dsm_free_packet(&response);
    QMI_UIM_FREE_CMD_BUF(cmd_buf_p);
  }
} /* qmi_uimi_write_resp */


/*===========================================================================
  FUNCTION QMI_UIMI_GET_FILE_ATTRIBUTES_RESP()

  DESCRIPTION
    Composes either the response or indication for the get file attributes
    function

  PARAMETERS
    status                : status of MMGSDI operation
    get_file_attr_cnf_ptr : result of MMGSDI operation

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_get_file_attributes_resp
(
  mmgsdi_return_enum_type               status,
  const mmgsdi_get_file_attr_cnf_type * get_file_attr_cnf_ptr
)
{
  qmi_cmd_buf_type *       cmd_buf_p        = NULL;
  qmi_uimi_userdata_type * cb_userdata_ptr  = NULL;
  dsm_item_type *          response         = NULL;
  qmi_error_e_type         errval           = QMI_ERR_NONE;
  qmi_result_e_type        result           = QMI_RESULT_SUCCESS;
  boolean                  retval           = TRUE;
  boolean                  ind_required     = FALSE;
  uint8                    clid             = QMI_SVC_CLID_UNUSED;
  uint32                   client_reg_count = 0;

  UIM_MSG_HIGH_0("Sending response for get file attributes");

  ASSERT( get_file_attr_cnf_ptr );

  /* Retrieve userdata */
  cb_userdata_ptr = (qmi_uimi_userdata_type*)get_file_attr_cnf_ptr->response_header.client_data;
  if (cb_userdata_ptr == NULL)
  {
    UIM_MSG_HIGH_0("Null userdata ptr in response");
    return;
  }

  /* Retrieve parameters */
  clid             = cb_userdata_ptr->clid;
  client_reg_count = cb_userdata_ptr->client_reg_count;
  cmd_buf_p        = (qmi_cmd_buf_type*)cb_userdata_ptr->cmd_buf_ptr;
  QMI_UIM_VALIDATE_CMD_BUF_IN_USERDATA(cb_userdata_ptr);

  /* First check if the requested client is still valid */
  if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
  {
    UIM_MSG_HIGH_0("Invalid Client, not sending indication or response");
    qmi_uim_free_cb_userdata(cb_userdata_ptr);
    return;
  }

  /* Store the file type in the cache, so it will be available later, if needed */
  if (status == MMGSDI_SUCCESS)
  {
    UIM_MSG_HIGH_1("Caching record type: 0x%x",
                   get_file_attr_cnf_ptr->file_attrib.file_type);
    qmi_uim_cache_record_type(get_file_attr_cnf_ptr->response_header.session_id,
                              cb_userdata_ptr->data.get_file_attributes.file_access,
                              get_file_attr_cnf_ptr->file_attrib.file_type);
  }

  /* Check if an indication needs to be sent instead of a response */
  ind_required = cb_userdata_ptr->ind_token.is_valid;
  if (ind_required)
  {
    if (FALSE == qmi_uim_response_ind_token(UIMI_TLV_IND_TAG_MANDATORY_1,
                                            &response,
                                            cb_userdata_ptr->ind_token.token))
    {
      UIM_MSG_ERR_0("Could not insert ind_token TLV, not sending indication");
      qmi_uim_free_cb_userdata(cb_userdata_ptr);
      dsm_free_packet(&response);
      return;
    }
  }

  /* Insert card result in the TLV: this is always present */
  if (qmi_uim_response_card_result(UIMI_TLV_RESP_TAG_OPTIONAL_1,
                                   &response,
                                   get_file_attr_cnf_ptr->response_header.status_word))
  {
    /* Insert needed TLVs only in case of success */
    if (status == MMGSDI_SUCCESS)
    {
      /* Insert file attributes TLV */
      if (FALSE == qmi_uim_response_get_file_attributes(
                              UIMI_TLV_RESP_TAG_OPTIONAL_2,
                              &response,
                              get_file_attr_cnf_ptr->file_attrib,
                              get_file_attr_cnf_ptr->raw_file_attr_data))
      {
        errval = QMI_ERR_NO_MEMORY;
        dsm_free_packet(&response);
      }
      /* Insert File Status TLV upon successfully adding previous TLV */
      else
      {
        /* This is an optional TLV... we can ignore the error */
        (void)qmi_uim_response_file_status(
                ind_required ? UIMI_TLV_RESP_TAG_OPTIONAL_3 : UIMI_TLV_RESP_TAG_OPTIONAL_4,
                &response,
                &get_file_attr_cnf_ptr->file_attrib);
      }
    }
    else
    {
      /* Convert MMGSDI status to QMI err code */
      errval = qmi_uim_convert_mmgsdi_status_to_errval(status);
      if (status == MMGSDI_NOT_SUPPORTED)
      {
        errval = QMI_ERR_NOT_PROVISIONED;
      }
    }
  }
  else
  {
    errval = QMI_ERR_NO_MEMORY;
    dsm_free_packet(&response);
  }

  /* Free userdata */
  qmi_uim_free_cb_userdata(cb_userdata_ptr);
  cb_userdata_ptr = NULL;

  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    QMI_UIM_FREE_CMD_BUF(cmd_buf_p);
    return;
  }

  /* Send response or indication */
  if (ind_required)
  {
    retval = qmi_uimi_send_indication(clid,
                                     (uint16)UIMI_CMD_VAL_GET_FILE_ATTRIBUTES,
                                     response);
  }
  else
  {
    retval = qmi_uimi_send_response(cmd_buf_p,
                                    response);
  }
  if (FALSE == retval)
  {
    UIM_MSG_HIGH_0("Unable to send response for get file attributes operation");
    dsm_free_packet(&response);
    QMI_UIM_FREE_CMD_BUF(cmd_buf_p);
  }
} /* qmi_uimi_get_file_attributes_resp */


/*===========================================================================
  FUNCTION QMI_UIMI_WRITE_RECORD_AFTER_GET_FILE_ATTRIBUTES()

  DESCRIPTION
    Handle the response for get file attributes before a write record.
    It takes care of sending the response in case of error, as if the
    original request was a get_file_attributes, or initiate a write
    record, if the attributes were retrieved successfully.

  PARAMETERS
    status                : status of MMGSDI operation
    get_file_attr_cnf_ptr : result of MMGSDI operation

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_write_record_after_get_file_attributes
(
  mmgsdi_return_enum_type               status,
  const mmgsdi_get_file_attr_cnf_type * get_file_attr_cnf_ptr
)
{
  qmi_uimi_userdata_type * cb_userdata_ptr  = NULL;
  qmi_cmd_buf_type *       cmd_buf_p        = NULL;
  mmgsdi_return_enum_type  mmgsdi_status    = MMGSDI_SUCCESS;
  uint8                    clid             = QMI_SVC_CLID_UNUSED;
  uint32                   client_reg_count = 0;

  UIM_MSG_HIGH_0("Handling response of get file attributes for write record");

  ASSERT( get_file_attr_cnf_ptr );

  /* Retrieve userdata */
  cb_userdata_ptr = (qmi_uimi_userdata_type*)get_file_attr_cnf_ptr->response_header.client_data;
  if (cb_userdata_ptr == NULL)
  {
    UIM_MSG_HIGH_0("Null userdata ptr in response");
    return;
  }

  if (status != MMGSDI_SUCCESS)
  {
    /* Error while retrieving file attributes */
    UIM_MSG_ERR_1("Error in file attributes before write record: 0x%x",
                  status);

    /* Handle it as a normal error during get file attributes.
       The userdata will be freed there. */
    qmi_uimi_get_file_attributes_resp(status, get_file_attr_cnf_ptr);
    return;
  }

  /* Store the file type in the cache, so it will be available later, if needed */
  UIM_MSG_HIGH_1("Caching record type: 0x%x",
                 get_file_attr_cnf_ptr->file_attrib.file_type);
  qmi_uim_cache_record_type(get_file_attr_cnf_ptr->response_header.session_id,
                            cb_userdata_ptr->data.write_record.file_access,
                            get_file_attr_cnf_ptr->file_attrib.file_type);

  /* Initiate the write record */
  mmgsdi_status = mmgsdi_session_write_record(
                           get_file_attr_cnf_ptr->response_header.session_id,
                           cb_userdata_ptr->data.write_record.file_access,
                           get_file_attr_cnf_ptr->file_attrib.file_type,
                           cb_userdata_ptr->data.write_record.record,
                           cb_userdata_ptr->data.write_record.data,
                           qmi_uimi_mmgsdi_callback,
                           get_file_attr_cnf_ptr->response_header.client_data );

  if (mmgsdi_status != MMGSDI_SUCCESS)
  {
    UIM_MSG_ERR_1("Unable to write record (0x%x): sending internal error",
                  mmgsdi_status);

    /* Retrieve parameters */
    clid             = cb_userdata_ptr->clid;
    client_reg_count = cb_userdata_ptr->client_reg_count;
    cmd_buf_p = (qmi_cmd_buf_type*)cb_userdata_ptr->cmd_buf_ptr;

    /* Free userdata */
    qmi_uim_free_cb_userdata(cb_userdata_ptr);
    cb_userdata_ptr = NULL;

    /* First check if the requested client is still valid */
    if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
    {
      UIM_MSG_HIGH_0("Invalid Client, not proceeding with building default write response");
      return;
    }

    qmi_uim_internal_error_resp(cmd_buf_p);
  }
} /* qmi_uimi_write_record_after_get_file_attributes */


/*===========================================================================
  FUNCTION QMI_UIMI_POWER_DOWN_RESP()

  DESCRIPTION
    Composes the response for the power down function

  PARAMETERS
    status             : status of MMGSDI operation
    card_pdown_cnf_ptr : result of MMGSDI operation

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_power_down_resp
(
  mmgsdi_return_enum_type            status,
  const mmgsdi_card_pdown_cnf_type * card_pdown_cnf_ptr
)
{
  qmi_cmd_buf_type *       cmd_buf_p        = NULL;
  qmi_uimi_userdata_type * cb_userdata_ptr  = NULL;
  dsm_item_type *          response         = NULL;
  qmi_error_e_type         errval           = QMI_ERR_NONE;
  qmi_result_e_type        result           = QMI_RESULT_SUCCESS;
  boolean                  retval           = TRUE;
  uint8                    clid             = QMI_SVC_CLID_UNUSED;
  uint32                   client_reg_count = 0;

  UIM_MSG_HIGH_0("Sending response for card power down");

  ASSERT( card_pdown_cnf_ptr );

  /* Retrieve userdata */
  cb_userdata_ptr = (qmi_uimi_userdata_type*)card_pdown_cnf_ptr->response_header.client_data;
  if (cb_userdata_ptr == NULL)
  {
    UIM_MSG_HIGH_0("Null userdata ptr in response");
    return;
  }

  /* Retrieve parameters */
  clid             = cb_userdata_ptr->clid;
  client_reg_count = cb_userdata_ptr->client_reg_count;
  cmd_buf_p        = (qmi_cmd_buf_type*)cb_userdata_ptr->cmd_buf_ptr;

  /* Free userdata */
  qmi_uim_free_cb_userdata(cb_userdata_ptr);
  cb_userdata_ptr = NULL;

  /* First check if the requested client is still valid */
  if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
  {
    UIM_MSG_HIGH_0("Invalid Client, not sending response");
    return;
  }

  if (cmd_buf_p == NULL)
  {
    UIM_MSG_HIGH_0("Null cmd_buf ptr in response");
    return;
  }

  QMI_UIM_VALIDATE_SP_IN_CMD_BUF(cmd_buf_p);

  /* Convert MMGSDI status in QMI code */
  errval = qmi_uim_convert_mmgsdi_status_to_errval(status);

  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    ds_qmi_fw_free_cmd_buf( &cmd_buf_p );
    return;
  }

  /* Send response */
  if (FALSE == qmi_uimi_send_response(cmd_buf_p,
                                      response))
  {
    UIM_MSG_HIGH_0("Unable to send response for power down operation");
    dsm_free_packet(&response);
  }
} /* qmi_uimi_power_down_resp */


/*===========================================================================
  FUNCTION QMI_UIMI_POWER_UP_RESP()

  DESCRIPTION
    Composes the response for the get power up function

  PARAMETERS
    status           : status of MMGSDI operation
    card_pup_cnf_ptr : result of MMGSDI operation

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_power_up_resp
(
  mmgsdi_return_enum_type          status,
  const mmgsdi_card_pup_cnf_type * card_pup_cnf_ptr
)
{
  qmi_cmd_buf_type *       cmd_buf_p        = NULL;
  qmi_uimi_userdata_type * cb_userdata_ptr  = NULL;
  dsm_item_type *          response         = NULL;
  qmi_error_e_type         errval           = QMI_ERR_NONE;
  qmi_result_e_type        result           = QMI_RESULT_SUCCESS;
  boolean                  retval           = TRUE;
  uint8                    slot_idx         = 0;
  uint8                    clid             = QMI_SVC_CLID_UNUSED;
  uint32                   client_reg_count = 0;

  UIM_MSG_HIGH_0("Sending response for card power up");

  ASSERT( card_pup_cnf_ptr );

  if (qmi_uim_mmgsdi_slot_to_slot_index(card_pup_cnf_ptr->response_header.slot_id,
                                        &slot_idx) != QMI_ERR_NONE)
  {
    return;
  }

  if(slot_idx >= QMI_UIM_MAX_CARD_COUNT ||
     slot_idx >= qmi_uim_global_ptr->card_state.num_slots)
  {
    return;
  }

  /* If rsp is already sent to client then no need to send another rsp */
  if (qmi_uim_global_ptr->power_up_state[slot_idx] == QMI_UIM_PUP_NOT_IN_PROGRESS ||
      qmi_uim_global_ptr->power_up_state[slot_idx] == QMI_UIM_PUP_RSP_SENT_TO_CLIENT)
  {
    /* card pup encountered error, trigger internal card error QCRIL */
    if(status == MMGSDI_CAN_NOT_REFRESH)
    {
      if (qmi_uim_process_card_error_evt(
                         MMGSDI_CARD_ERR_NO_PROTOCOL_AT_CARD_PUP,
                         card_pup_cnf_ptr->response_header.slot_id))
      {
        if (card_pup_cnf_ptr->response_header.slot_id <= MMGSDI_SLOT_2)
        {
          qmi_uim_send_card_status_indication_to_all(TRUE, FALSE, TRUE);
        }
        else
        {
          qmi_uim_send_card_status_indication_to_all(FALSE, FALSE, TRUE);
        }
      }
    }
    UIM_MSG_HIGH_1("No power_up rsp pending... dropping callback, power_up state: 0x%x",
                   qmi_uim_global_ptr->power_up_state[slot_idx]);
    qmi_uim_global_ptr->power_up_state[slot_idx] = QMI_UIM_PUP_NOT_IN_PROGRESS;
    return;
  }

  /* Per design, modem returns 2 callbacks during power up, so
     dropping one of the refresh callback */
  if (status == MMGSDI_REFRESH_SUCCESS)
  {
    UIM_MSG_HIGH_1("Drop the refresh callback for power up operation, power_up state: 0x%x",
                   qmi_uim_global_ptr->power_up_state[slot_idx]);

    /* If state is QMI_UIM_PUP_MMGSDI_RSP_PENDING then don't send the rsp to
       client now. Rsp will be sent on recieving the second rsp from MMGSDI
       after the REFRESH is done else set the state to no pup in progress */
    if (qmi_uim_global_ptr->power_up_state[slot_idx] == QMI_UIM_PUP_MMGSDI_RSP_PENDING)
    {
      qmi_uim_global_ptr->power_up_state[slot_idx] = QMI_UIM_PUP_CLIENT_RSP_PENDING;
    }
    else
    {
      qmi_uim_global_ptr->power_up_state[slot_idx] = QMI_UIM_PUP_NOT_IN_PROGRESS;
    }
    return;
  }

  /* If rsp is not sent to client then send the response, free the cb_userdata
     and update the power_up state to QMI_UIM_PUP_RSP_SENT_TO_CLIENT if this
     is the first response and QMI_UIM_PUP_NOT_IN_PROGRESS if this is the
     second rsp */
  if (qmi_uim_global_ptr->power_up_state[slot_idx] != QMI_UIM_PUP_CLIENT_RSP_PENDING &&
      qmi_uim_global_ptr->power_up_state[slot_idx] != QMI_UIM_PUP_MMGSDI_RSP_PENDING)
  {
    return;
  }

  if (qmi_uim_global_ptr->power_up_state[slot_idx] == QMI_UIM_PUP_CLIENT_RSP_PENDING)
  {
    qmi_uim_global_ptr->power_up_state[slot_idx] = QMI_UIM_PUP_NOT_IN_PROGRESS;
  }
  else
  {
    qmi_uim_global_ptr->power_up_state[slot_idx] = QMI_UIM_PUP_RSP_SENT_TO_CLIENT;
  }

  /* Retrieve userdata */
  cb_userdata_ptr = (qmi_uimi_userdata_type*)card_pup_cnf_ptr->response_header.client_data;
  if (cb_userdata_ptr == NULL)
  {
    UIM_MSG_HIGH_0("Null userdata ptr in response");
    return;
  }

  /* Retrieve parameters */
  clid             = cb_userdata_ptr->clid;
  client_reg_count = cb_userdata_ptr->client_reg_count;
  cmd_buf_p = (qmi_cmd_buf_type*)cb_userdata_ptr->cmd_buf_ptr;

  /* Free userdata */
  qmi_uim_free_cb_userdata(cb_userdata_ptr);
  cb_userdata_ptr = NULL;

  /* First check if the requested client is still valid */
  if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
  {
    UIM_MSG_HIGH_0("Invalid Client, not sending response");
    return;
  }

  if (cmd_buf_p == NULL)
  {
    UIM_MSG_HIGH_0("Null cmd_buf ptr in response");
    return;
  }

  QMI_UIM_VALIDATE_SP_IN_CMD_BUF(cmd_buf_p);

  /* Convert MMGSDI status in QMI code */
  errval = qmi_uim_convert_mmgsdi_status_to_errval(status);

  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    ds_qmi_fw_free_cmd_buf( &cmd_buf_p );
    return;
  }

  /* Send response */
  if (FALSE == qmi_uimi_send_response(cmd_buf_p,
                                      response))
  {
    UIM_MSG_HIGH_0("Unable to send response for power up operation");
    dsm_free_packet(&response);
  }
} /* qmi_uimi_power_up_resp */


/*===========================================================================
  FUNCTION QMI_UIMI_REFRESH_RESP()

  DESCRIPTION
    Composes the response for the refresh function

  PARAMETERS
    status          : status of MMGSDI operation
    refresh_cnf_ptr : result of MMGSDI operation

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_refresh_resp
(
  mmgsdi_return_enum_type         status,
  const mmgsdi_refresh_cnf_type * refresh_cnf_ptr
)
{
  /* Right now, no need to do any processing on the refresh CNF because
     response to application is sent synchronously */

  ASSERT( refresh_cnf_ptr );

  UIM_MSG_HIGH_2("Refresh confirmation for orig 0x%x. Status = 0x%x",
                 refresh_cnf_ptr->orig_refresh_req, status);

} /* qmi_uimi_refresh_resp */


/*===========================================================================
  FUNCTION QMI_UIMI_PIN_OPERATION_RESP()

  DESCRIPTION
    Composes either response or indication for the PIN operation functions

  PARAMETERS
    status                : status of MMGSDI operation
    pin_operation_cnf_ptr : result of MMGSDI operation

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_pin_operation_resp
(
  mmgsdi_return_enum_type               status,
  const mmgsdi_pin_operation_cnf_type * pin_operation_cnf_ptr
)
{
  qmi_cmd_buf_type *       cmd_buf_p              = NULL;
  qmi_uimi_userdata_type * cb_userdata_ptr        = NULL;
  dsm_item_type *          response               = NULL;
  qmi_error_e_type         errval                 = QMI_ERR_NONE;
  qmi_result_e_type        result                 = QMI_RESULT_SUCCESS;
  boolean                  retval                 = TRUE;
  boolean                  card_ind_required      = FALSE;
  uint8                    pin1_length            = 0;
  uint8                    pin1_value[QMI_UIM_TLV_MAX_PIN_LEN];
  boolean                  result_ind_required    = FALSE;
  uint8                    clid                   = QMI_SVC_CLID_UNUSED;
  qmi_uimi_cmd_val_e_type  request_id             = UIMI_CMD_VAL_WIDTH;
  uint32                   client_reg_count       = 0;

  UIM_MSG_HIGH_0("Sending response for pin operation");

  ASSERT( pin_operation_cnf_ptr );
  ASSERT(qmi_uim_global_ptr != NULL);

  memset(pin1_value, 0, sizeof(pin1_value));

  /* Retrieve userdata */
  cb_userdata_ptr = (qmi_uimi_userdata_type*)pin_operation_cnf_ptr->response_header.client_data;
  if (cb_userdata_ptr == NULL)
  {
    UIM_MSG_HIGH_0("Null userdata ptr in response");
    return;
  }

  /* Retrieve parameters */
  clid             = cb_userdata_ptr->clid;
  client_reg_count = cb_userdata_ptr->client_reg_count;
  request_id       = cb_userdata_ptr->request_id;
  cmd_buf_p        = (qmi_cmd_buf_type*)cb_userdata_ptr->cmd_buf_ptr;
  QMI_UIM_VALIDATE_CMD_BUF_IN_USERDATA(cb_userdata_ptr);

  /* First check if the requested client is still valid */
  if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
  {
    UIM_MSG_HIGH_0("Invalid Client, not sending indication or response");
    qmi_uim_free_cb_userdata(cb_userdata_ptr);
    return;
  }

  /* Copy PIN1 value from userdata */
  if (cb_userdata_ptr->data.pin_operation.pin1_length > 0 &&
      cb_userdata_ptr->data.pin_operation.pin1_length <= QMI_UIM_TLV_MAX_PIN_LEN)
  {
    pin1_length = cb_userdata_ptr->data.pin_operation.pin1_length;
    (void)memscpy(pin1_value, sizeof(pin1_value),
                  cb_userdata_ptr->data.pin_operation.pin1_value, pin1_length);
  }

  UIM_MSG_HIGH_3("PIN operation: 0x%x, with PIN retries 0x%x, unblock retries 0x%x",
                 pin_operation_cnf_ptr->pin_op,
                 pin_operation_cnf_ptr->pin_info.num_retries,
                 pin_operation_cnf_ptr->pin_info.num_unblock_retries);

  /* Check if an indication needs to be sent instead of a response */
  result_ind_required = cb_userdata_ptr->ind_token.is_valid;
  if (result_ind_required)
  {
    if (FALSE == qmi_uim_response_ind_token(UIMI_TLV_IND_TAG_MANDATORY_1,
                                            &response,
                                            cb_userdata_ptr->ind_token.token))
    {
      UIM_MSG_ERR_0("Could not insert ind_token TLV, not sending indication");
      qmi_uim_free_cb_userdata(cb_userdata_ptr);
      dsm_free_packet(&response);
      return;
    }
  }

  /* Insert retries in the TLV only in case of error */
  if (status != MMGSDI_SUCCESS)
  {
    /* Convert MMGSDI into QMI error code */
    errval = qmi_uim_convert_mmgsdi_status_to_errval(status);

    /* In cases where enable/disable operation of PIN1 or PIN2 is not supported,
       appropriate error code needs to be set */
    /* As per GSM spec 11.11, sec 11.3.3 to disable PIN1 on a 2G card,
       the service n must be "allocated and activated". If not, the
       operation is unsupported */
    if (((pin_operation_cnf_ptr->pin_info.pin_id == MMGSDI_PIN2) &&
         (status == MMGSDI_INCORRECT_PARAMS ||
          status == MMGSDI_WARNING_NO_INFO_GIVEN ||
          status == MMGSDI_NOT_SUPPORTED)) ||
        ((pin_operation_cnf_ptr->pin_info.pin_id == MMGSDI_PIN1) &&
         (status == MMGSDI_NOT_SUPPORTED)))
    {
      mmgsdi_app_enum_type          app_type     = MMGSDI_APP_NONE;
      mmgsdi_session_type_enum_type session_type = MMGSDI_MAX_SESSION_TYPE_ENUM;
      mmgsdi_static_data_type       aid          = { 0, };
      qmi_error_e_type              temp_errval  = QMI_ERR_NONE;

      /* Get the session type in order to get the app_type */
      temp_errval = qmi_uim_session_id_to_session_type(&session_type, &aid,
                                                       pin_operation_cnf_ptr->response_header.session_id);
      if(temp_errval == QMI_ERR_NONE)
      {
        /* Use the session type to get the app_type */
        temp_errval = qmi_uim_session_type_to_card_type(&app_type, session_type, aid);
      }

      if (temp_errval == QMI_ERR_NONE)
      {
        /* PIN2 cannot be disabled on ICC cards */
        if (app_type == MMGSDI_APP_SIM || app_type == MMGSDI_APP_RUIM)
        {
          errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
        }
        else if (app_type == MMGSDI_APP_USIM || app_type == MMGSDI_APP_CSIM)
        {
          if (pin_operation_cnf_ptr->response_header.status_word.present &&
              ((pin_operation_cnf_ptr->response_header.status_word.sw1 == 0x6B &&
                pin_operation_cnf_ptr->response_header.status_word.sw2 == 0x00)||
               (pin_operation_cnf_ptr->response_header.status_word.sw1 == 0x62 &&
                pin_operation_cnf_ptr->response_header.status_word.sw2 == 0x00)||
               (pin_operation_cnf_ptr->response_header.status_word.sw1 == 0x6A &&
                pin_operation_cnf_ptr->response_header.status_word.sw2 == 0x81)))
          {
            errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
          }
        }
      }
    }

    /* Take care of case where PIN is permanently blocked */
    if (errval == QMI_ERR_PIN_BLOCKED &&
        pin_operation_cnf_ptr->pin_info.num_retries == 0 &&
        pin_operation_cnf_ptr->pin_info.num_unblock_retries == 0)
    {
      UIM_MSG_HIGH_0("Force error code to permanent blocked");
      errval = QMI_ERR_PIN_PERM_BLOCKED;
    }

    /* Add TLV with number of retries */
    if (FALSE == qmi_uim_response_retries_left(
                    UIMI_TLV_RESP_TAG_OPTIONAL_1,
                    &response,
                    pin_operation_cnf_ptr->pin_info.num_retries,
                    pin_operation_cnf_ptr->pin_info.num_unblock_retries))
    {
      errval = QMI_ERR_NO_MEMORY;
      dsm_free_packet(&response);
    }
  }
  else
  {
    /* Encrypt the PIN1 and return it */
    if ((pin1_length > 0) && (qmi_uim_global_ptr->silent_pin1_supported))
    {
      uint8   encrypted_pin1_length    = QMI_UIM_TLV_MAX_ENCRYPTED_PIN1_LEN;
      uint8 * encrypted_pin1_value_ptr = NULL;

      encrypted_pin1_value_ptr = (uint8*)uimqmi_malloc(encrypted_pin1_length);
      if (encrypted_pin1_value_ptr != NULL)
      {
        UIM_MSG_HIGH_0("Encrypting PIN1 value");

        memset(encrypted_pin1_value_ptr, 0, encrypted_pin1_length);

        if (qmi_uim_encrypt_pin(pin1_length,
                                pin1_value,
                                &encrypted_pin1_length,
                                encrypted_pin1_value_ptr))
        {
          /* Add encrypted PIN1 TLV */
          if (FALSE == qmi_uim_response_encrypted_pin1(
                           UIMI_TLV_RESP_TAG_OPTIONAL_2,
                           &response,
                           encrypted_pin1_length,
                           encrypted_pin1_value_ptr))
          {
            UIM_MSG_HIGH_0("Error in constructing encrypted pin1, ignoring TLV");
          }
        }
        uimqmi_free(encrypted_pin1_value_ptr);
      }
    }
  }

  /* Insert card result in the TLV: this is always present */
  if (FALSE == qmi_uim_response_card_result(
                 (result_ind_required) ? UIMI_TLV_RESP_TAG_OPTIONAL_3 : UIMI_TLV_RESP_TAG_OPTIONAL_4,
                 &response,
                 pin_operation_cnf_ptr->response_header.status_word))
  {
    errval = QMI_ERR_NO_MEMORY;
    dsm_free_packet(&response);
  }

  /* Update PIN retries and state in the global variable */
  card_ind_required = qmi_uim_update_pin_retries_and_state(pin_operation_cnf_ptr);

  /* Free userdata, this also takes care of clearing temporarily stored PIN1 */
  qmi_uim_free_cb_userdata(cb_userdata_ptr);
  cb_userdata_ptr = NULL;

  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    QMI_UIM_FREE_CMD_BUF(cmd_buf_p);
    return;
  }

  /* Send response or indiction */
  if (result_ind_required)
  {
    retval = qmi_uimi_send_indication(clid,
                                      (uint16)request_id,
                                      response);
  }
  else
  {
    retval = qmi_uimi_send_response(cmd_buf_p,
                                    response);
  }

  if (FALSE == retval)
  {
    UIM_MSG_HIGH_0("Unable to send response for PIN operation");
    dsm_free_packet(&response);
    QMI_UIM_FREE_CMD_BUF(cmd_buf_p);
  }

  /* If indication is required, send it to all clients */
  if (card_ind_required)
  {
    if (pin_operation_cnf_ptr->response_header.slot_id <= MMGSDI_SLOT_2)
    {
      qmi_uim_send_card_status_indication_to_all(TRUE, FALSE, TRUE);
    }
    else
    {
      qmi_uim_send_card_status_indication_to_all(FALSE, FALSE, TRUE);
    }
  }
} /* qmi_uimi_pin_operation_resp */


/*===========================================================================
  FUNCTION QMI_UIMI_RUN_CAVE_RESP()

  DESCRIPTION
    Composes either the response or indication for the authenticate function

  PARAMETERS
    status           : status of MMGSDI operation
    run_cave_cnf_ptr : result of MMGSDI operation

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_run_cave_resp
(
  mmgsdi_return_enum_type          status,
  const mmgsdi_run_cave_cnf_type * run_cave_cnf_ptr
)
{
  qmi_cmd_buf_type *       cmd_buf_p        = NULL;
  qmi_uimi_userdata_type * cb_userdata_ptr  = NULL;
  dsm_item_type *          response         = NULL;
  qmi_error_e_type         errval           = QMI_ERR_NONE;
  qmi_result_e_type        result           = QMI_RESULT_SUCCESS;
  boolean                  retval           = TRUE;
  boolean                  ind_required     = FALSE;
  uint8                    clid             = QMI_SVC_CLID_UNUSED;
  uint32                   client_reg_count = 0;

  UIM_MSG_HIGH_0("Sending response for run cave");

  ASSERT( run_cave_cnf_ptr );

  /* Retrieve userdata */
  cb_userdata_ptr = (qmi_uimi_userdata_type*)run_cave_cnf_ptr->response_header.client_data;
  if (cb_userdata_ptr == NULL)
  {
    UIM_MSG_HIGH_0("Null userdata ptr in response");
    return;
  }

  /* Retrieve parameters */
  clid             = cb_userdata_ptr->clid;
  client_reg_count = cb_userdata_ptr->client_reg_count;
  cmd_buf_p        = (qmi_cmd_buf_type*)cb_userdata_ptr->cmd_buf_ptr;
  QMI_UIM_VALIDATE_CMD_BUF_IN_USERDATA(cb_userdata_ptr);

  /* First check if the requested client is still valid */
  if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
  {
    UIM_MSG_HIGH_0("Invalid Client, not sending indication or response");
    qmi_uim_free_cb_userdata(cb_userdata_ptr);
    return;
  }

  /* Check if an indication needs to be sent instead of a response */
  ind_required = cb_userdata_ptr->ind_token.is_valid;
  if (ind_required)
  {
    if (FALSE == qmi_uim_response_ind_token(UIMI_TLV_IND_TAG_MANDATORY_1,
                                            &response,
                                            cb_userdata_ptr->ind_token.token))
    {
      UIM_MSG_ERR_0("Could not insert ind_token TLV, not sending indication");
      qmi_uim_free_cb_userdata(cb_userdata_ptr);
      dsm_free_packet(&response);
      return;
    }
  }

  /* Insert card result in the TLV: this is always present */
  if (qmi_uim_response_card_result(UIMI_TLV_RESP_TAG_OPTIONAL_1,
                                   &response,
                                   run_cave_cnf_ptr->response_header.status_word))
  {
    /* Insert authenticate body in the TLV: only in case of success */
    if (status == MMGSDI_SUCCESS)
    {
      if (FALSE == qmi_uim_response_authenticate_cave(
                              UIMI_TLV_RESP_TAG_OPTIONAL_2,
                              &response,
                              run_cave_cnf_ptr->run_cave_response_data))
      {
        errval = QMI_ERR_NO_MEMORY;
        dsm_free_packet(&response);
      }
    }
    else
    {
      /* Convert MMGSDI status to QMI err code */
      errval = qmi_uim_convert_mmgsdi_status_to_errval(status);
    }
  }
  else
  {
    errval = QMI_ERR_NO_MEMORY;
    dsm_free_packet(&response);
  }

  /* Free userdata */
  qmi_uim_free_cb_userdata(cb_userdata_ptr);
  cb_userdata_ptr = NULL;

  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    QMI_UIM_FREE_CMD_BUF(cmd_buf_p);
    return;
  }

  /* Send response or indication */
  if (ind_required)
  {
    retval = qmi_uimi_send_indication(clid,
                                     (uint16)UIMI_CMD_VAL_AUTHENTICATE,
                                     response);
  }
  else
  {
    retval = qmi_uimi_send_response(cmd_buf_p,
                                    response);
  }
  if (FALSE == retval)
  {
    UIM_MSG_HIGH_0("Unable to send response for Run cave operation");
    dsm_free_packet(&response);
    QMI_UIM_FREE_CMD_BUF(cmd_buf_p);
  }
} /* qmi_uimi_run_cave_resp */


/*===========================================================================
  FUNCTION QMI_UIMI_RUN_GSM_ALGO_RESP()

  DESCRIPTION
    Composes either the response or indication for the authenticate function

  PARAMETERS
    status               : status of MMGSDI operation
    run_gsm_algo_cnf_ptr : result of MMGSDI operation

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_run_gsm_algo_resp
(
  mmgsdi_return_enum_type                      status,
  const mmgsdi_session_run_gsm_algo_cnf_type * run_gsm_algo_cnf_ptr
)
{
  qmi_cmd_buf_type *       cmd_buf_p        = NULL;
  qmi_uimi_userdata_type * cb_userdata_ptr  = NULL;
  dsm_item_type *          response         = NULL;
  qmi_error_e_type         errval           = QMI_ERR_NONE;
  qmi_result_e_type        result           = QMI_RESULT_SUCCESS;
  boolean                  retval           = TRUE;
  boolean                  ind_required     = FALSE;
  uint8                    clid             = QMI_SVC_CLID_UNUSED;
  uint32                   client_reg_count = 0;

  UIM_MSG_HIGH_0("Sending response for run GSM algo");

  ASSERT( run_gsm_algo_cnf_ptr );

  /* Retrieve userdata */
  cb_userdata_ptr = (qmi_uimi_userdata_type*)run_gsm_algo_cnf_ptr->response_header.client_data;
  if (cb_userdata_ptr == NULL)
  {
    UIM_MSG_HIGH_0("Null userdata ptr in response");
    return;
  }

  /* Retrieve parameters */
  clid             = cb_userdata_ptr->clid;
  client_reg_count = cb_userdata_ptr->client_reg_count;
  cmd_buf_p        = (qmi_cmd_buf_type*)cb_userdata_ptr->cmd_buf_ptr;
  QMI_UIM_VALIDATE_CMD_BUF_IN_USERDATA(cb_userdata_ptr);

  /* First check if the requested client is still valid */
  if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
  {
    UIM_MSG_HIGH_0("Invalid Client, not sending indication or response");
    qmi_uim_free_cb_userdata(cb_userdata_ptr);
    return;
  }

  /* Check if an indication needs to be sent instead of a response */
  ind_required = cb_userdata_ptr->ind_token.is_valid;
  if (ind_required)
  {
    if (FALSE == qmi_uim_response_ind_token(UIMI_TLV_IND_TAG_MANDATORY_1,
                                            &response,
                                            cb_userdata_ptr->ind_token.token))
    {
      UIM_MSG_ERR_0("Could not insert ind_token TLV, not sending indication");
      qmi_uim_free_cb_userdata(cb_userdata_ptr);
      dsm_free_packet(&response);
      return;
    }
  }

  /* Insert card result in the TLV: this is always present */
  if (qmi_uim_response_card_result(UIMI_TLV_RESP_TAG_OPTIONAL_1,
                                   &response,
                                   run_gsm_algo_cnf_ptr->response_header.status_word))
  {
    /* Insert authenticate body in the TLV: only in case of success */
    if (status == MMGSDI_SUCCESS)
    {
      if (FALSE == qmi_uim_response_authenticate_gsm_algo(
                              UIMI_TLV_RESP_TAG_OPTIONAL_2,
                              &response,
                              run_gsm_algo_cnf_ptr->sres_resp,
                              run_gsm_algo_cnf_ptr->kc_resp))
      {
        errval = QMI_ERR_NO_MEMORY;
        dsm_free_packet(&response);
      }
    }
    else
    {
      /* Convert MMGSDI status to QMI err code */
      errval = qmi_uim_convert_mmgsdi_status_to_errval(status);
    }
  }
  else
  {
    errval = QMI_ERR_NO_MEMORY;
    dsm_free_packet(&response);
  }

  /* Free userdata */
  qmi_uim_free_cb_userdata(cb_userdata_ptr);
  cb_userdata_ptr = NULL;

  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    QMI_UIM_FREE_CMD_BUF(cmd_buf_p);
    return;
  }

  /* Send response or indication */
  if (ind_required)
  {
    retval = qmi_uimi_send_indication(clid,
                                     (uint16)UIMI_CMD_VAL_AUTHENTICATE,
                                     response);
  }
  else
  {
    retval = qmi_uimi_send_response(cmd_buf_p,
                                    response);
  }
  if (FALSE == retval)
  {
    UIM_MSG_HIGH_0("Unable to send response for Run GSM algo operation");
    dsm_free_packet(&response);
    QMI_UIM_FREE_CMD_BUF(cmd_buf_p);
  }
} /* qmi_uimi_run_gsm_algo_resp */


/*===========================================================================
  FUNCTION QMI_UIMI_ISIM_AUTH_RESP()

  DESCRIPTION
    Composes either the response or indication for the authenticate function

  PARAMETERS
    status            : status of MMGSDI operation
    isim_auth_cnf_ptr : result of MMGSDI operation

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_isim_auth_resp
(
  mmgsdi_return_enum_type           status,
  const mmgsdi_isim_auth_cnf_type * isim_auth_cnf_ptr
)
{
  qmi_cmd_buf_type *       cmd_buf_p        = NULL;
  qmi_uimi_userdata_type * cb_userdata_ptr  = NULL;
  dsm_item_type *          response         = NULL;
  qmi_error_e_type         errval           = QMI_ERR_NONE;
  qmi_result_e_type        result           = QMI_RESULT_SUCCESS;
  boolean                  retval           = TRUE;
  boolean                  ind_required     = FALSE;
  uint8                    clid             = QMI_SVC_CLID_UNUSED;
  uint32                   client_reg_count = 0;

  UIM_MSG_HIGH_0("Sending response for ISIM authenticate");

  ASSERT( isim_auth_cnf_ptr );

  /* Retrieve userdata */
  cb_userdata_ptr = (qmi_uimi_userdata_type*)isim_auth_cnf_ptr->response_header.client_data;
  if (cb_userdata_ptr == NULL)
  {
    UIM_MSG_HIGH_0("Null userdata ptr in response");
    return;
  }

  /* Retrieve parameters */
  clid             = cb_userdata_ptr->clid;
  client_reg_count = cb_userdata_ptr->client_reg_count;
  cmd_buf_p        = (qmi_cmd_buf_type*)cb_userdata_ptr->cmd_buf_ptr;
  QMI_UIM_VALIDATE_CMD_BUF_IN_USERDATA(cb_userdata_ptr);

  /* First check if the requested client is still valid */
  if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
  {
    UIM_MSG_HIGH_0("Invalid Client, not sending indication or response");
    qmi_uim_free_cb_userdata(cb_userdata_ptr);
    return;
  }

  /* Check if an indication needs to be sent instead of a response */
  ind_required = cb_userdata_ptr->ind_token.is_valid;
  if (ind_required)
  {
    if (FALSE == qmi_uim_response_ind_token(UIMI_TLV_IND_TAG_MANDATORY_1,
                                            &response,
                                            cb_userdata_ptr->ind_token.token))
    {
      UIM_MSG_ERR_0("Could not insert ind_token TLV, not sending indication");
      qmi_uim_free_cb_userdata(cb_userdata_ptr);
      dsm_free_packet(&response);
      return;
    }
  }

  /* Insert card result in the TLV: this is always present */
  if (qmi_uim_response_card_result(UIMI_TLV_RESP_TAG_OPTIONAL_1,
                                   &response,
                                   isim_auth_cnf_ptr->response_header.status_word))
  {
    /* Insert authenticate body in the TLV: in case of success or
       Authentication Sequence Counter failure */
    if (status == MMGSDI_SUCCESS ||
        status == MMGSDI_AUTS_FAIL)
    {
      if (FALSE == qmi_uim_response_authenticate_isim(
                              UIMI_TLV_RESP_TAG_OPTIONAL_2,
                              &response,
                              status,
                              cb_userdata_ptr->data.authenticate.auth_context,
                              isim_auth_cnf_ptr->res,
                              isim_auth_cnf_ptr->ck,
                              isim_auth_cnf_ptr->ik,
                              isim_auth_cnf_ptr->auts))
      {
        errval = QMI_ERR_NO_MEMORY;
        dsm_free_packet(&response);
      }
    }
    if (status != MMGSDI_SUCCESS)
    {
      /* Convert MMGSDI status to QMI err code */
      errval = qmi_uim_convert_mmgsdi_status_to_errval(status);
    }
  }
  else
  {
    errval = QMI_ERR_NO_MEMORY;
    dsm_free_packet(&response);
  }

  /* Free userdata */
  qmi_uim_free_cb_userdata(cb_userdata_ptr);
  cb_userdata_ptr = NULL;

  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    QMI_UIM_FREE_CMD_BUF(cmd_buf_p);
    return;
  }

  /* Send response or indication */
  if (ind_required)
  {
    retval = qmi_uimi_send_indication(clid,
                                     (uint16)UIMI_CMD_VAL_AUTHENTICATE,
                                     response);
  }
  else
  {
    retval = qmi_uimi_send_response(cmd_buf_p,
                                    response);
  }
  if (FALSE == retval)
  {
    UIM_MSG_HIGH_0("Unable to send response for ISIM authenticate");
    dsm_free_packet(&response);
    QMI_UIM_FREE_CMD_BUF(cmd_buf_p);
  }
} /* qmi_uimi_isim_auth_resp */


/*===========================================================================
  FUNCTION QMI_UIMI_USIM_AUTH_RESP()

  DESCRIPTION
    Composes either the response or indication for the authenticate function

  PARAMETERS
    status            : status of MMGSDI operation
    usim_auth_cnf_ptr : result of MMGSDI operation

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_usim_auth_resp
(
  mmgsdi_return_enum_type           status,
  const mmgsdi_usim_auth_cnf_type * usim_auth_cnf_ptr
)
{
  qmi_cmd_buf_type *       cmd_buf_p        = NULL;
  dsm_item_type *          response         = NULL;
  qmi_uimi_userdata_type * cb_userdata_ptr  = NULL;
  qmi_error_e_type         errval           = QMI_ERR_NONE;
  qmi_result_e_type        result           = QMI_RESULT_SUCCESS;
  boolean                  retval           = TRUE;
  boolean                  ind_required     = FALSE;
  uint8                    clid             = QMI_SVC_CLID_UNUSED;
  uint32                   client_reg_count = 0;

  UIM_MSG_HIGH_0("Sending response for USIM authenticate");

  ASSERT( usim_auth_cnf_ptr );

  /* Retrieve userdata */
  cb_userdata_ptr = (qmi_uimi_userdata_type*)usim_auth_cnf_ptr->response_header.client_data;
  if (cb_userdata_ptr == NULL)
  {
    UIM_MSG_HIGH_0("Null userdata ptr in response");
    return;
  }

  /* Retrieve parameters */
  clid             = cb_userdata_ptr->clid;
  client_reg_count = cb_userdata_ptr->client_reg_count;
  cmd_buf_p        = (qmi_cmd_buf_type*)cb_userdata_ptr->cmd_buf_ptr;
  QMI_UIM_VALIDATE_CMD_BUF_IN_USERDATA(cb_userdata_ptr);

  /* First check if the requested client is still valid */
  if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
  {
    UIM_MSG_HIGH_0("Invalid Client, not sending indication or response");
    qmi_uim_free_cb_userdata(cb_userdata_ptr);
    return;
  }

  /* Check if an indication needs to be sent instead of a response */
  ind_required = cb_userdata_ptr->ind_token.is_valid;
  if (ind_required)
  {
    if (FALSE == qmi_uim_response_ind_token(UIMI_TLV_IND_TAG_MANDATORY_1,
                                            &response,
                                            cb_userdata_ptr->ind_token.token))
    {
      UIM_MSG_ERR_0("Could not insert ind_token TLV, not sending indication");
      qmi_uim_free_cb_userdata(cb_userdata_ptr);
      dsm_free_packet(&response);
      return;
    }
  }

  /* Insert card result in the TLV: this is always present */
  if (qmi_uim_response_card_result(UIMI_TLV_RESP_TAG_OPTIONAL_1,
                                   &response,
                                   usim_auth_cnf_ptr->response_header.status_word))
  {
    /* Insert authenticate body in the TLV */
    if (usim_auth_cnf_ptr->auth_response.data_len > 0 &&
        usim_auth_cnf_ptr->auth_response.data_ptr != NULL)
    {
      if (FALSE == qmi_uim_response_authenticate_generic(
                              UIMI_TLV_RESP_TAG_OPTIONAL_2,
                              &response,
                              usim_auth_cnf_ptr->auth_response))
      {
        errval = QMI_ERR_NO_MEMORY;
        dsm_free_packet(&response);
      }
    }
    else
    {
      /* Convert MMGSDI status to QMI err code */
      errval = qmi_uim_convert_mmgsdi_status_to_errval(status);
    }
  }
  else
  {
    errval = QMI_ERR_NO_MEMORY;
    dsm_free_packet(&response);
  }

  /* Free userdata */
  qmi_uim_free_cb_userdata(cb_userdata_ptr);
  cb_userdata_ptr = NULL;

  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    QMI_UIM_FREE_CMD_BUF(cmd_buf_p);
    return;
  }

  /* Send response or indication */
  if (ind_required)
  {
    retval = qmi_uimi_send_indication(clid,
                                     (uint16)UIMI_CMD_VAL_AUTHENTICATE,
                                     response);
  }
  else
  {
    retval = qmi_uimi_send_response(cmd_buf_p,
                                    response);
  }
  if (FALSE == retval)
  {
    UIM_MSG_HIGH_0("Unable to send response for USIM authenticate");
    dsm_free_packet(&response);
    QMI_UIM_FREE_CMD_BUF(cmd_buf_p);
  }
} /* qmi_uimi_usim_auth_resp */


/*===========================================================================
  FUNCTION QMI_UIMI_COMPUTE_IP_AUTH_RESP()

  DESCRIPTION
    Composes either the response or indication for the authenticate function

  PARAMETERS
    status                  : status of MMGSDI operation
    compute_ip_auth_cnf_ptr : result of MMGSDI operation

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_compute_ip_auth_resp
(
  mmgsdi_return_enum_type                 status,
  const mmgsdi_compute_ip_auth_cnf_type * compute_ip_auth_cnf_ptr
)
{
  qmi_cmd_buf_type *       cmd_buf_p        = NULL;
  dsm_item_type *          response         = NULL;
  qmi_uimi_userdata_type * cb_userdata_ptr  = NULL;
  qmi_error_e_type         errval           = QMI_ERR_NONE;
  qmi_result_e_type        result           = QMI_RESULT_SUCCESS;
  boolean                  retval           = TRUE;
  boolean                  ind_required     = FALSE;
  uint8                    clid             = QMI_SVC_CLID_UNUSED;
  uint32                   client_reg_count = 0;

  UIM_MSG_HIGH_0("Sending response for Compute IP authentication");

  ASSERT( compute_ip_auth_cnf_ptr );

  /* Retrieve userdata */
  cb_userdata_ptr = (qmi_uimi_userdata_type*)compute_ip_auth_cnf_ptr->response_header.client_data;
  if (cb_userdata_ptr == NULL)
  {
    UIM_MSG_HIGH_0("Null userdata ptr in response");
    return;
  }

  /* Retrieve parameters */
  clid             = cb_userdata_ptr->clid;
  client_reg_count = cb_userdata_ptr->client_reg_count;
  cmd_buf_p        = (qmi_cmd_buf_type*)cb_userdata_ptr->cmd_buf_ptr;
  QMI_UIM_VALIDATE_CMD_BUF_IN_USERDATA(cb_userdata_ptr);

  /* First check if the requested client is still valid */
  if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
  {
    UIM_MSG_HIGH_0("Invalid Client, not sending indication or response");
    qmi_uim_free_cb_userdata(cb_userdata_ptr);
    return;
  }

  /* Check if an indication needs to be sent instead of a response */
  ind_required = cb_userdata_ptr->ind_token.is_valid;
  if (ind_required)
  {
    if (FALSE == qmi_uim_response_ind_token(UIMI_TLV_IND_TAG_MANDATORY_1,
                                            &response,
                                            cb_userdata_ptr->ind_token.token))
    {
      UIM_MSG_ERR_0("Could not insert ind_token TLV, not sending indication");
      qmi_uim_free_cb_userdata(cb_userdata_ptr);
      dsm_free_packet(&response);
      return;
    }
  }

  /* Insert card result in the TLV: this is always present */
  if (qmi_uim_response_card_result(UIMI_TLV_RESP_TAG_OPTIONAL_1,
                                   &response,
                                   compute_ip_auth_cnf_ptr->response_header.status_word))
  {
    /* Insert authenticate body in the TLV */
    if (compute_ip_auth_cnf_ptr->cmpt_ip_response_data.data_len > 0 &&
        compute_ip_auth_cnf_ptr->cmpt_ip_response_data.data_ptr != NULL)
    {
      if (FALSE == qmi_uim_response_authenticate_generic(
                              UIMI_TLV_RESP_TAG_OPTIONAL_2,
                              &response,
                              compute_ip_auth_cnf_ptr->cmpt_ip_response_data))
      {
        errval = QMI_ERR_NO_MEMORY;
        dsm_free_packet(&response);
      }
    }
    else
    {
      /* Convert MMGSDI status to QMI err code */
      errval = qmi_uim_convert_mmgsdi_status_to_errval(status);
    }
  }
  else
  {
    errval = QMI_ERR_NO_MEMORY;
    dsm_free_packet(&response);
  }

  /* Free userdata */
  qmi_uim_free_cb_userdata(cb_userdata_ptr);
  cb_userdata_ptr = NULL;

  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    QMI_UIM_FREE_CMD_BUF(cmd_buf_p);
    return;
  }

  /* Send response or indication */
  if (ind_required)
  {
    retval = qmi_uimi_send_indication(clid,
                                     (uint16)UIMI_CMD_VAL_AUTHENTICATE,
                                     response);
  }
  else
  {
    retval = qmi_uimi_send_response(cmd_buf_p,
                                    response);
  }
  if (FALSE == retval)
  {
    UIM_MSG_HIGH_0("Unable to send response for Compute IP authentication");
    dsm_free_packet(&response);
    QMI_UIM_FREE_CMD_BUF(cmd_buf_p);
  }
} /* qmi_uimi_compute_ip_auth_resp */


/*===========================================================================
  FUNCTION QMI_UIMI_SET_SERVICE_RESP()

  DESCRIPTION
    Composes the response for the set service function

  PARAMETERS
    status                  : status of MMGSDI operation
    response_header_cnf_ptr : result of MMGSDI operation

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_set_service_resp
(
  mmgsdi_return_enum_type             status,
  const mmgsdi_response_header_type * response_header_cnf_ptr
)
{
  qmi_cmd_buf_type *       cmd_buf_p        = NULL;
  qmi_uimi_userdata_type * cb_userdata_ptr  = NULL;
  dsm_item_type *          response         = NULL;
  qmi_error_e_type         errval           = QMI_ERR_NONE;
  qmi_result_e_type        result           = QMI_RESULT_SUCCESS;
  boolean                  retval           = TRUE;
  uint8                    clid             = QMI_SVC_CLID_UNUSED;
  uint32                   client_reg_count = 0;

  UIM_MSG_HIGH_0("Sending response for set service");

  ASSERT( response_header_cnf_ptr );

  /* Retrieve userdata */
  cb_userdata_ptr = (qmi_uimi_userdata_type*)response_header_cnf_ptr->client_data;
  if (cb_userdata_ptr == NULL)
  {
    UIM_MSG_HIGH_0("Null userdata ptr in response");
    return;
  }

  /* Retrieve parameters */
  clid             = cb_userdata_ptr->clid;
  client_reg_count = cb_userdata_ptr->client_reg_count;
  cmd_buf_p = (qmi_cmd_buf_type*)cb_userdata_ptr->cmd_buf_ptr;

  /* Free userdata */
  qmi_uim_free_cb_userdata(cb_userdata_ptr);
  cb_userdata_ptr = NULL;

  /* First check if the requested client is still valid */
  if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
  {
    UIM_MSG_HIGH_0("Invalid Client, not sending response");
    return;
  }

  if (cmd_buf_p == NULL)
  {
    UIM_MSG_HIGH_0("Null cmd_buf ptr in response");
    return;
  }

  QMI_UIM_VALIDATE_SP_IN_CMD_BUF(cmd_buf_p);

  /* Convert result */
  errval = qmi_uim_convert_mmgsdi_status_to_errval(status);

  /* Convert to a specific result code*/
  if (status == MMGSDI_ACCESS_DENIED)
  {
    UIM_MSG_HIGH_0("QMI Set Service with error in PIN2 restriction");
    errval = QMI_ERR_PIN2_RESTRICTION;
  }

  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    ds_qmi_fw_free_cmd_buf( &cmd_buf_p );
    return;
  }

  /* Send response */
  if (FALSE == qmi_uimi_send_response(cmd_buf_p,
                                      response))
  {
    UIM_MSG_HIGH_0("Unable to send response for USIM authenticate");
    dsm_free_packet(&response);
  }
} /* qmi_uimi_set_service_resp */


/*===========================================================================
  FUNCTION QMI_UIMI_GET_SERVICE_ENABLED_RESP()

  DESCRIPTION
    Composes the response for the get service function

  PARAMETERS
    status                   : status of MMGSDI operation
    app_capabilities_cnf_ptr : result of MMGSDI operation

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_get_service_enabled_resp
(
  mmgsdi_return_enum_type                          status,
  const mmgsdi_session_app_capabilities_cnf_type * app_capabilities_cnf_ptr
)
{
  qmi_cmd_buf_type *       cmd_buf_p        = NULL;
  qmi_uimi_userdata_type * cb_userdata_ptr  = NULL;
  dsm_item_type *          response         = NULL;
  qmi_error_e_type         errval           = QMI_ERR_NONE;
  qmi_result_e_type        result           = QMI_RESULT_SUCCESS;
  boolean                  retval           = TRUE;
  uint8                    clid             = QMI_SVC_CLID_UNUSED;
  uint32                   client_reg_count = 0;
  mmgsdi_service_enum_type service_id       = MMGSDI_NONE;

  UIM_MSG_HIGH_0("Sending response for get service");

  ASSERT( app_capabilities_cnf_ptr );

  /* Retrieve userdata */
  cb_userdata_ptr = (qmi_uimi_userdata_type*)app_capabilities_cnf_ptr->response_header.client_data;
  if (cb_userdata_ptr == NULL)
  {
    UIM_MSG_HIGH_0("Null userdata ptr in response");
    return;
  }

  service_id = cb_userdata_ptr->data.get_service_status.service_id;

  /* Retrieve parameters */
  clid             = cb_userdata_ptr->clid;
  client_reg_count = cb_userdata_ptr->client_reg_count;
  cmd_buf_p = (qmi_cmd_buf_type*)cb_userdata_ptr->cmd_buf_ptr;

  /* Free userdata */
  qmi_uim_free_cb_userdata(cb_userdata_ptr);
  cb_userdata_ptr = NULL;

  /* First check if the requested client is still valid */
  if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
  {
    UIM_MSG_HIGH_0("Invalid Client, not sending response");
    return;
  }

  if (cmd_buf_p == NULL)
  {
    UIM_MSG_HIGH_0("Null cmd_buf ptr in response");
    return;
  }

  QMI_UIM_VALIDATE_SP_IN_CMD_BUF(cmd_buf_p);

  /* Insert FDN status in the TLV */
  if (status == MMGSDI_SUCCESS)
  {
    /* We currently support only FDN and ACL. */
    if ((service_id == MMGSDI_GSM_SRV_FDN ||
         service_id == MMGSDI_CDMA_SRV_FDN ||
         service_id == MMGSDI_CSIM_SRV_FDN ||
         service_id == MMGSDI_USIM_SRV_FDN) &&
        FALSE == qmi_uim_response_service_status(
                            UIMI_TLV_RESP_TAG_OPTIONAL_1,
                            &response,
                            TRUE,
                            app_capabilities_cnf_ptr->fdn_enabled))
    {
      errval = QMI_ERR_NO_MEMORY;
      dsm_free_packet(&response);
    }
    else if ((service_id == MMGSDI_USIM_SRV_ACL) &&
             FALSE == qmi_uim_response_service_status(
                            UIMI_TLV_RESP_TAG_OPTIONAL_5,
                            &response,
                            TRUE,
                            app_capabilities_cnf_ptr->acl_enabled))
    {
      errval = QMI_ERR_NO_MEMORY;
      dsm_free_packet(&response);
    }
  }
  else
  {
    /* Convert MMGSDI status to QMI err code */
    errval = qmi_uim_convert_mmgsdi_status_to_errval(status);
  }

  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    ds_qmi_fw_free_cmd_buf( &cmd_buf_p );
    return;
  }

  /* Send response */
  if (FALSE == qmi_uimi_send_response(cmd_buf_p,
                                      response))
  {
    UIM_MSG_HIGH_0("Unable to send response for get service status");
    dsm_free_packet(&response);
  }
} /* qmi_uimi_get_service_enabled_resp */


/*===========================================================================
  FUNCTION QMI_UIMI_GET_SERVICE_AVAILABLE_RESP()

  DESCRIPTION
    Composes the response for the get service status function

  PARAMETERS
    status                : status of MMGSDI operation
    srv_available_cnf_ptr : result of MMGSDI operation

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_get_service_available_resp
(
  mmgsdi_return_enum_type               status,
  const mmgsdi_srv_available_cnf_type * srv_available_cnf_ptr
)
{
  qmi_cmd_buf_type *       cmd_buf_p         = NULL;
  qmi_uimi_userdata_type * cb_userdata_ptr   = NULL;
  dsm_item_type *          response          = NULL;
  mmgsdi_return_enum_type  mmgsdi_status     = MMGSDI_SUCCESS;
  qmi_error_e_type         errval            = QMI_ERR_NONE;
  qmi_result_e_type        result            = QMI_RESULT_SUCCESS;
  boolean                  retval            = TRUE;
  uint8                    clid              = QMI_SVC_CLID_UNUSED;
  uint32                   client_reg_count  = 0;
  mmgsdi_service_enum_type service_id        = MMGSDI_NONE;

  UIM_MSG_HIGH_0("Get service available status");

  ASSERT( srv_available_cnf_ptr );

  /* Retrieve userdata */
  cb_userdata_ptr = (qmi_uimi_userdata_type*)srv_available_cnf_ptr->response_header.client_data;
  if (cb_userdata_ptr == NULL)
  {
    UIM_MSG_HIGH_0("Null userdata ptr in response");
    return;
  }

  /* We currently support only FDN, so there is no need to make
     any check on which service is being requested. It needs to
     be improved in future, if additional services are supported */

  if (status == MMGSDI_SUCCESS)
  {
    /* if service is available, get service status */
    if (srv_available_cnf_ptr->srv_available)
    {
      mmgsdi_status = mmgsdi_session_get_app_capabilities(
                      srv_available_cnf_ptr->response_header.session_id,
                      qmi_uimi_mmgsdi_callback,
                      (mmgsdi_client_data_type)cb_userdata_ptr);
      if (mmgsdi_status == MMGSDI_SUCCESS)
      {
        UIM_MSG_HIGH_0("Retrieving FDN status");
        return;
      }
      /* Convert MMGSDI status to QMI err code */
      errval = qmi_uim_convert_mmgsdi_status_to_errval(mmgsdi_status);
    }
  }
  else
  {
  /* Convert MMGSDI status to QMI err code */
  errval = qmi_uim_convert_mmgsdi_status_to_errval(status);
  }

  /* FDN/ACL is not available or there was an error... proceed with response */
  UIM_MSG_HIGH_0("FDN/ACL not available or error");

  service_id = cb_userdata_ptr->data.get_service_status.service_id;

  /* Retrieve parameters */
  clid             = cb_userdata_ptr->clid;
  client_reg_count = cb_userdata_ptr->client_reg_count;
  cmd_buf_p = (qmi_cmd_buf_type*)cb_userdata_ptr->cmd_buf_ptr;

  /* Free userdata */
  qmi_uim_free_cb_userdata(cb_userdata_ptr);
  cb_userdata_ptr = NULL;

  /* First check if the requested client is still valid */
  if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
  {
    UIM_MSG_HIGH_0("Invalid Client, not sending indication or response");
    return;
  }

  if (cmd_buf_p == NULL)
  {
    UIM_MSG_HIGH_0("Null cmd_buf ptr in response");
    return;
  }

  QMI_UIM_VALIDATE_SP_IN_CMD_BUF(cmd_buf_p);

  /* Insert service status result in the TLV */
  if (errval == QMI_ERR_NONE)
  {
    if (service_id == MMGSDI_GSM_SRV_FDN ||
             service_id == MMGSDI_CDMA_SRV_FDN ||
             service_id == MMGSDI_USIM_SRV_FDN ||
             service_id == MMGSDI_CSIM_SRV_FDN)
    {
      /* The reuqest was to find out if the FDN service is available and enabled.
         We reached here because MMGSDI indicated the service is not available,
         hence, no need to proceed with get_app_capabilities to find out if the
         service is enabled */
      if (FALSE == qmi_uim_response_service_status(
                    UIMI_TLV_RESP_TAG_OPTIONAL_1,
                    &response,
                    FALSE,
                    FALSE))
      {
        errval = QMI_ERR_NO_MEMORY;
        dsm_free_packet(&response);
      }
    }
    else if (service_id == MMGSDI_USIM_SRV_ACL)
    {
      /* The reuqest was to find out if the ACL service is available and enabled.
         We reached here because MMGSDI indicated the service is not available,
         hence, no need to proceed with get_app_capabilities to find out if the
         service is enabled */
      if (FALSE == qmi_uim_response_service_status(
                      UIMI_TLV_RESP_TAG_OPTIONAL_5,
                      &response,
                      FALSE,
                      FALSE))
      {
        errval = QMI_ERR_NO_MEMORY;
        dsm_free_packet(&response);
      }
    }
  }

  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    ds_qmi_fw_free_cmd_buf( &cmd_buf_p );
    return;
  }

  /* Send response */
  if (FALSE == qmi_uimi_send_response(cmd_buf_p,
                                      response))
  {
    UIM_MSG_HIGH_0("Unable to send response for get service status");
    dsm_free_packet(&response);
  }
} /* qmi_uimi_get_service_available_resp */


/*===========================================================================
  FUNCTION QMI_UIMI_GET_ALL_PIN_STATUS_RESP()

  DESCRIPTION
    Composes the response for the get all pin status function

  PARAMETERS
    status                     : status of MMGSDI operation
    get_all_pin_status_cnf_ptr : result of MMGSDI operation

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_get_all_pin_status_resp
(
  mmgsdi_return_enum_type                    status,
  const mmgsdi_get_all_pin_status_cnf_type * get_all_pin_status_cnf_ptr
)
{
  qmi_cmd_buf_type *       cmd_buf_p       = NULL;
  qmi_uimi_userdata_type * cb_userdata_ptr = NULL;
  dsm_item_type *          response        = NULL;
  qmi_error_e_type         errval          = QMI_ERR_NONE;
  qmi_result_e_type        result          = QMI_RESULT_SUCCESS;
  boolean                  retval          = TRUE;
  boolean                  hidden_key      = FALSE;
  boolean                  index_in_dir    = FALSE;
  uint8                    clid             = QMI_SVC_CLID_UNUSED;
  uint32                   client_reg_count = 0;

  UIM_MSG_HIGH_0("Get all pin status");

  ASSERT( get_all_pin_status_cnf_ptr );

  /* Retrieve userdata */
  cb_userdata_ptr = (qmi_uimi_userdata_type*)get_all_pin_status_cnf_ptr->response_header.client_data;
  if (cb_userdata_ptr == NULL)
  {
    UIM_MSG_HIGH_0("Null userdata ptr in response");
    return;
  }

  /* Retrieve parameters */
  clid             = cb_userdata_ptr->clid;
  client_reg_count = cb_userdata_ptr->client_reg_count;
  cmd_buf_p = (qmi_cmd_buf_type*)cb_userdata_ptr->cmd_buf_ptr;

  /* Extract details about request */
  hidden_key   = cb_userdata_ptr->data.get_service_status.hidden_key;
  index_in_dir = cb_userdata_ptr->data.get_service_status.index_in_dir;

  /* Free userdata */
  qmi_uim_free_cb_userdata(cb_userdata_ptr);
  cb_userdata_ptr = NULL;


  /* First check if the requested client is still valid */
  if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
  {
    UIM_MSG_HIGH_0("Invalid Client, not sending response");
    return;
  }

  if (cmd_buf_p == NULL)
  {
    UIM_MSG_HIGH_0("Null cmd_buf ptr in response");
    return;
  }

  QMI_UIM_VALIDATE_SP_IN_CMD_BUF(cmd_buf_p);

  /* Insert hidden key status in the TLV */
  if (status == MMGSDI_SUCCESS)
  {
    if (hidden_key)
    {
      if (FALSE == qmi_uim_response_hidden_key_status(
                              UIMI_TLV_RESP_TAG_OPTIONAL_2,
                              &response,
                              get_all_pin_status_cnf_ptr->hiddenkey.status))
      {
        errval = QMI_ERR_NO_MEMORY;
        dsm_free_packet(&response);
      }
    }
    if (index_in_dir)
    {
      if (FALSE == qmi_uim_response_index_in_dir(
                              UIMI_TLV_RESP_TAG_OPTIONAL_3,
                              &response,
                              get_all_pin_status_cnf_ptr->dir_index))
      {
        errval = QMI_ERR_NO_MEMORY;
        dsm_free_packet(&response);
      }
    }
  }
  else
  {
    /* Convert MMGSDI status to QMI err code */
    errval = qmi_uim_convert_mmgsdi_status_to_errval(status);
  }

  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    ds_qmi_fw_free_cmd_buf( &cmd_buf_p );
    return;
  }

  /* Send response */
  if (FALSE == qmi_uimi_send_response(cmd_buf_p,
                                      response))
  {
    UIM_MSG_HIGH_0("Unable to send response for get all pin status");
    dsm_free_packet(&response);
  }
} /* qmi_uimi_get_all_pin_status_resp */


/*===========================================================================
  FUNCTION QMI_UIMI_NONPROV_GET_ALL_PIN_STATUS()

  DESCRIPTION
    Updates the global pin status for a nonprov session

  PARAMETERS
    status                     : status of MMGSDI operation
    get_all_pin_status_cnf_ptr : result of MMGSDI operation

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_nonprov_get_all_pin_status
(
  mmgsdi_return_enum_type                    status,
  const mmgsdi_get_all_pin_status_cnf_type * get_all_pin_status_cnf_ptr
)
{
  qmi_error_e_type               errval        = QMI_ERR_NONE;
  boolean                        notify        = FALSE;
  mmgsdi_session_type_enum_type  session_type  = MMGSDI_MAX_SESSION_TYPE_ENUM;
  mmgsdi_aid_type                aid_value     = { MMGSDI_APP_NONE };
  uint16                         app_index     = UIM_INVALID_APP_INDEX;

  UIM_MSG_HIGH_0("Nonprov get all pin status response");

  ASSERT(get_all_pin_status_cnf_ptr);
  ASSERT(qmi_uim_global_ptr);

  /* Check response status */
  if (status != MMGSDI_SUCCESS)
  {
    UIM_MSG_ERR_1("Error in get all pin status response: 0x%x", status);
    return;
  }

  /* Retrieve AID for a nonprov session */
  errval = qmi_uim_session_id_to_session_type(
                       &session_type,
                       &aid_value.aid,
                       get_all_pin_status_cnf_ptr->response_header.session_id);
  if(errval != QMI_ERR_NONE)
  {
    UIM_MSG_ERR_1("Error retrieving aid: 0x%x", errval);
    return;
  }

  if((session_type != MMGSDI_NON_PROV_SESSION_SLOT_1) &&
     (session_type != MMGSDI_NON_PROV_SESSION_SLOT_2) &&
     (session_type != MMGSDI_NON_PROV_SESSION_SLOT_3))
  {
    UIM_MSG_ERR_1("Invalid session type: 0x%x", session_type);
    return;
  }

  if(aid_value.aid.data_len == 0)
  {
    UIM_MSG_ERR_0("No PIN to update for empty AID length");
    return;
  }

  aid_value.app_type = MMGSDI_APP_UNKNOWN;

  /* Find the application */
  app_index = qmi_uim_find_aid(&aid_value,
                               get_all_pin_status_cnf_ptr->response_header.slot_id);
  if (app_index < QMI_UIM_MAX_APP_COUNT &&
      qmi_uim_global_ptr->card_state.application[app_index] != NULL)
  {
    if(!qmi_uim_global_ptr->card_state.application[app_index]->upin)
    {
      /* Update global PIN1 status */
      if(qmi_uim_global_ptr->card_state.application[app_index]->pin1_state !=
            get_all_pin_status_cnf_ptr->pin1.status)
      {
        qmi_uim_global_ptr->card_state.application[app_index]->pin1_state =
            get_all_pin_status_cnf_ptr->pin1.status;
        notify = TRUE;
      }
      if((get_all_pin_status_cnf_ptr->pin1.valid_num_retries) &&
         (qmi_uim_global_ptr->card_state.application[app_index]->pin1_num_retries !=
            get_all_pin_status_cnf_ptr->pin1.num_retries) )
      {
         qmi_uim_global_ptr->card_state.application[app_index]->pin1_num_retries =
            get_all_pin_status_cnf_ptr->pin1.num_retries;
         notify = TRUE;
      }
      if((get_all_pin_status_cnf_ptr->pin1.valid_num_unblock_retries) &&
         (qmi_uim_global_ptr->card_state.application[app_index]->puk1_num_retries !=
            get_all_pin_status_cnf_ptr->pin1.num_unblock_retries))
      {
        qmi_uim_global_ptr->card_state.application[app_index]->puk1_num_retries =
            get_all_pin_status_cnf_ptr->pin1.num_unblock_retries;
        notify = TRUE;
      }

      /* Update global PIN2 status */
      if(qmi_uim_global_ptr->card_state.application[app_index]->pin2_state !=
              get_all_pin_status_cnf_ptr->pin2.status)
      {
        qmi_uim_global_ptr->card_state.application[app_index]->pin2_state =
              get_all_pin_status_cnf_ptr->pin2.status;
        notify = TRUE;
      }
      if((get_all_pin_status_cnf_ptr->pin2.valid_num_retries) &&
         (qmi_uim_global_ptr->card_state.application[app_index]->pin2_num_retries !=
            get_all_pin_status_cnf_ptr->pin2.num_retries))
      {
         qmi_uim_global_ptr->card_state.application[app_index]->pin2_num_retries =
            get_all_pin_status_cnf_ptr->pin2.num_retries;
         notify = TRUE;
      }
      if((get_all_pin_status_cnf_ptr->pin2.valid_num_unblock_retries) &&
         (qmi_uim_global_ptr->card_state.application[app_index]->puk2_num_retries !=
            get_all_pin_status_cnf_ptr->pin2.num_unblock_retries))
      {
        qmi_uim_global_ptr->card_state.application[app_index]->puk2_num_retries =
            get_all_pin_status_cnf_ptr->pin2.num_unblock_retries;
        notify = TRUE;
      }
    }
  }

  /* If update is required, send it to all clients */
  if(notify)
  {
    if (session_type == MMGSDI_NON_PROV_SESSION_SLOT_1 ||
        session_type == MMGSDI_NON_PROV_SESSION_SLOT_2 ||
        session_type == MMGSDI_NON_PROV_SESSION_SLOT_3)
    {
      qmi_uim_send_card_status_indication_to_all(TRUE, FALSE, TRUE);
    }
    else
    {
      qmi_uim_send_card_status_indication_to_all(FALSE, FALSE, TRUE);
    }
  }
}/* qmi_uimi_nonprov_get_all_pin_status */


/*===========================================================================
  FUNCTION QMI_UIMI_CHANGE_PROVISIONING_SESSION_RESP()

  DESCRIPTION
    Composes the response for the change provisioning session function

  PARAMETERS
    status                  : status of MMGSDI operation
    response_header_cnf_ptr : result of MMGSDI operation

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_change_provisioning_session_resp
(
  mmgsdi_return_enum_type             status,
  const mmgsdi_response_header_type * response_header_cnf_ptr
)
{
  qmi_cmd_buf_type *       cmd_buf_p        = NULL;
  qmi_uimi_userdata_type * cb_userdata_ptr  = NULL;
  dsm_item_type *          response         = NULL;
  qmi_error_e_type         errval           = QMI_ERR_NONE;
  qmi_result_e_type        result           = QMI_RESULT_SUCCESS;
  boolean                  retval           = TRUE;
  uint8                    clid             = QMI_SVC_CLID_UNUSED;
  uint32                   client_reg_count = 0;

  UIM_MSG_HIGH_0("Sending response for change prov session");

  ASSERT( response_header_cnf_ptr );

  /* Retrieve userdata */
  cb_userdata_ptr = (qmi_uimi_userdata_type*)response_header_cnf_ptr->client_data;
  if (cb_userdata_ptr == NULL)
  {
    UIM_MSG_HIGH_0("Null userdata ptr in response");
    return;
  }

  /* Retrieve parameters */
  clid             = cb_userdata_ptr->clid;
  client_reg_count = cb_userdata_ptr->client_reg_count;
  cmd_buf_p = (qmi_cmd_buf_type*)cb_userdata_ptr->cmd_buf_ptr;

  /* Free userdata */
  qmi_uim_free_cb_userdata(cb_userdata_ptr);
  cb_userdata_ptr = NULL;

  /* First check if the requested client is still valid */
  if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
  {
    UIM_MSG_HIGH_0("Invalid Client, not sending response");
    return;
  }

  if (cmd_buf_p == NULL)
  {
    UIM_MSG_HIGH_0("Null cmd_buf ptr in response");
    return;
  }

  QMI_UIM_VALIDATE_SP_IN_CMD_BUF(cmd_buf_p);

  errval = qmi_uim_convert_mmgsdi_status_to_errval(status);

  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    ds_qmi_fw_free_cmd_buf( &cmd_buf_p );
    return;
  }

  /* Send response */
  if (FALSE == qmi_uimi_send_response(cmd_buf_p,
                                      response))
  {
    UIM_MSG_HIGH_0("Unable to send response for change provisioning session operation");
    dsm_free_packet(&response);
  }
} /* qmi_uimi_change_provisioning_session_resp */


/*===========================================================================
  FUNCTION QMI_UIMI_SEND_APDU_RESP()

  DESCRIPTION
    Composes the response for send APDU function

  PARAMETERS
    status            : status of MMGSDI operation
    send_apdu_cnf_ptr : result of MMGSDI operation

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_send_apdu_resp
(
  mmgsdi_return_enum_type           status,
  const mmgsdi_send_apdu_ext_cnf_type * send_apdu_cnf_ptr
)
{
  qmi_cmd_buf_type *       cmd_buf_p        = NULL;
  qmi_uimi_userdata_type * cb_userdata_ptr  = NULL;
  dsm_item_type *          response         = NULL;
  qmi_error_e_type         errval           = QMI_ERR_NONE;
  qmi_result_e_type        result           = QMI_RESULT_SUCCESS;
  boolean                  retval           = TRUE;
  uint8                    clid             = QMI_SVC_CLID_UNUSED;
  boolean                  ind_required     = FALSE;
  uint32                   client_reg_count = 0;

  UIM_MSG_HIGH_0("Sending response for send apdu");

  ASSERT( send_apdu_cnf_ptr );
  ASSERT( qmi_uim_global_ptr );

  /* Retrieve userdata */
  cb_userdata_ptr = (qmi_uimi_userdata_type*)send_apdu_cnf_ptr->response_header.client_data;
  if (cb_userdata_ptr == NULL)
  {
    UIM_MSG_HIGH_0("Null userdata ptr in response");
    return;
  }

  /* Retrieve parameters */
  clid             = cb_userdata_ptr->clid;
  client_reg_count = cb_userdata_ptr->client_reg_count;
  cmd_buf_p        = (qmi_cmd_buf_type*)cb_userdata_ptr->cmd_buf_ptr;

  /* Free userdata */
  qmi_uim_free_cb_userdata(cb_userdata_ptr);
  cb_userdata_ptr = NULL;

  /* First check if the requested client is still valid */
  if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
  {
    UIM_MSG_HIGH_0("Invalid Client, not sending indication or response");
    return;
  }

  if (cmd_buf_p == NULL)
  {
    UIM_MSG_HIGH_0("Null cmd_buf ptr in response");
    return;
  }

  QMI_UIM_VALIDATE_SP_IN_CMD_BUF(cmd_buf_p);

  /* Insert APDU response in the TLV, in case of success */
  if (status == MMGSDI_SUCCESS)
  {
    mmgsdi_sw_type   procedure_bytes;
    memset(&procedure_bytes, 0, sizeof(mmgsdi_sw_type));

    /* Sanity check on the data size */
    if (send_apdu_cnf_ptr->apdu_data.data_len <= 0)
    {
      UIM_MSG_HIGH_1( "Invalid data_len in response: 0x%X",
                      send_apdu_cnf_ptr->apdu_data.data_len);
      errval = QMI_ERR_INTERNAL;
    }
    else if (send_apdu_cnf_ptr->apdu_data.data_len > QMI_UIM_APDU_RESP_MAX_DATA_LEN)
    {
      /* Check if data size exceeds the max value supported by this response.
         In such cases, send long response TLV with appropriate error code */
      qmi_uim_global_ptr->apdu_response_token++;
      if (FALSE == qmi_uim_response_apdu_long_response(
                            UIMI_TLV_RESP_TAG_OPTIONAL_2,
                            &response,
                            qmi_uim_global_ptr->apdu_response_token,
                            send_apdu_cnf_ptr->apdu_data.data_len))
      {
        errval = QMI_ERR_NO_MEMORY;
        dsm_free_packet(&response);
      }
      else
      {
        errval       = QMI_ERR_INSUFFICIENT_RESOURCES;
        ind_required = TRUE;
      }
    }
    else
    {
      if (FALSE == qmi_uim_response_send_apdu_result(
                            UIMI_TLV_RESP_TAG_OPTIONAL_1,
                            &response,
                            send_apdu_cnf_ptr->apdu_data,
                            procedure_bytes))
      {
        errval = QMI_ERR_NO_MEMORY;
        dsm_free_packet(&response);
      }
    }
  }
  else
  {
    /* Convert MMGSDI status to QMI err code */
    errval = qmi_uim_convert_mmgsdi_status_to_errval(status);
  }

  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    ds_qmi_fw_free_cmd_buf( &cmd_buf_p );
    return;
  }

  /* Send response */
  if (FALSE == qmi_uimi_send_response(cmd_buf_p,
                                      response))
  {
    UIM_MSG_HIGH_0("Unable to send response for send apdu");
    dsm_free_packet(&response);
  }

  /* Send indications in certain cases */
  if (ind_required)
  {
    uint16  i             = 0;
    uint16  offset        = 0;
    uint16  num_of_chunks = 0;
    uint16  total_len     = (uint16)send_apdu_cnf_ptr->apdu_data.data_len;

    num_of_chunks = (total_len - 1) / QMI_UIM_APDU_RESP_MAX_DATA_LEN + 1;

    /* Send one chunk of APDU response per indication until entire data is sent */
    for (i = 0; i < num_of_chunks && offset < total_len; i++)
    {
      dsm_item_type               * indication = NULL;
      mmgsdi_send_apdu_data_type    apdu_data;

      memset(&apdu_data, 0, sizeof(mmgsdi_send_apdu_data_type));
      apdu_data.data_ptr = send_apdu_cnf_ptr->apdu_data.data_ptr + offset;
      apdu_data.data_len = ((total_len - offset) > QMI_UIM_APDU_RESP_MAX_DATA_LEN) ?
                             QMI_UIM_APDU_RESP_MAX_DATA_LEN : (total_len - offset) ;

      UIM_MSG_HIGH_3("Sending APDUs in indication, chunk[%d], token: 0x%x, offset: 0x%x",
                     i, qmi_uim_global_ptr->apdu_response_token, offset);

      /* Prepare the TLV */
      if (FALSE == qmi_uim_response_long_response_chunk(
                            UIMI_TLV_TAG_MANDATORY_1,
                            &indication,
                            qmi_uim_global_ptr->apdu_response_token,
                            total_len,
                            offset,
                            apdu_data))
      {
        UIM_MSG_HIGH_0("Unable to construct indication for send apdu");
        dsm_free_packet(&indication);
        return;
      }

      /* Send indication to the client */
      if (FALSE == qmi_uimi_send_indication(clid,
                                            (uint16)UIMI_CMD_VAL_SEND_APDU,
                                            indication))
      {
        UIM_MSG_HIGH_0("Unable to send indication for send apdu");
        dsm_free_packet(&indication);
      }

      /* Jump to the next chunk */
      offset += apdu_data.data_len;
    }
  }
} /* qmi_uimi_send_apdu_resp */


/*===========================================================================
  FUNCTION QMI_UIMI_SAP_CONNECTION_RESP()

  DESCRIPTION
    Composes the response for SAP connection request

  PARAMETERS
    status                  : status of MMGSDI operation
    response_header_cnf_ptr : result of MMGSDI operation

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_sap_connection_resp
(
  mmgsdi_return_enum_type                 status,
  const mmgsdi_response_header_type     * response_header_cnf_ptr
)
{
  qmi_cmd_buf_type *       cmd_buf_p        = NULL;
  qmi_uimi_userdata_type * cb_userdata_ptr  = NULL;
  dsm_item_type *          response         = NULL;
  qmi_error_e_type         errval           = QMI_ERR_NONE;
  qmi_result_e_type        result           = QMI_RESULT_SUCCESS;
  boolean                  retval           = TRUE;
  uint8                    clid             = QMI_SVC_CLID_UNUSED;
  uint32                   client_reg_count = 0;

  UIM_MSG_HIGH_1("Sending response for sap connection, status = 0x%x",
                 status );

  ASSERT( response_header_cnf_ptr );

  /* Retrieve userdata */
  cb_userdata_ptr = (qmi_uimi_userdata_type*)response_header_cnf_ptr->client_data;
  if (cb_userdata_ptr == NULL)
  {
    UIM_MSG_HIGH_0("Null userdata ptr in response");
    return;
  }

  /* Retrieve parameters */
  clid             = cb_userdata_ptr->clid;
  client_reg_count = cb_userdata_ptr->client_reg_count;
  cmd_buf_p = (qmi_cmd_buf_type*)cb_userdata_ptr->cmd_buf_ptr;

  /* Free userdata */
  qmi_uim_free_cb_userdata(cb_userdata_ptr);
  cb_userdata_ptr = NULL;

  /* First check if the requested client is still valid */
  if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
  {
    UIM_MSG_HIGH_0("Invalid Client, not sending response");
    return;
  }

  if (cmd_buf_p == NULL)
  {
    UIM_MSG_HIGH_0( "Null cmd_buf ptr in response");
    return;
  }

  QMI_UIM_VALIDATE_SP_IN_CMD_BUF(cmd_buf_p);

  /* Convert result */
  if(status == MMGSDI_SIM_BUSY)
  {
    /* Keep impact cofined to SAP, may have different meaning for other commands */
    errval = QMI_ERR_DEVICE_NOT_READY;
  }
  else
  {
    errval = qmi_uim_convert_mmgsdi_status_to_errval(status);
  }

  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    ds_qmi_fw_free_cmd_buf( &cmd_buf_p );
    return;
  }

  /* Send response */
  if (FALSE == qmi_uimi_send_response(cmd_buf_p,
                                      response))
  {
    UIM_MSG_HIGH_0("Unable to send response for sap connection");
    dsm_free_packet(&response);
  }
} /* qmi_uimi_sap_connection_resp */


/*===========================================================================
  FUNCTION QMI_UIMI_SAP_REQUEST_RESP()

  DESCRIPTION
    Composes the response for various SAP requests

  PARAMETERS
    status              : status of MMGSDI operation
    cnf_type            : confirmation type
    cnf_ptr             : result of MMGSDI operation

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_sap_request_resp
(
  mmgsdi_return_enum_type                 status,
  mmgsdi_cnf_enum_type                    cnf_type,
  const mmgsdi_cnf_type                 * cnf_ptr
)
{
  qmi_cmd_buf_type *                  cmd_buf_p          = NULL;
  qmi_uimi_userdata_type            * cb_userdata_ptr    = NULL;
  dsm_item_type *                     response           = NULL;
  qmi_error_e_type                    errval             = QMI_ERR_NONE;
  qmi_result_e_type                   result             = QMI_RESULT_SUCCESS;
  boolean                             retval             = TRUE;
  qmi_uimi_client_state_type        * cl_sp              = NULL;
  uint8                               ins_byte           = 0;
  uint8                               clid               = QMI_SVC_CLID_UNUSED;
  uint32                              client_reg_count   = 0;

  UIM_MSG_HIGH_0("Sending response for sap request");

  ASSERT( cnf_ptr );

  /* Retrieve userdata */
  cb_userdata_ptr = (qmi_uimi_userdata_type*)cnf_ptr->response_header.client_data;
  if (cb_userdata_ptr == NULL)
  {
    UIM_MSG_HIGH_0("Null userdata ptr in response");
    return;
  }

  /* Retrieve parameters */
  clid             = cb_userdata_ptr->clid;
  client_reg_count = cb_userdata_ptr->client_reg_count;
  cmd_buf_p = (qmi_cmd_buf_type*)cb_userdata_ptr->cmd_buf_ptr;

  /* Retrieve INS byte info */
  ins_byte          = cb_userdata_ptr->data.sap_request.ins_value;

  /* Free userdata */
  qmi_uim_free_cb_userdata(cb_userdata_ptr);
  cb_userdata_ptr = NULL;

  /* First check if the requested client is still valid */
  if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
  {
    UIM_MSG_HIGH_0("Invalid Client, not sending response");
    return;
  }

  if (cmd_buf_p == NULL)
  {
    UIM_MSG_HIGH_0( "Null cmd_buf ptr in response");
    return;
  }

  QMI_UIM_VALIDATE_SP_IN_CMD_BUF(cmd_buf_p);

  /* Convert result initially */
  errval = qmi_uim_convert_mmgsdi_status_to_errval(status);

  /* Retreive client state pointer */
  cl_sp = (qmi_uimi_client_state_type *)cmd_buf_p->x_p->cl_sp;

  switch (cnf_type)
  {
    case MMGSDI_SAP_GET_ATR_CNF:
      /* Insert ATR value TLV on successful conf */
      if (status == MMGSDI_SUCCESS)
      {
        if (FALSE == qmi_uim_response_generic_payload_8bit(
                              UIMI_TLV_RESP_TAG_OPTIONAL_1,
                              &response,
                              cnf_ptr->sap_get_atr_cnf.atr_data,
                              FALSE))
        {
          errval = QMI_ERR_NO_MEMORY;
          dsm_free_packet(&response);
        }
      }
      break;
    case MMGSDI_SAP_SEND_APDU_CNF:
      /* Insert APDU result TLV on successful conf */

      UIM_MSG_HIGH_3("implicit get response bytes: sw1:0x%x, sw2: 0x%x, data_len: 0x%x",
                     cnf_ptr->sap_send_apdu_cnf.implicit_get_rsp_sw1,
                     cnf_ptr->sap_send_apdu_cnf.implicit_get_rsp_sw2,
                     cnf_ptr->sap_send_apdu_cnf.apdu_data.data_len);

      if (status == MMGSDI_SUCCESS)
      {
        boolean          send_apdu_res = TRUE;
        mmgsdi_sw_type   procedure_bytes;
        memset(&procedure_bytes, 0, sizeof(mmgsdi_sw_type));

        /* Update pending status only for these cases */
        if (cl_sp->uim_info.sap_intermediate_get_resp)
        {
          if ((cnf_ptr->sap_send_apdu_cnf.implicit_get_rsp_sw1 == QMI_UIM_PROCEDURE_BYTE_SW1_NORMAL) &&
              (cnf_ptr->sap_send_apdu_cnf.implicit_get_rsp_sw2 != QMI_UIM_PROCEDURE_BYTE_SW2_ZERO))
          {
            /* Update procedure bytes when valid */
            procedure_bytes.present = TRUE;
            procedure_bytes.sw1 = (uint8)cnf_ptr->sap_send_apdu_cnf.implicit_get_rsp_sw1;
            procedure_bytes.sw2 = (uint8)cnf_ptr->sap_send_apdu_cnf.implicit_get_rsp_sw2;

            /* For first response, only procedure bytes are sent,
               for subsequent responses, sw1 sw2 bytes are appended to data,
               for last response only data is sent */
            if (ins_byte != QMI_UIM_INS_BYTE_GET_RESPONSE)
            {
              send_apdu_res = FALSE;
              if (FALSE == qmi_uim_response_procedure_bytes(
                                UIMI_TLV_RESP_TAG_OPTIONAL_2,
                                &response,
                                procedure_bytes))
              {
                errval = QMI_ERR_NO_MEMORY;
                dsm_free_packet(&response);
              }
            }
          }
        }

        /* Send APDU response and if needed, also procedure bytes */
        if (send_apdu_res)
        {
          if (FALSE == qmi_uim_response_send_apdu_result(
                              UIMI_TLV_RESP_TAG_OPTIONAL_2,
                              &response,
                              cnf_ptr->sap_send_apdu_cnf.apdu_data,
                              procedure_bytes))
          {
            errval = QMI_ERR_NO_MEMORY;
            dsm_free_packet(&response);
          }
        }
      }
      break;
    case MMGSDI_SAP_CARD_READER_STATUS_CNF:
      /* Insert card reader status TLV on successful conf */
      if (status == MMGSDI_SUCCESS)
      {
        if (FALSE == qmi_uim_response_generic_payload_8bit(
                              UIMI_TLV_RESP_TAG_OPTIONAL_3,
                              &response,
                              cnf_ptr->sap_card_reader_status_cnf.card_reader_status_data,
                              FALSE))
        {
          errval = QMI_ERR_NO_MEMORY;
          dsm_free_packet(&response);
        }
      }
      break;
    case MMGSDI_SAP_POWER_ON_CNF:
    case MMGSDI_SAP_POWER_OFF_CNF:
    case MMGSDI_SAP_RESET_CNF:
      /* Nothing to do */
      break;
    default:
      UIM_MSG_HIGH_0("Invalid cnf_type in response");
      return;
  }

  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    ds_qmi_fw_free_cmd_buf( &cmd_buf_p );
    return;
  }

  /* Send response */
  if (FALSE == qmi_uimi_send_response(cmd_buf_p,
                                      response))
  {
    UIM_MSG_HIGH_0("Unable to send response for sap connection");
    dsm_free_packet(&response);
  }
} /* qmi_uimi_sap_request_resp */


/*===========================================================================
  FUNCTION QMI_UIMI_SUBSCRIPTION_OK_RESP()

  DESCRIPTION
    Composes the response for the subscription ok request

  PARAMETERS
    status           : status of MMGSDI operation
    sub_ok_cnf_ptr   : result of MMGSDI operation

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_subscription_ok_resp
(
  mmgsdi_return_enum_type                         status,
  const mmgsdi_session_subscription_ok_cnf_type  *sub_ok_cnf_ptr
)
{
  qmi_cmd_buf_type *       cmd_buf_p        = NULL;
  qmi_uimi_userdata_type * cb_userdata_ptr  = NULL;
  dsm_item_type *          response         = NULL;
  qmi_error_e_type         errval           = QMI_ERR_NONE;
  qmi_result_e_type        result           = QMI_RESULT_SUCCESS;
  boolean                  retval           = TRUE;
  uint8                    clid             = QMI_SVC_CLID_UNUSED;
  uint32                   client_reg_count = 0;

  UIM_MSG_HIGH_0("Sending response for subscription OK");

  ASSERT( sub_ok_cnf_ptr );

  /* Retrieve userdata */
  cb_userdata_ptr = (qmi_uimi_userdata_type*)sub_ok_cnf_ptr->response_header.client_data;
  if (cb_userdata_ptr == NULL)
  {
    UIM_MSG_HIGH_0("Null userdata ptr in response");
    return;
  }

  /* Retrieve parameters */
  clid             = cb_userdata_ptr->clid;
  client_reg_count = cb_userdata_ptr->client_reg_count;
  cmd_buf_p = (qmi_cmd_buf_type*)cb_userdata_ptr->cmd_buf_ptr;

  /* Free userdata */
  qmi_uim_free_cb_userdata(cb_userdata_ptr);
  cb_userdata_ptr = NULL;

  /* First check if the requested client is still valid */
  if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
  {
    UIM_MSG_HIGH_0("Invalid Client, not sending response");
    return;
  }

  if (cmd_buf_p == NULL)
  {
    UIM_MSG_HIGH_0("Null cmd_buf ptr in response");
    return;
  }

  QMI_UIM_VALIDATE_SP_IN_CMD_BUF(cmd_buf_p);

  /* Convert MMGSDI status in QMI code */
  errval = qmi_uim_convert_mmgsdi_status_to_errval(status);

  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    ds_qmi_fw_free_cmd_buf( &cmd_buf_p );
    return;
  }

  /* Send response */
  if (FALSE == qmi_uimi_send_response(cmd_buf_p,
                                      response))
  {
    UIM_MSG_HIGH_0("Unable to send response for SUB OK request");
    dsm_free_packet(&response);
  }
} /* qmi_uimi_subscription_ok_resp */


/*===========================================================================
  FUNCTION QMI_UIMI_GET_ATR_RESP()

  DESCRIPTION
    Composes the response for get ATR request

  PARAMETERS
    status              : status of MMGSDI operation
    cnf_type            : confirmation type
    cnf_ptr             : result of MMGSDI operation

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_get_atr_resp
(
  mmgsdi_return_enum_type                 status,
  const mmgsdi_get_atr_cnf_type         * get_atr_cnf_ptr
)
{
  qmi_cmd_buf_type *                  cmd_buf_p        = NULL;
  qmi_uimi_userdata_type            * cb_userdata_ptr  = NULL;
  dsm_item_type *                     response         = NULL;
  qmi_error_e_type                    errval           = QMI_ERR_NONE;
  qmi_result_e_type                   result           = QMI_RESULT_SUCCESS;
  boolean                             retval           = TRUE;
  uint8                               clid             = QMI_SVC_CLID_UNUSED;
  uint32                              client_reg_count = 0;

  UIM_MSG_HIGH_0("Sending response for get atr");

  ASSERT( get_atr_cnf_ptr );

  /* Retrieve userdata */
  cb_userdata_ptr = (qmi_uimi_userdata_type*)get_atr_cnf_ptr->response_header.client_data;
  if (cb_userdata_ptr == NULL)
  {
    UIM_MSG_HIGH_0("Null userdata ptr in response");
    return;
  }

  /* Retrieve parameters */
  clid             = cb_userdata_ptr->clid;
  client_reg_count = cb_userdata_ptr->client_reg_count;
  cmd_buf_p = (qmi_cmd_buf_type*)cb_userdata_ptr->cmd_buf_ptr;

  /* Free userdata */
  qmi_uim_free_cb_userdata(cb_userdata_ptr);
  cb_userdata_ptr = NULL;

  /* First check if the requested client is still valid */
  if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
  {
    UIM_MSG_HIGH_0("Invalid Client, not sending response");
    return;
  }

  if (cmd_buf_p == NULL)
  {
    UIM_MSG_HIGH_0( "Null cmd_buf ptr in response");
    return;
  }

  QMI_UIM_VALIDATE_SP_IN_CMD_BUF(cmd_buf_p);

  /* Insert APDU response in the TLV, in case of success */
  if (status == MMGSDI_SUCCESS)
  {
    if (FALSE == qmi_uim_response_generic_payload_8bit(
                            UIMI_TLV_RESP_TAG_OPTIONAL_1,
                            &response,
                            get_atr_cnf_ptr->atr_data,
                            TRUE))
    {
      errval = QMI_ERR_NO_MEMORY;
      dsm_free_packet(&response);
    }
  }
  else
  {
    /* Convert MMGSDI status to QMI err code */
    errval = qmi_uim_convert_mmgsdi_status_to_errval(status);
  }

  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    ds_qmi_fw_free_cmd_buf( &cmd_buf_p );
    return;
  }

  /* Send response */
  if (FALSE == qmi_uimi_send_response(cmd_buf_p,
                                      response))
  {
    UIM_MSG_HIGH_0("Unable to send response for get atr");
    dsm_free_packet(&response);
  }
} /* qmi_uimi_get_atr_resp */


/*===========================================================================
  FUNCTION QMI_UIMI_SET_FILE_STATUS_RESP()

  DESCRIPTION
    Composes the response for SET_FILE_STATUS request

  PARAMETERS
    status                  : status of MMGSDI operation
    response_header_cnf_ptr : result of MMGSDI operation

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_set_file_status_resp
(
  mmgsdi_return_enum_type                 status,
  const mmgsdi_response_header_type     * response_header_cnf_ptr
)
{
  qmi_cmd_buf_type *                  cmd_buf_p        = NULL;
  qmi_uimi_userdata_type            * cb_userdata_ptr  = NULL;
  dsm_item_type *                     response         = NULL;
  qmi_error_e_type                    errval           = QMI_ERR_NONE;
  qmi_result_e_type                   result           = QMI_RESULT_SUCCESS;
  boolean                             retval           = TRUE;
  uint8                               clid             = QMI_SVC_CLID_UNUSED;
  uint32                              client_reg_count = 0;

  UIM_MSG_HIGH_0("Sending response for set file status");

  ASSERT( response_header_cnf_ptr );

  /* Retrieve userdata */
  cb_userdata_ptr = (qmi_uimi_userdata_type*)response_header_cnf_ptr->client_data;
  if (cb_userdata_ptr == NULL)
  {
    UIM_MSG_HIGH_0("Null userdata ptr in response");
    return;
  }

  /* Retrieve parameters */
  clid             = cb_userdata_ptr->clid;
  client_reg_count = cb_userdata_ptr->client_reg_count;
  cmd_buf_p = (qmi_cmd_buf_type*)cb_userdata_ptr->cmd_buf_ptr;

  /* Free userdata */
  qmi_uim_free_cb_userdata(cb_userdata_ptr);
  cb_userdata_ptr = NULL;

  /* First check if the requested client is still valid */
  if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
  {
    UIM_MSG_HIGH_0("Invalid Client, not sending response");
    return;
  }

  if (cmd_buf_p == NULL)
  {
    UIM_MSG_HIGH_0( "Null cmd_buf ptr in response");
    return;
  }

  QMI_UIM_VALIDATE_SP_IN_CMD_BUF(cmd_buf_p);

  /* Convert MMGSDI status in QMI code */
  errval = qmi_uim_convert_mmgsdi_status_to_errval(status);

  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    ds_qmi_fw_free_cmd_buf( &cmd_buf_p );
    return;
  }

  /* Send response */
  if (FALSE == qmi_uimi_send_response(cmd_buf_p,
                                      response))
  {
    UIM_MSG_HIGH_0("Unable to send response for SET FILE STATUS request");
    dsm_free_packet(&response);
  }
} /* qmi_uimi_set_file_status_resp */


/*===========================================================================
  FUNCTION QMI_UIMI_INCREASE_RESP()

  DESCRIPTION
    Composes either the response or indication for the increase function

  PARAMETERS
    status       : status of MMGSDI operation
    increase_cnf_ptr : result of MMGSDI operation

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_increase_resp
(
  mmgsdi_return_enum_type          status,
  const mmgsdi_increase_cnf_type * increase_cnf_ptr
)
{
  qmi_cmd_buf_type *       cmd_buf_p        = NULL;
  qmi_uimi_userdata_type * cb_userdata_ptr  = NULL;
  dsm_item_type *          response         = NULL;
  qmi_error_e_type         errval           = QMI_ERR_NONE;
  qmi_result_e_type        result           = QMI_RESULT_SUCCESS;
  boolean                  retval           = TRUE;
  boolean                  ind_required     = FALSE;
  uint8                    clid             = QMI_SVC_CLID_UNUSED;
  qmi_uimi_cmd_val_e_type  request_id       = UIMI_CMD_VAL_WIDTH;
  uint32                   client_reg_count = 0;

  UIM_MSG_HIGH_0("Sending response for increase");

  ASSERT( increase_cnf_ptr );

  /* Retrieve userdata */
  cb_userdata_ptr = (qmi_uimi_userdata_type*)increase_cnf_ptr->response_header.client_data;
  if (cb_userdata_ptr == NULL)
  {
    UIM_MSG_HIGH_0("Null userdata ptr in response");
    return;
  }

  /* Retrieve info */
  clid             = cb_userdata_ptr->clid;
  client_reg_count = cb_userdata_ptr->client_reg_count;
  request_id       = cb_userdata_ptr->request_id;
  cmd_buf_p        = (qmi_cmd_buf_type*)cb_userdata_ptr->cmd_buf_ptr;
  QMI_UIM_VALIDATE_CMD_BUF_IN_USERDATA(cb_userdata_ptr);

  /* First check if the requested client is still valid */
  if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
  {
    UIM_MSG_HIGH_0("Invalid Client, not sending indication or response");
    qmi_uim_free_cb_userdata(cb_userdata_ptr);
    return;
  }

  /* Check if an indication needs to be sent instead of a response */
  ind_required = cb_userdata_ptr->ind_token.is_valid;
  if (ind_required)
  {
    if (FALSE == qmi_uim_response_ind_token(UIMI_TLV_IND_TAG_MANDATORY_1,
                                            &response,
                                            cb_userdata_ptr->ind_token.token))
    {
      UIM_MSG_ERR_0("Could not insert ind_token TLV, not sending indication");
      qmi_uim_free_cb_userdata(cb_userdata_ptr);
      dsm_free_packet(&response);
      return;
    }
  }

  /* Insert card result in the TLV */
  if (qmi_uim_response_card_result(UIMI_TLV_RESP_TAG_OPTIONAL_1,
                                   &response,
                                   increase_cnf_ptr->response_header.status_word))
  {
    /* Convert MMGSDI status to QMI err code */
    errval = qmi_uim_convert_mmgsdi_status_to_errval(status);
    if (status == MMGSDI_NOT_SUPPORTED)
    {
      errval = QMI_ERR_NOT_PROVISIONED;
    }
  }
  else
  {
    errval = QMI_ERR_NO_MEMORY;
    dsm_free_packet(&response);
  }

  /* Insert increase result in the TLV */
  if (increase_cnf_ptr->increased_data.data_len <= QMI_UIM_MAX_INCREASE_DATA)
  {
    if (FALSE == qmi_uim_response_increase_result(UIMI_TLV_RESP_TAG_OPTIONAL_2,
                                                  &response,
                                                  increase_cnf_ptr->increased_data))
    {
      errval = QMI_ERR_NO_MEMORY;
      dsm_free_packet(&response);
    }
  }
  else
  {
    errval = QMI_ERR_INTERNAL;
    dsm_free_packet(&response);
  }

  /* Free userdata */
  qmi_uim_free_cb_userdata(cb_userdata_ptr);
  cb_userdata_ptr = NULL;

  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    QMI_UIM_FREE_CMD_BUF(cmd_buf_p);
    return;
  }

  /* Send response or indication */
  if (ind_required)
  {
    retval = qmi_uimi_send_indication(clid,
                                     (uint16)request_id,
                                     response);
  }
  else
  {
    retval = qmi_uimi_send_response(cmd_buf_p,
                                    response);
  }
  if (FALSE == retval)
  {
    UIM_MSG_HIGH_0("Unable to send response for increase operation");
    dsm_free_packet(&response);
    QMI_UIM_FREE_CMD_BUF(cmd_buf_p);
  }
} /* qmi_uimi_increase_resp */


/*===========================================================================
  FUNCTION QMI_UIMI_RESELECT_RESP

  DESCRIPTION
    Handles the confirmation of reselect request

  PARAMETERS
    status             : status of MMGSDI operation
    select_aid_cnf_ptr : result of MMGSDI operation

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_reselect_resp
(
  mmgsdi_return_enum_type                    status,
  const mmgsdi_session_select_aid_cnf_type * select_aid_cnf_ptr
)
{
  uint8                          clid              = QMI_SVC_CLID_UNUSED;
  uint32                         client_reg_count  = 0;
  qmi_cmd_buf_type *             cmd_buf_p         = NULL;
  qmi_uimi_userdata_type       * cb_userdata_ptr   = NULL;
  dsm_item_type *                response          = NULL;
  qmi_error_e_type               errval            = QMI_ERR_NONE;
  qmi_result_e_type              result            = QMI_RESULT_SUCCESS;
  boolean                        retval            = TRUE;
  uint8                          index             = 0;

  ASSERT(select_aid_cnf_ptr);

  /* Retrieve userdata */
  cb_userdata_ptr =
    (qmi_uimi_userdata_type*)select_aid_cnf_ptr->response_header.client_data;
  if (cb_userdata_ptr == NULL)
  {
    UIM_MSG_HIGH_0("Null userdata ptr in response");
    return;
  }

  /* Retrieve info */
  clid              = cb_userdata_ptr->clid;
  client_reg_count  = cb_userdata_ptr->client_reg_count;
  index             = cb_userdata_ptr->data.reselect_request.channel_index;
  cmd_buf_p         = cb_userdata_ptr->cmd_buf_ptr;

  /* Free userdata */
  qmi_uim_free_cb_userdata(cb_userdata_ptr);
  cb_userdata_ptr = NULL;

  UIM_MSG_ERR_3("RESELECT AID status=0x%x, sw1=0x%x, sw2=0x%x",
                status,
                select_aid_cnf_ptr->response_header.status_word.sw1,
                select_aid_cnf_ptr->response_header.status_word.sw2);

  if (cmd_buf_p == NULL)
  {
    UIM_MSG_HIGH_0("Null cmd_buf ptr in response");
    return;
  }

  /* Check if the requested client is still valid */
  if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
  {
    UIM_MSG_HIGH_0("Invalid Client, not sending response");
    return;
  }

  QMI_UIM_VALIDATE_SP_IN_CMD_BUF(cmd_buf_p);

  if (FALSE == qmi_uim_response_card_result(
                 UIMI_TLV_RESP_TAG_OPTIONAL_1,
                 &response,
                 select_aid_cnf_ptr->response_header.status_word))
  {
    errval = QMI_ERR_NO_MEMORY;
    dsm_free_packet(&response);
  }

  if (status == MMGSDI_SUCCESS)
  {
    /* It is possible that the original open channel request was sent
       with a partial AID to MMGSDI. So, AID stored in the global for
       this apdu_channel could be a partial AID. Now is the opportunity
       to update the global with the actual AID returned as part of select */
    if (select_aid_cnf_ptr->app_id.aid.data_len > 0 &&
        select_aid_cnf_ptr->app_id.aid.data_len < MMGSDI_MAX_AID_LEN &&
        index < UIM_MAX_APDU_CHANNEL_COUNT)
    {
      (void)memscpy(&qmi_uim_global_ptr->apdu_channel[index]->aid,
                    sizeof(qmi_uim_global_ptr->apdu_channel[index]->aid),
                    &select_aid_cnf_ptr->app_id.aid,
                    sizeof(select_aid_cnf_ptr->app_id.aid));
    }

    if (FALSE == qmi_uim_response_generic_payload_8bit(
                   UIMI_TLV_RESP_TAG_OPTIONAL_2,
                   &response,
                   select_aid_cnf_ptr->select_rsp,
                   FALSE))
    {
      errval = QMI_ERR_NO_MEMORY;
      dsm_free_packet(&response);
    }
  }
  else
  {
    if (status == MMGSDI_SELECT_AID_FAILED)
    {
      errval = QMI_ERR_SIM_FILE_NOT_FOUND;
    }
    else if (status == MMGSDI_APP_NOT_SHAREABLE)
    {
      errval = QMI_ERR_INCOMPATIBLE_STATE;
    }
    else if (status == MMGSDI_NOT_SUPPORTED)
    {
      errval = QMI_ERR_NOT_SUPPORTED;
    }
    else
    {
      errval = QMI_ERR_INTERNAL;
    }
  }

  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    ds_qmi_fw_free_cmd_buf( &cmd_buf_p );
    return;
  }

  /* Send response */
  if (FALSE == qmi_uimi_send_response(cmd_buf_p,
                                      response))
  {
    UIM_MSG_HIGH_0("Unable to send response for RESELECT AID operation");
    dsm_free_packet(&response);
  }
} /* qmi_uimi_reselect_resp */


/*===========================================================================
  FUNCTION QMI_UIMI_SEND_STATUS_RESP

  DESCRIPTION
    Handles the confirmation from MMGSDI of the send status command.

  PARAMETERS
    status         : status of MMGSDI operation
    status_cnf_ptr : result of MMGSDI operation

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_send_status_resp
(
  mmgsdi_return_enum_type       status,
  const mmgsdi_status_cnf_type *status_cnf_ptr
)
{
  uint8                          clid              = QMI_SVC_CLID_UNUSED;
  uint32                         client_reg_count  = 0;
  qmi_cmd_buf_type *             cmd_buf_p         = NULL;
  qmi_uimi_userdata_type       * cb_userdata_ptr   = NULL;
  dsm_item_type *                response          = NULL;
  qmi_error_e_type               errval            = QMI_ERR_NONE;
  qmi_result_e_type              result            = QMI_RESULT_SUCCESS;
  boolean                        retval            = TRUE;

  UIM_MSG_HIGH_0("Sending response for send status");

  ASSERT(status_cnf_ptr);

  /* Retrieve userdata */
  cb_userdata_ptr =
    (qmi_uimi_userdata_type*)status_cnf_ptr->response_header.client_data;
  if (cb_userdata_ptr == NULL)
  {
    UIM_MSG_HIGH_0("Null userdata ptr in response");
    return;
  }

  /* Retrieve info */
  clid              = cb_userdata_ptr->clid;
  client_reg_count  = cb_userdata_ptr->client_reg_count;
  cmd_buf_p         = cb_userdata_ptr->cmd_buf_ptr;

  /* Free userdata */
  qmi_uim_free_cb_userdata(cb_userdata_ptr);
  cb_userdata_ptr = NULL;

  /* First check if the requested client is still valid */
  if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
  {
    UIM_MSG_HIGH_0("Invalid Client, not sending indication or response");
    return;
  }

  QMI_UIM_VALIDATE_SP_IN_CMD_BUF(cmd_buf_p);

  /* Insert APDU response in the TLV, in case of success */
  if (status == MMGSDI_SUCCESS)
  {
    if (FALSE == qmi_uim_response_generic_payload_8bit(
                            UIMI_TLV_RESP_TAG_OPTIONAL_1,
                            &response,
                            status_cnf_ptr->status_data,
                            FALSE))
    {
      errval = QMI_ERR_NO_MEMORY;
      dsm_free_packet(&response);
    }
  }
  else
  {
    /* Convert MMGSDI status to QMI err code */
    errval = qmi_uim_convert_mmgsdi_status_to_errval(status);
  }

  if (FALSE == qmi_uim_response_card_result(
                 UIMI_TLV_RESP_TAG_OPTIONAL_2,
                 &response,
                 status_cnf_ptr->response_header.status_word))
  {
    errval = QMI_ERR_NO_MEMORY;
    dsm_free_packet(&response);
  }

  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    ds_qmi_fw_free_cmd_buf( &cmd_buf_p );
    return;
  }

  /* Send response */
  if (FALSE == qmi_uimi_send_response(cmd_buf_p,
                                      response))
  {
    UIM_MSG_HIGH_0("Unable to send response for SEND STATUS operation");
    dsm_free_packet(&response);
  }
} /* qmi_uimi_send_status_resp */


/*===========================================================================
  FUNCTION QMI_UIMI_GET_SIM_PROFILE_RESP()

  DESCRIPTION
    Composes the response for get SIM profile request

  PARAMETERS
    status                  : status of MMGSDI operation
    get_sim_profile_cnf_ptr : result of MMGSDI operation

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_get_sim_profile_resp
(
  mmgsdi_return_enum_type                 status,
  const mmgsdi_get_sim_profile_cnf_type  *get_sim_profile_cnf_ptr
)
{
  uint8                               clid               = QMI_SVC_CLID_UNUSED;
  uint32                              client_reg_count   = 0;
  qmi_cmd_buf_type *                  cmd_buf_p          = NULL;
  qmi_uimi_userdata_type            * cb_userdata_ptr    = NULL;
  dsm_item_type *                     response           = NULL;
  qmi_error_e_type                    errval             = QMI_ERR_NONE;
  qmi_result_e_type                   result             = QMI_RESULT_SUCCESS;
  boolean                             retval             = TRUE;

  UIM_MSG_HIGH_0("Sending response for get sim profile");

  ASSERT(get_sim_profile_cnf_ptr);

  /* Retrieve userdata */
  cb_userdata_ptr =
    (qmi_uimi_userdata_type*)get_sim_profile_cnf_ptr->response_header.client_data;
  if (cb_userdata_ptr == NULL)
  {
    UIM_MSG_HIGH_0("Null userdata ptr in response");
    return;
  }

  /* Retrieve info */
  clid              = cb_userdata_ptr->clid;
  client_reg_count  = cb_userdata_ptr->client_reg_count;
  cmd_buf_p         = cb_userdata_ptr->cmd_buf_ptr;

  /* Free userdata */
  qmi_uim_free_cb_userdata(cb_userdata_ptr);
  cb_userdata_ptr = NULL;

  /* First check if the requested client is still valid */
  if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
  {
    UIM_MSG_HIGH_0("Invalid Client, not sending indication or response");
    return;
  }

  QMI_UIM_VALIDATE_SP_IN_CMD_BUF(cmd_buf_p);

  /* Insert APDU response in the TLV, in case of success */
  if (status == MMGSDI_SUCCESS)
  {
    /* Insert profile info TLV*/
    if (FALSE == qmi_uim_response_get_all_profile_info(
                            UIMI_TLV_RESP_TAG_OPTIONAL_1,
                            &response,
                            get_sim_profile_cnf_ptr))
    {
      errval = QMI_ERR_NO_MEMORY;
      dsm_free_packet(&response);
    }

    /* Insert active profile info TLV*/
    if (FALSE == qmi_uim_response_get_active_profile_info(
                            UIMI_TLV_RESP_TAG_OPTIONAL_2,
                            &response,
                            get_sim_profile_cnf_ptr))
    {
      errval = QMI_ERR_NO_MEMORY;
      dsm_free_packet(&response);
    }
  }
  else
  {
    /* Convert MMGSDI status to QMI err code */
    errval = qmi_uim_convert_mmgsdi_status_to_errval(status);
  }

  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    ds_qmi_fw_free_cmd_buf( &cmd_buf_p );
    return;
  }

  /* Send response */
  if (FALSE == qmi_uimi_send_response(cmd_buf_p,
                                      response))
  {
    UIM_MSG_HIGH_0("Unable to send response for get sim profile");
    dsm_free_packet(&response);
  }
} /* qmi_uimi_get_sim_profile_resp */


/*===========================================================================
  FUNCTION QMI_UIMI_SET_SIM_PROFILE_RESP()

  DESCRIPTION
    Composes the response for set SIM profile request

  PARAMETERS
    status                  : status of MMGSDI operation
    set_sim_profile_cnf_ptr : result of MMGSDI operation

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_set_sim_profile_resp
(
  mmgsdi_return_enum_type                 status,
  const mmgsdi_set_sim_profile_cnf_type  *set_sim_profile_cnf_ptr
)
{
  uint8                               clid               = QMI_SVC_CLID_UNUSED;
  uint32                              client_reg_count   = 0;
  qmi_cmd_buf_type *                  cmd_buf_p          = NULL;
  qmi_uimi_userdata_type            * cb_userdata_ptr    = NULL;
  dsm_item_type *                     response           = NULL;
  qmi_error_e_type                    errval             = QMI_ERR_NONE;
  qmi_result_e_type                   result             = QMI_RESULT_SUCCESS;
  boolean                             retval             = TRUE;

  UIM_MSG_HIGH_0("Sending response for set sim profile");

  ASSERT(set_sim_profile_cnf_ptr);

  /* Retrieve userdata */
  cb_userdata_ptr =
    (qmi_uimi_userdata_type*)set_sim_profile_cnf_ptr->response_header.client_data;
  if (cb_userdata_ptr == NULL)
  {
    UIM_MSG_HIGH_0("Null userdata ptr in response");
    return;
  }

  /* Retrieve info */
  clid              = cb_userdata_ptr->clid;
  client_reg_count  = cb_userdata_ptr->client_reg_count;
  cmd_buf_p         = cb_userdata_ptr->cmd_buf_ptr;

  /* Free userdata */
  qmi_uim_free_cb_userdata(cb_userdata_ptr);
  cb_userdata_ptr = NULL;

  /* First check if the requested client is still valid */
  if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
  {
    UIM_MSG_HIGH_0("Invalid Client, not sending indication or response");
    return;
  }

  QMI_UIM_VALIDATE_SP_IN_CMD_BUF(cmd_buf_p);

  /* Convert MMGSDI status to QMI err code */
  errval = qmi_uim_convert_mmgsdi_status_to_errval(status);

  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    ds_qmi_fw_free_cmd_buf( &cmd_buf_p );
    return;
  }

  /* Send response */
  if (FALSE == qmi_uimi_send_response(cmd_buf_p,
                                      response))
  {
    UIM_MSG_HIGH_0("Unable to send response for set sim profile");
    dsm_free_packet(&response);
  }
} /* qmi_uimi_set_sim_profile_resp */


/*===========================================================================
  FUNCTION QMI_UIMI_SEARCH_RECORD_RESP()

  DESCRIPTION
    Composes the response for search record request

  PARAMETERS
    status                  : status of MMGSDI operation
    search_record_cnf_ptr   : result of MMGSDI operation

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_search_record_resp
(
  mmgsdi_return_enum_type                 status,
  const mmgsdi_search_cnf_type           *search_record_cnf_ptr
)
{
  qmi_cmd_buf_type *       cmd_buf_p        = NULL;
  qmi_uimi_userdata_type * cb_userdata_ptr  = NULL;
  dsm_item_type *          response         = NULL;
  qmi_error_e_type         errval           = QMI_ERR_NONE;
  qmi_result_e_type        result           = QMI_RESULT_SUCCESS;
  boolean                  retval           = TRUE;
  boolean                  ind_required     = FALSE;
  uint8                    clid             = QMI_SVC_CLID_UNUSED;
  qmi_uimi_cmd_val_e_type  request_id       = UIMI_CMD_VAL_WIDTH;
  uint32                   client_reg_count = 0;

  UIM_MSG_HIGH_0("Sending response for search record");

  ASSERT( search_record_cnf_ptr );

  /* Retrieve userdata */
  cb_userdata_ptr = (qmi_uimi_userdata_type*)search_record_cnf_ptr->response_header.client_data;
  if (cb_userdata_ptr == NULL)
  {
    UIM_MSG_HIGH_0("Null userdata ptr in response");
    return;
  }

  /* Retrieve info */
  clid             = cb_userdata_ptr->clid;
  client_reg_count = cb_userdata_ptr->client_reg_count;
  request_id       = cb_userdata_ptr->request_id;
  cmd_buf_p        = (qmi_cmd_buf_type*)cb_userdata_ptr->cmd_buf_ptr;
  QMI_UIM_VALIDATE_CMD_BUF_IN_USERDATA(cb_userdata_ptr);

  /* First check if the requested client is still valid */
  if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
  {
    UIM_MSG_HIGH_0("Invalid Client, not sending indication or response");
    qmi_uim_free_cb_userdata(cb_userdata_ptr);
    return;
  }

  /* Check if an indication needs to be sent instead of a response */
  ind_required = cb_userdata_ptr->ind_token.is_valid;
  if (ind_required)
  {
    if (FALSE == qmi_uim_response_ind_token(UIMI_TLV_IND_TAG_MANDATORY_1,
                                            &response,
                                            cb_userdata_ptr->ind_token.token))
    {
      UIM_MSG_ERR_0("Could not insert ind_token TLV, not sending indication");
      qmi_uim_free_cb_userdata(cb_userdata_ptr);
      dsm_free_packet(&response);
      return;
    }
  }

  /* Insert card result in the TLV */
  if (qmi_uim_response_card_result(UIMI_TLV_RESP_TAG_OPTIONAL_1,
                                   &response,
                                   search_record_cnf_ptr->response_header.status_word))
  {
    /* Convert MMGSDI status to QMI err code */
    errval = qmi_uim_convert_mmgsdi_status_to_errval(status);
    if (status == MMGSDI_NOT_SUPPORTED)
    {
      errval = QMI_ERR_NOT_PROVISIONED;
    }
  }
  else
  {
    errval = QMI_ERR_NO_MEMORY;
    dsm_free_packet(&response);
  }

  /* Insert search result in the TLV */
  if (search_record_cnf_ptr->searched_record_nums.data_len <= QMI_UIM_MAX_NUM_RECORD)
  {
    if (FALSE == qmi_uim_response_generic_payload_8bit(
                   UIMI_TLV_RESP_TAG_OPTIONAL_2,
                   &response,
                   search_record_cnf_ptr->searched_record_nums,
                   FALSE))
    {
      errval = QMI_ERR_NO_MEMORY;
      dsm_free_packet(&response);
    }
  }
  else
  {
    errval = QMI_ERR_INTERNAL;
    dsm_free_packet(&response);
  }

  /* Free userdata */
  qmi_uim_free_cb_userdata(cb_userdata_ptr);
  cb_userdata_ptr = NULL;
  
  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    QMI_UIM_FREE_CMD_BUF(cmd_buf_p);
    return;
  }

  /* Send response or indication */
  if (ind_required)
  {
    retval = qmi_uimi_send_indication(clid,
                                     (uint16)request_id,
                                     response);
  }
  else
  {
    retval = qmi_uimi_send_response(cmd_buf_p,
                                    response);
  }
  if (FALSE == retval)
  {
    UIM_MSG_HIGH_0("Unable to send response for search operation");
    dsm_free_packet(&response);
    QMI_UIM_FREE_CMD_BUF(cmd_buf_p);
  }
} /* qmi_uimi_search_record_resp */


/*===========================================================================
  FUNCTION QMI_UIMI_GET_EID_RESP()

  DESCRIPTION
    Composes the response for GET_EID request

  PARAMETERS
    status                       : status of LPA operation
    get_eid_resp_ptr             : result of LPA operation
    cb_userdata_ptr              : user_data to retrieve the cmd

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_get_eid_resp
(
  lpa_result_enum_type                              status,
  const lpa_get_eid_resp_type                     * get_eid_resp_ptr,
  qmi_uimi_userdata_type                          * cb_userdata_ptr
)
{
  qmi_cmd_buf_type *       cmd_buf_p        = NULL;
  dsm_item_type *          response         = NULL;
  qmi_error_e_type         errval           = QMI_ERR_NONE;
  uint32                   client_reg_count = 0;
  uint8                    clid             = QMI_SVC_CLID_UNUSED;

  ASSERT(get_eid_resp_ptr);

  if (cb_userdata_ptr == NULL)
  {
    return;
  }

  /* Retrieve parameters */
  cmd_buf_p        = (qmi_cmd_buf_type*)cb_userdata_ptr->cmd_buf_ptr;
  clid             = cb_userdata_ptr->clid;
  client_reg_count = cb_userdata_ptr->client_reg_count;

  /* Free callback user data */
  qmi_uim_free_cb_userdata(cb_userdata_ptr);
  cb_userdata_ptr = NULL;

  /* First check if the requested client is still valid */
  if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
  {
    return;
  }

  if (cmd_buf_p == NULL)
  {
    return;
  }

  QMI_UIM_VALIDATE_SP_IN_CMD_BUF(cmd_buf_p);

  if (status == LPA_SUCCESS)
  {
    /* Insert EID info TLV*/
    if (FALSE == qmi_uim_response_get_eid_info(
                            UIMI_TLV_RESP_TAG_OPTIONAL_1,
                            &response,
                            get_eid_resp_ptr))
    {
      errval = QMI_ERR_NO_MEMORY;
      dsm_free_packet(&response);
    }
  }
  else
  {
    /* Convert MMGSDI status in QMI code */
    errval = qmi_uim_convert_lpa_status_to_errval(status);
  }

  /* Update result TLV and Send response */
  uimqmi_put_result_send_response_ind(cmd_buf_p,
                                      response,
                                      errval,
                                      QMUX_SERVICE_UIM,
                                      FALSE,
                                      QMI_SVC_CLID_UNUSED,
                                      (uint16)UIMI_CMD_VAL_WIDTH);
}/* qmi_uimi_get_eid_resp */


/*===========================================================================

  FUNCTION QMI_UIMI_GENERIC_RESULT_RESP()

  DESCRIPTION
    Composes the response for delete profile request

  PARAMETERS
    status                      : status of LPA operation
    cb_userdata_ptr             : user_data to retrieve the cmd

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_generic_result_resp
(
  qmi_error_e_type                                  errval,
  qmi_uimi_userdata_type                          * cb_userdata_ptr
)
{
  qmi_cmd_buf_type *       cmd_buf_p        = NULL;
  dsm_item_type *          response         = NULL;
  boolean                  free_userdata    = TRUE;

  if (cb_userdata_ptr == NULL)
  {
    return;
  }

  UIM_MSG_HIGH_2("qmi_uimi_generic_result_resp request_id(lpa_command)=0x%x, errval=0x%x",
                 cb_userdata_ptr->request_id, errval);

  do
  {
    /* Retrieve parameters */
    cmd_buf_p        = (qmi_cmd_buf_type*)cb_userdata_ptr->cmd_buf_ptr;
  
    /* First check if the requested client is still valid */
    if (FALSE == qmi_uim_check_clid(cb_userdata_ptr->clid,
                                    cb_userdata_ptr->client_reg_count))
    {
      break;
    }
  
    if (cmd_buf_p == NULL)
    {
      break;
    }
  
    QMI_UIM_VALIDATE_SP_IN_CMD_BUF(cmd_buf_p);
  
    /* eUICC_RESET: Clear all the profile info.
       ENABLE/DISBALE: REFRESH will be triggered. If client request
         any operation before REFRESH, already available cache can be used.
       ADD_PROFILE: get_profile_info will be done when installation_complete
         received.
       DELETE/UPDATE: Query get_profile_info as REFRESH is not mandatory.
         The cached information will be cleared in get_profile_info response
         handling */

    if (errval == QMI_ERR_NONE)
    {
      if (cb_userdata_ptr->request_id == UIMI_CMD_VAL_EUICC_MEMORY_RESET)
      {
        qmi_uim_clear_profile_info(cb_userdata_ptr->data.lpa.slot);
      }
  
      /* Use the userdata of original request if needs to query profile info
         again from LPA internally after update nickname or delete profile */
      else if (cb_userdata_ptr->request_id == UIMI_CMD_VAL_DELETE_PROFILE ||
               cb_userdata_ptr->request_id == UIMI_CMD_VAL_UPDATE_NICKNAME)
      {
        if (qmi_uim_query_euicc_profile_info(cb_userdata_ptr) == QMI_ERR_NONE)
        {
          free_userdata = FALSE;
        }
      }
    }

    /* Update result TLV and Send response */
    uimqmi_put_result_send_response_ind(cmd_buf_p,
                                        response,
                                        errval,
                                        QMUX_SERVICE_UIM,
                                        FALSE,
                                        QMI_SVC_CLID_UNUSED,
                                        (uint16)UIMI_CMD_VAL_WIDTH);
  } while(0);

  if (free_userdata)
  {
    /* Free callback user data */
    qmi_uim_free_cb_userdata(cb_userdata_ptr);
    cb_userdata_ptr = NULL;
  }
}/* qmi_uimi_generic_result_resp */


/*===========================================================================
  FUNCTION QMI_UIMI_GET_EUICC_PROFILE_RESP()

  DESCRIPTION
    Composes the response for get_sim_profile request

  PARAMETERS
    status                     : status of LPA operation
    get_profiles_info_resp_ptr : result of LPA operation
    cb_userdata_ptr            : user_data to retrieve the cmd

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_get_euicc_profile_resp
(
  lpa_result_enum_type                              status,
  const lpa_get_profiles_info_resp_type           * get_profiles_info_resp_ptr,
  qmi_uimi_userdata_type                          * cb_userdata_ptr
)
{
  qmi_cmd_buf_type *       cmd_buf_p        = NULL;
  dsm_item_type *          response         = NULL;
  qmi_error_e_type         errval           = QMI_ERR_NONE;
  uint32                   client_reg_count = 0;
  uint8                    clid             = QMI_SVC_CLID_UNUSED;
  mmgsdi_slot_id_enum_type slot             = MMGSDI_MAX_SLOT_ID_ENUM;

  ASSERT(get_profiles_info_resp_ptr);

  if (cb_userdata_ptr == NULL)
  {
    return;
  }

  /* Retrieve parameters */
  cmd_buf_p        = (qmi_cmd_buf_type*)cb_userdata_ptr->cmd_buf_ptr;
  clid             = cb_userdata_ptr->clid;
  client_reg_count = cb_userdata_ptr->client_reg_count;
  slot             = cb_userdata_ptr->data.lpa.slot;

  /* Free callback user data */
  qmi_uim_free_cb_userdata(cb_userdata_ptr);
  cb_userdata_ptr = NULL;

  /* First check if the requested client is still valid */
  if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
  {
    return;
  }
  
  if (cmd_buf_p == NULL)
  {
    return;
  }
  
  QMI_UIM_VALIDATE_SP_IN_CMD_BUF(cmd_buf_p);

  if (status == LPA_SUCCESS)
  {
    /* Insert profile info TLV*/
    if (FALSE == qmi_uim_response_get_euicc_profile_info(
                            UIMI_TLV_RESP_TAG_OPTIONAL_1,
                            &response,
                            get_profiles_info_resp_ptr))
    {
      errval = QMI_ERR_NO_MEMORY;
      dsm_free_packet(&response);
    }
    if (errval == QMI_ERR_NONE)
    {
      /* Copy all the profile data in global for providing to apps in the
         subsequents QMI UIM API calls */
      qmi_uim_copy_euicc_profile_info(get_profiles_info_resp_ptr, slot);
    }
  }
  else
  {
    /* Convert LPA status in QMI code */
    errval = qmi_uim_convert_lpa_status_to_errval(status);
  }

  /* Update result TLV and Send response */
  uimqmi_put_result_send_response_ind(cmd_buf_p,
                                      response,
                                      errval,
                                      QMUX_SERVICE_UIM,
                                      FALSE,
                                      QMI_SVC_CLID_UNUSED,
                                      (uint16)UIMI_CMD_VAL_WIDTH);
}/* qmi_uimi_get_euicc_profile_resp */


/*===========================================================================

                             CALLBACK FUNCTIONS

===========================================================================*/

/*===========================================================================
  FUNCTION QMI_UIMI_MMGSDI_CALLBACK()

  DESCRIPTION
    This function is executed as callback of MMGSDI API. This is
    executed in the context of MMGSDI task and needs to make a deep
    copy of the results and post a command to the QMI task to be
    processed.

  PARAMETERS

  RETURN VALUE
    None.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_mmgsdi_callback
(
  mmgsdi_return_enum_type status,
  mmgsdi_cnf_enum_type    cnf_type,
  const mmgsdi_cnf_type  *cnf_ptr
)
{
  qmi_uim_message_type * msg_ptr = NULL;

  /* Copy content into a buffer and post a message to QMI task */
  UIM_MSG_HIGH_1("Got response from MMGSDI for cnf_type: 0x%x", cnf_type);

  switch(cnf_type)
  {
    case MMGSDI_CLIENT_ID_AND_EVT_REG_CNF:
    case MMGSDI_SESSION_OPEN_EXT_CNF:
    case MMGSDI_SESSION_CLOSE_CNF:
    case MMGSDI_READ_CNF:
    case MMGSDI_WRITE_CNF:
    case MMGSDI_GET_FILE_ATTR_CNF:
    case MMGSDI_CARD_PDOWN_CNF:
    case MMGSDI_CARD_PUP_CNF:
    case MMGSDI_REFRESH_CNF:
    case MMGSDI_PIN_OPERATION_CNF:
    case MMGSDI_RUN_CAVE_CNF:
    case MMGSDI_SESSION_RUN_GSM_ALGO_CNF:
    case MMGSDI_ISIM_AUTH_CNF:
    case MMGSDI_USIM_AUTH_CNF:
    case MMGSDI_COMPUTE_IP_AUTH_CNF:
    case MMGSDI_SESSION_ENABLE_SERVICE_CNF:
    case MMGSDI_SESSION_DISABLE_SERVICE_CNF:
    case MMGSDI_SRV_AVAILABLE_CNF:
    case MMGSDI_SESSION_GET_APP_CAPABILITIES_CNF:
    case MMGSDI_GET_ALL_PIN_STATUS_CNF:
    case MMGSDI_SESSION_ACTIVATE_OR_SWITCH_PROVISIONING_CNF:
    case MMGSDI_SESSION_DEACTIVATE_CNF:
    case MMGSDI_SEND_APDU_EXT_CNF:
    case MMGSDI_SAP_CONNECT_CNF:
    case MMGSDI_SAP_DISCONNECT_CNF:
    case MMGSDI_SAP_GET_ATR_CNF:
    case MMGSDI_SAP_SEND_APDU_CNF:
    case MMGSDI_SAP_POWER_ON_CNF:
    case MMGSDI_SAP_POWER_OFF_CNF:
    case MMGSDI_SAP_RESET_CNF:
    case MMGSDI_SAP_CARD_READER_STATUS_CNF:
    case MMGSDI_SESSION_SUBSCRIPTION_OK_CNF:
    case MMGSDI_GET_ATR_CNF:
    case MMGSDI_SESSION_OPEN_WITH_SELECT_RSP_CNF:
    case MMGSDI_SESSION_OPEN_WITH_MF_CNF:
    case MMGSDI_REHABILITATE_CNF:
    case MMGSDI_INVALIDATE_CNF:
    case MMGSDI_INCREASE_CNF:
    case MMGSDI_SESSION_SELECT_AID_CNF:
    case MMGSDI_CARD_STATUS_CNF:
    case MMGSDI_GET_SIM_PROFILE_CNF:
    case MMGSDI_SET_SIM_PROFILE_CNF:
    case MMGSDI_SEARCH_CNF:
      msg_ptr = qmi_uim_create_message(QMI_UIM_MESSAGE_CNF);
      if (msg_ptr != NULL)
      {
        msg_ptr->data.cnf.cnf_type  = cnf_type;
        msg_ptr->data.cnf.status    = status;

        /* Make deep copy of confirmation */
        qmi_uim_cnf_deep_copy(
          cnf_type,
          &msg_ptr->data.cnf.cnf_value,
          cnf_ptr);

        /* Send command */
        qmi_uim_post_message(msg_ptr);
        msg_ptr = NULL;
      }
      break;

    default:
      UIM_MSG_ERR_0("Message cnf not handled");
      break;
  }
} /* qmi_uimi_mmgsdi_callback */


/*===========================================================================
  FUNCTION QMI_UIMI_GBA_CALLBACK()

  DESCRIPTION
    This function is executed as callback of GBA API. This function makes a
    deep copy of the results and post a command to the QMI task to be
    processed.

  PARAMETERS

  RETURN VALUE
    None.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_gba_callback
(
  gba_result_enum_type          status,
  uint32                        request_id,
  const gba_response_data_type *cnf_ptr,
  const void                   *user_data_ptr
)
{
  qmi_uim_message_type * msg_ptr = NULL;

  (void)request_id;

  UIM_MSG_HIGH_1("Got response from GBA with status: 0x%x", status);

  if(status == GBA_SUCCESS && cnf_ptr == NULL)
  {
    UIM_MSG_ERR_0("NULL response from GBA module");
    return;
  }

  /* Copy content into a buffer and post a message to QMI task */
  msg_ptr = qmi_uim_create_message(QMI_UIM_MESSAGE_GBA_CB);
  if (msg_ptr != NULL)
  {
    msg_ptr->data.gba_cnf.status    = status;

    if(cnf_ptr != NULL)
    {
      (void)memscpy(&msg_ptr->data.gba_cnf.cnf_value,
                    sizeof(msg_ptr->data.gba_cnf.cnf_value),
                    cnf_ptr,
                    sizeof(gba_response_data_type));
    }
    msg_ptr->data.gba_cnf.user_data_ptr = user_data_ptr;

    /* Send command */
    qmi_uim_post_message(msg_ptr);
    msg_ptr = NULL;
  }
} /* qmi_uimi_gba_callback */


/*===========================================================================
  FUNCTION QMI_UIMI_LPA_CALLBACK()

  DESCRIPTION
    This function is executed as callback of LPA API. This function makes a
    deep copy of the results and post a command to the QMI task to be
    processed.

  PARAMETERS
    status           : LPA status for the request
    cnf_ptr          : LPA response data
    user_data_ptr    : Client data

  RETURN VALUE
    None.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_lpa_callback
(
  lpa_result_enum_type          status,
  const lpa_response_data_type *cnf_ptr,
  void                         *user_data_ptr
)
{
  qmi_uim_message_type * msg_ptr = NULL;
  qmi_uimi_userdata_type * cb_userdata_ptr  = NULL;

  UIM_MSG_HIGH_1("Got response from LPA with status: 0x%x", status);

  if(status == LPA_SUCCESS && cnf_ptr == NULL)
  {
    return;
  }

  cb_userdata_ptr = (qmi_uimi_userdata_type*)user_data_ptr;
  if (cb_userdata_ptr != NULL)
  {
    if(cb_userdata_ptr->data.lpa.is_profile_query)
    {
      msg_ptr = qmi_uim_create_message(QMI_UIM_MESSAGE_LPA_PROFILE_INFO_CB);
    }
    else
    {
      msg_ptr = qmi_uim_create_message(QMI_UIM_MESSAGE_LPA_CB);
    }
  }

  /* Copy content into a buffer and post a message to QMI task */
  if (msg_ptr != NULL)
  {
    msg_ptr->data.lpa_cnf.status    = status;

    if(cnf_ptr != NULL)
    {
      (void)memscpy(&msg_ptr->data.lpa_cnf.cnf_value,
                    sizeof(msg_ptr->data.lpa_cnf.cnf_value),
                    cnf_ptr,
                    sizeof(lpa_response_data_type));

    /* Need to deep copy the icon data from response */
    if (cnf_ptr->msg_type == LPA_GET_PROFILES_INFO_MSG)
    {
      uint8     num_profiles = MIN (msg_ptr->data.lpa_cnf.cnf_value.message.get_profiles_info_resp.num_profiles, QMI_UIM_PROFILES_MAX_V01);
      uint8     profile_index = 0;

      for (profile_index = 0; profile_index < num_profiles; profile_index++)
      {
        if (cnf_ptr->message.get_profiles_info_resp.profile_info[profile_index].icon.data_len > 0)
        {
          uimqmi_deep_copy((void **)&cnf_ptr->message.get_profiles_info_resp.profile_info[profile_index].icon.data_ptr,
                           (void *)msg_ptr->data.lpa_cnf.cnf_value.message.get_profiles_info_resp.profile_info[profile_index].icon.data_ptr,
                           (uint32)cnf_ptr->message.get_profiles_info_resp.profile_info[profile_index].icon.data_len);
        }
      }
    }
    }

    msg_ptr->data.lpa_cnf.user_data_ptr = user_data_ptr;

    /* Send command */
    qmi_uim_post_message(msg_ptr);
    msg_ptr = NULL;
  }
} /* qmi_uimi_lpa_callback */


/*===========================================================================
  FUNCTION QMI_UIM_LPA_EVENT_CALLBACK()

  DESCRIPTION
    This function is executed as event callback from LPA. This function makes
    a deep copy of the event data and post a command to the QMI task to be
    processed.

  PARAMETERS
  status             : LPA status for the request
  event_ptr          : LPA event data

  RETURN VALUE
    None.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_lpa_event_callback
(
  lpa_result_enum_type                status,
  const lpa_event_data_type         * event_ptr
)
{
  qmi_uim_message_type * msg_ptr = NULL;

  ASSERT(event_ptr);

  UIM_MSG_HIGH_1("Received event callback from LPA for event 0x%x",
                 event_ptr->evt_type);

  switch(event_ptr->evt_type)
  {
    /* Post events to the QMI context. */
    case LPA_PROFILE_DOWNLOAD_PROGRESS_EVENT:
      msg_ptr = qmi_uim_create_message(QMI_UIM_MESSAGE_LPA_EVENT);
      if (msg_ptr == NULL)
      {
        return;
      }

      msg_ptr->data.lpa_evt.evt.evt_type = event_ptr->evt_type;
      msg_ptr->data.lpa_evt.status       = status;

      msg_ptr->data.lpa_evt.evt.evt_data.profile_download_progress =
        event_ptr->evt_data.profile_download_progress;

      /* Send command */
      qmi_uim_post_message(msg_ptr);
      msg_ptr = NULL;
      break;

    default:
      UIM_MSG_MED_1("Unhandled event: 0x%x", event_ptr->evt_type);
      break;
  }
} /* qmi_uimi_lpa_event_callback */


/*===========================================================================
  FUNCTION QMI_UIMI_SIMLOCK_CALLBACK()

  DESCRIPTION
    This function is executed as callback of SIM Lock API. This is
    executed in the context of SIM Lock task and needs to make a deep
    copy of the results and post a command to the QMI task to be
    processed.

  PARAMETERS

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_uimi_simlock_callback
(
  simlock_result_enum_type                    status,
  const simlock_message_response_data_type  * resp_ptr,
  const void                                * user_data_ptr
)
{
  qmi_uim_message_type * msg_ptr = NULL;

  ASSERT(user_data_ptr != NULL);

  /* resp_ptr can be NULL if SIMLOCK cleans up commands as part of TASK STOP
     signal handling */
  if(resp_ptr == NULL)
  {
    qmi_uim_free_cb_userdata((qmi_uimi_userdata_type*)user_data_ptr);
    return;
  }

  UIM_MSG_HIGH_1("Got response from SIM Lock for message: 0x%x", resp_ptr->msg_type);

  switch(resp_ptr->msg_type)
  {
    case SIMLOCK_UNLOCK_DEVICE_MSG:
    case SIMLOCK_TEMPORARY_UNLOCK_MSG:
    case SIMLOCK_GET_STATUS_MSG:
    case SIMLOCK_SET_LOCK_CK_MSG:
    case SIMLOCK_SET_DEVICE_MODE_MSG:
    case SIMLOCK_ADD_LOCK_CODES_CK_MSG:
    case SIMLOCK_RELOCK_DEVICE_MSG:
      msg_ptr = qmi_uim_create_message(QMI_UIM_MESSAGE_SIMLOCK_CB);
      if (msg_ptr != NULL)
      {
        msg_ptr->data.simlock.status  = status;
        msg_ptr->data.simlock.user_data_ptr = user_data_ptr;

        memscpy(&msg_ptr->data.simlock.data,
                sizeof(msg_ptr->data.simlock.data),
                resp_ptr,
                sizeof(simlock_message_response_data_type));

        /* Send command */
        qmi_uim_post_message(msg_ptr);
        msg_ptr = NULL;
      }
      break;

    default:
      UIM_MSG_ERR_0("Message type not supported");
      break;
  }
} /* qmi_uimi_simlock_callback */


/*===========================================================================
  FUNCTION QMI_UIM_SIMLOCK_REMOTE_SFS_CB()

  DESCRIPTION
    This function is executed in the context of SIM Lock task, when the
    simlock requires the data to be read from or written to a remote
    SFS

  PARAMETERS

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static simlock_result_enum_type qmi_uim_simlock_remote_sfs_cb (
  simlock_file_operation_enum_type            operation,
  simlock_file_type                           file,
  simlock_token_id_type                       token,
  const simlock_data_type                   * simlock_data_ptr,
  simlock_remote_sfs_response_cb_type         simlock_resp_cb
)
{
  qmi_uim_message_type * msg_ptr = NULL;

  ASSERT(simlock_data_ptr != NULL);

  UIM_MSG_HIGH_1("qmi_uim_simlock_remote_sfs_cb, operation: 0x%x", operation);

  msg_ptr = qmi_uim_create_message(QMI_UIM_MESSAGE_SIMLOCK_REMOTE_SFS_CB);

  if(msg_ptr != NULL)
  {
    msg_ptr->data.simlock_remote_sfs_req.operation           = operation;
    msg_ptr->data.simlock_remote_sfs_req.request_token_id    = token;
    msg_ptr->data.simlock_remote_sfs_req.file                = file;
    msg_ptr->data.simlock_remote_sfs_req.simlock_resp_cb     = simlock_resp_cb;

    if (simlock_data_ptr->data_len > 0)
    {
      msg_ptr->data.simlock_remote_sfs_req.simlock_data.data_len =
                                               simlock_data_ptr->data_len;

      qmi_uim_deep_copy(
        (void**)&msg_ptr->data.simlock_remote_sfs_req.simlock_data.data_ptr,
        (void*)simlock_data_ptr->data_ptr,
        (uint32)simlock_data_ptr->data_len);
    }
    else
    {
      msg_ptr->data.simlock_remote_sfs_req.simlock_data.data_len = 0;
      msg_ptr->data.simlock_remote_sfs_req.simlock_data.data_ptr = NULL;
    }

    /* Send command */
    qmi_uim_post_message(msg_ptr);
    msg_ptr = NULL;

    return SIMLOCK_SUCCESS;
  }

  return SIMLOCK_GENERIC_ERROR;
} /* qmi_uim_simlock_remote_sfs_cb */


/*===========================================================================
  FUNCTION QMI_UIMI_SIMLOCK_SET_REMOTE_SFS_CALLBACK()

  DESCRIPTION
    This function is executed as callback of simlock_set_remote_sfs API.
    This is executed in the context of SIM Lock task.

  PARAMETERS

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_simlock_set_remote_sfs_callback
(
  simlock_result_enum_type                    status,
  const void                                * user_data_ptr
)
{
  qmi_uim_message_type * msg_ptr = NULL;

  ASSERT(user_data_ptr != NULL);

  UIM_MSG_HIGH_0("Got response from set remote SFS req");

  msg_ptr = qmi_uim_create_message(QMI_UIM_MESSAGE_SIMLOCK_SET_REMOTE_SFS_CB);

  if(msg_ptr != NULL)
  {
    msg_ptr->data.simlock_set_remote_sfs_resp.status        = status;
    msg_ptr->data.simlock_set_remote_sfs_resp.user_data_ptr = user_data_ptr;

    /* Send command */
    qmi_uim_post_message(msg_ptr);
    msg_ptr = NULL;
  }
} /* qmi_uimi_simlock_set_remote_sfs_callback */


/*===========================================================================
  FUNCTION QMI_UIMI_REMOTE_UNLOCK_CALLBACK()

  DESCRIPTION
    This function is executed as callback of SIM Lock remote unlock API.
    This is executed in the context of SIM Lock task and needs to make a deep
    copy of the results and post a command to the QMI task to be processed.

  PARAMETERS

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_remote_unlock_callback
(
  simlock_result_enum_type             status,
  const simlock_data_type              resp_data,
  const void                         * user_data_ptr

)
{
  qmi_uim_message_type * msg_ptr = NULL;

  msg_ptr = qmi_uim_create_message(QMI_UIM_MESSAGE_REMOTE_UNLOCK_CB);
  if(msg_ptr != NULL)
  {
    msg_ptr->data.remote_unlock_resp.status        = status;
    msg_ptr->data.remote_unlock_resp.user_data_ptr = user_data_ptr;

    if (resp_data.data_len > 0)
    {
      msg_ptr->data.remote_unlock_resp.key_data.data_len =
                                               resp_data.data_len;

      qmi_uim_deep_copy(
        (void**)&msg_ptr->data.remote_unlock_resp.key_data.data_ptr,
        (void*)resp_data.data_ptr,
        (uint32)resp_data.data_len);
    }
    else
    {
      msg_ptr->data.remote_unlock_resp.key_data.data_len = 0;
      msg_ptr->data.remote_unlock_resp.key_data.data_ptr = NULL;
    }

    /* Send command */
    qmi_uim_post_message(msg_ptr);
    msg_ptr = NULL;
  }
} /* qmi_uimi_remote_unlock_callback */


/*===========================================================================
  FUNCTION QMI_UIMI_SIMLOCK_TEMPORARY_UNLOCK_CALLBACK()

  DESCRIPTION
    This function is executed as callback of SIM Lock API. This is
    executed in the context of SIM Lock task and needs to make a deep
    copy of the results and post a command to the QMI task to be
    processed.

  PARAMETERS

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_simlock_temporary_unlock_callback
(
  simlock_result_enum_type                    status,
  const simlock_message_response_data_type  * resp_ptr,
  const void                                * user_data_ptr
)
{
  qmi_uim_message_type * msg_ptr = NULL;

  /* resp_ptr can be NULL if SIMLOCK cleans up commands as part of TASK STOP
     signal handling */
  if(resp_ptr == NULL)
  {
    return;
  }

  UIM_MSG_HIGH_0("qmi_uimi_simlock_get_status_callback");

  msg_ptr = qmi_uim_create_message(QMI_UIM_MESSAGE_SIMLOCK_TEMPORARY_UNLOCK_CB);
  if (msg_ptr != NULL)
  {
    msg_ptr->data.simlock.status  = status;
    msg_ptr->data.simlock.user_data_ptr = user_data_ptr;

    memscpy(&msg_ptr->data.simlock.data,
            sizeof(msg_ptr->data.simlock.data),
            resp_ptr,
            sizeof(simlock_message_response_data_type));

    /* Send command */
    qmi_uim_post_message(msg_ptr);
    msg_ptr = NULL;
  }
} /* qmi_uimi_simlock_temporary_unlock_callback */


#ifdef FEATURE_UIM_SSM
/*===========================================================================
  FUNCTION QMI_UIM_SSM_CBACK

  DESCRIPTION
    This callback is used to notify QMI UIM asynchronosly about the state of
    initialization.  'qmi_uim_ssm_id' is only valid when this callback returns
    'E_SSM_SUCCESS'.  SSM can transition to different modes, and this callback
    will be used to notify Diag if 'qmi_uim_ssm_id' is valid or not.

  PARAMETERS
    ssm_err_t

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_ssm_cback
(
  ssm_err_t err
)
{
  UIM_MSG_MED_1("qmi_uim_ssm_cback with err= 0x%x", err);
  if (qmi_uim_global_ptr != NULL)
  {
    qmi_uim_global_ptr->ssm_info.qmi_uim_ssm_init_err = err;
  }
} /* qmi_uim_ssm_cback */
#endif /* FEATURE_UIM_SSM */


/*===========================================================================
  FUNCTION  QMI_UIM_PROCESS_UNLOCK_RESP

  DESCRIPTION
    Processes the response to the SIM Lock unlock command

  PARAMETERS
    status          : Status of the unlock request
    unlock_ptr      : Pointer to the unlock response data
    user_data_ptr   : Pointer to the user data

  RETURN VALUE
    None

  DEPENDENCIES
    QMI UIM must already have been initialized and registered with Framework

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_process_unlock_resp
(
  simlock_result_enum_type                     status,
  const simlock_unlock_device_msg_resp_type  * unlock_ptr,
  qmi_uimi_userdata_type                     * user_data_ptr
)
{
  qmi_cmd_buf_type              * cmd_buf_p           = NULL;
  dsm_item_type                 * response            = NULL;
  qmi_error_e_type                errval              = QMI_ERR_NONE;
  qmi_result_e_type               result              = QMI_RESULT_SUCCESS;
  boolean                         retval              = TRUE;
  uint8                           clid                = QMI_SVC_CLID_UNUSED;
  simlock_category_enum_type      category            = SIMLOCK_CATEGORY_3GPP_NW;
  simlock_slot_enum_type          slot                = SIMLOCK_SLOT_1;
  uint32                          client_reg_count    = 0;
  uint32                          num_retries         = 0;
  uint16                          request_id          = 0;
  boolean                         ck_present          = TRUE;
  qmi_uimi_cmd_val_e_type         cmd_id              = UIMI_CMD_VAL_WIDTH;

  UIM_MSG_HIGH_0("qmi_uim_process_unlock_resp");

  ASSERT( unlock_ptr );
  ASSERT( user_data_ptr );

  /* Retrieve parameters */
  clid             = user_data_ptr->clid;
  cmd_id           = user_data_ptr->request_id;
  client_reg_count = user_data_ptr->client_reg_count;
  category         = user_data_ptr->data.simlock_unlock.category;
  slot             = user_data_ptr->data.simlock_unlock.slot;
  cmd_buf_p        = (qmi_cmd_buf_type*)user_data_ptr->cmd_buf_ptr;
  request_id       = user_data_ptr->data.simlock_unlock.request_id;
  ck_present       = user_data_ptr->data.simlock_unlock.ck_present;

  if (status != SIMLOCK_SUCCESS && ck_present)
  {
    simlock_result_enum_type    simlock_status  = SIMLOCK_SUCCESS;

    if (unlock_ptr->num_retries_max == 0)
    {
      num_retries = QMI_UIM_SIMLOCK_MAX_RETRIES;
    }
    else if (unlock_ptr->curr_retries >= unlock_ptr->num_retries_max)
    {
      num_retries = 0;
    }
    else
    {
      num_retries = unlock_ptr->num_retries_max - unlock_ptr->curr_retries;
    }

    user_data_ptr->data.simlock_unlock.num_retries = num_retries;
    user_data_ptr->data.simlock_unlock.result      = status;

    simlock_status = simlock_get_status(qmi_uimi_simlock_callback,
                                        user_data_ptr);
    if(simlock_status == SIMLOCK_SUCCESS)
    {
      /* In case of sucess return. The response to client
         is sent in the get_status callback */
      return;
    }

    /* Update SIM Lock retries in the global variable. Since
       get_status failed, use the default slot policy to update retries */
    (void)qmi_uim_update_simlock_retries(category, slot,
                                         SIMLOCK_SLOT_POLICY_SAME_ON_ALL_SLOTS, num_retries);
  }

  /* Convert SIMLOCK status in QMI code */
  errval = qmi_uim_convert_simlock_status_to_errval(status);

  /* Free userdata */
  qmi_uim_free_cb_userdata(user_data_ptr);
  user_data_ptr = NULL;

  /* First check if the requested client is still valid */
  if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
  {
    UIM_MSG_HIGH_0("Invalid Client, not sending response");
    return;
  }

  if (cmd_buf_p == NULL)
  {
    UIM_MSG_HIGH_0("Null cmd_buf ptr in response");
    return;
  }

  QMI_UIM_VALIDATE_SP_IN_CMD_BUF(cmd_buf_p);

  if (status != SIMLOCK_SUCCESS && ck_present)
  {
    /* Send the num_retries in the response */
    if (FALSE == qmi_uim_response_retries_left(
                  UIMI_TLV_RESP_TAG_OPTIONAL_1,
                  &response,
                  num_retries,
                  0))
    {
      dsm_free_packet(&response);
    }
  }

  if(cmd_id == UIMI_CMD_VAL_DEPERSONALIZATION_SECURE)
  {
    /* build the result and encrypt the data */
    errval = qmi_uim_response_encrypted_status(UIMI_TLV_RESP_TAG_OPTIONAL_1,
                                               UIMI_CMD_VAL_DEPERSONALIZATION_SECURE,
                                               request_id,
                                               errval,
                                               &response);
  }

  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    ds_qmi_fw_free_cmd_buf(&cmd_buf_p);
    return;
  }

  /* Send response */
  if (FALSE == qmi_uimi_send_response(cmd_buf_p,
                                      response))
  {
    UIM_MSG_HIGH_0("Unable to send response for SIM Lock unlock operation");
    dsm_free_packet(&response);
  }
} /* qmi_uim_process_unlock_resp */


/*===========================================================================
  FUNCTION  QMI_UIM_PROCESS_SIMLOCK_GET_STATUS_RESP_AFTER_UNLOCK

  DESCRIPTION
    Processes the response to the SIM Lock get status command which was
    requested due to a failed unlock attempt

  PARAMETERS
    status          : Status of the get_status request
    get_status_ptr  : Pointer to the response data
    user_data_ptr   : Pointer to the user data

  RETURN VALUE
    None

  DEPENDENCIES
    QMI UIM must already have been initialized and registered with Framework

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_process_simlock_get_status_resp_after_unlock
(
  simlock_result_enum_type                  status,
  const simlock_get_status_msg_resp_type  * get_status_ptr,
  qmi_uimi_userdata_type                  * user_data_ptr
)
{
  qmi_cmd_buf_type             * cmd_buf_p           = NULL;
  dsm_item_type                * response            = NULL;
  qmi_error_e_type               errval              = QMI_ERR_NONE;
  qmi_result_e_type              result              = QMI_RESULT_SUCCESS;
  boolean                        retval              = TRUE;
  uint8                          clid                = QMI_SVC_CLID_UNUSED;
  uint32                         client_reg_count    = 0;
  simlock_category_enum_type     category            = SIMLOCK_CATEGORY_3GPP_NW;
  simlock_slot_enum_type         slot                = SIMLOCK_SLOT_1;
  simlock_result_enum_type       unlock_status       = SIMLOCK_SUCCESS;
  simlock_slot_policy_enum_type  slot_policy         = SIMLOCK_SLOT_POLICY_SAME_ON_ALL_SLOTS;
  uint32                         num_retries         = 0;

  UIM_MSG_MED_0("qmi_uim_process_simlock_get_status_resp_after_unlock");

  ASSERT( get_status_ptr );
  ASSERT( user_data_ptr );

  /* Retrieve parameters */
  clid             = user_data_ptr->clid;
  client_reg_count = user_data_ptr->client_reg_count;
  category         = user_data_ptr->data.simlock_unlock.category;
  slot             = user_data_ptr->data.simlock_unlock.slot;
  unlock_status    = user_data_ptr->data.simlock_unlock.result;
  num_retries      = user_data_ptr->data.simlock_unlock.num_retries;
  cmd_buf_p        = (qmi_cmd_buf_type*)user_data_ptr->cmd_buf_ptr;

  /* Free userdata */
  qmi_uim_free_cb_userdata(user_data_ptr);
  user_data_ptr = NULL;

  /* First check if the requested client is still valid */
  if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
  {
    UIM_MSG_HIGH_0("Invalid Client, not sending response");
    return;
  }

  if (cmd_buf_p == NULL)
  {
    UIM_MSG_HIGH_0("Null cmd_buf ptr in response");
    return;
  }

  QMI_UIM_VALIDATE_SP_IN_CMD_BUF(cmd_buf_p);

  /* If the request is a success, retrieve the
     slot_policy from the response. In case the request
     is a failure, then set the policy to SAME_ON_ALL_SLOTS
     as the best possible option */
  if (status == SIMLOCK_SUCCESS)
  {
    slot_policy = get_status_ptr->slot_policy;
  }

  /* Update SIM Lock retries in the global variable */
  (void)qmi_uim_update_simlock_retries(category, slot,
                                       slot_policy, num_retries);

  errval = qmi_uim_convert_simlock_status_to_errval(unlock_status);

  if (FALSE == qmi_uim_response_retries_left(
                    UIMI_TLV_RESP_TAG_OPTIONAL_1,
                    &response,
                    num_retries,
                    0))
  {
    errval = QMI_ERR_NO_MEMORY;
    dsm_free_packet(&response);
  }

  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    ds_qmi_fw_free_cmd_buf( &cmd_buf_p );
    return;
  }

  /* Send response */
  if (FALSE == qmi_uimi_send_response(cmd_buf_p,
                                      response))
  {
    UIM_MSG_HIGH_0("Unable to send response for simlock operation");
    dsm_free_packet(&response);
  }
} /* qmi_uim_process_simlock_get_status_resp_after_unlock */


/*===========================================================================
  FUNCTION  QMI_UIM_PROCESS_SIMLOCK_GET_STATUS_RESP

  DESCRIPTION
    Processes the response to the SIM Lock get status command

  PARAMETERS
    status          : Status of the get_status request
    get_status_ptr  : Pointer to the response data
    user_data_ptr   : Pointer to the user data

  RETURN VALUE
    None

  DEPENDENCIES
    QMI UIM must already have been initialized and registered with Framework

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_process_simlock_get_status_resp
(
  simlock_result_enum_type                  status,
  const simlock_get_status_msg_resp_type  * get_status_ptr,
  qmi_uimi_userdata_type                  * user_data_ptr
)
{
  qmi_cmd_buf_type       * cmd_buf_p           = NULL;
  dsm_item_type          * response            = NULL;
  qmi_error_e_type         errval              = QMI_ERR_NONE;
  qmi_result_e_type        result              = QMI_RESULT_SUCCESS;
  boolean                  retval              = TRUE;
  uint8                    clid                = QMI_SVC_CLID_UNUSED;
  uint32                   client_reg_count    = 0;

  UIM_MSG_HIGH_0("qmi_uim_process_simlock_get_status_resp");

  ASSERT( get_status_ptr );
  ASSERT( user_data_ptr );
  ASSERT( qmi_uim_global_ptr );

  if (status != SIMLOCK_SUCCESS)
  {
    UIM_MSG_ERR_1("Error in SIM Lock result: 0x%x", status);
    errval = QMI_ERR_INTERNAL;
  }

  /* If we are sending result here then personalisation data was definitly requested.*/
  /* Send the automatic selection TLV only if it was requested, even if we failed to get perso
     configuration */
  if(user_data_ptr->data.get_configuration.automatic_selection_status)
  {
    if (FALSE == qmi_uim_response_boolean(
                        UIMI_TLV_RESP_TAG_OPTIONAL_1,
                        &response,
                        user_data_ptr->data.get_configuration.automatic_selection))
    {
      errval = QMI_ERR_NO_MEMORY;
      dsm_free_packet(&response);
    }
  }

  /* Insert TLV with perso configuration only in case of success */
  if (errval == QMI_ERR_NONE)
  {
    if (FALSE == qmi_uim_response_get_configuration_simlock(
                        UIMI_TLV_RESP_TAG_OPTIONAL_2,
                        &response,
                        get_status_ptr))
    {
      errval = QMI_ERR_NO_MEMORY;
      dsm_free_packet(&response);
    }
  }

    /* Insert TLV with halt subscription configuration */
  if((user_data_ptr->data.get_configuration.halt_subscription_status) &&
     (errval == QMI_ERR_NONE))
  {
    if (FALSE == qmi_uim_response_boolean(
                      UIMI_TLV_RESP_TAG_OPTIONAL_3,
                      &response,
                      user_data_ptr->data.get_configuration.halt_subscription))
    {
      errval = QMI_ERR_NO_MEMORY;
      dsm_free_packet(&response);
    }
  }

  /* Insert TLV with temporary unlock time left */
  if (errval == QMI_ERR_NONE)
  {
    if (FALSE == qmi_uim_response_temporary_unlock_time_left(
                        UIMI_TLV_RESP_TAG_OPTIONAL_7,
                        &response,
                        qmi_uim_global_ptr->card_state.num_slots,
                        get_status_ptr))
    {
      errval = QMI_ERR_NO_MEMORY;
      dsm_free_packet(&response);
    }
  }

  /* Insert TLV with perso control key only in case of success */
  if (errval == QMI_ERR_NONE)
  {
    if (FALSE == qmi_uim_response_perso_control_key_presence(
                        UIMI_TLV_RESP_TAG_OPTIONAL_9,
                        &response,
                        qmi_uim_global_ptr->card_state.num_slots,
                        get_status_ptr))
    {
      errval = QMI_ERR_NO_MEMORY;
      dsm_free_packet(&response);
    }
  }

  /* Retrieve parameters */
  clid             = user_data_ptr->clid;
  client_reg_count = user_data_ptr->client_reg_count;
  cmd_buf_p = (qmi_cmd_buf_type*)user_data_ptr->cmd_buf_ptr;

  /* Free userdata */
  qmi_uim_free_cb_userdata(user_data_ptr);
  user_data_ptr = NULL;

  /* First check if the requested client is still valid */
  if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
  {
    UIM_MSG_HIGH_0("Invalid Client, not sending response");
    dsm_free_packet(&response);
    return;
  }

  if (cmd_buf_p == NULL)
  {
    UIM_MSG_HIGH_0("Null cmd_buf ptr in response");
    dsm_free_packet(&response);
    return;
  }

  QMI_UIM_VALIDATE_SP_IN_CMD_BUF_FREE_RESPONSE(cmd_buf_p, response);

  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    ds_qmi_fw_free_cmd_buf( &cmd_buf_p );
    return;
  }

  /* Send response */
  if (FALSE == qmi_uimi_send_response(cmd_buf_p,
                                      response))
  {
    UIM_MSG_HIGH_0("Unable to send response for Perso operation");
    dsm_free_packet(&response);
  }
} /* qmi_uim_process_simlock_get_status_resp */


/*===========================================================================
  FUNCTION  QMI_UIM_PROCESS_SIMLOCK_TEMPORARY_UNLOCK_CB

  DESCRIPTION
    Processes the response to the SIM Lock get status command which is queued
    in handling of MMGSDI_TEMPORARY_UNLOCK_EVENT.

  PARAMETERS
    uim_message_ptr : Message pointer containing the information received from SIMLOCK
                      get status request

  RETURN VALUE
    None

  DEPENDENCIES
    QMI UIM must already have been initialized and registered with Framework

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_process_simlock_temporary_unlock_cb(
  const qmi_uim_message_type *uim_message_ptr
)
{
  const simlock_get_status_msg_resp_type *get_status_ptr = NULL;

  ASSERT(uim_message_ptr);

  UIM_MSG_MED_0("qmi_uim_process_simlock_temporary_unlock_cb");

  /* If the response from SIMLOCK is failure and is not get_status message,
     then no further processing can be done.*/
  if(uim_message_ptr->message_type != QMI_UIM_MESSAGE_SIMLOCK_TEMPORARY_UNLOCK_CB ||
     uim_message_ptr->data.simlock.status != SIMLOCK_SUCCESS ||
     uim_message_ptr->data.simlock.data.msg_type != SIMLOCK_GET_STATUS_MSG)
  {
    return;
  }

  /* stores the simlock slot policy */
  qmi_uim_global_ptr->simlock_slot_policy =
    uim_message_ptr->data.simlock.data.message.get_status_resp.slot_policy;

  get_status_ptr = &uim_message_ptr->data.simlock.data.message.get_status_resp;

  if(qmi_uim_check_and_update_if_simlock_temporary_unlock_status_changed(
       get_status_ptr))
  {
    qmi_uim_send_temporary_unlock_indication_to_all(get_status_ptr);
  }
} /* qmi_uim_process_simlock_temporary_unlock_cb */


/*===========================================================================
  FUNCTION  QMI_UIM_PROCESS_LOCK_RESP

  DESCRIPTION
    Processes the response of the personalization command

  PARAMETERS
    status          : Status of the lock request
    user_data_ptr   : Pointer to the user data

  RETURN VALUE
    None

  DEPENDENCIES
    QMI UIM must already have been initialized and registered with Framework

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_process_lock_resp
(
  simlock_result_enum_type       status,
  qmi_uimi_userdata_type       * user_data_ptr
)
{
  qmi_cmd_buf_type          * cmd_buf_p           = NULL;
  dsm_item_type             * response            = NULL;
  qmi_error_e_type            errval              = QMI_ERR_NONE;
  qmi_result_e_type           result              = QMI_RESULT_SUCCESS;
  boolean                     retval              = TRUE;
  uint8                       clid                = QMI_SVC_CLID_UNUSED;
  uint32                      client_reg_count    = 0;
  uint16                      request_id          = 0;
  boolean                     ck_present          = TRUE;
  qmi_uimi_cmd_val_e_type     cmd_id              = UIMI_CMD_VAL_WIDTH;

  UIM_MSG_HIGH_0("qmi_uim_process_lock_resp");

  ASSERT( user_data_ptr );

  /* Retrieve parameters */
  clid             = user_data_ptr->clid;
  cmd_id           = user_data_ptr->request_id;
  client_reg_count = user_data_ptr->client_reg_count;
  cmd_buf_p        = (qmi_cmd_buf_type*)user_data_ptr->cmd_buf_ptr;
  request_id       = user_data_ptr->data.simlock_lock.request_id;
  ck_present       = user_data_ptr->data.simlock_lock.ck_present;

  if((status == SIMLOCK_SUCCESS) &&
     (user_data_ptr->data.simlock_lock.next_list_to_lock <
               user_data_ptr->data.simlock_lock.total_list_cnt) &&
     (user_data_ptr->data.simlock_lock.code_ptr != NULL))
  {
    simlock_result_enum_type                 simlock_status = SIMLOCK_SUCCESS;
    uint8                                    list_to_lock   = 0;
    simlock_add_lock_codes_ck_msg_req_type   add_lock_codes;

    memset(&add_lock_codes, 0x00, sizeof(simlock_add_lock_codes_ck_msg_req_type));

    UIM_MSG_HIGH_0("Processing additional lock codes");

    list_to_lock = user_data_ptr->data.simlock_lock.next_list_to_lock;

    add_lock_codes.slot      = user_data_ptr->data.simlock_lock.slot;
    add_lock_codes.ck        = user_data_ptr->data.simlock_lock.ck;
    add_lock_codes.blacklist = FALSE;
    add_lock_codes.category  = user_data_ptr->data.simlock_lock.code_ptr[list_to_lock];

    user_data_ptr->data.simlock_lock.next_list_to_lock++;

    simlock_status = simlock_add_lock_codes_ck(add_lock_codes,
                                               qmi_uimi_simlock_callback,
                                               user_data_ptr);
    if(simlock_status == SIMLOCK_SUCCESS)
    {
      return;
    }
  }

  if(user_data_ptr->data.simlock_lock.next_list_to_lock == 1)
  {
    /* Indicates there was only one list to lock */
    errval = qmi_uim_convert_simlock_status_to_errval(status);
  }
  else if((user_data_ptr->data.simlock_lock.next_list_to_lock ==
             user_data_ptr->data.simlock_lock.total_list_cnt)  &&
          (status == SIMLOCK_SUCCESS))
  {
    /* Indicates all the lists were successfully locked */
    errval = QMI_ERR_NONE;
  }
  else
  {
    /* Indicates some lists were added successfully,
       but then an error occurred */
    errval = QMI_ERR_OP_PARTIAL_FAILURE;
  }

  /* Free userdata */
  qmi_uim_free_cb_userdata(user_data_ptr);
  user_data_ptr = NULL;

  /* First check if the requested client is still valid */
  if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
  {
    UIM_MSG_HIGH_0("Invalid Client, not sending response");
    return;
  }

  if (cmd_buf_p == NULL)
  {
    UIM_MSG_HIGH_0("Null cmd_buf ptr in response");
    return;
  }

  QMI_UIM_VALIDATE_SP_IN_CMD_BUF(cmd_buf_p);

  if(cmd_id == UIMI_CMD_VAL_PERSONALIZATION_SECURE)
  {
    /* build the result and encrypt the data */
    errval = qmi_uim_response_encrypted_status(UIMI_TLV_RESP_TAG_OPTIONAL_1,
                                               UIMI_CMD_VAL_PERSONALIZATION_SECURE,
                                               request_id,
                                               errval,
                                               &response);
  }

  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    ds_qmi_fw_free_cmd_buf(&cmd_buf_p);
    return;
  }

  /* Send response */
  if (FALSE == qmi_uimi_send_response(cmd_buf_p,
                                      response))
  {
    UIM_MSG_HIGH_0("Unable to send response for SIM Lock lock operation");
    dsm_free_packet(&response);
  }
} /* qmi_uim_process_lock_resp */


/*===========================================================================
  FUNCTION  QMI_UIM_PROCESS_RELOCK_RESP

  DESCRIPTION
    Processes the response of the relock personalization command

  PARAMETERS
    status          : Status of the relock request
    user_data_ptr   : Pointer to the user data

  RETURN VALUE
    None

  DEPENDENCIES
    QMI UIM must already have been initialized and registered with Framework

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_process_relock_resp
(
  simlock_result_enum_type                      status,
  const simlock_relock_device_msg_resp_type   * relock_rsp_ptr,
  qmi_uimi_userdata_type                      * user_data_ptr
)
{
  qmi_cmd_buf_type          * cmd_buf_p           = NULL;
  dsm_item_type             * response            = NULL;
  qmi_error_e_type            errval              = QMI_ERR_NONE;
  qmi_result_e_type           result              = QMI_RESULT_SUCCESS;
  boolean                     retval              = TRUE;
  uint8                       clid                = QMI_SVC_CLID_UNUSED;
  uint32                      client_reg_count    = 0;
  qmi_uimi_cmd_val_e_type     cmd_id              = UIMI_CMD_VAL_WIDTH;

  UIM_MSG_HIGH_0("qmi_uim_process_relock_resp");

  ASSERT( relock_rsp_ptr );
  ASSERT( user_data_ptr );

  /* Retrieve parameters */
  clid             = user_data_ptr->clid;
  cmd_id           = user_data_ptr->request_id;
  client_reg_count = user_data_ptr->client_reg_count;
  cmd_buf_p        = (qmi_cmd_buf_type*)user_data_ptr->cmd_buf_ptr;

  /* Free userdata */
  qmi_uim_free_cb_userdata(user_data_ptr);
  user_data_ptr = NULL;

  /* First check if the requested client is still valid */
  if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
  {
    UIM_MSG_HIGH_0("Invalid Client, not sending response");
    return;
  }

  if (cmd_buf_p == NULL)
  {
    UIM_MSG_HIGH_0("Null cmd_buf ptr in response");
    return;
  }

  QMI_UIM_VALIDATE_SP_IN_CMD_BUF(cmd_buf_p);

  /* For relock, retries are sent in these cases */
  if ((status == SIMLOCK_SUCCESS)       ||
      (status == SIMLOCK_INCORRECT_KEY) ||
      (status == SIMLOCK_MAX_RETRIES_REACHED))
  {
    uint32   num_retries = 0;

    if (relock_rsp_ptr->num_retries_max == 0)
    {
      num_retries = QMI_UIM_SIMLOCK_MAX_RETRIES;
    }
    else if (relock_rsp_ptr->curr_retries >= relock_rsp_ptr->num_retries_max)
    {
      num_retries = 0;
    }
    else
    {
      num_retries = relock_rsp_ptr->num_retries_max - relock_rsp_ptr->curr_retries;
    }

    /* Send the num_retries in the response */
    if (FALSE == qmi_uim_response_retries_left(
                  UIMI_TLV_RESP_TAG_OPTIONAL_1,
                  &response,
                  num_retries,
                  0))
    {
      dsm_free_packet(&response);
    }
  }

  errval = qmi_uim_convert_simlock_status_to_errval(status);

  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    ds_qmi_fw_free_cmd_buf(&cmd_buf_p);
    return;
  }

  /* Send response */
  if (FALSE == qmi_uimi_send_response(cmd_buf_p,
                                      response))
  {
    UIM_MSG_HIGH_0("Unable to send response for SIM Lock relock operation");
    dsm_free_packet(&response);
  }
} /* qmi_uim_process_relock_resp */


/*===========================================================================
  FUNCTION  QMI_UIM_PROCESS_SET_DEVICE_MODE_RESP

  DESCRIPTION
    Processes the response of the set device mode command

  PARAMETERS
    status          : Status of the set device mode request
    user_data_ptr   : Pointer to the user data

  RETURN VALUE
    None

  DEPENDENCIES
    QMI UIM must already have been initialized and registered with Framework

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_process_set_device_mode_resp
(
  simlock_result_enum_type       status,
  qmi_uimi_userdata_type       * user_data_ptr
)
{
  qmi_cmd_buf_type          * cmd_buf_p           = NULL;
  dsm_item_type             * response            = NULL;
  qmi_error_e_type            errval              = QMI_ERR_NONE;
  qmi_result_e_type           result              = QMI_RESULT_SUCCESS;
  boolean                     retval              = TRUE;
  uint8                       clid                = QMI_SVC_CLID_UNUSED;
  uint32                      client_reg_count    = 0;
  uint16                      request_id          = 0;
  qmi_uimi_cmd_val_e_type     cmd_id              = UIMI_CMD_VAL_WIDTH;

  ASSERT( user_data_ptr );

  /* Retrieve parameters */
  clid             = user_data_ptr->clid;
  cmd_id           = user_data_ptr->request_id;
  client_reg_count = user_data_ptr->client_reg_count;
  cmd_buf_p        = (qmi_cmd_buf_type*)user_data_ptr->cmd_buf_ptr;
  request_id       = user_data_ptr->data.simlock_set_device_mode.request_id;

  /* Free userdata */
  qmi_uim_free_cb_userdata(user_data_ptr);
  user_data_ptr = NULL;

  UIM_MSG_HIGH_0("qmi_uim_process_set_device_mode_resp");

  /* First check if the requested client is still valid */
  if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
  {
    UIM_MSG_HIGH_0("Invalid Client, not sending response");
    return;
  }

  if (cmd_buf_p == NULL)
  {
    UIM_MSG_HIGH_0("Null cmd_buf ptr in response");
    return;
  }

  QMI_UIM_VALIDATE_SP_IN_CMD_BUF(cmd_buf_p);

  errval = qmi_uim_convert_simlock_status_to_errval(status);

  /* build the result and encrypt the data */
  errval = qmi_uim_response_encrypted_status(UIMI_TLV_RESP_TAG_OPTIONAL_1,
                                             UIMI_CMD_VAL_EMERGENCY_ONLY,
                                             request_id,
                                             errval,
                                             &response);

  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    ds_qmi_fw_free_cmd_buf(&cmd_buf_p);
    return;
  }

  /* Send response */
  if (FALSE == qmi_uimi_send_response(cmd_buf_p,
                                      response))
  {
    UIM_MSG_HIGH_0("Unable to send response for SIM Lock lock operation");
    dsm_free_packet(&response);
  }
} /* qmi_uim_process_set_device_mode_resp */


/*===========================================================================
  FUNCTION  QMI_UIM_PROCESS_SET_REMOTE_SFS_RESP

  DESCRIPTION
    Processes the response of the set remote SFS command

  PARAMETERS
    status          : Status of the set remote SFS request
    user_data_ptr   : Pointer to the user data

  RETURN VALUE
    None

  DEPENDENCIES
    QMI UIM must already have been initialized and registered with Framework

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_process_set_remote_sfs_resp
(
  simlock_result_enum_type       status,
  qmi_uimi_userdata_type       * user_data_ptr
)
{
  qmi_cmd_buf_type          * cmd_buf_p           = NULL;
  dsm_item_type             * response            = NULL;
  qmi_error_e_type            errval              = QMI_ERR_NONE;
  qmi_result_e_type           result              = QMI_RESULT_SUCCESS;
  boolean                     retval              = TRUE;
  uint8                       clid                = QMI_SVC_CLID_UNUSED;
  uint32                      client_reg_count    = 0;
  uint16                      request_id          = 0;
  qmi_uimi_cmd_val_e_type     cmd_id              = UIMI_CMD_VAL_WIDTH;

  ASSERT( user_data_ptr );

  /* Retrieve parameters */
  clid             = user_data_ptr->clid;
  cmd_id           = user_data_ptr->request_id;
  client_reg_count = user_data_ptr->client_reg_count;
  cmd_buf_p        = (qmi_cmd_buf_type*)user_data_ptr->cmd_buf_ptr;
  request_id       = user_data_ptr->data.simlock_set_remote_sfs.request_id;

  /* Free userdata */
  qmi_uim_free_cb_userdata(user_data_ptr);
  user_data_ptr = NULL;

  /* First check if the requested client is still valid */
  if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
  {
    UIM_MSG_HIGH_0("Invalid Client, not sending response");
    return;
  }

  if (cmd_buf_p == NULL)
  {
    UIM_MSG_HIGH_0("Null cmd_buf ptr in response");
    return;
  }

  QMI_UIM_VALIDATE_SP_IN_CMD_BUF(cmd_buf_p);

  errval = qmi_uim_convert_simlock_status_to_errval(status);

  /* build the result and encrypt the data */
  errval = qmi_uim_response_encrypted_status(UIMI_TLV_RESP_TAG_OPTIONAL_1,
                                             UIMI_CMD_VAL_SIMLOCK_CONFIGURATION,
                                             request_id,
                                             errval,
                                             &response);

  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    ds_qmi_fw_free_cmd_buf(&cmd_buf_p);
    return;
  }

  /* Send response */
  if (FALSE == qmi_uimi_send_response(cmd_buf_p,
                                      response))
  {
    UIM_MSG_HIGH_0("Unable to send response for SIM Lock lock operation");
    dsm_free_packet(&response);
  }
} /* qmi_uim_process_set_remote_sfs_resp */


/*===========================================================================
  FUNCTION  QMI_UIM_PROCESS_REMOTE_UNLOCK_RESP

  DESCRIPTION
    Processes the response of the remote unlock command

  PARAMETERS
    status             : Status of the remote unlock request
    encrypted_key_ptr  : Pointer to encrypted key data
    user_data_ptr      : Pointer to the user data

  RETURN VALUE
    None

  DEPENDENCIES
    QMI UIM must already have been initialized and registered with Framework

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_process_remote_unlock_resp
(
  simlock_result_enum_type         status,
  simlock_data_type             *  encrypted_key_ptr,
  qmi_uimi_userdata_type        *  user_data_ptr
)
{
  qmi_cmd_buf_type          * cmd_buf_p           = NULL;
  dsm_item_type             * response            = NULL;
  qmi_error_e_type            errval              = QMI_ERR_NONE;
  qmi_result_e_type           result              = QMI_RESULT_SUCCESS;
  boolean                     retval              = TRUE;
  uint8                       clid                = QMI_SVC_CLID_UNUSED;
  uint32                      client_reg_count    = 0;
  qmi_uimi_cmd_val_e_type     cmd_id              = UIMI_CMD_VAL_WIDTH;

  ASSERT(user_data_ptr);
  ASSERT(encrypted_key_ptr);

  /* Retrieve parameters */
  clid             = user_data_ptr->clid;
  cmd_id           = user_data_ptr->request_id;
  client_reg_count = user_data_ptr->client_reg_count;
  cmd_buf_p        = (qmi_cmd_buf_type*)user_data_ptr->cmd_buf_ptr;

  /* Free userdata */
  qmi_uim_free_cb_userdata(user_data_ptr);
  user_data_ptr = NULL;

  /* First check if the requested client is still valid */
  if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
  {
    UIM_MSG_HIGH_0("Invalid Client, not sending response");
    return;
  }

  if (cmd_buf_p == NULL)
  {
    UIM_MSG_HIGH_0("Null cmd_buf ptr in response");
    return;
  }

  QMI_UIM_VALIDATE_SP_IN_CMD_BUF(cmd_buf_p);

  errval = qmi_uim_convert_simlock_status_to_errval(status);

  if((status == SIMLOCK_SUCCESS) &&
     (encrypted_key_ptr->data_len > 0) &&
     (encrypted_key_ptr->data_ptr != NULL))
  {
    mmgsdi_data_type    key_data = { 0, NULL };

    key_data.data_ptr = encrypted_key_ptr->data_ptr;
    key_data.data_len = (int32)encrypted_key_ptr->data_len;

    if (FALSE == qmi_uim_response_generic_payload_16bit(UIMI_TLV_RESP_TAG_OPTIONAL_1,
                                                        &response,
                                                        key_data,
                                                        FALSE))
    {
      errval = QMI_ERR_NO_MEMORY;
      dsm_free_packet(&response);
    }
  }

  if (encrypted_key_ptr->data_ptr != NULL)
  {
    uimqmi_free(encrypted_key_ptr->data_ptr);
    encrypted_key_ptr->data_ptr = NULL;
  }

  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    ds_qmi_fw_free_cmd_buf(&cmd_buf_p);
    return;
  }

  /* Send response */
  if (FALSE == qmi_uimi_send_response(cmd_buf_p,
                                      response))
  {
    UIM_MSG_HIGH_0("Unable to send response for remote unlock request");
    dsm_free_packet(&response);
  }
} /* qmi_uim_process_remote_unlock_resp */


/*===========================================================================
  FUNCTION  QMI_UIM_PROCESS_SIMLOCK_CB

  DESCRIPTION
    Generic QMI processing for external commands

  PARAMETERS
    uim_message_ptr : message to the internal qmi_uim_message
                      containing an external command

  RETURN VALUE
    None

  DEPENDENCIES
    QMI UIM must already have been initialized and registered with Framework

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_process_simlock_cb
(
  qmi_uim_message_type * uim_message_ptr
)
{
  qmi_uimi_userdata_type * cb_userdata_ptr = NULL;

  UIM_MSG_HIGH_0("qmi_uim_process_simlock_cb");

  ASSERT(uim_message_ptr);

  switch (uim_message_ptr->data.simlock.data.msg_type)
  {
    case SIMLOCK_UNLOCK_DEVICE_MSG:
    case SIMLOCK_TEMPORARY_UNLOCK_MSG:
      qmi_uim_process_unlock_resp(uim_message_ptr->data.simlock.status,
                                  &uim_message_ptr->data.simlock.data.message.unlock_resp,
                                  (qmi_uimi_userdata_type*)uim_message_ptr->data.simlock.user_data_ptr);
      break;

    case SIMLOCK_GET_STATUS_MSG:
      cb_userdata_ptr = (qmi_uimi_userdata_type*)uim_message_ptr->data.simlock.user_data_ptr;
      if (cb_userdata_ptr == NULL)
      {
        return;
      }
      if(cb_userdata_ptr->request_id == UIMI_CMD_VAL_GET_CONFIGURATION)
      {
        qmi_uim_process_simlock_get_status_resp(uim_message_ptr->data.simlock.status,
                                                &uim_message_ptr->data.simlock.data.message.get_status_resp,
                                                (qmi_uimi_userdata_type*)uim_message_ptr->data.simlock.user_data_ptr);
      }
      else if (cb_userdata_ptr->request_id == UIMI_CMD_VAL_DEPERSONALIZATION)
      {
        qmi_uim_process_simlock_get_status_resp_after_unlock(uim_message_ptr->data.simlock.status,
                                                             &uim_message_ptr->data.simlock.data.message.get_status_resp,
                                                             (qmi_uimi_userdata_type*)uim_message_ptr->data.simlock.user_data_ptr);
      }
      break;

    case SIMLOCK_SET_LOCK_CK_MSG:
    case SIMLOCK_ADD_LOCK_CODES_CK_MSG:
      qmi_uim_process_lock_resp(uim_message_ptr->data.simlock.status,
                                (qmi_uimi_userdata_type*)uim_message_ptr->data.simlock.user_data_ptr);
      break;

    case SIMLOCK_SET_DEVICE_MODE_MSG:
      qmi_uim_process_set_device_mode_resp(uim_message_ptr->data.simlock.status,
                                           (qmi_uimi_userdata_type*)uim_message_ptr->data.simlock.user_data_ptr);
      break;

    case SIMLOCK_RELOCK_DEVICE_MSG:
      qmi_uim_process_relock_resp(uim_message_ptr->data.simlock.status,
                                  &uim_message_ptr->data.simlock.data.message.relock_resp,
                                 (qmi_uimi_userdata_type*)uim_message_ptr->data.simlock.user_data_ptr);
      break;

    default:
      UIM_MSG_ERR_1("Unsupported SIMLOCK command: 0x%x",
                    uim_message_ptr->data.simlock.data.msg_type);
      break;
  }
} /* qmi_uim_process_simlock_cb */


/*===========================================================================
  FUNCTION QMI_UIM_PROCESS_SIMLOCK_REMOTE_SFS_CB()

  DESCRIPTION
    This function processes the callback from simlock task. It indicates
    either the simlock data needs to be read from or write to a remote
    storage location to all registered QMI clients.

  PARAMETERS
    uim_message_ptr: QMI UIM message

  RETURN VALUE
    None

  DEPENDENCIES
    QMI UIM must already have been initialized and registered with Framework

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_process_simlock_remote_sfs_cb
(
  const qmi_uim_message_type * uim_message_ptr
)
{
  boolean is_indication_sent = FALSE;

  ASSERT(uim_message_ptr != NULL);
  ASSERT(qmi_uim_global_ptr);

  is_indication_sent = qmi_uim_simlock_send_remote_sfs_operation_indication_to_all(uim_message_ptr);

  if (is_indication_sent)
  {
    /* Save the simlock cb. In case the simlock cb is not NULL,
       indicating a response from TZ is pending, we ignore and
       overwrite it. The expectation is the TZ should respond
       to each operation request in requested order.*/
    qmi_uim_global_ptr->simlock_remote_sfs_operation_resp_cb =
      uim_message_ptr->data.simlock_remote_sfs_req.simlock_resp_cb;
  }
  else
  {
    UIM_MSG_ERR_0("simlock_remote_sfs indication was not sent");

    /* No indication was sent, invoke the callback with error status */
    if (uim_message_ptr->data.simlock_remote_sfs_req.simlock_resp_cb)
    {
      uim_message_ptr->data.simlock_remote_sfs_req.simlock_resp_cb(SIMLOCK_GENERIC_ERROR,
                                                                   uim_message_ptr->data.simlock_remote_sfs_req.request_token_id,
                                                                   NULL);
    }
  }

  if (uim_message_ptr->data.simlock_remote_sfs_req.simlock_data.data_ptr != NULL)
  {
    uimqmi_free(uim_message_ptr->data.simlock_remote_sfs_req.simlock_data.data_ptr);
  }
} /* qmi_uim_process_simlock_remote_sfs_cb */


/*===========================================================================
  FUNCTION QMI_UIM_PROCESS_MMGSDI_CALLBACK_MSG()

  DESCRIPTION
    This function is called as a result of a message posted to QMI UIM
    queue from a callback from MMGSDI.

  PARAMETERS
    uim_message_ptr: Pointer to message from QMI UIM message queue
  RETURN VALUE
    None.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_process_mmgsdi_callback_msg
(
  qmi_uim_message_type * uim_message_ptr
)
{
  mmgsdi_return_enum_type  status   = MMGSDI_ERROR;
  mmgsdi_cnf_type        * cnf_ptr  = NULL;
  mmgsdi_cnf_enum_type     cnf_type = MMGSDI_MAX_CNF_ENUM;

  qmi_uimi_userdata_type * cb_userdata_ptr = NULL;

  ASSERT(uim_message_ptr != NULL);

  status   = uim_message_ptr->data.cnf.status;
  cnf_ptr  = &uim_message_ptr->data.cnf.cnf_value;
  cnf_type = uim_message_ptr->data.cnf.cnf_type;

  switch(cnf_type)
  {
    case MMGSDI_CLIENT_ID_AND_EVT_REG_CNF:
      qmi_uim_client_id_evt_reg_conf(status, &cnf_ptr->client_id_and_evt_reg_cnf);
      break;

    case MMGSDI_SESSION_OPEN_EXT_CNF:
      qmi_uim_client_open_session_ext_conf(status, &cnf_ptr->session_open_ext_cnf);
      break;

    case MMGSDI_SESSION_OPEN_WITH_SELECT_RSP_CNF:
      qmi_uim_client_open_session_with_select_rsp_conf(
        status, &cnf_ptr->session_open_with_sel_rsp_cnf);
      break;

    case MMGSDI_SESSION_OPEN_WITH_MF_CNF:
      qmi_uim_client_open_session_with_mf_conf(status, &cnf_ptr->session_open_with_mf_cnf);
      break;

    case MMGSDI_SESSION_CLOSE_CNF:
      qmi_uim_client_close_session_resp(status, &cnf_ptr->session_close_cnf);
      break;

    case MMGSDI_READ_CNF:
      cb_userdata_ptr = (qmi_uimi_userdata_type*)cnf_ptr->response_header.client_data;
      if(cb_userdata_ptr == NULL)
      {
        return;
      }
      if(cb_userdata_ptr->request_id == UIMI_CMD_VAL_GET_GBA_IMPI)
      {
        qmi_uimi_read_impi_resp(status, &cnf_ptr->read_cnf);
      }
      else
      {
        qmi_uimi_read_resp(status, &cnf_ptr->read_cnf);
      }
      break;

    case MMGSDI_WRITE_CNF:
      qmi_uimi_write_resp(status, &cnf_ptr->write_cnf);
      break;

    case MMGSDI_GET_FILE_ATTR_CNF:
      cb_userdata_ptr = (qmi_uimi_userdata_type*)cnf_ptr->response_header.client_data;
      if (cb_userdata_ptr == NULL)
      {
        return;
      }
      if (cb_userdata_ptr->request_id == UIMI_CMD_VAL_WRITE_RECORD)
      {
        qmi_uimi_write_record_after_get_file_attributes(status, &cnf_ptr->get_file_attr_cnf);
      }
      else
      {
        qmi_uimi_get_file_attributes_resp(status, &cnf_ptr->get_file_attr_cnf);
      }
      break;

    case MMGSDI_CARD_PDOWN_CNF:
      qmi_uimi_power_down_resp(status, &cnf_ptr->card_pdown_cnf);
      break;

    case MMGSDI_CARD_PUP_CNF:
      qmi_uimi_power_up_resp(status, &cnf_ptr->card_pup_cnf);
      break;

    case MMGSDI_REFRESH_CNF:
      qmi_uimi_refresh_resp(status, &cnf_ptr->refresh_cnf);
      break;

    case MMGSDI_PIN_OPERATION_CNF:
      qmi_uimi_pin_operation_resp(status, &cnf_ptr->pin_operation_cnf);
      break;

    case MMGSDI_RUN_CAVE_CNF:
      qmi_uimi_run_cave_resp(status, &cnf_ptr->run_cave_cnf);
      break;

    case MMGSDI_SESSION_RUN_GSM_ALGO_CNF:
      qmi_uimi_run_gsm_algo_resp(status, &cnf_ptr->session_run_gsm_algo_cnf);
      break;

    case MMGSDI_ISIM_AUTH_CNF:
      qmi_uimi_isim_auth_resp(status, &cnf_ptr->isim_auth_cnf);
      break;

    case MMGSDI_USIM_AUTH_CNF:
      qmi_uimi_usim_auth_resp(status, &cnf_ptr->usim_auth_cnf);
      break;

    case MMGSDI_COMPUTE_IP_AUTH_CNF:
      qmi_uimi_compute_ip_auth_resp(status, &cnf_ptr->compute_ip_cnf);
      break;

    case MMGSDI_SESSION_ENABLE_SERVICE_CNF:
      qmi_uimi_set_service_resp(status, &cnf_ptr->session_enable_service_cnf.response_header);
      break;

    case MMGSDI_SESSION_DISABLE_SERVICE_CNF:
      qmi_uimi_set_service_resp(status, &cnf_ptr->session_disable_service_cnf.response_header);
      break;

    case MMGSDI_SRV_AVAILABLE_CNF:
      qmi_uimi_get_service_available_resp(status, &cnf_ptr->srv_available_cnf);
      break;

    case MMGSDI_SESSION_GET_APP_CAPABILITIES_CNF:
      qmi_uimi_get_service_enabled_resp(status, &cnf_ptr->session_app_capabilities_cnf);
      break;

    case MMGSDI_GET_ALL_PIN_STATUS_CNF:
      cb_userdata_ptr = (qmi_uimi_userdata_type*)cnf_ptr->response_header.client_data;
      if (cb_userdata_ptr == NULL)
      {
        qmi_uimi_nonprov_get_all_pin_status(status, &cnf_ptr->get_all_pin_status_cnf);
      }
      else
      {
        qmi_uimi_get_all_pin_status_resp(status, &cnf_ptr->get_all_pin_status_cnf);
      }
      break;

    case MMGSDI_SESSION_ACTIVATE_OR_SWITCH_PROVISIONING_CNF:
      qmi_uimi_change_provisioning_session_resp(status,
        &cnf_ptr->session_activate_or_switch_provisioning_cnf.response_header);
      break;

    case MMGSDI_SESSION_DEACTIVATE_CNF:
      qmi_uimi_change_provisioning_session_resp(status, &cnf_ptr->session_deactivate_cnf.response_header);
      break;

    case MMGSDI_SEND_APDU_EXT_CNF:
      qmi_uimi_send_apdu_resp(status, &cnf_ptr->send_apdu_ext_cnf);
      break;

    case MMGSDI_SAP_CONNECT_CNF:
      qmi_uimi_sap_connection_resp(status, &cnf_ptr->sap_connect_cnf.response_header);
      break;

    case MMGSDI_SAP_DISCONNECT_CNF:
      qmi_uimi_sap_connection_resp(status, &cnf_ptr->sap_disconnect_cnf.response_header);
      break;

    case MMGSDI_SAP_GET_ATR_CNF:
    case MMGSDI_SAP_SEND_APDU_CNF:
    case MMGSDI_SAP_CARD_READER_STATUS_CNF:
    case MMGSDI_SAP_POWER_ON_CNF:
    case MMGSDI_SAP_POWER_OFF_CNF:
    case MMGSDI_SAP_RESET_CNF:
      qmi_uimi_sap_request_resp(status, cnf_type, cnf_ptr);
      break;

    case MMGSDI_SESSION_SUBSCRIPTION_OK_CNF:
      qmi_uimi_subscription_ok_resp(status, &cnf_ptr->session_subscription_ok_cnf);
      break;

    case MMGSDI_GET_ATR_CNF:
      qmi_uimi_get_atr_resp(status, &cnf_ptr->get_atr_cnf);
      break;

    case MMGSDI_REHABILITATE_CNF:
      qmi_uimi_set_file_status_resp(status, &cnf_ptr->rehab_cnf.response_header);
      break;

    case MMGSDI_INVALIDATE_CNF:
       qmi_uimi_set_file_status_resp(status, &cnf_ptr->invalidate_cnf.response_header);
       break;

    case MMGSDI_INCREASE_CNF:
      qmi_uimi_increase_resp(status, &cnf_ptr->increase_cnf);
      break;

    case MMGSDI_SESSION_SELECT_AID_CNF:
      qmi_uimi_reselect_resp(status, &cnf_ptr->session_select_aid_cnf);
      break;

    case MMGSDI_CARD_STATUS_CNF:
      qmi_uimi_send_status_resp(status, &cnf_ptr->status_cnf);
      break;

    case MMGSDI_GET_SIM_PROFILE_CNF:
      qmi_uimi_get_sim_profile_resp(status, &cnf_ptr->get_sim_profile_cnf);
      break;

    case MMGSDI_SET_SIM_PROFILE_CNF:
      cb_userdata_ptr = (qmi_uimi_userdata_type*)cnf_ptr->set_sim_profile_cnf.response_header.client_data;
      if (cb_userdata_ptr == NULL)
      {
        return;
      }
      qmi_uimi_generic_result_resp(qmi_uim_convert_mmgsdi_status_to_errval(status),
                                   cb_userdata_ptr);
      break;

    case MMGSDI_SEARCH_CNF:
      qmi_uimi_search_record_resp(status, &cnf_ptr->search_cnf);
      break;

    default:
      /* This case should not happen! */
      break;
  }

  /* Free memory allocated for deep copy */
  qmi_uim_cnf_free_copy(cnf_type, cnf_ptr);
} /* qmi_uim_process_mmgsdi_callback_msg */


/*===========================================================================
  FUNCTION QMI_UIM_MMGSDI_EVT_CBACK()

  DESCRIPTION
    This function is executed as callback from MMGSDI whenever there
    is an event. It is executed in the context of MMGSDI task and needs
    to make a deep copy of the event and post a command to the QMI task
    to be processed.

  PARAMETERS

  RETURN VALUE
    None.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_mmgsdi_evt_cback
(
  const mmgsdi_event_data_type * event
)
{
  qmi_uim_message_type * msg_ptr = NULL;

  ASSERT(event);

  UIM_MSG_HIGH_1("Received event_cback from MMGSDI for event 0x%x",
                 event->evt);

  switch(event->evt)
  {
    /* Post events to the QMI context. */
    case MMGSDI_CARD_INSERTED_EVT:
    case MMGSDI_CARD_ERROR_EVT:
    case MMGSDI_CARD_REMOVED_EVT:
    case MMGSDI_SIM_BUSY_EVT:
    case MMGSDI_PIN1_EVT:
    case MMGSDI_PIN2_EVT:
    case MMGSDI_UNIVERSAL_PIN_EVT:
    case MMGSDI_SESSION_CHANGED_EVT:
    case MMGSDI_SUBSCRIPTION_READY_EVT:
    case MMGSDI_SESSION_CLOSE_EVT:
    case MMGSDI_PERSO_EVT:
    case MMGSDI_SESSION_ILLEGAL_SUBSCRIPTION_EVT:
    case MMGSDI_SESSION_LEGAL_SUBSCRIPTION_EVT:
    case MMGSDI_REFRESH_EVT:
    case MMGSDI_SAP_CONNECT_EVT:
    case MMGSDI_SAP_DISCONNECT_EVT:
    case MMGSDI_PERSO_TEMPORARY_UNLOCK_EVT:
      msg_ptr = qmi_uim_create_message(QMI_UIM_MESSAGE_EVENT);
      if (msg_ptr == NULL)
      {
        return;
      }

      qmi_uim_event_deep_copy(&msg_ptr->data.event.evt, event);

      /* Send command */
      qmi_uim_post_message(msg_ptr);
      msg_ptr = NULL;
      break;

    /* All other cases are not handled, so it's useless to make a copy
       and post it to the QMI context. Simply drop unnecessary events */
    default:
      UIM_MSG_HIGH_1("Unhandled event: 0x%x", event->evt);
      break;
  }
} /* qmi_uim_mmgsdi_evt_cback */


#ifdef FEATURE_GSTK
/*===========================================================================
  FUNCTION QMI_UIMI_OTASP_REG_CALLBACK()

  DESCRIPTION
    This function is executed as callback from GSTK and it determines whether
    registration for OTASP status is success.

  PARAMETERS

  RETURN VALUE
    None.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_otasp_reg_callback
(
  gstk_status_enum_type     gstk_reg_status,
  gstk_client_ref_data_type user_data
)
{
  /* Ignore this callback as there is no action to be taken by QMI UIM */
  (void)gstk_reg_status;
  (void)user_data;
} /* qmi_uimi_otasp_reg_callback */


/*===========================================================================
  FUNCTION QMI_UIMI_OTASP_STATUS_CALLBACK()

  DESCRIPTION
    This function is executed as callback from GSTK and it provides OTASP
    status. It is executed in the context of GSTK task and needs to make
    a deep copy of the event and post a command to the QMI task to be processed.

  PARAMETERS

  RETURN VALUE
    None.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_otasp_status_callback
(
  gstk_slot_id_enum_type       slot,
  gstk_otasp_act_status_enum_type  status
)
{
  qmi_uim_message_type * msg_ptr = NULL;

  UIM_MSG_HIGH_2("Received qmi_uimi_otasp_status_callback from GSTK, slot: 0x%x, status: 0x%x",
                 slot, status);

  msg_ptr = qmi_uim_create_message(QMI_UIM_MESSAGE_OTASP_STATUS_IND);
  if (msg_ptr == NULL)
  {
    return;
  }

  msg_ptr->data.otasp_status_ind.slot = slot;
  msg_ptr->data.otasp_status_ind.status = status;

  /* Send command */
  qmi_uim_post_message(msg_ptr);
  msg_ptr = NULL;
} /* qmi_uimi_otasp_status_callback */
#endif /* FEATURE_GSTK */


/*===========================================================================
  FUNCTION QMI_UIM_PROCESS_MMGSDI_EVENT_MSG()

  DESCRIPTION
    This function handles messages from the
    QMI UIM queue for events from MMGSDI

  PARAMETERS
    uim_message_ptr: Pointer to QMI UIM message from message queue

  RETURN VALUE
    None.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_process_mmgsdi_event_msg
(
  qmi_uim_message_type * uim_message_ptr
)
{
  boolean                           sap_update_required  = FALSE;
  mmgsdi_event_data_type           *event_ptr            = NULL;
  mmgsdi_slot_id_enum_type          slot_id              = MMGSDI_MAX_SLOT_ID_ENUM;
  qmi_uim_card_update_required_type result               = {FALSE, FALSE};

  ASSERT(uim_message_ptr);

  event_ptr = &uim_message_ptr->data.event.evt;

  UIM_MSG_HIGH_1("Processing event_cback from MMGSDI for event 0x%x",
                 event_ptr->evt);

  /* Update the card status */
  switch(event_ptr->evt)
  {
    case MMGSDI_CARD_INSERTED_EVT:
      slot_id = event_ptr->data.card_inserted.slot;
      result =
        qmi_uim_process_card_inserted_evt(&event_ptr->data.card_inserted);
      break;

    case MMGSDI_SESSION_CHANGED_EVT:
      slot_id = event_ptr->data.session_changed.app_info.slot;
      result =
        qmi_uim_process_session_changed_evt(event_ptr->session_id,
                                            &event_ptr->data.session_changed);
      break;

    case MMGSDI_PIN1_EVT:
    case MMGSDI_PIN2_EVT:
    case MMGSDI_UNIVERSAL_PIN_EVT:
      result =
        qmi_uim_process_pin_evts(event_ptr->evt,
                                 &event_ptr->data.pin);
      break;

    case MMGSDI_SIM_BUSY_EVT:
      qmi_uim_process_sim_busy_evt(event_ptr->data.sim_busy.slot,
                                   event_ptr->data.sim_busy.sim_busy);
      break;

    case MMGSDI_CARD_ERROR_EVT:
      slot_id = event_ptr->data.card_error.slot;
      if(event_ptr->data.card_error.info == MMGSDI_CARD_ERR_CARD_REMOVED)
      {
        result.card_update_required =
          qmi_uim_process_card_removed_evt(event_ptr->data.card_removed.slot);
      }
      else
      {
        result.card_update_required =
          qmi_uim_process_card_error_evt(event_ptr->data.card_error.info,
                                         event_ptr->data.card_error.slot);
      }
      result.reduced_card_update_required = result.card_update_required;

      /* Check if SAP disconnect event needs to be sent */
      sap_update_required = qmi_uim_process_sap_evt(event_ptr);
      break;

    case MMGSDI_CARD_REMOVED_EVT:
      slot_id = event_ptr->data.card_removed.slot;
      result.card_update_required =
        qmi_uim_process_card_removed_evt(event_ptr->data.card_removed.slot);
      /* Check if SAP disconnect event needs to be sent */
      sap_update_required = qmi_uim_process_sap_evt(event_ptr);
      result.reduced_card_update_required = result.card_update_required;
      break;

    case MMGSDI_SESSION_ILLEGAL_SUBSCRIPTION_EVT:
      result.card_update_required =
        qmi_uim_process_manage_illegal_card_evt(event_ptr->session_id,
                                                MMGSDI_SESSION_APP_IS_ILLEGAL);
      result.reduced_card_update_required = result.card_update_required;
      break;

    case MMGSDI_SESSION_LEGAL_SUBSCRIPTION_EVT:
      result.card_update_required =
        qmi_uim_process_manage_illegal_card_evt(event_ptr->session_id,
                                                MMGSDI_SESSION_APP_IS_LEGAL);
      result.reduced_card_update_required = result.card_update_required;
      break;

    case MMGSDI_PERSO_EVT:
#ifndef FEATURE_SIMLOCK
      if (qmi_uim_get_halt_subscription_value())
#endif /* !FEATURE_SIMLOCK */
      {
        result =
          qmi_uim_process_perso_evt(event_ptr->session_id,
                                    &event_ptr->data.perso);
      }
      break;

    case MMGSDI_SUBSCRIPTION_READY_EVT:
      result.card_update_required =
        qmi_uim_process_subscription_ready_evt(event_ptr->session_id,
                                               &event_ptr->data.subscription_ready);
      result.reduced_card_update_required = result.card_update_required;
      break;

    case MMGSDI_SESSION_CLOSE_EVT:
      qmi_uim_process_session_closed_evt(event_ptr->session_id,
                                         &event_ptr->data.session_close);
      break;

    case MMGSDI_REFRESH_EVT:
      qmi_uim_process_refresh_evt(event_ptr->session_id,
                                  &event_ptr->data.refresh);
      break;

    case MMGSDI_SAP_CONNECT_EVT:
      slot_id = event_ptr->data.sap_connect.slot;
      sap_update_required = qmi_uim_process_sap_evt(event_ptr);
      break;

    case MMGSDI_SAP_DISCONNECT_EVT:
      slot_id = event_ptr->data.sap_disconnect.slot;
      sap_update_required = qmi_uim_process_sap_evt(event_ptr);
      break;

    case MMGSDI_PERSO_TEMPORARY_UNLOCK_EVT:
      qmi_uim_process_temporary_unlock_event(event_ptr);
      break;

    default:
      /* This should never happen: unhandled events are not sent
         to the QMI content! */
      UIM_MSG_ERR_1( "Unhandled Event 0x%x\n", event_ptr->evt);
      return;
  }

  /* If card status of respective slot is valid then we only set card update required.
     We intentionally dont set reduced card update required as this change is of no intrest */
  if (qmi_uim_update_card_status_validity(event_ptr))
  {
    result.card_update_required = TRUE;
  }

  /* Free the copy of the event (if deep copy was needed) */
  qmi_uim_event_free_copy(event_ptr);

  /* Send update to clients */
  if (result.card_update_required)
  {
    if (event_ptr->session_id != 0)
    {
      if (qmi_uim_session_id_to_slot(&slot_id,
                                     event_ptr->session_id) != QMI_ERR_NONE)
      {
        UIM_MSG_ERR_1("Unable to determine slot for MMGSDI event 0x%x",
                      event_ptr->evt);
      }
    }
    /* Legacy card status indication is sent to clients who only register
       for legacy card status if the update is only to the legacy (first two)
       slots. Extended indication is sent to clients who register for it. */
    if (slot_id <= MMGSDI_SLOT_2)
    {
      qmi_uim_send_card_status_indication_to_all(TRUE,
                                                 FALSE,
                                                 result.reduced_card_update_required);
    }
    else
    {
      qmi_uim_send_card_status_indication_to_all(FALSE,
                                                 FALSE,
                                                 result.reduced_card_update_required);
    }
  }
  if (sap_update_required)
  {
    qmi_uim_send_sap_status_indication_to_all(slot_id);
  }
} /* qmi_uim_process_mmgsdi_event_msg */


/*===========================================================================
  FUNCTION QMI_UIM_PROCESS_PHYSICAL_SLOTS_STATUS_MSG()

  DESCRIPTION
    This function handles message from the QMI UIM queue for physical slots
    status from drivers

  PARAMETERS
    uim_message_ptr: Pointer to QMI UIM message from message queue

  RETURN VALUE
    None.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_process_physical_slots_status_msg
(
  qmi_uim_message_type * uim_message_ptr
)
{
  boolean is_info_updated = FALSE;

  ASSERT(uim_message_ptr);

  UIM_MSG_HIGH_1("Processing physical slots status CB from drivers; num physical slots: 0x%x",
                 uim_message_ptr->data.physical_slots_info.num_slots);

  is_info_updated = qmi_uim_store_physical_slots_status(
                        uim_message_ptr->data.physical_slots_info.num_slots,
                        uim_message_ptr->data.physical_slots_info.slot_status_ptr);

  /* Free the physical slots info in the message */
  if(uim_message_ptr->data.physical_slots_info.slot_status_ptr != NULL)
  {
    modem_mem_free(uim_message_ptr->data.physical_slots_info.slot_status_ptr,
                   MODEM_MEM_CLIENT_UIM);
    uim_message_ptr->data.physical_slots_info.slot_status_ptr = NULL;
  }

  if(is_info_updated != FALSE)
  {
    /* Send slots status indication */
    qmi_uim_send_slots_status_indication_to_all();
  }
} /* qmi_uim_process_physical_slots_status_msg */


#ifdef FEATURE_UIM_DS_SUBSCRIPTION_MANAGER
/*===========================================================================
FUNCTION QMI_UIM_NOTIFY_SLOTS_STATUS_CB()

DESCRIPTION
  A callback called by uimdrv when an association of a logical slot to
  a physical slot changes or whenever there is a change to the card state
  in any physical slot.

PARAMETERS
  uint8                   : number of physical slots
  uim_phy_slot_status_type: status of the physical slots

RETURN VALUE
  None

DEPENDENCIES
  QMI UIM service must be initialized and registered with Framework

SIDE EFFECTS
  None

===========================================================================*/
static void qmi_uim_notify_slots_status_cb
(
  uint8                           num_physical_slots,
  const uim_phy_slot_status_type *physical_slot_status_ptr
)
{
  qmi_uim_message_type * msg_ptr = NULL;

  if (num_physical_slots == 0 ||
      physical_slot_status_ptr == NULL)
  {
    UIM_MSG_ERR_0("Invalid physical slots info reported by drivers");
    return;
  }

  msg_ptr = qmi_uim_create_message(QMI_UIM_MESSAGE_PHYSICAL_SLOTS_STATUS);
  if (msg_ptr == NULL)
  {
    return;
  }

  /* Copy the physical slots info into the qmiuim message */
  msg_ptr->data.physical_slots_info.num_slots = num_physical_slots;
  qmi_uim_deep_copy(
       (void**)&msg_ptr->data.physical_slots_info.slot_status_ptr,
       (void*)physical_slot_status_ptr,
       sizeof(uim_phy_slot_status_type) * num_physical_slots);

  /* Send command */
  qmi_uim_post_message(msg_ptr);
  msg_ptr = NULL;
} /* qmi_uim_notify_slots_status_cb() */
#endif /* FEATURE_UIM_DS_SUBSCRIPTION_MANAGER */


/*===========================================================================
  FUNCTION QMI_UIMI_UIM_CALLBACK()

  DESCRIPTION
    This function is executed as callback of UIM Recovery API. This
    is executed in the context of UIM task and needs to make a deep
    copy of the results and post a command to the QMI task to be
    processed.

  PARAMETERS

  RETURN VALUE
    None.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uimi_recovery_callback
(
  uim_slot_type                     slot,
  const void                       *user_data,
  uimdrv_recovery_stage_enum_type   recovery_stage
)
{
  qmi_uim_message_type * msg_ptr = NULL;

  switch(recovery_stage)
  {
    case UIMDRV_RECOVERY_STAGE_START:
      UIM_MSG_MED_0("Recovery stage start response");
      /* Nothing to do */
      break;

    case UIMDRV_RECOVERY_STAGE_END:
      UIM_MSG_MED_0("Recovery stage end response");
      msg_ptr = qmi_uim_create_message(QMI_UIM_MESSAGE_RECOVERY_CB);
      if (msg_ptr != NULL)
      {
        msg_ptr->data.recovery_data.slot = slot;
        msg_ptr->data.recovery_data.user_data = user_data;

        /* Send command */
        qmi_uim_post_message(msg_ptr);
        msg_ptr = NULL;
      }
      break;

    default:
      UIM_MSG_ERR_0("Message recovery response not handled");
      break;
  }
} /* qmi_uimi_recovery_callback */


/*===========================================================================
  FUNCTION  QMI_UIM_PROCESS_RECOVERY_CB()

  DESCRIPTION
    Generic QMI processing for external commands

  PARAMETERS
    uim_message_ptr : message to the internal qmi_uim_message
                      containing an external command

  RETURN VALUE
    None

  DEPENDENCIES
    QMI UIM must already have been initialized and registered with Framework

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_process_recovery_cb
(
  qmi_uim_message_type * uim_message_ptr
)
{
  qmi_cmd_buf_type *       cmd_buf_p        = NULL;
  qmi_uimi_userdata_type * cb_userdata_ptr  = NULL;
  dsm_item_type *          response         = NULL;
  boolean                  retval           = TRUE;
  uint8                    clid             = QMI_SVC_CLID_UNUSED;
  uint32                   client_reg_count = 0;

  UIM_MSG_HIGH_0("Sending response for recovery");

  ASSERT( uim_message_ptr );

  /* Retrieve userdata */
  cb_userdata_ptr = (qmi_uimi_userdata_type*)uim_message_ptr->data.recovery_data.user_data;
  if (cb_userdata_ptr == NULL)
  {
    UIM_MSG_HIGH_0("Null userdata ptr in response");
    return;
  }

  /* Retrieve parameters */
  clid             = cb_userdata_ptr->clid;
  client_reg_count = cb_userdata_ptr->client_reg_count;
  cmd_buf_p        = (qmi_cmd_buf_type*)cb_userdata_ptr->cmd_buf_ptr;

  /* Free userdata */
  qmi_uim_free_cb_userdata(cb_userdata_ptr);
  cb_userdata_ptr = NULL;

  /* First check if the requested client is still valid */
  if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
  {
    UIM_MSG_HIGH_0("Invalid Client, not sending response");
    return;
  }

  if (cmd_buf_p == NULL)
  {
    UIM_MSG_HIGH_0("Null cmd_buf ptr in response");
    return;
  }

  QMI_UIM_VALIDATE_SP_IN_CMD_BUF(cmd_buf_p);

  retval = qmi_svc_put_result_tlv(&response, QMI_RESULT_SUCCESS, QMI_ERR_NONE);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    ds_qmi_fw_free_cmd_buf( &cmd_buf_p );
    return;
  }

  /* Send response */
  if (FALSE == qmi_uimi_send_response(cmd_buf_p,
                                      response))
  {
    UIM_MSG_HIGH_0("Unable to send response for UIM recovery operation");
    dsm_free_packet(&response);
  }
} /* qmi_uim_process_recovery_cb */


/*===========================================================================
  FUNCTION  QMI_UIM_PROCESS_GBA_CB()

  DESCRIPTION
    Generic QMI processing for external commands

  PARAMETERS
    uim_message_ptr : message to the internal qmi_uim_message
                      containing an external command

  RETURN VALUE
    None

  DEPENDENCIES
    QMI UIM must already have been initialized and registered with Framework

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_process_gba_cb
(
  qmi_uim_message_type * uim_message_ptr
)
{
  qmi_cmd_buf_type *       cmd_buf_p        = NULL;
  qmi_uimi_userdata_type * cb_userdata_ptr  = NULL;
  qmi_uimi_cmd_val_e_type  request_id       = UIMI_CMD_VAL_WIDTH;
  dsm_item_type *          response         = NULL;
  boolean                  retval           = TRUE;
  uint8                    clid             = QMI_SVC_CLID_UNUSED;
  uint32                   client_reg_count = 0;
  qmi_error_e_type         errval           = QMI_ERR_NONE;
  boolean                  ind_required     = FALSE;
  qmi_result_e_type        result           = QMI_RESULT_FAILURE;
  uint32                   token            = 0;
  gba_naf_fqdn_type        fqdn_data        = {0};

  UIM_MSG_HIGH_0("Sending response for GBA");

  ASSERT( uim_message_ptr );

  /* Retrieve userdata */
  cb_userdata_ptr = (qmi_uimi_userdata_type*)uim_message_ptr->data.gba_cnf.user_data_ptr;
  if (cb_userdata_ptr == NULL)
  {
    UIM_MSG_HIGH_0("Null userdata ptr in response");
    return;
  }

  /* Retrieve info */
  clid             = cb_userdata_ptr->clid;
  client_reg_count = cb_userdata_ptr->client_reg_count;
  request_id       = cb_userdata_ptr->request_id;
  ind_required     = cb_userdata_ptr->ind_token.is_valid;
  token            = cb_userdata_ptr->ind_token.token;
  fqdn_data        = cb_userdata_ptr->data.gba.fqdn_data;
  cmd_buf_p        = (qmi_cmd_buf_type*)cb_userdata_ptr->cmd_buf_ptr;

  QMI_UIM_VALIDATE_CMD_BUF_IN_USERDATA(cb_userdata_ptr);

  /* Free userdata */
  qmi_uim_free_cb_userdata(cb_userdata_ptr);
  cb_userdata_ptr = NULL;

  errval = qmi_uim_convert_gba_status_to_errval(uim_message_ptr->data.gba_cnf.status);

  /* First check if the requested client is still valid */
  if (FALSE == qmi_uim_check_clid(clid, client_reg_count))
  {
    UIM_MSG_HIGH_0("Invalid Client, not sending indication or response");
    return;
  }

  if (ind_required)
  {
    if (FALSE == qmi_uim_response_ind_token(UIMI_TLV_IND_TAG_MANDATORY_1,
                                            &response,
                                            token))
    {
      UIM_MSG_ERR_0("Could not insert ind_token TLV, not sending indication");
      dsm_free_packet(&response);
      return;
    }
  }

  if(uim_message_ptr->data.gba_cnf.status == GBA_SUCCESS)
  {
    mmgsdi_data_type   gba_resp_data = {0, NULL};

    /* If NAF id is empty then do not send Ks_NAF TLV in the response */
    if(fqdn_data.data_len > 0)
    {
      /* Check whether ks_naf should be encrypted */
      if(qmi_uim_encrypt_ks_naf_required(&fqdn_data))
      {
        mmgsdi_data_type     naf_enc_data        = {0, NULL};
        mmgsdi_data_type     ks_naf_data         = {0, NULL};

        ks_naf_data.data_ptr = uim_message_ptr->data.gba_cnf.cnf_value.resp_data.success.ks_naf;
        ks_naf_data.data_len = sizeof(uim_message_ptr->data.gba_cnf.cnf_value.resp_data.success.ks_naf);

        if(qmi_uim_encrypt_payload(ks_naf_data, &naf_enc_data))
        {
          if(FALSE == qmi_uim_response_generic_payload_16bit(
                       UIMI_TLV_RESP_TAG_OPTIONAL_2,
                       &response,
                       naf_enc_data,
                       TRUE))
          {
            dsm_free_packet(&response);
            errval = QMI_ERR_NO_MEMORY;
          }
        }
        else
        {
          errval = QMI_ERR_INTERNAL;
        }

        /* Free the naf encrypted data if it is allocated */
        if(naf_enc_data.data_ptr != NULL)
        {
          uimqmi_free(naf_enc_data.data_ptr);
          naf_enc_data.data_ptr = NULL;
        }
      }
      else
      {
        if(FALSE == qmi_svc_put_param_tlv(
                     &response,
                     UIMI_TLV_RESP_TAG_OPTIONAL_1,
                     sizeof(uim_message_ptr->data.gba_cnf.cnf_value.resp_data.success.ks_naf),
                     (void *)uim_message_ptr->data.gba_cnf.cnf_value.resp_data.success.ks_naf))
        {
          errval = QMI_ERR_NO_MEMORY;
          dsm_free_packet(&response);
        }
      }
    }

    if(errval == QMI_ERR_NONE)
    {
      gba_resp_data.data_len = uim_message_ptr->data.gba_cnf.cnf_value.resp_data.success.btid.data_len;
      gba_resp_data.data_ptr = (uint8 *)uim_message_ptr->data.gba_cnf.cnf_value.resp_data.success.btid.data;

      if (FALSE == qmi_uim_response_generic_payload_8bit(
                              UIMI_TLV_RESP_TAG_OPTIONAL_3,
                              &response,
                              gba_resp_data,
                              FALSE))
      {
        errval = QMI_ERR_NO_MEMORY;
        dsm_free_packet(&response);
      }
    }

    if(errval == QMI_ERR_NONE)
    {
      gba_resp_data.data_len =  uim_message_ptr->data.gba_cnf.cnf_value.resp_data.success.lifetime.data_len;
      gba_resp_data.data_ptr = (uint8 *)uim_message_ptr->data.gba_cnf.cnf_value.resp_data.success.lifetime.data;

      if(FALSE == qmi_uim_response_generic_payload_8bit(
                              UIMI_TLV_RESP_TAG_OPTIONAL_4,
                              &response,
                              gba_resp_data,
                              FALSE))
      {
        errval = QMI_ERR_NO_MEMORY;
        dsm_free_packet(&response);
      }
    }

    if(errval == QMI_ERR_NONE)
    {
      gba_resp_data.data_len = uim_message_ptr->data.gba_cnf.cnf_value.resp_data.success.impi.data_len;
      gba_resp_data.data_ptr = (uint8 *)uim_message_ptr->data.gba_cnf.cnf_value.resp_data.success.impi.data;

      if(FALSE == qmi_uim_response_generic_payload_8bit(
                               UIMI_TLV_RESP_TAG_OPTIONAL_5,
                               &response,
                               gba_resp_data,
                               FALSE))
      {
        errval = QMI_ERR_NO_MEMORY;
        dsm_free_packet(&response);
      }
    }
  }

  /* Insert result item in the TLV */
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    QMI_UIM_FREE_CMD_BUF(cmd_buf_p);
    return;
  }

  /* Send response or indication */
  if (ind_required)
  {
    retval = qmi_uimi_send_indication(clid,
                                     (uint16)request_id,
                                     response);
  }
  else
  {
    retval = qmi_uimi_send_response(cmd_buf_p,
                                    response);
  }
  if (FALSE == retval)
  {
    UIM_MSG_HIGH_0("Unable to send response for GBA callback");
    dsm_free_packet(&response);
    QMI_UIM_FREE_CMD_BUF(cmd_buf_p);
  }
} /* qmi_uim_process_gba_cb */


/*===========================================================================
    FUNCTION  QMI_UIM_PROCESS_LPA_PROFILE_INFO_CB()
  
    DESCRIPTION
      Processing of LPA response for internally triggered profile fetch
  
    PARAMETERS
      uim_message_ptr : message to the internal qmi_uim_message
                        containing an external command
  
    RETURN VALUE
      None
  
    DEPENDENCIES
      QMI UIM must already have been initialized and registered with Framework
  
    SIDE EFFECTS
      None
  ===========================================================================*/
  static void qmi_uim_process_lpa_profile_info_cb
  (
    qmi_uim_message_type * uim_message_ptr
  )
  {
    lpa_result_enum_type     status           = LPA_SUCCESS;
    lpa_response_data_type * cnf_ptr          = NULL;
    lpa_message_enum_type    msg_type;
    qmi_uimi_userdata_type * cb_userdata_ptr  = NULL;
  
    ASSERT(uim_message_ptr != NULL);
  
    status   = uim_message_ptr->data.lpa_cnf.status;
    cnf_ptr  = &uim_message_ptr->data.lpa_cnf.cnf_value;
    msg_type = uim_message_ptr->data.lpa_cnf.cnf_value.msg_type;
  
    /* Retrieve userdata */
    cb_userdata_ptr = (qmi_uimi_userdata_type*)uim_message_ptr->data.lpa_cnf.user_data_ptr;
    if (cb_userdata_ptr == NULL)
    {
      UIM_MSG_HIGH_0("Null userdata ptr in response");
      return;
    }
    if (status == LPA_SUCCESS && msg_type == LPA_GET_PROFILES_INFO_MSG)
    {
      qmi_uim_copy_euicc_profile_info(&cnf_ptr->message.get_profiles_info_resp,
                                      cb_userdata_ptr->data.lpa.slot);
    }
    /* Free callback user data */
    qmi_uim_free_cb_userdata(cb_userdata_ptr);
    cb_userdata_ptr = NULL;
  } /* qmi_uim_process_lpa_profile_info_cb */


/*===========================================================================
  FUNCTION  QMI_UIM_PROCESS_LPA_CB()

  DESCRIPTION
    Processing of LPA response

  PARAMETERS
    uim_message_ptr : message to the internal qmi_uim_message
                      containing an external command

  RETURN VALUE
    None

  DEPENDENCIES
    QMI UIM must already have been initialized and registered with Framework

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_process_lpa_cb
(
  qmi_uim_message_type * uim_message_ptr
)
{
  lpa_result_enum_type     status           = LPA_SUCCESS;
  lpa_response_data_type * cnf_ptr          = NULL;
  lpa_message_enum_type    msg_type;
  qmi_uimi_userdata_type * cb_userdata_ptr  = NULL;

  ASSERT(uim_message_ptr != NULL);

  status   = uim_message_ptr->data.lpa_cnf.status;
  cnf_ptr  = &uim_message_ptr->data.lpa_cnf.cnf_value;
  msg_type = uim_message_ptr->data.lpa_cnf.cnf_value.msg_type;

  /* Retrieve userdata */
  cb_userdata_ptr = (qmi_uimi_userdata_type*)uim_message_ptr->data.lpa_cnf.user_data_ptr;
  if (cb_userdata_ptr == NULL)
  {
    UIM_MSG_HIGH_0("Null userdata ptr in response");
    return;
  }

  switch (msg_type)
  {
    case LPA_GET_PROFILES_INFO_MSG:
      /* If request_id is not GET_SIM_PROFILE, it means this is response of
         internally queried profile info. So, copy the latest profile
         data and return */
      if (cb_userdata_ptr->request_id != UIMI_CMD_VAL_GET_SIM_PROFILE)
      {
        if (status == LPA_SUCCESS)
        {
          qmi_uim_copy_euicc_profile_info(&cnf_ptr->message.get_profiles_info_resp,
                                          cb_userdata_ptr->data.lpa.slot);

          /* Free callback user data */
          qmi_uim_free_cb_userdata(cb_userdata_ptr);
          cb_userdata_ptr = NULL;
        }
      }
      else
      {
        qmi_uimi_get_euicc_profile_resp(status, &cnf_ptr->message.get_profiles_info_resp, cb_userdata_ptr);
      }
      break;
    case LPA_ENABLE_PROFILE_MSG:
      qmi_uimi_generic_result_resp(qmi_uim_convert_lpa_status_to_errval(status),
                                   cb_userdata_ptr);
      break;
    case LPA_DISABLE_PROFILE_MSG:
      qmi_uimi_generic_result_resp(qmi_uim_convert_lpa_status_to_errval(status),
                                   cb_userdata_ptr);
      break;
    case LPA_DELETE_PROFILE_MSG:
      qmi_uimi_generic_result_resp(qmi_uim_convert_lpa_status_to_errval(status),
                                   cb_userdata_ptr);
      break;
    case LPA_CARD_MEMORY_RESET_MSG:
      qmi_uimi_generic_result_resp(qmi_uim_convert_lpa_status_to_errval(status),
                                   cb_userdata_ptr);
      break;
    case LPA_GET_EID_MSG:
      qmi_uimi_get_eid_resp(status, &cnf_ptr->message.get_eid_resp, cb_userdata_ptr);
      break;
    case LPA_ADD_PROFILE_MSG:
      qmi_uimi_generic_result_resp(qmi_uim_convert_lpa_status_to_errval(status),
                                   cb_userdata_ptr);
      break;
    case LPA_ADD_OR_UPDATE_PROFILE_NICKNAME_MSG:
      qmi_uimi_generic_result_resp(qmi_uim_convert_lpa_status_to_errval(status),
                                   cb_userdata_ptr);
      break;
    default:
      break;
  }
} /* qmi_uim_process_lpa_cb */


/*===========================================================================
  FUNCTION  QMI_UIM_SEND_ADD_PROFILE_IND()

  DESCRIPTION
    This function sends the Download Progress during add profile

  PARAMETERS
    clid                 : Clint ID to whom ind is send
    lpa_event_ptr        : The event data
    status               : LPA status

  RETURN VALUE
    None

  DEPENDENCIES
    QMI UIM must already have been initialized and registered with Framework

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_send_add_profile_ind
(
  uint8                       clid,
  const lpa_event_data_type * lpa_event_ptr,
  lpa_result_enum_type        status
)
{
  dsm_item_type                 * indication     = NULL;
  mmgsdi_slot_id_enum_type        mmgsdi_slot    = MMGSDI_MAX_SLOT_ID_ENUM;

  ASSERT(lpa_event_ptr);

  switch (lpa_event_ptr->evt_data.profile_download_progress.slot_id)
  {
    case LPA_SLOT_1:
      mmgsdi_slot = MMGSDI_SLOT_1;
      break;
    case LPA_SLOT_2:
      mmgsdi_slot = MMGSDI_SLOT_2;
      break;
    default:
      return;
  }

  if (FALSE == qmi_uim_response_slot(
                             UIMI_TLV_IND_TAG_MANDATORY_1,
                             &indication,
                             mmgsdi_slot))
  {
    dsm_free_packet(&indication);
    return;
  }

  if (FALSE == qmi_uim_response_euicc_download_status_data(
                   UIMI_TLV_IND_TAG_MANDATORY_2,
                   &indication,
                   lpa_event_ptr,
                   status))
  {
    dsm_free_packet(&indication);
    return;
  }

  if (status != LPA_SUCCESS)
  {
    if (FALSE == qmi_uim_response_download_error_cause(
                                      UIMI_TLV_IND_TAG_OPTIONAL_1,
                                      &indication,
                                      status))
    {
      UIM_MSG_LOW_0("Error in constructing download error cause tlv");
    }
  }

  if (lpa_event_ptr->evt_data.profile_download_progress.installation_complete == FALSE)
  {
    if (FALSE == qmi_uim_response_profile_percentage(
                     UIMI_TLV_IND_TAG_OPTIONAL_2,
                     &indication,
                     lpa_event_ptr->evt_data.profile_download_progress.percent_downloaded))
    {
      UIM_MSG_LOW_0("Error in constructing profile percentage tlv");
    }
  }

  (void)uimqmi_send_indication(clid,
                               UIMI_CMD_VAL_ADD_PROFILE_IND,
                               indication,
                               QMUX_SERVICE_UIM);
} /* qmi_uim_send_add_profile_ind */


/*===========================================================================
  FUNCTION  QMI_UIM_PROCESS_LPA_EVENT_CB()

  DESCRIPTION
    This function processes the LPA event

  PARAMETERS
    uim_message_ptr : message to the internal qmi_uim_message
                      containing an external command

  RETURN VALUE
    None

  DEPENDENCIES
    QMI UIM must already have been initialized and registered with Framework

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_process_lpa_event_cb
(
  qmi_uim_message_type * uim_message_ptr
)
{
  uint8                           client_index   = 0;
  qmi_uimi_client_state_type    * cl_sp          = NULL;
  lpa_event_data_type           * lpa_event_ptr  = NULL;
  lpa_result_enum_type            status         = LPA_SUCCESS;

  ASSERT( uim_message_ptr );

  lpa_event_ptr = &uim_message_ptr->data.lpa_evt.evt;
  status        = uim_message_ptr->data.lpa_evt.status;

  /* Send indication to only that client who initiated the add_profile req */
  for (client_index = 0; client_index < UIMQMI_SVC_MAX_CLIDS; client_index++)
  {
    cl_sp = (qmi_uimi_client_state_type*)qmi_uim_state_ptr->client[client_index];
    if(cl_sp == NULL)
    {
      continue;
    }
    if (cl_sp->uim_info.add_profile_requested &&
        cl_sp->common.clid != QMI_SVC_CLID_UNUSED)
    {
      qmi_uim_send_add_profile_ind(cl_sp->common.clid,
                                   lpa_event_ptr,
                                   status);

      /* If profile installation is complete or if there is an error while
         add_profile is in progress, reset the add_profile_requested flag
         so that no further indication will be sent to client. Also, query
         for the new profile information to cache in QMI UIM */
      if (status != LPA_SUCCESS ||
          (lpa_event_ptr->evt_data.profile_download_progress.installation_complete &&
           lpa_event_ptr->evt_data.profile_download_progress.percent_downloaded >= 100))
      {
        qmi_error_e_type         errval          = QMI_ERR_INTERNAL;
        qmi_uimi_userdata_type  *cb_userdata_ptr = NULL;
        mmgsdi_slot_id_enum_type mmgsdi_slot     = MMGSDI_MAX_SLOT_ID_ENUM;

        /* Reset the flag as it is error case or the profile
           installation is complete */
        cl_sp->uim_info.add_profile_requested = FALSE;

        switch (lpa_event_ptr->evt_data.profile_download_progress.slot_id)
        {
          case LPA_SLOT_1:
            mmgsdi_slot = MMGSDI_SLOT_1;
            break;
          case LPA_SLOT_2:
            mmgsdi_slot = MMGSDI_SLOT_2;
            break;
          default:
            return;
        }

        cb_userdata_ptr = uimqmi_malloc(sizeof(qmi_uimi_userdata_type));
        if (cb_userdata_ptr != NULL)
        {
          memset(cb_userdata_ptr, 0, sizeof(qmi_uimi_userdata_type));
          cb_userdata_ptr->data.lpa.slot             = mmgsdi_slot;
          cb_userdata_ptr->data.lpa.is_profile_query = TRUE;
        
          errval = qmi_uim_query_euicc_profile_info(cb_userdata_ptr);
          UIM_MSG_MED_2("Internally triggered get_profile_info result: 0x%x for slot: 0x%x",
                        errval, mmgsdi_slot);
        }
      }
      break;
    }
  }
} /* qmi_uim_process_lpa_event_cb */


/*===========================================================================
  FUNCTION QMI_UIM_PROCESS_SUPPLY_VOLTAGE_IND()

  DESCRIPTION
    This function processes the supply voltage indication from UIM drivers.
    It indicates either Vcc needs to be deactivated or that Vcc activation has
    occurred to all registered QMI clients.

  PARAMETERS
    uim_message_ptr: QMI UIM message

  RETURN VALUE
    None

  DEPENDENCIES
    QMI UIM must already have been initialized and registered with Framework

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_process_supply_voltage_ind
(
  const qmi_uim_message_type * uim_message_ptr
)
{
  uint8                     slot_idx     = 0;
  mmgsdi_slot_id_enum_type  mmgsdi_slot  = MMGSDI_MAX_SLOT_ID_ENUM;
  qmi_error_e_type          errval       = QMI_ERR_NONE;

  if(uim_message_ptr == NULL)
  {
    return;
  }

  errval = qmi_uim_uim_slot_id_to_mmgsdi_slot_id(uim_message_ptr->data.supply_voltage.slot,
                                                 &mmgsdi_slot);
  if (errval != QMI_ERR_NONE)
  {
    return;
  }

  if (qmi_uim_mmgsdi_slot_to_slot_index(mmgsdi_slot,
                                        &slot_idx) != QMI_ERR_NONE)
  {
    return;
  }

  qmi_uim_send_supply_voltage_indication_to_all(uim_message_ptr);

  (void)qmi_uim_all_reg_clients_ack_vcc_deactivation(mmgsdi_slot);
} /* qmi_uim_process_supply_voltage_ind */


/*===========================================================================
  FUNCTION  QMI_UIM_PROCESS_ALLOC_CLID()

  DESCRIPTION
    Process client allocation from QMI Framework

  PARAMETERS
    uim_message_ptr : message to the internal qmi_uim_message
                     containing alloc_clid data

  RETURN VALUE
    None

  DEPENDENCIES
    QMI UIM must already have been initialized and registered with Framework

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_process_alloc_clid
(
  qmi_uim_message_type * uim_message_ptr
)
{
  qmi_uimi_client_state_type * cl_sp     = NULL;
  qmi_result_e_type            result    = QMI_RESULT_FAILURE;
  uint8                        client_id = QMI_FRAMEWORK_SVC_MAX_CLIENTS;

  ASSERT(uim_message_ptr);
  ASSERT(qmi_uim_state_ptr);

  client_id = uim_message_ptr->data.clid_cb.cmd_hdr.client_id;

  UIM_MSG_HIGH_1( "Process clid allocation for clid:0x%x", client_id );

  if ((client_id == QMI_SVC_CLID_UNUSED ) ||
      (client_id > UIMI_MAX_CLIDS ))
  {
    qmi_framework_svc_send_alloc_clid_result_ex(result, &uim_message_ptr->data.clid_cb.cmd_hdr,
                                                QMI_ERR_INVALID_CLIENT_ID);
    return;
  }

  if (uim_message_ptr->data.clid_cb.cmd_hdr.service != QMUX_SERVICE_UIM)
  {
    qmi_framework_svc_send_alloc_clid_result_ex(result, &uim_message_ptr->data.clid_cb.cmd_hdr,
                                                QMI_ERR_INTERNAL);
    return;
  }

  cl_sp = uimqmi_malloc(sizeof(qmi_uimi_client_state_type));
  if (cl_sp == NULL)
  {
    qmi_framework_svc_send_alloc_clid_result_ex(result, &uim_message_ptr->data.clid_cb.cmd_hdr,
                                                QMI_ERR_NO_MEMORY);
    return;
  }
  memset(cl_sp, 0, sizeof(qmi_uimi_client_state_type));

  qmi_uim_state_ptr->client[client_id - 1] = cl_sp;
  ds_qmi_fw_common_cl_init(qmi_uim_state_ptr, (qmi_common_client_state_type *)cl_sp);
  cl_sp->common.clid = client_id;
  cl_sp->instance    = (uint16)uim_message_ptr->data.clid_cb.cmd_hdr.qmi_instance;
  cl_sp->service_id  = uim_message_ptr->data.clid_cb.cmd_hdr.service;

  UIM_MSG_HIGH_1("QMI UIM clid successful for clid:0x%x", cl_sp->common.clid );
  result = QMI_RESULT_SUCCESS;

  /* Notifying the clid allocation back to client via QMI Framework*/
  qmi_framework_svc_send_alloc_clid_result_ex(result, &uim_message_ptr->data.clid_cb.cmd_hdr,
                                              QMI_ERR_NONE);
} /* qmi_uim_process_alloc_clid */


/*===========================================================================
  FUNCTION  QMI_UIM_PROCESS_DEALLOC_CLID()

  DESCRIPTION
    Process client deallocation from QMI Framework

  PARAMETERS
    uim_message_ptr : message to the internal qmi_uim_message
                     containing dealloc_clid data

  RETURN VALUE
    None

  DEPENDENCIES
    QMI UIM must already have been initialized and registered with Framework

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_process_dealloc_clid
(
  qmi_uim_message_type * uim_message_ptr
)
{
  qmi_uimi_client_state_type * cl_sp     = NULL;
  qmi_result_e_type            result    = QMI_RESULT_FAILURE;
  uint16                       client_id = QMI_FRAMEWORK_SVC_MAX_CLIENTS;

  ASSERT(uim_message_ptr);
  ASSERT(qmi_uim_state_ptr);

  client_id = uim_message_ptr->data.clid_cb.cmd_hdr.client_id;

  UIM_MSG_HIGH_1("QMI_UIM process deallocation for Client_id: 0x%x",
                 client_id );

  if ((client_id == QMI_SVC_CLID_UNUSED ) ||
      (client_id > UIMI_MAX_CLIDS ))
  {
    UIM_MSG_ERR_1("Invalid client ID clid:0x%x", client_id );
    qmi_framework_svc_send_dealloc_clid_result_ex(result, &uim_message_ptr->data.clid_cb.cmd_hdr,
                                                  QMI_ERR_INVALID_CLIENT_ID);
    return;
  }

  cl_sp = (qmi_uimi_client_state_type *)
           qmi_uim_state_ptr->client[client_id  - 1];

  if (cl_sp != NULL && cl_sp->common.clid == client_id)
  {
    /* Increment Client reg. count when deactivation occurs. This ensures
       that when responses are recevied from MMGSDI for any pending command
       w.r.t. this client, no response is built */
    qmi_uim_state_ptr->client_reg_count[client_id - 1]++;
    qmi_uimi_reset_client(cl_sp);
    q_destroy( &cl_sp->common.x_free_q );
    q_destroy( &cl_sp->common.cmd_free_q );
    cl_sp->common.clid = QMI_SVC_CLID_UNUSED;
    cl_sp->instance    = UIMI_INVALID_INSTANCE;
    uimqmi_free(cl_sp);
    qmi_uim_state_ptr->client[client_id  - 1] = NULL;
    cl_sp = NULL;
    UIM_MSG_HIGH_1("QMI UIM clid deallocation successful for clid:0x%x",
                   client_id );
    result = QMI_RESULT_SUCCESS;
  }
  else
  {
    UIM_MSG_ERR_0("INVALID CLIENT ID" );
  }

  /* Notifying the clid deallocation back to client via QMI Framework*/
  qmi_framework_svc_send_dealloc_clid_result_ex(result, &uim_message_ptr->data.clid_cb.cmd_hdr,
                                                QMI_ERR_NONE);
} /* qmi_uim_process_dealloc_clid */


/*===========================================================================
  FUNCTION  QMI_UIM_IS_COMMAND_DISABLED()

  DESCRIPTION
    Utility function to determine if the command is disabled at compile
    time or not

  PARAMETERS
    cmd_type : QMI UIM command

  RETURN VALUE
    boolean

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_uim_is_command_disabled
(
  uint16 cmd_type
)
{
  boolean is_disabled = FALSE;

  if(!(cmd_type != UIMI_CMD_VAL_WIDTH
#ifdef REMOVE_QMI_UIM_RESET_V01
     && cmd_type != UIMI_CMD_VAL_RESET
#endif /* REMOVE_QMI_UIM_RESET_V01 */
#ifdef REMOVE_QMI_UIM_READ_TRANSPARENT_V01
      && cmd_type != UIMI_CMD_VAL_READ_TRANSPARENT
#endif /* REMOVE_QMI_UIM_READ_TRANSPARENT_V01 */
#ifdef REMOVE_QMI_UIM_READ_RECORD_V01
      && cmd_type != UIMI_CMD_VAL_READ_RECORD
#endif /* REMOVE_QMI_UIM_READ_RECORD_V01 */
#ifdef REMOVE_QMI_UIM_WRITE_TRANSPARENT_V01
      && cmd_type != UIMI_CMD_VAL_WRITE_TRANSPARENT
#endif /* REMOVE_QMI_UIM_WRITE_TRANSPARENT_V01 */
#ifdef REMOVE_QMI_UIM_WRITE_RECORD_V01
      && cmd_type != UIMI_CMD_VAL_WRITE_RECORD
#endif /* REMOVE_QMI_UIM_WRITE_RECORD_V01 */
#ifdef REMOVE_QMI_UIM_GET_FILE_ATTRIBUTES_V01
      && cmd_type != UIMI_CMD_VAL_GET_FILE_ATTRIBUTES
#endif /* REMOVE_QMI_UIM_GET_FILE_ATTRIBUTES_V01 */
#ifdef REMOVE_QMI_UIM_SET_PIN_PROTECTION_V01
      && cmd_type != UIMI_CMD_VAL_SET_PIN_PROTECTION
#endif /* REMOVE_QMI_UIM_SET_PIN_PROTECTION_V01 */
#ifdef REMOVE_QMI_UIM_VERIFY_PIN_V01
      && cmd_type != UIMI_CMD_VAL_VERIFY_PIN
#endif /* REMOVE_QMI_UIM_VERIFY_PIN_V01 */
#ifdef REMOVE_QMI_UIM_UNBLOCK_PIN_V01
      && cmd_type != UIMI_CMD_VAL_UNBLOCK_PIN
#endif /* REMOVE_QMI_UIM_UNBLOCK_PIN_V01 */
#ifdef REMOVE_QMI_UIM_CHANGE_PIN_V01
      && cmd_type != UIMI_CMD_VAL_CHANGE_PIN
#endif /* REMOVE_QMI_UIM_CHANGE_PIN_V01 */
#ifdef REMOVE_QMI_UIM_DEPERSONALIZATION_V01
      && cmd_type != UIMI_CMD_VAL_DEPERSONALIZATION
#endif /* REMOVE_QMI_UIM_DEPERSONALIZATION_V01 */
#ifdef REMOVE_QMI_UIM_REFRESH_REGISTER_V01
      && cmd_type != UIMI_CMD_VAL_REFRESH_REGISTER
#endif /* REMOVE_QMI_UIM_REFRESH_REGISTER_V01 */
#ifdef REMOVE_QMI_UIM_REFRESH_OK_V01
      && cmd_type != UIMI_CMD_VAL_REFRESH_OK
#endif /* REMOVE_QMI_UIM_REFRESH_OK_V01 */
#ifdef REMOVE_QMI_UIM_REFRESH_COMPLETE_V01
      && cmd_type != UIMI_CMD_VAL_REFRESH_COMPLETE
#endif /* REMOVE_QMI_UIM_REFRESH_COMPLETE_V01 */
#ifdef REMOVE_QMI_UIM_REFRESH_GET_LAST_EVENT_V01
      && cmd_type != UIMI_CMD_VAL_REFRESH_GET_LAST_EVENT
#endif /* REMOVE_QMI_UIM_REFRESH_GET_LAST_EVENT_V01 */
#ifdef REMOVE_QMI_UIM_EVENT_REG_V01
      && cmd_type != UIMI_CMD_VAL_EVENT_REG
#endif /* REMOVE_QMI_UIM_EVENT_REG_V01 */
#ifdef REMOVE_QMI_UIM_GET_CARD_STATUS_V01
      && cmd_type != UIMI_CMD_VAL_GET_CARD_STATUS
#endif /* REMOVE_QMI_UIM_GET_CARD_STATUS_V01 */
#ifdef REMOVE_QMI_UIM_POWER_DOWN_V01
      && cmd_type != UIMI_CMD_VAL_POWER_DOWN
#endif /* REMOVE_QMI_UIM_POWER_DOWN_V01 */
#ifdef REMOVE_QMI_UIM_POWER_UP_V01
      && cmd_type != UIMI_CMD_VAL_POWER_UP
#endif /* REMOVE_QMI_UIM_POWER_UP_V01 */
#ifdef REMOVE_QMI_UIM_AUTHENTICATE_V01
      && cmd_type != UIMI_CMD_VAL_AUTHENTICATE
#endif /* REMOVE_QMI_UIM_AUTHENTICATE_V01 */
#ifdef REMOVE_QMI_UIM_CLOSE_SESSION_V01
      && cmd_type != UIMI_CMD_VAL_CLOSE_SESSION
#endif /* REMOVE_QMI_UIM_CLOSE_SESSION_V01 */
#ifdef REMOVE_QMI_UIM_GET_SERVICE_STATUS_V01
      && cmd_type != UIMI_CMD_VAL_GET_SERVICE_STATUS
#endif /* REMOVE_QMI_UIM_GET_SERVICE_STATUS_V01 */
#ifdef REMOVE_QMI_UIM_SET_SERVICE_STATUS_V01
      && cmd_type != UIMI_CMD_VAL_SET_SERVICE_STATUS
#endif /* REMOVE_QMI_UIM_SET_SERVICE_STATUS_V01 */
#ifdef REMOVE_QMI_UIM_CHANGE_PROVISIONING_SESSION_V01
      && cmd_type != UIMI_CMD_VAL_CHANGE_PROVISIONING_SESSION
#endif /* REMOVE_QMI_UIM_CHANGE_PROVISIONING_SESSION_V01 */
#ifdef REMOVE_QMI_UIM_GET_LABEL_V01
      && cmd_type != UIMI_CMD_VAL_GET_LABEL
#endif /* REMOVE_QMI_UIM_GET_LABEL_V01 */
#ifdef REMOVE_QMI_UIM_GET_CONFIGURATION_V01
      && cmd_type != UIMI_CMD_VAL_GET_CONFIGURATION
#endif /* REMOVE_QMI_UIM_GET_CONFIGURATION_V01 */
#ifdef REMOVE_QMI_UIM_SEND_APDU_V01
      && cmd_type != UIMI_CMD_VAL_SEND_APDU
#endif /* REMOVE_QMI_UIM_SEND_APDU_V01 */
#ifdef REMOVE_QMI_UIM_SAP_CONNECTION_V01
      && cmd_type != UIMI_CMD_VAL_SAP_CONNECTION
#endif /* REMOVE_QMI_UIM_SAP_CONNECTION_V01 */
#ifdef REMOVE_QMI_UIM_SAP_REQUEST_V01
      && cmd_type != UIMI_CMD_VAL_SAP_REQUEST
#endif /* REMOVE_QMI_UIM_SAP_REQUEST_V01 */
#ifdef REMOVE_QMI_UIM_LOGICAL_CHANNEL_V01
      && cmd_type != UIMI_CMD_VAL_LOGICAL_CHANNEL
#endif /* REMOVE_QMI_UIM_LOGICAL_CHANNEL_V01 */
#ifdef REMOVE_QMI_UIM_SUBSCRIPTION_OK_V01
      && cmd_type != UIMI_CMD_VAL_SUBSCRIPTION_OK_REQ
#endif /* REMOVE_QMI_UIM_SUBSCRIPTION_OK_V01 */
#ifdef REMOVE_QMI_UIM_GET_ATR_V01
      && cmd_type != UIMI_CMD_VAL_GET_ATR
#endif /* REMOVE_QMI_UIM_GET_ATR_V01 */
#ifdef REMOVE_QMI_UIM_OPEN_LOGICAL_CHANNEL_V01
      && cmd_type != UIMI_CMD_VAL_OPEN_LOGICAL_CHANNEL
#endif /* REMOVE_QMI_UIM_OPEN_LOGICAL_CHANNEL_V01 */
#ifdef REMOVE_QMI_UIM_REFRESH_REGISTER_ALL_V01
      && cmd_type != UIMI_CMD_VAL_REFRESH_REGISTER_ALL
#endif /* REMOVE_QMI_UIM_REFRESH_REGISTER_ALL_V01 */
#ifdef REMOVE_QMI_UIM_SET_FILE_STATUS_V01
      && cmd_type != UIMI_CMD_VAL_SET_FILE_STATUS
#endif /* REMOVE_QMI_UIM_SET_FILE_STATUS_V01 */
#ifdef REMOVE_QMI_UIM_SWITCH_SLOT_V01
      && cmd_type != UIMI_CMD_VAL_SWITCH_SLOT
#endif /* REMOVE_QMI_UIM_SWITCH_SLOT_V01 */
#ifdef REMOVE_QMI_UIM_GET_SLOTS_STATUS_V01
      && cmd_type != UIMI_CMD_VAL_GET_SLOTS_STATUS
#endif /* REMOVE_QMI_UIM_GET_SLOTS_STATUS_V01 */
#ifdef REMOVE_QMI_UIM_GET_PLMN_NAME_TABLE_INFO_V01
      && cmd_type != UIMI_CMD_VAL_GET_PLMN_NAME_TABLE_INFO
#endif /* REMOVE_QMI_UIM_GET_PLMN_NAME_TABLE_INFO_V01 */
#ifdef REMOVE_QMI_UIM_PERSONALIZATION_V01
      && cmd_type != UIMI_CMD_VAL_PERSONALIZATION
#endif /* REMOVE_QMI_UIM_PERSONALIZATION_V01 */
#ifdef REMOVE_QMI_UIM_INCREASE_V01
      && cmd_type != UIMI_CMD_VAL_INCREASE
#endif /* REMOVE_QMI_UIM_INCREASE_V01 */
#ifdef REMOVE_QMI_UIM_RECOVERY_V01
      && cmd_type != UIMI_CMD_VAL_RECOVERY
#endif /* REMOVE_QMI_UIM_RECOVERY_V01 */
#ifdef REMOVE_QMI_UIM_RESELECT_V01
      && cmd_type != UIMI_CMD_VAL_RESELECT
#endif /* REMOVE_QMI_UIM_RESELECT_V01 */
#ifdef REMOVE_QMI_UIM_SEND_STATUS_V01
      && cmd_type != UIMI_CMD_VAL_SEND_STATUS
#endif /* REMOVE_QMI_UIM_SEND_STATUS_V01 */
#ifdef REMOVE_QMI_UIM_GET_SIM_PROFILE_V01
      && cmd_type != UIMI_CMD_VAL_GET_SIM_PROFILE
#endif /* REMOVE_QMI_UIM_GET_SIM_PROFILE_V01 */
#ifdef REMOVE_QMI_UIM_SET_SIM_PROFILE_V01
      && cmd_type != UIMI_CMD_VAL_SET_SIM_PROFILE
#endif /* REMOVE_QMI_UIM_SET_SIM_PROFILE_V01 */
#ifdef REMOVE_QMI_UIM_SUPPLY_VOLTAGE_V01
      && cmd_type != UIMI_CMD_VAL_SUPPLY_VOLTAGE
#endif /* REMOVE_QMI_UIM_SUPPLY_VOLTAGE_V01 */
#ifdef REMOVE_QMI_UIM_DEPERSONALIZATION_SECURE_V01
      && cmd_type != UIMI_CMD_VAL_DEPERSONALIZATION_SECURE
#endif /* REMOVE_QMI_UIM_DEPERSONALIZATION_SECURE_V01 */
#ifdef REMOVE_QMI_UIM_PERSONALIZATION_SECURE_V01
      && cmd_type != UIMI_CMD_VAL_PERSONALIZATION_SECURE
#endif /* REMOVE_QMI_UIM_PERSONALIZATION_SECURE_V01 */
#ifdef REMOVE_QMI_UIM_EMERGENCY_ONLY_V01
      && cmd_type != UIMI_CMD_VAL_EMERGENCY_ONLY
#endif /* REMOVE_QMI_UIM_EMERGENCY_ONLY_V01 */
#ifdef REMOVE_QMI_UIM_SIMLOCK_CONFIGURATION_V01
      && cmd_type != UIMI_CMD_VAL_SIMLOCK_CONFIGURATION
#endif /* REMOVE_QMI_UIM_SIMLOCK_CONFIGURATION_V01 */
#ifdef REMOVE_QMI_UIM_GBA_V01
      && cmd_type != UIMI_CMD_VAL_GBA
#endif /* REMOVE_QMI_UIM_GBA_V01 */
#ifdef REMOVE_QMI_UIM_GBA_IMPI_V01
      && cmd_type != UIMI_CMD_VAL_GET_GBA_IMPI
#endif /* REMOVE_QMI_UIM_GBA_IMPI_V01 */
#ifdef REMOVE_QMI_UIM_REMOTE_UNLOCK_V01
      && cmd_type != UIMI_CMD_VAL_REMOTE_UNLOCK
#endif /* REMOVE_QMI_UIM_REMOTE_UNLOCK_V01 */
#ifdef REMOVE_QMI_UIM_VERIFY_IMSI_V01
      && cmd_type != UIMI_CMD_VAL_VERIFY_IMSI
#endif /* REMOVE_QMI_UIM_VERIFY_IMSI_V01 */
#ifdef REMOVE_QMI_UIM_TEMPORARY_UNLOCK_STATUS_IND_V01
      && cmd_type != UIMI_CMD_VAL_TEMPORARY_UNLOCK_STATUS_IND
#endif /* REMOVE_QMI_UIM_TEMPORARY_UNLOCK_STATUS_IND_V01 */
#ifdef REMOVE_QMI_UIM_SEARCH_RECORD_V01
      && cmd_type != UIMI_CMD_VAL_SEARCH_RECORD
#endif /* REMOVE_QMI_UIM_SEARCH_RECORD_V01 */
    ))
  {
    is_disabled = TRUE;
  }

  return is_disabled;
} /* qmi_uim_is_command_disabled */


/*===========================================================================
  FUNCTION  QMI_UIM_PROCESS_FRAMEWORK_CMD()

  DESCRIPTION
    Generic QMI processing for external commands

  PARAMETERS
    uim_message_ptr : message to the internal qmi_uim_message
                     containing an external command

  RETURN VALUE
    None

  DEPENDENCIES
    QMI UIM must already have been initialized and registered with Framework

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_process_framework_cmd
(
  qmi_uim_message_type * uim_message_ptr
)
{
  qmi_framework_msg_hdr_type * fw_msg_hdr_ptr  = NULL;
  dsm_item_type              * sdu             = NULL;
  qmi_uimi_state_type        * svc_sp          = NULL;
  qmi_uimi_client_state_type * cl_sp           = NULL;
  qmi_svc_cmd_hdlr_type      * cmd_hdlr_ptr    = NULL;
  qmi_transaction_type       * x_p             = NULL;
  qmi_cmd_buf_type           * cmd_buf_p       = NULL;
  dsm_item_type *              response_ptr    = NULL;
  uint16                       cmd             = 0;
  int32                        temp            = 0;
  uint16                       cmd_type        = 0;
  uint16                       sdu_len         = 0;
  uint16                       remaining_bytes = 0;
  qmi_error_e_type             errval          = QMI_ERR_NONE;

  ASSERT(uim_message_ptr);
  ASSERT(uim_message_ptr->data.framework_cmd.sdu);
  ASSERT(qmi_uim_state_ptr);

  fw_msg_hdr_ptr = &uim_message_ptr->data.framework_cmd.cmd_hdr;
  sdu            = uim_message_ptr->data.framework_cmd.sdu;

  if(fw_msg_hdr_ptr->common_hdr.client_id >  UIMI_MAX_CLIDS ||
     fw_msg_hdr_ptr->common_hdr.client_id == 0)
  {
    UIM_MSG_ERR_0("Invalid qmi_framework message header");
    dsm_free_packet(&sdu);
    return;
  }

  /* Get a service state and client state pointer */
  svc_sp = qmi_uim_state_ptr;
  cl_sp  = svc_sp->client[fw_msg_hdr_ptr->common_hdr.client_id - 1];

  if(cl_sp == NULL)
  {
    UIM_MSG_ERR_0("Invalid client indicated by qmi_framework");
    dsm_free_packet(&sdu);
    return;
  }

  /* get a transaction container */
  x_p = ds_qmi_fw_get_transaction(((qmi_common_svc_state_type*)svc_sp),
                                  ((qmi_common_client_state_type*)cl_sp));
  if (x_p == NULL)
  {
    UIM_MSG_ERR_0("No transaction container!  Discarding QMI UIM framework message");
    dsm_free_packet(&sdu);
    return;
  }

  /* Get a QMI command buffer to hold the command */
  cmd_buf_p = ds_qmi_fw_new_cmd_buf(x_p);
  if (cmd_buf_p == NULL)
  {
    UIM_MSG_ERR_1("No QMI command buffer. Discarding service transaction: %d",
                  fw_msg_hdr_ptr->common_hdr.transaction_id);
    dsm_free_packet(&sdu);
    ds_qmi_fw_free_transaction(&x_p);
    return;
  }

  x_p->ctl  = fw_msg_hdr_ptr->msg_ctl_flag;
  x_p->x_id = fw_msg_hdr_ptr->common_hdr.transaction_id;

  /* Parse the incoming service message */
  remaining_bytes = (uint16) dsm_length_packet(sdu);

  /* Pull out the command ID */
  temp = dsm_pull16(&sdu);
  if (temp == -1)
  {
    UIM_MSG_ERR_1("Short QMI UIM svc header!  Discarding transaction %d",
                  fw_msg_hdr_ptr->common_hdr.transaction_id);
    errval = QMI_ERR_INTERNAL;
    goto send_result;
  }
  cmd_type = ps_ntohs(temp);

  /* Pull out the length of the input sdu */
  temp = dsm_pull16(&sdu);
  if (temp == -1)
  {
    UIM_MSG_ERR_1("Short QMI UIM svc header!  Discarding transaction %d",
                  fw_msg_hdr_ptr->common_hdr.transaction_id);
    errval = QMI_ERR_INTERNAL;
    goto send_result;
  }
  sdu_len = ps_ntohs(temp);

  /* Framework input sdus have the command and length
     nibbles prepended to them.  Remove these bytes and
     insure we have one and only one input sdu
     remaining bytes must be >= 4 adding the check for lint */
  if(remaining_bytes >=4)
  {
    remaining_bytes -= 4;
  }

  if (sdu_len != remaining_bytes)
  {
    UIM_MSG_ERR_2("Invalid payload length - sdu len:0x%x svc payload len:0x%x",
                  sdu_len, remaining_bytes);
    errval = QMI_ERR_MALFORMED_MSG;
    goto send_result;
  }

  cmd_buf_p->cmd_type = cmd_type;

  /* search through the uim command callbacks for
     the command specified in the incoming sdu */
  cmd_hdlr_ptr = qmi_uimi_cmd_callbacks;
  for(cmd = 0; cmd < sizeof(qmi_uimi_cmd_callbacks)/sizeof(qmi_uimi_cmd_callbacks[0]); cmd++, cmd_hdlr_ptr++)
  {
    if (cmd_buf_p->cmd_type == cmd_hdlr_ptr->cmd_type)
    {
      break;
    }
  }

  if((cmd == sizeof(qmi_uimi_cmd_callbacks)/sizeof(qmi_uimi_cmd_callbacks[0])) ||
     cmd_hdlr_ptr->request_hdlr == NULL ||
     qmi_uim_is_command_disabled(cmd_hdlr_ptr->cmd_type) != FALSE)
  {
    /* We couldn't find this command in the UIM command callbacks array */
    UIM_MSG_ERR_1("Unrecognized type 0x%x for QMI UIM CMD HDLR",
                  cmd_buf_p->cmd_type );
    errval = QMI_ERR_INVALID_QMI_CMD;
    goto send_result;
  }
  else
  {
    /* We found the specified command in the UIM command callbacks array */
    cmd_buf_p->in_progress = TRUE;
    if((cmd_buf_p->x_p->ctl & QMI_FLAG_MASK_MSGTYPE) == QMI_FLAG_MSGTYPE_CMD)
    {
      response_ptr = cmd_hdlr_ptr->request_hdlr(svc_sp, cmd_buf_p, cl_sp, &sdu);
      UIM_MSG_HIGH_2("Handling cmd:0x%x Response ptr = 0x%x",
                      cmd_hdlr_ptr->cmd_type, response_ptr);
    }
    else
    {
      errval = QMI_ERR_MALFORMED_MSG;
    }
  }
  cmd_buf_p->in_progress = FALSE;

  if (response_ptr == QMI_SVC_RESPONSE_PENDING)
  {
    dsm_free_packet(&sdu);
    return;
  }

  send_result:
    UIM_MSG_HIGH_0("No response pending - execute send_response");
    /* If there was some error from the TLV to send. Otherwise
       the response_ptr will be populated by the cmd_hdlr. */
    if(response_ptr == NULL)
    {
      (void)qmi_svc_put_result_tlv(&response_ptr,
                                   QMI_RESULT_FAILURE,
                                   errval);
    }
    if((response_ptr == NULL) ||
       (FALSE == qmi_uimi_send_response(cmd_buf_p, response_ptr)))
    {
      ds_qmi_fw_free_transaction(&x_p);
    }
    dsm_free_packet(&sdu);

} /* qmi_uim_process_framework_cmd */


/*===========================================================================
  FUNCTION  QMI_UIM_PROCESS_MESSAGE()

  DESCRIPTION
    Generic QMI processing for events and confirmations

  PARAMETERS
    cmd_ptr : ptr to the cmd enum passed to QMI

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_uim_process_message
(
  void
)
{
  qmi_uim_message_type * uim_message_ptr = NULL;

  uim_message_ptr = qmi_uim_get_message();
  if (uim_message_ptr == NULL)
  {
    UIM_MSG_ERR_0("No message in QMI UIM queue");
    return;
  }

  switch(uim_message_ptr->message_type)
  {
    case QMI_UIM_MESSAGE_CNF:
      qmi_uim_process_mmgsdi_callback_msg(uim_message_ptr);
      break;
    case QMI_UIM_MESSAGE_EVENT:
      qmi_uim_process_mmgsdi_event_msg(uim_message_ptr);
      break;
    case QMI_UIM_MESSAGE_PHYSICAL_SLOTS_STATUS:
      qmi_uim_process_physical_slots_status_msg(uim_message_ptr);
      break;
    case QMI_UIM_MESSAGE_ALLOC_CLID:
      qmi_uim_process_alloc_clid(uim_message_ptr);
      break;
    case QMI_UIM_MESSAGE_DEALLOC_CLID:
      qmi_uim_process_dealloc_clid(uim_message_ptr);
      break;
    case QMI_UIM_MESSAGE_FRAMEWORK_CMD:
      qmi_uim_process_framework_cmd(uim_message_ptr);
      break;
    case QMI_UIM_MESSAGE_RECOVERY_CB:
      qmi_uim_process_recovery_cb(uim_message_ptr);
      break;
    case QMI_UIM_MESSAGE_SIMLOCK_CB:
      qmi_uim_process_simlock_cb(uim_message_ptr);
      break;
    case QMI_UIM_MESSAGE_RECOVERY_COMPLETE_IND:
      qmi_uim_process_recovery_complete(uim_message_ptr->data.recovery_ind.slot);
      break;
    case QMI_UIM_MESSAGE_SUPPLY_VOLTAGE_IND:
      qmi_uim_process_supply_voltage_ind(uim_message_ptr);
      break;
    case QMI_UIM_MESSAGE_SIMLOCK_REMOTE_SFS_CB:
      qmi_uim_process_simlock_remote_sfs_cb(uim_message_ptr);
      break;
    case QMI_UIM_MESSAGE_OTASP_STATUS_IND:
      qmi_uim_process_otasp_status_indication(uim_message_ptr);
      break;
    case QMI_UIM_MESSAGE_SIMLOCK_SET_REMOTE_SFS_CB:
      qmi_uim_process_set_remote_sfs_resp(uim_message_ptr->data.simlock_set_remote_sfs_resp.status,
                                          (qmi_uimi_userdata_type*)uim_message_ptr->data.simlock_set_remote_sfs_resp.user_data_ptr);
      break;
    case QMI_UIM_MESSAGE_GBA_CB:
      qmi_uim_process_gba_cb(uim_message_ptr);
      break;
    case QMI_UIM_MESSAGE_REMOTE_UNLOCK_CB:
      qmi_uim_process_remote_unlock_resp(uim_message_ptr->data.remote_unlock_resp.status,
                                         &uim_message_ptr->data.remote_unlock_resp.key_data,
                                         (qmi_uimi_userdata_type*)uim_message_ptr->data.remote_unlock_resp.user_data_ptr);
      break;
    case QMI_UIM_MESSAGE_SIMLOCK_TEMPORARY_UNLOCK_CB:
     qmi_uim_process_simlock_temporary_unlock_cb(uim_message_ptr);
      break;
    case QMI_UIM_MESSAGE_LPA_CB:
      qmi_uim_process_lpa_cb(uim_message_ptr);
      break;
    case QMI_UIM_MESSAGE_LPA_EVENT:
      qmi_uim_process_lpa_event_cb(uim_message_ptr);
      break;
    case QMI_UIM_MESSAGE_LPA_PROFILE_INFO_CB:
      qmi_uim_process_lpa_profile_info_cb(uim_message_ptr);
      break;
    default:
      UIM_MSG_ERR_1("Unhandled UIM message: 0x%x",
                    uim_message_ptr->message_type);
      break;
  }

  uimqmi_free(uim_message_ptr);
  uim_message_ptr = NULL;
} /* qmi_uim_process_message */


/*===========================================================================
  FUNCTION QMI_UIMI_SEND_INDICATION()

  DESCRIPTION
    This function calls the QMI Framework API to send out the UIM service
    indication to client.

  PARAMETERS
    client_id: client ID
    cmd_type : type of indication
    ind_ptr  : dsm item

  RETURN VALUE
    TRUE  - For success
    FALSE - For qmi svc failure

  DEPENDENCIES
    QMI UIM service must be initialized and registered with Framework

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_uimi_send_indication
(
  uint8           client_id,
  uint16          cmd_type,
  dsm_item_type * ind_ptr
)
{
  qmi_framework_msg_hdr_type framework_msg_hdr;

  ASSERT(ind_ptr);

  if (client_id == QMI_SVC_CLID_UNUSED || client_id > UIMI_MAX_CLIDS)
  {
    UIM_MSG_ERR_1("Invalid Client ID: 0x%x", client_id);
    return FALSE;
  }

  /* for indication the transaction ID can be ignored */
  framework_msg_hdr.common_hdr.transaction_id = 0;
  /* if unicast indication, qmi framework map the instance and no need to fill*/
  framework_msg_hdr.common_hdr.qmi_instance   = UIMI_INVALID_INSTANCE;
  framework_msg_hdr.common_hdr.client_id      = client_id;
  framework_msg_hdr.common_hdr.service        = QMUX_SERVICE_UIM;
  framework_msg_hdr.msg_ctl_flag              = QMI_FLAG_MSGTYPE_IND;
  framework_msg_hdr.msg_len                   = (uint16)dsm_length_packet(ind_ptr);

  UIM_MSG_HIGH_2("Sending QMI UIM Indication to QMI Framework: clid:0x%x, ind_id:0x%x",
                 client_id, cmd_type);

  if(FALSE == qmi_svc_prepend_msg_hdr(&ind_ptr, cmd_type))
  {
    UIM_MSG_ERR_1("Unable to build indication for cmd 0x%x", cmd_type);
    return FALSE;
  }

  if(FALSE == qmi_framework_svc_send_ind(&framework_msg_hdr, ind_ptr))
  {
    UIM_MSG_ERR_0("Unable to send QMI UIM indication to QMI Framework" );
    return FALSE;
  }
  return TRUE;
} /* qmi_uimi_send_indication */


/*===========================================================================
FUNCTION QMI_UIMI_SEND_RESPONSE()

DESCRIPTION
  This function calls QMI Framework API to send a QMI UIM Service response to a
  clients.  It always frees cmd_buf_p and when successful frees the transaction

PARAMETERS
  cmd_buf_p: command buffer
  msg_ptr : dsm item

RETURN VALUE
  TRUE: If responses send to Framework
  FALSE: otherwise

DEPENDENCIES
  QMI UIM service must be initialized and registered with Framework

SIDE EFFECTS
  Frees cmd_buf_p

===========================================================================*/
static boolean qmi_uimi_send_response
(
  qmi_cmd_buf_type           * cmd_buf_p,
  dsm_item_type              * msg_ptr
)
{
  qmi_transaction_type       * x_p     = NULL;
  qmi_uimi_client_state_type * cl_sp   = NULL;
  qmi_framework_msg_hdr_type   msg_hdr;


  ASSERT (msg_ptr);
  ASSERT (cmd_buf_p);
  ASSERT (cmd_buf_p->x_p);
  ASSERT (cmd_buf_p->x_p->cl_sp);

  memset(&msg_hdr,0, sizeof(msg_hdr));
  cl_sp = (qmi_uimi_client_state_type *)cmd_buf_p->x_p->cl_sp;

  if(FALSE == qmi_svc_prepend_msg_hdr(&msg_ptr, cmd_buf_p->cmd_type))
  {
    UIM_MSG_ERR_1("Unable to send Response for cmd %d", cmd_buf_p->cmd_type);
    /* Freeing msg_ptr is done in qmi_svc_prepend_msg_hdr for failure */
    ds_qmi_fw_free_cmd_buf(&cmd_buf_p);
    return FALSE;
  }

  /* Get the transaction from the command buffer*/
  x_p = cmd_buf_p->x_p;

  /* We do not support bundled commands only check the first command in list
     make sure we only have one command and be sure it's expecting a resp. */
  if( (x_p->n_cmds != 1) ||
      (cmd_buf_p->cmd_no != 0) ||
      (cmd_buf_p != x_p->cmd_list[cmd_buf_p->cmd_no]) ||
      (x_p->resp_list[cmd_buf_p->cmd_no] != QMI_SVC_RESPONSE_PENDING) ||
      (cl_sp->service_id != QMUX_SERVICE_UIM) ||
      (cl_sp->common.clid == QMI_SVC_CLID_UNUSED) ||
      (cl_sp->common.clid > UIMI_MAX_CLIDS))
  {
    UIM_MSG_ERR_0("Command is linked to transaction it doesn't belong to! discarding");
    dsm_free_packet(&msg_ptr);
    ds_qmi_fw_free_cmd_buf(&cmd_buf_p);
    return FALSE;
  }

  /* Freeup the transaction and the command buffer as it no longer used */
  ds_qmi_fw_free_cmd_buf(&cmd_buf_p);

  msg_hdr.common_hdr.client_id      = cl_sp->common.clid;
  msg_hdr.common_hdr.qmi_instance   = cl_sp->instance;
  msg_hdr.common_hdr.service        = (qmux_service_e_type)cl_sp->service_id;
  msg_hdr.common_hdr.transaction_id = x_p->x_id;

  msg_hdr.msg_ctl_flag = QMI_FLAG_MSGTYPE_RESP;

  msg_hdr.msg_len  = (uint16) dsm_length_packet(msg_ptr);

  /* qmi_framework_svc_send_response takes care of freeing msg_ptr */
  (void)qmi_framework_svc_send_response(&msg_hdr, msg_ptr);

  /* free the transaction buffer */
  ds_qmi_fw_free_transaction(&x_p);
  return TRUE;
} /* qmi_uimi_send_response */


/*===========================================================================
  FUNCTION QMI_UIM_RECOVERY_COMPLETE_IND()

  DESCRIPTION
    This function is invoked by the UIM drivers when a recovery indication
    has completed successfully to inform clients of QMI UIM.

  PARAMETERS
    slot: Indicates the slot in which the recovery occured

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_uim_recovery_complete_ind
(
  const uim_slot_type slot
)
{
  qmi_uim_message_type * msg_ptr = NULL;

  UIM_MSG_HIGH_0("Received recovery indication from UIM drivers");

  msg_ptr = qmi_uim_create_message(QMI_UIM_MESSAGE_RECOVERY_COMPLETE_IND);

  if (msg_ptr == NULL)
  {
    return;
  }

  msg_ptr->data.recovery_ind.slot = slot;

  /* Send command */
  qmi_uim_post_message(msg_ptr);
  msg_ptr = NULL;
} /* qmi_uim_recovery_complete_ind */


/*===========================================================================
  FUNCTION QMI_UIM_SUPPLY_VOLTAGE_IND()

  DESCRIPTION
    This function is invoked by the UIM drivers when the Vcc needs to
    be deactivated or when Vcc has been activated.

  PARAMETERS
    slot                                      : UIM slot id
    uimdrv_qmi_indications_type               : LDO state
    uimdrv_qmi_power_management_callback_type : callback to ack drivers

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_uim_supply_voltage_ind
(
  uim_slot_type                                     slot,
  uimdrv_qmi_indications_type                       ldo_state,
  uimdrv_qmi_power_management_callback_type         uim_callback_ptr
)
{
  qmi_uim_message_type * msg_ptr = NULL;

  UIM_MSG_HIGH_2("Received supply voltage indication, slot: 0x%x, ldo_state: 0x%x",
                 slot, ldo_state);

  msg_ptr = qmi_uim_create_message(QMI_UIM_MESSAGE_SUPPLY_VOLTAGE_IND);
  if (msg_ptr == NULL)
  {
    return;
  }

  msg_ptr->data.supply_voltage.slot             = slot;
  msg_ptr->data.supply_voltage.ldo_state        = ldo_state;
  msg_ptr->data.supply_voltage.uim_callback     = uim_callback_ptr;

  /* Send command */
  qmi_uim_post_message(msg_ptr);
  msg_ptr = NULL;
} /* qmi_uim_supply_voltage_ind */


/*===========================================================================
  FUNCTION QMI_UIM_BLOCK_CARD_STATUS_INDICATIONS

  DESCRIPTION
    API to block card status indications from being sent.

  PARAMETERS
    None.

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_uim_block_card_status_indications
(
  void
)
{
  if (qmi_uim_global_ptr != NULL)
  {
    qmi_uim_global_ptr->block_card_status_ind = TRUE;
  }
} /* qmi_uim_block_card_status_indications */

#ifdef FEATURE_UIM_TEST_FRAMEWORK
#error code not present
#endif /* FEATURE_UIM_TEST_FRAMEWORK */
