#ifndef FTM_COMMON_ENH_INTERNAL_DEVICE_CAL_H
#define FTM_COMMON_ENH_INTERNAL_DEVICE_CAL_H
/*!
  @file
  ftm_common_enh_internal_device_cal.h

  @brief
  This module contains prototypes and definitions used by enhanced internal calibration  code.
*/

/*==============================================================================

  Copyright (c) 2013 Qualcomm Technologies Incorporated. All Rights Reserved

  Qualcomm Proprietary

  Export of this technology or software is regulated by the U.S. Government.
  Diversion contrary to U.S. law prohibited.

  All ideas, data and information contained in or disclosed by
  this document are confidential and proprietary information of
  Qualcomm Technologies Incorporated and all rights therein are expressly reserved.
  By accepting this material the recipient agrees that this material
  and the information contained therein are held in confidence and in
  trust and will not be used, copied, reproduced in whole or in part,
  nor its contents revealed in any manner to others without the express
  written permission of Qualcomm Technologies Incorporated.

==============================================================================*/

/*==============================================================================

                      EDIT HISTORY FOR FILE

  This section contains comments describing changes made to this file.
  Notice that changes are listed in reverse chronological order.

  $Header: //commercial/MPSS.JO.2.0.c1.4/Main/modem_proc/rfa/rf/common/ftm/inc/ftm_common_enh_internal_device_cal.h#1 $

when       who     what, where, why
--------   ---     ------------------------------------------------------------- 
11/05/14  xsh     Add scell2 rxrsb support
09/12/14  xsh     Change rsb max validation length for different tech to save meomory
08/30/14   jmf     Add STG tone power return from FBRx Droop Cal FTM API
08/18/14    jmf    Add new API for XPT IQ capture without wait
08/05/14   xsh    Seperate efs write from normal rsb cal
08/05/14   xsh    Remove fixed rsb_result_type and Added rsb_cal_res_len in ftm_enh_internal_device_cal_data_type to support variable length of rsb cal results
08/05/14   xsh    Add Error code of required response payload size is larger than max supported internal cal response size
07/15/14   xsh   Add RSB Cal incomplete Errror Type 
07/07/14   xsh   Add RSB Result Fetch to solve rsb cal time out of max allowed esc segment
05/30/14   xsh   Add different gain state rsb cal support
05/29/14   xsh   Add lte scell rx rsb cal support
04/08/14   jmf    Added FBRx Droop Cal Processing related constants and prototype defs
03/14/14   jmf    Added function to convert band number to NV band enum for DC cal
02/06/14   jmf    Added FBRx BW to common payload header
                  Updated FBRx Capture API prototype
                  Added FBRx Capture config/deconfig prototypes
01/21/14   jmf    Droop Filter Coeff structure update
10/02/13   xsh    Initial Revision

==============================================================================*/

//#include "rfa_variation.h"
#include "comdef.h"
//#include "rfm_device_types.h"
#include "ftmdiag.h"
#include "rfcommon_core_xpt_buffer.h"

#ifdef __cplusplus
extern "C" {
#endif

#ifdef T_WINNT
#error code not present
#endif


#define MAX_ENH_INTERNAL_DEVICE_CAL_INSTR_SIZE 2048
#define MAX_ENH_INTERNAL_DEVICE_CAL_RES_SIZE 2048
#define MAX_ENH_INTERNAL_DEVICE_CAL_RSB_VER_LENGTH 3000
#define WCDMA_TDS_ENH_INTERNAL_DEVICE_CAL_RSB_VER_LENTH 512

#define MAX_NUM_DROOP_FILTERS_GEN_PER_SWP 4  
// Max number of Droop filters that can be generated by doing one round of IQ capture
// e.g. One set of LTE10 captures can produce filters for both LTE5 and LTE10

#define MAX_FREQ_OFFSETS_STG_IQ_CAP RF_COMMON_XPT_NUM_CONT_SAMPLE_CAPT
// Max number of STG IQ captures allowed per sweep of Droop calibration

#define MAX_NUM_RSB_GAIN_STATES 8
// Max number of RSB cal gain states

//typedef uint16 ftm_internal_device_calibration_duration_type;


typedef int32 ftm_enh_internal_device_calibration_error_type;


typedef enum
{
  ENH_INTERNAL_DEVICE_CAL_FBDROOP_BIT = 0,
  ENH_INTERNAL_DEVICE_CAL_GROUP_DELAY_BIT = 1,
  ENH_INTERNAL_DEVICE_CAL_IP2_BIT = 2,
  ENH_INTERNAL_DEVICE_CAL_DC_BIT = 3,  
  ENH_INTERNAL_DEVICE_CAL_RSB_BIT=4,
  ENH_INTERNAL_DEVICE_CAL_MAX = 5
} ftm_enh_internal_device_cal_bit_type;





/*----------------------------------------------------------------------------*/
/*!
  @brief
  Enumeration of default CRC value to be checked against
*/
#define FTM_INTERNAL_DEVICE_CAL_PACKET_CRC_VAL 0xDAAD

#define FTM_ENH_INTERNAL_DEVICE_CAL_FBRX_DROOP_FILTER_LEN_MAX 32
// number of complex coefficients for FBRx Droop Compensation Filter


/*----------------------------------------------------------------------------*/
/*!
  @brief
  Enumeration indicating the status of internal cal
*/
typedef enum
{
 
  FTM_ENH_INTERNAL_DEVICE_CAL_NOT_STARTED =0,
 
  FTM_ENH_INTERNAL_DEVICE_CAL_INITIATED = 1,
  	/*!< Internal Calibration is initiated */

  FTM_ENH_INTERNAL_DEVICE_CAL_PACKET_COPIED = 2,
  /*!< the Calibration request packet sent from PC is  stored in internal_cal_data structure */

  FTM_ENH_INTERNAL_DEVICE_CAL_START_CAL = 3,
   /*!< the Calibration STARTED */
  FTM_ENH_INTERNAL_DEVICE_CAL_PROCESSING =4,
  /* !<INTERNAL CA IS ON PROCESSING */
  FTM_ENH_INTERNAL_DEVICE_CAL_COMPLETE = 5,
  /*!< INTERNAL CAL COMPLTED, BUT DATA NOT SENT TO PC YET */

  FTM_ENH_INTERNAL_DEVICE_CAL_NOT_PROCESSED = 6,
		/*!<INTERNAL cal not processed because of decoding error or not valid internal cal type*/

  FTM_ENH_INTERNAL_DEVICE_CAL_ERROR = 7,
   /*!<INTERNAL cal started processing but encountered error*/

} ftm_enh_internal_device_cal_status;



/*----------------------------------------------------------------------------*/
/*!
  @brief
  Enumeration indicating the status response of Enhanced internal Calibration
*/
typedef enum
{
  FTM_ENH_INTERNAL_DEVICE_CAL_RESULTS_SUCCESS = 0,
	/*!< Success Code indicating that the internal cal is successful 
	and the result data sent back to PC is valid */

  FTM_ENH_INTERNAL_DEVICE_CAL_RESULTS_EMPTY_BUFFER = -1,
  /*!< Error Code indicating that the Result buffer is empty */

  FTM_ENH_INTERNAL_DEVICE_CAL_INVALID_CAL_TYPE = -2,
  /*!< Internal Cal request contains invalid internal cal type */
 
  FTM_ENH_INTERNAL_DEVICE_CAL_INVALID_CRC = -3,
  /*!< Error Code indicating bad CRC being detected at the end of the request
  packet */

  FTM_ENH_INTERNAL_DEVICE_CAL_INSTRUCTION_OVERSIZE = -4,
  /*!< Error Code indicating that the payload packet instruction longer than max size
  defined in MAX_INTERNAL_CAL_INSTR_SIZE */

   FTM_ENH_INTERNAL_DEVICE_CAL_BAD_INSTRUCTION = -5,
  /*!< Error code indicating that the invalid instruction decoded */
 
  FTM_ENH_INTERNAL_DEVICE_CAL_DATA_POINTER_INVALID = -6,
   /*!< Error code indicating that the global internal_cal data pointer invalid */

  FTM_ENH_INTERNAL_DEVICE_CAL_OVER_ONE_TYPE_PER_REQ = -7,
  /*!< Error code indicating that more than one internal Cal type is requested, may remove it in the future to support multiple internal cal type per request */

  FTM_ENH_INTERNAL_DEVICE_CAL_MEM_ALLOC_FAILURE = -8,
  /*!< Error code indicating that error on memory allocation */
  
  FTM_ENH_INTERNAL_DEVICE_CAL_IQ_CAPTURE_FAILURE = -9,
  /*!< Error code indicating that iq capture failure */

  FTM_ENH_INTERNAL_DEVICE_CAL_IQ_CAP_CONFIG_FAILURE = -10,
  /*!< Error code indicating that an IQ Capture Config Operation Failed */

  FTM_ENH_INTERNAL_DEVICE_CAL_UNSUPPORTED_ACTION = -11,
  /*!< Error code indicating that the requested action is not yet supported */

  FTM_ENH_INTERNAL_DEVICE_CAL_TECH_MISMATCH = -12,
  /*!< Error code indicating that there is a mismatch in request FBRx Cal Tech */

  FTM_ENH_INTERNAL_DEVICE_CAL_INVALID_TECHBW = -13,
  /*!< Error code indicating that the requested action is not yet supported */

  FTM_ENH_INTERNAL_DEVICE_CAL_UNSUPPORTED_TECH = -14,
  /*!< Error code indicating that the cal action is not supported for request tech */

  FTM_ENH_INTERNAL_DEVICE_CAL_FBRX_DEV_ACTION_FAILED = -15,
  /*!< Error code indicating that the requested WTR device api failed */

  FTM_ENH_INTERNAL_DEVICE_CAL_NV_ACTION_FAILED = -16,
  /*!< Error code indicating that the requested NV read/update action failed */

  FTM_ENH_INTERNAL_DEVICE_CAL_PROCESSING_FAILED = -17,
  /*!< Error code indicating that the requested data processing action failed */

  FTM_ENH_INTERNAL_DEVICE_CAL_INSUFFICIENT_CAP_TIME = -18,
  /*!< Error code indicating that an IQ Capture Operation Failed to complete in time*/

  FTM_ENH_INTERNAL_DEVICE_CAL_EMPTY_FILENAME = -19,
  /*!< Error code indicating that an empty filename was input for IQ Cap EFS file save */

  FTM_ENH_INTERNAL_DEVICE_CAL_EFS_FILESAVE_FAILED = -20,
  /*!< Error code indicating that saving IQ samples to EFS file failed */

  FTM_ENH_INTERNAL_DEVICE_CAL_GENERAL_FAILURE = -21,
  /*!< Error code indicating that a General Failure occurred */

  FTM_ENH_INTERNAL_DEVICE_CAL_INSUFFICIENT_PARAMS = -22,
  /*!< Error code indicating that insufficient parameters were input for cal */

  FTM_ENH_INTERNAL_DEVICE_CAL_FETCH_SAMPLES_FAILED = -23,
  /*!< Error code indicating that fetching IQ samples from FW Shared memory failed */

  FTM_ENH_INTERNAL_DEVICE_CAL_ARITHMETIC_OVERFLOW = -24,
  /*!< Error code indicating that an overflow/underflow occurred in IQ sample processing */

  FTM_ENH_INTERNAL_DEVICE_CAL_UNSUPPORTED_CAPTURE_NUM = -25,
  /*!< Error code indicating that an overflow/underflow occurred in IQ sample processing */

  FTM_ENH_INTERNAL_DEVICE_CAL_GAIN_STATE_UNSUPPORTED = -26,
  /**!< Error code indicating that gain state not supported */

  FTM_ENH_INTERNAL_DEVICE_CAL_NUM_OF_GAIN_STATES_UNSUPPORTED = -27,
  /**!< Error code indicating that number of gain state not supported */

  FTM_ENH_INTERNAL_DEVICE_CAL_STILL_PROCESSING = -28,
  /** <Error code indicating when request to fetch data, internal cal is still not completed */
  
  FTM_ENH_INTERNAL_DEVICE_CAL_RES_OVERSIZE = -29,
  /** <Error code indicating when required response payload size is too big to be handled by max size */  

  FTM_ENH_INTERNAL_DEVICE_CAL_CARRIER_NOT_MATCH_DEV_ID = -30,
  /** <Error code indicating when requested carrier id not matching the deice id, for example, set carrier=1, while asking for dev 4,5 cal */  
  
} ftm_enh_internal_device_cal_error_code_type;


/*----------------------------------------------------------------------------*/
/*! 
  @brief
  Error mask enumeration indicating each internal cal type error code
*/
/*----------------------------------------------------------------------------*/
/*!< 
	  @brief
	  Mask to store all error codes for all internal cal.
	 
	  @details
	  This is a mask where each bit corresponds to a particular type of error code
	  experienced in internal cal. The definition of error code for each bit is
	  defined in #ftm_internal_calibration_error_code_mask. If this 32-bit mask
	  is zero, then this indicates that all the operation in the internal cal types executed
	  without any error.
*/

typedef enum
{
  FTM_ENH_INTERNAL_DEVICE_CAL_ERROR_FB_DROOP        = 0,
 
  FTM_ENH_INTERNAL_DEVICE_CAL_ERROR_GROUP_DELAY      = 1,
 
  FTM_ENH_INTERNAL_DEVICE_CAL_ERROR_IP2       = 2,

  FTM_ENH_INTERNAL_DEVICE_CAL_ERROR_DC       = 3,

  FTM_ENH_INTERNAL_DEVICE_CAL_ERROR_RSB       = 4,
 
  FTM_ENH_INTERNAL_DEVICE_CAL_ERROR_MAX
} ftm_enh_internal_device_cal_error_code_mask;


 

/*============================================================================*/
/*!
  @name Enhanced Internal Calibration FTM Request and Response Packet structure definition

  @brief
  This section contains definitions of Enhanced Internal calibration FTM Request and Response packet fields.
*/

/*----------------------------------------------------------------------------*/
/*!
  @brief
  FTM Enhanced Internal Calibration Request packet
*/
typedef PACK(struct)
{
  uint8 cmd;
  /*!< Command Identification */

  uint8 sub_sys;
  /*!< Sub-system Identification. For instance - 11 for FTM */

  uint16  mode;
  /*!< RF Mode Identification. For Instance - 20 for FTM_COMMON_C */

  uint16  cdma_cmd;
  /*!< FTM Sub Command. Example-  FTM_DO_ENH_INTERNAL_CAL*/

  uint16 req_len;
  /*!< Length of Diag Request Packet to the Target, Unused for current enh_internal_cal ftm cmd */

  uint16 rsp_len;
  /*!< Length of response packet to Diag/PC, unused for current enh_internal_cal ftm cmd */

  uint8 enh_internal_cal_param;
  /*!< Enhanced Internal Caibraiton Payload Param */
  
} ftm_enh_internal_device_cal_req_pkt_type;


/*----------------------------------------------------------------------------*/
/*!
  @brief
  FTM Enhanced Internal Calibration Response packet
*/
typedef PACK(struct)
{
  uint8 cmd;
  /*!< Command Identification */

  uint8 sub_sys;
  /*!< Sub-system Identification. For instance - 11 for FTM */

  uint16 mode;
  /*!< RF Mode Identification. For Instance - 20 for FTM_COMMON_C */

  uint16 cdma_cmd;
  /*!< FTM Sub Command. Example-  FTM_DO_ENH_INTERNAL_CAL */

  uint16 req_len;
  /*!< Length of Diag Request Packet to the Target */

  uint16 rsp_len;
  /*!< Length of response packet to Diag/PC */
 
  uint8  tech;         /* tech */  
  uint16 band;        /* <band */
  uint8 bw; /* fbrx_bandwidth */
 
  uint32 cal_type_error_mask;
  /* Error mask indicating which internal cal type get error. This parameter
   is prepared for future multiple internal cal type  request in one FTM Cmd, where these multiple internal cal type have the same radio config */

  int32 cal_status_error_code;
  /*!< Enhanced Internal Calibration Resp Error Code indicating the status of results. This will be 
  used to validate the returned Result packet */ 

//  uint32 cal_resp_mask;
   /* !< mask indicating the good internal cal response, reserved for multiple internal cal types within one FTM request, not used for now */
 
  uint16  cal_result_len;
  /*!< Total Length of Internal Calibration results (Payload) in Bytes for this response packet. */

 
  uint8 cal_result;
  /*!< Start of Internal Calibration results. The size of this calibration results are given by cal_result_len */

} ftm_enh_internal_device_cal_rsp_pkt_type;




/*============================================================================*/
/*!
  @name Enhanced Internal Calibration Packet Fields

  @brief
  This section contains definitions of Enhanced Internal calibration packet fields.
*/

/*----------------------------------------------------------------------------*/
/*!
  @brief
  definition of enh_internal_cal_mask 
*/

typedef uint32 ftm_enh_internal_device_cal_mask_type;


/*----------------------------------------------------------------------------*/
/*!
  @brief
  Structure to extract the Header from the Enhanced Internal Calibration Payload
*/
typedef PACK(struct)
{

  uint8 res_rev; /* Indicates the results revision, 0 for now */
  uint8 dbg_mode_en; /* Indicates if the debug mode is enabled or not */
  uint16 flag;    /* flag, open for future usuage */
  uint32 tot_instr_size;  /*!< Total size of all instruction. */
  ftm_enh_internal_device_cal_mask_type internal_cal_type_mask;  /* !< Indicating the internal cal type mask */
  uint8  tech;         /* tech */  
  uint8 bw;            /* fbrx signal bandwidth */
  uint16 band;        /* <band */
  int32  ref_chan;     /* <reference channel */
  uint16 device_mask; // rsb_cal  path mask
} ftm_enh_internal_device_cal_payload_header_type;


/*----------------------------------------------------------------------------*/
/*!
  @brief
  Structure to of the Internal Calibration Payload Packet
*/
typedef PACK(struct)
{
  ftm_enh_internal_device_cal_payload_header_type packet_header;  /*!< Internal Calibration Payload Header */
 
  uint8 instr_ptr;  /*!< Internal Calibration Instruction, instr_ptr is indicating in tot_instr_size  */

} ftm_enh_internal_device_cal_req_payload_type;






/*----------------------------------------------------------------------------*/
/*!
  @brief
  Structure to extract the payload of each Internal Calibration type
*/
typedef PACK(struct)
{
  uint32 internal_cal_type; // internal cal type
  uint16 instr_len; // internal cal instruction length for that type
  uint8 instr_ptr;   /*!< Internal Calibration detailed Instruction  */

} ftm_enh_internal_device_cal_instruction_packet_type;



/*-----------------------------------------------------------------------------------*/
/*!
  This section is for detailed internal cal payload as well as response payload

*/


//=================ftm_enh_internal_device_cal_RSB ===========================//


/*----------------------------------------------------------------------------*/
/*!
  @brief
  Structure template for Internal_DEVICE_Cal_RSB Instruction.

  @details
  Contains the RSB Internal Device Cal  instruction (Payload)
*/

typedef enum
{
  FTM_ENH_INTERNAL_DEVICE_CAL_RSB_ALG_CALLBOX = 0,
  FTM_ENH_INTERNAL_DEVICE_CAL_RSB_ALG_STG = 1,
  FTM_ENH_INTERNAL_DEVICE_CAL_RSB_ALG_TX = 2,
  FTM_ENH_INTERNAL_DEVICE_CAL_RSB_ALG_MAX 
}ftm_enh_internal_device_cal_rsb_alg;

typedef enum
{
  FTM_ENH_INTERNAL_DEVICE_CAL_RX_RSB = 0,
  FTM_ENH_INTERNAL_DEVICE_CAL_FB_RSB = 1,
  FTM_ENH_INTERNAL_DEVICE_CAL_RSBTYPE_MAX
} ftm_enh_internal_device_cal_rsb_type;

typedef PACK(struct)
{
   uint8 rsb_type;
   uint8 rsb_cal_alg; // 0 for using callbox, 1 for using stg, 2 for using Tx
   int32 offset; // offset from the ref chan, for using internal stg only   
   uint8 num_gain_states; // number of gain states
   uint8 gain_states[MAX_NUM_RSB_GAIN_STATES];
//   uint16 device_mask; // rsb_cal  path mask
   uint8 iq_capture_type;
   uint32 iq_sample_size; 
   uint8 carrier; //// bitwise carrier id, bit 0 for PCell, bit 1 for Scell1, 
   uint16 pcell_band_for_scell;
   uint32 pcell_ref_chan_for_scell; 
   
} ftm_enh_internal_device_cal_instr_payload_rsb_type;


/*----------------------------------------------------------------------------*/
/*!
  @brief
  Structure to hold RSB Data
*/
typedef PACK(struct)
{
  int8 nv_active;
  int16 sin_theta_final;
  int16 cos_theta_final; 
  int16 gain_inv_final; 
  int16 sin_theta_after_cal;
  int16 cos_theta_after_cal;
  int16 gain_inv_after_cal;
  int8  rsb_before_cal;
  int8  rsb_after_cal;
}ftm_rsb_result_data_type;

/*----------------------------------------------------------------------------*/
/*!
  @brief
  Structure to hold FBRx droop Data
*/
typedef PACK(struct)
{
  uint32 fbrx_tech_bw_type;
  // tech-bw-specific FBRx Mode for each filter

  uint8 group_delay; 
  // Group Delay for each filter

  uint8 num_filter_taps;
  // number of filter taps found for each filter

  int32  fbrx_fir_tap_coeffs_nv[FTM_ENH_INTERNAL_DEVICE_CAL_FBRX_DROOP_FILTER_LEN_MAX]; 
  // 32 real/complex FIR tap coefficients that have been internally written to NV
  // for each filter, first 16 bits are set to 0 if only real coeffs
  // if complex, all 32 bits are in use and extra processing is done to fill them up

} ftm_fbrx_droop_result_data_type;

typedef enum
{
  FTM_ENH_INTERNAL_DEVICE_CAL_RXRSB_RES_PRX1 = 0,
  FTM_ENH_INTERNAL_DEVICE_CAL_RXRSB_RES_DRX1 = 1,
  FTM_ENH_INTERNAL_DEVICE_CAL_RXRSB_RES_PRX2 = 2,
  FTM_ENH_INTERNAL_DEVICE_CAL_RXRSB_RES_DRX2 = 3,
  FTM_ENH_INTERNAL_DEVICE_CAL_RSB_RES_FBRX = 4,
  FTM_ENH_INTERNAL_DEVICE_CAL_RXRSB_RES_PRX3 = 4,
  FTM_ENH_INTERNAL_DEVICE_CAL_RXRSB_RES_DRX3 = 5,
  FTM_ENH_INTERNAL_DEVICE_CAL_RSB_RES_MAX = 8,
} ftm_enh_internal_device_cal_rsb_rxpath;

typedef enum
{
  FTM_ENH_INTERNAL_DEVICE_CAL_FBRX_DROOP_STG_REAL_COEFFS = 0,
    // FBRx Droop Filter (Only Real Coeffs) is calculated by transmitting STG tones at several offset frequencies
    // Then performing a fit on pre-calculated pole-based response to calculate least error coefficients
  FTM_ENH_INTERNAL_DEVICE_CAL_FBRX_DROOP_STG_CPLX_COEFFS = 1,
    // FBRx Droop Filter (Complex Coeffs) is calculated by transmitting STG tones at several offset frequencies
  // Then performing a fit on pre-calculated pole-based response to calculate least error coefficients
  FTM_ENH_INTERNAL_DEVICE_CAL_FBRX_DROOP_MOD_REAL_COEFFS = 2,
    // FBRx Droop Filter (Only Real Coeffs) is calculated by transmitting a modulated signal on the Tx path
  // FBRx capture is performed on a bypass path that connects FBRx to Tx DAC directly
  // Optimum Coefficients are found through some sort of Least Squares method
  FTM_ENH_INTERNAL_DEVICE_CAL_FBRX_DROOP_MOD_CPLX_COEFFS = 3,
    // FBRx Droop Filter (Complex Coeffs) is calculated by transmitting a modulated signal on the Tx path
    // FBRx capture is performed on a bypass path that connects FBRx to Tx DAC directly
    // Optimum Coefficients are found through some sort of Least Squares method
  FTM_ENH_INTERNAL_DEVICE_CAL_FBRX_DROOP_MAX = 4,
  // Invalid Entry
} ftm_enh_internal_device_cal_fbrx_droop_cal_method_type;

typedef PACK(struct)
{
  uint8 device_mask;
  uint8 num_gain_states; // number of gain states
  uint8 gain_states[MAX_NUM_RSB_GAIN_STATES];
  ftm_rsb_result_data_type rsb_res[FTM_ENH_INTERNAL_DEVICE_CAL_RSB_RES_MAX][MAX_NUM_RSB_GAIN_STATES];
} ftm_enh_internal_device_cal_rsb_result_type;



/*----------------------------------------------------------------------------*/
/*!
  @brief
  Structure template for Internal_Device_Cal_FB_Droop Instruction.

  @details
  Contains the FB Droop Internal Cal  instruction (Payload)
*/
typedef PACK(struct)
{
  ftm_enh_internal_device_cal_fbrx_droop_cal_method_type cal_method; 
  // fbrx droop cal method to use

  uint8 tx_device; 
  // Tx Device to use for FTM_ENH_INTERNAL_DEVICE_CAL_DROOP_MOD; need to set up the bypass path and fbrx depending on tx_device

  uint8 fbrx_gain_state;
  // not needed since gain and filter response are independent

  uint8 num_captures;
  // number of IQ captures to perform, whether STG or PA bypass; each STG capture will be performed on different offsets indicated by freq_list

  int32 stg_offset_khz[MAX_FREQ_OFFSETS_STG_IQ_CAP];
  // 16 possible STG freqs to capture and calibrate with, only first 'num_captures' are going to be valid

  uint16 num_iq_samples; 
  // number of IQ samples for each of num_captures captures

  uint8 do_processing;
  // enable processing to calculate Droop Filter coeffs, turn off to get captures only (for verification purpose)

} ftm_enh_internal_device_cal_instr_payload_fb_droop_type;

/*----------------------------------------------------------------------------*/
/*!
  @brief
  Structure to hold FB Droop calibration Data
*/
typedef PACK(struct)
{
  /* jmf: define fbrx droop cal FTM response, 12/30/13*/
  /* int16 band; */
  // fbrx droop is only tech dependent, no dependency on band
  // uint8 device_mask;
  // Does this device_mask have both tx/fbrx connotation? 
  // there is only one fbrx device, so no ambiguity is present regarding device and this field can be removed?
  uint8 fbrx_gain_state; 
  // not needed since gain and filter response are independent
  uint8 num_filters;  // can be up to 4 (MAX_NUM_DROOP_FILTERS_GEN_PER_SWP)
  // For LTE5/10, Only LTE10 capture is needed
  // For LTE15/20, Only LTE20 capture is needed
  // So for LTE10/LTE20 each, there are two sets of coeffs returned LTE5/10 and LTE15/20
  // This will be only 1 for other techs
  ftm_fbrx_droop_result_data_type fbrx_droop_res[MAX_NUM_DROOP_FILTERS_GEN_PER_SWP];
  // fbrx droop cal results structure containing 
  //   - tech-specific fbrx mode that has been internally written to NV
  //   - 32 FIR tap coefficients that have been internally written to NV

  uint32 stg_tone_pwrs[MAX_FREQ_OFFSETS_STG_IQ_CAP];
  // Raw tone powers from STG offset captures used to calculated filter coeffs

} ftm_enh_internal_device_cal_fb_droop_result_type;


//=================internal_cal_group_delay ===========================//

/*----------------------------------------------------------------------------*/
/*!
  @brief
  Structure template for Internal_Cal_Group_Delay Instruction.

  @details
  Contains the Group Delay Internal Cal  instruction (Payload)
*/
typedef PACK(struct)
{
  //
  //   ......
  //
  // uint16 device_mask; // rx  path mask
   int32 offset; // offset from the ref chan
   uint8 num_of_carrier; //Number of Carrier, 1 for PCell only, 2 for PCell and SCell, Extendable to other number for future increasing of number of WTR, 
   uint8 iq_capture_type;
   uint32 iq_sample_size;   
} ftm_enh_internal_device_cal_instr_payload_group_delay_type;

/*----------------------------------------------------------------------------*/
/*!
  @brief
  Structure to hold Internal_Cal_Group_Delay Data
*/
typedef PACK(struct)
{
  // to be determined......
  int16 band;
} ftm_enh_internal_device_cal_group_delay_result_type;



//=================internal_cal_IP2 ===========================//

/*----------------------------------------------------------------------------*/
/*!
  @brief
  Structure template for Internal_Cal_IP2 Instruction.

  @details
  Contains the IP2 Internal Cal  instruction (Payload)
*/
typedef PACK(struct)
{
  //
  //   ......
  //
  // to be determined......, added dummy structure to avoid off target compilation error
  // uint16 device_mask; // rx  path mask
   int32 offset; // offset from the ref chan
   uint8 num_of_carrier; //Number of Carrier, 1 for PCell only, 2 for PCell and SCell, Extendable to other number for future increasing of number of WTR, 
   uint8 iq_capture_type;
   uint32 iq_sample_size;   
} ftm_enh_internal_device_cal_instr_payload_ip2_type;

/*----------------------------------------------------------------------------*/
/*!
  @brief
  Structure to hold Internal_Cal_IP2 Data
*/
typedef PACK(struct)
{

  // to be determined......, added dummy structure to avoid off target compilation error
  int16 band;

} ftm_enh_internal_device_cal_ip2_result_type;


//=================internal_cal_DC ===========================//

/*----------------------------------------------------------------------------*/
/*!
  @brief
  Structure template for Internal_Cal_DC Instruction.

  @details
  Contains the DC Internal Cal  instruction (Payload)
*/
typedef PACK(struct)
{
  //
  //   to be determinded, ....added dummy structure to avoid off target compilation error
  //
  // uint16 device_mask; // rx  path mask
   uint8 num_of_carrier; //Number of Carrier, 1 for PCell only, 2 for PCell and SCell, Extendable to other number for future increasing of number of WTR, 
} ftm_enh_internal_device_cal_instr_payload_dc_type;

/*----------------------------------------------------------------------------*/




/*-------------------------------------------------------------------*/
/*!
   The following section define the internal_cal_data structure, including three members
   @ftm_internal_calibration_status_type internal_status
   @ftm_internal_calibration_config_data_type internal_cal_config
   @ftm_internal_calibration_result_data_type internal_cal_result

 */


/*----------------------------------------------------------------------------*/
/*!
  @brief
  Structure containing Internal Calibration status.
  
*/
typedef struct
{
 
  boolean is_active;
  /*! < Flag indicating internal cal is on processing */
  
  ftm_enh_internal_device_cal_status cal_status; // check with Chito
  /*! <Internal Cal Status */
 
  ftm_enh_internal_device_cal_error_code_mask error_mask;  /* !< bitMask indicating which internal cal type got error */

  ftm_enh_internal_device_cal_error_code_type error_log;   /*!< Structure to hold the error log. This  log will be used to send the status when result is sent back to PC side */

} ftm_enh_internal_device_cal_status_type;


/*----------------------------------------------------------------------------*/
/*! 
  @brief
  Structure containing the Internal Calibration configuration Data. 
*/
typedef struct
{
  uint8 dbg_mode_en; 
  /*!< Flag indicating the debug mode is enabled for Internal Cal.  */
  uint8 res_ver;

  uint16 flag;
  /*!< Flag reserved for future usuage */

  uint32 tot_instr_size;/*!< Total size of all instruction. */

  uint32 internal_cal_mask;/* !< Indicating the internal cal type mask */

  uint8  tech;         /* tech */  
  uint8  bw;  /* fbrx signal bandwidth */
  uint16 band;        /* <band */
  int32  ref_chan;     /* <reference channel */
  uint16 device_mask; /*!< common device mask that needs to do internal cal, individual internal cal type can over-ride it if needed*/ 
  
  uint8 instruction[MAX_ENH_INTERNAL_DEVICE_CAL_INSTR_SIZE];
   /*!< Internal_Calibration configuration parameter for the current request packet. */
  uint8 *read_node_payload_ptr;
  /*!< Pointer to traverse through various payload within the Current internal cal node */  
 
} ftm_enh_internal_device_cal_config_data_type;


/*----------------------------------------------------------------------------*/
/*!
  @brief
  Structure containing Internal Calibration Results Data.
*/
typedef struct
{
  uint16 res_max_len; 
  /* !< max allocated validation data length >*/
  
  uint8 result_rev;
  /*!< variable to indicate the result revision, not used for now */

  uint32 res_mask;
  /*!< indicating which results mask, currently will just support one  internal cal per request, reserved it for future use */

  uint8 *write_ptr;
  /*!< Pointer to traverse through Result Buffer, where results data is being written.*/


  uint16 total_result_sz;
  /* Actual Internal Cal results size because of unexpected failure on certain internal cal type */

  // uint32 internal_cal_type;
  uint8 buff_ptr[MAX_ENH_INTERNAL_DEVICE_CAL_RES_SIZE];
  /*! WE use array for internal cal results as current design used one internal cal type per request*/

  uint8 *rsb_calver_buff_ptr;
  /*! rsb_calver_response, only when flag=2 or flag=3*/

   uint16 rsb_cal_res_len;
  /* rsb_cal res length,  */

  uint16 rsb_cal_ver_data_len;
  /* rsb_cal ver data length */

} ftm_enh_internal_device_cal_result_data_type;



/*----------------------------------------------------------------------------*/
/*!
  @brief
  Structure containing Internal RF Calibration Configuration.
*/
typedef struct ftm_enh_internal_device_cal_data_type_t
{
  ftm_enh_internal_device_cal_status_type internal_device_cal_status;
  /*!< Structure containing current RF Calibration Sweep status. */
  
 // ftm_internal_calibration_info_type internal_cal_data;
  /*!< Structure to hold all information pertaining to current internal_cal */

  ftm_enh_internal_device_cal_config_data_type internal_device_cal_config;
  /*!< Structure containing the Calibration configuration Data. This 
  includes data related to linked list where all instruction configuration 
  is stored. */ 

  ftm_enh_internal_device_cal_result_data_type internal_device_cal_result;
  /*!< Structure containing RF Calibration Sweep Results Data */
} ftm_enh_internal_device_cal_data_type;


/*--------------------------------------------------------------*/
/* !
This section is for detailed internal cal process function call dispatch structure

*/

/* 
   Internal Cal Process Function Pointer 
*/

typedef boolean (*ftm_enh_internal_device_cal_process_fp)(
    void const *instr, uint16 *result_len, void *result  );




/*----------------------------------------------------------------------------*/
/*! Structure containing result buffer parameter */
typedef struct
{
  uint8 *buff_ptr;
  /*!< Pointer to the memory where each activated internal cal type should populate the results, 
  if present */

  uint16 buff_sz;
  /*!< buffer size of buff_ptr */

  uint16 res_len;
  /*!< Actual buffer size results for all activated internal cal type */

} ftm_enh_internal_device_cal_result_buffer_type;


/*----------------------------------------------------------------------------*/
/*! Table containing the dispatch data for each internal cal type */
typedef struct ftm_internal_device_cal_dispatch_info_type_t
{
  boolean validity;
  /*!< Flag indicating, if the entry is valid */

  ftm_enh_internal_device_cal_bit_type ic_bit;
  /*!< Internal Cal bit Type to indicate which internal Cal it is */

  ftm_enh_internal_device_cal_process_fp process_fp;
  /*!< Function pointer to be called when various internal cal type payload is to be processed 
     */

  uint8 *payload_ptr;
  /*!< Pointer to the memory which contains each internal cal type payload */
  
  ftm_enh_internal_device_cal_result_buffer_type res_buff_info;
  /*!< Structure containing information related to results buffer */
  
} ftm_enh_internal_device_cal_dispatch_info_type;



	
ftm_rsp_pkt_type
ftm_enh_internal_device_calibration
(
	  void *ftm_req_data
);


ftm_enh_internal_device_cal_error_code_type
ftm_enh_internal_device_calibration_push_instruction
(
  uint16 instr_size,
  uint8 *instr_ptr
);


ftm_enh_internal_device_cal_error_code_type
ftm_enh_internal_device_calibration_configure
(
  ftm_enh_internal_device_cal_req_pkt_type* header
);


ftm_enh_internal_device_cal_error_code_type
ftm_enh_internal_device_calibration_unpack_instruction
(
  void
);

ftm_enh_internal_device_cal_error_code_type
ftm_enh_internal_device_calibration_process
(
  void
);

void
ftm_enh_internal_device_calibration_clear_result_buffer
(
  void
);
	

/*----------------------------------------------------------------------------*/
ftm_rsp_pkt_type
ftm_enh_internal_device_calibration_send_results
(
  void *ftm_req_data
);
	
/*---------------------------------------------------------------------------*/
/* 
    This section define internal cal process functions
  
*/	
	
boolean ftm_enh_internal_device_cal_group_delay
(
  void const *group_delay_instr,
  uint16 *res_len,
  void *group_delay_result 
);
	
boolean ftm_enh_internal_device_cal_fb_ip2
(
  void const *ip2_instr,
  uint16 *res_len,
  void *ip2_result 
);
	
/*--------------------------------------------------------------------------*/
/*
   Internal cal Initialization function

*/




void 
ftm_enh_internal_device_calibration_data_init
(
  void
);
	



/*
boolean ftm_enh_internal_device_cal_fbrx_iq_capture
(
	uint8 tech, 
	uint16 sampleSize, 
	int32* fbrx_iq_data_pointer
);*/
ftm_enh_internal_device_cal_error_code_type ftm_enh_internal_device_cal_fbrx_iq_capture
(
   ftm_rf_technology_type ftm_rf_tech,                        // FTM RF Tech
   ftm_cal_xpt_instr_payload_iq_capture_type * iq_cap_instr,  // IQ Capture Instruction Pointer
   uint8  * cap_buf_id,                                       // Buffer Index where Samples are available
   uint8 debug_mode_en,                                       // Debug Mode Flag, to save samples to EFS
   char * filename                                            // In Debug Mode, use this filanema to save EFS dump
);

ftm_enh_internal_device_cal_error_code_type ftm_enh_internal_device_cal_fbrx_fastmulti_iq_capture
(
   ftm_rf_technology_type ftm_rf_tech, 
   ftm_cal_xpt_instr_payload_iq_capture_type * iq_cap_instr_ptr, 
   uint8  * cap_buf_id_ptr,
   uint32 * samp_rate
);

ftm_enh_internal_device_cal_error_code_type ftm_enh_internal_device_cal_fbrx_iq_cap_config
(
   ftm_rf_technology_type tech,
   uint8 bw
);

ftm_enh_internal_device_cal_error_code_type ftm_enh_internal_device_cal_fbrx_iq_cap_deconfig
(
  ftm_rf_technology_type ftm_rf_tech
);

uint16 ftm_convert_tech_bandnum_to_fbrxnv_band_type(ftm_rf_technology_type fbrx_tech, uint16 fbrx_band);

/*----------------------------------------------------------------------------*/
/*!
  @brief
  Type/Size of CRC used for Calibration packet validation
*/
typedef uint16 ftm_enh_internal_device_cal_packet_crc_type;




#ifdef T_WINNT
#error code not present
#endif

#ifdef __cplusplus
}
#endif

#endif /* FTM_COMMON_ENH_INTERNAL_DEVICE_CAL_H */




