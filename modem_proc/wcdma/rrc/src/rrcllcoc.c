/*===========================================================================

                    L3 - RRC Lower Layer Controller Ordered Config

DESCRIPTION
  This file contains functions necessary for the RRC Lower Layer Controller
  Ordered Config Processing.

  The functions that are to be called from external modules are:

  - rrcllc_set_ordered_config(rrc_state_e_type next_state,
                              uint8 dl_sdu_num, void *msg_ptr)

    This function takes a pointer to the ASN.1 decoded message, the next
    state, and the downlink SDU number as parameters. It then fills in the
    ordered config database. After the order config data base is filled in,
    status is then returned to the calling function as to the success
    or failure to fill in the ordered config database.

    The return type is of type rrcllc_oc_status_e_type. This indicates
    if ORDERED_CONFIG is set and if not, what the current failure
    status is. The calling procedure then needs to act accordingly.

    Once ORDERED_CONFIG is set, rrcllc_channel_config() is called with
    LLC using the newly programed data to configure the lower layers with
    ORDERED_CONFIG.


    * Idle-Disconnected to Idle-Connecting

    ************ Procedure calls rrcllc_chan_config_req() *************
    1) Copy SIB5 data to CURRENT_CONFIG (Note SIB5 data is already in
       CURRENT_CONFIG, courtesy the PCH setup), unless a SIB change
       has occurred.
    2) Config Lower Layers (via primitives with CURRENT_CONFIG_PTR),
       note this is for PRACH/RACH/CCCH Uplink only, while enabling
       FACH Transport blocks, i.e. RLC-UL, MAC-UL, and PHYCHAN-PRACH.
    3) Wait for Lower Layer confirms
    4) Send Channel Confirm to RRC Connection Establishment

    * Idle-Connecting to CELL_DCH

    ************ Procedure calls rrcllc_set_ordered_config() **********
    1) ORDERED_CONFIG = CURRENT_CONFIG
    2) Extract OTA Msg IEs and overwrite those values included in Msg.
    3) ordered_config.set_status = OC_SET_FOR..
    ************ Procedure calls rrcllc_chan_config_req() *************
    1) Config Lower Layers (via primitives with ORDERED_CONFIG_PTR)
    2) Wait for Lower Layer confirms
    3) Change State (to CELL_DCH)
    4) Send Channel Confirm to RRC Connection Establishment
    *********** Procedure calls rrcllc_clear_ordered_config() *********
    1) ordered_config.set_status = OC_NOT_SET
    2) CURRENT_CONFIG_PTR = ORDERED_CONFIG_PTR
    ************ Receive an RB Setup msg & stay in CELL_DCH ***********
    ************ Procedure calls rrcllc_set_ordered_config() **********
    1) ORDERED_CONFIG = CURRENT_CONFIG
    2) Extract OTA Msg IEs and overwrite those values included in Msg.
    3) ordered_config.set_status = OC_SET_FOR..
    ************ Procedure calls rrcllc_chan_config_req() *************
    1) Config Lower Layers (via primitives with ORDERED_CONFIG_PTR)
    2) Wait for Lower Layer confirms
    3) Change State (to CELL_DCH)
    4) Send Channel Confirm to RB Setup
    *********** Procedure calls rrcllc_clear_ordered_config() *********
    1) ordered_config.set_status = OC_NOT_SET
    2) CURRENT_CONFIG_PTR = ORDERED_CONFIG_PTR


    * Idle-Connecting to CELL_FACH

    ************ Procedure calls rrcllc_set_ordered_config() **********
    1) ORDERED_CONFIG = CURRENT_CONFIG
    2) If SIB change Overwrite ORDERED_CONFIG with SIB5 updates.
    3) Extract OTA Msg IEs and overwrite those values included in Msg.
    4) ordered_config.set_status = OC_SET_FOR..
    ************ Procedure calls rrcllc_chan_config_req() *************
    1) Config Lower Layers (via primitives with ORDERED_CONFIG_PTR)
    2) Wait for Lower Layer confirms
    3) Change State (to CELL_FACH)
    4) Send Channel Confirm to RRC Connection Establishment
    *********** Procedure calls rrcllc_clear_ordered_config() *********
    1) ordered_config.set_status = OC_NOT_SET
    2) CURRENT_CONFIG_PTR = ORDERED_CONFIG_PTR

  - rrcllc_clear_ordered_config(void)

    This function will clear(reset) the ordered_config_status flag. It also
    swaps the ordered_config_ptr and current_config_ptr.

    The following steps occur:
    1) ordered_config.set_status = OC_NOT_SET
    2) temp_ptr = current_config_ptr
    3) current_config_ptr = ordered_config_ptr
    4) ordered_config_ptr = temp_ptr

  Functions that can be called from other rrcllc modules are:

  - rrcllc_init_ordered_config()

    This function is called by rrcllc_init(). This function initializes
    the ordered config and current config pointers and data inside
    the ordered config and current config data bases.

  - rrcllc_copy_sib_to_oc(rrc_SysInfoType5 *sib5_ptr,
                          rrc_state_e_type next_state)

    This function copies data from the SIB data base to the ordered
    config data base. It also performs the SCCPCH, PRACH and the
    Access Service Class Establishment selection that is required in RRC.

   *********************************************************************
   ***************** Other Assumptions in the code *********************
   *********************************************************************
   - There is no support for TDD, DRAC, PDSCH, or CPCH.

   - CELL_PCH and URA_PCH states are not supported.

   - Ciphering and Integrity Protection IEs are not processed now.

   - Dynamic TTIs are only for TDD,; however it is not clear in the
     spec; hence, we will error fatal in the code.

   - Only the first PRACH in the SIB 5 PRACH list is supported.

   - Only the first SCCPCH in the SIB 5 SCCPCH list is supported.

   - No PRACH and SCCPCH selection algorithms are used. In other words
     they have been coded but not tested.

   - Since only 1 PRACH and SCCPCH are supported, there is no support for
     reading the info from the previous entry in the list for the various
     IEs as stated in 25.331. 25.331 indicates that for optional present
     IEs, the first is mandatory, and if not present for others in the loop
     (1 to MAX_PRACH or 1 to MAX_SCCPCH) use the previous value. Since only
     the first is used, the remaining has not been implemented.

   - Only UE_MAX_TFC, UE_MAX_TF, and UE_MAX_TRCH are supported. All values
     not in these ranges are ignored.

Copyright (c) 2000-2009 Qualcomm Technologies, Inc.  All Rights Reserved.
QUALCOMM Proprietary.  Export of this technology or software is regulated
by the U.S. Government. Diversion contrary to U.S. law prohibited.
===========================================================================*/


/*===========================================================================
                      EDIT HISTORY FOR FILE

This section contains comments describing changes made to this file.
Notice that changes are listed in reverse chronological order.

$PVCSPath:  L:/src/asw/MSM5200/RRC/vcs/rrcllcoc.c_v   1.63   12 Jul 2002 09:17:04   djm  $
$Header: //commercial/MPSS.JO.2.0.c1.4/Main/modem_proc/wcdma/rrc/src/rrcllcoc.c#1 $ $DateTime: 2016/12/13 08:00:12 $ $Author: mplcsds1 $

when       who      what, where, why
--------   ---      ----------------------------------------------------------
06/20/16   sp      Made changes to reduce F3s
05/11/16   nr      Adding log packet for hanging RB 
05/09/16   nr      Made changes to reduce F3 in get_am_index function
03/29/16   nr      Made changes to fix KW error
03/21/16   ha      Made changes to return valid parameters when UL queries rrc_ul_tx_pwr_ind() during reselection scenario
02/08/16   nr      CR973374: Made changes to not allow LTA if delay restriction IE is set
10/16/15   as      Added code to support LTA durting activation time
09/11/15   sr      Made changes for FR29345 EFS/NV Settings to be Read per Sub
06/29/15   sp      Made changes to reset hspa_rnti flag if mac-d flow ID 7 is configured for SRBs
05/06/15   bc      Made changes to configure WL1 with DRX cycle length of 2.56 seconds when
                   SIM is not yet inserted.
03/18/15   ad      Made changes to pick to ac to asc info from sib5 if missing in sib6.
02/23/15   sg      Made changes to pick edch size if dch size is not configured by network
01/21/15   sa      Made changes for QTF with CRM
12/24/14   sp      Made changes not to include AGCH add mask for non-serving RLs
11/14/14   sp      Made changes to compute fixed rlc_size correctly for EDCH cases.
10/16/14   sp      Made changes to copy HRNTI to TOC for PCH state transition
10/11/14   sg      Made changes to add validations for 3C window size
10/07/14   aa      Included a new function rrcllc_check_if_rb_mapped_on_macehs_q_for_efach for the RB mapping checks in MACEHS passed config pointer for EFACH
10/01/14   sp      Made changes to set HSPA RNTI flag to false so that UE triggers CU instead of MR so that start value is sent to the network
09/30/14   sp      Made changes to store HRNTI in TOC if HSPA RNTI in cell pch is true
09/05/14   sp      Made changes to detect UL size change for fach to pch transition before sending 
                   RB complete to facilitate inclusion of start valu
09/05/14   as      Made changes to log events for inter freq HHO status
08/14/14   sp      Made changes to set ready for edch transmission flag whenver 
                   common edch transmission flag is set to TRUE.
08/08/14   sg      Made changes to check URNTI in TOC also if it is not 
                   present on config ptr in use
08/04/14   sp      Made changes to fix compilation errors
07/28/14   sg      Made changes to include code comments for delay CU
07/25/14   sg      Made changes to support band II for 
                   single carrier 3C
07/24/14   sp      Made changes to replace memcpy with safer macro WCDMA_MEMCPY
07/18/14   ad      Made changes to reduce F3s
07/15/14   ac      NV reorganization
12/30/13   sg      Made changes to add initialization of local variables and bound conditions 
                   to access array to avoid warnings and invalid memory access. 
06/19/14   sg      Made changes to revert the cipher config db if cipher config type is
                   updated to step1 but later message validation failed.
06/20/14   db      Mainlined FEATURE_WCDMA_HS_RACH_DELAY_CU and introduced NV control
06/17/14   sp      Made changes to mainline DCH-FACH transition optimization changes
06/17/14   sp      Made changes to mainline RLC-restablihment redesign changes
06/16/14   db      Made change to detect size change during fach to fach redirection
06/09/14   as      Made changes to reset the hs-action if OTA message processing fails
06/04/14   as      Made changes for DCH-FACH transition time optimization
06/02/14   sp      Made changes for FR19997 - UL rlc re-establishment redesign
05/20/14   sp      Made changes to retain the predef_po3_status
05/20/14   sp      Made changes to delete ERNTI while coming out of cell_PCH state when hspa_rnti_stored_in_pch flag is false
05/19/14   vg      Made changes to send HO_START only when voice HHO is triggered.
05/15/14   sp      Made changes to avoid accessing null pointer while accessing hsdpa_l1_info.
05/14/14   ymu     Feature name FEATURE_WCDMA_DC_HSUPA_FRAME replacement with FEATURE_WCDMA_DC_HSUPA 
05/06/14   geg     Use safer versions of memcpy() and memmove()
18/04/14   ad      Made changes to adaptively calcualte T304 for GCF TCs
04/10/14   db      Made changes to enable/disable feature support in DSDS/DSDA/TSTS modes through NV
04/07/14   as      Changes are made to do hsrach-init before restoring from TOC for FACH to DCH
04/02/14   vg      Made changes to Systematically log all the internal and external primitive handled in RRC and corresponding top level action.
04/01/14   sp      Fixed KW errors
03/06/14   sg      Made changes to reject the config if ehs window size
                   is not compatible with TSN extn.
02/04/14   sg      Made code changes for 3C for latest interface
03/06/14   sg      Made changes to reject the config if ehs window size
                   is not compatible with TSN extn.
03/14/14   sp      Made changes to init cm ota params in rrcllc_init_before_msg_processing() 
03/13/14   db      Made changes to skip uplink size detection when next state is non-DCH
03/13/14   sp      Removed code under FEATURE_WCDMA_HS_PCH feature flag
02/13/14   ad      Made changes to remove redundant F3s
03/08/14   vg      Made changes to reduce the stack size usage of some RRC functions which has the usage more than 500 bytes.
01/22/14   ad      Made changes to reestablish DL and UL both even if one-sided reestablishment
                   flag is FALSE
01/15/14   sp      Fixed compiler warnings
01/09/14   sp      Removed code under FEATURE_CS_VOICE_OVER_HSPA feature
02/01/14   sp      Made changes to avoid crash while setting TVI in CU when Mac is waiting for L1 signal.  
12/24/13   sp      Made changes to avoid determining efach action twice for reselection case.
12/19/13   db      Made changes to configure lower layers properly and detect size re-establishment for SIB5 change
11/08/13   ad      Made changes to indicate ho_type as part of codec info to CM
12/12/13   rmn      Mainlined feature flag FEATURE_INTERRAT_HANDOVER_GTOW
12/12/13   sp      Made changes to provide ul tx ind validation status to TRUE
12/03/13   sg      Made changes to update review comments for 3C
11/22/13   sp      Made changes to check dcch fach mappings for SRBs individually and added checks for user RBs
11/20/13   ad      Made changes to not reset predefined preset status flag after GtoWHO until 
                   PO3 is explicitly indicated by NW
11/18/13   db      Made changes to configure mappings upon DCH to PCH transition to allow TVI to be set
11/14/13   sa      DC feature support will be controlled thru UE Cat
11/13/13   sa      Mainline the changes FEATURE_MVS_UNDER_GHDI
11/07/13   db      Made changes to check for mapping and ERNTI in Connection setup for HSRACH
10/30/13   as      Made changes to add feature code for FEATURE_WCDMA_3C_HSDPA
10/21/13   vg      Made changed to Accept reconfiguration which asks UE to use (MACi/is, DCH) and reject reconfiguration only with (MACi/is, MAChs).  
10/17/13   ad      Changes for DC HSDPA feature with 3C interface
10/10/13   ad      Made changes to init the reestablish entity during RL failure 
                   and also during clearing procedure
10/09/13   sp      Added changes for rel-10 ASU message that were missed in the rel 10 signalling changes
10/07/13   db      Made changes to configure downlink properly upon PCH to FACH thorugh MR
09/16/13   mp      Added code for REL10 signalling under feature FEATURE_WCDMA_REL10
08/26/13   ad      Made changes to provide CTCH indicator on the correct FACH index to MAC
07/25/13   sg      Made changes to reset OC when intitate CU is received
                   when CU is waiting for RB1_RB4_EST_CNF and copy rlc params to 
                   CC from toc in chan_config_within fach fr RL failure
07/23/13   db      Made changes to ignore flow-ID check for SRB's and user RB when cell update is triggered
07/16/13   vi      Made changes to read GPS-cell id on HS serving cell if HS is active
07/08/13   ad      Made changes to remove redundant F3s
06/12/13   ad       Made changes to configure from OC when cell update confirm takes to 
                    PCH state and OC is set.This will remove the use of 
                    RRCLLC_CHAN_CFG_EPCH_HRNTI_ONLY cause.
06/14/13   db      Added backup and restore ERNTI logic for transition to(out of) PCH state
06/13/13   db       Made changes to ignore mapping check for released RB's
06/05/13   db       Made changes to restore EDCH_EHS mappings when camped cell supports HSRACH
05/21/13   db      Made changes to check for flexible size in OC for DCH to FACH scenario
05/22/13   sa       Added code changes to support FEATURE_WCDMA_DC_HSUPA
05/15/13   vg       Removed code under compiler flag FEATURE_WCDMA_RLC_DL_SIZE_CHECK.
05/15/13   as       Made changes to pass whether PO3 is signalled or pre-set
05/08/13   db       Multiple mapping support for EFACH
04/25/13   sg       Added code for REL9 under FEATURE_WCDMA_REL9
04/24/13   ad       Made changes to configure hsrach dedicated mode during reselection.
                    Made changes not to reset hsrach actions in OC if OC is set when RRCLLC_CHAN_CFG_EPCH_HRNTI_ONLY
                    cause is used.
03/28/13   db       Cleared redirection info in OC before processing OTA
03/28/13   db       Decremented DL tm Channel(BCCH:GPS) in TOC upon transition out of DCH state
03/18/13   db       set HRNTI status in OC to DEDICATED when DCH FACH cell selection timer expires
03/14/13   md       Made changes to provide active subscription ID to NAS APIs for DSDA
03/13/13   db       Made changes to clear CRNTI in CC during PCH to FACH transition
03/06/13   ad       Added prints to print CRNTI on PCH->FACH and FACH->PCH transition
                    Removed redundant F3s
02/11/13   ad       Made changes to reset the hsrach action when channel configuration is from CCM and
                    next state is fach or connecting. Made changes not to determine
                    hsrach action when configuration of dedicated mode fails.
02/04/13   ad       Moved the place to print the hs info
02/01/13   db       Made changes to clear HRNTI for HSFACH to DCH(non-HS) case
01/25/13   sa      Made changes for TM loop back mode under FEATURE_TM_LB
01/22/13   vi       Made the changes to move out ul_pdu_type based on the eul is active or not
18/01/13   ad      Made changes not force reset the mac_hs_reset_indicator 
                   for efach to hs transition
11/01/13   ad      Added featurization for MVS code
09/01/13   ad      Added featurization for MVS code
01/03/13   ad      Made changes to reduce the redundant F3s
01/02/13   as      Made changes to copy the CCTRCH-ID from CC to OC for connecting to DCH transition
12/18/12   mp      Removed the extra copy cc to oc during RL failure.
12/17/12   mp      Fixing KW errors
12/12/12   mp      Fixing KW errors
12/10/12   sa      Made the changes to update copy_sib_to_oc_for_hsrach for connecting to fach state
12/04/12   ad      Made changes to send start of SRVCC indication to CM 
11/28/12   db       Made changes to determine the hspa_rnti_stored_cell_pch flag based 
                    on if CRNTI is provided in the OTA message or not
11/02/12   db      EFACH Redesign changes to handle SysInofChange Indication
10/26/12   db      EFACH Redesign changes
10/25/12   ad      Made changes to deactivate the CM patterns which are not configured
                   in the message which does a timing re-initialized HHO
10/23/12   pm      Made changes to assign pointer to NULL after de-allocation
10/18/12   sg       Added checks for current and ordered hanging RBs before accessing them
10/19/12   sg      Made changes for Rel 9 migration, removing unsupported IEs and ZI reductions. 
10/04/12   md      Made changes to detect RLC size change during state transitions via CELL PCH state.
10/04/12   pm      Removed unnecessary comments
10/03/12   pm     Made changes to initialize hsrach structure while going to disconnected
                  and DCH state. Checking for mappings only if ERNTI is valid.
                  Copying ERNTI from HSRACH structures to Legacy structures on FACH
                  to DCH transition only if there is a valid ERNTI in CC. Making ERNTI
                  invalid if cell doesnt support HSRACH
09/28/12   mp    Made the change to check the missing rb mapping info for eFACH cell 
09/28/12   sa     Made the changes to reset the eul req mask in FACH state while waiting for state change indication
09/27/12   db     Made changes to determine hsrach action if cell doesnt support hsrach
09/26/12   pm      Made changes to reset the ordered codec when procedure is cleared
09/02/12   sg      Made changes to provide an API for dl amr mode value.
08/29/12   sa      Made changes to detect missing RB mapping info in CELL_FACH state
08/17/12   sa      Made the changes to check ul edch flexible size only for edch is active
08/15/12   sa     Made the changes not to do EF for cell reselections from HSRACH to non HSRACH
08/14/12   db     Made changes to use common_edch_transmission variable from CC while determining 
                   hsrach action
08/14/12   as      Made changes to restore rlc size list for rach
07/20/12   ad       Made changes to do rlc-reestablishment during reselections.
17/07/12   ad      Changes for handling RRCLLC_CHAN_CFG_REASON_RL_FAILURE
                   reason from CU
08/13/12   md      Made changes to take the SCCPCH config from SIB5 for CTCH setup if not present in SIB6
07/24/12   geg      Upmerge WCDMA.MPSS.1.0 to WCDMA.MPSS.2.0
07/11/12   ad      Changes for including the hsdpcch bitmask in 
                   cell_transition_req for a hsrach cell.Made changes 
                   to handle ERNTI correctly. Changes to avoid starting MAC
                   for a HSRACH to HSRACH SIB5 change.Increased the handing rb size.
11/07/12   ad       Made changes to handle ERNTI correctly. Changes to avoid starting MAC
                    for a HSRACH to HSRACH SIB5 change.Increased the handing rb size.
07/04/12   ad       Missed changes of HS-RACH
06/29/12   ad       Made changes for triggering CU if E-RNTI is not given.
                    Skipped the de-registration of WMs if HS-RACH is ON and RRC is 
                    triggering MR while coming out of PCH. Fixed bug to updated E-RNTI
                    in OC correctly. Added code to trigger CU if R99 or R5 CUCNF is received. 
                    Added code to keep L1 and MAC in sync wrt HS-RACH actions.
06/27/12   db       Made changes not to initialize RB mapping info in all cases
04/06/12   ad       Changes for HS-RACH feature
05/24/12   sks      Added support for QCHAT specific dynamic DRX.
05/18/12   db       Reverted changes to restore and backup EFACH mapping an queue info while coming out of PCH
05/10/12   md       Added code changes to support FEATURE_MAC_I
05/07/12   db       Made changes to restore and backup EFACH mapping an queue info while coming out of PCH
05/02/12   db       Made changes to delete common mac-ehs Queue from OC database when
                    UE moves from connecting to DCH
04/30/12   as       Added Null pointer access check while getting dl/ul data rate
04/12/12   as       Added code to support feature NB/WB handover support
03/07/12   db       Made changes to set the HRNTI bit mask properly during DCH->FACH transition
02/17/12   db       Fixed Compiler errors and warnings
02/03/12   mn       Added APIs to provide UL AMR and AMR-WB mode
12/30/11   ad       Resetting the flag rrciho_mvs_control_flag in rrc_save_mvs fn
01/08/12   md       Made changes to set DSCH bit mask in L1 request  MASK when 64QAM is configured
                    through active set update while HSDSCH action is active.
01/04/12   md       Fixed compilation errors for rel-9 to rel-10 asn migration.
12/28/11   ad       Made changes to bring the mvs code outside of qchat feature
12/28/11   sa       mainlined the FEATURE_WCDMA_CHECK_NAS_ACQUIRED_VOC
12/20/11   db       Made changes to restore dedicated queue after moving to DCH
12/12/11   gv       Added code to support free floating of tasks
12/08/11   db       Made changes to handle EFACH/EPCH support change in SIB5
12/08/11   db       Made changes to delete BCCH/PCCH mac-ehs mapping while moving to DCH
12/08/11   db       Made changes to trigger cell update if H-RNTI is missing 
12/08/11   db       Made changes to not invalidate hrnti status during dch to fach transtion
12/07/11   db       Made changes to invalidate common HRNTI if present before OTA processing
12/05/11   pm       Added code to support cell id request by CM in DCH state"
11/20/11   db       Made changes to backup and restore dedicated queue info
                    if queue id is same as in common queue
11/16/11   db       Made changes to set efach status to FALSE even if efach mappings are not given while
                    moving from efach to legacy pch
11/16/11   db       Made changes to reset mac_hs_reset_indicator at channel config cnf
11/16/11   db       Corrected a bug to use CC instead of OC in 
                    rrcllc_get_dc_hsdpa_action_in_config function
10/25/11   ad       Made changes to take the mac header into consideration
                    for calculation of UL data rate.
10/03/11   ad       Made changes to check for sCCPCH_SystemInformationListPresent
                    instead of prach_SystemInformationList in rrcllc_update_oc_for_resel
09/14/11   ad       Added code for FEATURE_WCDMA_CPC_DRX feature
08/26/11   rl       Fixed the KW error
08/16/11   rl       Merged with VU_MODEM_WCDMA_RRC.01.104.00
08/02/11   as       Made changes to restore HRNTI after DCH to FACH transition
07/05/11   rl       Merged with VU_MODEM_WCDMA_RRC.01.101.00
07/29/11   as       Made changes to reset rlc size list properly during unmap rb
06/22/11   ad       Made changes to update the rrciho_mvs_control_flag 
                    variable only when vocoder is acquired by WCDMA
06/21/11   rl       Merged with VU_MODEM_WCDMA_RRC.01.100.50
06/20/11   as       Made changes to update rnti info properly duirng
                    toc update with oc
06/15/11   ad       Fixed compilation error
06/14/11   ad       Made changes to remember that WCDMA has released MVS and 
                    uses the flag later to acquire MVS back for non-IHO cases
06/06/11   ad       Initialize the TOC nchan for UL and DL TM channels
                    on fach to pch transition with redirection. 
05/24/11   rl       Merged with VU_MODEM_WCDMA_RRC.01.98.50
05/18/11   ad       Added changes to include UM RBs also in channel config request 
                    from established rabs
05/03/11   rl       Fixed the lint error
04/26/11   rl       Merged with VU_MODEM_WCDMA_RRC.01.96.50
04/25/11   as       Fixed compilation issue because of featurization
04/21/11   as       Made changes to reject OTA if ordered code from OTA
                    is different from derived one
04/13/11   ad       On MVS release, WCDMA should deconfig MVS. 
04/13/11   ad       Fix the compilation errors for Qchat changes
04/13/11   ad       Fix the compilation errors for Qchat changes
04/13/11   ad       Changes to address the rate change issue for voice call
                    Qchat media concurrency scenarios
03/28/11   rl       Merged the HS-FACH/PCH changes from mainline
03/14/11   rl       Merged with VU_MODEM_WCDMA_RRC.01.93.50
03/09/11   ad       Made changes to indicate the correct Max datarate for cat above 19 
03/09/11   su       Made changes to mainline code under FEATURE_WCDMA HSUPA 2MS TTI.
02/15/11   rl       Merged with VU_MODEM_WCDMA_RRC.01.91.50
02/03/11   as       Made changes to do rnti validation for dch to fach/pch
                    transition when efach is enabled 
02/02/11   as       Fixed compiler warning
01/31/11   as       Made changes to update hs_req_mask in efach mode during 
                    cell reselection in connecting state
01/31/11   ad      Fixed compilation warnings
02/07/11   rl       Merged with VU_MODEM_WCDMA_RRC.01.90.50
01/28/11   rl       Fixed compilation error
01/28/11   rl       Merged with VU_MODEM_WCDMA_RRC.01.89.57
01/18/11   su       Fixed compilation warnings.
01/12/11   ad       Added changes for RRC SW decoupling
01/07/11   prk      Made changes to configure enhFACH in dedicated mode after 
                    SIB change indication in FACH state.
01/06/11   as       Made changes to delete commonn queue info while moving
                    to non EFACH cell or DCH state
01/05/11   prk      Fixed compilation error.
01/04/11   as       Made changes to set DL data rate for EFACH
01/12/11   rl       Migrated to VU_MODEM_WCDMA_RRC.01.88.50
12/30/10   prk      In e-fach mode PCCH and BCCH RBs will have same LC ID, to
                    differentiate made changes to pass rb-id as argument to function.
01/04/11   rl       Merged with VU_MODEM_WCDMA_RRC.01.87.50
12/20/10   prk      Made changes to init efach hs action in config DB after sending 
                    channel config cnf.
12/17/10   prk      Made changes to indicate RLC if network configures DL PDU 
                    sizes for AM.
12/15/10   kp       Added code to set BD action for cell reselection in ePCH.
12/13/10   kp       Added code to reset hs_pcch_info_valid  in all cases except BD.
12/10/10   prk      Modified the coditions to get mappings from TOC to OC after
                    redirection.
12/07/10   prk      During connecting to DCH transition, init num of UL trch. 
12/31/10   rl       Merged with VU_MODEM_WCDMA_RRC.01.86.50
11/23/10   kp       updated rrcllc_check_dcch_fach_mapping for eFACH 
11/22/10   prk      Skip setting e-fach status to TRUE if cell doesn't support 
                    enh-fach or enh-pch.
11/29/10   rl       Merged with VU_MODEM_WCDMA_RRC.01.85.50
11/19/10   prk      Removed queue id check for e-fach common mode.
11/12/10   prk      Removed queue id check for enh-pch blind decoding.
11/09/10   prk      Set hs_mode_in_e_pch to invalid in disconnected state. 
11/09/10   rl       Merged with VU_MODEM_WCDMA_RRC.01.84.50
11/04/10   su       Corrected the Typo from FEATURE_WCMDA_COMBINED_MIMO_AND_64QAM
                    to FEATURE_WCDMA_COMBINED_MIMO_AND_64QAM
11/02/10   su       Fixed Klocwork warnings.
10/25/10   prk      Set hs_mode_in_e_pch to invalid in ura_pch to fach transition. 
10/25/10   prk      Set hs_mode_in_e_pch to invalid in fach state. 
10/21/10   prk      Copy e-fach mapping from TOC after DCH to PCH transition.
10/21/10   prk      Fix for DCH to enh_pch transition.
10/21/10   prk      Determine HS state correctly after cell reselction.
10/13/10   su       Changed RRC_WCMDA_COMBINED_MIMO_AND_64QAM to 
                    FEATURE_WCMDA_COMBINED_MIMO_AND_64QAM
10/12/10   su       Fixed klockwork warnings
10/11/10   ss       ASN.1 migration to ASN1 9.3.0
10/08/10   su       Added code to support RRC_WCMDA_COMBINED_MIMO_AND_64QAM
10/08/10   prk      Fixes for e-fach calls.
10/04/10   prk      Added code to support FEATURE_WCDMA_HS_PCH.
10/04/10   prk      Merging latest e-fach fixes.
10/01/10   su       Fixed compiler warnings
09/24/10   kp       Implemented spec cr-4287 "Explicit HARQ Memory partitioning for dual cell operation"
09/23/10   kp       Added code to maintain status of Chan_config_req posted by CSP for sib5 change,
                    the status life time will be from where CSP post the cmd till LLC starts processing
09/17/10   kp       Fixed a typo in debug print in the function rrcllc_copy_trch_info.
09/17/10   kp       Made changes to take EUl TTI infor from TOC inot OC for FACH->DCH transition
09/20/10   prk/kp   Added code to support FEATURE_WCDMA_HS_FACH
09/17/10   su       Featurizing MVS related code
11/03/10   rl       Fixed compiler warnings
10/30/10   rl       Objective systems migration changes check in 
                    on code base VU_MODEM_WCDMA_RRC.01.80.00
09/13/10   prk      When RB has no transport channel mapping, RLC pdu size will be -1, 
                    in such a case use previous RLC PDU size from CC.
08/27/10   rm       Made changes to index SIB with correct SIB type
08/02/10   prk      Made changes to initialize L1 dl common opt params bitmask 
                    when moving to non-DCH state.
08/02/10   kp       Dont init E_TTI in OC l1_e_info as it hold trch parm whcih UE need to remeber.
07/21/10   kp       Bug fix in EUL to init E_TTI in OC l1_e_info. This is needed in case of any 
                    OTA config which start EUL firt time that fail due to invalid config mac db 
                    will not be updated properly for E_TTI for next OTA message that starts EUL.
07/14/10   su       Fixed Lint errors.
06/29/10   rm       Added code to support LTE<->WCDMA Inter RAT
06/18/10   dm       Fixed compilation warnings.
06/07/10   ss       Added code to reset SVTHHO in case of failure message
06/03/10   gkg      Made changes to implement Spec CR3955 "Carrier-specific STTD configuration 
                    for DC-HSDPA". Changes are under feature FEATURE_WCDMA_DC_HSDPA_DIFF_TXD_MODE
05/24/10   kp       Added code for feature CPC-DRX under feature flag FEATURE_WCDMA_CPC_DRX
05/07/10   prk      Fixed compiler warnings.
05/04/10   gkg      Made changes to initialize DL CTFC properly.
04/30/10   kp       Added code to backup & restore RNTI properly in rrcllcoc_update_toc_with_oc_from_fach() 
04/15/10   gkg      Made changes for processing MIMO Codebook Restriction.
04/07/10   gkg      ASN.1 migration to 8.a.0
04/28/10   gkg      Made changes so that while copying MAC-EHS info from TOC to OC for 
                    FACH->DCH transition, copy the logical channel info completely.
04/26/10   ss       Added code changes for Fast Dormancy feature under feature flag
                    FEATURE_3GPP_FAST_DORMANCY
04/08/10   gkg      Changed NAS API name from ghdi_has_nas_already_acquired_voc to 
                    mn_has_nas_already_acquired_voc()
04/01/10   gkg      Un-featurize function rrcllc_get_config_ptr_in_use().
03/19/10   gkg      Made changes to invalidate the OTA if memory partitioning
                    is given explicitly for DC-HSDPA operation.
03/19/10   gkg      Made changes to invalidate the OTA if no. of HARQ processes
                    configured for each HS-DSCH stream isn't 6 to 8.
03/19/10   gkg      Made changes to invalidate the OTA if TxDiversity CLTD is being
                    used with DC-HSDPA operation.
03/17/10   gkg      Made changes to populate Secondary C-PICH Power Offset 
                    from R7 and R8 OTAs for MIMO UEs.
03/17/10   as       Resolved Errors due to ASN.1 8.9 Migration
03/15/10   as       Updated RRC Code to support ASN.1 8.9 version
03/15/10   gkg      Made changes to put changes for "Multiple DRX Cycles" and 
                    "CU wait Timer" under feature R7. 
03/10/10   gkg      Featurize the Opt Timer changes under feature FEATURE_CS_VOICE_OVER_HSPA.
02/01/10   dm       Made changes for returning DRX cycle length for multiple DRX support feature.
02/11/10   gkg      Made changes for Opt Timer for CSoHS.
02/08/10   dm       Made changes to not clear config db if it is NULL.
01/22/10   ss       Added code to take backup of MAX HFN for CS RB's before HHO Step-1 
                    and later use that backup to calculate START_VALUE_TO_TRANSMIT for CS domain.
12/24/09   gkg      Made changes so that Standalone DCHs are checked while performing
                    the validation for UL/DL TFCS against added/deleted UL/DL DCH TrCHs.
12/21/09   gkg      Made changes for CSoHSPA under feature FEATURE_CS_VOICE_OVER_HSPA.
12/01/09   dm       Added code to send Schedule Period Offset to BMC as part of 
                    FEATURE_UMTS_BMC_ENH_SCHEDULE. Made changes to ignore CTCH configuration present in SIB6 
                    and use the info contained in SIB5 in connected mode.
11/10/09   gkg      Made changes to initialize the MAC-ehs Queue DB when a MAC-ehs 
                    queue is added or deleted.
10/05/09   ps       Fixed Klockwork warnings
10/12/09   kp       If N/W is providing AGCH info for non EUL serving RL then don’t 
                    indicate add/reconfig action to L1, since AGCH makes sense 
                    only for serving RL.
10/07/09   gkg/kp   Changes for REL8 under FEATURE_WCDMA_REL8 and CPC-DTX
09/03/09   ps       Made changes for EDPCCH power Boost under 
                    FEATURE_WCDMA_REL7_EDPCCH_POWER_BOOST
09/01/09   ps       Changed has_nas_already_acquired_voc() to 
                    ghdi_has_nas_already_acquired_voc() according to NAS requirement
08/17/10   ps       Made changes FEATURE WCDMA CHECK NAS ACQUIRED VOC to acquire
                    the vocoder during Codec change only if NAS had acquired it before
                    i.e. the the NAS level signalling to connect a voice call is already
                    done
07/30/09   gkg      Made changes to handle the corner scenario when L1 triggers OOS 
                    IND just after UE has recovered from OOS due to RLF/RLC unrecoverable 
                    error.
07/21/09   dm       Made function rrcllc_update_configs_with_sib7_info_in_fach
                    independent of any feature flag.
07/16/09   kp       Added code to change the enum member name CM_NONE to RRC_CM_NONE in 
                    rrcllc_cm_status_e_type as it was conflicting with MS VS 2005.NET 
                    which is needed for RRC UTF.
06/23/09   gkg      Made changes so that HSDPA action isn't overwritten in the case
                    when MAC-EHS <-> MAC-HS mapping change happens alongwith stopping 
                    of HSDPA.
06/05/09   ps       Made changes to change MODEM_MEM_CL_WCDMA….to 
                    MODEM_MEM_CLIENT_WCDMA_.. accordinf to memory team requirement
05/25/09   ps       Made changes for EDPCH interpolation support
05/22/09   ps       Fixing  lint warning when FEATURE SUB LCID MACEHS is defined
05/18/09   ps       Changed MODEM_MEM_CL_WCDMA_RRC_GLOBAL_CRITICAL
                     to MODEM_MEM_CL_WCDMA_RRC_GLOBAL_CRIT
05/11/09   ps       Feature to dynamically allocate OC, CC and TOC ptr
05/06/09   gkg      Made changes for ZI memory optimization for global prach_sel_info.
                    If feature FEATURE MODEM HEAP is defined and FEATURE_WCDMA_ZI_OPT_DISABLED
                    is not defined, then global prach_sel_info is initialized using modem heap,
                    otherwise it's initialized statically.
05/10/09   kp      Added support for demand paging RRC code using pragma.
05/08/09   ss      Updated Copyright Information
05/04/09   ps       Made changes to update the TFRI table status for Non-R7 OTA 
                    also
04/29/09   ss       Made changes to compiler warnings on gcc compilers.
04/21/09   ps       Made changes to maintian RLC size for FACh as Octet aligned always
04/13/09   ps       Made changes to reject an OTA, if MAC-HS reset Ind is 
                    not included for MAC-EHS<-> MAC HS transition
04/08/09   gkg      In case of Cell_FACH->Cell_DCH transition through Reconfig OTA, 
                    if RB-Mapping for any RB is provided again, TOC will be not be 
                    updated for RB-Mapping.
04/09/09   ps       Made changes to send reconfig ind in CU/or go to idle
                    if RL failure is triggered while l2 ack for reconfig complete
03/30/09   ps       Made correction look inot the correct DB TOC/CC/OC 
                    whichever applicable to get the OTA RLC size status
03/24/09   ps       Made changes that once OTA provides RLC size, then it
                    can be changed only through OTA, only in case of R3 OTA
                    RLC size will be calculated from the TF of the Trch
03/09/09   ps       cleanup of feature flag 
                    FEATURE TFC RLC SIZE
                    FEATURE_DCH_FACH_STATE_TRANSITIONS
                    FEATURE TFC RLC SIZE
                    FEATURE_DCH_IE_IN_CELL_FACH
                    FEATURE_TFCSUBSET
                    FEATURE_ADJUST_TB_SIZE_WHEN_TRCH_INFO_NOT_PRESENT
03/06/09   gkg      Made changes for resetting MAC-HS action in Config DB when 
                    LLC sends Channel Config Confirm to procedures. Also reset hs_
                    req_mask for L1.
03/02/09   ps       Include CPHY_HS_DSCH_CFG_INCL for HSDPA to l1, if Tau DPCH
                     changes by 1 ,under FEATURE WCDMA REL7 HACK CHG TAU DPCH
02/12/09   gkg      Made changes towards optimizing PRACH working DB. 
                    Basically the data type of PRACH working DB is changed from 
                    ordered_config_type to prach_config_type.
02/05/09   ps       Made changes to set mac_hs_transition_type to NO TRANSITION
                    before OTA processing
01/19/09   ps       Made changes for ASn1 migration 25.331v7.9  
                    i.e.May 2008 version  (2008-05) 
01/15/09   gkg      Made changes to initialize rlc_size_change_in_progress DB before 
                    processing any DL RRC OTA that can set OC.
12/18/08   ps       Made changes to send an add and drop for DPCH , if the tau DPCH
                    changes by 1 under FEATURE WCDMA REL7 HACK CHG TAU DPCH
12/17/08   gkg      Made changes so that RRC calculates data rates for R99 PS Data calls 
                    correctly. Basically, now RLC SDU size is used instead of RLC PDU size.
12/16/08   gkg      To ensure that variable amr_cb_set has always valid values, made
                    changes to make it global variable.
12/08/08   ps       Made changes to set the MAC-HS(R5/R6 HS-DSCH )CAT 
                    according to global variable "rrc_machs_cat" when the 
                    HSDPA CAT is above 12 for R7
12/05/08   ps       Made changes to set the HS rates for R7 category also.
                    Also made changes to set the HSDSCH bitmask for change in
                    64QAM status
11/28/08   gkg      Made Changes for new MVS-RRC Interface to (de)configure vocoder
                    for AMR Voice Calls.
11/27/08   sk       Hold utran drx cycle in OC. Required for BPLMN 320ms.
11/14/08   gkg      While reporting the data rate for HSUPA, TTI of the EUL is also
                    considered.
11/12/08   gkg      While calculating the data rate for HSDPA/HSUPA, made changes to use the correct 
                    unit conversion factor. Instead of 1 kbps = 1024 bps, use 1 kbps = 1000 bps.
10/29/08   ns       Fixed compilation errors
24/10/08   gkg      Removed the check for BTFD + Turbo Coded DL DCH TrCHs for GCF TC.
10/10/08   gkg      Added code for updating UM RBs in OC first and then making them 
                    available to LLC to configure RLC while doing Channel Config Req. 
                    Also added code for Alt E Bit that is used for UM RBs.
10/23/08   ps       Made changes to add support for event EVENT_WCDMA_UL_AMR_RATE
                    to log the UL AMR rates
10/22/08   ps       Made changes to include CPHY_HS_DSCH_CFG_INCL to 
                    L1 even if only SYNCA procedure is triggered
10/10/08   ps       Made changes to support Delay restriction IE
10/10/08   ps       Reset the TFRI table to bit aligned for Non-r7 OTA msg
10/08/08   gkg      Made changes so that validation of Max TF for UL/DL is done using 
                    UE_MAX_TF instead of UE_MAX_NUM_TF_32/UE_MAX_NUM_TF_64. Macro UE_MAX_TF
                    is defined as UE_MAX_NUM_TF_64.
10/08/08   gkg      Fixed the featurization issue in function rrcllc_derive_dl_amr_mode().
09/29/08   ps       Check-in of some bug fixes for MIMO
09/22/08   gkg      Once OC is set by a procedure, a check is made whether both 
                    BTFD and Turbo Coding for any DL TrCH are signalled from NW.
                    If yes then OC status is set to Invalid.
09/19/08   gkg      Made changes to pass the correct operand for sizeof operator used in
                    functions rrcllc_rearrange_dflow_index() and rrcllc_rearrange_queue_index().
09/12/08   ps       Added code for REl7 under FEATURE_WCDMA_REL7
06/08/08   ps       Made changes to restore Delta Ack, Delta Nack and Ack
                    nack  Repetition factor values from TOC to OC, for
                    FACH->DCH transition
06/30/08   ps       Made changes to call rrc_initialize_rlc_size_per_rb() even
                    if FEATURE HSDPA is not defined.
06/23/08   ps       Added changes for FEATURE_HSDPA_PERFORMANCE_OPTIMIZATION 
                    which was missing in R6 path
06/13/08   gkg      Added code for notification of Cell_Id change through OTAs
                    in Cell_DCH state.
06/13/08   gkg      Made changes so that if RLC PDU size changes for RBs through
                    Transport Channel IEs of OTA messages, those RBs are reconfigured
                    and therefore their RLC entity is notified for new RLC PDU size.
06/06/08   ps       Made changes to indicate mac_hs_reset_indicator to MAC 
                    only if the OTA msg indicates a MAC HS RESET
05/08/08   ps       Made changes to initialise the num-trch as 0, for
                    config-ptr instead of ordered-config_ptr
05/05/08   ps       Made changes to update the TTI values from CC to OC
                    for FACH->DCH transition.
04/25/08   ps       Made changes to pass num_trch and num_tfci as 0 to L1
                    when num_dpdch in UL is 0
04/28/08   gkg      To notify MAC UL about the change of UL TFCS, set the flag 
                    new_tfcs_list_present to TRUE while handling Spec CR 2980.
04/25/08   gkg      Made Changes for Spec CR 2980. To handle TFCS with no DCH configured, 
                    initialized the TFCS for UL & DL in OC.
04/18/08   gkg      Fixed Klockwork errors.
04/17/08   ps       Made Correction in function rrcllc_derive_dl_amr_mode().
04/14/08   gkg      Made changes for configuration of AMR Call so that no. of AMR
                    classes in UL to be registered with MVS is 3 whenever no. of RBs in
                    voice RAB is 3. This is done irrespective of amr mode.
01/04/08   gkg      Added support for asymmetric AMR call by updating DL rlc ids, 
                    tr-ch ids and cctrch ids separate from UL. Modified function
                    rrcllc_derive_dl_amr_mode().
03/28/08   da       Updated function rrcllc_get_ul_ded_rate() to include HSUPA rates
03/28/08   gkg      Added support for configuring MVS for AMR voice call for DL using 
                    DL CTFCs. Added function rrcllc_derive_dl_amr_mode() for this.
03/19/08   rm       Made changes to reject the reconfig message with failure cause as Incompatible simultaneous
                    reconfgiruation if lower layers are being configured for SIb5 change
10/03/08   gkg      Made changes so that RRC correctly calculates number of UL 
                    TM channels in FACH->FACH redirection.
03/07/08   ps       Reverting changes done to init the TFCS pointer when
                    no DCH is present
03/06/08   da       Added MBMS phase 2C changes.  MBMS support in CELL_DCH.  
                    Includes mobility and dynamic resource management.
03/06/08   da       Changed FEATURE_MBMS to FEATURE_MODEM_MBMS
03/03/08   vk       In fn rrcllc_init_hsdpa_mac_info(), initialize the variable
                    mac_hs_restore_tsns to FALSE. Also, set the same variable
                    to FALSE in RRC Internal HSDPA structure by default. 
                    Changes have been featurized under FEATURE HSDPA MAC HS DL RESTORE TSN
29/02/08   gkg      Made Changes for Spec CR 2980. To handle TFCS with no DCH 
                    configured, initialized the TFCS for UL & DL in OC. The 
                    changes are added under feature flag FEATURE_TFCS_SANITY_CHECK 
                    in function rrcllc_is_tfcs_provided_on_add_delete_trch() only.
28/02/08   gkg      Made changes for correct calculation of UL RLC size in Cell_FACH state.
21/02/08   gkg      Fixed array index out-of-bound warnings reported by Klocwork.
02/13/08   rm       Added rrcllc_get_rach_cctrch_ptr to return RACH cctrch config ptr
                    from current config
02/13/08   kp       Bug fix for Setting num_logch for this index as Zero 
                    in function rrcllc_fill_holes_in_e_mac_d_flow_idx() when 
                    e_mac_d_flow_id in invalidated for this index.
12/02/08   gkg      Fixed lint error when FEATURE_CCCH_IE_ENH is enabled.
11/02/08   gkg      Made changes so that whenever there is a mismatch in what is
                    expected in an OTA msg and what is received, always INVALID 
                    Config is returned instead of UNSUPPORTED Config.
02/04/08   kp       Added a new function which will will set all E-DCH active set DL RL's bit mask
                    to reconfig, This is currenlty used in TTI reconfiguration, where L1 needs to reconfigure
                    all DL RL's in E-DCH active set.
12/27/07   rm       Made changes to update the DL TM RLC params in OC correctly
                    during discon to conencting transition
12/21/07   da       Support for FEATURE_MBMS
12/03/07   ps       Made changes to support Additional Transport format for CCCH
                    received in SIB5/SIB6.Changes are made under feature 
                    flag FEATURE_CCCH_IE_ENH.
11/28/07   da       Fix for compiler warning.
11/26/07   gkg      Added support for VT->Voice fallback and vice versa
                    by RB-Reconfig msg for SCUDIF.Also added changes to 
                    support VT->Voice fallback using RB-Setup msg.
                    Changes under feature flag FEATURE_SCUDIF_ENHANCEMENT
11/14/07   rm       Made changes to initialize new_tfcs_list_present in ordered config
                    and added a new function to return the status of new_tfcs_list_present
11/09/07   da       In rrcllc_check_if_rb_mapped_on_dflow(), made changes to look @ the 
                    passed config_db, rather than OC, for determining num_dlfow. 
10/12/07   vk       Implemented fn rrcllc_init_fdpch_info() to initialize F-DPCH parameters.
                    Called the above fn from rrcllc_init_config_data(). Changes have
                    been featurized under FEATURE_WCDMA_FDPCH
10/08/07   da       Change to get utran drx from TOC when TOC is set for FACH
                    to PCH for freq/PSC redirection
09/18/07   rm       Added a check whether the info is valid before reading the
                    measurement purpose while saving CM info for inter Frequency
09/13/07   vk       In fn rrcllc_check_if_rb_mapped_on_dflow(),add check to allow
                    SRB Mapping on HS-DSCH under FEATURE_WCDMA_FDPCH
09/10/07   ps       Added support for Frequency redirection received in 
                    FACH->FACH and FACH->PCH cases under feature flag
                    FEATURE_RRC_FREQ_REDIRECTION_THRU_RB_AND_CU
07/17/07   rm       Added support for FEATURE_WCDMA_INTER_FREQ_RACH_REPORTING feature.
07/09/07   da       Added defensive checks to make sure config_ptr->mac_dl_parms.num_bchs
                    does not exceed 1.
07/05/07   da       Featured out code that sets UL crc bits to 0 for loopback 
                    mode 2.  If feature FEATURE_TM_LB, ul crc bits will not be
                    force set to 0.
06/21/07   da       Fixed lint warning.
05/23/07   ps       The function rrcllc_get_trch_id_mapped_to_rb() was defined 
                    only under FEATURE HSDPA. Moved the function,for it to be 
                    always defined.
05/18/07   ps       Corrected rrcllc_find_e_mac_d_flow_idx(), to search for 
                    all the index to find the required flow id.
05/08/07   sm       Added function rrcllc_init_before_msg_processing() to be called before
                    rrc message processing
04/19/07   da       Put TFCS check when TrCH is added/deleted under feature
                    FEATURE_TFCS_SANITY_CHECK.  Also made change to enforce
                    this rule when destination state is CELL_DCH and relaxed
                    the checkf for other states.
04/10/07   ps       Added support for default configs sent through Rb-Setup msg
03/23/07   da       Added change to update e-mac-d-flow info in TOC with LC id.
03/14/07   ps       Made correction in rrcllc_get_amr_wb_mapping & 
                    rrcllc_get_amr_mapping to initialise variable with default
                    values under feature flag FEATURE_VOC_AMR_WB
03/15/07   da       Fixed featurization problem. rrcllc_rb_release_ie_r5 should be 
                    under FEATURE REL5 rather than FEATURE HSDPA.
03/08/07   da       Bug fix in function rrcllc_invalid_tfcs_info that was causing
                    local config_ptr to point at wrong DB.
03/07/07   vm       fixed compilation error.
03/02/06   ps       Added support for Wb-AMR under the feature flag
                    FEATURE_VOC_AMR_WB.
02/28/07   sgk      Added support for HSDPA ASU repointing under 
                    FEATURE_HSDPA_ASU_REPOINTING. 
02/26/07   sm       Added code changes for rejection of EUL+CM config for early R6 UEs
02/13/07   sgk      Added function rrcllc_update_cm_params that modifies the TOC
                    to retain the inter frequency patterns in inactive state while
                    deleting the inter rat patterns on DCH->FACH transition thro
                    a reconfiguration message taking us to a UTRAN directed cell.
02/09/07   ps       Made changes to re-initializes Re-establish entity whenever
                    a OTA msg is received in all state transitions.
02/07/07   da       Added tfcs_needed and tfcs_rcvd flags for both DL and UL.
                    These booleans are to be used to validate the reconfig message.
                    if tfcs_needed is TRUE and tfcs_rcvd is FALSE, UE
                    shall reject that reconfig msg with cause "invalid config".
                    Added some fns to init and status of these flags.
02/07/07   ps       Made changes to handle Standalone Rb-Mappings
02/02/07   da       Added function rrcllc_get_dch_fach_act_time_in_ms()
01/29/07   rm       Added defensive checks by validations for nbch and sbch
01/29/07   ps       Added changes to ignore timingMaintainedSynchInd IE when 
                    Frequency info IE is not present or in Timing Initialised case
01/22/07   da       Made change to pass boolean param to fn rrcllc_init_rach_info
                    as indication on whether to init RB-mapping info or not.
01/19/07   rm       Added support for SIB7 update in Cell FACH state.
                    The code is under feature flag FEATURE_UPDATE_SIB7_IN_FACH.
                    Update CC,OC & TOC with the updated Up link interference value from SIB-7
01/12/07   sm/vr    Added function to return whether reconfig message includes
                    timing init HHO or not.
01/08/07   vk       Removed code under FEATURE_RRC_ENABLE_CM_HSDPA for Release 6
                    in fn rrcllc_determine_hsdpa_action_r6() for checking if 
                    HSDPA + CM are ACTIVE at the same time
12/22/06   ps       Made changes to handle postVerificationPeriod and the
                    timingMaintainedSynchInd IE received in OTA messages
12/19/06   sm       Added function rrcllc_init_mac_ul_edch_info_ie() to clear UL-EDCH-
                    Information stored in MAC datastructures
11/20/06   da       Set variable ordered_config_ptr->rach_rlc_size_restriction_info.mac_update_needed
                    to TRUE in funcs that update OC with TOC within FACH and PCH when
                    toc_usage is set for TOC_FOR_OOS.
11/15/06   sm       Added EUL HHO and reverting back to old config support
10/16/06   vk       Re-initialized the re-establishment indicator by calling fn
                    rrcllc_init_reestablish_entity() under FEATURE RLC ONE SIDE RE ESTABLISHMENT
10/13/06   sgk      Fixed 7200 compiler warnings. 
10/05/06   da       Updated function rrcllc_get_dl_ded_rate() with HS rates 
09/27/06   sgk      Fixed 7200 compiler warnings. 
09/09/06   sm/da    Fix code review comments and general clean-up for REL6 and HSUPA and
                    cleaned up #else part of FEATURE SPEC CR2393
09/11/06   vk       Set re-establish entity to NONE in rrcllc_init_rlc_parms().
                    Also defined function to compare RLC Sizes. Changes have been featurized
                    under FEATURE RLC ONE SIDE RE ESTABLISHMENT
09/05/06    da      Get the UTRAN DRX cycle from TOC when toc usage is set for TOC_FOR_OOS
08/29/06   sm/da    Made changes required for R6 ASN.1 migration.  Also merged
                    FEATURE_WCDMA_REL6 and FEATURE WCDMA HSUPA.
08/28/06    da      Added support for OOS area handling during transition from DCH.
08/21/06   tkk      Added SRB#5 support.
06/05/06   sgk      Made changes to include rel5 non HSDPA functionality under 
                    FEATURE REL5 while retaining the HSDPA specifc processing 
                    under FEATURE HSDPA.
05/01/06   vk       Initialized beta_table_present and hrnti_changed variable to
                    default value in structure hsdpa_msg_params. Also while setting
                    HSDPA action, check if beta table or measurement feedback info
                    has changed and then accordingly set the bit mask in HS_DPCCH
                    structure. Changes have been featurized under 
                    FEATURE_HSDPA_PERFORMANCE_OPTIMZATION
04/20/06   vk       Fixed the previous merge issue from 3270 baseline
04/20/06   vk       Made compressed mode gap patterns inactive in OC in fn
                    rrcllc_init_hsdpa_info_before_msg_processing() if CM is inactive
04/18/06   vk       Defined a global variable nv_hsdpa_cm_enabled to store the
                    value of NV variable. Also implemented the fn 
                    rrcllc_get_cm_hsdpa_nv_item(). Changes have been featurized
                    under FEATURE HSDPA
04/18/06   da       Modified code to support migration to Mar-06 Rel-5 ASN1 +
                    R6 Hacks
03/28/06   vk       Removed code under FEATURE_RRC_ENABLE_CM_HSDPA as it is no longer
                    required
03/21/06   da       If loopback mode 1 is chosen, determine whether to indicate 
                    LOOPBACK_MODE_1 with TM or NON_TM bearers to L1. IF TM RBs 
                    are setup for LB mode 1, L1 passes up the blocks to RLC regardless of
                    CRC.  Else for non-tm, L1 will discard blocks that don't pass CRC
03/14/06   tkk      Lint warnings/errors cleanup
03/10/06    da      Added Initial support for PDCP under FEATURE_UMTS_PDCP
02/28/06  da/sm     Modified code to support migration to Dec-05 Rel-6 ASN1
02/23/06  ss/tkk    Added function "rrcllc_get_dl_amr_mode_for_rb" to calculate the
                    DL AMR rate from the voice RB IDs.
1/18/06   vk        Added code to ignore SRB Delay, PC Preamble & DPCCH power offset
                    when HSDPA reconfigurations is in progress and Sync A Procedure
                    is not involved.
12/18/05    da      Modified functions rrcllc_get_dl_ded_rate() and rrcllc_get_ul_ded_rate
                    to calculate the right data rate.
                    Changed check to tfs_cnt <= UE_MAX_NUM_TF_32 instead of
                    tfs_cnt < UE_MAX_NUM_TF_32 in function rrcllc_check_ul_tfs_cnt()
                    Changed check to tfs_cnt <= UE_MAX_NUM_TF_64 instead of 
                    tfs_cnt < UE_MAX_NUM_TF_64 in func rrcllc_check_dl_tfs_cnt()
11/10/05    da      Removed extern definition of nv_rel_ind;
11/10/05    da      Checking global flag rrc_nv_rel_indicator before doing R5 related
                    processing.
11/10/05   tkk      Added support for Rel-5 Interrat HO To UTRAN.
11/03/05    vk      Made the change to not invalidate HSDPA Scrambling Code when
                    HSDPA action is STOP while determining HSDPA Action. Also, set
                    MAC HS Reset variable to TRUE when the HS Action is STOP
11/08/05   da       In case SIB4 indicator is set to True in SIB3, but SIB4 is not in 
                    SIB DB, func rrcllc_copy_sib_to_oc() shall look into SIB3 rather 
                    than returning failure.
09/02/05   da       Made 2 new functions that take in an rb_id and return the rate 
                    1.rrcllc_get_dl_ded_rate() and 2. rrcllc_get_ul_ded_rate()
08/25/05   vk       Featurized the code for rejecting HSDPA activation when CM is already 
                    active under FEATURE_RRC_ENABLE_CM_HSDPA
08/24/05   da       In func rrcllc_copy_sccpch_info_from_sib_to_oc_in_connected_mode,
                    added change not to initialize RB mapping info if next state is 
                    CELL_PCH or URA_PCH.
08/12/05   vk       If CM is already ACTIVE and network tries to activate HSDPA,
                    then reject that configuration
08/10/05   vk       Set HSDPA bit mask as per hs_dpcch_info in new hsdpa_msg_params
                    structure. Initialized hs_dpcch_info to FALSE
                    in rrcllc_init_hsdpa_msg_params_struct(). Added a
                    new function rrcllc_set_r99_hsdpa_action() to set
                    HSDPA action for R99 Messages
08/05/05   vk       If network forces UE to do a forced Sync A procedure by specifying
                    the Downlink Freq again, then set HSDPA Action to RECONFIG
07/29/05   vk       If HS-Reset is set to TRUE and no other HSDPA parameter has
                    changed, set L1 HSDPA Action forcibly to RECONFIG
08/21/05   vk       Changed some MSG_HIGH to MSG_MED as during HSDPA testing, lot
                    of F3 messages are getting dropped. This is part of the
                    overall effort to reduce un-necessary F3 messages
07/15/05   vk       Updated the comments for function rrcllc_initialize_queue_info()
07/01/05   vk       In case of soft repointing, if HRNI has changed then set
                    the corresponding bit mask
06/21/05   vk       If Network just specifies the dl-HSPDSCH FDD information and
                    does not change any other HSDPA parameter, change the HSDPA
                    action from RECONFIG to NOOP so that L1 does not need to
                    reconfigure for HSDPA.
06/06/05   da       Added func rrcllc_print_trans_chnl_rate for printing old trans
                    chan rate from cc and new trans chan rate from oc.
05/26/05   vk       Added support for spec CR 2393 for fn rrcllc_determine_hsdpa_action
                    under FEATURE SPEC CR2393
05/05/05   svk      Added function rrcllc_update_oc_in_fach_with_sibs().
05/04/05   da       Removed making TOC invalid in function
                    rrcllc_update_oc_from_fach_to_dch().  TOC should be set to invalid
                    after successfully configuring lower layers
04/22/05   vk       Added code to process Cell Update Confirm Release 5 and call
                    appropriate function handler. Defined new fn rrcllc_copy_harq_info.
                    Also copy HARQ information from TOC to OC on FACH to DCH transition
04/15/05   da       In fucntion rrc_query_crnti(), added code to look for valid
                    crnti in OC first if  lower layers are configured with OC.
04/13/05   da       Added change in rrcllc_copy_sib_to_oc_for_sccpch_with_ctch()
                    to copy sib info to oc in ura_pch state.
04/06/05   da       Added Initial support for BMC.  Handling of CTCH  and
                    a second SCCPCH in IDLE, CELL_PCH and URA_PCH states
                    are now supported.  CTCH is not present in CONNECTING, CELL_FACH
                    and CELL_DCH states.
03/11/05   vk       Merged HSDPA code in Mainline from RRC_MSM6275 branch under FEATURE HSDPA
03/09/05   kc       Added support to get N312, N315 from global database in data.c
03/02/05   ttl      Support RRC ASN1 Release 5.
01/17/05   sk       Added new function to update oc with SIBs for scchpch reconfiguration.
12/29/04   svk      In function rrcllc_get_amr_mapping(): determine the amr rate
                    based on the TCS table rather than the TFS information.
                    raverse the TFCS tabel and based on what TFCI's are allowed
                    determine the rate
12/23/04   sk       Init OC before copying SIB to OC when OC is processed for
                    pcch reconfiguration in disconnect state.
12/04/04   svk      Added function rrcllc_update_lbt_mode_for_fachs() under
                    FEATURE_TC for processing loopback infromation to lower layers
                    in FACH state. Now in FACH state UE would support only loopback
                    mode 1. Loopback mode 2 (constatnt delay) can't be applied in
                    FACH state.
11/22/04    sk      Modified reset_ordered_config to handle reset when lower layers
                    are configured.
10/22/04    svk     rrcllc_get_amr_mapping_info() : Corrected handling of determining
                    the AMR rate when all possible rates are configured in the RB
                    setup message. This is added under FEATURE_WCDMA_MULTIRATE_AMR
10/11/04    sk      Removed Lint errors
                    Fixed indentations.
                    Moved rrcllc_check_dcch_fach_mapping() function from rrcllc.c
                    Moved protypes for rrcllc_copy_rlc_parms() and
                    rrcllc_copy_cell_fach_rlc_size_list() to rrcllcoc.h file
                    Removed unused local variables.
09/16/04    vk      Initialized tgpsi seq id in rrcllc_modify_cm_info_in_current_config()
                    to 0
08/27/04    jh      Added code to clear ordered_config.reconfig_in_progress
                    when setting ordered config fails.
08/26/04    jh      Updated to use new L1 tx_div_ind interface.
08/20/04    jh      Added CCTrCh and TrCh lookup for enhanced AMR processing.
08/19/04    sgk     Changed the last else if to else to fix lint warning
                    function 'rrcllc_get_drx_info(void)' should return a value
                    Removed empty function rrcllc_print_trch_info to fix lint
                    error 'config_ptr' not referenced
                    Changed the return type of the functions
                    rrcllc_update_oc_from_pch_to_fach,
                    rrcllc_update_oc_from_fach_to_cell_pch_or_ura_pch,
                    rrcllc_update_oc_from_dch_to_pch_with_sibs,
                    rrcllc_update_oc_from_dch_to_fach_with_sibs
                    from rrcllc_oc_status_e_type to uecomdef_status_e_type
                    to correct lint errors 'bad type' in file rrcllc.c where
                    the functions were called.
07/22/04    vn      Added a new function rrcllc_init_dl_common_info() to initialize
                    Timing Init field to "Timing Maintained".
07/19/04    ttl     Init lg_ch_cnt_down and lg_ch_cnt_up.
07/15/04    jh      Initialize timing_ind in rrcllc_init_l1_dl_dpch_chan_info()
                    to be L1_TIMING_IND_MAINTAIN.
07/14/04    sk      Added RL failure/RLC reset handling support.
                    New function to reset OC and get the proc that set oc
07/09/04    jh      Added additional logging for channel counts.
06/21/04    vk      Copy CM params from TOC on trans from FACH->DCH. Also imple
                    mented fn rrcllc_initialize_cm_parms to initialize CM params
          in TOC
06/02/04    jh      Fixed incorrect initialization of compressed mode info
                    in rrcllc_init_l1_dl_dpch_chan_info()
05/11/04    jh      Added case for WVS_AMR_MODE_515_CLASS_A_BIT_SIZE in
                    rrcllc_get_amr_mapping()
05/07/04    bu      Removed the feature definition around rrc_query_crnti().
04/02/04    jh      Fixed rrcllc_populate_mac_size_restriction_info() to
                    support PCH states.
03/18/04    jh/sk   Merged fixes from Sanjay for properly determining RLC sizes
                    and UTRAN DRX cycle in Cell_PCH/URA_PCH.
03/04/04    ttl     Added FEATURE_CELLPCH_URAPCH for code of Cell_PCH/URA_PCH.
02/27/04    jh/sk   Merged fixes from Sanjay: Initialize PCH info when
                    transitioning from PCH->FACH, then fill in the correct
                    values from SIBs and current_config.  Do likewise
                    for FACH->PCH.
02/06/04    sk      Removed copying of oc to toc during fach->pch transmission
02/06/04    jh      Added rrcllc_update_oc_from_pch_to_fach(),
                    rrcllc_update_oc_from_dch_to_pch_with_msg(),
                    rrcllc_update_oc_from_dch_to_pch_with_sibs(),
                    rrcllc_update_oc_from_fach_to_cell_pch_or_ura_pch(),
                    rrcllc_update_oc_in_pch_with_toc(), and
                    rrcllc_update_oc_for_pch_to_fach_with_toc() to support
                    CELL_PCH and URA_PCH states.
01/30/04    jh      Regardless of whether or not ordered config can be cleared
                    immediately when rrcllc_clear_ordered_config() is called,
                    if a reconfig procedure even attempted to clear ordered
                    config, that means the reconfig is done, so we should at
                    at least clear the reconfig_in_progress flag.
12/10/03    bu      Added function rrc_query_crnti() for L1 to query
                    if UE has a valid CRNTI for making Inter-RAT FACH measurements.
12/03/03    sk      Support for Radio lonk failure. under feature RL_FAILURE_HANDLING
11/21/03    bu      Decrement num_bchs in mac_dl_parms only if it's > 0.
11/13/03    jh      Allow set_ordered_config() with OC already set, but only
                    if lower layers have been configured and ASU is the
                    current procedure.  When updating OC in DCH, skip copying
                    CC to OC if OC is already set, which could be the case
                    from the previously described change.
11/06/03    vk      Moved initialisation of cm info from rrcllc_init_l1_dl_ptr()
                    to rrcllc_init_l1_dl_dpch_chan_info(). Also removed
                    the incorrect checking of tgpsi from ordered config
                    when L1 indicates a TGPSI that needs to be deleted
10/21/03    kc      Added code to use ordered/config ptr based on
                    config_ptr_in_use to get ul dedicated rlc size.
09/23/03    sk      In function rrcllc_return_freq_for_fach_pch() return
                    'current frequency' if 'freq info' is not present in the
                    transition_config db.
08/11/03    jh      Added initialization for rlc_info_incl flags in
                    rrcllc_init_rlc_parms().
08/04/03    jh      Added QXDM messages for ASU failure cases.
07/23/03    jh      Added initialization for loopback_test_mode in
                    rrcllc_init_dl_dch_rb_mapping_info() and
                    rrcllc_init_ul_dch_info().
06/27/03    jh      Fixed typo in rrcllc_get_amr_mapping().
06/04/03    vn      In rrcllc_copy_sccpch_info_from_sib_to_oc_in_connected_mode,
                    rrcllc_copy_sib_to_oc and rrcllc_update_oc_for_resel
                    ensure that if no SCCPCH with FACH is present in SIB6,
                    SIB5 is read - Spec CR1618r1
05/01/03    jh      Corrected enum MAC_LOOPBACK_MODE_NA to MAC_LOOPBACK_NA
04/29/03    vn      Changed rrcllc_clear_ordered_config to clear ordered
                    config only if LLC permits doing so. Consolidated all
                    Ordered Config status/states into one structure, added
                    ordered config processing state to isolate race conditions
                    between OC and cell reselection.
04/24/03    jh      Added support for filling in MAC loopback mode in DCH info.
04/03/03    bu      If Serving/Neighbor PCCPCH is up while going from CONNECTING
                    to DCH or FACH to DCH, increment the DL TM channels as they
                    will be dropped before going to DCH.
03/26/03    vn      Wrapped all RLC size for DCH processing with
                    FEATURE_RRC_TFC_RLC_SIZE_FOR_DCH.Changed to not copy OC
                    to CC when FEATURE_DROP_ADD_FOR_PHYCHL_RECONFIG is not
                    defined. Removed compilation warnings from earlier check-ins.
03/18/03    vn      On going from CELL_FACH to CELL_DCH, do not set
                    ordered config status to OC_SET_FOR_CELL_DCH
                    as various checks interspersed in all modules check for
                    OC_SET_FOR_CELL_DCH to resolve race conditions between
                    reselection and trannsition to CELL_DCH.
03/17/03    jh      Split up switch statements that translate N312, N313, and
                    N315 enum types into uint16 values and put them into
                    individual functions for use in multiple spots in the
                    code.
02/18/03    vn      In rrcllc_update_oc_from_fach_to_dch, copy TrCH data
                    from TOC only if TOC is NOT invalid, copy U-RNTI from
                    Current Config to Ordered Config. Also copy RLC size list
                    from Current Config instead of TOC. This ensures any updates
                    to RLC size list while in CELL_FACH are preserved when
                    going to CELL_DCH. Added new functions rrcllc_return_freq_
                    _for_fach_pch and rrcllc_return_psc_for_fach_dch.
02/14/03    kc      Changed feature defn from INTERRAT_HANDOVER_GTOW_RRC to
                    INTERRAT_HANDOVER_GTOW
02/13/03    jh      Added rrcllc_update_oc_from_disconnected_to_dch()
                    function to update Ordered Config with information
                    received in Handover to UTRAN command.
02/05/03    sk      March2002Rel specific changes (see comments with March2002Rel)
02/05/03    vn      Merged in changes dropped during linting.
01/17/02    vn      In rrcllc_copy_trch_info, do not copy L1 UL and DL Phy
                    channel parameters. This prevents usage of any stale
                    values from previous Cell_DCH state.
01/10/03    vn      Maintain procedure ID that last changed OC status. Changed
                    rrcllc_set_ordered_config to have an calling procedure ID
                    as argument.
12/20/02    vk      Moved the initialisation of tgp_seq_id of compressed mode ptr
                    with in the for loop in function rrcllc_init_l1_dl_ptrs(..)
11/22/02    jh      Corrected DTX activation algorithm.  Updated the
                    rrcllc_copy_sib_to_oc() function to properly ignore
                    SIB5 RLS size restriction information when the restriction
                    type is set to explicit list for a RACH TFS.  Numerous
                    fixes to RLC size restriction processing merged in from
                    branch.
10/30/02    vn      Set the RRC state in Ordered Config to CELL_FACH in
                    rrcllc_update_oc_from_dch_to_fach_with_sibs. Needed for
                    DCH to FACH transitions.
10/14/02    jh      Fixed compilation error when FEATURE TFC RLC SIZE is not
                    defined.
10/11/02    vn      Do not initialize tfci_existence for Downlink in init_dl
                    _ctfcs(). The same would be initialized while processing
                    SCCPCH Info or DL DPCH Info Common for all RLs.
10/09/02    vn      Fixed compilation error.
10/09/02    jh      In rrcllc_update_oc_from_fach_to_dch(), added code to copy
                    RACH RLC size restriction info in from TOC after
                    initializing OC.
10/09/02    vn      In rrcllc_update_oc_in_fach_with_toc, update OC with
                    RNTI info from TOC. This is to enable the use of last U-RNTI.
                    Set TOC to invalid on successfully processing a message that
                    transitions UE from FACH to DCH. Additional debug info.
10/08/02   bu,vn    In rrcllc_clear_reselection_ordered_config, set
                    config_ptr_in_use to CURRENT_CONFIG. In update_oc_for_resel,
                    copy CC to OC only when Current Config is in use.
10/08/02    jh      Fixes in rrcllc_populate_mac_size_restriction_info. Skip it
                    when passed state is CELL_DCH.
10/04/02    vn      Support for FACH to DCH transitions. Added rrcllc_discard_oc
                    to discard Ordered Config, rrcllc_update_oc_from_fach_to_dch
                    to update OC when transitioning from FACH to DCH and
                    rrcllc_copy_trch_info to copy TrCH Info.
10/04/02    jh      Added support for RLC size restrictions: Added functions to
                    initialize structures in OC that hold restriction info
                    received from message IEs.  Added code to update MAC data
                    structures with RLC size restriction info after reading
                    SIBs.  Added code to copy RLC size restriction info from
                    TOC to OC and update MAC when transitioning to FACH state.
                    Added code to update MAC when doing cell reselection.
09/26/02    vn      Fixed to compile with FEATURE_DCH_FACH_STATE_TRANSITIONS off.
09/24/02    vn      Added support for DCH-FACH state transitions: Added
                    transition_config to store config data when transitioning
                    from CELL_DCH to CELL_FACH, added config_ptr_in_use to
                    indicate which of Ordered or Current Config is in use, use
                    config_ptr_in_use to provide CCCH RLC size and UL TX Power
                    info. Call to rrcllc_update_oc_from_dch_to_fach_with_msg
                    on receiving a message transitioning UE from DCH to FACH.
                    Added new functions rrcllc_swap_oc_and_cc to swap OC/CC
                    pointers without changing ordered_config_status, rrcllc_
                    init_config_data to init data without changing ordered_
                    config_status, rrcllc_init_ordered_config_status_and_data
                    to init config_data and ordered_config_status, rrcllc_copy_
                    oc_to_toc copies OC to TOC before transitioning to CELL_FACH.
                    New fns: rrcllc_update_oc_from_dch_to_fach_with_msg to
                    handle a message transitioning state from DCH to FACH, rrcllc_
                    update_oc_from_dch_to_fach_with_sibs to update OC with SIBs
                    on transition to FACH from DCH, rrcllc_copy_rlc_parms,
                    rrcllc_copy_rb_mapping_info and rrcllc_update_oc_in_fach_with
                    _toc to update OC with RLC info and RB Mapping Info applicable
                    to CELL_FACH from TOC, fns to update Mapping Info with log chl
                    ID. Corrected logic for the selection of SIB6/5 for PRACH and
                    SCCPCH Info.Also initialize cell_fach_rb_mappinbg_info while
                    initializing FACH/RACH mapping info.
09/25/02    xfg     Added support for WVS to MVS migration. The changes were
                    made under FEATURE_MVS.
09/24/02    vn      In rrcllc_set_ordered_config, if a transition to a state
                    is requested which is not supported, return a status
                    ORDERED_CONFIG_CONFIGURATION_NOT_SUPPORTED so that a Failure
                    message is sent by requesting procedure.
09/23/02    vk      Initialized tgq seq id explicitly in rrcllc_init_l1_dl_ptrs(..)
                    for all the compressed mode gap patterns so that the tgp seq id
                    has an invalid value when UE goes from connected to idle mode
                    and comes back to connected mode without doing a power reset
09/20/02    vn      Support for re-mapping logical channel info on a cell
                    reselection in Connecting and CELL_FACH states. One
                    generic function rrcllc_update_oc_for_resel() for
                    cell reselection in all RRC states. Before updating for
                    reselection, copy CC to OC when OC is not set.
            vn      Added support to establish/drop serving and neighbor BCHs
                    in Connecting and Connected states - for cell reselection.
09/09/02    vn      Set "reconfig_needed" flag for L1 UL to TRUE for LBT mode 2.
09/04/02    bu      Added definition for rrcllc_register_for_reconfig_complete().
                    This function is called by SMC to register to get reconfig
                    complete notification.
08/21/02    vk      Initialized action_needed variable in the compressed mode
                    structure while initialising downlink dpch channel information
                    Implemented rrcllc_modify_cm_info_in_current_config(...) to
                    update current config for compressed mode gap tgpsi. Changes
                    have been put under FEATURE CM SUPPORTED
08/20/02    jh      Added code to process Dynamic Persistence Level in SIB5 and
                    SIB6.
07/31/02    vk      Changed default value assigned to scr_code_change as per
                    new L1 requirement
07/31/02    vk      Fixed the incorrect merge done in the last build
07/31/02    vk      Initialized compressed mode gap seq in rrcllc_init_dl_rl_info(..)
                    & compressed mode ptr in rrcllc_init_l1_dl_dpch_chan_info(..).
                    These changes have been put under FEATURE CM SUPPORTED
06/24/02    vn      Read URNTI from Ordered Config if it is set.
06/18/02    vn      Fixed typo in rrcllc_init_dl_tfs_info that didn't let
                    initialization to LOOPBACK_MODE_NA.
06/12/02    vn      Merged in Dummy signalling support. Always copy OC to CC
                    for LBT even when FEATURE_DROP_ADD.. is defined. This is
                    so because DL is not dropped/added for LBT and Inter-layer
                    Out of sync can happen if OC and CC are at variance.
06/12/02    rj      Added utility to provide URNTI in Current Config.
06/10/02    vn      Removed FEATURE_DROP_ADD_FOR_PHYCHL_RECONFIG definition.
06/07/02    vn      Fixed rrcllc_fill_holes_in_dl/ul_dch_trch to call routines
                    for new transport channel index so as to maintain TrCH counts
                    Removed rrcllc_dl_trch_reconfig, rrcllc_dl_trch_reconfig2
                    and rrcllc_ul_trch_reconfig as they are not being used anymore.
06/05/02    vn      Do not copy updated Ordered Config into Current Config
                    if FEATURE_DROP_ADD_FOR_PHYCHL_RECONFIG is defined. This
                    is beacuse if Physical channel is going to be dropped (in
                    place of a reconfig), there is no need to cover up for
                    inter-layer out of sync issue due to separate databases.
06/03/02    vn      Added function rrcllc_update_sib1_data to read updated
                    SIB1 for DRX cycle length coefficient. Corrected existing
                    logic to take care of DRX length calculations when the
                    selected cell has no CS domain attached.
05/21/02    vn      In rrcllc_update_lbt_mode_for_dchs, copy Ordered Config
                    to Current Config to take care of out-of-sync problem
                    with activation times.
05/15/02    vn      Merged the following from cell reselection branch:
            vn      Read all SIBs on reselection in Idle disconnected state.
            vn      Cell reselection fixes: Update num_trch only in semi_
                    permanent_data for BCH and N_BCH. Set num_trch to 1 or 0
                    instead of increment and decrement operation. Do not update
                    Ordered Config for any BCH/N_BCH operation.
            vn      Added support for cell reselection. Add/drop neighbor BCHs
                    in rrcllc_update_oc_in_disconnected. Added support to
                    update ordered config when reselectiong to a new cell -
                    keeping all RB Mapping info intact.
05/07/02    vn      Support for TrCH Reconfig: Reconfigure DL MAC whenever
                    DL L1 is reconfigured. Clear out Removed TFCIs while
                    initializing Uplink TFI table.
05/01/02    vn      Update Cuurent Config also in addition to updating
                    Ordered Config while in Cell DCH state.
04/30/02    vn      Initialize Loopback mode in rrcllc_init_dl_tfs_table.
04/23/02    vn      Invalidate RM Restriction Info on Ordered/Current Config
                    initialization. Initialize Reconfig needed info on OC
                    initialization and when copying CC to OC.
04/22/02    vn      Changes made in all OC utilities that provide OC parameters
                    to other RRC procedures/lower layers to read from Current
                    Config when Ordered Config is not set. No separate
                    common and dedicated TrCH info is maintained anymore as
                    either one or the other is valid. No need for RRC state
                    in init_l1_dl_ptrs and functions that call it.
04/22/02    vn      Removed rrcllc_semi_permanent_data from ordered_config_type
04/15/02    vn      Ordered and Current config pointers are initialized
                    separately from the ordered_config_init. In
                    rrcllc_clear_ordered_config, only swap the current and
                    ordered config pointers.
04/12/02    vn      Merged support for Loopback mode 2 from branch.
03/21/02    vn      Fixed implementation in rrcllc_get_ul_um_rlc_size,
                    rrcllc_get_dl_ded_rlc_size and rrcllc_get_ul_ded_rlc_size
                    to correctly compute RLC size based on the biggest transport
                    format size and MAC header. More details as comments inside.
03/18/02    vn      Updated rrcllc_get_current_crnti_status to look for a
                    valid C-RNTI in both Current and Ordered Config.
03/11/02    vn      Added rrcllc_copy_ccch_info_from_cc_to_oc to copy CCCH info
                    When going from Connecting to Cell_FACH, ensure all CCCH
                    related info is maintained. While calculating DL UM DCCH
                    size in Cell_FACH state, look for a FACH mapped onto SCCPCH
03/08/02    vn      Updated rrcllc_init_fach_info to initialize RB Mapping
                    info for FACH based on a new parameter. While copying
                    SCCPCH info in connected mode, do not initialize RB Mapping
                    Info if current and next states are Cell_FACH.
03/06/02    vn      Merged the following from branch -
            vn      rrcllc_get_dl_um_dcch_rlc_size and rrcllc_get_ul_um_rlc_
                    size now calculate RLC sizes when Dedicated logical channel
                    is mapped to FACH/RACH. Changes due to change in names
                    of MAC Header sizes.
            vn      In rrcllc_get_dl_pch_trch_idx, corrected to assign
                    L1_DL_TRCH_PCH_TYPE to ref_type in L1 CCTrCH TrCH info.
            vn      Added Cell_FACH support and Cleanup/Restructuring.
                    Moved the following structures to ordered_config_type:
                    TrCH index and mapping structs, TFCS, CCTrCH info, CTFC
                    info and ASC info strcuts, FACH, DCH and DSCH info, RLC
                    AM Config, gain factor parsm struct. New functs added to
                    update OC in disconnected, from disc. to connecting,
                    connecting to dch or fach, in dch and in fach. These fns
                    called from rrcllc_set_ordered_config.rrcllc_clear_ordered_
                    config now copies OC to CC. rrcllc_init_ordered_config can
                    now initialize both OC and CC. It calls new functions to
                    initialize data struct pointers in MAC UL and DL, L1 UL and
                    DL and RLC structures in ordered_config_type. New functions
                    added to initialize RNTI, BCH, PCH, FACH, DL-DCH, RACH and
                    UL DCH info, DL CCTrCH, DL CTFC, DL DPCH, SCCPCH, UL DPCH
                    and RLC parms info independently. All initialization
                    functions now take pointers to OC/CC. All fns to initialize
                    TrCH indices also init the respective TrCH data. rrcllc_copy
                    sib_to_oc now reads SIBs 4 and 6 (if present) for Cell_FACH
                    Do not read SCCPCH info in copy_sib_to_oc if next state is
                    Cell_FACH/Cell/URA_PCH and U-RNTI is invalid. New functions
                    to copy OC to CC and vice versa. get_dl_pch_trch_idx also
                    updates TrCH ID and TrCH count in all other L1/MAC structs.
                    New fn: allocate_dl_fach_trch_idx called by get_dl_fach_
                    trch_idx if an index not already allocated. All TrCH counts
                    and TrCH IDs updated when a new TrCH index is allocated.
                    find_dl_fach_trch_idx and find_ul_rach_trch_idx do not look
                    for TrCH ID match since no TrCH ID comes in RB Mapping info.
                    ul_trch_cnt and dl_trch_cnt replaced with a macro. New fns
                    to copy SCCPCH info from SIB to OC in connected mode, copy
                    BCH info from CC to OC, get current C-RNTI status.
            vn      Loopback Test mode: Added rrcllc_update_lbt_mode_for_dchs
                    to update loopback mode for all DCHs mapped to DTCHs.
                    Initialize LBT mode in rrcllc_init_dl_com_tfs_table().
02/14/02    kc      Updated UE Conn mode timers to use macros from rrcdata.h
01/16/02    vn      Fixes made to rrcllc_get_amr_mapping after lab testing.
01/15/02    vn      Modified rrcllc_get_amr_mapping to look for transport
                    block sizes corresponding to all AMR modes. Corrected
                    logic to look within available TrCHs and Tr Formats.
12/20/01    vn      Updated function rrcllc_get_ul_tm_ccch_rlc_size not
                    to return negative sdu size.
12/18/01    vn      Do not initialize logical channel IDs to invalid values.
12/12/01    vn      In rrcllc_get_dl_um_ccch_rlc_size, while calculating RLC
                    size, make sure it is for FACH and not PCH.
11/21/01    vn      Merged the following from branch -
            vn      Initialize all logical channel IDs in RLC data to
                    Invalid ID values.
11/16/01    vn      Merged the following from branch -
                    Support for non-sequential transport channel handling:
                    Added and changed utilities to manage transport channel
                    indices. Added functions to get, allocate, find and
                    deallocate TrCH indices for UL/DL TrCHs. Corrected logic
                    in rrcllc_get_ul_rach_trch_idx. Added functions to fill
                    holes in UL/DL DCH TrCH index allocations.
11/14/01    kmp     Remove support for uplink DTX and SCR until vocoder
                    services fixes a bug.
11/09/01    vn      Get N312 and T312 from Idle timers and constants in SIB1.
11/03/01    vn      Absence of a Mandatory Default IE is treated as acceptable
                    and a default value is supplied.Updated to compare DRX length
                    in SIBs against CN domain specific DRX length min and max
                    values in place of UTRAN DRX cycle length min and max values.
                    Added validation checks for AICH and PICH power offsets
                    and UL interference.
10/29/01    vn      Fixed a compiler error in previous version.
10/22/01    kmp     Added support for uplink DTX and SCR for wvs services in
                    rrcllc_get_amr_mapping().
10/19/01    vn      Initialize Ordered Config when copy_sib_to_oc() is called
                    in Disconnected state also. This is needed for handling of
                    Out of Service Area, RL Failure and Reselection. Read and
                    store timers T312 and T313 for Radio Link failure processing.
                    Return a failure if an MD item is not present.
09/25/01    kmp     Initialized the num_tfci field in the UL CCTrCH portion
                    of ordered config in rrcllc_init_ul_tfi_table().
08/27/01    kmp     Added rrcllc_get_drx_info(). In rrcllc_copy_sib_to_oc()
                    added to read the DRX cycle length coefficients from SIB 1
                    and store the PS and CS DRX Cycle Lengths in ORDERED_CONFIG.
                    In rrcllc_init_ordered_config() also initialize the
                    ps_drx_cycle_length and cs_drx_cycle_length ordered config
                    elements. Add rrcllc_check_ul_tfs_cnt() and
                    rrcllc_check_dl_tfs_cnt().
07/17/01    kmp     Updated rrcllc_update_oc_with_msg_ie() to handle the
                    Active Set Update message. Added rrcllc_init_dl_rl_info().
                    No initialize the DL phychan DPCH info data. Added
                    rrcllc_ul_dch_rb_map_info and rrcllc_dl_dch_rb_map_info
                    to support TrCH reconfigurations. Added function
                    rrcllc_trch_reconfig(). Added next state to copy_sib_to_oc().
06/30/01    kmp     In rrcllc_init_ordered_config() initialized the number of
                    FBI bits to 0.
06/28/01    kmp     Fixed a bug in rrcllc_init_ordered_config() where the
                    ordered_config RRC state indicator is not initialized.
                    Update MSG_* outputs for QXDM length of 40 characters.
                    rrcllc_copy_sib_to_oc() has been updated to handle
                    getting all sib pointers for filling in the info from
                    sib1, sib3, sib5, and sib7. rrcllc_init_ordered_config()
                    now initializes the SIB1 data.
06/27/01    ram     Fixed a problem in rrcllc_get_amr_mapping() function to
                    copy the correct uplink rlc ids to the given pointer.
06/15/01    kmp     In rrcllc_get_amr_mapping() ensure to look for DTCHs when
                    looking up RB IDs.
06/14/01    kmp     No longer initialize the nchan in rrcllc_init_ul_tfi_table().
                    Initialize only in rrcllc_init_ordered_config().
06/14/01    kmp     Fixed a bug in rrcllc_update_oc_with_msg_ie() to switch
                    on the correct DCCH message type.
06/13/01    kmp     Fixed bugs in rrcllc_get_dl_um_rlc_size() and
                    rrcllc_get_ul_um_rlc_size() to return correct sizes when
                    in CELL_DCH.
06/13/01    kmp     Fixed a bug in rrcllc_init_ordered_config() where the
                    number of TrCHs i nthe uplink was initialized twice.
06/13/01    kmp     Added a few MACROs for the bit sizes for AMR Modes: 7, 8,
                    and 15 Classes: A, B, C. Finished coding
                    rrcllc_get_amr_mapping(). Removed ul_trch_cnt and dl_trch_cnt
                    globals and made them part of ordered_config_structure.
                    Added rrcllc_init_rach_rb_mapping_info(),
                    rrcllc_init_ul_dch_rb_mapping_info(),
                    rrcllc_init_fach_rb_mapping_info(), and
                    rrcllc_init_dl_dch_rb_mapping_info(). Make the DL TF array
                    a 2 dimensional array indexed by TrCH Index, and TF index.
06/08/01    kmp     Fixed arm compiler warnings.
06/06/01    kmp     Fixed a bug in rrcllc_init_ordered_config(). Added
                    rrcllc_init_dl_tfi_table(), rrcllc_init_ul_tfi_table(),
                    rrcllc_init_ul_tfs_table(), rrcllc_init_dl_com_tfs_table(),
                    and rrcllc_init_dl_ded_tfs_table(). Also call them from
                    rrcllc_init_ordered_config().
05/30/01    kmp     Fixed a bug in rrcllc_set_ordered_config(). In
                    rrcllc_copy_sib_to_oc() added sib3 ptr as a parameter.
                    This SIB contains the Max UL Transmit data needed by the
                    UL Ordered Config. Moved MAC and RLC header macros from
                    here to rrcllcoc.h. Fixed a bug in
                    rrcllc_init_ordered_config(). Added a new Transport Format
                    array for Dedicated TrCH rrcllc_ded_tf_info. Changed
                    rrcllc_tf_info to rrcllc_com_tf_info.
05/29/01    kmp     Updated to initialize the local AM data pointers and
                    channel counts. Updated to return the correct RLC size for
                    the Uplink CCCH.
05/24/01    kmp     In rrcllc_copy_sib_to_oc() changed the AICH Power offset
                    from the L1 UL data structure to the L1 DL data structure.
05/23/01    kmp     Updated rrcllc_init_ordered_config() to initialize various
                    flags in the mac database. rrcllc_get_ul_tm_ccch_rlc_size()
                    was updated to read the ordered config data base and return
                    the appropriate RLC Size. Added rrcllc_get_dl_um_rlc_size()
                    and rrcllc_get_ul_um_rlc_size(). Added constants for the
                    MAC header sizes. Added rrcllc_get_dl_um_ccch_rlc_size().
                    In rrcllc_update_oc_with_msg_ie() changed the types from
                    *MessageType to *Message.
05/17/01    kmp     Added #include "wvs.h".
05/16/01    kmp     Added initialization of internal dl ctfc structure. Moved
                    rrcllc_get_ul_tm_ccch_rlc_size() and rrc_ul_tx_pwr_ind()
                    from rrcllc.c.
05/14/01    kmp     Added rrcllc_get_amr_mapping(). Removed get_u_rnti(), and
                    get_c_rnti().
05/10/01    kmp     Indicate that not supporting CRNTI now, and URNTI function.
05/09/01    kmp     Finish the initialization routine. Added new static data
                    to help manage the DL TFCS calculation, and DL Rate
                    matching data. Fixed a bug in rrcllc_set_ordered_config().
                    Changed rrcllc_copy_oc_to_oc() to rrcllc_copy_oc_to_cc().
                    Added new fucntionality to manage the PCH, FACH, DL-DCH,
                    RACH and UL-DCH transport channel IEs separately. Added
                    a total TrCH count to ensure the UE accepts no more than
                    8 DL and 8 UL TrCHs. Added rrcllc_is_ordered_config_set().
04/13/01    kmp     Updated to add calls to the improved IE processing functions.
                    Added support for SIB 7 processing.
04/05/01    kmp     Updated for the function rrcllc_copy_sib_to_oc(). Updated
                    to the December 2000 version of RRC.
04/03/01    kmp     Updated for the new RLC interfaces.
03/02/01    kmp     Initial release, just as a holding in case something
                    happened while on vacation.
===========================================================================*/


/*===========================================================================
                           INCLUDE FILES
===========================================================================*/
#include "wcdma_variation.h"
#include "comdef.h"
#include "err.h"
#include "l1dlcctrchcfg.h"
#include "l1dlphychancfg.h"
#include "l1sapcommon.h"
#include "l1rrcif.h"
#include "l1task_v.h"
#include "l1ulcfg.h"
#include "macrrcif_v.h"
#include "msg.h"
#include "rlcrrcif_v.h"
#include "rrcasn1.h"
#include "rrccsp.h"
#include "rrcdata_v.h"
#include "rrcllc.h"
#include "rrcllcoc.h"
#include "rrcscmgr.h"
#include "rrcsibdb.h"
#include "uecomdef.h"
#include "rrclcm.h"
#include "rrcrbcommon.h"
#include "rrcdt.h"
#include "rrcccm.h"
#include "rrcsmc.h"

#ifdef FEATURE_WCDMA_HS_RACH
#include "rrcllcoc.h"
#include "rrchsrachcfg.h"
#endif
#ifdef WCDMA_RRC_INDICATE_CODEC_TO_CM
#include "rrciho.h"
#endif
#include "rrcdata_v.h"

#ifdef FEATURE_MVS
#include <mvsamr.h>
#endif /* FEATURE_MVS */

#include "rrcnv.h"
#ifdef FEATURE_WCDMA_HS_FACH
#include "rrcenhstateproc.h"
#include "rrcenhstatecfg.h"
#endif

#include "seq.h"
#include "event.h"

#include "rrcmisc.h"
#include "rrclogging.h"
#include "rrclog.h"
/*===================================================================
                        FORWARD DECLARATIONS
=====================================================================*/
  
#ifdef FEATURE_WCDMA_FREE_FLOATING_TASK
  rex_crit_sect_type            rrc_ul_tx_pwr_mutex;
  rrcllcoc_l1_ul_init_pwr_type  rrc_ul_init_pwr;
#endif

#ifdef FEATURE_VOC_AMR_WB

/* Flag to indicate that RRC is in charge of the Vocoder */
extern boolean rrciho_mvs_control_flag ;
extern boolean mn_has_nas_already_acquired_voc(void);
#if defined(FEATURE_DUAL_SIM) && defined(FEATURE_DUAL_ACTIVE)
extern boolean mn_has_nas_already_acquired_voc_subs(sys_modem_as_id_e_type as_id);
#endif
#endif /* FEATURE_VOC_AMR_WB */

/*===================================================================
                        DATA DECLARATIONS
=====================================================================*/
extern boolean rrc_log_inter_freq_hho_started;
#ifdef FEATURE_MVS
/* Introduced this global to give the dl_amr_mode */
mvs_amr_mode_type rrc_dl_amr_mode;
#endif /* FEATURE_MVS */

rrcllc_transition_config_type  transition_config;
ordered_config_type *ordered_config_ptr;
ordered_config_type *current_config_ptr;


/* Global to backup the UL RLC size */
ul_rlc_size_info rrc_old_ul_rlc_size_backup[MAX_NO_USER_RB];

rrc_state_e_type  rrc_ordered_state = RRC_STATE_MAX;

boolean ul_reestab_for_pch_trans = FALSE;

/* Used for configuration of lower layers during cell reselection */
ordered_config_type *reselection_config_ptr;

/* This has complete status of Ordered Config */
rrcllc_oc_complete_status_type  ordered_config;

rrcllc_config_e_type config_ptr_in_use;


/*Typical life span of this variable is as below
CSP sends Channel config for change in SIB5 :sets from CELL_CHANGE_INACTIVE -> CELL_CHANGE_ACTIVE
LLC processes channel config and sets from ACTIVE to either NO_CHANGE_IN_CELL_CAP/CELL_CAP_CHANGED/SIB5CHANGE_HSRACH_DELAY_CU
Channel configuration confirm will reset the variable to INACTIVE
*/
rrcllc_sib5_change_type is_sib5_change_in_progress = CELL_CHANGE_INACTIVE;

rrc_hsdpa_msg_struct_type hsdpa_msg_params;

mac_hs_queue_struct_type tmp_queue_info[UE_MAX_HS_QUEUE];

/* HSDPA + CM is enabled by default */
uint8 hsdpa_cm_enabled = TRUE;

extern rrcllc_cm_status_e_type cm_status_from_ota_msg;

#ifdef FEATURE_WCDMA_MIMO
rrc_mimo_status_enum_type rrc_mimo_status = RRC_MIMO_INACTIVE;
#endif /*FEATURE_WCDMA_MIMO*/

/*rrc_rb_list_mapped_to_dch is used to store the list of RBs that are 
mapped to DCH and for whcih RLC PDU size has changed. This list is 
used by procedures while sending channel config req to LLC.*/
rrcllc_rb_list_mapped_to_dch_type rrc_rb_list_mapped_to_dch;

/* Booleans kepts for checking of invalid config as per 25.331 8.6.5.2
If the IE "Transport format combination set" is not included for either the uplink or the downlink 
and for that direction after the reconfiguration there is one or more DCH; and
1> if no transport format combination set is stored in the UE; or
1> if transport channels are added or removed in the message; or
1> if any transport channel is reconfigured in the message such that the size of the 
   transport format set is changed: 
the UE shall:
1> set the variable INVALID_CONFIGURATION to TRUE.
*/
boolean ul_tfcs_needed = FALSE;
boolean dl_tfcs_needed = FALSE;
boolean ul_tfcs_rcvd = FALSE;
boolean dl_tfcs_rcvd = FALSE;

#if defined(FEATURE_AS_MVS_ENHANCED_AMR_PROCESSING)
rrc_amr_info_type rrc_amr_info; /* storing MVS conf values to be used W Acquires the VOC */
#endif /*FEATURE_AS_MVS_ENHANCED_AMR_PROCESSING*/

/********************************************************************
* End ORDERED_CONFIG definition
*********************************************************************/

/*===================================================================
                        CONSTANTS
=====================================================================*/
/*
* The following constants are used when determining the Logical
* channel mapping information for the vocoder AMR Modes and Classes.
* Some of these are not actually used in the code anywhere, but it's
* nice to have them here for completeness.  The unused ones are
* commented out to prevent lint complaints.
*/
/* #define WVS_AMR_MODE_CLASS_C_0_BIT_SIZE     0 */

/* AMR 4.75 kbps speech */
#define WVS_AMR_MODE_475_CLASS_A_BIT_SIZE  42
#define WVS_AMR_MODE_475_CLASS_B_BIT_SIZE  53
/* #define WVS_AMR_MODE_475_CLASS_C_BIT_SIZE  WVS_AMR_MODE_CLASS_C_0_BIT_SIZE */

/* AMR 5.15 kbps speech */
#define WVS_AMR_MODE_515_CLASS_A_BIT_SIZE  49
#define WVS_AMR_MODE_515_CLASS_B_BIT_SIZE  54
/* #define WVS_AMR_MODE_515_CLASS_C_BIT_SIZE  WVS_AMR_MODE_CLASS_C_0_BIT_SIZE */

/* AMR 5.90 kbps speech */
#define WVS_AMR_MODE_590_CLASS_A_BIT_SIZE  55
#define WVS_AMR_MODE_590_CLASS_B_BIT_SIZE  63
/* #define WVS_AMR_MODE_590_CLASS_C_BIT_SIZE  WVS_AMR_MODE_CLASS_C_0_BIT_SIZE */

/* AMR 6.70 kbps speech */
#define WVS_AMR_MODE_670_CLASS_A_BIT_SIZE  58
#define WVS_AMR_MODE_670_CLASS_B_BIT_SIZE  76
/* #define WVS_AMR_MODE_670_CLASS_C_BIT_SIZE  WVS_AMR_MODE_CLASS_C_0_BIT_SIZE */

/* AMR 7.40 kbps speech */
#define WVS_AMR_MODE_740_CLASS_A_BIT_SIZE  61
#define WVS_AMR_MODE_740_CLASS_B_BIT_SIZE  87
/* #define WVS_AMR_MODE_740_CLASS_C_BIT_SIZE  WVS_AMR_MODE_CLASS_C_0_BIT_SIZE */

/* AMR 7.95 kbps speech */
#define WVS_AMR_MODE_795_CLASS_A_BIT_SIZE  75
#define WVS_AMR_MODE_795_CLASS_B_BIT_SIZE  84
/* #define WVS_AMR_MODE_795_CLASS_C_BIT_SIZE  WVS_AMR_MODE_CLASS_C_0_BIT_SIZE */

/* AMR 10.2 kbps speech */
#define WVS_AMR_MODE_102_CLASS_A_BIT_SIZE  65
#define WVS_AMR_MODE_102_CLASS_B_BIT_SIZE  99
#define WVS_AMR_MODE_102_CLASS_C_BIT_SIZE  40

/* AMR 12.2 kbps speech */
#define WVS_AMR_MODE_122_CLASS_A_BIT_SIZE  81
#define WVS_AMR_MODE_122_CLASS_B_BIT_SIZE 103
#define WVS_AMR_MODE_122_CLASS_C_BIT_SIZE  60

/* AMR Mode 8 (SID) */
#define RRCLLC_AMR_MODE_8_CLASS_A_BIT_SIZE   39
/* #define RRCLLC_AMR_MODE_8_CLASS_B_BIT_SIZE    0 */
/* #define RRCLLC_AMR_MODE_8_CLASS_C_BIT_SIZE    WVS_AMR_MODE_CLASS_C_0_BIT_SIZE */

/* AMR Mode 15 (SID) */
/* #define RRCLLC_AMR_MODE_15_CLASS_A_BIT_SIZE   0 */
/* #define RRCLLC_AMR_MODE_15_CLASS_B_BIT_SIZE   0 */
/* #define RRCLLC_AMR_MODE_15_CLASS_C_BIT_SIZE   WVS_AMR_MODE_CLASS_C_0_BIT_SIZE */

#define RRCLLC_AMR_WB_CLASS_NO_DATA_FRAME_SIZE 0

#define RRCLLC_AMR_WB_CLASS_A_BIT_SIZE  40


#define  WVS_AMR_WB_MODE_475_TOTAL_BITS  (WVS_AMR_MODE_475_CLASS_A_BIT_SIZE + \
                                                                                 WVS_AMR_MODE_475_CLASS_B_BIT_SIZE)
#define  WVS_AMR_MODE_515_TOTAL_BITS (WVS_AMR_MODE_515_CLASS_A_BIT_SIZE + \
                                                                          WVS_AMR_MODE_515_CLASS_B_BIT_SIZE)
#define WVS_AMR_MODE_590_TOTAL_BITS (WVS_AMR_MODE_590_CLASS_A_BIT_SIZE + \
                                                                          WVS_AMR_MODE_590_CLASS_B_BIT_SIZE)
#define WVS_AMR_MODE_670_TOTAL_BITS (WVS_AMR_MODE_670_CLASS_A_BIT_SIZE + \
                                                                          WVS_AMR_MODE_670_CLASS_B_BIT_SIZE) 
#define WVS_AMR_MODE_740_TOTAL_BITS (WVS_AMR_MODE_740_CLASS_A_BIT_SIZE + \
                                                                         WVS_AMR_MODE_740_CLASS_B_BIT_SIZE)
#define WVS_AMR_MODE_795_TOTAL_BITS (WVS_AMR_MODE_795_CLASS_A_BIT_SIZE + \
                                                                         WVS_AMR_MODE_795_CLASS_B_BIT_SIZE)
#define WVS_AMR_MODE_102_TOTAL_BITS (WVS_AMR_MODE_102_CLASS_A_BIT_SIZE + \
             WVS_AMR_MODE_102_CLASS_B_BIT_SIZE + WVS_AMR_MODE_102_CLASS_C_BIT_SIZE)
#define WVS_AMR_MODE_122_TOTAL_BITS (WVS_AMR_MODE_122_CLASS_A_BIT_SIZE + \
             WVS_AMR_MODE_122_CLASS_B_BIT_SIZE + WVS_AMR_MODE_122_CLASS_C_BIT_SIZE)

#ifdef FEATURE_VOC_AMR_WB

/* WB_AMR  6.60 kbps Speech carries 132 bits in total */
#define WVS_AMR_WB_MODE_660_CLASS_A_BIT_SIZE  54
#define WVS_AMR_WB_MODE_660_CLASS_B_BIT_SIZE  78

/* WB_AMR  8.85 kbps Speech carries 177 bits in total */
#define WVS_AMR_WB_MODE_885_CLASS_A_BIT_SIZE  64
#define WVS_AMR_WB_MODE_885_CLASS_B_BIT_SIZE  113

/* WB_AMR  12.65, 4.25. 15.85, 18.25, 19.85. 23.05,23.85 
 * kbps Speech 
 */
#define WVS_AMR_WB_MODE_1265_TO_2385_CLASS_A_BIT_SIZE 72

/* WB_AMR  12.65 kbps Speech carries 253 bits in total */
#define WVS_AMR_WB_MODE_1265_CLASS_B_BIT_SIZE 181

/* WB_AMR  14.25 kbps Speech carries 285 bits in total */
#define WVS_AMR_WB_MODE_1425_CLASS_B_BIT_SIZE 213

/* WB_AMR  15.85 kbps Speech carries 317 bits in total */
#define WVS_AMR_WB_MODE_1585_CLASS_B_BIT_SIZE 245

/* WB_AMR  18.25 kbps Speech carries 365 bits in total */
#define WVS_AMR_WB_MODE_1825_CLASS_B_BIT_SIZE 293

/* WB_AMR  19.85 kbps Speech carries 397 bits in total */
#define WVS_AMR_WB_MODE_1985_CLASS_B_BIT_SIZE 325

/* WB_AMR  23.05 kbps Speech carries 461 bits in total */
#define WVS_AMR_WB_MODE_2305_CLASS_B_BIT_SIZE 389

/* WB_AMR  23.85 kbps Speech carries 477 bits in total */
#define WVS_AMR_WB_MODE_2385_CLASS_B_BIT_SIZE 405

#define WVS_AMR_WB_MODE_660_TOTAL_BITS (WVS_AMR_WB_MODE_660_CLASS_A_BIT_SIZE + \
                                                                            WVS_AMR_WB_MODE_660_CLASS_B_BIT_SIZE)
#define WVS_AMR_WB_MODE_885_TOTAL_BITS (WVS_AMR_WB_MODE_885_CLASS_A_BIT_SIZE + \
                                                                            WVS_AMR_WB_MODE_885_CLASS_B_BIT_SIZE)
#define WVS_AMR_WB_MODE_1265_TOTAL_BITS (WVS_AMR_WB_MODE_1265_TO_2385_CLASS_A_BIT_SIZE + \
                                                                           WVS_AMR_WB_MODE_1265_CLASS_B_BIT_SIZE)
#define WVS_AMR_WB_MODE_1425_TOTAL_BITS (WVS_AMR_WB_MODE_1265_TO_2385_CLASS_A_BIT_SIZE+  \
                                                                           WVS_AMR_WB_MODE_1425_CLASS_B_BIT_SIZE)
#define WVS_AMR_WB_MODE_1585_TOTAL_BITS (WVS_AMR_WB_MODE_1265_TO_2385_CLASS_A_BIT_SIZE + \
                                                                           WVS_AMR_WB_MODE_1585_CLASS_B_BIT_SIZE)
#define WVS_AMR_WB_MODE_1825_TOTAL_BITS (WVS_AMR_WB_MODE_1265_TO_2385_CLASS_A_BIT_SIZE +  \
                                                                           WVS_AMR_WB_MODE_1825_CLASS_B_BIT_SIZE)
#define WVS_AMR_WB_MODE_1985_TOTAL_BITS (WVS_AMR_WB_MODE_1265_TO_2385_CLASS_A_BIT_SIZE +  \
                                                                           WVS_AMR_WB_MODE_1985_CLASS_B_BIT_SIZE)
#define WVS_AMR_WB_MODE_2305_TOTAL_BITS (WVS_AMR_WB_MODE_1265_TO_2385_CLASS_A_BIT_SIZE +  \
                                                                         WVS_AMR_WB_MODE_2305_CLASS_B_BIT_SIZE)
#define WVS_AMR_WB_MODE_2385_TOTAL_BITS (WVS_AMR_WB_MODE_1265_TO_2385_CLASS_A_BIT_SIZE +  \
                                                                         WVS_AMR_WB_MODE_2385_CLASS_B_BIT_SIZE)
#endif /*FEATURE_VOC_AMR_WB*/

#define RRCLLC_INVALID_TRCH_ID                0xFFFF
#define RRCLLC_INVALID_LC_ID                0xFFFF

#ifdef FEATURE_WCDMA_DB_DC_HSDPA
/*Global structure to store the number of DB-DC band combinations supported*/
extern rrcueci_db_dc_band_storage_type db_dc_band_comb_list;
#endif
boolean rrc_predef_po3_not_needed = FALSE;
#define RRC_AMR_RATE_SIZE 9

#define RRCLLC_SIM_NOT_INSERTED_DRX_LENGTH 256

/*===================================================================
                        FORWARD DECLARATIONS
=====================================================================*/
/* To store new cm list */
l1_cm_tgp_seq_info_struct_type  tgp_seq_info[L1_CM_MAX_TGP_SEQ_COUNT];



/*===========================================================================
** -----------------------------------------------------------------------------------
**-- ----------NON-Demand paging section Srart--------------------------------------------
** -----------------------------------------------------------------------------------
  This section will have code section that will not be demand paged. Function which should be in this section are
  -RRC functions that are called by L1/L2 which are higher priority then RRC
  -RRC functions that are called in ISR context or RTOS timer call back
  -RRC functions that indirectly gets called by L1/L2 /ISR/timer call back   
  For example: Fun1() gets called by L1. Fun2() is called by Fun1(). Now both  Fun1() & Fun2() should be NON demand paged, 
  so both should be added in this section  
  Usage of pragma 
  __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED__
  void foo(void)
  {
    function body here
  }
        __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED_END__
  If you have another function to be added in the same section then again it needs to be wrapped with these pragma 
  for example:- function bar() is just below function foo() then function bar() needs to be written like this …. 
  __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED__
  void bar(void)
  {
    function body here
  }
  __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED_END__
** ----------------------------------------------------------------------- */



/*====================================================================
FUNCTION: rrc_query_crnti()

DESCRIPTION:
  This function returns the C-RNTI if it is valid in the Current Config.
  If Current Config does not have a valid CRNTI but a valid CRNTI exists
  in Ordered Config, that is understood as a valid CRNTI status.

DEPENDENCIES:
  This will be called by L1 to do GSM measurementse in CONNECTED state.

RETURN VALUE:
  boolean - TRUE indicates C-RNTI value will be filled in the c-rnti pointer
            FALSE indicates no C-RNTI

SIDE EFFECTS:
  None.
====================================================================*/
/***/ __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED__ /***/
boolean
rrc_query_crnti(uint16 *c_rnti)
{

  /* If lower layers are already configured with OC, check OC before
     Checking CC */

  rrcllc_oc_set_status_e_type oc_status = rrcllc_get_ordered_config_status_wo_f3();

  if ((oc_status != OC_NOT_SET ) &&
      (ordered_config.process_state == LL_CONFIG_WITH_OC) &&
      ((ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid == CRNTI_VALID)||
       (ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid == BOTH_VALID)) )
  {
    *c_rnti = ordered_config_ptr->mac_dl_parms.rnti_info.crnti;
    return TRUE;
  }
  else if ((current_config_ptr->mac_dl_parms.rnti_info.rnti_valid == CRNTI_VALID)||
           (current_config_ptr->mac_dl_parms.rnti_info.rnti_valid == BOTH_VALID))
  {
    *c_rnti = current_config_ptr->mac_dl_parms.rnti_info.crnti;
    return TRUE;
  }
  else
  {
    return FALSE;
  }  /* No valid C_RNTI in Current Config */
} /* rrc_query_crnti */
/***/ __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED_END__ /***/

/*====================================================================
FUNCTION: rrcllc_get_ordered_config_status()

DESCRIPTION:
  This function checks if ORDERED_CONFIG is set. If so, it
  returns TRUE. If it's not set it returns FALSE.

DEPENDENCIES:
  None.

RETURN VALUE:
  Returns a value that indicates if Ordered Config is set for
  an RRC state or not set.

SIDE EFFECTS:
  None.
====================================================================*/
/***/ __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED__ /***/

rrcllc_oc_set_status_e_type rrcllc_get_ordered_config_status( void )
{
  if(ordered_config.set_status != OC_NOT_SET)
  {
    WRRC_MSG2_HIGH("Get OC status rrcllc_oc_set_status_e_type_value%d proc rrc_proc_e_type_value%d",
           ordered_config.set_status, ordered_config.set_by_proc);
  }
  /* return the status of ordered_config.set_status variable */
  return ordered_config.set_status;

} /* end rrcllc_get_ordered_config_status() */
/***/ __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED_END__ /***/

/*====================================================================
FUNCTION: rrcllc_get_ordered_config_status_wo_f3()

DESCRIPTION:
  This function checks if ORDERED_CONFIG is set. If so, it
  returns TRUE. If it's not set it returns FALSE.

DEPENDENCIES:
  None.

RETURN VALUE:
  Returns a value that indicates if Ordered Config is set for
  an RRC state or not set.

SIDE EFFECTS:
  None.
====================================================================*/
/***/ __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED__ /***/

rrcllc_oc_set_status_e_type rrcllc_get_ordered_config_status_wo_f3( void )
{
  /* return the status of ordered_config.set_status variable */
  return ordered_config.set_status;

} /* end rrcllc_get_ordered_config_status() */
/***/ __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED_END__ /***/
/*====================================================================
FUNCTION: rrcllc_get_drx_info()

DESCRIPTION:
  This function returns the shorter of the PS or CS CN DRX Cycle
  Length.

DEPENDENCIES:
  None.

RETURN VALUE:
  uint32 of the DRX Cycle length, per 25.304.

SIDE EFFECTS:
  This function should only be called after the following function
  calls:
  - rrcllc_copy_sib_to_oc() or
  - rrcllc_set_ordered_config().
====================================================================*/
/***/ __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED__ /***/

uint32 rrcllc_get_drx_info(void)
{
  uint32 cs_drx = current_config_ptr->cs_drx_cycle_length;
  uint32 ps_drx = current_config_ptr->ps_drx_cycle_length;
  uint32 utran_drx = 0;
  rrcllc_oc_set_status_e_type oc_status;

  uint32 qchat_drx = 0;

  if(!rrc_imsi_valid)
  {
    /* If SIM is not yet inserted, configure DRX cycle with DRX length 2.56 seconds.This is as per spec */
    return RRCLLC_SIM_NOT_INSERTED_DRX_LENGTH;
  }
   oc_status = rrcllc_get_ordered_config_status_wo_f3();
   /*get the UTRAN DRX cycle length coef only if the OC is
   set for Cell_PCH or URA_PCH state transition */
   if((oc_status == OC_SET_FOR_DCH_CELL_PCH_TRANS) ||
      (oc_status == OC_SET_FOR_DCH_URA_PCH_TRANS) 
      ||(transition_config.toc_usage == TOC_FOR_OOS)
       || (transition_config.toc_usage == TOC_FOR_OOS_WITHOUT_DCH_INFO)
       || (transition_config.toc_usage == TOC_FOR_OOS_WITH_DCH_INFO)
       || (transition_config.toc_usage == TOC_FOR_FACH_AND_PCH)
       || (transition_config.toc_usage == TOC_FOR_FACH_AND_PCH_WITH_DCH_INFO)
      )
   {
     /* Read the UTRAN DRX cycle from TOC */
     /* This will take care of DCH->PCH state transition */
     utran_drx = transition_config.toc_ptr->utran_drx_cycle_length;
     cs_drx = ordered_config_ptr->cs_drx_cycle_length;
     ps_drx = ordered_config_ptr->ps_drx_cycle_length;
   }
   else if((oc_status == OC_SET_FOR_FACH_CELL_PCH_TRANS) ||
      (oc_status == OC_SET_FOR_FACH_URA_PCH_TRANS))
   {
     /* This will take care of FACH->PCH state transition with a message
   that sets ordered_reconfig variable */
     utran_drx = ordered_config_ptr->utran_drx_cycle_length;
   }
   else
   {
     /* this will take care of FACH->PCH state transition
   with a message that does not set the ordered_reconfig variable*/
     utran_drx = current_config_ptr->utran_drx_cycle_length;
   }

    /* Get the QCHAT configured drx cycle length. If there is a successfully negotiated
       PS drx coeff available, use that as the PS drx value.
       Spec ref: 25.331 - 8.3 Discontinuous Reception for Paging
       The CS CN specific DRX cycle length coefficient shall be updated locally in the UE using
       information given in system information. On the other hand, the PS CN specific DRX cycle length 
       coefficient shall be updated after the negotiation between the UE and PS CN by NAS procedure.
       If no specific value "k" is negotiated in NAS procedure, the UE and PS CN shall use the DRX
       cycle length given for PS CN domain in system information.
    */
    qchat_drx = rrc_get_qchat_specific_drx_cycle_length();
    if((qchat_drx < ps_drx) && (qchat_drx != 0))
    {
      ps_drx = qchat_drx;
    }

  /* We may not have a UTRAN DRX cycle length, so we must not consider
     it in this case.*/

   MSG_HIGH("DRX cs:%d, ps:%d, utran:%d", cs_drx,ps_drx, utran_drx);
  if(utran_drx == 0)
  {
    /* Return the DRX Cycle Length */
    if (cs_drx < ps_drx)
    {
      return cs_drx;
    }
    else
    {
      return ps_drx;
    }
  }
  else /* this is non idle case so must be cell_PCH/URA_PCH case */
  {
    /* find out the un-established domain.*/
     if ((rrcscr_get_signalling_connection_status (RRC_PS_DOMAIN_CN_ID) == FALSE) &&
         (rrcscr_get_signalling_connection_status (RRC_CS_DOMAIN_CN_ID) == TRUE))
     {
       if (ps_drx < utran_drx)
       {
         return ps_drx;
       }
       else
       {
         return utran_drx;
       }
       //return (ps_drx<utran_drx?ps_drx:utran_drx);
     }
     else if ((rrcscr_get_signalling_connection_status (RRC_CS_DOMAIN_CN_ID) == FALSE) &&
              (rrcscr_get_signalling_connection_status (RRC_PS_DOMAIN_CN_ID) == TRUE))
     {
       //return (cs_drx<utran_drx?cs_drx:utran_drx);
       if (cs_drx < utran_drx)
       {
         return cs_drx;
       }
       else
       {
         return utran_drx;
       }
     }
     else if ((rrcscr_get_signalling_connection_status (RRC_CS_DOMAIN_CN_ID) == TRUE) &&
              (rrcscr_get_signalling_connection_status (RRC_PS_DOMAIN_CN_ID) == TRUE))
     {
       return (utran_drx);
     }
     else /*((rrcscr_get_signalling_connection_status (RRC_CS_DOMAIN_CN_ID) == FALSE) &&
              (rrcscr_get_signalling_connection_status (RRC_PS_DOMAIN_CN_ID) == FALSE))*/
     {
       if(cs_drx <= ps_drx && cs_drx <= utran_drx)
       {
         return cs_drx;
       }
       else if(ps_drx <= cs_drx && ps_drx <= utran_drx)
       {
         return ps_drx;
       }
       else
       {
         return utran_drx;
       }
     }
  }
} /* end rrcllc_get_drx_info() */
/***/ __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED_END__ /***/

/*====================================================================
FUNCTION: rrcllc_get_drx_info_values()

DESCRIPTION:
  This function returns the values of the PS/CS CN DRX Cycle and DRX
  cycle in use Length.

DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
  This function should only be called after the following function
  calls:
  - rrcllc_copy_sib_to_oc() or
  - rrcllc_set_ordered_config().
====================================================================*/
void rrcllc_get_drx_info_values
(
  uint32 *cs_drx_ptr,
  uint32 *ps_drx_ptr,
  uint32 *drx_in_use
)
{
  uint32 cs_drx = current_config_ptr->cs_drx_cycle_length;
  uint32 ps_drx = current_config_ptr->ps_drx_cycle_length;
  rrcllc_oc_set_status_e_type oc_status;

  oc_status = rrcllc_get_ordered_config_status_wo_f3();
  
  /* Get the UTRAN DRX cycle length coef only if the OC is
     * set for Cell_PCH or URA_PCH state transition */
  if((oc_status == OC_SET_FOR_DCH_CELL_PCH_TRANS) 
     || (oc_status == OC_SET_FOR_DCH_URA_PCH_TRANS) 
     || (transition_config.toc_usage == TOC_FOR_OOS)
     || (transition_config.toc_usage == TOC_FOR_OOS_WITHOUT_DCH_INFO)
     || (transition_config.toc_usage == TOC_FOR_OOS_WITH_DCH_INFO)
     || (transition_config.toc_usage == TOC_FOR_FACH_AND_PCH)
     || (transition_config.toc_usage == TOC_FOR_FACH_AND_PCH_WITH_DCH_INFO)
    )
  {
    /* This will take care of DCH->PCH state transition */
    cs_drx = ordered_config_ptr->cs_drx_cycle_length;
    ps_drx = ordered_config_ptr->ps_drx_cycle_length;
  }

  *cs_drx_ptr = cs_drx;
  *ps_drx_ptr = ps_drx;
  *drx_in_use = rrcllc_get_drx_info();

  MSG_HIGH("DRX cs:%d, ps:%d, in_use:%d", cs_drx, ps_drx, *drx_in_use);
}

/*====================================================================
FUNCTION: rrc_ul_tx_pwr_ind()

DESCRIPTION:
  This function places the values of cpich tx power, ul interference,
  and a constant value defined in PRACH sys info, into the addresses
  passed into this function.

DEPENDENCIES:
  None.

RETURN VALUE:
 Return True only if UE is camped and not in DCH state

SIDE EFFECTS:
  None.
====================================================================*/
/***/ __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED__ /***/
boolean rrc_ul_tx_pwr_ind
(
  int8 *cpich_tx_pwr,
  int8 *ul_if,
  int8 *const_val
)
{
#ifdef FEATURE_WCDMA_FREE_FLOATING_TASK
  REX_ISR_LOCK(&rrc_ul_tx_pwr_mutex);
  *cpich_tx_pwr = (int8) rrc_ul_init_pwr.primary_cpich_tx_power;
  *ul_if     = (int8) rrc_ul_init_pwr.ul_interference;
  *const_val   = (int8) rrc_ul_init_pwr.constant_value;
  REX_ISR_UNLOCK(&rrc_ul_tx_pwr_mutex);
#else
  /* Return the values from Ordered_Config if reselection is not in progress */
  if((config_ptr_in_use == ORDERED_CONFIG) && (FALSE == rrc_ccm_is_reselection_in_progress()))
  {
#ifdef FEATURE_WCDMA_HS_RACH  
    if(TRUE == rrchsrach_get_ready_for_common_edch(ordered_config_ptr))
    {
     *cpich_tx_pwr =  ordered_config_ptr->rrc_ul_pwr_init_parms.cpich_tx_pwr;
     *ul_if		  =  ordered_config_ptr->rrc_ul_pwr_init_parms.ul_interference_commonedch;
     *const_val	  =  ordered_config_ptr->rrc_ul_pwr_init_parms.const_val;
    }
    else
#endif		
    {
   *cpich_tx_pwr = (int8) ordered_config_ptr->rrc_ul_pwr_init_parms.primary_cpich_tx_power;
   *ul_if		  = (int8) ordered_config_ptr->rrc_ul_pwr_init_parms.ul_interference;
   *const_val	  = (int8) ordered_config_ptr->rrc_ul_pwr_init_parms.constant_value;
  }
  }
  else
  {
#ifdef FEATURE_WCDMA_HS_RACH  
    if(TRUE == rrchsrach_get_ready_for_common_edch(current_config_ptr))
    {
       *cpich_tx_pwr =  current_config_ptr->rrc_ul_pwr_init_parms.cpich_tx_pwr;
       *ul_if		   =  current_config_ptr->rrc_ul_pwr_init_parms.ul_interference_commonedch;
       *const_val	   =  current_config_ptr->rrc_ul_pwr_init_parms.const_val;
    }
  else
#endif		
  {
    *cpich_tx_pwr = (int8) current_config_ptr->rrc_ul_pwr_init_parms.primary_cpich_tx_power;
    *ul_if		  = (int8) current_config_ptr->rrc_ul_pwr_init_parms.ul_interference;
    *const_val	  = (int8) current_config_ptr->rrc_ul_pwr_init_parms.constant_value;
  }
  }
#endif
 /*Return false if state is DCH or UE is not camped and reselection is not in progress*/
 if((RRC_STATE_CELL_DCH == rrc_get_state()) ||
   (((RRC_CAMPED_ON != rrc_ccm_get_curr_camping_status(RRC_PROCEDURE_SIB)) && (FALSE == rrc_ccm_is_reselection_in_progress()))
 #ifdef FEATURE_DUAL_SIM
   && (rrc_csp_int_data.curr_scan != RRC_CSP_UNLOCK_BY_SCAN)
 #endif
    ))
 {
   return FALSE;
 }

 return TRUE;

} /* end rrc_ul_tx_pwr_ind() */
/***/ __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED_END__ /***/

#ifdef FEATURE_WCDMA_MIMO
/*============================================================================
FUNCTION: rrcllc_get_mimo_action_in_config()

DESCRIPTION:


DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
/***/ __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED__ /***/

l1_dl_hs_mimo_action_enum_type 
  rrcllc_get_mimo_action_in_config
(
  void
)
{
  if(config_ptr_in_use == ORDERED_CONFIG)
  {
   return (ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action);
  }
  else
  {
    return( current_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action);
  }
}
/***/ __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED_END__ /***/

/*============================================================================
FUNCTION: rrcllc_get_mimo_status()

DESCRIPTION:


DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
/***/ __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED__ /***/

rrc_mimo_status_enum_type rrcllc_get_mimo_status
(
   void
)
{
  WRRC_MSG1_HIGH("MIMO:MIMO Status is  %d",rrc_mimo_status);
  return rrc_mimo_status;
}
/***/ __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED_END__ /***/

#endif

/*===================================================================
*                       FUNCTION PROTOTYPES
====================================================================*/

/*===================================================================
                        EXTERNAL FUNCTIONS
=====================================================================*/
/* The declarations for these functions are in rrcllc.h */
#ifdef FEATURE_MVS
/*============================================================================
FUNCTION: rrc_mvssup_get_dl_amr_mode()

DESCRIPTION:
This function gets the DL AMR mode

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
=============================================================================*/
mvs_amr_mode_type rrc_mvssup_get_dl_amr_mode
(
  void 
)
{
  WRRC_MSG1_HIGH("RRC: Get AMR mode returned %d ",rrc_dl_amr_mode);
  return rrc_dl_amr_mode;
}
#endif
/*====================================================================
FUNCTION: rrcllc_allocate_dflow_index()

DESCRIPTION:
  Allocates a Dflow Id.

DEPENDENCIES:
  None.

RETURN VALUE:
  uint8 -> A DL DCH TrCH Index that was already allocated to
           given transport channel ID.
  RRCLLC_INVALID_TRCH_IDX -> Given Transport channel ID does not
           have an allocated DCH transport channel index.

SIDE EFFECTS:
====================================================================*/
uint8  rrcllc_allocate_dflow_index()
{

  uint8 cnt = UE_MAX_MAC_D_FLOW;
  /* An index with the same DFLOW ID is NOT in use.
  * Allocate a new index */
  for (cnt =0; cnt <UE_MAX_MAC_D_FLOW; cnt++)
  {
    if ((ordered_config_ptr->dl_dflow_index_in_use[cnt] == FALSE) &&
      (ordered_config_ptr->mac_dflow_info[cnt].mac_dflow_id == INVALID_DFLOW_ID))
    {
      WRRC_MSG1_HIGH("RRCHS:Assign Index %d for new DFLOW", cnt);
      ordered_config_ptr->dl_dflow_index_in_use[cnt] = TRUE;
      break;
    }
  }
  return cnt;

} /* rrcllc_allocate_dflow_index */

/*====================================================================
FUNCTION: rrcllc_allocate_queue_index()

DESCRIPTION:
  Allocates a Queue Index for the queue.

DEPENDENCIES:
  None.

RETURN VALUE:
  Queue Index if found/allocated else UE_MAX_HS_QUEUE

SIDE EFFECTS:
====================================================================*/
static uint8  rrcllc_allocate_queue_index(uint8 dflow_index, uint32 queue_id)
{
  uint8 cnt = UE_MAX_HS_QUEUE;
  /* An index with the same DFLOW ID is NOT in use. Allocate a new index */

  if (ordered_config_ptr->mac_dflow_info[dflow_index].no_of_queues == UE_MAX_HS_QUEUE)
  {
    WRRC_MSG2_ERROR("RRCHS:Num Queues %d with dflow %d",ordered_config_ptr->mac_dflow_info[dflow_index].no_of_queues
        ,ordered_config_ptr->mac_dflow_info[dflow_index].mac_dflow_id);

    return cnt;
  }
  for (cnt =0; cnt <UE_MAX_HS_QUEUE; cnt++)
  {
    if (ordered_config_ptr->mac_dflow_info[dflow_index].queue_info[cnt].queue_id == INVALID_QUEUE_ID)
    {
      WRRC_MSG2_HIGH("RRCHS:Assign Index %d for queue %d", cnt,queue_id);
      ordered_config_ptr->mac_dflow_info[dflow_index].queue_info[cnt].queue_id = (uint8) queue_id;
      ordered_config_ptr->mac_dflow_info[dflow_index].no_of_queues++;
      return cnt;
    }
  }
  return cnt;

} /* rrcllc_allocate_queue_index */


/*====================================================================
FUNCTION: rrcllc_find_dflow_idx()

DESCRIPTION:
  This function finds the dflow index for the DFLOW. If not found, it allocates
  a new index and return to the index number.

DEPENDENCIES:
  None.

RETURN VALUE:
  DFLOW Index if found
  Else UE_MAX_MAC_D_FLOW.

SIDE EFFECTS:
====================================================================*/
uint8  rrcllc_find_dflow_index
(
  uint8  dflow_id
)
{
  uint8 index = UE_MAX_MAC_D_FLOW;

  for(index = 0; index < UE_MAX_MAC_D_FLOW; index++)
  {
    if((ordered_config_ptr->dl_dflow_index_in_use[index] == TRUE) &&
      (ordered_config_ptr->mac_dflow_info[index].mac_dflow_id == dflow_id))
    {
      WRRC_MSG2_HIGH("RRCHS:DFLOWidx %d, Id %d",index, dflow_id);

      break;
    }
  }
  return(index);
}

/*====================================================================
FUNCTION: rrcllc_init_dflow_rb_mapping_info()

DESCRIPTION:
  This function initializes the Downlink RB Mapping Info table for that
  particular MAC-D Flow Identifier in MAC D Flow structure

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_dflow_rb_mapping_info
(
  ordered_config_type  *config_ptr,
  uint8  ix
)
{
  /* local loop variable */
  uint8 iy;

  /* Make the dflow index available */
  config_ptr->mac_dflow_info[ix].mac_dflow_id = INVALID_DFLOW_ID;

  /* No Dedicated Logical Channels now */
  config_ptr->mac_dflow_info[ix].ndlchan = 0;

  config_ptr->mac_dflow_info[ix].no_of_queues = 0;

  for(iy = 0; iy < UE_MAX_HS_QUEUE; iy++)
  {
    config_ptr->mac_dflow_info[ix].queue_info[iy].queue_id = INVALID_QUEUE_ID;

    config_ptr->mac_dflow_info[ix].queue_info[iy].no_of_pdu_sizes = 0;

    config_ptr->mac_dflow_info[ix].queue_info[iy].release_timer = 0;

    config_ptr->mac_dflow_info[ix].queue_info[iy].window_size = 0;

  }

  /* Clear out all Logical Channel info for this TrCH */
  for(iy = 0; iy < MAX_DED_LOGCHAN_PER_TRCH; iy++)
  {
    /* LLC will clear out the RB ID and RLC ID */
    config_ptr->mac_dflow_info[ix].dlchan_info[iy].mac_id = 0;
  }

  return;

} /* end rrcllc_init_dl_dch_rb_mapping_info */


/*====================================================================
FUNCTION: rrcllc_deallocate_dflow_index()

DESCRIPTION:
  This function deallocates a DFLOW Index specified by passed pointer
  so that it can be used Later

DEPENDENCIES:
  None.

RETURN VALUE:
  ue_comdef_status_e_type -> SUCCESS/FAILURE
SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_deallocate_dflow_index
(
  uint8 dflow_index
)
{
  uecomdef_status_e_type status = SUCCESS;

  /*
  * Check to make sure that the DFLOW Index is in range
  */
  if(dflow_index < UE_MAX_MAC_D_FLOW)
  {
    ordered_config_ptr->dl_dflow_index_in_use[dflow_index] = FALSE;
  }
  else
  {
    /* Bad DFLOW Index */
    WRRC_MSG1_HIGH("RRCHS:Invalid DFLOW Index %d",dflow_index);
    status = FAILURE;
  }

  return status;
} /* end rrcllc_deallocate_dflow_index() */


/*====================================================================
FUNCTION: rrcllc_initialize_queue_info()

DESCRIPTION:
  This function deallocates all the queues associated with a DFLOW

DEPENDENCIES:
  None.

RETURN VALUE:
  None.
  
SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_initialize_queue_info
(
  uint8 dflow_index
)
{
  uint8 cnt = 0;

  for (cnt = 0; cnt < ordered_config_ptr->mac_dflow_info[dflow_index].no_of_queues; cnt++)
  {
    ordered_config_ptr->mac_dflow_info[dflow_index].queue_info[cnt].queue_id = INVALID_QUEUE_ID;
    ordered_config_ptr->mac_dflow_info[dflow_index].queue_info[cnt].no_of_pdu_sizes = 0;
    ordered_config_ptr->mac_dflow_info[dflow_index].queue_info[cnt].release_timer = 0;
    ordered_config_ptr->mac_dflow_info[dflow_index].queue_info[cnt].window_size = 0;
  }
  ordered_config_ptr->mac_dflow_info[dflow_index].no_of_queues = 0;
} /* end rrcllc_initialize_queue_info() */




/*====================================================================
FUNCTION: rrcllc_get_dflow_index()

DESCRIPTION:
  This function gets a DFLOW Index for the specified DFLOW ID. If the
  DFLOW already existed, its index is returned. Otherwise a new index is
  allocated for the DFLOW ID. If a new DFLOW index is allocated,
  DFLOW count in MAC structure is updated.

DEPENDENCIES:
  None.

RETURN VALUE:
  Index value if successful else
  UE_MAX_MAC_D_FLOW if no index is available

SIDE EFFECTS:

====================================================================*/

uint8 rrcllc_get_dflow_index
(
  uint8  dflow_id
)
{
  /* To indicate if DFLOW Index has been founf */
  boolean       dflow_index_found = FALSE;

  uint8 index = UE_MAX_MAC_D_FLOW;

  for(index = 0; index < UE_MAX_MAC_D_FLOW; index++)
  {
    if((ordered_config_ptr->dl_dflow_index_in_use[index] == TRUE) &&
      (ordered_config_ptr->mac_dflow_info[index].mac_dflow_id == dflow_id))
    {
      WRRC_MSG2_HIGH("RRCHS:DFLOWidx %d, Id %d",index, dflow_id);

      dflow_index_found = TRUE;

      break;
    }
  }

  if(dflow_index_found)
  {
    return(index);
  }
  else  /* DFLOW index not found, Allocate new */
  {
    index = rrcllc_allocate_dflow_index();
    if(index == UE_MAX_MAC_D_FLOW)
    {
      /* Failure to allocate a new DFLOW Index */
      return(UE_MAX_MAC_D_FLOW);
    }
    else  /* A valid new DFLOW index has been allocated */
    {

      /* Now Save DFLOW ID in MAC structure */
      ordered_config_ptr->mac_dflow_info[index].mac_dflow_id = dflow_id;

      /* Increment no of DFLOWs */
      ordered_config_ptr->mac_dl_parms.num_dflow++;

      WRRC_MSG1_HIGH("RRCHS:New dflow cnt %d in MAC struct", ordered_config_ptr->mac_dl_parms.num_dflow);

      return(index);

    } /* A valid new DFLOW index allocated */
  } /* DFLOW index not found, Allocate new */
} /* rrcllc_get_dflow_index */


/*====================================================================
FUNCTION: rrcllc_remove_dflow_queue_mapping()

DESCRIPTION:

  This function removes the association of former dflow associated
  with the queue. The dflow associated with this queue in the passed
  ptr is the new DFLOW

DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:

====================================================================*/
void rrcllc_remove_dflow_queue_mapping
(
  rrc_MAC_hs_AddReconfQueue* queue_ptr
)
{
  /* transport Channel Index */
  uint8  dflow_index = 0;

  uint32  queue_index = 0;

  /* Check if queue is is already present */
  for(dflow_index = 0; dflow_index < ordered_config_ptr->mac_dl_parms.num_dflow; dflow_index++)
  {
    if ((ordered_config_ptr->mac_dflow_info[dflow_index].mac_dflow_id == INVALID_DFLOW_ID) ||
        (ordered_config_ptr->dl_dflow_index_in_use[dflow_index]  == FALSE))

      continue;

    for(queue_index = 0; queue_index < ordered_config_ptr->mac_dflow_info[dflow_index].no_of_queues;
         queue_index++)
    {
      if (ordered_config_ptr->mac_dflow_info[dflow_index].queue_info[queue_index].queue_id == INVALID_QUEUE_ID)
        continue;

      /* Find if queue Id is same but dflow id is different */
      if ((ordered_config_ptr->mac_dflow_info[dflow_index].queue_info[queue_index].queue_id ==
          queue_ptr->mac_hsQueueId) &&
          (ordered_config_ptr->mac_dflow_info[dflow_index].mac_dflow_id != queue_ptr->mac_dFlowId))
      {
        WRRC_MSG2_HIGH("RRCHS:Remove DFLOW %d association with Queue %d",
                 queue_ptr->mac_dFlowId,queue_ptr->mac_hsQueueId);
        /* Take the backup of the RB-Mapping , as the DFlow is been deleted */
        rrcllc_backup_rbmapping_info(dflow_index,MAC_D_RB_MAPPING );
        ordered_config_ptr->mac_dflow_info[dflow_index].mac_dflow_id = INVALID_DFLOW_ID;

        ordered_config_ptr->mac_dflow_info[dflow_index].queue_info[queue_index].queue_id = INVALID_QUEUE_ID;

        ordered_config_ptr->mac_dflow_info[dflow_index].queue_info[queue_index].no_of_pdu_sizes = 0;

        ordered_config_ptr->mac_dflow_info[dflow_index].queue_info[queue_index].release_timer = 0;

        ordered_config_ptr->mac_dflow_info[dflow_index].queue_info[queue_index].window_size = 0;

        ordered_config_ptr->mac_dflow_info[dflow_index].no_of_queues = 0;
      }
    }
  }
}


/*====================================================================
FUNCTION: rrcllc_get_queue_index()

DESCRIPTION:

  This function gets a Queue Index for the specified DFLOW ID. If the
  Queue already existed, its index is returned. Otherwise a new queue index is
  allocated for the DFLOW ID. The queue count for that index is also
  incremented. The fn also fills the passed queue already present indicator
  if the queue is already present.

DEPENDENCIES:
  None.

RETURN VALUE:
  Queue Index if successfully allocated else UE_MAX_HS_QUEUE

SIDE EFFECTS:

====================================================================*/
uint8 rrcllc_get_queue_index
(
  uint8  dflow_index,
  uint32 queue_id,
  boolean* queue_present_ptr
)
{
  /* transport Channel Index */
  uint8         index = 0;

  /* Initialize by default indicating that queue is absent */
  *queue_present_ptr = FALSE;

  /* Check if queue is is already present */
  for(index = 0; index < ordered_config_ptr->mac_dflow_info[dflow_index].no_of_queues; index++)
  {
    if(ordered_config_ptr->mac_dflow_info[dflow_index].queue_info[index].queue_id == queue_id)
    {
      WRRC_MSG2_HIGH("RRCHS:Queue id %d already present for Flow Id %d",index,
        ordered_config_ptr->mac_dflow_info[dflow_index].mac_dflow_id);

        /* This is the case when queue is already present and Network wants to
        reconfigure this queue again. Set a boolean indicating this condition */

      *queue_present_ptr = TRUE;

      break;
    }
  }

  if(*queue_present_ptr == TRUE)
  {
    /* Return queue index. */
    return(index);
  }
  else  /* Queue index not found, allocate new */
  {
    /* An index with the same Queue Id is NOT in use.Need to allocate a new index. */

    WRRC_MSG2_HIGH("RRCHS:Alloc new queue idx for FlowIdx %d,QueueId %d", dflow_index, queue_id);
    index = rrcllc_allocate_queue_index(dflow_index, queue_id);

    return index;

  } /* Existing transport channel index couldn't be found, allocated new */
} /* rrcllc_get_queue_index */


/*====================================================================
FUNCTION: rrcllc_determine_hsdpa_action_r6()

DESCRIPTION:

  This function determines the HSDPA action and sets the parameters in L1
  structure accordingly.
  
DEPENDENCIES:
  None.

RETURN VALUE:
  Sucess if HSDPA action and parameters have been set
  Failure Otherwise

SIDE EFFECTS:
  
====================================================================*/
uecomdef_status_e_type rrcllc_determine_hsdpa_action_r6
(
  rrc_DL_HSPDSCH_Information_r6* hspdsch_info_ptr
)
{
  uint8 reconfig_bit_mask = 0;
  boolean hsscch_codes_changed = FALSE;

  boolean hsdpcch_changed = FALSE;

  boolean b_table_changed = FALSE;

  /* HSDPA params have already been set in rrc_hsdpa_params.
  Check if HSDPA is already ACTIVE */
   ordered_config_ptr->mac_dl_parms.mac_hs_transition_type = MAC_HS_NO_TRANSITION;

  if (rrc_get_hsdpa_status() == HSDPA_INACTIVE)
  {
    /* HSDPA is currently inactive */
    /* Check if network wants to activate HSDPA */
    if (hsdpa_msg_params.msg_params_present == TRUE)
    {
      if (hsdpa_msg_params.hspdsch_info_present == TRUE)
      {
        /* Check if channelization codes and feedback info present */
        if ( RRC_MSG_COMMON_BITMASK_IE_PTR(hspdsch_info_ptr,rrc_DL_HSPDSCH_Information_r6,hs_scch_Info))  
        {
          if (set_hsscch_info_r6(&hspdsch_info_ptr->hs_scch_Info) == FAILURE)
          {
            return FAILURE;
          }
        }

						
        if(RRC_MSG_COMMON_BITMASK_IE_PTR(hspdsch_info_ptr,rrc_DL_HSPDSCH_Information_r6,measurement_feedback_Info))
        {
          /* Set Meas Feedback Info */
          if (set_meas_feedback_info(&hspdsch_info_ptr->measurement_feedback_Info) == FAILURE)
          {
            return FAILURE;
          }
        }
      }
      /* Set HS-RL */
      if (hsdpa_msg_params.rl_link_present == TRUE)
      {
        /* Set Radio Link in L1 HSDPA structure */
        ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc = hsdpa_msg_params.new_rl_link;
      }
    } /* End of if of hsdpa message params absent */
    else
    {
      rrc_set_hsdpa_action(HSDPA_NOOP);
      rrc_reset_mac_ehs_params(ordered_config_ptr);
      return SUCCESS;
    }

    /* Set Queue Info */
    if (set_hsdpa_l1_queue_info() == FAILURE)
    {
      WRRC_MSG0_ERROR("RRCHS:Unable to set Queue Info");
      return FAILURE;
    }

    /* Final Check to make sure that everything is present */
    if (rrcllc_check_if_hsdpa_can_be_started_reconfigured(ordered_config_ptr) == FALSE)
    {
      WRRC_MSG0_HIGH("RRCHS:HSNOOP");
      return SUCCESS;
    }
    rrc_set_hsdpa_action(HSDPA_START);

    /* Set Bit Mask */
    ordered_config_ptr->l1_hsdpa_info.hs_req_mask = CPHY_HS_DSCH_CFG_INCL | 
      CPHY_HS_PDSCH_RL_CFG_INCL | CPHY_HS_SCCH_CFG_INCL | CPHY_HS_DPCCH_CFG_INCL;
    ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 
      HS_DPCCH_BETA_HS_INFO_PRESENT_BITMASK | HS_DPCCH_MEAS_FEEDBACK_INFO_PRESENT_BITMASK;

#ifdef FEATURE_WCDMA_HS_FACH
     /*Don't reset For EFACH to MAC-HS transitions*/
    if(current_config_ptr->hs_status_in_e_fach  == FALSE)
#endif
    {
      /* In case UTRAN messes up, set HS-RESET to FALSE */      
      ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator = FALSE;
    }

     MSG_HIGH("RRCHS:HS Bit Mask/ordered_config_ptr->l1_hsdpa_info.hs_req_mask is (Dec) %d (Hex) %x and mac-hs reset indicator %d", ordered_config_ptr->l1_hsdpa_info.hs_req_mask,
             ordered_config_ptr->l1_hsdpa_info.hs_req_mask,ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator);
    
    return SUCCESS;
    
  }
  else
  {
    ordered_config_ptr->l1_hsdpa_info.hs_req_mask = 0;
    ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 0;

    /* HSDPA is already ACTIVE */
    
	      MSG_9(MSG_SSID_DFLT, MSG_LEGACY_HIGH,"hsdpa_params_present:%d,rl_link_present:%d,ifhho_involved:%d, intra_hho_involved:%d,new_rl_link:%d,hrnti_present:%d, dest_freq_present:%d, hsdpa_msg_params.hsdsch_info_present:%d, hsdpa_msg_params.hrnti_changed %d",
            hsdpa_msg_params.msg_params_present,
            hsdpa_msg_params.rl_link_present,
            hsdpa_msg_params.ifhho_involved,
            hsdpa_msg_params.intra_hho_involved,
            hsdpa_msg_params.new_rl_link,
            hsdpa_msg_params.hrnti_present,
            ordered_config_ptr->dest_freq_present,
            hsdpa_msg_params.hsdsch_info_present,
            hsdpa_msg_params.hrnti_changed
            );
    if (hsdpa_msg_params.msg_params_present == TRUE)
    {
      /* Now check if IFREQ Hard Handoff is involved */
      if ((hsdpa_msg_params.rl_link_present == FALSE) &&
        (hsdpa_msg_params.ifhho_involved == TRUE))
      {
        rrc_set_hsdpa_action(HSDPA_STOP);
        return SUCCESS;
      }
      /* Check if Intra Freq HO involved */
      if ((hsdpa_msg_params.rl_link_present == FALSE) &&
        (hsdpa_msg_params.intra_hho_involved == TRUE))
      {
        rrc_set_hsdpa_action(HSDPA_STOP);
        return SUCCESS;
      }

      /* Set bit mask for HO */
      if (((hsdpa_msg_params.ifhho_involved == TRUE)  || 
            (hsdpa_msg_params.intra_hho_involved == TRUE)) && (hsdpa_msg_params.rl_link_present == TRUE))
      {
        /* Asking us to do Hard HO with new HS RL */
        /* Check if new H-RNTI is provided */
        if (hsdpa_msg_params.hrnti_present == FALSE)
        {
          return FAILURE;
        }
        ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc = hsdpa_msg_params.new_rl_link;
        reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_PDSCH_RL_CFG_INCL | CPHY_HS_DSCH_CFG_INCL;

      }
      else if (ordered_config_ptr->dest_freq_present == TRUE)
      {
        WRRC_MSG1_HIGH("RRCHS:SYNC A procedure triggered  freq %d Set HS-DSCH in bit_mask ",
               ordered_config_ptr->dest_freq);
       
        reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_DSCH_CFG_INCL;
      }


      if ((hsdpa_msg_params.rl_link_present == TRUE) &&
          (hsdpa_msg_params.intra_hho_involved == FALSE) &&
          (hsdpa_msg_params.ifhho_involved == FALSE) &&
          (hsdpa_msg_params.new_rl_link != ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc))
      {
        WRRC_MSG1_HIGH("RRCHS:softrepointing to psc %d", hsdpa_msg_params.new_rl_link);
        ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc = hsdpa_msg_params.new_rl_link;
        reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_PDSCH_RL_CFG_INCL;
      }

      /* Check if SRB Delay, DPCCH Power Offset & PC Preamble Information was indicated
      in the message & Sync A Procedure is not involved. If yes, then rewrite the old 
      information from CC as the new information needs to be ignored */
      if ((ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.valid == TRUE) &&
        (ordered_config_ptr->dest_freq_present == FALSE) && 
        (hsdpa_msg_params.intra_hho_involved == FALSE) &&
        (hsdpa_msg_params.ifhho_involved == FALSE))
      {
        WRRC_MSG0_HIGH("Ignore SRBDelay/PCPreamble/POffset");
        
        /* Get them from CC. Do validation check to be doubly 
        sure that CC values are valid */
        if ((current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.valid == TRUE) &&
          (current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.dpcch_pwr_offset
          <= 2*RRCLLC_UL_DPCCH_PWR_OFFSET_MAX) && 
          (current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.dpcch_pwr_offset
          >= 2*RRCLLC_UL_DPCCH_PWR_OFFSET_MIN) && 
          (current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.pcp_len < 8) && 
          (current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.srb_delay < 8))
        {
          MSG_6(MSG_SSID_DIAG, MSG_LEGACY_HIGH,"RRCHS: Po Offset OC %d CC %d,PCP Length OC %d CC %d,SRB Delay OC %d CC %d", 
            ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.dpcch_pwr_offset,
            current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.dpcch_pwr_offset,
            ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.pcp_len,
            current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.pcp_len,
            ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.srb_delay,
            current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.srb_delay);
          
          /* Copy Old information from CC */
          ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.dpcch_pwr_offset =
            current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.dpcch_pwr_offset;
          
          ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.pcp_len =
            current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.pcp_len;
          
          ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.srb_delay =
            current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.srb_delay;          
          
        }
      }

      if ((hsdpa_msg_params.rl_link_present == TRUE) &&
          (hsdpa_msg_params.intra_hho_involved == FALSE) &&
          (hsdpa_msg_params.ifhho_involved == FALSE))
      {
        ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc = hsdpa_msg_params.new_rl_link;
      }
      
      if (hsdpa_msg_params.hspdsch_info_present == TRUE)
      {
        if ( RRC_MSG_COMMON_BITMASK_IE_PTR(hspdsch_info_ptr,rrc_DL_HSPDSCH_Information_r6,hs_scch_Info))
        {
          /* Check if HS-SCCH Info has changed */
          if (rrcllc_check_if_hsscch_changed(&hspdsch_info_ptr->hs_scch_Info,MSG_REL6) == TRUE)
          {
            hsscch_codes_changed = TRUE;
          }

          if (set_hsscch_info_r6(&hspdsch_info_ptr->hs_scch_Info) == FAILURE)
          {
            return FAILURE;
          }
          else
          {
            if (hsscch_codes_changed == TRUE)
            {
              reconfig_bit_mask =reconfig_bit_mask | CPHY_HS_SCCH_CFG_INCL;
            }

          }
        }
        if(RRC_MSG_COMMON_BITMASK_IE_PTR(hspdsch_info_ptr,rrc_DL_HSPDSCH_Information_r6,measurement_feedback_Info))
        {
          /* Check if Meas Feedback Info has changed */
          rrcllc_check_if_meas_feedback_changed(&hspdsch_info_ptr->measurement_feedback_Info, 
                                                &b_table_changed, &hsdpcch_changed);

          if (set_meas_feedback_info(&hspdsch_info_ptr->measurement_feedback_Info) == FAILURE)
          {
            return FAILURE;
          }
          else
          {
            if (b_table_changed == TRUE)
            {
              ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 
                HS_DPCCH_BETA_HS_INFO_PRESENT_BITMASK;
              reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_DPCCH_CFG_INCL;
            }
            if (hsdpcch_changed == TRUE)
            {
              ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 
                ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask |
                HS_DPCCH_MEAS_FEEDBACK_INFO_PRESENT_BITMASK;
              reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_DPCCH_CFG_INCL;
            }


          }
        }
      }
      /* Check if only beta table has changed */
      if ((b_table_changed == FALSE) && (hsdpa_msg_params.beta_table_present == TRUE))
      {
        ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 
          HS_DPCCH_BETA_HS_INFO_PRESENT_BITMASK;

        reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_DPCCH_CFG_INCL;
      }

      /* Check if only beta table has changed */
      if ((hsdpcch_changed == FALSE) && (hsdpa_msg_params.hs_dpcch_info_present == TRUE))
      {
        ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 
          HS_DPCCH_MEAS_FEEDBACK_INFO_PRESENT_BITMASK;

        reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_DPCCH_CFG_INCL;
      }

	  MSG_6(MSG_SSID_DIAG, MSG_LEGACY_HIGH,"RRCHS: hsdpa_msg_params.hspdsch_info_present %d hsscch_codes_changed %d,b_table_changed %d hsdpcch_changed %d,hsdpa_msg_params.beta_table_present %d hsdpa_msg_params.hs_dpcch_info_present %d", 
            hsdpa_msg_params.hspdsch_info_present,
            hsscch_codes_changed,
            b_table_changed,
            hsdpcch_changed,
            hsdpa_msg_params.beta_table_present,
            hsdpa_msg_params.hs_dpcch_info_present);

      /* Final Check to make sure that everything is present */
      if (rrcllc_check_if_hsdpa_can_be_started_reconfigured(ordered_config_ptr) == FALSE)
      {
        rrc_set_hsdpa_action(HSDPA_STOP);
        return SUCCESS;
      }

      /* Check if HS-DPCCH Info has changed */
      if (hsdpa_msg_params.hs_dpcch_info_present == TRUE)
      {
        reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_DPCCH_CFG_INCL;
      }
      /* Set the queue information */
      if (set_hsdpa_l1_queue_info() == FAILURE)
      {
        WRRC_MSG0_ERROR("RRCHS:Unable to set HSDPA info in L1");
        return FAILURE;
      }
      else
      {
        if ((hsdpa_msg_params.hsdsch_info_present == TRUE) ||
            ((hsdpa_msg_params.hrnti_present == TRUE) && (hsdpa_msg_params.hrnti_changed == TRUE)))
        {
          reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_DSCH_CFG_INCL;
        }

      }
      if ((reconfig_bit_mask == 0) && 
          (ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator == FALSE) &&
          ordered_config_ptr->dest_freq_present == FALSE)
      {
        rrc_set_hsdpa_action(HSDPA_NOOP);
        return SUCCESS;
      }
      

      ordered_config_ptr->l1_hsdpa_info.hs_req_mask = reconfig_bit_mask;

      /* Set Action to RECONFIG */
     
      MSG_3(MSG_SSID_DIAG, MSG_LEGACY_HIGH,"RRCHS:HSRECONFIG bit mask/ordered_config_ptr->l1_hsdpa_info.hs_req_mask %d,HS-RESET %d, ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask %d",
               reconfig_bit_mask,
               ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator,
               ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask);
      rrc_set_hsdpa_action(HSDPA_RECONFIG);
      
      return SUCCESS;
      
    } /* End of if of hsdpa msg params present */
    else
    {
      /* Final Check to make sure that everything is present */
      if (rrcllc_check_if_hsdpa_can_be_started_reconfigured(ordered_config_ptr) == FALSE)
      {
        rrc_set_hsdpa_action(HSDPA_STOP);
        return SUCCESS;
      }
      if (ordered_config_ptr->dest_freq_present == TRUE)
      {
        rrc_set_hsdpa_action(HSDPA_RECONFIG);
        return SUCCESS;
      }

      /* Means No Action */
      rrc_set_hsdpa_action(HSDPA_NOOP);
      return SUCCESS;
    }
  }
}

#ifdef FEATURE_MAC_I
/*====================================================================
FUNCTION: rrcllc_is_maci_compatible_with_hsdpa()

DESCRIPTION:
  This function checks if  MACi/is is compatible with HSDPA being configured

DEPENDENCIES:
  rrc_set_hsdpa_action must be called before calling this function.

RETURN VALUE:
  SUCCESS if MACi/is and HSDPA being configured are compatible
  FAILURE Otherwise

SIDE EFFECTS:  
====================================================================*/

uecomdef_status_e_type rrcllc_is_maci_compatible_with_hsdpa
(
  void
)
{
  /*If Mac-i is configured then mac-hs should NOT be configured
     this is valid only if eul is active other wise this condition is obsolete*/
  /* FACH (HSRACH) to DCH, ul_pdu_type is not being set from MAC_I_PDU HDR to MAC_E_PDU HDR and the corresponding 
     check is need only if EUL active.
     However maci/is and DCH combination is allowed.*/
  if((ordered_config_ptr->mac_ul_parms.ul_pdu_type == MAC_I_PDU_HDR) &&
     (ordered_config_ptr->e_dch_transmission == TRUE)&&
     (ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_HS)&& 
     (((rrc_get_hsdpa_status() == HSDPA_INACTIVE) && (rrc_get_hsdpa_action() == HSDPA_START)) 
      ||  
      ((rrc_get_hsdpa_status() == HSDPA_ACTIVE) && (rrc_get_hsdpa_action() != HSDPA_STOP))
     )
    )
  {
    WRRC_MSG1_HIGH("MAC_I:MACHS is configured when Mac-i/is is configured. DL type %d  ", ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs);
    return FAILURE;
  }
  return SUCCESS;
}
#endif /* FEATURE_MAC_I */	


/*====================================================================
FUNCTION: rrcllc_determine_hsdpa_action()

DESCRIPTION:

  This function determines the HSDPA action and sets the parameters in L1
  structure accordingly.
  
DEPENDENCIES:
  None.

RETURN VALUE:
  Sucess if HSDPA action and parameters have been set
  Failure Otherwise

SIDE EFFECTS:
  
====================================================================*/
uecomdef_status_e_type rrcllc_determine_hsdpa_action
(
  rrc_DL_HSPDSCH_Information* hspdsch_info_ptr
)
{
  uint8 reconfig_bit_mask = 0;
  boolean hsscch_codes_changed = FALSE;
  boolean hsdpcch_changed = FALSE;
  boolean b_table_changed = FALSE;
  boolean hrnti_absent_with_repointing = FALSE;


  if(rrcllc_set_macehs_or_machs_and_check_if_coexist()== TRUE)
  {
    WRRC_MSG2_HIGH("MACEHS: MAC EHS %d and MAC HS %d cant co-exist ",
                        ordered_config_ptr->mac_dl_parms.num_mac_ehs_queue, 
                        ordered_config_ptr->mac_dl_parms.num_dflow);
    return FAILURE;
  }

  rrcllc_set_machs_ehs_transition();

  if(((ordered_config_ptr->mac_dl_parms.mac_hs_transition_type == MAC_HS_TO_EHS )
        ||(ordered_config_ptr->mac_dl_parms.mac_hs_transition_type == MAC_EHS_TO_HS ))
        && (ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator == FALSE))
  {
    WRRC_MSG2_ERROR("MAC-HS <->  MAC-EHS transition %d, and Mac Reset Ind not set %d, reject config",
            ordered_config_ptr->mac_dl_parms.mac_hs_transition_type,
            ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator);
    return FAILURE;
  }
 
#ifdef FEATURE_WCDMA_HS_FACH
  if((ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_HS) &&
     (ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator == FALSE)&&
     (current_config_ptr->hs_status_in_e_fach == TRUE))
  {
    WRRC_MSG2_ERROR("MAC-EHS ->  MAC-HS transition %d, and Mac Reset Ind not set %d, reject config",
            ordered_config_ptr->mac_dl_parms.mac_hs_transition_type,
            ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator);
    return FAILURE;
  }
#endif
 
  if(hsdpa_msg_params.hspdsch_info_present )
  {
    ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured = FALSE;
    if(current_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured == TRUE)
    {
      hsdpa_msg_params.hsdsch_info_present = TRUE;
      WRRC_MSG0_HIGH("Set HS-DSCh bitmask as 64 QAM is stopped");
    }
  }

  /* HSDPA params have already been set in rrc_hsdpa_params.
  Check if HSDPA is already ACTIVE */
  if (rrc_get_hsdpa_status() == HSDPA_INACTIVE)
  {
    /* HSDPA is currently inactive */
    /* Check if network wants to activate HSDPA */
    if (hsdpa_msg_params.msg_params_present == TRUE)
    {
      if (hsdpa_msg_params.hspdsch_info_present == TRUE)
      {
        /* Check if channelization codes and feedback info present */
        if (RRC_MSG_COMMON_BITMASK_IE_PTR(hspdsch_info_ptr,rrc_DL_HSPDSCH_Information,hs_scch_Info))
        {
          if (set_hsscch_info(&hspdsch_info_ptr->hs_scch_Info) == FAILURE)
          {
            return FAILURE;
          }
        }
        if(RRC_MSG_COMMON_BITMASK_IE_PTR(hspdsch_info_ptr,rrc_DL_HSPDSCH_Information,measurement_feedback_Info))
        {
          /* Set Meas Feedback Info */
          if (set_meas_feedback_info(&hspdsch_info_ptr->measurement_feedback_Info) == FAILURE)
          {
            return FAILURE;
          }
        }
      }
      /* Set HS-RL */
      if (hsdpa_msg_params.rl_link_present == TRUE)
      {
        /* Set Radio Link in L1 HSDPA structure */
        ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc = hsdpa_msg_params.new_rl_link;
      }
    } /* End of if of hsdpa message params absent */
    else
    {
      rrc_set_hsdpa_action(HSDPA_NOOP);
      rrc_reset_mac_ehs_params(ordered_config_ptr);

      
      return SUCCESS;
    }

    /* Set Queue Info */
    if (set_hsdpa_l1_queue_info() == FAILURE)
    {
      WRRC_MSG0_ERROR("RRCHS:Unable to set Queue Info");
      return FAILURE;
    }

    /* Final Check to make sure that everything is present */
    if (rrcllc_check_if_hsdpa_can_be_started_reconfigured(ordered_config_ptr) == FALSE)
    {
      WRRC_MSG0_HIGH("RRCHS:HSNOOP");
      return SUCCESS;
    }
    rrc_set_hsdpa_action(HSDPA_START);

#ifdef FEATURE_MAC_I
    if(rrcllc_is_maci_compatible_with_hsdpa()==FAILURE)
    { 
      return FAILURE;
    }
#endif
    /* Set Bit Mask */
    ordered_config_ptr->l1_hsdpa_info.hs_req_mask = CPHY_HS_DSCH_CFG_INCL | 
      CPHY_HS_PDSCH_RL_CFG_INCL | CPHY_HS_SCCH_CFG_INCL | CPHY_HS_DPCCH_CFG_INCL;
    ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 
      HS_DPCCH_BETA_HS_INFO_PRESENT_BITMASK | HS_DPCCH_MEAS_FEEDBACK_INFO_PRESENT_BITMASK;

#ifdef FEATURE_WCDMA_HS_FACH
   /*For EFACH to MAC-HS transitions*/
    if(current_config_ptr->hs_status_in_e_fach  == FALSE)
#endif
    {
    /* In case UTRAN messes up, set HS-RESET to FALSE */
      ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator = FALSE;
    }

MSG_HIGH("RRCHS:HS Bit Mask/hs_req_mask is (Hex)/ %x,info_present_bitmask %x  and mac-hs reset indicator %d", ordered_config_ptr->l1_hsdpa_info.hs_req_mask,
             ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask,ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator);


    return SUCCESS;
    
  }
  else
  {
    ordered_config_ptr->l1_hsdpa_info.hs_req_mask = 0;

    ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 0;
    /* HSDPA is already ACTIVE */
    MSG_9(MSG_SSID_DFLT, MSG_LEGACY_HIGH,"hsdpa_params_present:%d,rl_link_present:%d,ifhho_involved:%d, intra_hho_involved:%d,new_rl_link:%d,hrnti_present:%d, dest_freq_present:%d, hsdpa_msg_params.hsdsch_info_present:%d, hsdpa_msg_params.hrnti_changed %d",
            hsdpa_msg_params.msg_params_present,
            hsdpa_msg_params.rl_link_present,
            hsdpa_msg_params.ifhho_involved,
            hsdpa_msg_params.intra_hho_involved,
            hsdpa_msg_params.new_rl_link,
            hsdpa_msg_params.hrnti_present,
            ordered_config_ptr->dest_freq_present,
            hsdpa_msg_params.hsdsch_info_present,
            hsdpa_msg_params.hrnti_changed
            );
    
    if (hsdpa_msg_params.msg_params_present == TRUE)
    {
      /* Now check if IFREQ Hard Handoff is involved */
      if ((hsdpa_msg_params.rl_link_present == FALSE) &&
        (hsdpa_msg_params.ifhho_involved == TRUE))
      {
        rrc_set_hsdpa_action(HSDPA_STOP);
        
        return SUCCESS;
      }
      /* Check if Intra Freq HO involved */
      if ((hsdpa_msg_params.rl_link_present == FALSE) &&
        (hsdpa_msg_params.intra_hho_involved == TRUE))
      {
        rrc_set_hsdpa_action(HSDPA_STOP);
        
        return SUCCESS;
      }

      /* Set bit mask for HO */
      if (((hsdpa_msg_params.ifhho_involved == TRUE)  || 
            (hsdpa_msg_params.intra_hho_involved == TRUE)) && (hsdpa_msg_params.rl_link_present == TRUE))
      {
        /* Asking us to do Hard HO with new HS RL */
        /* Check if new H-RNTI is provided */
        if (hsdpa_msg_params.hrnti_present == FALSE)
        {
          WRRC_MSG0_ERROR("RRCHS:HRNTI absent with hard repointing");
          return FAILURE;
        }
        ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc = hsdpa_msg_params.new_rl_link;
        reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_PDSCH_RL_CFG_INCL | CPHY_HS_DSCH_CFG_INCL;
      }
      else if (ordered_config_ptr->dest_freq_present == TRUE)
      {
        WRRC_MSG1_HIGH("RRCHS:SYNC A procedure triggered  freq %d Set HS-DSCH in bit_mask ",
               ordered_config_ptr->dest_freq);
       
        reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_DSCH_CFG_INCL;
      }


      
      if ((hsdpa_msg_params.rl_link_present == TRUE) &&
          (hsdpa_msg_params.intra_hho_involved == FALSE) &&
          (hsdpa_msg_params.ifhho_involved == FALSE) &&
          (hsdpa_msg_params.new_rl_link != ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc))
      {
        if (hsdpa_msg_params.hrnti_present == FALSE)
        {
          hrnti_absent_with_repointing = TRUE; 
        }
        ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc = hsdpa_msg_params.new_rl_link;
        reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_PDSCH_RL_CFG_INCL;
      }


      /* Check if SRB Delay, DPCCH Power Offset & PC Preamble Information was indicated
      in the message & Sync A Procedure is not involved. If yes, then rewrite the old 
      information from CC as the new information needs to be ignored */
      if ((ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.valid == TRUE) &&
          (ordered_config_ptr->dest_freq_present == FALSE) && 
          (hsdpa_msg_params.intra_hho_involved == FALSE) &&
          (hsdpa_msg_params.ifhho_involved == FALSE))
      {
        WRRC_MSG0_HIGH("Ignore SRBDelay/PCPreamble/POffset");
        
        /* Get them from CC. Do validation check to be doubly 
        sure that CC values are valid */
        if ((current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.valid == TRUE) &&
          (current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.dpcch_pwr_offset
          <= 2*RRCLLC_UL_DPCCH_PWR_OFFSET_MAX) && 
          (current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.dpcch_pwr_offset
          >= 2*RRCLLC_UL_DPCCH_PWR_OFFSET_MIN) && 
          (current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.pcp_len < 8) && 
          (current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.srb_delay < 8))
        {
          MSG_6(MSG_SSID_DIAG, MSG_LEGACY_HIGH,"RRCHS: Po Offset OC %d CC %d,PCP Length OC %d CC %d,SRB Delay OC %d CC %d", 
            ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.dpcch_pwr_offset,
            current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.dpcch_pwr_offset,
            ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.pcp_len,
            current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.pcp_len,
            ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.srb_delay,
            current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.srb_delay);
          
          /* Copy Old information from CC */
          ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.dpcch_pwr_offset =
            current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.dpcch_pwr_offset;
          
          ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.pcp_len =
            current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.pcp_len;
          
          ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.srb_delay =
            current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.srb_delay;         
          
        }
      }

      if ((hsdpa_msg_params.rl_link_present == TRUE) &&
          (hsdpa_msg_params.intra_hho_involved == FALSE) &&
          (hsdpa_msg_params.ifhho_involved == FALSE))
      {
        ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc = hsdpa_msg_params.new_rl_link;
      }
      
      if (hsdpa_msg_params.hspdsch_info_present == TRUE)
      {
        if(RRC_MSG_COMMON_BITMASK_IE_PTR(hspdsch_info_ptr,rrc_DL_HSPDSCH_Information,hs_scch_Info))
        {
          /* Check if HS-SCCH Info has changed */
          if (rrcllc_check_if_hsscch_changed(&hspdsch_info_ptr->hs_scch_Info,MSG_REL5) == TRUE)
            hsscch_codes_changed = TRUE;
          if (set_hsscch_info(&hspdsch_info_ptr->hs_scch_Info) == FAILURE)
          {
            return FAILURE;
          }
          else
          {
            if (hsscch_codes_changed == TRUE)
            {
              WRRC_MSG0_HIGH("RRCHS:SCCH Info changed");
              reconfig_bit_mask =reconfig_bit_mask | CPHY_HS_SCCH_CFG_INCL;
            }
          }
        }
        if(RRC_MSG_COMMON_BITMASK_IE_PTR(hspdsch_info_ptr,rrc_DL_HSPDSCH_Information,measurement_feedback_Info))
        {
          /* Check if Meas Feedback Info has changed */
          rrcllc_check_if_meas_feedback_changed(&hspdsch_info_ptr->measurement_feedback_Info, 
                                                &b_table_changed, &hsdpcch_changed);
          if (set_meas_feedback_info(&hspdsch_info_ptr->measurement_feedback_Info) == FAILURE)
          {
            return FAILURE;
          }
          else
          {
            
            if (b_table_changed == TRUE)
            {
              ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 
                HS_DPCCH_BETA_HS_INFO_PRESENT_BITMASK;
              reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_DPCCH_CFG_INCL;
            }
            if (hsdpcch_changed == TRUE)
            {
              ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 
                ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask |
                HS_DPCCH_MEAS_FEEDBACK_INFO_PRESENT_BITMASK;
              reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_DPCCH_CFG_INCL;
            }


          }
        }
      }

      /* Check if only beta table has changed */
      if ((b_table_changed == FALSE) && (hsdpa_msg_params.beta_table_present == TRUE))
      {
        ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 
          HS_DPCCH_BETA_HS_INFO_PRESENT_BITMASK;

        reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_DPCCH_CFG_INCL;
      }

      /* Check if only beta table has changed */
      if ((hsdpcch_changed == FALSE) && (hsdpa_msg_params.hs_dpcch_info_present == TRUE))
      {
        ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 
          HS_DPCCH_MEAS_FEEDBACK_INFO_PRESENT_BITMASK;

        reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_DPCCH_CFG_INCL;
      }
         
	   MSG_6(MSG_SSID_DIAG, MSG_LEGACY_HIGH,"RRCHS: hsdpa_msg_params.hspdsch_info_present %d hsscch_codes_changed %d,b_table_changed %d hsdpcch_changed %d,hsdpa_msg_params.beta_table_present %d hsdpa_msg_params.hs_dpcch_info_present %d", 
            hsdpa_msg_params.hspdsch_info_present,
            hsscch_codes_changed,
            b_table_changed,
            hsdpcch_changed,
            hsdpa_msg_params.beta_table_present,
            hsdpa_msg_params.hs_dpcch_info_present);
         
      /* Final Check to make sure that everything is present */
      if (rrcllc_check_if_hsdpa_can_be_started_reconfigured(ordered_config_ptr) == FALSE)
      {
        rrc_set_hsdpa_action(HSDPA_STOP);
        return SUCCESS;
      }

      /* Check if HS-DPCCH Info has changed */
      if (hsdpa_msg_params.hs_dpcch_info_present == TRUE)
      {
        reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_DPCCH_CFG_INCL;
      }
      /* Set the queue information */
      if (set_hsdpa_l1_queue_info() == FAILURE)
      {
        WRRC_MSG0_ERROR("RRCHS:Unable to set HSDPA info in L1");
        return FAILURE;
      }
      else
      {
        if ((hsdpa_msg_params.hsdsch_info_present == TRUE) ||
            ((hsdpa_msg_params.hrnti_present == TRUE) && (hsdpa_msg_params.hrnti_changed == TRUE)))
        {
          reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_DSCH_CFG_INCL;
        }
      }
      if ((reconfig_bit_mask == 0) && 
          (ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator == FALSE) &&
          ordered_config_ptr->dest_freq_present == FALSE)
      {
        WRRC_MSG0_HIGH("RRCHS:Change action RECONFIG to NOOP");
        rrc_set_hsdpa_action(HSDPA_NOOP);
        return SUCCESS;
      }
      if(hrnti_absent_with_repointing == TRUE)
      {
        WRRC_MSG0_ERROR("RRCHS:HRNTI absent with soft repointing");
        rrc_set_hsdpa_action(HSDPA_STOP);
        return SUCCESS;
      }

      ordered_config_ptr->l1_hsdpa_info.hs_req_mask = reconfig_bit_mask;

      /* Set Action to RECONFIG */
     
      MSG_3(MSG_SSID_DIAG, MSG_LEGACY_HIGH,"RRCHS:HSRECONFIG bit mask/ordered_config_ptr->l1_hsdpa_info.hs_req_mask %d,HS-RESET %d, ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask %d",
               reconfig_bit_mask,
               ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator,
               ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask);
      rrc_set_hsdpa_action(HSDPA_RECONFIG);

#ifdef FEATURE_MAC_I
      if(rrcllc_is_maci_compatible_with_hsdpa() == FAILURE)
      {
        return FAILURE;
      }
#endif /* FEATURE_MAC_I */
      
      return SUCCESS;
      
    } /* End of if of hsdpa msg params present */
    else
    {
      /* Final Check to make sure that everything is present */
      if (rrcllc_check_if_hsdpa_can_be_started_reconfigured(ordered_config_ptr) == FALSE)
      {
        rrc_set_hsdpa_action(HSDPA_STOP);
        return SUCCESS;
      }
      if (ordered_config_ptr->dest_freq_present == TRUE)
      {
        WRRC_MSG0_HIGH("FORCEDSYNCA,HS Action RECONFIG");
        rrc_set_hsdpa_action(HSDPA_RECONFIG);

#ifdef FEATURE_MAC_I
        if(rrcllc_is_maci_compatible_with_hsdpa() == FAILURE)
        {
          return FAILURE;
        }
#endif /* FEATURE_MAC_I */

        return SUCCESS;
      }

      /* Means No Action */
      rrc_set_hsdpa_action(HSDPA_NOOP);
      return SUCCESS;
    }
  }
}

/*====================================================================
FUNCTION: rrcllc_init_hsdpa_mac_ptr()

DESCRIPTION:
  This function initializes the DFLOW Pointer in MAC.

DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:

====================================================================*/
static void  rrcllc_init_hsdpa_mac_ptr(ordered_config_type *config_ptr)
{
  uint8  ix;
  MSG_MED("RRCHS:Init HS MAC Ptr",0,0,0);
  for(ix = 0 ; ix < UE_MAX_MAC_D_FLOW; ix++)
  {
    config_ptr->mac_dl_parms.hsdpa_info[ix] = &config_ptr->mac_dflow_info[ix];
  }
  for(ix = 0 ; ix < UE_MAX_HS_QUEUE; ix++)
  {
    config_ptr->mac_dl_parms.hsdpa_ehs_queue_info[ix] = &config_ptr->mac_ehs_queue_info[ix];
  }
  for(ix = 0 ; ix < UE_MAX_DL_LOGICAL_CHANNEL; ix++)
  {
    config_ptr->mac_dl_parms.dl_macehs_logchan_info[ix] = &config_ptr->dl_macehs_logchan_info[ix];
#ifdef FEATURE_WCDMA_HS_FACH
    config_ptr->mac_dl_parms.efach_dl_logchan_info[ix] = &config_ptr->efach_dl_logchan_info[ix];
#endif
  }
}



/*====================================================================
FUNCTION: rrcllc_print_rlc_info()

DESCRIPTION:
  This function prints RLC information.

DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:

====================================================================*/
void rrcllc_print_rlc_info(ordered_config_type *config_ptr)
{
  int ix;

  WRRC_MSG1_HIGH("RLC AM entities:%d,", config_ptr->rlc_am_parms.nentity);
  for(ix = 0; ix < UE_MAX_AM_ENTITY; ix++)
  {
    MSG_HIGH("ul_nch:%d,dl_nch:%d,ul_rlc_size:%d",
              config_ptr->am_config[ix].ul_nchan,
              config_ptr->am_config[ix].dl_nchan,
              config_ptr->am_config[ix].rlc_ul_am_config.ul_rlc_size
             );
  }
  WRRC_MSG1_HIGH("RLC DL TM entities:%d,", config_ptr->rlc_dl_tm_parms.nchan);
  for(ix = 0; ix < UE_MAX_DL_TM_CHANNEL; ix++)
  {
    MSG_HIGH("DL TM lc_id:%d,lc_type:%d,action:%d",
              config_ptr->rlc_dl_tm_parms.chan_info[ix].lc_id,
              config_ptr->rlc_dl_tm_parms.chan_info[ix].lc_type,
              config_ptr->rlc_dl_tm_parms.dl_tm_act[ix].action
             );
  }
  WRRC_MSG1_HIGH("RLC UL TM entities:%d,", config_ptr->rlc_ul_tm_parms.nchan);
  for(ix = 0; ix < UE_MAX_UL_TM_CHANNEL; ix++)
  {
    MSG_HIGH("UL TM lc_id:%d,lc_type:%d,action:%d",
              config_ptr->rlc_ul_tm_parms.chan_info[ix].lc_id,
              config_ptr->rlc_ul_tm_parms.chan_info[ix].lc_type,
              config_ptr->rlc_ul_tm_parms.ul_tm_act[ix].action
             );
  }

  WRRC_MSG1_HIGH("RLC DL UM entities:%d,", config_ptr->rlc_dl_um_parms.nchan);
  for(ix = 0; ix < UE_MAX_DL_UM_CHANNEL; ix++)
  {
    MSG_HIGH("DL UM lc_id:%d,lc_type:%d,action:%d",
              config_ptr->rlc_dl_um_parms.chan_info[ix].lc_id,
              config_ptr->rlc_dl_um_parms.chan_info[ix].lc_type,0
             );
  }

  WRRC_MSG1_HIGH("RLC UL UM entities:%d,", config_ptr->rlc_ul_um_parms.nchan);
  for(ix = 0; ix < UE_MAX_DL_UM_CHANNEL; ix++)
  {
    MSG_HIGH("DL UM lc_id:%d,lc_type:%d,action:%d",
              config_ptr->rlc_ul_um_parms.chan_info[ix].lc_id,
              config_ptr->rlc_ul_um_parms.chan_info[ix].lc_type,0
             );
  }
}


/*====================================================================
FUNCTION: rrcllc_check_if_rb_mapped_on_macehs_q

DESCRIPTION:
  This function checks if a RB is mapped to  MACEHS passed
  config ptr.

DEPENDENCIES:
  None

RETURN VALUE:
  TRUE if RB is found to be mapped on a MACEHS else FALSE

SIDE EFFECTS:
  None.
====================================================================*/
static boolean rrcllc_check_if_rb_mapped_on_macehs_q
(
  ordered_config_type  *config_ptr,
  rrc_RB_Identity  rb_id
)
{
  uint32 queue_cnt=0;
  uint32 num_queue=0;
  uint32 nlchl_cnt=0;
  num_queue =config_ptr->mac_dl_parms.num_mac_ehs_queue;

#if 0
  if for hsfach pass argument or write new function to take from new hsfach structures
#endif
  for(queue_cnt=0;queue_cnt < num_queue;queue_cnt++)
  {
    if ((config_ptr->mac_ehs_queue_info[queue_cnt].queue_id != INVALID_QUEUE_ID)
        && (config_ptr->mac_ehs_queue_index_in_use[queue_cnt] == TRUE))
    {
      for(nlchl_cnt =0; (nlchl_cnt <config_ptr->mac_dl_parms.ndlchan_macehs);nlchl_cnt++)
      {
        if ((config_ptr->mac_ehs_lc_id_in_use[nlchl_cnt] == TRUE) 
           && (config_ptr->dl_macehs_logchan_info[nlchl_cnt].queue_id == 
           config_ptr->mac_ehs_queue_info[queue_cnt].queue_id)&&
            (config_ptr->dl_macehs_logchan_info[nlchl_cnt].rb_id == rb_id)
            && (config_ptr->dl_macehs_logchan_info[nlchl_cnt].chan_type == UE_LOGCHAN_DTCH))
        {
          return TRUE;
        }
      }
    }
  }
  return FALSE;
}

#ifdef FEATURE_WCDMA_HS_FACH
/*====================================================================
FUNCTION: rrcllc_check_if_rb_mapped_on_macehs_q_for_efach

DESCRIPTION:
  This function checks if a RB is mapped to  MACEHS passed
  config ptr for EFACH

DEPENDENCIES:
  None

RETURN VALUE:
  TRUE if RB is found to be mapped on a MACEHS else FALSE

SIDE EFFECTS:
  None.
====================================================================*/
static boolean rrcllc_check_if_rb_mapped_on_macehs_q_for_efach
(
  ordered_config_type  *config_ptr,
  rrc_RB_Identity  rb_id
)
{
   uint32 queue_cnt=0;
   uint32 nlchl_cnt=0;
   if(config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_EHS)
   {
     for(queue_cnt=0;queue_cnt < config_ptr->mac_dl_parms.efach_num_queue;queue_cnt++)
     {
       if ((config_ptr->mac_ehs_queue_info[queue_cnt].queue_id != INVALID_QUEUE_ID)
           && (config_ptr->mac_ehs_queue_index_in_use[queue_cnt] == TRUE))
       {
  	     for(nlchl_cnt =0; (nlchl_cnt <config_ptr->mac_dl_parms.efach_ndlchans);nlchl_cnt++)
         {
           if ((config_ptr->mac_dl_parms.efach_dl_logchan_info[nlchl_cnt]->queue_id == 
               config_ptr->mac_ehs_queue_info[queue_cnt].queue_id)&&
               (config_ptr->mac_dl_parms.efach_dl_logchan_info[nlchl_cnt]->rb_id == rb_id)
               && (config_ptr->mac_dl_parms.efach_dl_logchan_info[nlchl_cnt]->chan_type == UE_LOGCHAN_DTCH))
           {
              return TRUE;
           }
         }
       }
     }
   }
  return (FALSE);
}
#endif /* FEATURE_WCDMA_HS_FACH */

/*===========================================================================

FUNCTION rrc_set_hsdpa_action_in_machs_macehs

DESCRIPTION


  
DEPENDENCIES


RETURN VALUE
  None
 

SIDE EFFECTS

  None

===========================================================================*/
void rrc_set_hsdpa_action_in_machs_macehs
(
  void
)
{
  /*The additional check for HSDPA_STOP is done to avoid over-writing HSDPA action in the case of
  MAC-EHS -> MAC-HS mapping change alongwith HSDPA STOP*/
  WRRC_MSG2_MED("MACEHS: hsdpa_action %d,ordered_config_ptr->mac_dl_parms.mac_hs_transition_type %d",
  ordered_config_ptr->mac_dl_parms.mac_hsdpa_action, ordered_config_ptr->mac_dl_parms.mac_hs_transition_type  );
  if((ordered_config_ptr->mac_dl_parms.mac_hs_transition_type == MAC_HS_TO_EHS) && 
    (rrc_get_hsdpa_action() != HSDPA_STOP))
  {
    ordered_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_RECONFIG;
    rrc_set_hsdpa_action(HSDPA_RECONFIG);
  }
  /*The additional check for HSDPA_STOP is done to avoid over-writing HSDPA action in the case of
  MAC-HS -> MAC-EHS mapping change alongwith HSDPA STOP*/  
  else if((ordered_config_ptr->mac_dl_parms.mac_hs_transition_type == MAC_EHS_TO_HS) && 
    (rrc_get_hsdpa_action() != HSDPA_STOP))
  {
    ordered_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_RECONFIG;
    rrc_set_hsdpa_action(HSDPA_RECONFIG);
  }
  else
  {
    ordered_config_ptr->mac_dl_parms.mac_hsdpa_action = rrc_get_hsdpa_action();

    if((rrc_get_hsdpa_status() == HSDPA_ACTIVE ) ||
        (ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_START) ||
        (ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_STOP))
    {
      ordered_config_ptr->mac_dl_parms.mac_hs_transition_type = MAC_HS_NO_TRANSITION;
    }

  }
}

/*===========================================================================

FUNCTION rrc_reset_mac_ehs_params

DESCRIPTION


  
DEPENDENCIES


RETURN VALUE
  None
 

SIDE EFFECTS

  None

===========================================================================*/

void rrc_reset_mac_ehs_params
(
  ordered_config_type * config_ptr
)
{
  if(rrc_get_hsdpa_status() == HSDPA_ACTIVE)
  {
     config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_STOP;
                /* HSDPA to be stopped */
     rrc_set_hsdpa_action(HSDPA_STOP);
  }
  else
  {
    config_ptr->mac_dl_parms.mac_hs_or_ehs = MAC_HS_TYPE_INVALID;
    config_ptr->mac_dl_parms.mac_hs_transition_type= MAC_HS_INVALID_TRANSITION;
    config_ptr->l1_hsdpa_info.hs_dsch_info.mac_hs_or_ehs = MAC_HS_TYPE_INVALID;
  }
}

/*===========================================================================

FUNCTION rrcllc_set_machs_ehs_transition

DESCRIPTION


  
DEPENDENCIES


RETURN VALUE
  None
 

SIDE EFFECTS

  None

===========================================================================*/
void rrcllc_set_machs_ehs_transition
(
void
)
{
    ordered_config_ptr->mac_dl_parms.mac_hs_transition_type = MAC_HS_NO_TRANSITION;
    if(rrc_get_hsdpa_status() == HSDPA_ACTIVE )
    {
      if((ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_HS) &&
          (current_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_EHS))
      {
          ordered_config_ptr->mac_dl_parms.mac_hs_transition_type = MAC_EHS_TO_HS;
      }
      else if((ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_EHS) &&
          (current_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_HS))
      {

          ordered_config_ptr->mac_dl_parms.mac_hs_transition_type = MAC_HS_TO_EHS;
      }
    }
    if(ordered_config_ptr->mac_dl_parms.mac_hs_transition_type != MAC_HS_NO_TRANSITION)
    {
      WRRC_MSG1_HIGH("MACEHS:Transition type %d [0= INVALID, 1= HS to EHS, 2= EHS to HS, 3= No TRANS]",
      ordered_config_ptr->mac_dl_parms.mac_hs_transition_type);
    }
    return;
}
/*====================================================================
FUNCTION: rrcllc_get_macehs_queue_index()

DESCRIPTION:

DEPENDENCIES:
  None.

RETURN VALUE:


SIDE EFFECTS:

====================================================================*/
uint8  rrcllc_allocate_lc_index_macehs
( 
  ordered_config_type *config_ptr,
  rrc_LogicalChannelIdentity logicalChannelIdentity
)
{

  uint8 cnt = UE_MAX_DL_LOGICAL_CHANNEL;
  /* An index with the same DFLOW ID is NOT in use.
  * Allocate a new index */
  for (cnt =0; cnt <UE_MAX_DL_LOGICAL_CHANNEL; cnt++)
  {
    if ((config_ptr->mac_ehs_lc_id_in_use[cnt] == FALSE) &&
      (config_ptr->dl_macehs_logchan_info[cnt].mac_id == INVALID_LOGICAL_CHANNEL_ID))
    {
      /*give it to MAC as LC id -1 as recieved in MAC EHS header*/
      config_ptr->dl_macehs_logchan_info[cnt].mac_id= logicalChannelIdentity -1;

      /* Increment no of DFLOWs */
      config_ptr->mac_dl_parms.ndlchan_macehs ++;
      
      WRRC_MSG2_MED("MACEHS:Assign Index %d for new LC ID %d", 
         cnt,logicalChannelIdentity);
      config_ptr->mac_ehs_lc_id_in_use[cnt] = TRUE;
      break;
    }
  }
  return cnt;

}
/*====================================================================
FUNCTION: rrcllc_get_macehs_queue_index()

DESCRIPTION:

DEPENDENCIES:
  None.

RETURN VALUE:


SIDE EFFECTS:

====================================================================*/
uint8 rrcllc_find_lc_index_for_macehs
( 
  ordered_config_type *config_ptr,
  rrc_LogicalChannelIdentity logicalChannelIdentity,
  uint16 rb_id
)
{

  uint8 index = UE_MAX_DL_LOGICAL_CHANNEL;

  for(index = 0; index < UE_MAX_DL_LOGICAL_CHANNEL; index++)
  {
    if((config_ptr->mac_ehs_lc_id_in_use[index] == TRUE) &&
      (config_ptr->dl_macehs_logchan_info[index].mac_id == (logicalChannelIdentity -1)))
    {
      if(rb_id != config_ptr->dl_macehs_logchan_info[index].rb_id )
      {
        WRRC_MSG2_HIGH("MACEHS:LCH Id index %d, RB Id %d",logicalChannelIdentity-1,rb_id);
        continue;
      }
      WRRC_MSG2_MED("MACEHS:LCH Id index %d, Id %d",index, logicalChannelIdentity);

      return index;
    }
  }

  return UE_MAX_DL_LOGICAL_CHANNEL;
  
}
   
/*====================================================================
FUNCTION: rrcllc_init_hsdpa_mac_ehs_info()

DESCRIPTION:
  This function initializes the HSDPA Information in the configuration
  database.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_init_hsdpa_mac_ehs_info(ordered_config_type  *config_ptr)
{
  uint8 idx = 0;
  
  rrc_reset_mac_ehs_params(config_ptr);

  config_ptr->mac_dl_parms.num_mac_ehs_queue = 0;

  for(idx = 0; idx < UE_MAX_HS_QUEUE ; idx++)
  {
    config_ptr->mac_ehs_queue_info[idx].queue_id = INVALID_QUEUE_ID;
    config_ptr->mac_ehs_queue_info[idx].release_timer = 0;
    config_ptr->mac_ehs_queue_info[idx].window_size = 0;
    config_ptr->mac_ehs_queue_index_in_use[idx] = FALSE;
  }
  config_ptr->mac_dl_parms.ndlchan_macehs = 0;
  for(idx = 0; idx < UE_MAX_DL_LOGICAL_CHANNEL; idx++)
  {
    config_ptr->mac_ehs_lc_id_in_use[idx] = FALSE;
    config_ptr->dl_macehs_logchan_info[idx].queue_id = INVALID_QUEUE_ID;
    config_ptr->dl_macehs_logchan_info[idx].mac_id = INVALID_LOGICAL_CHANNEL_ID;
    config_ptr->dl_macehs_logchan_info[idx].rb_id = RRC_INVALID_RB_ID;
    config_ptr->dl_macehs_logchan_info[idx].rlc_id = 0;
    config_ptr->dl_macehs_logchan_info[idx].chan_type = UE_LOGCHAN_NONE;
    config_ptr->dl_macehs_logchan_info[idx].rlc_mode = UE_MODE_MAX_NUM;
  }
}
/*====================================================================
FUNCTION: rrcllc_rearrange_macehs_queue_index()

DESCRIPTION:
  This function deletes any holes
DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/

void rrcllc_rearrange_macehs_queue_index
(
  ordered_config_type *config_ptr
)
{
  uint32  ix, iy;


  if (config_ptr->mac_dl_parms.num_mac_ehs_queue == 0)
  {
    WRRC_MSG0_MED("MACEHS:MAC EHS 0");
    return;
  }
 /* Put all the values in tmp structure. No there are no holes in tmp structure */
  for(ix = UE_MAX_HS_QUEUE; ix > 0; ix--)
  {
    /* Check if valid data */
    if(config_ptr->mac_ehs_queue_info[ix-1].queue_id!= INVALID_QUEUE_ID)
    {
      for(iy = 0; iy < (ix - 1); iy++)
      {
        /* Check if valid data */
        if(config_ptr->mac_ehs_queue_info[iy].queue_id== INVALID_QUEUE_ID)
        {
          config_ptr->mac_ehs_queue_index_in_use[iy] =  
                    config_ptr->mac_ehs_queue_index_in_use[ix-1];
          WCDMA_MEMCPY(&config_ptr->mac_ehs_queue_info[iy], 
                       sizeof(config_ptr->mac_ehs_queue_info[iy]),
                       &config_ptr->mac_ehs_queue_info[ix-1], 
                       sizeof(config_ptr->mac_ehs_queue_info[iy]));
          config_ptr->mac_ehs_queue_info[ix-1].queue_id= INVALID_QUEUE_ID;
          config_ptr->mac_ehs_queue_info[ix-1].release_timer = 0;
          config_ptr->mac_ehs_queue_info[ix-1].window_size = 0;
          config_ptr->mac_ehs_queue_index_in_use[ix-1] = FALSE;
          break;
        }
      }
      if (iy == (ix-1)) 
      {
        WRRC_MSG1_MED("MACEHS: Rearranging MAC EHS Q complete. Total %d",
                  config_ptr->mac_dl_parms.num_mac_ehs_queue);
        break;
      }
    }
  } /* End of for (...) */

}

/*====================================================================
FUNCTION: rrcllc_allocate_macehs_q_index()

DESCRIPTION:


DEPENDENCIES:
  None.

RETURN VALUE:
  uint8 -> A EDCH MAC-d flow Index.
  UE_MAX_MAC_D_FLOW -> Given EDCH Mac-d flow does not
           have an allocated DCH transport channel index.

SIDE EFFECTS:
====================================================================*/
uint8  rrcllc_allocate_macehs_q_index
(
  uint8  mac_ehs_q_id
)
{

  uint8 cnt = UE_MAX_HS_QUEUE;
  /* An index with the same DFLOW ID is NOT in use.
  * Allocate a new index */
  for (cnt =0; cnt <UE_MAX_HS_QUEUE; cnt++)
  {
    if ((ordered_config_ptr->mac_ehs_queue_index_in_use[cnt] == FALSE) &&
      (ordered_config_ptr->mac_ehs_queue_info[cnt].queue_id== INVALID_QUEUE_ID ))
    {
      WRRC_MSG1_MED("MACEHS:Assign Index %d for new MACEHS Q", cnt);
      memset(&ordered_config_ptr->mac_ehs_queue_info[cnt],0,sizeof(mac_ehs_queue_struct_type));
      ordered_config_ptr->mac_ehs_queue_info[cnt].queue_id =mac_ehs_q_id;
      
      ordered_config_ptr->mac_ehs_queue_index_in_use[cnt] = TRUE;

      break;
    }
  }
  return cnt;

}
/*====================================================================
FUNCTION: rrcllc_get_macehs_queue_index()

DESCRIPTION:

DEPENDENCIES:
  None.

RETURN VALUE:


SIDE EFFECTS:

====================================================================*/
uint8 rrcllc_get_macehs_queue_index
(
  uint8  mac_ehs_q_id
)
{
  uint8 index = UE_MAX_HS_QUEUE;

  for(index = 0; index < UE_MAX_HS_QUEUE; index++)
  {
    if((ordered_config_ptr->mac_ehs_queue_index_in_use[index] == TRUE) &&
      (ordered_config_ptr->mac_ehs_queue_info[index].queue_id == mac_ehs_q_id))
    {
      WRRC_MSG2_HIGH("MACEHS: MAC EHS Q Id %d at index %d", mac_ehs_q_id,index);
      return(index);
    }
  }
  
  /* MAC EHS Q index not found, Allocate new */
  
  index = rrcllc_allocate_macehs_q_index(mac_ehs_q_id);
  if(index == UE_MAX_HS_QUEUE)
  {
    WRRC_MSG1_HIGH("MACEHS: MAC EHS Q index %d absent",mac_ehs_q_id);
    /* Failure to allocate a new DFLOW Index */
    return(UE_MAX_HS_QUEUE);
  }
  else  /* A valid new DFLOW index has been allocated */
  {
  
    /* Now Save Q ID in MAC structure */
    ordered_config_ptr->mac_ehs_queue_info[index].queue_id = mac_ehs_q_id;
  
    /* Increment no of MAC EHS Qs */
    ordered_config_ptr->mac_dl_parms.num_mac_ehs_queue ++;
  
    WRRC_MSG1_MED("MACEHS:New MAC EHS cnt %d in MAC struct", ordered_config_ptr->mac_dl_parms.num_mac_ehs_queue);
  
    return(index);
  
  } /* A valid new MAC EHS Q index allocated */
  
}

/*====================================================================
FUNCTION: rrcllc_get_ehs_log_chan_mode()

DESCRIPTION:
  This function gets a the log_chan_mode for the rb id specified if the rb_id is mapped to EHS
  queues

DEPENDENCIES:
  None.

RETURN VALUE:
  Logical Channel mode of the rb_id    if rb_id is found mapped to a EHS queue
  UE_MODE_MAX_NUM     otherwise

SIDE EFFECTS:

====================================================================*/
uecomdef_logch_mode_e_type rrcllc_get_ehs_log_chan_mode
(
  rrc_RB_Identity rb_id
)
{
  uint32 queue_cnt=0;
  uint32 num_queue=0;
  uint32 nlchl_cnt=0;
#if 0
  If (hsfach status is true)
    return mapping from new efach strcutres
#endif
  num_queue =ordered_config_ptr->mac_dl_parms.num_mac_ehs_queue;
  for(queue_cnt=0;queue_cnt < num_queue;queue_cnt++)
  {
    if (ordered_config_ptr->mac_ehs_queue_info[queue_cnt].queue_id != INVALID_QUEUE_ID)
    {
      for(nlchl_cnt =0; (nlchl_cnt <ordered_config_ptr->mac_dl_parms.ndlchan_macehs);nlchl_cnt++)
      {
        if (((ordered_config_ptr->dl_macehs_logchan_info[nlchl_cnt].queue_id) == 
           (ordered_config_ptr->mac_ehs_queue_info[queue_cnt].queue_id))&&
            (ordered_config_ptr->dl_macehs_logchan_info[nlchl_cnt].rb_id == rb_id))
        {
          return (ordered_config_ptr->dl_macehs_logchan_info[nlchl_cnt].rlc_mode);
        }
      }
    }
  }
  return (UE_MODE_MAX_NUM);
}

#ifdef FEATURE_WCDMA_HS_FACH

/*====================================================================
FUNCTION: rrcllc_set_hs_status_in_e_fach()

DESCRIPTION:

DEPENDENCIES:
  None
  
RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_set_hs_status_in_e_fach
(
  ordered_config_type *config_ptr,
  boolean status
)
{
  if(config_ptr != NULL)
  {
    if(config_ptr->hs_status_in_e_fach != status)
    {
      WRRC_MSG2_HIGH("EFACH:Set Status = %d. In use DB(0:OC/1:CC/2:TOC) %d",status,config_ptr_in_use);
    }
   config_ptr->hs_status_in_e_fach = status;
  }
  return;
}

/*====================================================================
FUNCTION: rrcllc_set_hs_action_in_e_fach()

DESCRIPTION:

DEPENDENCIES:
  None
  
RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_set_hs_action_in_e_fach
(
  ordered_config_type *config_ptr,
  hsdpa_action_enum_type action
)
{
  if(config_ptr != NULL)
  {
    if(action != config_ptr->hs_action_in_e_fach)
    {
      WRRC_MSG2_HIGH("EFACH:Set Action (0:N/1:S/2:R/3:S) = %d. In use DB(0:OC/1:CC/2:TOC) %d",action,config_ptr_in_use);
    }
    config_ptr->hs_action_in_e_fach = action;
  }

  return;
}

/*====================================================================
FUNCTION: rrcllc_get_hs_status_in_e_fach()

DESCRIPTION:

DEPENDENCIES:
  None
  
RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
boolean rrcllc_get_hs_status_in_e_fach
(
  ordered_config_type *config_ptr
)
{
  boolean status = FALSE;

  if(config_ptr != NULL)
  {
    status = config_ptr->hs_status_in_e_fach;
  }

  WRRC_MSG2_MED("EFACH:Get Status (0:F/1:T) = %d. In use DB(0:OC/1:CC/2:TOC) = %d",status,config_ptr_in_use);

  return status;
}

/*====================================================================
FUNCTION: rrcllc_get_hs_status_in_e_fach()

DESCRIPTION:

DEPENDENCIES:
  None
  
RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
hsdpa_action_enum_type rrcllc_get_hs_action_in_e_fach
(
  ordered_config_type *config_ptr
)
{
  hsdpa_action_enum_type action = HSDPA_NOOP;

  if(config_ptr != NULL)
  {
    action = config_ptr->hs_action_in_e_fach;
  }

  WRRC_MSG2_MED("EFACH:Get Action (0:N/1:S/2:R/3:S) = %d. In use DB(0:OC/1:CC/2:TOC) = %d",action,config_ptr_in_use);

  return action;
}

/*====================================================================
FUNCTION: rrcllc_get_rb_idx_from_hrb()

DESCRIPTION:
Gets the index for the RB from the new hanging RB structure

DEPENDENCIES:
  None.

RETURN VALUE:
  rb_index

SIDE EFFECTS:
  None.
====================================================================*/

uint8 rrcllc_get_rb_idx_from_hrb(uint8 rb_id)
{
  uint8 rb_index;
  
  for(rb_index = 0;rb_index < MAX_HANGING_RB_MAPPING_INFO ;rb_index++)
  {
    if(rrc_ordered_hanging_rb[rb_index].rb_id == rb_id)
    {
      return rb_index;
    }
  }
  return MAX_HANGING_RB_MAPPING_INFO;
}
/*====================================================================
FUNCTION: rrcllc_efach_mappings_are_given_for_rbs()

DESCRIPTION:
This function checks whether all the RBs are mapped to eFACH mappings i.e. RACH in UL and HS-DSCH in DL

DEPENDENCIES:
  None.

RETURN VALUE:
  True/False.

SIDE EFFECTS:
  None.
====================================================================*/
boolean rrcllc_efach_mappings_are_given_for_rbs
(
  ordered_config_type *config_ptr
)
{
  uint8 idx = 0,srbcnt=0;

#ifdef FEATURE_WCDMA_HS_RACH
  /*If cell supports HS-RACH is TRUE we can skip the rb mapping validation as it is being done as part of hs-rach*/
  if(TRUE == rrchsrach_camped_cell_supports_hsrach())
  {
    return TRUE;
  }
#endif

  for(idx =0;idx< MAX_HANGING_RB_MAPPING_INFO;idx++)
  {
    if(rrc_ordered_hanging_rb[idx].rb_id == MAX_RB)
      continue;
    if(rrcllc_check_mapping_in_hanging_rb(UL_RACH_MAPPING|DL_MAC_EHS_MAPPING,idx) ==
         MAX_MAPPING_COMBO)
    {

      WRRC_MSG1_HIGH("EFACH:RB ID %d doesn't have RACH/HS Mapping",rrc_ordered_hanging_rb[idx].rb_id);
      
      switch(rrc_ordered_hanging_rb[idx].rb_id)
      {
          case DCCH_UM_RADIO_BEARER_ID:
          case DCCH_AM_RADIO_BEARER_ID:
          case DCCH_DT_HIGH_PRI_RADIO_BEARER_ID:
            return FALSE;  
          case DCCH_DT_LOW_PRI_RADIO_BEARER_ID:
            break;
          default:
            return FALSE;
      }
    }
    else if((rrc_ordered_hanging_rb[idx].rb_id >= DCCH_UM_RADIO_BEARER_ID) &&
            (rrc_ordered_hanging_rb[idx].rb_id <= DCCH_DT_HIGH_PRI_RADIO_BEARER_ID))
    {
      srbcnt++;
    }
  }

  if(srbcnt != 3)
  {
    WRRC_MSG0_HIGH("EFACH:RACH/HS mapping missing for atleast one SRB");
    return FALSE;
  }
  return TRUE;
}

/*====================================================================
FUNCTION: rrcllc_check_hsrach_mappings_are_given_for_rbs()

DESCRIPTION:


DEPENDENCIES:
  None.

RETURN VALUE:
  True/False.

SIDE EFFECTS:
  None.
====================================================================*/
boolean rrcllc_check_hsrach_mappings_are_given_for_rbs
(
  ordered_config_type *config_ptr
)
{
  uint8 i;
  for(i=0;i<MAX_HANGING_RB_MAPPING_INFO;i++)
  {

    if(rrc_ordered_hanging_rb[i].rb_id == MAX_RB)
      continue;

    if(rrcllc_check_mapping_in_hanging_rb(UL_EDCH_MAPPING|DL_MAC_EHS_MAPPING,i) 
        != MAX_MAPPING_COMBO)
    {
      if( FALSE == rrcllc_check_for_edch_hsrach_mapping(config_ptr,rrc_ordered_hanging_rb[i].rb_id))
      {
        return FALSE;
      }
      if( FALSE == rrcllc_check_for_efach_mapping(config_ptr,rrc_ordered_hanging_rb[i].rb_id))
      {
        return FALSE;
      }
    }
    else
    {
      WRRC_MSG1_HIGH("HSRACH: EUL-EHS mapping for rb_id %d is not present",rrc_ordered_hanging_rb[i].rb_id);
      return FALSE;
    }
  }
  return TRUE;
}



/*====================================================================
FUNCTION: rrcllc_check_if_hs_can_be_started_reconfigured_in_e_fach()

DESCRIPTION:
  This function checks if HSDPA can be started/reconfigured in e-FACH state by looking at the following
  Check whether C-RNTI is present
  Dedicated H-RNTI is present
  The MAC-ehs Re-ordering Queues are present on which RBs are mapped.

  checkStatus is added when this fuction is called by rrcllc_configure_e_fach_pch(), 
  refer to this function on why the parameter is addded
  

DEPENDENCIES:
  None.

RETURN VALUE:
  True/False.

SIDE EFFECTS:
  None.
====================================================================*/
boolean rrcllc_check_if_hs_can_be_started_reconfigured_in_e_fach
(
  ordered_config_type *config_ptr,
  rrc_state_e_type next_rrc_state,
  rrc_e_fach_operation_mode_e_type efach_mode
)
{

  /* While moving from efach to legacy pch we should set efach status
     to FALSE even if efach mappings are not given (in common mode when may not have
     efach mapping) */

  if(rrcllc_check_efach_config_data(ordered_config_ptr,
                                    next_rrc_state,
                                    efach_mode) == FALSE)
  {
    return FALSE;
  }

  if((rrcllc_set_macehs_or_machs_and_check_if_coexist()== TRUE) )
  {
    WRRC_MSG2_HIGH("EFACH:MAC EHS %d and MAC HS %d cant co-exist ",
                        config_ptr->mac_dl_parms.num_mac_ehs_queue, 
                        config_ptr->mac_dl_parms.num_dflow);
    return FALSE;
  }

  config_ptr->l1_hsdpa_info.hs_dsch_info.efach_h_rnti_bmsk &= L1_BCCH_H_RNTI_VALID;
  if(efach_mode == RRC_E_FACH_DEDICATED)
    config_ptr->l1_hsdpa_info.hs_dsch_info.efach_h_rnti_bmsk |= L1_DEDICATED_H_RNTI_VALID;
  else if(efach_mode == RRC_E_FACH_COMMON)
    config_ptr->l1_hsdpa_info.hs_dsch_info.efach_h_rnti_bmsk |= L1_COMMON_H_RNTI_VALID;

  config_ptr->l1_hsdpa_info.hs_dsch_info.h_rnti = config_ptr->efach_hrnti;

  // HACK: For now, keep the transition as NO, later needs to be changed coz it an be 
  config_ptr->mac_dl_parms.mac_hs_transition_type = MAC_HS_NO_TRANSITION;

  config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc = rrc_ccm_get_curr_camped_psc();

    /*Updating BCCH_HSDSCH info into config ptr*/
  rrcenhstate_get_bcch_mapping_from_sib5(config_ptr);
  
    /*The above three statements are needed for the below function*/
  rrcllc_set_hsdpa_l1_queue_info_for_e_fach(config_ptr);

  return TRUE;

}

/*====================================================================
FUNCTION: rrcllc_determine_hsdpa_action_for_e_fach()

DESCRIPTION:
  This function sets HSDPA action in global hsdpa_action.
  Also set the var ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator
  And var ordered_config_ptr->mac_dl_parms.mac_hsdpa_action

DEPENDENCIES:
  None.

RETURN VALUE:
  True/False.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_determine_hsdpa_action_for_e_fach
(
  void
)
{
  if(current_config_ptr->hs_status_in_e_fach)
  {
    if(ordered_config_ptr->hs_status_in_e_fach)
    {
      ordered_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_RECONFIG;    
      rrcllc_set_hs_action_in_e_fach(ordered_config_ptr,HSDPA_RECONFIG);
    }
    else
    {
      ordered_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_STOP;        
      rrcllc_set_hs_action_in_e_fach(ordered_config_ptr,HSDPA_STOP);
    }
  }
  else
  {
    if(ordered_config_ptr->hs_status_in_e_fach)
    {
      ordered_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_START;        
      rrcllc_set_hs_action_in_e_fach(ordered_config_ptr,HSDPA_START);
    }
    else
    {
      ordered_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_NOOP;            
      rrcllc_set_hs_action_in_e_fach(ordered_config_ptr,HSDPA_NOOP);           
    }
  }
}

/*====================================================================
FUNCTION: rrcllc_efach_update_dedicated_params()

DESCRIPTION:

DEPENDENCIES:
  None.

RETURN VALUE:

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_efach_update_dedicated_params
(
  ordered_config_type *config_ptr
)
{
 uint8 i=0;
  WRRC_MSG0_HIGH("EFACH:Copying TOC to OC for EFACH");

  for(i=0; i< UE_MAX_HS_QUEUE; i++)
  {
    if(transition_config.toc_ptr->mac_ehs_queue_info[i].queue_id != INVALID_QUEUE_ID)
    {
      WRRC_MSG1_HIGH("QUEUE_ID in TOC %d",transition_config.toc_ptr->mac_ehs_queue_info[i].queue_id);
    }
    config_ptr->mac_ehs_queue_index_in_use[i] = transition_config.toc_ptr->mac_ehs_queue_index_in_use[i];
    config_ptr->mac_ehs_queue_info[i] = transition_config.toc_ptr->mac_ehs_queue_info[i]; 
  }
  config_ptr->mac_dl_parms.efach_num_queue = transition_config.toc_ptr->mac_dl_parms.num_mac_ehs_queue;
  if(transition_config.toc_ptr->l1_hsdpa_info.hs_dsch_info.harq_info.num_proc != 0)
  {
    config_ptr->l1_hsdpa_info.hs_dsch_info.harq_info = transition_config.toc_ptr->l1_hsdpa_info.hs_dsch_info.harq_info;
  }
  else
  {
    WRRC_MSG1_HIGH("EFACH: Common harq info is already present in OC num_proc:%d ",config_ptr->l1_hsdpa_info.hs_dsch_info.harq_info.num_proc);
  }

  /*Init the config db mapping database*/
  //rrcenhstate_init_efach_mapping(config_ptr); this is now done in restore from hanging
  /*Always take mapping from Hanging-RB*/
#ifdef FEATURE_WCDMA_HS_RACH
  if(rrchsrach_camped_cell_supports_hsrach() == TRUE)
  {
    (void)rrcllc_restore_from_hanging(config_ptr,(UL_EDCH_MAPPING|DL_MAC_EHS_MAPPING));
  }
  else
#endif
  {
    (void)rrcllc_restore_from_hanging(config_ptr,(UL_RACH_MAPPING|DL_MAC_EHS_MAPPING));
  }

  ordered_config_ptr->rach_rlc_size_restriction_info.mac_update_needed = TRUE;

  /* Update the MAC layer with the newly copied RLC size restriction info */
  (void)rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, RRC_STATE_CELL_FACH);
  
}

/*====================================================================
FUNCTION: rrcllc_copy_sib_to_oc_for_efach()

DESCRIPTION:

DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS
  FAILURE

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_copy_sib_to_oc_for_efach(rrc_state_e_type next_rrc_state ,
               rrc_e_fach_operation_mode_e_type rrc_e_fach_operation_mode)
{

  if( ( (rrcenhstate_camped_cell_supports_e_fach() == TRUE) && 
          (next_rrc_state == RRC_STATE_CELL_FACH || next_rrc_state == RRC_STATE_CONNECTING)))
  {
    if(FAILURE == rrcenhstate_get_hs_dsch_common_info(ordered_config_ptr, 
                                 next_rrc_state, rrc_e_fach_operation_mode))
    {
       ERR_FATAL("ENH STATE: Error updating HSDSCH Common Info", 0, 0, 0);
    }
    else if(rrcllc_check_if_hs_can_be_started_reconfigured_in_e_fach(ordered_config_ptr, next_rrc_state,
                                 rrc_e_fach_operation_mode) == FALSE)
    {
      WRRC_MSG0_ERROR("ENH STATE:HS start/reconfig failure");
    }
    else
    {
      rrcllc_set_hs_status_in_e_fach(ordered_config_ptr, TRUE);
      WRRC_MSG1_HIGH("ENH STATE:Set eFACH active in OC %d", ordered_config_ptr->hs_status_in_e_fach);    
    }
  }
  else
  {
    rrcllc_set_hs_status_in_e_fach(ordered_config_ptr, FALSE);
    WRRC_MSG0_MED("EFACH: Either Cell doesn't support E-FACH or next state is PCH/URA-PCH");

#ifdef FEATURE_WCDMA_HS_FACH
    ordered_config_ptr->efach_hrnti_status = INVALID_HRNTI;
    current_config_ptr->efach_hrnti_status = INVALID_HRNTI;
    
#ifdef FEATURE_WCDMA_HS_RACH
    WRRC_MSG2_HIGH("HSRACH:next_state %d hspa_rnti_stored_cell_pch %d ",next_rrc_state,ordered_config_ptr->hspa_rnti_stored_cell_pch);
    /*HSRACH:Do not invalidate HRNTI in TOC, needed for MR*/
    if(next_rrc_state != RRC_STATE_CELL_PCH &&
       ordered_config_ptr->hspa_rnti_stored_cell_pch != TRUE)
    {
      transition_config.toc_ptr->efach_hrnti_status = INVALID_HRNTI;
    }
#else
    transition_config.toc_ptr->efach_hrnti_status = INVALID_HRNTI;
#endif
#endif
  }
  rrcllc_determine_hsdpa_action_for_e_fach();
}


/*====================================================================
FUNCTION: rrcllc_fill_directed_cell_info()

DESCRIPTION:
  Function fills directed cell info from config pointer 

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_fill_directed_cell_info(ordered_config_type *config_ptr,
                                      rrcrb_directed_cell_info_type  *directed_cell_info)
{
   directed_cell_info->freq_info_present = config_ptr->dest_freq_present;
   directed_cell_info->pscr_present = config_ptr->dest_psc_present;
   directed_cell_info->uarfcn_dl = config_ptr->dest_freq;
   directed_cell_info->pscr = config_ptr->dest_psc;

}


#endif /*FEATURE_WCDMA_HS_FACH*/


/*====================================================================
FUNCTION: rrcllc_determine_hsdpa_action_r7()

DESCRIPTION:

  This function determines the HSDPA action and sets the parameters in L1
  structure accordingly.
  
DEPENDENCIES:
  None.

RETURN VALUE:
  Sucess if HSDPA action and parameters have been set
  Failure Otherwise

SIDE EFFECTS:
  
====================================================================*/
uecomdef_status_e_type rrcllc_determine_hsdpa_action_r7
(
  rrc_DL_HSPDSCH_Information_r7* hspdsch_info_ptr
)
{
  uint8 reconfig_bit_mask = 0;

  boolean hsscch_codes_changed = FALSE;

  boolean hsdpcch_changed = FALSE;

  boolean b_table_changed = FALSE;


  /* HSDPA params have already been set in rrc_hsdpa_params.
  Check if HSDPA is already ACTIVE */
  if (rrc_get_hsdpa_status() == HSDPA_INACTIVE)
  {
    /* HSDPA is currently inactive */
    /* Check if network wants to activate HSDPA */
    if (hsdpa_msg_params.msg_params_present == TRUE)
    {
      if (hsdpa_msg_params.hspdsch_info_present == TRUE)
      {
        /* Check if channelization codes and feedback info present */
        if(RRC_MSG_COMMON_BITMASK_IE_PTR(hspdsch_info_ptr,rrc_DL_HSPDSCH_Information_r7,hs_scch_Info))
        {
          if (set_hsscch_info_r7(&hspdsch_info_ptr->hs_scch_Info) == FAILURE)
          {
            return FAILURE;
          }
        }
        if(RRC_MSG_COMMON_BITMASK_IE_PTR(hspdsch_info_ptr,rrc_DL_HSPDSCH_Information_r7,measurement_feedback_Info)) 
        {
          /* Set Meas Feedback Info */
          if (set_meas_feedback_info_r7(&hspdsch_info_ptr->measurement_feedback_Info) == FAILURE)
          {
            return FAILURE;
          }
        }
      }
      /* Set HS-RL */
      if (hsdpa_msg_params.rl_link_present == TRUE)
      {
        /* Set Radio Link in L1 HSDPA structure */
        ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc = hsdpa_msg_params.new_rl_link;
      }
    } /* End of if of hsdpa message params absent */
    else
    {
      rrc_set_hsdpa_action(HSDPA_NOOP);
      rrc_reset_mac_ehs_params(ordered_config_ptr);
      return SUCCESS;
    }
    /* Set Queue Info */
    if (set_hsdpa_l1_queue_info() == FAILURE)
    {
      WRRC_MSG0_ERROR("RRCHS:Unable to set Queue Info");
      return FAILURE;
    }

    /* Final Check to make sure that everything is present */
    if (rrcllc_check_if_hsdpa_can_be_started_reconfigured(ordered_config_ptr) == FALSE)
    {
      rrc_set_hsdpa_action(HSDPA_NOOP);
      rrc_reset_mac_ehs_params(ordered_config_ptr);
      return SUCCESS;
    }

    rrc_set_hsdpa_action(HSDPA_START);

    /* Set Bit Mask */
    ordered_config_ptr->l1_hsdpa_info.hs_req_mask = CPHY_HS_DSCH_CFG_INCL | 
      CPHY_HS_PDSCH_RL_CFG_INCL | CPHY_HS_SCCH_CFG_INCL | CPHY_HS_DPCCH_CFG_INCL;

    ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 
      HS_DPCCH_BETA_HS_INFO_PRESENT_BITMASK | HS_DPCCH_MEAS_FEEDBACK_INFO_PRESENT_BITMASK;

#ifdef FEATURE_WCDMA_HS_FACH
     /*For EFACH to MAC-HS transitions*/
    if(current_config_ptr->hs_status_in_e_fach  == FALSE)
 #endif
    {
    /* In case UTRAN messes up, set HS-RESET to FALSE */   
    ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator = FALSE;
    }

     MSG_HIGH("RRCHS:HS Bit Mask is (Dec) %d (Hex) %x and mac-hs reset indicator %d", ordered_config_ptr->l1_hsdpa_info.hs_req_mask,
             ordered_config_ptr->l1_hsdpa_info.hs_req_mask,ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator);
     
    return SUCCESS;
    
  }
  else
  {
    ordered_config_ptr->l1_hsdpa_info.hs_req_mask = 0;


    ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 0;

    MSG_9(MSG_SSID_DFLT, MSG_LEGACY_HIGH,"hsdpa_params_present:%d,rl_link_present:%d,ifhho_involved:%d, intra_hho_involved:%d,new_rl_link:%d,hrnti_present:%d, dest_freq_present:%d, hsdpa_msg_params.hsdsch_info_present:%d, hsdpa_msg_params.hrnti_changed %d",
            hsdpa_msg_params.msg_params_present,
            hsdpa_msg_params.rl_link_present,
            hsdpa_msg_params.ifhho_involved,
            hsdpa_msg_params.intra_hho_involved,
            hsdpa_msg_params.new_rl_link,
            hsdpa_msg_params.hrnti_present,
            ordered_config_ptr->dest_freq_present,
            hsdpa_msg_params.hsdsch_info_present,
            hsdpa_msg_params.hrnti_changed
            );

    /* HSDPA is already ACTIVE */
    
    if (hsdpa_msg_params.msg_params_present == TRUE)
    {
      /* Now check if IFREQ Hard Handoff is involved */
      if ((hsdpa_msg_params.rl_link_present == FALSE) &&
        (hsdpa_msg_params.ifhho_involved == TRUE))
      {

        WRRC_MSG0_HIGH("RRCHS:IFreq Hard HO without repointing");
        rrc_set_hsdpa_action(HSDPA_STOP);
        
        return SUCCESS;
      }
      /* Check if Intra Freq HO involved */
      if ((hsdpa_msg_params.rl_link_present == FALSE) &&
        (hsdpa_msg_params.intra_hho_involved == TRUE))
      {
        rrc_set_hsdpa_action(HSDPA_STOP);
        
        return SUCCESS;
      }

      /* Set bit mask for HO */
      if (((hsdpa_msg_params.ifhho_involved == TRUE)  || 
            (hsdpa_msg_params.intra_hho_involved == TRUE)) && (hsdpa_msg_params.rl_link_present == TRUE))
      {
        /* Asking us to do Hard HO with new HS RL */
        /* Check if new H-RNTI is provided */
        if (hsdpa_msg_params.hrnti_present == FALSE)
        {
          WRRC_MSG0_ERROR("RRCHS:HRNTI absent with hard repointing");
          return FAILURE;
        }
        ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc = hsdpa_msg_params.new_rl_link;
        reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_PDSCH_RL_CFG_INCL | CPHY_HS_DSCH_CFG_INCL;

        if(ordered_config_ptr->cpc_dtx_drx_status == TRUE)
        {
          WRRC_MSG0_HIGH("RRCCPC:HS Serv cell change set hs_scch_order as BACKUP_AND_DISCARD"); 
          ordered_config_ptr->l1_hs_scch_order_action = L1_HS_SCCH_ORDER_ACTION_BACKUP_AND_DISCARD;
        }

      }
      else if (ordered_config_ptr->dest_freq_present == TRUE)
      {
        WRRC_MSG1_HIGH("RRCHS:SYNC A procedure triggered  freq %d Set HS-DSCH in bit_mask ",
               ordered_config_ptr->dest_freq);
       
        reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_DSCH_CFG_INCL;
      }
    
      if ((hsdpa_msg_params.rl_link_present == TRUE) &&
          (hsdpa_msg_params.intra_hho_involved == FALSE) &&
          (hsdpa_msg_params.ifhho_involved == FALSE) &&
          (hsdpa_msg_params.new_rl_link != ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc))
      {
        ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc = hsdpa_msg_params.new_rl_link;
        reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_PDSCH_RL_CFG_INCL;

        if(ordered_config_ptr->cpc_dtx_drx_status == TRUE)
        {
          WRRC_MSG0_HIGH("RRCCPC:HS Serv cell change set hs_scch_order as BACKUP_AND_DISCARD"); 
          ordered_config_ptr->l1_hs_scch_order_action = L1_HS_SCCH_ORDER_ACTION_BACKUP_AND_DISCARD;
        }
      }


      /* Check if SRB Delay, DPCCH Power Offset & PC Preamble Information was indicated
      in the message & Sync A Procedure is not involved. If yes, then rewrite the old 
      information from CC as the new information needs to be ignored */
      if ((ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.valid == TRUE) &&
        (ordered_config_ptr->dest_freq_present == FALSE) && 
        (hsdpa_msg_params.intra_hho_involved == FALSE) &&
        (hsdpa_msg_params.ifhho_involved == FALSE))
      {
        WRRC_MSG0_HIGH("Ignore SRBDelay/PCPreamble/POffset");
        
        /* Get them from CC. Do validation check to be doubly 
        sure that CC values are valid */
        if ((current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.valid == TRUE) &&
          (current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.dpcch_pwr_offset
          <= 2*RRCLLC_UL_DPCCH_PWR_OFFSET_MAX) && 
          (current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.dpcch_pwr_offset
          >= 2*RRCLLC_UL_DPCCH_PWR_OFFSET_MIN) && 
          (current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.pcp_len < 8) && 
          (current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.srb_delay < 8))
        {
          MSG_6(MSG_SSID_DIAG, MSG_LEGACY_HIGH,"RRCHS: Po Offset OC %d CC %d,PCP Length OC %d CC %d,SRB Delay OC %d CC %d", 
            ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.dpcch_pwr_offset,
            current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.dpcch_pwr_offset,
            ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.pcp_len,
            current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.pcp_len,
            ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.srb_delay,
            current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.srb_delay);
          
          /* Copy Old information from CC */
          ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.dpcch_pwr_offset =
            current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.dpcch_pwr_offset;
          
          ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.pcp_len =
            current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.pcp_len;
          
          ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.srb_delay =
            current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.srb_delay;          
          
        }
      }

      if ((hsdpa_msg_params.rl_link_present == TRUE) &&
          (hsdpa_msg_params.intra_hho_involved == FALSE) &&
          (hsdpa_msg_params.ifhho_involved == FALSE))
      {
        ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc = hsdpa_msg_params.new_rl_link;
      }
      
      if (hsdpa_msg_params.hspdsch_info_present == TRUE)
      {
        if (RRC_MSG_COMMON_BITMASK_IE_PTR(hspdsch_info_ptr,rrc_DL_HSPDSCH_Information_r7,hs_scch_Info))
        {

          /* Check if HS-SCCH Info has changed */
          if (rrcllc_check_if_hsscch_changed(&hspdsch_info_ptr->hs_scch_Info,MSG_REL7) == TRUE)
          {
            hsscch_codes_changed = TRUE;
          }


          if (set_hsscch_info_r7(&hspdsch_info_ptr->hs_scch_Info) == FAILURE)
          {
            return FAILURE;
          }
          else
          {

            if (hsscch_codes_changed == TRUE)
            {
              WRRC_MSG0_HIGH("RRCHS:SCCH Info changed");
              reconfig_bit_mask =reconfig_bit_mask | CPHY_HS_SCCH_CFG_INCL;
            }
          }
        }
        
        if(RRC_MSG_COMMON_BITMASK_IE_PTR(hspdsch_info_ptr,rrc_DL_HSPDSCH_Information_r7,measurement_feedback_Info))
        {

          /* Check if Meas Feedback Info has changed */
          rrcllc_check_if_meas_feedback_changed_r7(&hspdsch_info_ptr->measurement_feedback_Info, 
                                                &b_table_changed, &hsdpcch_changed);


          if (set_meas_feedback_info_r7(&hspdsch_info_ptr->measurement_feedback_Info) == FAILURE)
          {
            return FAILURE;
          }
          else
          {

            if (b_table_changed == TRUE)
            {
              ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 
                HS_DPCCH_BETA_HS_INFO_PRESENT_BITMASK;
              reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_DPCCH_CFG_INCL;
            }
            if (hsdpcch_changed == TRUE)
            {
              ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 
                ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask |
                HS_DPCCH_MEAS_FEEDBACK_INFO_PRESENT_BITMASK;
              reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_DPCCH_CFG_INCL;
            }


          }
        }
#ifdef FEATURE_WCDMA_64QAM
        if(current_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured !=
               ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured)
        {
          hsdpa_msg_params.hsdsch_info_present = TRUE;
          WRRC_MSG0_HIGH("Set HS-DSCh bitmask as 64 QAM config is changed ");
        }
#endif
      }

      /* Check if only beta table has changed */
      if ((b_table_changed == FALSE) && (hsdpa_msg_params.beta_table_present == TRUE))
      {
        ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 
          HS_DPCCH_BETA_HS_INFO_PRESENT_BITMASK;

        reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_DPCCH_CFG_INCL;
      }

      /* Check if only beta table has changed */
      if ((hsdpcch_changed == FALSE) && (hsdpa_msg_params.hs_dpcch_info_present == TRUE))
      {
        ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 
          HS_DPCCH_MEAS_FEEDBACK_INFO_PRESENT_BITMASK;

        reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_DPCCH_CFG_INCL;
      }

	  MSG_6(MSG_SSID_DIAG, MSG_LEGACY_HIGH,"RRCHS: hsdpa_msg_params.hspdsch_info_present %d hsscch_codes_changed %d,b_table_changed %d hsdpcch_changed %d,hsdpa_msg_params.beta_table_present %d hsdpa_msg_params.hs_dpcch_info_present %d", 
            hsdpa_msg_params.hspdsch_info_present,
            hsscch_codes_changed,
            b_table_changed,
            hsdpcch_changed,
            hsdpa_msg_params.beta_table_present,
            hsdpa_msg_params.hs_dpcch_info_present);

      /* Final Check to make sure that everything is present */
      if (rrcllc_check_if_hsdpa_can_be_started_reconfigured(ordered_config_ptr) == FALSE)
      {
       rrc_set_hsdpa_action(HSDPA_STOP);

        return SUCCESS;
      }

      /* Check if HS-DPCCH Info has changed */
      if (hsdpa_msg_params.hs_dpcch_info_present == TRUE)
      {
        reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_DPCCH_CFG_INCL;
      }
      /* Set the queue information */
      if (set_hsdpa_l1_queue_info() == FAILURE)
      {
        WRRC_MSG0_ERROR("RRCHS:Unable to set HSDPA info in L1");
        return FAILURE;
      }
      else
      {

        if ((hsdpa_msg_params.hsdsch_info_present == TRUE) ||
            ((hsdpa_msg_params.hrnti_present == TRUE) && (hsdpa_msg_params.hrnti_changed == TRUE)))
        {
          reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_DSCH_CFG_INCL;
        }

      }


      if ((reconfig_bit_mask == 0) && 
          (ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator == FALSE) &&
          ordered_config_ptr->dest_freq_present == FALSE)
      {

        rrc_set_hsdpa_action(HSDPA_NOOP);
        return SUCCESS;

      }
      

      ordered_config_ptr->l1_hsdpa_info.hs_req_mask = reconfig_bit_mask;

      /* Set Action to RECONFIG */
     MSG_3(MSG_SSID_DIAG, MSG_LEGACY_HIGH,"RRCHS:HSRECONFIG bit mask/ordered_config_ptr->l1_hsdpa_info.hs_req_mask %d,HS-RESET %d, ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask %d",
               reconfig_bit_mask,
               ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator,
               ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask);
       rrc_set_hsdpa_action(HSDPA_RECONFIG);
      
      return SUCCESS;
      
    } /* End of if of hsdpa msg params present */
    else
    {
      /* Final Check to make sure that everything is present */
      if (rrcllc_check_if_hsdpa_can_be_started_reconfigured(ordered_config_ptr) == FALSE)
      {
         rrc_set_hsdpa_action(HSDPA_STOP);

        return SUCCESS;
      }
      if (ordered_config_ptr->dest_freq_present == TRUE)
      {
        rrc_set_hsdpa_action(HSDPA_RECONFIG);
        return SUCCESS;
      }

      /* Means No Action */
      rrc_set_hsdpa_action(HSDPA_NOOP);

      return SUCCESS;
    }
  }
}
#ifdef FEATURE_WCDMA_MIMO

/*============================================================================
FUNCTION: rrcllc_check_if_mimo_can_be_started()

DESCRIPTION:


DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
boolean rrcllc_check_if_mimo_can_be_started
(
  rrc_RRC_StateIndicator rrc_state
)
{
  uint32 i;
  hsdpa_action_enum_type hs_action =rrc_get_hsdpa_action() ;
  /*
  The MIMO_STATUS variable shall be set to TRUE only when all the following conditions are met:
    "	The UE is in CELL_DCH state.
    "	The variable MIMO_PARAMS contains a value for the IE "MIMO N_cqi_typeA/M_cqi ratio". and
    "	The variable MIMO_PARAMS contains a value for the IE "MIMO pilot configuration".

  */

  
  if(( rrc_state != rrc_RRC_StateIndicator_cell_DCH ) ||
     (ordered_config_ptr->l1_hsdpa_info.mimo_info.mimo_n_m_ratio == MIMO_N_TO_M_RATIO_INVALID ) ||
     (ordered_config_ptr->l1_hsdpa_info.mimo_info.second_cpich_pattern == MIMO_INVALID_PILOT_PATTERN)
     )
  {
    MSG_HIGH("Mimo status false, rrc state %d, N-M ratio %d, CIPH pattern %d ",rrc_state,
          ordered_config_ptr->l1_hsdpa_info.mimo_info.mimo_n_m_ratio,
          ordered_config_ptr->l1_hsdpa_info.mimo_info.second_cpich_pattern);
    return FALSE;
  }
 /*
   *  Section 8.6.6.41	MIMO parameters
   *  1> If the IE "Primary CPICH usage for Channel Estimation" is set to "FALSE":
   *       2>	the UE behavior is undefined.
   *  1> If the IE "S-CPICH Info" is included and if  the IE "Channelisation code" in MIMO pilot configuration 
   *        is different from  the IE "Channelisation Code" in Secondary CPICH info
   *        2>	the UE behavior is undefined.
   *
   */
  for(i=0;i< ordered_config_ptr->l1_dl_chan_parms.num_rl;i++)
  {
    if( ordered_config_ptr->l1_dl_chan_parms.dl_per_rl[i].dpch_per_rl.use_pri_cpich == L1_DO_NOT_USE_PRI_CPICH)
    {
       WRRC_MSG1_ERROR("MIMO:MIMO cannot be started as Primary CIPCH for rl %d cant use Channel estimation",
           i);
       return FALSE;
    }

    if(ordered_config_ptr->l1_hsdpa_info.mimo_info.second_cpich_pattern == MIMO_DIVERSITY_PATTERN)
    {
        if( ordered_config_ptr->l1_dl_chan_parms.dl_per_rl[i].dpch_per_rl.opt_parms_present_mask
        & DL_DPCH_INFO_PER_RL_SEC_CPICH_INFO_PRESENT)
        {           
          if( ordered_config_ptr->l1_dl_chan_parms.dl_per_rl[i].dpch_per_rl.sec_cpich_ch_code != 
           ordered_config_ptr->l1_hsdpa_info.mimo_info.channelisation_code)
          {
            MSG_ERROR("MIMO:MIMO cannot be started as rl %d sec chann code %d is not same mimo chann code %d",
                i,ordered_config_ptr->l1_dl_chan_parms.dl_per_rl[i].dpch_per_rl.sec_cpich_ch_code,
                ordered_config_ptr->l1_hsdpa_info.mimo_info.channelisation_code);
            return FALSE;
          }
        }
    }
  }
  if((CHECK_WCDMA_OPTIONAL_FEATURE_MIMO_SUPPORTED ) && 
       ((hs_action == HSDPA_START) ||
         ((rrc_get_hsdpa_status() == HSDPA_ACTIVE) && (hs_action != HSDPA_STOP)) )
     )
  {
    WRRC_MSG0_HIGH("MIMO:MIMO can be started");
    return TRUE;
  }
  else
  {
    MSG_HIGH("MIMO:MIMO cannot be started HS Active %d HS Status %d MIMO supported %d",
           hs_action,rrc_get_hsdpa_status(),CHECK_WCDMA_OPTIONAL_FEATURE_MIMO_SUPPORTED);
    return FALSE;
    
  }
   
}


/*============================================================================
FUNCTION: rrcllc_update_mimo_status()

DESCRIPTION:


DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
void rrcllc_update_mimo_status
(
  rrc_mimo_status_enum_type mimo_status
)
{
  WRRC_MSG1_HIGH("MIMO:Set MIMO Status to %d",mimo_status);
  rrc_mimo_status = mimo_status;
}
/*============================================================================
FUNCTION: rrcllc_init_mimo_params()

DESCRIPTION:


DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
void rrcllc_init_mimo_params
(
  ordered_config_type *config_ptr
)
{
  ordered_config_ptr->l1_hsdpa_info.hs_req_mask &= ~CPHY_HS_MIMO_CFG_INCL;
  config_ptr->l1_hsdpa_info.mimo_info.mimo_n_m_ratio = MIMO_N_TO_M_RATIO_INVALID;
  config_ptr->l1_hsdpa_info.mimo_info.second_cpich_pattern = MIMO_INVALID_PILOT_PATTERN;
  config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_NOOP;
  rrcllc_update_mimo_status(RRC_MIMO_INACTIVE);

#ifdef FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT
  config_ptr->l1_hsdpa_info.mimo_info.s_cpich_po = rrc_mimo_s_cpich_po;  
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT*/
  
#ifdef FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION
  config_ptr->l1_hsdpa_info.mimo_info.mimo_codebook_restriction_present= FALSE;  
#endif /*FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/
  
}
#endif /*FEATURE_WCDMA_MIMO*/

/*============================================================================
FUNCTION: rrcllc_update_l1_dtx_req_mask_for_stop()

DESCRIPTION:
  This function updates the l1_cpc_dtx_req_mask to be sent to layer1.
  This function is called whenever any of the EUL related UL physical layer 
  parameters are modified by reconfig message.

DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
void rrcllc_update_l1_dtx_req_mask_for_stop
(
  boolean dtx_info_present
)
{
  if (TRUE == dtx_info_present)
  {
    /* set the reqeest mask with stop, because DTX evaluation has set 
     * DTX-DRX-status = FALSE */

    ordered_config_ptr->l1_cpc_dtx_req_mask |= L1_CPC_DTX_STOP;
  }
}
/*============================================================================
FUNCTION: rrcllc_update_l1_dtx_req_mask_for_reconfig()

DESCRIPTION:
  This function updates the l1_cpc_dtx_req_mask to be sent to layer1.
  This function is called whenever any of the EUL related UL physical layer 
  parameters are modified by reconfig message.

DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
void rrcllc_update_l1_dtx_req_mask_for_reconfig
(
  boolean dtx_info_present
)
{
  if (TRUE == dtx_info_present)
  {
    /* set the reqeest mask with stop, because DTX evaluation has set 
     * DTX-DRX-status = FALSE */

    ordered_config_ptr->l1_cpc_dtx_req_mask |= L1_CPC_DTX_RECONFIG;
  }
}
/*============================================================================
FUNCTION: rrcllc_update_l1_dtx_req_mask_for_start()

DESCRIPTION:
  This function updates the l1_cpc_dtx_req_mask to be sent to layer1.
  This function is called whenever any of the EUL related UL physical layer 
  parameters are modified by reconfig message.

DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
void rrcllc_update_l1_dtx_req_mask_for_start
(
  boolean dtx_info_present
)
{
  if (TRUE == dtx_info_present)
  {
    /* set the reqeest mask with stop, because DRX evaluation has set 
     * DTX-DRX-status = FALSE */

    ordered_config_ptr->l1_cpc_dtx_req_mask |= L1_CPC_DTX_START;
  }
}
/*============================================================================
FUNCTION: rrcllc_update_l1_dtx_req_mask_for_no_op()

DESCRIPTION:
  This function updates the l1_cpc_dtx_req_mask to be sent to layer1.
  This function is called whenever any of the EUL related UL physical layer 
  parameters are modified by reconfig message.

DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
void rrcllc_update_l1_dtx_req_mask_for_no_op
(
  boolean dtx_info_present
)
{
  if (TRUE == dtx_info_present)
  {
    /* set the reqeest mask with NO-OP*/

    ordered_config_ptr->l1_cpc_dtx_req_mask |= L1_CPC_DTX_NO_OP;
  }
}

/*============================================================================
FUNCTION: rrcllc_update_l1_drx_req_mask_for_stop()

DESCRIPTION:
  This function updates the l1_cpc_drx_req_mask to be sent to layer1.
  This function is called whenever any of the EUL related UL physical layer 
  parameters are modified by reconfig message.

DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
void rrcllc_update_l1_drx_req_mask_for_stop
(
  ordered_config_type *config_ptr,
  boolean drx_info_present
)
{
  if (TRUE == drx_info_present)
  {
    /* set the reqeest mask with stop, because DRX evaluation has set 
     * DTX-DRX-status = FALSE */

    config_ptr->l1_cpc_drx_req_mask |= L1_CPC_DRX_STOP;
  }
}
/*============================================================================
FUNCTION: rrcllc_update_l1_drx_req_mask_for_reconfig()

DESCRIPTION:
  This function updates the l1_cpc_drx_req_mask to be sent to layer1.
  This function is called whenever any of the EUL related UL physical layer 
  parameters are modified by reconfig message.

DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
void rrcllc_update_l1_drx_req_mask_for_reconfig
(
  ordered_config_type *config_ptr,
  boolean drx_info_present
)
{
  if (TRUE == drx_info_present)
  {
    /* set the reqeest mask with stop, because DRX evaluation has set 
     * DTX-DRX-status = FALSE */

    config_ptr->l1_cpc_drx_req_mask |= L1_CPC_DRX_RECONFIG;
  }
}
/*============================================================================
FUNCTION: rrcllc_update_l1_drx_req_mask_for_start()

DESCRIPTION:
  This function updates the l1_cpc_drx_req_mask to be sent to layer1.
  This function is called whenever any of the EUL related UL physical layer 
  parameters are modified by reconfig message.

DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
void rrcllc_update_l1_drx_req_mask_for_start
(
  ordered_config_type *config_ptr,
  boolean drx_info_present
)
{
  if (TRUE == drx_info_present)
  {
    /* set the reqeest mask with start, because DRX evaluation has set 
     * DTX-DRX-status = TRUE */

    config_ptr->l1_cpc_drx_req_mask |= L1_CPC_DRX_START;
  }
}
/*============================================================================
FUNCTION: rrcllc_update_l1_drx_req_mask_for_no_op()

DESCRIPTION:
  This function updates the l1_cpc_drx_req_mask to be sent to layer1.
  This function is called whenever any of the EUL related UL physical layer 
  parameters are modified by reconfig message.

DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
void rrcllc_update_l1_drx_req_mask_for_no_op
(
 ordered_config_type *config_ptr,
  boolean drx_info_present
)
{
  if (TRUE == drx_info_present)
  {
    /* set the reqeest mask with NO-OP*/

    config_ptr->l1_cpc_drx_req_mask |= L1_CPC_DRX_NO_OP;
  }
}
/*============================================================================
FUNCTION: rrcllc_get_l1_cpc_drx_status()

DESCRIPTION:
  This function retuens the l1_cpc_drx_status.

DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
boolean rrcllc_get_l1_cpc_drx_status
(
 ordered_config_type *config_ptr
)
{
  return (config_ptr->cpc_drx_status);
}

/*============================================================================
FUNCTION: rrcllc_update_l1_e_req_mask_for_e_ul_info()

DESCRIPTION:
  This function updates the e_req_mask to be sent to layer1.
  This function is called whenever any of the EUL related UL physical layer 
  parameters are modified by reconfig message.

DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
void rrcllc_update_l1_e_req_mask_for_e_ul_info
(
  boolean e_ul_info_present
)
{
  if (TRUE == e_ul_info_present)
  {
    /* set the reqeest mask with reconfig, because EUL is already up */
    /* if E-DCH transmission is START or STOP then this request mask needs to be
       modified accordingly*/    
    ordered_config_ptr->l1_e_req_mask |= L1_EUL_RECFG_UL;
  }
}

/*============================================================================
FUNCTION: rrcllc_update_l1_e_req_mask_for_e_dl_info()

DESCRIPTION:
  This function updates the e_req_mask to be sent to layer1.
  This function is called whenever any of the EUL related DL physical layer 
  parameters are modified by reconfig message.

DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
void rrcllc_update_l1_e_req_mask_for_e_dl_info
(
  boolean e_dl_info_present
)
{
  if (TRUE == e_dl_info_present)
  {
    /* set the reqeest mask with reconfig, because EUL is already up */
    /* if E-DCH transmission is START or STOP then this request mask needs to be
       modified accordingly*/
    ordered_config_ptr->l1_e_req_mask |= L1_EUL_RECFG_DL;
  }
}
/*============================================================================
FUNCTION: rrcllc_update_e_dl_channel_mask_for_e_active_set_rl_to_reconfig()

DESCRIPTION:
  This function will set all E-DCH active set DL RL's bit mask to reconfig, This is 
  currenlty used in TTI reconfiguration, where L1 needs to reconfigure all DL RL's 
  in E-DCH active set.
      
DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
void rrcllc_update_e_dl_channel_mask_for_e_active_set_rl_to_reconfig
(
  void
)
{
  uint32 idx;
  l1_e_dl_info_struct_type *e_dl_info_ptr = 
                                      &ordered_config_ptr->l1_e_info.e_dl_info;
  
  for (idx = 0; idx<e_dl_info_ptr->num_e_dl_rl_add_recfg_info; idx++)
  {


  
    if(e_dl_info_ptr->e_dl_rl_add_recfg_info[idx].e_dl_channel_mask  &
      L1_E_AGCH_INFO_PRESENT)
    {
      e_dl_info_ptr->e_dl_rl_add_recfg_info[idx].e_dl_channel_mask |= 
        L1_E_AGCH_INFO_RECFG;
    }
    
    if(e_dl_info_ptr->e_dl_rl_add_recfg_info[idx].e_dl_channel_mask  &
      L1_E_HICH_INFO_PRESENT)
    {
      e_dl_info_ptr->e_dl_rl_add_recfg_info[idx].e_dl_channel_mask |= 
        L1_E_HICH_INFO_RECFG;
    }
    
    if(e_dl_info_ptr->e_dl_rl_add_recfg_info[idx].e_dl_channel_mask  &
      L1_E_RGCH_INFO_PRESENT)
    {
      e_dl_info_ptr->e_dl_rl_add_recfg_info[idx].e_dl_channel_mask |= 
        L1_E_RGCH_INFO_RECFG;
    }
    MSG_HIGH("RRCEUL:e_dl_channel_mask 0x%x for PSC=%d, idx= %d",
      e_dl_info_ptr->e_dl_rl_add_recfg_info[idx].e_dl_channel_mask, e_dl_info_ptr->e_dl_rl_add_recfg_info[idx].e_rl_psc, idx);
  }
}
/*============================================================================
FUNCTION: rrcllc_update_mac_eul_action()

DESCRIPTION:
  This function updates the mac_eul_action to be sent to MAC.
  This function is called whenever any of the EUL related parameters used by MAC 
  is modified by reconfig message.

DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
void rrcllc_update_mac_eul_action
(
  boolean mac_e_es_info_present
)
{
  if (TRUE == mac_e_es_info_present)
  {
    /* set the reqeest mask with reconfig, because EUL is already up */
    /* if E-DCH transmission is START or STOP then this action needs to be
       modified accordingly*/
    ordered_config_ptr->mac_eul_action = MAC_EUL_CONFIG;
  }
}


#ifdef FEATURE_WCDMA_DC_HSUPA

/*============================================================================
FUNCTION: rrcllc_update_mac_sec_eul_action()

DESCRIPTION:
  This function updates the mac_sec_eul_action to be sent to MAC.
  This function is called whenever any of the SEC EUL related parameters used by MAC 
  is modified by reconfig message.

DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
void rrcllc_update_mac_sec_eul_action
(
  boolean mac_e_es_info_present
)
{
  if (TRUE == mac_e_es_info_present)
  {
    /* set the reqeest mask with reconfig, because EUL is already up */
    /* if E-DCH transmission is START or STOP then this action needs to be
       modified accordingly*/
    ordered_config_ptr->mac_sec_eul_action= MAC_SEC_EUL_CONFIG;
  }
}


#endif /* FEATURE_WCDMA_DC_HSUPA */


/*====================================================================
FUNCTION: rrcllc_init_mac_ul_edch_info_ie()

DESCRIPTION:
  This function initializes 'mac_e_config.e_dch_info' variables (i.e. UL-EDCH
  physical layer parameters).
  This function should be called whenever UE leaves DCH state.  
DEPENDENCIES:


RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_mac_ul_edch_info_ie
(
  ordered_config_type *config_ptr
)
{
  config_ptr->mac_e_config.e_dch_info.e_dpcch_info.happy_bit_delay_in_ms = 0;

  config_ptr->mac_e_config.e_dch_info.e_dpdch_info.e_tfci_min_set = 
    MAC_E_TFCI_MIN_SET_NOT_PRESENT;

  config_ptr->mac_e_config.e_dch_info.e_dpdch_info.e_tfci_table_index = 0;

  config_ptr->mac_e_config.e_dch_info.e_dpdch_info.sched_info_config.
    grant_periodicity_of_si = 0;

  config_ptr->mac_e_config.e_dch_info.e_dpdch_info.sched_info_config.
    no_grant_periodicity_of_si = 0;

  config_ptr->mac_e_config.e_dch_info.e_dpdch_info.sched_info_config.
    power_offset_of_si = 0;

  config_ptr->mac_e_config.e_dch_info.e_dpdch_info.sched_tx_config.
    sched_tx_grant_harq_allocation_2ms = 0xFF;

}

#ifdef FEATURE_WCDMA_DC_HSUPA
/*====================================================================
FUNCTION: rrcllc_init_mac_sec_ul_edch_info_ie()

DESCRIPTION:
  This function initializes 'mac_sec_eul_config' variables (i.e. UL-EDCH
  physical layer parameters).
  This function should be called whenever UE leaves DCH state.  
DEPENDENCIES:


RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_mac_sec_ul_edch_info_ie
(
  ordered_config_type *config_ptr
)
{
  config_ptr->mac_sec_eul_config.e_tfci_min_set = 
    MAC_E_TFCI_MIN_SET_NOT_PRESENT;

  config_ptr->mac_sec_eul_config.sched_tx_config.sched_tx_grant_harq_allocation_2ms = 0xFF;

}
#endif /* FEATURE_WCDMA_DC_HSUPA */

/*====================================================================
FUNCTION: rrcllc_init_mac_e_info()

DESCRIPTION:
  This function initializes mac e info stored in rrc data-base
  
DEPENDENCIES:
  Function is only called before processing the DL OTA Msg.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_mac_e_info(ordered_config_type *config_ptr)
{
  uint32 count, idx;

  config_ptr->mac_eul_action = MAC_EUL_NOOP;

  config_ptr->mac_e_reset_indicator = FALSE;

  config_ptr->mac_e_tsn_action = MAC_E_TSN_ACTION_BACKUP;

  config_ptr->mac_e_config.e_tti = NUM_E_TTI;

  rrcllc_init_mac_ul_edch_info_ie(config_ptr);

  config_ptr->mac_e_config.num_e_mac_d_flow = 0;

  for (count=0; count<MAX_E_DCH_MAC_D_FLOW; count++)
  {
    config_ptr->mac_e_config.e_mac_d_flow_info[count].
      e_mac_d_flow_id = INVALID_DFLOW_ID;

    config_ptr->mac_e_config.e_mac_d_flow_info[count].
      e_mac_d_flow_power_offset = 0xFF;

    config_ptr->mac_e_config.e_mac_d_flow_info[count].
      e_mac_d_flow_max_num_of_retx = 0xFF;

    config_ptr->mac_e_config.e_mac_d_flow_info[count].
      e_mac_d_flow_mux_list = 0xFF;

    config_ptr->mac_e_config.e_mac_d_flow_info[count].
      e_tx_grant_info = MAC_E_TX_GRANT_NOT_DEFINED;

    config_ptr->mac_e_config.e_mac_d_flow_info[count].
      num_logch = 0;

    for (idx=0; idx < MAX_DED_LOGCHAN_PER_TRCH; idx++)
    {
      config_ptr->mac_e_config.e_mac_d_flow_info[count].
        e_ul_logch_info[idx].include_in_scheduling_info = FALSE;
      config_ptr->mac_e_config.e_mac_d_flow_info[count].
        e_ul_logch_info[idx].num_rlc_size_ddi_info = 0;
#ifdef FEATURE_MAC_I
      config_ptr->mac_e_config.e_mac_d_flow_info[count].
        e_ul_logch_info[idx].rlc_pdu_type = RLC_INVALID_PDU_SIZE;
      config_ptr->mac_e_config.e_mac_d_flow_info[count].
        e_ul_logch_info[idx].ul_li_size = LI_UNSPECIFIED;
      config_ptr->mac_e_config.e_mac_d_flow_info[count].
        e_ul_logch_info[idx].ul_flex_min_pdu_size = RRC_UL_INVALID_RLC_SIZE;
      config_ptr->mac_e_config.e_mac_d_flow_info[count].
        e_ul_logch_info[idx].ul_flex_max_pdu_size = RRC_UL_INVALID_RLC_SIZE;
#endif /* FEATURE_MAC_I */	
    }

    config_ptr->mac_e_config.e_mac_d_flow_info[count].
      non_sched_tx_grant.non_sched_tx_grant_harq_allocation_2ms = 0xFF;

    config_ptr->mac_e_config.e_mac_d_flow_info[count].
      non_sched_tx_grant.max_mac_e_pdu_size_in_bits = 0;
  }
}

#ifdef FEATURE_WCDMA_DC_HSUPA


/*====================================================================
FUNCTION: rrcllc_init_mac_e_info()

DESCRIPTION:
  This function initializes sec mac e info stored in rrc data-base
  
DEPENDENCIES:
  Function is only called before processing the DL OTA Msg.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_mac_sec_eul_e_info(ordered_config_type *config_ptr)
{

  config_ptr->mac_sec_eul_action = MAC_SEC_EUL_NOOP;

  config_ptr->mac_e_reset_indicator = FALSE;

  config_ptr->mac_e_tsn_action = MAC_E_TSN_ACTION_BACKUP;

  rrcllc_init_mac_sec_ul_edch_info_ie(config_ptr);
}

#endif /* FEATURE_WCDMA_DC_HSUPA */

/*====================================================================
FUNCTION: rrcllc_init_l1_e_ul_info_going_to_idle()

DESCRIPTION:
  This function initializes l1_e_ul_info variables.
  Some of the variables needs to be touched only if UE is in idle state or
  transitioning to idle state.

DEPENDENCIES:


RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_l1_e_ul_info
(
  boolean is_idle,
  ordered_config_type *config_ptr  
)
{
  config_ptr->l1_e_info.e_ul_info.e_dpcch_info.e_dpcch_pwr_offset = 0xFF;
#ifdef FEATURE_WCDMA_REL7_EDPCCH_POWER_BOOST
  config_ptr->l1_e_info.e_ul_info.e_dpcch_info.e_tfc_boost_info.e_tfci_boost_val =0xff;
  config_ptr->l1_e_info.e_ul_info.e_dpcch_info.e_tfc_boost_info.delta_t2tp =0xff;
#endif
  config_ptr->l1_e_info.e_ul_info.e_dpcch_info.e_dpdch_pwr_interpolation 
        = FALSE;
  config_ptr->l1_e_info.e_ul_info.e_dpdch_info.e_max_ch_codes = 
    L1_NUM_L1_E_MAX_CH_CODES_SF;  

  config_ptr->l1_e_info.e_ul_info.e_dpdch_info.num_ref_e_tfci = 0;

  config_ptr->l1_e_info.e_ul_info.e_dpdch_info.e_dpdch_pl_non_max = 0xFF;

  config_ptr->l1_e_info.e_ul_info.e_dpdch_info.e_tfci_table_idx = 0xFF;

  config_ptr->e_dch_transmission = FALSE;

  if (is_idle == TRUE)
  {
    config_ptr->l1_e_info.e_ul_info.e_tti = NUM_E_TTI;
    config_ptr->l1_e_info.e_ul_info.harq_rv_config = L1_RV_NOT_PRESENT;
  }
}
#ifdef FEATURE_WCDMA_DC_HSUPA
/*====================================================================
FUNCTION: rrcllc_init_l1_sec_e_ul_info()

DESCRIPTION:
  This function initializes l1_sec_e_ul_info variables.
  Some of the variables needs to be touched only if UE is in idle state or
  transitioning to idle state.

DEPENDENCIES:


RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_l1_sec_e_ul_info
(
  ordered_config_type *config_ptr  
)
{
  config_ptr->sec_e_dch_transmission = FALSE;
  config_ptr->l1_sec_e_info.e_ul_info.dpcch_info.dpcch_pwr_offset = 0;
  config_ptr->l1_sec_e_info.e_ul_info.dpcch_info.pcp_len = 0xFF;
  config_ptr->l1_sec_e_info.e_ul_info.dpcch_info.scrambling_code = 0xFFFFFFFF;
  config_ptr->l1_sec_e_info.e_ul_info.dpcch_info.scrambling_code_type = L1_UL_SC_SHORT;
}



/*====================================================================
FUNCTION: rrcllc_init_l1_dl_dpch_chan_info()

DESCRIPTION:
  This function initializes the Downlink sec FDPCH related channel info
  that goes to L1.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void  rrcllc_init_l1_dl_sec_fdpch_chan_info(ordered_config_type  *config_ptr)
{
  uint8  rl_count;

  config_ptr->l1_dl_chan_parms.sec_num_rl =0;
  

  for (rl_count = 0; rl_count < UE_MAX_RL; rl_count++)
  {
    rrcllc_init_dl_rl_info(config_ptr, rl_count
#ifdef FEATURE_WCDMA_DC_HSUPA
                            ,TRUE
#endif /* FEATURE_WCDMA_DC_HSUPA */

                            );
  }
}

#endif /* FEATURE_WCDMA_DC_HSUPA */
/*====================================================================
FUNCTION: rrcllc_init_l1_e_dl_info()

DESCRIPTION:
  This function initializes l1_e_dl_info variables.
  Some of the variables needs to be touched only if UE is in idle state or
  transitioning to idle state.
  
DEPENDENCIES:


RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_l1_e_dl_info
(
  boolean is_idle,
  boolean is_hho,
  ordered_config_type *config_ptr  
)
{
  uint32 count;

  config_ptr->l1_e_info.e_dl_info.primary_e_rnti_present = FALSE;

  config_ptr->l1_e_info.e_dl_info.secondary_e_rnti_present = FALSE;

  config_ptr->e_dch_transmission = FALSE;

  if (TRUE == is_idle)
  {
    config_ptr->l1_e_info.e_dl_info.e_tti = NUM_E_TTI;
  }

  config_ptr->l1_e_info.e_dl_info.grant_config.serving_grant =  
    L1_SERVING_GRANT_NOT_PRESENT;

  config_ptr->l1_e_info.e_dl_info.grant_config.grant_selector = 
    L1_E_GRANT_SELECTOR_NOT_PRESENT;

  /* If init is called because of HHO, no need to reset the step thresholds */
  if (!is_hho) 
  {
    config_ptr->l1_e_info.e_dl_info.grant_config.
      three_index_step_threshold = L1_SG_STEP_THRESHOLD_NOT_PRESENT;

    config_ptr->l1_e_info.e_dl_info.grant_config.
      two_index_step_threshold = L1_SG_STEP_THRESHOLD_NOT_PRESENT;
  }

  config_ptr->l1_e_info.e_dl_info.num_e_rl_release_info = 0;
  config_ptr->l1_e_info.e_dl_info.e_serving_rl_idx =  L1_MAX_EDCH_RL;

  config_ptr->l1_e_info.e_dl_info.num_e_dl_rl_add_recfg_info = 0;

  for (count=0; count < L1_MAX_EDCH_RL; count++)
  {
    config_ptr->l1_e_info.e_dl_info.
      e_dl_rl_add_recfg_info[count].e_dl_channel_mask = 0;
  }
}
#ifdef FEATURE_WCDMA_DC_HSUPA
/*====================================================================
FUNCTION: rrcllc_init_l1_sec_e_dl_info()

DESCRIPTION:
  This function initializes l1_sec_e_dl_info variables.
  Some of the variables needs to be touched only if UE is in idle state or
  transitioning to idle state.
  
DEPENDENCIES:


RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_l1_sec_e_dl_info
(
  boolean is_idle,
  boolean is_hho,
  ordered_config_type *config_ptr  
)
{
  uint32 count;

  config_ptr->l1_sec_e_info.e_dl_info.primary_e_rnti_present = FALSE;

  config_ptr->l1_sec_e_info.e_dl_info.secondary_e_rnti_present = FALSE;

  config_ptr->sec_e_dch_transmission = FALSE;

  if (TRUE == is_idle)
  {
    config_ptr->l1_sec_e_info.e_dl_info.e_tti = NUM_E_TTI;
  }

  config_ptr->l1_sec_e_info.e_dl_info.grant_config.serving_grant =  
    L1_SERVING_GRANT_NOT_PRESENT;

  config_ptr->l1_sec_e_info.e_dl_info.grant_config.grant_selector = 
    L1_E_GRANT_SELECTOR_NOT_PRESENT;

  /* If init is called because of HHO, no need to reset the step thresholds */
  if (!is_hho) 
  {
    config_ptr->l1_sec_e_info.e_dl_info.grant_config.
      three_index_step_threshold = L1_SG_STEP_THRESHOLD_NOT_PRESENT;

    config_ptr->l1_sec_e_info.e_dl_info.grant_config.
      two_index_step_threshold = L1_SG_STEP_THRESHOLD_NOT_PRESENT;
  }

  config_ptr->l1_sec_e_info.e_dl_info.num_e_rl_release_info = 0;
  config_ptr->l1_sec_e_info.e_dl_info.e_serving_rl_idx =  L1_MAX_EDCH_RL;

  config_ptr->l1_sec_e_info.e_dl_info.num_e_dl_rl_add_recfg_info = 0;

  for (count=0; count < L1_MAX_EDCH_RL; count++)
  {
    config_ptr->l1_sec_e_info.e_dl_info.
      e_dl_rl_add_recfg_info[count].e_dl_channel_mask = 0;
  }
}
#endif /* FEATURE_WCDMA_DC_HSUPA */
/*====================================================================
FUNCTION: rrcllc_reset_mac_and_l1_e_info_on_llc_cfg_cnf()

DESCRIPTION:
  This function resets the MAC and L1 variables on receipt of LLC CONFIG CNF 
  by any procedure
  
DEPENDENCIES:
  None
  
RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_reset_mac_and_l1_e_info_on_llc_cfg_cnf(void)
{
  uint32 rl_idx;
  l1_e_dl_info_struct_type *e_dl_info_ptr;
  ordered_config_type  *config_ptr;
  if(config_ptr_in_use == ORDERED_CONFIG)
  {
    config_ptr = ordered_config_ptr;
  }
  else
  {
    config_ptr = current_config_ptr;
  }
  e_dl_info_ptr = &config_ptr->l1_e_info.e_dl_info;

  if (config_ptr->e_dch_transmission) 
  {
  WRRC_MSG3_MED("RRCEUL:Reset E-masks<Prev: e_req_mask: L1: %d, MAC: %d, num_e_rl_rel: %d>, reset 'is_hho' flag",
    config_ptr->l1_e_req_mask, 
    config_ptr->mac_eul_action,
    e_dl_info_ptr->num_e_rl_release_info);
  }
  config_ptr->l1_e_req_mask = L1_EUL_NOOP;
  config_ptr->mac_eul_action = MAC_EUL_NOOP;

  for (rl_idx = 0; rl_idx < e_dl_info_ptr->num_e_dl_rl_add_recfg_info; rl_idx++)
  {
    e_dl_info_ptr->e_dl_rl_add_recfg_info[rl_idx].e_dl_channel_mask &= 
      ~(L1_E_HICH_INFO_ADD | L1_E_HICH_INFO_RECFG | L1_E_AGCH_INFO_ADD |
        L1_E_AGCH_INFO_DROP |L1_E_AGCH_INFO_RECFG | L1_E_RGCH_INFO_ADD |
        L1_E_RGCH_INFO_DROP | L1_E_RGCH_INFO_RECFG);
  }

  e_dl_info_ptr->num_e_rl_release_info = 0;

  if (config_ptr->e_dch_transmission) 
  {
    WRRC_MSG0_MED("RRCEUL:Initializing serv grant and grant selector");
    e_dl_info_ptr->grant_config.serving_grant = L1_SERVING_GRANT_NOT_PRESENT;
    e_dl_info_ptr->grant_config.grant_selector = L1_E_GRANT_SELECTOR_NOT_PRESENT;
  }

  config_ptr->mac_e_reset_indicator = FALSE;

  config_ptr->mac_e_tsn_action = MAC_E_TSN_ACTION_BACKUP;

}

#ifdef FEATURE_WCDMA_DC_HSUPA
/*====================================================================
FUNCTION: rrcllc_reset_mac_and_l1_e_info_on_llc_cfg_cnf()

DESCRIPTION:
  This function resets the sec eul  MAC and L1 variables on receipt of LLC CONFIG CNF 
  by any procedure
  
DEPENDENCIES:
  None
  
RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_reset_mac_and_l1_sec_e_info_on_llc_cfg_cnf
(
void
)
{
  uint32 rl_idx;
  l1_e_dl_info_struct_type *e_dl_info_ptr;
  ordered_config_type  *config_ptr;
  if(config_ptr_in_use == ORDERED_CONFIG)
  {
    config_ptr = ordered_config_ptr;
  }
  else
  {
    config_ptr = current_config_ptr;
  }

  e_dl_info_ptr = &config_ptr->l1_sec_e_info.e_dl_info;

  if (config_ptr->sec_e_dch_transmission) 
  {
  WRRC_MSG3_MED("DC_HSUPA:Reset E-masks<Prev: e_req_mask: L1: %d, MAC: %d, num_e_rl_rel: %d>, reset 'is_hho' flag",
    config_ptr->l1_sec_e_req_mask, 
    config_ptr->mac_sec_eul_action,
    e_dl_info_ptr->num_e_rl_release_info);
  }
  config_ptr->l1_sec_e_req_mask = L1_EUL_NOOP;
  config_ptr->mac_sec_eul_action = MAC_SEC_EUL_NOOP;

  for (rl_idx = 0; rl_idx < e_dl_info_ptr->num_e_dl_rl_add_recfg_info; rl_idx++)
  {
    e_dl_info_ptr->e_dl_rl_add_recfg_info[rl_idx].e_dl_channel_mask &= 
      ~(L1_E_HICH_INFO_ADD | L1_E_HICH_INFO_RECFG | L1_E_AGCH_INFO_ADD |
        L1_E_AGCH_INFO_DROP |L1_E_AGCH_INFO_RECFG | L1_E_RGCH_INFO_ADD |
        L1_E_RGCH_INFO_DROP | L1_E_RGCH_INFO_RECFG);
  }

  e_dl_info_ptr->num_e_rl_release_info = 0;

  if (config_ptr->sec_e_dch_transmission) 
  {
    WRRC_MSG0_MED("DC_HSUPA:Initializing serv grant and grant selector");
    e_dl_info_ptr->grant_config.serving_grant = L1_SERVING_GRANT_NOT_PRESENT;
    e_dl_info_ptr->grant_config.grant_selector = L1_E_GRANT_SELECTOR_NOT_PRESENT;
  }

  config_ptr->mac_e_reset_indicator = FALSE;

  config_ptr->mac_e_tsn_action = MAC_E_TSN_ACTION_BACKUP;

}


#endif /* FEATURE_WCDMA_DC_HSUPA */
/*====================================================================
FUNCTION: rrcllc_init_e_dch_rbmapping_info()

DESCRIPTION:
  This function initializes E-DCH mac-d flow information.  To initialize
  all info, pass second parameter as true.  Else, pass index to be
  initialized

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:

====================================================================*/
void rrcllc_init_e_dch_rbmapping_info
(
  ordered_config_type  *config_ptr,
  uint8  e_mac_d_flow_idx
)
{

  /* Initialize some of the mac-d flow values*/
  config_ptr->mac_e_config.e_mac_d_flow_info[e_mac_d_flow_idx].
    e_mac_d_flow_id = INVALID_DFLOW_ID;
  config_ptr->mac_e_config.e_mac_d_flow_info[e_mac_d_flow_idx].
    num_logch = 0;
  config_ptr->mac_e_config.e_mac_d_flow_info[e_mac_d_flow_idx].
    e_mac_d_flow_max_num_of_retx = 0xFF;
  config_ptr->mac_e_config.e_mac_d_flow_info[e_mac_d_flow_idx].
    e_mac_d_flow_mux_list = 0xFF;
  config_ptr->mac_e_config.e_mac_d_flow_info[e_mac_d_flow_idx].
    non_sched_tx_grant.non_sched_tx_grant_harq_allocation_2ms = 0xFF;
  config_ptr->mac_e_config.e_mac_d_flow_info[e_mac_d_flow_idx].
    e_tx_grant_info = MAC_E_TX_GRANT_NOT_DEFINED;
  config_ptr->mac_e_config.e_mac_d_flow_info[e_mac_d_flow_idx].
    non_sched_tx_grant.max_mac_e_pdu_size_in_bits = 0;

  if (config_ptr->mac_e_config.num_e_mac_d_flow > 0)
  {
    config_ptr->mac_e_config.num_e_mac_d_flow--;
  }
  else
  {
    WRRC_MSG1_ERROR("RRCEUL: trying to delete e-mac-d-flow-id: %d when num_e_mac_d_flow is 0",
      e_mac_d_flow_idx);
  }

  WRRC_MSG2_HIGH("RRCEUL: Init idx %d e_mac_d_flow info, updated num_e_mac_d_flow: %d",
    e_mac_d_flow_idx, config_ptr->mac_e_config.num_e_mac_d_flow);

}
/*====================================================================
FUNCTION: rrcllc_update_e_dch_mapping_info_with_log_chl_id()

DESCRIPTION:
  This function updates the Uplink Mapping Info in EDCH RB Mapping
  Info with the passed Logical Channel ID.
  The correct entity is selected based on the passed RB ID.
  The EDCH RB mapping info in the passed Config data is updated.

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_update_e_dch_mapping_info_with_log_chl_id
(
  ordered_config_type  *config_ptr,
  rrc_RB_Identity  rb_id,
  rlc_lc_id_type   rlc_ul_log_chl_id
)
{
  boolean rb_found = FALSE;
  int ix, iy;

  for(ix = 0; (!rb_found) && (ix < config_ptr->mac_e_config.num_e_mac_d_flow); ix++)
  {
    if(config_ptr->mac_e_config.e_mac_d_flow_info[ix].e_mac_d_flow_id != INVALID_DFLOW_ID)
    {
      for(iy = 0; (!rb_found) && (iy < config_ptr->mac_e_config.e_mac_d_flow_info[ix].num_logch); iy++)
      {
        if (config_ptr->mac_e_config.e_mac_d_flow_info[ix].e_ul_logch_info[iy].rb_id == rb_id) 
        {
          WRRC_MSG2_MED("RRCEUL: rb_id %d lc_id %d", rb_id, rlc_ul_log_chl_id);
          rb_found = TRUE;
          config_ptr->mac_e_config.e_mac_d_flow_info[ix].e_ul_logch_info[iy].rlc_id = rlc_ul_log_chl_id;
          break;
        }
      }
    }
  }
}
/*====================================================================
FUNCTION: rrcllc_get_e_mac_dflow_idx()

DESCRIPTION:
  This function gets a EDCH mac-d flow Index for the specified mac-d flow. 
  If the the mac-d flow already existed, its index is returned. Otherwise a 
  new index is allocated for the mac-d ID. If a new mac-d flowindex is allocated,
  e_mac_d_flow count in MAC structure is updated.

DEPENDENCIES:
  None.

RETURN VALUE:
  Index value if successful else
  UE_MAX_MAC_D_FLOW if no index is available

SIDE EFFECTS:

====================================================================*/
uint8 rrcllc_get_e_mac_dflow_idx
(
  uint8  e_mac_d_flow_id
)
{
  uint8 index = MAX_E_DCH_MAC_D_FLOW;

  for(index = 0; index < ordered_config_ptr->mac_e_config.num_e_mac_d_flow; index++)
  {
    if(ordered_config_ptr->mac_e_config.e_mac_d_flow_info[index].e_mac_d_flow_id == e_mac_d_flow_id)
    {
      WRRC_MSG2_MED("RRCEUL:DFLOWidx %d, Id %d",index, e_mac_d_flow_id);
      return(index);
    }
  }

  /* E-MAC-d flow index not found, Allocate new */
  index = rrcllc_allocate_e_mac_d_flow_index();
  if(index != MAX_E_DCH_MAC_D_FLOW)
  {  
    /* Now Save the MAC-d flow ID in MAC structure */
    ordered_config_ptr->mac_e_config.e_mac_d_flow_info[index].e_mac_d_flow_id = e_mac_d_flow_id;
    
    /* Increment no of DFLOWs */
    ordered_config_ptr->mac_e_config.num_e_mac_d_flow++;
    
    WRRC_MSG1_MED("RRCEUL:New e-dch dflow cnt %d in MAC struct",ordered_config_ptr->mac_e_config.num_e_mac_d_flow );  
  } /* A valid new DFLOW index allocated */

  return(index);   
} /* rrcllc_get_dflow_index */

/*====================================================================
FUNCTION: rrcllc_find_e_mac_d_flow_idx()

DESCRIPTION:
  This function finds the edch mac-d flow index for the E-MAC-d FLOW. 
  If not found, it allocates a new index and return to the index number.

DEPENDENCIES:
  None.

RETURN VALUE:
  E-MAC-d FLOW Index if found
  Else UE_MAX_MAC_D_FLOW.

SIDE EFFECTS:
====================================================================*/
uint8  rrcllc_find_e_mac_d_flow_idx
(
  uint8  e_mac_dflow_id
)
{
  uint8 index = MAX_E_DCH_MAC_D_FLOW;

  for(index = 0; index < MAX_E_DCH_MAC_D_FLOW; index++)
  {
    if(ordered_config_ptr->mac_e_config.e_mac_d_flow_info[index].e_mac_d_flow_id == e_mac_dflow_id)
    {
      break;
    }
  }
  return(index);
}
/*====================================================================
FUNCTION: rrcllc_allocate_e_mac_d_flow_idx()

DESCRIPTION:
  Allocates a EDCH MAC-d flow Id.

DEPENDENCIES:
  None.

RETURN VALUE:
  uint8 -> A EDCH MAC-d flow Index.
  UE_MAX_MAC_D_FLOW -> Given EDCH Mac-d flow does not
           have an allocated DCH transport channel index.

SIDE EFFECTS:
====================================================================*/
uint8  rrcllc_allocate_e_mac_d_flow_index(void)
{
  uint8 cnt = MAX_E_DCH_MAC_D_FLOW;
  /* An index with the same EDCH Mac-d FLOW ID is NOT in use.
  * Allocate a new index */
  for (cnt =0; cnt < MAX_E_DCH_MAC_D_FLOW; cnt++)
  {
    if (ordered_config_ptr->mac_e_config.e_mac_d_flow_info[cnt].e_mac_d_flow_id == INVALID_DFLOW_ID)
    {
      WRRC_MSG1_MED("RRCEUL:Assign Index %d for new EDCH Mac-D flow", cnt);    
      break;
    }
  }
  return cnt;
}

/*====================================================================
FUNCTION: rrcllc_fill_holes_in_e_mac_d_flow_idx()

DESCRIPTION:
  This function deletes any holes in the MAC edch mac-d flow structure.

DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_fill_holes_in_e_mac_d_flow_idx
(
  void
)
{
  uint8  ix, iy;

  if (ordered_config_ptr->mac_e_config.num_e_mac_d_flow == 0)
  {
    WRRC_MSG0_MED("RRCEUL:Num EDCH MAC-d flow is 0");
    return;
  }

  /* Put all the values in tmp structure. No there are no holes in tmp structure */
  for(ix = MAX_E_DCH_MAC_D_FLOW; ix > 0; ix--)
  {
    /* Check if valid data */
    if(ordered_config_ptr->mac_e_config.e_mac_d_flow_info[ix-1].e_mac_d_flow_id != INVALID_DFLOW_ID)
    {
      for(iy = 0; iy < (ix - 1); iy++)
      {
        /* Check if valid data */
        if(ordered_config_ptr->mac_e_config.e_mac_d_flow_info[iy].e_mac_d_flow_id == INVALID_DFLOW_ID)
        {
          WCDMA_MEMCPY(&ordered_config_ptr->mac_e_config.e_mac_d_flow_info[iy], 
                       sizeof(ordered_config_ptr->mac_e_config.e_mac_d_flow_info[iy]),
                       &ordered_config_ptr->mac_e_config.e_mac_d_flow_info[ix-1], 
                       sizeof(ordered_config_ptr->mac_e_config.e_mac_d_flow_info[iy]));
          ordered_config_ptr->mac_e_config.e_mac_d_flow_info[ix-1].e_mac_d_flow_id = INVALID_DFLOW_ID;
          /*Set num_logch for this index as Zero*/
          ordered_config_ptr->mac_e_config.e_mac_d_flow_info[ix-1].num_logch = 0;
          break;
        }
      }
      if (iy == (ix-1)) 
      {
        break;
      }
    }
  }
}
/*====================================================================
FUNCTION: rrcllc_get_e_dch_log_chan_mode()

DESCRIPTION:
  This function gets a the log_chan_mode for the rb id specified

DEPENDENCIES:
  None.

RETURN VALUE:
  Index value if successful else
  UE_MAX_MAC_D_FLOW if no index is available

SIDE EFFECTS:

====================================================================*/
uecomdef_logch_mode_e_type rrcllc_get_e_dch_log_chan_mode(uint32 rb_id)
{
  int ix, iy;
  mac_e_config_s_type *mac_e_config_ptr = &ordered_config_ptr->mac_e_config;
  
#ifdef FEATURE_WCDMA_HS_RACH
  if(TRUE == rrchsrach_get_common_edch_transmission_wof3(ordered_config_ptr))
  {
    mac_e_config_ptr = &ordered_config_ptr->mac_hs_rach_config.hs_rach_config;
  }
#endif

  for(ix = 0; (ix < mac_e_config_ptr->num_e_mac_d_flow); ix++)
    {
    if(mac_e_config_ptr->e_mac_d_flow_info[ix].e_mac_d_flow_id != INVALID_DFLOW_ID)
    {
      for(iy = 0; (iy < mac_e_config_ptr->e_mac_d_flow_info[ix].num_logch); iy++)
      {
        if (mac_e_config_ptr->e_mac_d_flow_info[ix].e_ul_logch_info[iy].rb_id == rb_id) 
        {
          return (mac_e_config_ptr->e_mac_d_flow_info[ix].e_ul_logch_info[iy]).rlc_mode;
        }
      }
    }
  }
  return UE_MODE_MAX_NUM;
}
#ifdef FEATURE_MAC_I
/*====================================================================
FUNCTION: rrcllc_check_edch_fixed_ul_size_configured()

DESCRIPTION:
  This function checks if edch mapping and fixed size is configured
  the rb id specified

DEPENDENCIES:
  None.

RETURN VALUE:
  boolean


SIDE EFFECTS:

====================================================================*/
boolean rrcllc_check_edch_fixed_ul_size_configured
(
  uint32 rb_id
)
{
  int ix, iy;
  mac_e_config_s_type *mac_e_config_ptr = &ordered_config_ptr->mac_e_config;

#ifdef FEATURE_WCDMA_HS_RACH
  if(TRUE == rrchsrach_get_common_edch_transmission_wof3(ordered_config_ptr))
  {
    mac_e_config_ptr = &ordered_config_ptr->mac_hs_rach_config.hs_rach_config;
  }
#endif

  for(ix = 0; (ix < mac_e_config_ptr->num_e_mac_d_flow); ix++)
    {
    if(mac_e_config_ptr->e_mac_d_flow_info[ix].e_mac_d_flow_id != INVALID_DFLOW_ID)
      {
      for(iy = 0; (iy < mac_e_config_ptr->e_mac_d_flow_info[ix].num_logch); iy++)
      {
        if ((mac_e_config_ptr->e_mac_d_flow_info[ix].e_ul_logch_info[iy].rb_id == rb_id) &&
             (mac_e_config_ptr->e_mac_d_flow_info[ix].e_ul_logch_info[iy].rlc_pdu_type == RLC_FIXED_PDU_SIZE))
        {
         WRRC_MSG1_HIGH("MACI UL fixed size configured for RB ID %d",rb_id);	
          return TRUE;				 
        }
      }
    }
  }

  return FALSE;	
}
/*====================================================================
FUNCTION: rrcllc_check_edch_flexible_ul_size_configured()

DESCRIPTION:
  This function checks if edch mapping and flexible size is configured
  the rb id specified

DEPENDENCIES:
  None.

RETURN VALUE:
  boolean

SIDE EFFECTS:

====================================================================*/
boolean rrcllc_check_edch_flexible_ul_size_configured
(
  ordered_config_type *config_ptr,
  uint32 rb_id
)
{
  int ix, iy;
  mac_e_config_s_type *mac_e_config_ptr = &config_ptr->mac_e_config;
  boolean cedch_trans = rrchsrach_get_common_edch_transmission_wof3(config_ptr);

// flexible or fixed size needs to be checked only if edch is active. meaning this is not applicable for non edch cells
#ifdef FEATURE_WCDMA_HS_RACH
  
if((FALSE == cedch_trans)&&( config_ptr->e_dch_transmission == FALSE)
  &&(config_ptr->hspa_rnti_stored_cell_pch == FALSE))
{
   return FALSE;
}

  if((TRUE == cedch_trans)
      || (config_ptr->hspa_rnti_stored_cell_pch == TRUE))
  {
    mac_e_config_ptr = &config_ptr->mac_hs_rach_config.hs_rach_config;
  }
#endif

    for(ix = 0; (ix < mac_e_config_ptr->num_e_mac_d_flow); ix++)
    {
      if(mac_e_config_ptr->e_mac_d_flow_info[ix].e_mac_d_flow_id != INVALID_DFLOW_ID)
      {
        for(iy = 0; (iy < mac_e_config_ptr->e_mac_d_flow_info[ix].num_logch); iy++)
        {
          if ((mac_e_config_ptr->e_mac_d_flow_info[ix].e_ul_logch_info[iy].rb_id == rb_id) &&
              (mac_e_config_ptr->e_mac_d_flow_info[ix].e_ul_logch_info[iy].rlc_pdu_type == RLC_FLEXIBLE_PDU_SIZE))
          {
           WRRC_MSG1_MED("MACI UL flexible size configured for RB ID %d",rb_id);
           return TRUE;				 
          }
        }
      }
    }

  return FALSE;	
}
/*====================================================================
FUNCTION: rrcllc_get_edch_ul_rlc_flexible_params()

DESCRIPTION:
  This function returns the UL RLC parameters configured for 
  flexible size for the specified rb id

DEPENDENCIES:
  None.

RETURN VALUE:
  void

SIDE EFFECTS:

====================================================================*/
void rrcllc_get_edch_ul_rlc_flexible_params
(
  ordered_config_type *config_ptr,
  uint32 rb_id,
  rlc_ul_flexi_size_info_type *rlc_flexi_ul_size
)
{
  int ix, iy;
  mac_e_config_s_type *mac_e_config_ptr = &config_ptr->mac_e_config;

#ifdef FEATURE_WCDMA_HS_RACH
  if((TRUE == rrchsrach_get_common_edch_transmission_wof3(config_ptr))
     ||(config_ptr->hspa_rnti_stored_cell_pch == TRUE))
  {
    mac_e_config_ptr = &config_ptr->mac_hs_rach_config.hs_rach_config;
  }
#endif

  for(ix = 0; (ix < mac_e_config_ptr->num_e_mac_d_flow); ix++)
  {
    if(mac_e_config_ptr->e_mac_d_flow_info[ix].e_mac_d_flow_id != INVALID_DFLOW_ID)
    {
      for(iy = 0; (iy < mac_e_config_ptr->e_mac_d_flow_info[ix].num_logch); iy++)
      {
        if ((mac_e_config_ptr->e_mac_d_flow_info[ix].e_ul_logch_info[iy].rb_id == rb_id) &&
            (mac_e_config_ptr->e_mac_d_flow_info[ix].e_ul_logch_info[iy].rlc_pdu_type == RLC_FLEXIBLE_PDU_SIZE))
        {
          rlc_flexi_ul_size->rrc_ul_flex_min_pdu_size = mac_e_config_ptr->e_mac_d_flow_info[ix].e_ul_logch_info[iy].ul_flex_min_pdu_size;
          rlc_flexi_ul_size->rrc_ul_flex_max_pdu_size = mac_e_config_ptr->e_mac_d_flow_info[ix].e_ul_logch_info[iy].ul_flex_max_pdu_size;
          rlc_flexi_ul_size->rrc_ul_li_size = mac_e_config_ptr->e_mac_d_flow_info[ix].e_ul_logch_info[iy].ul_li_size;
          WRRC_MSG4_MED("MACI UL flexible size configured for RB ID %d,Max size %d Min size %d Li %d",rb_id,rlc_flexi_ul_size->rrc_ul_flex_max_pdu_size,
						rlc_flexi_ul_size->rrc_ul_flex_min_pdu_size,rlc_flexi_ul_size->rrc_ul_li_size);			
          if((mac_e_config_ptr->e_mac_d_flow_info[ix].e_ul_logch_info[iy].ul_flex_min_pdu_size==RRC_UL_INVALID_RLC_SIZE)||
              (mac_e_config_ptr->e_mac_d_flow_info[ix].e_ul_logch_info[iy].ul_flex_max_pdu_size==RRC_UL_INVALID_RLC_SIZE))
          {
            WRRC_MSG1_ERROR("Invalid UL RLC size for RBid:%d",rb_id);
          
          }				
        }
      }
    }
  }

}

#endif /* FEATURE_MAC_I */

/*============================================================================
FUNCTION: rrcllc_reset_mac_and_l1_for_hsdpa()

DESCRIPTION:
  This funtion resets MAC-HS actions. It also resets the hs_req_mask for L1.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
=============================================================================*/
void rrcllc_reset_mac_and_l1_for_hsdpa
(
  void
)
{
  ordered_config_type  *config_ptr;
  if(config_ptr_in_use == ORDERED_CONFIG)
  {
    config_ptr = ordered_config_ptr;
  }
  else
  {
    config_ptr = current_config_ptr;
  }

  WRRC_MSG2_MED("Reset MAC-HS action %d and L1 hs_req_mask %d",config_ptr->mac_dl_parms.mac_hsdpa_action,
    config_ptr->l1_hsdpa_info.hs_req_mask);

  config_ptr->l1_hsdpa_info.hs_req_mask = 0;
  config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_NOOP;
  /*Reset the reset indicator since configuration to MAC is done*/
  config_ptr->mac_dl_parms.mac_hs_reset_indicator = FALSE;

#ifdef FEATURE_WCDMA_HS_FACH
  /*To be on safer side, set HS status in FACH to FALSE here.*/
  WRRC_MSG1_MED("EFACH:ReseteFACH action [previous]= %d",config_ptr->hs_action_in_e_fach);
  rrcllc_set_hs_action_in_e_fach(config_ptr, HSDPA_NOOP);
#endif 

  config_ptr->mac_dl_parms.mac_hs_transition_type = MAC_HS_NO_TRANSITION;

  return;
}
/*====================================================================
FUNCTION: rrcllc_init_hsdpa_mac_info()

DESCRIPTION:
  This function initializes the HSDPA Information in the configuration
  database.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_hsdpa_mac_info(ordered_config_type  *config_ptr)
{
  uint8 idx = 0, idy = 0, idz = 0;

  config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_NOOP;
  config_ptr->mac_dl_parms.num_dflow = 0;
  config_ptr->mac_dl_parms.mac_hs_reset_indicator = FALSE;
  config_ptr->mac_dl_parms.mac_hs_restore_tsns = FALSE;

  for(idx = 0; idx < UE_MAX_MAC_D_FLOW; idx++)
  {
    config_ptr->mac_dflow_info[idx].no_of_queues = 0;
    config_ptr->mac_dflow_info[idx].ndlchan = 0;


    config_ptr->dl_dflow_index_in_use[idx] = FALSE;
    config_ptr->mac_dflow_info[idx].mac_dflow_id = INVALID_DFLOW_ID;

    for(idz = 0; idz < UE_MAX_LOGCHAN_PER_DFLOW; idz++)
    {
      config_ptr->mac_dflow_info[idx].dlchan_info[idz].mac_id = 0;
      config_ptr->mac_dflow_info[idx].dlchan_info[idz].rb_id = 0;
      config_ptr->mac_dflow_info[idx].dlchan_info[idz].rlc_id = 0;
    }


    for(idy = 0; idy < UE_MAX_HS_QUEUE; idy++)
    {
      config_ptr->mac_dflow_info[idx].queue_info[idy].queue_id = INVALID_QUEUE_ID;
      config_ptr->mac_dflow_info[idx].queue_info[idy].no_of_pdu_sizes = 0;
      for(idz = 0; idz < UE_MAX_HS_NO_OF_PDU_SIZE_PER_QUEUE; idz++)
      {
        config_ptr->mac_dflow_info[idx].queue_info[idy].pdu_info[idz].mac_pdu_index = INVALID_PDU_INDEX_ID;
      }
      config_ptr->mac_dflow_info[idx].queue_info[idy].release_timer = 0;
      config_ptr->mac_dflow_info[idx].queue_info[idy].window_size = 0;
    }
  }
}

/*====================================================================
FUNCTION: rrcllc_init_hsdpa_l1_queue()

DESCRIPTION:
  This function initializes the HSDPA Information in the configuration
  database.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_hsdpa_l1_queue
(
  ordered_config_type  *config_ptr
)
{
  uint8 idx = 0, idy = 0;

  for(idx = 0; idx < L1_DL_MAX_LOGICAL_CHANNEL; idx++)
  {
    config_ptr->l1_hsdpa_info.hs_dsch_info.mac_ehs_dlchan_q_info[idx] = INVALID_QUEUE_ID;
  }
  config_ptr->l1_hsdpa_info.hs_dsch_info.macd_info.num_mac_hs_q = 0;

  for(idx = 0; idx < UE_MAX_HS_QUEUE; idx++)
  {
    config_ptr->l1_hsdpa_info.hs_dsch_info.macd_info.mac_hs_q_info[idx].mac_hs_q_id = INVALID_QUEUE_ID;
    config_ptr->l1_hsdpa_info.hs_dsch_info.macd_info.mac_hs_q_info[idx].num_mac_d_pdu_sz = 0;
    for(idy = 0; idy < L1_DL_MACD_PDU_SZ_PER_Q_MAX_COUNT; idy++)
    {
      config_ptr->l1_hsdpa_info.hs_dsch_info.macd_info.mac_hs_q_info[idx].mac_d_pdu_sz_info[idy].pdu_sz = 0;
      config_ptr->l1_hsdpa_info.hs_dsch_info.macd_info.mac_hs_q_info[idx].mac_d_pdu_sz_info[idy].pdu_sz_idx = 0;
    }
  }
}


/*====================================================================
FUNCTION: rrcllc_init_hsdpa_msg_params_struct()

DESCRIPTION:
  This function initializes the HSDPA Message Parameter structure

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_hsdpa_msg_params_struct
(
  void
)
{
  hsdpa_msg_params.msg_params_present = FALSE;
  hsdpa_msg_params.ifhho_involved = FALSE;
  hsdpa_msg_params.hrnti_present = FALSE;
  hsdpa_msg_params.hspdsch_info_present = FALSE;
  hsdpa_msg_params.rl_link_present = FALSE;
  hsdpa_msg_params.hsdsch_info_present = FALSE;
  hsdpa_msg_params.intra_hho_involved = FALSE;
  hsdpa_msg_params.hs_dpcch_info_present = FALSE;

  hsdpa_msg_params.beta_table_present = FALSE;
  hsdpa_msg_params.hrnti_changed = FALSE;
  hsdpa_msg_params.mac_hs_restore_tsns = FALSE;


}


/*====================================================================
FUNCTION: rrcllc_init_hsdpa_info_before_msg_processing()

DESCRIPTION:
  This function initializes the HSDPA Action in MAC structure, forces
  the MAC Reset variable to FALSE. Also, makes sure that the HSDPA
  Action variable is set to NOOP and also initializes the HSDPA
  message param structure and rlc size per rb structure

DEPENDENCIES:
  Function is only called before processing the DL OTA Msg.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_hsdpa_info_before_msg_processing
(
  void
)
{
  uint8 cnt = 0;

  /* Initialize HSDPA action forcibly to NOOP */
  rrc_set_hsdpa_action(HSDPA_NOOP);
  rrcllc_init_hsdpa_msg_params_struct();
  rrc_initialize_rlc_size_per_rb();

  cm_status_from_ota_msg = RRC_CM_NONE;

  /* Set MAC Action variable to NOOP */
  ordered_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_NOOP;

  ordered_config_ptr->mac_dl_parms.mac_hs_transition_type = MAC_HS_NO_TRANSITION;
  
  ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator = FALSE;
  if (hsdpa_cm_enabled == FALSE)
  {
    /* Check if CM is not ACTIVE and TGPSI is set to active, then make it inactive */
    if ( l1_cm_query_compressed_mode_active() == FALSE)
    {
      WRRC_MSG0_HIGH("RRCHS:CM not Active");

      for (cnt =0; cnt < ordered_config_ptr->cm_info.tgp_seq_info_count; cnt++)
      {
        if ((ordered_config_ptr->tgp_seq_info[cnt].tgp_seq_id != 0) &&
           (ordered_config_ptr->tgp_seq_info[cnt].active == TRUE))
        {
          ordered_config_ptr->tgp_seq_info[cnt].active = FALSE;
          WRRC_MSG1_HIGH("RRCHS:Make TGPSI %d, INACTIVE", 
            ordered_config_ptr->tgp_seq_info[cnt].tgp_seq_id);
          
        }
      }
    }
    else
    {
      WRRC_MSG0_HIGH("RRCHS:CM ACTIVE");
    }
  }

#ifdef FEATURE_WCDMA_HS_FACH
  ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator = FALSE;
  rrcllc_set_hs_action_in_e_fach(ordered_config_ptr, HSDPA_NOOP);
#endif /*FEATURE_WCDMA_HS_FACH*/
  
}


/*====================================================================
FUNCTION: rrcllc_init_hsdpa_l1_info()

DESCRIPTION:
  This function initializes the HSDPA Information in the configuration
  database.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_init_hsdpa_l1_info(ordered_config_type  *config_ptr)
{
  config_ptr->l1_hsdpa_info.hs_req_mask = 0;
  config_ptr->l1_hsdpa_info.hs_dsch_info.mac_hs_or_ehs = MAC_HS_TYPE_INVALID;

  ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hsdsch_tb_size_alignment_type = 
               L1_DL_HS_DSCH_TB_TABLE_OCTET_UNALIGNED;
  if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
  {
    WRRC_MSG0_MED("RRCHS:Init HSDPA L1 Info");
  }
  config_ptr->l1_hsdpa_info.hs_scch_info.num_ch_code = 0;
  config_ptr->l1_hsdpa_info.hs_scch_info.sec_scr_code_valid = FALSE;

  config_ptr->l1_hsdpa_info.hs_dsch_info.harq_info.mem_part_info_valid = FALSE;
  config_ptr->l1_hsdpa_info.hs_dsch_info.harq_info.num_proc = 0;

#ifdef FEATURE_WCDMA_MIMO
  config_ptr->l1_hsdpa_info.hs_dsch_info.harq_info.mimo_additional_mem_part_info_valid = FALSE;
#endif
  config_ptr->l1_hsdpa_info.hs_dsch_info.macd_info.num_mac_hs_q = 0;

  config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc = RRCLLC_INVALID_CPICH_SCR_CODE;

  config_ptr->l1_hsdpa_info.hs_req_mask = 0;

  config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 0;

  config_ptr->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_ack = RRCLLC_DELTA_ACK_MAX + 1;

  config_ptr->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_nack = RRCLLC_DELTA_NACK_MAX + 1;

  config_ptr->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_cqi = RRCLLC_DELTA_CQI_MAX + 1;

  config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.ack_nack_rep_factor = 
        RRCLLC_DELTA_ACK_NACK_REPITITION_FACTOR_MAX +1;

  config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured = FALSE;

  rrcllc_init_hsdpa_l1_queue(config_ptr);
}



/*====================================================================
FUNCTION: rrcllc_init_before_msg_processing()

DESCRIPTION:
  This function initializes global variables which need to be initialized before message
  processing.

DEPENDENCIES:
  Function is only called before processing the DL OTA Msg.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_before_msg_processing (void)
{

  ordered_config_ptr->is_hho = FALSE;
  /*Reset the psc and freq present flag*/
  ordered_config_ptr->dest_freq_present = FALSE;
  ordered_config_ptr->dest_psc_present = FALSE;

  rrcllc_init_tfcs_needed_flags();

  /* Initialize HSDPA parameters */
  rrcllc_init_hsdpa_info_before_msg_processing();

  rrc_initialize_rlc_size_per_rb();

  rrcllc_init_e_dch_info_before_msg_processing(ordered_config_ptr);
#ifdef FEATURE_WCDMA_DC_HSUPA
  rrcllc_init_sec_e_dch_info_before_msg_processing(ordered_config_ptr);
#endif /* FEATURE_WCDMA_DC_HSUPA */

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  rrcdata_misc_info.rrc_delay_restriction_flag = 0; /*Reset the delay restriction flag*/
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/

  /*Intialize the global variable rrc_rb_list_mapped_to_dch */
  rrcllc_init_rb_list_mapped_to_dch();

  rrc_initialize_rlc_size_change();

  rrcllc_init_cpc_dtx_info_before_msg_processing(ordered_config_ptr);

  rrcllc_init_cpc_drx_info_before_msg_processing(ordered_config_ptr);

  if(rrc_ordered_state != RRC_STATE_CELL_DCH)
  {
     /* Initialize the L1 bitmask for the parameters in the "Downlink
      * information for all radio links" IE.  Since the IE is optional,
      * we want to make sure we don't signal L1 erroneously that we have
      * received information when we haven't.
      */
    /* In case of DCH state dont init bitmask, This will mask the existing DCH parameters*/
    WRRC_MSG0_MED("Init dl common opt parm present bit mask"); 
    ordered_config_ptr->l1_dl_chan_parms.dl_common.opt_parm_presence_bitmask = 0;
  }

 /*Initialize the new CM structures before message processing*/
  rrcllc_init_rrc_cm_ota_parms(ordered_config_ptr);

#ifdef FEATURE_WCDMA_DC_HSUPA
 
  ordered_config_ptr->sec_ul_asu = FALSE;
  ordered_config_ptr->sec_eul_is_hho = FALSE;
  
#endif /* FEATURE_WCDMA_DC_HSUPA */
  rrc_predef_po3_not_needed = FALSE;     
  
  rrc_log_inter_freq_hho_started = FALSE;  

}

/*====================================================================
FUNCTION: rrcllc_init_rb_list_mapped_to_dch()

DESCRIPTION:
  This function initializes global variable rrc_rb_list_mapped_to_dch

DEPENDENCIES:
  None
  
RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_rb_list_mapped_to_dch
(
  void
)
{
  uint8 rb_idx=0;
  
  rrc_rb_list_mapped_to_dch.num_of_RBs = 0;
  
  for(rb_idx = 0; rb_idx < MAX_RB; rb_idx++)
  {
    rrc_rb_list_mapped_to_dch.rrc_rb_mapped_to_dch[rb_idx] = RRC_INVALID_RB_ID;
  }
}

#ifdef FEATURE_UMTS_PDCP
/*====================================================================
FUNCTION: rrcllc_print_pdcp_info()

DESCRIPTION:
  This function prints the PDCP information in the ordered config pointer

DEPENDENCIES:
  None.
RETURN VALUE:
  None
SIDE EFFECTS:
  None
====================================================================*/
void rrcllc_print_pdcp_info(ordered_config_type *config_ptr)
{
  uint32 x;

  WRRC_MSG1_MED(" Num RBs with PDCP: %d", config_ptr->pdcp_parms.num_rbs);

  for (x = 0; x < config_ptr->pdcp_parms.num_rbs; x++) 
  {
    MSG_6(MSG_SSID_DIAG, MSG_LEGACY_HIGH,"PDCP RB_ID:%d, in use: %d, info_changed %d PDCP action:%d, rb_id: %d, srns_reloc %d",
    config_ptr->pdcp_parms.pdcp_config_req[x].rb_id,
    config_ptr->pdcp_parms.pdcp_config_req[x].in_use,
    config_ptr->pdcp_parms.pdcp_config_req[x].pdcp_info_changed,
             config_ptr->pdcp_parms.pdcp_config_req[x].pdcp_cfg_req.action,
             config_ptr->pdcp_parms.pdcp_config_req[x].pdcp_cfg_req.rb_id,
             config_ptr->pdcp_parms.pdcp_config_req[x].pdcp_cfg_req.srns_reloc_flag);
  }
}
#endif /* FEATURE_UMTS_PDCP*/

/*====================================================================
FUNCTION: rrcllc_print_mac_info()

DESCRIPTION:
  This function prints the MAC information in the ordered config pointer

DEPENDENCIES:
  None.
RETURN VALUE:
  None
SIDE EFFECTS:
  None
====================================================================*/
void rrcllc_print_mac_info(ordered_config_type *config_ptr)
{
  int ix,iy;

  WRRC_MSG1_HIGH("MAC DL nbch:%d", config_ptr->mac_dl_parms.num_bchs);
  for(ix = 0; ix < config_ptr->mac_dl_parms.num_bchs; ix++)
  {
    WRRC_MSG2_HIGH("MAC BCH bcch_id:%d,cctrch_id:%d",
              config_ptr->mac_dl_parms.bch_info[ix].bcch_id,
              config_ptr->mac_dl_parms.bch_info[ix].cctrch_id);
  }

  WRRC_MSG1_HIGH("MAC DL npch:%d", config_ptr->mac_dl_parms.num_pchs);
  for(ix = 0; ix < config_ptr->mac_dl_parms.num_pchs; ix++)
  {
    WRRC_MSG2_HIGH("MAC PCH pcch_id:%d,cctrch_id:%d",
              config_ptr->mac_dl_parms.pch_info[ix].pcch_id,
              config_ptr->mac_dl_parms.pch_info[ix].cctrch_id);
  }
  WRRC_MSG1_HIGH("MAC DL nfach:%d", config_ptr->mac_dl_parms.num_fachs);
  for(ix = 0; ix < config_ptr->mac_dl_parms.num_fachs; ix++)
  {
    MSG_5(MSG_SSID_DIAG, MSG_LEGACY_HIGH,"MAC FACH bcch_en:%d,bcch_id:%d ccch_en:%d,ccch_id:%d,ndlchan:%d",
              config_ptr->mac_dl_parms.fach_info[ix]->bcch_enable,
              config_ptr->mac_dl_parms.fach_info[ix]->bcch_id,
              config_ptr->mac_dl_parms.fach_info[ix]->ccch_enable,
              config_ptr->mac_dl_parms.fach_info[ix]->ccch_id,
              config_ptr->mac_dl_parms.fach_info[ix]->ndlchan);
    for (iy=0; iy<config_ptr->mac_dl_parms.fach_info[ix]->ndlchan; iy++)
    {
      MSG_HIGH("FACH dlchan mac_id:%d,rb_id:%d,rlc_id:%d",
                config_ptr->mac_dl_parms.fach_info[ix]->dlchan_info[iy].mac_id,
                config_ptr->mac_dl_parms.fach_info[ix]->dlchan_info[iy].rb_id,
                config_ptr->mac_dl_parms.fach_info[ix]->dlchan_info[iy].rlc_id
                );
    }
  }

  WRRC_MSG1_HIGH("MAC DL ndch:%d", config_ptr->mac_dl_parms.num_dchs);
  for(ix = 0; ix < config_ptr->mac_dl_parms.num_dchs; ix++)
  {
    MSG_HIGH("MAC DCH trch_id:%d,cctrch_id:%d,ndlchan:%d",
              config_ptr->mac_dl_parms.dch_info[ix]->trch_id,
              config_ptr->mac_dl_parms.dch_info[ix]->cctrch_id,
              config_ptr->mac_dl_parms.dch_info[ix]->ndlchan
              );
    for (iy=0; iy<config_ptr->mac_dl_parms.dch_info[ix]->ndlchan; iy++)
    {
      MSG_HIGH("DCH dlchan mac_id:%d,rb_id:%d,rlc_id:%d",
                config_ptr->mac_dl_parms.dch_info[ix]->dlchan_info[iy].mac_id,
                config_ptr->mac_dl_parms.dch_info[ix]->dlchan_info[iy].rb_id,
                config_ptr->mac_dl_parms.dch_info[ix]->dlchan_info[iy].rlc_id
                );
    }
  }
  if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
  {
    WRRC_MSG1_HIGH("RRCHS:Num HS-DSCH:%d", config_ptr->mac_dl_parms.num_dflow);

    for(ix = 0; ix < config_ptr->mac_dl_parms.num_dflow; ix++)
    {
      MSG_HIGH("Dflow Id:%d,cctrch_id:%d,ndlchan:%d",
               config_ptr->mac_dl_parms.hsdpa_info[ix]->mac_dflow_id,
               config_ptr->mac_dl_parms.hsdpa_info[ix]->cctrch_id,
               config_ptr->mac_dl_parms.hsdpa_info[ix]->ndlchan
               );
      for (iy=0; iy<config_ptr->mac_dl_parms.hsdpa_info[ix]->ndlchan; iy++)
      {
        MSG_HIGH("MAC Id:%d,rb_id:%d,rlc_id:%d",
                 config_ptr->mac_dl_parms.hsdpa_info[ix]->dlchan_info[iy].mac_id,
                 config_ptr->mac_dl_parms.hsdpa_info[ix]->dlchan_info[iy].rb_id,
                 config_ptr->mac_dl_parms.hsdpa_info[ix]->dlchan_info[iy].rlc_id
                 );
      }
    }
  }
  MSG_9(MSG_SSID_DIAG, MSG_LEGACY_HIGH,"MAC RNTI info type:%d crnti:0x%x,urnti:0x%x UL cctrch_type:%d, cfg_chg:%d, wf1sig:%d RACH ccch_en:%d,ccch_id:%d,trch_id:%d",
            config_ptr->mac_dl_parms.rnti_info.rnti_valid,
            config_ptr->mac_dl_parms.rnti_info.crnti,
            config_ptr->mac_dl_parms.rnti_info.urnti,
           config_ptr->mac_ul_parms.cctrch_ptr->cctrch_type,
           config_ptr->mac_ul_parms.mac_config_changed,
            config_ptr->mac_ul_parms.wait_for_l1_sig,
            config_ptr->mac_ul_parms.cctrch_ptr->rach_info.ccch_enable,
            config_ptr->mac_ul_parms.cctrch_ptr->rach_info.ccch_id,
            config_ptr->mac_ul_parms.cctrch_ptr->rach_info.trch_id
            );
  MSG_HIGH("MAC RACH ccch_asc:%d,ndlchan:%d",
            config_ptr->mac_ul_parms.cctrch_ptr->rach_info.ccch_asc,
            config_ptr->mac_ul_parms.cctrch_ptr->rach_info.ndlchan,
            0
            );
  for(ix = 0; ix < config_ptr->mac_ul_parms.cctrch_ptr->rach_info.ndlchan; ix++)
  {
    MSG_8(MSG_SSID_DIAG, MSG_LEGACY_HIGH,"RACH ndlch rb_id:%d,rlc_id:%d,rlc_mode:%d mac_id:%d,pri:%d,ch_type:%d all_tfi_valid:%d,n_tfi:%d",
            config_ptr->mac_ul_parms.cctrch_ptr->rach_info.dlchan_info[ix].rb_id,
            config_ptr->mac_ul_parms.cctrch_ptr->rach_info.dlchan_info[ix].rlc_id,
            config_ptr->mac_ul_parms.cctrch_ptr->rach_info.dlchan_info[ix].rlc_mode,
            config_ptr->mac_ul_parms.cctrch_ptr->rach_info.dlchan_info[ix].mac_id,
            config_ptr->mac_ul_parms.cctrch_ptr->rach_info.dlchan_info[ix].priority,
            config_ptr->mac_ul_parms.cctrch_ptr->rach_info.dlchan_info[ix].chan_type,
            config_ptr->mac_ul_parms.cctrch_ptr->rach_info.dlchan_info[ix].rlc_size_info.all_tfi_valid,
            config_ptr->mac_ul_parms.cctrch_ptr->rach_info.dlchan_info[ix].rlc_size_info.ntfi_per_lc
            );
    MSG_HIGH(" RACH dlchan tfi0:%d,tfi1:%d,tfi2:%d",
             config_ptr->mac_ul_parms.cctrch_ptr->rach_info.dlchan_info[ix].rlc_size_info.lc_tfi_list[0],
             config_ptr->mac_ul_parms.cctrch_ptr->rach_info.dlchan_info[ix].rlc_size_info.lc_tfi_list[1],
             config_ptr->mac_ul_parms.cctrch_ptr->rach_info.dlchan_info[ix].rlc_size_info.lc_tfi_list[2]
            );
  }
  /* mac dch info */
  WRRC_MSG1_HIGH("MAC DCH ndchs:%d",
            config_ptr->mac_ul_parms.cctrch_ptr->dch_info.ndchs
            );

  for(ix=0; ix<config_ptr->mac_ul_parms.cctrch_ptr->dch_info.ndchs; ix++)
  {
    MSG_HIGH("RACH ndlch rb_id:%d,rlc_id:%d,rlc_mode:%d",
            config_ptr->mac_ul_parms.cctrch_ptr->dch_info.dch_info[ix].cctrch_id,
            config_ptr->mac_ul_parms.cctrch_ptr->dch_info.dch_info[ix].trch_id,
            config_ptr->mac_ul_parms.cctrch_ptr->dch_info.dch_info[ix].ndlchan
            );

    for (iy=0; iy<config_ptr->mac_ul_parms.cctrch_ptr->dch_info.dch_info[ix].ndlchan; iy++)
    {
      MSG_8(MSG_SSID_DIAG, MSG_LEGACY_HIGH,"UL DCH dlchan chan_type:%d,mac_id:%d,pri:%d rb_id:%d,rlc_id:%d,rlc_mode:%d all_tfi_val:%d,ntfi:%d ",
                config_ptr->mac_ul_parms.cctrch_ptr->dch_info.dch_info[ix].dlchan_info[iy].chan_type,
                config_ptr->mac_ul_parms.cctrch_ptr->dch_info.dch_info[ix].dlchan_info[iy].mac_id,
                config_ptr->mac_ul_parms.cctrch_ptr->dch_info.dch_info[ix].dlchan_info[iy].priority,
                config_ptr->mac_ul_parms.cctrch_ptr->dch_info.dch_info[ix].dlchan_info[iy].rb_id,
                config_ptr->mac_ul_parms.cctrch_ptr->dch_info.dch_info[ix].dlchan_info[iy].rlc_id,
                config_ptr->mac_ul_parms.cctrch_ptr->dch_info.dch_info[ix].dlchan_info[iy].rlc_mode,
                config_ptr->mac_ul_parms.cctrch_ptr->dch_info.dch_info[ix].dlchan_info[iy].rlc_size_info.all_tfi_valid,
                config_ptr->mac_ul_parms.cctrch_ptr->dch_info.dch_info[ix].dlchan_info[iy].rlc_size_info.ntfi_per_lc
              );
      MSG_HIGH(" UL DCH dlchan tfi0:%d,tfi1:%d,tfi2:%d",
               config_ptr->mac_ul_parms.cctrch_ptr->dch_info.dch_info[ix].dlchan_info[iy].rlc_size_info.lc_tfi_list[0],
               config_ptr->mac_ul_parms.cctrch_ptr->dch_info.dch_info[ix].dlchan_info[iy].rlc_size_info.lc_tfi_list[1],
               config_ptr->mac_ul_parms.cctrch_ptr->dch_info.dch_info[ix].dlchan_info[iy].rlc_size_info.lc_tfi_list[2]
              );
    }
  }

}
/*====================================================================
FUNCTION: rrcllc_print_l1_info()
DESCRIPTION:
  This function prints the L1 information in the ordered config pointer
DEPENDENCIES:
  None.
RETURN VALUE:
  None
SIDE EFFECTS:
  None
====================================================================*/
void rrcllc_print_l1_info(ordered_config_type *config_ptr)
{
 int ix, iy;
  MSG_HIGH("L1UL CCTRCH  chan:%d,ntrch:%d,ntfci:%d",
           config_ptr->l1_ul_cctrch_parms.chan,
           config_ptr->l1_ul_cctrch_parms.num_trch,
           config_ptr->l1_ul_cctrch_parms.num_tfci
           );
  for (ix=0;ix<config_ptr->l1_ul_cctrch_parms.num_trch; ix++)
  {
    MSG_HIGH("Semist info  chan:%d,ntrch:%d,ntfci:%d",
             config_ptr->l1_ul_cctrch_parms.semi_static_parms_ptr[ix]->coding,
             config_ptr->l1_ul_cctrch_parms.semi_static_parms_ptr[ix]->trch_id,
             config_ptr->l1_ul_cctrch_parms.semi_static_parms_ptr[ix]->tti
             );
  }
  MSG_9(MSG_SSID_DIAG, MSG_LEGACY_HIGH,"L1 UL DPCH fbi_len:%d,punct_lim:%d,psc:%d sf_min:%d,tfci_pr:%d,ndpdch:%d dpcch_pwr_offset:%d,pcp_len:%d,srb_delay:%d",
           config_ptr->l1_ul_chan_parms.dpch_cfg.fbi_len,
           config_ptr->l1_ul_chan_parms.dpch_cfg.punct_lim,
           config_ptr->l1_ul_chan_parms.dpch_cfg.scrambling_code,
           config_ptr->l1_ul_chan_parms.dpch_cfg.sf_min,
           config_ptr->l1_ul_chan_parms.dpch_cfg.tfci_present,
           config_ptr->l1_ul_chan_parms.dpch_cfg.num_dpdch,
           config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.dpcch_pwr_offset,
           config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.pcp_len,
           config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.srb_delay
          );
  MSG_8(MSG_SSID_DIAG, MSG_LEGACY_HIGH,"L1 PRACH sig_mask:0x%x,sub_ch:0x%x,punct_lim:%d max_pramb_tx:%d,pwr_off:%d num_asc:%d,sc_num:%d,sf_min:%d",
           config_ptr->l1_ul_chan_parms.prach_cfg.avail_sig_mask,
           config_ptr->l1_ul_chan_parms.prach_cfg.avail_sub_chan_mask,
           config_ptr->l1_ul_chan_parms.prach_cfg.punct_lim,
           config_ptr->l1_ul_chan_parms.prach_cfg.max_preamble_tx,
           config_ptr->l1_ul_chan_parms.prach_cfg.pwr_offset_P0,
           config_ptr->l1_ul_chan_parms.prach_cfg.asc_cfg.num_asc,
           config_ptr->l1_ul_chan_parms.prach_cfg.sc_num,
           config_ptr->l1_ul_chan_parms.prach_cfg.sf_min
          );
  /*downlink L1 parms */
  MSG_HIGH("L1DL CCTRCH  cctrch_id:%d,ntrch:%d,trchbf:0x%x",
           config_ptr->l1_dl_cctrch_parms.cctrch_id,
           config_ptr->l1_dl_cctrch_parms.num_trch,
           (config_ptr->l1_dl_cctrch_parms.trch_enable_bf|
           config_ptr->l1_dl_cctrch_parms.trch_ref_type_bf)
           );
  for (ix=0; ix<config_ptr->l1_dl_cctrch_parms.num_trch; ix++)
  {
    MSG_6(MSG_SSID_DIAG, MSG_LEGACY_HIGH,"L1DL CCTRCH blerqval:%d,coding:%d,crc:%d ntf:%d,trchid:%d,tti:%d ",
             config_ptr->l1_dl_cctrch_parms.trch_info_array[ix]->bler_quality_val,
             config_ptr->l1_dl_cctrch_parms.trch_info_array[ix]->coding_type,
             config_ptr->l1_dl_cctrch_parms.trch_info_array[ix]->crc_length,
             config_ptr->l1_dl_cctrch_parms.trch_info_array[ix]->num_tf,
             config_ptr->l1_dl_cctrch_parms.trch_info_array[ix]->trch_id,
             config_ptr->l1_dl_cctrch_parms.trch_info_array[ix]->tti_value
             );
    for (iy=0; iy<config_ptr->l1_dl_cctrch_parms.trch_info_array[ix]->num_tf; iy++)
    {
      MSG_HIGH("L1DL CCTRCH allowed:%d,num_tb:%d,tb_size:%d",
               config_ptr->l1_dl_cctrch_parms.trch_info_array[ix]->tf_info_array[iy]->allowed,
               config_ptr->l1_dl_cctrch_parms.trch_info_array[ix]->tf_info_array[iy]->num_tb,
               config_ptr->l1_dl_cctrch_parms.trch_info_array[ix]->tf_info_array[iy]->tb_size
               );
    }

  }
  for (ix=0; ix<MAX_SCCPCH; ix++)
  {
    MSG_9(MSG_SSID_DIAG, MSG_LEGACY_HIGH,"L1 SCCPCH code_num:%d,pilot_exists:%d,tfci_exists:%d,scpich code:%d,scpich_ssc:%d,ssc:%d sf:%d,use_pcpich:%d,timing_off:%d",
             config_ptr->l1_dl_chan_parms.sccpch[ix].code_num,
             config_ptr->l1_dl_chan_parms.sccpch[ix].pilot_exists,
             config_ptr->l1_dl_chan_parms.sccpch[ix].tfci_exists,
             config_ptr->l1_dl_chan_parms.sccpch[ix].sec_cpich_ch_code,
             config_ptr->l1_dl_chan_parms.sccpch[ix].sec_cpich_sec_scr_code,
             config_ptr->l1_dl_chan_parms.sccpch[ix].sec_scr_code,
             config_ptr->l1_dl_chan_parms.sccpch[ix].sf,
             config_ptr->l1_dl_chan_parms.sccpch[ix].use_pri_cpich,
             config_ptr->l1_dl_chan_parms.sccpch[ix].timing_offset
            );
  }
  MSG_9(MSG_SSID_DIAG, MSG_LEGACY_HIGH,"L1 PICH ch_code:%d,imsi_dev_8192:%d,pi_per_frame:%d PCCPCH psc:%d,sttd:%d,use_pich:%d AICH ovsf:%d,pwr_off:%d,tt:%d  ",
           config_ptr->l1_dl_chan_parms.pich.ch_code,
           config_ptr->l1_dl_chan_parms.pich.imsi_div_8192,
           config_ptr->l1_dl_chan_parms.pich.pi_per_frame,
           config_ptr->l1_dl_chan_parms.pccpch.scr_code,
           config_ptr->l1_dl_chan_parms.pccpch.tx_div_ind,
           config_ptr->l1_dl_chan_parms.use_pich,
           config_ptr->l1_dl_chan_parms.aich.ovsf,
           config_ptr->l1_dl_chan_parms.aich.pwr_offset,
           config_ptr->l1_dl_chan_parms.aich.tt
          );
  MSG_8(MSG_SSID_DIAG, MSG_LEGACY_HIGH,"L1 DL_COMMON COMP act:%d, tgp_seq_ct:%d doff:%d, dpc_info:%d,pilot_b:%d po3:%d,sf:%d,tgt_frameoff:%d",
           config_ptr->l1_dl_chan_parms.dl_common.comp_mode_info->action_needed,
           config_ptr->l1_dl_chan_parms.dl_common.comp_mode_info->tgp_seq_info_count,
           config_ptr->l1_dl_chan_parms.dl_common.default_dpch_offset,
           config_ptr->l1_dl_chan_parms.dl_common.dpch_common.dpc_info,
           config_ptr->l1_dl_chan_parms.dl_common.dpch_common.num_pilot_bits,
           config_ptr->l1_dl_chan_parms.dl_common.dpch_common.po3,
           config_ptr->l1_dl_chan_parms.dl_common.dpch_common.sf,
           config_ptr->l1_dl_chan_parms.dl_common.dpch_common.targ_frame_offset
          );
  for (ix=0; ix<L1_MAX_RL; ix++)
  {
    MSG_HIGH("L1 DL_PER_RL chan_code:%d,frame_off:%d,tpc_idx:%d",
             config_ptr->l1_dl_chan_parms.dl_per_rl[ix].dpch_per_rl.dl_chan_code,
             config_ptr->l1_dl_chan_parms.dl_per_rl[ix].dpch_per_rl.frame_offset,
             config_ptr->l1_dl_chan_parms.dl_per_rl[ix].dpch_per_rl.tpc_idx
            );
  }

}

/*====================================================================
FUNCTION: rrcllc_set_utran_drx_info()

DESCRIPTION:
  This function sets the utran_drx_coef in to ordered_config
  data structure. This api is used when a procedure does not have
  to set ordered_config but needs to configure it with utran_drx_info

DEPENDENCIES:
  None.

RETURN VALUE:
  void

SIDE EFFECTS:
====================================================================*/
void rrcllc_set_utran_drx_info( uint32 utran_drx_coef )
{
  if(config_ptr_in_use == ORDERED_CONFIG)
  {
    ordered_config_ptr->utran_drx_cycle_length =
      (1 << utran_drx_coef);
    WRRC_MSG1_HIGH("drx cycle set in OC %d",ordered_config_ptr->utran_drx_cycle_length);
    current_config_ptr->utran_drx_cycle_length =
      (1 << utran_drx_coef);
  }
  else
  {
    current_config_ptr->utran_drx_cycle_length =
      (1 << utran_drx_coef);
    ordered_config_ptr->utran_drx_cycle_length =
      (1 << utran_drx_coef);
    WRRC_MSG1_HIGH("drx cycle set in CC %d",current_config_ptr->utran_drx_cycle_length);
  }

} /* end rrcllc_set_utran_drx_info() */


/*====================================================================
FUNCTION: rrcllc_update_sib1_data()

DESCRIPTION:
  This function reads SIB1 for the Current Serving Cell and updates
  both Current and Ordered Config databases with DRX cycle values
  for all available CN domains.
  If a domain is not present (CS or PS), the DRX cycle length for
  that domain is initialized to the one for the other domain to
  prevent any wrong calculations elsewhere.

DEPENDENCIES:
  The caller of this function has to make sure Cell Reselection is
  not in progress when this is called. Otherwise it may lead to
  storing DRX values of the old cell.

RETURN VALUE:
  Success/Failure to update.

SIDE EFFECTS:
  Look under dependency.
====================================================================*/
uecomdef_status_e_type  rrcllc_update_sib1_data(void)
{
  rrc_SysInfoType1    *sib1_ptr = NULL;

  /* Pointer & counter to loop through the CN System Information List */
  rrc_CN_DomainSysInfoList * cn_ptr = NULL;
  uint32     cn_cnt  = 0;
  uint32     ps_drx_cycle_length  = 0;
  uint32 cs_drx_cycle_length =0;


  /* Get an index to SIB1 */
  sib1_ptr = (rrc_SysInfoType1 *)
               rrc_sibdb_return_sib_for_srv_cell(rrc_SIB1);
  if (sib1_ptr == NULL)
  {
     WRRC_MSG0_ERROR("SIB 1 not yet in SIB data base");
     return FAILURE;
  }

  /* Get the CS and PS DRX Cycle Lengths */
  cn_ptr = &sib1_ptr->cn_DomainSysInfoList;
 
  while((cn_cnt < cn_ptr->n) && (cn_cnt < UE_MAX_CN_DOMAINS))
  {
    if((cn_ptr->elem[cn_cnt].cn_DRX_CycleLengthCoeff >= RRCLLC_CN_DOMAIN_MIN_DRX_CYCLE_LENGTH) &&
       (cn_ptr->elem[cn_cnt].cn_DRX_CycleLengthCoeff <= RRCLLC_CN_DOMAIN_MAX_DRX_CYCLE_LENGTH))
    {
      switch(cn_ptr->elem[cn_cnt].cn_DomainIdentity)
      {
        case rrc_CN_DomainIdentity_cs_domain:
          cs_drx_cycle_length =
            (uint32) (1 << cn_ptr->elem[cn_cnt].cn_DRX_CycleLengthCoeff);
          break;
        case rrc_CN_DomainIdentity_ps_domain:
          ps_drx_cycle_length =
            (uint32) (1 << cn_ptr->elem[cn_cnt].cn_DRX_CycleLengthCoeff);
          break;
        default:
          WRRC_MSG1_ERROR("Invalid CN 0x%x for DRX", cn_ptr->elem[cn_cnt].cn_DomainIdentity);
          return FAILURE;
      } /* end CN Identity switch */
    } /* end drx cycle length check */
    else
    {
      /* A SIB with invalid DRX length coefficient is unacceptable */
      WRRC_MSG2_ERROR("Invalid DRX len value %d, CN domain %d",
          cn_ptr->elem[cn_cnt].cn_DRX_CycleLengthCoeff, cn_cnt);
      return FAILURE;
    }
    /* Next CN Info */
    cn_cnt++;
  } /* end while Core Network Info */

  /*
   * Check to make sure both Core Networks have good DRX info
   * Will always get CS DRX info, may not get PS. If no PS info, copy
   * the CS DRX into the PS DRX info.
  */
  if(ps_drx_cycle_length == 0)
  {
    /* This indicates PS domain not present */
    if(cs_drx_cycle_length > 0)
    {
      ps_drx_cycle_length = cs_drx_cycle_length;
    }
    else
    {
      WRRC_MSG0_ERROR("Both PS and CS DRX info missing");
      return FAILURE;
    }
  }

  if(cs_drx_cycle_length == 0)
  {
    /* This indicates CS domain not present */
    if(ps_drx_cycle_length > 0)
    {
      cs_drx_cycle_length = ps_drx_cycle_length;
    }
    else
    {
      WRRC_MSG0_ERROR("Both PS and CS DRX info missing");
      return FAILURE;
    }
  }

  /* Update Ordered and Current Config now */
  current_config_ptr->ps_drx_cycle_length =
  ordered_config_ptr->ps_drx_cycle_length =
    ps_drx_cycle_length;

  current_config_ptr->cs_drx_cycle_length =
  ordered_config_ptr->cs_drx_cycle_length =
    cs_drx_cycle_length;

  return SUCCESS;
} /* rrcllc_update_sib1_data */

/*====================================================================
FUNCTION: rrcllc_get_ul_tm_ccch_rlc_size()

DESCRIPTION:
  This is called when the RLC size for an uplink Transparent Mode
  Channel is required. This is needed by RRC procedures (specifically
  the RRC Connection Establishment procedure) to fill in the missing
  number of bits to fit the given RLC size.

  How this works is the following way:
  * Ordered config processing takes the size of the encoded pdu
  * Ordered config then looks at the RLC sizes for all UL TM Transport
    Formats.
  * Ordered config then returns the Transport Format RLC size of the
    closest (without going under) of the encoded PDU size.

  * For example if the encoded PDU size is 129 bits, and the UL TM
    RLC sizes for all Transport Formats are 128 and 166, this function
    will return the RLC size of the Transport Format which equals 166.

  * If no RLC size is found that can accomidate the given encoded PDU
    size RRCLLC_INVALID_RLC_SIZE.

DEPENDENCIES:
  None.

RETURN VALUE:
  uint32  - The size of the RLC Transparent Mode buffer.

SIDE EFFECTS:
  Note that currently all logical channels mapped to a Transport
  channel must have the same TrBLK size. Therefore, by extracting
  the RLC size of the first Transport Format, this will apply to
  all Transport Formats for all logical channels and types mapped to
  this TrCH.
====================================================================*/
uint32 rrcllc_get_ul_tm_ccch_rlc_size
(
  uint32   pdu_size
)
{
  uint32 rlc_size;
  ordered_config_type  *config_ptr;

  if(config_ptr_in_use == ORDERED_CONFIG)
  {
    /* If Ordered Config is SET and next state is Cell_FACH, look into
     * the Ordered Config. Otherwise look into Current Config.
     */
    config_ptr = ordered_config_ptr;
  }
  else
  {
    config_ptr = current_config_ptr;
  }

  /*If ATF is present, then select it to send UL Data on CCCH */
  if(config_ptr->mac_ul_parms.cctrch_ptr->rach_info.atf_present == TRUE )
  {
    uint16 atf_index = config_ptr->mac_ul_parms.cctrch_ptr->rach_info.atf_ccch_tf_index;
    /*
    * Get the RLC Size and make sure the Uplink PDU will fit in
    * the RLC size Rcv'd in the SIBS.
    */
    WRRC_MSG1_HIGH("ATF:send the SRB0 with TB size in ATF in SIB with size %d",config_ptr->ul_tfcs.tfs_info[0].tf_info[atf_index].tb_size);
    if(config_ptr->ul_tfcs.tfs_info[0].tf_info[atf_index].tb_size <
       RRCLLC_COM_LOG_CHL_RACH_MAC_HDR_SIZE)
    {
      WRRC_MSG1_ERROR("TB Size invalid %d",
            config_ptr->ul_tfcs.tfs_info[0].tf_info[atf_index].tb_size);
      return(RRCLLC_INVALID_RLC_SIZE);
    }

    rlc_size = config_ptr->ul_tfcs.tfs_info[0].tf_info[atf_index].tb_size -
      RRCLLC_COM_LOG_CHL_RACH_MAC_HDR_SIZE;
  }
  else
  {
    /*
    * Get the RLC Size and make sure the Uplink PDU will fit in
    * the RLC size Rcv'd in the SIBS.
    */
    if(config_ptr->ul_tfcs.tfs_info[0].tf_info[0].tb_size <
       RRCLLC_COM_LOG_CHL_RACH_MAC_HDR_SIZE)
    {
      WRRC_MSG1_ERROR("TB Size invalid %d",
            config_ptr->ul_tfcs.tfs_info[0].tf_info[0].tb_size);
      return(RRCLLC_INVALID_RLC_SIZE);
    }

    rlc_size = config_ptr->ul_tfcs.tfs_info[0].tf_info[0].tb_size -
      RRCLLC_COM_LOG_CHL_RACH_MAC_HDR_SIZE;
  }

  /* Uplink PDU cannot fit into a single TrBLK. This is not Good */
  if(pdu_size > rlc_size)
  {
    rlc_size = RRCLLC_INVALID_RLC_SIZE;
  }

  return rlc_size;

} /* end rrcllc_get_ul_tm_ccch_rlc_size() */


/*====================================================================
FUNCTION: rrcllc_calculate_ul_tm_ccch_rlc_size()

DESCRIPTION:
  This is called when the RLC size for an uplink Transparent Mode
  Channel is required. 
  This function returns the rlc size removing the MAC header size from the tansport block size

DEPENDENCIES:
  None.

RETURN VALUE:
  uint32  - The size of the RLC Transparent Mode buffer.

SIDE EFFECTS:
  Note that currently all logical channels mapped to a Transport
  channel must have the same TrBLK size. Therefore, by extracting
  the RLC size of the first Transport Format, this will apply to
  all Transport Formats for all logical channels and types mapped to
  this TrCH.
====================================================================*/
uint32 rrcllc_calculate_ul_tm_ccch_rlc_size
(
  void
)
{
  uint32 rlc_size;
  ordered_config_type  *config_ptr;
  if(config_ptr_in_use == ORDERED_CONFIG)
  {
    config_ptr = ordered_config_ptr;
  }
  else
  {
    config_ptr = current_config_ptr;
  }

  /*If ATF is present, then select it to send UL Data on CCCH */
  if(config_ptr->mac_ul_parms.cctrch_ptr->rach_info.atf_present == TRUE )
  {
    uint16 atf_index = config_ptr->mac_ul_parms.cctrch_ptr->rach_info.atf_ccch_tf_index;
    /*
    * Get the RLC Size and make sure the Uplink PDU will fit in
    * the RLC size Rcv'd in the SIBS.
    */
    WRRC_MSG1_HIGH("ATF:send the SRB0 with TB size in ATF in SIB with size %d",config_ptr->ul_tfcs.tfs_info[0].tf_info[atf_index].tb_size);
    if(config_ptr->ul_tfcs.tfs_info[0].tf_info[atf_index].tb_size <
       RRCLLC_COM_LOG_CHL_RACH_MAC_HDR_SIZE)
    {
      WRRC_MSG1_ERROR("TB Size invalid %d",
            config_ptr->ul_tfcs.tfs_info[0].tf_info[atf_index].tb_size);
      return(RRCLLC_INVALID_RLC_SIZE);
    }

    rlc_size = config_ptr->ul_tfcs.tfs_info[0].tf_info[atf_index].tb_size -
      RRCLLC_COM_LOG_CHL_RACH_MAC_HDR_SIZE;
  }
  else

  {
    if(config_ptr->ul_tfcs.tfs_info[0].tf_info[0].tb_size <
       RRCLLC_COM_LOG_CHL_RACH_MAC_HDR_SIZE)
    {
      WRRC_MSG1_ERROR("TB Size invalid %d",
            config_ptr->ul_tfcs.tfs_info[0].tf_info[0].tb_size);
      return(RRCLLC_INVALID_RLC_SIZE);
    }

#ifdef FEATURE_WCDMA_HS_RACH
      if(rrchsrach_camped_cell_supports_hsrach())
      {
        rlc_size = config_ptr->ul_tfcs.tfs_info[0].tf_info[0].tb_size;
  }
      else
#endif
      {
        rlc_size = config_ptr->ul_tfcs.tfs_info[0].tf_info[0].tb_size - RRCLLC_COM_LOG_CHL_RACH_MAC_HDR_SIZE;
  }

  }
  WRRC_MSG1_HIGH("RRCHSRACH: PDU Size %d", rlc_size);
  return rlc_size;

} 

/*====================================================================
FUNCTION: rrcllc_get_amr_mapping()

DESCRIPTION:
  This function returns takes a pointer to a data structure of type
  rrcllc_amr_mapping_info_type, fills in the RLC LC IDs of the Uplink
  and Downlink AMR Modes (A, B, C), as well as the AMR and SRC modes\
  in use.

DEPENDENCIES:
  None.

RETURN VALUE:
  FAILURE: If either the AMR mode is not understood (based on TFs)
           Or info on Class A and B is not available. For 12.2 and
           10.2 Kbps AMR modes, Class C info is also needed.
  SUCCESS: If info on AMR mode and all classes is available.

SIDE EFFECTS:
  The uplink and downlink TrCH IDs and RLC Sizes are assumed to be
  the same.

  Since the UE only supports Logical Channels mapped to a TrCH
  where all Logical Channels mapped support all Transport Formats,
  and since this is not the case for AMR Modes, there can only be
  1 Logical channel on this TrCH.
====================================================================*/
#ifdef FEATURE_VOC_AMR_WB
uecomdef_status_e_type
rrcllc_get_amr_mapping( rrcllc_amr_mapping_info_type *ptr )
{
  /* local index variables */
  uint8 ix;

  boolean found_1x39_class_a = FALSE;
  boolean found_0_class_a = FALSE;
  boolean found_0_class_b = FALSE;
  boolean found_0_class_c = FALSE;
  
   mvs_mode_type  codec_info;
  /* Local RB ids for AMR Mode Classes */
  rrc_RB_Identity amr_a_rb_id = RRCLLC_INVALID_RB_ID;
  rrc_RB_Identity amr_b_rb_id = RRCLLC_INVALID_RB_ID;
  rrc_RB_Identity amr_c_rb_id = RRCLLC_INVALID_RB_ID;

  /* Indexes of the DCHs for AMR Mode Classes */
  uint8 amr_a_dch_idx = UE_MAX_TRCH;
  uint8 amr_b_dch_idx = UE_MAX_TRCH;
  uint8 amr_c_dch_idx = UE_MAX_TRCH;

  dch_id_mapping dch_mapping[MAX_DCH_VOICE_CHANNEL];
  

  /* Disable SCR(DTX), aka Background Noise suppression */
#ifdef FEATURE_MVS
  ptr->scr_mode = MVS_SCR_DISABLE;
#endif  /* FEATURE_MVS */

  /* Set AMR mode to invalid value */
#ifdef FEATURE_MVS
  ptr->amr_mode = MVS_AMR_MODE_MAX;
#endif  /* FEATURE_MVS */

#ifdef FEATURE_WCDMA_MULTIRATE_AMR

  ptr->amr_mode = MVS_AMR_MODE_0475;

#endif

  WRRC_MSG0_MED("Get AMR Mapping info");
  
  /*
  * Get the RLC Logical Channel IDs for UL, and use
  * RB IDs extracted here to get Logical Channel IDs
  * for DL
  */
  
  ptr->amr_mode=  rrcllc_derive_amr_rate(&codec_info,dch_mapping);
    
  if(codec_info != MVS_MODE_AMR )
  {
    return FAILURE;
  }
  if(dch_mapping[0].transport_channel_index != UE_MAX_TRCH)
  {
    /* update the rlc_id, rb_id for Class A*/
    ptr->ul_amr_a_id = dch_mapping[0].rlc_id;
  
    /* Remember the RB ID for class A  so can easily get the DL AMR channel */
    amr_a_rb_id = dch_mapping[0].rb_id;
  
    /* Remember the DCH idx for class A so we can check for DTX activation later */
    amr_a_dch_idx = dch_mapping[0].transport_channel_index;
  }
  
  if(dch_mapping[1].transport_channel_index != UE_MAX_TRCH)
  {
    /* update the rlc_id, rb_id for Class B*/
    ptr->ul_amr_b_id = dch_mapping[1].rlc_id;
  
    /* Remember the RB ID for class B so can easily get the DL AMR channel */
    amr_b_rb_id = dch_mapping[1].rb_id;
  
    /* Remember the DCH idx for class B  so we can check for DTX activation later */
    amr_b_dch_idx = dch_mapping[1].transport_channel_index;
  }
  if(dch_mapping[2].transport_channel_index != UE_MAX_TRCH)
  {
    /* update the rlc_id for Class C*/
    ptr->ul_amr_c_id = dch_mapping[2].rlc_id;
    
    /* Remember the RB ID for class c  so can easily get the DL AMR channel */
    amr_c_rb_id = dch_mapping[2].rb_id;
    
    /* Remember the DCH idx for class c so we can check for DTX activation later */
    amr_c_dch_idx = dch_mapping[2].transport_channel_index;
  }

  
  /* Check whether to enable DTX (Source Controlled Rate).  DTX should be
     enabled if both of the following conditions are met:

       * There is a TFC that allows a SID frame (i.e. 1x39 for Class A)
       * There is a TFC that allows no data on each of Class A, B, and C

     This check is for Uplink only.
     Note: For UMTS: SCR and DTX are the same.
  */
  if(amr_a_dch_idx < UE_MAX_TRCH)
  {
    for(ix = 0; ix < ordered_config_ptr->ul_tfcs.tfs_info[amr_a_dch_idx].ntf; ix++)
    {
      if(ordered_config_ptr->ul_tfcs.tfs_info[amr_a_dch_idx].tf_info[ix].tb_size ==
         RRCLLC_AMR_MODE_8_CLASS_A_BIT_SIZE &&
         ordered_config_ptr->ul_tfcs.tfs_info[amr_a_dch_idx].tf_info[ix].ntblks ==
         1)
      {
        /* This is a 1x39 TFC */
        found_1x39_class_a = TRUE;
      }
      else if(ordered_config_ptr->ul_tfcs.tfs_info[amr_a_dch_idx].tf_info[ix].tb_size *
              ordered_config_ptr->ul_tfcs.tfs_info[amr_a_dch_idx].tf_info[ix].ntblks
              == 0)
      {
        /* This is a TFC that allows no data */
        found_0_class_a = TRUE;
      }

      if(found_1x39_class_a && found_0_class_a)
      {
        break;
      }
    }
  }

  if(amr_b_dch_idx < UE_MAX_TRCH)
  {
    for(ix = 0; ix < ordered_config_ptr->ul_tfcs.tfs_info[amr_b_dch_idx].ntf; ix++)
    {
      if(ordered_config_ptr->ul_tfcs.tfs_info[amr_b_dch_idx].tf_info[ix].tb_size *
         ordered_config_ptr->ul_tfcs.tfs_info[amr_b_dch_idx].tf_info[ix].ntblks
         == 0)
      {
        /* This is a TFC that allows no data */
        found_0_class_b = TRUE;
        break;
      }
    }
  }

  if(amr_c_dch_idx < UE_MAX_TRCH)
  {
    for(ix = 0; ix < ordered_config_ptr->ul_tfcs.tfs_info[amr_c_dch_idx].ntf; ix++)
    {
      if(ordered_config_ptr->ul_tfcs.tfs_info[amr_c_dch_idx].tf_info[ix].tb_size *
         ordered_config_ptr->ul_tfcs.tfs_info[amr_c_dch_idx].tf_info[ix].ntblks
         == 0)
      {
        /* This is a TFC that allows no data */
        found_0_class_c = TRUE;
        break;
      }
    }
  }

  if(found_1x39_class_a && found_0_class_a && found_0_class_b)
  {
    /* Provisionally switch on DTX.  If we find later that we needed a Class C
       and didn't find one, we'll switch it back off again. */
#ifdef FEATURE_MVS
    ptr->scr_mode = MVS_SCR_ENABLE;
#endif /* FEATURE_MVS */
  }

#ifdef FEATURE_MVS
  if(ptr->amr_mode == MVS_AMR_MODE_MAX)
#endif  /* FEATURE_MVS */
  {
    WRRC_MSG0_ERROR("Unknown AMR mode");
    return(FAILURE);
  }

  /* Check if TrCHs for Class A and B data have been
   * found. For 12.2 and 10.2 AMR modes, also check for
   * channel for Class C data.
   */
  if((amr_a_rb_id == RRCLLC_INVALID_RB_ID) ||
     (amr_b_rb_id == RRCLLC_INVALID_RB_ID))
  {
    WRRC_MSG0_ERROR("Not all UL TrCHs for AMR found");
    return(FAILURE);
  }
  else
  {
#ifdef FEATURE_MVS
    if((ptr->amr_mode == MVS_AMR_MODE_1220) ||
       (ptr->amr_mode == MVS_AMR_MODE_1020))
#endif  /* FEATURE_MVS */
    {
      /* Only 12.2 and 10.2 modes have Class C data */
      if(amr_c_rb_id == RRCLLC_INVALID_RB_ID)
      {
        WRRC_MSG0_ERROR("Not all UL TrCHs for AMR found");
        return(FAILURE);
      }

      if(!found_0_class_c)
      {
        /* If we previously turned on DTX, we need to turn it off now, since
           we didn't find a cooperative Class C TFC. */
#ifdef FEATURE_MVS
        ptr->scr_mode = MVS_SCR_DISABLE;
#endif /* FEATURE_MVS */
      }
    }
  }  /* If Class A and B TrCH have been found */
  WRRC_MSG1_HIGH("SCR mode = %d",ptr->scr_mode);
  
  /* Go through the DL RB Mapping info to get the DL RLC IDs */
  for(ix = 0; ix < ordered_config_ptr->mac_dl_parms.num_dchs; ix++)
  {
    if(ordered_config_ptr->dl_dch_info[ix].dlchan_info[0].rb_id == amr_a_rb_id)
    {
      ptr->dl_amr_a_id = ordered_config_ptr->dl_dch_info[ix].dlchan_info[0].rlc_id;
#ifdef FEATURE_AS_MVS_ENHANCED_AMR_PROCESSING
      ptr->dl_amr_a_trch_id = ordered_config_ptr->dl_dch_info[ix].trch_id;
      ptr->dl_amr_a_cctrch_id = ordered_config_ptr->dl_dch_info[ix].cctrch_id;
#endif /* FEATURE_AS_MVS_ENHANCED_AMR_PROCESSING */
      amr_a_rb_id = RRCLLC_INVALID_RB_ID;
    }
    else if(ordered_config_ptr->dl_dch_info[ix].dlchan_info[0].rb_id == amr_b_rb_id)
    {
      ptr->dl_amr_b_id = ordered_config_ptr->dl_dch_info[ix].dlchan_info[0].rlc_id;
#ifdef FEATURE_AS_MVS_ENHANCED_AMR_PROCESSING
      ptr->dl_amr_b_trch_id = ordered_config_ptr->dl_dch_info[ix].trch_id;
      ptr->dl_amr_b_cctrch_id = ordered_config_ptr->dl_dch_info[ix].cctrch_id;
#endif /* FEATURE_AS_MVS_ENHANCED_AMR_PROCESSING */
      amr_b_rb_id = RRCLLC_INVALID_RB_ID;
    }
    else if(ordered_config_ptr->dl_dch_info[ix].dlchan_info[0].rb_id == amr_c_rb_id)
    {
      ptr->dl_amr_c_id = ordered_config_ptr->dl_dch_info[ix].dlchan_info[0].rlc_id;
#ifdef FEATURE_AS_MVS_ENHANCED_AMR_PROCESSING
      ptr->dl_amr_c_trch_id = ordered_config_ptr->dl_dch_info[ix].trch_id;
      ptr->dl_amr_c_cctrch_id = ordered_config_ptr->dl_dch_info[ix].cctrch_id;
#endif /* FEATURE_AS_MVS_ENHANCED_AMR_PROCESSING */
      amr_c_rb_id = RRCLLC_INVALID_RB_ID;
    }
    /* Break the loop if all Logical Channel IDs have been established */
    if((amr_a_rb_id == RRCLLC_INVALID_RB_ID) &&
       (amr_b_rb_id == RRCLLC_INVALID_RB_ID))
    {
#ifdef FEATURE_MVS
      if((ptr->amr_mode == MVS_AMR_MODE_1220) ||
         (ptr->amr_mode == MVS_AMR_MODE_1020))
#endif  /* FEATURE_MVS */
      {
        /* For 12.2 and 10.2 AMR modes, make sure Class C
         * info has been obtained.
         */
        if(amr_c_rb_id == RRCLLC_INVALID_RB_ID)
        {
          break;
        }
      }  /* AMR mode of 12.2 or 10.2 kbps */
      else /* All other AMR modes do not have Class C data */
      {
        break;
      } /* All other AMR modes that have no Class C bits */
    } /* Info for Class A and B logical channel has been obtained */
  }

  /* Check if TrCHs for Class A and B data have been
   * found. For 12.2 and 10.2 AMR modes, also check for
   * channel for Class C data.
   */
  if((amr_a_rb_id != RRCLLC_INVALID_RB_ID) ||
     (amr_b_rb_id != RRCLLC_INVALID_RB_ID))
  {
    WRRC_MSG0_ERROR("Not all DL TrCHs for AMR found");
    return(FAILURE);
  }
  else
  {
#ifdef FEATURE_MVS
    if((ptr->amr_mode == MVS_AMR_MODE_1220) ||
       (ptr->amr_mode == MVS_AMR_MODE_1020))
#endif  /* FEATURE_MVS */
    {
      /* Only 12.2 and 10.2 modes have Class C data */
      if(amr_c_rb_id != RRCLLC_INVALID_RB_ID)
      {
        WRRC_MSG0_ERROR("Not all DL TrCHs for AMR found");
        return(FAILURE);
      }
    }
  }  /* If Class A and B TrCH have been found */

  rrcllc_derive_dl_amr_mode(ptr);
  WRRC_MSG1_MED("AMR Mode for DL = %d",ptr->dl_amr_mode);

#if defined(FEATURE_AS_MVS_ENHANCED_AMR_PROCESSING)
  rrc_save_rrc_amr_info_for_mvs_callback(ptr);
#endif /*FEATURE_AS_MVS_ENHANCED_AMR_PROCESSING*/  
 
  return(SUCCESS);
}

#else /*FEATURE_VOC_AMR_WB*/
uecomdef_status_e_type
rrcllc_get_amr_mapping( rrcllc_amr_mapping_info_type *ptr )
{
#ifdef FEATURE_MVS
  /* local index variables */
  uint8 ix, iy,iz;

  boolean found_1x39_class_a = FALSE;
  boolean found_0_class_a = FALSE;
  boolean found_0_class_b = FALSE;
  boolean found_0_class_c = FALSE;

  /* Local RB ids for AMR Mode Classes */
  rrc_RB_Identity amr_a_rb_id = RRCLLC_INVALID_RB_ID;
  rrc_RB_Identity amr_b_rb_id = RRCLLC_INVALID_RB_ID;
  rrc_RB_Identity amr_c_rb_id = RRCLLC_INVALID_RB_ID;

  /* Indexes of the DCHs for AMR Mode Classes */
  uint8 amr_a_dch_idx = UE_MAX_TRCH;
  uint8 amr_b_dch_idx = UE_MAX_TRCH;
  uint8 amr_c_dch_idx = UE_MAX_TRCH;

  uint16   tfi;
  wcdma_ul_amr_rate_event_type start_event_log;

  start_event_log.num_rates =0;
  start_event_log.codec_type =RRC_NO_CODEC;/*In valid*/
  for(ix=0;ix< 9; ix++)
  {
    start_event_log.amr_rate[ix] = MAC_AMR_MODE_UNDEF;
  }
  
  /* Disable SCR(DTX), aka Background Noise suppression */
#ifdef FEATURE_MVS
  ptr->scr_mode = MVS_SCR_DISABLE;
#endif  /* FEATURE_MVS */

  /* Set AMR mode to invalid value */
#ifdef FEATURE_MVS
  ptr->amr_mode = MVS_AMR_MODE_MAX;
#endif  /* FEATURE_MVS */

#ifdef FEATURE_WCDMA_MULTIRATE_AMR

  ptr->amr_mode = MVS_AMR_MODE_0475;

#endif

  MSG_MED("Get AMR Mapping info",0,0,0);

  /*
  * Get the RLC Logical Channel IDs for UL, and use
  * RB IDs extracted here to get Logical Channel IDs
  * for DL
  */

  for (ix=0; ix < ordered_config_ptr->ul_tfcs.ntfc; ix++)
  {
    // Check if the TFC is allowed
    if (ordered_config_ptr->ul_tfcs.tfc_info[ix].control_flag == TFC_ALLOWED)
    {
      // Go through the number of transport channels configured
      for (iy=0; iy < ordered_config_ptr->ul_tfcs.nchan; iy++)
      {
        /* Only check for DTCHs, only 1 DTCH per DCH */
        if(ordered_config_ptr->ul_cctrch.dch_info.dch_info[iy].dlchan_info[0].chan_type == UE_LOGCHAN_DTCH)
        {
          // Get the transport format index for TFC "ix" and TFI corresponding to Transoprt channel "iy"
          tfi = ordered_config_ptr->ul_tfcs.tfc_info[ix].tfi[iy];

          // If the number of transport blocks are > 0
          if (ordered_config_ptr->ul_tfcs.tfs_info[iy].tf_info[tfi].ntblks > 0)
          {
            boolean rate_present_in_event = FALSE;
            mvs_amr_mode_type  current_amr_mode = MVS_AMR_MODE_0475;
            // Check the TB_size
            switch (ordered_config_ptr->ul_tfcs.tfs_info[iy].tf_info[tfi].tb_size)
            {
              case WVS_AMR_MODE_122_CLASS_A_BIT_SIZE:
              case WVS_AMR_MODE_102_CLASS_A_BIT_SIZE:
              case WVS_AMR_MODE_795_CLASS_A_BIT_SIZE:
              case WVS_AMR_MODE_740_CLASS_A_BIT_SIZE:
              case WVS_AMR_MODE_670_CLASS_A_BIT_SIZE:
              case WVS_AMR_MODE_590_CLASS_A_BIT_SIZE:
              case WVS_AMR_MODE_515_CLASS_A_BIT_SIZE:
              case WVS_AMR_MODE_475_CLASS_A_BIT_SIZE:
                switch(ordered_config_ptr->ul_tfcs.tfs_info[iy].tf_info[tfi].tb_size)
                {
#ifdef FEATURE_MVS
                case WVS_AMR_MODE_122_CLASS_A_BIT_SIZE:
                  current_amr_mode = MVS_AMR_MODE_1220;
                  #ifndef FEATURE_WCDMA_MULTIRATE_AMR
                  ptr->amr_mode = MVS_AMR_MODE_1220;
                  #else
                  ptr->amr_mode = MVS_AMR_MODE_1220;
                  #endif
                  break;
                case WVS_AMR_MODE_102_CLASS_A_BIT_SIZE:
                  current_amr_mode = MVS_AMR_MODE_1020;
                  #ifndef FEATURE_WCDMA_MULTIRATE_AMR
                  ptr->amr_mode = MVS_AMR_MODE_1020;
                  #else
                  if (ptr->amr_mode < MVS_AMR_MODE_1020 )
                  {
                    ptr->amr_mode = MVS_AMR_MODE_1020;
                  }
                  #endif
                  break;
                case WVS_AMR_MODE_795_CLASS_A_BIT_SIZE:
                  current_amr_mode = MVS_AMR_MODE_0795;
                  #ifndef FEATURE_WCDMA_MULTIRATE_AMR
                  ptr->amr_mode = MVS_AMR_MODE_0795;
                  #else
                  if (ptr->amr_mode < MVS_AMR_MODE_0795 )
                  {
                    ptr->amr_mode = MVS_AMR_MODE_0795;
                  }
                  #endif
                  break;
                case WVS_AMR_MODE_740_CLASS_A_BIT_SIZE:
                  current_amr_mode = MVS_AMR_MODE_0740;
                  #ifndef FEATURE_WCDMA_MULTIRATE_AMR
                  ptr->amr_mode = MVS_AMR_MODE_0740;
                  #else
                  if (ptr->amr_mode < MVS_AMR_MODE_0740 )
                  {
                    ptr->amr_mode = MVS_AMR_MODE_0740;
                  }
                  #endif
                  break;
                case WVS_AMR_MODE_670_CLASS_A_BIT_SIZE:
                  current_amr_mode = MVS_AMR_MODE_0670;
                  #ifndef FEATURE_WCDMA_MULTIRATE_AMR
                  ptr->amr_mode = MVS_AMR_MODE_0670;
                  #else
                  if (ptr->amr_mode < MVS_AMR_MODE_0670 )
                  {
                    ptr->amr_mode = MVS_AMR_MODE_0670;
                  }
                  #endif
                  break;
                case WVS_AMR_MODE_590_CLASS_A_BIT_SIZE:
                  current_amr_mode = MVS_AMR_MODE_0590;
                  #ifndef FEATURE_WCDMA_MULTIRATE_AMR
                  ptr->amr_mode = MVS_AMR_MODE_0590;
                  #else
                  if (ptr->amr_mode < MVS_AMR_MODE_0590 )
                  {
                    ptr->amr_mode = MVS_AMR_MODE_0590;
                  }
                  #endif
                  break;
                case WVS_AMR_MODE_515_CLASS_A_BIT_SIZE:
                  current_amr_mode = MVS_AMR_MODE_0515;
                  #ifndef FEATURE_WCDMA_MULTIRATE_AMR
                  ptr->amr_mode = MVS_AMR_MODE_0515;
                  #else
                  if (ptr->amr_mode < MVS_AMR_MODE_0515 )
                  {
                    ptr->amr_mode = MVS_AMR_MODE_0515;
                  }
                  #endif
                  break;
                case WVS_AMR_MODE_475_CLASS_A_BIT_SIZE:
                  current_amr_mode = MVS_AMR_MODE_0475;
                  #ifndef FEATURE_WCDMA_MULTIRATE_AMR
                  ptr->amr_mode = MVS_AMR_MODE_0475;
                  #endif
                  break;
  #endif  /* FEATURE_MVS */
                default:
                  WRRC_MSG1_ERROR("Invalid AMR mode bit size %d",
                        ordered_config_ptr->ul_tfcs.tfs_info[iy].tf_info[tfi].tb_size);
                  return FAILURE;
                }
                for(iz =0; iz<start_event_log.num_rates;iz++)
                {
                  if(start_event_log.amr_rate[iz] == ((rrc_event_ul_amr_rate_type)current_amr_mode) )
                  {
                    rate_present_in_event = TRUE;
                    break;
                  }
                }
                if(rate_present_in_event == FALSE)
                {
                  start_event_log.amr_rate[ start_event_log.num_rates] =
                      (rrc_event_ul_amr_rate_type) current_amr_mode;
                  start_event_log.num_rates++;
                }
        
                ptr->ul_amr_a_id = ordered_config_ptr->ul_cctrch.dch_info.dch_info[iy].dlchan_info[0].rlc_id;

                /* Remember the RB ID so can easily get the DL AMR channel */
                amr_a_rb_id = ordered_config_ptr->ul_cctrch.dch_info.dch_info[iy].dlchan_info[0].rb_id;

                /* Remember the DCH idx so we can check for DTX activation later */
                amr_a_dch_idx = iy;

                break;

            case WVS_AMR_MODE_122_CLASS_B_BIT_SIZE:
            case WVS_AMR_MODE_102_CLASS_B_BIT_SIZE:
            case WVS_AMR_MODE_795_CLASS_B_BIT_SIZE:
            case WVS_AMR_MODE_740_CLASS_B_BIT_SIZE:
            case WVS_AMR_MODE_670_CLASS_B_BIT_SIZE:
            case WVS_AMR_MODE_590_CLASS_B_BIT_SIZE:
            case WVS_AMR_MODE_515_CLASS_B_BIT_SIZE:
            case WVS_AMR_MODE_475_CLASS_B_BIT_SIZE:
                ptr->ul_amr_b_id = ordered_config_ptr->ul_cctrch.dch_info.dch_info[iy].dlchan_info[0].rlc_id;

                /* Remember the RB ID so can easily get the DL AMR channel */
                amr_b_rb_id = ordered_config_ptr->ul_cctrch.dch_info.dch_info[iy].dlchan_info[0].rb_id;

                /* Remember the DCH idx so we can check for DTX activation later */
                amr_b_dch_idx = iy;


                break;

            case WVS_AMR_MODE_122_CLASS_C_BIT_SIZE:
            case WVS_AMR_MODE_102_CLASS_C_BIT_SIZE:
                ptr->ul_amr_c_id = ordered_config_ptr->ul_cctrch.dch_info.dch_info[iy].dlchan_info[0].rlc_id;

                /* Remember the RB ID so can easily get the DL AMR channel */
                amr_c_rb_id = ordered_config_ptr->ul_cctrch.dch_info.dch_info[iy].dlchan_info[0].rb_id;

                /* Remember the DCH idx so we can check for DTX activation later */
                amr_c_dch_idx = iy;


                break;

            default:
                MSG_LOW("Bad RLC Size %d for AMR",
                          ordered_config_ptr->ul_tfcs.tfs_info[ix].tf_info[iy].tb_size,0,0);

                break;

            }
          }
        }
      }

      /* Exit Inner TF loop */
    /* For AMR mode of 12.2 and 10.2 Kbps, exit TrCH loop when info
     * for Class A, B and C logical channels has been collected */
#ifndef FEATURE_WCDMA_MULTIRATE_AMR
#ifdef FEATURE_MVS
    if(ptr->amr_mode != MVS_AMR_MODE_MAX)
#endif  /* FEATURE_MVS */
    {
      if((amr_a_rb_id != RRCLLC_INVALID_RB_ID) &&
         (amr_b_rb_id != RRCLLC_INVALID_RB_ID))
      {
#ifdef FEATURE_MVS
        if((ptr->amr_mode == MVS_AMR_MODE_1220) ||
           (ptr->amr_mode == MVS_AMR_MODE_1020))
#endif  /* FEATURE_MVS */
        {
          /* For 12.2 and 10.2 AMR modes, make sure Class C
           * info has been obtained.
           */
          if(amr_c_rb_id != RRCLLC_INVALID_RB_ID)
          {
            break;
          }
        }  /* AMR mode of 12.2 or 10.2 kbps */
        else /* All other AMR modes do not have Class C data */
        {
          break;
        } /* All other AMR modes that have no Class C bits */
       }
      }
#endif
    }
  }

  /* Check whether to enable DTX (Source Controlled Rate).  DTX should be
     enabled if both of the following conditions are met:

       * There is a TFC that allows a SID frame (i.e. 1x39 for Class A)
       * There is a TFC that allows no data on each of Class A, B, and C

     This check is for Uplink only.
     Note: For UMTS: SCR and DTX are the same.
  */
  if(amr_a_dch_idx != UE_MAX_TRCH)
  {
    for(ix = 0; ix < ordered_config_ptr->ul_tfcs.tfs_info[amr_a_dch_idx].ntf; ix++)
    {
      if(ordered_config_ptr->ul_tfcs.tfs_info[amr_a_dch_idx].tf_info[ix].tb_size ==
         RRCLLC_AMR_MODE_8_CLASS_A_BIT_SIZE &&
         ordered_config_ptr->ul_tfcs.tfs_info[amr_a_dch_idx].tf_info[ix].ntblks ==
         1)
      {
        /* This is a 1x39 TFC */
        found_1x39_class_a = TRUE;
      }
      else if(ordered_config_ptr->ul_tfcs.tfs_info[amr_a_dch_idx].tf_info[ix].tb_size *
              ordered_config_ptr->ul_tfcs.tfs_info[amr_a_dch_idx].tf_info[ix].ntblks
              == 0)
      {
        /* This is a TFC that allows no data */
        found_0_class_a = TRUE;
      }

      if(found_1x39_class_a && found_0_class_a)
      {
        break;
      }
    }
  }

  if(amr_b_dch_idx != UE_MAX_TRCH)
  {
    for(ix = 0; ix < ordered_config_ptr->ul_tfcs.tfs_info[amr_b_dch_idx].ntf; ix++)
    {
      if(ordered_config_ptr->ul_tfcs.tfs_info[amr_b_dch_idx].tf_info[ix].tb_size *
         ordered_config_ptr->ul_tfcs.tfs_info[amr_b_dch_idx].tf_info[ix].ntblks
         == 0)
      {
        /* This is a TFC that allows no data */
        found_0_class_b = TRUE;
        break;
      }
    }
  }

  if(amr_c_dch_idx != UE_MAX_TRCH)
  {
    for(ix = 0; ix < ordered_config_ptr->ul_tfcs.tfs_info[amr_c_dch_idx].ntf; ix++)
    {
      if(ordered_config_ptr->ul_tfcs.tfs_info[amr_c_dch_idx].tf_info[ix].tb_size *
         ordered_config_ptr->ul_tfcs.tfs_info[amr_c_dch_idx].tf_info[ix].ntblks
         == 0)
      {
        /* This is a TFC that allows no data */
        found_0_class_c = TRUE;
        break;
      }
    }
  }

  if(found_1x39_class_a && found_0_class_a && found_0_class_b)
  {
    /* Provisionally switch on DTX.  If we find later that we needed a Class C
       and didn't find one, we'll switch it back off again. */
#ifdef FEATURE_MVS
    ptr->scr_mode = MVS_SCR_ENABLE;
#endif /* FEATURE_MVS */
  }

#ifdef FEATURE_MVS
  if(ptr->amr_mode == MVS_AMR_MODE_MAX)
#endif  /* FEATURE_MVS */
  {
    WRRC_MSG0_ERROR("Unknown AMR mode");
    return(FAILURE);
  }

  /* Check if TrCHs for Class A and B data have been
   * found. For 12.2 and 10.2 AMR modes, also check for
   * channel for Class C data.
   */
  if((amr_a_rb_id == RRCLLC_INVALID_RB_ID) ||
     (amr_b_rb_id == RRCLLC_INVALID_RB_ID))
  {
    WRRC_MSG0_ERROR("Not all UL TrCHs for AMR found");
    return(FAILURE);
  }
  else
  {
#ifdef FEATURE_MVS
    if((ptr->amr_mode == MVS_AMR_MODE_1220) ||
       (ptr->amr_mode == MVS_AMR_MODE_1020))
#endif  /* FEATURE_MVS */
    {
      /* Only 12.2 and 10.2 modes have Class C data */
      if(amr_c_rb_id == RRCLLC_INVALID_RB_ID)
      {
        WRRC_MSG0_ERROR("Not all UL TrCHs for AMR found");
        return(FAILURE);
      }

      if(!found_0_class_c)
      {
        /* If we previously turned on DTX, we need to turn it off now, since
           we didn't find a cooperative Class C TFC. */
#ifdef FEATURE_MVS
        ptr->scr_mode = MVS_SCR_DISABLE;
#endif /* FEATURE_MVS */
      }
    }
  }  /* If Class A and B TrCH have been found */

  /* Go through the DL RB Mapping info to get the DL RLC IDs */
  for(ix = 0; ix < ordered_config_ptr->mac_dl_parms.num_dchs; ix++)
  {
    if(ordered_config_ptr->dl_dch_info[ix].dlchan_info[0].rb_id == amr_a_rb_id)
    {
      ptr->dl_amr_a_id = ordered_config_ptr->dl_dch_info[ix].dlchan_info[0].rlc_id;
#ifdef FEATURE_AS_MVS_ENHANCED_AMR_PROCESSING
      ptr->dl_amr_a_trch_id = ordered_config_ptr->dl_dch_info[ix].trch_id;
      ptr->dl_amr_a_cctrch_id = ordered_config_ptr->dl_dch_info[ix].cctrch_id;
#endif /* FEATURE_AS_MVS_ENHANCED_AMR_PROCESSING */
      amr_a_rb_id = RRCLLC_INVALID_RB_ID;
    }
    else if(ordered_config_ptr->dl_dch_info[ix].dlchan_info[0].rb_id == amr_b_rb_id)
    {
      ptr->dl_amr_b_id = ordered_config_ptr->dl_dch_info[ix].dlchan_info[0].rlc_id;
#ifdef FEATURE_AS_MVS_ENHANCED_AMR_PROCESSING
      ptr->dl_amr_b_trch_id = ordered_config_ptr->dl_dch_info[ix].trch_id;
      ptr->dl_amr_b_cctrch_id = ordered_config_ptr->dl_dch_info[ix].cctrch_id;
#endif /* FEATURE_AS_MVS_ENHANCED_AMR_PROCESSING */
      amr_b_rb_id = RRCLLC_INVALID_RB_ID;
    }
    else if(ordered_config_ptr->dl_dch_info[ix].dlchan_info[0].rb_id == amr_c_rb_id)
    {
      ptr->dl_amr_c_id = ordered_config_ptr->dl_dch_info[ix].dlchan_info[0].rlc_id;
#ifdef FEATURE_AS_MVS_ENHANCED_AMR_PROCESSING
      ptr->dl_amr_c_trch_id = ordered_config_ptr->dl_dch_info[ix].trch_id;
      ptr->dl_amr_c_cctrch_id = ordered_config_ptr->dl_dch_info[ix].cctrch_id;
#endif /* FEATURE_AS_MVS_ENHANCED_AMR_PROCESSING */
      amr_c_rb_id = RRCLLC_INVALID_RB_ID;
    }
    /* Break the loop if all Logical Channel IDs have been established */
    if((amr_a_rb_id == RRCLLC_INVALID_RB_ID) &&
       (amr_b_rb_id == RRCLLC_INVALID_RB_ID))
    {
#ifdef FEATURE_MVS
      if((ptr->amr_mode == MVS_AMR_MODE_1220) ||
         (ptr->amr_mode == MVS_AMR_MODE_1020))
#endif  /* FEATURE_MVS */
      {
        /* For 12.2 and 10.2 AMR modes, make sure Class C
         * info has been obtained.
         */
        if(amr_c_rb_id == RRCLLC_INVALID_RB_ID)
        {
          break;
        }
      }  /* AMR mode of 12.2 or 10.2 kbps */
      else /* All other AMR modes do not have Class C data */
      {
        break;
      } /* All other AMR modes that have no Class C bits */
    } /* Info for Class A and B logical channel has been obtained */
  }

  /* Check if TrCHs for Class A and B data have been
   * found. For 12.2 and 10.2 AMR modes, also check for
   * channel for Class C data.
   */
  if((amr_a_rb_id != RRCLLC_INVALID_RB_ID) ||
     (amr_b_rb_id != RRCLLC_INVALID_RB_ID))
  {
    WRRC_MSG0_ERROR("Not all DL TrCHs for AMR found");
    return(FAILURE);
  }
  else
  {
#ifdef FEATURE_MVS
    if((ptr->amr_mode == MVS_AMR_MODE_1220) ||
       (ptr->amr_mode == MVS_AMR_MODE_1020))
#endif  /* FEATURE_MVS */
    {
      /* Only 12.2 and 10.2 modes have Class C data */
      if(amr_c_rb_id != RRCLLC_INVALID_RB_ID)
      {
        WRRC_MSG0_ERROR("Not all DL TrCHs for AMR found");
        return(FAILURE);
      }
    }
  }  /* If Class A and B TrCH have been found */

  rrcllc_derive_dl_amr_mode(ptr);
  WRRC_MSG1_HIGH("AMR Mode for DL = %d",ptr->dl_amr_mode);

#if defined(FEATURE_AS_MVS_ENHANCED_AMR_PROCESSING)
  rrc_save_rrc_amr_info_for_mvs_callback(ptr);
#endif /* FEATURE_AS_MVS_ENHANCED_AMR_PROCESSING*/    

  start_event_log.codec_type =RRC_NB_AMR_CODEC;
   
  event_report_payload(EVENT_WCDMA_UL_AMR_RATE,
                       sizeof(start_event_log),
                       (void *)&start_event_log);
#endif   
  return(SUCCESS);
} /* end rrcllc_get_amr_mapping() */

#endif /*FEATURE_VOC_AMR_WB*/

#ifdef FEATURE_VOC_AMR_WB

/*====================================================================
FUNCTION: rrcllc_get_amr_wb_mapping()

DESCRIPTION:
  This function returns takes a pointer to a data structure of type
  rrcllc_amr_wb_mapping_info_type, fills in the RLC LC IDs of the Uplink
  and Downlink AMR Modes (A, B, C), as well as the AMR and SRC modes\
  in use.

DEPENDENCIES:
  None.

RETURN VALUE:
  FAILURE: If either the AMR mode is not understood (based on TFs)
           Or info on Class A and B is not available. 
  SUCCESS: If info on AMR mode and all classes is available.

SIDE EFFECTS:
  The uplink and downlink TrCH IDs and RLC Sizes are assumed to be
  the same.

  Since the UE only supports Logical Channels mapped to a TrCH
  where all Logical Channels mapped support all Transport Formats,
  and since this is not the case for AMR Modes, there can only be
  1 Logical channel on this TrCH.
====================================================================*/

uecomdef_status_e_type
rrcllc_get_amr_wb_mapping( rrcllc_amr_mapping_info_type *ptr )
{
  /* local index variables */
  uint8 ix;

  boolean found_1x40_class_a = FALSE;
  boolean found_0_class_a = FALSE;
  boolean found_0_class_b = FALSE;
  
  /* Local RB ids for AMR Mode Classes */
  rrc_RB_Identity amr_a_rb_id = RRCLLC_INVALID_RB_ID;
  rrc_RB_Identity amr_b_rb_id = RRCLLC_INVALID_RB_ID;

  /* Indexes of the DCHs for AMR Mode Classes */
  uint8 amr_a_dch_idx = UE_MAX_TRCH;
  uint8 amr_b_dch_idx = UE_MAX_TRCH;

  dch_id_mapping dch_mapping[MAX_DCH_VOICE_CHANNEL];

  /* Disable SCR(DTX), aka Background Noise suppression */
  mvs_mode_type  codec_info;
  ptr->scr_mode = MVS_SCR_DISABLE;

  /* Set AMR mode to invalid value */ 
  
  WRRC_MSG0_HIGH("Get WB-AMR Mapping info");


  ptr->amr_mode=  rrcllc_derive_amr_rate(&codec_info,dch_mapping);
  rrcllc_derive_dl_amr_mode(ptr);
    
  if(codec_info != MVS_MODE_AMR_WB )
  {
    return FAILURE;
  }
     
  if(dch_mapping[0].transport_channel_index != UE_MAX_TRCH)
  {
    /* update the rlc_id, rb_id for Class A*/
    ptr->ul_amr_a_id = dch_mapping[0].rlc_id;
    
    /* Remember the RB ID so can easily get the DL AMR channel */
    amr_a_rb_id = dch_mapping[0].rb_id;
    
    /* Remember the DCH idx so we can check for DTX activation later */
    amr_a_dch_idx = dch_mapping[0].transport_channel_index;
  }
  
  if(dch_mapping[1].transport_channel_index != UE_MAX_TRCH)
  {
    /* update the rlc_id, rb_id for Class B*/
    ptr->ul_amr_b_id = dch_mapping[1].rlc_id;
    
    /* Remember the RB ID so can easily get the DL AMR channel */
    amr_b_rb_id = dch_mapping[1].rb_id;
    
    /* Remember the DCH idx so we can check for DTX activation later */
    amr_b_dch_idx = dch_mapping[1].transport_channel_index;
  }
  /*  Check whether to enable DTX (Source Controlled Rate).  DTX should be
  *  enabled if both of the following conditions are met:
  *
  *    * There is a TFC that allows a SID frame (i.e. 1x40 for Class A)
  *    * There is a TFC that allows no data on each of Class A and C
  *
  *  This check is for Uplink only.
  *  Note: For UMTS: SCR and DTX are the same.
  */
  if(amr_a_dch_idx < UE_MAX_TRCH)
  {
    for(ix = 0; ix < ordered_config_ptr->ul_tfcs.tfs_info[amr_a_dch_idx].ntf; ix++)
    {
      if(ordered_config_ptr->ul_tfcs.tfs_info[amr_a_dch_idx].tf_info[ix].tb_size ==
         RRCLLC_AMR_WB_CLASS_A_BIT_SIZE &&
         ordered_config_ptr->ul_tfcs.tfs_info[amr_a_dch_idx].tf_info[ix].ntblks ==
         1)
      {
        /* This is a 1x40 TFC */
        found_1x40_class_a = TRUE;
      }
      else if(ordered_config_ptr->ul_tfcs.tfs_info[amr_a_dch_idx].tf_info[ix].tb_size *
              ordered_config_ptr->ul_tfcs.tfs_info[amr_a_dch_idx].tf_info[ix].ntblks
              == 0)
      {
        /* This is a TFC that allows no data */
        found_0_class_a = TRUE;
      }
      /* Exit the loop if the TFC for a SID frame and TFC with no data is found */
      if(found_1x40_class_a && found_0_class_a)
      {
        break;
      }
    }
  }

  if(amr_b_dch_idx < UE_MAX_TRCH)
  {
    for(ix = 0; ix < ordered_config_ptr->ul_tfcs.tfs_info[amr_b_dch_idx].ntf; ix++)
    {
      if(ordered_config_ptr->ul_tfcs.tfs_info[amr_b_dch_idx].tf_info[ix].tb_size *
         ordered_config_ptr->ul_tfcs.tfs_info[amr_b_dch_idx].tf_info[ix].ntblks
         == 0)
      {
        /* This is a TFC that allows no data */
        found_0_class_b = TRUE;
        break;
      }
    }
  }

  /* DTX can be enabled is TFC with SID frame and 
   * TFC with no data(for Class A & Class B) is found
   */
  if(found_1x40_class_a && found_0_class_a && found_0_class_b)
  {
    /* Provisionally switch on DTX.  */
    ptr->scr_mode = MVS_SCR_ENABLE;
  }


  if(ptr->amr_mode == MVS_AMR_MODE_MAX)
  {
    WRRC_MSG0_ERROR("Unknown WB AMR mode");
    return(FAILURE);
  }

  /* Check if TrCHs for Class A and B data have been
   * found. 
   */
  if((amr_a_rb_id == RRCLLC_INVALID_RB_ID) ||
     (amr_b_rb_id == RRCLLC_INVALID_RB_ID))
  {
    WRRC_MSG0_ERROR("Not all UL TrCHs for AMR found");
    return(FAILURE);
  }
 
  WRRC_MSG1_HIGH("SCR mode ",ptr->scr_mode);
  /* Go through the DL RB Mapping info to get the DL RLC IDs */
  for(ix = 0; ix < ordered_config_ptr->mac_dl_parms.num_dchs; ix++)
  {
    if(ordered_config_ptr->dl_dch_info[ix].dlchan_info[0].rb_id == amr_a_rb_id)
    {
      /* Update The RLC-ID, transport channel id and CCTrCh ID for 
       * for Class A the DL Channel also
       */
      ptr->dl_amr_a_id = ordered_config_ptr->dl_dch_info[ix].dlchan_info[0].rlc_id;
#ifdef FEATURE_AS_MVS_ENHANCED_AMR_PROCESSING
      ptr->dl_amr_a_trch_id = ordered_config_ptr->dl_dch_info[ix].trch_id;
      ptr->dl_amr_a_cctrch_id = ordered_config_ptr->dl_dch_info[ix].cctrch_id;
#endif /* FEATURE_AS_MVS_ENHANCED_AMR_PROCESSING */
       WRRC_MSG0_HIGH("amr_a_rb_id made invalid");
      amr_a_rb_id = RRCLLC_INVALID_RB_ID;
    }
    else if(ordered_config_ptr->dl_dch_info[ix].dlchan_info[0].rb_id == amr_b_rb_id)
    {
      /* Update The RLC-ID, transport channel id and CCTrCh ID for 
       * for Class B the DL Channel also
       */
      ptr->dl_amr_b_id = ordered_config_ptr->dl_dch_info[ix].dlchan_info[0].rlc_id;
#ifdef FEATURE_AS_MVS_ENHANCED_AMR_PROCESSING
      ptr->dl_amr_b_trch_id = ordered_config_ptr->dl_dch_info[ix].trch_id;
      ptr->dl_amr_b_cctrch_id = ordered_config_ptr->dl_dch_info[ix].cctrch_id;
#endif /* FEATURE_AS_MVS_ENHANCED_AMR_PROCESSING */
       WRRC_MSG0_HIGH("amr_b_rb_id made invalid");
      amr_b_rb_id = RRCLLC_INVALID_RB_ID;
    }
    
    /* Break the loop if all Logical Channel IDs have been established */
    if((amr_a_rb_id == RRCLLC_INVALID_RB_ID) &&
       (amr_b_rb_id == RRCLLC_INVALID_RB_ID))
    {
      break;     
    } /* Info for Class A and B logical channel has been obtained */
  }
 
  /* Check if TrCHs for Class A and B data have been
   * found. 
   */
  if((amr_a_rb_id != RRCLLC_INVALID_RB_ID) ||
     (amr_b_rb_id != RRCLLC_INVALID_RB_ID))
  {
    WRRC_MSG0_ERROR("Not all DL TrCHs for AMR found");
    return(FAILURE);
  }

#if defined(FEATURE_AS_MVS_ENHANCED_AMR_PROCESSING)
  rrc_save_rrc_amr_info_for_mvs_callback(ptr);
#endif /* FEATURE_AS_MVS_ENHANCED_AMR_PROCESSING*/    

    /* If Class A and B TrCH have been found */
  return(SUCCESS);
}
/*====================================================================
FUNCTION: rrcllc_derive_amr_rate()

DESCRIPTION: This function derives the AMR rate. And differentaites if a Wb-AMR codec or a NB-AMR codec
                       is used to configured. 
                       it also 
DEPENDENCIES:
  None.

RETURN VALUE:
 None

SIDE EFFECTS:
  
====================================================================*/

mvs_amr_mode_type rrcllc_derive_amr_rate
( 
   mvs_mode_type * codec_info ,
    dch_id_mapping * dch_mapping
 )
{
  /* local index variables */
  uint8 ix, iy,iz;
  uint8 index=0;
  uint16   tfi;

  
  mvs_amr_mode_type  current_amr_mode = MVS_AMR_MODE_0475;
  mvs_amr_mode_type  previous_amr_mode = MVS_AMR_MODE_0475;
  uint16 total_bits;
  boolean found  = TRUE;
  boolean found_rate = FALSE;
  uint16 log_total_bits[8]={0};
  wcdma_ul_amr_rate_event_type start_event_log;
  /* Disable SCR(DTX), aka Background Noise suppression */

  WRRC_MSG0_MED("Derive AMR mode and rate");
  start_event_log.num_rates =0;
  start_event_log.codec_type =RRC_NO_CODEC;/*In valid*/
  for(ix=0;ix < RRC_AMR_RATE_SIZE; ix++)
  {
    start_event_log.amr_rate[ix] = MAC_AMR_MODE_UNDEF;
  }
  /*
  * Get the RLC Logical Channel IDs for UL, and use
  * RB IDs extracted here to get Logical Channel IDs
  * for DL
  */
  for(ix =0;ix< MAX_DCH_VOICE_CHANNEL; ix++ )
  {
    dch_mapping[ix].transport_channel_index = UE_MAX_TRCH;
    dch_mapping[ix].amr_class_size = 0;
    dch_mapping[ix].rlc_id= 0xFF;
    dch_mapping[ix].rb_id = RRCLLC_INVALID_RB_ID;
  }
    
  for (ix=0; ix < ordered_config_ptr->ul_tfcs.ntfc; ix++)
  {
    index =0;
    /* Since for every rate it iterated, reset the values  */
    dch_mapping[0].amr_class_size =0;
    dch_mapping[1].amr_class_size=0;
    dch_mapping[2].amr_class_size=0;
    /* Check if the TFC is allowed*/
    if (ordered_config_ptr->ul_tfcs.tfc_info[ix].control_flag == TFC_ALLOWED)
    {  
      /* Go through the number of transport channels configured*/
      for (iy=0; iy < ordered_config_ptr->ul_tfcs.nchan; iy++)
      {
         /* Only check for DTCHs, only 1 DTCH per DCH */
        if((ordered_config_ptr->ul_cctrch.dch_info.dch_info[iy].dlchan_info[0].chan_type == UE_LOGCHAN_DTCH)
            && (ordered_config_ptr->ul_cctrch.dch_info.dch_info[iy].dlchan_info[0].rlc_mode== UE_MODE_TRANSPARENT))
        {
          /* Since we allocated for only 3 RBs for voice */
          if(index == MAX_DCH_VOICE_CHANNEL )
          {
            WRRC_MSG1_HIGH("only 3 transport channel allowed index> %d so break ",index);
            break;
          }
          /* Get the transport format index for TFC "ix" and TFI corresponding to Transoprt channel "iy"*/
          tfi = ordered_config_ptr->ul_tfcs.tfc_info[ix].tfi[iy];
         
          /* If the number of transport blocks are > 0 */
          if (ordered_config_ptr->ul_tfcs.tfs_info[iy].tf_info[tfi].ntblks > 0)
          {
            /* Check the TB_size*/
            dch_mapping[index].amr_class_size = ordered_config_ptr->ul_tfcs.tfs_info[iy].tf_info[tfi].tb_size;
                     /* update the rlc_id, rb_id for Class A*/
            dch_mapping[index].rlc_id = ordered_config_ptr->ul_cctrch.dch_info.dch_info[iy].dlchan_info[0].rlc_id;
        
            /* Remember the RB ID so can easily get the DL AMR channel */
            dch_mapping[index].rb_id = ordered_config_ptr->ul_cctrch.dch_info.dch_info[iy].dlchan_info[0].rb_id;
        
            dch_mapping[index].transport_channel_index = iy;
            index++;                            
          }
        }
      }
      
           
      total_bits = dch_mapping[0].amr_class_size + dch_mapping[1].amr_class_size +dch_mapping[2].amr_class_size;
      log_total_bits[ix%8] = total_bits;
                
      /*WM AMR 132 = 6.6k,177=8.85k,253=12.65k,285=14.25k,317=15.85k,365=18.25k,397=19.85k,461=23.05k,477=23.86k,NB AMR 244=12.2k,204=10.2k,159=7.95k,148=7.4k,134=6.7k,118= 5.9k,103=5.15k,95=4.75k*/
        
      switch(total_bits)
      {
        case WVS_AMR_WB_MODE_660_TOTAL_BITS :
        {
          current_amr_mode = MVS_AMR_MODE_0660;
        }
        break;
        case WVS_AMR_WB_MODE_885_TOTAL_BITS :
        {
          current_amr_mode = MVS_AMR_MODE_0885;
        }
        break;
        case WVS_AMR_WB_MODE_1265_TOTAL_BITS :
        {
          current_amr_mode = MVS_AMR_MODE_1265;
        }
        break;
        case WVS_AMR_WB_MODE_1425_TOTAL_BITS :
        { 
          current_amr_mode = MVS_AMR_MODE_1425;          
        }
        break;
        case WVS_AMR_WB_MODE_1585_TOTAL_BITS :
        {
          current_amr_mode = MVS_AMR_MODE_1585;
        }
        break;
        case WVS_AMR_WB_MODE_1825_TOTAL_BITS : 
        {
          current_amr_mode = MVS_AMR_MODE_1825;
        }
        break;
        case WVS_AMR_WB_MODE_1985_TOTAL_BITS : 
        {
          current_amr_mode = MVS_AMR_MODE_1985;
        }
        break;
        case WVS_AMR_WB_MODE_2305_TOTAL_BITS : 
        {
          current_amr_mode = MVS_AMR_MODE_2305;
        }
        break;
        case WVS_AMR_WB_MODE_2385_TOTAL_BITS : 
        {
          current_amr_mode = MVS_AMR_MODE_2385;
         }
         break;
         case WVS_AMR_MODE_122_TOTAL_BITS  :
        {
          current_amr_mode = MVS_AMR_MODE_1220;
        }
        break;
        case WVS_AMR_MODE_102_TOTAL_BITS  :
        {
          current_amr_mode = MVS_AMR_MODE_1020;
        }
        break;
        case WVS_AMR_MODE_795_TOTAL_BITS  :
        {
          current_amr_mode = MVS_AMR_MODE_0795;
        }
        break;
        case WVS_AMR_MODE_740_TOTAL_BITS  :
        {
          current_amr_mode = MVS_AMR_MODE_0740;
        }
        break;
        case WVS_AMR_MODE_670_TOTAL_BITS  :
        {
          current_amr_mode = MVS_AMR_MODE_0670;
        }
        break;
        case WVS_AMR_MODE_590_TOTAL_BITS  :
        {
          current_amr_mode = MVS_AMR_MODE_0590;
        }
        break;
        case WVS_AMR_MODE_515_TOTAL_BITS  :
        {
          current_amr_mode = MVS_AMR_MODE_0515;
        }  
        break;
        case WVS_AMR_WB_MODE_475_TOTAL_BITS  :
        {
          current_amr_mode = MVS_AMR_MODE_0475;
        }
        break;         
        default:
          if((total_bits == RRCLLC_AMR_WB_CLASS_NO_DATA_FRAME_SIZE)
             || (total_bits == RRCLLC_AMR_WB_CLASS_A_BIT_SIZE)
             ||(total_bits == RRCLLC_AMR_MODE_8_CLASS_A_BIT_SIZE))
          {
            WRRC_MSG1_MED("SID frames found or No dat frames found",
                              total_bits);
          }
          else
          {
            WRRC_MSG1_HIGH("wrong total size %d for  AMR",
                              total_bits);
          }
          found = FALSE;
        break;
      }
      if(found == TRUE)
      {
        boolean rate_present_in_event = FALSE;
        found_rate = TRUE;
        WRRC_MSG2_MED("Total bits %d and  amr mode is %0x [WM AMR 132 = 6.6k,177=8.85k,253=12.65k,285=14.25k,317=15.85k,365=18.25k,397=19.85k,461=23.05k,477=23.86k,NB AMR 244=12.2k,204=10.2k,159=7.95k,148=7.4k,134=6.7k,118= 5.9k,103=5.15k,95=4.75k]",total_bits,current_amr_mode);
        for(iz =0;(iz < RRC_AMR_RATE_SIZE) && (iz<start_event_log.num_rates);iz++)
        {
          if(start_event_log.amr_rate[iz] == ((rrc_event_ul_amr_rate_type)current_amr_mode) )
          {
            rate_present_in_event = TRUE;
            break;
          }
        }
        if((rate_present_in_event == FALSE) && (start_event_log.num_rates < RRC_AMR_RATE_SIZE))
        {
          start_event_log.amr_rate[ start_event_log.num_rates] =
              (rrc_event_ul_amr_rate_type) current_amr_mode;
          start_event_log.num_rates++;
        }
 #ifdef FEATURE_WCDMA_MULTIRATE_AMR
        if( previous_amr_mode < current_amr_mode)
        {
          WRRC_MSG2_MED("Multirate wb-amr lower amr rate %0x higher rate %0x ",previous_amr_mode,current_amr_mode);
          previous_amr_mode = current_amr_mode;
        }
 #else/*FEATURE_WCDMA_MULTIRATE_AMR*/
        previous_amr_mode= current_amr_mode;
        WRRC_MSG1_HIGH("previous_amr_mode %d",previous_amr_mode);
        break;  
 #endif/*FEATURE_WCDMA_MULTIRATE_AMR*/
      }
      found = TRUE;
    }
  }
  WRRC_MSG9_HIGH("AMR calc. ntfc: %d, total_bits[0]: %d, total_bits[1]: %d, total_bits[2]: %d, total_bits[3]: %d, total_bits[4]: %d, total_bits[5]: %d, total_bits[6]: %d, total_bits[7]: %d, total_bits[8]: %d",
		ordered_config_ptr->ul_tfcs.ntfc,log_total_bits[0], log_total_bits[1],
		log_total_bits[2],log_total_bits[3],log_total_bits[4],log_total_bits[5],
		log_total_bits[6],log_total_bits[7]);
      
  if(found_rate == TRUE )
  {
    if( (previous_amr_mode >= MVS_AMR_MODE_0660) &&
       (previous_amr_mode < MVS_AMR_MODE_MAX))
    {
      *codec_info = MVS_MODE_AMR_WB;
      start_event_log.codec_type =RRC_WB_AMR_CODEC;
    }
    else
    {
      *codec_info = MVS_MODE_AMR;
      start_event_log.codec_type =RRC_NB_AMR_CODEC;
    }
    event_report_payload(EVENT_WCDMA_UL_AMR_RATE,
                       sizeof(start_event_log),
                       (void *)&start_event_log);
  }
  else
  {
    *codec_info = MVS_MODE_NONE;
  }   
  WRRC_MSG2_HIGH("UL AMR mode: 0x%x, codec_type:0x%x",previous_amr_mode,*codec_info);
  return previous_amr_mode;
}

#endif /*FEATURE_VOC_AMR_WB*/

/*====================================================================
FUNCTION: rrcllc_derive_dl_amr_mode()

DESCRIPTION:

  This function returns MVS AMR mode for DL. This function uses DL CTFCs to derive the AMR mode.
  
DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  
====================================================================*/
void rrcllc_derive_dl_amr_mode(rrcllc_amr_mapping_info_type *ptr)
{
#ifdef FEATURE_MVS
  uint8 ix, iy, index=0, tfi;
  uint16 total_bits;
  dch_id_mapping dch_mapping[MAX_DCH_VOICE_CHANNEL];
#ifdef FEATURE_AS_MVS_ENHANCED_AMR_PROCESSING   
  cctrch_id_type amr_class_cctrch_id[MAX_DCH_VOICE_CHANNEL] = {0,0,0};
#endif /*FEATURE_AS_MVS_ENHANCED_AMR_PROCESSING*/
  
 
  boolean found  = TRUE;
  mvs_amr_mode_type  current_amr_mode = MVS_AMR_MODE_0475;
  mvs_amr_mode_type  previous_amr_mode = MVS_AMR_MODE_0475;
  uint16 log_total_bits[8] = {0};
  WRRC_MSG0_MED("Derive AMR mode for DL using CTFCs");


  for(ix =0;ix< MAX_DCH_VOICE_CHANNEL; ix++ )
  {
    dch_mapping[ix].transport_channel_index = UE_MAX_TRCH;
    dch_mapping[ix].amr_class_size = 0;
    dch_mapping[ix].rlc_id= 0xFF;
  }
    
  
  /*Loop through all the CTFCs for DL*/
  for (ix=0; (( ordered_config_ptr->dl_ctfc.last_ctfc_entry_index != RRC_DL_INVALID_CTFC_VALUE) && 
    (ix <= ordered_config_ptr->dl_ctfc.last_ctfc_entry_index)) ;ix++)
  {
    index =0;
    dch_mapping[0].amr_class_size =0; /*Class A*/
    dch_mapping[1].amr_class_size =0; /*Class B*/
    dch_mapping[2].amr_class_size =0; /*Class C*/
	
    /*Check whether the CTFC is allowed or not*/
    if (ordered_config_ptr->dl_ctfc.ctfc_entry_data[ix].state== ALLOWED)
    {
      /*Loop through all the DL DCH TrCHs*/
      for (iy=0; iy < ordered_config_ptr->mac_dl_parms.num_dchs; iy++)
      {
        /*Check whether the Logical channel mapped to DCH is of DTCH type and of TM RLC mode*/
        if((ordered_config_ptr->mac_dl_parms.dch_info[iy]->dlchan_info[0].chan_type == UE_LOGCHAN_DTCH)
              && (ordered_config_ptr->mac_dl_parms.dch_info[iy]->dlchan_info[0].rlc_mode== UE_MODE_TRANSPARENT))
        {
          if(index >= MAX_DCH_VOICE_CHANNEL)
          {
            WRRC_MSG1_HIGH("Only 3 transport channel allowed (index = %d) so break ",index);
            break;
          }
          /*TF index given by DL CTFCs*/
          tfi = ordered_config_ptr->dl_ctfc.ctfc_entry_data[ix].tfi_table[iy];

          if (ordered_config_ptr->l1_dl_cctrch_parms.trch_info_array[iy]->tf_info_array[tfi]->num_tb > 0)
          {
            dch_mapping[index].rlc_id = ordered_config_ptr->mac_dl_parms.dch_info[iy]->dlchan_info[0].rlc_id;
            dch_mapping[index].transport_channel_index = ordered_config_ptr->dl_dch_info[iy].trch_id;
#ifdef FEATURE_AS_MVS_ENHANCED_AMR_PROCESSING 			
            amr_class_cctrch_id[index] = ordered_config_ptr->dl_dch_info[iy].cctrch_id;
#endif /*FEATURE_AS_MVS_ENHANCED_AMR_PROCESSING*/

            dch_mapping[index].amr_class_size = (ordered_config_ptr->l1_dl_cctrch_parms.trch_info_array[iy]->tf_info_array[tfi]->tb_size);
            index++;
          }
        }
      }
      total_bits = dch_mapping[0].amr_class_size + dch_mapping[1].amr_class_size + dch_mapping[2].amr_class_size;
      log_total_bits[ix%8] = total_bits;
      /*WM AMR 132 = 6.6k,177=8.85k,253=12.65k,285=14.25k,317=15.85k,363=18.25k,397=19.85k,461=23.05k,477=23.86k,NB AMR 244=12.2k,204=10.2k,159=7.95k,148=7.4k,134=6.7k,118= 5.9k,103=5.15k,95=4.75k*/

      switch(total_bits)
      {
#ifdef FEATURE_VOC_AMR_WB
        case WVS_AMR_WB_MODE_660_TOTAL_BITS :
        {
          current_amr_mode = MVS_AMR_MODE_0660;
        }
        break;
        case WVS_AMR_WB_MODE_885_TOTAL_BITS :
        {
          current_amr_mode = MVS_AMR_MODE_0885;
        }
        break;
        case WVS_AMR_WB_MODE_1265_TOTAL_BITS :
        {
          current_amr_mode = MVS_AMR_MODE_1265;
        }
        break;
        case WVS_AMR_WB_MODE_1425_TOTAL_BITS :
        { 
          current_amr_mode = MVS_AMR_MODE_1425;          
        }
        break;
        case WVS_AMR_WB_MODE_1585_TOTAL_BITS :
        {
          current_amr_mode = MVS_AMR_MODE_1585;
        }
        break;
        case WVS_AMR_WB_MODE_1825_TOTAL_BITS : 
        {
          current_amr_mode = MVS_AMR_MODE_1825;
        }
        break;
        case WVS_AMR_WB_MODE_1985_TOTAL_BITS : 
        {
          current_amr_mode = MVS_AMR_MODE_1985;
        }
        break;
        case WVS_AMR_WB_MODE_2305_TOTAL_BITS : 
        {
          current_amr_mode = MVS_AMR_MODE_2305;
        }
        break;
        case WVS_AMR_WB_MODE_2385_TOTAL_BITS : 
        {
          current_amr_mode = MVS_AMR_MODE_2385;
        }
        break;
#endif /* FEATURE_VOC_AMR_WB */
        case WVS_AMR_MODE_122_TOTAL_BITS  :
        {
          current_amr_mode = MVS_AMR_MODE_1220;
        }
        break;
        case WVS_AMR_MODE_102_TOTAL_BITS  :
        {
          current_amr_mode = MVS_AMR_MODE_1020;
        }
        break;
        case WVS_AMR_MODE_795_TOTAL_BITS  :
        {
          current_amr_mode = MVS_AMR_MODE_0795;
        }
        break;
        case WVS_AMR_MODE_740_TOTAL_BITS  :
        {
          current_amr_mode = MVS_AMR_MODE_0740;
        }
        break;
        case WVS_AMR_MODE_670_TOTAL_BITS  :
        {
          current_amr_mode = MVS_AMR_MODE_0670;
        }
        break;
        case WVS_AMR_MODE_590_TOTAL_BITS  :
        {
          current_amr_mode = MVS_AMR_MODE_0590;
        }
        break;
        case WVS_AMR_MODE_515_TOTAL_BITS  :
        {
          current_amr_mode = MVS_AMR_MODE_0515;
        }  
        break;
        case WVS_AMR_WB_MODE_475_TOTAL_BITS  :
        {
          current_amr_mode = MVS_AMR_MODE_0475;
        }
        break;         
        default:
          if((total_bits == RRCLLC_AMR_WB_CLASS_NO_DATA_FRAME_SIZE)
              || (total_bits == RRCLLC_AMR_WB_CLASS_A_BIT_SIZE)
              ||(total_bits == RRCLLC_AMR_MODE_8_CLASS_A_BIT_SIZE))
          {
            WRRC_MSG1_MED("SID frames found or No data frames found",
                              total_bits);
          }
          else
          {
            WRRC_MSG1_HIGH("Wrong total size %d for  AMR",
                              total_bits);
          }
          found = FALSE;
        break;
      }
      if(found == TRUE)
      {
        WRRC_MSG2_MED("Total bits %d and  AMR mode %0x",total_bits,current_amr_mode);
 #ifdef FEATURE_WCDMA_MULTIRATE_AMR
        /*Comparison is done to find the larger of the two amr modes*/
        if( previous_amr_mode < current_amr_mode)
        {
          WRRC_MSG2_MED("Multirate_AMR, lower AMR mode %d higher AMR mode %d ",previous_amr_mode,current_amr_mode);
          previous_amr_mode = current_amr_mode;
        }
 #else/*FEATURE_WCDMA_MULTIRATE_AMR*/
        previous_amr_mode= current_amr_mode;
        WRRC_MSG1_HIGH("Previous_amr_mode %d",previous_amr_mode);
        break;  
 #endif/*FEATURE_WCDMA_MULTIRATE_AMR*/
      } /* if(found == TRUE) */
      found = TRUE;
    }
  }
  
  WRRC_MSG9_HIGH("AMR calc. last_ctfc_entry_idx: %d, total_bits[0]: %d, total_bits[1]: %d, total_bits[2]: %d, total_bits[3]: %d, total_bits[4]: %d, total_bits[5]: %d, total_bits[6]: %d, total_bits[7]: %d, total_bits[8]: %d",
		ordered_config_ptr->dl_ctfc.last_ctfc_entry_index,log_total_bits[0], log_total_bits[1],
		log_total_bits[2],log_total_bits[3],log_total_bits[4],log_total_bits[5],
		log_total_bits[6],log_total_bits[7]);

  ptr->dl_amr_mode = previous_amr_mode;

  rrc_dl_amr_mode = ptr->dl_amr_mode;

  ptr->dl_amr_a_id = dch_mapping[0].rlc_id;
  ptr->dl_amr_b_id = dch_mapping[1].rlc_id;
  ptr->dl_amr_c_id = dch_mapping[2].rlc_id;

#ifdef FEATURE_AS_MVS_ENHANCED_AMR_PROCESSING  
  ptr->dl_amr_a_cctrch_id = amr_class_cctrch_id[0];
  ptr->dl_amr_b_cctrch_id = amr_class_cctrch_id[1];
  ptr->dl_amr_c_cctrch_id = amr_class_cctrch_id[2];

  ptr->dl_amr_a_trch_id = dch_mapping[0].transport_channel_index;
  ptr->dl_amr_b_trch_id = dch_mapping[1].transport_channel_index;
  ptr->dl_amr_c_trch_id = dch_mapping[2].transport_channel_index;
#endif /*FEATURE_AS_MVS_ENHANCED_AMR_PROCESSING*/  

  WRRC_MSG1_HIGH("DL AMR Mode %d",ptr->dl_amr_mode);
#endif
  return;
}

/*====================================================================
FUNCTION: rrcllc_set_r99_hsdpa_action()

DESCRIPTION:

  This function sets the HSDPA Action based on the contents of R99 Message.
  
DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  
====================================================================*/
void rrcllc_set_r99_hsdpa_action
(
  void
)
{
  /* Check to make sure that everything is present */
  if (((hsdpa_msg_params.msg_params_present == TRUE)  &&
       ((hsdpa_msg_params.ifhho_involved == TRUE) || 
        (hsdpa_msg_params.intra_hho_involved == TRUE))) || 
      (rrcllc_check_if_hsdpa_can_be_started_reconfigured(ordered_config_ptr) == FALSE))
  {
    rrc_set_hsdpa_action(HSDPA_STOP);
    ordered_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_STOP;
  }
  else
  {
    
    if (ordered_config_ptr->dest_freq_present == TRUE)
    {
      WRRC_MSG0_HIGH("ForcedSyncA. HSAction RECONFIG");
      rrc_set_hsdpa_action(HSDPA_RECONFIG);
      ordered_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_RECONFIG;
    }
    rrcllcpcie_update_hs_tfri_table_type_non_r7_ota();
  }
}
/*====================================================================
FUNCTION: rrc_print_emac_dflow_info_in_oc

DESCRIPTION:
  Prints the updated OC content

DEPENDENCIES:

RETURN VALUE:

SIDE EFFECTS:
  None.
====================================================================*/

void rrc_print_emac_dflow_info_in_oc(void)
{
  if(ordered_config_ptr->e_dch_transmission == TRUE)
  {
    WRRC_MSG8_MED("RRCEUL:E_MAC_D FLOW ID %d %d %d %d %d %d %d %d",
      ordered_config_ptr->mac_e_config.e_mac_d_flow_info[0].e_mac_d_flow_id,
      ordered_config_ptr->mac_e_config.e_mac_d_flow_info[1].e_mac_d_flow_id,
      ordered_config_ptr->mac_e_config.e_mac_d_flow_info[2].e_mac_d_flow_id,
      ordered_config_ptr->mac_e_config.e_mac_d_flow_info[3].e_mac_d_flow_id,
      ordered_config_ptr->mac_e_config.e_mac_d_flow_info[4].e_mac_d_flow_id,
      ordered_config_ptr->mac_e_config.e_mac_d_flow_info[5].e_mac_d_flow_id,
      ordered_config_ptr->mac_e_config.e_mac_d_flow_info[6].e_mac_d_flow_id,
      ordered_config_ptr->mac_e_config.e_mac_d_flow_info[7].e_mac_d_flow_id);
  }
}
/*====================================================================
FUNCTION: rrcllc_set_ordered_config

DESCRIPTION:
  This is called when the ORDERED_CONFIG variable needs to be set.
  It checks to see whether or not it is set or not, and returns
  the status of the check.

  It also takes a pointer to the asn1 decoded message stream and
  places it into the ordered_config database.

  The procedure name is required so that the message asn1 decoded
  message can be properly typecast so as to populate the
  ORDERED_CONFIG database.

DEPENDENCIES:
  CELL_DCH is the only supported state. Now Cell_FACH/Cell_PCH/URA_PCH
  are also supported.

RETURN VALUE:
  rrcllc_oc_status_e_type - indicates whether the ORDERED_CONFIG
                            variable could be successfully set or
                            what the failure was.

SIDE EFFECTS:
  None.
====================================================================*/
rrcllc_oc_status_e_type rrcllc_set_ordered_config
(
  /*
  * This variable indicates the PDU number as defined in the ASN.1
  * header file. This information can be used to map the to correct
  * logical channel received on and then down to the message type.
  * The message contents are in msg_ptr, and need to be typecasted.
  */
  rrc_proc_e_type  proc_id,
  rrc_state_e_type  next_state,
  uint32            dl_sdu_num,
  void             *msg_ptr
)
{
  /* local copy of current state */
  rrc_state_e_type current_state;

  rrcllc_oc_status_e_type  oc_status;

  uint8 idx=0;
  rrc_log_feature_state_variables_status(current_config_ptr);
  rrc_log_rb_mapping_info(current_config_ptr);
  rrc_update_reconfig_waiting_for_l2ack_dch(MAX_NUM_OF_PROCEDURES);

  if ((ordered_config.set_status != OC_NOT_SET &&
      !(proc_id == RRC_PROCEDURE_ASU &&
        ordered_config.process_state == LL_CONFIG_WITH_OC))
      || (transition_config.toc_usage == TOC_FOR_OOS)
      || (transition_config.toc_usage == TOC_FOR_OOS_WITHOUT_DCH_INFO)
      || (transition_config.toc_usage == TOC_FOR_OOS_WITH_DCH_INFO)
      || (transition_config.toc_usage == TOC_FOR_FACH_AND_PCH)
      || (transition_config.toc_usage == TOC_FOR_FACH_AND_PCH_WITH_DCH_INFO)
      )
  {
    WRRC_MSG2_HIGH("Incompatible Simultaneous Reconfig with OC status rrcllc_oc_set_status_e_type_value%d, proc rrc_proc_e_type_value%d ",
                ordered_config.set_status, ordered_config.set_by_proc);
    return (ORDERED_CONFIG_INCOMPATABLE_SIMULTANEOUS_RECONFIG);
  }

  if(config_ptr_in_use == ORDERED_CONFIG &&
    rrcllc_check_if_chan_config_in_progress_for_sib5_change())
  {
    WRRC_MSG0_HIGH("LLC is configuring lower layers for SIB5 change");
    return (ORDERED_CONFIG_INCOMPATABLE_SIMULTANEOUS_RECONFIG);
  }
#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  if(rrcdata_check_if_ota_is_buffered())
  {
    WRRC_MSG1_HIGH("Another OTA message is received when procedure %d processing in progress",rrcdata_misc_info.procedure);
    ordered_config.set_status = OC_NOT_SET;
    ordered_config.reconfig_in_progress = FALSE;
    return (ORDERED_CONFIG_INCOMPATABLE_SIMULTANEOUS_RECONFIG);
  }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
  
  /*Copy the current Rb-Mapping to the ordered RB-Mapping database
  * As the OTA contents will updated in the Ordered RB-mapping database
  */
  if( (proc_id == RRC_PROCEDURE_RBE)||
    (proc_id == RRC_PROCEDURE_RBR)||
    (proc_id == RRC_PROCEDURE_RBRC)||
    (proc_id == RRC_PROCEDURE_CU)||
    (proc_id == RRC_PROCEDURE_TCR)
    )
  {
    WCDMA_MEMCPY(rrc_ordered_hanging_rb_mapping, 
                 (sizeof(rb_mapping_info_type) * MAX_HANGING_RB_MAPPING_INFO),
                 rrc_current_hanging_rb_mapping,
                 (sizeof(rb_mapping_info_type) * MAX_HANGING_RB_MAPPING_INFO));
  }
  /*
  * If made it this far, check the state to determine how to
  * setup ORDERED_CONFIG
  */
  if (next_state == RRC_STATE_DISCONNECTED)
  {
    WRRC_MSG0_HIGH("Cannot set ORDERED_CONFIG in Idle-Disconnected State");
    return (ORDERED_CONFIG_NOT_SET_OTHER);
  }

  /* Get the current state */
  current_state = rrc_get_state();
  rrc_ordered_state = next_state;

  /*Initialization of cell_id_per_rl is done for nonDCH -> DCH states.*/
  if((next_state == RRC_STATE_CELL_DCH) && (current_state !=RRC_STATE_CELL_DCH))
  {
    for(idx=0; idx < L1_MAX_RL; idx++)
    {
      cell_id_per_rl[idx] = WCDMA_INVALID_CELL_ID;
    }
  }  

  switch (next_state)
  {
    case RRC_STATE_CELL_DCH:
    {

      switch(current_state)
      {
        case RRC_STATE_CELL_DCH:
          oc_status = rrcllc_update_oc_in_dch(dl_sdu_num, msg_ptr);
          break;

        case RRC_STATE_CONNECTING:
          oc_status = rrcllc_update_oc_from_connecting_to_dch(dl_sdu_num, msg_ptr);
          break;

        case RRC_STATE_CELL_FACH:
          oc_status = rrcllc_update_oc_from_fach_to_dch(dl_sdu_num, msg_ptr);
          break;


        case RRC_STATE_DISCONNECTED:
          oc_status = rrcllc_update_oc_from_disconnected_to_dch(dl_sdu_num, msg_ptr);
          break;

        default:
          WRRC_MSG1_ERROR("State %d to Cell_DCH transition not supported", current_state);
          oc_status = ORDERED_CONFIG_CONFIGURATION_INVALID;
          break;
      }
    }
    break;

    case RRC_STATE_CELL_FACH:
    {
      switch(current_state)
      {
        case RRC_STATE_CELL_FACH:
          oc_status = rrcllc_update_oc_in_fach_with_msg(dl_sdu_num, msg_ptr);
          break;

        case RRC_STATE_CONNECTING:
          oc_status = rrcllc_update_oc_from_connecting_to_fach(dl_sdu_num, msg_ptr);
          break;

        case RRC_STATE_CELL_DCH:
          oc_status = rrcllc_update_oc_from_dch_to_fach_with_msg(dl_sdu_num, msg_ptr);
          break;


        default:
          WRRC_MSG1_ERROR("State %d to Cell_FACH transition not supported", current_state);
          oc_status = ORDERED_CONFIG_CONFIGURATION_INVALID;
          break;
      }
    }
    break;


  case RRC_STATE_CELL_PCH:
  case RRC_STATE_URA_PCH:
      switch(current_state)
      {
        case RRC_STATE_CELL_FACH:
          oc_status = rrcllc_update_oc_from_fach_to_pch_with_msg(dl_sdu_num,
                                                                 msg_ptr,
                                                                 next_state);
          break;

        case RRC_STATE_CELL_DCH:
          oc_status = rrcllc_update_oc_from_dch_to_pch_with_msg(dl_sdu_num,
                                                                msg_ptr,
                                                                next_state);
          break;

        default:
          WRRC_MSG1_ERROR("State %d to PCH transition not supported", current_state);
          oc_status = ORDERED_CONFIG_CONFIGURATION_INVALID;
          break;
      }
      break;


    default:
      WRRC_MSG1_ERROR("Invalid next state %d for ORDERED_CONFIG", next_state);
      oc_status = ORDERED_CONFIG_CONFIGURATION_INVALID;
      break;

  } /* end switch(next_state) */

  if((oc_status != ORDERED_CONFIG_SET) &&
     (oc_status != ORDERED_CONFIG_INCOMPATABLE_SIMULTANEOUS_RECONFIG))
  {
    /* This implies Ordered Config is not being used - update the
     * config pointer in use
     */
    config_ptr_in_use = CURRENT_CONFIG;
  }


  if(oc_status == ORDERED_CONFIG_SET)
  {
    /* If we're doing an Active Set Update while the process_state is
     * LL_CONFIG_WITH_OC, that means there is already a reconfiguration
     * in progress, so we will leave set_by_proc alone.
     */
    if(!(proc_id == RRC_PROCEDURE_ASU &&
         ordered_config.process_state == LL_CONFIG_WITH_OC))
    {
      /* Update the Procedure ID */
      ordered_config.set_by_proc = proc_id;
    }

    /* Update OC process state */
    ordered_config.process_state = LL_NOT_CONFIG_WITH_OC;
    /* This variable indicates that SMC needs to be notified when
     * a reconfiguration is completed.
     */
    ordered_config.notify_smc = FALSE;

     WRRC_MSG1_HIGH("OC set status: %d", ordered_config.set_status);
    rrcllcpcie_validate_timing_maintained_sync_ind( proc_id);
    rrc_print_emac_dflow_info_in_oc();
  }
  if(oc_status != ORDERED_CONFIG_SET)
  {
#ifndef FEATURE_WCDMA_HS_FACH
    /* Channel config failure, so initialise the ordered RB-Mapping database*/
    rrcllc_init_ordered_hanging_rb_mapping_info();
#else
    rrcllc_copy_current_hanging_rb_mapping_to_ordered();
#endif

    /* In case of OC NOT set, this means the OTA failed some validation, 
    we need to revert cipher config db, if config type is updated as step-1 */ 
    rrcsmc_revert_to_old_config_for_failure_message(TRUE);
  }

  rrc_ordered_state = RRC_STATE_MAX;
  rrc_log_rlc_am_info();
  return (oc_status);

} /* end rrcllc_set_ordered_config() */

/*====================================================================
FUNCTION: rrcllc_swap_oc_and_cc

DESCRIPTION:
  This function swaps ordered_config_ptr and current_config_ptrs
  without altering the ordered_config.set_status.
  This could be called in place of rrcllc_clear_ordered_config
  when the ordered_config.set_status needs to be preserved.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void  rrcllc_swap_oc_and_cc(void)
{
  ordered_config_type *tmp_config_ptr;
  /* Make Ordered Config as Current Config and
   * Current Config as Ordered Config - so that at the next
   * reconfiguration, the data pointed to by the ordered_config
   * before calling this function is not disturbed.
   */
  tmp_config_ptr = current_config_ptr;
  current_config_ptr = ordered_config_ptr;
  ordered_config_ptr = tmp_config_ptr;
  config_ptr_in_use = CURRENT_CONFIG;
  WRRC_MSG0_HIGH("Swap OC and CC");

}

/*====================================================================
FUNCTION: rrcllc_clear_ordered_config

DESCRIPTION:
  This is called when the ORDERED_CONFIG variable needs to be cleared.
  That means the Ordered Config and Current Config pointers are swapped.

  This function puts control of ORDERED_CONFIG in the hands of the
  individual procedures. Each procedure can then decide whether or not
  they wish to wait for a layer 2 ack before clearing or just clearing
  after reciept of an lower layer configuration message.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_clear_ordered_config
(
  void
)
{
  /* Check with LLC if this is the right time to clear ordered config */
  if(rrcllc_can_oc_be_cleared_now())
  {
    rrcllc_clear_ordered_config_now();
  }
  /* If this is not the correct time to clear ordered config,
   * LLC will do it when it is done with the command under process
   */

  /* Regardless of whether or not ordered config can be cleared now,
   * if a reconfig procedure tried to clear ordered config, that means
   * the reconfig is done, so we should clear the reconfig_in_progress
   * flag.
   */
  if (ordered_config.set_by_proc == RRC_PROCEDURE_CU   ||
    ordered_config.set_by_proc == RRC_PROCEDURE_PCR  ||
    ordered_config.set_by_proc == RRC_PROCEDURE_RBE  ||
    ordered_config.set_by_proc == RRC_PROCEDURE_RCE  ||
    ordered_config.set_by_proc == RRC_PROCEDURE_RBR  ||
    ordered_config.set_by_proc == RRC_PROCEDURE_RBRC ||
    ordered_config.set_by_proc == RRC_PROCEDURE_TCR  ||
    ordered_config.set_by_proc == RRC_PROCEDURE_UMI)
  {
    ordered_config.reconfig_in_progress = FALSE;
  }

  return;
} /* end rrcllc_clear_ordered_config() */

/*====================================================================
FUNCTION: rrcllc_clear_reselection_ordered_config

DESCRIPTION:
  This is called when the Reselection ORDERED_CONFIG variable needs
  to be cleared. That means the Reselection Ordered Config data
  is copied into Current Config.

  This function puts control of ORDERED_CONFIG in the hands of the
  individual procedures. Each procedure can then decide whether or not
  they wish to wait for a layer 2 ack before clearing or just clearing
  after reciept of an lower layer configuration message.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_clear_reselection_ordered_config
(
  void
)
{
  ordered_config_type *tmp_config_ptr;
  /* Make Ordered Config as Current Config and
   * Current Config as Ordered Config - so that at the next
   * reconfiguration, the data currently pointed to by the ordered_config
   * pointer is not disturbed.
   */
  tmp_config_ptr = current_config_ptr;
  current_config_ptr = reselection_config_ptr;
  ordered_config_ptr = tmp_config_ptr;

  config_ptr_in_use = CURRENT_CONFIG;


  return;
} /* end rrcllc_clear_reselection_ordered_config() */

/*====================================================================
FUNCTION: rrcllc_get_toc_usage()

DESCRIPTION:
  This function checks returns the toc_usage status

DEPENDENCIES:
  None.

RETURN VALUE:
  toc_usage status

SIDE EFFECTS:
  None.
====================================================================*/
rrcllc_toc_usage_e_type rrcllc_get_toc_usage(void)
{
  WRRC_MSG1_HIGH("TOC usage %d", transition_config.toc_usage);
  return transition_config.toc_usage;
} /*rrcllc_get_toc_usage */
/*====================================================================
FUNCTION: rrcllc_get_ordered_config_process_state()

DESCRIPTION:
  This function returns info on whether or not lower layers have been
  configured with the information in odered config.

DEPENDENCIES:
  None.

RETURN VALUE:
  Returns a value that indicates if lower layers have been set with the
  info in ordered config.

SIDE EFFECTS:
  None.
====================================================================*/
rrcllc_oc_process_state_e_type rrcllc_get_ordered_config_process_state( void )
{
  WRRC_MSG2_HIGH("Get OC process state %d proc rrc_proc_e_type_value%d",
           ordered_config.process_state, ordered_config.set_by_proc);
  /* return the status of ordered_config.process_state variable */
  return ordered_config.process_state;

} /* end rrcllc_get_ordered_process_state() */

/*====================================================================
FUNCTION: rrcllc_reconfig_in_progress()

DESCRIPTION:
  This function returns info on whether or not a reconfiguration is
  currently in progress.

DEPENDENCIES:
  None.

RETURN VALUE:
  Returns a value that indicates if a reconfiguration is in progress.

SIDE EFFECTS:
  None.
====================================================================*/
boolean rrcllc_reconfig_in_progress( void )
{
  WRRC_MSG2_HIGH("Get reconfig in progress %d proc rrc_proc_e_type_value%d",
           ordered_config.reconfig_in_progress, ordered_config.set_by_proc);
  /* return the status of ordered_config.process_state variable */
  return ordered_config.reconfig_in_progress;

} /* end rrcllc_reconfig_in_progress() */

 /*====================================================================
FUNCTION: rrcllc_get_ordered_config_state_and_proc()

DESCRIPTION:
  This function returns oc status. It also indicates which process
  has set the OC and process status.

DEPENDENCIES:
  None.

RETURN VALUE:
  Returns a value that indicates if Ordered Config is set for
  an RRC state or not set.

SIDE EFFECTS:
  None.
====================================================================*/
rrcllc_oc_set_status_e_type rrcllc_get_ordered_config_state_and_proc(
                                                   rrc_proc_e_type *proc_ptr,
                                                   rrcllc_oc_process_state_e_type *process_status_ptr
                                                    )
{
  if(rrcllc_get_ordered_config_status_wo_f3() != OC_NOT_SET)
  {
    MSG_HIGH("Get OC set_status rrcllc_oc_set_status_e_type_value%d proc rrc_proc_e_type_value%d proc_st %d",
           ordered_config.set_status, ordered_config.set_by_proc,
           ordered_config.process_state);
  }
  *proc_ptr           = ordered_config.set_by_proc;
  *process_status_ptr = ordered_config.process_state;
  /* return the status of ordered_config.process_state variable */
  return ordered_config.set_status;

} /* end rrcllc_get_ordered_config_state_and_proc() */


 /*====================================================================
FUNCTION: rrcllc_get_ordered_config_state_and_proc_wo_f3()

DESCRIPTION:
  This function returns oc status. It also indicates which process
  has set the OC and process status.

DEPENDENCIES:
  None.

RETURN VALUE:
  Returns a value that indicates if Ordered Config is set for
  an RRC state or not set.

SIDE EFFECTS:
  None.
====================================================================*/
rrcllc_oc_set_status_e_type rrcllc_get_ordered_config_state_and_proc_wo_f3(
                                                   rrc_proc_e_type *proc_ptr,
                                                   rrcllc_oc_process_state_e_type *process_status_ptr
                                                    )
{
  *proc_ptr           = ordered_config.set_by_proc;
  *process_status_ptr = ordered_config.process_state;
  /* return the status of ordered_config.process_state variable */
  return ordered_config.set_status;

} /* end rrcllc_get_ordered_config_state_and_proc() */

 /*====================================================================
FUNCTION: rrcllc_reset_ordered_config()

DESCRIPTION:
  This function is used to reset the OC

DEPENDENCIES:
  None.

RETURN VALUE:
  Returns a value that indicates if Ordered Config is set for
  an RRC state or not set.

SIDE EFFECTS:
  None.
====================================================================*/
rrcllc_oc_set_status_e_type rrcllc_reset_ordered_config(
                                                   rrc_proc_e_type proc_id
                                                   ,boolean reset_toc

                                                    )
{

  MSG_4(MSG_SSID_DIAG, MSG_LEGACY_HIGH,"Reset OC state %d proc rrc_proc_e_type_value%d proc_st %d requested proc:%d",
           ordered_config.set_status, ordered_config.set_by_proc,
           ordered_config.process_state, proc_id);

  if (OC_NOT_SET == ordered_config.set_status)
  {
    WRRC_MSG0_HIGH("OC is not set");
  }
  if (ordered_config.process_state != LL_CONFIG_WITH_OC)
  {
    WRRC_MSG0_HIGH("Reseting OC while ll configured");
  }
  ordered_config.set_status    = OC_NOT_SET;
  ordered_config.process_state = LL_NOT_CONFIG_WITH_OC;
  ordered_config.set_by_proc   = RRC_PROCEDURE_NONE;
  /* Clear the boolean */
  ordered_config.notify_smc    = FALSE;

   ordered_config.reconfig_in_progress = FALSE;

  if ( RRC_STATE_CELL_DCH == rrc_get_state()
      && reset_toc                                        
       ) 
  {
     transition_config.toc_usage = TOC_INVALID;
  }
  else if (!reset_toc) 
  {
    WRRC_MSG0_HIGH("Setting TOC usage for OOS");


    if( transition_config.toc_usage == TOC_FOR_FACH_AND_PCH) 
    {
      transition_config.toc_usage = TOC_FOR_OOS_WITHOUT_DCH_INFO;
    }
    else if(transition_config.toc_usage == TOC_FOR_FACH_AND_PCH_WITH_DCH_INFO)
    {
      transition_config.toc_usage = TOC_FOR_OOS_WITH_DCH_INFO;
    }
    else
    {
      transition_config.toc_usage = TOC_FOR_OOS;
    }
  }
  config_ptr_in_use = CURRENT_CONFIG;
  return ordered_config.set_status;
} /* end rrcllc_reset_ordered_config() */

/*===================================================================
                         INTERNAL FUNCTIONS
=====================================================================*/
/* These functions are declared in rrcllcoc.h */


/*====================================================================
FUNCTION: rrcllc_init_rach_logical_channel_lists()

DESCRIPTION:
  This function initializes the RACH logical channel lists in the RLC
  size restriction info of the given database.
  Pointer to the database is passed as a parameter.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
static void  rrcllc_init_rach_logical_channel_lists(ordered_config_type *config_ptr)
{
  int i;
  rrcllcoc_logical_channel_list_type *rec = NULL;

  for(i = 0; i < UE_MAX_TF; i++)
  {
    rec = &(config_ptr->rach_rlc_size_restriction_info.logical_channel_list[i]);
    rec->restriction_type = RLC_SIZES_UNCONFIGURED;
    rec->count = 0;
    memset(rec->rb_id, RRC_INVALID_RB_ID, sizeof(rec->rb_id));
  }
}

/*====================================================================
FUNCTION: rrcllc_init_rach_rlc_size_lists()

DESCRIPTION:
  This function initializes the RACH rlc size lists in the RLC
  size restriction info of the given database.
  Pointer to the database is passed as a parameter.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
static void  rrcllc_init_rach_rlc_size_lists(ordered_config_type *config_ptr)
{
  int i;
  rrcllcoc_rlc_size_list_type *rec = NULL;

  for(i = 0; i < MAX_DED_LOGCHAN_PER_TRCH; i++)
  {
    rec = &(config_ptr->rach_rlc_size_restriction_info.rlc_size_list[i]);
    rec->rb_id = RRC_INVALID_RB_ID;
    rec->restriction_type = RLC_SIZES_UNCONFIGURED;
    rec->count = 0;
    memset(rec->size_idx, 0xff, sizeof(rec->size_idx));
  }
}


/*====================================================================
FUNCTION: rrcllc_reset_rach_rlc_size_lists()

DESCRIPTION:
  This function initializes the RACH rlc size lists in the RLC
  size restriction info of the given database.
  Pointer to the database is passed as a parameter.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void  rrcllc_reset_rach_rlc_size_lists(
  rrcllcoc_rlc_size_list_type *rec,
  uint8                        entry_to_remove,
  boolean remove_all
)
{
  int i;

  for(i = 0; i < MAX_DED_LOGCHAN_PER_TRCH; i++)
  {
    /*Restore a particular RB*/
    if((remove_all == FALSE) && (i != entry_to_remove))
    {
      continue;
    }
    rec[i].rb_id = RRC_INVALID_RB_ID;
    rec[i].restriction_type = RLC_SIZES_UNCONFIGURED;
    rec[i].count = 0;
    memset(rec[i].size_idx, 0xff, sizeof(rec[i].size_idx));
  }
}

#ifdef FEATURE_RRC_TFC_RLC_SIZE_FOR_DCH
/*====================================================================
FUNCTION: rrcllc_init_dch_logical_channel_lists()

DESCRIPTION:
  This function initializes the DCH logical channel lists in the RLC
  size restriction info of the given database.
  Pointer to the database is passed as a parameter.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void  rrcllc_init_dch_logical_channel_lists(ordered_config_type *config_ptr)
{
  int i, j;
  rrcllcoc_logical_channel_list_type *rec = NULL;

  for(j = 0; j < UE_MAX_TRCH; j++)
  {
    for(i = 0; i < UE_MAX_TF; i++)
    {
      rec = &(config_ptr->dch_rlc_size_restriction_info[j].logical_channel_list[i]);
      rec->restriction_type = RLC_SIZES_UNCONFIGURED;
      rec->count = 0;
      memset(rec->rb_id, RRC_INVALID_RB_ID, sizeof(rec->rb_id));
    }
  }
}

/*====================================================================
FUNCTION: rrcllc_init_dch_rlc_size_lists()

DESCRIPTION:
  This function initializes the DCH rlc size lists in the RLC
  size restriction info of the given database.
  Pointer to the database is passed as a parameter.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void  rrcllc_init_dch_rlc_size_lists(ordered_config_type *config_ptr)
{
  int i, j;
  rrcllcoc_rlc_size_list_type *rec = NULL;

  for(j = 0; j < UE_MAX_TRCH; j++)
  {
    for(i = 0; i < MAX_DED_LOGCHAN_PER_TRCH; i++)
    {
      rec = &(config_ptr->dch_rlc_size_restriction_info[j].rlc_size_list[i]);
      rec->rb_id = RRC_INVALID_RB_ID;
      rec->restriction_type = RLC_SIZES_UNCONFIGURED;
      rec->count = 0;
      memset(rec->size_idx, 0xff, sizeof(rec->size_idx));
    }
  }
}

#endif /* #ifdef FEATURE_RRC_TFC_RLC_SIZE_FOR_DCH */

#ifdef FEATURE_UMTS_PDCP
/*====================================================================
FUNCTION: rrcllc_init_pdcp_parms()

DESCRIPTION:
  This function initializes all PDCP related information.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_pdcp_parms(ordered_config_type *config_ptr)
{
  uint32 i;
  config_ptr->pdcp_parms.num_rbs = 0;

  for(i=0; i < MAX_RAB_TO_SETUP; i++)
  {
    config_ptr->pdcp_parms.pdcp_config_req[i].in_use = FALSE;
    config_ptr->pdcp_parms.pdcp_config_req[i].pdcp_info_changed = FALSE;
    config_ptr->pdcp_parms.pdcp_config_req[i].rb_id = RRC_INVALID_RB_ID;
    memset(&(config_ptr->pdcp_parms.pdcp_config_req[i].pdcp_cfg_req), 0, sizeof(pdcp_cfg_req_data_type)); 
    config_ptr->pdcp_parms.pdcp_config_req[i].pdcp_cfg_req.action = MAX_ACTION_PDCP;
    config_ptr->pdcp_parms.pdcp_config_req[i].pdcp_cfg_req.rb_id = RRC_INVALID_RB_ID;
  }
}
#endif /* FEATURE_UMTS_PDCP*/

/*====================================================================
FUNCTION        rrcllc_init_srb5_info()

DESCRIPTION     This function initializes SRB#5 data structures 
                with default values.

DEPENDENCIES    NONE

RETURN VALUE    void

SIDE EFFECTS
====================================================================*/
void rrcllc_init_srb5_info(ordered_config_type *config_ptr)
{
  memset((void *)&(config_ptr->srb5_info), 0, sizeof(rrcllc_srb5_info_type));
  config_ptr->srb5_info.srb5_rb_exists   = FALSE;
  config_ptr->srb5_info.rb_id            = RRCLLC_INVALID_RB_ID;
  config_ptr->srb5_info.srb5_trch_exists = FALSE;
  config_ptr->srb5_info.trch_id          = RRCLLC_INVALID_TRCH_ID;
  config_ptr->srb5_info.lc_id            = RRCLLC_INVALID_LC_ID;
} /* rrcllc_init_srb5_info */

/*====================================================================
FUNCTION        rrcllc_has_config_srb5()

DESCRIPTION     This function tells if the passed RB Id maps to SRB#5 
                or not.

DEPENDENCIES    NONE

RETURN VALUE    boolean
                TRUE: If RB Id is same as SRB#5 Id.
                FALSE: otherwise

SIDE EFFECTS
====================================================================*/
boolean rrcllc_has_config_srb5
(
  rrcllc_config_e_type config_type, 
  uint16 rb_id
)
{
  boolean srb5_status = FALSE;
  ordered_config_type *config_ptr = NULL;

  if(ORDERED_CONFIG == config_type)
  {
    config_ptr = ordered_config_ptr;
  }
  else if(CURRENT_CONFIG ==  config_type)
  {
    config_ptr = current_config_ptr;
  }
  else if(TRANSITION_CONFIG == config_type)
  {
    config_ptr = transition_config.toc_ptr;
  }

  if(config_ptr != NULL)
  {
    if(config_ptr->srb5_info.srb5_rb_exists == TRUE &&
       config_ptr->srb5_info.rb_id == rb_id)
    {
      srb5_status = TRUE;
      WRRC_MSG0_HIGH("Config has SRB#5");
    }
  }

  return srb5_status; 
} /* rrcllc_has_config_srb5 */

/*====================================================================
FUNCTION: rrcllc_init_cpc_dtx_params()

DESCRIPTION:
  This function initializes the CPC DTX config database.
  Pointer to the database is passed as a parameter.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
static void  rrcllc_init_cpc_dtx_params
(
  ordered_config_type *config_ptr
)
{
  config_ptr->l1_cpc_dtx_req_mask= L1_CPC_DTX_NO_OP;
  rrcllc_init_dtx_params(config_ptr);
}

/*====================================================================
FUNCTION: rrcllc_init_cpc_drx_params()

DESCRIPTION:
  This function initializes the CPC DRX config database.
  Pointer to the database is passed as a parameter.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void  rrcllc_init_cpc_drx_params
(
  ordered_config_type *config_ptr
)
{
  config_ptr->l1_cpc_drx_req_mask= L1_CPC_DRX_NO_OP;
  rrcllcpcie_init_drx_info_before_processing(config_ptr);
}


/*====================================================================
FUNCTION: rrcllc_init_config_data()

DESCRIPTION:
  This function initializes the config database.
  Pointer to the database is passed as a parameter.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void  rrcllc_init_config_data(
  ordered_config_type *config_ptr,
  rrc_state_e_type  rrc_state
  )
{

  if(config_ptr == NULL)
  {
    WRRC_MSG0_HIGH("CC/OC/TOC already freed.");
    return;
  }

  /* Initialize all pointers in L1, MAC and RLC structures */
  rrcllc_init_mac_dl_ptrs(config_ptr);
  rrcllc_init_mac_ul_ptrs(config_ptr);
  rrcllc_init_l1_dl_ptrs(config_ptr);
  rrcllc_init_l1_ul_ptrs(config_ptr);
  rrcllc_init_rlc_ptrs(config_ptr);

  /* Initialize RNTI (C-RNTI and U-RNTI) info */
  rrcllc_init_rnti_info(config_ptr);

  /*** Initialize Downlink Info ***/
  /* Initialize BCH Info */
  rrcllc_init_bch_info(config_ptr);
  /* Initialize PCH Info */
  rrcllc_init_pch_info(config_ptr);
  /* Initialize FACH Info */
  rrcllc_init_fach_info(config_ptr, TRUE);
  /* Initialize DL DCH  Info */
  rrcllc_init_dl_dch_info(config_ptr);
  /* Initialize Downlink CCTrCH Info */
  rrcllc_init_dl_cctrch_info(config_ptr);
  /* Initialize Downlink CTFC Info */
  rrcllc_init_dl_ctfcs(config_ptr);
  rrcllc_init_dl_ctfcs_for_sccpch_with_ctch(config_ptr);
  rrcllc_init_cbs_info(config_ptr);
  /* Initialize Downlink DPCH Channel Info */
  rrcllc_init_l1_dl_dpch_chan_info(config_ptr);
  /* Initialize Downlink SCCPCH Channel Info */
  rrcllc_init_l1_sccpch_chan_info(config_ptr);

  /*** Initialize Uplink Info ***/
  /* Initialize RACH Info */
  rrcllc_init_rach_info(config_ptr, TRUE);
  /* Initialize Uplink DCH Info */
  rrcllc_init_ul_dch_info(config_ptr);
  /* Initialize Uplink DPCH Channel Info */
  rrcllc_l1_ul_dpch_chan_info(config_ptr);

  /*** Initialize RLC Logical Channel Info ***/
  /* Initialize RLC Info */
  if(rrc_state == RRC_STATE_CONNECTING)
  {
    WRRC_MSG2_HIGH("Current DL TM in OC nchan %d and DL TM nchan with LCM is %d",
                  config_ptr->rlc_dl_tm_parms.nchan,rrclcm_get_nchan_dl_tm());
  }
  rrcllc_init_rlc_parms(config_ptr);
  if(rrc_state == RRC_STATE_CONNECTING)
  {
    config_ptr->rlc_dl_tm_parms.nchan = rrclcm_get_nchan_dl_tm();
  }
  /* Initialize the Activation Time */
  rrcllc_init_activation_time(config_ptr);

  /* Invalidate RM Restriction Info */
  set_dl_rm_restriction_info_to_invalid(&config_ptr->rm_restrict);
  /* Invalidate RM Restriction Info */
  set_dl_rm_restriction_info_to_invalid(&config_ptr->rm_restrict_for_sccpch_with_ctch);

  /* Initaialize Reconfig needed */
  rrcllc_init_reconfig_needed(config_ptr);

  /***************************************************/
  /* Initialize Transport Channel Counts for UL & DL */
  /***************************************************/
  /* The ordered RRC State */
  config_ptr->rrc_state_indicator = rrc_state;
  /*initialize the destination freq */
  config_ptr->dest_freq_present = FALSE;
  config_ptr->dest_psc_present = FALSE;

  /* Initialize the CS and PS Drx Cycle Length */
  config_ptr->cs_drx_cycle_length = 0;
  config_ptr->ps_drx_cycle_length = 0;
  config_ptr->utran_drx_cycle_length = 0;


  /* Initialize RLC size restriction info */
  rrcllc_init_rach_rlc_size_lists(config_ptr);
  rrcllc_init_rach_logical_channel_lists(config_ptr);
#ifdef FEATURE_RRC_TFC_RLC_SIZE_FOR_DCH
  rrcllc_init_dch_rlc_size_lists(config_ptr);
  rrcllc_init_dch_logical_channel_lists(config_ptr);
#endif


  rrcllc_init_hsdpa_l1_info(config_ptr);
  rrcllc_init_hsdpa_mac_info(config_ptr);

  rrc_set_hrnti_status(config_ptr,HRNTI_INVALID);

  rrcllc_init_hsdpa_mac_ehs_info(config_ptr);
#ifdef FEATURE_WCDMA_HS_FACH
  rrcenhstate_init_efach_mapping(config_ptr);
  if(RRC_STATE_DISCONNECTED == rrc_state)
  {
    config_ptr->efach_hrnti_status = INVALID_HRNTI;
    rrcenhstate_init_efach_queues(config_ptr);
  }
#endif

#ifdef FEATURE_WCDMA_HS_FACH
  if (RRC_STATE_DISCONNECTED == rrc_state)
  {
    WRRC_MSG0_HIGH("EFACH: State: RRC_STATE_DISCONNECTED, hence resetting e_fach:status, action, rb_mapping_info");
  rrcllc_set_hs_status_in_e_fach(config_ptr, FALSE);
  rrcllc_set_hs_action_in_e_fach(config_ptr, HSDPA_NOOP);
  }
  else
  {
    rrcllc_set_hs_action_in_e_fach(config_ptr, HSDPA_NOOP);
  }
#endif /*FEATURE_WCDMA_HS_FACH*/


  if (RRC_STATE_DISCONNECTED == rrc_state)
  {
    WRRC_MSG0_HIGH("RRCEUL: State: RRC_STATE_DISCONNECTED, hence resetting mac-e, e-dl, e-ul information");
    rrcllc_init_mac_e_info(config_ptr);
    rrcllc_init_l1_e_ul_info(TRUE, config_ptr);
    rrcllc_init_l1_e_dl_info(TRUE, FALSE,config_ptr);
    config_ptr->l1_e_req_mask = L1_EUL_NOOP;
    config_ptr->mac_eul_action = MAC_EUL_NOOP;    
	
#ifdef FEATURE_WCDMA_HS_RACH
    /*Initialise HSRACH structures and actions while going to disconnected state*/
    rrcllc_init_hsrach_info(config_ptr,rrc_state);
    rrcllc_init_hs_rach_info(config_ptr);
    config_ptr->l1_hs_rach_req_mask = L1_HS_RACH_NO_OP;
    config_ptr->mac_hs_rach_action = MAC_HS_RACH_NOOP;
    config_ptr->hs_rach_to_eul_trans = FALSE;
    rrchsrach_set_hspa_rnti_stored_cell_pch(config_ptr, FALSE);
#endif

#ifdef FEATURE_VOC_AMR_WB
    /* Reset the current codec to the default mode */
    rrc_set_current_codec_mode(MVS_MODE_AMR);
    rrc_set_ordered_codec_mode(MVS_MODE_NONE);
#endif /*FEATURE_VOC_AMR_WB*/
#ifdef FEATURE_WCDMA_DC_HSUPA
      rrcllc_init_mac_sec_eul_e_info(config_ptr);
      config_ptr->l1_sec_e_req_mask = L1_EUL_NOOP;
      config_ptr->sec_eul_is_hho = FALSE;
      config_ptr->sec_ul_asu = FALSE;
      rrcllc_init_l1_sec_e_ul_info(config_ptr);    
      rrcllc_init_l1_sec_e_dl_info(TRUE, TRUE,config_ptr);
      rrcllc_init_l1_dl_sec_fdpch_chan_info(config_ptr);
      
#endif
#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
    rrcdata_reset_buffed_ota_info();
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/

  }
  else
  {
    WRRC_MSG2_MED("RRCEUL: State: %d <not IDLE>, resetting selective eul information, cc(e_dch_tx)=%d", 
      rrc_state, current_config_ptr->e_dch_transmission);
    rrcllc_init_mac_e_info(config_ptr);
    /*If previously EUL is not active then clear e_tti in connected mode*/
    rrcllc_init_l1_e_ul_info(FALSE, config_ptr);
    rrcllc_init_l1_e_dl_info(FALSE, FALSE,config_ptr);
    config_ptr->l1_e_req_mask = L1_EUL_NOOP;

#ifdef FEATURE_WCDMA_DC_HSUPA

    rrcllc_init_mac_sec_ul_edch_info_ie(config_ptr);
    rrcllc_init_l1_sec_e_ul_info(config_ptr);    
    rrcllc_init_l1_sec_e_dl_info(FALSE, FALSE,config_ptr);
    config_ptr->mac_sec_eul_action = MAC_SEC_EUL_NOOP;
    config_ptr->l1_sec_e_req_mask = L1_EUL_NOOP;
    config_ptr->sec_eul_is_hho = FALSE;
    config_ptr->sec_ul_asu = FALSE;
    rrcllc_init_l1_dl_sec_fdpch_chan_info(config_ptr);


    
#endif

  }

#ifdef FEATURE_UMTS_PDCP
  rrcllc_init_pdcp_parms(config_ptr);
#endif /* FEATURE_UMTS_PDCP */

  rrcllc_init_srb5_info(config_ptr);

  rrcllc_init_fdpch_info(config_ptr);

#ifdef FEATURE_WCDMA_MIMO
  rrcllc_init_mimo_params(config_ptr);
#endif

#ifdef FEATURE_WCDMA_DC_HSDPA
  /*Notice that we will reset the global rrc_sec_hsdpa_status also*/
  rrcllc_init_sec_hsdpa_params(config_ptr);
#endif /*FEATURE_WCDMA_DC_HSDPA*/

  config_ptr->mac_ul_parms.new_tfcs_list_present = FALSE;

/* init cpc-DTX-DRX ptrs here*/
rrcllc_init_cpc_dtx_params(config_ptr);

  rrcllc_init_cpc_drx_params(config_ptr);
  if(rrc_state != RRC_STATE_CELL_DCH)
  {
    rrc_set_predefined_po3_status(FALSE);
	   rrc_predef_po3_not_needed = FALSE;
  }

} /* rrcllc_init_config_data */

/*====================================================================
FUNCTION: rrcllc_init_ordered_config_status_and_data()

DESCRIPTION:
  This function initializes the ordered_config database. It sets up
  the ordered_config_ptr and current_config_ptr, as well as
  initializing all data.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_ordered_config_status_and_data(
  rrc_state_e_type  rrc_state
  )
{
  uint8 i;
  /* Initialize the ordered_reconfiguration to FALSE, i.e. no pending
  * ORDERED_RECONFIGURATION.
  */
  ordered_config.set_status = OC_NOT_SET;
  ordered_config.notify_smc = FALSE;
  ordered_config.process_state = LL_NOT_CONFIG_WITH_OC;
  ordered_config.set_by_proc = RRC_PROCEDURE_NONE;
  ordered_config.reconfig_in_progress = FALSE;

  config_ptr_in_use = CURRENT_CONFIG;


  if((NULL != rrc_current_hanging_rb_mapping) && (NULL != rrc_ordered_hanging_rb_mapping))
  {
  /* Init the Rb_mapping database with default values*/
  for(i=0;i<MAX_HANGING_RB_MAPPING_INFO;i++)
  {
    memset(&rrc_current_hanging_rb_mapping[i],0,sizeof(rb_mapping_info_type));
    rrc_current_hanging_rb_mapping[i].in_use = FALSE;  
  }
  rrcllc_init_ordered_hanging_rb_mapping_info();
  }
  else
  {
    WRRC_MSG0_HIGH("Hanging RBs already freed");
  }

  if(ordered_config_ptr == NULL)
  {
    WRRC_MSG0_HIGH("OC already freed.");
  }
  else
  {
    rrcllc_init_config_data(ordered_config_ptr, rrc_state);
  }

  return;
} /* end rrcllc_init_ordered_config_status_and_data() */

/*====================================================================
FUNCTION: rrcllc_init_ordered_config_mac_info()

DESCRIPTION:
  This function initializes the MAC Info in Config database.
DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_ordered_config_mac_info
(
  rrcllc_config_e_type config_type
)
{
  ordered_config_type  *config_ptr;
  /* This function effectively sets all kinds of
   * Downlink and Uplink Transport Channels in MAC
   * to 0. It also invalidates RNTI info.
   */
  if(config_type == ORDERED_CONFIG)
  {
    config_ptr = ordered_config_ptr;
  }
  else
  {
    config_ptr = current_config_ptr;
  }

  rrcllc_init_mac_dl_ptrs(config_ptr);
  rrcllc_init_mac_ul_ptrs(config_ptr);
  /* Initialize RNTI (C-RNTI and U-RNTI) info */
  rrcllc_init_rnti_info(config_ptr);

  /*** Initialize Downlink Info ***/
  /* Initialize BCH Info */
  rrcllc_init_bch_info(config_ptr);
  /* Initialize PCH Info */
  rrcllc_init_pch_info(config_ptr);
  /* Initialize FACH Info */
  rrcllc_init_fach_info(config_ptr, TRUE);
  /* Initialize DL DCH  Info */
  rrcllc_init_dl_dch_info(config_ptr);


  rrcllc_init_hsdpa_mac_info(config_ptr);


  rrcllc_init_hsdpa_mac_ehs_info(config_ptr);

#ifdef FEATURE_WCDMA_HS_FACH
  rrcenhstate_init_efach_mapping(config_ptr);
  rrcenhstate_init_efach_queues(config_ptr);
#endif

  /*** Initialize Uplink Info ***/
  /* Initialize RACH Info */
  rrcllc_init_rach_info(config_ptr, TRUE);
  /* Initialize Uplink DCH Info */
  rrcllc_init_ul_dch_info(config_ptr);

  rrcllc_init_mac_e_info(config_ptr);
#ifdef FEATURE_WCDMA_DC_HSUPA
  rrcllc_init_mac_sec_eul_e_info(config_ptr);
#endif /* FEATURE_WCDMA_DC_HSUPA */

} /* rrcllc_init_ordered_config */

/*====================================================================
FUNCTION: rrcllc_init_rlc_parms()

DESCRIPTION:
  This function initializes the Number of channels and Number of
  entities in RLC parameters to 0.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_rlc_parms(ordered_config_type  *config_ptr)
{
  uint8  ix;
  /* Init the local AM data pointers, DL & UL channel counts */
  config_ptr->rlc_am_parms.nentity = 0;

  for(ix = 0; ix < UE_MAX_AM_ENTITY; ix++)
  {
    config_ptr->am_config[ix].ul_nchan =
    config_ptr->am_config[ix].dl_nchan = 0;
    config_ptr->am_config[ix].rlc_ul_am_config.rlc_info.rlc_info_incl =
    config_ptr->am_config[ix].rlc_dl_am_config.rlc_info.rlc_info_incl = FALSE;
    config_ptr->am_config[ix].reestab_entity = RLC_RE_ESTABLISH_NONE;
    rrcllc_init_am_dl_rlc_size(config_ptr,ix);
    config_ptr->am_config[ix].rlc_ul_am_config.special_value_he_config = 
    config_ptr->am_config[ix].rlc_dl_am_config.special_value_he_config = FALSE;

#ifdef FEATURE_MAC_I
  config_ptr->am_config[ix].rlc_ul_am_config.ul_flex_min_pdu_size = RRC_UL_INVALID_RLC_SIZE;
  config_ptr->am_config[ix].rlc_ul_am_config.ul_flex_pdu_size= RLC_INVALID_PDU_SIZE;
  config_ptr->am_config[ix].rlc_ul_am_config.ul_li_size= LI_UNSPECIFIED;
  config_ptr->rlc_one_sided_reest[ix] = FALSE;
#endif /* FEATURE_MAC_I */
  }

  config_ptr->rlc_dl_tm_parms.nchan = 0;
  config_ptr->rlc_dl_um_parms.nchan = 0;
  config_ptr->rlc_ul_tm_parms.nchan = 0;
  config_ptr->rlc_ul_um_parms.nchan = 0;
  
  for(ix =0; ix < UE_MAX_UL_UM_CHANNEL; ix++)
  {
    config_ptr->rlc_ul_um_parms.chan_info[ix].rb_id = RRCLLC_INVALID_RB_ID ;
    config_ptr->rlc_ul_um_parms.chan_info[ix].timer_discard = 0;
    config_ptr->rlc_ul_um_parms.chan_info[ix].alternate_e_bit = FALSE;
  }
  
  for(ix =0; ix < UE_MAX_DL_UM_CHANNEL; ix++)
  {
    config_ptr->rlc_dl_um_parms.chan_info[ix].rb_id = RRCLLC_INVALID_RB_ID ;
    config_ptr->rlc_dl_um_parms.chan_info[ix].alternate_e_bit = FALSE;
  }

}

/*====================================================================
FUNCTION: rrcllc_init_rnti_info()

DESCRIPTION:
  This function initializes the RNTI info in Uplink and Downlink
  MAC parameter data to NO RNTI VALID.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void  rrcllc_init_rnti_info(ordered_config_type  *config_ptr)
{
  config_ptr->mac_dl_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
  config_ptr->mac_ul_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
}

/*====================================================================
FUNCTION: rrcllc_init_activation_time()

DESCRIPTION:
  This function initializes the Activation Time to Avtivation Time
  NONE. This is equivalent to saying the Avtivation Time is "Now".

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void  rrcllc_init_activation_time(ordered_config_type  *config_ptr)
{
  config_ptr->act_time_type = L1_ACTIVATION_TIME_NONE;
}

/*====================================================================
FUNCTION: rrcllc_init_reconfig_needed()

DESCRIPTION:
  This function initializes the Reconfig Needed structure.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_reconfig_needed(ordered_config_type  *config_ptr)
{
  config_ptr->reconfig_needed.downlink_l1 = FALSE;
  config_ptr->reconfig_needed.downlink_mac = FALSE;
  config_ptr->reconfig_needed.uplink_l1 = FALSE;
  config_ptr->reconfig_needed.uplink_mac = FALSE;
}

/*====================================================================
FUNCTION: rrcllc_init_l1_dl_dpch_chan_info()

DESCRIPTION:
  This function initializes the Downlink DPCH related channel info
  that goes to L1.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void  rrcllc_init_l1_dl_dpch_chan_info(ordered_config_type  *config_ptr)
{
  uint8  rl_count;

  config_ptr->l1_dl_chan_parms.dl_common.dpch_common.opt_parm_present_mask = 0;
  config_ptr->l1_dl_chan_parms.dl_common.dpch_common.timing_ind =
    L1_TIMING_IND_MAINTAIN;
  config_ptr->cm_info.tgp_seq_info_count = 0;
  rl_count = 0;
  /* Now initialize the action_needed variable */
  while (rl_count< L1_CM_MAX_TGP_SEQ_COUNT)
  {
    config_ptr->tgp_seq_info[rl_count].tgp_seq_id = 0;
    config_ptr->tgp_seq_info[rl_count].info_valid = FALSE;
    config_ptr->cm_info.action_needed[rl_count++] = FALSE;
  }
  /* Initialize the Downlink RL information. */
  /* Number of PhyChan Radio Links (RLs) */
  config_ptr->l1_dl_chan_parms.num_rl = 0;

  for (rl_count = 0; rl_count < UE_MAX_RL; rl_count++)
  {
    rrcllc_init_dl_rl_info(config_ptr, rl_count
#ifdef FEATURE_WCDMA_DC_HSUPA
                            ,FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */

                            );
  }
}

/*====================================================================
FUNCTION: rrcllc_init_l1_sccpch_chan_info()

DESCRIPTION:
  This function initializes the SCCPCH related channel info
  that goes to L1.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void  rrcllc_init_l1_sccpch_chan_info(ordered_config_type  *config_ptr)
{
  uint8  sccpch_count;
  for(sccpch_count = 0; sccpch_count < MAX_SCCPCH; sccpch_count ++)
  {
    config_ptr->l1_dl_chan_parms.sccpch[sccpch_count].
      opt_parm_present_mask = 0;
  }
  config_ptr->l1_dl_chan_parms.use_pich = FALSE;

}



/*====================================================================
FUNCTION: rrcllc_init_l1_sccpch_for_ctch_chan_info()

DESCRIPTION:
  This function initializes the SCCPCH (used for ctch) related channel info
  that goes to L1.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void  rrcllc_init_l1_sccpch_for_ctch_chan_info(ordered_config_type  *config_ptr)
{
     config_ptr->l1_dl_chan_parms.sccpch[1].
      opt_parm_present_mask = 0;

     config_ptr->l1_dl_chan_parms.use_pich = FALSE;

}

/*====================================================================
FUNCTION: rrcllc_init_bch_info()

DESCRIPTION:
  This function initializes the BCH transport channel related info.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_bch_info(ordered_config_type *config_ptr)
{
  config_ptr->mac_dl_parms.num_bchs = 0;
}

/*====================================================================
FUNCTION: rrcllc_init_pch_info()

DESCRIPTION:
  This function initializes the PCH transport channel related info.
  This also includes releasing the PCH TrCH index and setting "PCH
  Included" to FALSE for LLC.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_pch_info(ordered_config_type *config_ptr)
{
  config_ptr->mac_dl_parms.num_pchs = 0;
  rrcllc_init_dl_pch_trch_idx(config_ptr);
  /* Reflect the status of no PCH in LLC */
  rrcllc_set_pch_included(FALSE);
}

/*====================================================================
FUNCTION: rrcllc_init_fach_info()

DESCRIPTION:
  This function initializes the FACH transport channel related info.
  This also includes releasing all FACH TrCH indices, setting
  "FACH Included" to FALSE for LLC and initializing the FACH RB
  Mapping Info.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_fach_info(ordered_config_type *config_ptr, boolean init_rb_mapping_info)
{
  uint8  trch_index;

  config_ptr->mac_dl_parms.num_fachs = 0;

  rrcllc_init_dl_fach_trch_idx_info(config_ptr);

  /* Reflect the status of no FACH in LLC */
  rrcllc_set_fach_included(FALSE);

  if(init_rb_mapping_info)
  {
    for(trch_index = 0; trch_index < UE_MAX_TRCH; trch_index ++)
    {
      rrcllc_init_fach_rb_mapping_info(config_ptr, trch_index);
    }
  }
}

/*====================================================================
FUNCTION: rrcllc_init_dl_dch_info()

DESCRIPTION:
  This function initializes the DL DCH transport channel related info.
  This also includes releasing all DL DCH TrCH indices and
  initializing the DL DCH RB Mapping Info.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_dl_dch_info(ordered_config_type *config_ptr)
{
  uint8  trch_index;
  config_ptr->mac_dl_parms.num_dchs = 0;

  rrcllc_init_dl_dch_trch_idx_info(config_ptr);

  for(trch_index = 0; trch_index < UE_MAX_TRCH; trch_index ++)
  {
    rrcllc_init_dl_dch_rb_mapping_info(config_ptr, trch_index);
  }
}

/*====================================================================
FUNCTION: rrcllc_init_cbs_info()

DESCRIPTION:
  This function initializes the CBS related info.  Sets the flag that
  indicated to L1 that ctch info is present to FALSE.


DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_cbs_info(ordered_config_type *config_ptr)
{
  uint8  sccpch_count;
  for(sccpch_count = 0; sccpch_count < MAX_SCCPCH; sccpch_count ++)
  {
    config_ptr->l1_dl_chan_parms.sccpch[sccpch_count].cbs_sched.ctch_info_present = FALSE;
  }

}


/*====================================================================
FUNCTION: rrcllc_init_dl_cctrch_info_for_sccpch_with_ctch()

DESCRIPTION:
  This function initializes the DL CCTrCH Info for L1.
  This includes setting the number of transport channels for this
  CCTrCH to 0 and initializing the Transport Format Set.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_dl_cctrch_info_for_sccpch_with_ctch(ordered_config_type *config_ptr)
{
  uint8  trch_index;
  config_ptr->l1_dl_cctrch_parms_for_sccpch_with_ctch.num_trch = 0;

  for(trch_index = 0; trch_index < L1_MAX_TRCH; trch_index ++)
  {
    rrcllc_init_dl_tfs_table(config_ptr, trch_index);
  }
}


/*====================================================================
FUNCTION: rrcllc_init_dl_ctfcs_for_sccpch_with_ctch()

DESCRIPTION:
  This function initializes the Downlink TFI table. This is
  called whenever the DL CCTrCH type changes (i.e. a state change),
  or when a TrCH is deleted..

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_dl_ctfcs_for_sccpch_with_ctch(ordered_config_type *config_ptr)
{
  /* local variables */
  uint8 ix, iy;

  config_ptr->l1_dl_ctfc_parms_for_sccpch_with_ctch.last_ctfc_entry_index = RRC_DL_INVALID_CTFC_VALUE;

  /* Initialize the array count */
  config_ptr->dl_ctfc_for_sccpch_with_ctch.last_ctfc_entry_index = RRC_DL_INVALID_CTFC_VALUE;

  /* Clear out the downlink ctfc */
  for(ix = 0; ix < UE_MAX_TFC; ix++)
  {
    /* Clear out the ctfc array */
    config_ptr->dl_ctfc_for_sccpch_with_ctch.ctfc_entry_data[ix].ctfc_value = 0;
    config_ptr->dl_ctfc_for_sccpch_with_ctch.ctfc_entry_data[ix].state = INVALID;

    for(iy = 0; iy < UE_MAX_TRCH; iy++)
    {
      config_ptr->dl_ctfc_for_sccpch_with_ctch.ctfc_entry_data[ix].tfi_table[iy] = 0;
    }

    /* clear out valid ctfc field */
    config_ptr->l1_dl_ctfc_parms_for_sccpch_with_ctch.ctfc_entry_array[ix]->valid_ctfc = FALSE;
    config_ptr->l1_dl_ctfc_parms_for_sccpch_with_ctch.ctfc_entry_array[ix]->tfi_table = NULL;
  }

  return;
} /* end rrcllc_init_dl_ctfcs_for_sccpch_with_ctch */

/*====================================================================
FUNCTION: rrcllc_init_dl_cctrch_info()

DESCRIPTION:
  This function initializes the DL CCTrCH Info for L1.
  This includes setting the number of transport channels for this
  CCTrCH to 0 and initializing the Transport Format Set.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_dl_cctrch_info(ordered_config_type *config_ptr)
{
  uint8  trch_index;
  config_ptr->l1_dl_cctrch_parms.num_trch = 0;

  config_ptr->l1_dl_cctrch_parms_for_sccpch_with_ctch.num_trch = 0;

  for(trch_index = 0; trch_index < L1_MAX_TRCH; trch_index ++)
  {
    rrcllc_init_dl_tfs_table(config_ptr, trch_index);
  }
}

/*====================================================================
FUNCTION: rrcllc_init_dl_ctfcs()

DESCRIPTION:
  This function initializes the Downlink TFI table. This is
  called whenever the DL CCTrCH type changes (i.e. a state change),
  or when a TrCH is deleted..

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_dl_ctfcs(ordered_config_type *config_ptr)
{
  /* local variables */
  uint8 ix, iy;

  config_ptr->l1_dl_ctfc_parms.last_ctfc_entry_index = RRC_DL_INVALID_CTFC_VALUE;

  /* Initialize the array count */
  config_ptr->dl_ctfc.last_ctfc_entry_index = RRC_DL_INVALID_CTFC_VALUE;

  /* Clear out the downlink ctfc */
  for(ix = 0; ix < UE_MAX_TFC; ix++)
  {
    /* Clear out the ctfc array */
    config_ptr->dl_ctfc.ctfc_entry_data[ix].ctfc_value = 0;
    config_ptr->dl_ctfc.ctfc_entry_data[ix].state = INVALID;

    for(iy = 0; iy < UE_MAX_TRCH; iy++)
    {
      config_ptr->dl_ctfc.ctfc_entry_data[ix].tfi_table[iy] = 0;
    }

    /* clear out valid ctfc field */
    config_ptr->l1_dl_ctfc_parms.ctfc_entry_array[ix]->valid_ctfc = FALSE;
    config_ptr->l1_dl_ctfc_parms.ctfc_entry_array[ix]->tfi_table = NULL;
  }

  return;
} /* end rrcllc_init_dl_ctfcs */

/*====================================================================
FUNCTION: rrcllc_l1_ul_dpch_chan_info()

DESCRIPTION:
  This function initializes the UL DPCH Physical Channel Related Info.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_l1_ul_dpch_chan_info(ordered_config_type  *config_ptr)
{
  config_ptr->l1_ul_chan_parms.dpch_cfg.num_dpdch = 0;
}

/*====================================================================
FUNCTION: rrcllc_init_rach_info()

DESCRIPTION:
  This function initializes the RACH Transport Channel Related Info.
  Since there can be only one Uplink Physical Channel at any time,
  initializing RACH info also results in initialization of:
  - MAC UL CCTrCH type to INVALID
  - Number of TrCHs in Uplink TFCS
  - Number of TrCHs in L1 Uplink CCTrCH parameters
  - Uplink TFCS table
  - Uplink TFS for all TrCHs.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_rach_info(ordered_config_type *config_ptr, boolean init_rb_map_info)
{
  uint8  trch_index;

  config_ptr->mac_ul_parms.cctrch_ptr->cctrch_type = INVALID_UL_CCTRCH;

  /* Since RACH Info is being initialized, initialize number of
   * Transport channels in TFCS Info and L1 UL CCTrCH parameters to 0
   */
  config_ptr->mac_ul_parms.tfcs_ptr->nchan = 0;
  config_ptr->l1_ul_cctrch_parms.num_trch = 0;

  /* Release the RACH TrCH Index and initialize local info */
  rrcllc_init_ul_rach_trch_idx_info(config_ptr);
  if (init_rb_map_info)
  {
    /* Initialize RACH RB Mapping Info */
    rrcllc_init_rach_rb_mapping_info(config_ptr);
  }

  /* Initialize the TFCS Info */
  rrcllc_init_ul_tfi_table(config_ptr);
  /* Init ATF info to default values */
  config_ptr->mac_ul_parms.cctrch_ptr->rach_info.atf_present = FALSE;
  
  config_ptr->mac_ul_parms.cctrch_ptr->rach_info.atf_ccch_tf_index = 0;

  /* Initialize the UL TFS info for all transport channels */
  for(trch_index = 0; trch_index < UE_MAX_TRCH; trch_index ++)
  {
    rrcllc_init_ul_tfs_table(config_ptr, trch_index);
  }
}

#ifdef FEATURE_RRC_TFC_RLC_SIZE_FOR_DCH 
/*====================================================================
FUNCTION: rrcllc_init_dch_rlc_size_info()

DESCRIPTION:
  This function initializes the DCH RLC size restriction info for the
  given transport channel identity.  Any existing RLC size restriction
  information is cleared out.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_dch_rlc_size_info(tr_ch_id_type trch_id)
{
  uint8 i, j;
  rrcllcoc_rlc_size_restriction_info_type *rec;

  if(trch_id < UE_MAX_TRCH)
  {
    rec = &(ordered_config_ptr->dch_rlc_size_restriction_info[trch_id]);
    rec->mac_update_needed = FALSE;
    for(i = 0; i < MAX_DED_LOGCHAN_PER_TRCH; i++)
    {
      rec->rlc_size_list[i].rb_id = RRC_INVALID_RB_ID;
      rec->rlc_size_list[i].restriction_type = RLC_SIZES_UNCONFIGURED;
      rec->rlc_size_list[i].count = 0;
      for(j = 0; j < UE_MAX_TF; j++)
      {
        rec->rlc_size_list[i].size_idx[j] = 0;
      }
    }
    for(i = 0; i < UE_MAX_TF; i++)
    {
      rec->logical_channel_list[i].restriction_type = RLC_SIZES_UNCONFIGURED;
      rec->logical_channel_list[i].count = 0;
      for(j = 0; j < 15; j++)
      {
        rec->logical_channel_list[i].rb_id[j] = RRC_INVALID_RB_ID;
      }
    }
  }
} /* end rrcllc_init_dch_rlc_size_info() */


#endif  /*  FEATURE_RRC_TFC_RLC_SIZE_FOR_DCH */

/*====================================================================
FUNCTION: rrcllc_init_fach_rlc_size_info()

DESCRIPTION:
  This function initializes the FACH RLC size restriction info.
  Any existing RLC size restriction information is cleared out.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_fach_rlc_size_info(void)
{
  uint8 i, j;
  rrcllcoc_rlc_size_restriction_info_type *rec;

  rec = &(ordered_config_ptr->rach_rlc_size_restriction_info);
  rec->mac_update_needed = FALSE;
  for(i = 0; i < MAX_DED_LOGCHAN_PER_TRCH; i++)
  {
    rec->rlc_size_list[i].rb_id = RRC_INVALID_RB_ID;
    rec->rlc_size_list[i].restriction_type = RLC_SIZES_UNCONFIGURED;
    rec->rlc_size_list[i].count = 0;
    for(j = 0; j < UE_MAX_TF; j++)
    {
      rec->rlc_size_list[i].size_idx[j] = 0;
    }
  }
  for(i = 0; i < UE_MAX_TF; i++)
  {
    rec->logical_channel_list[i].restriction_type = RLC_SIZES_UNCONFIGURED;
    rec->logical_channel_list[i].count = 0;
    for(j = 0; j < 15; j++)
    {
      rec->logical_channel_list[i].rb_id[j] = RRC_INVALID_RB_ID;
    }
  }
} /* end rrcllc_init_fach_rlc_size_info() */


/*====================================================================
FUNCTION: rrcllc_init_ul_dch_info()

DESCRIPTION:
  This function initializes the UL DCH Transport Channel Related Info.
  Since there can be only one Uplink Physical Channel at any time,
  initializing UL DCH info also results in initialization of:
  - MAC UL CCTrCH type to INVALID
  - Number of TrCHs in Uplink TFCS
  - Number of TrCHs in L1 Uplink CCTrCH parameters
  - Uplink TFCS table
  - Uplink TFS for all TrCHs.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_ul_dch_info(ordered_config_type *config_ptr)
{
  uint8  trch_index;
  #ifdef FEATURE_RRC_TFC_RLC_SIZE_FOR_DCH
  tr_ch_id_type trch_id;
#endif

  config_ptr->mac_ul_parms.cctrch_ptr->cctrch_type = INVALID_UL_CCTRCH;
  /* Initialize number of UL DCHs to 0 */
  config_ptr->mac_ul_parms.cctrch_ptr->dch_info.ndchs = 0;

  /* Initialize loopback mode */
  config_ptr->mac_ul_parms.cctrch_ptr->dch_info.loopback_test_mode =
    MAC_LOOPBACK_NA;

  /* Initialize Loopback mode 2 info */
#ifdef FEATURE_DUMMY_SIGNALING
  #error code not present
#endif
  /* Set the number of channels in TFCS to 0 */
  config_ptr->mac_ul_parms.tfcs_ptr->nchan = 0;
  /* Set number of TrCHs in L1 to 0 */
  config_ptr->l1_ul_cctrch_parms.num_trch = 0;

  config_ptr->rrc_ul_cctrch_params.num_trch =0;


  /* Release all UL DCH TrCH indices and initialize the local info */
  rrcllc_init_ul_dch_trch_idx_info(config_ptr);

  /* Initialize RB Mapping info for all transport channels */
  for(trch_index = 0; trch_index < UE_MAX_TRCH; trch_index ++)
  {
    rrcllc_init_ul_dch_rb_mapping_info(config_ptr, trch_index);
  }

  /* Initialize the TFCS Info */
  rrcllc_init_ul_tfi_table(config_ptr);

  /* Initialize the UL TFS info for all transport channels */
  for(trch_index = 0; trch_index < UE_MAX_TRCH; trch_index ++)
  {
    rrcllc_init_ul_tfs_table(config_ptr, trch_index);
  }
#ifdef FEATURE_RRC_TFC_RLC_SIZE_FOR_DCH
  /* Initialize the RLC size restriction info */
  for(trch_id = 0; trch_id < UE_MAX_TRCH; trch_id++)
  {
    rrcllc_init_dch_rlc_size_info(trch_id);
  }
#endif/*FEATURE_RRC_TFC_RLC_SIZE_FOR_DCH*/
}

/*====================================================================
FUNCTION: rrcllc_init_dl_rl_info()

DESCRIPTION:
  This function initializes the Downlink Radio Link Info.
DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_dl_rl_info
(
  ordered_config_type *config_ptr,
  uint8 ix
#ifdef FEATURE_WCDMA_DC_HSUPA
  ,boolean is_sec_eul
#endif /* FEATURE_WCDMA_DC_HSUPA */

)
{
  /* local loop variable */
  uint8 iy;
  l1_dl_info_per_rl_struct_type *dl_info_per_rl = NULL;
#ifdef FEATURE_WCDMA_DC_HSUPA
  if(is_sec_eul == TRUE)
  {
    dl_info_per_rl = &config_ptr->l1_dl_chan_parms.sec_dl_per_rl[ix];
  }
  else
#endif /* FEATURE_WCDMA_DC_HSUPA */
  {
    dl_info_per_rl = &config_ptr->l1_dl_chan_parms.dl_per_rl[ix];
  /*Since we remove the PSC at index ix, we need to remove the Cell_id also at same index ix.*/
  cell_id_per_rl[ix] = WCDMA_INVALID_CELL_ID;    
  }

  /* Primary Scrambling Code */
  dl_info_per_rl->pri_cpich_scr_code = RRCLLC_INVALID_CPICH_SCR_CODE;

  /* RL info */
  dl_info_per_rl->dpch_per_rl.opt_parms_present_mask = 0;
  dl_info_per_rl->dpch_per_rl.closed_loop_timing_adj_mode = 0;
  dl_info_per_rl->dpch_per_rl.frame_offset = 0;
  dl_info_per_rl->dpch_per_rl.num_dpch = 0;
  dl_info_per_rl->dpch_per_rl.sec_cpich_ch_code = RRCLLC_INVALID_CHAN_CODE;
  dl_info_per_rl->dpch_per_rl.sec_cpich_sec_scr_code = RRCLLC_INVALID_SEC_SCR_CODE;
  dl_info_per_rl->dpch_per_rl.tpc_idx = 0;
  dl_info_per_rl->dpch_per_rl.use_pri_cpich = L1_USE_PRI_CPICH;
  dl_info_per_rl->dpch_per_rl.efdpch_slot_format = 0;

  dl_info_per_rl->dpch_per_rl.fdpch_sttd_ind = FALSE;

  /* Channelization code info */
  for (iy=0; iy < MAX_DPCH; iy++)
  {
    dl_info_per_rl->dpch_per_rl.dl_chan_code[iy].opt_parm_present_mask = 0;
    dl_info_per_rl->dpch_per_rl.dl_chan_code[iy].code_number = RRCLLC_INVALID_CHAN_CODE;
    dl_info_per_rl->dpch_per_rl.dl_chan_code[iy].scr_code_change = FALSE;
    dl_info_per_rl->dpch_per_rl.dl_chan_code[iy].sec_scr_code = RRCLLC_INVALID_SEC_SCR_CODE;
  }

  return;
} /* end rrcllc_init_dl_rl_info() */

/*====================================================================
FUNCTION: rrcllc_init_dl_tfs_table()

DESCRIPTION:
  This function initializes the Downlink TrCH TFS table. This
  is called whenever the UL CCTrCH type changes (i.e. a state change),
  or when a TrCH is deleted.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_dl_tfs_table(ordered_config_type *config_ptr, uint8 ix)
{
  /* local variables */
  uint8 iy;

  config_ptr->dl_trch_info[ix].num_tf = 0;
  config_ptr->dl_trch_info[ix].trch_id = 0;
  config_ptr->dl_trch_info[ix].tti_value = L1_NUM_TTI;
  config_ptr->dl_trch_info[ix].crc_length = L1_NUM_CRC_LENGTH;
  config_ptr->dl_trch_info[ix].coding_type = L1_DL_UNCODED;
  config_ptr->dl_trch_info[ix].rate_match_attrib = 0;
  config_ptr->dl_trch_info[ix].ref_type = L1_DL_TRCH_INVALID;
  config_ptr->dl_trch_info[ix].loopback_mode = L1_LOOPBACK_NA;

  for(iy = 0; iy < MAX_TF; iy++)
  {
    config_ptr->dl_trch_info[ix].tf_info_array[iy]->num_tb  = 0;
    config_ptr->dl_trch_info[ix].tf_info_array[iy]->tb_size = 0;
    config_ptr->dl_trch_info[ix].tf_info_array[iy]->allowed = FALSE;
  }

/* clear the trch info for sccpch with ctch */
  config_ptr->dl_trch_info_for_sccpch_with_ctch[ix].num_tf = 0;
  config_ptr->dl_trch_info_for_sccpch_with_ctch[ix].trch_id = 0;
  config_ptr->dl_trch_info_for_sccpch_with_ctch[ix].tti_value = L1_NUM_TTI;
  config_ptr->dl_trch_info_for_sccpch_with_ctch[ix].crc_length = L1_NUM_CRC_LENGTH;
  config_ptr->dl_trch_info_for_sccpch_with_ctch[ix].coding_type = L1_DL_UNCODED;
  config_ptr->dl_trch_info_for_sccpch_with_ctch[ix].rate_match_attrib = 0;
  config_ptr->dl_trch_info_for_sccpch_with_ctch[ix].ref_type = L1_DL_TRCH_INVALID;
  config_ptr->dl_trch_info_for_sccpch_with_ctch[ix].loopback_mode = L1_LOOPBACK_NA;

  for(iy = 0; iy < MAX_TF; iy++)
  {
    config_ptr->dl_trch_info_for_sccpch_with_ctch[ix].tf_info_array[iy]->num_tb  = 0;
    config_ptr->dl_trch_info_for_sccpch_with_ctch[ix].tf_info_array[iy]->tb_size = 0;
    config_ptr->dl_trch_info_for_sccpch_with_ctch[ix].tf_info_array[iy]->allowed = FALSE;
  }

  return;
} /* end rrcllc_dl_tfs_table() */

/*====================================================================
FUNCTION: rrcllc_init_ul_tfs_table()

DESCRIPTION:
  This function initializes the Uplink TFS table. This is
  called whenever the UL CCTrCH type changes (i.e. a state change),
  or when a TrCH is deleted.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_ul_tfs_table(ordered_config_type *config_ptr, uint8 ix)
{
  /* local variables */
  uint8 iy;

  config_ptr->mac_ul_parms.tfcs_ptr->tfs_info[ix].ntf      = 0;
  config_ptr->mac_ul_parms.tfcs_ptr->tfs_info[ix].tti_info = L1_NUM_TTI;

  for(iy = 0; iy < MAX_TF; iy++)
  {
    config_ptr->mac_ul_parms.tfcs_ptr->tfs_info[ix].tf_info[iy].ntblks  = 0;
    config_ptr->mac_ul_parms.tfcs_ptr->tfs_info[ix].tf_info[iy].tb_size = 0;
    config_ptr->mac_ul_parms.tfcs_ptr->tfs_info[ix].tf_info[iy].tf_flag = FALSE;
  }
  return;
} /* end rrcllc_init_ul_tfs_table */

/*====================================================================
FUNCTION: rrcllc_init_ul_tfi_table()

DESCRIPTION:
  This function initializes the Uplink TFI table. This needs to be
  called whenever the DL CCTrCH type changes (i.e. a state change),
  or when a TrCH is deleted.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_ul_tfi_table(ordered_config_type *config_ptr)
{
  /* local variables */
  uint8 ix, iy;

  /* Indicate no Transport Format Combinations
     in ordered_config for MAC and L1 */
  config_ptr->mac_ul_parms.tfcs_ptr->ntfc = 0;
  config_ptr->l1_ul_cctrch_parms.num_tfci = 0;
  config_ptr->rrc_ul_cctrch_params.num_tfci = 0;

  /* Clear out the number of removed TFCIs */
  config_ptr->num_removed_tfcis = 0;

  /* Clear out the uplink ctfc & tfis */
  for(ix = 0; ix < UE_MAX_TFC; ix++)
  {
    config_ptr->mac_ul_parms.tfcs_ptr->tfc_info[ix].control_flag = TFC_NOT_ALLOWED;
    config_ptr->mac_ul_parms.tfcs_ptr->tfc_info[ix].ctfc = 0;

    /* Clear out the Removed TFCI list and number */
    config_ptr->removed_tfci_list[ix] = 0;

    for(iy = 0; iy < UE_MAX_TRCH; iy++)
    {
      config_ptr->mac_ul_parms.tfcs_ptr->tfc_info[ix].tfi[iy] = 0;
    }
  }

  return;
} /* end rrcllc_init_ul_tfi_table */

/*====================================================================
FUNCTION: rrcllc_init_dl_dch_rb_mapping_info()

DESCRIPTION:
  This function initializes the Downlink RB Mapping Info table. This is
  called whenever the DL CCTrCH type changes (i.e. a state change), or
  a TrCH is deleted.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_dl_dch_rb_mapping_info
(
  ordered_config_type  *config_ptr,
  uint8  ix
)
{
  /* local loop variable */
  uint8 iy;

  /* Initialize the UL DCH RB Mapping info for a given TrCH Index */
  config_ptr->dl_dch_info[ix].trch_id = 0;

  /* No Dedicated Logical Channels now */
  config_ptr->dl_dch_info[ix].ndlchan = 0;

  /* Initialize loopback mode */
  config_ptr->dl_dch_info[ix].loopback_test_mode = MAC_LOOPBACK_NA;

  /* Clear out all Logical Channel info for this TrCH */
  for(iy = 0; iy < MAX_DED_LOGCHAN_PER_TRCH; iy++)
  {
    config_ptr->dl_dch_info[ix].dlchan_info[iy].mac_id = 0;
    /* LLC will clear out the RB ID and RLC ID */
    /* Don't care whether it is TM,UM,AM or DCCH or DTCH */
  }

  return;

} /* end rrcllc_init_dl_dch_rb_mapping_info */

/*====================================================================
FUNCTION: rrcllc_init_fach_rb_mapping_info()

DESCRIPTION:
  This function initializes the Downlink RB Mapping Info table. This is
  called whenever the DL CCTrCH type changes (i.e. a state change), or
  a TrCH is deleted.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_fach_rb_mapping_info
(
  ordered_config_type  *config_ptr,
  uint8  ix
)
{
  /* local loop variable */
  uint8 iy;

  /* Initialize the UL DCH RB Mapping info for a given TrCH Index */
  config_ptr->fach_info[ix].trch_id = 0;

  /* No Dedicated Logical Channels now */
  config_ptr->fach_info[ix].ndlchan = 0;

  config_ptr->cell_fach_rb_mapping_info.dl_ndlchan = 0;

  /* Clear out all Logical Channel info for this TrCH */
  for(iy = 0; iy < MAX_DED_LOGCHAN_PER_TRCH; iy++)
  {
    config_ptr->fach_info[ix].dlchan_info[iy].mac_id = 0;
    /* LLC will clear out the RB ID and RLC ID */
    /* Don't care whether it is TM,UM,AM or DCCH or DTCH */
  }

  /* No BCCH, CCCH, or CTCH either on this FACH */
  config_ptr->fach_info[ix].bcch_enable = FALSE;
  config_ptr->fach_info[ix].bcch_id     = 0;
  config_ptr->fach_info[ix].ccch_enable = FALSE;
  config_ptr->fach_info[ix].ccch_id     = 0;
  config_ptr->fach_info[ix].ctch_enable = FALSE;
  config_ptr->fach_info[ix].ctch_id     = 0;

  return;

} /* end rrcllc_init_fach_rb_mapping_info */

/*====================================================================
FUNCTION: rrcllc_init_ul_dch_rb_mapping_info()

DESCRIPTION:
  This function initializes the Uplink RB Mapping Info table. This is
  called whenever the DL CCTrCH type changes (i.e. a state change), or
  a TrCH is deleted.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_ul_dch_rb_mapping_info
(
  ordered_config_type  *config_ptr,
  uint8  ix
)
{
  /* local loop variable */
  uint8 iy;


  /* Initialize the UL DCH RB Mapping info for a given TrCH Index */
  config_ptr->ul_cctrch.dch_info.dch_info[ix].trch_id = 0;

  /* No Dedicated Logical Channels now */
  config_ptr->ul_cctrch.dch_info.dch_info[ix].ndlchan = 0;


  /* Clear out all Logical Channel info for this TrCH */
  for(iy = 0; iy < MAX_DED_LOGCHAN_PER_TRCH; iy++)
  {
    config_ptr->ul_cctrch.dch_info.dch_info[ix].dlchan_info[iy].mac_id = 0;
    config_ptr->ul_cctrch.dch_info.dch_info[ix].dlchan_info[iy].priority = 0;
    config_ptr->ul_cctrch.dch_info.dch_info[ix].dlchan_info[iy].rlc_size_info.all_tfi_valid = TRUE;
    config_ptr->ul_cctrch.dch_info.dch_info[ix].dlchan_info[iy].rlc_size_info.ntfi_per_lc = 0;
    /* LLC will clear out the RB ID and RLC ID */
    /* Don't care whether it is TM,UM,AM or DCCH or DTCH */
  }


  return;

} /* end rrcllc_init_ul_dch_rb_mapping_info */

/*====================================================================
FUNCTION: rrcllc_init_rach_rb_mapping_info()

DESCRIPTION:
  This function initializes the Uplink RB Mapping Info table. This is
  called whenever the DL CCTrCH type changes (i.e. a state change), or
  a TrCH is deleted.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_rach_rb_mapping_info(ordered_config_type  *config_ptr)
{
  /* local loop variable */
  uint8 iy;


  /* Initialize the UL DCH RB Mapping info for a given TrCH Index */
  config_ptr->ul_cctrch.rach_info.trch_id = 0;

  /* No Dedicated Logical Channels now */
  config_ptr->ul_cctrch.rach_info.ndlchan = 0;

  config_ptr->cell_fach_rb_mapping_info.ul_ndlchan = 0;


  /* Clear out all Logical Channel info for this TrCH */
  for(iy = 0; iy < MAX_DED_LOGCHAN_PER_TRCH; iy++)
  {
    config_ptr->ul_cctrch.rach_info.dlchan_info[iy].mac_id = 0;
    config_ptr->ul_cctrch.rach_info.dlchan_info[iy].priority = 0;
    config_ptr->ul_cctrch.rach_info.dlchan_info[iy].rlc_size_info.all_tfi_valid = TRUE;
    config_ptr->ul_cctrch.rach_info.dlchan_info[iy].rlc_size_info.ntfi_per_lc = 0;
    /* LLC will clear out the RB ID and RLC ID */
    /* Don't care whether it is TM,UM,AM or DCCH or DTCH */
  }


  /* No CCCH either on this RACH */
  config_ptr->ul_cctrch.rach_info.ccch_enable = FALSE;
  config_ptr->ul_cctrch.rach_info.ccch_id     = 0;
  config_ptr->ul_cctrch.rach_info.ccch_asc    = 0;

  return;

} /* end rrcllc_init_rach_rb_mapping_info */

/*====================================================================
FUNCTION: rrcllc_init_dl_pch_trch_idx()

DESCRIPTION:
  This function initializes the RRC DL PCH TRCH Data base. All DL
  PCH TRCH IDs are marked as available for use.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_dl_pch_trch_idx(ordered_config_type *config_ptr)
{
  MSG_MED("Initializing the DL PCH TrCH Index Data Base",0,0,0);
  config_ptr->dl_pch_trch_idx_in_use   = FALSE;
  return;
} /* end rrcllc_init_dl_pch_trch_idx() */

/*====================================================================
FUNCTION: rrcllc_init_dl_fach_trch_idx()

DESCRIPTION:
  This function initializes the RRC DL FACH TRCH Data base. All DL
  FACH TRCH IDs are marked as available for use.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_dl_fach_trch_idx_info(ordered_config_type *config_ptr)
{
  int trch_idx; /* local loop variable */

  MSG_MED("Initializing the DL FACH TrCH Index Data Base",0,0,0);

  /* check for a valid DL TrCH ID */
  for(trch_idx = 0; trch_idx < UE_MAX_TRCH; trch_idx++)
  {
    config_ptr->dl_fach_trch_idx_in_use[trch_idx] = FALSE;
    /* Initialize the rrcllcoc FACH TrCH database */
    config_ptr->dl_fach_trch_info[trch_idx].trch_id     = 0;
    config_ptr->dl_fach_trch_info[trch_idx].tf_cnt      = 0;
    config_ptr->dl_fach_trch_info[trch_idx].lg_ch_cnt   = 0;
    config_ptr->dl_fach_trch_info[trch_idx].dch_present = FALSE;

    config_ptr->dl_fach_trch_idx_in_use_for_sccpch_with_ctch[trch_idx] = FALSE;
    /* Initialize the rrcllcoc FACH TrCH database */
    config_ptr->dl_fach_trch_info_for_sccpch_with_ctch[trch_idx].trch_id     = 0;
    config_ptr->dl_fach_trch_info_for_sccpch_with_ctch[trch_idx].tf_cnt      = 0;
    config_ptr->dl_fach_trch_info_for_sccpch_with_ctch[trch_idx].lg_ch_cnt   = 0;
    config_ptr->dl_fach_trch_info_for_sccpch_with_ctch[trch_idx].dch_present = FALSE;
  }
  return;
} /* end rrcllc_init_dl_fach_trch_idx() */

/*====================================================================
FUNCTION: rrcllc_init_dl_dch_trch_idx()

DESCRIPTION:
  This function initializes the RRC DL DCH TRCH Data base. All DL
  DCH TRCH IDs are marked as available for use.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_dl_dch_trch_idx_info(ordered_config_type *config_ptr)
{
  int trch_idx; /* local loop variable */

  MSG_MED("Initializing the DL DCH TrCH Index Data Base",0,0,0);

  /* check for a valid DL TrCH ID */
  for(trch_idx = 0; trch_idx < UE_MAX_TRCH; trch_idx++)
  {
    config_ptr->dl_dch_trch_idx_in_use[trch_idx] = FALSE;
    /* Initialize the rrcllcoc DCH TrCH database */
    config_ptr->dl_dch_trch_info[trch_idx].trch_id     = 0;
    config_ptr->dl_dch_trch_info[trch_idx].tf_cnt      = 0;
    config_ptr->dl_dch_trch_info[trch_idx].lg_ch_cnt   = 0;
    config_ptr->dl_dch_trch_info[trch_idx].dch_present = FALSE;

    /* These two flags track the number of logic channels mapped into one
     * Transport channel in DCH and decide when should the TB size be
     * adjusted.
     */
    config_ptr->dl_dch_trch_info[trch_idx].lg_ch_cnt_down = FALSE;
    config_ptr->dl_dch_trch_info[trch_idx].lg_ch_cnt_up = FALSE;
  }

  return;
} /* end rrcllc_init_dl_dch_trch_idx() */

/*====================================================================
FUNCTION: rrcllc_init_ul_rach_trch_idx()

DESCRIPTION:
  This function initializes the RRC UL RACH TRCH Data base. All UL
  RACH TRCH IDs are marked as available for use.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_ul_rach_trch_idx_info(ordered_config_type *config_ptr)
{
  uint8 trch_idx; /* local loop variable */

  MSG_MED("Initializing the UL TrCH Index Data Base",0,0,0);

  /* check for a valid DL TrCH ID */
  for(trch_idx = 0; trch_idx < UE_MAX_TRCH; trch_idx++)
  {
    config_ptr->ul_rach_trch_idx_in_use[trch_idx] = FALSE;
    /* Initialize the DCH TrCH Info */
    config_ptr->ul_rach_trch_info[trch_idx].trch_id     = 0;
    config_ptr->ul_rach_trch_info[trch_idx].tf_cnt      = 0;
    config_ptr->ul_rach_trch_info[trch_idx].lg_ch_cnt   = 0;
    config_ptr->ul_rach_trch_info[trch_idx].dch_present = FALSE;
  }

  return;
} /* end rrcllc_init_ul_rach_trch_idx() */

/*====================================================================
FUNCTION: rrcllc_init_ul_dch_trch_idx()

DESCRIPTION:
  This function initializes the RRC UL RACH TRCH Data base. All UL
  RACH TRCH IDs are marked as available for use.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_ul_dch_trch_idx_info(ordered_config_type *config_ptr)
{
  uint8 trch_idx; /* local loop variable */

  MSG_MED("Initializing the UL TrCH Index Data Base",0,0,0);

  /* check for a valid DL TrCH ID */
  for(trch_idx = 0; trch_idx < UE_MAX_TRCH; trch_idx++)
  {
    config_ptr->ul_dch_trch_idx_in_use[trch_idx] = FALSE;
    /* Initialize the DCH TrCH Info */
    config_ptr->ul_dch_trch_info[trch_idx].trch_id     = 0;
    config_ptr->ul_dch_trch_info[trch_idx].tf_cnt      = 0;
    config_ptr->ul_dch_trch_info[trch_idx].lg_ch_cnt   = 0;
    config_ptr->ul_dch_trch_info[trch_idx].dch_present = FALSE;
  }

  return;
} /* end rrcllc_init_ul_dch_trch_idx() */

/*====================================================================
  The RLC size saga:
    For dedicated TrCHs:
      UTRAN gives RLC size in Transport format set.
      In Uplink:
        OC stores RLC size in TFS,
        MAC calculates TB Size from RLC size.
      In Downlink:
        OC stores TB size in TFS.

    For Common TrCHs
      UTRAN gives TB size in TFS.
        In Uplink and Downlink:
          OC stores TB size in TFS

    Calculation of RLC size:
      For dedicated TrCHs (DCHs):
        In Uplink:
          Find the TrCH that has the RB mapped to it.
          RLC size = MAX(TB size in OC)
        In Downlink:
          Find the TrCH that has the RB mapped to it.
          Determine MAC header length based on multiple/single
           logical channels on that TrCH.
          RLC size = MAX(RLC size in OC - MAC header size)

      For Common TrCHs (FACH/RACH):
        In Downlink:
          Determine MAC header length based on multiple/single
           logical channels on FACHes.
          For each FACH:
            RLC size = MAX(RLC size in OC - MAC header size)
          RLC size = MAX(RLC sizes from each FACH)
        In Uplink:
          Determine MAC header length based on multiple/single
            logical channels on RACH.
          RLC size = MAX(RLC size in OC - MAC header size)
=====================================================================*/

/*====================================================================
FUNCTION: rrcllc_get_dl_um_ccch_rlc_size()

DESCRIPTION:
  This is called when the RLC size for an downlink Unacknowledged Mode
  CCCH Logical Channel is required.

DEPENDENCIES:
  None.

RETURN VALUE:
  uint32  - The size of the RLC UM channel.

SIDE EFFECTS:
  Note that currently all logical channels mapped to a Transport
  channel must have the same TrBLK size. Therefore, by extracting
  the RLC size of the first Transport Format, this will apply to
  all Transport Formats for all logical channels and types mapped to
  this TrCH, except for PCH/FACH, where it is the second index.
====================================================================*/
uint32 rrcllc_get_dl_um_ccch_rlc_size(void)
{
  uint32  rlc_size = 0;
  uint32  trch_count;
  uint32  tf_count;

  for(trch_count = 0;
      trch_count < ordered_config_ptr->l1_dl_cctrch_parms.num_trch;
      trch_count ++)
  {
    /* The Common Transport Channel could either be a PCH
     * or a FACH.
     */
    if(ordered_config_ptr->l1_dl_cctrch_parms.
        trch_info_array[trch_count]->ref_type == L1_DL_TRCH_FACH_TYPE)
    {
      for(tf_count = 0;
          tf_count < ordered_config_ptr->l1_dl_cctrch_parms.
                     trch_info_array[trch_count]->num_tf;
          tf_count ++)
      {
        if((ordered_config_ptr->l1_dl_cctrch_parms.trch_info_array[trch_count]->
              tf_info_array[tf_count]->tb_size -
              RRCLLC_COM_LOG_CHL_FACH_MAC_HDR_SIZE) >
            rlc_size)
        {
          rlc_size = ordered_config_ptr->l1_dl_cctrch_parms.
                       trch_info_array[trch_count]->
                       tf_info_array[tf_count]->tb_size -
                     RRCLLC_COM_LOG_CHL_FACH_MAC_HDR_SIZE;
        }
      } /* For all TFs in a TRCH */
    } /* If TrCH type is a FACH */
  }  /* For all TrCHs */

  if(rlc_size == 0)
  {
    rlc_size = RRCLLC_INVALID_RLC_SIZE;
  }

  return(rlc_size);
} /* end rrcllc_get_dl_um_ccch_rlc_size() */

/*===========================================================================

FUNCTION RRCLLC_CONVERT_TTI_TO_MS

DESCRIPTION
  This function converts the l1_tti_enums to milliseconds

DEPENDENCIES
  None

RETURN VALUE
  uint32

SIDE EFFECTS
  None
===========================================================================*/
uint32 rrc_convert_tti_to_ms
(
  l1_tti_enum_type tti                    
)
{
  uint32    timer_value;                         /* Timer Value in milli seconds */

  switch (tti)
  {
    case L1_TTI_10MS:
      timer_value = 10;          
      break;
    case L1_TTI_20MS:
      timer_value = 20;
      break;      
    case L1_TTI_40MS:
      timer_value = 40;
      break;
    case L1_TTI_80MS:
      timer_value = 80;
      break;
    default:
      WRRC_MSG0_HIGH("Unknown Timer value received ");
      timer_value = 0xEFFFFFFF;         
      break;
  }
  return (timer_value);
} /* RRCLLC_CONVERT_TTI_TO_MS */


/*====================================================================
FUNCTION: rrcllc_print_trans_chnl_rate()

DESCRIPTION:
  This is called to print the rate of each transport channel in CC and OC
  in order to see how rate has changed.

DEPENDENCIES:
  None.

RETURN VALUE:
  void.

SIDE EFFECTS:

====================================================================*/
void rrcllc_print_trans_chnl_rate(void)
{
  uint32  data_size = 0;
  uint32  rate = 0;
  uint32  tti_in_ms = 0;
  uint32  trch_count;
  uint32  tf_count;
  rrcllc_oc_set_status_e_type oc_status;
  l1_dl_cctrch_info_struct_type   *l1_dl_cctrch_parms_p;
  ordered_config_type  *db_ptr = current_config_ptr;
  rrc_state_e_type  rrc_state = rrc_get_state();
  

  l1_dl_cctrch_parms_p = &(db_ptr->l1_dl_cctrch_parms);

  /* dont want to print old rate in connecting */
  if (rrc_state != RRC_STATE_CONNECTING)
  {
    for(trch_count = 0;
         trch_count < l1_dl_cctrch_parms_p->num_trch;
         trch_count ++)
    {
      for(tf_count = 0;
           tf_count < l1_dl_cctrch_parms_p->
           trch_info_array[trch_count]->num_tf;
           tf_count ++)
      {
        if((l1_dl_cctrch_parms_p->trch_info_array[trch_count]->tf_info_array[tf_count]->tb_size *
            l1_dl_cctrch_parms_p->trch_info_array[trch_count]->tf_info_array[tf_count]->num_tb) >
           data_size)
        {
          data_size = l1_dl_cctrch_parms_p->trch_info_array[trch_count]->tf_info_array[tf_count]->tb_size *
            l1_dl_cctrch_parms_p->trch_info_array[trch_count]->tf_info_array[tf_count]->num_tb;
        }
      } /* For all TFs in a TRCH */
      tti_in_ms = rrc_convert_tti_to_ms(l1_dl_cctrch_parms_p->trch_info_array[trch_count]->tti_value); 
      rate = (data_size * 1000)/tti_in_ms;
      WRRC_MSG3_MED("Old rates for DL ==> Tr_id: %d  rate: %d tti_in_ms:%d",
               l1_dl_cctrch_parms_p->trch_info_array[trch_count]->trch_id, 
               rate, tti_in_ms);
      
      data_size = 0;  
    }  /* For all TrCHs */
    
    for(trch_count = 0; (trch_count < db_ptr->ul_tfcs.nchan); trch_count ++)
    {
      for(tf_count = 0; tf_count < db_ptr->ul_tfcs.tfs_info[trch_count].ntf; tf_count ++)
      {
        if(((uint32)(db_ptr->ul_tfcs.tfs_info[trch_count].tf_info[tf_count].tb_size *
            db_ptr->ul_tfcs.tfs_info[trch_count].tf_info[tf_count].ntblks))  > data_size)
        { 
          data_size =  db_ptr->ul_tfcs.tfs_info[trch_count].tf_info[tf_count].tb_size * 
            db_ptr->ul_tfcs.tfs_info[trch_count].tf_info[tf_count].ntblks;
        }
      }  /* For all TFs of a TrCH */
      tti_in_ms = rrc_convert_tti_to_ms(db_ptr->ul_tfcs.tfs_info[trch_count].tti_info);
      rate = (data_size * 1000)/tti_in_ms;
      if (trch_count == 0 && (rrc_state == RRC_STATE_CONNECTING || rrc_state == RRC_STATE_CELL_FACH) )
      { 
        
        WRRC_MSG3_MED("Old rates for UL ==> Tr_id: %d  rate: %d tti_in_ms:%d",
                 db_ptr->mac_ul_parms.cctrch_ptr->rach_info.trch_id, 
                 rate, tti_in_ms);
      }
      else
      {
        WRRC_MSG3_MED("Old rates for UL ==> Tr_id: %d  rate: %d tti_in_ms:%d",
                 db_ptr->mac_ul_parms.cctrch_ptr->dch_info.dch_info[trch_count].trch_id, 
                 rate, tti_in_ms);
      }
      data_size = 0;  
    }
  }
  
  db_ptr = ordered_config_ptr;
  l1_dl_cctrch_parms_p = &(db_ptr->l1_dl_cctrch_parms);
  
  data_size = 0;
  oc_status = rrcllc_get_ordered_config_status_wo_f3();

  if(oc_status == OC_NOT_SET)
  {
    WRRC_MSG0_ERROR("Getting rate from OC while it is not set");
  }
  for(trch_count = 0;
       trch_count < l1_dl_cctrch_parms_p->num_trch;
       trch_count ++)
  {
    for(tf_count = 0;
         tf_count < l1_dl_cctrch_parms_p->
         trch_info_array[trch_count]->num_tf;
         tf_count ++)
    {
      if((l1_dl_cctrch_parms_p->trch_info_array[trch_count]->tf_info_array[tf_count]->tb_size *
          l1_dl_cctrch_parms_p->trch_info_array[trch_count]->tf_info_array[tf_count]->num_tb) >
         data_size)
      {
        data_size = l1_dl_cctrch_parms_p->trch_info_array[trch_count]->tf_info_array[tf_count]->tb_size *
          l1_dl_cctrch_parms_p->trch_info_array[trch_count]->tf_info_array[tf_count]->num_tb;
      }
    } /* For all TFs in a TRCH */
    tti_in_ms = rrc_convert_tti_to_ms(l1_dl_cctrch_parms_p->trch_info_array[trch_count]->tti_value);
    rate = (data_size * 1000)/tti_in_ms;
    
    WRRC_MSG3_MED("New rates for DL ==> Tr_id: %d  rate: %d tti_in_ms:%d",
             l1_dl_cctrch_parms_p->trch_info_array[trch_count]->trch_id, 
             rate, tti_in_ms);
    data_size = 0;
  }  
  
  for(trch_count = 0; (trch_count < db_ptr->ul_tfcs.nchan); trch_count ++)
  {
    for(tf_count = 0; tf_count < db_ptr->ul_tfcs.tfs_info[trch_count].ntf; tf_count ++)
    {
      if(((uint32)(db_ptr->ul_tfcs.tfs_info[trch_count].tf_info[tf_count].tb_size *
          db_ptr->ul_tfcs.tfs_info[trch_count].tf_info[tf_count].ntblks))  > data_size)
      {
        
        data_size =  db_ptr->ul_tfcs.tfs_info[trch_count].tf_info[tf_count].tb_size * 
          db_ptr->ul_tfcs.tfs_info[trch_count].tf_info[tf_count].ntblks;
      }
    } 
    tti_in_ms = rrc_convert_tti_to_ms(db_ptr->ul_tfcs.tfs_info[trch_count].tti_info); 
    rate = (data_size * 1000)/tti_in_ms;
    if (trch_count == 0 && (rrc_state == RRC_STATE_CONNECTING || rrc_state == RRC_STATE_CELL_FACH) )
    { 
      WRRC_MSG3_MED("New rates for UL ==> Tr_id: %d  rate: %d tti_in_ms:%d",
               db_ptr->mac_ul_parms.cctrch_ptr->rach_info.trch_id, 
               rate, tti_in_ms);
    }
    else
    {
      WRRC_MSG3_MED("New rates for UL ==> Tr_id: %d  rate: %d tti_in_ms:%d",
               db_ptr->mac_ul_parms.cctrch_ptr->dch_info.dch_info[trch_count].trch_id, rate,
               tti_in_ms);
    }
    data_size = 0;  
  }
  
} /* rrcllc_print_trans_chnl_rate() */


/*====================================================================
FUNCTION: rrcllc_get_ctch_enabled_status()

DESCRIPTION:
  This is called from other modules to check whether CTCH-FACH-SCCPCH
  pipe is currently set up.

DEPENDENCIES:
  None.

RETURN VALUE:
  boolean

SIDE EFFECTS:
  None.
====================================================================*/
boolean rrcllc_get_ctch_enabled_status(void)
{

  ordered_config_type  *config_ptr;
  uint8 i;
  if(config_ptr_in_use == ORDERED_CONFIG)
  {
    /* If Ordered Config is SET and next state is Cell_FACH, look into
     * the Ordered Config. Otherwise look into Current Config.
     */
    config_ptr = ordered_config_ptr;
  }
  else
  {
    config_ptr = current_config_ptr;
  }

  for(i = 0; i < config_ptr->mac_dl_parms.num_fachs; i ++)
  {
    if (config_ptr->mac_dl_parms.fach_info[i]->ctch_enable == TRUE)
    {
      return TRUE;
    }
  }

  return FALSE;
}
/*====================================================================
FUNCTION: rrcllc_get_ctch_drx_info()

DESCRIPTION:
  This is called when DRX info for CTCH is required.

DEPENDENCIES:
  None.

RETURN VALUE:


SIDE EFFECTS:

====================================================================*/
void rrcllc_get_ctch_drx_info(uint8 *frame_offset, uint16 *alloc_period)
{

  ordered_config_type  *config_ptr;

  if(config_ptr_in_use == ORDERED_CONFIG)
  {
    /* If Ordered Config is SET and next state is Cell_FACH, look into
     * the Ordered Config. Otherwise look into Current Config.
     */
    config_ptr = ordered_config_ptr;
  }
  else
  {
    config_ptr = current_config_ptr;
  }

  if (config_ptr->l1_dl_chan_parms.sccpch[0].cbs_sched.ctch_info_present)
  {
    *frame_offset = (uint8)config_ptr->l1_dl_chan_parms.sccpch[0].cbs_sched.cbs_frame_offset;
    *alloc_period = (uint16)config_ptr->l1_dl_chan_parms.sccpch[0].cbs_sched.ctch_allocation_period;
  }
  else
  {
    *frame_offset = (uint8)config_ptr->l1_dl_chan_parms.sccpch[1].cbs_sched.cbs_frame_offset;
    *alloc_period = (uint16)config_ptr->l1_dl_chan_parms.sccpch[1].cbs_sched.ctch_allocation_period;
  }
}

/*====================================================================
FUNCTION: rrcllc_get_ctch_rlc_size()

DESCRIPTION:
  This is called when the RLC size for an downlink Unacknowledged Mode
  CTCH Logical Channel is required.

DEPENDENCIES:
  None.

RETURN VALUE:
  uint32  - The size of the RLC UM channel.

SIDE EFFECTS:
  Note that currently all logical channels mapped to a Transport
  channel must have the same TrBLK size. Therefore, by extracting
  the RLC size of the first Transport Format, this will apply to
  all Transport Formats for all logical channels and types mapped to
  this TrCH, except for PCH/FACH, where it is the second index.
====================================================================*/
uint32 rrcllc_get_ctch_rlc_size(void)
{
  uint32  rlc_size = 0;
  uint32  trch_count;
  uint32   fach_count = 0;
  uint32  tf_count;
  rrcllc_ctch_status_e_type ctch_status;
  l1_dl_cctrch_info_struct_type   *l1_dl_cctrch_parms_p;
  ordered_config_type  *config_ptr;

  ctch_status = rrcllc_semi_permanent_data.dl_phy_chan.ctch_status;


  if(config_ptr_in_use == ORDERED_CONFIG)
  {
    /* If Ordered Config is SET and next state is Cell_FACH, look into
     * the Ordered Config. Otherwise look into Current Config.
     */
    config_ptr = ordered_config_ptr;
  }
  else
  {
    config_ptr = current_config_ptr;
  }


  if (ctch_status == RRCLLC_CTCH_WITH_PCCH)
  {
    l1_dl_cctrch_parms_p = &(config_ptr->l1_dl_cctrch_parms);
  }
  else if (ctch_status == RRCLLC_CTCH_ON_DIF_SCCPCH)
  {
    l1_dl_cctrch_parms_p = &(config_ptr->l1_dl_cctrch_parms_for_sccpch_with_ctch);
  }
  else
  {
    WRRC_MSG0_ERROR("There is no CTCH");
    return  (RRCLLC_INVALID_RLC_SIZE);
  }

  for(trch_count = 0;
      trch_count < l1_dl_cctrch_parms_p->num_trch;
      trch_count ++)
  {
    /* The Common Transport Channel could either be a PCH
     * or a FACH.
     */
    if((fach_count < UE_MAX_TRCH) && (l1_dl_cctrch_parms_p->trch_info_array[trch_count]->ref_type == L1_DL_TRCH_FACH_TYPE))
    {
      if (config_ptr->mac_dl_parms.fach_info[fach_count]->ctch_enable == TRUE)
      {
        for(tf_count = 0;
             tf_count < l1_dl_cctrch_parms_p->
             trch_info_array[trch_count]->num_tf;
             tf_count ++)
        {
          if((l1_dl_cctrch_parms_p->trch_info_array[trch_count]->
              tf_info_array[tf_count]->tb_size -
              RRCLLC_COM_LOG_CHL_FACH_MAC_HDR_SIZE) >
             rlc_size)
          {
            rlc_size = l1_dl_cctrch_parms_p->
                       trch_info_array[trch_count]->
                       tf_info_array[tf_count]->tb_size -
                       RRCLLC_COM_LOG_CHL_FACH_MAC_HDR_SIZE;
          }
        } /* For all TFs in a TRCH */
        return rlc_size;
      }
      fach_count++;
    } /* If TrCH type is a FACH */
  }  /* For all TrCHs */

  if(rlc_size == 0)
  {
    rlc_size = RRCLLC_INVALID_RLC_SIZE;
  }

  return(rlc_size);
} /* end rrcllc_get_ctch_rlc_size() */

/*====================================================================
FUNCTION: rrcllc_get_bmc_schedul_info()

DESCRIPTION:
  This is called when the period of BMC scheduling message is required.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_get_bmc_schedul_info(uint16 *schedul_msg_period)
{
  rrc_SysInfoType5 *sib5_ptr = NULL;
  sib5_ptr = (rrc_SysInfoType5 *)
               rrc_sibdb_return_sib_for_srv_cell(rrc_SIB5);
  
  if (sib5_ptr == NULL)
  {
    WRRC_MSG0_ERROR("SIB 5 not yet in SIB data base");
    return;
  }
  
  if(RRCLLC_SIB5_DRX_LEVEL1_INFO_EXT_PRESENT(sib5_ptr))
  {
  /*The asn1 value cBS_DRX_Level1Information_extension is an enum. So should translate it to the right scale*/
    *schedul_msg_period = 1 << (3 + sib5_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtensions.v650NonCriticalExtensions.
                   v680NonCriticalExtensions.v690NonCriticalExtensions.sysInfoType5_v690ext.cBS_DRX_Level1Information_extension);
    WRRC_MSG1_HIGH("Period of BMC scheduling messages: %d",*schedul_msg_period);
  }
return;
} /* end rrcllc_get_bmc_schedul_info() */

/*====================================================================
FUNCTION: rrcllc_get_am_rlc_size_for_rb()

DESCRIPTION:
 This function retrieves AM RLC PDU size from CC for a given RB rb_id.

DEPENDENCIES:
  None.

RETURN VALUE:
  uint32  - The size of the RLC PDU.

SIDE EFFECTS:
  None
===================================================================*/
uint32 rrcllc_get_am_rlc_size_for_rb
(
  rrc_RB_Identity  rb_id, 
  rrc_direction_enum_type direction
)
{
  uint8 am_idx = 0;
  uint32 rlc_size = RRCLLC_INVALID_RLC_SIZE;

#ifdef FEATURE_MAC_I
  /*For the scenario of EDCH to DCH tranport channel transition To detect size change return the size as 0
  so that size change gets detected in rrcllc_get_rb_for_rb_list_mapped_to_dch and the RB id gets filled in 
  rrc_rb_list_mapped_to_dch */
  if((direction == UL)&& (rrcllc_check_edch_flexible_ul_size_configured(current_config_ptr,rb_id)))
  {
    rlc_size = 0;
    WRRC_MSG2_HIGH("MAC_I: Flexible PDU Size in CC for RB ID %d rlc size %d ",rb_id,rlc_size);
    return rlc_size;
  }
#endif

  /*Loop thru all the AM entities in CC */
  for(am_idx = 0; am_idx < UE_MAX_AM_ENTITY; am_idx++)
  {
    if(current_config_ptr->am_config[am_idx].common_config.rb_id == rb_id)
    {
      /* RLC size is retrieved for UL*/
      if(direction == UL)
      {
        rlc_size = current_config_ptr->am_config[am_idx].rlc_ul_am_config.ul_rlc_size;
      }
      /* RLC size is retrieved for DL*/	  
      else if (direction == DL)
      {
        rlc_size = current_config_ptr->am_config[am_idx].rlc_dl_am_config.dl_rlc_size;
      }
      break;
    }
  }
  return rlc_size;
}

/*====================================================================
FUNCTION: rrcllc_get_dl_ded_rlc_size()

DESCRIPTION:
  This is called when the RLC size for a downlink dedicated RLC
  entity is required. This is needed since the RLC sap requires the
  rlc size for channel setups. The input parameter is the next
  state.

DEPENDENCIES:
  None.

RETURN VALUE:
  uint32  - The size of the RLC channel.

SIDE EFFECTS:
  None
===================================================================*/
uint32 rrcllc_get_dl_ded_rlc_size
(
  rrc_state_e_type  rrc_state,
  rrc_RB_Identity  rb_id
)
{
  uint32 rlc_size = RRCLLC_INVALID_RLC_SIZE;
  uint32 trch_count;
  uint32 tf_count;
  uint32 dlch_count;
  uint8 mac_hdr_size;
  boolean  rb_found = FALSE;
  ordered_config_type  *config_ptr;

  if((rrc_state == RRC_STATE_CELL_PCH) || (rrc_state == RRC_STATE_URA_PCH))
  {
    if (RRC_STATE_CELL_FACH == rrc_get_state())
    {
      config_ptr = ordered_config_ptr;
      /*make rrc_state as CELL_FACH */
      rrc_state =  RRC_STATE_CELL_FACH;
    }
    else
    {
      /* it is dch->pch transition. Check whether transition config has
      dcch_fach mapping in this case use the ordered_config to populate the
      rlc size (cell_fach mapping is already copied to oc from toc by this time
      change the next state as CELL_FACH to reuse the same code */
      if(TRUE == rrcllc_check_dcch_fach_mapping(transition_config.toc_ptr))
      {
        config_ptr = ordered_config_ptr;
        /*make rrc_state as CELL_FACH */
        rrc_state =  RRC_STATE_CELL_FACH;
      }
      else
      {
        /*dcch_fach mapping was not present in toc. This means UE is transitioning from
        DCH to PCH without CELL_FACH mapping. Use the dch info to populate the RLC
        */
        config_ptr = transition_config.toc_ptr;
        /*make rrc_state as CELL_FACH */
        rrc_state =  RRC_STATE_CELL_DCH;
      }
    }
  }
  else
  {
    config_ptr = ordered_config_ptr;
  }

  if (rrc_state == RRC_STATE_CELL_DCH)
  {
    rlc_size = 0;
    /* Look for the DCH that has the same RB mapped to it. Then calculate
    * RLC size from TrBlk size by substracting MAC header
    */
    for(
        trch_count = 0;
        (trch_count < config_ptr->l1_dl_cctrch_parms.num_trch) &&
          (rb_found == FALSE);
        trch_count ++
       )
    {
      for(
          dlch_count = 0;
          (dlch_count < config_ptr->mac_dl_parms.
                        dch_info[trch_count]->ndlchan) &&
            (rb_found == FALSE);
          dlch_count ++
         )
      {
        if(config_ptr->mac_dl_parms.dch_info[trch_count]->
            dlchan_info[dlch_count].rb_id == rb_id)
        {
          rb_found = TRUE;
          /* This is the TrCH */
          if(config_ptr->mac_dl_parms.dch_info[trch_count]->ndlchan > 1)
          {
            /* Multiple dedicated logical channels mapped on DCH */
            mac_hdr_size = RRCLLC_DED_MULTI_LOG_CHL_DL_DCH_MAC_HDR_SIZE;
          }
          else
          {
            /* Single dedicated logical channel on DCH */
            mac_hdr_size = RRCLLC_DED_SINGLE_LOG_CHL_DL_DCH_MAC_HDR_SIZE;
          }

          for(
              tf_count = 0;
              tf_count < config_ptr->l1_dl_cctrch_parms.
                         trch_info_array[trch_count]->num_tf;
              tf_count ++
             )
          {
            if(config_ptr->l1_dl_cctrch_parms.trch_info_array[trch_count]->
                  tf_info_array[tf_count]->tb_size != 0)
            {
              /* If the tb_size less the mac_hdr_size is bigger than the
                 rlc_size, then we need to adjust the rlc_size up.  This
                 comparison is written with respect to zero to avoid a lint
                 warning about comparing signed and unsigned values, since a
                 subtraction always results in a signed value and the rlc_size
                 is an unsigned value. */
              if((config_ptr->l1_dl_cctrch_parms.trch_info_array[trch_count]->
                    tf_info_array[tf_count]->tb_size - mac_hdr_size - rlc_size)
                  > 0)
              {
                /*RLC size has to be octet aligned so dont subtract by 4 if 
                  already octet aligned */
                if((config_ptr->l1_dl_cctrch_parms.trch_info_array[trch_count]->
                             tf_info_array[tf_count]->tb_size % 8 ) == 0 )
                {
                  mac_hdr_size = RRCLLC_DED_SINGLE_LOG_CHL_DL_DCH_MAC_HDR_SIZE;
                }
                
                rlc_size = config_ptr->l1_dl_cctrch_parms.
                             trch_info_array[trch_count]->
                             tf_info_array[tf_count]->tb_size -
                           mac_hdr_size;
              }
            } /* Consider only those TFs that have TB size > 0 */
          } /* For all TFs in a TRCH */
        } /* If RB is found */
      } /* For all dedicated logical channels on this TrCH */
    }  /* For all TrCHs */
  } /* If state is Cell_DCH */

  else if(rrc_state == RRC_STATE_CELL_FACH)
  {
    /* For FACH, the MAC header for dedicated logical channel is 24 bits
     * if C-RNTI is used. If U-RNTI is used, it is 40 bits. Based on C-RNTI,
     * subtract 24 from TB Size to get RLC size for DCCH mapped on FACH
     */
    rlc_size = 0;
    for(trch_count = 0;
        trch_count < config_ptr->l1_dl_cctrch_parms.num_trch;
        trch_count ++)
    {
      /* The Common Transport Channel could either be a PCH
       * or a FACH.
       */
      if(config_ptr->l1_dl_cctrch_parms.
          trch_info_array[trch_count]->ref_type == L1_DL_TRCH_FACH_TYPE)
      {
#if 0
        /*Here the index used for FACh in MAC DB might be incorrect as L1 DB has 
           PCH also*/
        if(config_ptr->mac_dl_parms.fach_info[trch_count]->ndlchan > 1)
        {
          /* Multiple dedicated logical channels on FACH */
          mac_hdr_size = RRCLLC_DED_MULTI_LOG_CHL_FACH_CRNTI_MAC_HDR_SIZE;
        }
        else
        {
          /* Single dedicated logical channel */
          mac_hdr_size = RRCLLC_DED_SINGLE_LOG_CHL_FACH_CRNTI_MAC_HDR_SIZE;
        }
#endif

        /* Since the RLC size needs to be byte aligned, and the Tb size received in 
             FACH Trch is always Octet aligned, subtract by MAX FACH header size ,
             always. In any case all FACh shld have multiple
             Rbs, as we always map all Rbs to all the FACh */
        mac_hdr_size = RRCLLC_DED_MULTI_LOG_CHL_FACH_CRNTI_MAC_HDR_SIZE;
  
        for(tf_count = 0;
            tf_count < config_ptr->l1_dl_cctrch_parms.
                       trch_info_array[trch_count]->num_tf;
            tf_count ++)
        {
          if(config_ptr->l1_dl_cctrch_parms.trch_info_array[trch_count]->
                tf_info_array[tf_count]->tb_size > 0)
          {
            /* If the tb_size less the mac_hdr_size is bigger than the
               rlc_size, then we need to adjust the rlc_size up.  This
               comparison is written with respect to zero to avoid a lint
               warning about comparing signed and unsigned values, since a
               subtraction always results in a signed value and the rlc_size
               is an unsigned value. */
            if((config_ptr->l1_dl_cctrch_parms.trch_info_array[trch_count]->
                  tf_info_array[tf_count]->tb_size - mac_hdr_size - rlc_size) >
                0)
            {
              rlc_size = config_ptr->l1_dl_cctrch_parms.
                           trch_info_array[trch_count]->
                           tf_info_array[tf_count]->tb_size -
                         mac_hdr_size;
            }
          }  /* If TB size > 0 */
        } /* For all TFs in a TRCH */
      } /* If TrCH type is a FACH */
    }  /* For all TrCHs */
  } /* State is Cell_FACH */
  if(rlc_size == 0)
  {
    rlc_size = RRCLLC_INVALID_RLC_SIZE;
  }

  if((rlc_size % 8 ) != 0)
  {
    ERR("Invalid DL RLC size shld be byte aligned for RBid:%d, Size:%d next_rrc_st:%d",
    rb_id,rlc_size,rrc_state);
  }
  else
  {
    MSG_HIGH(" DL RLC size for RBid:%d, Size:%d next_rrc_st:%d",
    rb_id,rlc_size,rrc_state);
  }
  return rlc_size;
} /* end rrcllc_get_dl_ded_rlc_size() */

/*====================================================================
FUNCTION: rrcllc_get_ul_ded_rlc_size()

DESCRIPTION:
  This is called when the RLC size for an uplink dedicated RLC
  entity is required. This is needed since the RLC sap requires the
  rlc size for channel setups. The input parameter is the next
  state.

DEPENDENCIES:
  None.

RETURN VALUE:
  uint32  - The size of the RLC channel.

SIDE EFFECTS:
  None
===================================================================*/
uint32 rrcllc_get_ul_ded_rlc_size
(
  rrc_state_e_type  rrc_state,
  rrc_RB_Identity  rb_id
)
{
  uint32 rlc_size = 0;
  uint32 trch_count;
  uint32 tf_count;
  uint32 tfi_count;
  uint32 tf_idx;
  uint32 dlch_count;
  uint8 mac_hdr_size;
  boolean  rb_found = FALSE;

  ordered_config_type  *config_ptr;
  uint32 ix = 0, iy = 0, iz = 0;

  if(config_ptr_in_use == ORDERED_CONFIG)
  {
    config_ptr = ordered_config_ptr;
  }
  else
  {
    config_ptr = current_config_ptr;
  }
  if((rrc_state == RRC_STATE_CELL_PCH) || (rrc_state == RRC_STATE_URA_PCH))
  {
#ifdef FEATURE_WCDMA_HS_RACH  
    /*if hspa_rnti_stored_cell_pch is TRUE then get the size from HSRACH structures
    also make sure hsrach mappings are updated into config_ptr before calling this function*/
    if(config_ptr->hspa_rnti_stored_cell_pch != TRUE)
#endif
    {
      if (RRC_STATE_CELL_FACH == rrc_get_state())
      {
        /*this is cell_FACH->PCH transition */
        config_ptr = ordered_config_ptr;
        /*make rrc_state as CELL_FACH */
        rrc_state =  RRC_STATE_CELL_FACH;
      }
      else
      {
        /* it is dch->pch transition. Check whether transition config has
        dcch_fach mapping in this case use the ordered_config to populate the
        rlc size (cell_fach mapping is already copied to oc from toc by this time
        change the next state as CELL_FACH to reuse the same code */
        if(TRUE == rrcllc_check_dcch_fach_mapping(transition_config.toc_ptr))
        {
          config_ptr = ordered_config_ptr;
          /*make rrc_state as CELL_FACH */
          rrc_state =  RRC_STATE_CELL_FACH;
        }
        else
        {
          /*dcch_fach mapping was not present in toc. This means UE is transitioning from
          DCH to PCH without CELL_FACH mapping. Use the dch info to populate the RLC
          */
          config_ptr = transition_config.toc_ptr;
          /*make rrc_state as CELL_FACH */
          rrc_state =  RRC_STATE_CELL_DCH;
        }
      }
    }
    else
    {
        /* Set the state to FACH if hspa rnti flag is true so that existing code populates the 
           RLC sizes */
        rrc_state = RRC_STATE_CELL_FACH;
    }

  }
  /* Note: UL UM could only be a dedicated logical channel */
  if(rrc_state == RRC_STATE_CELL_DCH)
  {
    for(trch_count = 0;
        (trch_count < config_ptr->ul_tfcs.nchan) &&
          (rb_found == FALSE);
        trch_count ++)
    {
      for(
          dlch_count = 0;
          (dlch_count < config_ptr->mac_ul_parms.cctrch_ptr->dch_info.
            dch_info[trch_count].ndlchan) &&
            (rb_found == FALSE);
          dlch_count ++
         )
      {
        if(config_ptr->mac_ul_parms.cctrch_ptr->dch_info.
           dch_info[trch_count].dlchan_info[dlch_count].rb_id == rb_id)
        {
          rlc_size = 0;
          rb_found = TRUE;
          /* Get the RLC size */
          for(tf_count = 0;
              tf_count < config_ptr->ul_tfcs.tfs_info[trch_count].ntf;
              tf_count ++)
          {
            if(config_ptr->ul_tfcs.tfs_info[trch_count].
                tf_info[tf_count].tb_size  > rlc_size)
            {
              /* In Uplink the Transport format set in Ordered Config is
               * in terms of RLC PDU size as sent in RRC message.
               */
              rlc_size =  config_ptr->ul_tfcs.tfs_info[trch_count].
                          tf_info[tf_count].tb_size;
            }
          }  /* For all TFs of a TrCH */
        }  /* If this TrCH has the same RB ID mapped to it */
      } /* For all dedicated logical channels */
    } /* For all Transport Channels */
    /* Check in EDCH MAC structure if there is a higher RLC size */
    rb_found = FALSE;
    /* Compute EDCH rlc size only if EDCH transmission is TRUE - CR#754844 
       If both EDCH/DCH transport channels are added, pick either RLC size of dch/EDCH 
       based on e_dch_transmisson 
    */
    if((TRUE == config_ptr->e_dch_transmission)|| (rlc_size == 0))
    {
      for (ix = 0; (!rb_found) && (ix < MAX_E_DCH_MAC_D_FLOW) ; ix++) 
      {
        for (iy = 0; (!rb_found) && (iy < config_ptr->mac_e_config.e_mac_d_flow_info[ix].num_logch); iy++)
        {
          if (config_ptr->mac_e_config.e_mac_d_flow_info[ix].e_ul_logch_info[iy].rb_id == rb_id)
          { 
            rb_found = TRUE;
            rlc_size = 0;
            for (iz = 0; iz < config_ptr->mac_e_config.e_mac_d_flow_info[ix].e_ul_logch_info[iy].num_rlc_size_ddi_info; iz++) 
            {
              if (rlc_size < config_ptr->mac_e_config.e_mac_d_flow_info[ix].e_ul_logch_info[iy].rlc_size_ddi_info[iz].rlc_pdu_size_in_bits) 
              {
                rlc_size = config_ptr->mac_e_config.e_mac_d_flow_info[ix].e_ul_logch_info[iy].rlc_size_ddi_info[iz].rlc_pdu_size_in_bits;
              }
            }
          }
        }
      }
    }

  } /* State is DCH */
  else if(rrc_state == RRC_STATE_CELL_FACH)
  {
    rlc_size = 0;

    /* When multiple logical channels are mapped to RACH, we need extra 4 bits in MAC header */
    
    if(config_ptr->mac_ul_parms.cctrch_ptr->rach_info.ndlchan > 1)
    {
      mac_hdr_size = RRCLLC_DED_MULTI_LOG_CHL_RACH_MAC_HDR_SIZE;
    }
    else
    {
      mac_hdr_size = RRCLLC_DED_SINGLE_LOG_CHL_RACH_MAC_HDR_SIZE;
    }

    /*We need to loop through all the logical channels that are mapped to RACH 
        and find out which logical channel has RB id same as rb_id*/
    
    for(dlch_count = 0;
     (dlch_count < config_ptr->mac_ul_parms.cctrch_ptr->rach_info.ndlchan) &&
          (rb_found == FALSE);
        dlch_count ++)
    {
      if(config_ptr->mac_ul_parms.cctrch_ptr->rach_info.dlchan_info[dlch_count].rb_id == rb_id)
      {
        rb_found = TRUE;
        
        /* Check for whether all the TFs are allowed */
        if(config_ptr->mac_ul_parms.cctrch_ptr->rach_info.dlchan_info[dlch_count].rlc_size_info.all_tfi_valid == TRUE)
        {
          /* Since there is only one RACH Channel, we use index 0 instead of looping through all the TrCHs 
           We loop through all the TFs of the RACH channel to find the max TB size. */
          WRRC_MSG0_HIGH("All TFs are allowed.");
          for(tf_count =0;
               tf_count < config_ptr->ul_tfcs.tfs_info[0].ntf;
               tf_count ++)
          {
            /* We need to subtract MAC hdr from TB size to get RLC PDU size. */
            if((config_ptr->ul_tfcs.tfs_info[0].tf_info[tf_count].tb_size - mac_hdr_size - rlc_size) > 0)
            {
              rlc_size =  (config_ptr->ul_tfcs.tfs_info[0].tf_info[tf_count].tb_size - mac_hdr_size);
            }
          }
        } /*If all the TFs are allowed*/
        
        /*This case will arise when explicit list of TFs is given*/
        else
        {
          /* We loop through all the TFs of the RACH channel to find the max TB size. */
          
          for(tfi_count =0; 
               tfi_count < config_ptr->mac_ul_parms.cctrch_ptr->rach_info.dlchan_info[dlch_count].rlc_size_info.ntfi_per_lc; 
                tfi_count++)
          {
            /* tf_idx is the TF index that is given in explicit list of TFs for RACH Channel */
            
            tf_idx = config_ptr->mac_ul_parms.cctrch_ptr->rach_info.dlchan_info[dlch_count].rlc_size_info.lc_tfi_list[tfi_count];
            
            if((config_ptr->ul_tfcs.tfs_info[0].tf_info[tf_idx].tb_size - mac_hdr_size - rlc_size) > 0)
            {
              rlc_size =  (config_ptr->ul_tfcs.tfs_info[0].tf_info[tf_idx].tb_size - mac_hdr_size);
            }
          } /* For all the TFIs that are given for the logical channel dlch_count */
        } /*If all the TFs are not allowed*/
      } /*If this TrCH has the same RB ID mapped to it*/
    }/* For all dedicated logical channels mapped to CCTrCH*/
#ifdef FEATURE_WCDMA_HS_RACH
    /* Check in HS-RACH EDCH MAC structure if there is a higher RLC size */
    rb_found = FALSE;
       /* Get the RLC size if hspa rnti flag is set */
    if((TRUE == rrchsrach_get_common_edch_transmission_wof3(config_ptr))
       ||((rrc_state == RRC_STATE_CELL_PCH) && (config_ptr->hspa_rnti_stored_cell_pch == TRUE)))
    {
      for (ix = 0; (!rb_found) && (ix < MAX_E_DCH_MAC_D_FLOW) ; ix++) 
      {
        for (iy = 0; (!rb_found) && (iy < config_ptr->mac_hs_rach_config.hs_rach_config.e_mac_d_flow_info[ix].num_logch); iy++)
        {
          if (config_ptr->mac_hs_rach_config.hs_rach_config.e_mac_d_flow_info[ix].e_ul_logch_info[iy].rb_id == rb_id)
          { 
            rb_found = TRUE;
            /* Reset RLC size and compute HRACH RLC size */
            rlc_size = 0;
            for (iz = 0; iz < config_ptr->mac_hs_rach_config.hs_rach_config.e_mac_d_flow_info[ix].e_ul_logch_info[iy].num_rlc_size_ddi_info; iz++) 
            {
               /*HSRACH: Do we need to consider mac_hdr_size ?*/
              if (rlc_size < config_ptr->mac_hs_rach_config.hs_rach_config.e_mac_d_flow_info[ix].e_ul_logch_info[iy].rlc_size_ddi_info[iz].rlc_pdu_size_in_bits) 
              {
                rlc_size = config_ptr->mac_hs_rach_config.hs_rach_config.e_mac_d_flow_info[ix].e_ul_logch_info[iy].rlc_size_ddi_info[iz].rlc_pdu_size_in_bits;
                WRRC_MSG1_MED("RRCHSRACH: rlc_size %d in get_ul_ded_rlc_size",rlc_size);
              }
            }
          }
        }
      }
    }
#endif /* FEATURE_WCDMA_HS_RACH */

  } /* State is FACH */
  if(rlc_size == 0)
  {
    MSG_ERROR("Invalid UL RLC size for RBid:%d, curr_rrc_st:%d next_rrc_st:%d",
    rb_id,rrc_get_state(),rrc_state);
    /*Check if CC has a valid RLC Size, if then use it in OC*/
    for(dlch_count = 0; dlch_count< UE_MAX_AM_ENTITY; dlch_count++)
    {
      if(current_config_ptr->am_config[dlch_count].common_config.rb_id == rb_id)
      {
        rlc_size = current_config_ptr->am_config[dlch_count].rlc_ul_am_config.ul_rlc_size;
        WRRC_MSG0_HIGH("Use valid RLC Size from CC");
        break;
      }
    }
  }

  WRRC_MSG2_HIGH("UL ded RLC Size for RB id %d is %d",rb_id,rlc_size);
  return rlc_size;
} /* end rrcllc_get_ul_ded_rlc_size() */

/*====================================================================
 FUNCTION: rrcllc_get_hs_dl_ded_rate()

DESCRIPTION:
  This is called when dl rate for a particular rb is needed

DEPENDENCIES:
  None.

RETURN VALUE:
  uint32  - The uplink rate of the rb passed in.

SIDE EFFECTS:
  None
===================================================================*/
static uint32 rrcllc_get_hs_dl_ded_rate
(
   rrc_RB_Identity  rb_id,
   boolean is_rb_mapped_to_dflow,
   boolean is_rb_mapped_on_macehs_q
)
{
  ordered_config_type  *config_ptr;
  uint32 rate = 0;
#ifdef FEATURE_WCDMA_MIMO
  l1_dl_hs_mimo_action_enum_type mimo_action 
                    =rrcllc_get_mimo_action_in_config();            
#endif          
#ifdef FEATURE_WCDMA_DC_HSDPA
  uint8 num_sec_hs_carrier = 0;
#endif
       
  if(config_ptr_in_use == ORDERED_CONFIG)
  {
    config_ptr = ordered_config_ptr;
  }
  else
  {
    config_ptr = current_config_ptr;
  }

#ifdef FEATURE_WCDMA_DC_HSDPA
  num_sec_hs_carrier = rrcllcpcie_return_num_sec_hsdpa_carriers(config_ptr);
#endif
  WRRC_MSG1_MED("rb_id %d is HS rb - set rate based on cat",rb_id);

  /* Here return based on the HS category as HS rates are dynamic */
  /*The relation between HSDPA category and rate are taken from 80-W0331-1 Rev B.*/	
  /*Here 1Mbps = (1000 * 1000) bps*/		
  switch(nv_hsdpa_category)
  {
    case 6:
      /* 3.6 Mbps */
      rate = 3600000;
      break;              

    case 8:
      /* 7.2 Mpbs */  
      rate = 7200000;
      break;             

    case 11:
      /* 0.9 Mbps */
      rate = 900000;
      break;
            
    case 12:
      /* 1.8 Mbps */
      rate = 1800000;
      break;
            
 /* TBD PSR need to add for the other categories supported. */
    case 9:
      /* 10.1 Mbps */
      rate = 10100000;
      break;
      
    case 10:
      /* 14.0 Mbps */
      rate = 14000000;
      break;
      
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    {
      /*If MApped on MAC-HS then Cat is CAT 8 */
      if (is_rb_mapped_to_dflow)
      {
        switch(rrc_machs_cat)
        {
          case 8:
            /* 7.2 Mbps */
            rate = 7200000;
            break;

          case 9:
            /* 10.1 Mbps */
            rate = 10100000;
            break;

          case 10:
            /* 14.0 Mbps */
            rate = 14000000;
            break;
            
          default:
            WRRC_MSG0_ERROR("MAC-HS cat not set, set default rate as 7.2 mbp");
            /* 7.2 Mbps */
            rate = 7200000;
            break;
                  
        }

        break;
      }
      else
      {
        if(config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured == TRUE)
        {
          switch(nv_hsdpa_category)
          {
            case 13:
            case 14:
            case 17:
            case 18:
             /* 21 Mbps */
             rate = 21000000;
             break;

            default:
              WRRC_MSG0_HIGH("Invalid rate for HS rab for 64 QAm");
              break;
          }
        }
        else
#ifdef FEATURE_WCDMA_MIMO
        if(((rrcllc_get_mimo_status() == RRC_MIMO_ACTIVE) && (mimo_action != L1_MIMO_STOP) ) ||
              (mimo_action == L1_MIMO_START))
        {
          switch(nv_hsdpa_category)
          {
            case 15:
            case 17:
              /* 23.4 Mbps */
              rate = 23400000;
              break;
           
            case 16:
            case 18:
              /* 28 Mbps */
              rate = 28000000;
              break;
           
            default:
              WRRC_MSG0_HIGH("Invalid rate for HS rab for MIMO");
              break;
          }
        }
        else
#endif/*FEATURE_WCDMA_MIMO*/
        {
          switch(nv_hsdpa_category)
          {
            case 13:
            case 15:
            case 17:
              /* 10.1 Mbps */
              rate = 10100000;
              break;

            case 14:
            case 16:
            case 18:
              /* 14.0 Mbps */
              rate = 14000000;
              break;
           
            default:
              WRRC_MSG0_HIGH("Invalid rate for HS rab for MAC-EHS");
              break;
          }
        }              
      }
    }
    break;

#ifdef FEATURE_WCDMA_COMBINED_MIMO_AND_64QAM
    case 19:
    case 20:
#endif

    case 21:
    case 22:
    case 23:
    case 24:
    case 29:
    {
      if(is_rb_mapped_on_macehs_q)
      {
  /*RRC_GKG: Later add rate for HS/EHS/64QAM/MIMO etc.*/
#ifdef FEATURE_WCDMA_DC_HSDPA
        if(num_sec_hs_carrier)
        {
          switch(nv_hsdpa_category)
          {
            case 24:
            case 29:
             /*42 Mbps*/
             rate = 21000000*(num_sec_hs_carrier + 1);
             break;

            default:
              WRRC_MSG1_HIGH("DC-HSDPA: Invalid HS Rate for CAT %d",nv_hsdpa_category);
          }
        }
        else
#endif /*FEATURE_WCDMA_DC_HSDPA*/
#ifdef FEATURE_WCDMA_COMBINED_MIMO_AND_64QAM
        if((((rrcllc_get_mimo_status() == RRC_MIMO_ACTIVE) && (mimo_action != L1_MIMO_STOP) ) ||
             (mimo_action == L1_MIMO_START))&&(rrcllc_get_64QAM_status()))
        {
          switch(rrc_macehs_cat)
          {
            case 20:
            case 19:
              /* 42 Mbps */
              rate = 42000000;
              break;

            default:
              WRRC_MSG0_ERROR("MIMO+64AM cant be set, set default rate as 7.2 mbp");
              /* 7.2 Mbps */
              rate = 7200000;
              break;              
          }
        }
        else
#endif
#if defined(FEATURE_WCDMA_MIMO) 
        if((((rrcllc_get_mimo_status() == RRC_MIMO_ACTIVE) && (mimo_action != L1_MIMO_STOP) ) ||
             (mimo_action == L1_MIMO_START)))
        {
          /* 28 Mbps */
          rate = 28000000;
        }
        else
#endif
        if(config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured == TRUE)
        {
          /* 21 Mbps */
          rate = 21000000;
        }
        else
        {
          /* 14 Mbps */
          rate = 14000000;
        }
      }
      else
      {
        switch(rrc_machs_cat)
        {
          case 8:
            /* 7.2 Mbps */
            rate = 7200000;
            break;

          case 9:
            /* 10.1 Mbps */
            rate = 10100000;
            break;

          case 10:
            /* 14.0 Mbps */
            rate = 14000000;
            break;
            
          default:
            WRRC_MSG0_ERROR("MAC-HS cat not set, set default rate as 7.2 mbp");
            /* 7.2 Mbps */
            rate = 7200000;
            break;
            
        }
      }
    }
    break;
    default:
    WRRC_MSG0_HIGH("Invalid rate for HS rab");
    break;
  }
  return rate;
}
/*====================================================================
FUNCTION: rrcllc_get_dl_ded_rate()

DESCRIPTION:
  This is called when dl rate for a particular rb is needed

DEPENDENCIES:
  None.

RETURN VALUE:
  uint32  - The uplink rate of the rb passed in.

SIDE EFFECTS:
  None
===================================================================*/
uint32 rrcllc_get_dl_ded_rate
(
  rrc_state_e_type  rrc_state,
  rrc_RB_Identity  rb_id
)
{
  uint32 data_size = RRCLLC_INVALID_RLC_SIZE;
  uint32 trch_count;
  uint32 tf_count;
  uint32 dlch_count;
  uint8 mac_hdr_size = 0;
  uint8 rlc_hdr_size = 0;
  boolean  rb_found = FALSE;
  ordered_config_type  *config_ptr;
  uint32 tti_in_ms = 0;
  uint32 rate = 0;
  hsdpa_action_enum_type hs_action = HSDPA_NOOP;
  rrc_hsdpa_status_enum_type hs_status = HSDPA_INACTIVE;
  boolean is_rb_mapped_to_dflow = FALSE;
  boolean is_rb_mapped_on_macehs_q = FALSE;
       
            
  if(config_ptr_in_use == ORDERED_CONFIG)
  {
    config_ptr = ordered_config_ptr;
  }
  else
  {
    config_ptr = current_config_ptr;
  }

  if(NULL == config_ptr)
  {
    WRRC_MSG0_ERROR("Config ptr is NULL, returing zero");
    return 0;
  }

  /* If state is ura_pch or cell_pch, and prev state is DCH, look into TOC */
  if ((rrc_state == RRC_STATE_CELL_PCH) || (rrc_state == RRC_STATE_URA_PCH)) 
  {
    if (RRC_STATE_CELL_DCH == rrc_get_prev_state()) 
    {
      config_ptr = transition_config.toc_ptr;
      rrc_state =  RRC_STATE_CELL_DCH;
    }
    else
    {
      /*make rrc_state as CELL_FACH to to look at dtch-fach mapping*/
      rrc_state =  RRC_STATE_CELL_FACH;
    }
  }

  if (rrc_state == RRC_STATE_CELL_DCH)
  {
    /* Look for the DCH that has the same RB mapped to it. Then calculate
    * RLC size from TrBlk size by substracting MAC header
    */
    for(
        trch_count = 0;
        (trch_count < config_ptr->l1_dl_cctrch_parms.num_trch) &&
          (rb_found == FALSE);
        trch_count ++
       )
    {
      for( dlch_count = 0;
           (dlch_count < config_ptr->mac_dl_parms.dch_info[trch_count]->ndlchan) &&
            (rb_found == FALSE);
           dlch_count ++
         )
      {
        if(config_ptr->mac_dl_parms.dch_info[trch_count]->
            dlchan_info[dlch_count].rb_id == rb_id)
        {
          rb_found = TRUE;
          data_size = 0;
          /*Set RLC header size based on RLC mode of the corresponding RB.*/
          if((config_ptr->mac_dl_parms.dch_info[trch_count]->
            dlchan_info[dlch_count].rlc_mode == UE_MODE_ACKNOWLEDGED) ||
          (config_ptr->mac_dl_parms.dch_info[trch_count]->
            dlchan_info[dlch_count].rlc_mode == UE_MODE_ACKNOWLEDGED_DATA) ||
          (config_ptr->mac_dl_parms.dch_info[trch_count]->
            dlchan_info[dlch_count].rlc_mode == UE_MODE_ACKNOWLEDGED_CONTROL))
          {
            rlc_hdr_size = 16;
          }
          else if(config_ptr->mac_dl_parms.dch_info[trch_count]->
            dlchan_info[dlch_count].rlc_mode == UE_MODE_UNACKNOWLEDGED)
          {
            rlc_hdr_size = 8;
          }
          else if(config_ptr->mac_dl_parms.dch_info[trch_count]->
            dlchan_info[dlch_count].rlc_mode == UE_MODE_TRANSPARENT)
          {
            rlc_hdr_size = 0;
          }
          /* This is the TrCH */
          if(config_ptr->mac_dl_parms.dch_info[trch_count]->ndlchan > 1)
          {
            /* Multiple dedicated logical channels mapped on DCH */
            mac_hdr_size = RRCLLC_DED_MULTI_LOG_CHL_DL_DCH_MAC_HDR_SIZE;
          }
          else
          {
            /* Single dedicated logical channel on DCH */
            mac_hdr_size = RRCLLC_DED_SINGLE_LOG_CHL_DL_DCH_MAC_HDR_SIZE;
          }

          for(
              tf_count = 0;
              tf_count < config_ptr->l1_dl_cctrch_parms.
                         trch_info_array[trch_count]->num_tf;
              tf_count ++
             )
          {
            if(config_ptr->l1_dl_cctrch_parms.trch_info_array[trch_count]->
                  tf_info_array[tf_count]->tb_size != 0)
            {
              /* If the tb_size less the mac_hdr_size is bigger than the
                 rlc_size, then we need to adjust the rlc_size up.  This
                 comparison is written with respect to zero to avoid a lint
                 warning about comparing signed and unsigned values, since a
                 subtraction always results in a signed value and the rlc_size
                 is an unsigned value. */
              if(
                 ((uint32)((config_ptr->l1_dl_cctrch_parms.trch_info_array[trch_count]->
                    tf_info_array[tf_count]->tb_size - (rlc_hdr_size +  mac_hdr_size)) * 
                   config_ptr->l1_dl_cctrch_parms.trch_info_array[trch_count]->
                    tf_info_array[tf_count]->num_tb) > data_size))
              {
                data_size = (config_ptr->l1_dl_cctrch_parms.
                  trch_info_array[trch_count]->tf_info_array[tf_count]->tb_size - 
                  (rlc_hdr_size + mac_hdr_size) )* config_ptr->l1_dl_cctrch_parms.
                  trch_info_array[trch_count]->tf_info_array[tf_count]->num_tb;
                tti_in_ms = rrc_convert_tti_to_ms(config_ptr->l1_dl_cctrch_parms.trch_info_array[trch_count]->tti_value); 
                rate = ((data_size * 1000)/tti_in_ms);
              }
            } /* Consider only those TFs that have TB size > 0 */
          } /* For all TFs in a TRCH */
        } /* If RB is found */
      } /* For all dedicated logical channels on this TrCH */
    }  /* For all TrCHs */

    /* Check for higher rates in HS.  Look for the rb_id in HS database */
    /* Look into all DFLOWs to get to the one mapped to the same RB ID */

    hs_status = rrc_get_hsdpa_status();
    hs_action = rrc_get_hsdpa_action();
    
    if (((hs_status == HSDPA_ACTIVE) &&
        (hs_action != HSDPA_STOP)) ||
        ((hs_status == HSDPA_INACTIVE) &&
          (hs_action == HSDPA_START)))
    {
       is_rb_mapped_to_dflow = rrcllc_check_if_rb_mapped_on_dflow(config_ptr, rb_id);
       is_rb_mapped_on_macehs_q = rrcllc_check_if_rb_mapped_on_macehs_q(config_ptr, rb_id);

       if(is_rb_mapped_to_dflow || is_rb_mapped_on_macehs_q)
      {
         rate = rrcllc_get_hs_dl_ded_rate(rb_id,is_rb_mapped_to_dflow,is_rb_mapped_on_macehs_q);
      }
    }
  } /* If state is Cell_DCH */

  else if(rrc_state == RRC_STATE_CELL_FACH)
  {
    /* For FACH, the MAC header for dedicated logical channel is 24 bits
     * if C-RNTI is used. If U-RNTI is used, it is 40 bits. Based on C-RNTI,
     * subtract 24 from TB Size to get RLC size for DCCH mapped on FACH
     */
    for(trch_count = 0;
        trch_count < config_ptr->l1_dl_cctrch_parms.num_trch && rb_found == FALSE;
        trch_count ++)
    {
      /* The Common Transport Channel could either be a PCH
       * or a FACH.
       */
      if(config_ptr->l1_dl_cctrch_parms.
          trch_info_array[trch_count]->ref_type == L1_DL_TRCH_FACH_TYPE)
      {
        if(config_ptr->mac_dl_parms.fach_info[trch_count]->ndlchan > 1)
        {
          /* Multiple dedicated logical channels on FACH */
          mac_hdr_size = RRCLLC_DED_MULTI_LOG_CHL_FACH_CRNTI_MAC_HDR_SIZE;
        }
        else
        {
          /* Single dedicated logical channel */
          mac_hdr_size = RRCLLC_DED_SINGLE_LOG_CHL_FACH_CRNTI_MAC_HDR_SIZE;
        }

        for (
             dlch_count = 0;
             (dlch_count < config_ptr->mac_dl_parms.fach_info[trch_count]->ndlchan) && 
              (rb_found == FALSE);
              dlch_count ++ )
        {
          if (config_ptr->mac_dl_parms.fach_info[trch_count]->dlchan_info[dlch_count].rb_id == rb_id) 
          {
            rb_found = TRUE;
            data_size = 0;
            /*RLC header is updated based on the RLC mode of the RB*/
            if((config_ptr->mac_dl_parms.fach_info[trch_count]->
              dlchan_info[dlch_count].rlc_mode == UE_MODE_ACKNOWLEDGED) ||
            (config_ptr->mac_dl_parms.fach_info[trch_count]->
              dlchan_info[dlch_count].rlc_mode == UE_MODE_ACKNOWLEDGED_DATA) ||
            (config_ptr->mac_dl_parms.fach_info[trch_count]->
              dlchan_info[dlch_count].rlc_mode == UE_MODE_ACKNOWLEDGED_CONTROL))
            {
              rlc_hdr_size = 16;
            }
            else if(config_ptr->mac_dl_parms.fach_info[trch_count]->
              dlchan_info[dlch_count].rlc_mode == UE_MODE_UNACKNOWLEDGED)
            {
              rlc_hdr_size = 8;
            }
            else if(config_ptr->mac_dl_parms.fach_info[trch_count]->
              dlchan_info[dlch_count].rlc_mode == UE_MODE_TRANSPARENT)
            {
              rlc_hdr_size = 0;
            }
            
            for(tf_count = 0;
                 tf_count < config_ptr->l1_dl_cctrch_parms.
                 trch_info_array[trch_count]->num_tf;
                 tf_count ++)
            {
              if(config_ptr->l1_dl_cctrch_parms.trch_info_array[trch_count]->
                 tf_info_array[tf_count]->tb_size > 0 && 
                 config_ptr->l1_dl_cctrch_parms.trch_info_array[trch_count]->
                 tf_info_array[tf_count]->num_tb > 0)
              {
                /* If the tb_size less the mac_hdr_size is bigger than the
                rlc_size, then we need to adjust the rlc_size up.  This
                comparison is written with respect to zero to avoid a lint
                warning about comparing signed and unsigned values, since a
               subtraction always results in a signed value and the rlc_size
               is an unsigned value. */
                if((uint32)((config_ptr->l1_dl_cctrch_parms.trch_info_array[trch_count]->
                    tf_info_array[tf_count]->tb_size - mac_hdr_size - rlc_hdr_size)* 
                   config_ptr->l1_dl_cctrch_parms.trch_info_array[trch_count]->
                    tf_info_array[tf_count]->num_tb) > data_size)
                {
                  data_size = (config_ptr->l1_dl_cctrch_parms.
                    trch_info_array[trch_count]->
                    tf_info_array[tf_count]->tb_size -
                    mac_hdr_size - rlc_hdr_size) * config_ptr->l1_dl_cctrch_parms.trch_info_array[trch_count]->
                    tf_info_array[tf_count]->num_tb;
                  tti_in_ms = rrc_convert_tti_to_ms(config_ptr->l1_dl_cctrch_parms.trch_info_array[trch_count]->tti_value); 
                  rate = ((data_size * 1000)/tti_in_ms);
                }
              }  /* If TB size > 0 */
            } /* For all TFs in a TRCH */ 
          } /* if RB_ID is found */
        } /* For all dedicated logical channels on this TrCH */
      } /* If TrCH type is a FACH */
    }  /* For all TrCHs */
#ifdef FEATURE_WCDMA_HS_FACH
    /* Check for higher rates in HS.  Look for the rb_id in HS database */
    /* Look into all DFLOWs to get to the one mapped to the same RB ID */
    if(rrcllc_get_hs_status_in_e_fach(ordered_config_ptr) == TRUE)
    {
      is_rb_mapped_on_macehs_q = rrcllc_check_if_rb_mapped_on_macehs_q_for_efach(config_ptr, rb_id);
      if(is_rb_mapped_on_macehs_q)
      {
        rate = rrcllc_get_hs_dl_ded_rate(rb_id,is_rb_mapped_to_dflow,is_rb_mapped_on_macehs_q);
      }
    }
#endif /* FEATURE_WCDMA_HS_FACH */
  } /* State is Cell_FACH */
  if(data_size == 0)
  {
    data_size = RRCLLC_INVALID_RLC_SIZE;
  }


  WRRC_MSG4_MED("DL Rate for rb_id %d is %d data size %d tti %d",rb_id, rate, data_size, tti_in_ms);
  return rate;
} /* end rrcllc_get_dl_ded_rate() */
/*====================================================================
FUNCTION: rrcllc_get_ul_ded_rate()

DESCRIPTION:
  This is called when the uplink rate for a particular rb is needed

DEPENDENCIES:
  None.

RETURN VALUE:
  uint32  - The uplink rate of the rb passed in.

SIDE EFFECTS:
  None
===================================================================*/
uint32 rrcllc_get_ul_ded_rate
(
  rrc_state_e_type  rrc_state,
  rrc_RB_Identity  rb_id
)
{
  uint32 data_size = RRCLLC_INVALID_RLC_SIZE;
  uint32 trch_count;
  uint32 tf_count;
  uint32 dlch_count;
  uint8 rlc_hdr_size = 0;
  boolean  rb_found = FALSE;
  uint32 rate = 0;
  uint32 tti_in_ms = 0;
  uint8 mac_hdr_size = 0;

  ordered_config_type  *config_ptr;

  if(config_ptr_in_use == ORDERED_CONFIG)
  {
    config_ptr = ordered_config_ptr;
  }
  else
  {
    config_ptr = current_config_ptr;
  }
  if(NULL == config_ptr)
  {
    WRRC_MSG0_ERROR("Config ptr is NULL, returing zero");
    return 0;
  }

  /* If state is ura_pch or cell_pch, and prev state is DCH, look into TOC */
  if ((rrc_state == RRC_STATE_CELL_PCH) || (rrc_state == RRC_STATE_URA_PCH)) 
  {
    if (RRC_STATE_CELL_DCH == rrc_get_prev_state()) 
    {
      config_ptr = transition_config.toc_ptr;
      rrc_state =  RRC_STATE_CELL_DCH;
    }
    else
    {
      /*make rrc_state as CELL_FACH to to look at dtch-fach mapping*/
      rrc_state =  RRC_STATE_CELL_FACH;
    }
  }

  /* Note: UL UM could only be a dedicated logical channel */
  if(rrc_state == RRC_STATE_CELL_DCH)
  {
    for(trch_count = 0;
        (trch_count < config_ptr->ul_tfcs.nchan) &&
          (rb_found == FALSE);
        trch_count ++)
    {
      for(
          dlch_count = 0;
          (dlch_count < config_ptr->mac_ul_parms.cctrch_ptr->dch_info.
            dch_info[trch_count].ndlchan) &&
            (rb_found == FALSE);
          dlch_count ++
         )
      {
        mac_hdr_size = 0;
        if ( config_ptr->mac_ul_parms.cctrch_ptr->dch_info.dch_info[trch_count].ndlchan > 1)
        {
          /*Multiple dedicated logical channels mapped on DCH */  
          mac_hdr_size = RRCLLC_DED_MULTI_LOG_CHL_DL_DCH_MAC_HDR_SIZE;
        }
        else
        {
          /*Single dedicated logical channel on DCH */
          mac_hdr_size = RRCLLC_DED_SINGLE_LOG_CHL_DL_DCH_MAC_HDR_SIZE;
        }
							
        if(config_ptr->mac_ul_parms.cctrch_ptr->dch_info.
           dch_info[trch_count].dlchan_info[dlch_count].rb_id == rb_id)
        {
          data_size = 0;
          rb_found = TRUE;
          /*RLC header is updated based on the RLC mode of the RB*/
          if((config_ptr->mac_ul_parms.cctrch_ptr->dch_info.dch_info[trch_count].
            dlchan_info[dlch_count].rlc_mode == UE_MODE_ACKNOWLEDGED) ||
          (config_ptr->mac_ul_parms.cctrch_ptr->dch_info.dch_info[trch_count].
            dlchan_info[dlch_count].rlc_mode == UE_MODE_ACKNOWLEDGED_DATA) ||
          (config_ptr->mac_ul_parms.cctrch_ptr->dch_info.dch_info[trch_count].
            dlchan_info[dlch_count].rlc_mode == UE_MODE_ACKNOWLEDGED_CONTROL))
          {
            rlc_hdr_size = 16;
          }
          else if(config_ptr->mac_ul_parms.cctrch_ptr->dch_info.dch_info[trch_count].
            dlchan_info[dlch_count].rlc_mode == UE_MODE_UNACKNOWLEDGED)
          {
            rlc_hdr_size = 8;
          }
          else if(config_ptr->mac_ul_parms.cctrch_ptr->dch_info.dch_info[trch_count].
            dlchan_info[dlch_count].rlc_mode == UE_MODE_TRANSPARENT)
          {
            rlc_hdr_size = 0;
          }          
          
          /* Get the RLC size */
          for(tf_count = 0;
              tf_count < config_ptr->ul_tfcs.tfs_info[trch_count].ntf;
              tf_count ++)
          {
            if((uint32)((config_ptr->ul_tfcs.tfs_info[trch_count].
                tf_info[tf_count].tb_size - rlc_hdr_size - mac_hdr_size) *  
                config_ptr->ul_tfcs.tfs_info[trch_count].
                tf_info[tf_count].ntblks) > data_size)
            {
              /* In Uplink the Transport format set in Ordered Config is
               * in terms of RLC PDU size as sent in RRC message.
               */
              data_size =  (config_ptr->ul_tfcs.tfs_info[trch_count].
                          tf_info[tf_count].tb_size - rlc_hdr_size - mac_hdr_size) * 
                config_ptr->ul_tfcs.tfs_info[trch_count].tf_info[tf_count].ntblks ;
              tti_in_ms = rrc_convert_tti_to_ms(config_ptr->ul_tfcs.tfs_info[trch_count].tti_info); 
              rate = ((data_size * 1000)/tti_in_ms);
            }
          }  /* For all TFs of a TrCH */
        }  /* If this TrCH has the same RB ID mapped to it */
      } /* For all dedicated logical channels */
    } /* For all Transport Channels */

    /* Check for higher rates in HS.  Look for the rb_id in EDCH database */
    if (TRUE == rrc_is_eul_active())
    {
      rb_found = FALSE;
      for(trch_count = 0;
           (trch_count < config_ptr->mac_e_config.num_e_mac_d_flow) &&
           (rb_found == FALSE);
           trch_count ++)
      {
        for (dlch_count=0;
             dlch_count < config_ptr->mac_e_config.e_mac_d_flow_info[trch_count].num_logch; 
             dlch_count++)
        {
          if (config_ptr->mac_e_config.e_mac_d_flow_info[trch_count].e_ul_logch_info[dlch_count].rb_id == rb_id)
          {
            /* set data seize to non-zero value so that it doesn't return invalid below*/
            data_size = 1;
            rb_found = TRUE;

            /*The relation between HSUPA categories and rate is taken from Spec 25.306 7.80 
            (Table 5.1g: FDD E-DCH physical layer categories). Here 1 Mbps  = (1000 * 1000) bps*/			
            switch (wcdma_nv_hsupa_category) 
            {
              case 1:
                /* 0.7110 Mbps */
                rate = 711000;
                break;

              case 2:
                if(config_ptr->mac_e_config.e_tti == E_TTI_10MS)
                {
                  /* 1.4484 Mbps */
                  rate = 1448400;
                }
                else if(config_ptr->mac_e_config.e_tti == E_TTI_2MS)
                {
                  /* 1.3990 Mbps*/
                  rate = 1399000;
                }
                else
                {
                  WRRC_MSG0_HIGH("Invalid rate for EUL rab");
                }
                break;

              case 3:
                /* 1.4484 Mpbs */
                rate = 1448400;
                break;

              case 4:
                if(config_ptr->mac_e_config.e_tti == E_TTI_10MS)
                {
                  /* 2.0000 Mbps */
                  rate = 2000000;
                }
                else if(config_ptr->mac_e_config.e_tti == E_TTI_2MS)
                {
                  /*2.8860 Mbps*/
                  rate = 2886000;
                }
                else
                {
                  WRRC_MSG0_HIGH("Invalid rate for EUL rab");
                }
                break;

              case 5:
                /* 2.0000 Mbps */
                rate = 2000000;
                break;

              case 6:
                if(config_ptr->mac_e_config.e_tti == E_TTI_10MS)
                {
                  /* 2.0000 Mbps */
                  rate = 2000000;
                }
                else if(config_ptr->mac_e_config.e_tti == E_TTI_2MS)
                {
                  /* 5.7420 Mbps */
                  rate = 5742000;
                }
                else
                {
                  WRRC_MSG0_HIGH("Invalid rate for EUL rab");
                }
                break;

              case 7:
#ifdef FEATURE_WCDMA_DC_HSUPA
              case 8:
#endif
                if(config_ptr->mac_e_config.e_tti == E_TTI_10MS)
                {
                  /* 2.0000 Mbps */
                  rate = 2000000;
                }
                else if(config_ptr->mac_e_config.e_tti == E_TTI_2MS)
                {
                  /* 11.4980 Mbps */
                  rate = 11498000;
                }
                else
                {
                  WRRC_MSG0_HIGH("Invalid rate for EUL rab");
                }
                break;

            default:
              WRRC_MSG0_HIGH("Invalid rate for EUL rab");
              break;
            }
            break;
          }
        }		
      }
    }
  } /* State is DCH */
  else if(rrc_state == RRC_STATE_CELL_FACH)
  {
    for(trch_count = 0;
        trch_count < config_ptr->ul_tfcs.nchan && rb_found == FALSE;
        trch_count ++)
    {
      mac_hdr_size = 0;
      
      if(config_ptr->mac_ul_parms.cctrch_ptr->rach_info.ndlchan > 1)
      {
        /*Multiple DCCH/DTCH logical channels mapped on RACH then header size 24*/
        mac_hdr_size = RRCLLC_DED_MULTI_LOG_CHL_RACH_MAC_HDR_SIZE;
      }
      else if (config_ptr->mac_ul_parms.cctrch_ptr->rach_info.ndlchan == 1)
      {
        /*Single DCCH/DTCH logical channel mapped on RACH then header size 20*/
        mac_hdr_size = RRCLLC_DED_SINGLE_LOG_CHL_RACH_MAC_HDR_SIZE;
      }
      else if (config_ptr->mac_ul_parms.cctrch_ptr->rach_info.ccch_enable == TRUE)
      {
        /*Only CCCH mapped on RACH then header size 2*/
        mac_hdr_size= RRCLLC_COM_LOG_CHL_RACH_MAC_HDR_SIZE;
      }
		
      for(
          dlch_count = 0;
          (dlch_count < config_ptr->mac_ul_parms.cctrch_ptr->rach_info.ndlchan) &&
           (rb_found == FALSE);
          dlch_count ++
            )
      {
        if(config_ptr->mac_ul_parms.cctrch_ptr->rach_info.dlchan_info[dlch_count].rb_id == rb_id)
        {
          data_size = 0;
          rb_found = TRUE;
          if((config_ptr->mac_ul_parms.cctrch_ptr->rach_info.dlchan_info[dlch_count].
            rlc_mode == UE_MODE_ACKNOWLEDGED) ||
          (config_ptr->mac_ul_parms.cctrch_ptr->rach_info.dlchan_info[dlch_count].
            rlc_mode == UE_MODE_ACKNOWLEDGED_DATA) ||
          (config_ptr->mac_ul_parms.cctrch_ptr->rach_info.dlchan_info[dlch_count].
            rlc_mode == UE_MODE_ACKNOWLEDGED_CONTROL))
          {
            rlc_hdr_size = 16;
          }
          else if(config_ptr->mac_ul_parms.cctrch_ptr->rach_info.dlchan_info[dlch_count].
            rlc_mode == UE_MODE_UNACKNOWLEDGED)
          {
            rlc_hdr_size = 8;
          }
          else if(config_ptr->mac_ul_parms.cctrch_ptr->rach_info.dlchan_info[dlch_count].
            rlc_mode == UE_MODE_TRANSPARENT)
          {
            rlc_hdr_size = 0;
          }          
          for(tf_count = 0;
               tf_count < config_ptr->ul_tfcs.tfs_info[trch_count].ntf;
               tf_count ++)
          {
            /* If the tb_size less the mac_hdr_size is bigger than the
            rlc_size, then we need to adjust the rlc_size up.  This
            comparison is written with respect to zero to avoid a lint
            warning about comparing signed and unsigned values, since a
            subtraction always results in a signed value and the rlc_size
            is an unsigned value. */
            if((uint32)((config_ptr->ul_tfcs.tfs_info[trch_count].
                tf_info[tf_count].tb_size - mac_hdr_size - rlc_hdr_size) * 
               config_ptr->ul_tfcs.tfs_info[trch_count].
                tf_info[tf_count].ntblks) > data_size)
            {
              data_size =  (config_ptr->ul_tfcs.tfs_info[trch_count].
                           tf_info[tf_count].tb_size - mac_hdr_size - rlc_hdr_size) * 
                config_ptr->ul_tfcs.tfs_info[trch_count].tf_info[tf_count].ntblks;
              tti_in_ms = rrc_convert_tti_to_ms(config_ptr->ul_tfcs.tfs_info[trch_count].tti_info);
              rate = ((data_size * 1000)/tti_in_ms);
            }
          }  /* For all TFs of a TrCH */
        } /* if rb_id is found */
      } /* for all dedicated logical channel*/
    } /* For all Transport Channels */
#ifdef FEATURE_WCDMA_HS_RACH
    /* Check for higher rates in HS.  Look for the rb_id in EDCH database */
    if (TRUE == rrchsrach_get_common_edch_transmission_wof3(config_ptr))
    {
      rb_found = FALSE;
      for(trch_count = 0;
           (trch_count < config_ptr->mac_hs_rach_config.hs_rach_config.num_e_mac_d_flow) &&
           (rb_found == FALSE);
           trch_count ++)
      {
        for (dlch_count=0;
             dlch_count < config_ptr->mac_hs_rach_config.hs_rach_config.e_mac_d_flow_info[trch_count].num_logch; 
             dlch_count++)
        {
          if (config_ptr->mac_hs_rach_config.hs_rach_config.e_mac_d_flow_info[trch_count].e_ul_logch_info[dlch_count].rb_id == rb_id)
          {
            /* set data seize to non-zero value so that it doesn't return invalid below*/
            data_size = 1;
            rb_found = TRUE;

            /*The relation between HSUPA categories and rate is taken from Spec 25.306 7.80 
            (Table 5.1g: FDD E-DCH physical layer categories). Here 1 Mbps  = (1000 * 1000) bps*/     
            switch (wcdma_nv_hsupa_category) 
            {
              case 1:
                /* 0.7110 Mbps */
                rate = 711000;
                break;

              case 2:
                if(config_ptr->mac_hs_rach_config.hs_rach_config.e_tti == E_TTI_10MS)
                {
                  /* 1.4484 Mbps */
                  rate = 1448400;
                }
                else if(config_ptr->mac_hs_rach_config.hs_rach_config.e_tti == E_TTI_2MS)
                {
                  /* 1.3990 Mbps*/
                  rate = 1399000;
                }
                else
                {
                  WRRC_MSG0_HIGH("RRCHSRACH:Invalid rate for EUL rab");
                }
                break;

              case 3:
                /* 1.4484 Mpbs */
                rate = 1448400;
                break;

              case 4:
                if(config_ptr->mac_hs_rach_config.hs_rach_config.e_tti == E_TTI_10MS)
                {
                  /* 2.0000 Mbps */
                  rate = 2000000;
                }
                else if(config_ptr->mac_hs_rach_config.hs_rach_config.e_tti == E_TTI_2MS)
                {
                  /*2.8860 Mbps*/
                  rate = 2886000;
                }
                else
                {
                  WRRC_MSG0_HIGH("RRCHSRACH:Invalid rate for EUL rab");
                }
                break;

              case 5:
                /* 2.0000 Mbps */
                rate = 2000000;
                break;

              case 6:
                if(config_ptr->mac_hs_rach_config.hs_rach_config.e_tti == E_TTI_10MS)
                {
                  /* 2.0000 Mbps */
                  rate = 2000000;
                }
                else if(config_ptr->mac_hs_rach_config.hs_rach_config.e_tti == E_TTI_2MS)
                {
                  /* 5.7420 Mbps */
                  rate = 5742000;
                }
                else
                {
                  WRRC_MSG0_HIGH("RRCHSRACH:Invalid rate for EUL rab");
                }
                break;

              case 7:
                if(config_ptr->mac_hs_rach_config.hs_rach_config.e_tti == E_TTI_10MS)
                {
                  /* 2.0000 Mbps */
                  rate = 2000000;
                }
                else if(config_ptr->mac_hs_rach_config.hs_rach_config.e_tti == E_TTI_2MS)
                {
                  /* 11.4980 Mbps */
                  rate = 11498000;
                }
                else
                {
                  WRRC_MSG0_HIGH("RRCHSRACH:Invalid rate for EUL rab");
                }
                break;

            default:
              WRRC_MSG0_HIGH("RRCHSRACH:Invalid rate for EUL rab");
              break;
            }
            break;
          }
        }   
      }
    }
#endif /* FEATURE_WCDMA_HS_RACH */

  } /* State is FACH */
  if(data_size == 0)
  {
    data_size = RRCLLC_INVALID_RLC_SIZE;
  }


  WRRC_MSG4_MED("UL Rate for rb_id %d is %d data size %d tti %d",rb_id, rate,data_size, tti_in_ms);
  return rate;
} /* end rrcllc_get_ul_ded_rlc_size() */
/*====================================================================
FUNCTION: rrcllc_translate_n313

DESCRIPTION:
  This function translates the enum for timer N313 into an int16 value.

DEPENDENCIES:
  None

RETURN VALUE:
  uint16 value corresponding to the enum passed, 0 if invalid

SIDE EFFECTS:
====================================================================*/
static uint16 rrcllc_translate_n313(rrc_N_313 val)
{
  switch (val)
  {
    case rrc_N_313_s1:
      return 1;
    case rrc_N_313_s2:
      return 2;
    case rrc_N_313_s4:
      return 4;
    case rrc_N_313_s10:
      return 10;
    case rrc_N_313_s20:
      return 20;
    case rrc_N_313_s50:
      return 50;
    case rrc_N_313_s100:
      return 100;
    case rrc_N_313_s200:
      return 200;
    default:
      return 0; /*lint !e527  This default case is flagged unreachable, since
                              we cover all the enum values in the case
                              clauses, but we want it here anyway for extra
                              safety. */
  }
}

/*====================================================================
FUNCTION: rrcllc_get_timers_and_const_in_conn_mode_for_handover

DESCRIPTION:
  This function initializes default connected mode timers and
  constants for GtoW handover.  Defaults are used here because the
  UE does not have access to SIB1 at this point.

DEPENDENCIES:
  None

RETURN VALUE:
  None.

SIDE EFFECTS:
====================================================================*/
void
rrcllc_get_timers_and_const_in_conn_mode_for_handover(void)
{
  //initialize timers and constants to mandatory default params
  rrc_initialize_ue_conn_timers_and_constants();

  ordered_config_ptr->l1_dl_chan_parms.sync_det.N312 = (uint16)RRC_GET_N312();
  ordered_config_ptr->l1_dl_chan_parms.sync_det.N313 =
    rrcllc_translate_n313(RRC_GET_N313());
  ordered_config_ptr->l1_dl_chan_parms.sync_det.N315 = (uint16)RRC_GET_N315();

  ordered_config_ptr->l1_dl_chan_parms.sync_det.T312 = (uint8)RRC_GET_T312();
  ordered_config_ptr->l1_dl_chan_parms.sync_det.T313 = (uint8)RRC_GET_T313();

}


/*====================================================================
FUNCTION: rrcllc_get_timers_and_const_in_conn_mode

DESCRIPTION:
  This function takes a pointer to the serving cell SIB 1 and
  copies all timers and constant values that are needed by L1
  into Ordered Config. If an element is mandatory default, the
  default value is supplied if it is not present in the SIB.

DEPENDENCIES:
  None

RETURN VALUE:
  None.

SIDE EFFECTS:
====================================================================*/
static uecomdef_status_e_type
rrcllc_get_timers_and_const_in_conn_mode
(
  ordered_config_type *config_ptr,
  rrc_SysInfoType1 *sib1_ptr
)
{
  if(sib1_ptr == NULL)
  {
    WRRC_MSG0_ERROR("Passed NULL SIB1 pointer");
    return(FAILURE);
  }
  /* Get the Physical Channel Establishment Criteria counter value */
  config_ptr->l1_dl_chan_parms.sync_det.N312 = (uint16)RRC_GET_N312();

  /* Get the Radio Link Failure Criteria counter value. */
  config_ptr->l1_dl_chan_parms.sync_det.N313 =
    rrcllc_translate_n313(RRC_GET_N313());

  /* Get the Radio Link Re-establishment Criteria counter value. */
  config_ptr->l1_dl_chan_parms.sync_det.N315 = (uint16)RRC_GET_N315();

  /* Get the Physical Channel establishment timer T312 */
  config_ptr->l1_dl_chan_parms.sync_det.T312 =
      (uint8)RRC_GET_T312();

  /* Get the Radio Link Failure timer T313 */
  config_ptr->l1_dl_chan_parms.sync_det.T313 =
    (uint8)RRC_GET_T313();

  /* Indicate that L1 Downlink needs to be reconfigured */
  config_ptr->reconfig_needed.downlink_l1 = TRUE;
  /* Although no new parameters for MAC have been received, MAC
  * still needs to be reconfigured so as to get the new CCTrCH
  * ID whenever Downlink L1 is reconfigured. This is due to the
  * interface requirements.
  */
  config_ptr->reconfig_needed.downlink_mac = TRUE;

  return(SUCCESS);
} /*  rrcllc_get_timers_and_const_in_conn_mode */


/*====================================================================
FUNCTION: rrcllc_copy_sib_to_oc

DESCRIPTION:
  This function takes a pointer to the serving cell data base for
  SIB 5 and copies all applicable IEs for RLC, MAC and L1 and places
  it into an internal format from the format received and processed
  over-the-air.

DEPENDENCIES:
  SIB 6 is currently not supported.

RETURN VALUE:
  None.

SIDE EFFECTS:
  If SIB 6 is available, SIB 6 data will instead be used in place of
  SIB 5 data. In other words, the correct SIB data will be used.
====================================================================*/
uecomdef_status_e_type rrcllc_copy_sib_to_oc(rrc_state_e_type next_rrc_state)
{
  rrc_SysInfoType1    *sib1_ptr = NULL;
  rrc_SysInfoType3    *sib3_ptr = NULL;
  rrc_SysInfoType4    *sib4_ptr = NULL;
  rrc_SysInfoType5    *sib5_ptr = NULL;
  rrc_SysInfoType6    *sib6_ptr = NULL;
  rrc_SysInfoType7    *sib7_ptr = NULL;

  /* Pointer & counter to loop through the CN System Information List */
  rrc_CN_DomainSysInfoList * cn_ptr = NULL;
  uint8 cn_cnt                    = 0;

  /* Pointer & counter to loop through the Dynamic Persistence level values */
  rrc_DynamicPersistenceLevelList *dpl_ptr = NULL;
  uint8 dpl_cnt                                   = 0;

  /* If we are going to a connected mode state, we must use the connected mode
     specific SIBs if they are available. */
  boolean use_conn_mode_sibs = FALSE;
  rrc_AdditionalPRACH_TF_and_TFCS_CCCH_List * rrc_additional_prach_TF_list = NULL;
  /* Check the state to find out what initializations to perform on OC */
  switch(next_rrc_state)
  {
    case RRC_STATE_CELL_DCH:
      WRRC_MSG0_HIGH("Invalid state to read sibs");
      return FAILURE;

    case RRC_STATE_DISCONNECTED:
    case RRC_STATE_CONNECTING:
      use_conn_mode_sibs = FALSE;
      break;

    case RRC_STATE_CELL_FACH:
    case RRC_STATE_CELL_PCH:
    case RRC_STATE_URA_PCH:

      use_conn_mode_sibs = TRUE;
      break;

    default:
      WRRC_MSG1_HIGH("Invalid RRC state %d passed", next_rrc_state);
      return(FAILURE);

  } /* end switch */

  /************************/
  /* Get SIB 1 data first */
  /************************/
  sib1_ptr = (rrc_SysInfoType1 *)
               rrc_sibdb_return_sib_for_srv_cell(rrc_SIB1);
  if (sib1_ptr == NULL)
  {
     WRRC_MSG0_ERROR("SIB 1 not yet in SIB data base");
     return FAILURE;
  }

  /* Get the CS and PS DRX Cycle Lengths */
  cn_ptr = &sib1_ptr->cn_DomainSysInfoList;

  while((cn_cnt < cn_ptr->n ) && (cn_cnt < UE_MAX_CN_DOMAINS))
  {
    if((cn_ptr->elem[cn_cnt].cn_DRX_CycleLengthCoeff >= RRCLLC_CN_DOMAIN_MIN_DRX_CYCLE_LENGTH) &&
       (cn_ptr->elem[cn_cnt].cn_DRX_CycleLengthCoeff <= RRCLLC_CN_DOMAIN_MAX_DRX_CYCLE_LENGTH))
    {
      switch(cn_ptr->elem[cn_cnt].cn_DomainIdentity)
      {
        case rrc_CN_DomainIdentity_cs_domain:
          ordered_config_ptr->cs_drx_cycle_length =
            (uint32) (1 << cn_ptr->elem[cn_cnt].cn_DRX_CycleLengthCoeff);
          break;
        case rrc_CN_DomainIdentity_ps_domain:
          ordered_config_ptr->ps_drx_cycle_length =
            (uint32) (1 << cn_ptr->elem[cn_cnt].cn_DRX_CycleLengthCoeff);
          break;
        default:
          WRRC_MSG1_ERROR("Invalid CN 0x%x for DRX", cn_ptr->elem[cn_cnt].cn_DomainIdentity);
          return FAILURE;
      } /* end CN Identity switch */
    } /* end drx cycle length check */
    else
    {
      /* A SIB with invalid DRX length coefficient is unacceptable */
      WRRC_MSG2_ERROR("Invalid DRX len value %d, CN domain %d",
          cn_ptr->elem[cn_cnt].cn_DRX_CycleLengthCoeff, cn_cnt);
      return FAILURE;
    }
    /* Next CN Info */
    cn_cnt++;
  } /* end while Core Network Info */

  /* Check to make sure both Core Networks have good DRX info */
  if(ordered_config_ptr->ps_drx_cycle_length == 0)
  {
    /* This indicates PS domain not present */
    if(ordered_config_ptr->cs_drx_cycle_length > 0)
    {
      ordered_config_ptr->ps_drx_cycle_length =
        ordered_config_ptr->cs_drx_cycle_length;
    }
    else
    {
      WRRC_MSG0_ERROR("Both PS and CS DRX info missing");
      return FAILURE;
    }
  }

  if(ordered_config_ptr->cs_drx_cycle_length == 0)
  {
    /* This indicates CS domain not present */
    if(ordered_config_ptr->ps_drx_cycle_length > 0)
    {
      ordered_config_ptr->cs_drx_cycle_length =
        ordered_config_ptr->ps_drx_cycle_length;
    }
    else
    {
      WRRC_MSG0_ERROR("Both PS and CS DRX info missing");
      return FAILURE;
    }
  }

  /* Only T312 and N312 in Idle mode timers and constants are needed
   * by L1. There is no need to read them in Idle mode since they are
   * going to be used only in Connected mode.
   */
  if(rrcllc_get_timers_and_const_in_conn_mode(ordered_config_ptr, sib1_ptr) == FAILURE)
  {
    return(FAILURE);
  }

  /************************/
  /* Get SIB 3 data next  */
  /************************/
  sib3_ptr = (rrc_SysInfoType3 *)
             rrc_sibdb_return_sib_for_srv_cell(rrc_SIB3);
  if (sib3_ptr == NULL)
  {
     WRRC_MSG0_ERROR("SIB 3 not yet in SIB data base");
     return FAILURE;
  }

  if(use_conn_mode_sibs && (sib3_ptr->sib4indicator == TRUE) && ((sib4_ptr = (rrc_SysInfoType4 *)
                                                                  rrc_sibdb_return_sib_for_srv_cell(rrc_SIB4)) != NULL))
  {
    if((sib4_ptr->cellSelectReselectInfo.maxAllowedUL_TX_Power >= RRCLLC_MIN_ALLOW_UL_TX_PWR) &&
       (sib4_ptr->cellSelectReselectInfo.maxAllowedUL_TX_Power <= RRCLLC_MAX_ALLOW_UL_TX_PWR))
    {
      ordered_config_ptr->l1_ul_chan_parms.max_tx_pwr =
        (int8) sib4_ptr->cellSelectReselectInfo.maxAllowedUL_TX_Power;
      /* Indicate that L1 UL needs to be reconfigured */
      ordered_config_ptr->reconfig_needed.uplink_l1 = TRUE;
    }
    else
    {
      WRRC_MSG1_ERROR("Rcv'd invalid UL TX PWR %d", sib4_ptr->cellSelectReselectInfo.maxAllowedUL_TX_Power);
      return FAILURE;
    }
  } /* If next state == Cell_FACH AND SIB 4 is present */
  else
  {
    if((sib3_ptr->cellSelectReselectInfo.maxAllowedUL_TX_Power >= RRCLLC_MIN_ALLOW_UL_TX_PWR) &&
       (sib3_ptr->cellSelectReselectInfo.maxAllowedUL_TX_Power <= RRCLLC_MAX_ALLOW_UL_TX_PWR)
      )
    {
      ordered_config_ptr->l1_ul_chan_parms.max_tx_pwr =
        (int8) sib3_ptr->cellSelectReselectInfo.maxAllowedUL_TX_Power;
      /* Indicate that L1 UL needs to be reconfigured */
      ordered_config_ptr->reconfig_needed.uplink_l1 = TRUE;
    }
    else
    {
      WRRC_MSG1_ERROR("Rcv'd invalid UL TX PWR %d", sib3_ptr->cellSelectReselectInfo.maxAllowedUL_TX_Power);
      return FAILURE;
    }
  }

  /************************/
  /* Get SIB 7 data next  */
  /************************/
  sib7_ptr = (rrc_SysInfoType7 *)
             rrc_sibdb_return_sib_for_srv_cell(rrc_SIB7);
  if (sib7_ptr == NULL)
  {
     WRRC_MSG0_ERROR("SIB 7 not yet in SIB data base");
     return FAILURE;
  }
                                         

  /* Get the UL interference parameter */
  if(RRC_CHECK_COMMON_MSG_TYPE(sib7_ptr->modeSpecificInfo, rrc_SysInfoType7_modeSpecificInfo_fdd))
  {
    if((sib7_ptr->modeSpecificInfo.u.fdd->ul_Interference >=
        RRCLLC_MIN_UL_INTERFERENCE) &&
       (sib7_ptr->modeSpecificInfo.u.fdd->ul_Interference <=
        RRCLLC_MAX_UL_INTERFERENCE))
    {
      ordered_config_ptr->rrc_ul_pwr_init_parms.ul_interference =
       sib7_ptr->modeSpecificInfo.u.fdd->ul_Interference;
    }
    else
    {
      WRRC_MSG1_ERROR("Invalid value %d UL interference",sib7_ptr->modeSpecificInfo.u.fdd->ul_Interference);
      return(FAILURE);
    }
  }
  else
  {
    WRRC_MSG0_ERROR("Cell FDD info absent");
    return FAILURE;
  }

  /* We have to wait until we read SIB 5 before we can get the Dynamic
     Persistence level so we know whether to get the values for SIB 5 or
     SIB 6. */

  /************************/
  /* Get SIB 5 data next  */
  /************************/
  sib5_ptr = (rrc_SysInfoType5 *)
             rrc_sibdb_return_sib_for_srv_cell(rrc_SIB5);
  if (sib5_ptr == NULL)
  {
     WRRC_MSG0_ERROR("SIB 5 not yet in SIB data base");
     return FAILURE;
  }
  if(use_conn_mode_sibs && (sib5_ptr->sib6indicator == TRUE))
  {
    sib6_ptr = (rrc_SysInfoType6 *)
               rrc_sibdb_return_sib_for_srv_cell(rrc_SIB6);
    if (sib6_ptr == NULL)
    {
       /* SIB 6 may not be present. That is acceptable */
       WRRC_MSG0_HIGH("SIB 6 not in SIB data base");
    }
  }

  /* Get the Dynamic Persistence level */
  if(use_conn_mode_sibs && (sib5_ptr->sib6indicator == TRUE))
  {
    dpl_ptr = &sib7_ptr->prach_Information_SIB6_List;
  }
  else
  {
    dpl_ptr = &sib7_ptr->prach_Information_SIB5_List;
  }
  while((dpl_cnt < dpl_ptr->n ) && (dpl_cnt < UE_MAX_PRACH))
  {
    ordered_config_ptr->dpl = dpl_ptr->elem[dpl_cnt];
    dpl_cnt++;
  }

  /* Get the PICH Power offset */
  if(sib6_ptr && use_conn_mode_sibs)
  {
    if(((int8)sib6_ptr->pich_PowerOffset >= RRCLLC_MIN_PICH_PWR_OFFSET) &&
       ((int8)sib6_ptr->pich_PowerOffset <= RRCLLC_MAX_PICH_PWR_OFFSET))
    {
      ordered_config_ptr->l1_dl_chan_parms.pich.pwr_offset =
        (int8)sib6_ptr->pich_PowerOffset;
      /* Indicate that L1 DL needs to be reconfigured */
      ordered_config_ptr->reconfig_needed.downlink_l1 = TRUE;
      /* Although no new parameters for MAC have been received, MAC
       * still needs to be reconfigured so as to get the new CCTrCH
       * ID whenever Downlink L1 is reconfigured. This is due to the
       * interface requirements.
       */
      ordered_config_ptr->reconfig_needed.downlink_mac = TRUE;
    }
    else
    {
      WRRC_MSG1_ERROR("invalid PICH Power Offset %d", (int8)sib6_ptr->pich_PowerOffset);
      return(FAILURE);
    }
  }
  else
  {
    if(((int8)sib5_ptr->pich_PowerOffset >= RRCLLC_MIN_PICH_PWR_OFFSET) &&
       ((int8)sib5_ptr->pich_PowerOffset <= RRCLLC_MAX_PICH_PWR_OFFSET))
    {
      ordered_config_ptr->l1_dl_chan_parms.pich.pwr_offset =
        (int8)sib5_ptr->pich_PowerOffset;
      /* Indicate that L1 DL needs to be reconfigured */
      ordered_config_ptr->reconfig_needed.downlink_l1 = TRUE;
      /* Although no new parameters for MAC have been received, MAC
       * still needs to be reconfigured so as to get the new CCTrCH
       * ID whenever Downlink L1 is reconfigured. This is due to the
       * interface requirements.
       */
      ordered_config_ptr->reconfig_needed.downlink_mac = TRUE;
    }
    else
    {
      WRRC_MSG1_ERROR("invalid PICH Power Offset %d", (int8)sib5_ptr->pich_PowerOffset);
      return(FAILURE);
    }
  } /* SIB 6 ptr is NULL */

  /* Get the AICH Power offset */
  if(sib6_ptr && use_conn_mode_sibs)
  {
    if(RRC_CHECK_COMMON_MSG_TYPE(sib6_ptr->modeSpecificInfo, rrc_SysInfoType6_modeSpecificInfo_fdd))
    {
      if(((int8) sib6_ptr->modeSpecificInfo.u.fdd->aich_PowerOffset >=
            RRCLLC_MIN_AICH_PWR_OFFSET) &&
         ((int8) sib6_ptr->modeSpecificInfo.u.fdd->aich_PowerOffset <=
            RRCLLC_MAX_AICH_PWR_OFFSET))
      {
        ordered_config_ptr->l1_dl_chan_parms.aich.pwr_offset =
          (int8) sib6_ptr->modeSpecificInfo.u.fdd->aich_PowerOffset;
        /* Indicate that L1 DL needs to be reconfigured */
        ordered_config_ptr->reconfig_needed.downlink_l1 = TRUE;
        /* Although no new parameters for MAC have been received, MAC
         * still needs to be reconfigured so as to get the new CCTrCH
         * ID whenever Downlink L1 is reconfigured. This is due to the
         * interface requirements.
         */
        ordered_config_ptr->reconfig_needed.downlink_mac = TRUE;
      }
      else
      {
        WRRC_MSG1_ERROR("Invalid value %d AICH power offset",
            sib6_ptr->modeSpecificInfo.u.fdd->aich_PowerOffset);
        return(FAILURE);
      }
    }
    else
    {
      WRRC_MSG0_ERROR("Cell FDD info absent");
      return FAILURE;
    }
  }
  else
  {
    if(RRC_CHECK_COMMON_MSG_TYPE(sib5_ptr->modeSpecificInfo, rrc_SysInfoType5_modeSpecificInfo_fdd))
    {
      if(((int8) sib5_ptr->modeSpecificInfo.u.fdd->aich_PowerOffset >=
            RRCLLC_MIN_AICH_PWR_OFFSET) &&
         ((int8) sib5_ptr->modeSpecificInfo.u.fdd->aich_PowerOffset <=
            RRCLLC_MAX_AICH_PWR_OFFSET))
      {
        ordered_config_ptr->l1_dl_chan_parms.aich.pwr_offset =
          (int8) sib5_ptr->modeSpecificInfo.u.fdd->aich_PowerOffset;
        /* Indicate that L1 DL needs to be reconfigured */
        ordered_config_ptr->reconfig_needed.downlink_l1 = TRUE;
        /* Although no new parameters for MAC have been received, MAC
         * still needs to be reconfigured so as to get the new CCTrCH
         * ID whenever Downlink L1 is reconfigured. This is due to the
         * interface requirements.
         */
        ordered_config_ptr->reconfig_needed.downlink_mac = TRUE;
      }
      else
      {
        WRRC_MSG1_ERROR("Invalid value %d AICH power offset",
            sib5_ptr->modeSpecificInfo.u.fdd->aich_PowerOffset);
        return(FAILURE);
      }
    }
    else
    {
      WRRC_MSG0_ERROR("Cell FDD info absent");
      return FAILURE;
    }
  }  /* SIB 6 ptr is NULL */

  /* Check to see if Primary PCCPCH info is present. If so, save it. */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(sib5_ptr,rrc_SysInfoType5,primaryCCPCH_Info))
  {
    /* This information is present */
    /* Note, ORDERED_CONFIG is always filled out for the serving cell */
    // new function call here due to modularization
    // rrcllc_set_pccpch(sib5_ptr->primaryCCPCH_Info.u.fdd.tx_DiversityIndicator);
  }
  /* else this IE is not present */

  /* Now get the PRACH system information */
  if(sib6_ptr && use_conn_mode_sibs)
  {
    if(RRC_MSG_COMMON_BITMASK_IE_PTR(sib6_ptr,rrc_SysInfoType6,prach_SystemInformationList))
    {
      if(RRCLLC_SIB6_ADD_PRACH_TF_EXT_PRESENT(sib6_ptr))
      {
        WRRC_MSG0_HIGH("ATF: ATF list is present in SIB6");
        rrc_additional_prach_TF_list =  &sib6_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtensions.
           v650nonCriticalExtensions.v690nonCriticalExtensions.sysInfoType6_v690ext.additionalPRACH_TF_and_TFCS_CCCH_List;
      }

      if(get_prach_sys_info(ordered_config_ptr, &sib6_ptr->prach_SystemInformationList
             ,rrc_additional_prach_TF_list,TRUE
        ) == FAILURE)
      {
        WRRC_MSG0_ERROR("Failure updating PRACH Info");
        return FAILURE;
      }
    } /* If PRACH Info present in SIB6 */
    else  /* Read it from SIB5 */ /* CHECK_VN */
    {
      if(RRCLLC_SIB5_ADD_PRACH_TF_EXT_PRESENT(sib5_ptr))
      {
              WRRC_MSG0_HIGH("ATF: ATF list is present in SIB5");
        rrc_additional_prach_TF_list = &sib5_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtensions.v650NonCriticalExtensions.
             v680NonCriticalExtensions.v690NonCriticalExtensions.sysInfoType5_v690ext.
             additionalPRACH_TF_and_TFCS_CCCH_List;
      }

      if(get_prach_sys_info(ordered_config_ptr, &sib5_ptr->prach_SystemInformationList
             ,rrc_additional_prach_TF_list,FALSE
        ) == FAILURE)
      {
        WRRC_MSG0_ERROR("Failure updating PRACH Info");
        return FAILURE;
      }
    }
  }
  else
  {
     
    if(RRCLLC_SIB5_ADD_PRACH_TF_EXT_PRESENT(sib5_ptr))
    {
      WRRC_MSG0_HIGH("ATF: ATF list is present in SIB5");
      rrc_additional_prach_TF_list = &sib5_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtensions.v650NonCriticalExtensions.
                        v680NonCriticalExtensions.v690NonCriticalExtensions.sysInfoType5_v690ext.additionalPRACH_TF_and_TFCS_CCCH_List;
    }

    if(get_prach_sys_info(ordered_config_ptr, &sib5_ptr->prach_SystemInformationList
             ,rrc_additional_prach_TF_list,FALSE
    ) == FAILURE)
    {
      WRRC_MSG0_ERROR("Failure updating PRACH Info");
      return FAILURE;
    }
  }


  /* Clause 8.6.5.1 of 25.331 specifies that we must ignore this SIB if the
     logical channel restriction type is set to explicit list and this is
     a RACH TFS.  We accomplish this (if necessary) by resetting the
     mac_update_needed flag for our RACH restriction information to FALSE.
     Although the rrcllc_populate_mac_rlc_size_restriction_info() function
     still gets called, nothing is done with the MAC structures, since this
     flag is set to FALSE. */
  if(ordered_config_ptr->rach_rlc_size_restriction_info.mac_update_needed)
  {
    int i;
    for(i = 0; i < MAX_DED_LOGCHAN_PER_TRCH; i++)
    {
      if(ordered_config_ptr->
         rach_rlc_size_restriction_info.rlc_size_list[i].restriction_type ==
         RLC_SIZES_EXPLICIT_LIST)
      {
        ordered_config_ptr->rach_rlc_size_restriction_info.mac_update_needed =
          FALSE;
      }
    }
  }

  /* Fill in the RLC size restriction information for MAC */
  (void)rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr,
                                                      ordered_config_ptr->
                                                      rrc_state_indicator);


  /* Now get the SCCPCH system information */
  if(use_conn_mode_sibs)
  {
    if ((ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid == NO_RNTI_VALID) ||
       (ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid == CRNTI_VALID))
    {
     /* We are going to be in one of Connected mode states and a valid URNTI
       * is NOT present - return from here - do not process SCCPCH info.
       */
       WRRC_MSG1_ERROR("RNTI not valid %d",ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid);
      /* Set the Config Pointer in Use */
      config_ptr_in_use = ORDERED_CONFIG;

      return(SUCCESS);
    }
  }

  if(sib6_ptr && use_conn_mode_sibs)
  {
    if(RRC_MSG_COMMON_BITMASK_IE_TYPE2_PTR(sib6_ptr,sCCPCH_SystemInformationList))
    {
      if(verify_sccpch_exists(&sib6_ptr->sCCPCH_SystemInformationList,
                              next_rrc_state)
         == TRUE)
      {
        /* If SCCPCH Info present inSIB6, read ot from there */
        if(get_sccpch_sys_info(ordered_config_ptr,
                               &sib6_ptr->sCCPCH_SystemInformationList,
                               next_rrc_state,TRUE)
         == FAILURE)
        {
         WRRC_MSG0_ERROR("Failure updating SCCPCH Info");
         return FAILURE;
        }
      } /* SCCPCH with FACH exists */
      else
      {
        if(get_sccpch_sys_info(ordered_config_ptr,
                               &sib5_ptr->sCCPCH_SystemInformationList,
                               next_rrc_state,FALSE)
         == FAILURE)
        {
         WRRC_MSG0_ERROR("Failure updating SCCPCH Info");
         return FAILURE;
        }
      } /* SCCPCH with FACH does NOT exist in SIB6 */
    } /* SCCPCH system info list present in SIB 6 */
    else
    {
      /* SCCPCH INfo not present in SIB6, read it from SIB 5 */
      /* CHECK_VN */
      if(get_sccpch_sys_info(ordered_config_ptr,
                             &sib5_ptr->sCCPCH_SystemInformationList,
                             next_rrc_state,FALSE)
       == FAILURE)
      {
       WRRC_MSG0_ERROR("Failure updating SCCPCH Info");
       return FAILURE;
      }
    }
  } /* SIB6 present and next state is CELL_FACH, CELL_PCH, URA_PCH */
  else /* SCCPCH system info in SIB 5 has to be used */
  {
    if(get_sccpch_sys_info(ordered_config_ptr,
                           &sib5_ptr->sCCPCH_SystemInformationList,
                           next_rrc_state,FALSE)
       == FAILURE)
    {
      WRRC_MSG0_ERROR("Failure updating SCCPCH Info");
      return FAILURE;
    }
  }

  /*
  * Note that since CTCH is not initially supported the CBS DRX
  * Level 1 information is not decoded here.
  */

  /* Getting CBS related info.  Get the Period of CTCH allocation (N) and
     CBS frame offset (K)  */
  if (next_rrc_state == RRC_STATE_DISCONNECTED || next_rrc_state == RRC_STATE_CELL_PCH ||
      next_rrc_state == RRC_STATE_URA_PCH )
  {
    if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status == RRCLLC_CTCH_WITH_PCCH)
    {
      ordered_config_ptr->l1_dl_chan_parms.sccpch[0].cbs_sched.ctch_info_present = TRUE;
      ordered_config_ptr->l1_dl_chan_parms.sccpch[0].cbs_sched.only_ctch_on_sccpch = FALSE;
/*When UE is in connected mode, it ignores any CTCH info present in SIB6 and only uses info in SIB5*/
      ordered_config_ptr->l1_dl_chan_parms.sccpch[0].cbs_sched.cbs_frame_offset =
        (uint16)sib5_ptr->cbs_DRX_Level1Information.cbs_FrameOffset;
      ordered_config_ptr->l1_dl_chan_parms.sccpch[0].cbs_sched.ctch_allocation_period =
        (uint16)sib5_ptr->cbs_DRX_Level1Information.ctch_AllocationPeriod;
    }
  }

  /* Set the Config Pointer in Use */
  config_ptr_in_use = ORDERED_CONFIG;

#ifdef FEATURE_WCDMA_FREE_FLOATING_TASK
  if((next_rrc_state == RRC_STATE_CONNECTING)||
     (next_rrc_state == RRC_STATE_CELL_FACH))
  {
    REX_ISR_LOCK(&rrc_ul_tx_pwr_mutex);
    rrc_ul_init_pwr.ul_interference = 
      ordered_config_ptr->rrc_ul_pwr_init_parms.ul_interference;
    rrc_ul_init_pwr.primary_cpich_tx_power = ordered_config_ptr->rrc_ul_pwr_init_parms.primary_cpich_tx_power;
    rrc_ul_init_pwr.constant_value = ordered_config_ptr->rrc_ul_pwr_init_parms.constant_value;
    REX_ISR_UNLOCK(&rrc_ul_tx_pwr_mutex);
  }
#endif

  return SUCCESS;
} /* end rrcllc_copy_sib_to_oc() */

/*====================================================================
FUNCTION: rrcllc_copy_cc_to_oc

DESCRIPTION:
  This function copies the current config and places it in ordered
  config. It also updates the ordered_config pointer.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_copy_cc_to_oc
(
  void
)
{
  WCDMA_MEMCPY(ordered_config_ptr, 
               sizeof(ordered_config_type),
               current_config_ptr, 
               sizeof(ordered_config_type));
  /* Now initialize all pointers in interface structures within
   * current config.
   * TBD: Remove these pointers in interface structures.
   */
  /* Initialize all pointers in L1, MAC and RLC structures */
  rrcllc_init_mac_dl_ptrs(ordered_config_ptr);
  rrcllc_init_mac_ul_ptrs(ordered_config_ptr);
  rrcllc_init_l1_dl_ptrs(ordered_config_ptr);
  rrcllc_init_l1_ul_ptrs(ordered_config_ptr);
  rrcllc_init_rlc_ptrs(ordered_config_ptr);

  /* Initialize Reconfig needed */
  rrcllc_init_reconfig_needed(ordered_config_ptr);

  config_ptr_in_use = ORDERED_CONFIG;
  WRRC_MSG0_HIGH("Copy CC to OC");

  ordered_config_ptr->mac_ul_parms.new_tfcs_list_present = FALSE;

  return;
} /* end rrcllc_copy_cc_to_oc() */

/*====================================================================
FUNCTION: rrcllc_copy_oc_to_cc

DESCRIPTION:
  This function copies the Ordered config and places it in Current
  config. It also updates the current_config pointer.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_copy_oc_to_cc
(
  void
)
{
  WCDMA_MEMCPY(current_config_ptr, 
               sizeof(ordered_config_type),
               ordered_config_ptr, 
               sizeof(ordered_config_type));
  /* Now initialize all pointers in interface structures within
   * current config.
   * TBD: Remove these pointers in interface structures.
   */
  /* Initialize all pointers in L1, MAC and RLC structures */
  rrcllc_init_mac_dl_ptrs(current_config_ptr);
  rrcllc_init_mac_ul_ptrs(current_config_ptr);
  rrcllc_init_l1_dl_ptrs(current_config_ptr);
  rrcllc_init_l1_ul_ptrs(current_config_ptr);
  rrcllc_init_rlc_ptrs(current_config_ptr);

  /* Initialize Reconfig needed */
  rrcllc_init_reconfig_needed(current_config_ptr);

  WRRC_MSG0_HIGH("Copy OC to CC");
  return;
} /* end rrcllc_copy_oc_to_cc() */

/*====================================================================
FUNCTION: rrcllc_copy_oc_to_toc

DESCRIPTION:
  This function copies the Ordered config to Transitional Ordered
  Config during a CELL_DCH to CELL_FACH state transition.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_copy_oc_to_toc
(
  void
)
{
  WCDMA_MEMCPY(transition_config.toc_ptr, 
               sizeof(ordered_config_type),
               ordered_config_ptr, 
               sizeof(ordered_config_type));
  /* Now initialize all pointers in interface structures within
   * current config.
   * TBD: Remove these pointers in interface structures.
   */
  /* Initialize all pointers in L1, MAC and RLC structures */
  rrcllc_init_mac_dl_ptrs(transition_config.toc_ptr);
  rrcllc_init_mac_ul_ptrs(transition_config.toc_ptr);
  rrcllc_init_l1_dl_ptrs(transition_config.toc_ptr);
  rrcllc_init_l1_ul_ptrs(transition_config.toc_ptr);
  rrcllc_init_rlc_ptrs(transition_config.toc_ptr);

  WRRC_MSG0_HIGH("Copy OC to TOC");

#ifdef FEATURE_UMTS_PDCP
  rrcllc_print_pdcp_info(transition_config.toc_ptr);
#endif /* FEATURE_UMTS_PDCP*/

  /*BCCH channel is up, make sure this does not carry to TOC, if it 
    carries over we will eventually see setup/reconfig failures as OC update 
    fails due to max dl tm channels
    This happens during when GPS event is active and DCH to FACH/PCH transition 
    or RL failure is triggered, needs to hit  atleast four times for the failure
    to occur
 */
  if(RRCLCM_RLC_LC_ID_NOT_FOUND != rrclcm_check_dl_rlc_lc_id(UE_LOGCHAN_BCCH,
                                                              BCCH_S_RADIO_BEARER_ID,
                                                              UE_MODE_TRANSPARENT))
  {
    transition_config.toc_ptr->rlc_dl_tm_parms.nchan-- ;
    WRRC_MSG1_HIGH("BCCH channel is up, decremented tm_parms.nchan in TOC, %d ",
              transition_config.toc_ptr->rlc_dl_tm_parms.nchan);
  }
  return;
} /* end rrcllc_copy_oc_to_toc() */


/*====================================================================
FUNCTION: rrcllc_process_non_critcal_trch_reconfig_ie_r5

DESCRIPTION:
  This function acts on the NON Critical IE for Trch Reconfig R5

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_process_non_critcal_trch_reconfig_ie_r5
(
  rrc_DL_DCCH_Message *dcch_ptr
)
{
  rrc_TransportChannelReconfiguration_r5 *rrc_trch_reconfig = &dcch_ptr->message.u.transportChannelReconfiguration.u.
            later_than_r3.criticalExtensions.u.criticalExtensions.u.r5;

 
  if(rrcllc_check_delay_restriction_ie_trch_reconfig_r5(dcch_ptr) ==TRUE)
  {
    rrcllc_update_delay_restriction(RRC_MSG_COMMON_BITMASK_IE(rrc_trch_reconfig->transportChannelReconfiguration_r5,
	     rrc_TransportChannelReconfiguration_r5_IEs,activationTime),
             TRUE,
             rrc_trch_reconfig->transportChannelReconfiguration_r5.activationTime,
             rrc_trch_reconfig->transportChannelReconfiguration_r5.rrc_StateIndicator
          );
  }
  rrcllcpcie_update_sync_a_post_veri_info(dcch_ptr,rrc_DL_DCCH_Message_PDU);
}

/*====================================================================
FUNCTION: rrcllc_check_delay_restriction_ie_trch_reconfig_r5

DESCRIPTION:
  This function returns TRUE if delay restriction is applicable

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
boolean rrcllc_check_delay_restriction_ie_trch_reconfig_r5
(
  rrc_DL_DCCH_Message *dcch_ptr
)
{
  boolean delay_restriction_flag = FALSE;
  
  rrc_TransportChannelReconfiguration_r5 *rrc_trch_reconfig = &dcch_ptr->message.u.transportChannelReconfiguration.u.
            later_than_r3.criticalExtensions.u.criticalExtensions.u.r5;

  if(rrc_trch_reconfig->m.v690NonCriticalExtensionsPresent)
  {
    if(RRC_MSG_COMMON_BITMASK_IE(rrc_trch_reconfig->v690NonCriticalExtensions.transportChannelReconfiguration_v690ext,
		         rrc_TransportChannelReconfiguration_v690ext_IEs,
		         delayRestrictionFlag))
    {
      if((RRC_MSG_COMMON_BITMASK_IE(rrc_trch_reconfig->transportChannelReconfiguration_r5,
	  	          rrc_TransportChannelReconfiguration_r5_IEs,
	  	          ul_AddReconfTransChInfoList ))
          ||(RRC_MSG_COMMON_BITMASK_IE(rrc_trch_reconfig->transportChannelReconfiguration_r5,
                  rrc_TransportChannelReconfiguration_r5_IEs,
                  dl_AddReconfTransChInfoList )
      ))
      {
        WRRC_MSG0_ERROR("Trch Ie touched bitmask , so Delay restriction cannot be applied");
      }
      else
      {
        delay_restriction_flag = TRUE;
      }
    }
  }
 
  return delay_restriction_flag;
}

/*====================================================================
FUNCTION: rrcllc_process_non_critcal_trch_reconfig_ie

DESCRIPTION:
  This function acts on the NON Critical IE for Trch Reconfig R99

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_process_non_critcal_trch_reconfig_ie
(
  rrc_DL_DCCH_Message *dcch_ptr
)
{
  if((dcch_ptr->message.u.transportChannelReconfiguration.u.r3.m.v3a0NonCriticalExtensionsPresent) &&
     (dcch_ptr->message.u.transportChannelReconfiguration.u.r3.
     v3a0NonCriticalExtensions.m.laterNonCriticalExtensionsPresent) && 
     (dcch_ptr->message.u.transportChannelReconfiguration.u.r3.v3a0NonCriticalExtensions.
     laterNonCriticalExtensions.m.v4b0NonCriticalExtensionsPresent) 
     )
  {
    if(RRC_MSG_COMMON_BITMASK_IE(dcch_ptr->message.u.transportChannelReconfiguration.u.r3.v3a0NonCriticalExtensions.laterNonCriticalExtensions.
      v4b0NonCriticalExtensions.transportChannelReconfiguration_v4b0ext,
         rrc_TransportChannelReconfiguration_v4b0ext_IEs,
         cell_id_PerRL_List))
    {
      if(RRC_MSG_COMMON_BITMASK_IE(dcch_ptr->message.u.transportChannelReconfiguration.u.
	  	  r3.transportChannelReconfiguration_r3,
	  	  rrc_TransportChannelReconfiguration_r3_IEs,
	  	  dl_InformationPerRL_List))
      {
        rrc_CellIdentity_PerRL_List * ptr_CellIdentity_PerRL = &dcch_ptr->message.u.transportChannelReconfiguration.u.r3.
                  v3a0NonCriticalExtensions.laterNonCriticalExtensions.v4b0NonCriticalExtensions.
                  transportChannelReconfiguration_v4b0ext.cell_id_PerRL_List;
        if(get_cell_id_per_rl_list(ptr_CellIdentity_PerRL, &dcch_ptr->message.u.transportChannelReconfiguration.u.r3.
                transportChannelReconfiguration_r3.dl_InformationPerRL_List) == FAILURE)
        {
          WRRC_MSG0_ERROR("TCRC failed updating cell_id_per_rl");
        }
      }
    }
  }
 
  if(rrcllc_check_delay_restriction_ie_trch_reconfig(dcch_ptr) ==TRUE)
  {
    rrcllc_update_delay_restriction(RRC_MSG_COMMON_BITMASK_IE(dcch_ptr->message.u.transportChannelReconfiguration.u.r3.
                transportChannelReconfiguration_r3,rrc_TransportChannelReconfiguration_r3_IEs, activationTime),
                     TRUE,
                     dcch_ptr->message.u.transportChannelReconfiguration.u.r3.transportChannelReconfiguration_r3.activationTime,
                     dcch_ptr->message.u.transportChannelReconfiguration.u.r3.transportChannelReconfiguration_r3.rrc_StateIndicator
                  );
  }
   
  rrcllcpcie_update_sync_a_post_veri_info(dcch_ptr,rrc_DL_DCCH_Message_PDU);

}

/*====================================================================
FUNCTION: rrcllc_check_delay_restriction_ie_trch_reconfig

DESCRIPTION:
  This function returns TRUE if delay restriction is applicable

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/

boolean rrcllc_check_delay_restriction_ie_trch_reconfig
(
  rrc_DL_DCCH_Message *dcch_ptr
)
{
  boolean delay_restriction_flag = FALSE;
  if((dcch_ptr->message.u.transportChannelReconfiguration.u.r3.m.v3a0NonCriticalExtensionsPresent) &&
     (dcch_ptr->message.u.transportChannelReconfiguration.u.r3.
     v3a0NonCriticalExtensions.m.laterNonCriticalExtensionsPresent) && 
     (dcch_ptr->message.u.transportChannelReconfiguration.u.r3.v3a0NonCriticalExtensions.
     laterNonCriticalExtensions.m.v4b0NonCriticalExtensionsPresent) 
     )
  {
    if((dcch_ptr->message.u.transportChannelReconfiguration.u.r3.v3a0NonCriticalExtensions.
                  laterNonCriticalExtensions.v4b0NonCriticalExtensions.m.v590NonCriticalExtensionsPresent )
          &&(dcch_ptr->message.u.transportChannelReconfiguration.u.r3.v3a0NonCriticalExtensions.
                  laterNonCriticalExtensions.v4b0NonCriticalExtensions.v590NonCriticalExtensions.m.
                  v690NonCriticalExtensionsPresent))
    {
      if(RRC_MSG_COMMON_BITMASK_IE(dcch_ptr->message.u.transportChannelReconfiguration.u.r3.v3a0NonCriticalExtensions.
                  laterNonCriticalExtensions.v4b0NonCriticalExtensions.v590NonCriticalExtensions.
                  v690NonCriticalExtensions.transportChannelReconfiguration_v690ext,
                  rrc_TransportChannelReconfiguration_v690ext_IEs,
                  delayRestrictionFlag)
                  )
      {
        if((RRC_MSG_COMMON_BITMASK_IE(dcch_ptr->message.u.transportChannelReconfiguration.u.r3.
			transportChannelReconfiguration_r3,
               rrc_TransportChannelReconfiguration_r3_IEs,
               ul_AddReconfTransChInfoList ))
            || (RRC_MSG_COMMON_BITMASK_IE(dcch_ptr->message.u.transportChannelReconfiguration.u.r3.transportChannelReconfiguration_r3,
               rrc_TransportChannelReconfiguration_r3_IEs,
               dl_AddReconfTransChInfoList )))
        {
          WRRC_MSG0_ERROR("Trch Ie touched bitmask , so Delay restriction cannot be applied");
        }
        else
        {
          delay_restriction_flag = TRUE;
        }
      }
    }
  } 
 
 return delay_restriction_flag;
}

/*====================================================================
FUNCTION: rrcllc_process_non_critcal_phys_reconfig_ie

DESCRIPTION:
  This function acts on the NON Critical IE for Phys Reconfig 

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_process_non_critcal_phys_reconfig_ie
(
  rrc_DL_DCCH_Message *dcch_ptr
)
{
  if((dcch_ptr->message.u.physicalChannelReconfiguration.u.r3.m.v3a0NonCriticalExtensionsPresent)
  	  && (dcch_ptr->message.u.physicalChannelReconfiguration.u.r3.v3a0NonCriticalExtensions.m. 
        laterNonCriticalExtensionsPresent ) && (dcch_ptr->message.u.physicalChannelReconfiguration.u.
        r3.v3a0NonCriticalExtensions.laterNonCriticalExtensions.m.v4b0NonCriticalExtenstionsPresent))
 
  {
    if(RRC_MSG_COMMON_BITMASK_IE(dcch_ptr->message.u.physicalChannelReconfiguration.u.r3.v3a0NonCriticalExtensions.
                  laterNonCriticalExtensions.v4b0NonCriticalExtenstions.physicalChannelReconfiguration_v4b0ext,
                  rrc_PhysicalChannelReconfiguration_v4b0ext_IEs,
                  cell_id_PerRL_List))
    {
      if(RRC_MSG_COMMON_BITMASK_IE(dcch_ptr->message.u.physicalChannelReconfiguration.u.r3.
	  	physicalChannelReconfiguration_r3,rrc_PhysicalChannelReconfiguration_r3_IEs,
	  	dl_InformationPerRL_List))
      {
        rrc_CellIdentity_PerRL_List * ptr_CellIdentity_PerRL = &dcch_ptr->message.u.physicalChannelReconfiguration.u.r3.
                v3a0NonCriticalExtensions.laterNonCriticalExtensions.v4b0NonCriticalExtenstions.
                physicalChannelReconfiguration_v4b0ext.cell_id_PerRL_List;
        if(get_cell_id_per_rl_list(ptr_CellIdentity_PerRL, &dcch_ptr->message.u.physicalChannelReconfiguration.u.r3.
                physicalChannelReconfiguration_r3.dl_InformationPerRL_List) == FAILURE)
        {
          WRRC_MSG0_ERROR("PCRC failed updating cell_id_per_rl");
        }
      }
    }
  }

  if((rrcllc_check_delay_restriction_ie_phys_reconfig(dcch_ptr))==TRUE)
  {
     rrcllc_update_delay_restriction(RRC_MSG_COMMON_BITMASK_IE(dcch_ptr->message.u.physicalChannelReconfiguration.u.r3.
                physicalChannelReconfiguration_r3,rrc_PhysicalChannelReconfiguration_r3_IEs, activationTime),
                TRUE,
                dcch_ptr->message.u.physicalChannelReconfiguration.u.r3.physicalChannelReconfiguration_r3.activationTime,
                dcch_ptr->message.u.physicalChannelReconfiguration.u.r3.physicalChannelReconfiguration_r3.rrc_StateIndicator
                );
  }  
 
  rrcllcpcie_update_sync_a_post_veri_info(dcch_ptr,rrc_DL_DCCH_Message_PDU);

}


/*====================================================================
FUNCTION: rrcllc_check_delay_restriction_ie_phys_reconfig

DESCRIPTION:
  This function returns TRUE if delay restriction is applicable

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/

boolean rrcllc_check_delay_restriction_ie_phys_reconfig
(
  rrc_DL_DCCH_Message *dcch_ptr
)
{
  boolean delay_restriction_flag = FALSE;

  if((dcch_ptr->message.u.physicalChannelReconfiguration.u.r3.m.v3a0NonCriticalExtensionsPresent)
  	  && (dcch_ptr->message.u.physicalChannelReconfiguration.u.r3.v3a0NonCriticalExtensions.m. 
        laterNonCriticalExtensionsPresent ) && (dcch_ptr->message.u.physicalChannelReconfiguration.u.
        r3.v3a0NonCriticalExtensions.laterNonCriticalExtensions.m.v4b0NonCriticalExtenstionsPresent))
  
  {
    if((dcch_ptr->message.u.physicalChannelReconfiguration.u.r3.v3a0NonCriticalExtensions.
                  laterNonCriticalExtensions.v4b0NonCriticalExtenstions.m.v590NonCriticalExtenstionsPresent )
          &&(dcch_ptr->message.u.physicalChannelReconfiguration.u.r3.v3a0NonCriticalExtensions.
                  laterNonCriticalExtensions.v4b0NonCriticalExtenstions.v590NonCriticalExtenstions.
                  m.v690NonCriticalExtensionsPresent))
    {
      if(dcch_ptr->message.u.physicalChannelReconfiguration.u.r3.v3a0NonCriticalExtensions.
                  laterNonCriticalExtensions.v4b0NonCriticalExtenstions.v590NonCriticalExtenstions.
                  v690NonCriticalExtensions.
                  physicalChannelReconfiguration_v690ext.m.delayRestrictionFlagPresent
                  )
      {
        delay_restriction_flag = TRUE;
      }
    }  
  } 

 return delay_restriction_flag;
}

/*====================================================================
FUNCTION: rrcllc_process_non_critcal_rb_reconfig_ie_r5

DESCRIPTION:
  This function acts on the NON Critical IE for RB Reconfig R5

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_process_non_critcal_rb_reconfig_ie_r5
(
  rrc_DL_DCCH_Message *dcch_ptr
)
{
  rrc_RadioBearerReconfiguration_r5 *rrc_rb_reconfig = &dcch_ptr->message.u.radioBearerReconfiguration.u.
            later_than_r3.criticalExtensions.u.criticalExtensions.u.r5;
 
  if(rrcllc_check_delay_restriction_ie_rb_reconfig_r5(dcch_ptr) ==TRUE)
  {
     rrcllc_update_delay_restriction(RRC_MSG_COMMON_BITMASK_IE(rrc_rb_reconfig->radioBearerReconfiguration_r5,
		rrc_RadioBearerReconfiguration_r5_IEs,activationTime),
                TRUE,
                rrc_rb_reconfig->radioBearerReconfiguration_r5.activationTime,
                rrc_rb_reconfig->radioBearerReconfiguration_r5.rrc_StateIndicator
              );
  }
  rrcllcpcie_update_sync_a_post_veri_info(dcch_ptr,rrc_DL_DCCH_Message_PDU);


}


/*====================================================================
FUNCTION: rrcllc_check_delay_restriction_ie_rb_reconfig_r5

DESCRIPTION:
  This function returns TRUE if delay restriction is applicable

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/

boolean rrcllc_check_delay_restriction_ie_rb_reconfig_r5 
(
  rrc_DL_DCCH_Message *dcch_ptr
)
{
  boolean delay_restriction_flag = FALSE;
  rrc_RadioBearerReconfiguration_r5 *rrc_rb_reconfig = &dcch_ptr->message.u.radioBearerReconfiguration.u.
            later_than_r3.criticalExtensions.u.criticalExtensions.u.r5;
  rrc_RadioBearerReconfiguration_r5_IEs *r5_rb_reconfig;

  r5_rb_reconfig = &rrc_rb_reconfig->radioBearerReconfiguration_r5;
  if((rrc_rb_reconfig->m.v5d0NonCriticalExtenstionsPresent)
          && (rrc_rb_reconfig->v5d0NonCriticalExtenstions.m.v690NonCriticalExtensionsPresent))
  {
    if(RRC_MSG_COMMON_BITMASK_IE(rrc_rb_reconfig->v5d0NonCriticalExtenstions.v690NonCriticalExtensions.radioBearerReconfiguration_v690ext,
          rrc_RadioBearerReconfiguration_v690ext_IEs,delayRestrictionFlag))
    {
      if((RRC_CHECK_COMMON_MSG_TYPE(r5_rb_reconfig->specificationMode,rrc_RadioBearerReconfiguration_r5_IEs_specificationMode_complete ))
          && (  (r5_rb_reconfig->specificationMode.u.complete.m.dl_AddReconfTransChInfoListPresent )
          ||(r5_rb_reconfig->specificationMode.u.complete.m.ul_AddReconfTransChInfoListPresent )
         ||(r5_rb_reconfig->specificationMode.u.complete.m.ul_deletedTransChInfoListPresent )
         ||(r5_rb_reconfig->specificationMode.u.complete.m.dl_DeletedTransChInfoListPresent ))
     
       )
      {
        WRRC_MSG0_ERROR("Trch Ie touched , so Delay restriction cannot be applied");
      }
      else
      {
        delay_restriction_flag = TRUE;
      }
    }
  }
  return delay_restriction_flag;
}

/*====================================================================
FUNCTION: rrcllc_process_non_critcal_phys_reconfig_ie_r5

DESCRIPTION:
  This function acts on the NON Critical IE for Phys Reconfig R5

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_process_non_critcal_phys_reconfig_ie_r5
(
  rrc_DL_DCCH_Message *dcch_ptr
)
{
  rrc_PhysicalChannelReconfiguration_r5 *rrc_phys_chan_reconfig = &dcch_ptr->message.u.physicalChannelReconfiguration.u.
          later_than_r3.criticalExtensions.u.criticalExtensions.u.r5;
  
  if(rrcllc_check_delay_restriction_ie_phys_reconfig_r5(dcch_ptr)==TRUE)
    {
      rrcllc_update_delay_restriction(RRC_MSG_COMMON_BITMASK_IE(
           rrc_phys_chan_reconfig->physicalChannelReconfiguration_r5,
              rrc_PhysicalChannelReconfiguration_r5_IEs,activationTime),
              TRUE,
              rrc_phys_chan_reconfig->physicalChannelReconfiguration_r5.activationTime,
              rrc_phys_chan_reconfig->physicalChannelReconfiguration_r5.rrc_StateIndicator
           );   
  }
 
  rrcllcpcie_update_sync_a_post_veri_info(dcch_ptr,rrc_DL_DCCH_Message_PDU);


}

/*====================================================================
FUNCTION: rrcllc_check_delay_restriction_ie_phys_reconfig_r5

DESCRIPTION:
  This function returns TRUE if delay restriction is applicable

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/

boolean rrcllc_check_delay_restriction_ie_phys_reconfig_r5
(
  rrc_DL_DCCH_Message *dcch_ptr
)
{
  boolean delay_restriction_flag = FALSE;
  rrc_PhysicalChannelReconfiguration_r5 *rrc_phys_chan_reconfig = &dcch_ptr->message.u.physicalChannelReconfiguration.u.
          later_than_r3.criticalExtensions.u.criticalExtensions.u.r5;
  
  if(rrc_phys_chan_reconfig->m.v690NonCriticalExtensionsPresent)
  {
    if(RRC_MSG_COMMON_BITMASK_IE(rrc_phys_chan_reconfig->v690NonCriticalExtensions.
		physicalChannelReconfiguration_v690ext,rrc_PhysicalChannelReconfiguration_v690ext_IEs,
		delayRestrictionFlag))
    {
      delay_restriction_flag = TRUE;
    }
  }
  
  return delay_restriction_flag;
}

/*====================================================================
FUNCTION: rrcllc_process_non_critcal_rb_reconfig_ie

DESCRIPTION:
  This function acts on the NON Critical IE for RB Reconfig R99

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_process_non_critcal_rb_reconfig_ie
(
  rrc_DL_DCCH_Message *dcch_ptr
)
{
  if((dcch_ptr->message.u.radioBearerReconfiguration.u.r3.m.v3aoNonCriticalExtensionsPresent) &&
      (dcch_ptr->message.u.radioBearerReconfiguration.u.r3.v3aoNonCriticalExtensions.m.laterNonCriticalExtensionsPresent)
      && (dcch_ptr->message.u.radioBearerReconfiguration.u.r3.v3aoNonCriticalExtensions.
      laterNonCriticalExtensions.m.v4b0NonCriticalExtensionsPresent)  )
  
  {
    if(RRC_MSG_COMMON_BITMASK_IE(dcch_ptr->message.u.radioBearerReconfiguration.u.r3.v3aoNonCriticalExtensions.laterNonCriticalExtensions.v4b0NonCriticalExtensions.
                  radioBearerReconfiguration_v4b0ext,
                  rrc_RadioBearerReconfiguration_v4b0ext_IEs,cell_id_PerRL_List))
    {
      if(RRC_MSG_COMMON_BITMASK_IE(dcch_ptr->message.u.radioBearerReconfiguration.u.r3.radioBearerReconfiguration_r3, 
              rrc_RadioBearerReconfiguration_r3_IEs,dl_CommonInformation))
      {
        rrc_CellIdentity_PerRL_List  * ptr_CellIdentity_PerRL = &dcch_ptr->message.u.radioBearerReconfiguration.u.r3.
            v3aoNonCriticalExtensions.laterNonCriticalExtensions.v4b0NonCriticalExtensions.
            radioBearerReconfiguration_v4b0ext.cell_id_PerRL_List;
        if(get_cell_id_per_rl_list(ptr_CellIdentity_PerRL, &dcch_ptr->message.u.radioBearerReconfiguration.u.r3.
            radioBearerReconfiguration_r3.dl_InformationPerRL_List) == FAILURE)
        {
          WRRC_MSG0_ERROR("RBRC failed updating cell_id_per_rl");
        }
      }
    }
  }

  if(rrcllc_check_delay_restriction_ie_rb_reconfig(dcch_ptr)==TRUE)
  {
      rrcllc_update_delay_restriction(RRC_MSG_COMMON_BITMASK_IE(
                  dcch_ptr->message.u.radioBearerReconfiguration.u.r3.radioBearerReconfiguration_r3,
                       rrc_RadioBearerReconfiguration_r3_IEs,activationTime),
                       TRUE,
                       dcch_ptr->message.u.radioBearerReconfiguration.u.r3.radioBearerReconfiguration_r3.activationTime,
                       dcch_ptr->message.u.radioBearerReconfiguration.u.r3.radioBearerReconfiguration_r3.rrc_StateIndicator
                    );
    
  } 

  rrcllcpcie_update_sync_a_post_veri_info(dcch_ptr,rrc_DL_DCCH_Message_PDU);


}

/*====================================================================
FUNCTION: rrcllc_check_delay_restriction_ie_rb_reconfig

DESCRIPTION:
  This function returns TRUE if delay restriction is applicable

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/

boolean rrcllc_check_delay_restriction_ie_rb_reconfig
(
  rrc_DL_DCCH_Message *dcch_ptr
)
{
  boolean delay_restriction_flag = FALSE;
  
  if((dcch_ptr->message.u.radioBearerReconfiguration.u.r3.m.v3aoNonCriticalExtensionsPresent) &&
      (dcch_ptr->message.u.radioBearerReconfiguration.u.r3.v3aoNonCriticalExtensions.m.laterNonCriticalExtensionsPresent)
      && (dcch_ptr->message.u.radioBearerReconfiguration.u.r3.v3aoNonCriticalExtensions.
      laterNonCriticalExtensions.m.v4b0NonCriticalExtensionsPresent)  )
  
  {
    if((dcch_ptr->message.u.radioBearerReconfiguration.u.r3.v3aoNonCriticalExtensions.laterNonCriticalExtensions.
      v4b0NonCriticalExtensions.m.v590NonCriticalExtensionsPresent )
    && (dcch_ptr->message.u.radioBearerReconfiguration.u.r3.v3aoNonCriticalExtensions.laterNonCriticalExtensions.
      v4b0NonCriticalExtensions.v590NonCriticalExtensions.m.v5d0NonCriticalExtenstionsPresent)
    &&(dcch_ptr->message.u.radioBearerReconfiguration.u.r3.v3aoNonCriticalExtensions.laterNonCriticalExtensions.
      v4b0NonCriticalExtensions.v590NonCriticalExtensions.v5d0NonCriticalExtenstions.m.v690NonCriticalExtensionsPresent)
      )
    {
      if(RRC_MSG_COMMON_BITMASK_IE( dcch_ptr->message.u.radioBearerReconfiguration.u.r3.v3aoNonCriticalExtensions.laterNonCriticalExtensions.
      v4b0NonCriticalExtensions.v590NonCriticalExtensions.v5d0NonCriticalExtenstions.v690NonCriticalExtensions.radioBearerReconfiguration_v690ext,
      rrc_RadioBearerReconfiguration_v690ext_IEs,delayRestrictionFlag))
      {
  
        if( (RRC_MSG_COMMON_BITMASK_IE(dcch_ptr->message.u.radioBearerReconfiguration.u.r3.radioBearerReconfiguration_r3,
             rrc_RadioBearerReconfiguration_r3_IEs,dl_AddReconfTransChInfoList))
              ||(RRC_MSG_COMMON_BITMASK_IE(dcch_ptr->message.u.radioBearerReconfiguration.u.r3.radioBearerReconfiguration_r3,
             rrc_RadioBearerReconfiguration_r3_IEs,ul_AddReconfTransChInfoList))
             ||(RRC_MSG_COMMON_BITMASK_IE(dcch_ptr->message.u.radioBearerReconfiguration.u.r3.radioBearerReconfiguration_r3,
             rrc_RadioBearerReconfiguration_r3_IEs,ul_deletedTransChInfoList))
             ||(RRC_MSG_COMMON_BITMASK_IE(dcch_ptr->message.u.radioBearerReconfiguration.u.r3.radioBearerReconfiguration_r3,
             rrc_RadioBearerReconfiguration_r3_IEs,dl_DeletedTransChInfoList))
             )
        {
          WRRC_MSG0_ERROR("Trch Ie touched , so Delay restriction cannot be applied");
        }
        else
        {
          delay_restriction_flag = TRUE;
        }
      }
    }
  } 

  return delay_restriction_flag;
}

/*====================================================================
FUNCTION: rrcllcoc_process_conn_setup_msg

DESCRIPTION:
  This function processes the RRC Connection Setup msg  received on CCCH based on the REL version and
  updates ordered_config with the latest IEs recv'd by RRC Connection Setup msg

DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS if everything is valid, FAILURE otherwise.

SIDE EFFECTS:
  None.
====================================================================*/

static uecomdef_status_e_type rrcllcoc_process_conn_setup_msg
(
  uint32 dl_sdu_num,
  void *msg_ptr

)
{
	rrc_DL_CCCH_Message *ccch_ptr;
    uecomdef_status_e_type status = SUCCESS;
	ccch_ptr = (rrc_DL_CCCH_Message *)msg_ptr;

		if (RRC_CHECK_COMMON_MSG_TYPE(ccch_ptr->message.u.rrcConnectionSetup,rrc_RRCConnectionSetup_r3))
  		{
  		  if(rrcllc_rrc_conn_setup_ie(&ccch_ptr->message.u.rrcConnectionSetup.u.r3.rrcConnectionSetup_r3)
  		  == FAILURE)
  		  {
  			status = FAILURE;
  		  }
  		  else /*Here we update the cell_id_per_rl that is coming in no-critical extension of the R99 OTA.*/
  		  {
  			if ((ccch_ptr->message.u.rrcConnectionSetup.u.r3.m.laterNonCriticalExtensionsPresent)
  			 && (ccch_ptr->message.u.rrcConnectionSetup.u.r3.laterNonCriticalExtensions.m.v4b0NonCriticalExtensionsPresent) && 
  				(ccch_ptr->message.u.rrcConnectionSetup.u.r3.laterNonCriticalExtensions.v4b0NonCriticalExtensions.
  				 rrcConnectionSetup_v4b0ext.m.cell_id_PerRL_ListPresent))	  
  			{
  			  if(RRC_MSG_COMMON_BITMASK_IE(ccch_ptr->message.u.rrcConnectionSetup.u.r3.rrcConnectionSetup_r3,
  					rrc_RRCConnectionSetup_r3_IEs,dl_InformationPerRL_List))
  			  {
  				rrc_CellIdentity_PerRL_List * ptr_CellIdentity_PerRL = &ccch_ptr->message.u.rrcConnectionSetup.u.r3.
  						  laterNonCriticalExtensions.v4b0NonCriticalExtensions.rrcConnectionSetup_v4b0ext.cell_id_PerRL_List;
  				if(get_cell_id_per_rl_list(ptr_CellIdentity_PerRL, &ccch_ptr->message.u.rrcConnectionSetup.u.r3.
  						  rrcConnectionSetup_r3.dl_InformationPerRL_List) == FAILURE)
  				{
  				  WRRC_MSG0_ERROR("RCE failed updating cell_id_per_rl");
  				}
  			  }
  			}	
  		  } 	  
  		  if(status == SUCCESS )
  		  {
  			rrcllcpcie_update_sync_a_post_veri_info(msg_ptr,dl_sdu_num);
  		  }
  		}
	
			else if (RRCRB_R6_CRITICAL_EXT_PRESENT(
					ccch_ptr->message.u.rrcConnectionSetup,rrc_RRCConnectionSetup_))
					
			{
			  if (FAILURE == rrcllc_rrc_conn_setup_ie_r6(&ccch_ptr->message.u.rrcConnectionSetup.
				  u.later_than_r3.criticalExtensions.
				  u.criticalExtensions.
				  u.criticalExtensions.
				  u.r6.rrcConnectionSetup_r6
				 , &ccch_ptr->message.u.rrcConnectionSetup.
				  u.later_than_r3.criticalExtensions.
				  u.criticalExtensions.
				  u.criticalExtensions.
				  u.r6
				  ))
			  {
				status = FAILURE;
			  }
			}
			else if (RRCRB_R7_CRITICAL_EXT_PRESENT(
					ccch_ptr->message.u.rrcConnectionSetup,rrc_RRCConnectionSetup_))
			{
			  if (FAILURE == rrcllc_rrc_conn_setup_ie_r7(&ccch_ptr->message.u.rrcConnectionSetup.
				  u.later_than_r3.criticalExtensions.
				  u.criticalExtensions.
				  u.criticalExtensions.
				   u.criticalExtensions.
				  u.r7))
			  {
				status = FAILURE;
			  }
			}
			else if (RRCRB_R8_CRITICAL_EXT_PRESENT(
					ccch_ptr->message.u.rrcConnectionSetup,rrc_RRCConnectionSetup_))
			{
			  if (FAILURE == rrcllc_rrc_conn_setup_ie_r8(&ccch_ptr->message.u.rrcConnectionSetup.
				  u.later_than_r3.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.r8))
			  {
				status = FAILURE;
			  }
			}
#ifdef FEATURE_WCDMA_REL9

			else if (RRCRB_R9_CRITICAL_EXT_PRESENT(
					ccch_ptr->message.u.rrcConnectionSetup,rrc_RRCConnectionSetup_))
			{
			  if (FAILURE == rrcllc_rrc_conn_setup_ie_r9(&ccch_ptr->message.u.rrcConnectionSetup.
                                          u.later_than_r3.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.later_r8_criticalExtensions.u.r9))
			  {
				status = FAILURE;
			  }
			}
#endif /* FEATURE_WCDMA_REL9 */
#ifdef FEATURE_WCDMA_REL10
#error code not present
#endif /* FEATURE_WCDMA_REL10 */
	
			else
			{
			  if(rrcllc_rrc_conn_setup_ie_r5(&ccch_ptr->message.u.rrcConnectionSetup.u.
											 later_than_r3.criticalExtensions.u.
											 criticalExtensions.u.r5.rrcConnectionSetup_r5)
			  == FAILURE)
			  {
				status = FAILURE;
			  }
			  if(status == SUCCESS )
			  {
				rrcllcpcie_update_sync_a_post_veri_info(msg_ptr,dl_sdu_num);
			  }
	
			}
	
 return status;
}

/*====================================================================
FUNCTION: rrcllcoc_process_ccch_cell_update_cnf

DESCRIPTION:
  This function processes the Cell Update  msg  received on CCCH based on the REL version and
  updates ordered_config with the latest IEs recv'd by Cell Update  msg

DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS if everything is valid, FAILURE otherwise.

SIDE EFFECTS:
  None.
====================================================================*/

static uecomdef_status_e_type rrcllcoc_process_ccch_cell_update_cnf
(
  uint32 dl_sdu_num,
  void *msg_ptr

)
{
	rrc_DL_CCCH_Message *ccch_ptr;
    uecomdef_status_e_type status = SUCCESS;
	ccch_ptr = (rrc_DL_CCCH_Message *)msg_ptr;

	if(RRC_CHECK_COMMON_MSG_TYPE(ccch_ptr->message.u.cellUpdateConfirm,rrc_CellUpdateConfirm_CCCH_r3))
	{
	  if(rrcllc_cell_update_confirm_ie(&ccch_ptr->message.u.cellUpdateConfirm.u.r3.cellUpdateConfirm_r3)
	  == FAILURE)
	  {
		status = FAILURE;
	  }
	  else /*Here we update the cell_id_per_rl that is coming in no-critical extension of the R99 OTA.*/
	  { 		
		if((ccch_ptr->message.u.cellUpdateConfirm.u.r3.m.laterNonCriticalExtensionsPresent) &&
		(ccch_ptr->message.u.cellUpdateConfirm.u.r3.laterNonCriticalExtensions.m.v4b0NonCriticalExtensionsPresent)
		&& (ccch_ptr->message.u.cellUpdateConfirm.u.r3.laterNonCriticalExtensions.v4b0NonCriticalExtensions.
				cellUpdateConfirm_v4b0ext.m.cell_id_PerRL_ListPresent))
		{
		  if(RRC_MSG_COMMON_BITMASK_IE(ccch_ptr->message.u.cellUpdateConfirm.u.r3.cellUpdateConfirm_r3, 
				  rrc_CellUpdateConfirm_r3_IEs,dl_InformationPerRL_List))
		  {
			rrc_CellIdentity_PerRL_List * ptr_CellIdentity_PerRL = &ccch_ptr->message.u.cellUpdateConfirm.u.r3.
					  laterNonCriticalExtensions.v4b0NonCriticalExtensions.cellUpdateConfirm_v4b0ext.cell_id_PerRL_List;
			if(get_cell_id_per_rl_list(ptr_CellIdentity_PerRL, &ccch_ptr->message.u.cellUpdateConfirm.u.r3.
					cellUpdateConfirm_r3.dl_InformationPerRL_List) == FAILURE)
			{
			  WRRC_MSG0_ERROR("CU_CNF failed updating cell_id_per_rl");
			}
		  }
		} 
	  } 	  
	  if(status == SUCCESS )
	  {
		rrcllcpcie_update_sync_a_post_veri_info(msg_ptr,dl_sdu_num);
	  }

	}
			else if ((T_rrc_CellUpdateConfirm_CCCH_criticalExtensions_5_criticalExtensions == 
			  ccch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.t) && 
			  (T_rrc_CellUpdateConfirm_CCCH_criticalExtensions_4_criticalExtensions == 
				ccch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.u.criticalExtensions.t) && 
				(T_rrc_CellUpdateConfirm_CCCH_criticalExtensions_3_r6 == 
				 ccch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.u.criticalExtensions.u.criticalExtensions.t))
			{
			  rrc_DL_InformationPerRL_List_v6b0ext *dl_InformationPerRL_List_v6b0ext = NULL;
			  if(RRCRB_R6_DL_INFO_PERRL_EXT_PRESENT_IN_CU(ccch_ptr, rrc_CellUpdateConfirm,
																			   cellUpdateConfirm))
			  {
				dl_InformationPerRL_List_v6b0ext =	&ccch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.u.criticalExtensions.u.
					criticalExtensions.u.r6.v6b0NonCriticalExtensions.cellUpdateConfirm_v6b0ext.dl_InformationPerRL_List_v6b0ext;
			  }
			  
			  if(rrcllc_cell_update_confirm_ie_r6(&ccch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.
												  criticalExtensions.u.criticalExtensions.u.criticalExtensions.
												  u.r6.cellUpdateConfirm_r6
												  ,dl_InformationPerRL_List_v6b0ext
												  )
				 == FAILURE)
			  {
				status = FAILURE;
			  }
			}
			else if ((T_rrc_CellUpdateConfirm_CCCH_criticalExtensions_5_criticalExtensions == 
			  ccch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.t) && 
			  (T_rrc_CellUpdateConfirm_CCCH_criticalExtensions_4_criticalExtensions == 
				ccch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.u.criticalExtensions.t) && 
				(T_rrc_CellUpdateConfirm_CCCH_criticalExtensions_3_criticalExtensions == 
				 ccch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.u.criticalExtensions.u.criticalExtensions.t)
				 && (T_rrc_CellUpdateConfirm_CCCH_criticalExtensions_2_r7 & 
				 ccch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.t))
			{
			  if(rrcllc_cell_update_confirm_ie_r7(dl_sdu_num,msg_ptr)
				 == FAILURE)
			  {
				status = FAILURE;
			  }
			}
			else if (RRCRB_R8_CU_CRITICAL_EXT_PRESENT_PTR(ccch_ptr,rrc_CellUpdateConfirm_CCCH))
			{
			  if(rrcllc_cell_update_confirm_ie_r8(dl_sdu_num,msg_ptr) == FAILURE)
			  {
				status = FAILURE;
			  }
			}
#ifdef FEATURE_WCDMA_REL9
     else if (RRCRB_R9_CU_CRITICAL_EXT_PRESENT_PTR(ccch_ptr,rrc_CellUpdateConfirm_CCCH))
     {
       if(rrcllc_cell_update_confirm_ie_r9(dl_sdu_num,msg_ptr) == FAILURE)
       {
       status = FAILURE;
       }
     }

#endif /* FEATURE_WCDMA_REL9 */
#ifdef FEATURE_WCDMA_REL10
     #error code not present
#endif /* FEATURE_WCDMA_REL10 */
	
			else
			{
			  if (rrcllc_cell_update_confirm_ie_r5(&ccch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.
												criticalExtensions.u.criticalExtensions.
												   u.r5.cellUpdateConfirm_r5) == FAILURE)
			  {
				status = FAILURE;
			  }
			  if(status == SUCCESS )
			  {
				rrcllcpcie_update_sync_a_post_veri_info(msg_ptr,dl_sdu_num);
			  }
	
			}
  return status;
}

/*====================================================================
FUNCTION: rrcllcoc_process_asu_msg

DESCRIPTION:
  This function processes the Active Set Update  msg based on the REL version and
  updates ordered_config with the latest IEs recv'd by Active Set Update  msg

DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS if everything is valid, FAILURE otherwise.

SIDE EFFECTS:
  None.
====================================================================*/

static uecomdef_status_e_type rrcllcoc_process_asu_msg
(
  uint32 dl_sdu_num,
  void *msg_ptr

)
{
  /* local variables */
  uecomdef_status_e_type  status = SUCCESS;
  rrc_DL_DCCH_Message *dcch_ptr;
  dcch_ptr = (rrc_DL_DCCH_Message *)msg_ptr;
  if (RRC_CHECK_COMMON_MSG_TYPE(dcch_ptr->message.u.activeSetUpdate,rrc_ActiveSetUpdate_r3))
  {
    if(rrcllc_active_set_update_ie(&dcch_ptr->message.u.activeSetUpdate.u.r3.activeSetUpdate_r3)
          == FAILURE)
    {
      status = FAILURE;
    }
    else /*Here we update the cell_id_per_rl that is coming in no-critical extension of the R99 OTA.*/
    {
      if ((dcch_ptr->message.u.activeSetUpdate.u.r3.m.laterNonCriticalExtensionsPresent)
         && (dcch_ptr->message.u.activeSetUpdate.u.r3.laterNonCriticalExtensions.m.v4b0NonCriticalExtensionsPresent)  
         &&(dcch_ptr->message.u.activeSetUpdate.u.r3.laterNonCriticalExtensions.v4b0NonCriticalExtensions.
                  activeSetUpdate_v4b0ext.m.cell_id_PerRL_ListPresent))	  
      {
        if(RRC_MSG_COMMON_BITMASK_IE(dcch_ptr->message.u.activeSetUpdate.u.r3.activeSetUpdate_r3, 
              rrc_ActiveSetUpdate_r3_IEs, rl_AdditionInformationList))
        {
          rrc_CellIdentity_PerRL_List * ptr_CellIdentity_PerRL = &dcch_ptr->message.u.activeSetUpdate.u.r3.
                    laterNonCriticalExtensions.v4b0NonCriticalExtensions.activeSetUpdate_v4b0ext.cell_id_PerRL_List;
          if(get_cell_id_per_rl_list_for_asu(ptr_CellIdentity_PerRL, &dcch_ptr->message.u.activeSetUpdate.u.r3.
                    activeSetUpdate_r3.rl_AdditionInformationList) == FAILURE)
          {
            WRRC_MSG0_ERROR("ASU failed updating cell_id_per_rl");
          }
        }
      }          
    }
  }
  else if (T_rrc_ActiveSetUpdate_criticalExtensions_3_r6 == 
          dcch_ptr->message.u.activeSetUpdate.u.later_than_r3.criticalExtensions.t)
  {
    
    if(FAILURE == rrcllc_active_set_update_ie_r6(&dcch_ptr->message.u.
       activeSetUpdate.u.later_than_r3.criticalExtensions.u.r6.activeSetUpdate_r6
      ,&dcch_ptr->message.u.
       activeSetUpdate.u.later_than_r3.criticalExtensions.u.r6
    ))
    {
      status = FAILURE;
    }

  }
  else if ((T_rrc_ActiveSetUpdate_criticalExtensions_3_criticalExtensions == 
          dcch_ptr->message.u.activeSetUpdate.u.later_than_r3.criticalExtensions.t)
          && (T_rrc_ActiveSetUpdate_criticalExtensions_2_r7 == 
          dcch_ptr->message.u.activeSetUpdate.u.later_than_r3.criticalExtensions.u.criticalExtensions.t)
          )
  {
    if(FAILURE == rrcllc_active_set_update_ie_r7(&dcch_ptr->message.u.
       activeSetUpdate.u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r7
    ))
    {
      status = FAILURE;
    }
  }
  else if (RRCRB_R8_ASU_CRITICAL_EXT_PRESENT_PTR)
  {
    if(FAILURE == rrcllc_active_set_update_ie_r8(&dcch_ptr->message.u.
       activeSetUpdate.u.later_than_r3.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.r8
    ))
    {
      status = FAILURE;
    }
  }
#ifdef FEATURE_WCDMA_REL9
  else if (RRCRB_R9_ASU_CRITICAL_EXT_PRESENT_PTR )
  {
    if(FAILURE == rrcllc_active_set_update_ie_r9(&dcch_ptr->message.u.
       activeSetUpdate.u.later_than_r3.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.later_r8_criticalExtensions.u.r9
    ))
    {
      status = FAILURE;
    }
  }
#endif /*FEATURE_WCDMA_REL9*/

#ifdef FEATURE_WCDMA_REL10
  #error code not present
#endif /*FEATURE_WCDMA_REL10*/


  if(status == FAILURE)
  {
    WRRC_MSG0_HIGH("ASU failed updating OC");
  }
  return status;
}

/*====================================================================
FUNCTION: rrcllcoc_process_pcrc_msg

DESCRIPTION:
  This function processes the Physical Channel Reconfig msg based on the REL version and
  updates ordered_config with the latest IEs recv'd by Physical Channel Reconfig msg

DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS if everything is valid, FAILURE otherwise.

SIDE EFFECTS:
  None.
====================================================================*/

static uecomdef_status_e_type rrcllcoc_process_pcrc_msg
(
  uint32 dl_sdu_num,
  void *msg_ptr

)
{
	/* local variables */
  uecomdef_status_e_type  status = SUCCESS;
  rrc_DL_DCCH_Message *dcch_ptr;
  dcch_ptr = (rrc_DL_DCCH_Message *)msg_ptr;
	     
		 if (RRC_CHECK_COMMON_MSG_TYPE(dcch_ptr->message.u.physicalChannelReconfiguration,
		 	   rrc_PhysicalChannelReconfiguration_r3))
		 {
		   if(rrcllc_phychan_reconfig_ie(dcch_ptr) == FAILURE)
		   {
			 status = FAILURE;
		   }
		   else /*Here we update the cell_id_per_rl that is coming in no-critical extension of the R99 OTA.*/
		   {		 
			 rrcllc_process_non_critcal_phys_reconfig_ie(dcch_ptr);
   
		   }
		 }
		 else if (RRCRB_R6_CRITICAL_EXT_PRESENT(
				  dcch_ptr->message.u.physicalChannelReconfiguration, 
				  rrc_PhysicalChannelReconfiguration_))
		 {
		   
		   if (FAILURE == rrcllc_phychan_reconfig_ie_r6(&dcch_ptr->message.u.physicalChannelReconfiguration.
														u.later_than_r3.criticalExtensions.
														u.criticalExtensions.
														u.criticalExtensions.
														u.r6.physicalChannelReconfiguration_r6
														,&dcch_ptr->message.u.physicalChannelReconfiguration.
														u.later_than_r3.criticalExtensions.
														u.criticalExtensions.
														u.criticalExtensions.
														u.r6
														))
		   {
			 status = FAILURE;
		   }
		 }
				 else if (RRCRB_R7_CRITICAL_EXT_PRESENT(
						  dcch_ptr->message.u.physicalChannelReconfiguration, 
						  rrc_PhysicalChannelReconfiguration_))
				 {
				   if (FAILURE == rrcllc_phychan_reconfig_ie_r7(
																&dcch_ptr->message.u.physicalChannelReconfiguration.
																u.later_than_r3.criticalExtensions.
																u.criticalExtensions.
																u.criticalExtensions.
																u.criticalExtensions.
																u.r7
																))
				   {
					 status = FAILURE;
				   }
				 }
				 else if (RRCRB_R8_CRITICAL_EXT_PRESENT(
						  dcch_ptr->message.u.physicalChannelReconfiguration, 
						  rrc_PhysicalChannelReconfiguration_
						  ))
				 {
				   if (FAILURE == rrcllc_phychan_reconfig_ie_r8(
																&dcch_ptr->message.u.physicalChannelReconfiguration.
																u.later_than_r3.criticalExtensions.
																u.criticalExtensions.
																u.criticalExtensions.
																u.criticalExtensions.
																u.criticalExtensions.														
																u.r8
																))
				   {
					 status = FAILURE;
				   }
				 }
#ifdef FEATURE_WCDMA_REL9
        else if (RRCRB_R9_CRITICAL_EXT_PRESENT(
             dcch_ptr->message.u.physicalChannelReconfiguration, 
             rrc_PhysicalChannelReconfiguration_
             ))
        {
          if (FAILURE == rrcllc_phychan_reconfig_ie_r9(
                               &dcch_ptr->message.u.physicalChannelReconfiguration.
                               u.later_than_r3.criticalExtensions.
                               u.criticalExtensions.
                               u.criticalExtensions.
                               u.criticalExtensions.
                               u.criticalExtensions.                           
                               u.later_r8_criticalExtensions.
                               u.r9
                               ))
          {
          status = FAILURE;
          }
        }

#endif /* FEATURE_WCDMA_REL9 */
  
  #ifdef FEATURE_WCDMA_REL10
  #error code not present
#endif /* FEATURE_WCDMA_REL10 */
  
				 else
				 {
				   if(rrcllc_phychan_reconfig_ie_r5(dcch_ptr) == FAILURE)
				   {
					 status = FAILURE;
				   }
				   else
				   {
					  rrcllc_process_non_critcal_phys_reconfig_ie_r5(dcch_ptr);
				   }
		 
				 }


return status;
}

/*====================================================================
FUNCTION: rrcllcoc_process_rbrc_msg

DESCRIPTION:
  This function processes the Radio Bearer Reconfig msg based on the REL version and
  updates ordered_config with the latest IEs recv'd by TRadio Bearer Reconfig msg

DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS if everything is valid, FAILURE otherwise.

SIDE EFFECTS:
  None.
====================================================================*/

static uecomdef_status_e_type rrcllcoc_process_rbrc_msg
(
  uint32 dl_sdu_num,
  void *msg_ptr

)
{
	/* local variables */
  uecomdef_status_e_type  status = SUCCESS;
  rrc_DL_DCCH_Message *dcch_ptr;
  dcch_ptr = (rrc_DL_DCCH_Message *)msg_ptr;
	      
  if (RRC_CHECK_COMMON_MSG_TYPE(dcch_ptr->message.u.radioBearerReconfiguration,
  	  rrc_RadioBearerReconfiguration_r3 ))
  {
	if(rrcllc_rb_reconfig_ie(dcch_ptr) == FAILURE)
	{
	  status = FAILURE;
	}
	else /*Here we update the cell_id_per_rl that is coming in no-critical extension of the R99 OTA.*/
	{
	  rrcllc_process_non_critcal_rb_reconfig_ie(dcch_ptr);
	}
  }
  else if (RRCRB_R6_CRITICAL_EXT_PRESENT(
		  dcch_ptr->message.u.radioBearerReconfiguration, 
		  rrc_RadioBearerReconfiguration_))
  {
	if (FAILURE == rrcllc_rb_reconfig_ie_r6(&dcch_ptr->message.u.radioBearerReconfiguration.
											u.later_than_r3.criticalExtensions.
											u.criticalExtensions.
											u.criticalExtensions.
											u.r6.radioBearerReconfiguration_r6
												 ,&dcch_ptr->message.u.radioBearerReconfiguration.
											u.later_than_r3.criticalExtensions.
											u.criticalExtensions.
											u.criticalExtensions.
											u.r6

	))
	{
	  status = FAILURE; 		 
	}
  }
  else if (RRCRB_R7_CRITICAL_EXT_PRESENT(
		  dcch_ptr->message.u.radioBearerReconfiguration, 
		  rrc_RadioBearerReconfiguration_))
  {
	if (FAILURE == rrcllc_rb_reconfig_ie_r7(&dcch_ptr->message.u.radioBearerReconfiguration.
											u.later_than_r3.criticalExtensions.
											u.criticalExtensions.
											u.criticalExtensions.
											u.criticalExtensions.
											u.r7))
	{
	  status = FAILURE; 		 
	}
  }
  else if (RRCRB_R8_CRITICAL_EXT_PRESENT(
		  dcch_ptr->message.u.radioBearerReconfiguration, 
		  rrc_RadioBearerReconfiguration_))
  {
	if (FAILURE == rrcllc_rb_reconfig_ie_r8(&dcch_ptr->message.u.radioBearerReconfiguration.
											u.later_than_r3.criticalExtensions.
											u.criticalExtensions.
											u.criticalExtensions.
											u.criticalExtensions.
											u.criticalExtensions.												   
											u.r8))
	{
	  status = FAILURE; 		 
	}
  }
#ifdef FEATURE_WCDMA_REL9
  else if (RRCRB_R9_CRITICAL_EXT_PRESENT(
      dcch_ptr->message.u.radioBearerReconfiguration, 
      rrc_RadioBearerReconfiguration_))
  {
  if (FAILURE == rrcllc_rb_reconfig_ie_r9(&dcch_ptr->message.u.radioBearerReconfiguration.
                      u.later_than_r3.criticalExtensions.
                      u.criticalExtensions.
                      u.criticalExtensions.
                      u.criticalExtensions.
                      u.criticalExtensions.                          
                      u.later_r8_criticalExtensions.
                      u.r9))
  {
    status = FAILURE;      
  }
  }

#endif /* FEATURE_WCDMA_REL9 */

#ifdef FEATURE_WCDMA_REL10
  #error code not present
#endif /* FEATURE_WCDMA_REL10 */

  else
  {
	if(rrcllc_rb_reconfig_ie_r5(dcch_ptr) == FAILURE)
	{
	  status = FAILURE;
	}
	else
	{
	  rrcllc_process_non_critcal_rb_reconfig_ie_r5(dcch_ptr);
	}
  }

return status;
}

/*====================================================================
FUNCTION: rrcllcoc_process_rbr_msg

DESCRIPTION:
  This function processes the Radio Bearer Release msg based on the REL version and
  updates ordered_config with the latest IEs recv'd by TRadio Bearer Release msg

DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS if everything is valid, FAILURE otherwise.

SIDE EFFECTS:
  None.
====================================================================*/

static uecomdef_status_e_type rrcllcoc_process_rbr_msg
(
  uint32 dl_sdu_num,
  void *msg_ptr

)
{
  /* local variables */
  uecomdef_status_e_type  status = SUCCESS;
  rrc_DL_DCCH_Message *dcch_ptr;
  dcch_ptr = (rrc_DL_DCCH_Message *)msg_ptr;

  if (RRC_CHECK_COMMON_MSG_TYPE(dcch_ptr->message.u.radioBearerRelease,
       rrc_RadioBearerRelease_r3))
  {
    if(rrcllc_rb_release_ie(&dcch_ptr->message.u.radioBearerRelease.u.r3.radioBearerRelease_r3)
      == FAILURE)
    {
      status = FAILURE;
    }
    else /*Here we update the cell_id_per_rl that is coming in no-critical extension of the R99 OTA.*/
    {
      if((dcch_ptr->message.u.radioBearerRelease.u.r3.m.v3a0NonCriticalExtensionsPresent)&&
         (dcch_ptr->message.u.radioBearerRelease.u.r3.v3a0NonCriticalExtensions.m.laterNonCriticalExtensionsPresent)
          && (dcch_ptr->message.u.radioBearerRelease.u.r3.v3a0NonCriticalExtensions.laterNonCriticalExtensions.m. 
          v4b0NonCriticalExtensionsPresent) && (dcch_ptr->message.u.radioBearerRelease.u.r3.v3a0NonCriticalExtensions.
          laterNonCriticalExtensions.v4b0NonCriticalExtensions.radioBearerRelease_v4b0ext.m.cell_id_PerRL_ListPresent))
      {
        if(RRC_MSG_COMMON_BITMASK_IE(dcch_ptr->message.u.radioBearerRelease.u.r3.radioBearerRelease_r3,
                rrc_RadioBearerRelease_r3_IEs,dl_InformationPerRL_List))
        {
          rrc_CellIdentity_PerRL_List * ptr_CellIdentity_PerRL = &dcch_ptr->message.u.radioBearerRelease.u.r3.
                  v3a0NonCriticalExtensions.laterNonCriticalExtensions.v4b0NonCriticalExtensions.radioBearerRelease_v4b0ext.cell_id_PerRL_List;
          if(get_cell_id_per_rl_list(ptr_CellIdentity_PerRL, &dcch_ptr->message.u.radioBearerRelease.u.r3.radioBearerRelease_r3.
                  dl_InformationPerRL_List) == FAILURE)
          {
            WRRC_MSG0_ERROR("RBR failed updating cell_id_per_rl");
          }
        }
      } 
    }

    if(status == SUCCESS )
    {
      rrcllcpcie_update_sync_a_post_veri_info(msg_ptr,dl_sdu_num);
    }


  }
  else if (RRCRB_R6_CRITICAL_EXT_PRESENT(
          dcch_ptr->message.u.radioBearerRelease, 
          rrc_RadioBearerRelease_))
  {
    if (FAILURE == rrcllc_rb_release_ie_r6(&dcch_ptr->message.u.radioBearerRelease.
        u.later_than_r3.criticalExtensions.
        u.criticalExtensions.
        u.criticalExtensions.
        u.r6.radioBearerRelease_r6
             ,&dcch_ptr->message.u.radioBearerRelease.
        u.later_than_r3.criticalExtensions.
        u.criticalExtensions.
        u.criticalExtensions.
        u.r6
        ))
    {
      status = FAILURE;
    }         
  }

  else if (RRCRB_R7_CRITICAL_EXT_PRESENT(
          dcch_ptr->message.u.radioBearerRelease, 
          rrc_RadioBearerRelease_))
  {
    if (FAILURE == rrcllc_rb_release_ie_r7(&dcch_ptr->message.u.radioBearerRelease.
        u.later_than_r3.criticalExtensions.
        u.criticalExtensions.
        u.criticalExtensions.
        u.criticalExtensions.
        u.r7))
    {
      status = FAILURE;
    }            
  }
  else if (RRCRB_R8_CRITICAL_EXT_PRESENT(
          dcch_ptr->message.u.radioBearerRelease, 
          rrc_RadioBearerRelease_))
  {
    if (FAILURE == rrcllc_rb_release_ie_r8(&dcch_ptr->message.u.radioBearerRelease.
        u.later_than_r3.criticalExtensions.
        u.criticalExtensions.
        u.criticalExtensions.
        u.criticalExtensions.
        u.criticalExtensions.              
        u.r8))
    {
      status = FAILURE;
    }            
  }

#ifdef FEATURE_WCDMA_REL9
  else if (RRCRB_R9_CRITICAL_EXT_PRESENT(
          dcch_ptr->message.u.radioBearerRelease, 
          rrc_RadioBearerRelease_))
  {
    if (FAILURE == rrcllc_rb_release_ie_r9(&dcch_ptr->message.u.radioBearerRelease.u.later_than_r3.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.later_r8_criticalExtensions.u.r9))
    {
      status = FAILURE;
    }            
  }
#endif /* FEATURE_WCDMA_REL9 */
#ifdef FEATURE_WCDMA_REL10
  #error code not present
#endif /* FEATURE_WCDMA_REL10 */


  else
  {
    if(rrcllc_rb_release_ie_r5(&dcch_ptr->message.u.radioBearerRelease.u.
      later_than_r3.criticalExtensions.u.criticalExtensions.u.r5.radioBearerRelease_r5)
      == FAILURE)
    {
      status = FAILURE;
    }
    if(status == SUCCESS )
    {
      rrcllcpcie_update_sync_a_post_veri_info(msg_ptr,dl_sdu_num);
    }

  }

  return status;
}

/*====================================================================
FUNCTION: rrcllcoc_process_rbe_msg

DESCRIPTION:
  This function processes the Radio Bearer Setup msg based on the REL version and
  updates ordered_config with the latest IEs recv'd by TRadio Bearer Setup msg

DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS if everything is valid, FAILURE otherwise.

SIDE EFFECTS:
  None.
====================================================================*/

static uecomdef_status_e_type rrcllcoc_process_rbe_msg
(
  uint32 dl_sdu_num,
  void *msg_ptr

)
{
  /* local variables */
  uecomdef_status_e_type  status = SUCCESS;
  rrc_DL_DCCH_Message *dcch_ptr;
  dcch_ptr = (rrc_DL_DCCH_Message *)msg_ptr;

  if(RRC_CHECK_COMMON_MSG_TYPE(dcch_ptr->message.u.radioBearerSetup,
      rrc_RadioBearerSetup_r3))
  {
    if(rrcllc_rb_setup_ie(&dcch_ptr->message.u.radioBearerSetup.u.r3.radioBearerSetup_r3)
      == FAILURE)
    {
      status = FAILURE;
    }
    else /*Here we update the cell_id_per_rl that is coming in no-critical extension of the R99 OTA.*/
    {
      if((dcch_ptr->message.u.radioBearerSetup.u.r3.m.v3a0NonCriticalExtensionsPresent) &&
         (dcch_ptr->message.u.radioBearerSetup.u.r3.v3a0NonCriticalExtensions.m.laterNonCriticalExtensionsPresent) && 
         (dcch_ptr->message.u.radioBearerSetup.u.r3.v3a0NonCriticalExtensions.laterNonCriticalExtensions.m. 
          v4b0NonCriticalExtensionsPresent) &&(dcch_ptr->message.u.radioBearerSetup.u.r3.v3a0NonCriticalExtensions.laterNonCriticalExtensions.
              v4b0NonCriticalExtensions.radioBearerSetup_v4b0ext.m.cell_id_PerRL_ListPresent))
      {
        if(RRC_MSG_COMMON_BITMASK_IE(dcch_ptr->message.u.radioBearerSetup.u.r3.radioBearerSetup_r3, 
                rrc_RadioBearerSetup_r3_IEs,dl_InformationPerRL_List))
        {
          rrc_CellIdentity_PerRL_List * ptr_CellIdentity_PerRL = &dcch_ptr->message.u.radioBearerSetup.u.r3.
                    v3a0NonCriticalExtensions.laterNonCriticalExtensions.v4b0NonCriticalExtensions.
                    radioBearerSetup_v4b0ext.cell_id_PerRL_List;
          if(get_cell_id_per_rl_list(ptr_CellIdentity_PerRL, &dcch_ptr->message.u.radioBearerSetup.u.r3.radioBearerSetup_r3.
                  dl_InformationPerRL_List) == FAILURE)
          {
            WRRC_MSG0_ERROR("RBE failed updating cell_id_per_rl");
          }
        }
      } 
    }		  
    if(status == SUCCESS )
    {
      rrcllcpcie_update_sync_a_post_veri_info(msg_ptr,dl_sdu_num);
    }

  }
  else if (RRCRB_R6_CRITICAL_EXT_PRESENT(
          dcch_ptr->message.u.radioBearerSetup, 
          rrc_RadioBearerSetup_))
  {
    
    if (FAILURE == rrcllc_rb_setup_ie_r6(&dcch_ptr->message.u.radioBearerSetup.
        u.later_than_r3.criticalExtensions.
        u.criticalExtensions.
        u.criticalExtensions.u.r6.radioBearerSetup_r6
             ,&dcch_ptr->message.u.radioBearerSetup.
        u.later_than_r3.criticalExtensions.
        u.criticalExtensions.
        u.criticalExtensions.u.r6
        ))
    {
      status = FAILURE;
    }
  }
  else if (RRCRB_R7_CRITICAL_EXT_PRESENT(
          dcch_ptr->message.u.radioBearerSetup, 
          rrc_RadioBearerSetup_))
  {
    if (FAILURE == rrcllc_rb_setup_ie_r7(&dcch_ptr->message.u.radioBearerSetup.
       u.later_than_r3.criticalExtensions.u.
       criticalExtensions.u.criticalExtensions.
       u.criticalExtensions.u.r7))
    {
      status = FAILURE;
    }
  }
  else if (RRCRB_R8_CRITICAL_EXT_PRESENT(
          dcch_ptr->message.u.radioBearerSetup, 
          rrc_RadioBearerSetup_))
  {
    if (FAILURE == rrcllc_rb_setup_ie_r8(&dcch_ptr->message.u.radioBearerSetup.
       u.later_than_r3.criticalExtensions.u.
       criticalExtensions.u.criticalExtensions.
       u.criticalExtensions.u.criticalExtensions.u.r8))
    {
      status = FAILURE;
    }
  }
#ifdef FEATURE_WCDMA_REL9
  else if (RRCRB_R9_CRITICAL_EXT_PRESENT(
          dcch_ptr->message.u.radioBearerSetup, 
          rrc_RadioBearerSetup_))
  {
    if (FAILURE == rrcllc_rb_setup_ie_r9(&dcch_ptr->message.u.radioBearerSetup.
       u.later_than_r3.criticalExtensions.u.
       criticalExtensions.u.criticalExtensions.
       u.criticalExtensions.u.criticalExtensions.u.later_r8_criticalExtensions.u.r9))
    {
      status = FAILURE;
    }
  }

#endif /* FEATURE_WCDMA_REL9 */

#ifdef FEATURE_WCDMA_REL10
  #error code not present
#endif /* FEATURE_WCDMA_REL10 */


  else
  {
    if(rrcllc_rb_setup_ie_r5(&dcch_ptr->message.u.radioBearerSetup.u.
      later_than_r3.criticalExtensions.u.criticalExtensions.u.r5.radioBearerSetup_r5)
      == FAILURE)
    {
      status = FAILURE;
    }
    if(status == SUCCESS )
    {
      rrcllcpcie_update_sync_a_post_veri_info(msg_ptr,dl_sdu_num);
    }


  }

  return status;
}

/*====================================================================
FUNCTION: rrcllcoc_process_tcrc_msg

DESCRIPTION:
  This function processes the Transport Channel Reconfig msg based on the REL version and
  updates ordered_config with the latest IEs recv'd by Transport Channel Reconfig msg

DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS if everything is valid, FAILURE otherwise.

SIDE EFFECTS:
  None.
====================================================================*/

static uecomdef_status_e_type rrcllcoc_process_tcrc_msg
(
  uint32 dl_sdu_num,
  void *msg_ptr

)
{
  /* local variables */
  uecomdef_status_e_type  status = SUCCESS;
  rrc_DL_DCCH_Message *dcch_ptr;
  dcch_ptr = (rrc_DL_DCCH_Message *)msg_ptr;
  
  if (RRC_CHECK_COMMON_MSG_TYPE(dcch_ptr->message.u.transportChannelReconfiguration,
       rrc_TransportChannelReconfiguration_r3))
  {
    if(rrcllc_trch_reconfig_ie(dcch_ptr) == FAILURE)
    {
      status = FAILURE;
    }
    else /*Here we update the cell_id_per_rl that is coming in no-critical extension of the R99 OTA.*/
    {
      rrcllc_process_non_critcal_trch_reconfig_ie(dcch_ptr);
    }
  }
  else if (RRCRB_R6_CRITICAL_EXT_PRESENT(
            dcch_ptr->message.u.transportChannelReconfiguration, 
             rrc_TransportChannelReconfiguration_))
  {

    if (FAILURE == rrcllc_trch_reconfig_ie_r6(&dcch_ptr->message.u.transportChannelReconfiguration.
                   u.later_than_r3.criticalExtensions.u.criticalExtensions.u.criticalExtensions.
                   u.r6.transportChannelReconfiguration_r6
                  ,&dcch_ptr->message.u.transportChannelReconfiguration.
                  u.later_than_r3.criticalExtensions.
                  u.criticalExtensions.
                  u.criticalExtensions.
                  u.r6
       ))
    {
      status = FAILURE;
    }
  }
  else if (RRCRB_R7_CRITICAL_EXT_PRESENT(
            dcch_ptr->message.u.radioBearerSetup, 
            rrc_TransportChannelReconfiguration_))
  {
    if (FAILURE == rrcllc_trch_reconfig_ie_r7(&dcch_ptr->message.u.transportChannelReconfiguration.
           u.later_than_r3.criticalExtensions.u.
           criticalExtensions.u.criticalExtensions.
           u.criticalExtensions.u.r7))
    {
      status = FAILURE;
    }
  }
  else if (RRCRB_R8_CRITICAL_EXT_PRESENT(
            dcch_ptr->message.u.radioBearerSetup, 
             rrc_TransportChannelReconfiguration_))
  {
    if (FAILURE == rrcllc_trch_reconfig_ie_r8(&dcch_ptr->message.u.transportChannelReconfiguration.
          u.later_than_r3.criticalExtensions.u.
           criticalExtensions.u.criticalExtensions.
           u.criticalExtensions.u.criticalExtensions.u.r8))
    {
      status = FAILURE;
    }
  }
#ifdef FEATURE_WCDMA_REL9
  else if (RRCRB_R9_CRITICAL_EXT_PRESENT(
            dcch_ptr->message.u.radioBearerSetup, 
             rrc_TransportChannelReconfiguration_))
  {
    if (FAILURE == rrcllc_trch_reconfig_ie_r9(&dcch_ptr->message.u.transportChannelReconfiguration.
          u.later_than_r3.criticalExtensions.u.
           criticalExtensions.u.criticalExtensions.
           u.criticalExtensions.u.criticalExtensions.u.later_r8_criticalExtensions.u.r9))
    {
      status = FAILURE;
    }
  }

#endif /* FEATURE_WCDMA_REL9 */
#ifdef FEATURE_WCDMA_REL10
  #error code not present
#endif /* FEATURE_WCDMA_REL10 */


  else
  {
    if(rrcllc_trch_reconfig_ie_r5(dcch_ptr) == FAILURE)
    {
      status = FAILURE;
    }
    else
    {
      rrcllc_process_non_critcal_trch_reconfig_ie_r5(dcch_ptr);
    }
  }

  return status;
}

/*====================================================================
FUNCTION: rrcllcoc_process_dcch_cu_msg

DESCRIPTION:
  This function processes the CU m,sg received on DCCH based on the REL version and
  updates ordered_config with the latest IEs recv'd by CU

DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS if everything is valid, FAILURE otherwise.

SIDE EFFECTS:
  None.
====================================================================*/

static uecomdef_status_e_type rrcllcoc_process_dcch_cu_msg
(
  uint32 dl_sdu_num,
  void *msg_ptr

)
{
  /* local variables */
  uecomdef_status_e_type  status = SUCCESS;
  rrc_DL_DCCH_Message *dcch_ptr;
  dcch_ptr = (rrc_DL_DCCH_Message *)msg_ptr;
    
  if (RRC_CHECK_COMMON_MSG_TYPE(dcch_ptr->message.u.cellUpdateConfirm,
     rrc_CellUpdateConfirm_r3))
  {
    if(rrcllc_cell_update_confirm_ie(&dcch_ptr->message.u.cellUpdateConfirm.u.r3.cellUpdateConfirm_r3)
       == FAILURE)
    {
      status = FAILURE;
    }
    else /*Here we update the cell_id_per_rl that is coming in no-critical extension of the R99 OTA.*/
    {
      if((dcch_ptr->message.u.cellUpdateConfirm.u.r3.m.v3a0NonCriticalExtensionsPresent) &&
         (dcch_ptr->message.u.cellUpdateConfirm.u.r3.v3a0NonCriticalExtensions.m.laterNonCriticalExtensionsPresent) &&
         (dcch_ptr->message.u.cellUpdateConfirm.u.r3.v3a0NonCriticalExtensions.laterNonCriticalExtensions.m.v4b0NonCriticalExtensionsPresent) && 
         (dcch_ptr->message.u.cellUpdateConfirm.u.r3.v3a0NonCriticalExtensions.laterNonCriticalExtensions.v4b0NonCriticalExtensions.
           cellUpdateConfirm_v4b0ext.m.cell_id_PerRL_ListPresent))
      {
        if(RRC_MSG_COMMON_BITMASK_IE(dcch_ptr->message.u.cellUpdateConfirm.u.r3.cellUpdateConfirm_r3, 
           rrc_CellUpdateConfirm_r3_IEs,dl_InformationPerRL_List))
        {
          rrc_CellIdentity_PerRL_List * ptr_CellIdentity_PerRL = &dcch_ptr->message.u.cellUpdateConfirm.u.r3.
            v3a0NonCriticalExtensions.laterNonCriticalExtensions.v4b0NonCriticalExtensions.
             cellUpdateConfirm_v4b0ext.cell_id_PerRL_List;
          
          if(get_cell_id_per_rl_list(ptr_CellIdentity_PerRL, &dcch_ptr->message.u.cellUpdateConfirm.u.r3.
             cellUpdateConfirm_r3.dl_InformationPerRL_List) == FAILURE)
          {
            WRRC_MSG0_ERROR("CU_CNF failed updating cell_id_per_rl");
          }
        }
      } 
    }		
    if(status == SUCCESS )
    {
      rrcllcpcie_update_sync_a_post_veri_info(msg_ptr,dl_sdu_num);
    }
  }
  
  else if ((T_rrc_CellUpdateConfirm_criticalExtensions_5_criticalExtensions == 
 dcch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.t) && 
 (T_rrc_CellUpdateConfirm_criticalExtensions_4_criticalExtensions == 
   dcch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.u.criticalExtensions.t) && 
   (T_rrc_CellUpdateConfirm_criticalExtensions_3_r6 ==
    dcch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.u.criticalExtensions.u.criticalExtensions.t))
  {
    rrc_DL_InformationPerRL_List_v6b0ext *dl_InformationPerRL_List_v6b0ext = NULL;

    if(RRCRB_R6_DL_INFO_PERRL_EXT_PRESENT_IN_CU(dcch_ptr,rrc_CellUpdateConfirm,
cellUpdateConfirm))
    {
      dl_InformationPerRL_List_v6b0ext =  &dcch_ptr->message.u.cellUpdateConfirm.
       u.later_than_r3.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.r6.v6b0NonCriticalExtensions.
        cellUpdateConfirm_v6b0ext.dl_InformationPerRL_List_v6b0ext;
    }
    if(rrcllc_cell_update_confirm_ie_r6(&dcch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.
            u.criticalExtensions.u.criticalExtensions.u.r6.cellUpdateConfirm_r6
            ,dl_InformationPerRL_List_v6b0ext
           ) == FAILURE)
    {
      status = FAILURE; 		 
    }
  }
  else if ((T_rrc_CellUpdateConfirm_criticalExtensions_5_criticalExtensions ==
     dcch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.t) && 
   (T_rrc_CellUpdateConfirm_criticalExtensions_4_criticalExtensions == 
     dcch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.u.criticalExtensions.t) && 
   (T_rrc_CellUpdateConfirm_criticalExtensions_3_criticalExtensions == 
     dcch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.u.criticalExtensions.u.criticalExtensions.t) &&
   (T_rrc_CellUpdateConfirm_criticalExtensions_2_r7 == 
     dcch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.u.
     criticalExtensions.u.criticalExtensions.u.criticalExtensions.t) )
  {
    if(rrcllc_cell_update_confirm_ie_r7(dl_sdu_num,msg_ptr) == FAILURE)
    {
      status = FAILURE; 		 
    }
  }
  else if (RRCRB_R8_CU_CRITICAL_EXT_PRESENT_PTR(dcch_ptr,rrc_CellUpdateConfirm))
  {
    if(rrcllc_cell_update_confirm_ie_r8(dl_sdu_num,msg_ptr) == FAILURE)
    {
      status = FAILURE;
    }
  }
#ifdef FEATURE_WCDMA_REL9

  else if (RRCRB_R9_CU_CRITICAL_EXT_PRESENT_PTR(dcch_ptr,rrc_CellUpdateConfirm))
  {
    if(rrcllc_cell_update_confirm_ie_r9(dl_sdu_num,msg_ptr) == FAILURE)
    {
      status = FAILURE;
    }
  }
#endif /* FEATURE_WCDMA_REL9 */

#ifdef FEATURE_WCDMA_REL10
  #error code not present
#endif /* FEATURE_WCDMA_REL10 */


  else
  {
    if(rrcllc_cell_update_confirm_ie_r5(&dcch_ptr->message.u.cellUpdateConfirm.u.
           later_than_r3.criticalExtensions.u.criticalExtensions.u
               .r5.cellUpdateConfirm_r5) == FAILURE)
    {
      status = FAILURE;
    }
    if(status == SUCCESS )
    {
      rrcllcpcie_update_sync_a_post_veri_info(msg_ptr,dl_sdu_num);
    }
  }

  return status;
}

/*====================================================================
FUNCTION: rrcllc_copy_oc_with_msg_ie

DESCRIPTION:
  This function figures out which RRC message was received and
  updates ordered_config with the latest IEs recv'd by one of
  the RRC procedures (i.e. an over-the-air message). This is valid
  only for Downlink DCCH and CCCH messages.

DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS if everything is valid, FAILURE otherwise.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_copy_msg_ie_to_oc
(
  uint32 dl_sdu_num,
  void *msg_ptr
)
{
  /* local variables */
  uecomdef_status_e_type  status = SUCCESS;
  rrc_DL_CCCH_Message *ccch_ptr;
  rrc_DL_DCCH_Message *dcch_ptr;
#ifdef FEATURE_VOC_AMR_WB
  mvs_mode_type codec_info;
  dch_id_mapping  dch_mapping[MAX_DCH_VOICE_CHANNEL];
  mvs_mode_type ordered_codec_info;
  mvs_mode_type current_codec_info;
#ifdef WCDMA_RRC_INDICATE_CODEC_TO_CM
  boolean ordered_codec_status_flag = FALSE;
#endif
#endif

  if(msg_ptr == NULL)
  {
    WRRC_MSG0_ERROR("NULL message ptr passed to OC");
    return(FAILURE);
  }
/*Reset the flag, before process in the OTA message */
  ordered_config_ptr->tm_sync_ind_applicable =0x00;

  /* Determine if it was rcv'd on the DL CCCH */
  if(dl_sdu_num == rrc_DL_CCCH_Message_PDU)
  {
    ccch_ptr = (rrc_DL_CCCH_Message *)msg_ptr;

    /* Since it was a DL CCCH Msg, figure out the Message Type */
    switch(ccch_ptr->message.t)
    {
      case T_rrc_DL_CCCH_MessageType_rrcConnectionSetup:
        WRRC_MSG0_MED("RRC Conn Setup updating ORDERED_CONFIG");
        if(rrcllcoc_process_conn_setup_msg(dl_sdu_num,msg_ptr)== FAILURE)
        {
         status = FAILURE;
        }
   

        break;

      case T_rrc_DL_CCCH_MessageType_cellUpdateConfirm:
        WRRC_MSG0_MED("CellUpdateCnf updating ORDERED_CONFIG");
        if(rrcllcoc_process_ccch_cell_update_cnf(dl_sdu_num,msg_ptr)== FAILURE)
        {
         status = FAILURE;
        }
   
        break;

      case T_rrc_DL_CCCH_MessageType_uraUpdateConfirm:
        WRRC_MSG1_HIGH("CCCH Message %d not supported yet for ORDERED_CONFIG init", ccch_ptr->message.t);
        status = FAILURE;
        break;

      case T_rrc_DL_CCCH_MessageType_rrcConnectionReject:
      case T_rrc_DL_CCCH_MessageType_rrcConnectionRelease:
      /*March2002Rel changes : replaced with spare values
      case rrc_DL_CCCH_MessageType_extension_chosen:
    */
    case T_rrc_DL_CCCH_MessageType_spare2:
    case T_rrc_DL_CCCH_MessageType_spare1:
        WRRC_MSG1_HIGH("Invalid CCCH Message %d updating OC", ccch_ptr->message.t);
        status = FAILURE;
        break;

      default:
        ERR_FATAL("Invalid CCCH Message %d rcv'd", ccch_ptr->message.t,0,0);
        break;
    } /* end CCCH msg switch */
  } /* end DL CCCH msg */

  /* It was rcv'd on the DL DCCH */
  else if(dl_sdu_num == rrc_DL_DCCH_Message_PDU)
  {
    dcch_ptr = (rrc_DL_DCCH_Message *)msg_ptr;

    /* Since it was a DL DCCH Msg, figure out the Message Type */
    switch(dcch_ptr->message.t)
    {
      case T_rrc_DL_DCCH_MessageType_activeSetUpdate:
        WRRC_MSG0_MED("Active Set Updating ORDERED_CONFIG");
        if(rrcllcoc_process_asu_msg(dl_sdu_num,msg_ptr)== FAILURE)
        {
         status = FAILURE;
        }
        break;

      case T_rrc_DL_DCCH_MessageType_physicalChannelReconfiguration:
        WRRC_MSG0_MED("PhyChan Reconfig updating ORDERED_CONFIG");

		if(rrcllcoc_process_pcrc_msg(dl_sdu_num,msg_ptr)== FAILURE)
		{
		 status = FAILURE;
		}

        

        break;

      case T_rrc_DL_DCCH_MessageType_radioBearerReconfiguration:
        WRRC_MSG0_MED("RB Reconfig updating ORDERED_CONFIG");
		if(rrcllcoc_process_rbrc_msg(dl_sdu_num,msg_ptr)== FAILURE)
		{
		 status = FAILURE;
		}

        

        break;

      case T_rrc_DL_DCCH_MessageType_radioBearerRelease:
        WRRC_MSG0_MED("RB Release updating ORDERED_CONFIG");
        if(rrcllcoc_process_rbr_msg(dl_sdu_num,msg_ptr)== FAILURE)
		{
		 status = FAILURE;
		}
       
        
        break;

      case T_rrc_DL_DCCH_MessageType_radioBearerSetup:
        WRRC_MSG0_MED("RB Setup updating ORDERED_CONFIG");
        if(rrcllcoc_process_rbe_msg(dl_sdu_num,msg_ptr)== FAILURE)
		{
		 status = FAILURE;
		}
        

       break;

      case T_rrc_DL_DCCH_MessageType_transportChannelReconfiguration:
        WRRC_MSG0_MED("TrCH reconfig updating ORDERED_CONFIG");
        if(rrcllcoc_process_tcrc_msg(dl_sdu_num,msg_ptr)== FAILURE)
		{
		 status = FAILURE;
		}
        

        break;

      case T_rrc_DL_DCCH_MessageType_cellUpdateConfirm:
        WRRC_MSG0_MED("CellUpdateCnf updating ORDERED_CONFIG");
        if(rrcllcoc_process_dcch_cu_msg(dl_sdu_num,msg_ptr)== FAILURE)
		{
		 status = FAILURE;
		}
        

        break;

      case T_rrc_DL_DCCH_MessageType_handoverFromUTRANCommand_GSM:
      case T_rrc_DL_DCCH_MessageType_handoverFromUTRANCommand_CDMA2000:
      case T_rrc_DL_DCCH_MessageType_securityModeCommand:
      case T_rrc_DL_DCCH_MessageType_transportFormatCombinationControl:
      case T_rrc_DL_DCCH_MessageType_uraUpdateConfirm:
        WRRC_MSG1_HIGH("DCCH Message %d not supported yet for OC", dcch_ptr->message.t);
        status = FAILURE;
        break;

      case T_rrc_DL_DCCH_MessageType_rrcConnectionRelease:
      case T_rrc_DL_DCCH_MessageType_downlinkDirectTransfer:
      case T_rrc_DL_DCCH_MessageType_counterCheck:
      case T_rrc_DL_DCCH_MessageType_measurementControl:
      case T_rrc_DL_DCCH_MessageType_pagingType2:
      case T_rrc_DL_DCCH_MessageType_signallingConnectionRelease:
      case T_rrc_DL_DCCH_MessageType_ueCapabilityEnquiry:
      case T_rrc_DL_DCCH_MessageType_ueCapabilityInformationConfirm:
      case T_rrc_DL_DCCH_MessageType_utranMobilityInformation:
      /*March2002Rel changes : replaced with spare values
      case rrc_DL_DCCH_MessageType_extension_chosen:
      */
      case T_rrc_DL_DCCH_MessageType_handoverFromUTRANCommand_GERANIu:
      case T_rrc_DL_DCCH_MessageType_mbmsModifiedServicesInformation:
      case T_rrc_DL_DCCH_MessageType_ueInformationRequest:
      case T_rrc_DL_DCCH_MessageType_loggingMeasurementConfiguration:
      case T_rrc_DL_DCCH_MessageType_spare1:
        WRRC_MSG1_HIGH("Invalid DCCH Message %d updating OC", dcch_ptr->message.t);
        status = FAILURE;
        break;

      case T_rrc_DL_DCCH_MessageType_physicalSharedChannelAllocation:
      case T_rrc_DL_DCCH_MessageType_uplinkPhysicalChannelControl:
        WRRC_MSG1_HIGH("DL TDD Message %d will never be supported", dcch_ptr->message.t);
        status = FAILURE;
        break;

      default:
        ERR_FATAL("Invalid DCCH Message %d rcv'd", dcch_ptr->message.t,0,0);
        break;
    } /* end DCCH msg switch */
  } /* end DL DCCH msg */

  /* It is a Handover to UTRAN Command */
  else if(dl_sdu_num == rrc_HandoverToUTRANCommand_PDU)
  {
    if(rrcllc_handover_to_utran_ie((rrc_HandoverToUTRANCommand *)msg_ptr) == FAILURE)
    {
      status = FAILURE;
    }
  }

  /* No other downlink SDU type is valid for this case */
  else
  {
    ERR_FATAL("Invalid SDU %d received", dl_sdu_num,0,0);
  }

#ifdef FEATURE_VOC_AMR_WB
  ordered_codec_info = rrc_get_ordered_codec_mode();
  current_codec_info = rrc_get_current_codec_mode();
  if((status == SUCCESS ) && (ordered_codec_info != MVS_MODE_NONE) && (ordered_codec_info != current_codec_info))
  {
    (void) rrcllc_derive_amr_rate(&codec_info,dch_mapping);
    MSG_HIGH(  " derived codec mode = %d current codec mode = %d ordered codec mode = %d", codec_info,current_codec_info,ordered_codec_info);
    if(codec_info != ordered_codec_info)
    {
      WRRC_MSG0_ERROR("Derived code mode is different from Ordered codec mode");
      status = FAILURE;
    }
  }
#endif

  if(status == SUCCESS)
  {
    config_ptr_in_use = ORDERED_CONFIG;
#ifdef WCDMA_RRC_INDICATE_CODEC_TO_CM
    if(!rrciho_is_gtow_ho_active())
    {

      ordered_codec_status_flag = rrc_get_ordered_codec_status();

      if( (TRUE == ordered_config_ptr->is_hho) && 
	  (rrc_get_state() == RRC_STATE_CELL_DCH) && 
          (
            (TRUE == ordered_codec_status_flag) 
	    ||                          /* these checks ensure that voice RAB either established of newly configured */
            (TRUE == rrc_is_voice_rab_present())
	  )
	)
      {
        /*Send HHO start to CM if voice RAB is established or voice RAB is newly configured now*/
        rrc_send_hho_cmd_to_cm(SYS_HO_START,SYS_HO_TYPE_UMTS_UMTS);
      }
	  
      if((ordered_config_ptr->act_time_type == L1_ACTIVATION_TIME_NONE) && (TRUE == ordered_codec_status_flag)) /*Add the activation_time check also if needed*/
      {
        if(FALSE == rrc_is_voice_rab_present() || (ordered_codec_info != current_codec_info))
        {
          /*Sending codec info to CM*/
          rrc_send_codec_info_to_cm(ordered_codec_info);
        }
        else
        {
          MSG_HIGH("is_voice_rab %d, ordered codec %d current codec %d",rrc_is_voice_rab_present(),ordered_codec_info,current_codec_info);
        }
        rrc_set_ordered_codec_status(FALSE);
      }
      else
      {
        WRRC_MSG2_MED("Activation type is %d, ordered config status %d",ordered_config_ptr->act_time_type,ordered_codec_status_flag);
      }
    }
#endif
  }

/*As per the below spec clause for Timing re-initialized HHO deactivate the
  TGPSI which are not given in the OTA
8.6.6.15 DPCH Compressed mode info
For transmission gap pattern sequences stored in variable TGPS_IDENTITY, but not identified in IE "TGPSI" (either
due to the absence of the IE "DPCH compressed mode info" in the received message or due to not receiving the
corresponding TGPSI value in the IE "DPCH compressed mode info"), the UE shall:
1> if the received message implies a timing re-initialised hard handover (see subclause 8.3.5.1):
2> deactivate such transmission gap pattern sequences at the beginning of the frame, indicated by IE "Activation
time" (see subclause 8.6.3.1) received in this message; and
2> set IE "Current TGPS Status Flag" in corresponding UE variable TGPS_IDENTITY to 'inactive'.
*/

  if((status == SUCCESS) && (rrc_ordered_state==RRC_STATE_CELL_DCH) 
    && (ordered_config_ptr->dest_freq_present==TRUE)
    && (ordered_config_ptr->l1_dl_chan_parms.dl_common.dpch_common.timing_ind == L1_TIMING_IND_INIT))
    {
      rrcllc_find_and_deact_cm_pattern(ordered_config_ptr);
    }
  rrc_predef_po3_not_needed = FALSE;
  /*Init the HS global data if msg processing fails to avoid using this info during reselection/oos etc;*/
  if(status == FAILURE)
  {
    /* Initialize HSDPA action forcibly to NOOP */
    rrc_set_hsdpa_action(HSDPA_NOOP);
    rrcllc_init_hsdpa_msg_params_struct();
  }
  /* is_hho check is to prevent logging frequency redirection as it is set to TRUE only for state = DCH,
     States checks for CONNECTING and DISCONNECTED are to prevent logging for RCE and IHO procedures 
     respectively */
  if((status == SUCCESS) && (ordered_config_ptr->is_hho) && (ordered_config_ptr->dest_freq_present == TRUE)
     && (ordered_config_ptr->dest_freq != rrc_ccm_get_curr_camped_freq()) && (rrc_get_state()!= RRC_STATE_CONNECTING) 
     && (rrc_get_state()!= RRC_STATE_DISCONNECTED))
  {
    rrc_log_inter_freq_hho_started = TRUE;
    rrc_log_event_inter_freq_hho_update_status(RRC_LOG_INTER_FREQ_HHO_STARTED);
  }
  return status;
} /* end rrcllc_copy_msg_ie_to_oc() */

/*====================================================================
FUNCTION: rrcllc_get_dl_trch_idx()

DESCRIPTION:
  This function manages DL PCH TrCH Indexes for the UE.

DEPENDENCIES:
  None.

RETURN VALUE:
  uint8 -> A DL PCH TrCH Index that can be used.

SIDE EFFECTS:
  None.
====================================================================*/
uint8 rrcllc_get_dl_pch_trch_idx(
  ordered_config_type  *config_ptr,
  tr_ch_id_type transportChannelIdentity)
{
  /* The PCH TrCH index is always fixed as 0 since there is only
   * 1 PCH
   */
  uint8  pch_trch_idx = 0;

  //  ordered_config_ptr->dl_trch_cnt++;
  /* Allocate an index and update structures if an index is not being used */
  if(config_ptr->dl_pch_trch_idx_in_use == FALSE)
  {
    config_ptr->dl_pch_trch_idx_in_use = TRUE;
    /* Update the L1 count of transport channels */
    config_ptr->l1_dl_cctrch_parms.num_trch++;
  }

  /* Number of PCHs can not be more than 1. Ensure it is 1 whenever
   * SCCPCH has a PCH selected. Update MAC count
   */
  config_ptr->mac_dl_parms.num_pchs = 1;

  /* Save the Transport Channel ID in Local and L1 info */
  /* Note: MAC doesn't care for PCH Transport channel ID */
  config_ptr->dl_pch_trch_info.trch_id  =
  config_ptr->l1_dl_cctrch_parms.trch_info_array[pch_trch_idx]->trch_id =
    (uint8) transportChannelIdentity;

  /* Indicate to L1 that this reference TrCH type is a PCH */
  config_ptr->l1_dl_cctrch_parms.trch_info_array[pch_trch_idx]->
    ref_type = L1_DL_TRCH_PCH_TYPE;

  return (pch_trch_idx);
} /* end rrcllc_get_dl_pch_trch_idx() */

/*====================================================================
FUNCTION: rrcllc_get_dl_pch_trch_idx_for_sccpch_with_ctch()

DESCRIPTION:
  This function manages DL PCH TrCH Indexes for the UE.

DEPENDENCIES:
  None.

RETURN VALUE:
  uint8 -> A DL PCH TrCH Index that can be used.

SIDE EFFECTS:
  None.
====================================================================*/
uint8 rrcllc_get_dl_pch_trch_idx_for_sccpch_with_ctch(
  ordered_config_type  *config_ptr,
  tr_ch_id_type transportChannelIdentity)
{
  /* The PCH TrCH index is always fixed as 0 since there is only
   * 1 PCH
   */
  uint8  pch_trch_idx = 0;

  //  ordered_config_ptr->dl_trch_cnt++;
  /* Allocate an index and update structures if an index is not being used */
  if(config_ptr->dl_pch_trch_idx_in_use_for_sccpch_with_ctch == FALSE)
  {
    config_ptr->dl_pch_trch_idx_in_use_for_sccpch_with_ctch = TRUE;
    /* Update the L1 count of transport channels */
    config_ptr->l1_dl_cctrch_parms_for_sccpch_with_ctch.num_trch++;
  }

  config_ptr->l1_dl_cctrch_parms_for_sccpch_with_ctch.trch_info_array[pch_trch_idx]->trch_id =
    (uint8) transportChannelIdentity;

  /* Indicate to L1 that this reference TrCH type is a PCH */
  config_ptr->l1_dl_cctrch_parms_for_sccpch_with_ctch.trch_info_array[pch_trch_idx]->
    ref_type = L1_DL_TRCH_PCH_TYPE;

  return (pch_trch_idx);
} /* end rrcllc_get_dl_pch_trch_idx() */


/*====================================================================
FUNCTION: rrcllc_allocate_dl_fach_trch_idx_for_sccpch_with_ctch()

DESCRIPTION:
  This function allocates a DL FACH TrCH Index.

DEPENDENCIES:
  None.

RETURN VALUE:
  uint8 -> A DL FACH TrCH Index that can be used.

SIDE EFFECTS:
  trch_idx = 0xFF -> indicates no DL FACH TrCH Indexes are available.
====================================================================*/
uint8 rrcllc_allocate_dl_fach_trch_idx_for_sccpch_with_ctch(ordered_config_type *config_ptr)
{
  uint8 trch_idx; /* local loop variable */

  /* check for a valid DL TrCH Index */
  for(trch_idx = 0; trch_idx < UE_MAX_TRCH; trch_idx++)
  {
    if (config_ptr->dl_fach_trch_idx_in_use_for_sccpch_with_ctch[trch_idx] == FALSE)
    {
      /*
      * If this case holds true, indicate that this DL TrCH Index is used,
      * break the for loop and use this index as the DL TrCH Index.
      */
      config_ptr->dl_fach_trch_idx_in_use_for_sccpch_with_ctch[trch_idx] = TRUE;
      break;
    }
  }
  /* If we reached the max => no index was found */
  if (trch_idx == UE_MAX_TRCH)
  {
    /* no available unused TrCH index */
    trch_idx = RRCLLC_INVALID_TRCH_IDX;
    WRRC_MSG0_ERROR("No available DL FACH TrCH Index");
  }
  /* always return a DL TrCH Index */
  return (trch_idx);
} /* end rrcllc_allocate_dl_fach_trch_idx_for_sccpch_with_ctch() */


/*====================================================================
FUNCTION: rrcllc_allocate_dl_fach_trch_idx()

DESCRIPTION:
  This function allocates a DL FACH TrCH Index.

DEPENDENCIES:
  None.

RETURN VALUE:
  uint8 -> A DL FACH TrCH Index that can be used.

SIDE EFFECTS:
  trch_idx = 0xFF -> indicates no DL FACH TrCH Indexes are available.
====================================================================*/
static uint8 rrcllc_allocate_dl_fach_trch_idx(ordered_config_type *config_ptr)
{
  uint8 trch_idx; /* local loop variable */

  /* check for a valid DL TrCH Index */
  for(trch_idx = 0; trch_idx < UE_MAX_TRCH; trch_idx++)
  {
    if (config_ptr->dl_fach_trch_idx_in_use[trch_idx] == FALSE)
    {
      /*
      * If this case holds true, indicate that this DL TrCH Index is used,
      * break the for loop and use this index as the DL TrCH Index.
      */
      config_ptr->dl_fach_trch_idx_in_use[trch_idx] = TRUE;
      break;
    }
  }
  /* If we reached the max => no index was found */
  if (trch_idx == UE_MAX_TRCH)
  {
    /* no available unused TrCH index */
    trch_idx = RRCLLC_INVALID_TRCH_IDX;
    WRRC_MSG0_ERROR("No available DL FACH TrCH Index");
  }
  /* always return a DL TrCH Index */
  return (trch_idx);
} /* end rrcllc_allocate_dl_fach_trch_idx() */

/*====================================================================
FUNCTION: rrcllc_find_dl_fach_trch_idx()

DESCRIPTION:
  This function looks for and returns the 1st allocated transport
  channel index for FACH.

DEPENDENCIES:
  None.

RETURN VALUE:
  uint8 -> A DL FACH TrCH Index that was already allocated.
  RRCLLC_INVALID_TRCH_IDX -> No index allocated to a FACH.

SIDE EFFECTS:
====================================================================*/
uint8  rrcllc_find_dl_fach_trch_idx(void)
{
  uint8 trch_idx;

  for(trch_idx = 0; trch_idx < UE_MAX_TRCH; trch_idx++)
  {
    if((ordered_config_ptr->dl_fach_trch_info[trch_idx].trch_id != 0) &&
       (ordered_config_ptr->dl_fach_trch_idx_in_use[trch_idx] == TRUE))
    {
      /* Get Transport channel mapping index, since
       * it is already in database
       */
      break;
    }
  }
  if(trch_idx == UE_MAX_TRCH)
  {
    WRRC_MSG0_HIGH("DL FACH TrCH idx not found");
    trch_idx =  RRCLLC_INVALID_TRCH_IDX;
  }

  return(trch_idx);
}

/*====================================================================
FUNCTION: rrcllc_get_dl_fach_trch_idx()

DESCRIPTION:
  This function gets a DL FACH TrCH Index for a given TrCH ID. If an
  index already exists, it is returned. Otherwise a new one is
  allocated for this TrCH ID.
  If a new TrCH index is allocated, TrCH count in MAC, L1 and local
  data for TrCH ID and reference type is updated. The number of
  DL transport channels is also incremented in local, L1 and MAC
  structures.

DEPENDENCIES:
  None.

RETURN VALUE:
  uint8 -> A DL FACH TrCH Index that can be used.

SIDE EFFECTS:
  trch_idx = 0xFF -> indicates no DL FACH TrCH Indexes are available.
====================================================================*/
uint8 rrcllc_get_dl_fach_trch_idx(
  ordered_config_type  *config_ptr,
  tr_ch_id_type  trch_id,
  uint8 pch_trch_idx
)
{
  /* transport Channel Index */
  uint8         trch_idx;

  /* Indicate if already have this TrCH Id */
  boolean       trch_idx_found = FALSE;

  /* First look if this Transport Channel ID is already present
   * in an index that is being IN Use.
   */
  for(trch_idx = 0; trch_idx < UE_MAX_TRCH; trch_idx++)
  {
    if((config_ptr->dl_fach_trch_info[trch_idx].trch_id == trch_id) &&
       (config_ptr->dl_fach_trch_idx_in_use[trch_idx] == TRUE))
    {
      /* Get Transport channel mapping index, since
       * it is already in database
       */
      trch_idx_found = TRUE;
      break;
    }
  }

  if(trch_idx_found)
  {
    /* Since a Transport Channel Index that is in use has been found,
     * return this index. No need to change any counters or initialize
     * transport channel ID.
     */
    return(trch_idx);
  }
  else  /* TrCH index not found, allocate new */
  {
    /* An index with the same transport channel ID is NOT in use.
     * Need to allocate a new index.
     */
    trch_idx = rrcllc_allocate_dl_fach_trch_idx(config_ptr);
	
    if(trch_idx >= UE_MAX_TRCH)
    {
      /* Failure to allocate a new TrCH Index */
      return(trch_idx);
    }
    else  /* A valid new index has been allocated */
    {
      /* Now we've got a new TrCH index - need to initialize TrCH
       * data in local, MAC and L1 structures.
       */
      /* Update the Local info */
      config_ptr->dl_fach_trch_info[trch_idx].trch_id     = trch_id;
      config_ptr->dl_fach_trch_info[trch_idx].dch_present = FALSE;

      /* Save Transport Channel ID in MAC Configuration Data */
      config_ptr->fach_info[trch_idx].trch_id = trch_id;

      /* Save the TrCH type and TrCH ID to L1 data */
      config_ptr->dl_trch_info[pch_trch_idx+trch_idx].ref_type =
        L1_DL_TRCH_FACH_TYPE;
      config_ptr->dl_trch_info[pch_trch_idx+trch_idx].trch_id =
        (unsigned char)trch_id;

      /* MAC count */
      config_ptr->mac_dl_parms.num_fachs++;
      /* L1 count */
      config_ptr->l1_dl_cctrch_parms.num_trch++;

      return(trch_idx);

    } /* A valid new index allocated */
  } /* Existing transport channel index couldn't be found, allocated new */
} /* rrcllc_get_dl_fach_trch_idx */


/*====================================================================
FUNCTION: rrcllc_get_dl_fach_trch_idx_for_sccpch_with_ctch()

DESCRIPTION:
  This function gets a DL FACH TrCH Index for a given TrCH ID. If an
  index already exists, it is returned. Otherwise a new one is
  allocated for this TrCH ID.
  If a new TrCH index is allocated, TrCH count in MAC, L1 and local
  data for TrCH ID and reference type is updated. The number of
  DL transport channels is also incremented in local, L1 and MAC
  structures.

DEPENDENCIES:
  None.

RETURN VALUE:
  uint8 -> A DL FACH TrCH Index that can be used.

SIDE EFFECTS:
  trch_idx = 0xFF -> indicates no DL FACH TrCH Indexes are available.
====================================================================*/
uint8 rrcllc_get_dl_fach_trch_idx_for_sccpch_with_ctch(
  ordered_config_type  *config_ptr,
  tr_ch_id_type  trch_id,
  uint8 pch_trch_idx,
  boolean ctch_indicator
)
{
  /* transport Channel Index */
  uint8         trch_idx;

  /* Indicate if already have this TrCH Id */
  boolean       trch_idx_found = FALSE;

  uint8 mac_trch_idx;

  /* First look if this Transport Channel ID is already present
   * in an index that is being IN Use.
   */
  for(trch_idx = 0; trch_idx < UE_MAX_TRCH; trch_idx++)
  {
    if((config_ptr->dl_fach_trch_info_for_sccpch_with_ctch[trch_idx].trch_id == trch_id) &&
       (config_ptr->dl_fach_trch_idx_in_use_for_sccpch_with_ctch[trch_idx] == TRUE))
    {
      /* Get Transport channel mapping index, since
       * it is already in database
       */
      trch_idx_found = TRUE;
      break;
    }
  }

  if(trch_idx_found)
  {
    /* Since a Transport Channel Index that is in use has been found,
     * return this index. No need to change any counters or initialize
     * transport channel ID.
     */

    if(ctch_indicator)
    {
      for(mac_trch_idx = 0; mac_trch_idx < config_ptr->mac_dl_parms.num_fachs; mac_trch_idx++)
      {
        if(config_ptr->mac_dl_parms.fach_info[mac_trch_idx]->trch_id == config_ptr->dl_fach_trch_info_for_sccpch_with_ctch[trch_idx].trch_id)
        { 
          config_ptr->mac_dl_parms.fach_info[mac_trch_idx]->ctch_enable = TRUE; 
          break;
        }
      }
    }
    
    return(trch_idx);
  }
  else  /* TrCH index not found, allocate new */
  {
    /* An index with the same transport channel ID is NOT in use.
     * Need to allocate a new index.
     */
    trch_idx = rrcllc_allocate_dl_fach_trch_idx_for_sccpch_with_ctch(config_ptr);
    if(trch_idx >= UE_MAX_TRCH)
    {
      /* Failure to allocate a new TrCH Index */
      return(trch_idx);
    }
    else  /* A valid new index has been allocated */
    {
      /* Now we've got a new TrCH index - need to initialize TrCH
       * data in local, MAC and L1 structures.
       */
      /* Update the Local info */
      config_ptr->dl_fach_trch_info_for_sccpch_with_ctch[trch_idx].trch_id     = trch_id;
      config_ptr->dl_fach_trch_info_for_sccpch_with_ctch[trch_idx].dch_present = FALSE;

      /* Save Transport Channel ID in MAC Configuration Data */
      config_ptr->fach_info[config_ptr->mac_dl_parms.num_fachs].trch_id = trch_id;

      /* Save the TrCH type and TrCH ID to L1 data */
      config_ptr->dl_trch_info_for_sccpch_with_ctch[pch_trch_idx+trch_idx].ref_type =
        L1_DL_TRCH_FACH_TYPE;
      config_ptr->dl_trch_info_for_sccpch_with_ctch[pch_trch_idx+trch_idx].trch_id =
        (unsigned char)trch_id;

      if(ctch_indicator)
      {
        config_ptr->mac_dl_parms.fach_info[config_ptr->mac_dl_parms.num_fachs]->ctch_enable = TRUE;
      }
        
      /* MAC count */
      config_ptr->mac_dl_parms.num_fachs++;
      /* L1 count */
      config_ptr->l1_dl_cctrch_parms_for_sccpch_with_ctch.num_trch++;

      return(trch_idx);

    } /* A valid new index allocated */
  } /* Existing transport channel index couldn't be found, allocated new */
} /* rrcllc_get_dl_fach_trch_idx_for_sccpch_with_ctch */


/*====================================================================
FUNCTION: rrc_get_rl_idx_for_psc()

DESCRIPTION:
  This function finds out in index for a given PSC in OC.

DEPENDENCIES:
  None.

RETURN VALUE:
  RL index in OC

SIDE EFFECTS:
====================================================================*/
uint8 rrc_get_rl_idx_for_psc
(
  uint16 psc
)
{
  uint8 rl_idx=0;
  for(rl_idx =0; rl_idx < L1_MAX_RL; rl_idx++)
  {
    if(ordered_config_ptr->l1_dl_chan_parms.dl_per_rl[rl_idx].pri_cpich_scr_code == psc)
    {
      break;
    }
  }
  return rl_idx;
}

/*====================================================================
FUNCTION: rrcllc_allocate_dl_dch_trch_idx()

DESCRIPTION:
  This function allocates a DL DCH TrCH Index.

DEPENDENCIES:
  None.

RETURN VALUE:
  uint8 -> A DL DCH TrCH Index that can be used.

SIDE EFFECTS:
  trch_idx = 0xFF -> indicates no DL DCH TrCH Indexes are available.
====================================================================*/
uint8 rrcllc_allocate_dl_dch_trch_idx(void)
{
  uint8 trch_idx; /* local loop variable */

  /* check for a valid DL TrCH Index */
  for(trch_idx = 0; trch_idx < UE_MAX_TRCH; trch_idx++)
  {
    if (ordered_config_ptr->dl_dch_trch_idx_in_use[trch_idx] == FALSE)
    {
      /*
      * If this case holds true, indicate that this DL TrCH Index is used,
      * break the for loop and use this index as the DL TrCH Index.
      */
      ordered_config_ptr->dl_dch_trch_idx_in_use[trch_idx] = TRUE;
      break;
    }
  }
  /* If we reached the max => no index was found */
  if (trch_idx == UE_MAX_TRCH)
  {
    /* no available unused TrCH index */
    trch_idx = RRCLLC_INVALID_TRCH_IDX;
    WRRC_MSG0_ERROR("No available DL DCH TrCH Indexes");
  }
  /* always return a DL TrCH Index */
  return (trch_idx);
} /* end rrcllc_allocate_dl_dch_trch_idx() */

/*====================================================================
FUNCTION: rrcllc_find_dl_dch_trch_idx()

DESCRIPTION:
  This function looks for and returns a transport channel index
  for a given DCH transport channel ID. It returns a valid index only
  if it was already assigned to the given DCH transport channel ID.

DEPENDENCIES:
  None.

RETURN VALUE:
  uint8 -> A DL DCH TrCH Index that was already allocated to
           given transport channel ID.
  RRCLLC_INVALID_TRCH_IDX -> Given Transport channel ID does not
           have an allocated DCH transport channel index.

SIDE EFFECTS:
====================================================================*/
uint8  rrcllc_find_dl_dch_trch_idx(tr_ch_id_type  trch_id)
{
  uint8 trch_idx;

  for(trch_idx = 0; trch_idx < UE_MAX_TRCH; trch_idx++)
  {
    if((ordered_config_ptr->dl_dch_trch_info[trch_idx].dch_present) &&
       (ordered_config_ptr->dl_dch_trch_info[trch_idx].trch_id == trch_id) &&
       (ordered_config_ptr->dl_dch_trch_idx_in_use[trch_idx] == TRUE))
    {
      /* Get Transport channel mapping index, since
       * it is already in database
       */
      break;
    }
  }
  if(trch_idx == UE_MAX_TRCH)
  {
    WRRC_MSG1_HIGH("DL DCH TrCH idx not found: ID %d", trch_id);
    trch_idx =  RRCLLC_INVALID_TRCH_IDX;
  }

  return(trch_idx);
}

/*====================================================================
FUNCTION: rrcllc_get_dl_dch_trch_idx()

DESCRIPTION:
  This function gets a DL DCH TrCH Index for a given TrCH ID. If an
  index already exists, it is returned. Otherwise a new one is
  allocated for this TrCH ID.
  If a new TrCH index is allocated, TrCH count in MAC, L1 and local
  data for TrCH ID and reference type is updated. The number of
  DL transport channels is also incremented in local, L1 and MAC
  structures.

DEPENDENCIES:
  None.

RETURN VALUE:
  uint8 -> A DL DCH TrCH Index that can be used.

SIDE EFFECTS:
  trch_idx = 0xFF -> indicates no DL DCH TrCH Indexes are available.
====================================================================*/
uint8 rrcllc_get_dl_dch_trch_idx(tr_ch_id_type  trch_id)
{
  /* transport Channel Index */
  uint8         trch_idx;

  /* Indicate if already have this TrCH Id */
  boolean       trch_idx_found = FALSE;

  /* First look if this Transport Channel ID is already present
   * in an index that is being IN Use.
   */
  for(trch_idx = 0; trch_idx < UE_MAX_TRCH; trch_idx++)
  {
    if((ordered_config_ptr->dl_dch_trch_info[trch_idx].dch_present) &&
       (ordered_config_ptr->dl_dch_trch_info[trch_idx].trch_id == trch_id) &&
       (ordered_config_ptr->dl_dch_trch_idx_in_use[trch_idx] == TRUE))
    {
      /* Get Transport channel mapping index, since
       * it is already in database
       */
      trch_idx_found = TRUE;
      break;
    }
  }

  if(trch_idx_found)
  {
    /* Since a Transport Channel Index that is in use has been found,
     * return this index. No need to change any counters or initialize
     * transport channel ID.
     */
    return(trch_idx);
  }
  else  /* TrCH index not found, allocate new */
  {
    /* An index with the same transport channel ID is NOT in use.
     * Need to allocate a new index.
     */
    trch_idx = rrcllc_allocate_dl_dch_trch_idx();

    if(trch_idx >= UE_MAX_TRCH)
    {
      /* Failure to allocate a new TrCH Index */
      return(trch_idx);
    }
    else  /* A valid new index has been allocated */
    {
      /* Now we've got a new TrCH index - need to initialize TrCH
       * data in local, MAC and L1 structures.
       */
      /* Update the Local info */
      ordered_config_ptr->dl_dch_trch_info[trch_idx].dch_present = TRUE;
      ordered_config_ptr->dl_dch_trch_info[trch_idx].trch_id     = trch_id;

      /* Save Transport Channel ID in MAC Configuration Data */
      ordered_config_ptr->dl_dch_info[trch_idx].trch_id = trch_id;

      /* Save the TrCH type and TrCH ID to L1 data */
      ordered_config_ptr->dl_trch_info[trch_idx].ref_type = L1_DL_TRCH_DCH_TYPE;
      ordered_config_ptr->dl_trch_info[trch_idx].trch_id = (unsigned char)trch_id;

      /* MAC count */
      ordered_config_ptr->mac_dl_parms.num_dchs++;
      /* L1 count */
      ordered_config_ptr->l1_dl_cctrch_parms.num_trch++;
     /* set dl_tfcs_needed flag to true.  Later if common info is not preset,
      * UE needs to reject the message 
      */
      dl_tfcs_needed = TRUE;
      return(trch_idx);

    } /* A valid new index allocated */
  } /* Existing transport channel index couldn't be found, allocated new */
} /* rrcllc_get_dl_dch_trch_idx */

/*====================================================================
FUNCTION: rrcllc_clear_dl_pch_trch_idx()

DESCRIPTION:
  This function clears a DL PCH TrCH Index for later UE use.

DEPENDENCIES:
  None.

RETURN VALUE:
  ue_comdef_status_e_type -> SUCCESS indicates a DL PCH TrCH Index was cleared
                             FAILURE indicates a DL PCH TrCH Index was not cleared

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_clear_dl_pch_trch_idx(void)
{
  ordered_config_ptr->dl_pch_trch_idx_in_use   = FALSE;
  return SUCCESS;
} /* end rrcllc_clear_dl_trch_idx() */

/*====================================================================
FUNCTION: rrcllc_clear_dl_fach_trch_idx()

DESCRIPTION:
  This function clears a DL FACH TrCH Index for later UE use.

DEPENDENCIES:
  None.

RETURN VALUE:
  ue_comdef_status_e_type -> SUCCESS indicates a DL FACH TrCH Index was cleared
                             FAILURE indicates a DL FACH TrCH Index was not cleared

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_clear_dl_fach_trch_idx(uint8 trch_idx)
{
  uecomdef_status_e_type status = SUCCESS;

  /*
  * Check to make sure that the DL TrCH Index is in range
  */
  if(trch_idx < UE_MAX_TRCH)
  {
    ordered_config_ptr->dl_fach_trch_idx_in_use[trch_idx] = FALSE;
  }
  else
  {
    /* Bad TrCH Index */
    MSG_MED("Cannot free an invalid DL FACH TrCH Index",0,0,0);
    status = FAILURE;
  }

  return status;
} /* end rrcllc_clear_dl_fach_trch_idx() */

/*====================================================================
FUNCTION: rrcllc_deallocate_dl_dch_trch_idx()

DESCRIPTION:
  This function deallocates a DL DCH TrCH Index for later UE use.

DEPENDENCIES:
  None.

RETURN VALUE:
  ue_comdef_status_e_type -> SUCCESS indicates a DL DCH TrCH Index
                             was cleared
                             FAILURE indicates a DL DCH TrCH Index
                             was not cleared
SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_deallocate_dl_dch_trch_idx(uint8 trch_idx)
{
  uecomdef_status_e_type status = SUCCESS;

  /*
  * Check to make sure that the DL TrCH Index is in range
  */
  if(trch_idx < UE_MAX_TRCH)
  {
    ordered_config_ptr->dl_dch_trch_idx_in_use[trch_idx] = FALSE;
  }
  else
  {
    /* Bad TrCH Index */
    MSG_MED("Cannot free an invalid DL FACH TrCH Index",0,0,0);
    status = FAILURE;
  }

  return status;
} /* end rrcllc_deallocate_dl_dch_trch_idx() */

/*====================================================================
FUNCTION: rrcllc_allocate_ul_rach_trch_idx()

DESCRIPTION:
  This function allocates UL RACH TrCH Indexes for the UE.

DEPENDENCIES:
  None.

RETURN VALUE:
  uint8 -> A UL RACH TrCH Index that can be used.

SIDE EFFECTS:
  trch_idx = 0xFF -> indicates no UL RACH TrCH Indexes are available.
====================================================================*/
static uint8 rrcllc_allocate_ul_rach_trch_idx
(
  boolean  *ul_rach_trch_idx_in_use
)
{
  uint8 trch_idx; /* local loop variable */

  /* check for a valid UL TrCH Index */
  for(trch_idx = 0; trch_idx < UE_MAX_TRCH; trch_idx++)
  {
    if (ul_rach_trch_idx_in_use[trch_idx] == FALSE)
    {
      /*
      * If this case holds true, indicate that this UL TrCH Index is used,
      * break the for loop and use this index as the UL TrCH Index.
      */
      ul_rach_trch_idx_in_use[trch_idx] = TRUE;
      break;
    }
  }
  if (trch_idx == UE_MAX_TRCH)
  {
    /* no available TrCHs index's */
    trch_idx = RRCLLC_INVALID_TRCH_IDX;
    MSG_MED("No available UL RACH TrCH Indexes",0,0,0);
  }

  /* always return a UL TrCH Index */
  return trch_idx;

} /* end rrcllc_allocate_ul_rach_trch_idx() */

/*====================================================================
FUNCTION: rrcllc_find_ul_rach_trch_idx()

DESCRIPTION:
  This function looks for an already allocated transport channel index
  for an UL RACH transport channel.

DEPENDENCIES:
  None.

RETURN VALUE:
  Transport Channel Index.
  If no index found, returns RRCLLC_INVALID_TRCH_IDX.

SIDE EFFECTS:
  None.
====================================================================*/
uint8  rrcllc_find_ul_rach_trch_idx(void)
{
  uint8 trch_idx;
  /* Indicate if already have this TrCH Id */
  boolean       trch_idx_found = FALSE;

  for(trch_idx = 0; trch_idx < UE_MAX_TRCH; trch_idx++)
  {
    if(ordered_config_ptr->ul_rach_trch_idx_in_use[trch_idx] == TRUE)
    {
      /* Get Transport channel mapping index, since
       * it is already in database
       */
      trch_idx_found = TRUE;
      break;
    }
  }
  if(trch_idx_found)
  {
    return(trch_idx);
  }
  else
  {
    WRRC_MSG1_HIGH("UL TrCH idx not found for ID %d", trch_idx);
    return(RRCLLC_INVALID_TRCH_IDX);
  }
}  /* rrcllc_find_ul_rach_trch_idx */

/*====================================================================
FUNCTION: rrcllc_get_ul_rach_trch_idx_for_prach_db()

DESCRIPTION:
  This function gets a UL DCH TrCH Index for a given TrCH ID. If an
  index already exists, it is returned. Otherwise a new one is
  allocates for this TrCH ID.

DEPENDENCIES:
  None.

RETURN VALUE:
  uint8 -> A UL RACH TrCH Index that can be used.

SIDE EFFECTS:
  trch_idx = 0xFF -> indicates no DL RACH TrCH Indexes are available.
  If a new TrCH index is allocated, TrCH count in MAC, L1 and local
  data is incremented.
====================================================================*/
uint8 rrcllc_get_ul_rach_trch_idx_for_prach_db
(
  prach_config_type *prach_config_ptr,
  rrcllc_prach_sel_info_type * prach_sel_info_ptr,
  tr_ch_id_type  trch_id
)
{
  /* transport Channel Index */
  uint8         trch_idx;

  /* Indicate if already have this TrCH Id */
  boolean       trch_idx_found = FALSE;

  /* First look if this Transport Channel ID is already present
   * in an index that is being IN Use.
   */
  for(trch_idx = 0; trch_idx < UE_MAX_TRCH; trch_idx++)
  {
    if((prach_config_ptr->ul_rach_trch_info[trch_idx].trch_id == trch_id) &&
       (prach_config_ptr->ul_rach_trch_idx_in_use[trch_idx] == TRUE))
    {
      /* Get Transport channel mapping index, since
       * it is already in database
       */
      trch_idx_found = TRUE;
      WRRC_MSG1_HIGH("Found RACH trch_idx = %d",trch_idx);
      break;
    }
  }

  if(trch_idx_found)
  {
    /* Since a Transport Channel Index that is in use has been found,
     * return this index. No need to change any counters or initialize
     * transport channel ID.
     */
    return(trch_idx);
  }
  else  /* TrCH index not found, allocate new */
  {
    /* An index with the same transport channel ID is NOT in use.
     * Need to allocate a new index.
     */
    trch_idx = rrcllc_allocate_ul_rach_trch_idx(prach_config_ptr->ul_rach_trch_idx_in_use);

    if(trch_idx >= UE_MAX_TRCH)
    {
      /* Failure to allocate a new TrCH Index */
      return(trch_idx);
    }
    else  /* A valid new index has been allocated */
    {
      /* Now we've got a new TrCH index - need to initialize TrCH
       * data in local, MAC and L1 structures.
       */
      /* Update the Local info */
      prach_config_ptr->ul_rach_trch_info[trch_idx].dch_present = FALSE;
      prach_config_ptr->ul_rach_trch_info[trch_idx].trch_id     = trch_id;

      /* MAC TrCH count in TFCS */
      prach_sel_info_ptr->ul_tfcs.nchan++;

      /* L1 count */
      prach_sel_info_ptr->l1_ul_cctrch_parms.num_trch ++;
      if (prach_sel_info_ptr->l1_ul_cctrch_parms.num_trch > 1) 
      {
        WRRC_MSG0_ERROR("PRACH shall not have more that 1 TrCH");
      }
      return(trch_idx);
    }/* A valid new index allocated */
  } /* Existing transport channel index couldn't be found, allocated new */

}

/*====================================================================
FUNCTION: rrcllc_get_ul_rach_trch_idx()

DESCRIPTION:
  This function gets a UL DCH TrCH Index for a given TrCH ID. If an
  index already exists, it is returned. Otherwise a new one is
  allocates for this TrCH ID.

DEPENDENCIES:
  None.

RETURN VALUE:
  uint8 -> A UL RACH TrCH Index that can be used.

SIDE EFFECTS:
  trch_idx = 0xFF -> indicates no DL RACH TrCH Indexes are available.
  If a new TrCH index is allocated, TrCH count in MAC, L1 and local
  data is incremented.
====================================================================*/
uint8 rrcllc_get_ul_rach_trch_idx
(
  ordered_config_type *config_ptr,
  tr_ch_id_type  trch_id
)
{
  /* transport Channel Index */
  uint8         trch_idx;

  /* Indicate if already have this TrCH Id */
  boolean       trch_idx_found = FALSE;

  /* First look if this Transport Channel ID is already present
   * in an index that is being IN Use.
   */
  for(trch_idx = 0; trch_idx < UE_MAX_TRCH; trch_idx++)
  {
    if((config_ptr->ul_rach_trch_info[trch_idx].trch_id == trch_id) &&
       (config_ptr->ul_rach_trch_idx_in_use[trch_idx] == TRUE))
    {
      /* Get Transport channel mapping index, since
       * it is already in database
       */
      trch_idx_found = TRUE;
      break;
    }
  }

  if(trch_idx_found)
  {
    /* Since a Transport Channel Index that is in use has been found,
     * return this index. No need to change any counters or initialize
     * transport channel ID.
     */
    return(trch_idx);
  }
  else  /* TrCH index not found, allocate new */
  {
    /* An index with the same transport channel ID is NOT in use.
     * Need to allocate a new index.
     */
    trch_idx = rrcllc_allocate_ul_rach_trch_idx(config_ptr->ul_rach_trch_idx_in_use);

    if(trch_idx >= UE_MAX_TRCH)
    {
      /* Failure to allocate a new TrCH Index */
      return(trch_idx);
    }
    else  /* A valid new index has been allocated */
    {
      /* Now we've got a new TrCH index - need to initialize TrCH
       * data in local, MAC and L1 structures.
       */
      /* Update the Local info */
      config_ptr->ul_rach_trch_info[trch_idx].dch_present = FALSE;
      config_ptr->ul_rach_trch_info[trch_idx].trch_id     = trch_id;

      /* Save Transport Channel ID in MAC Configuration Data */
      config_ptr->ul_cctrch.rach_info.trch_id = trch_id;
      config_ptr->ul_cctrch.cctrch_type = RACH;

      /* Save Transport Channel ID in L1 UL configuration */
      config_ptr->l1_ul_chan_parms.prach_cfg.trch_id =
        (uint8) trch_id;

      /* Local count */
      //ordered_config_ptr->ul_trch_cnt ++;

      /* No MAC count for RACH - only 1 permissible */

      /* MAC TrCH count in TFCS */
      config_ptr->ul_tfcs.nchan++;

      /* L1 count */
      config_ptr->l1_ul_cctrch_parms.num_trch ++;
      if (config_ptr->l1_ul_cctrch_parms.num_trch > 1) 
      {
        WRRC_MSG0_ERROR("PRACH shall not have more that 1 TrCH");
      }
      return(trch_idx);
    } /* A valid new index allocated */
  } /* Existing transport channel index couldn't be found, allocated new */
} /* rrcllc_get_ul_rach_trch_idx */


/*====================================================================
FUNCTION: rrcllc_allocate_ul_dch_trch_idx()

DESCRIPTION:
  This function manages UL DCH TrCH Indexes for the UE.

DEPENDENCIES:
  None.

RETURN VALUE:
  uint8 -> A UL DCH TrCH Index that can be used.

SIDE EFFECTS:
  trch_idx = 0xFF -> indicates no UL DCH TrCH Indexes are available.
====================================================================*/
uint8 rrcllc_allocate_ul_dch_trch_idx(void)
{
  uint8 trch_idx; /* local loop variable */

  /* check for a valid UL TrCH Index */
  for(trch_idx = 0; trch_idx < UE_MAX_TRCH; trch_idx++)
  {
    if (ordered_config_ptr->ul_dch_trch_idx_in_use[trch_idx] == FALSE)
    {
      /*
      * If this case holds true, indicate that this UL TrCH Index is used,
      * break the for loop and use this index as the UL TrCH Index.
      */
      ordered_config_ptr->ul_dch_trch_idx_in_use[trch_idx] = TRUE;
      break;
    }
  }
  if(trch_idx == UE_MAX_TRCH)
  {
    /* no available TrCHs index's */
    trch_idx = RRCLLC_INVALID_TRCH_IDX;
    WRRC_MSG0_ERROR("No available UL DCH TrCH Indexes");
  }
  /* always return a UL TrCH Index */
  return trch_idx;
} /* end rrcllc_allocate_ul_dch_trch_idx() */

/*====================================================================
FUNCTION: rrcllc_find_ul_dch_trch_idx()

DESCRIPTION:
  This function looks for and returns a transport channel index for a
  given UL DCH transport channel ID. It returns a valid index only
  if it was already assigned to the given DCH transport channel ID.

DEPENDENCIES:
  None.

RETURN VALUE:
  uint8 -> A UL DCH TrCH Index that was already allocated to
           given transport channel ID.
  RRCLLC_INVALID_TRCH_IDX -> Given Transport channel ID does not
           have an allocated DCH transport channel index.

SIDE EFFECTS:
====================================================================*/
uint8  rrcllc_find_ul_dch_trch_idx(ordered_config_type *config_ptr,
                                   tr_ch_id_type  trch_id)
{
  uint8 trch_idx;
  /* Indicate if already have this TrCH Id */
  boolean       trch_idx_found = FALSE;

  for(trch_idx = 0; trch_idx < UE_MAX_TRCH; trch_idx++)
  {
    if((config_ptr->ul_dch_trch_info[trch_idx].dch_present) &&
       (config_ptr->ul_dch_trch_info[trch_idx].trch_id == trch_id) &&
       (config_ptr->ul_dch_trch_idx_in_use[trch_idx] == TRUE))
    {
      /* Get Transport channel mapping index, since
       * it is already in database
       */
      trch_idx_found = TRUE;
      break;
    }
  }
  if(trch_idx_found)
  {
    return(trch_idx);
  }
  else
  {
    WRRC_MSG1_HIGH("TrCH idx not found for ID %d", trch_id);
    return(RRCLLC_INVALID_TRCH_IDX);
  }
}

/*====================================================================
FUNCTION: rrcllc_get_ul_dch_trch_idx()

DESCRIPTION:
  This function gets a UL DCH TrCH Index for a given TrCH ID. If an
  index already exists, it is returned. Otherwise a new one is
  allocates for this TrCH ID.

DEPENDENCIES:
  None.

RETURN VALUE:
  uint8 -> A UL DCH TrCH Index that can be used.

SIDE EFFECTS:
  trch_idx = 0xFF -> indicates no DL DCH TrCH Indexes are available.
  If a new TrCH index is allocated, TrCH count in MAC, L1 and local
  data is incremented.
====================================================================*/
uint8 rrcllc_get_ul_dch_trch_idx(tr_ch_id_type  trch_id)
{
  /* transport Channel Index */
  uint8         trch_idx;

  /* Indicate if already have this TrCH Id */
  boolean       trch_idx_found = FALSE;

  /* First look if this Transport Channel ID is already present
   * in an index that is being IN Use.
   */
  for(trch_idx = 0; trch_idx < UE_MAX_TRCH; trch_idx++)
  {
    if((ordered_config_ptr->ul_dch_trch_info[trch_idx].dch_present) &&
       (ordered_config_ptr->ul_dch_trch_info[trch_idx].trch_id == trch_id) &&
       (ordered_config_ptr->ul_dch_trch_idx_in_use[trch_idx] == TRUE))
    {
      /* Get Transport channel mapping index, since
       * it is already in database
       */
      trch_idx_found = TRUE;
      break;
    }
  }

  if(trch_idx_found)
  {
    /* Since a Transport Channel Index that is in use has been found,
     * return this index. No need to change any counters or initialize
     * transport channel ID.
     */
    return(trch_idx);
  }
  else  /* TrCH index not found, allocate new */
  {
    /* An index with the same transport channel ID is NOT in use.
     * Need to allocate a new index.
     */
    trch_idx = rrcllc_allocate_ul_dch_trch_idx();

    if(trch_idx >= UE_MAX_TRCH)
    {
      /* Failure to allocate a new TrCH Index */
      return(trch_idx);
    }
    else  /* A valid new index has been allocated */
    {
      /* Now we've got a new TrCH index - need to initialize TrCH
       * data in local, MAC and L1 structures.
       */
      /* Update the Local info */
      ordered_config_ptr->ul_dch_trch_info[trch_idx].dch_present = TRUE;
      ordered_config_ptr->ul_dch_trch_info[trch_idx].trch_id     = trch_id;

      /* Save Transport Channel ID in MAC Configuration Data */
      ordered_config_ptr->ul_cctrch.dch_info.dch_info[trch_idx].trch_id = trch_id;
      ordered_config_ptr->ul_cctrch.cctrch_type = DCH;

      /* MAC count */
      ordered_config_ptr->mac_ul_parms.cctrch_ptr->dch_info.ndchs ++;
      /* MAC TrCH count in TFCS */
      ordered_config_ptr->ul_tfcs.nchan++;
      /* L1 count */

      ordered_config_ptr->rrc_ul_cctrch_params.num_trch ++;
      
      /* set ul_tfcs_needed flag to true.  Later if common info is not preset,
       * UE needs to reject the message 
       */
      ul_tfcs_needed = TRUE;
      return(trch_idx);
    } /* A valid new index allocated */
  } /* Existing transport channel index couldn't be found, allocated new */
} /* rrcllc_get_ul_dch_trch_idx */

/*====================================================================
FUNCTION: rrcllc_clear_ul_rach_trch_idx()

DESCRIPTION:
  This function clears a UL RACH TrCH Index for later UE use.

DEPENDENCIES:
  None.

RETURN VALUE:
  ue_comdef_status_e_type -> SUCCESS indicates a UL RACH TrCH Index was cleared
                             FAILURE indicates a UL RACH TrCH Index was not cleared

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_clear_ul_rach_trch_idx(uint8 trch_idx)
{
  uecomdef_status_e_type status = SUCCESS;

  /*
  * Check to make sure that the UL TrCH Index is in range
  */
  if(trch_idx < UE_MAX_TRCH)
  {
    ordered_config_ptr->ul_rach_trch_idx_in_use[trch_idx] = FALSE;
  }
  else
  {
    /* Bad TrCH Index */
    MSG_MED("Cannot free an invalid UL RACH TrCH Index",0,0,0);
    status = FAILURE;
  }

  return status;
} /* end rrcllc_clear_ul_rach_trch_idx() */

/*====================================================================
FUNCTION: rrcllc_deallocate_ul_dch_trch_idx()

DESCRIPTION:
  This function clears a UL DCH TrCH Index for later UE use.

DEPENDENCIES:
  None.

RETURN VALUE:
  ue_comdef_status_e_type -> SUCCESS indicates a UL DCH TrCH Index was cleared
                             FAILURE indicates a UL DCH TrCH Index was not cleared

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_deallocate_ul_dch_trch_idx(uint8 trch_idx)
{
  uecomdef_status_e_type status = SUCCESS;

  /*
  * Check to make sure that the UL TrCH Index is in range
  */
  if(trch_idx < UE_MAX_TRCH)
  {
    ordered_config_ptr->ul_dch_trch_idx_in_use[trch_idx] = FALSE;
  }
  else
  {
    /* Bad TrCH Index */
    MSG_MED("Cannot free an invalid UL DCH TrCH Index",0,0,0);
    status = FAILURE;
  }

  return status;
} /* end rrcllc_deallocate_ul_dch_trch_idx() */


/*====================================================================
FUNCTION: rrcllc_check_ul_tfs_cnt()

DESCRIPTION:
  This function verifies that the number of Transport Format sets
  received in an OTA Message is within the UE Capabilities.

DEPENDENCIES:
  None.

RETURN VALUE:
  ue_comdef_status_e_type -> SUCCESS indicates # of UL TFS < UE Cap
                             FAILURE indicates # of UL TFS > UE Cap

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_check_ul_tfs_cnt(void)
{
  /* local variables */
  uint8  ix;
  uint32 tfs_cnt = 0;

  /* First get a count of all UL TFS into ordered config */
  for(ix = 0; ix < ordered_config_ptr->mac_ul_parms.tfcs_ptr->nchan; ix++)
  {
    tfs_cnt += ordered_config_ptr->mac_ul_parms.tfcs_ptr->tfs_info[ix].ntf;
  }

  /* Check to make sure it is less than UE Capability */
  if (tfs_cnt <= UE_MAX_TF)
  {
    MSG_LOW("UL TFS Cnt = %d", tfs_cnt,0,0);
    return SUCCESS;
  }
  else
  {
    WRRC_MSG1_ERROR("UL TFS Cnt %d > UE Cap of 32", tfs_cnt);
    return FAILURE;
  }
} /* end rrcllc_check_ul_tfs_cnt() */

/*====================================================================
FUNCTION: rrcllc_check_dl_tfs_cnt()

DESCRIPTION:
  This function verifies that the number of Transport Format sets
  received in an OTA Message is within the UE Capabilities.

DEPENDENCIES:
  None.

RETURN VALUE:
  ue_comdef_status_e_type -> SUCCESS indicates # of DL TFS < UE Cap
                             FAILURE indicates # of DL TFS > UE Cap

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_check_dl_tfs_cnt(void)
{
  /* local variables */
  uint8  ix;
  uint32 tfs_cnt = 0;

  /* First get a count of all DL TFS into ordered config */
  for(ix = 0; ix < ordered_config_ptr->l1_dl_cctrch_parms.num_trch; ix++)
  {
    tfs_cnt += ordered_config_ptr->l1_dl_cctrch_parms.trch_info_array[ix]->num_tf;
  }

  /* Check to make sure it is less than UE Capability */
  if (tfs_cnt <= UE_MAX_TF)
  {
    MSG_LOW("DL TFS Cnt = %d", tfs_cnt,0,0);
    return SUCCESS;
  }
  else
  {
    WRRC_MSG1_ERROR("DL TFS Cnt %d > UE Cap of 64", tfs_cnt);
    return FAILURE;
  }
} /* end rrcllc_check_dl_tfs_cnt() */



/*====================================================================
FUNCTION: rrcllc_rearrange_dflow_index()

DESCRIPTION:
  This function deletes any hoes in dl_dflow_index_in_use structure
  and the MAC DFLOW structure.

DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/

void rrcllc_rearrange_dflow_index
(
  void
)
{
  uint8  ix;
  uint8  count = 0;
  boolean tmp_dl_dlfow_index_in_use[UE_MAX_MAC_D_FLOW];
  mac_dflow_struct_type *tmp_mac_dflow_info_ptr;

  if (ordered_config_ptr->mac_dl_parms.num_dflow == 0)
  {
    WRRC_MSG0_MED("RRCHS:Num DFLOW 0");
    return;
  }
  tmp_mac_dflow_info_ptr = (mac_dflow_struct_type *)rrc_malloc(sizeof(mac_dflow_struct_type)*UE_MAX_MAC_D_FLOW);
  /* Put all the values in tmp structure. No there are no holes in tmp structure */
  for(ix = 0; ix < ordered_config_ptr->mac_dl_parms.num_dflow; ix ++)
  {
    /* Check if valid data */
    if((ordered_config_ptr->mac_dflow_info[ix].mac_dflow_id != INVALID_DFLOW_ID) &&
      (ordered_config_ptr->dl_dflow_index_in_use[ix] == TRUE))
    {
      WCDMA_MEMCPY(&tmp_dl_dlfow_index_in_use[count],
                   sizeof(tmp_dl_dlfow_index_in_use[ix]),
                   &ordered_config_ptr->dl_dflow_index_in_use[ix],
                   sizeof(tmp_dl_dlfow_index_in_use[ix]));

      WCDMA_MEMCPY(&(tmp_mac_dflow_info_ptr[count]), 
                   sizeof(mac_dflow_struct_type),
                   &ordered_config_ptr->mac_dflow_info[ix], 
                   sizeof(mac_dflow_struct_type));

      /* Now reinitialize the dflow index to indicate that it is avaliable */
      memset(&ordered_config_ptr->dl_dflow_index_in_use[ix], 0, sizeof(ordered_config_ptr->dl_dflow_index_in_use[ix]));

      memset(&ordered_config_ptr->mac_dflow_info[ix].mac_dflow_id, INVALID_DFLOW_ID, sizeof(ordered_config_ptr->mac_dflow_info[ix].mac_dflow_id));

      count++;

    }  /* If this index is not being used */
  } /* Outer for (...) */

  /* Now copy back the tmp structure into the original structure. */
  for(ix = 0; ix < count; ix ++)
  {
    WCDMA_MEMCPY(&ordered_config_ptr->dl_dflow_index_in_use[ix], 
                 sizeof(ordered_config_ptr->dl_dflow_index_in_use[ix]),
                 &tmp_dl_dlfow_index_in_use[ix], 
                 sizeof(ordered_config_ptr->dl_dflow_index_in_use[ix]));
    WCDMA_MEMCPY(&ordered_config_ptr->mac_dflow_info[ix], 
                 sizeof(ordered_config_ptr->mac_dflow_info[ix]),
                 &(tmp_mac_dflow_info_ptr[ix]), 
                 sizeof(ordered_config_ptr->mac_dflow_info[ix]));
  }
  rrc_free(tmp_mac_dflow_info_ptr);

}


/*============================================================================
FUNCTION: rrcllc_rearrange_queue_index()

DESCRIPTION:
  This function rearranges the queue for a particular DFLOW so that the hole
  which may have been created earlier is filled up

DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
void rrcllc_rearrange_queue_index
(
  void
)
{
  uint8  ix, iy;
  uint8  count;

  WRRC_MSG0_HIGH("RRCHS:Rearranging queue index");

  if (ordered_config_ptr->mac_dl_parms.num_dflow == 0)
  {
    WRRC_MSG0_HIGH("RRCHS:DFLOW 0");
    return;
  }
  /* Put all the values in tmp structure. No there are no holes in tmp structure */
  for(ix = 0; ix < ordered_config_ptr->mac_dl_parms.num_dflow; ix ++)
  {
    /* Check if valid data */
    if((ordered_config_ptr->mac_dflow_info[ix].mac_dflow_id != INVALID_DFLOW_ID) &&
      (ordered_config_ptr->dl_dflow_index_in_use[ix] == TRUE))
    {
      count = 0;
      for(iy = 0; iy < ordered_config_ptr->mac_dflow_info[ix].no_of_queues; iy ++)
      {
        if (ordered_config_ptr->mac_dflow_info[ix].queue_info[iy].queue_id != INVALID_QUEUE_ID)
        {
          WCDMA_MEMCPY(&tmp_queue_info[count], 
                       sizeof(mac_hs_queue_struct_type),
                       &ordered_config_ptr->mac_dflow_info[ix].queue_info[iy],
                       sizeof(mac_hs_queue_struct_type));
          /* Make existing one as INVALID */
          ordered_config_ptr->mac_dflow_info[ix].queue_info[iy].queue_id = INVALID_QUEUE_ID;
          count++;
        }
      }
      /* Now copy back the queue */
      if (count == 0)
      {
        WRRC_MSG0_HIGH("RRCHS:No copy back");
        continue;
      }
      else
      {
        for(iy = 0; iy < count; iy ++)
        {
          /* Copy back the queue in first locn */
          WCDMA_MEMCPY(&ordered_config_ptr->mac_dflow_info[ix].queue_info[iy],
                       sizeof(mac_hs_queue_struct_type), 
                       &tmp_queue_info[iy],
                       sizeof(mac_hs_queue_struct_type));
        }
        ordered_config_ptr->mac_dflow_info[ix].no_of_queues = count;
      }
      /* Holes removed for this DFLOW Id */
    }  /* If this index is being used */
  } /* End of for (...) */

}



/*====================================================================
FUNCTION: rrcllc_fill_holes_in_dl_dch_trch_idx()

DESCRIPTION:
  This function goes over the local transport channel index database
  for downlink and looks for any holes in the index allocation.
  If an index is found un-allocated, it is allocated and all
  transport channel data from a later index is copied to the
  local, MAC and L1 structures pointed to by the 1st index. The
  later downlink index is deleted and de-allocated.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void  rrcllc_fill_holes_in_dl_dch_trch_idx(void)
{

  uint8  ix;
  uint8  iy;
  uint8  new_idx;

  for(ix = 0; ix <(RRCLLC_DOWNLINK_TRCH_COUNT(ordered_config_ptr)); ix ++)
  {
    /* Move data to fill holes */
    if(ordered_config_ptr->dl_dch_trch_idx_in_use[ix] == FALSE)
    {
      /* Look for a index in use in the rest of list */
      for(iy = ix+1; iy < UE_MAX_TRCH; iy ++)
      {
        if(ordered_config_ptr->dl_dch_trch_idx_in_use[iy] == TRUE)
        {
          /* Copy all data for TrCH iy to a temp buffer */
          rrcllc_copy_dl_dch_trch_info_to_buffer(iy);

          /* Delete transport channel index iy - this also clears
           * all data associated with index iy
           */
          (void)rrcllc_delete_dl_dch_trch_index(iy);

          /* Allocate a new TrCH index */
          if( (new_idx = rrcllc_get_dl_dch_trch_idx(ordered_config_ptr->
                   mac_dl_parms.dch_info[iy]->trch_id)) < UE_MAX_TRCH)
          {
                                               

            /* Copy data from buffer to the new index just allocated. */
            rrcllc_copy_dl_dch_trch_info_from_buffer(new_idx);
          }
          else
          {
            WRRC_MSG1_ERROR("new_idx for DL %d exceeds UE_MAX_TRCH ",new_idx);
          }

          break;
        }
      }  /* for(.... ) */
    }  /* If this index is not being used */
  } /* Outer for (...) */
} /* rrcllc_fill_holes_in_dl_dch_trch_idx */

/*====================================================================
FUNCTION: rrcllc_fill_holes_in_ul_dch_trch_idx()

DESCRIPTION:
  This function goes over the local transport channel index database
  for uplink and looks for any holes in the index allocation.
  If an index is found un-allocated, it is allocated and all
  transport channel data from a later index is copied to the
  local, MAC and L1 structures pointed to by the 1st index. The
  later uplink index is deleted and de-allocated.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void  rrcllc_fill_holes_in_ul_dch_trch_idx(void)
{
  uint8  ix;
  uint8  iy;
  uint8  new_idx;

  for(ix = 0; ix < (RRCLLC_UPLINK_TRCH_COUNT(ordered_config_ptr)); ix ++)
  {
    /* Move data to fill holes */
    if(ordered_config_ptr->ul_dch_trch_idx_in_use[ix] == FALSE)
    {
      /* Look for a index in use in the rest of list */
      for(iy = ix+1; iy < UE_MAX_TRCH; iy ++)
      {
        if(ordered_config_ptr->ul_dch_trch_idx_in_use[iy] == TRUE)
        {

          /* Copy data from iy to the temporary buffer. */
          rrcllc_copy_ul_dch_trch_info_to_buffer(iy);

          /* Delete transport channel index iy - this also clears
           * all data associated with index iy
           */
          (void)rrcllc_delete_ul_dch_trch_index(iy);

          /* Allocate a new index - should be ix */
          if(( new_idx = rrcllc_get_ul_dch_trch_idx(ordered_config_ptr->
                mac_ul_parms.cctrch_ptr->dch_info.dch_info[iy].trch_id)
                ) < UE_MAX_TRCH)
          {

            /* Copy data to new index */
            rrcllc_copy_ul_dch_trch_info_from_buffer(new_idx);
          }
          else
          {
            WRRC_MSG1_ERROR("new_idx for UL %d exceeds UE_MAX_TRCH ",new_idx);
          }
          break;
        }
      }  /* for(.... ) */
    }  /* If this index is not being used */
  } /* Outer for (...) */
} /* rrcllc_fill_holes_in_ul_dch_trch_idx */

/*====================================================================
FUNCTION: rrcllc_check_if_rlc_mode_is_am()

DESCRIPTION:
 This function queries CC and finds out whether a given RB rb_id is of 
 AM RLC mode or not.

DEPENDENCIES:
  None.

RETURN VALUE:
  TRUE - RB rb_id is of AM RLC mode.
  FALSE - RB rb_id isn't of AM RLC mode.

SIDE EFFECTS:
  None.
====================================================================*/
boolean rrcllc_check_if_rlc_mode_is_am
(
  rrc_RB_Identity rb_id
)
{
  uint8 am_idx = 0;
  boolean rb_found = FALSE;
  
  for(am_idx = 0; am_idx < UE_MAX_AM_ENTITY; am_idx++)
  {
    if(current_config_ptr->am_config[am_idx].common_config.rb_id == rb_id)
    {
      rb_found = TRUE;
      break;
    }
  }
  return rb_found;
}
/*====================================================================
FUNCTION: rrcllc_check_if_rlc_mode_is_um()

DESCRIPTION:
 This function queries CC and finds out whether a given RB rb_id is of 
 UM RLC mode or not.

DEPENDENCIES:
  None.

RETURN VALUE:
  TRUE - RB rb_id is of UM RLC mode.
  FALSE - RB rb_id isn't of UM RLC mode.

SIDE EFFECTS:
  None.
====================================================================*/
boolean rrcllc_check_if_rlc_mode_is_um
(
  rrc_RB_Identity rb_id
)
{
  uint8 um_idx = 0;
  boolean rb_found = FALSE;
  
  for(um_idx = 0; um_idx < UE_MAX_UL_UM_CHANNEL; um_idx++)
  {
    if(current_config_ptr->rlc_ul_um_parms.chan_info[um_idx].rb_id == rb_id)
    {
      rb_found = TRUE;
      return rb_found;
    }
  }
  for(um_idx = 0; um_idx < UE_MAX_DL_UM_CHANNEL; um_idx++)
  {
    if(current_config_ptr->rlc_dl_um_parms.chan_info[um_idx].rb_id == rb_id)
    {
      rb_found = TRUE;
      return rb_found;
    }
  }	
  return rb_found;
}

/*====================================================================
FUNCTION: rrcllc_fill_rb_list_mapped_to_dch()

DESCRIPTION:
  This function fills the given RB rb_id in the global structure 
  rrc_rb_list_mapped_to_dch. It does so only if the given RB rb_id 
  isn't already present in rrc_rb_list_mapped_to_dch.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_fill_rb_list_mapped_to_dch
(
  rrc_RB_Identity rb_id
#ifdef FEATURE_MAC_I
 ,rrc_direction_enum_type  direction
#endif
)
{
  uint8 rb_idx = 0;
  boolean rb_found = FALSE;
#ifdef FEATURE_MAC_I
  uint8 am_entity_idx = 0;

/*To make sure that data rbs also get added to the array and re-establishment could be done for them aswell*/
  if((rrc_rb_list_mapped_to_dch.num_of_RBs < MAX_RB))
#else /* FEATURE_MAC_I */  	
  /*To make sure that no. of RBs don't exceed in array rrc_rb_mapped_to_dch*/
  if((rrc_rb_list_mapped_to_dch.num_of_RBs < MAX_RB) && (rb_id <= DCCH_DT_LOW_PRI_RADIO_BEARER_ID))
#endif /* FEATURE_MAC_I */
  {
    for(rb_idx = 0; rb_idx < rrc_rb_list_mapped_to_dch.num_of_RBs; rb_idx++)
    {
      if(rrc_rb_list_mapped_to_dch.rrc_rb_mapped_to_dch[rb_idx] == rb_id)
      {
        rb_found = TRUE;
        break; 
      }
    }
    /*Only if rb_id isn't already present in rrc_rb_mapped_to_dch*/	
    if(rb_found == FALSE)
    {
      if(rrc_rb_list_mapped_to_dch.num_of_RBs < MAX_RB)	
      {
        rrc_rb_list_mapped_to_dch.rrc_rb_mapped_to_dch[rrc_rb_list_mapped_to_dch.num_of_RBs] = rb_id;
      }
      rrc_rb_list_mapped_to_dch.num_of_RBs++;	  

#ifdef FEATURE_MAC_I
  /*Set the re-establish entity now only rather than in rrc_fill_rb_id_chan_req_from_rb_list_mapped_to_dch
    In case mapping is taken from hanging rb the above function may not be called */
      if((am_entity_idx =get_am_index(rb_id)) < UE_MAX_AM_ENTITY)
      {
        if(ordered_config_ptr->rlc_one_sided_reest[am_entity_idx])
        {
          if ((DL == direction) )
          {
            if(RLC_RE_ESTABLISH_UL == ordered_config_ptr->am_config[am_entity_idx].reestab_entity)
            {
              ordered_config_ptr->am_config[am_entity_idx].reestab_entity = RLC_RE_ESTABLISH_DL_UL;
              WRRC_MSG2_ERROR("One sided re-est TRUE for Rb ID %d  but reestab_entity is %d[0-DL&UL 1-UL 2-DL] ",
                rb_id,ordered_config_ptr->am_config[am_entity_idx].reestab_entity);
            }
            else
            {
              ordered_config_ptr->am_config[am_entity_idx].reestab_entity = RLC_RE_ESTABLISH_DL;
            }
          }
        }
        else
        {
          if(UL == direction)
          {
            /* Reset the re-establish entity here. Redesign code will set it later */
            ordered_config_ptr->am_config[am_entity_idx].reestab_entity = RLC_RE_ESTABLISH_NONE;
          }
          else
          {
            ordered_config_ptr->am_config[am_entity_idx].reestab_entity = RLC_RE_ESTABLISH_DL_UL;
          }
        }

        MSG_HIGH("MAC_I :Re-establish RB-ID %d at AM index %d in OC reestab_entity% d",rb_id,am_entity_idx,ordered_config_ptr->am_config[am_entity_idx].reestab_entity);
      }
#endif /*FEATURE_MAC_I*/	  
    }
  }
  else
  {
    WRRC_MSG2_ERROR("No. of RBs in rrc_rb_list_mapped_to_dch %d. And RB-Id to be added is %d",
            rrc_rb_list_mapped_to_dch.num_of_RBs,rb_id);
  }
}

/*====================================================================
FUNCTION: rrcllc_get_rb_for_rb_list_mapped_to_dch()

DESCRIPTION:
  This function calls rrcllc_fill_rb_list_mapped_to_dch() to fill the 
  given RB in rrc_rb_list_mapped_to_dch, if RLC PDU size for that RB has 
  changed. The third parameter is to notify whether RLC PDU size will be 
  checked for UL or DL.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
====================================================================*/
void rrcllc_get_rb_for_rb_list_mapped_to_dch
(
  tr_ch_id_type trch_id, 
  rrc_state_e_type next_state, 
  rrc_direction_enum_type direction
)
{
  uint8 trch_idx=0, rb_idx = 0;
  uint32 rlc_size_old = 0, rlc_size_new = 0;
  
  rrc_RB_Identity   rb_id = MAX_RB;
  
  /*We need to avoid size change detection through add/reconfiguration of DCH transport channels
    during DCH->FACH transition, otherwise re-est entity may get incorrectly set to DL_UL
    The below function is valid for only DCH->DCH state transitions*/
  if((rrc_get_state() == RRC_STATE_CELL_DCH) && (rrc_ordered_state == RRC_STATE_CELL_DCH))
  {
    /*If trch_id is given for UL*/
    if(direction == UL)
    {
      /*Loop thru all the UL DCH TrCH in OC*/
      for(trch_idx = 0; trch_idx < ordered_config_ptr->mac_ul_parms.cctrch_ptr->
              dch_info.ndchs;trch_idx++)
      {
        if(ordered_config_ptr->mac_ul_parms.cctrch_ptr->dch_info.dch_info[trch_idx].trch_id == trch_id)
        {
          /*UL DCH TrCH trch_id was found in OC. Now loop thru all the RBs mapped to trch_id TrCH*/
          for(rb_idx = 0;rb_idx < ordered_config_ptr->mac_ul_parms.cctrch_ptr->
                dch_info.dch_info[trch_idx].ndlchan; rb_idx++)
          {
            if(ordered_config_ptr->mac_ul_parms.cctrch_ptr->dch_info.dch_info[trch_idx].
                  dlchan_info[rb_idx].rlc_mode == UE_MODE_ACKNOWLEDGED_DATA)
            {
              rb_id = ordered_config_ptr->mac_ul_parms.cctrch_ptr->dch_info.dch_info[trch_idx].
                      dlchan_info[rb_idx].rb_id;
              rlc_size_old = rrcllc_get_am_rlc_size_for_rb(rb_id, direction);
              rlc_size_new = rrcllc_get_ul_ded_rlc_size(next_state, rb_id);
  			
              /*We need to add the RB in rb_list_mapped_to_dch only when RLC size has changed.*/			  
              if((rlc_size_old != RRCLLC_INVALID_RLC_SIZE) && (rlc_size_new != RRCLLC_INVALID_RLC_SIZE) 
                      && (rlc_size_old != rlc_size_new))
              {
                MSG_HIGH("Old & New UL RLC size for RB %d are %u and %u",rb_id, rlc_size_old, rlc_size_new);   
                rrcllc_fill_rb_list_mapped_to_dch(rb_id
#ifdef FEATURE_MAC_I
                                                                        ,direction
#endif /* FEATURE_MAC_I */
                                                                        );
              }
            }
          }
        }
      }
    }
    /*If trch_id is given for DL*/
    else if(direction == DL)
    {
      /*Loop thru all the DL DCH TrCH in OC*/
      for(trch_idx = 0; trch_idx < ordered_config_ptr->mac_dl_parms.num_dchs; trch_idx++)
      {
        if(ordered_config_ptr->mac_dl_parms.dch_info[trch_idx]->trch_id == trch_id)
        {
          /*DL DCH TrCH trch_id was found in OC. Now loop thru all the RBs mapped to trch_id TrCH*/      
          for(rb_idx = 0;rb_idx < ordered_config_ptr->mac_dl_parms.dch_info[trch_idx]->ndlchan; rb_idx++)
          {
            if((ordered_config_ptr->mac_dl_parms.dch_info[trch_idx]->dlchan_info[rb_idx].rlc_mode == 
                    UE_MODE_ACKNOWLEDGED_DATA)
                && (rrcllc_get_am_dl_rlc_size_ota(ordered_config_ptr->mac_dl_parms.dch_info[trch_idx]->dlchan_info[rb_idx].rb_id)
                    == RRCLLC_INVALID_RLC_SIZE)
                    )
            {
              rb_id =  ordered_config_ptr->mac_dl_parms.dch_info[trch_idx]->dlchan_info[rb_idx].rb_id;  
              rlc_size_old = rrcllc_get_am_rlc_size_for_rb(rb_id, direction);
              rlc_size_new = rrcllc_get_dl_ded_rlc_size(next_state, rb_id);
    
              /*We need to add the RB in rb_list_mapped_to_dch only when RLC size has changed.*/		  
              if((rlc_size_old != RRCLLC_INVALID_RLC_SIZE) && (rlc_size_new != RRCLLC_INVALID_RLC_SIZE) 
                      && (rlc_size_old != rlc_size_new))
              {
                MSG_HIGH("Old & New DL RLC size for RB %d are %u and %u",rb_id, rlc_size_old, rlc_size_new);			
                rrcllc_fill_rb_list_mapped_to_dch(rb_id
#ifdef FEATURE_MAC_I
                                                                        ,direction
#endif /* FEATURE_MAC_I */
                                                                        );
              }
            }
          }
        }
      }
    }
  }
}


/*====================================================================
FUNCTION: rrcllc_update_lbt_mode_for_dchs()

DESCRIPTION:
  This function updates the Loopback Test mode in CCTrCH Info for
  L1 in the Ordered Config.
  It updates the mode for those transport channels that have a DTCH
  logical channel mapped.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_update_lbt_mode_for_dchs(
  l1_loop_back_mode_type_enum_type loopback_test_mode
#ifdef FEATURE_DUMMY_SIGNALING
  #error code not present
#endif
)
{
  uint32 dch_idx;
  uint32 dlch_count;

  /* Check for all Transport Channels */
  for( dch_idx = 0;
       dch_idx < ordered_config_ptr->l1_dl_cctrch_parms.num_trch;
       dch_idx ++
      )
  {
    if(ordered_config_ptr->l1_dl_cctrch_parms.trch_info_array[dch_idx]->
        ref_type == L1_DL_TRCH_DCH_TYPE)
    {
      for( dlch_count = 0;
           dlch_count < ordered_config_ptr->mac_dl_parms.dch_info[dch_idx]->ndlchan;
           dlch_count ++)
      {

        switch(loopback_test_mode)
        {
          case L1_LOOPBACK_MODE_1:
            ordered_config_ptr->mac_dl_parms.dch_info[dch_idx]->loopback_test_mode
              = MAC_LOOPBACK_MODE_1;
            break;
          case L1_LOOPBACK_MODE_2:
            ordered_config_ptr->mac_dl_parms.dch_info[dch_idx]->loopback_test_mode
              = MAC_LOOPBACK_MODE_2;
            break;
          default:
            ordered_config_ptr->mac_dl_parms.dch_info[dch_idx]->loopback_test_mode
              = MAC_LOOPBACK_NA;
            break;
        }

        if(ordered_config_ptr->mac_dl_parms.dch_info[dch_idx]->
            dlchan_info[dlch_count].chan_type
              == UE_LOGCHAN_DTCH)
        {
          /* This DCH is mapped to a DTCH - yes, update the mode */
          ordered_config_ptr->l1_dl_cctrch_parms.trch_info_array[dch_idx]->
            loopback_mode = loopback_test_mode;

          /* If loopback mode 1 is chosen, determine whether to indicate LOOPBACK_MODE_1 with
           * TM or NON_TM bearers to L1. IF TM RBs are setup for LB, L1 passes up the blocks
           * to RLC regardless of CRC.  Else for non-tm, L1 will discard blocks that don't pass CRC
           */
          if (loopback_test_mode == L1_LOOPBACK_MODE_1) 
          {
            if (ordered_config_ptr->mac_dl_parms.dch_info[dch_idx]->
            dlchan_info[dlch_count].rlc_mode == UE_MODE_TRANSPARENT) 
            {
              WRRC_MSG1_HIGH("Setting L1 loopback mode to L1_LOOPBACK_MODE_1 for TM RB idx:%d",dch_idx);
              ordered_config_ptr->l1_dl_cctrch_parms.trch_info_array[dch_idx]->non_tm_rb = FALSE;
            }
            else
            {
              WRRC_MSG1_HIGH("Setting L1 loopback mode to L1_LOOPBACK_MODE_1 for Non-TM RB idx: %d",dch_idx);
              ordered_config_ptr->l1_dl_cctrch_parms.trch_info_array[dch_idx]->non_tm_rb = TRUE;
            }
          }
          /* Move to the next transport channel */
          break;
        } /* Is Logical Channel type a DTCH ? */
      }  /* Loop for all available Dedicated Logical channels mapped on this DCH */
    } /* This TrCH is a DCH */
  } /* Loop for all available DCHs */

  if(loopback_test_mode == L1_LOOPBACK_MODE_2)
  {
    /* Additionally, for loopback mode 2, zero out the CRC length
     * for all user plane UL TrCHs
     */
    for(dch_idx = 0;
        dch_idx < ordered_config_ptr->mac_ul_parms.cctrch_ptr->dch_info.ndchs;
        dch_idx ++)
    {
      for(dlch_count = 0;
          dlch_count < ordered_config_ptr->mac_ul_parms.
                       cctrch_ptr->dch_info.dch_info[dch_idx].ndlchan;
          dlch_count ++)
      {
        if(ordered_config_ptr->mac_ul_parms.cctrch_ptr->dch_info.
            dch_info[dch_idx].dlchan_info[dlch_count].chan_type
           == UE_LOGCHAN_DTCH)
        {
#ifndef FEATURE_TM_LB
          ordered_config_ptr->l1_ul_cctrch_parms.
            semi_static_parms_ptr[dch_idx]->crc = L1_UL_CRC_0_BITS;
#endif
          ordered_config_ptr->reconfig_needed.uplink_l1 = TRUE;
          break;
        }
      } /* For all dedicated logical channels on this DCH */
    } /* For all DCHs */
  } /* If this is Loopback mode 2 */

#ifdef FEATURE_DUMMY_SIGNALING
    #error code not present
#endif

  switch(loopback_test_mode)
  {
    case L1_LOOPBACK_MODE_1:
      ordered_config_ptr->mac_ul_parms.cctrch_ptr->dch_info.loopback_test_mode
        = MAC_LOOPBACK_MODE_1;
      break;
    case L1_LOOPBACK_MODE_2:
      ordered_config_ptr->mac_ul_parms.cctrch_ptr->dch_info.loopback_test_mode
        = MAC_LOOPBACK_MODE_2;
      break;
    default:
      ordered_config_ptr->mac_ul_parms.cctrch_ptr->dch_info.loopback_test_mode
        = MAC_LOOPBACK_NA;
      break;
  }

  ordered_config_ptr->reconfig_needed.uplink_mac = TRUE;

  /* Till a solution is deviced to fix the lower layer out-of-sync issue
   * with activation time, copy the Ordered Config to Current Config
   * Note: For LBT always keep CC and OC in sync since Physical channels
   * are not Dropped and Added for LBT.
   */
  rrcllc_copy_oc_to_cc();

  return;
} /* rrcllc_update_lbt_mode_for_dchs */

/*====================================================================
FUNCTION: rrcllc_update_lbt_mode_for_fachs()

DESCRIPTION:
  This function updates the Loopback Test mode in CCTrCH Info for
  L1 in the Ordered Config.
  It updates the mode for those transport channels that have a DTCH
  logical channel mapped.

DEPENDENCIES:
  This function would update the test mode only for LOOPBACK mode 1.
  Loopback mode 2 is not applicable for FACH since constnat delay
  can't be applied in RACH.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_update_lbt_mode_for_fachs(
  l1_loop_back_mode_type_enum_type loopback_test_mode
)
{
  uint32 fach_idx;
  uint32 dlch_count;

  /* Check for all Transport Channels */
  for( fach_idx = 0;
       fach_idx < ordered_config_ptr->l1_dl_cctrch_parms.num_trch;
       fach_idx ++
      )
  {
    if(ordered_config_ptr->l1_dl_cctrch_parms.trch_info_array[fach_idx]->
        ref_type == L1_DL_TRCH_FACH_TYPE)
    {
      for( dlch_count = 0;
           dlch_count < ordered_config_ptr->mac_dl_parms.fach_info[fach_idx]->ndlchan;
           dlch_count ++)
      {

        if(ordered_config_ptr->mac_dl_parms.fach_info[fach_idx]->
            dlchan_info[dlch_count].chan_type
              == UE_LOGCHAN_DTCH)
        {
          /* This FACH is mapped to a DTCH - yes, update the mode */
          ordered_config_ptr->l1_dl_cctrch_parms.trch_info_array[fach_idx]->
            loopback_mode = loopback_test_mode;

          /* If loopback mode 1 is chosen, determine whether to indicate LOOPBACK_MODE_1 with
           * TM or NON_TM bearers to L1. IF TM RBs are setup for LB, L1 passes up the blocks
           * to RLC regardless of CRC.  Else for non-tm, L1 will discard blocks that don't pass CRC
           */
          if (loopback_test_mode == L1_LOOPBACK_MODE_1) 
          {
            if (ordered_config_ptr->mac_dl_parms.fach_info[fach_idx]->
                dlchan_info[dlch_count].rlc_mode == UE_MODE_TRANSPARENT) 
            {
              WRRC_MSG1_HIGH("Setting L1 loopback mode to L1_LOOPBACK_MODE_1 for TM RB idx:%d",fach_idx);
              ordered_config_ptr->l1_dl_cctrch_parms.trch_info_array[fach_idx]->non_tm_rb = FALSE;
            }
            else
            {
              WRRC_MSG1_HIGH("Setting L1 loopback mode to L1_LOOPBACK_MODE_1 for non-TM RB idx:%d",fach_idx);
              ordered_config_ptr->l1_dl_cctrch_parms.trch_info_array[fach_idx]->non_tm_rb = TRUE;
            }
          }
          
          /* Move to the next transport channel */
          break;
        } /* Is Logical Channel type a DTCH ? */
      }  /* Loop for all available Dedicated Logical channels mapped on this FACH */
    } /* This TrCH is a FACH*/
  } /* Loop for all available DCHs */

  switch(loopback_test_mode)
  {
    case L1_LOOPBACK_MODE_1:
      ordered_config_ptr->mac_ul_parms.cctrch_ptr->rach_info.loopback_test_mode
        = MAC_LOOPBACK_MODE_1;
      break;
    case L1_LOOPBACK_MODE_2:
      ordered_config_ptr->mac_ul_parms.cctrch_ptr->rach_info.loopback_test_mode
        = MAC_LOOPBACK_NA;
      break;
    default:
      ordered_config_ptr->mac_ul_parms.cctrch_ptr->dch_info.loopback_test_mode
        = MAC_LOOPBACK_NA;
      break;
  }

  ordered_config_ptr->reconfig_needed.uplink_mac = TRUE;

  /* Till a solution is deviced to fix the lower layer out-of-sync issue
   * with activation time, copy the Ordered Config to Current Config
   * Note: For LBT always keep CC and OC in sync since Physical channels
   * are not Dropped and Added for LBT.
   */
  rrcllc_copy_oc_to_cc();

  return;
} /* rrcllc_update_lbt_mode_for_dchs */


/*====================================================================
FUNCTION: rrcllc_init_dl_common_info()
DESCRIPTION:
  This function is responsible for initializing DL Common Info
  for DPCH. The only field that needs to be init is the Timing
  Initialization type. It is set to "Timing Maintained".
DEPENDENCIES:
  None
RETURN VALUE:
  None
SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_dl_common_info(ordered_config_type *config_ptr)
{
  /* Initialize to Timing Maintained */
  config_ptr->l1_dl_chan_parms.dl_common.dpch_common.timing_ind = L1_TIMING_IND_MAINTAIN;
}
/*====================================================================
FUNCTION: rrcllc_timing_init_in_progress()
DESCRIPTION:
  This function returns true if timing init HHO is ongoing.
DEPENDENCIES:
  None
RETURN VALUE:
  None
SIDE EFFECTS:
  None.
====================================================================*/
boolean rrcllc_timing_init_in_progress(void)
{
  ordered_config_type *config_ptr = NULL;

  if(config_ptr_in_use == ORDERED_CONFIG)
  {
    config_ptr = ordered_config_ptr;
  }
  else
  {
    config_ptr = current_config_ptr;
  }

  if (config_ptr->l1_dl_chan_parms.dl_common.dpch_common.timing_ind == L1_TIMING_IND_INIT) 
  {
    return TRUE;
  }
  else
  { 
    return FALSE;
  }
}

/*====================================================================
FUNCTION: rrcllc_init_mac_dl_ptrs()

DESCRIPTION:
  This function is responsible for initializing pointers to FACH, DCH
  and DSCH info in MAC DL Parameter structure to the storage
  space for FACH, DCH and DSCH info respectively.
  NOTE: Once mac_dl_config_type is changed to have the data
  structures in place of pointers, this function will not be
  needed anymore.

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
void  rrcllc_init_mac_dl_ptrs(ordered_config_type *config_ptr)
{
  uint8  ix;
  for(ix = 0 ; ix < UE_MAX_TRCH; ix++)
  {
    /* MAC FACH, DCH, and DSCH data pointers */
    config_ptr->mac_dl_parms.fach_info[ix] = &config_ptr->fach_info[ix];
    config_ptr->mac_dl_parms.dch_info[ix]  = &config_ptr->dl_dch_info[ix];
    config_ptr->mac_dl_parms.dsch_info[ix] = &config_ptr->dsch_info[ix];
  }

  MSG_MED("RRCHS:Init MAC HS Ptr",0,0,0);
  rrcllc_init_hsdpa_mac_ptr(config_ptr);

}

/*====================================================================
FUNCTION: rrcllc_init_mac_ul_ptrs()

DESCRIPTION:
  This function is responsible for initializing pointers to
  TFCS and CCTrCH configuration in MAC UL Parameter structure to the
  TFCS and CCTrCH Config info in ordered_config_type respectively.
  NOTE: Once mac_ul_config_type is changed to have the data
  structures in place of pointers, this function will not be
  needed anymore.

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
void  rrcllc_init_mac_ul_ptrs(ordered_config_type *config_ptr)
{
  /* Save the address of the MAC Uplink TFCS info */
  config_ptr->mac_ul_parms.tfcs_ptr = &config_ptr->ul_tfcs;

  /* Save the address of the MAC Uplink CCTrCH info */
  config_ptr->mac_ul_parms.cctrch_ptr = &config_ptr->ul_cctrch;

  config_ptr->mac_ul_parms.mac_e_config_ptr = &config_ptr->mac_e_config;

#ifdef FEATURE_WCDMA_DC_HSUPA
      
  config_ptr->mac_ul_parms.mac_sec_eul_config_ptr = &config_ptr->mac_sec_eul_config;

#endif


}

/*====================================================================
FUNCTION: rrcllc_init_l1_dl_ptrs()

DESCRIPTION:
  This function is responsible for initializing pointers to
  transport channel info (for each TrCH) in l1_dl_cctrch_parms
  to dedicated or common TrCH info in ordered config type
  depending on the passed RRC state. It also initializes the
  pointers to Transport format info inside dedicated or common TrCH info
  to dedicated or common transport format info respectively.
  This also initializes pointers to CTFC info in l1_dl_ctfc_parms
  to ctfc_info in ordered_config_type for all CTFCs. The pointers
  to TFI table inside ctfc_info are initialized to TFI table inside
  the local dl_ctfc in ordered_config_type.

  NOTE: Once l1_dl_cctrch_parms, l1_dl_trch_info_struct_type,
  l1_dl_ctfc_parms and l1_dl_ctfc_entry_info_struct_type are changed
  to have the data structures in place of pointers, this function will
  not be needed anymore.

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
void  rrcllc_init_l1_dl_ptrs
(
  ordered_config_type *config_ptr
)
{
  uint8  ix;
  uint8  iy;
  uint16  num_tfc;

  for(ix = 0 ; ix < L1_MAX_TRCH; ix++)
  {
    /* In Cell_DCH state, initialize Transport Channel Info array
     * to point to Dedicated Transport Channel Info array elements.
     */
    config_ptr->l1_dl_cctrch_parms.trch_info_array[ix] =
      &config_ptr->dl_trch_info[ix];

    /* Init the DL Transport Format data pointers, indicate common at first */
    for (iy = 0; iy < L1_MAX_TF_PER_TRCH; iy++)
    {
      config_ptr->dl_trch_info[ix].tf_info_array[iy] = &config_ptr->dl_tf_info[ix][iy];
    } /* end TF initialization */
  }

  for(ix = 0 ; ix < L1_MAX_TRCH; ix++)
  {
    /* In Cell_DCH state, initialize Transport Channel Info array
     * to point to Dedicated Transport Channel Info array elements.
     */
    config_ptr->l1_dl_cctrch_parms_for_sccpch_with_ctch.trch_info_array[ix] =
      &config_ptr->dl_trch_info_for_sccpch_with_ctch[ix];

    /* Init the DL Transport Format data pointers, indicate common at first */
    for (iy = 0; iy < L1_MAX_TF_PER_TRCH; iy++)
    {
      config_ptr->dl_trch_info_for_sccpch_with_ctch[ix].tf_info_array[iy] =
        &config_ptr->dl_tf_info_for_sccpch_with_ctch[ix][iy];
    } /* end TF initialization */
  }
  for(num_tfc = 0; num_tfc < UE_MAX_TFC; num_tfc++)
  {
    /* Init the DL Transport Format Combination data pointers */
    config_ptr->l1_dl_ctfc_parms_for_sccpch_with_ctch.ctfc_entry_array[num_tfc] =
      &config_ptr->ctfc_info_for_sccpch_with_ctch[num_tfc];

    /* Initialize the pointer to tfi_table in CTFC Info */
    config_ptr->ctfc_info_for_sccpch_with_ctch[num_tfc].tfi_table = config_ptr->dl_ctfc_for_sccpch_with_ctch.ctfc_entry_data[num_tfc].tfi_table;

  }

  for(num_tfc = 0; num_tfc < UE_MAX_TFC; num_tfc++)
  {
    /* Init the DL Transport Format Combination data pointers */
    config_ptr->l1_dl_ctfc_parms.ctfc_entry_array[num_tfc] = &config_ptr->ctfc_info[num_tfc];

    /* Initialize the pointer to tfi_table in CTFC Info */
    config_ptr->ctfc_info[num_tfc].tfi_table = config_ptr->dl_ctfc.ctfc_entry_data[num_tfc].tfi_table;

  }

  for (ix = 0 ; ix < L1_CM_MAX_TGP_SEQ_COUNT; ix++)
  {
    config_ptr->cm_info.tgp_seq_info[ix] = &(config_ptr->tgp_seq_info[ix]);
  }

  /* Initialize l1 Config ptr of Compressed Mode to Compressed Mode Info */
  config_ptr->l1_dl_chan_parms.dl_common.comp_mode_info = &(config_ptr->cm_info);
}  /* rrcllc_init_l1_dl_ptrs */

/*====================================================================
FUNCTION: rrcllc_init_l1_ul_ptrs()

DESCRIPTION:
  This function is responsible for initializing pointers to
  semi static and gain factor info in L1 UL CCTrCH Parameter structure
  to the info stored locally in ordered_config_type. It also
  initializes pointers to ASC Info in L1 UL Channel Parameters.

  NOTE: Once l1_ul_cctrch_parms and l1_ul_chan_parms are changed
  to have the data structures in place of pointers, this function will
  not be needed anymore.

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
void  rrcllc_init_l1_ul_ptrs(ordered_config_type *config_ptr)
{
  uint8  ix;

  for(ix = 0 ; ix < L1_UL_TRCH_MAX ; ix++)
  {

    /* L1 UL Semi static parameter data pointers */
    config_ptr->l1_ul_cctrch_parms.semi_static_parms_ptr[ix] =
      &config_ptr->rrc_ul_cctrch_params.semi_static_parms[ix];
  }
  for(ix = 0; ix < L1_UL_TFC_MAX; ix++)
  {

    /* Init the UL Gain Factors that are TFC specific */
    config_ptr->l1_ul_cctrch_parms.gain_factor_parms_ptr[ix] =
      &config_ptr->rrc_ul_cctrch_params.gain_factor_parms[ix];

  } /* end TFC initialization */

  /* Init the ASC data pointers */
  for(ix = 0; ix < MAX_ASC; ix ++)
  {
    config_ptr->l1_ul_chan_parms.prach_cfg.asc_cfg.asc_info_ptr[ix] =
      &config_ptr->asc_info[ix];
  } /* end ASC initialization */
} /* rrcllc_init_l1_ul_ptrs */

/*====================================================================
FUNCTION: rrcllc_init_rlc_ptrs()

DESCRIPTION:
  This function is responsible for initializing pointers to
  AM Info in RLC AM parameter structure to the AM Configuration
  stored locally in ordered_config_type.

  NOTE: Once rlc_am_config_req_type is changed to have the data
  structures in place of pointers, this function will not be
  needed anymore.

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
void  rrcllc_init_rlc_ptrs(ordered_config_type *config_ptr)
{
  uint8  ix;
  /* Init the local AM data pointers, DL & UL channel counts */
  for(ix = 0; ix < UE_MAX_AM_ENTITY; ix++)
  {
    config_ptr->rlc_am_parms.am_info[ix] = &config_ptr->am_config[ix];
  }
}

/*====================================================================
FUNCTION: rrcllc_copy_bch_info_from_cc_to_oc()

DESCRIPTION:
  This function is responsible for copying all BCH related info from
  Current Config to Ordered Config.

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
void  rrcllc_copy_bch_info_from_cc_to_oc(void)
{
  uint8  bch_count;

  /* Copy the BCH count from Current to Ordered Config */
  ordered_config_ptr->mac_dl_parms.num_bchs =
    current_config_ptr->mac_dl_parms.num_bchs;

  /* Copy BCH info for all active BCHs from current to ordered config */
  for(bch_count=0;
      bch_count < ordered_config_ptr->mac_dl_parms.num_bchs;
      bch_count++)
  {
    ordered_config_ptr->mac_dl_parms.bch_info->bcch_id =
     current_config_ptr->mac_dl_parms.bch_info->bcch_id;
    ordered_config_ptr->mac_dl_parms.bch_info->cctrch_id =
     current_config_ptr->mac_dl_parms.bch_info->cctrch_id;
  }
}  /* rrcllc_copy_bch_info_from_cc_to_oc */

/*====================================================================
FUNCTION: rrcllc_copy_ccch_info_from_cc_to_oc()

DESCRIPTION:
  This function is responsible for copying all CCCH related info from
  Current Config to Ordered Config.

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_copy_ccch_info_from_cc_to_oc(void)
{
  uint32  count, num_fach;
  /* Copy CCCH info in Uplink and Downlink */

  if(ordered_config_ptr->mac_dl_parms.num_fachs == 0)
  {
    WRRC_MSG0_HIGH("Number of FACHes in OC zero");
    return;
  }
  if(current_config_ptr->mac_dl_parms.num_fachs == 0)
  {
    WRRC_MSG0_HIGH("Number of FACHes in CC zero");
    return;
  }

  /* Update Downlink first */
  /* Copy for all FACHes in the Ordered Config. Since there
   * is atleast one FACH in Current Config, copy from the data
   * for the first FACH.
   */
  num_fach = ordered_config_ptr->mac_dl_parms.num_fachs;
  for(count = 0; count < num_fach; count ++)
  {
    ordered_config_ptr->mac_dl_parms.fach_info[count]->ccch_enable =
      current_config_ptr->mac_dl_parms.fach_info[0]->ccch_enable;
    ordered_config_ptr->mac_dl_parms.fach_info[count]->ccch_id =
      current_config_ptr->mac_dl_parms.fach_info[0]->ccch_id;
  }

  /* Update Uplink next */
  ordered_config_ptr->mac_ul_parms.cctrch_ptr->rach_info.ccch_asc =
    current_config_ptr->mac_ul_parms.cctrch_ptr->rach_info.ccch_asc;

  ordered_config_ptr->mac_ul_parms.cctrch_ptr->rach_info.ccch_enable =
    current_config_ptr->mac_ul_parms.cctrch_ptr->rach_info.ccch_enable;

  ordered_config_ptr->mac_ul_parms.cctrch_ptr->rach_info.ccch_id =
    current_config_ptr->mac_ul_parms.cctrch_ptr->rach_info.ccch_id;

  /* Since RLC info is not kept track of, no point of copying it */
} /* rrcllc_copy_ccch_info_from_cc_to_oc */



/*====================================================================
FUNCTION: rrcllc_update_oc_in_pch_for_pcch_reconfig()

DESCRIPTION:
  This function is responsible for updating the Ordered Config when
  in cell_pch or URA pch state.

DEPENDENCIES:
  For a PCH add/reconfig operation, all SIBs should be read before
  calling this function.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type  rrcllc_update_oc_in_pch_for_pcch_reconfig
(
  ordered_config_type *config_ptr,
  rrc_state_e_type state
)
{
  uecomdef_status_e_type  oc_status = SUCCESS;

  /* Set the Activation Time to "Now" */
  rrcllc_init_activation_time(config_ptr);

  WRRC_MSG0_HIGH("Init OC before updating with SIB");

  /* Initialize PCH Info */
  rrcllc_init_pch_info(config_ptr);
  /* Do not delete RB Mapping Info in any other RRC state */
  rrcllc_init_fach_info(config_ptr, FALSE);
  /* Initialize L1 SCCPCH Channel Info */
  rrcllc_init_l1_sccpch_chan_info(config_ptr);
  /* Initialize L1 Downlink CCTrCH Info that includes Transport Format Set */
  rrcllc_init_dl_cctrch_info(config_ptr);
  /* Initialize Downlink TFCS */
  rrcllc_init_dl_ctfcs(config_ptr);
  rrcllc_init_dl_ctfcs_for_sccpch_with_ctch(config_ptr);

  oc_status = rrcllc_copy_sib_to_oc(state);

  if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status == RRCLLC_CTCH_ON_DIF_SCCPCH )
  {
    (void)rrcllc_copy_sib_to_oc_for_sccpch_with_ctch(state);
  }
  return oc_status;

}

/*====================================================================
FUNCTION: rrcllc_update_oc_in_disconnected()

DESCRIPTION:
  This function is responsible for updating the Ordered Config when
  in Disconnected state. It is based on the PCH and BCH operation type
  that is passed as a parameter.
  It starts with copying Current Config to Ordered Config and then
  updating Ordered Config data. For a PCH add/reconfig, OC is updated
  with SIBs and in the event of a failure, the Ordered Config data is
  reverted back to Current Config data.

DEPENDENCIES:
  For a PCH add/reconfig operation, all SIBs should be read before
  calling this function.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type  rrcllc_update_oc_in_disconnected
(
  ordered_config_type *config_ptr,
  rrcllc_bch_op_e_type  bch_op,
  rrcllc_nbch_op_e_type  nbch_op,
  rrcllc_pch_op_e_type  pch_op
)
{
  uecomdef_status_e_type  oc_status = SUCCESS;

  /* Set the Activation Time to "Now" */
  rrcllc_init_activation_time(config_ptr);

  /* Always process the drop of BCH and NBCH before processing
     the addition.  This is to ensure that num_bch always remain
     at 0 or 1.  
   */
  if(bch_op == RRCLLC_DROP_BCH)
  {
    /* Set number of BCHs in MAC correctly */
    if(config_ptr->mac_dl_parms.num_bchs)
    {
      config_ptr->mac_dl_parms.num_bchs --;
    }

    /* Update number of transport channels on PCCPCH in L1 CCTrCH Parameters */
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch.num_trch = 0;

    /* Ordered Config NOT set */
    ordered_config.set_status = OC_NOT_SET;
  }
  else if(nbch_op == RRCLLC_DROP_NBCH)
  {
    /* Set number of BCHs in MAC correctly */
    if(config_ptr->mac_dl_parms.num_bchs)
    {
      config_ptr->mac_dl_parms.num_bchs --;
    }

    /* Update number of transport channels on PCCPCH in L1 CCTrCH Parameters */
    rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch.num_trch = 0;

    /* Ordered Config NOT set */
    ordered_config.set_status = OC_NOT_SET;
  }

  if(bch_op == RRCLLC_ADD_BCH)
  {
    /* Set number of BCHs in MAC correctly */
    if(config_ptr->mac_dl_parms.num_bchs)
    {
      WRRC_MSG1_ERROR("Number of BCHS : %d not Zero",config_ptr->mac_dl_parms.num_bchs);
    }
    else
    {
      config_ptr->mac_dl_parms.num_bchs ++;
    }

    /* Update number of transport channels on PCCPCH in L1 CCTrCH Parameters */
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch.num_trch = 1;

    /* Ordered Config NOT set */
    ordered_config.set_status = OC_NOT_SET;
  }
  else if(nbch_op == RRCLLC_ADD_NBCH)
  {
    /* Set number of BCHs in MAC correctly */
    if(config_ptr->mac_dl_parms.num_bchs)
    {
      WRRC_MSG1_ERROR("Number of BCHS : %d not Zero",config_ptr->mac_dl_parms.num_bchs);
    }
    else
    {
      config_ptr->mac_dl_parms.num_bchs ++;
    }

    /* Update number of transport channels on PCCPCH in L1 CCTrCH Parameters */
    rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch.num_trch = 1;

    /* Ordered Config NOT set */
    ordered_config.set_status = OC_NOT_SET;
  }


  if((pch_op == RRCLLC_ADD_PCH) || (pch_op == RRCLLC_RECONFIG_PCH))
  {
    WRRC_MSG0_HIGH("Init OC before updating with SIB");

    /* Initialize PCH Info */
    rrcllc_init_pch_info(config_ptr);
    /* Do not delete RB Mapping Info in any other RRC state */
    rrcllc_init_fach_info(config_ptr, FALSE);
    /* Initialize L1 SCCPCH Channel Info */
    rrcllc_init_l1_sccpch_chan_info(config_ptr);
    /* Initialize L1 Downlink CCTrCH Info that includes Transport Format Set */
    rrcllc_init_dl_cctrch_info(config_ptr);
    /* Initialize Downlink TFCS */
    rrcllc_init_dl_ctfcs(config_ptr);
    rrcllc_init_dl_ctfcs_for_sccpch_with_ctch(config_ptr);

    oc_status = rrcllc_copy_sib_to_oc(RRC_STATE_DISCONNECTED);


    if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status == RRCLLC_CTCH_ON_DIF_SCCPCH )
    {
      (void)rrcllc_copy_sib_to_oc_for_sccpch_with_ctch(RRC_STATE_DISCONNECTED);
    }

    /* In Idle Disconnected state, Ordered Config is never set */
    ordered_config.set_status = OC_NOT_SET;
  }

  /* Return the Ordered Config status and let the calling fuinction handle it */
  return(oc_status);

}  /* rrcllc_update_oc_in_disconnected */

/*====================================================================
FUNCTION: rrcllc_update_oc_in_fach_with_sibs()

DESCRIPTION:
  This function is responsible for updating the Ordered Config when
  in Disconnected state. It is based on the PCH and BCH operation type
  that is passed as a parameter.
  It starts with copying Current Config to Ordered Config and then
  updating Ordered Config data. For a PCH add/reconfig, OC is updated
  with SIBs and in the event of a failure, the Ordered Config data is
  reverted back to Current Config data.

DEPENDENCIES:
  For a PCH add/reconfig operation, all SIBs should be read before
  calling this function.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type  rrcllc_update_oc_in_fach_with_sibs
(
  ordered_config_type *config_ptr
)
{
  uecomdef_status_e_type  oc_status = SUCCESS;


  /* Set the Activation Time to "Now" */
  rrcllc_init_activation_time(config_ptr);

  WRRC_MSG0_HIGH("Init OC before updating with SIB");

  /* Initialize PCH Info */
  rrcllc_init_pch_info(config_ptr);
  /* Do not delete RB Mapping Info in any other RRC state */
  rrcllc_init_fach_info(config_ptr, FALSE);
  /* Initialize L1 SCCPCH Channel Info */
  rrcllc_init_l1_sccpch_chan_info(config_ptr);
  /* Initialize L1 Downlink CCTrCH Info that includes Transport Format Set */
  rrcllc_init_dl_cctrch_info(config_ptr);
  /* Initialize Downlink TFCS */
  rrcllc_init_dl_ctfcs(config_ptr);

#ifdef FEATURE_WCDMA_HS_FACH
  if(rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP &&
     rrcllc_cmd_under_process.chan_config.chan_config_reason ==RRCLLC_CHAN_CFG_REASON_RECONFIG_PCH_FACH &&
     rrcenhstate_camped_cell_supports_e_fach() == TRUE &&
     rrcllc_get_hs_status_in_e_fach(current_config_ptr) == TRUE &&
     current_config_ptr->efach_hrnti_status == DEDICATED_HRNTI) /*Check if dedicated mode was configured prior to SIB5 change*/
  {
    /*If chan config is due to SIB5 change indication, configure e-fach in dedicated mode*/
    rrcllc_copy_sib_to_oc_for_efach(RRC_STATE_CELL_FACH ,RRC_E_FACH_DEDICATED);
  }
  else
  {
    rrcllc_copy_sib_to_oc_for_efach(RRC_STATE_CELL_FACH ,RRC_E_FACH_COMMON);
  }
#endif

  oc_status = rrcllc_copy_sib_to_oc(RRC_STATE_CELL_FACH);

#ifdef FEATURE_WCDMA_HS_RACH
  rrcllc_copy_sib_to_oc_for_hsrach(RRC_STATE_CELL_FACH);
#endif

  /* In Idle Disconnected state, Ordered Config is never set */
  //ordered_config.set_status = OC_NOT_SET;

  /* Return the Ordered Config status and let the calling fuinction handle it */
  return(oc_status);

}  /* rrcllc_update_oc_in_fach_with_sibs */

/*====================================================================
FUNCTION: rrcllc_update_oc_for_serving_neighbor_bch_in_connected()

DESCRIPTION:
  This function is responsible for updating the Ordered Config
  for Serving and/or Neighbor BCH in Connected mode states.
  It is based on the BCH and NBCH operation type
  that is passed as a parameter.

DEPENDENCIES:
  None

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type  rrcllc_update_oc_for_serving_neighbor_bch_in_connected
(
  ordered_config_type  *config_ptr,
  rrcllc_bch_op_e_type  bch_op,
  rrcllc_nbch_op_e_type  nbch_op
)
{
  uecomdef_status_e_type  oc_status = SUCCESS;

  /* Set the Activation Time to "Now" */
  rrcllc_init_activation_time(config_ptr);

  /* Always process the drop of BCH and NBCH before processing
     the addition.  This is to ensure that num_bch always remain
     at 0 or 1.  
   */
  if((bch_op == RRCLLC_DROP_BCH)&&(rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up))
  {
    /* Set number of BCHs in MAC correctly */
    if(config_ptr->mac_dl_parms.num_bchs)
    {
      config_ptr->mac_dl_parms.num_bchs --;
    }

    /* Update number of transport channels on PCCPCH in L1 CCTrCH Parameters */
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch.num_trch = 0;
  }
  else if((nbch_op == RRCLLC_DROP_NBCH)&&(rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch_is_up))
  {
    /* Set number of BCHs in MAC correctly */
    if(config_ptr->mac_dl_parms.num_bchs)
    {
      config_ptr->mac_dl_parms.num_bchs --;
    }

    /* Update number of transport channels on PCCPCH in L1 CCTrCH Parameters */
    rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch.num_trch = 0;

    
  }

  if(bch_op == RRCLLC_ADD_BCH)
  {
    /* Set number of BCHs in MAC correctly */
    if(config_ptr->mac_dl_parms.num_bchs)
    {
      WRRC_MSG1_ERROR("Number of BCHS : %d not Zero",config_ptr->mac_dl_parms.num_bchs);
    }
    else
    {
      config_ptr->mac_dl_parms.num_bchs ++;
    }

    /* Update number of transport channels on PCCPCH in L1 CCTrCH Parameters */
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch.num_trch = 1;

    
  }
  else if(nbch_op == RRCLLC_ADD_NBCH)
  {
    /* Set number of BCHs in MAC correctly */
    if(config_ptr->mac_dl_parms.num_bchs)
    {
      WRRC_MSG1_ERROR("Number of BCHS : %d not Zero",config_ptr->mac_dl_parms.num_bchs);
    }
    else
    {
      config_ptr->mac_dl_parms.num_bchs ++;
    }

    /* Update number of transport channels on PCCPCH in L1 CCTrCH Parameters */
    rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch.num_trch = 1;

  }


  /* Return the Ordered Config status and let the calling fuinction handle it */
  return(oc_status);
} /* rrcllc_update_oc_for_serving_neighbor_bch_in_connected */

/*====================================================================
FUNCTION: rrcllc_update_oc_from_disconnected_to_connecting()

DESCRIPTION:
  This function is responsible for updating the Ordered Config when
  mving from Disconnected to Connecting state.
  It starts with initializing Ordered Config and then
  updating Ordered Config data with SIBs
  In the event of a failure, the Ordered Config data is
  reverted back to Current Config data and a FAILURE status is returned.

DEPENDENCIES:
  All SIBs should be read before calling this function.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type
rrcllc_update_oc_from_disconnected_to_connecting(void)
{
  uecomdef_status_e_type  oc_status = SUCCESS;

  /* Since changing a state, start with initialized Ordered Config */
  rrcllc_init_ordered_config_status_and_data(RRC_STATE_CONNECTING);


  rrc_set_hsdpa_action(HSDPA_NOOP);


#ifdef FEATURE_WCDMA_HS_FACH
  rrcllc_copy_sib_to_oc_for_efach(RRC_STATE_CONNECTING ,RRC_E_FACH_COMMON);
#endif


  oc_status = rrcllc_copy_sib_to_oc(RRC_STATE_CONNECTING);

#ifdef FEATURE_WCDMA_HS_RACH
  rrcllc_copy_sib_to_oc_for_hsrach(RRC_STATE_CONNECTING);
#endif

  /* Restore BCH info from current to ordered config
   */
  if(oc_status ==  SUCCESS)
  {
    rrcllc_copy_bch_info_from_cc_to_oc();
  }
  else
  {
    rrcllc_discard_oc();
  }


  /* Return the Ordered Config status and let the calling fuinction handle it */
  return(oc_status);

}  /* rrcllc_update_oc_from_disconnected_to_connecting */

/*====================================================================
FUNCTION: rrcllc_update_oc_from_disconnected_to_dch()

DESCRIPTION:
  This function is responsible for updating the Ordered Config when
  moving from Disconnected to Cell DCH state.
  It starts with initializing Ordered Config and then
  updating Ordered Config data with message IEs.
  In the event of a failure, the Ordered Config data is
  reverted back to Current Config data and a FAILURE status is returned.

DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
  None.
====================================================================*/
rrcllc_oc_status_e_type
rrcllc_update_oc_from_disconnected_to_dch(
  uint32            dl_sdu_num,
  void             *msg_ptr
)
{
  /* Since changing a state, start with initialized Ordered Config */
  rrcllc_init_ordered_config_status_and_data(RRC_STATE_CELL_DCH);
  rrcllc_init_reestablish_entity(ORDERED_CONFIG_ONLY );

  /* Update with new IEs received in msg */
  if(rrcllc_copy_msg_ie_to_oc(dl_sdu_num, msg_ptr) == SUCCESS)
  {
    WRRC_MSG0_MED("ORDERED_CONFIG updated for CELL_DCH");

    /* Ordered Config now set */
    ordered_config.set_status = OC_SET_FOR_CELL_DCH;

    return (ORDERED_CONFIG_SET);
  }
  else
  {
    WRRC_MSG0_HIGH("ORDERED_CONFIG update failed for CELL_DCH");

    /* Ordered Config NOT set */
    ordered_config.set_status = OC_NOT_SET;
    ordered_config.reconfig_in_progress = FALSE;


    rrcllc_discard_oc();

    return (ORDERED_CONFIG_CONFIGURATION_INVALID);
  }
} /* rrcllc_update_oc_from_disconnected_to_dch */

/*====================================================================
FUNCTION: rrcllc_update_oc_from_connecting_to_dch()

DESCRIPTION:
  This function is responsible for updating the Ordered Config when
  moving from Connecting to Cell_DCH state.
  It starts with initializing Ordered Config and then
  updating Ordered Config data with Message IEs.
  In the event of a failure, the Ordered Config data is
  reverted back to Current Config data and a NOT_SUPPORTED
  status is returned.
  On successful updation, ordered_config.set_status is set to TRUE.

DEPENDENCIES:
  None

RETURN VALUE:
  rrcllc_oc_status_e_type

SIDE EFFECTS:
  None.
====================================================================*/
rrcllc_oc_status_e_type
rrcllc_update_oc_from_connecting_to_dch(
  uint32            dl_sdu_num,
  void             *msg_ptr
)
{

  /* Since changing a state, start with initialized Ordered Config */
  rrcllc_init_ordered_config_status_and_data(RRC_STATE_CELL_DCH);
#ifdef FEATURE_WCDMA_HS_FACH
  if(rrcllc_get_hs_status_in_e_fach(current_config_ptr) == TRUE)
  {
    WRRC_MSG2_HIGH("EFACH:Copy hs cctrch_id[oc=%d,cc=%d] from CC",
    ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.cctrch_id,
      current_config_ptr->l1_hsdpa_info.hs_dsch_info.cctrch_id);

    ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.cctrch_id =
      current_config_ptr->l1_hsdpa_info.hs_dsch_info.cctrch_id;
  }
#endif


#ifdef FEATURE_WCDMA_HS_RACH
  /*Initialise HSRACH structures while going to DCH state*/
   rrcllc_init_hsrach_info(ordered_config_ptr,RRC_STATE_CELL_DCH);
#endif

  rrc_set_hsdpa_action(HSDPA_NOOP);


  /* Check if Serving BCCH is up */
  if( (rrclcm_check_dl_rlc_lc_id( UE_LOGCHAN_BCCH,
                                  BCCH_S_RADIO_BEARER_ID,
                                  UE_MODE_TRANSPARENT ))
       != RRCLCM_RLC_LC_ID_NOT_FOUND )
  {
    /* S-BCCH is up. Increment the number of DL TM channels by 1 */
    MSG_MED("S-BCCH up for the cell", 0, 0, 0);
    ordered_config_ptr->rlc_dl_tm_parms.nchan++;
  }

  /* Check if Neighbor BCCH is up */
  if( (rrclcm_check_dl_rlc_lc_id( UE_LOGCHAN_BCCH,
                                  BCCH_N_RADIO_BEARER_ID,
                                  UE_MODE_TRANSPARENT ))
       != RRCLCM_RLC_LC_ID_NOT_FOUND )
  {
    /* N-BCCH is up. Increment the number of DL TM channels by 1 */
    MSG_MED("N-BCCH up", 0, 0, 0);
    ordered_config_ptr->rlc_dl_tm_parms.nchan++;
  }

  /* Check if PCCH is up */
  if( (rrclcm_check_dl_rlc_lc_id( UE_LOGCHAN_PCCH,
                                  PCCH_RADIO_BEARER_ID,
                                  UE_MODE_TRANSPARENT ))
       != RRCLCM_RLC_LC_ID_NOT_FOUND )
  {
    /* PCCH is up. Increment the number of DL TM channels by 1 */
    MSG_MED("PCCH up", 0, 0, 0);
    ordered_config_ptr->rlc_dl_tm_parms.nchan++;
  }

  /* Check if CCCH is up */
  if( (rrclcm_check_ul_rlc_lc_id( UE_LOGCHAN_CCCH,
                                  CCCH_RADIO_BEARER_ID,
                                  UE_MODE_TRANSPARENT ))
       != RRCLCM_RLC_LC_ID_NOT_FOUND )
  {
    /* CCCH is up. Increment the number of DL TM channels by 1 */
    MSG_MED("CCCH up", 0, 0, 0);
    ordered_config_ptr->rlc_ul_tm_parms.nchan++;
    WRRC_MSG1_MED("nchan: CONN->DCH CCCH up UL TM %d after increment",
        ordered_config_ptr->rlc_ul_tm_parms.nchan);
  }
  rrcllc_init_reestablish_entity(ORDERED_CONFIG_ONLY);


  /* Update with new IEs received in CCCH/DCCH msg */
  if(rrcllc_copy_msg_ie_to_oc(dl_sdu_num, msg_ptr) == SUCCESS)
  {
    WRRC_MSG0_MED("ORDERED_CONFIG updated for CELL_DCH");

    /* Ordered Config now set */
    ordered_config.set_status = OC_SET_FOR_CELL_DCH;

    return (ORDERED_CONFIG_SET);
  }
  else
  {
    WRRC_MSG0_HIGH("ORDERED_CONFIG update failed for CELL_DCH");

    /* Ordered Config NOT set */
    ordered_config.set_status = OC_NOT_SET;
    ordered_config.reconfig_in_progress = FALSE;

    rrcllc_discard_oc();

    return (ORDERED_CONFIG_CONFIGURATION_INVALID);
  }
} /* rrcllc_update_oc_from_connecting_to_dch */

/*====================================================================
FUNCTION: rrcllc_update_oc_in_dch()

DESCRIPTION:
  This function is responsible for updating the Ordered Config when
  in Cell_DCH state.
  It starts with copying Current Config to Ordered Config and then
  updating Ordered Config data with Message IEs.
  In the event of a failure, the Ordered Config data is
  reverted back to Current Config data and a NOT_SUPPORTED
  status is returned.
  On successful updation, ordered_config.set_status is set to TRUE.

DEPENDENCIES:
  None

RETURN VALUE:
  rrcllc_oc_status_e_type

SIDE EFFECTS:
  None.
====================================================================*/
rrcllc_oc_status_e_type
rrcllc_update_oc_in_dch(
  uint32            dl_sdu_num,
  void             *msg_ptr
)
{
  if (ordered_config.set_status == OC_NOT_SET)
  {
    /* Ordinarily, the ordered config status would be OC_NOT_SET, or
       we wouldn't even be in this function.  However, if we are
       processing an active set update in parallel with a
       reconfiguration, we could end up here with ordered config
       already set, so we don't want to copy current config.
     */
    rrcllc_copy_cc_to_oc();
  }
  else
  {
    WRRC_MSG0_HIGH("Skip copy CC->OC for DCH, OC already set");
  }

  rrcllc_init_reestablish_entity(ORDERED_CONFIG_ONLY);

  if(rrcllc_copy_msg_ie_to_oc(dl_sdu_num, msg_ptr) == SUCCESS)
  {
    /* Copy OC back to CC. This is so as to keep MAC and L1 in
     * sync. Once the RRC-MAC-L1 interface is fixed for all
     * out-of-sync scenarios, this must go away. This is TBD
     */

    WRRC_MSG0_MED("ORDERED_CONFIG updated for CELL_DCH");

    /* Ordered Config now set */
    ordered_config.set_status = OC_SET_FOR_CELL_DCH;

    return (ORDERED_CONFIG_SET);
  }
  else
  {

    /* Ordered Config NOT set */
    ordered_config.set_status = OC_NOT_SET;
    ordered_config.reconfig_in_progress = FALSE;
#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
    if(rrcdata_misc_info.rrc_buffer_ota_message == TRUE)
    {
      return ORDERED_CONFIG_CONFIGURATION_SET_DEFERRED;
    }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
    WRRC_MSG0_HIGH("ORDERED_CONFIG update failed for CELL_DCH");
    return (ORDERED_CONFIG_CONFIGURATION_INVALID);
  }
}  /* rrcllc_update_oc_in_dch */



/*====================================================================
FUNCTION: rrcllc_update_oc_from_dch_to_fach_with_msg()

DESCRIPTION:
  This function is responsible for updating the Ordered Config when
  transitioning from Cell_DCH to Cell_FACH state.
  This function updates OC with the message contents of the message
  that transitions UE from Cell_DCH to Cell_FACH.
  The updated OC is copied to TOC to be used later in Cell_FACH and
  when coming back to Cell_DCH from Cell_FACH.

DEPENDENCIES:
  None

RETURN VALUE:
  rrcllc_oc_status_e_type

SIDE EFFECTS:
  None.
====================================================================*/
rrcllc_oc_status_e_type
rrcllc_update_oc_from_dch_to_fach_with_msg(
  uint32            dl_sdu_num,
  void             *msg_ptr
)
{
  /* Copy Current Config to Ordered Config */
  rrcllc_copy_cc_to_oc();
  rrcllc_init_reestablish_entity(ORDERED_CONFIG_ONLY);

  if(rrcllc_copy_msg_ie_to_oc(dl_sdu_num, msg_ptr) == SUCCESS)
  {
    /* Copy OC back to CC. This is so as to keep MAC and L1 in
     * sync. Once the RRC-MAC-L1 interface is fixed for all
     * out-of-sync scenarios, this must go away. This is TBD
     */

    WRRC_MSG0_MED("OC and TOC updated for DCH->FACH");

    /* Ordered Config now set */
    ordered_config.set_status = OC_SET_FOR_DCH_FACH_TRANS;

    /* Now copy OC to TOC */
    rrcllc_copy_oc_to_toc();
    /* Inducate that TOC could be used both for DCH and FACH in the future */
    transition_config.toc_usage = TOC_FOR_DCH_AND_FACH;

    return (ORDERED_CONFIG_SET);
  }
  else
  {
    WRRC_MSG0_HIGH("OC update failed for DCH->FACH");

    /* Ordered Config NOT set */
    ordered_config.set_status = OC_NOT_SET;
    ordered_config.reconfig_in_progress = FALSE;
    return (ORDERED_CONFIG_CONFIGURATION_INVALID);
  }
}

/*====================================================================
FUNCTION: rrcllc_update_oc_from_dch_to_fach_with_sibs()

DESCRIPTION:
  This function is responsible for updating the Ordered Config when
  transitioning from Cell_DCH to Cell_FACH state.
  This function reads the SIBs and updates OC with SIB info.
  The BCH info is preserved from the CC to OC.

DEPENDENCIES:
  None

RETURN VALUE:
  rrcllc_oc_status_e_type

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type
rrcllc_update_oc_from_dch_to_fach_with_sibs(void)
{
  uecomdef_status_e_type  oc_status = SUCCESS;

  /* Start with copying CC to OC */
  rrcllc_copy_cc_to_oc();

  /* Now copy RNTI Info from TOC to OC */
  ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = URNTI_VALID;
  ordered_config_ptr->mac_dl_parms.rnti_info.urnti =
    transition_config.toc_ptr->mac_dl_parms.rnti_info.urnti;

  ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = URNTI_VALID;
  ordered_config_ptr->mac_ul_parms.rnti_info.urnti =
    transition_config.toc_ptr->mac_dl_parms.rnti_info.urnti;

#ifdef FEATURE_WCDMA_HS_FACH
  rrcllc_copy_sib_to_oc_for_efach(RRC_STATE_CELL_FACH ,RRC_E_FACH_COMMON);
#endif

  oc_status = rrcllc_copy_sib_to_oc(RRC_STATE_CELL_FACH);

#ifdef FEATURE_WCDMA_HS_RACH
  rrcllc_copy_sib_to_oc_for_hsrach(RRC_STATE_CELL_FACH);
#endif

  /* Restore BCH info from current to ordered config
   */
  if(oc_status ==  SUCCESS)
  {
    rrcllc_copy_bch_info_from_cc_to_oc();
  }

  if(oc_status == SUCCESS)
  {
    WRRC_MSG0_HIGH("Update OC with SIBs DCH->FACH");
    /* Update OC with next state as CELL_FACH */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_FACH;
  }
  else
  {
    WRRC_MSG0_HIGH("Failure updating OC with SIBs DCH->FACH");
  }
#ifdef FEATURE_WCDMA_HS_FACH

  // Re-set the hs-fach status and action as actual channel setup happens in last channel config
  if(rrcllc_check_dch_fach_reconfig_status() && (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CCM))
  {
    rrcllc_set_hs_status_in_e_fach(ordered_config_ptr, FALSE);
    ordered_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_NOOP;            
    rrcllc_set_hs_action_in_e_fach(ordered_config_ptr,HSDPA_NOOP);           
#ifdef FEATURE_WCDMA_HS_RACH

    rrchsrach_set_common_edch_transmission(ordered_config_ptr, FALSE);
    rrchsrach_set_ready_for_common_edch(ordered_config_ptr, FALSE);
    ordered_config_ptr->l1_hs_rach_req_mask = L1_HS_RACH_NO_OP;
    rrcllc_set_hs_rach_action(ordered_config_ptr,MAC_HS_RACH_NOOP);           
#endif
  }
#endif
  /* Return the Ordered Config status and let the calling fuinction handle it */
  return(oc_status);
} /* rrcllc_update_oc_from_dch_to_fach_with_sibs */




/*====================================================================
FUNCTION: rrcllc_update_oc_from_pch_to_fach()

DESCRIPTION:
  This function is responsible for updating the Ordered Config when
  transitioning from Cell_PCH to Cell_FACH state.
  This function reads the SIBs and updates OC with SIB info.
  The BCH info is preserved from the CC to OC.

DEPENDENCIES:
  None

RETURN VALUE:
  uecomdef_status_e_type

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type
rrcllc_update_oc_from_pch_to_fach(void)
{
  uecomdef_status_e_type  oc_status = SUCCESS;
  int i, j;

  /* Start with copying CC to OC */
  rrcllc_copy_cc_to_oc();


  rrc_set_hsdpa_action(HSDPA_NOOP);


#ifdef FEATURE_WCDMA_HS_RACH
  if((TRUE == rrchsrach_get_ready_for_common_edch(ordered_config_ptr)) ||
      (TRUE == rrcllc_get_hspa_rnti_stored_cell_pch(ordered_config_ptr)))
  {
    ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = BOTH_VALID;
    ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = BOTH_VALID;

    MSG_4(MSG_SSID_DFLT, MSG_LEGACY_HIGH,"RRCHSRACH:ERNTI Present %d Restore ERNTI %d from TOC to OC HRNTI status %d hrnti %d",
    transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present,
        transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti,
        transition_config.toc_ptr->efach_hrnti_status, transition_config.toc_ptr->efach_hrnti);
    
    /*Always get the HRNTI and ERNTI from TOC to OC while coming out of PCH state */
    if(transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present)
    {
      ordered_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = 
        transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present;
    
      ordered_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti = 
        transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti;

      transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = FALSE;
    
    }

    if(DEDICATED_HRNTI ==transition_config.toc_ptr->efach_hrnti_status)
    {
      ordered_config_ptr->efach_hrnti_status=current_config_ptr->efach_hrnti_status=transition_config.toc_ptr->efach_hrnti_status;
      ordered_config_ptr->efach_hrnti=current_config_ptr->efach_hrnti=transition_config.toc_ptr->efach_hrnti;
    }    

  }
  else
#endif
  {
  /* Now copy RNTI Info from TOC to OC */
  ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = URNTI_VALID;
  current_config_ptr->mac_dl_parms.rnti_info.rnti_valid = URNTI_VALID;
  /*
  ordered_config_ptr->mac_dl_parms.rnti_info.urnti =
    transition_config.toc_ptr->mac_dl_parms.rnti_info.urnti;
    */

  ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = URNTI_VALID;
  current_config_ptr->mac_ul_parms.rnti_info.rnti_valid = URNTI_VALID;
  /*
  ordered_config_ptr->mac_ul_parms.rnti_info.urnti =
    transition_config.toc_ptr->mac_dl_parms.rnti_info.urnti;
    */
  }

  /* If HSPA RNTI flag is false invalidate ERNTI in all databases. If this is not done, MAC prioritizes sending data 
     instead of sending CU */
  if(FALSE == rrcllc_get_hspa_rnti_stored_cell_pch(ordered_config_ptr))
  {
    current_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = FALSE;
    ordered_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = FALSE;
    transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = FALSE;
    WRRC_MSG0_HIGH("Reset the ERNTI in all data bases");
  }

  /* Initialize PCH Info */
  rrcllc_init_pch_info(ordered_config_ptr);
  /* Do not delete RB Mapping Info in any other RRC state */
  rrcllc_init_fach_info(ordered_config_ptr, FALSE);
  /* Initialize L1 SCCPCH Channel Info */
  rrcllc_init_l1_sccpch_chan_info(ordered_config_ptr);
  /* Initialize L1 Downlink CCTrCH Info that includes Transport Format Set */
  rrcllc_init_dl_cctrch_info(ordered_config_ptr);
  /* Initialize Downlink TFCS */
  rrcllc_init_dl_ctfcs(ordered_config_ptr);
  rrcllc_init_reestablish_entity(ORDERED_CONFIG_ONLY);

#ifdef FEATURE_WCDMA_HS_FACH
#ifdef FEATURE_WCDMA_HS_RACH
  if((TRUE == rrchsrach_get_ready_for_common_edch(current_config_ptr)) ||
     (TRUE == rrcllc_get_hspa_rnti_stored_cell_pch(current_config_ptr))
    )
  {
    rrcllc_copy_sib_to_oc_for_efach(RRC_STATE_CELL_FACH,RRC_E_FACH_DEDICATED);
    if(rrcenhstate_evaluate_efach_and_set_lower_layers_action(ordered_config_ptr,
                                                            RRC_STATE_CELL_FACH,
                                                            RRC_E_FACH_DEDICATED) == FAILURE)
    {
      WRRC_MSG0_HIGH("EFACH:Failed to configure HS-FACH");
      return FAILURE;
    }
  }
  else
#endif
  {
    rrcllc_copy_sib_to_oc_for_efach(RRC_STATE_CELL_FACH ,RRC_E_FACH_COMMON);
  }
#endif/* FEATURE_WCDMA_HS_FACH*/


  /* we need to copy SIB info again because of the SCCPCH selection
  based on fach */
  oc_status = rrcllc_copy_sib_to_oc(RRC_STATE_CELL_FACH);

#ifdef FEATURE_WCDMA_HS_RACH

    rrcllc_copy_sib_to_oc_for_hsrach(RRC_STATE_CELL_FACH);

  /*while coming out of pch we configure all the dedicated rbs so the below code is needed
 Restore the mapping for for dedicated mode config*/
  if((TRUE == rrchsrach_get_ready_for_common_edch(current_config_ptr)) ||
      (TRUE == rrcllc_get_hspa_rnti_stored_cell_pch(current_config_ptr)))
    {
    if(FAILURE == rrcllc_evaluate_hs_rach_and_set_lower_layers_action(RRC_STATE_CELL_FACH,ordered_config_ptr))
    {
      WRRC_MSG0_HIGH("RRCHSRACH:cant configure HS_RACH ");
        oc_status = FAILURE;
      }
    }

  /*This has to be done for setting TVI indicator in CU
       for cases where HSRACh mapping has not yet restored into config pointers
       EG: R99 DCH to PCH(HSRACH) transitions, MAC queries the list of logical chanenls 
       from hsrach pointer in config_ptr_in_use, we restore into same
  */
    if(rrchsrach_camped_cell_supports_hsrach() == TRUE)
    {
      rrcllc_update_hs_rach_params(ordered_config_ptr); /* HSRACH params are updated to OC as config_ptr_in_use is OC and TVI is set based on config_ptr_in_use */
    } 

#endif

  /* Restore BCH info from current to ordered config
   */
  if(oc_status ==  SUCCESS)
  {
    if(ordered_config_ptr->mac_dl_parms.num_fachs > 1)
    {
      for(i = 0; i < ordered_config_ptr->mac_dl_parms.num_fachs; i ++)
      {
        ordered_config_ptr->mac_dl_parms.fach_info[i]->ccch_enable =
          ordered_config_ptr->mac_dl_parms.fach_info[0]->ccch_enable;
        ordered_config_ptr->mac_dl_parms.fach_info[i]->ccch_id =
          ordered_config_ptr->mac_dl_parms.fach_info[0]->ccch_id;
        ordered_config_ptr->mac_dl_parms.fach_info[i]->ndlchan =
          ordered_config_ptr->mac_dl_parms.fach_info[0]->ndlchan;

        for(j = 0; j < MAX_DED_LOGCHAN_PER_TRCH; j ++)
        {
          ordered_config_ptr->mac_dl_parms.fach_info[i]->dlchan_info[j] =
            ordered_config_ptr->mac_dl_parms.fach_info[0]->dlchan_info[j];
        }
        ordered_config_ptr->mac_dl_parms.fach_info[i]->bcch_enable =
          ordered_config_ptr->mac_dl_parms.fach_info[0]->bcch_enable;
        ordered_config_ptr->mac_dl_parms.fach_info[i]->bcch_id =
          ordered_config_ptr->mac_dl_parms.fach_info[0]->bcch_id;
      }
    } /* If number of FACHs > 1 */
    rrcllc_copy_bch_info_from_cc_to_oc();
  }

  if(oc_status == SUCCESS)
  {
    WRRC_MSG0_HIGH("Update OC with SIBs PCH->FACH");
    /* Update OC with next state as CELL_FACH */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_FACH;
  }
  else
  {
    WRRC_MSG0_HIGH("Failure updating OC with SIBs PCH->FACH");
  }

  /* Return the Ordered Config status and let the calling fuinction handle it */
  return(oc_status);
} /* rrcllc_update_oc_from_pch_to_fach_with_sibs */


/*====================================================================
FUNCTION: rrcllc_update_oc_from_connecting_to_fach()

DESCRIPTION:
  This function is responsible for updating the Ordered Config when
  going from Connecting to Cell_FACH state.
  It starts with initializing Ordered Config and then
  updating Ordered Config data with Message IEs.
  In the event of a failure, the Ordered Config data is
  reverted back to Current Config data and a NOT_SUPPORTED
  status is returned.
  On successful updation, ordered_config.set_status is set to TRUE.

DEPENDENCIES:
  None

RETURN VALUE:
  rrcllc_oc_status_e_type

SIDE EFFECTS:
  None.
====================================================================*/
rrcllc_oc_status_e_type
rrcllc_update_oc_from_connecting_to_fach(
  uint32            dl_sdu_num,
  void             *msg_ptr
)
{
  rrcllc_oc_status_e_type  oc_status;

  /* Since changing a state, start with initialized Ordered Config */
  rrcllc_init_ordered_config_status_and_data(RRC_STATE_CELL_FACH);

#ifdef FEATURE_WCDMA_HS_FACH
    rrcllc_copy_sib_to_oc_for_efach(RRC_STATE_CELL_FACH, RRC_E_FACH_COMMON);
  if(rrcllc_get_hs_status_in_e_fach(current_config_ptr) == TRUE)
  {
    WRRC_MSG2_HIGH("EFACH:Copy hs cctrch_id[oc=%d,cc=%d] from CC",
        ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.cctrch_id,
      current_config_ptr->l1_hsdpa_info.hs_dsch_info.cctrch_id);

    ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.cctrch_id =
      current_config_ptr->l1_hsdpa_info.hs_dsch_info.cctrch_id;
  }
#endif

  /* Restore BCH info from current to ordered config */
  rrcllc_copy_bch_info_from_cc_to_oc();

  /* Update OC with SIB Info */
  if(rrcllc_copy_sib_to_oc(RRC_STATE_CELL_FACH) == FAILURE)
  {
    WRRC_MSG0_HIGH("ORDERED_CONFIG update failed for CELL_FACH");

    /* Ordered Config NOT set */
    ordered_config.set_status = OC_NOT_SET;
    ordered_config.reconfig_in_progress = FALSE;

    rrcllc_discard_oc();

    oc_status = ORDERED_CONFIG_CONFIGURATION_NOT_SUPPORTED;
  }
  else /* Successfully updated with SIBs */
  {

#ifdef FEATURE_WCDMA_HS_RACH
    rrcllc_copy_sib_to_oc_for_hsrach(RRC_STATE_CELL_FACH);
#endif
  
    rrcllc_init_reestablish_entity(ORDERED_CONFIG_ONLY);

    /* Update with new IEs received in CCCH/DCCH msg */
    if(rrcllc_copy_msg_ie_to_oc(dl_sdu_num, msg_ptr) == SUCCESS)
    {
      /* Restore the CCCH info from Current Config to Ordered Config */
      rrcllc_copy_ccch_info_from_cc_to_oc();


      WRRC_MSG0_MED("ORDERED_CONFIG updated for CELL_FACH");

      /* Ordered Config now set */
      ordered_config.set_status = OC_SET_FOR_CELL_FACH;

      oc_status = ORDERED_CONFIG_SET;
    }
    else
    {
      WRRC_MSG0_HIGH("ORDERED_CONFIG update failed for CELL_FACH");

      /* Ordered Config NOT set */
      ordered_config.set_status = OC_NOT_SET;
      ordered_config.reconfig_in_progress = FALSE;
      oc_status = ORDERED_CONFIG_CONFIGURATION_INVALID;
    }
  }

  return(oc_status);
} /* rrcllc_update_oc_from_connecting_to_fach */

/*====================================================================
FUNCTION: rrcllc_update_oc_from_dch_to_pch_with_msg()

DESCRIPTION:
  This function is responsible for updating the Ordered Config when
  transitioning from Cell_DCH to Cell_PCH or URA_PCH state.
  This function updates OC with the message contents of the message
  that transitions UE from Cell_DCH to Cell_PCH or URA_PCH.
  The updated OC is copied to TOC to be used later when coming back to
  Cell_FACH from Cell_PCH or URA_PCH.

DEPENDENCIES:
  None

RETURN VALUE:
  rrcllc_oc_status_e_type

SIDE EFFECTS:
  None.
====================================================================*/
rrcllc_oc_status_e_type
rrcllc_update_oc_from_dch_to_pch_with_msg(
  uint32            dl_sdu_num,
  void             *msg_ptr,
  rrc_state_e_type  next_rrc_state
)
{
  /* Copy Current Config to Ordered Config */
  rrcllc_copy_cc_to_oc();

#ifdef FEATURE_WCDMA_HS_RACH
    /*For DCH to PCH transition copy the ERNTI present in old structure to  new structureif valid 
    For DCH to FACH transition network needs to give new ERNTI so its not needed */
    if(current_config_ptr->l1_e_info.e_dl_info.primary_e_rnti_present)
    {
      ordered_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = 
      current_config_ptr->l1_e_info.e_dl_info.primary_e_rnti_present;

      ordered_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti = 
      current_config_ptr->l1_e_info.e_dl_info.primary_e_rnti ;

      WRRC_MSG0_HIGH("RRCHSRACH Copying ERNTI from Legacy to HSRACH struc for DCh to PCH transition");
    }
#endif

  rrcllc_init_reestablish_entity(ORDERED_CONFIG_ONLY);

  if(rrcllc_copy_msg_ie_to_oc(dl_sdu_num, msg_ptr) == SUCCESS)
  {
    /* Copy OC back to CC. This is so as to keep MAC and L1 in
     * sync. Once the RRC-MAC-L1 interface is fixed for all
     * out-of-sync scenarios, this must go away. This is TBD
     */

    WRRC_MSG0_MED("OC and TOC updated for DCH->PCH");

    /* Ordered Config now set */
    switch(next_rrc_state)
    {
      case RRC_STATE_CELL_PCH:
        ordered_config.set_status = OC_SET_FOR_DCH_CELL_PCH_TRANS;
        break;
      case RRC_STATE_URA_PCH:
        ordered_config.set_status = OC_SET_FOR_DCH_URA_PCH_TRANS;
        break;
      default:
        WRRC_MSG1_ERROR("Invalid state %d for DCH->PCH OC update", next_rrc_state);
        ordered_config.set_status = OC_NOT_SET;
        ordered_config.reconfig_in_progress = FALSE;
        return ORDERED_CONFIG_CONFIGURATION_NOT_SUPPORTED;
    }

    /* Now copy OC to TOC */
    rrcllc_copy_oc_to_toc();
    /* Indicate that TOC could be used both for DCH and FACH in the future */
    transition_config.toc_usage = TOC_FOR_DCH_AND_FACH;

    return (ORDERED_CONFIG_SET);
  }
  else
  {
    WRRC_MSG0_HIGH("OC update failed for DCH->CELL_PCH");

    /* Ordered Config NOT set */
    ordered_config.set_status = OC_NOT_SET;
    ordered_config.reconfig_in_progress = FALSE;
    return (ORDERED_CONFIG_CONFIGURATION_INVALID);
  }
}

/*====================================================================
FUNCTION: rrcllc_update_oc_from_dch_to_pch_with_sibs()

DESCRIPTION:
  This function is responsible for updating the Ordered Config when
  transitioning from Cell_DCH to Cell_PCH or URA_PCH state.
  This function reads the SIBs and updates OC with SIB info.
  The BCH info is preserved from the CC to OC.

DEPENDENCIES:
  None

RETURN VALUE:
  uecomdef_status_e_type

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type
rrcllc_update_oc_from_dch_to_pch_with_sibs(rrc_state_e_type next_rrc_state)
{
  uecomdef_status_e_type  oc_status = SUCCESS;

  /* Start with copying CC to OC */
  rrcllc_copy_cc_to_oc();

  /* Now copy U-RNTI Info from TOC to OC */
  ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = URNTI_VALID;
  ordered_config_ptr->mac_dl_parms.rnti_info.urnti =
    transition_config.toc_ptr->mac_dl_parms.rnti_info.urnti;

  ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = URNTI_VALID;
  ordered_config_ptr->mac_ul_parms.rnti_info.urnti =
    transition_config.toc_ptr->mac_dl_parms.rnti_info.urnti;

#ifdef FEATURE_WCDMA_HS_FACH
  rrcllc_copy_sib_to_oc_for_efach(next_rrc_state ,RRC_E_FACH_COMMON);
#endif

  oc_status = rrcllc_copy_sib_to_oc(next_rrc_state);

#ifdef FEATURE_WCDMA_HS_RACH
    rrcllc_copy_sib_to_oc_for_hsrach(next_rrc_state);
#endif

    if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status == RRCLLC_CTCH_ON_DIF_SCCPCH )
    {
      (void)rrcllc_copy_sib_to_oc_for_sccpch_with_ctch(next_rrc_state);
    }

  /* Restore BCH info from current to ordered config
   */
  if(oc_status ==  SUCCESS)
  {
    rrcllc_copy_bch_info_from_cc_to_oc();
  }

  if(oc_status == SUCCESS)
  {
    WRRC_MSG0_HIGH("Update OC with SIBs DCH->PCH");
    /* Update OC with next state. */
    ordered_config_ptr->rrc_state_indicator = next_rrc_state;
  }
  else
  {
    WRRC_MSG0_HIGH("Failure updating OC with SIBs DCH->PCH");
  }

  /* Return the Ordered Config status and let the calling fuinction handle it */
  return(oc_status);
} /* rrcllc_update_oc_from_dch_to_fach_with_sibs */



/*====================================================================
FUNCTION: rrcllc_update_oc_from_fach_to_cell_pch_or_ura_pch()

DESCRIPTION:
  This function is responsible for updating the Ordered Config when
  transitioning from Cell_FACH to Cell_PCH or URA_PCH state.
  This function reads the SIBs and updates OC with SIB info.
  The BCH info is preserved from the CC to OC.

DEPENDENCIES:
  None

RETURN VALUE:
  uecomdef_status_e_type

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type
rrcllc_update_oc_from_fach_to_cell_pch_or_ura_pch(rrc_state_e_type next_rrc_state)
{
  int i,j;
  uecomdef_status_e_type  oc_status = SUCCESS;

  /* Initialize PCH Info */
  rrcllc_init_pch_info(ordered_config_ptr);
  /* Do not delete RB Mapping Info in any other RRC state */
  rrcllc_init_fach_info(ordered_config_ptr, FALSE);
  /* Initialize L1 SCCPCH Channel Info */
  rrcllc_init_l1_sccpch_chan_info(ordered_config_ptr);
  /* Initialize L1 Downlink CCTrCH Info that includes Transport Format Set */
  rrcllc_init_dl_cctrch_info(ordered_config_ptr);
  /* Initialize Downlink TFCS */
  rrcllc_init_dl_ctfcs(ordered_config_ptr);
  rrcllc_init_dl_ctfcs_for_sccpch_with_ctch(ordered_config_ptr);

  oc_status = rrcllc_copy_sib_to_oc(next_rrc_state);

    if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status == RRCLLC_CTCH_ON_DIF_SCCPCH )
    {
      (void)rrcllc_copy_sib_to_oc_for_sccpch_with_ctch(next_rrc_state);
    }

  /* Restore BCH info from current to ordered config
   */

  if(oc_status ==  SUCCESS)
  {
    if(ordered_config_ptr->mac_dl_parms.num_fachs > 1)
    {
      for(i = 0; i < ordered_config_ptr->mac_dl_parms.num_fachs; i ++)
      {
        ordered_config_ptr->mac_dl_parms.fach_info[i]->ccch_enable =
          ordered_config_ptr->mac_dl_parms.fach_info[0]->ccch_enable;
        ordered_config_ptr->mac_dl_parms.fach_info[i]->ccch_id =
          ordered_config_ptr->mac_dl_parms.fach_info[0]->ccch_id;
        ordered_config_ptr->mac_dl_parms.fach_info[i]->ndlchan =
          ordered_config_ptr->mac_dl_parms.fach_info[0]->ndlchan;

        for(j = 0; j < MAX_DED_LOGCHAN_PER_TRCH; j ++)
        {
          ordered_config_ptr->mac_dl_parms.fach_info[i]->dlchan_info[j] =
            ordered_config_ptr->mac_dl_parms.fach_info[0]->dlchan_info[j];
        }
        ordered_config_ptr->mac_dl_parms.fach_info[i]->bcch_enable =
          ordered_config_ptr->mac_dl_parms.fach_info[0]->bcch_enable;
        ordered_config_ptr->mac_dl_parms.fach_info[i]->bcch_id =
          ordered_config_ptr->mac_dl_parms.fach_info[0]->bcch_id;
      }
    } /* If number of FACHs > 1 */
    rrcllc_copy_bch_info_from_cc_to_oc();
    rrcllc_copy_bch_info_from_cc_to_oc();
  }

  if(oc_status == SUCCESS)
  {
    WRRC_MSG0_HIGH("Update OC with SIBs FACH->PCH");
    /* Update OC with next state. */
    ordered_config_ptr->rrc_state_indicator = next_rrc_state;
  }
  else
  {
    WRRC_MSG0_HIGH("Failure updating OC with SIBs FACH->PCH");
  }

  /* Return the Ordered Config status and let the calling function handle it */
  return(oc_status);
} /* rrcllc_update_oc_from_fach_to_cell_pch_or_ura_pch */

/*====================================================================
FUNCTION: rrcllc_update_oc_from_fach_to_pch_with_msg()

DESCRIPTION:
  This function is responsible for updating the Ordered Config when
  transitioning from Cell_FACH to Cell_PCH or URA_PCH state.
  It starts with copying Current Config to Ordered Config and then
  updating Ordered Config data with Message IEs.
  In the event of a failure, the Ordered Config data is
  reverted back to Current Config data and a NOT_SUPPORTED
  status is returned.
  On successful updation, ordered_config.set_status is set to TRUE.

DEPENDENCIES:
  None

RETURN VALUE:
  rrcllc_oc_status_e_type

SIDE EFFECTS:
  None.
====================================================================*/
rrcllc_oc_status_e_type
rrcllc_update_oc_from_fach_to_pch_with_msg(
  uint32            dl_sdu_num,
  void             *msg_ptr,
  rrc_state_e_type  next_rrc_state
)
{
  /* Start with copying Current Config to Ordered Config */
  rrcllc_copy_cc_to_oc();

 /* Copy U-RNTI from Current Config to Ordered Config. Note that C-RNTI
   * is not applicable in CELL_PCH, and so is not copied.
   */
  if((current_config_ptr->mac_dl_parms.rnti_info.rnti_valid == URNTI_VALID) ||
     (current_config_ptr->mac_dl_parms.rnti_info.rnti_valid == BOTH_VALID))
  {
    ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = URNTI_VALID;
    ordered_config_ptr->mac_dl_parms.rnti_info.urnti =
      current_config_ptr->mac_dl_parms.rnti_info.urnti;
  }
  else
  {
    ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
    WRRC_MSG0_ERROR("No URNTI FACH->PCH");
  }

  if((current_config_ptr->mac_ul_parms.rnti_info.rnti_valid == URNTI_VALID) ||
     (current_config_ptr->mac_ul_parms.rnti_info.rnti_valid == BOTH_VALID))
  {
    ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = URNTI_VALID;
    ordered_config_ptr->mac_ul_parms.rnti_info.urnti =
      current_config_ptr->mac_ul_parms.rnti_info.urnti;
  }
  else
  {
    ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
    WRRC_MSG0_ERROR("No URNTI FACH->PCH");
  }

  rrcllc_init_reestablish_entity(ORDERED_CONFIG_ONLY);

  if(rrcllc_copy_msg_ie_to_oc(dl_sdu_num, msg_ptr) == SUCCESS)
  {
    WRRC_MSG0_MED("ORDERED_CONFIG updated for CELL_FACH->PCH");

    /* Ordered Config now set */
    switch(next_rrc_state)
    {
      case RRC_STATE_CELL_PCH:
        ordered_config.set_status = OC_SET_FOR_FACH_CELL_PCH_TRANS;
        break;
      case RRC_STATE_URA_PCH:
        ordered_config.set_status = OC_SET_FOR_FACH_URA_PCH_TRANS;
        break;
      default:
        WRRC_MSG1_ERROR("Invalid state %d for FACH->PCH OC update", next_rrc_state);
        ordered_config.set_status = OC_NOT_SET;
        ordered_config.reconfig_in_progress = FALSE;
        return ORDERED_CONFIG_CONFIGURATION_NOT_SUPPORTED;
    }
    /* Now copy OC to TOC */
   // rrcllc_copy_oc_to_toc();
    /* Indicate that TOC could be used both for DCH and FACH in the future */
    //transition_config.toc_usage = TOC_FOR_DCH_AND_FACH;

    return (ORDERED_CONFIG_SET);
  }
  else
  {
    WRRC_MSG0_HIGH("ORDERED_CONFIG update failed for CELL_FACH->PCH");

    /* Ordered Config NOT set */
    ordered_config.set_status = OC_NOT_SET;
    ordered_config.reconfig_in_progress = FALSE;

    return (ORDERED_CONFIG_CONFIGURATION_INVALID);
  }
}  /* rrcllc_update_oc_from_fach_to_pch_with_msg */




/*====================================================================
FUNCTION: rrcllc_copy_harq_info()

DESCRIPTION:
  This function is responsible for copying all HARQ related data from
  source to destination config.

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_copy_harq_info
(
  ordered_config_type *dest_config,
  ordered_config_type *src_config
)
{
  dest_config->l1_hsdpa_info.hs_dsch_info.harq_info =
    src_config->l1_hsdpa_info.hs_dsch_info.harq_info;
  

  dest_config->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_ack =
        src_config->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_ack;
  dest_config->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_nack =
        src_config->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_nack;
  dest_config->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.ack_nack_rep_factor =
        src_config->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.ack_nack_rep_factor;
 

  MSG_HIGH("RRCHS:Copying HS-DSCH Info Delta ack %d, Delta Nack %d, Ack nack Rep %d",
        dest_config->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_ack,
        dest_config->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_nack,
        dest_config->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.ack_nack_rep_factor);

}




/*====================================================================
FUNCTION: rrcllc_copy_srb5_info()

DESCRIPTION:
  This function is responsible for copying all SRB#5 related data from
  source to destination config.

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_copy_srb5_info
(
  ordered_config_type *dest_config,
  ordered_config_type *src_config
)
{
  WCDMA_MEMCPY((void *)&(dest_config->srb5_info),
               sizeof(rrcllc_srb5_info_type), 
               (void *)&(src_config->srb5_info), 
               sizeof(rrcllc_srb5_info_type));
} /* rrcllc_copy_srb5_info */

/*====================================================================
FUNCTION: rrcllc_copy_trch_info()

DESCRIPTION:
  This function is responsible for copying all TrCH related data from
  source to destination config.

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_copy_trch_info
(
  ordered_config_type *dest_config,
  ordered_config_type *src_config
)
{
  int i, j;
  dest_config->cm_info = src_config->cm_info;
  for(i=0; i<L1_CM_MAX_TGP_SEQ_COUNT; i++)
  {
    dest_config->tgp_seq_info[i] = src_config->tgp_seq_info[i];
    dest_config->cm_info.tgp_seq_info[i] = &dest_config->tgp_seq_info[i];
  }
  /* Copy all L1 data */
  dest_config->l1_dl_cctrch_parms = src_config->l1_dl_cctrch_parms;
  dest_config->l1_dl_ctfc_parms = src_config->l1_dl_ctfc_parms;
  dest_config->l1_ul_cctrch_parms = src_config->l1_ul_cctrch_parms;

  /* Copy MAC data */
  dest_config->mac_dl_parms = src_config->mac_dl_parms;
  dest_config->mac_ul_parms = src_config->mac_ul_parms;
  dest_config->rrc_ul_cctrch_params = src_config->rrc_ul_cctrch_params;


  /* Copy local data structures that may be pointed to by L1/MAC structures */
  for(i=0; i<UE_MAX_TFC; i++)
  {
    dest_config->ctfc_info[i] = src_config->ctfc_info[i];
  }

  dest_config->dl_ctfc = src_config->dl_ctfc;

  if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
  {
    for(i=0; i<UE_MAX_MAC_D_FLOW; i++)
    {
      dest_config->mac_dflow_info[i] = src_config->mac_dflow_info[i];
      dest_config->dl_dflow_index_in_use[i] = src_config->dl_dflow_index_in_use[i];
    }
  }

  for(i=0; i< UE_MAX_HS_QUEUE; i++)
  {
    dest_config->mac_ehs_queue_info[i] = src_config->mac_ehs_queue_info[i];
    dest_config->mac_ehs_queue_index_in_use[i] = src_config->mac_ehs_queue_index_in_use[i];
  }
  
  for(i=0; i< UE_MAX_DL_LOGICAL_CHANNEL; i++)
  {
    dest_config->dl_macehs_logchan_info[i] = src_config->dl_macehs_logchan_info[i];
    dest_config->mac_ehs_lc_id_in_use[i] = src_config->mac_ehs_lc_id_in_use[i];
#ifdef FEATURE_WCDMA_HS_FACH
    dest_config->efach_dl_logchan_info[i] = src_config->efach_dl_logchan_info[i];
    dest_config->efach_dl_lc_id_in_use[i] = src_config->efach_dl_lc_id_in_use[i];
#endif
  }


  dest_config->mac_e_config = src_config->mac_e_config;

  dest_config->l1_e_info.e_ul_info.e_tti = 
   src_config->l1_e_info.e_ul_info.e_tti;

  dest_config->l1_e_info.e_dl_info.e_tti = 
   src_config->l1_e_info.e_dl_info.e_tti;

  dest_config->l1_e_info.e_ul_info.harq_rv_config = 
   src_config->l1_e_info.e_ul_info.harq_rv_config;



#ifdef FEATURE_WCDMA_DC_HSUPA
    dest_config->mac_sec_eul_config = src_config->mac_sec_eul_config;
#endif /* FEATURE_WCDMA_DC_HSUPA */


  for(i=0; i<UE_MAX_TRCH; i++)
  {
    dest_config->dl_dch_info[i] = src_config->dl_dch_info[i];
    dest_config->dl_dch_trch_idx_in_use[i] = src_config->dl_dch_trch_idx_in_use[i];
    dest_config->dl_dch_trch_info[i] = src_config->dl_dch_trch_info[i];
    for(j=0; j<MAX_TF; j++)
    {
      dest_config->dl_tf_info[i][j] = src_config->dl_tf_info[i][j];
    }
    dest_config->dl_trch_info[i] = src_config->dl_trch_info[i];
    dest_config->rrc_ul_cctrch_params.semi_static_parms[i] = 
            src_config->rrc_ul_cctrch_params.semi_static_parms[i];
    dest_config->ul_dch_trch_idx_in_use[i] = src_config->ul_dch_trch_idx_in_use[i];
    dest_config->ul_dch_trch_info[i] = src_config->ul_dch_trch_info[i];
  }

  dest_config->dl_trch_cnt = src_config->dl_trch_cnt;
  dest_config->ul_trch_cnt = src_config->ul_trch_cnt;

  dest_config->ul_cctrch = src_config->ul_cctrch;
  dest_config->ul_tfcs = src_config->ul_tfcs;


  for(i=0; i<L1_UL_TFC_MAX; i++)
  {
    dest_config->rrc_ul_cctrch_params.gain_factor_parms[i] =
            src_config->rrc_ul_cctrch_params.gain_factor_parms[i];
  }

  dest_config->reconfig_needed.downlink_l1 = TRUE;
  dest_config->reconfig_needed.uplink_l1 = TRUE;
  dest_config->reconfig_needed.downlink_mac = TRUE;
  dest_config->reconfig_needed.uplink_mac = TRUE;

  dest_config->rrc_state_indicator = RRC_STATE_CELL_DCH;

  dest_config->num_removed_tfcis = 0;

  /* Initialize all pointers in L1, MAC and RLC structures */
  rrcllc_init_mac_dl_ptrs(dest_config);
  rrcllc_init_mac_ul_ptrs(dest_config);
  rrcllc_init_l1_dl_ptrs(dest_config);
  rrcllc_init_l1_ul_ptrs(dest_config);
  rrcllc_init_rlc_ptrs(dest_config);

} /* rrcllc_copy_trch_info */

/*====================================================================
FUNCTION: rrcllc_update_oc_from_fach_to_dch()

DESCRIPTION:
  This function is responsible for updating the Ordered Config when
  transitioning from Cell_FACH to Cell_DCH state.

DEPENDENCIES:
  None

RETURN VALUE:
  rrcllc_oc_status_e_type

SIDE EFFECTS:
  None.
====================================================================*/
rrcllc_oc_status_e_type
rrcllc_update_oc_from_fach_to_dch(
  uint32            dl_sdu_num,
  void             *msg_ptr
)
{
  uint8 ix = 0;
  ordered_config_ptr->l1_e_info.e_ul_info.e_tti = 
          current_config_ptr->l1_e_info.e_ul_info.e_tti;
  ordered_config_ptr->l1_e_info.e_dl_info.e_tti = 
          current_config_ptr->l1_e_info.e_dl_info.e_tti;

  /* Initialize Ordered Config */
  rrcllc_init_config_data(ordered_config_ptr, RRC_STATE_CELL_DCH);
#ifdef FEATURE_WCDMA_HS_RACH
  /*Initialise HSRACH structures while going to DCH state*/
  rrcllc_init_hsrach_info(ordered_config_ptr,RRC_STATE_CELL_DCH);
#endif

#ifdef FEATURE_WCDMA_HS_FACH
    if(rrcllc_get_hs_status_in_e_fach(current_config_ptr) == TRUE)
    {
    WRRC_MSG2_HIGH("EFACH:Copy hs cctrch_id[oc=%d,cc=%d] from CC",
        ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.cctrch_id,
      current_config_ptr->l1_hsdpa_info.hs_dsch_info.cctrch_id);

      ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.cctrch_id =
        current_config_ptr->l1_hsdpa_info.hs_dsch_info.cctrch_id;
    }
  

#endif

  /* Check if Serving BCCH is up */
  if( (rrclcm_check_dl_rlc_lc_id( UE_LOGCHAN_BCCH,
                                  BCCH_S_RADIO_BEARER_ID,
                                  UE_MODE_TRANSPARENT ))
       != RRCLCM_RLC_LC_ID_NOT_FOUND )
  {
    /* S-BCCH is up. Increment the number of DL TM channelsu by 1 */
    MSG_MED("S-BCCH up for the cell", 0, 0, 0);
    ordered_config_ptr->rlc_dl_tm_parms.nchan++;
  }

  /* Check if Neighbor BCCH is up */
  if( (rrclcm_check_dl_rlc_lc_id( UE_LOGCHAN_BCCH,
                                  BCCH_N_RADIO_BEARER_ID,
                                  UE_MODE_TRANSPARENT ))
       != RRCLCM_RLC_LC_ID_NOT_FOUND )
  {
    /* N-BCCH is up. Increment the number of DL TM channels by 1 */
    MSG_MED("N-BCCH up", 0, 0, 0);
    ordered_config_ptr->rlc_dl_tm_parms.nchan++;
  }

#ifdef FEATURE_UMTS_PDCP
  rrcllc_copy_pdcp_parms(ordered_config_ptr, current_config_ptr);
#endif /* FEATURE_UMTS_PDCP*/


  /* Copy RLC size restrictions for FACH from CC to OC */
  /* The "RLC size list" within "RLC size restrictions" should be cleared first */

  /* Copy RLC Info from Current Config */
  rrcllc_copy_rlc_parms(ordered_config_ptr, current_config_ptr);

  /* Copy Cell FACH RB Mapping Info from Current to Ordered Config. This
   * will be needed on subsequent transitions between CELL_DCH and CELL_FACH
   */
  rrcllc_copy_cell_fach_rb_mapping_info(ordered_config_ptr, current_config_ptr);

  /* Copy all TrCH related data from TOC to OC if TOC is valid */
  if(transition_config.toc_usage != TOC_INVALID)
  {
    rrcllc_copy_trch_info(ordered_config_ptr, transition_config.toc_ptr);
    rrcllc_copy_srb5_info(ordered_config_ptr, transition_config.toc_ptr);
    if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
    {
      /* Copy HARQ Information to L1 */
      rrcllc_copy_harq_info(ordered_config_ptr, transition_config.toc_ptr);
    }
    /* Copy CM params from TOC to OC */
    for (ix = 0 ; ix < L1_CM_MAX_TGP_SEQ_COUNT; ix++)
    {
      ordered_config_ptr->tgp_seq_info[ix] = transition_config.toc_ptr->tgp_seq_info[ix];
      ordered_config_ptr->cm_info.action_needed[ix] = transition_config.toc_ptr->cm_info.action_needed[ix];
    }
    ordered_config_ptr->cm_info.tgp_seq_info_count = transition_config.toc_ptr->cm_info.tgp_seq_info_count;
  }

  /* Copy U-RNTI from Current Config to Ordered Config. Note that C-RNTI
   * is not applicable in CELL_DCH, and so is not copied.
   */
  if((current_config_ptr->mac_dl_parms.rnti_info.rnti_valid == URNTI_VALID) ||
     (current_config_ptr->mac_dl_parms.rnti_info.rnti_valid == BOTH_VALID))
  {
    ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = URNTI_VALID;
    ordered_config_ptr->mac_dl_parms.rnti_info.urnti =
      current_config_ptr->mac_dl_parms.rnti_info.urnti;
  }
  else
  {
    ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
    WRRC_MSG0_ERROR("No URNTI FACH->DCH");
  }

  if((current_config_ptr->mac_ul_parms.rnti_info.rnti_valid == URNTI_VALID) ||
     (current_config_ptr->mac_ul_parms.rnti_info.rnti_valid == BOTH_VALID))
  {
    ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = URNTI_VALID;
    ordered_config_ptr->mac_ul_parms.rnti_info.urnti =
      current_config_ptr->mac_ul_parms.rnti_info.urnti;
  }
  else
  {
    ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
    WRRC_MSG0_ERROR("No URNTI FACH->DCH");
  }
#ifdef FEATURE_WCDMA_HS_FACH
  
  if(current_config_ptr->efach_hrnti_status == DEDICATED_HRNTI)
  {
    ordered_config_ptr->hrnti_status = HRNTI_VALID;
    ordered_config_ptr->hrnti = ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.h_rnti = current_config_ptr->efach_hrnti;
    WRRC_MSG1_MED("EFACH: Updated HRNTI in OC, FACH->DCH Transition %d",ordered_config_ptr->hrnti);
    //Do we need to restore EFACH HRNTI bit mask 
    /*TODO: someplace we need to clear hrnti othewise we may end up using it after R99 to EFACH*/
  }
#endif

#ifdef FEATURE_WCDMA_HS_RACH
    /* From OC new structure enrnti into old structure if valid   */
    if(current_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present)
    {
   ordered_config_ptr->l1_e_info.e_dl_info.primary_e_rnti_present = 
     current_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present;

   ordered_config_ptr->l1_e_info.e_dl_info.primary_e_rnti = 
    current_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti;
    }

   ordered_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = FALSE;
#endif
  /* Copy RLC size restrictions for DCH from TOC to OC
   * if TOC is not invalid
   */
  /* Copy RLC Size Info list from Current Config - Current
   * Config has the latest.
   */
  rrcllc_copy_cell_fach_rlc_size_list(ordered_config_ptr,
                                      current_config_ptr);
#ifdef FEATURE_RRC_TFC_RLC_SIZE_FOR_DCH
  rrcllc_init_dch_logical_channel_lists(ordered_config_ptr);
#endif  /* #ifdef FEATURE_RRC_TFC_RLC_SIZE_FOR_DCH */


  /* Now Ordered Config is in a state where it can be updated
   * with Message Contents.
   */
  rrcllc_init_reestablish_entity(ORDERED_CONFIG_ONLY);

  if(rrcllc_copy_msg_ie_to_oc(dl_sdu_num, msg_ptr) == SUCCESS)
  {
    /* Copy OC back to CC. This is so as to keep MAC and L1 in
     * sync. Once the RRC-MAC-L1 interface is fixed for all
     * out-of-sync scenarios, this must go away. This is TBD
     */

    WRRC_MSG0_MED("OC updated for FACH->DCH");

    /* Ordered Config now set */
    ordered_config.set_status = OC_SET_FOR_CELL_DCH;


    return (ORDERED_CONFIG_SET);
  }
  else
  {
    WRRC_MSG0_HIGH("OC update failed for FACH->DCH");

    /* Ordered Config NOT set */
    ordered_config.set_status = OC_NOT_SET;
    ordered_config.reconfig_in_progress = FALSE;
    return (ORDERED_CONFIG_CONFIGURATION_INVALID);
  }
}


/*====================================================================
FUNCTION: rrcllc_update_oc_in_fach_with_msg()

DESCRIPTION:
  This function is responsible for updating the Ordered Config when
  in Cell_FACH state.
  It starts with copying Current Config to Ordered Config and then
  updating Ordered Config data with Message IEs.
  In the event of a failure, the Ordered Config data is
  reverted back to Current Config data and a NOT_SUPPORTED
  status is returned.
  On successful updation, ordered_config.set_status is set to TRUE.

DEPENDENCIES:
  None

RETURN VALUE:
  rrcllc_oc_status_e_type

SIDE EFFECTS:
  None.
====================================================================*/
rrcllc_oc_status_e_type
rrcllc_update_oc_in_fach_with_msg(
  uint32            dl_sdu_num,
  void             *msg_ptr
)
{
  /* Start with copying Current Config to Ordered Config */
  rrcllc_copy_cc_to_oc();

  rrcllc_init_reestablish_entity(ORDERED_CONFIG_ONLY);

  if(rrcllc_copy_msg_ie_to_oc(dl_sdu_num, msg_ptr) == SUCCESS)
  {
    WRRC_MSG0_MED("ORDERED_CONFIG updated for CELL_FACH");

    /* Ordered Config now set */
    ordered_config.set_status = OC_SET_FOR_CELL_FACH;

    return (ORDERED_CONFIG_SET);
  }
  else
  {
    WRRC_MSG0_HIGH("ORDERED_CONFIG update failed for CELL_FACH");

    /* Ordered Config NOT set */
    ordered_config.set_status = OC_NOT_SET;
    ordered_config.reconfig_in_progress = FALSE;


    return (ORDERED_CONFIG_CONFIGURATION_INVALID);
  }
}  /* rrcllc_update_oc_in_fach_with_msg */

#ifdef FEATURE_UMTS_PDCP

/*====================================================================
FUNCTION: rrcllc_copy_pdcp_parms()

DESCRIPTION:
  This function is responsible for copying the PDCP
  parms from Source to Destination Config data.

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_copy_pdcp_parms
(
  ordered_config_type  *dest_config,
  ordered_config_type  *src_config
)
{
  dest_config->pdcp_parms = src_config->pdcp_parms;
}
#endif /* FEATURE_UMTS_PDCP */



/*====================================================================
FUNCTION: rrcllc_copy_rlc_parms()

DESCRIPTION:
  This function is responsible for copying the RLC AM, UM and TM
  parms from Source to Destination Config data.

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_copy_rlc_parms(
  ordered_config_type  *dest_config,
  ordered_config_type  *src_config
  )
{
  uint32  i;
  /* Copy RLC AM Parameter Info from Source to Destination */
  dest_config->rlc_am_parms = src_config->rlc_am_parms;
  WCDMA_MEMCPY(dest_config->rb_am_rlc_size_ota,
               sizeof(rrc_rb_dl_am_rlc_size_info) * UE_MAX_AM_ENTITY,
               src_config->rb_am_rlc_size_ota,
               sizeof(rrc_rb_dl_am_rlc_size_info) * UE_MAX_AM_ENTITY);
  
  for(i = 0; i < UE_MAX_AM_ENTITY; i ++)
  {
    /* Copy AM Config Info from Source to Destination */
    dest_config->am_config[i] = src_config->am_config[i];
    /* Re-init destination AM Config pointers */
    dest_config->rlc_am_parms.am_info[i] = &dest_config->am_config[i];
  }

  /* Copy DL TM Config Info */
  dest_config->rlc_dl_tm_parms = src_config->rlc_dl_tm_parms;
  /* Copy DL UM Config Info */
  dest_config->rlc_dl_um_parms = src_config->rlc_dl_um_parms;
  /* Copy UL TM Config Info */
  dest_config->rlc_ul_tm_parms = src_config->rlc_ul_tm_parms;
  /* Copy UL UM Config Info */
  dest_config->rlc_ul_um_parms = src_config->rlc_ul_um_parms;

  rrcllc_init_rlc_ptrs(dest_config);
  return;
} /* rrcllc_copy_rlc_parms */

#ifdef FEATURE_WCDMA_HS_FACH
/*====================================================================
FUNCTION: rrcllc_copy_cell_fach_rb_mapping_info()

DESCRIPTION:
  This function is responsible for copying all RB Mapping Info stored
  for CELL_FACH state in the Source Config, to the RB Mapping Info for
  RACH in the Destination Config.

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
void  rrcllc_copy_cell_rach_rb_mapping_info(
  ordered_config_type  *dest_config,
  ordered_config_type  *src_config
  )
{
  uint32  j;

  /* Copy number of UL Dedicated logical channels on RACH */
  dest_config->mac_ul_parms.cctrch_ptr->rach_info.ndlchan =
    src_config->cell_fach_rb_mapping_info.ul_ndlchan;

  /* Copy mapping info for UL dedicated logical channels */
  for ( j = 0; j < MAX_DED_LOGCHAN_PER_TRCH; j ++ )
  {
    dest_config->mac_ul_parms.cctrch_ptr->rach_info.dlchan_info[j] =
      src_config->cell_fach_rb_mapping_info.ul_dlchan_info[j];
  }

  /* Finally copy Cell FACH RB Mapping INfo from Source to Destination */
  dest_config->cell_fach_rb_mapping_info = src_config->cell_fach_rb_mapping_info;

} /* rrcllc_copy_cell_fach_rb_mapping_info */



/*====================================================================
FUNCTION: rrcllc_check_for_macehs_hsrach_mapping()

DESCRIPTION:


DEPENDENCIES:
  None.

RETURN VALUE:
  True/False.

SIDE EFFECTS:
  None.
====================================================================*/
boolean rrcllc_check_for_efach_mapping
(
  ordered_config_type *config_ptr,
  rb_id_type rb_id
)
{
  return TRUE;

}



#endif

/*====================================================================
FUNCTION: rrcllc_copy_cell_fach_rb_mapping_info()

DESCRIPTION:
  This function is responsible for copying all RB Mapping Info stored
  for CELL_FACH state in the Source Config, to the RB Mapping Info for
  FACH and RACH in the Destination Config.

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
void  rrcllc_copy_cell_fach_rb_mapping_info(
  ordered_config_type  *dest_config,
  ordered_config_type  *src_config
  )
{
  uint32  i;
  uint32  j;

  /* Copy for all FACHes */
  for( i = 0; i < UE_MAX_TRCH; i ++)
  {
    /* Copy number of DL DEdicated logical channels on FACH */
    dest_config->fach_info[i].ndlchan = src_config->cell_fach_rb_mapping_info.dl_ndlchan;
    for ( j = 0; j < MAX_DED_LOGCHAN_PER_TRCH; j ++ )
    {
      /* Copy mapping info for DL dedicated logical channels */
      dest_config->fach_info[i].dlchan_info[j] =
        src_config->cell_fach_rb_mapping_info.dl_dlchan_info[j];
    }
  }

  /* Copy number of UL Dedicated logical channels on RACH */
  dest_config->mac_ul_parms.cctrch_ptr->rach_info.ndlchan =
    src_config->cell_fach_rb_mapping_info.ul_ndlchan;

  /* Copy mapping info for UL dedicated logical channels */
  for ( j = 0; j < MAX_DED_LOGCHAN_PER_TRCH; j ++ )
  {
    dest_config->mac_ul_parms.cctrch_ptr->rach_info.dlchan_info[j] =
      src_config->cell_fach_rb_mapping_info.ul_dlchan_info[j];
  }

  /* Finally copy Cell FACH RB Mapping INfo from Source to Destination */
  dest_config->cell_fach_rb_mapping_info = src_config->cell_fach_rb_mapping_info;

} /* rrcllc_copy_cell_fach_rb_mapping_info */

/*====================================================================
FUNCTION: rrcllc_copy_cell_fach_rlc_size_list()

DESCRIPTION:
  This function is responsible for copying all RLC Size Restriction Info
  stored for CELL_FACH state in the Source Config, to the RLC Size
  Restriction Info for FACH and RACH in the Destination Config.

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
void  rrcllc_copy_cell_fach_rlc_size_list(
  ordered_config_type  *dest_config,
  ordered_config_type  *src_config
  )
{
  WCDMA_MEMCPY(dest_config->rach_rlc_size_restriction_info.rlc_size_list,
               sizeof(dest_config->rach_rlc_size_restriction_info.rlc_size_list),
               src_config->rach_rlc_size_restriction_info.rlc_size_list,
               sizeof(dest_config->rach_rlc_size_restriction_info.rlc_size_list));
} /* rrcllc_copy_cell_fach_rlc_size_list */



/*====================================================================
FUNCTION: rrcllc_update_oc_for_pch_to_fach_with_toc()

DESCRIPTION:
  This function is responsible for updating OC with TOC parameters
  immediately after transitioning to CELL_FACH.
  The CC is copied to OC and then OC is updated with RLC and RB Mapping
  Info.

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_update_oc_for_pch_to_fach_with_toc(
  void
)
{
  WRRC_MSG1_HIGH("update_oc_for_pch_to_fach_with_toc toc_usage:%d",transition_config.toc_usage);
  ///* Copy all RLC Config data for AM channels */
  //rrcllc_copy_rlc_parms(ordered_config_ptr, transition_config.toc_ptr);
  /* Increment DL UM and UL TM Nchans to accomodate the already
   * existing PCCH.
   */
 // ordered_config_ptr->rlc_dl_tm_parms.nchan ++;

  /* Re-map all channels previously mapped on DCHs to FACHs and PRACH */
  //rrcllc_copy_cell_fach_rb_mapping_info(ordered_config_ptr, transition_config.toc_ptr);


   ordered_config_ptr->rach_rlc_size_restriction_info.mac_update_needed = TRUE;
  /* Copy over the RB-oriented side of RLC size restrictions */
  rrcllc_copy_cell_fach_rlc_size_list(ordered_config_ptr, transition_config.toc_ptr);

  /* Update the MAC layer with the newly copied RLC size restriction info */
  (void)rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, RRC_STATE_CELL_FACH);

  
} /* rrcllc_update_oc_in_fach_with_toc */

/*====================================================================
FUNCTION: rrcllc_update_oc_in_fach_with_toc()

DESCRIPTION:
  This function is responsible for updating OC with TOC parameters
  immediately after transitioning to CELL_FACH.
  The CC is copied to OC and then OC is updated with RLC and RB Mapping
  Info.

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_update_oc_in_fach_with_toc(
  void
)
{
  /* Start with copying CC to OC */
  rrcllc_copy_cc_to_oc();

#ifdef FEATURE_UMTS_PDCP
  /* Copy all pdcp info into TOC */
  rrcllc_print_pdcp_info(transition_config.toc_ptr);
  rrcllc_copy_pdcp_parms(ordered_config_ptr, transition_config.toc_ptr);
#endif /* FEATURE_UMTS_PDCP*/


  /* Copy all RLC Config data for AM channels */
  rrcllc_copy_rlc_parms(ordered_config_ptr, transition_config.toc_ptr);
/* Restore the one-sided flag from TOC to OC */
   WCDMA_MEMCPY(ordered_config_ptr->rlc_one_sided_reest,
               (sizeof(ordered_config_ptr->rlc_one_sided_reest)),
                transition_config.toc_ptr->rlc_one_sided_reest,
                (sizeof(transition_config.toc_ptr->rlc_one_sided_reest)));

  /* Re-map all channels previously mapped on DCHs to FACHs and PRACH */
  rrcllc_copy_cell_fach_rb_mapping_info(ordered_config_ptr, transition_config.toc_ptr);

  /* Also copy the RNTI Info from TOC to OC */
  ordered_config_ptr->mac_ul_parms.rnti_info =
    transition_config.toc_ptr->mac_ul_parms.rnti_info;
  ordered_config_ptr->mac_dl_parms.rnti_info =
    transition_config.toc_ptr->mac_dl_parms.rnti_info;

  if ((transition_config.toc_usage == TOC_FOR_OOS)
      || (transition_config.toc_usage == TOC_FOR_OOS_WITHOUT_DCH_INFO)
      || (transition_config.toc_usage == TOC_FOR_OOS_WITH_DCH_INFO)
      ||(transition_config.toc_usage == TOC_FOR_FACH_AND_PCH  )
      ||(transition_config.toc_usage == TOC_FOR_FACH_AND_PCH_WITH_DCH_INFO )
  ) 
  {
    ordered_config_ptr->rach_rlc_size_restriction_info.mac_update_needed = TRUE;
  }
  /* Copy over the RB-oriented side of RLC size restrictions */
  rrcllc_copy_cell_fach_rlc_size_list(ordered_config_ptr, transition_config.toc_ptr);

  /* Update the MAC layer with the newly copied RLC size restriction info */
  (void)rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, RRC_STATE_CELL_FACH);


#ifdef FEATURE_WCDMA_HS_FACH
  if( (transition_config.toc_usage == TOC_FOR_DCH_AND_FACH)
     ||(transition_config.toc_usage == TOC_FOR_OOS_WITHOUT_DCH_INFO)
     ||(transition_config.toc_usage == TOC_FOR_OOS_WITH_DCH_INFO)
     ||(transition_config.toc_usage == TOC_FOR_FACH_AND_PCH)
     ||(transition_config.toc_usage == TOC_FOR_FACH_AND_PCH_WITH_DCH_INFO)
   )
  {
   /*restore hrnti from TOC to OC after redirection or dch to fach transition*/
    ordered_config_ptr->efach_hrnti = transition_config.toc_ptr->efach_hrnti;
    ordered_config_ptr->efach_hrnti_status = transition_config.toc_ptr->efach_hrnti_status;
    WRRC_MSG1_HIGH("EFACH: Updated HRNTI from TOC to OC %d",ordered_config_ptr->efach_hrnti);

    rrcenhstate_evaluate_efach_and_set_lower_layers_action(ordered_config_ptr,
                                                             RRC_STATE_CELL_FACH,RRC_E_FACH_DEDICATED);
  }

  /*DCH to FACH transition where DCH_FACH cell selection timer expires, set HRNTI status in OC to DEDICATED 
      to make chan_config by procedure pass, functionality wise this is similar to  rrcenhstate_set_hrnti_status_for_transitions() 
      for this specific scneario */
  if((transition_config.toc_usage == TOC_FOR_OOS)&&
     (rrcllc_get_ordered_config_status_wo_f3() == OC_NOT_SET)&&
     (rrcenhstate_camped_cell_supports_e_fach() == TRUE))
  {
    WRRC_MSG0_HIGH("EFACH:DCH_FACH cell selection timer has expired, set OC-HRNTI to DEDICATED_HRNTI to pass configuration by procedure");
    ordered_config_ptr->efach_hrnti_status = DEDICATED_HRNTI;
  }
#endif

  WRRC_MSG0_HIGH("update_oc_in_fach_with_toc");
} /* rrcllc_update_oc_in_fach_with_toc */



/*====================================================================
FUNCTION: rrcllc_update_oc_in_pch_with_toc()

DESCRIPTION:
  This function is responsible for updating OC with TOC parameters
  immediately after transitioning to CELL_PCH or URA_PCH.
  The CC is copied to OC and then OC is updated with RLC info.

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_update_oc_in_pch_with_toc(
  void
)
{
  /* Start with copying CC to OC */
  rrcllc_copy_cc_to_oc();

#ifdef FEATURE_UMTS_PDCP
  /* Copy all pdcp info into TOC */
  rrcllc_print_pdcp_info(transition_config.toc_ptr);
  rrcllc_copy_pdcp_parms(ordered_config_ptr, transition_config.toc_ptr);
#endif /* FEATURE_UMTS_PDCP*/


  /* Copy all RLC Config data for AM channels */
  rrcllc_copy_rlc_parms(ordered_config_ptr, transition_config.toc_ptr);
/* Restore the one-sided flag from TOC */
  WCDMA_MEMCPY(ordered_config_ptr->rlc_one_sided_reest,
               (sizeof(ordered_config_ptr->rlc_one_sided_reest)),
               transition_config.toc_ptr->rlc_one_sided_reest,
               (sizeof(transition_config.toc_ptr->rlc_one_sided_reest)));
  /* Increment DL UM and UL TM Nchans to accomodate the already
   * existing PCCH.
   */
  ordered_config_ptr->rlc_dl_tm_parms.nchan ++;

  /* Re-map all channels previously mapped on DCHs to FACHs and PRACH */
  rrcllc_copy_cell_fach_rb_mapping_info(ordered_config_ptr, transition_config.toc_ptr);

  /* Also copy the RNTI Info from TOC to OC */
  ordered_config_ptr->mac_ul_parms.rnti_info =
    transition_config.toc_ptr->mac_ul_parms.rnti_info;
  ordered_config_ptr->mac_dl_parms.rnti_info =
    transition_config.toc_ptr->mac_dl_parms.rnti_info;

  if ((transition_config.toc_usage == TOC_FOR_OOS)
      || (transition_config.toc_usage == TOC_FOR_OOS_WITHOUT_DCH_INFO)
      || (transition_config.toc_usage == TOC_FOR_OOS_WITH_DCH_INFO)
      || (transition_config.toc_usage == TOC_FOR_FACH_AND_PCH)
      || (transition_config.toc_usage == TOC_FOR_FACH_AND_PCH_WITH_DCH_INFO)

  ) 
  {
    ordered_config_ptr->rach_rlc_size_restriction_info.mac_update_needed = TRUE;
  }

  ordered_config_ptr->utran_drx_cycle_length =  transition_config.toc_ptr->utran_drx_cycle_length;
  /* Copy over the RB-oriented side of RLC size restrictions */
  rrcllc_copy_cell_fach_rlc_size_list(ordered_config_ptr, transition_config.toc_ptr);

  /* Update the MAC layer with the newly copied RLC size restriction info */
  (void)rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, RRC_STATE_CELL_FACH);

#ifdef FEATURE_WCDMA_HS_FACH
  if(transition_config.toc_usage == TOC_FOR_DCH_AND_FACH)
  {
    rrcenhstate_evaluate_efach_and_set_lower_layers_action(ordered_config_ptr,
                                                             ordered_config_ptr->rrc_state_indicator,RRC_E_FACH_DEDICATED);

  }
#endif

  WRRC_MSG0_HIGH("update_oc_in_pch_with_toc");
} /* rrcllc_update_oc_in_pch_with_toc */


/*====================================================================
FUNCTION: rrcllc_init_oc_cc_in_diconnected()

DESCRIPTION:
  This function is responsible for initializing the Ordered Config
  and Current Config in Disconnecting state.

DEPENDENCIES:
  None

RETURN VALUE:
  SUCCESS/FAILURE
  (For now, SUCCESS is always returned)

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type
rrcllc_init_oc_cc_in_diconnected(void)
{
  /* Initialize Ordered Config */
  rrcllc_init_ordered_config_status_and_data(RRC_STATE_DISCONNECTED);
  /* Initialize Current Config */
  rrcllc_init_config_data(current_config_ptr, RRC_STATE_DISCONNECTED);

  return (SUCCESS);
}  /* rrcllc_init_oc_cc_in_diconnected */

/*====================================================================
FUNCTION: rrcllc_copy_sccpch_info_from_sib_to_oc_in_connected_mode()

DESCRIPTION:
  This function is responsible for getting the SCCPCH info from SIB
  and updating of relevant Ordered Config data structures.

DEPENDENCIES:
  None

RETURN VALUE:
  SUCCESS/FAILURE
  (For now, SUCCESS is always returned)

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type
rrcllc_copy_sccpch_info_from_sib_to_oc_in_connected_mode
(
  rrc_state_e_type  curr_rrc_state,
  rrc_state_e_type  next_rrc_state
)
{
  rrc_SysInfoType5    *sib5_ptr = NULL;
  rrc_SysInfoType6    *sib6_ptr = NULL;

  if((next_rrc_state == RRC_STATE_DISCONNECTED) ||
     (next_rrc_state == RRC_STATE_CONNECTING))
  {
    WRRC_MSG1_HIGH("RRC state %d not handled here", next_rrc_state);
    return(FAILURE);
  }

  sib5_ptr = (rrc_SysInfoType5 *)
              rrc_sibdb_return_sib_for_srv_cell(rrc_SIB5);

  if (sib5_ptr == NULL)
  {
     WRRC_MSG0_ERROR("SIB 5 not yet in SIB data base");
     return FAILURE;
  }

  if(sib5_ptr->sib6indicator == TRUE)
  {
    sib6_ptr = (rrc_SysInfoType6 *)
                rrc_sibdb_return_sib_for_srv_cell(rrc_SIB6);
    if(sib6_ptr == NULL)
    {
      WRRC_MSG0_HIGH("SIB6 not present in SIB DB");
    }
  } /* SIB6 is present as per SIB5 */

  /* Before updating with SCCPCH info, initialize all relevant Ordered
   * Config data structures.
   */
  /* Initialize PCH Info */
  rrcllc_init_pch_info(ordered_config_ptr);

  rrcllc_init_fach_info(ordered_config_ptr, FALSE);
  
  /* Initialize L1 SCCPCH Channel Info */
  rrcllc_init_l1_sccpch_chan_info(ordered_config_ptr);
  /* Initialize L1 Downlink CCTrCH Info that includes Transport Format Set */
  rrcllc_init_dl_cctrch_info(ordered_config_ptr);
  /* Initialize Downlink TFCS */
  rrcllc_init_dl_ctfcs(ordered_config_ptr);

    /* Now get the SCCPCH system information */
  if(sib6_ptr)
  {
    if(RRC_CHECK_MSG_TYPE_IE_PTR(sib6_ptr, 
             sCCPCH_SystemInformationListPresent))
    {
      if(verify_sccpch_exists(&sib6_ptr->sCCPCH_SystemInformationList,
                              next_rrc_state)
         == TRUE)
      {
        if(get_sccpch_sys_info(ordered_config_ptr,
                               &sib6_ptr->sCCPCH_SystemInformationList,
                               next_rrc_state,TRUE)
            == FAILURE)
        {
          WRRC_MSG0_ERROR("Failure updating SCCPCH Info");
          return FAILURE;
        }
      } /* SCCPCH with FACH exists in SIB6 */
      else
      {
        if(get_sccpch_sys_info( ordered_config_ptr,
                                &sib5_ptr->sCCPCH_SystemInformationList,
                                next_rrc_state,FALSE)
            == FAILURE)
        {
          WRRC_MSG0_ERROR("Failure updating SCCPCH Info");
          return FAILURE;
        }
      } /* SCCPCH with FACH DOES NOT exist in SIB6 */
    } /* SCCPCH info in SIB6 is present */
    else
    {
      if(get_sccpch_sys_info( ordered_config_ptr,
                              &sib5_ptr->sCCPCH_SystemInformationList,
                              next_rrc_state,FALSE)
          == FAILURE)
      {
        WRRC_MSG0_ERROR("Failure updating SCCPCH Info");
        return FAILURE;
      }
    } /* SCCPCH info in SIB6 not present */
  } /* SIB6 is present */
  else
  {
    if(get_sccpch_sys_info( ordered_config_ptr,
                            &sib5_ptr->sCCPCH_SystemInformationList,
                            next_rrc_state,FALSE)
        == FAILURE)
    {
      WRRC_MSG0_ERROR("Failure updating SCCPCH Info");
      return FAILURE;
    }
  } /* SIB6 is NOT present */

  return(SUCCESS);
}  /* rrcllc_copy_sccpch_info_from_sib_to_oc_in_connected_mode */


/*====================================================================
FUNCTION: rrcllc_copy_sib_to_oc_for_sccpch_with_ctch()

DESCRIPTION:
  This function is responsible for getting the SCCPCH info from SIB
  and updating of relevant Ordered Config data structures.

DEPENDENCIES:
  None

RETURN VALUE:
  SUCCESS/FAILURE
  (For now, SUCCESS is always returned)

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type
rrcllc_copy_sib_to_oc_for_sccpch_with_ctch
(
  rrc_state_e_type  next_rrc_state
)
{
  rrc_SysInfoType5    *sib5_ptr = NULL;
  rrc_SysInfoType6    *sib6_ptr = NULL;

  /* Boolean value to indicate if sib 5 is in use.  If set to false, then
     sib 6 is in use */
  sib5_ptr = (rrc_SysInfoType5 *)
              rrc_sibdb_return_sib_for_srv_cell(rrc_SIB5);

  if (sib5_ptr == NULL)
  {
     WRRC_MSG0_ERROR("SIB 5 not yet in SIB data base");
     return FAILURE;
  }

  if(sib5_ptr->sib6indicator == TRUE)
  {
    sib6_ptr = (rrc_SysInfoType6 *)
                rrc_sibdb_return_sib_for_srv_cell(rrc_SIB6);
    if(sib6_ptr == NULL)
    {
      WRRC_MSG0_HIGH("SIB6 not present in SIB DB");
    }
  } /* SIB6 is present as per SIB5 */

  /* Before updating with SCCPCH info, initialize all relevant Ordered
   * Config data structures.
   */

    /* Now get the SCCPCH system information */
  if(((next_rrc_state == RRC_STATE_CELL_PCH) ||(next_rrc_state == RRC_STATE_URA_PCH)) &&
      (sib6_ptr))
  {
    if(sib6_ptr->m.sCCPCH_SystemInformationListPresent)
    {
      if(verify_sccpch_exists(&sib6_ptr->sCCPCH_SystemInformationList,
                              next_rrc_state)
         == TRUE)
      {
        if((get_sys_info_for_sccpch_with_ctch(ordered_config_ptr,
                               &(sib6_ptr->sCCPCH_SystemInformationList),
                               next_rrc_state)
            == FAILURE) && 
            (get_sys_info_for_sccpch_with_ctch( ordered_config_ptr,
                                &(sib5_ptr->sCCPCH_SystemInformationList),
                                next_rrc_state)
            == FAILURE))
        {
          WRRC_MSG0_ERROR("Failure updating SCCPCH Info from SIB5 and SIB6");
          return FAILURE;
        }
      } /* SCCPCH with FACH exists in SIB6 */
      else
      {
        if(get_sys_info_for_sccpch_with_ctch( ordered_config_ptr,
                                &(sib5_ptr->sCCPCH_SystemInformationList),
                                next_rrc_state)
            == FAILURE)
        {
          WRRC_MSG0_ERROR("Failure updating SCCPCH Info");
          return FAILURE;
        }
      } /* SCCPCH with FACH DOES NOT exist in SIB6 */
    } /* SCCPCH info in SIB6 is present */
    else
    {
      if(get_sys_info_for_sccpch_with_ctch( ordered_config_ptr,
                              &(sib5_ptr->sCCPCH_SystemInformationList),
                              next_rrc_state)
          == FAILURE)
      {
        WRRC_MSG0_ERROR("Failure updating SCCPCH Info");
        return FAILURE;
      }
    } /* SCCPCH info in SIB6 not present */
  } /* SIB6 is present */

  else  /* sib 6 is not present */
  {
    if(get_sys_info_for_sccpch_with_ctch( ordered_config_ptr,
                            &(sib5_ptr->sCCPCH_SystemInformationList),
                            next_rrc_state)
        == FAILURE)
    {
      WRRC_MSG0_ERROR("Failure updating SCCPCH Info");
      return FAILURE;
    }
  } /* SIB6 is NOT present */
  /* Getting CBS related info.  Get the Period of CTCH allocation (N) and
     CBS frame offset (K)  */
  if (next_rrc_state == RRC_STATE_DISCONNECTED || next_rrc_state == RRC_STATE_CELL_PCH ||
      next_rrc_state == RRC_STATE_URA_PCH )
  {
    if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status == RRCLLC_CTCH_ON_DIF_SCCPCH)
    {
      ordered_config_ptr->l1_dl_chan_parms.sccpch[1].cbs_sched.ctch_info_present = TRUE;
      ordered_config_ptr->l1_dl_chan_parms.sccpch[1].cbs_sched.only_ctch_on_sccpch = TRUE;
      /*When UE is in connected mode, it ignores any CTCH info present in SIB6 and only uses info in SIB5*/
      ordered_config_ptr->l1_dl_chan_parms.sccpch[1].cbs_sched.cbs_frame_offset =
        (uint16)sib5_ptr->cbs_DRX_Level1Information.cbs_FrameOffset;
      ordered_config_ptr->l1_dl_chan_parms.sccpch[1].cbs_sched.ctch_allocation_period =
        (uint16)sib5_ptr->cbs_DRX_Level1Information.ctch_AllocationPeriod;
      
    }
  }

  return(SUCCESS);
}  /* rrcllc_copy_sccpch_info_from_sib_to_oc_in_connected_mode */

/*====================================================================
FUNCTION: rrcllc_get_current_crnti_status()

DESCRIPTION:
  This function is responsible for returning the C-RNTI status as it
  exists in the Current Config. If Current Config does not have a valid
  CRNTI but a valid CRNTI exists in Ordered Config, that is understood
  as a valid CRNTI status.

DEPENDENCIES:
  The procedure calling this function should have called either
  set_ordered_config or should have updated C-RNTI thru' RNTI UPDATE REQ
  before a call to this function is made.

RETURN VALUE:
  rrcllc_crnti_status_e_type

SIDE EFFECTS:
  None.
====================================================================*/
rrcllc_crnti_status_e_type
rrcllc_get_current_crnti_status(void)
{
  if ((current_config_ptr->mac_dl_parms.rnti_info.rnti_valid == CRNTI_VALID)||
      (current_config_ptr->mac_dl_parms.rnti_info.rnti_valid == BOTH_VALID))
  {
    MSG_LOW("Valid C-RNTI in CC", 0, 0, 0);
    return C_RNTI_VALID;
  }
  else /* No valid C_RNTI in Current Config */
  {
    if ((ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid == CRNTI_VALID)||
        (ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid == BOTH_VALID))
    {
      MSG_LOW("Valid C-RNTI in OC", 0, 0, 0);
      return C_RNTI_VALID;
    }
    else
    {
      MSG_LOW("No Valid C-RNTI in CC or OC", 0, 0, 0);
      return C_RNTI_NOT_VALID;
    }
  }  /* No valid C_RNTI in Current Config */
} /* rrcllc_get_current_crnti_status */

/*====================================================================
FUNCTION: rrcllc_get_current_urnti()

DESCRIPTION:
  This function is responsible for returning the U-RNTI status as it
  exists in the Current Config. If Current Config does not have a valid
  URNTI, then it return U_RNTI_NOT_PRESENT.

DEPENDENCIES:
  None

RETURN VALUE:
  rrcllc_urnti_status_e_type

SIDE EFFECTS:
  None.
====================================================================*/
rrcllc_urnti_status_e_type
rrcllc_get_current_urnti(uint32* urnti)
{
  if(config_ptr_in_use == ORDERED_CONFIG)
  {
    if ((ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid == URNTI_VALID)||
        (ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid == BOTH_VALID))
    {
      MSG_LOW("U-RNTI present in OC", 0, 0, 0);
      *urnti = ordered_config_ptr->mac_dl_parms.rnti_info.urnti;
      return U_RNTI_PRESENT;
    }
    else /* No valid U_RNTI in Ordered Config */
    {
      WRRC_MSG0_HIGH("U_RNTI is not present in OC");

      return U_RNTI_NOT_PRESENT;
    }  /* No valid U_RNTI in Ordered Config */
  }
  else  /* Ordered Config NOT set */
  {
    if ((current_config_ptr->mac_dl_parms.rnti_info.rnti_valid == URNTI_VALID)||
        (current_config_ptr->mac_dl_parms.rnti_info.rnti_valid == BOTH_VALID))
    {
      MSG_LOW("U-RNTI present in CC", 0, 0, 0);
      *urnti = current_config_ptr->mac_dl_parms.rnti_info.urnti;
      return U_RNTI_PRESENT;
    }
    else /* No valid U_RNTI in Current Config */
    {
      WRRC_MSG0_HIGH("U_RNTI is not present in CC");

      return U_RNTI_NOT_PRESENT;
    }  /* No valid U_RNTI in Current Config */
  }
} /* rrcllc_get_current_urnti */
/*====================================================================
FUNCTION: rrcllc_get_urnti_from_toc()

DESCRIPTION:
  This function is responsible for returning the U-RNTI if present on TOC

DEPENDENCIES:
  None

RETURN VALUE:
  rrcllc_urnti_status_e_type

SIDE EFFECTS:
  None.
====================================================================*/

rrcllc_urnti_status_e_type rrcllc_get_urnti_from_toc(uint32 *urnti)
{
  /* If connection release is received in a race condition where URNTI is absent in OC/CC, check in TOC.
  Race condition: CU is triggered due to RL_FAILURE/OOS but cell selection is not completed yet */
  /* Even if URNTI is absent in TOC, do not ERR FATAL. Connection release will get ignored and CU will be sent after UE camps on. */
  MSG_ERROR("URNTI not present in config ptr in use, trying to get from TOC, TOC usage: %d, rnti_valid: %d, urnti: %d", transition_config.toc_usage, transition_config.toc_ptr->mac_dl_parms.rnti_info.rnti_valid, transition_config.toc_ptr->mac_dl_parms.rnti_info.urnti);
  if((transition_config.toc_usage != TOC_INVALID)&&((transition_config.toc_ptr->mac_dl_parms.rnti_info.rnti_valid == URNTI_VALID) || 
    (transition_config.toc_ptr->mac_dl_parms.rnti_info.rnti_valid == BOTH_VALID)))
  {
    *urnti = transition_config.toc_ptr->mac_dl_parms.rnti_info.urnti;
     return U_RNTI_PRESENT;
  }
  return U_RNTI_NOT_PRESENT;
}

/*====================================================================
FUNCTION: rrcllc_update_oc_for_resel()

DESCRIPTION:
  This function is responsible for updating Ordered Config due to a
  Cell reselection in all RRC states.
  It initializes all SCCPCH Info, CTFCs and L1 CCTrCH Info.
  The PCH info is not initialized so that the PCCH logical channel ID
  could be maintained. In Connecting and Connected modes, FACH
  info is not initialized
  The SCCPCH Info on new cell is read and all
  info is updated. The PCH Transport Channel ID is also updated.

DEPENDENCIES:
  Serving Cell index in SIB should be initialized before calling this
  function. Otherwise this may read SIBs from old cell.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type
rrcllc_update_oc_for_resel
(
  rrc_state_e_type  curr_rrc_state
)
{
  rrc_SysInfoType1    *sib1_ptr = NULL;
  rrc_SysInfoType3    *sib3_ptr = NULL;
  rrc_SysInfoType4    *sib4_ptr = NULL;
  rrc_SysInfoType5    *sib5_ptr = NULL;
  rrc_SysInfoType6    *sib6_ptr = NULL;
  rrc_SysInfoType7    *sib7_ptr = NULL;

   rrc_AdditionalPRACH_TF_and_TFCS_CCCH_List * rrc_additional_prach_TF_list = NULL;
  /* Pointer & counter to loop through the CN System Information List */
  rrc_CN_DomainSysInfoList * cn_ptr = NULL;
  uint8 cn_cnt                    = 0;
  uint32     i;
  uint32     j;

  /* Update ROC only in all cases. */
  /* Before updating with SCCPCH info, initialize all relevant
   * Reselection Config data structures.
   */
  /* Initialize PCH Info */
  rrcllc_init_pch_info(reselection_config_ptr);
  /* Initialize FACH Info */
  if(curr_rrc_state == RRC_STATE_DISCONNECTED)
  {
    rrcllc_init_fach_info(reselection_config_ptr, TRUE);
  }
  else
  {
    /* Do not delete RB Mapping Info in any other RRC state */
    rrcllc_init_fach_info(reselection_config_ptr, FALSE);
  }
  /* Initialize L1 SCCPCH Channel Info */
  rrcllc_init_l1_sccpch_chan_info(reselection_config_ptr);
  /* Initialize L1 Downlink CCTrCH Info that includes Transport Format Set */
  rrcllc_init_dl_cctrch_info(reselection_config_ptr);
  /* Initialize Downlink TFCS */
  rrcllc_init_dl_ctfcs(reselection_config_ptr);

    rrcllc_init_dl_ctfcs_for_sccpch_with_ctch(reselection_config_ptr);

  /************************/
  /* Get SIB 1 data first */
  /************************/
  sib1_ptr = (rrc_SysInfoType1 *)
               rrc_sibdb_return_sib_for_srv_cell(rrc_SIB1);
  if (sib1_ptr == NULL)
  {
     WRRC_MSG0_ERROR("SIB 1 not yet in SIB data base");
     return FAILURE;
  }

  /* Get the CS and PS DRX Cycle Lengths */
  cn_ptr = &sib1_ptr->cn_DomainSysInfoList;

  while((cn_cnt < cn_ptr->n ) && (cn_cnt < UE_MAX_CN_DOMAINS))
  {
    if((cn_ptr->elem[cn_cnt].cn_DRX_CycleLengthCoeff >= RRCLLC_CN_DOMAIN_MIN_DRX_CYCLE_LENGTH) &&
       (cn_ptr->elem[cn_cnt].cn_DRX_CycleLengthCoeff <= RRCLLC_CN_DOMAIN_MAX_DRX_CYCLE_LENGTH))
    {
      switch(cn_ptr->elem[cn_cnt].cn_DomainIdentity)
      {
        case rrc_CN_DomainIdentity_cs_domain:
          reselection_config_ptr->cs_drx_cycle_length =
            (uint32) (1 << cn_ptr->elem[cn_cnt].cn_DRX_CycleLengthCoeff);
          break;
        case rrc_CN_DomainIdentity_ps_domain:
          reselection_config_ptr->ps_drx_cycle_length =
            (uint32) (1 << cn_ptr->elem[cn_cnt].cn_DRX_CycleLengthCoeff);
          break;
        default:
          WRRC_MSG1_ERROR("Invalid CN 0x%x for DRX", cn_ptr->elem[cn_cnt].cn_DomainIdentity);
          return FAILURE;
      } /* end CN Identity switch */
    } /* end drx cycle length check */
    else
    {
      /* A SIB with invalid DRX length coefficient is unacceptable */
      WRRC_MSG2_ERROR("Invalid DRX len value %d, CN domain %d",
          cn_ptr->elem[cn_cnt].cn_DRX_CycleLengthCoeff, cn_cnt);
      return FAILURE;
    }
    /* Next CN Info */
    cn_cnt++;
  } /* end while Core Network Info */


  /* Check to make sure both Core Networks have good DRX info */
  if(reselection_config_ptr->ps_drx_cycle_length == 0)
  {
    /* This indicates PS domain not present */
    if(reselection_config_ptr->cs_drx_cycle_length > 0)
    {
      reselection_config_ptr->ps_drx_cycle_length =
        reselection_config_ptr->cs_drx_cycle_length;
    }
    else
    {
      WRRC_MSG0_ERROR("Both PS and CS DRX info missing");
      return FAILURE;
    }
  }

  if(reselection_config_ptr->cs_drx_cycle_length == 0)
  {
    /* This indicates CS domain not present */
    if(reselection_config_ptr->ps_drx_cycle_length > 0)
    {
      reselection_config_ptr->cs_drx_cycle_length =
        reselection_config_ptr->ps_drx_cycle_length;
    }
    else
    {
      WRRC_MSG0_ERROR("Both PS and CS DRX info missing");
      return FAILURE;
    }
  }

  /* Only T312 and N312 in Idle mode timers and constants are needed
   * by L1. There is no need to read them in Idle mode since they are
   * going to be used only in Connected mode.
   */
  if(rrcllc_get_timers_and_const_in_conn_mode(reselection_config_ptr, sib1_ptr) == FAILURE)
  {
    return(FAILURE);
  }

  /************************/
  /* Get SIB 3 data next  */
  /************************/
  sib3_ptr = (rrc_SysInfoType3 *)
             rrc_sibdb_return_sib_for_srv_cell(rrc_SIB3);
  if (sib3_ptr == NULL)
  {
     WRRC_MSG0_ERROR("SIB 3 not yet in SIB data base");
     return FAILURE;
  }

  if(((curr_rrc_state == RRC_STATE_CELL_FACH) || (curr_rrc_state == RRC_STATE_CELL_PCH) ||
      (curr_rrc_state == RRC_STATE_URA_PCH)) && (sib3_ptr->sib4indicator == TRUE) && 
     ((sib4_ptr = (rrc_SysInfoType4 *) rrc_sibdb_return_sib_for_srv_cell(rrc_SIB4)) != NULL ))
  {
    if((sib4_ptr->cellSelectReselectInfo.maxAllowedUL_TX_Power >= RRCLLC_MIN_ALLOW_UL_TX_PWR) &&
       (sib4_ptr->cellSelectReselectInfo.maxAllowedUL_TX_Power <= RRCLLC_MAX_ALLOW_UL_TX_PWR))
    {
      reselection_config_ptr->l1_ul_chan_parms.max_tx_pwr =
        (int8) sib4_ptr->cellSelectReselectInfo.maxAllowedUL_TX_Power;
      /* Indicate that L1 UL needs to be reconfigured */
      reselection_config_ptr->reconfig_needed.uplink_l1 = TRUE;
    }
    else
    {
      WRRC_MSG1_ERROR("Rcv'd invalid UL TX PWR %d", sib4_ptr->cellSelectReselectInfo.maxAllowedUL_TX_Power);
      return FAILURE;
    }
  } /* If next state == Cell_FACH AND SIB 4 is present */
  else
  {
    if((sib3_ptr->cellSelectReselectInfo.maxAllowedUL_TX_Power >= RRCLLC_MIN_ALLOW_UL_TX_PWR) &&
       (sib3_ptr->cellSelectReselectInfo.maxAllowedUL_TX_Power <= RRCLLC_MAX_ALLOW_UL_TX_PWR)
      )
    {
      reselection_config_ptr->l1_ul_chan_parms.max_tx_pwr =
        (int8) sib3_ptr->cellSelectReselectInfo.maxAllowedUL_TX_Power;
      /* Indicate that L1 UL needs to be reconfigured */
      reselection_config_ptr->reconfig_needed.uplink_l1 = TRUE;
    }
    else
    {
      WRRC_MSG1_ERROR("Rcv'd invalid UL TX PWR %d", sib3_ptr->cellSelectReselectInfo.maxAllowedUL_TX_Power);
      return FAILURE;
    }
  }

  /************************/
  /* Get SIB 7 data next  */
  /************************/
  sib7_ptr = (rrc_SysInfoType7 *)
             rrc_sibdb_return_sib_for_srv_cell(rrc_SIB7);
  if (sib7_ptr == NULL)
  {
     WRRC_MSG0_ERROR("SIB 7 not yet in SIB data base");
     return FAILURE;
  }

  /* Get the UL interference parameter */
  if(RRC_CHECK_COMMON_MSG_TYPE(sib7_ptr->modeSpecificInfo,
  	rrc_SysInfoType7_modeSpecificInfo_fdd))
  {
    if((sib7_ptr->modeSpecificInfo.u.fdd->ul_Interference >=
        RRCLLC_MIN_UL_INTERFERENCE) &&
       (sib7_ptr->modeSpecificInfo.u.fdd->ul_Interference <=
        RRCLLC_MAX_UL_INTERFERENCE))
    {
      reselection_config_ptr->rrc_ul_pwr_init_parms.ul_interference =
       sib7_ptr->modeSpecificInfo.u.fdd->ul_Interference;
    }
    else
    {
      WRRC_MSG1_ERROR("Invalid value %d UL interference",sib7_ptr->modeSpecificInfo.u.fdd->ul_Interference);
      return(FAILURE);
    }
  }
  else
  {
    WRRC_MSG0_ERROR("Cell FDD info absent");
    return FAILURE;
  }

  /************************/
  /* Get SIB 5 data next  */
  /************************/

  sib5_ptr = (rrc_SysInfoType5 *)
             rrc_sibdb_return_sib_for_srv_cell(rrc_SIB5);
  if (sib5_ptr == NULL)
  {
     WRRC_MSG0_ERROR("SIB 5 not yet in SIB data base");
     return FAILURE;
  }
  if(((curr_rrc_state == RRC_STATE_CELL_FACH)|| (curr_rrc_state == RRC_STATE_CELL_PCH) ||
          (curr_rrc_state == RRC_STATE_URA_PCH)) && (sib5_ptr->sib6indicator == TRUE))
  {
    sib6_ptr = (rrc_SysInfoType6 *)
               rrc_sibdb_return_sib_for_srv_cell(rrc_SIB6);
    if (sib6_ptr == NULL)
    {
       /* SIB 6 may not be present. That is acceptable */
       WRRC_MSG0_HIGH("SIB 6 not in SIB data base");
    }
  }

  /* Get the PICH Power offset */
  if(sib6_ptr && ((curr_rrc_state == RRC_STATE_CELL_FACH)|| (curr_rrc_state == RRC_STATE_CELL_PCH) ||
          (curr_rrc_state == RRC_STATE_URA_PCH)))
  {
    if(((int8)sib6_ptr->pich_PowerOffset >= RRCLLC_MIN_PICH_PWR_OFFSET) &&
       ((int8)sib6_ptr->pich_PowerOffset <= RRCLLC_MAX_PICH_PWR_OFFSET))
    {
      reselection_config_ptr->l1_dl_chan_parms.pich.pwr_offset =
        (int8)sib6_ptr->pich_PowerOffset;
      /* Indicate that L1 DL needs to be reconfigured */
      reselection_config_ptr->reconfig_needed.downlink_l1 = TRUE;
      /* Although no new parameters for MAC have been received, MAC
       * still needs to be reconfigured so as to get the new CCTrCH
       * ID whenever Downlink L1 is reconfigured. This is due to the
       * interface requirements.
       */
      reselection_config_ptr->reconfig_needed.downlink_mac = TRUE;
    }
    else
    {
      WRRC_MSG1_ERROR("invalid PICH Power Offset %d", (int8)sib6_ptr->pich_PowerOffset);
      return(FAILURE);
    }
  }
  else
  {
    if(((int8)sib5_ptr->pich_PowerOffset >= RRCLLC_MIN_PICH_PWR_OFFSET) &&
       ((int8)sib5_ptr->pich_PowerOffset <= RRCLLC_MAX_PICH_PWR_OFFSET))
    {
      reselection_config_ptr->l1_dl_chan_parms.pich.pwr_offset =
        (int8)sib5_ptr->pich_PowerOffset;
      /* Indicate that L1 DL needs to be reconfigured */
      reselection_config_ptr->reconfig_needed.downlink_l1 = TRUE;
      /* Although no new parameters for MAC have been received, MAC
       * still needs to be reconfigured so as to get the new CCTrCH
       * ID whenever Downlink L1 is reconfigured. This is due to the
       * interface requirements.
       */
      reselection_config_ptr->reconfig_needed.downlink_mac = TRUE;
    }
    else
    {
      WRRC_MSG1_ERROR("invalid PICH Power Offset %d", (int8)sib5_ptr->pich_PowerOffset);
      return(FAILURE);
    }
  } /* SIB 6 ptr is NULL */

  /* Get the AICH Power offset */
  if(sib6_ptr && ((curr_rrc_state == RRC_STATE_CELL_FACH) || (curr_rrc_state == RRC_STATE_CELL_PCH) ||
          (curr_rrc_state == RRC_STATE_URA_PCH)))
  {
    if(RRC_CHECK_COMMON_MSG_TYPE(sib6_ptr->modeSpecificInfo,
  	rrc_SysInfoType6_modeSpecificInfo_fdd))
    {
      if(((int8) sib6_ptr->modeSpecificInfo.u.fdd->aich_PowerOffset >=
            RRCLLC_MIN_AICH_PWR_OFFSET) &&
         ((int8) sib6_ptr->modeSpecificInfo.u.fdd->aich_PowerOffset <=
            RRCLLC_MAX_AICH_PWR_OFFSET))
      {
        reselection_config_ptr->l1_dl_chan_parms.aich.pwr_offset =
          (int8) sib6_ptr->modeSpecificInfo.u.fdd->aich_PowerOffset;
        /* Indicate that L1 DL needs to be reconfigured */
        reselection_config_ptr->reconfig_needed.downlink_l1 = TRUE;
        /* Although no new parameters for MAC have been received, MAC
         * still needs to be reconfigured so as to get the new CCTrCH
         * ID whenever Downlink L1 is reconfigured. This is due to the
         * interface requirements.
         */
        reselection_config_ptr->reconfig_needed.downlink_mac = TRUE;
      }
      else
      {
        WRRC_MSG1_ERROR("Invalid value %d AICH power offset",
            sib6_ptr->modeSpecificInfo.u.fdd->aich_PowerOffset);
        return(FAILURE);
      }
    }
    else
    {
      WRRC_MSG0_ERROR("Cell FDD info absent");
      return FAILURE;
    }
  }
  else
  {
    if(RRC_CHECK_COMMON_MSG_TYPE(sib5_ptr->modeSpecificInfo,
  	rrc_SysInfoType5_modeSpecificInfo_fdd))
    {
      if(((int8) sib5_ptr->modeSpecificInfo.u.fdd->aich_PowerOffset >=
            RRCLLC_MIN_AICH_PWR_OFFSET) &&
         ((int8) sib5_ptr->modeSpecificInfo.u.fdd->aich_PowerOffset <=
            RRCLLC_MAX_AICH_PWR_OFFSET))
      {
        reselection_config_ptr->l1_dl_chan_parms.aich.pwr_offset =
          (int8) sib5_ptr->modeSpecificInfo.u.fdd->aich_PowerOffset;
        /* Indicate that L1 DL needs to be reconfigured */
        reselection_config_ptr->reconfig_needed.downlink_l1 = TRUE;
        /* Although no new parameters for MAC have been received, MAC
         * still needs to be reconfigured so as to get the new CCTrCH
         * ID whenever Downlink L1 is reconfigured. This is due to the
         * interface requirements.
         */
        reselection_config_ptr->reconfig_needed.downlink_mac = TRUE;
      }
      else
      {
        WRRC_MSG1_ERROR("Invalid value %d AICH power offset",
            sib5_ptr->modeSpecificInfo.u.fdd->aich_PowerOffset);
        return(FAILURE);
      }
    }
    else
    {
      WRRC_MSG0_ERROR("Cell FDD info absent");
      return FAILURE;
    }
  }  /* SIB 6 ptr is NULL */

  /* Check to see if Primary PCCPCH info is present. If so, save it. */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(sib5_ptr,rrc_SysInfoType5,primaryCCPCH_Info))
  {
    /* This information is present */
    /* Note, ORDERED_CONFIG is always filled out for the serving cell */
    // new function call here due to modularization
    // rrcllc_set_pccpch(sib5_ptr->primaryCCPCH_Info.u.fdd.tx_DiversityIndicator);
  }
  /* else this IE is not present */

  /* Now get the PRACH system information */
  if(sib6_ptr && ((curr_rrc_state == RRC_STATE_CELL_FACH) || (curr_rrc_state == RRC_STATE_CELL_PCH) ||
          (curr_rrc_state == RRC_STATE_URA_PCH)))
  {
    if(RRC_MSG_COMMON_BITMASK_IE_PTR(sib6_ptr,rrc_SysInfoType6,prach_SystemInformationList))
    {

     
      if(RRCLLC_SIB6_ADD_PRACH_TF_EXT_PRESENT(sib6_ptr))
      {
        WRRC_MSG0_HIGH("ATF: ATF list is present in SIB6");
        rrc_additional_prach_TF_list = &sib6_ptr->v4b0NonCriticalExtensions.
	v590NonCriticalExtensions.v650nonCriticalExtensions.v690nonCriticalExtensions.
	sysInfoType6_v690ext.additionalPRACH_TF_and_TFCS_CCCH_List;
      }


      if(get_prach_sys_info(reselection_config_ptr, &sib6_ptr->prach_SystemInformationList
             ,rrc_additional_prach_TF_list,TRUE

      ) == FAILURE)
      {
        WRRC_MSG0_ERROR("Failure updating PRACH Info");
        return FAILURE;
      }
    }
    else  /* Read PRACH Info from SIB 5 */
    {
    
      if(RRCLLC_SIB5_ADD_PRACH_TF_EXT_PRESENT(sib5_ptr))
      {
        WRRC_MSG0_HIGH("ATF: ATF list is present in SIB5");
        rrc_additional_prach_TF_list = &sib5_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtensions.v650NonCriticalExtensions.v680NonCriticalExtensions.v690NonCriticalExtensions.sysInfoType5_v690ext.additionalPRACH_TF_and_TFCS_CCCH_List;
      }

      if(get_prach_sys_info(reselection_config_ptr, &sib5_ptr->prach_SystemInformationList
             ,rrc_additional_prach_TF_list,FALSE

      ) == FAILURE)
      {
        WRRC_MSG0_ERROR("Failure updating PRACH Info");
        return FAILURE;
      }
    }
  }
  else
  {
    if(RRCLLC_SIB5_ADD_PRACH_TF_EXT_PRESENT(sib5_ptr))
    {
      WRRC_MSG0_HIGH("ATF: ATF list is present in SIB5");
      rrc_additional_prach_TF_list = &sib5_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtensions.v650NonCriticalExtensions.v680NonCriticalExtensions.v690NonCriticalExtensions.sysInfoType5_v690ext.additionalPRACH_TF_and_TFCS_CCCH_List;
    }

    if(get_prach_sys_info(reselection_config_ptr, &sib5_ptr->prach_SystemInformationList
             ,rrc_additional_prach_TF_list,FALSE
    ) == FAILURE)
    {
      WRRC_MSG0_ERROR("Failure updating PRACH Info");
      return FAILURE;
    }
  }

  (void)rrcllc_populate_mac_rlc_size_restriction_info(reselection_config_ptr,
                                                      reselection_config_ptr->rrc_state_indicator);

#ifdef FEATURE_WCDMA_HS_FACH
    if(curr_rrc_state == RRC_STATE_DISCONNECTED||
       curr_rrc_state == RRC_STATE_CELL_DCH)
    {
      WRRC_MSG0_HIGH("EFACH:Skip HS Config from SIB5");
    }
    else
    {
      if( ( (rrcenhstate_camped_cell_supports_e_fach() == TRUE) && 
          ((curr_rrc_state == RRC_STATE_CELL_FACH)||
          (curr_rrc_state == RRC_STATE_CONNECTING)) ))
      {
        if(FAILURE == rrcenhstate_get_hs_dsch_common_info(reselection_config_ptr, curr_rrc_state, RRC_E_FACH_COMMON))
        {
          ERR_FATAL("ENH STATE: Error updating HSDSCH Common Info", 0, 0, 0);
        }
        else if(rrcllc_check_if_hs_can_be_started_reconfigured_in_e_fach(
                  reselection_config_ptr, rrcllc_cmd_under_process.next_rrc_state,RRC_E_FACH_COMMON) == FALSE)
        {
          ERR_FATAL("ENH STATE:HS start/reconfig failure", 0, 0, 0);
        }
      }
      else
      {
        WRRC_MSG0_HIGH("EFACH:Cell doesn't support E-FACH operation");
      }
      if(rrcenhstate_config_phychan_for_resel(curr_rrc_state) == FAILURE)
      {
        ERR_FATAL("RRCENHST:Configuring phy channels for resel in FACH failed",0,0,0);
      }
    }
#endif
    {

  if(sib6_ptr && ((curr_rrc_state == RRC_STATE_CELL_FACH)|| (curr_rrc_state == RRC_STATE_CELL_PCH) ||
          (curr_rrc_state == RRC_STATE_URA_PCH)))
  {
    if(RRC_CHECK_MSG_TYPE_IE_PTR(sib6_ptr,sCCPCH_SystemInformationListPresent))
    {
      if(verify_sccpch_exists(&sib6_ptr->sCCPCH_SystemInformationList,
                              curr_rrc_state)
         == TRUE)
      {
        if(get_sccpch_sys_info(reselection_config_ptr,
                               &sib6_ptr->sCCPCH_SystemInformationList,
                               curr_rrc_state,TRUE)
           == FAILURE)
        {
          WRRC_MSG0_ERROR("Failure updating SCCPCH Info");
          return FAILURE;
        }
      } /* SCCPCH with FACH present in SIB6 */
      else
      {
        if(get_sccpch_sys_info(reselection_config_ptr,
                               &sib5_ptr->sCCPCH_SystemInformationList,
                               curr_rrc_state,FALSE)
           == FAILURE)
        {
          WRRC_MSG0_ERROR("Failure updating SCCPCH Info");
          return FAILURE;
        }
      } /* SCCPCH with FACH NOT present in SIB6 */
    } /* SCCPCH Info present in SIB6 */
    else /* Read it from SIB5 */
    {
      if(get_sccpch_sys_info(reselection_config_ptr,
                             &sib5_ptr->sCCPCH_SystemInformationList,
                             curr_rrc_state,FALSE)
         == FAILURE)
      {
        WRRC_MSG0_ERROR("Failure updating SCCPCH Info");
        return FAILURE;
      }
    }
  }
  else /* SCCPCH system info in SIB 5 has to be used */
  {
    if(get_sccpch_sys_info(reselection_config_ptr,
                           &sib5_ptr->sCCPCH_SystemInformationList,
                           curr_rrc_state,FALSE)
       == FAILURE)
    {
      WRRC_MSG0_ERROR("Failure updating SCCPCH Info");
      return FAILURE;
    }
  }
  }
#ifdef FEATURE_WCDMA_HS_RACH

  rrchsrach_set_common_edch_transmission(reselection_config_ptr, FALSE);
  rrchsrach_set_ready_for_common_edch(reselection_config_ptr, FALSE);
  rrchsrach_set_hspa_rnti_stored_cell_pch(reselection_config_ptr, FALSE);
  
  /*remove the state check for dch and disconn */
  if(curr_rrc_state == RRC_STATE_DISCONNECTED||
     curr_rrc_state == RRC_STATE_CELL_DCH)
  {
    WRRC_MSG0_HIGH("RRCHSRACH:Skip HS RACH Config from SIB5");
  }
  else
  {
    if((rrchsrach_camped_cell_supports_hsrach() == TRUE) &&
        ((curr_rrc_state == RRC_STATE_CELL_FACH) || (curr_rrc_state == RRC_STATE_CONNECTING)))
    {
      if(FAILURE == rrchsrach_get_edch_rach_info_from_sib5(reselection_config_ptr, 
                                   curr_rrc_state))
      {
         WRRC_MSG0_ERROR("RRCHSRACH: Error updating HSRACH Common Info");
      }
      else
      {
        rrchsrach_set_common_edch_transmission(reselection_config_ptr, TRUE);
        rrchsrach_set_ready_for_common_edch(reselection_config_ptr, TRUE);
        WRRC_MSG1_HIGH("RRCHSRACH:Set edch transmission in OC %d", reselection_config_ptr->hs_status_in_e_fach);    
      }
    }
  }
#endif
  /* Getting CBS related info.  Get the Period of CTCH allocation (N) and
     CBS frame offset (K)  */
  if (curr_rrc_state == RRC_STATE_DISCONNECTED || curr_rrc_state == RRC_STATE_CELL_PCH ||
      curr_rrc_state == RRC_STATE_URA_PCH )
  {
    if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status == RRCLLC_CTCH_WITH_PCCH)
    {
      reselection_config_ptr->l1_dl_chan_parms.sccpch[0].cbs_sched.ctch_info_present = TRUE;
      reselection_config_ptr->l1_dl_chan_parms.sccpch[0].cbs_sched.only_ctch_on_sccpch = FALSE;
      /*When UE is in connected mode, it ignores any CTCH info present in SIB6 and only uses info in SIB5*/
      reselection_config_ptr->l1_dl_chan_parms.sccpch[0].cbs_sched.cbs_frame_offset =
        (uint16)sib5_ptr->cbs_DRX_Level1Information.cbs_FrameOffset;
      reselection_config_ptr->l1_dl_chan_parms.sccpch[0].cbs_sched.ctch_allocation_period =
        (uint16)sib5_ptr->cbs_DRX_Level1Information.ctch_AllocationPeriod;
    }
  }

  /* If this is in Connecting/CELL_FACH/CELL_PCH/URA_PCH state, copy the Mapping
   * info to all available FACHes
   */
  if((curr_rrc_state == RRC_STATE_CONNECTING) ||
     (curr_rrc_state == RRC_STATE_CELL_FACH) ||
   (curr_rrc_state == RRC_STATE_CELL_PCH) ||
   (curr_rrc_state == RRC_STATE_URA_PCH))
  {
    if(reselection_config_ptr->mac_dl_parms.num_fachs > 1)
    {
      for(i = 0; i < ordered_config_ptr->mac_dl_parms.num_fachs; i ++)
      {
        reselection_config_ptr->mac_dl_parms.fach_info[i]->ccch_enable =
          reselection_config_ptr->mac_dl_parms.fach_info[0]->ccch_enable;
        reselection_config_ptr->mac_dl_parms.fach_info[i]->ccch_id =
          reselection_config_ptr->mac_dl_parms.fach_info[0]->ccch_id;
        reselection_config_ptr->mac_dl_parms.fach_info[i]->ndlchan =
          reselection_config_ptr->mac_dl_parms.fach_info[0]->ndlchan;

        for(j = 0; j < MAX_DED_LOGCHAN_PER_TRCH; j ++)
        {
          reselection_config_ptr->mac_dl_parms.fach_info[i]->dlchan_info[j] =
            reselection_config_ptr->mac_dl_parms.fach_info[0]->dlchan_info[j];
        }
        reselection_config_ptr->mac_dl_parms.fach_info[i]->bcch_enable =
          reselection_config_ptr->mac_dl_parms.fach_info[0]->bcch_enable;
        reselection_config_ptr->mac_dl_parms.fach_info[i]->bcch_id =
          reselection_config_ptr->mac_dl_parms.fach_info[0]->bcch_id;
      }
    } /* If number of FACHs > 1 */
  } /* If current state is CELL_FACH or Connecting */

#ifdef FEATURE_WCDMA_FREE_FLOATING_TASK
  if((curr_rrc_state == RRC_STATE_CONNECTING)||
     (curr_rrc_state == RRC_STATE_CELL_FACH))
  {
    REX_ISR_LOCK(&rrc_ul_tx_pwr_mutex);
    rrc_ul_init_pwr.ul_interference = 
       reselection_config_ptr->rrc_ul_pwr_init_parms.ul_interference;
    rrc_ul_init_pwr.primary_cpich_tx_power = reselection_config_ptr->rrc_ul_pwr_init_parms.primary_cpich_tx_power;
    rrc_ul_init_pwr.constant_value = reselection_config_ptr->rrc_ul_pwr_init_parms.constant_value;
    REX_ISR_UNLOCK(&rrc_ul_tx_pwr_mutex);
  }
#endif

  return(SUCCESS);
}  /* rrcllc_update_oc_for_resel */

/*====================================================================
FUNCTION: rrcllc_update_cell_fach_dl_mapping_info_with_log_chl_id()

DESCRIPTION:
  This function updates the Downlink Mapping Info in Cell FACH RB Mapping
  Info with the passed Logical Channel ID.
  The correct entity is selected based on the passed RB ID.
  The Cell FACH RB mapping info in the passed Config data is updated.

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_update_cell_fach_dl_mapping_info_with_log_chl_id
(
  ordered_config_type  *config_ptr,
  rrc_RB_Identity  rb_id,
  rlc_lc_id_type   rlc_dl_log_chl_id
)
{
  int i;
  for(i=0; i<config_ptr->cell_fach_rb_mapping_info.dl_ndlchan; i++)
  {
    if(config_ptr->cell_fach_rb_mapping_info.dl_dlchan_info[i].rb_id == rb_id)
    {
      config_ptr->cell_fach_rb_mapping_info.dl_dlchan_info[i].rlc_id = rlc_dl_log_chl_id;
      break;
    }
  }
}

/*====================================================================
FUNCTION: rrcllc_update_cell_fach_ul_mapping_info_with_log_chl_id()

DESCRIPTION:
  This function updates the Uplink Mapping Info in Cell FACH RB Mapping
  Info with the passed Logical Channel ID.
  The correct entity is selected based on the passed RB ID.
  The Cell FACH RB mapping info in the passed Config data is updated.

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_update_cell_fach_ul_mapping_info_with_log_chl_id
(
  ordered_config_type  *config_ptr,
  rrc_RB_Identity  rb_id,
  rlc_lc_id_type   rlc_ul_log_chl_id
)
{
  int i;
  for(i=0; i<config_ptr->cell_fach_rb_mapping_info.ul_ndlchan; i++)
  {
    if(config_ptr->cell_fach_rb_mapping_info.ul_dlchan_info[i].rb_id == rb_id)
    {
      config_ptr->cell_fach_rb_mapping_info.ul_dlchan_info[i].rlc_id = rlc_ul_log_chl_id;
      break;
    }
  }
}


/*====================================================================
FUNCTION: rrcllc_check_dcch_fach_mapping(ordered_config_type *config_ptr)

DESCRIPTION:
  This function checks whether DCCH mapping on FACH exists in
  ordered config.

DEPENDENCIES:
  None
RETURN VALUE:
  booean
SIDE EFFECTS:
  None.
====================================================================*/
boolean rrcllc_check_dcch_fach_mapping(ordered_config_type *config_ptr)
{
  uint8 dl_srb_count = 0;
  uint8 ul_srb_count = 0;
  uint8 i;

  for(i = 0; i < config_ptr->cell_fach_rb_mapping_info.dl_ndlchan; i++)
  {
    switch(config_ptr->cell_fach_rb_mapping_info.dl_dlchan_info[i].rb_id)
    {
      case DCCH_UM_RADIO_BEARER_ID:
      case DCCH_AM_RADIO_BEARER_ID:
      case DCCH_DT_HIGH_PRI_RADIO_BEARER_ID:
        dl_srb_count++;
        break;
      case DCCH_DT_LOW_PRI_RADIO_BEARER_ID:
        break; /* SRB 4 is optional */
      default:
        break;
    }
  }
  for(i = 0; i < config_ptr->cell_fach_rb_mapping_info.ul_ndlchan; i++)
  {
    switch(config_ptr->cell_fach_rb_mapping_info.ul_dlchan_info[i].rb_id) 
    {
      case DCCH_UM_RADIO_BEARER_ID:
      case DCCH_AM_RADIO_BEARER_ID:
      case DCCH_DT_HIGH_PRI_RADIO_BEARER_ID:
        ul_srb_count++;
        break;
      case DCCH_DT_LOW_PRI_RADIO_BEARER_ID:
        break; /* SRB 4 is optional */
      default:
       break;     
    }
  }

  if((dl_srb_count == 3) && (ul_srb_count == 3))
  {
    WRRC_MSG2_HIGH("DCCH mapping on FACH present dlrb:%d ulrb:%d",
dl_srb_count, ul_srb_count);
    return (TRUE);
  }
  else
  {
#ifdef FEATURE_WCDMA_HS_FACH
    if( rrcenhstate_camped_cell_supports_e_fach() == TRUE)
    {
      WRRC_MSG0_HIGH("EFACH: DCCH mapping on FACH not required");
      return TRUE;
    }
#endif
    /*Atleast one of the mappings for RBs is missing */
    WRRC_MSG2_HIGH("No DCCH mapping on FACH  dlrb:%d ulrb:%d",
dl_srb_count, ul_srb_count);
    return(FALSE);
  }
}

/*====================================================================
FUNCTION: rrcllc_update_oc_for__fach_with_toc_for_rl_failure()

DESCRIPTION:
  This function is responsible for updating OC with TOC parameters
  immediately after transitioning to CELL_FACH.
  The CC is copied to OC and then OC is updated with RLC and RB Mapping
  Info.

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_update_oc_in_fach_with_toc_for_rl_failure(
  void
)
{

#ifdef FEATURE_UMTS_PDCP
  /* Copy all pdcp info into TOC */
  rrcllc_print_pdcp_info(transition_config.toc_ptr);
  rrcllc_copy_pdcp_parms(ordered_config_ptr, transition_config.toc_ptr);
#endif /* FEATURE_UMTS_PDCP*/

  rrcllc_init_reestablish_entity(ORDERED_CONFIG_ONLY);

  /* Copy all RLC Config data for AM channels */
  rrcllc_copy_rlc_parms(ordered_config_ptr, transition_config.toc_ptr);
  /* Increment DL UM and UL TM Nchans to accomodate the already
   * existing CCCH.
   */
  if(get_rlc_dl_um_info(CCCH_RADIO_BEARER_ID, TRUE, ordered_config_ptr) == FAILURE)
  {
    WRRC_MSG0_ERROR("Could not update CCCH RB in OC.");
  }
  
  ordered_config_ptr->rlc_ul_tm_parms.nchan ++;
  WRRC_MSG1_MED("nchan: FACH RLF CCCH up UL TM %d after increment",
      ordered_config_ptr->rlc_ul_tm_parms.nchan);

  /* Re-map all channels previously mapped on DCHs to FACHs and PRACH */
  rrcllc_copy_cell_fach_rb_mapping_info(ordered_config_ptr, transition_config.toc_ptr);

  /* Also copy the RNTI Info from TOC to OC */
  ordered_config_ptr->mac_ul_parms.rnti_info =
    transition_config.toc_ptr->mac_ul_parms.rnti_info;
  ordered_config_ptr->mac_dl_parms.rnti_info =
    transition_config.toc_ptr->mac_dl_parms.rnti_info;

  /* Copy over the RB-oriented side of RLC size restrictions */
  rrcllc_copy_cell_fach_rlc_size_list(ordered_config_ptr, transition_config.toc_ptr);

  /* Update the MAC layer with the newly copied RLC size restriction info */
  (void)rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, RRC_STATE_CELL_FACH);


  rrcllc_copy_srb5_info(ordered_config_ptr, transition_config.toc_ptr);

  rrcllc_copy_oc_to_cc();

  WRRC_MSG0_HIGH("update_oc_in_fach_with_toc_for_rl_failure");

} /* rrcllc_update_oc_in_fach_with_toc_for_rl_failure */

/*====================================================================
FUNCTION: rrcllc_update_cc_in_fach_with_toc_for_oos_ind()

DESCRIPTION:
  This function is responsible for updating CC with TOC parameters
  immediately after transitioning to CELL_FACH.

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_update_cc_in_fach_with_toc_for_oos_ind
(
  void
)
{
#ifdef FEATURE_UMTS_PDCP
  rrcllc_print_pdcp_info(transition_config.toc_ptr);
  rrcllc_copy_pdcp_parms(current_config_ptr, transition_config.toc_ptr);
#endif /* FEATURE_UMTS_PDCP*/

  rrcllc_init_reestablish_entity(CURRENT_CONFIG_ONLY);

  /* Copy all RLC Config data for AM channels */
  rrcllc_copy_rlc_parms(current_config_ptr, transition_config.toc_ptr);

  /* Increment DL UM and UL TM nchans to accomodate the already
   * existing CCCH. */
  if(get_rlc_dl_um_info(CCCH_RADIO_BEARER_ID, TRUE, current_config_ptr) == FAILURE)
  {
    WRRC_MSG0_ERROR("Could not update CCCH RB in CC.");
  }
  
  current_config_ptr->rlc_ul_tm_parms.nchan ++;
  WRRC_MSG1_MED("nchan: FACH RLF CCCH up UL TM %d after increment",
      current_config_ptr->rlc_ul_tm_parms.nchan);

  /*Re-map all channels previously mapped on DCHs to FACHs and PRACH*/
  rrcllc_copy_cell_fach_rb_mapping_info(current_config_ptr, transition_config.toc_ptr);

  /* Also copy the RNTI Info from TOC to CC */
  current_config_ptr->mac_ul_parms.rnti_info = transition_config.toc_ptr->mac_ul_parms.rnti_info;
  current_config_ptr->mac_dl_parms.rnti_info = transition_config.toc_ptr->mac_dl_parms.rnti_info;

  /* Copy over the RB-oriented side of RLC size restrictions */
  rrcllc_copy_cell_fach_rlc_size_list(current_config_ptr, transition_config.toc_ptr);

  /* Update the MAC layer with the newly copied RLC size restriction info */
  (void)rrcllc_populate_mac_rlc_size_restriction_info(current_config_ptr, RRC_STATE_CELL_FACH);

  rrcllc_copy_srb5_info(current_config_ptr, transition_config.toc_ptr);

  WRRC_MSG0_HIGH("rrcllc_update_cc_in_fach_with_toc_for_oos_ind");
  return;
} /* rrcllc_update_oc_in_fach_with_toc_for_rl_failure */

/*====================================================================
FUNCTION: rrcllc_update_toc_ul_dch_info_with_log_chl_id()

DESCRIPTION:
  This function updates the MAC UL Info in TOC with LOgical Channel ID.
  The correct entity is selected based on the passed RB ID.

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
void  rrcllc_update_toc_ul_dch_info_with_log_chl_id
(
  rrc_RB_Identity  rb_id,
  rlc_lc_id_type  rlc_ul_log_chl_id
)
{
  int i, j;
  boolean  log_chl_found = FALSE;

  for(i=0; i<transition_config.toc_ptr->mac_ul_parms.cctrch_ptr->dch_info.ndchs; i++)
  {
    for(j=0; j<transition_config.toc_ptr->mac_ul_parms.cctrch_ptr->dch_info.dch_info[i].ndlchan; j++)
    {
      if(transition_config.toc_ptr->mac_ul_parms.cctrch_ptr->dch_info.dch_info[i].dlchan_info[j].rb_id == rb_id)
      {
        transition_config.toc_ptr->mac_ul_parms.cctrch_ptr->dch_info.dch_info[i].dlchan_info[j].rlc_id = rlc_ul_log_chl_id;
        log_chl_found = TRUE;
        break;
      }
    }

    /* The same logical channel can not be mapped to two TrCHs */
    if(log_chl_found)
    {
      break;
    }
  }

  for(i=0; i < transition_config.toc_ptr->mac_e_config.num_e_mac_d_flow; i++)
  {
    for(j=0; j < transition_config.toc_ptr->mac_e_config.e_mac_d_flow_info[i].num_logch;j++)
    {
      if(transition_config.toc_ptr->mac_e_config.e_mac_d_flow_info[i].e_ul_logch_info[j].rb_id == rb_id)
      {
        transition_config.toc_ptr->mac_e_config.e_mac_d_flow_info[i].e_ul_logch_info[j].rlc_id = rlc_ul_log_chl_id;
        log_chl_found = TRUE;
        break;
      }
    }
    /* The same logical channel can not be mapped to two TrCHs */
    if(log_chl_found)
    {
      break;
    }
  }

}

/*====================================================================
FUNCTION: rrcllc_update_toc_dl_dch_info_with_log_chl_id()

DESCRIPTION:
  This function updates the MAC DL Info in TOC with LOgical Channel ID.
  The correct entity is selected based on the passed RB ID.

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
void  rrcllc_update_toc_dl_dch_info_with_log_chl_id
(
  rrc_RB_Identity  rb_id,
  rlc_lc_id_type  rlc_dl_log_chl_id
)
{
  int i, j;
  boolean  log_chl_found = FALSE;

  for(i=0; i<transition_config.toc_ptr->mac_dl_parms.num_dchs; i++)
  {
    for(j=0; j<transition_config.toc_ptr->mac_dl_parms.dch_info[i]->ndlchan;   j++)
    {
      if(transition_config.toc_ptr->mac_dl_parms.dch_info[i]->dlchan_info[j].rb_id == rb_id)
      {
        transition_config.toc_ptr->mac_dl_parms.dch_info[i]->dlchan_info[j].rlc_id = rlc_dl_log_chl_id;
        log_chl_found = TRUE;
        break;
      }
    }
    /* The same logical channel can not be mapped to two TrCHs */
    if(log_chl_found)
    {
      break;
    }
  } /* for(i=0; i<transition_config.toc_ptr->mac_dl_parms.num_dchs; i++) */

}




/*====================================================================
FUNCTION: rrcllc_modify_cm_info_in_current_config()

DESCRIPTION:
  This function modifies the compressed mode gap sequence structure
  in current config by deleting the tgpsi given by L1 on compressed
  mode run time error indication.

DEPENDENCIES:
  None

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_modify_cm_info_in_current_config
(
  l1_compressed_mode_ind_type* cm_ind_ptr
)
{
  uint8 cnt = 0;
  uint8 stored_cnt = 0;


  /* So TGPSI exists. Need to delete TGPSI from current config. */
  while ((cnt < current_config_ptr->cm_info.tgp_seq_info_count)
         &&(stored_cnt < L1_CM_MAX_TGP_SEQ_COUNT))
  {
    /* Peek at the element */
    if (current_config_ptr->tgp_seq_info[cnt].tgp_seq_id == cm_ind_ptr->tgpsi)
    {
      current_config_ptr->tgp_seq_info[cnt].tgp_seq_id = 0;
      cnt++;
      continue;
    }
    WCDMA_MEMCPY(&tgp_seq_info[stored_cnt], 
                 sizeof(l1_cm_tgp_seq_info_struct_type),
                 &current_config_ptr->tgp_seq_info[cnt],
                 sizeof(l1_cm_tgp_seq_info_struct_type));
    stored_cnt++;
    cnt++;
  }
  /* So the new list is in tgp_seq_info */
  /* Now copy back the same list to current config and adjust the seq cnt */

  current_config_ptr->cm_info.tgp_seq_info_count = stored_cnt;

  cnt = 0;

  while (cnt < current_config_ptr->cm_info.tgp_seq_info_count)
  {
    WCDMA_MEMCPY(&current_config_ptr->tgp_seq_info[cnt], 
                 sizeof(l1_cm_tgp_seq_info_struct_type),
                 &tgp_seq_info[cnt],
                 sizeof(l1_cm_tgp_seq_info_struct_type));
    cnt++;
  }
  return SUCCESS;
}
/*====================================================================
FUNCTION: rrcllc_populate_mac_size_restriction_info()

DESCRIPTION:
  This function validates the information stored in the global
  rlc_size_restriction_info[] array and fills in the appropriate MAC
  data structures in ordered config.

DEPENDENCIES:
  None

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
  MAC ordered config parameters relating to RLC size restriction are
  updated.
====================================================================*/
uecomdef_status_e_type rrcllc_populate_mac_rlc_size_restriction_info
(
  ordered_config_type *config_ptr,
  rrc_state_e_type state
)
{
  tr_ch_id_type idx, max_idx;
  uint8 logch_idx;
  uint16 i, j;
  uint16 tf_idx;
  uint8 trch_idx;
  uint8 ndlchan;
  uint16 prev_size = 0;
  uint8 rlc_size_idx = 1;
  uint8 start_idx = 1;
  uint16 rlc_size = 0;
  boolean is_rach = FALSE;
  uint8 rlc_size_log_idx;

  mac_ul_ded_logch_config_type *dlchan_info;
  rrcllcoc_rlc_size_restriction_info_type *rec;
  rrcllcoc_rlc_size_restriction_info_type *rrc_rlc_size_restriction_info;
  mac_ul_dch_trch_config_type *dch_info;
  mac_ul_rach_cctrch_config_type *rach_info;
  mac_ul_tfs_type *tfs_info;
  mac_ul_rlc_size_info_type *sz_inf;

  switch(state)
  {
    case RRC_STATE_CELL_DCH:
      WRRC_MSG0_MED("RLC size restrictions not supported in DCH");
      return SUCCESS;
#ifdef FEATURE_RRC_TFC_RLC_SIZE_FOR_DCH
      /* In the future, when we support DCH: */
      rrc_rlc_size_restriction_info =
        &(config_ptr->dch_rlc_size_restriction_info[0]);
      max_idx = UE_MAX_TRCH;
      is_rach = FALSE;
#endif
    case RRC_STATE_DISCONNECTED:
    case RRC_STATE_CONNECTING:
    case RRC_STATE_CELL_FACH:
      rrc_rlc_size_restriction_info =
        &config_ptr->rach_rlc_size_restriction_info;
      max_idx = 1;
      is_rach = TRUE;
      break;
    case RRC_STATE_CELL_PCH:
    case RRC_STATE_URA_PCH:
      rrc_rlc_size_restriction_info =
        &config_ptr->rach_rlc_size_restriction_info;
      max_idx = 1;
      is_rach = TRUE;
      break;

    default:
      WRRC_MSG1_ERROR("Unsupported state %d.", config_ptr->rrc_state_indicator);
      return FAILURE;
  }

  for(idx = 0; idx < max_idx; idx++)
  {
    /* We will need the TFS info for this TrCH later in a couple of places. */
    tfs_info = &(config_ptr->mac_ul_parms.tfcs_ptr->tfs_info[idx]);

    rec = &(rrc_rlc_size_restriction_info[idx]);

    if(!rec->mac_update_needed)
    {
      continue;
    }
    rec->mac_update_needed = FALSE;

    switch(state)
    {
      case RRC_STATE_CELL_DCH:
        trch_idx = rrcllc_find_ul_dch_trch_idx(config_ptr, idx);
        if(trch_idx >= UE_MAX_TRCH)
        {
          return FAILURE;
        }
        dch_info =
          &(config_ptr->ul_cctrch.dch_info.dch_info[trch_idx]);
        ndlchan = dch_info->ndlchan;
        dlchan_info = &(dch_info->dlchan_info[0]);
        break;
      case RRC_STATE_DISCONNECTED:
      case RRC_STATE_CONNECTING:
      case RRC_STATE_CELL_FACH:
      case RRC_STATE_CELL_PCH:
      case RRC_STATE_URA_PCH:
        rach_info = &(config_ptr->ul_cctrch.rach_info);
        ndlchan = rach_info->ndlchan;
        dlchan_info = &(rach_info->dlchan_info[0]);
        break;
      default:
        WRRC_MSG1_ERROR("Unsupported state %d.", config_ptr->rrc_state_indicator);
        return FAILURE;
    }

    for(logch_idx = 0; logch_idx < ndlchan; logch_idx++)
    {
      sz_inf = &(dlchan_info[logch_idx].rlc_size_info);
      for(rlc_size_log_idx = 0; rlc_size_log_idx < MAX_DED_LOGCHAN_PER_TRCH ; rlc_size_log_idx++)
      {
        if(rec->rlc_size_list[rlc_size_log_idx].rb_id == dlchan_info[logch_idx].rb_id)
        {
          switch(rec->rlc_size_list[rlc_size_log_idx].restriction_type)
          {
            case RLC_SIZES_CONFIGURED:
              /* Skip this entry for now.  We will process it later as we loop
              through the logical_channel_list in this record. */
              break;
            case RLC_SIZES_ALL:
              for(tf_idx = 0; tf_idx < tfs_info->ntf; tf_idx++)
              {
                /* The Logical Channel List for all TFs in this record must be set
                   to CONFIGURED, since MAC is free to choose any of them. */
                if(rec->logical_channel_list[tf_idx].restriction_type !=
                   RLC_SIZES_CONFIGURED)
                {
                  WRRC_MSG1_ERROR("Bad RLC size restr combo: tf_idx = %d", tf_idx);
                  return FAILURE;
                }
              }
              sz_inf->all_tfi_valid = TRUE;
              sz_inf->ntfi_per_lc = 0;
              break;
            case RLC_SIZES_EXPLICIT_LIST:
              sz_inf->all_tfi_valid = FALSE;
              sz_inf->ntfi_per_lc = 0;

                  for(i = 0; i < rec->rlc_size_list[rlc_size_log_idx].count; i++)
              {
                /* The rec->rlc_size_list[logch_idx].size_idx[] array contains a
                   list of RLC size indices that are valid.  We don't store or use
                   RLC size indices, so these indices must be converted to groups
                   of TF indices instead.  For example:

                   RLC size index     tb_size      ntblks     TF index
                         1              136           1          0
                         1              136           2          1
                         2              360           1          2
                         2              360           2          3

                   If RLC size index 2 were specified in the size_idx[] array, that
                   would mean that TF indices 2 and 3 are valid. */

                /* We must find the starting index in the tf_info array for
                   each RLC size index specified in the record we're
                   processing. */
                    if(rec->rlc_size_list[rlc_size_log_idx].size_idx[i] > 1)
                {
                  prev_size = tfs_info->tf_info[0].tb_size;
                  rlc_size_idx = 1;
                  for(start_idx = 1; ((start_idx < tfs_info->ntf) && 
                     (start_idx < UE_MAX_TF)); start_idx++)
                  {
                    if(prev_size != tfs_info->tf_info[start_idx].tb_size)
                    {
                      prev_size = tfs_info->tf_info[start_idx].tb_size;
                      rlc_size_idx++;
                    }

                        if(rlc_size_idx == rec->rlc_size_list[rlc_size_log_idx].size_idx[i])
                    {
                      /*If ATF is used to send data on DCCH/DTCH then print error.
                        * As the spec allows ATF to be used only for CCCH 
                        */
                      if((state == RRC_STATE_CELL_FACH) ||(state == RRC_STATE_CONNECTING))
                      {
                        if((config_ptr->mac_ul_parms.cctrch_ptr->rach_info.atf_present == TRUE )
                            && (prev_size == 
                          config_ptr->ul_tfcs.tfs_info[0].tf_info[config_ptr->mac_ul_parms.cctrch_ptr->rach_info.atf_ccch_tf_index].tb_size ))
                        {
                          WRRC_MSG0_HIGH("ATF used for DTCH/DCCH ");
                        }
                      }
                      break;
                    }
                  }
                }
                else
                {
                  start_idx = 0;
                }
                if(start_idx < UE_MAX_TF)
                {
                  /* Now that we have the starting index, fill in a sequence of
                     numbers starting with that index and ending with the last
                     TF that's the same size as the one at the start index. */
                  rlc_size = tfs_info->tf_info[start_idx].tb_size;
                  for(j = start_idx; j < tfs_info->ntf; j++)
                  {
                    if (tfs_info->tf_info[j].tb_size != rlc_size)
                    {
                      break;
                    }
      
                    /* Validate the configuration.  The loop index j is counting TF
                       indices, and the logical_channel_list[] entries are stored by
                       TF index.  Therefore, logical_channel_list[j] must have a
                       restriction type of CONFIGURED, since it corresponds to this
                       rlc_size_list[] entry. */
                    if(rec->logical_channel_list[j].restriction_type !=
                       RLC_SIZES_CONFIGURED)
                    {
                      WRRC_MSG1_ERROR("Bad RLC size restr combo: j = %d", j);
                      return FAILURE;
                    }
      
                    sz_inf->lc_tfi_list[sz_inf->ntfi_per_lc++] = j;
                    WRRC_MSG3_MED("RRC_DEBUG: rach tf size %d, ntfi: %d for rb_id: %d", tfs_info->tf_info[j].tb_size,
                       sz_inf->ntfi_per_lc, dlchan_info[logch_idx].rb_id);
                  }
                }
              }

              if(sz_inf->ntfi_per_lc == 0 && !is_rach)
              {
                WRRC_MSG1_ERROR("No valid TF indices found for RLC size index %d", rlc_size_idx);
                return FAILURE;
              }
              break;
            case RLC_SIZES_UNCONFIGURED:
              WRRC_MSG2_HIGH("Unconfigured entry %d in LC list.  ntf = %d", logch_idx,
                       tfs_info->ntf);
              break;
            default:
              WRRC_MSG1_ERROR("Invalid RLC size restr type %d",
                  rec->rlc_size_list[rlc_size_log_idx].restriction_type);
              return FAILURE;
          }
          break;
        }
      }
    }

    /* Now process the Logical Channel List for this record. */
    for(tf_idx = 0; tf_idx < tfs_info->ntf; tf_idx++)
    {
      switch(rec->logical_channel_list[tf_idx].restriction_type)
      {
        case RLC_SIZES_CONFIGURED:
          /* Nothing to do here but validation.  Any actual processing should
             have already been taken care of when we processed the RLC Size
             List. */
          for(logch_idx = 0; logch_idx < ndlchan; logch_idx++)
          {
            if(rec->rlc_size_list[logch_idx].restriction_type ==
               RLC_SIZES_CONFIGURED)
            {
              WRRC_MSG1_ERROR("Bad RLC size restr combo: logch_idx = %d", logch_idx);
              return FAILURE;
            }
          }
          break;
        case RLC_SIZES_ALL:
          /* All logical channels mapped on this transport channel may use
             this tf_idx. */
          for(logch_idx = 0; logch_idx < ndlchan; logch_idx++)
          {
            /* If any of the RLC sizes for this transport channel is set to
               ALL, then all the RLC Size List entries for any logical channel
               mapped onto this transport channel must be set to CONFIGURED. */
            if(rec->rlc_size_list[logch_idx].restriction_type !=
               RLC_SIZES_CONFIGURED)
            {
              WRRC_MSG1_ERROR("Bad RLC size restr combo: logch_idx", logch_idx);
              return FAILURE;
            }

            /* Add this TF index to the list of allowed TF indices for this
               logical channel in the MAC configuration. */
            sz_inf = &(dlchan_info[logch_idx].rlc_size_info);
            if(sz_inf->all_tfi_valid)
            {
              sz_inf->all_tfi_valid = FALSE;
              sz_inf->ntfi_per_lc = 0;
            }
            sz_inf->lc_tfi_list[sz_inf->ntfi_per_lc++] = tf_idx;
          }
          break;
        case RLC_SIZES_EXPLICIT_LIST:
          for(i = 0; i < rec->logical_channel_list[tf_idx].count; i++)
          {
            /* The list we are given is a list of RBs, so we must search
               through the logical channels mapped onto this transport channel
               for the one whose RB id matches. */
            for(logch_idx = 0; logch_idx < ndlchan; logch_idx++)
            {
              if(dlchan_info[logch_idx].rb_id ==
                 rec->logical_channel_list[tf_idx].rb_id[i])
              {
                break;
              }
            }

            /* The value of RLC Size List for this logical channel must be set
               to CONFIGURED. */
            if(rec->rlc_size_list[logch_idx].restriction_type !=
               RLC_SIZES_CONFIGURED)
            {
              WRRC_MSG1_ERROR("Bad RLC size restr combo: logch_idx = %d",
                  logch_idx);
              return FAILURE;
            }

            /* Add this TF index to the list of allowed TF indices for this
               logical channel in the MAC configuration. */
            sz_inf = &(dlchan_info[logch_idx].rlc_size_info);
            if(sz_inf->all_tfi_valid)
            {
              sz_inf->all_tfi_valid = FALSE;
              sz_inf->ntfi_per_lc = 0;
            }
            sz_inf->lc_tfi_list[sz_inf->ntfi_per_lc++] = tf_idx;
            WRRC_MSG2_HIGH("RRC_DEBUG: rach ntfi: %d for rb_id: %d",
                       sz_inf->ntfi_per_lc, dlchan_info[logch_idx].rb_id);
          }
          break;
        case RLC_SIZES_UNCONFIGURED:
          WRRC_MSG2_HIGH("Unconfigured entry %d in LC list.  ntf = %d", tf_idx,
                   tfs_info->ntf);
          break;
        default:
          WRRC_MSG1_ERROR("Invalid RLC size restr type %d",
              rec->logical_channel_list[tf_idx].restriction_type);
          return FAILURE;
      }
    }
  }

  WRRC_MSG2_MED("RACH_DEBUG: tfs_info->ntf %d tti_info %d",tfs_info->ntf,tfs_info->tti_info);
  for(i=0;i<tfs_info->ntf; i++)
  {
    WRRC_MSG4_MED("RACH_DEBUG: Index %d, ntblks %d, tb_size %d tf_flag %d ",
                                          i,tfs_info->tf_info[i].ntblks,
                                          tfs_info->tf_info[i].tb_size,
                                          tfs_info->tf_info[i].tf_flag);
  }


  return SUCCESS;
} /* rrcllc_populate_mac_size_restriction_info */


/*============================================================================
FUNCTION: rrcllc_register_for_reconfig_cnf()

DESCRIPTION:
  This function is called by SMC if Ordered Config is set for reconfiguration.
  This function sets a boolean to notify SMC when the reconfiguration is
  completed.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
=============================================================================*/
void rrcllc_register_for_reconfig_cnf(void)
{
  ordered_config.notify_smc = TRUE;
  return;
}


/*============================================================================
FUNCTION: rrcllc_discard_oc()

DESCRIPTION:
  This function is called to discard the Ordered Config. This in effect
  sets the config_ptr_in_use to CURRENT CONFIG.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
=============================================================================*/
void rrcllc_discard_oc(void)
{
  WRRC_MSG0_HIGH("Discard OC and set config_ptr_in_use to CURRENT_CONFIG ");
  config_ptr_in_use = CURRENT_CONFIG;
}



/*============================================================================
FUNCTION: rrcllc_return_freq_for_fach_pch()

DESCRIPTION:
  This function returns the frequency that UE is directed to when going to
  either one of Cell_FACH, Cell_PCH or URA_PCH

DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE
  FAILURE indicates redirection frequency is NOT available.

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type
rrcllc_return_freq_for_fach_pch(rrc_freq_type  *freq)
{
  /* Return a Failure if Ordered Config NOT set for DCH to FACH
   * OR if Transition Config is somehow invalid.
   */
  if(
     (
      (ordered_config.set_status != OC_SET_FOR_DCH_FACH_TRANS) &&
      (ordered_config.set_status != OC_SET_FOR_DCH_CELL_PCH_TRANS) &&
      (ordered_config.set_status != OC_SET_FOR_DCH_URA_PCH_TRANS)
      &&
      (ordered_config.set_status != OC_SET_FOR_FACH_CELL_PCH_TRANS) &&
      (ordered_config.set_status != OC_SET_FOR_FACH_URA_PCH_TRANS)&&
      (ordered_config.set_status != OC_SET_FOR_CELL_FACH)

     ) ||
     (transition_config.toc_usage == TOC_INVALID))
  {
    WRRC_MSG0_HIGH("No freq to pickup ");
    return(FAILURE);
  }
  else
  {
    /* Check if the the directed frequency info is present in OTA message 
     *in  DCH-> FACH,or FACH->PCH or DCH->PCH or FACH->FACH.
     * This info is present in  TOC */
    if(transition_config.toc_ptr->dest_freq_present == FALSE)
    {
      /* Destination freq not present. Treat the current freq
      as destination frequency*/
      *freq = rrc_ccm_get_curr_camped_freq();
      WRRC_MSG1_HIGH("using current camped freq:%d", *freq);
      return(SUCCESS);
    }
    else
    {
      *freq = transition_config.toc_ptr->dest_freq;
      WRRC_MSG1_HIGH("using freq from msg, freq:%d", *freq);
      return(SUCCESS);
    }
  }
} /* rrcllc_return_freq_for_fach_pch */


/*============================================================================
FUNCTION: rrcllc_return_psc_for_fach_pch()

DESCRIPTION:
  This function returns the Primary Scvrambling Code that UE is directed to
  when going from to either one of Cell_FACH, Cell_PCH or URA_PCH

DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE
  FAILURE indicates redirection PSC is NOT available.

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type
rrcllc_return_psc_for_fach_pch(rrc_scr_code_type  *psc)
{
  /* Return a Failure if Ordered Config NOT set for DCH to FACH */
  if ((ordered_config.set_status != OC_SET_FOR_DCH_FACH_TRANS)&&
      (ordered_config.set_status != OC_SET_FOR_DCH_CELL_PCH_TRANS) &&
      (ordered_config.set_status != OC_SET_FOR_DCH_URA_PCH_TRANS)
      &&
      (ordered_config.set_status != OC_SET_FOR_FACH_CELL_PCH_TRANS) &&
      (ordered_config.set_status != OC_SET_FOR_FACH_URA_PCH_TRANS)&&
      (ordered_config.set_status != OC_SET_FOR_CELL_FACH)

      )
  {
    WRRC_MSG0_HIGH("No PSC to pickup ");
    return(FAILURE);
  }
  else
  {
     /* Check if the the directed PSC is present in OTA message 
      *  in  DCH-> FACH,or FACH->PCH or DCH->PCH or FACH->FACH.
      * This info is present in  TOC 
      */
    if(transition_config.toc_ptr->dest_psc_present == FALSE)
    {
      /* Destination freq not present */
      WRRC_MSG0_HIGH("No PSC in TOC ");
      return(FAILURE);
    }
    else
    {
      *psc = transition_config.toc_ptr->dest_psc;
      WRRC_MSG1_HIGH("PSC in TOC %d ", *psc);
      return(SUCCESS);
    }
  }
} /* rrcllc_return_psc_for_fach_pch */


/*====================================================================
FUNCTION: rrcllc_set_ordered_config_for_rl_failure

DESCRIPTION:
  This is called when the ORDERED_CONFIG variable needs to be set.
  It checks to see whether or not it is set or not, and returns
  the status of the check.

  It also takes a pointer to the asn1 decoded message stream and
  places it into the ordered_config database.

  The procedure name is required so that the message asn1 decoded
  message can be properly typecast so as to populate the
  ORDERED_CONFIG database.

DEPENDENCIES:
  CELL_DCH is the only supported state.

RETURN VALUE:
  rrcllc_oc_status_e_type - indicates whether the ORDERED_CONFIG
                            variable could be successfully set or
                            what the failure was.

SIDE EFFECTS:
  None.
====================================================================*/
rrcllc_oc_status_e_type rrcllc_set_ordered_config_for_rl_failure
(
  /*
  * This variable indicates the PDU number as defined in the ASN.1
  * header file. This information can be used to map the to correct
  * logical channel received on and then down to the message type.
  * The message contents are in msg_ptr, and need to be typecasted.
  */
  rrc_proc_e_type  proc_id
)
{
  rrcllc_oc_status_e_type  oc_status;

  /* Check to see if ORDERED_CONFIG is set */
  if (ordered_config.set_status != OC_NOT_SET)
  {
    WRRC_MSG2_HIGH("Incompatible Simultaneous Reconfig with OC status rrcllc_oc_set_status_e_type_value%d, proc rrc_proc_e_type_value%d",
                ordered_config.set_status, ordered_config.set_by_proc);
    return (ORDERED_CONFIG_INCOMPATABLE_SIMULTANEOUS_RECONFIG);
  }

  /*
  * If made it this far, check the state to determine how to
  * setup ORDERED_CONFIG
  */
    /* This implies Ordered Config is not being used - update the
     * config pointer in use
     */

  rrcllc_init_reestablish_entity(ORDERED_AND_CURRENT_CONFIG);

  current_config_ptr->rrc_state_indicator = RRC_STATE_CELL_FACH;
  rrcllc_copy_cc_to_oc();
#ifdef FEATURE_WCDMA_HS_RACH
  /*Delete ERNTI in both CC,OC and TOC. RL Failure*/
  ordered_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = FALSE;
  current_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = FALSE;
  transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = FALSE;
  /*Will add to reset E-rnti for mac also*/
#endif

  /* Ordered Config now set */
  ordered_config.set_status = OC_SET_FOR_DCH_FACH_TRANS;
  /* Now copy OC to TOC */
  rrcllc_copy_oc_to_toc();
  /* Inducate that TOC could be used both for DCH and FACH in the future */
  transition_config.toc_usage = TOC_FOR_DCH_AND_FACH;
  oc_status = ORDERED_CONFIG_SET;

  /* Update the Procedure ID */
  ordered_config.set_by_proc = proc_id;
  /* Update OC process state */
  ordered_config.process_state = LL_NOT_CONFIG_WITH_OC;
  /* This variable indicates that SMC needs to be notified when
   * a reconfiguration is completed.
  */
  ordered_config.notify_smc = FALSE;

  WRRC_MSG1_HIGH("OC set by proc rrc_proc_e_type_value%d", proc_id);

  return (oc_status);

} /* end rrcllc_set_ordered_config_for_rl_failure() */


/*===========================================================================

FUNCTION rrcllc_update_cm_parms

DESCRIPTION

 Updates CM params in Transition Config during DCH->FACH and DCH->PCH when 
 transition is due to a reconfiguration message to a UTRAN directed cell. 

DEPENDENCIES
 None

RETURN VALUE

 None

SIDE EFFECTS

 None

===========================================================================*/

void rrcllc_update_cm_parms
(
  void
)
{
  uint8 ix = 0;
  uint8 cnt = 0;
  
  WRRC_MSG0_HIGH("Updating TOC for CM info");
  for (ix = 0 ; ix < L1_CM_MAX_TGP_SEQ_COUNT; ix++)
  {
    if(transition_config.toc_ptr->tgp_seq_info[ix].info_valid &&
        transition_config.toc_ptr->tgp_seq_info[ix].tg_meas_purpose == L1_CM_TGMP_WCDMA_INTERF)
    {
      WRRC_MSG1_HIGH("Saving interf pattern id %d",transition_config.toc_ptr->tgp_seq_info[ix].tgp_seq_id);      
      if(ix == cnt)
      {
        transition_config.toc_ptr->tgp_seq_info[cnt].active = FALSE;
        transition_config.toc_ptr->cm_info.action_needed[cnt] = TRUE;
      }
      else
      {
        WCDMA_MEMCPY(&(transition_config.toc_ptr->tgp_seq_info[cnt]),
                     sizeof(current_config_ptr->tgp_seq_info[ix]), 
                     &(transition_config.toc_ptr->tgp_seq_info[ix]),
                     sizeof(current_config_ptr->tgp_seq_info[ix]));
        transition_config.toc_ptr->tgp_seq_info[cnt].active = FALSE; 
        transition_config.toc_ptr->cm_info.action_needed[cnt] = TRUE;  
      } 
      cnt++;
    }
  }
  
  for (ix = cnt ; ix < L1_CM_MAX_TGP_SEQ_COUNT; ix++)
  {  
    memset(&(transition_config.toc_ptr->tgp_seq_info[ix]), 0, sizeof(current_config_ptr->tgp_seq_info[ix]));
    transition_config.toc_ptr->cm_info.action_needed[ix] = FALSE;
  }
  
  transition_config.toc_ptr->cm_info.tgp_seq_info_count = cnt;
  WRRC_MSG1_HIGH("num interf pattern saved %d",transition_config.toc_ptr->cm_info.tgp_seq_info_count);
}

/*===========================================================================

FUNCTION rrcllc_init_rrc_cm_ota_parms

DESCRIPTION

 Initializes the cm_tgpsi_ota_cnt and cm_tgpsi_ota_changed structures

DEPENDENCIES
 None

RETURN VALUE

 None

SIDE EFFECTS

 None

===========================================================================*/

void rrcllc_init_rrc_cm_ota_parms
(
  ordered_config_type *config_ptr
)
{
  
  if(config_ptr == NULL)
  {
    WRRC_MSG0_HIGH("CC/OC/TOC already freed.");
  }
  else
  {
    config_ptr->cm_tgpsi_ota_cnt= 0;
    memset(config_ptr->cm_tgpsi_ota_changed,0,L1_CM_MAX_TGP_SEQ_COUNT*sizeof(uint8));
  }
  return;
}
/*===========================================================================

FUNCTION rrcllc_find_and_deact_cm_pattern

DESCRIPTION

 Checks and deactivates the CM params in config ptr

DEPENDENCIES
 None

RETURN VALUE

 None

SIDE EFFECTS

 None

===========================================================================*/

void rrcllc_find_and_deact_cm_pattern
(
  ordered_config_type *config_ptr
)
{
  uint8 ix = 0,iy=0;
  
  if(config_ptr == NULL)
  {
    WRRC_MSG0_HIGH("CC/OC/TOC already freed.");
  }
  else
  {
    if(config_ptr->cm_tgpsi_ota_cnt== 0)
    {
      for (ix = 0 ; ix < L1_CM_MAX_TGP_SEQ_COUNT; ix++)
      {
        if(config_ptr->tgp_seq_info[ix].active == TRUE)
        {
          config_ptr->cm_info.action_needed[ix] = TRUE;
          config_ptr->tgp_seq_info[ix].active  = FALSE;
        } 
      }
    }
    else
    {
    
      for (ix = 0 ; ix < L1_CM_MAX_TGP_SEQ_COUNT; ix++)
      {
        /*Check and deactivate the TGPSI's which are not given in OTA*/
        if(config_ptr->tgp_seq_info[ix].active == TRUE)
        {

          for(iy=0;iy<config_ptr->cm_tgpsi_ota_cnt;iy++)
          {
            if(config_ptr->tgp_seq_info[ix].tgp_seq_id ==config_ptr->cm_tgpsi_ota_changed[iy])
            {
              break;
            }
          }

          if(iy == config_ptr->cm_tgpsi_ota_cnt)
          {
              WRRC_MSG1_HIGH("Deactivate TGPSI %d  CM pattern",config_ptr->tgp_seq_info[ix].tgp_seq_id);
              config_ptr->tgp_seq_info[ix].active = FALSE;
              config_ptr->cm_info.action_needed[ix] = TRUE;
          }
        }
      }
    }
  }
  return;
}


/*===========================================================================

FUNCTION rrcllc_initialize_cm_parms

DESCRIPTION

 Initializes CM params in Transition Config

DEPENDENCIES
 None

RETURN VALUE

 None

SIDE EFFECTS

 None

===========================================================================*/

void rrcllc_initialize_cm_parms
(
  void
)
{
  uint8 ix = 0;
  if(transition_config.toc_ptr == NULL)
  {
    WRRC_MSG0_HIGH("CC/OC/TOC already freed.");
    
  }
  else
  {
    WRRC_MSG0_HIGH("Initializing TOC for CM info");
    for (ix = 0 ; ix < L1_CM_MAX_TGP_SEQ_COUNT; ix++)
    {
      memset(&(transition_config.toc_ptr->tgp_seq_info[ix]), 0, sizeof(current_config_ptr->tgp_seq_info[ix]));
      transition_config.toc_ptr->cm_info.action_needed[ix] = FALSE;
    }
    transition_config.toc_ptr->cm_info.tgp_seq_info_count = 0;
  }
  return;
}


#ifdef FEATURE_MVS
/*===========================================================================

FUNCTION rrcllc_get_dl_amr_mode

DESCRIPTION

 Given the TB size, this function returns the AMR mode associated with this 
 TB size

DEPENDENCIES
 None

RETURN VALUE

 mvs_amr_mode_type: AMR mode

SIDE EFFECTS

 None

===========================================================================*/
mvs_amr_mode_type rrcllc_get_dl_amr_mode(uint32 tb_size)
{
  mvs_amr_mode_type amr_mode = MVS_AMR_MODE_MAX;

  switch(tb_size)
  {
  case WVS_AMR_MODE_122_CLASS_A_BIT_SIZE:
  case WVS_AMR_MODE_122_CLASS_B_BIT_SIZE:
  case WVS_AMR_MODE_122_CLASS_C_BIT_SIZE:
    amr_mode =  MVS_AMR_MODE_1220;
    break;
 
  case WVS_AMR_MODE_102_CLASS_A_BIT_SIZE:
  case WVS_AMR_MODE_102_CLASS_B_BIT_SIZE:
  case WVS_AMR_MODE_102_CLASS_C_BIT_SIZE:
    amr_mode =  MVS_AMR_MODE_1020;
    break;
  
  case WVS_AMR_MODE_795_CLASS_A_BIT_SIZE:
  case WVS_AMR_MODE_795_CLASS_B_BIT_SIZE:
    amr_mode =  MVS_AMR_MODE_0795;
    break;
   
  case WVS_AMR_MODE_740_CLASS_A_BIT_SIZE:
  case WVS_AMR_MODE_740_CLASS_B_BIT_SIZE:
    amr_mode =  MVS_AMR_MODE_0740;
    break;
  
  case WVS_AMR_MODE_670_CLASS_A_BIT_SIZE:
  case WVS_AMR_MODE_670_CLASS_B_BIT_SIZE:
    amr_mode = MVS_AMR_MODE_0670;
    break;

  case WVS_AMR_MODE_590_CLASS_A_BIT_SIZE:
  case WVS_AMR_MODE_590_CLASS_B_BIT_SIZE:
    amr_mode = MVS_AMR_MODE_0590;
    break;
    
  case WVS_AMR_MODE_515_CLASS_A_BIT_SIZE:
  case WVS_AMR_MODE_515_CLASS_B_BIT_SIZE:
    amr_mode = MVS_AMR_MODE_0515;
    break;

  case WVS_AMR_MODE_475_CLASS_A_BIT_SIZE:
  case WVS_AMR_MODE_475_CLASS_B_BIT_SIZE:
    amr_mode = MVS_AMR_MODE_0475;
    break;

  default:
    amr_mode = MVS_AMR_MODE_MAX;
    break;
  }

  return amr_mode;
} /* rrcllc_get_dl_amr_mode */

/*===========================================================================

FUNCTION rrcllc_get_dl_amr_mode_for_rb

DESCRIPTION

 Given RB Id, returns the AMR mode associated with it

DEPENDENCIES
 None

RETURN VALUE

 mvs_amr_mode_type: AMR mode

SIDE EFFECTS

 None

===========================================================================*/
mvs_amr_mode_type rrcllc_get_dl_amr_mode_for_rb(rrc_RB_Identity  rb_id, ordered_config_type *config_ptr)
{
  uint32 trch_count = 0;
  uint32 dlch_count = 0;
  uint32 index_ctfc = 0;
  uint8 this_trch_tf_in_tfc = 0;
  mvs_amr_mode_type dl_amr_mode = MVS_AMR_MODE_MAX, new_dl_mode = MVS_AMR_MODE_MAX;
  boolean rate_initialised= FALSE;

  for(
      trch_count = 0;
      (trch_count < config_ptr->l1_dl_cctrch_parms.num_trch);
      trch_count ++
     )
  {
    for(
        dlch_count = 0;
        (dlch_count < config_ptr->mac_dl_parms.
                      dch_info[trch_count]->ndlchan);
        dlch_count ++
       )
    {
      if(config_ptr->mac_dl_parms.dch_info[trch_count]->
          dlchan_info[dlch_count].rb_id == rb_id)
      {
        for (index_ctfc = 0;
             ((index_ctfc < config_ptr->dl_ctfc.last_ctfc_entry_index) &&
              (config_ptr->dl_ctfc.last_ctfc_entry_index != RRC_DL_INVALID_CTFC_VALUE));
             index_ctfc++)
        { 
          /* The check against validity of CTFC state is particularly useful where multirate 
             configuration is given but one AMR rate is marked as allowed through
             CTFCs */
          if(config_ptr->dl_ctfc.ctfc_entry_data[index_ctfc].state == ALLOWED)
          {
            this_trch_tf_in_tfc = config_ptr->dl_ctfc.ctfc_entry_data[index_ctfc].tfi_table[trch_count];
            /* Only if no. of TBs is greater than ZERO, we run through CCRTrCH info to get the right TF */
            if((config_ptr->l1_dl_cctrch_parms.trch_info_array[trch_count]->tf_info_array[this_trch_tf_in_tfc]->num_tb > 0) &&
               (config_ptr->l1_dl_cctrch_parms.trch_info_array[trch_count]->tf_info_array[this_trch_tf_in_tfc]->allowed == TRUE))
            {
              new_dl_mode = rrcllc_get_dl_amr_mode(
                  config_ptr->l1_dl_cctrch_parms.trch_info_array[trch_count]->tf_info_array[this_trch_tf_in_tfc]->tb_size);
              
              /* Since the AMR mode enum has high value for INVALID mode,
                 the following logic ensures that right values are picked up
                 after finding first correct AMR mode.
                 At the end of the loop, it is expected that higher mode is
                 chosen in case of multirate AMR configuration.
              */
              if( (new_dl_mode != MVS_AMR_MODE_MAX) &&(rate_initialised == FALSE))
              {
                dl_amr_mode = new_dl_mode;
                rate_initialised = TRUE;
              }
              
              if((new_dl_mode != MVS_AMR_MODE_MAX) && (new_dl_mode > dl_amr_mode))
              {
                dl_amr_mode = new_dl_mode;
                WRRC_MSG1_HIGH("overwriting with=%d",dl_amr_mode);        
              }
            } 
          } 
        }
        return dl_amr_mode; /* No need to iterate as intended RB ID is found */
      }
    } 
  } 
  return dl_amr_mode;
} /* rrcllc_get_dl_amr_mode_for_rb */
#endif /* FEATURE_MVS */



/*===========================================================================

FUNCTION rrcllc_get_cm_hsdpa_nv_item

DESCRIPTION
  This  function gets NV item NV_HSDPA_COMPRESSED_MODE_ENABLED_I and stores it in the global variable

DEPENDENCIES
  None.

RETURN VALUE
  None.

===========================================================================*/
void rrcllc_get_cm_hsdpa_nv_item
(
sys_modem_as_id_e_type wrrc_as_id
)
{
  uint8 nv_hsdpa_cm_enabled;

  /* read HSDPA + CM Variable from NV */
  wnv_get_nv_msim(WNV_ID_HSDPA_COMPRESSED_MODE_ENABLED_I, &nv_hsdpa_cm_enabled, sizeof(nv_hsdpa_cm_enabled), wrrc_as_id);

  if (nv_hsdpa_cm_enabled == FALSE)
  {
    WRRC_MSG0_HIGH("NVHSDPACM disabled");
    hsdpa_cm_enabled = FALSE;
  }
  else
  {
    WRRC_MSG0_HIGH("NVHSDPACM ENABLED");
    hsdpa_cm_enabled = TRUE;
  }
}


/*===========================================================================

FUNCTION rrc_set_hrnti_status

DESCRIPTION

 Sets HRNTI status in the passed pointer

DEPENDENCIES
 None

RETURN VALUE

 None

SIDE EFFECTS

 None

===========================================================================*/

void rrc_set_hrnti_status
(
  ordered_config_type* config_ptr,
  rrc_hsdpa_hrnti_enum_type hrnti_status
)
{
  config_ptr->hrnti_status = hrnti_status;
}

/*===========================================================================

FUNCTION rrc_get_hrnti_status

DESCRIPTION

 Gets HRNTI status from CC

DEPENDENCIES
 None

RETURN VALUE

 None

SIDE EFFECTS

 None

===========================================================================*/
rrc_hsdpa_hrnti_enum_type rrc_get_hrnti_status
(
  void
)
{
  WRRC_MSG1_HIGH("RRCHS:HRNTIstatus is %d", current_config_ptr->hrnti_status);

  return current_config_ptr->hrnti_status;
}


/*===========================================================================

FUNCTION rrc_set_hrnti

DESCRIPTION

 Sets HRNTI in the passed pointer

DEPENDENCIES
 None

RETURN VALUE

 None

SIDE EFFECTS

 None

===========================================================================*/
void rrc_set_hrnti
(
  ordered_config_type* config_ptr,
  uint16 new_hrnti
)
{
  config_ptr->hrnti = new_hrnti;

  WRRC_MSG1_HIGH("RRCHS:HRNTI after setting %d", config_ptr->hrnti);

}


/*===========================================================================

FUNCTION rrc_get_hrnti

DESCRIPTION

 Gets HRNTI from CC

DEPENDENCIES
 None

RETURN VALUE

 None

SIDE EFFECTS

 None

===========================================================================*/

uint16 rrc_get_hrnti
(
  void
)
{
  WRRC_MSG1_HIGH("RRCHS:HRNTI returned %d", current_config_ptr->hrnti);

  return current_config_ptr->hrnti;
}

/*====================================================================
FUNCTION: rrcllc_check_if_rb_mapped_on_dflow()

DESCRIPTION:
  This function checks if a RB is mapped to a DFLOW in the passed
  config ptr.

DEPENDENCIES:
  None

RETURN VALUE:
  TRUE if RB is found to be mapped on a DFLOW else FALSE

SIDE EFFECTS:
  None.
====================================================================*/
boolean rrcllc_check_if_rb_mapped_on_dflow
(
  ordered_config_type  *config_ptr,
  rrc_RB_Identity  rb_id
)
{
  uint8 idx =0, idz =0;

  for (idx = 0; idx < config_ptr->mac_dl_parms.num_dflow; idx++)
  {
    if ((config_ptr->dl_dflow_index_in_use[idx] == TRUE) &&
      (config_ptr->mac_dflow_info[idx].mac_dflow_id != INVALID_DFLOW_ID))
    {

      for(idz = 0; idz < UE_MAX_LOGCHAN_PER_DFLOW; idz++)
      {
        if ((config_ptr->mac_dflow_info[idx].dlchan_info[idz].rb_id == rb_id) &&
          ((config_ptr->mac_dflow_info[idx].dlchan_info[idz].chan_type == UE_LOGCHAN_DTCH) ||
					(config_ptr->mac_dflow_info[idx].dlchan_info[idz].chan_type == UE_LOGCHAN_DCCH)) &&
          (config_ptr->mac_dflow_info[idx].dlchan_info[idz].rlc_mode != UE_MODE_TRANSPARENT))
        {
          WRRC_MSG2_HIGH("RRCHS:Found RB Id %d mapped on DFLOW %d",rb_id,
            config_ptr->mac_dflow_info[idx].mac_dflow_id);
          return TRUE;
        }

      }
    }
  }
  return FALSE;
}

/*====================================================================
FUNCTION: rrcllc_init_reestablish_entity()

DESCRIPTION:
  This function re-initializes Re-establish entity with in OC/CC.

DEPENDENCIES:
  None

RETURN VALUE:
  TRUE if RLC Size Changed

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_reestablish_entity
(
  rrcllc_reestab_config_e_type config_type
)
{
  uint8 ix = 0;
  if(config_type == ORDERED_CONFIG_ONLY )
  {
    for(ix = 0; ix < UE_MAX_AM_ENTITY; ix++)
    {
      ordered_config_ptr->am_config[ix].reestab_entity =  RLC_RE_ESTABLISH_NONE;
#ifdef FEATURE_MAC_I
      ordered_config_ptr->rlc_one_sided_reest[ix] = FALSE;
#endif /* FEATURE_MAC_I */
    }
  }
  else if(config_type == CURRENT_CONFIG_ONLY )
  {
    for(ix = 0; ix < UE_MAX_AM_ENTITY; ix++)
    {
      current_config_ptr->am_config[ix].reestab_entity = RLC_RE_ESTABLISH_NONE;
#ifdef FEATURE_MAC_I
      current_config_ptr->rlc_one_sided_reest[ix] = FALSE;
#endif /* FEATURE_MAC_I */
	  
    }
  }
  else
  {
    for(ix = 0; ix < UE_MAX_AM_ENTITY; ix++)
    {
      ordered_config_ptr->am_config[ix].reestab_entity = 
       current_config_ptr->am_config[ix].reestab_entity = RLC_RE_ESTABLISH_NONE;
#ifdef FEATURE_MAC_I
      ordered_config_ptr->rlc_one_sided_reest[ix]=
      current_config_ptr->rlc_one_sided_reest[ix] = FALSE;
#endif	/* FEATURE_MAC_I */  
    }
  }
  ul_reestab_for_pch_trans = FALSE;
}

/*====================================================================
FUNCTION: rrcllc_compare_rlc_size_change()

DESCRIPTION:
  This function compares the new size with old RLC Size. At present,
  we are comparing with 24 bits. [16 bits URNTI-CRNTI
  difference, 6 bits difference between channel mapping
  i.e CCCH/DCCH/DTCH over FACH. 2 bits difference for C/T field]
  This [24 bits difference comparison] would be removed later. TBD

DEPENDENCIES:
  None

RETURN VALUE:
  TRUE if RLC Size Changed

SIDE EFFECTS:
  None.
====================================================================*/

boolean rrcllc_compare_rlc_size_change(uint32 old_size, uint32 new_size)
{
  if (old_size == new_size)
  {
    return FALSE;
  }
  else if (old_size > new_size)
  {
    /* Check if new size is within 24 bits of the old size */
    if ((old_size - new_size) <= 24)
    {
      return FALSE;
    }
    else
    {
      return TRUE;
    }
  }
  else 
  {
    if ((new_size - old_size) <= 24)
    {
      return FALSE;
    }
    else
    {
      return TRUE;
    }
  }
  
}


/*====================================================================
FUNCTION: rrcllc_update_configs_with_sib7_info_in_fach

DESCRIPTION:
  This is called when the OC/CC/TOC's Uplink interference variable 
  needs to be updated with the latest value received by SIB.

DEPENDENCIES:
  None

RETURN VALUE:
  FAILURE -> If update of SIB7 interference is unsuccessful
  SUCCESS -> Otherwise.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_update_configs_with_sib7_info_in_fach(void)
{
  rrc_SysInfoType7    *sib7_ptr = NULL;
  int uplink_interference;
  uecomdef_status_e_type sib7_updated_in_configs = FAILURE;

  sib7_ptr = (rrc_SysInfoType7 *)
             rrc_sibdb_return_sib_for_srv_cell(rrc_SIB7);
  WRRC_MSG1_HIGH("sib7:Update OC/CC/TOC/ROC's with new values of sib7,ptr=%d",sib7_ptr);

  /* Pull out interference parameter if SIB7 is valid */
  if ((sib7_ptr != NULL) && (RRC_CHECK_COMMON_MSG_TYPE(sib7_ptr->modeSpecificInfo,
  	rrc_SysInfoType7_modeSpecificInfo_fdd)))
  {
    if((sib7_ptr->modeSpecificInfo.u.fdd->ul_Interference >=
        RRCLLC_MIN_UL_INTERFERENCE) &&
       (sib7_ptr->modeSpecificInfo.u.fdd->ul_Interference <=
        RRCLLC_MAX_UL_INTERFERENCE))
    {
      uplink_interference = sib7_ptr->modeSpecificInfo.u.fdd->ul_Interference;
      /* Update all the LLC configuration databases with latest uplink interface */
      current_config_ptr->rrc_ul_pwr_init_parms.ul_interference = uplink_interference;
      ordered_config_ptr->rrc_ul_pwr_init_parms.ul_interference = uplink_interference;
      transition_config.toc_ptr->rrc_ul_pwr_init_parms.ul_interference =uplink_interference;
      
#ifdef FEATURE_WCDMA_FREE_FLOATING_TASK
            REX_ISR_LOCK(&rrc_ul_tx_pwr_mutex);
            rrc_ul_init_pwr.ul_interference = uplink_interference;
            REX_ISR_UNLOCK(&rrc_ul_tx_pwr_mutex);
#endif

      sib7_updated_in_configs = SUCCESS;
    }
  }

  return sib7_updated_in_configs;
} /* rrcllc_update_configs_with_sib7_info_in_fach */

/*====================================================================
FUNCTION: rrcllc_get_dch_fach_act_time_in_ms()

DESCRIPTION:
  This function returns activation time in ms for dch->fach transitions.
  returns 0 if no act time or if this function is called during non dch-fach
  transitions.

DEPENDENCIES:
  None

RETURN VALUE:
  uin16.

SIDE EFFECTS:
  None.
====================================================================*/
uint16 rrcllc_get_dch_fach_act_time_in_ms(void)
{
  uint16 ans = 0;
  uint16 curr_cfn = 0;
  
  if ((OC_SET_FOR_DCH_FACH_TRANS == rrcllc_get_ordered_config_status_wo_f3()) &&
      ((transition_config.toc_ptr->activation_time != RRCLLC_ACTIVATION_TIME_NOW) &&
       (transition_config.toc_ptr->act_time_type == L1_ACTIVATION_TIME_CFN))) 
  {
    curr_cfn = seq_get_cfn();
    /*convert cfn to ms*/ 
    ans = (((256+(transition_config.toc_ptr->activation_time )-(curr_cfn)) & 0xFF) *10);
  }
  return ans;
}

/*====================================================================
FUNCTION: rrcllc_dl_dchs_not_standalone()

DESCRIPTION:
  This function returns TRUE if there's at least one DL DCH TrCH that's not standalone. 
  Essentially, it means that a DL DCH is in use.

DEPENDENCIES:
  None

RETURN VALUE:
  boolean

SIDE EFFECTS:
  None.
====================================================================*/
boolean rrcllc_dl_dchs_not_standalone
(
  void
)
{
  uint32 cnt,trch_idx;

  for(trch_idx=0;trch_idx< UE_MAX_TRCH;trch_idx++)
  {
    if((ordered_config_ptr->dl_dch_trch_info[trch_idx].dch_present) &&
      (ordered_config_ptr->dl_dch_trch_idx_in_use[trch_idx] == TRUE) )
    {
      for (cnt = 0; cnt < ordered_config_ptr->dl_dch_info[trch_idx].ndlchan;cnt++) 
      {      
        if (ordered_config_ptr->dl_dch_info[trch_idx].dlchan_info[cnt].rb_id != 0)
        {
          /* This IE must have already been provided as part of mapping info. Just return success */
          WRRC_MSG1_HIGH("DL Trch mapped to RB %d ",ordered_config_ptr->dl_dch_info[trch_idx].dlchan_info[cnt].rb_id);
          return TRUE;
        }
      }
    }
  }
  return FALSE;
}

/*====================================================================
FUNCTION: rrcllc_ul_dchs_not_standalone()

DESCRIPTION:
  This function returns TRUE if there's at least one UL DCH TrCH that's not standalone. 
  Essentially, it means that a UL DCH is in use.

DEPENDENCIES:
  None

RETURN VALUE:
  boolean

SIDE EFFECTS:
  None.
====================================================================*/
boolean rrcllc_ul_dchs_not_standalone
(
  void
)
{
  uint32 cnt,trch_idx;

  for(trch_idx=0;trch_idx< UE_MAX_TRCH;trch_idx++)
  {
    if((ordered_config_ptr->ul_dch_trch_info[trch_idx].dch_present) &&
        (ordered_config_ptr->ul_dch_trch_idx_in_use[trch_idx] == TRUE))
    {
      for (cnt = 0; cnt < ordered_config_ptr->ul_cctrch.dch_info.dch_info[trch_idx].ndlchan; cnt++) 
      {      
        if (ordered_config_ptr->ul_cctrch.dch_info.dch_info[trch_idx].dlchan_info[cnt].rb_id != 0)
        {
          /* This IE must have already been provided as part of mapping info. Just return success */
          WRRC_MSG1_HIGH("UL Trch mapped to RB %d ",ordered_config_ptr->ul_cctrch.dch_info.dch_info[trch_idx].dlchan_info[cnt].rb_id);
          return TRUE;
        }
      }
    }
  }
  return FALSE;
}

/*====================================================================
FUNCTION: rrcllc_init_tfcs_needed_flags()

DESCRIPTION:
  This functions initializes flags ul_tfcs_needed and dl_tfcs_needed.

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_tfcs_needed_flags(void)
{
  ul_tfcs_needed = FALSE;
  dl_tfcs_needed = FALSE;
  ul_tfcs_rcvd = FALSE;
  dl_tfcs_rcvd = FALSE;
}
/*====================================================================
FUNCTION: rrcllc_is_tfcs_provided_on_add_delete_trch()

DESCRIPTION:
  This function returns TRUE if UE was expecting to receive some TFCS
  info, but never received it.  Else returns FALSE.  Only enforce this
  rule is DCH and relax this rule in other states.

DEPENDENCIES:
  None

RETURN VALUE:
  boolean

SIDE EFFECTS:
  None.
====================================================================*/
boolean rrcllc_is_tfcs_provided_on_add_delete_trch(rrc_RRC_StateIndicator dest_state)
{
  ordered_config_type  *config_ptr = ordered_config_ptr;

  if (dest_state == rrc_RRC_StateIndicator_cell_DCH) 
  {
    if((dl_tfcs_needed == TRUE) && (dl_tfcs_rcvd == FALSE) &&
       (config_ptr->mac_dl_parms.num_dchs > 0))
    {
      /*The following check makes sure that there's not any standalone DL DCH*/
      if(rrcllc_dl_dchs_not_standalone())
      {
        WRRC_MSG2_ERROR("DL TFCS info not present: Invalid %d %d",dl_tfcs_needed,dl_tfcs_rcvd);
        return FALSE;
      }
    }
    else if((ul_tfcs_needed == TRUE) && (ul_tfcs_rcvd == FALSE) &&
            (config_ptr->mac_ul_parms.cctrch_ptr->dch_info.ndchs > 0))
    {
      if(rrcllc_ul_dchs_not_standalone())
      {
        WRRC_MSG2_ERROR("UL TFCS info not present: Invalid %d %d",ul_tfcs_needed, ul_tfcs_rcvd);
        return FALSE;
      }
    }
  }
  if(rrc_get_state() == RRC_STATE_CELL_DCH || dest_state == rrc_RRC_StateIndicator_cell_DCH)
  {
    if(config_ptr->mac_ul_parms.cctrch_ptr->dch_info.ndchs == 0)
    {
      WRRC_MSG0_HIGH("Initing UL TFCS");
      rrcllc_init_ul_tfi_table(config_ptr);
      config_ptr->mac_ul_parms.new_tfcs_list_present = TRUE;
    }
    if(config_ptr->mac_dl_parms.num_dchs == 0)
    {
      WRRC_MSG0_HIGH("Initing DL TFCS");
      rrcllc_init_dl_ctfcs(config_ptr);
    }
  }    
  return TRUE;
}
#ifdef FEATURE_MVS
#ifdef FEATURE_VOC_AMR_WB
/*===========================================================================

FUNCTION rrc_configure_amr_wb_mode_param

DESCRIPTION Configures the MVS  for WB- AMR
 
DEPENDENCIES
  None.

RETURN VALUE
 None
===========================================================================*/
void rrc_configure_amr_wb_mode_param
( 
  rrcllc_amr_mapping_info_type * amr_wb_info
)
{

  WRRC_MSG2_HIGH("Setting AMR_mode %d, SCR_mode %d",amr_wb_info->amr_mode,amr_wb_info->scr_mode);


  /*Setting AMR mode*/
  ghdi_mvs_amr_set_awb_mode(amr_wb_info->amr_mode);
  /*Setting SCR mode*/
  ghdi_mvs_amr_set_scr_mode(amr_wb_info->scr_mode);
  /*Registering UL Channels*/
  WRRC_MSG0_HIGH("Registering MVS through GHDI with 2 WB-AMR Classes in UL.");  
  ghdi_mvs_wcdma_set_ul_channel((amr_wb_info->ul_amr_a_id),
                                    (amr_wb_info->ul_amr_b_id),
                                    (amr_wb_info->ul_amr_c_id),
                                    MVSSUP_WCDMA_CHAN_CLASS_AB);
  /*Registering DL Channels*/
  WRRC_MSG0_HIGH("Registering MVS through GHDI with 2 WB-AMR Classes in DL.");    
  ghdi_mvs_wcdma_set_dl_channel((amr_wb_info->dl_amr_a_id),
                                    (amr_wb_info->dl_amr_b_id),
                                    (amr_wb_info->dl_amr_c_id),
                                    MVSSUP_WCDMA_CHAN_CLASS_AB);
         

}

/*===========================================================================

FUNCTION rrc_change_codec_configuration

DESCRIPTION This function is called if there is a codec change in a ongoing call.
                     In this case, the old codec is released. And then the MVS is configured 
                     with the new codec parameters. And then the new is acquired.
 
DEPENDENCIES
  None.

RETURN VALUE
 None

===========================================================================*/
void rrc_change_codec_configuration
(
  uint8 rab_idx
)
{
  mvs_mode_type current_mode;
  rrcllc_amr_mapping_info_type amr_info = {0};
		
#if defined(FEATURE_DUAL_SIM) && defined(FEATURE_DUAL_ACTIVE)
  if(mn_has_nas_already_acquired_voc_subs(rrc_get_as_id()) == TRUE)
#else
  if(mn_has_nas_already_acquired_voc() == TRUE)
#endif
  {
    ghdi_mvs_release(MVS_CLIENT_WCDMA);
  }
 
  current_mode = rrc_get_current_codec_mode();

  if( current_mode == MVS_MODE_AMR_WB)
  {
    WRRC_MSG0_HIGH("change config to AMR_WB");
    amr_info.mode_type = MVS_MODE_AMR_WB;
    (void) rrcllc_get_amr_wb_mapping(&(amr_info));
    rrc_configure_amr_wb_mode_param(&(amr_info));
  }
  else
  {    
    WRRC_MSG0_HIGH("change config to AMR");
    amr_info.mode_type = MVS_MODE_AMR;
    (void) rrcllc_get_amr_mapping(&(amr_info)); 
    rrc_configure_mvs(&amr_info, rab_idx);
  }
#if defined(FEATURE_DUAL_SIM) && defined(FEATURE_DUAL_ACTIVE)
  if(mn_has_nas_already_acquired_voc_subs(rrc_get_as_id()) == TRUE)
#else
  if(mn_has_nas_already_acquired_voc() == TRUE)
#endif
  {
    /* Now try to acquire W */
    WRRC_MSG0_HIGH("Acquiring MVS_CLIENT(W) due to reconfig procedures");
    {
      /* Set the control flag to true to indicate that we are taking control of the vocoder */
      rrciho_mvs_control_flag = TRUE;
      ghdi_mvs_acquire(MVS_CLIENT_WCDMA);
    }
  }
}

/*===========================================================================

FUNCTION rrcllcoc_update_oc_orderd_codec_mode

DESCRIPTION This function updates the OC with the codec mode which needs to be
                      applied.
 
DEPENDENCIES
  None.

RETURN VALUE
 None

===========================================================================*/
void rrcllcoc_update_oc_orderd_codec_mode
(
  mvs_mode_type codec_mode_ordered
)
{
  ordered_config_ptr->ul_tfcs.orderd_codec_mode = codec_mode_ordered;
}
#endif/*FEATURE_VOC_AMR_WB*/
#endif

/*===========================================================================

FUNCTION rrcllcoc_update_toc_with_oc_from_fach


DESCRIPTION This function updates the TOC with the OC value. 
            It also sets the TOC.
            It also handles the case where TOC originally had some DCH info.
 
DEPENDENCIES
  None.

RETURN VALUE
 None

===========================================================================*/
void rrcllcoc_update_toc_with_oc_from_fach
(
  void
)
{
  uint32 ix;
  rrcllc_toc_usage_e_type toc_usage_type ;
  mac_rnti_config_type      backup_rnti_info;
  backup_rnti_info.rnti_valid = NO_RNTI_VALID;
 /* Now copy OC to TOC */
  if( transition_config.toc_usage == TOC_INVALID )
  {
    toc_usage_type = TOC_FOR_FACH_AND_PCH;
  }
  else
  {
    toc_usage_type =TOC_FOR_FACH_AND_PCH_WITH_DCH_INFO;
  }
  
  /* Since TOC had some valid DCH info, backup the DCH info into OC 
   * So that when TOC is updated with OC, the existing TOC contents are also available.
   */     
  if(transition_config.toc_usage != TOC_INVALID)
  {
    //backup_rnti_info from OC,as TOC may no have proper value
    if(ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid != NO_RNTI_VALID)
    {
      backup_rnti_info = ordered_config_ptr->mac_dl_parms.rnti_info;
    }  
       
    /* Copy CM params from TOC to OC */
    for (ix = 0 ; ix < L1_CM_MAX_TGP_SEQ_COUNT; ix++)
    {
      ordered_config_ptr->tgp_seq_info[ix] = transition_config.toc_ptr->tgp_seq_info[ix];
      ordered_config_ptr->cm_info.action_needed[ix] = transition_config.toc_ptr->cm_info.action_needed[ix];
    }
    ordered_config_ptr->cm_info.tgp_seq_info_count = transition_config.toc_ptr->cm_info.tgp_seq_info_count;

      rrcllc_copy_trch_info(ordered_config_ptr, transition_config.toc_ptr);
      rrcllc_copy_srb5_info(ordered_config_ptr, transition_config.toc_ptr);

      if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
      {
        /* Copy HARQ Information to L1 */
        rrcllc_copy_harq_info(ordered_config_ptr, transition_config.toc_ptr);
      }
      //restore rnti_info to OC
      if((ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid == NO_RNTI_VALID)&&
         (backup_rnti_info.rnti_valid != NO_RNTI_VALID))
      {
        WRRC_MSG0_HIGH("RNTIinfo:Restore RNTI into OC");
        ordered_config_ptr->mac_dl_parms.rnti_info = backup_rnti_info;
        ordered_config_ptr->mac_ul_parms.rnti_info = backup_rnti_info;
      }
    }
  
  /* Now copy OC to TOC */
  rrcllc_copy_oc_to_toc();  
  transition_config.toc_ptr->rlc_ul_tm_parms.nchan = 0;
  transition_config.toc_ptr->rlc_dl_tm_parms.nchan = 0;	

  /* Indicate that TOC is used for FACH->FACH or FACH->PCH transition  */
  transition_config.toc_usage = toc_usage_type;
  WRRC_MSG1_HIGH("TOC Usage set as %d",toc_usage_type);
}


/*===========================================================================

FUNCTION rrcllc_init_fdpch_info


DESCRIPTION This function initializes the F-DPCH parameters in Config DB
 
DEPENDENCIES
  None.

RETURN VALUE
 None

===========================================================================*/
void  rrcllc_init_fdpch_info
(
  ordered_config_type *config_ptr
)
{
  /* Initialize F-DPCH Parameters */
  config_ptr->l1_dl_chan_parms.use_fdpch = FALSE;
}


/*============================================================================
FUNCTION: rrcllc_check_if_new_tfcs_present()

DESCRIPTION:
 This Function returns TRUE if UL TFCs is set in ordered config,
 FALSE otherwise

DEPENDENCIES:
  None

RETURN VALUE:
TRUE    if new UL TFCS is present in ordered config
FALSE  otherwise
=============================================================================*/
boolean rrcllc_check_if_new_tfcs_present
(
  void
)
{
  return ordered_config_ptr->mac_ul_parms.new_tfcs_list_present;
}

/*====================================================================
FUNCTION       rrcllc_compute_additional_prach_tf()

DESCRIPTION    Gets  the ATF size from SIb5/SIB6 and updates the TF and TFC list
               with it. Also update the atf_present, and atf_ccch_tf_index to 
               indicate to MAC the ATF size.

DEPENDENCIES   None

RETURN VALUE  None

SIDE EFFECTS   None.
====================================================================*/

void  rrcllc_compute_additional_prach_tf
(
  rrc_AdditionalPRACH_TF_and_TFCS_CCCH_IEs * rrc_additional_prach_TF_list ,
  ordered_config_type *config_ptr,
  uint8 trch_idx
)
{
  /* Pointer to the TFS info in Ordered Config */
  mac_ul_tfs_type     *oc_tfs_ptr = &config_ptr->ul_tfcs.tfs_info[trch_idx];
  /* Pointer to TFC info in Ordered Config Data Structure */
  mac_ul_tfc_type     *oc_tfc_ptr=NULL;

  /* Pointer to TF information in ordered config data */
  mac_ul_tf_type               *oc_tf_ptr = NULL;

  /* Transport Format index */
  uint16 tf_idx = 0;
  uint32  tfc_idx = 0;
  rrc_OctetModeRLC_SizeInfoType2 *rlc_size_info;
  tf_idx = oc_tfs_ptr->ntf;
  /* Get Dynamic Transport Format information */
  if((rrc_additional_prach_TF_list != NULL) 
      && (tf_idx < UE_MAX_TF))
  {
 
    /* TF info pointer in ordered config data */
    oc_tf_ptr = &oc_tfs_ptr->tf_info[tf_idx];
  
    /* Save Number of TBlks info in OC data structure 
    * At present save as 1 Trch blk, as no. of Trch blk is not given*/
    oc_tf_ptr->ntblks = 1;
    rlc_size_info = &rrc_additional_prach_TF_list->dynamicTFInformationCCCH.octetModeRLC_SizeInfoType2;
    switch (rlc_size_info->t)
    {
      case T_rrc_OctetModeRLC_SizeInfoType2_sizeType1:
        oc_tf_ptr->tb_size = (rlc_size_info->u.sizeType1 * 8) + 48;
        break;
      case T_rrc_OctetModeRLC_SizeInfoType2_sizeType2:
        oc_tf_ptr->tb_size = (rlc_size_info->u.sizeType2 * 16) + 312;
        break;
      case T_rrc_OctetModeRLC_SizeInfoType2_sizeType3:
        oc_tf_ptr->tb_size = (rlc_size_info->u.sizeType3 * 64) + 1384;
        break;
      default:
        oc_tf_ptr->tb_size = (uint16 )RRCLLC_INVALID_RLC_SIZE;
        break;
    } /* End switch-case, size types for RLC size in FDD mode  */
  
 
    WRRC_MSG2_HIGH("ATF: ATF tbsize value %d at tf_idx %d",oc_tf_ptr->tb_size,tf_idx);

   /* According to section 8.6.5.1, in spec 25.331 ,  the TFS added by the IE 
    * "Additional Dynamic Transport Format Information for CCCH" will always be 
    * considered as CONFIGURED 
    */
    config_ptr->rach_rlc_size_restriction_info.logical_channel_list[tf_idx].restriction_type = RLC_SIZES_CONFIGURED;
  


   config_ptr->mac_ul_parms.cctrch_ptr->rach_info.atf_present = TRUE;
   config_ptr->mac_ul_parms.cctrch_ptr->rach_info.atf_ccch_tf_index = tf_idx;
 
   tf_idx++;
 
   /* Save Number of Transport Formats info, and indicate all is well */
   oc_tfs_ptr->ntf = tf_idx;
  
  
    /* There are no holes in the TFCS Table */ 
    
    /* TFC is added at the end */ 
    tfc_idx = config_ptr->ul_tfcs.ntfc;   
 
 
    /* TFC Index is within maximum value */ 
    if ((tfc_idx < L1_UL_TFC_MAX) && (tfc_idx > 0))
    { 
      /* Pointer to TFC info info OC data */
      oc_tfc_ptr = &config_ptr->ul_tfcs.tfc_info[tfc_idx];
 
      /* Set TFC Control Flag to allowed */
      oc_tfc_ptr->control_flag = TFC_ALLOWED;
 
      /* Calculate  the CTFC value as 1 + the last highest ctfc, 
        * As PRACh has only one Trch Channel. 
        */
      oc_tfc_ptr->ctfc = (uint32)config_ptr->ul_tfcs.tfc_info[tfc_idx -1].ctfc +1 ; 
 
      /* Save the Power Offset Information */
      (void)get_ul_gain_factor_info (config_ptr->rrc_ul_cctrch_params.gain_factor_parms,
       &rrc_additional_prach_TF_list->powerOffsetInformation,
       (uint8)tfc_idx);
 

      /*Increment TFC count */
      if(tfc_idx == config_ptr->ul_tfcs.ntfc) 
      { 
        config_ptr->ul_tfcs.ntfc++;
        config_ptr->l1_ul_cctrch_parms.num_tfci++; 
      }

      MSG_HIGH("ATF: ATF config_ptr->ul_tfcs.ntfc value %d num_tfci %d ctfc  %d",config_ptr->ul_tfcs.ntfc,config_ptr->l1_ul_cctrch_parms.num_tfci,oc_tfc_ptr->ctfc);
    }   
    /* TFC index has exceeded the maximum value */  
    else 
    {  
       WRRC_MSG0_ERROR("Invalid number of Transport Formats");   
      return;
    }    
  }

  return;
}


/*==========================================================
FUNCTION  :   RRCLLC_GET_CONFIG_PTR_IN_USE()

DESCRIPTION : This function returns the config ptr in use.

DEPENDENCIES: None.

RETURN VALUE: See description.

SIDE EFFECTS: None.
============================================================*/
ordered_config_type *rrcllc_get_config_ptr_in_use(void)
{

  WRRC_MSG1_MED("config ptr in use 0x%x [0:OC/1:CC/2:TOC]",
           config_ptr_in_use);
  if (config_ptr_in_use == ORDERED_CONFIG) 
  {
    return ordered_config_ptr;
  }
  else if(config_ptr_in_use == CURRENT_CONFIG)
  {
    return current_config_ptr;
  }
  else if (config_ptr_in_use == TRANSITION_CONFIG) 
  {
    return transition_config.toc_ptr;
  }

  return NULL;
}/*rrcllc_get_config_ptr_in_use*/

/*====================================================================
FUNCTION: rrcllc_get_rach_cctrch_ptr()

DESCRIPTION:
  This function returns rach cctrch ptr from current config

DEPENDENCIES:
  None.

RETURN VALUE:

SIDE EFFECTS:
  None.

=====================================================================*/
mac_ul_rach_cctrch_config_type *rrcllc_get_rach_cctrch_ptr
(
  void
)
{
  mac_ul_rach_cctrch_config_type *rach_info_ptr =NULL;
  
  if(config_ptr_in_use == ORDERED_CONFIG)
  {
    rach_info_ptr = &ordered_config_ptr->mac_ul_parms.cctrch_ptr->rach_info;
  }
  else if(config_ptr_in_use == CURRENT_CONFIG)
  {
    rach_info_ptr = &current_config_ptr->mac_ul_parms.cctrch_ptr->rach_info;
  }

  if(rach_info_ptr != NULL)
  {
    return rach_info_ptr;
  }
  else
  {
    WRRC_MSG1_HIGH("config ptr in use 0x%x [0:OC/1:CC/2:TOC]", config_ptr_in_use);
    ERR_FATAL("RACH info pointer is NULL",0,0,0);
    return NULL;
  }
     
}

/*===========================================================================

FUNCTION rrc_deconfigure_mvs

DESCRIPTION
  This function deconfigures MVS for deregistration of UL / DL AMR RLC queues. 
  It also resets the RRC global variable rrc_amr_info.
  
DEPENDENCIES
  None.
  
RETURN VALUE
  None.
  
SIDE EFFECTS
  None.

===========================================================================*/
void rrc_deconfigure_mvs
(
  void
)
{
#ifdef FEATURE_MVS

  WRRC_MSG0_HIGH("Deregistering MVS through GHDI in UL/DL.");

  ghdi_mvs_wcdma_set_ul_channel(0, 0, 0, MVSSUP_WCDMA_CHAN_CLASS_NONE);
  ghdi_mvs_wcdma_set_dl_channel(0, 0, 0, MVSSUP_WCDMA_CHAN_CLASS_NONE);

#ifdef WCDMA_RRC_INDICATE_CODEC_TO_CM
  /*Send  WtoG hand over failure   */
  rrc_send_hho_cmd_to_cm(SYS_HO_FAIL,SYS_HO_TYPE_UMTS_UMTS);
  rrc_set_ordered_codec_status(FALSE);
#endif

    /*Initialize RRC global rrc_amr_info*/
#ifdef FEATURE_AS_MVS_ENHANCED_AMR_PROCESSING
  rrc_amr_info.dl_amr_a_cctrch_id = rrc_amr_info.dl_amr_b_cctrch_id = 
      rrc_amr_info.dl_amr_c_cctrch_id = RRCLLC_INVALID_CCTRCH_ID;
  rrc_amr_info.dl_amr_a_cctrch_id = rrc_amr_info.dl_amr_b_cctrch_id = 
      rrc_amr_info.dl_amr_c_cctrch_id = RRCLLC_INVALID_TRCH_IDX;
  rrc_amr_info.dl_amr_mode = MVS_AMR_MODE_UNDEF;
#ifdef FEATURE_VOC_AMR_WB	
  rrc_amr_info.mode_type = MVS_MODE_MAX;
#endif /*FEATURE_VOC_AMR_WB*/
#endif /*FEATURE_AS_MVS_ENHANCED_AMR_PROCESSING*/

#endif
  return;
}

/*===========================================================================

FUNCTION rrc_configure_mvs

DESCRIPTION
  This function configures MVS for registeration of AMR RLC queues in UL/DL. 
  For WB-AMR, only 2 classes are registered in UL /DL. For NB-AMR, the no. 
  of classes to be registered in UL / DL is taken based on no. of RBs / DL AMR rate.
  
DEPENDENCIES
  None.
  
RETURN VALUE
  None.
  
SIDE EFFECTS
  None.

===========================================================================*/
void rrc_configure_mvs
(
  rrcllc_amr_mapping_info_type * amr_info,
  uint8 rab_idx
)
{
#ifdef FEATURE_MVS

  uint8 num_of_RBs =0;

  if(rab_idx >= MAX_RAB_TO_SETUP)
  {
    WRRC_MSG1_HIGH("Invalid RAB Index = %d. Skipping the configuration of MVS.",rab_idx);
    return;
  }

  if((num_of_RBs = rrc_est_rabs.rabs[rab_idx].num_rbs_for_rab) > MAX_DCH_VOICE_CHANNEL)
  {
    WRRC_MSG1_HIGH("Invalid no. of RBs = %d. Skipping the configuration of MVS.",num_of_RBs);
    return;
  }

  /*The decision of registering for AMC Class C in UL is done based on no. of RBs.*/		
  if(num_of_RBs == 3)
  {
    amr_info->ul_amr_c_id = rrclcm_get_ul_rlc_lc_id((rrc_RB_Identity)rrc_est_rabs.rabs[rab_idx].rb_for_rab[2].rb_id);
    WRRC_MSG1_HIGH("LC id for AMR Class C = %d",amr_info->ul_amr_c_id);		  
  }
  
  WRRC_MSG2_HIGH("Setting AMR_mode %d, SCR_mode %d", amr_info->amr_mode,amr_info->scr_mode);
  

  /*Setting AMR mode*/
  ghdi_mvs_amr_set_amr_mode(amr_info->amr_mode);
  /*Setting SCR mode*/
  ghdi_mvs_amr_set_scr_mode(amr_info->scr_mode);
  /*Registering UL Channels*/
  if(num_of_RBs == 3)
  {
    WRRC_MSG0_HIGH("Registering MVS through GHDI with 3 AMR Classes in UL.");  
    ghdi_mvs_wcdma_set_ul_channel((amr_info->ul_amr_a_id),
                                  (amr_info->ul_amr_b_id),
                                  (amr_info->ul_amr_c_id),
                                  MVSSUP_WCDMA_CHAN_CLASS_ABC);
  }
  else
  {
    WRRC_MSG0_HIGH("Registering MVS through GHDI with 2 AMR Classes in UL.");  
    ghdi_mvs_wcdma_set_ul_channel((amr_info->ul_amr_a_id),
                                    (amr_info->ul_amr_b_id),
                                    (amr_info->ul_amr_c_id),
                                    MVSSUP_WCDMA_CHAN_CLASS_AB);
  }
  /*Registering DL Channels*/
  if (amr_info->dl_amr_mode >= MVS_AMR_MODE_1020)
  {
    WRRC_MSG0_HIGH("Registering MVS through GHDI with 3 AMR Classes in DL.");
    ghdi_mvs_wcdma_set_dl_channel((amr_info->dl_amr_a_id),
                                  (amr_info->dl_amr_b_id),
                                  (amr_info->dl_amr_c_id),                             
                                  MVSSUP_WCDMA_CHAN_CLASS_ABC);
  }
  else
  {
    WRRC_MSG0_HIGH("Registering with MVS through GHDI 2 AMR Classes in DL.");    
    ghdi_mvs_wcdma_set_dl_channel((amr_info->dl_amr_a_id),
                                  (amr_info->dl_amr_b_id),
                                  (amr_info->dl_amr_c_id),
                                  MVSSUP_WCDMA_CHAN_CLASS_AB);
  }

#endif

}

#ifdef FEATURE_MVS
/*===========================================================================
FUNCTION rrc_register_ul_mvs_through_ghdi()

DESCRIPTION
  This function is called only for MVS_MODE_AMR. Therefore no need to check 
  for MVS Mode. For NB-AMR, based on no. of RBs, RRC registers for either 
  2 or 3 AMR classes in UL.
  
DEPENDENCIES
  None.
  
RETURN VALUE
  None.
  
SIDE EFFECTS
  None.
===========================================================================*/
void rrc_register_ul_mvs_through_ghdi
(
  rrcllc_amr_mapping_info_type * amr_info,
  uint8 num_of_RBs
)
{
  WRRC_MSG2_HIGH("Setting AMR_mode %d, SCR_mode %d", amr_info->amr_mode,amr_info->scr_mode);
  
  ghdi_mvs_amr_set_amr_mode(amr_info->amr_mode);
  ghdi_mvs_amr_set_scr_mode(amr_info->scr_mode);
  
  if(num_of_RBs == 3)
  {
    ghdi_mvs_wcdma_set_ul_channel((amr_info->ul_amr_a_id),
                                      (amr_info->ul_amr_b_id),
                                      (amr_info->ul_amr_c_id),
                                       MVSSUP_WCDMA_CHAN_CLASS_ABC);
  }
  else
  {
    ghdi_mvs_wcdma_set_ul_channel((amr_info->ul_amr_a_id),
                                      (amr_info->ul_amr_b_id),
                                      (amr_info->ul_amr_c_id),
                                      MVSSUP_WCDMA_CHAN_CLASS_AB);
  }
}

/*===========================================================================
FUNCTION rrc_register_dl_mvs_through_ghdi

DESCRIPTION
  This function is called only for MVS_MODE_AMR. Therefore no need to check 
  for MVS Mode. For NB-AMR, based on AMR rate, RRC registers for either 2 or 
  3 AMR classes in DL.
  
DEPENDENCIES
  None.
  
RETURN VALUE
  None.
  
SIDE EFFECTS
  None.
===========================================================================*/
void rrc_register_dl_mvs_through_ghdi
(
  rrcllc_amr_mapping_info_type * amr_info
)
{

  if(amr_info->dl_amr_mode >= MVS_AMR_MODE_1020)
  {
    WRRC_MSG0_HIGH("Registering with MVS with 3 classes for DL");
    
    ghdi_mvs_wcdma_set_dl_channel((amr_info->dl_amr_a_id),
                                            (amr_info->dl_amr_b_id),
                                            (amr_info->dl_amr_c_id),
                                            MVSSUP_WCDMA_CHAN_CLASS_ABC);
  }
  else
  {
    WRRC_MSG0_HIGH("Registering with MVS with 2 classes for DL");
    
    ghdi_mvs_wcdma_set_dl_channel((amr_info->dl_amr_a_id),
                                            (amr_info->dl_amr_b_id),
                                            (amr_info->dl_amr_c_id),
                                            MVSSUP_WCDMA_CHAN_CLASS_AB);
  }
}

#ifdef FEATURE_AS_MVS_ENHANCED_AMR_PROCESSING
/*===========================================================================
FUNCTION rrc_save_rrc_amr_info_for_callback

DESCRIPTION
  This function saves the CCTrCH ids and TrCH ids for DL AMR Classes for 
  later use when Vocoder acquisition by RRC is successful. This function
  is called in the context of GHDI task.
  
DEPENDENCIES
  None.
  
RETURN VALUE
  None.
  
SIDE EFFECTS
  None.
===========================================================================*/
void rrc_save_rrc_amr_info_for_mvs_callback
(
  rrcllc_amr_mapping_info_type * amr_info
)
{
  rrc_amr_info.dl_amr_a_cctrch_id = amr_info->dl_amr_a_cctrch_id;
  rrc_amr_info.dl_amr_b_cctrch_id = amr_info->dl_amr_b_cctrch_id;  
  rrc_amr_info.dl_amr_c_cctrch_id = amr_info->dl_amr_c_cctrch_id;  

  MSG_HIGH("Class A, B and C CCTrCH Ids %d, %d and %d",amr_info->dl_amr_a_cctrch_id,
    amr_info->dl_amr_b_cctrch_id,amr_info->dl_amr_c_cctrch_id);  

  rrc_amr_info.dl_amr_a_trch_id = amr_info->dl_amr_a_trch_id;
  rrc_amr_info.dl_amr_b_trch_id = amr_info->dl_amr_b_trch_id;
  rrc_amr_info.dl_amr_c_trch_id = amr_info->dl_amr_c_trch_id;  

  MSG_HIGH("Class A, B and C TrCH Ids %d, %d, %d",amr_info->dl_amr_a_trch_id,
    amr_info->dl_amr_b_trch_id,amr_info->dl_amr_c_trch_id);  

  rrc_amr_info.dl_amr_mode = amr_info->dl_amr_mode;
  
#ifdef FEATURE_VOC_AMR_WB  
  rrc_amr_info.mode_type = amr_info->mode_type;
  WRRC_MSG2_HIGH("Saving rrc_amr_info. DL AMR rate %d, MVS Mode %d",amr_info->dl_amr_mode,
    amr_info->mode_type);
#endif /*FEATURE_VOC_AMR_WB*/
}

#endif /*FEATURE_AS_MVS_ENHANCED_AMR_PROCESSING*/
#endif /*FEATURE_MVS*/

/*====================================================================
FUNCTION: rrcllc_get_log_chan_mode_ul_dch()

DESCRIPTION:
  This function gets a the log_chan_mode for the rb id specified if the rb_id is UL DCH

DEPENDENCIES:
  None.

RETURN VALUE:
  Logical Channel mode of the rb_id    if rb_id is found mapped to a UL DCH
  UE_MODE_MAX_NUM     otherwise

SIDE EFFECTS:

====================================================================*/
uecomdef_logch_mode_e_type rrcllc_get_log_chan_mode_ul_dch
(
  rrc_RB_Identity rb_id
)
{
  uint32 dch_count = 0;
  uint32 num_dlchan = 0;
  uint32 num_dch=0;
  uint32 dlchl_count=0;
  /* Get the logical channel mode if a new logical channel is to be established */
  num_dch = ordered_config_ptr->mac_ul_parms.cctrch_ptr->dch_info.ndchs;
  /* Look into all DCHs to get to the one mapped to the same RB ID */
  for(dch_count=0;(dch_count < num_dch);dch_count++)
  {
    num_dlchan = ordered_config_ptr->mac_ul_parms.cctrch_ptr->
           dch_info.dch_info[dch_count].ndlchan;
    for(dlchl_count=0; dlchl_count< num_dlchan; dlchl_count++)
    {
      if(ordered_config_ptr->mac_ul_parms.cctrch_ptr->
        dch_info.dch_info[dch_count].dlchan_info[dlchl_count].rb_id == rb_id)
      {
        /* This DCH is mapped to the same RB ID as is being setup.
         */
         return (ordered_config_ptr->mac_ul_parms.cctrch_ptr->
          dch_info.dch_info[dch_count].dlchan_info[dlchl_count].rlc_mode);
      }
    }
  }
  return (UE_MODE_MAX_NUM);
}

/*====================================================================
FUNCTION: rrcllc_get_hs_log_chan_mode()

DESCRIPTION:
  This function gets a the log_chan_mode for the rb id specified if the rb_id is mapped to HS dflow

DEPENDENCIES:
  None.

RETURN VALUE:
  Logical Channel mode of the rb_id    if rb_id is found mapped to a HS dflow
  UE_MODE_MAX_NUM     otherwise

SIDE EFFECTS:

====================================================================*/
uecomdef_logch_mode_e_type rrcllc_get_hs_log_chan_mode
(
  rrc_RB_Identity rb_id
)
{
  uint32    num_dflow = 0;
  uint32    dflow_count = 0;
  uint32    dlchl_count;

  num_dflow= ordered_config_ptr->mac_dl_parms.num_dflow;
  
  /* Look into all DFLOWs to get to the one mapped to the same RB ID */
  for(dflow_count=0;(dflow_count < num_dflow);dflow_count++)
  {
    /* Preventive check */
    if (ordered_config_ptr->mac_dflow_info[dflow_count].mac_dflow_id == INVALID_DFLOW_ID)
    {
      continue;
    }
    WRRC_MSG2_HIGH("RRCHS:DFLOW %d, No DL Ch %d",
             ordered_config_ptr->mac_dflow_info[dflow_count].mac_dflow_id,
             ordered_config_ptr->mac_dflow_info[dflow_count].ndlchan);
    
    /* Check no of DL Dedicated Channels */
    
    for(dlchl_count=0; dlchl_count< ordered_config_ptr->mac_dflow_info[dflow_count].ndlchan; dlchl_count++)
    {
      if(ordered_config_ptr->mac_dflow_info[dflow_count].dlchan_info[dlchl_count].rb_id == rb_id)
      {
          /* This DFLOW is mapped to the same RB ID as is being setup.
        */
        MSG_HIGH("RRCHS:RB Id %d mapped to dflow %d with RLC Mode(0:T:1:U:2/3:A) %d",
                 rb_id,ordered_config_ptr->mac_dflow_info[dflow_count].mac_dflow_id,
                 ordered_config_ptr->mac_dflow_info[dflow_count].dlchan_info[dlchl_count].rlc_mode);
        return(ordered_config_ptr->mac_dflow_info[dflow_count].dlchan_info[dlchl_count].rlc_mode);
      }
    }
  }
  return (UE_MODE_MAX_NUM);
}

/*====================================================================
FUNCTION: rrcllc_check_if_dflow_exist_and_update_rlc_id()

DESCRIPTION:
  This function gets a the log_chan_mode for the rb id specified if the rb_id is mapped to dflow,
  if mapped to dflow, updates the dflow info the logicah channel id

DEPENDENCIES:
  None.

RETURN VALUE:
  TRUE   if RB id is mapped to dflow
  FALSE     otherwise

SIDE EFFECTS:

====================================================================*/
boolean rrcllc_check_if_dflow_exist_and_update_rlc_id
(
  rrc_RB_Identity rb_id,
  rlc_lc_id_type dl_lc_id
)
{
  uint32    num_dflow = 0;
  uint32    dflow_count = 0;
  uint32    dlchl_count;
/* Check in DFLOW List */
  /* Get the logical channel mode if a new logical channel is to be established */
  num_dflow= ordered_config_ptr->mac_dl_parms.num_dflow;

  /* Look into all DFLOWs to get to the one mapped to the same RB ID */
  for(dflow_count=0; (dflow_count < num_dflow); dflow_count++)
  {
    if (ordered_config_ptr->mac_dflow_info[dflow_count].mac_dflow_id == INVALID_DFLOW_ID)
    {
      continue;
    }
    WRRC_MSG2_HIGH("RRCHS:DFLOW %d, No DL Ch %d",
             ordered_config_ptr->mac_dflow_info[dflow_count].mac_dflow_id,
             ordered_config_ptr->mac_dflow_info[dflow_count].ndlchan);

    /* Check no of DL Dedicated Channels */

    for(dlchl_count=0; dlchl_count< ordered_config_ptr->mac_dflow_info[dflow_count].ndlchan; dlchl_count++)
    {
      if(ordered_config_ptr->mac_dflow_info[dflow_count].dlchan_info[dlchl_count].rb_id ==rb_id)
      {
        /* This DFLOW is mapped to the same RB ID as is being setup.*/

        MSG_HIGH("RRCHS:RB Id %d mapped to dflow %d with RLC Mode(0:T:1:U:2/3:A) %d",
                 rb_id, ordered_config_ptr->mac_dflow_info[dflow_count].mac_dflow_id,
                 ordered_config_ptr->mac_dflow_info[dflow_count].dlchan_info[dlchl_count].rlc_mode);
        ordered_config_ptr->mac_dflow_info[dflow_count].dlchan_info[dlchl_count].rlc_id =
          dl_lc_id;
        return TRUE;
      }
    }  /* for(...) */
  }
  return FALSE;
}
/*====================================================================
FUNCTION: rrcllc_check_if_ul_dch_exist_and_update_rlc_id()

DESCRIPTION:
  This function gets a the log_chan_mode for the rb id specified if the rb_id is mapped to UL DCH,
  if mapped to DCH, updates the UL DCH info the logicah channel id

DEPENDENCIES:
  None.

RETURN VALUE:
  TRUE   if RB id is mapped to UL DCH
  FALSE     otherwise

SIDE EFFECTS:

====================================================================*/
boolean rrcllc_check_if_ul_dch_exist_and_update_rlc_id
(
  rrc_RB_Identity rb_id,
  rlc_lc_id_type ul_lc_id,
  uecomdef_logchan_e_type log_chl_type
)
{
  uint32 dch_count = 0;
  uint32 num_dlchan = 0;
  uint32 num_dch=0;
  uint32 dlchl_count=0;
  
  num_dch = ordered_config_ptr->mac_ul_parms.cctrch_ptr->dch_info.ndchs;
  /* Look into all DCHs to get to the one mapped to the same RB ID */
  for(dch_count=0;(dch_count < num_dch); dch_count++)
  {
    num_dlchan = ordered_config_ptr->mac_ul_parms.cctrch_ptr->
                 dch_info.dch_info[dch_count].ndlchan;
    for(dlchl_count=0; dlchl_count< num_dlchan; dlchl_count++)
    {
      if((ordered_config_ptr->mac_ul_parms.cctrch_ptr->
            dch_info.dch_info[dch_count].dlchan_info[dlchl_count].rb_id == rb_id) &&
          (ordered_config_ptr->mac_ul_parms.cctrch_ptr->
          dch_info.dch_info[dch_count].dlchan_info[dlchl_count].chan_type == log_chl_type))
      {
        /* This DCH is mapped to the same RB ID and the same logical
         * Channel type as is being setup.
         */
        ordered_config_ptr->mac_ul_parms.cctrch_ptr->
          dch_info.dch_info[dch_count].dlchan_info[dlchl_count].rlc_id =  ul_lc_id;
        return (TRUE);
      }
    }  /* for(...) */
  }
  return (FALSE);
}

/*====================================================================
FUNCTION: rrcllc_check_if_dl_dch_exist_and_update_rlc_id()

DESCRIPTION:
  This function gets a the log_chan_mode for the rb id specified if the rb_id is mapped to UL DCH,
  if mapped to DCH, updates the UL DCH info the logicah channel id

DEPENDENCIES:
  None.

RETURN VALUE:
  TRUE   if RB id is mapped to UL DCH
  FALSE     otherwise

SIDE EFFECTS:

====================================================================*/
boolean rrcllc_check_if_dl_dch_exist_and_update_rlc_id
(
  rrc_RB_Identity rb_id,
  rlc_lc_id_type dl_lc_id,
  uecomdef_logchan_e_type log_chl_type
)
{
  uint32 dch_count = 0;
  uint32 num_dlchan = 0;
  uint32 num_dch=0;
  uint32 dlchl_count=0;

 num_dch = ordered_config_ptr->mac_dl_parms.num_dchs;
 
  /* Look into all DCHs to get to the one mapped to the same RB ID */
  for(dch_count=0;(dch_count < num_dch);dch_count++)
  {
    num_dlchan = ordered_config_ptr->mac_dl_parms.dch_info[dch_count]->ndlchan;
    for(dlchl_count=0; dlchl_count< num_dlchan; dlchl_count++)
    {
      if((ordered_config_ptr->mac_dl_parms.dch_info[dch_count]->
          dlchan_info[dlchl_count].rb_id  == rb_id) &&
         (ordered_config_ptr->mac_dl_parms.dch_info[dch_count]->dlchan_info[dlchl_count].
            chan_type == log_chl_type))
      {
        /* This logical channel is of the same RB ID and the same logical
         * Channel type as is being setup.
         */
        ordered_config_ptr->mac_dl_parms.dch_info[dch_count]->
          dlchan_info[dlchl_count].rlc_id = dl_lc_id;
        return (TRUE);
      }
    }  /* for(...) */
  }  /* for(...) */
  return (FALSE);
}

/*====================================================================
FUNCTION: rrcllc_allocate_mem_for_prach_sel_info()

DESCRIPTION:
  This function initializes global prach_sel_info dynamically/statically based on whether feature 
  FEATURE MODEM HEAP is defined or not.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.
  
SIDE EFFECTS:
  None.

=====================================================================*/
void rrcllc_allocate_mem_for_prach_sel_info
(
  uint8 rrc_num_of_prach
)
{
  uint8 idx = 0;

  if(rrc_num_of_prach > 0 && rrc_num_of_prach <= UE_MAX_PRACH)
  {
    for(idx = 0; idx < rrc_num_of_prach; idx++)
    {
      prach_sel_info[idx] = (rrcllc_prach_sel_info_type *) modem_mem_calloc(1,sizeof(rrcllc_prach_sel_info_type),
            MODEM_MEM_CLIENT_WCDMA_RRC_GLOBAL_CRIT);

      if(prach_sel_info[idx] == NULL)
      {
        ERR_FATAL("PRACH_OPT: Couldn't alloc mem for idx %d for num %d PRACHs",idx,rrc_num_of_prach,0);
      }
    }
    WRRC_MSG1_HIGH("PRACH_OPT: Allocated %d PRACHs in prach_sel_info",rrc_num_of_prach);
  }
  else
  {
    WRRC_MSG1_ERROR("PRACH_OPT: Invalid no. of prachs %d",rrc_num_of_prach);
  }

}

/*====================================================================
FUNCTION: rrcllc_allocate_mem_for_prach_sel_info()

DESCRIPTION:
  This function resets global prach_sel_info.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.
  
SIDE EFFECTS:
  None.

=====================================================================*/
void rrcllc_deallocate_mem_for_prach_sel_info
(
  uint8 rrc_num_of_prach
)
{
  uint8 idx = 0;
  
  for(idx = 0; idx < rrc_num_of_prach; idx++)
  {
    if(prach_sel_info[idx] != NULL)
    {
      modem_mem_free((void *)prach_sel_info[idx], MODEM_MEM_CLIENT_WCDMA_RRC_GLOBAL_CRIT);
      prach_sel_info[idx] = NULL;
    }
    else
    {
      WRRC_MSG0_ERROR("PRACH_OPT: Something wrong happened.");
    }
  }

  WRRC_MSG2_HIGH("PRACH_OPT: De-Allocated %d PRACHs in prach_sel_info with %d PRACHs",idx,rrc_num_of_prach);

}



/*====================================================================
FUNCTION: rrcllc_update_drx_coef_length()

DESCRIPTION:
  This function is called when T319 timer expires(or is stopped) and updates the UTRAN DRX Cycle Coef Length

DEPENDENCIES:
  None.

RETURN VALUE:
  None
  
SIDE EFFECTS:

====================================================================*/

void rrcllc_update_drx_coef_length
(
  void
)
{
  if((utran_drx_cycle_info.utran_drx_cycle_length.length>= RRCLLC_UTRAN_MIN_DRX_CYCLE_LENGTH) && 
    (utran_drx_cycle_info.utran_drx_cycle_length.length <= RRCLLC_UTRAN_MAX_DRX_CYCLE_LENGTH)
    )
  {
    if(config_ptr_in_use == ORDERED_CONFIG)
    {
      ordered_config_ptr->utran_drx_cycle_length =
        (uint32) (1 << utran_drx_cycle_info.utran_drx_cycle_length.length);
    }
    else if(config_ptr_in_use == CURRENT_CONFIG)
    {
      current_config_ptr->utran_drx_cycle_length =
        (uint32) (1 << utran_drx_cycle_info.utran_drx_cycle_length.length);
    }
  }
  else
  {
    WRRC_MSG1_ERROR("UTRAN DRX Cycle Length Coefficient %d is not valid",
      utran_drx_cycle_info.utran_drx_cycle_length.length);
    return;
  }
  if((rrc_get_state() == RRC_STATE_CELL_PCH) ||(rrc_get_state() == RRC_STATE_URA_PCH) )
  {
    WRRC_MSG1_HIGH("UTRAN DRX:send_l1_drx_req, cycle_length=%d",
      (uint32) (1 << utran_drx_cycle_info.utran_drx_cycle_length.length));
    /*Send a request to L1 to update the UTRAN DRX Cycle Coef Length*/
    (void)rrc_csp_send_l1_drx_req_for_multiple_drx();
  }
}
/*====================================================================
FUNCTION: rrcllc_get_drx_info_for_multiple_drx()

DESCRIPTION:
  This function returns the shorter of the PS or CS CN DRX Cycle
  Length for multiple DRX support feature.

DEPENDENCIES:
  None.

RETURN VALUE:
  uint32 of the DRX Cycle length, per 25.304.

SIDE EFFECTS:
  None.
====================================================================*/
uint32 rrcllc_get_drx_info_for_multiple_drx(void)
{
  uint32 cs_drx = current_config_ptr->cs_drx_cycle_length;
  uint32 ps_drx = current_config_ptr->ps_drx_cycle_length;
  uint32 utran_drx = 0;
 
  uint32 qchat_drx = 0;
 
  if(config_ptr_in_use == ORDERED_CONFIG)
  {
    utran_drx = ordered_config_ptr->utran_drx_cycle_length;
    cs_drx = ordered_config_ptr->cs_drx_cycle_length;
    ps_drx = ordered_config_ptr->ps_drx_cycle_length;
  }
  else if(config_ptr_in_use == CURRENT_CONFIG)
  {
    utran_drx = current_config_ptr->utran_drx_cycle_length;
  }
  else
  {
    WRRC_MSG1_ERROR("UTRAN DRX Cycle Length Coefficient %d is not valid",
      utran_drx_cycle_info.utran_drx_cycle_length.length);
    return utran_drx_cycle_info.utran_drx_cycle_length.length;
  }

  /* We may not have a UTRAN DRX cycle length, so we must not consider
     it in this case.*/

  /* Get the QCHAT configured drx cycle length. If there is a successfully negotiated PS drx coeff available,
     use that as the PS drx value.
     Spec ref: 25.331 - 8.3 Discontinuous Reception for Paging
     The CS CN specific DRX cycle length coefficient shall be updated locally in the UE using
     information given in system information. On the other hand, the PS CN specific DRX cycle length 
     coefficient shall be updated after the negotiation between the UE and PS CN by NAS procedure.
     If no specific value "k" is negotiated in NAS procedure, the UE and PS CN shall use the DRX
     cycle length given for PS CN domain in system information.
  */
  qchat_drx = rrc_get_qchat_specific_drx_cycle_length();
  if((qchat_drx < ps_drx) && (qchat_drx !=0 ))
  {
    ps_drx = qchat_drx;
  }

  MSG_HIGH("DRX cs:%d, ps:%d, utran:%d", cs_drx,ps_drx, utran_drx);
  if(utran_drx == 0)
  {
    /* Return the DRX Cycle Length */
    if (cs_drx < ps_drx)
    {
      return cs_drx;
    }
    else
    {
      return ps_drx;
    }
  }
  else /* this is non idle case so must be cell_PCH/URA_PCH case */
  {
    /* find out the un-established domain.*/
    if ((rrcscr_get_signalling_connection_status (RRC_PS_DOMAIN_CN_ID) == FALSE) &&
        (rrcscr_get_signalling_connection_status (RRC_CS_DOMAIN_CN_ID) == TRUE))
    {
      if (ps_drx < utran_drx)
      {
        return ps_drx;
      }
      else
      {
        return utran_drx;
      }
      //return (ps_drx<utran_drx?ps_drx:utran_drx);
    }
    else if ((rrcscr_get_signalling_connection_status (RRC_CS_DOMAIN_CN_ID) == FALSE) &&
             (rrcscr_get_signalling_connection_status (RRC_PS_DOMAIN_CN_ID) == TRUE))
    {
      //return (cs_drx<utran_drx?cs_drx:utran_drx);
      if (cs_drx < utran_drx)
      {
        return cs_drx;
      }
      else
      {
        return utran_drx;
      }
    }
    else if ((rrcscr_get_signalling_connection_status (RRC_CS_DOMAIN_CN_ID) == TRUE) &&
             (rrcscr_get_signalling_connection_status (RRC_PS_DOMAIN_CN_ID) == TRUE))
    {
      return (utran_drx);
    }
    else /*((rrcscr_get_signalling_connection_status (RRC_CS_DOMAIN_CN_ID) == FALSE) &&
            (rrcscr_get_signalling_connection_status (RRC_PS_DOMAIN_CN_ID) == FALSE))*/
    {
      if(cs_drx <= ps_drx && cs_drx <= utran_drx)
      {
        return cs_drx;
      }
      else if(ps_drx <= cs_drx && ps_drx <= utran_drx)
      {
        return ps_drx;
      }
      else
      {
        return utran_drx;
      }
    }
  }
} /* end rrcllc_get_drx_info_for_multiple_drx() */

/*====================================================================
FUNCTION: rrcllc_set_am_dl_rlc_size_ota()

DESCRIPTION:
  This function sets the PDU type and size for AM RB .
  If the PDU tpe is 
    RRC_PDU_SIZE_NOT_SET then the OTA has not provided the RLC size explicitly, and
     it should be calculated from the TF sizes of Trch
  RRC_FIXED_PDU_SIZE_SET the OTA had explicitly given the rlc size 
  RRC_FLEXIBLE_PDU_SIZE_SET OTA has set the RB as Flexible PDU
  
DEPENDENCIES:
  None.

RETURN VALUE:
  None
  
SIDE EFFECTS:

====================================================================*/

void rrcllc_set_am_dl_rlc_size_ota
(
  rrc_RB_Identity rb_id,
  uint32 dl_rlc_am_pdu_size,
  rrc_am_rlc_pdu_enum_type pdu_type

)
{
  uint32 entity_idx =0;
  
  if((entity_idx = get_am_index_wo_f3(rb_id)) != UE_MAX_AM_ENTITY)
  {
    WRRC_MSG3_MED("Set PDU type as %d for rb id %d at idx %d",pdu_type,rb_id,entity_idx);
    ordered_config_ptr->rb_am_rlc_size_ota[entity_idx].rrc_pdu_type = pdu_type;

    ordered_config_ptr->rb_am_rlc_size_ota[entity_idx].dl_rlc_am_pdu_size = dl_rlc_am_pdu_size;
    ordered_config_ptr->rb_am_rlc_size_ota[entity_idx].rb_id = rb_id;
  }
}

/*====================================================================
FUNCTION: rrcllc_get_am_dl_rlc_size_ota()

DESCRIPTION:
  This function returns  the RLC size if it is provided by the N\W  for AM RB .
 
  
DEPENDENCIES:
  None.

RETURN VALUE:
  RLC size if the OTA provided the rlcc size, 
  0 if it is flexible pdu,
  RRCLLC_INVALID_RLC_SIZE if rlc size is not provided in ota
  
SIDE EFFECTS:

====================================================================*/
uint32 rrcllc_get_am_dl_rlc_size_ota
(
  rrc_RB_Identity rb_id
)
{
  uint32 entity_idx;
  ordered_config_type * config_ptr;
  
  if((transition_config.toc_usage == TOC_FOR_DCH_AND_FACH)
      ||(transition_config.toc_usage == TOC_FOR_FACH_AND_PCH)
      ||(transition_config.toc_usage == TOC_FOR_FACH_AND_PCH_WITH_DCH_INFO))
  {
    entity_idx = get_am_index_in_toc(rb_id);
    config_ptr= transition_config.toc_ptr;
    WRRC_MSG1_HIGH("TOC in use %d",transition_config.toc_usage);
  }
  else
  {
    entity_idx = get_am_index(rb_id);
    config_ptr= ordered_config_ptr;
    if(config_ptr_in_use == ORDERED_CONFIG )
    {
      WRRC_MSG0_MED("OC in use ");
    }
    else
    {
      WRRC_MSG0_ERROR("CC in use unexpected to call this function");
    }
  }
  
  if( entity_idx != UE_MAX_AM_ENTITY)
  {
    if(config_ptr->rb_am_rlc_size_ota[entity_idx].rb_id == rb_id)
    {
      if(  config_ptr->rb_am_rlc_size_ota[entity_idx].rrc_pdu_type == RRC_PDU_SIZE_NOT_SET)
      {
        WRRC_MSG1_HIGH("No  RLC size for RB id %d from OTA",rb_id);
        return RRCLLC_INVALID_RLC_SIZE;
      }
      else if (  config_ptr->rb_am_rlc_size_ota[entity_idx].rrc_pdu_type == RRC_FIXED_PDU_SIZE_SET)
      {
        WRRC_MSG2_MED(" RLC size for RB id %d from OTA %d",rb_id,
             config_ptr->rb_am_rlc_size_ota[entity_idx].dl_rlc_am_pdu_size);
        return  config_ptr->rb_am_rlc_size_ota[entity_idx].dl_rlc_am_pdu_size;
      }
      else
      {  
           WRRC_MSG1_MED("Flexible PDU  RLC size for RB id %d from OTA",rb_id);
        return 0;
      }
    }
  
  }
  WRRC_MSG1_ERROR("No rb entry in RLC size for RB id %d",rb_id);
  return RRCLLC_INVALID_RLC_SIZE;
  
}

/*====================================================================
FUNCTION: rrcllc_init_am_dl_rlc_size()

DESCRIPTION:
  This function inits the db which contains rlc size from ota .
 
  
DEPENDENCIES:
  None.

RETURN VALUE:
  None
  
SIDE EFFECTS:

====================================================================*/
void rrcllc_init_am_dl_rlc_size
(
  ordered_config_type *config_ptr,
  uint32 entity_idx
)
{
   config_ptr->rb_am_rlc_size_ota[entity_idx].rrc_pdu_type = RRC_PDU_SIZE_NOT_SET;

   config_ptr->rb_am_rlc_size_ota[entity_idx].dl_rlc_am_pdu_size = RRCLLC_INVALID_RLC_SIZE;
   config_ptr->rb_am_rlc_size_ota[entity_idx].rb_id = RRCLLC_INVALID_RB_ID;
}

void
rrcllc_init_config_ptrs
(
  void
)
{

  if(current_config_ptr == NULL)
  {
    WRRC_MSG0_HIGH("CC/OC/TOC already freed.");
    return;
  }
  rrcllc_init_ordered_config_status_and_data(RRC_STATE_DISCONNECTED);
  rrcllc_init_config_data(current_config_ptr, RRC_STATE_DISCONNECTED);

  rrcllc_init_config_data(transition_config.toc_ptr, RRC_STATE_DISCONNECTED);
  rrcllc_initialize_cm_parms();
}


/*====================================================================
FUNCTION: rrcllc_reset_l1_cpc_dtx_info_on_llc_cfg_cnf()

DESCRIPTION:
  This function resets the L1 variables related to CPC-DTX on receipt of LLC CONFIG CNF 
  by any procedure
  
DEPENDENCIES:
  None
  
RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_reset_l1_cpc_dtx_info_on_llc_cfg_cnf(void)
{
  ordered_config_type  *config_ptr;
  if(config_ptr_in_use == ORDERED_CONFIG)
  {
    config_ptr = ordered_config_ptr;
  }
  else
  {
    config_ptr = current_config_ptr;
  }
  if((config_ptr->l1_cpc_dtx_req_mask != L1_CPC_DTX_NO_OP) || (config_ptr->l1_cpc_drx_req_mask != L1_CPC_DRX_NO_OP))
  {
  WRRC_MSG2_HIGH("RRCCPC:Reset CPC-DTX/DRX  masks<Prev: l1_cpc_dtx_req_mask: %d,l1_cpc_drx_req_mask: %d,",
    config_ptr->l1_cpc_dtx_req_mask,config_ptr->l1_cpc_drx_req_mask);
  }
  config_ptr->l1_cpc_dtx_req_mask = L1_CPC_DTX_NO_OP;
  
  config_ptr->l1_cpc_drx_req_mask = L1_CPC_DRX_NO_OP;

}

/*====================================================================
FUNCTION: rrcllc_determine_hsdpa_action_r8()

DESCRIPTION:
  This function determines the HSDPA action and sets the parameters in L1
  structure accordingly.
  
DEPENDENCIES:
  None.

RETURN VALUE:
  Sucess if HSDPA action and parameters have been set
  Failure Otherwise

SIDE EFFECTS:
====================================================================*/
uecomdef_status_e_type rrcllc_determine_hsdpa_action_r8
(
  rrc_DL_HSPDSCH_Information_r8* hspdsch_info_ptr
)
{
  /* HSDPA params have already been set in rrc_hsdpa_params.
  Check if HSDPA is already ACTIVE */
  if (rrc_get_hsdpa_status() == HSDPA_INACTIVE)
  {
    /* HSDPA is currently inactive */
    /* Check if network wants to activate HSDPA */
    if (hsdpa_msg_params.msg_params_present == TRUE)
    {
      if (hsdpa_msg_params.hspdsch_info_present == TRUE)
      {
        /* Check if channelization codes and feedback info present */
        if(RRC_MSG_COMMON_BITMASK_IE_PTR(hspdsch_info_ptr,rrc_DL_HSPDSCH_Information_r8,hs_scch_Info)) 
        {
          if (set_hsscch_info_r7(&hspdsch_info_ptr->hs_scch_Info) == FAILURE)
          {
            return FAILURE;
          }
        }
        if(RRC_MSG_COMMON_BITMASK_IE_PTR(hspdsch_info_ptr,rrc_DL_HSPDSCH_Information_r8,measurement_feedback_Info))
        {
          /* Set Meas Feedback Info */
          if (set_meas_feedback_info_r7(&hspdsch_info_ptr->measurement_feedback_Info) == FAILURE)
          {
            return FAILURE;
          }
        }
      }
      /* Set HS-RL */
      if (hsdpa_msg_params.rl_link_present == TRUE)
      {
        /* Set Radio Link in L1 HSDPA structure */
        ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc = hsdpa_msg_params.new_rl_link;
        WRRC_MSG1_MED("REL8:New HS RL %d set in L1 struct",ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc);
      }
    } /* End of if of hsdpa message params absent */
    else
    {
      rrc_set_hsdpa_action(HSDPA_NOOP);
      rrc_reset_mac_ehs_params(ordered_config_ptr);
      return SUCCESS;
    }

    /* Set Queue Info */
    if (set_hsdpa_l1_queue_info() == FAILURE)
    {
      WRRC_MSG0_ERROR("REL8:Unable to set Queue Info");
      return FAILURE;
    }

    /* Final Check to make sure that everything is present */
    if (rrcllc_check_if_hsdpa_can_be_started_reconfigured(ordered_config_ptr) == FALSE)
    {
      rrc_set_hsdpa_action(HSDPA_NOOP);
      rrc_reset_mac_ehs_params(ordered_config_ptr);
      return SUCCESS;
    }

    rrc_set_hsdpa_action(HSDPA_START);

    /* Set Bit Mask */
    ordered_config_ptr->l1_hsdpa_info.hs_req_mask = CPHY_HS_DSCH_CFG_INCL | 
      CPHY_HS_PDSCH_RL_CFG_INCL | CPHY_HS_SCCH_CFG_INCL | CPHY_HS_DPCCH_CFG_INCL;

    ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 
      HS_DPCCH_BETA_HS_INFO_PRESENT_BITMASK | HS_DPCCH_MEAS_FEEDBACK_INFO_PRESENT_BITMASK;


    WRRC_MSG2_MED("REL8:hs_req_mask 0X%x. info_present_bitmask 0X%x", ordered_config_ptr->l1_hsdpa_info.hs_req_mask,
             ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask);

#ifdef FEATURE_WCDMA_HS_FACH
     /*For EFACH to MAC-HS transitions*/
    if(current_config_ptr->hs_status_in_e_fach  == FALSE)
 #endif
    {
    WRRC_MSG0_HIGH("REL8:Force HS-RESET to FALSE");
    ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator = FALSE;
    }

    return SUCCESS;
  }
  /*The following deals with the scenarios when HSDPA is already ACTIVE and HS action needs to be decided.*/
  else
  {
    ordered_config_ptr->l1_hsdpa_info.hs_req_mask = 0;
    ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 0;  

    WRRC_MSG0_HIGH("REL8:HSDPA already active");

    if (hsdpa_msg_params.msg_params_present == TRUE)
    {
      return rrcllc_determine_hsdpa_action_for_hsdpa_active_r8(hspdsch_info_ptr);
    }
    else
    {
      /*It means that HSDPA ia already ACTIVE but OTA hasn't provided the HSDPA parameters*/
      /* So Final Check to make sure that everything is present */
      if (rrcllc_check_if_hsdpa_can_be_started_reconfigured(ordered_config_ptr) == FALSE)
      {
        rrc_set_hsdpa_action(HSDPA_STOP);
        return SUCCESS;
      }

      if (ordered_config_ptr->dest_freq_present == TRUE)
      {
        WRRC_MSG0_HIGH("REL8: FORCED SYNC A with HSDPA_RECONFIG");
        rrc_set_hsdpa_action(HSDPA_RECONFIG);
        return SUCCESS;
      }

      /* Means No Action has to be taken for HSDPA. i.e.*/
      rrc_set_hsdpa_action(HSDPA_NOOP);

      return SUCCESS;
    }
  }
}

/*====================================================================
FUNCTION: rrcllc_determine_hsdpa_action_for_hsdpa_active_r8()

DESCRIPTION:
  This function determines the HSDPA action when HSDPA ia already ACTIVE. 
  
DEPENDENCIES:
  None.

RETURN VALUE:
  Sucess if HSDPA action and parameters have been set
  Failure Otherwise

SIDE EFFECTS:
====================================================================*/
uecomdef_status_e_type rrcllc_determine_hsdpa_action_for_hsdpa_active_r8
(
  rrc_DL_HSPDSCH_Information_r8* hspdsch_info_ptr
)
{
  uint8 reconfig_bit_mask = 0;
  boolean hsscch_codes_changed = FALSE;
  boolean hsdpcch_changed = FALSE;
  boolean b_table_changed = FALSE;  

  MSG_9(MSG_SSID_DFLT, MSG_LEGACY_HIGH,"hsdpa_params_present:%d,rl_link_present:%d,ifhho_involved:%d, intra_hho_involved:%d,new_rl_link:%d,hrnti_present:%d, dest_freq_present:%d, hsdpa_msg_params.hsdsch_info_present:%d, hsdpa_msg_params.hrnti_changed %d",
            hsdpa_msg_params.msg_params_present,
            hsdpa_msg_params.rl_link_present,
            hsdpa_msg_params.ifhho_involved,
            hsdpa_msg_params.intra_hho_involved,
            hsdpa_msg_params.new_rl_link,
            hsdpa_msg_params.hrnti_present,
            ordered_config_ptr->dest_freq_present,
            hsdpa_msg_params.hsdsch_info_present,
            hsdpa_msg_params.hrnti_changed
            );

  /* Now check if InterF Hard Handoff is involved */
  if ((hsdpa_msg_params.rl_link_present == FALSE) &&
    (hsdpa_msg_params.ifhho_involved == TRUE))
  {
    rrc_set_hsdpa_action(HSDPA_STOP);
    return SUCCESS;
  }

  /* Check if Intra Freq HO involved */
  if ((hsdpa_msg_params.rl_link_present == FALSE) &&
    (hsdpa_msg_params.intra_hho_involved == TRUE))
  {
    rrc_set_hsdpa_action(HSDPA_STOP);
    return SUCCESS;
  }

  /*InterF or IntraF HO is happening and RL is given*/
  if(((hsdpa_msg_params.ifhho_involved == TRUE)||(hsdpa_msg_params.intra_hho_involved == TRUE)) 
    && (hsdpa_msg_params.rl_link_present == TRUE))
  {

    /* If Re-pointing is happenning then H-RNTI should be provided */
    if (hsdpa_msg_params.hrnti_present == FALSE)
    {
      WRRC_MSG0_ERROR("REL8:H-RNTI absent for HS Hard Repointing.");
      return FAILURE;
    }
    ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc = hsdpa_msg_params.new_rl_link;
    reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_PDSCH_RL_CFG_INCL | CPHY_HS_DSCH_CFG_INCL;
  }
  else if (ordered_config_ptr->dest_freq_present == TRUE)
  {
    WRRC_MSG1_HIGH("REL8:SYNC A procedure triggered freq %d Set HS-DSCH in bit_mask ",
           ordered_config_ptr->dest_freq);
   
    reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_DSCH_CFG_INCL;
  }
  if ((hsdpa_msg_params.rl_link_present == TRUE) &&
      (hsdpa_msg_params.intra_hho_involved == FALSE) &&
      (hsdpa_msg_params.ifhho_involved == FALSE) &&
      (hsdpa_msg_params.new_rl_link != ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc))
  {
    WRRC_MSG1_HIGH("REL8: HS Soft Repointing to PSC %d", hsdpa_msg_params.new_rl_link);
    ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc = hsdpa_msg_params.new_rl_link;
    reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_PDSCH_RL_CFG_INCL;
  }

  /* Check if SRB Delay, DPCCH Power Offset & PC Preamble Information was indicated
  in the message & Sync A Procedure is not involved. If yes, then rewrite the old information from CC 
  as the new information needs to be ignored */
  if ((ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.valid == TRUE) &&
    (ordered_config_ptr->dest_freq_present == FALSE) && 
    (hsdpa_msg_params.intra_hho_involved == FALSE) &&
    (hsdpa_msg_params.ifhho_involved == FALSE))
  {
    WRRC_MSG0_HIGH("REL8: Ignore SRBDelay/PCPreamble/POffset");

    /* Get them from CC. Do validation check to be doubly sure that CC values are valid */
    if ((current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.valid == TRUE) &&
      (current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.dpcch_pwr_offset
      <= 2*RRCLLC_UL_DPCCH_PWR_OFFSET_MAX) && 
      (current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.dpcch_pwr_offset
      >= 2*RRCLLC_UL_DPCCH_PWR_OFFSET_MIN) && 
      (current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.pcp_len < 8) && 
      (current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.srb_delay < 8))
    {
      MSG_6(MSG_SSID_DIAG, MSG_LEGACY_HIGH,"RRCHS: PO Offset OC %d CC %d PCP Length OC %d CC %d SRB Delay OC %d CC %d", 
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.dpcch_pwr_offset,
        current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.dpcch_pwr_offset,
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.pcp_len,
        current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.pcp_len,
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.srb_delay,
        current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.srb_delay);
      
      /* Copy Old information from CC */
      ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.dpcch_pwr_offset =
        current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.dpcch_pwr_offset;
      
      ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.pcp_len =
        current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.pcp_len;
      
      ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.srb_delay =
        current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.srb_delay;
    }
  }

  if ((hsdpa_msg_params.rl_link_present == TRUE) &&
      (hsdpa_msg_params.intra_hho_involved == FALSE) &&
      (hsdpa_msg_params.ifhho_involved == FALSE))
  {
    ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc = hsdpa_msg_params.new_rl_link;
  }
  
  if (hsdpa_msg_params.hspdsch_info_present == TRUE)
  {
    /*Process HS-SCCH Info*/
    if (RRC_MSG_COMMON_BITMASK_IE_PTR(hspdsch_info_ptr,rrc_DL_HSPDSCH_Information_r8,hs_scch_Info))
    {
      /* Check if HS-SCCH Info has changed */
      if (rrcllc_check_if_hsscch_changed(&hspdsch_info_ptr->hs_scch_Info,MSG_REL8) == TRUE)
      {
        hsscch_codes_changed = TRUE;
      }

      if (set_hsscch_info_r7(&hspdsch_info_ptr->hs_scch_Info) == FAILURE)
      {
        return FAILURE;
      }
      else
      {
        if (hsscch_codes_changed == TRUE)
        {
          WRRC_MSG0_HIGH("REL8:SCCH Info changed");
          reconfig_bit_mask =reconfig_bit_mask | CPHY_HS_SCCH_CFG_INCL;
        }
      }
    }

    /*Process Measurement Feedback Info.*/ 
    if(RRC_MSG_COMMON_BITMASK_IE_PTR(hspdsch_info_ptr,rrc_DL_HSPDSCH_Information_r8,measurement_feedback_Info))
    {
      /* Check if Meas Feedback Info has changed */
      rrcllc_check_if_meas_feedback_changed_r7(&hspdsch_info_ptr->measurement_feedback_Info, 
                                            &b_table_changed, &hsdpcch_changed);

      if (set_meas_feedback_info_r7(&hspdsch_info_ptr->measurement_feedback_Info) == FAILURE)
      {
        return FAILURE;
      }
      else
      {
        if(b_table_changed == TRUE)
        {
          ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 
            HS_DPCCH_BETA_HS_INFO_PRESENT_BITMASK;
          reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_DPCCH_CFG_INCL;

        }
        if(hsdpcch_changed == TRUE)
        {
          ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 
            ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask |
            HS_DPCCH_MEAS_FEEDBACK_INFO_PRESENT_BITMASK;
          reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_DPCCH_CFG_INCL;

        }
      }
    }
#ifdef FEATURE_WCDMA_64QAM
    if(current_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured !=
           ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured)
    {
      hsdpa_msg_params.hsdsch_info_present = TRUE;
      WRRC_MSG0_HIGH("Set HS-DSCh bitmask as 64 QAM config is changed ");
    }
#endif
  }/*HS-PDSCH Info is present in hsdpa_msg_params*/

  /* Check if only beta table has changed */
  if ((b_table_changed == FALSE) && (hsdpa_msg_params.beta_table_present == TRUE))
  {
    ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 
      HS_DPCCH_BETA_HS_INFO_PRESENT_BITMASK;
    reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_DPCCH_CFG_INCL;

    WRRC_MSG0_HIGH("REL8:Beta Table changed for HS.");
  }

  /* Check if only beta table has changed */
  if ((hsdpcch_changed == FALSE) && (hsdpa_msg_params.hs_dpcch_info_present == TRUE))
  {
    ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 
      HS_DPCCH_MEAS_FEEDBACK_INFO_PRESENT_BITMASK;
    reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_DPCCH_CFG_INCL;

    WRRC_MSG0_HIGH("REL8:Meas Feedback changed for HS.");
  }

  /* Final Check to make sure that everything is present */
  if (rrcllc_check_if_hsdpa_can_be_started_reconfigured(ordered_config_ptr) == FALSE)
  {
    rrc_set_hsdpa_action(HSDPA_STOP);
    return SUCCESS;
  }

  MSG_6(MSG_SSID_DIAG, MSG_LEGACY_HIGH,"RRCHS: hsdpa_msg_params.hspdsch_info_present %d hsscch_codes_changed %d,b_table_changed %d hsdpcch_changed %d,hsdpa_msg_params.beta_table_present %d hsdpa_msg_params.hs_dpcch_info_present %d", 
            hsdpa_msg_params.hspdsch_info_present,
            hsscch_codes_changed,
            b_table_changed,
            hsdpcch_changed,
            hsdpa_msg_params.beta_table_present,
            hsdpa_msg_params.hs_dpcch_info_present);

  /* Check if HS-DPCCH Info has changed */
  if (hsdpa_msg_params.hs_dpcch_info_present == TRUE)
  {
    reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_DPCCH_CFG_INCL;
  }

  /* Set the queue information */
  if(set_hsdpa_l1_queue_info() == FAILURE)
  {
    WRRC_MSG0_ERROR("REL8:Unable to set HSDPA info in L1");
    return FAILURE;
  }
  else
  {
    if((hsdpa_msg_params.hsdsch_info_present == TRUE) || 
      ((hsdpa_msg_params.hrnti_present == TRUE) && (hsdpa_msg_params.hrnti_changed == TRUE)))
    {
      reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_DSCH_CFG_INCL;
    }
  }

  if ((reconfig_bit_mask == 0) && (ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator == FALSE) &&
      ordered_config_ptr->dest_freq_present == FALSE)
  {
    rrc_set_hsdpa_action(HSDPA_NOOP);
    return SUCCESS;
  }

  ordered_config_ptr->l1_hsdpa_info.hs_req_mask = reconfig_bit_mask;

  /* Set Action to RECONFIG */
  MSG_3(MSG_SSID_DIAG, MSG_LEGACY_HIGH,"RRCHS:HSRECONFIG bit mask/ordered_config_ptr->l1_hsdpa_info.hs_req_mask %d,HS-RESET %d, ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask %d",
               reconfig_bit_mask,
               ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator,
               ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask);
  rrc_set_hsdpa_action(HSDPA_RECONFIG);
  return SUCCESS;
}

#ifdef FEATURE_WCDMA_DC_HSDPA
/*============================================================================
FUNCTION: 
static void rrc_update_sec_hsdpa_hs_scch_order_activation_status_to_oc()

DESCRIPTION:
L1 will call this API to update the scch order activation
DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
=============================================================================*/
void rrcllc_update_sec_hsdpa_hs_scch_order_activation_status_to_oc(uint8 activation_status, boolean oc_update_needed)
{
  uint8 ix=0;
  boolean local_act_status = FALSE;
  if((rrcllcpcie_return_num_sec_hsdpa_carriers(ordered_config_ptr) == 0) && (rrcllcpcie_return_num_sec_hsdpa_carriers(current_config_ptr) == 0))
  {
    return;
  }
  WRRC_MSG2_HIGH("3CHSDPA_DEBUG: Update HS SCCH activation status, activation_status: %x, oc_update_needed: %d",activation_status,oc_update_needed);
  for(ix=0; ix<MAX_NUM_OF_SEC_CARRIERS; ix++)
  {
    /* By default activation status will be st to TRUE */
    ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[ix].activation_status = TRUE;
    if(current_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[ix].sec_hsdpa_action == L1_SEC_HSDPA_RECFG)
    {
      if(activation_status & 0x1)
      {
        local_act_status = TRUE;
      }
      else
      {
        local_act_status = FALSE;
      }
      /* Always update the scch_order_activation_status in CC */
      current_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[ix].activation_status = local_act_status;
      /* Only if OC update needed is set to TRUE we will update the scch order activation status to OC */
      if(oc_update_needed == TRUE)
      {
        ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[ix].activation_status = local_act_status;
      }
      /* Code logic skips the carrier position which is not configured(action != RECFG)*/
      /* As L1 will do re-arrangement and will have only configured carriers, 
         each bit in activation status corresponds to the carriers that were configured in CC */
      activation_status = (activation_status >> 1);
    }
  }
}

/*============================================================================
FUNCTION: rrcllc_init_sec_hsdpa_params()

DESCRIPTION: This function resets DC-HSDPA parameters in Config DB (CC/OC). It also
  resets global status of DC-HSDPA.

DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
void rrcllc_init_sec_hsdpa_params
(
  ordered_config_type *config_ptr
)
{

  uint8 idx=0;
  /*The following is done for the sake of better readability*/
  if(config_ptr->l1_hsdpa_info.hs_req_mask & CPHY_HS_SEC_HSDPA_CFG_INCL)
  {
    config_ptr->l1_hsdpa_info.hs_req_mask &= ~CPHY_HS_SEC_HSDPA_CFG_INCL;    
  }
  /*Loop through max no of hs sec carrier info and reset. while adding 3C code*/
  for(idx=0; idx < MAX_NUM_OF_SEC_CARRIERS; idx++)
  {
    config_ptr->l1_hsdpa_info.sec_hs_carrier_info[idx].sec_hsdpa_action = L1_SEC_HSDPA_STOP;
		
    config_ptr->l1_hsdpa_info.sec_hs_carrier_info[idx].activation_status = TRUE;
  /*There's no valid need to reset H-RNTI because it's mandatory field and its validation is done
  while storing it.*/

    config_ptr->l1_hsdpa_info.sec_hs_carrier_info[idx].hs_sec_cell_64_qam_configured = FALSE;

    config_ptr->l1_hsdpa_info.sec_hs_carrier_info[idx].diff_txd_mode = FALSE;

    config_ptr->l1_hsdpa_info.sec_hs_carrier_info[idx].hs_sec_cell_tb_size_alignment_type = 
    L1_DL_HS_DSCH_TB_TABLE_OCTET_UNALIGNED;

    config_ptr->l1_hsdpa_info.sec_hs_carrier_info[idx].pri_cpich_scr_code = RRCLLC_INVALID_CPICH_SCR_CODE;

    config_ptr->l1_hsdpa_info.sec_hs_carrier_info[idx].hs_sec_cell_scch_info.sec_scr_code_valid = FALSE;
    config_ptr->l1_hsdpa_info.sec_hs_carrier_info[idx].hs_sec_cell_scch_info.sec_scr_code = (uint8)RRCLLC_INVALID_CPICH_SCR_CODE;
    config_ptr->l1_hsdpa_info.sec_hs_carrier_info[idx].hs_sec_cell_scch_info.num_ch_code = 0;
  /*Since num_ch_code is 0, no need to init each SCCH channelisation codes*/

    config_ptr->l1_hsdpa_info.sec_hs_carrier_info[idx].po_hs_dsch_sec_cell = RRCLLC_INVALID_MEAS_PWR_OFFSET;
    config_ptr->l1_hsdpa_info.sec_hs_carrier_info[idx].hs_sec_cell_dl_freq = RRCLLC_INVALID_DL_FREQ;

#ifdef FEATURE_WCDMA_3C_HSDPA
    config_ptr->mac_dl_parms.tsn_extn= FALSE;
#endif
  }
  return;
}

#ifdef FEATURE_WCDMA_3C_HSDPA
/*============================================================================
FUNCTION: 
static uecomdef_status_e_type rrcllc_validate_sec_carrier_freq_3c(void)

DESCRIPTION: This function validated the secondary carriers for 3C

DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/

static uecomdef_status_e_type rrcllc_validate_sec_carrier_freq_3c(void)
{

  rrc_csp_band_class_type primary_band, sec_band1, sec_band2;
  uint32 pri_uarfcn, primary_freq, sec_freq1, sec_freq2;
  uint16 band_comb_configured = 0;
  uint32 carrier_freq[3];
  uecomdef_status_e_type status = FAILURE;
  uint8 ix;
  
  pri_uarfcn = (ordered_config_ptr->dest_freq_present == TRUE) ? ordered_config_ptr->dest_freq : rrc_ccm_get_curr_camped_freq();
  primary_band = rrc_get_frequency_band(pri_uarfcn,rrc_ccm_get_curr_camped_plmn());
  primary_freq = rfm_get_freq_from_dl_arfcn(pri_uarfcn);
  for(ix=0; ix<MAX_NUM_OF_SEC_CARRIERS;ix++)
  {
    if(ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[ix].sec_hsdpa_action == L1_SEC_HSDPA_RECFG)
    {
      sec_band1= rrc_get_frequency_band(ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[ix].hs_sec_cell_dl_freq,rrc_ccm_get_curr_camped_plmn());
      sec_freq1=rfm_get_freq_from_dl_arfcn(ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[ix].hs_sec_cell_dl_freq);
      ix++;
      break;
    }
  }
  for(; ix<MAX_NUM_OF_SEC_CARRIERS; ix++)
  {
    if(ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[ix].sec_hsdpa_action == L1_SEC_HSDPA_RECFG)
    {
      sec_band2= rrc_get_frequency_band(ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[ix].hs_sec_cell_dl_freq,rrc_ccm_get_curr_camped_plmn());
      sec_freq2=rfm_get_freq_from_dl_arfcn(ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[ix].hs_sec_cell_dl_freq);
      break;
    }
  }
  /*
  	 3GPP TS 25.101: "UE Radio Transmission and Reception (FDD)".
  	 
  	 Table 3 2	Single band 3C/4C-HSDPA configurations	
  	 Single band 3C/4C-HSDPA Configuration
  	 I-3
  	 
  	 Table 3 3	Dual band 3C/4C-HSDPA configurations
  	 Dual band 3C/4C-HSDPA Configuration
  	 I-2-VIII-1
  	 I-3-VIII-1
  	 II-1-IV-2
  	 II-2-IV-1
  	 II-2-IV-2
  	 I-1-V-2
  	 I-2-V-1
  	 I-2-V-2
   */
   
  if((primary_band == RRC_CSP_IMT2K_BAND) && (sec_band1 == RRC_CSP_IMT2K_BAND) && (sec_band2 == RRC_CSP_IMT2K_BAND))
  {
    carrier_freq[0] = primary_freq;
    carrier_freq[1] = sec_freq1;
    carrier_freq[2] = sec_freq2;
    return rrcllc_verify_contiguous_carriers(carrier_freq, 3);
  }
  else if((RRC_SB_3C_BANDII_SUPPORTED & rrc_feature_nv_item_value) && (primary_band == RRC_CSP_PCS_BAND) && (sec_band1 == RRC_CSP_PCS_BAND) && (sec_band2 == RRC_CSP_PCS_BAND))
  {
    carrier_freq[0] = primary_freq;
    carrier_freq[1] = sec_freq1;
    carrier_freq[2] = sec_freq2;
    return rrcllc_verify_contiguous_carriers(carrier_freq,3);
  }
  if((primary_band == RRC_CSP_IMT2K_BAND) && (sec_band1 == RRC_CSP_IMT2K_BAND) && (sec_band2 == RRC_CSP_WCDMA_900_BAND ))
  {
    band_comb_configured = RRC_DB_DC_BAND1_BAND8;
    carrier_freq[0] = primary_freq;
    carrier_freq[1] = sec_freq1;
    status = rrcllc_verify_contiguous_carriers(carrier_freq, 2);
  }
  else if((primary_band == RRC_CSP_IMT2K_BAND) && (sec_band2 == RRC_CSP_IMT2K_BAND) && (sec_band1 == RRC_CSP_WCDMA_900_BAND))
  {
    band_comb_configured = RRC_DB_DC_BAND1_BAND8;
    carrier_freq[0] = primary_freq;
    carrier_freq[1] = sec_freq2;
    status = rrcllc_verify_contiguous_carriers(carrier_freq, 2);
  }
  else if((sec_band1 == RRC_CSP_IMT2K_BAND) && (sec_band2 == RRC_CSP_IMT2K_BAND) && (primary_band == RRC_CSP_WCDMA_900_BAND))
  {
    band_comb_configured = RRC_DB_DC_BAND1_BAND8;
    carrier_freq[0] = sec_freq1;
    carrier_freq[1] = sec_freq2;
    status = rrcllc_verify_contiguous_carriers(carrier_freq, 2);
  }
  else if((primary_band == RRC_CSP_PCS_BAND) && (sec_band1 == RRC_CSP_PCS_BAND) && (sec_band2 == RRC_CSP_WCDMA_1700_2100_BAND ))
  {
    band_comb_configured = RRC_DB_DC_BAND2_BAND4;
    carrier_freq[0] = primary_freq;
    carrier_freq[1] = sec_freq1;
    status = rrcllc_verify_contiguous_carriers(carrier_freq, 2);
  }
  else if((primary_band == RRC_CSP_PCS_BAND) && (sec_band2 == RRC_CSP_PCS_BAND) && (sec_band1 == RRC_CSP_WCDMA_1700_2100_BAND))
  {
  	band_comb_configured = RRC_DB_DC_BAND2_BAND4;
  	carrier_freq[0] = primary_freq;
  	carrier_freq[1] = sec_freq2;
  	status = rrcllc_verify_contiguous_carriers(carrier_freq, 2);
  }
  else if((sec_band1 == RRC_CSP_PCS_BAND) && (sec_band2 == RRC_CSP_PCS_BAND) && (primary_band == RRC_CSP_WCDMA_1700_2100_BAND))
  {
  	band_comb_configured = RRC_DB_DC_BAND2_BAND4;
  	carrier_freq[0] = sec_freq2;
  	carrier_freq[1] = sec_freq1;
  	status = rrcllc_verify_contiguous_carriers(carrier_freq, 2);
  }
  else if((primary_band == RRC_CSP_WCDMA_1700_2100_BAND) && (sec_band1 == RRC_CSP_WCDMA_1700_2100_BAND) && (sec_band2 == RRC_CSP_PCS_BAND ))
  {
  	band_comb_configured = RRC_DB_DC_BAND2_BAND4;
  	carrier_freq[0] = primary_freq;
  	carrier_freq[1] = sec_freq1;
  	status = rrcllc_verify_contiguous_carriers(carrier_freq, 2);
  }
  else if((primary_band == RRC_CSP_WCDMA_1700_2100_BAND) && (sec_band2 == RRC_CSP_WCDMA_1700_2100_BAND) && (sec_band1 == RRC_CSP_PCS_BAND))
  {
  	band_comb_configured = RRC_DB_DC_BAND2_BAND4;
  	carrier_freq[0] = primary_freq;
  	carrier_freq[1] = sec_freq2;
  	status = rrcllc_verify_contiguous_carriers(carrier_freq, 2);
  }
  else if((sec_band1 == RRC_CSP_WCDMA_1700_2100_BAND) && (sec_band2 == RRC_CSP_WCDMA_1700_2100_BAND) && (primary_band == RRC_CSP_PCS_BAND))
  {
  	band_comb_configured = RRC_DB_DC_BAND2_BAND4;
  	carrier_freq[0] = sec_freq2;
  	carrier_freq[1] = sec_freq1;
  	status = rrcllc_verify_contiguous_carriers(carrier_freq, 2);
  }
  else if((primary_band == RRC_CSP_IMT2K_BAND) && (sec_band1 == RRC_CSP_IMT2K_BAND) && (sec_band2 == RRC_CSP_WCDMA_1800_BAND ))
  {
  	band_comb_configured = RRC_DB_DC_BAND1_BAND5;
  	carrier_freq[0] = primary_freq;
  	carrier_freq[1] = sec_freq1;
  	status = rrcllc_verify_contiguous_carriers(carrier_freq, 2);
  }
  else if((primary_band == RRC_CSP_IMT2K_BAND) && (sec_band2 == RRC_CSP_IMT2K_BAND) && (sec_band1 == RRC_CSP_WCDMA_1800_BAND))
  {
  	band_comb_configured = RRC_DB_DC_BAND1_BAND5;
  	carrier_freq[0] = primary_freq;
  	carrier_freq[1] = sec_freq2;
  	status = rrcllc_verify_contiguous_carriers(carrier_freq, 2);
  }
  else if((sec_band1 == RRC_CSP_IMT2K_BAND) && (sec_band2 == RRC_CSP_IMT2K_BAND) && (primary_band == RRC_CSP_WCDMA_1800_BAND))
  {
  	band_comb_configured = RRC_DB_DC_BAND1_BAND5;
  	carrier_freq[0] = sec_freq2;
  	carrier_freq[1] = sec_freq1;
  	status = rrcllc_verify_contiguous_carriers(carrier_freq, 2);
  }
  else if((primary_band == RRC_CSP_WCDMA_1800_BAND) && (sec_band1 == RRC_CSP_WCDMA_1800_BAND) && (sec_band2 == RRC_CSP_IMT2K_BAND ))
  {
  	band_comb_configured = RRC_DB_DC_BAND1_BAND5;
  	carrier_freq[0] = primary_freq;
  	carrier_freq[1] = sec_freq1;
  	status = rrcllc_verify_contiguous_carriers(carrier_freq, 2);
  }
  else if((primary_band == RRC_CSP_WCDMA_1800_BAND) && (sec_band2 == RRC_CSP_WCDMA_1800_BAND) && (sec_band1 == RRC_CSP_IMT2K_BAND))
  {
  	band_comb_configured = RRC_DB_DC_BAND1_BAND5;
  	carrier_freq[0] = primary_freq;
  	carrier_freq[1] = sec_freq2;
  	status = rrcllc_verify_contiguous_carriers(carrier_freq, 2);
  }
  else if((sec_band1 == RRC_CSP_WCDMA_1800_BAND) && (sec_band2 == RRC_CSP_WCDMA_1800_BAND) && (primary_band == RRC_CSP_IMT2K_BAND))
  {
  	band_comb_configured = RRC_DB_DC_BAND1_BAND5;
  	carrier_freq[0] = sec_freq2;
  	carrier_freq[1] = sec_freq1;
  	status = rrcllc_verify_contiguous_carriers(carrier_freq, 2);
  }
  else
  {
  	return status;
  }
  for (ix = 0;ix < db_dc_band_comb_list.num_db_dc_band_comb_supp; ix++)
  {
  	if(db_dc_band_comb_list.db_dc_band_comb_list[ix] == band_comb_configured)
  	{
  		WRRC_MSG1_HIGH("DB-DC-band combination found %d by UE",band_comb_configured);
  		break;
  	}
  }
  /* Bands supported on DB_DC need not be supported on 3C */
  if(ix == db_dc_band_comb_list.num_db_dc_band_comb_supp)
  {
    WRRC_MSG1_ERROR("DB-3C-band combination not supported by UE: %d",
		band_comb_configured);
  	return FAILURE;
  } 
  return status;
}


#endif
/*====================================================================
FUNCTION: rrcllc_validate_hs_ehs_window_size_for_sec()

DESCRIPTION:
  This function checks if the window size is greater than 32.

DEPENDENCIES:
  None

RETURN VALUE:
  boolean

SIDE EFFECTS:
  None.
====================================================================*/
boolean rrcllc_validate_hs_ehs_window_size_for_sec
(
  rrc_RRC_StateIndicator rrc_rcvd_state
)
{
  uint8 count=0;
  ordered_config_type* config_ptr = NULL;

  /* This function will return failure even if there are hanging queues with window size 32 */
    
  if((rrc_rcvd_state != rrc_RRC_StateIndicator_cell_DCH) && (rrc_get_state() != RRC_STATE_CELL_DCH) && (transition_config.toc_usage != TOC_INVALID))
  {
    config_ptr = transition_config.toc_ptr;
  }  
  /* For cases within DCH and DCH to FACH, and FACH to DCH OC should be checked */  
  else
  {
    config_ptr = ordered_config_ptr;
  }

  /* Checking only for EHS because for HS the max window size possible is only 32 */
  /*
        MAC-hs-WindowSize ::= ENUMERATED {mws4 , mws6 , mws8 , mws12 , mws16 , mws24 , mws32 } 
        MAC-hs-WindowSize-r9 ::= ENUMERATED {mws4 , mws6 , mws8 , mws12 , mws16 , mws24 , mws32 , mw64 , mw128 } 
    */
  if(config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_EHS )
  {
    for (count = 0; count < config_ptr->mac_dl_parms.num_mac_ehs_queue; count++)
    {
      /* Check that there is at least one MAC-D FLow */
      if (config_ptr->mac_ehs_queue_info[count].queue_id != INVALID_QUEUE_ID )					 
      {
        /* Check if the window is proper with TSN */
        if(config_ptr->mac_ehs_queue_info[count].window_size > 32)
        {
           WRRC_MSG1_ERROR("3CHSDPA_DEBUG: window size : %d is not valid ",config_ptr->mac_ehs_queue_info[count].window_size);
           return FALSE;
        }
      }
    }
  }
  return TRUE;
}
/*============================================================================
FUNCTION: rrcllc_validate_sec_hsdpa_config()

DESCRIPTION: When this function returns FALSE, the Reconfug Failure is sent in the OTA.
  The following validations are done here.
  1. Make sure MIMO is not active with DC-HSDPA.
  2. Total no. of HS-SCCH codes doesn't exceed 6

DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
boolean rrcllc_validate_sec_hsdpa_config
(
    OSS_UINT32 dc_hsdpa_params_present_ota,
    rrc_RRC_StateIndicator rrc_rcvd_state
)
{
  uint8 max_hs_scch_code = MAX_HS_SCCH_CODES_WITH_DUAL_CELL;
  uint8 num_scch_codes = ordered_config_ptr->l1_hsdpa_info.hs_scch_info.num_ch_code;
  uint8 idx=0, iy=0, num_sec_hs_carrier = rrcllcpcie_return_num_sec_hsdpa_carriers(ordered_config_ptr);

  if((dc_hsdpa_params_present_ota) &&(rrcueci_nv_supports_dc_hsdpa() == FALSE))
  {
    WRRC_MSG1_HIGH("DC-HSDPA config can't be processed for NV HS-CAT %d.",nv_hsdpa_category);
    return FALSE;
  }
  /* If window size is greater than 32 and if TSN extn is FALSE, RRC should reject the configuration */
  if((num_sec_hs_carrier < 2) && (FALSE == rrcllc_validate_hs_ehs_window_size_for_sec(rrc_rcvd_state)))
  {
    return FALSE;
  }
  else if(!num_sec_hs_carrier)
  {
    return TRUE;
  }
#ifdef FEATURE_WCDMA_3C_HSDPA
  /* for 3C(1 primary + 2 secondary), max_hs_scch_code = MAX_HS_SCCH_CODES_WITH_3_CELL.*/
  if(NUM_OF_SEC_CARRIERS_3C == num_sec_hs_carrier)
  {
    max_hs_scch_code = MAX_HS_SCCH_CODES_WITH_3_CELL;
    if(ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs != MAC_EHS)
    {
      WRRC_MSG0_ERROR("3CHSDPA_DEBUG: 3CHSDPA configured, but EHS not configured");
      return FALSE;
    }
  }
#endif

  /*Make sure that DC-HSDPA isn't active with MIMO.*/
#ifdef FEATURE_WCDMA_MIMO
  if((ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action == L1_MIMO_START) ||
    ((ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action != L1_MIMO_STOP) && 
    (rrcllc_get_mimo_status() == RRC_MIMO_ACTIVE )))
  {
    WRRC_MSG0_ERROR("DC-HSDPA:Not started bcoz MIMO will also be active.");
    return FALSE;
  }
#endif /*FEATURE_WCDMA_MIMO*/

  for(idx=0;idx<MAX_NUM_OF_SEC_CARRIERS;idx++)
  {
    if(ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[idx].sec_hsdpa_action == L1_SEC_HSDPA_RECFG)
  {
  if((ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_HS) &&
        (ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[idx].hs_sec_cell_64_qam_configured))
  {
    WRRC_MSG0_ERROR("DC-HSDPA:Not started bcoz MAC header type is MAC-hs + 64QAM.");
    return FALSE;
  }
      for(iy=0; iy<ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[idx].hs_sec_cell_scch_info.num_ch_code; iy++)
      {
        if((ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[idx].hs_sec_cell_scch_info.ch_code[iy]> RRCLLC_MAX_SCCH_CHAN_CODE) || 
        (ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[idx].hs_sec_cell_scch_info.ch_code[iy] == 0))
        {
          WRRC_MSG1_ERROR("DC-HSDPA:Invalid HS-SCCH Code %d", ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[idx].hs_sec_cell_scch_info.ch_code[iy]);
          return FAILURE;
        }
      }			
    num_scch_codes += ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[idx].hs_sec_cell_scch_info.num_ch_code;
  }
  }
  if(num_scch_codes > max_hs_scch_code)
  {
    WRRC_MSG1_ERROR("num_scch_codes exceeded : %d",num_scch_codes);
    return FALSE;
  }
  if((ordered_config_ptr->l1_dl_chan_parms.dl_common.opt_parm_presence_bitmask & 
    DL_COMMON_INFO_TX_DIV_MODE_PRESENT) && (ordered_config_ptr->l1_dl_chan_parms.dl_common.tx_div_mode 
    == L1_TX_DIV_CLOSED_LOOP_1))
  {
    WRRC_MSG0_ERROR("DC-HSDPA:TxDiversity CLTD can't be used with DC operation");
    return FALSE;
  }


  /*Explicit HARQ Memory partitioning for dual cell operation doesnt have min/max check, its only for Implicit*/
  if(((ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.harq_info.num_proc < RRC_MIN_HARQ_PROC_FOR_DC_HSDPA) ||
    (ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.harq_info.num_proc > RRC_MAX_HARQ_PROC_FOR_DC_HSDPA))&&
    (ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.harq_info.mem_part_info_valid == FALSE))
  {
    MSG_ERROR("DC-HSDPA:No. of HARQ processes %d out of range (%d to %d)",
      ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.harq_info.num_proc,
      RRC_MIN_HARQ_PROC_FOR_DC_HSDPA, RRC_MAX_HARQ_PROC_FOR_DC_HSDPA);
    return FALSE;
  }

  WRRC_MSG1_HIGH("DC-HSDPA:HARQ info has Explicit memory partitioning: %d ",ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.harq_info.mem_part_info_valid);
#ifndef TEST_FRAMEWORK
#ifdef FEATURE_WCDMA_3C_HSDPA
  if(num_sec_hs_carrier == NUM_OF_SEC_CARRIERS_3C)
  {
    if(FAILURE == rrcllc_validate_sec_carrier_freq_3c())
      return FALSE;
  }
  else
#endif
  if(num_sec_hs_carrier == NUM_OF_SEC_CARRIERS_2C)
  {
    if(FAILURE == rrcllcpcie_validate_dbdc_band_combination())
      return FALSE;
  }
#endif  
  return TRUE;
}

#endif /*FEATURE_WCDMA_DC_HSDPA*/

/*====================================================================
FUNCTION: rrcllc_clear_agch_chan_mask_for_non_serving_rl()

DESCRIPTION:
  This function clear agch chan mask for non serving EUL rl.

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_clear_agch_chan_mask_for_non_serving_rl
(
  ordered_config_type  *config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
  , boolean is_sec_eul
#endif /* FEATURE_WCDMA_DC_HSUPA */

)
{
  uint32 count = 0;
  l1_e_dl_info_struct_type *e_dl_info_ptr = NULL;
  
#ifdef FEATURE_WCDMA_DC_HSUPA
  if(is_sec_eul == TRUE)
  {
    e_dl_info_ptr = &config_ptr->l1_sec_e_info.e_dl_info;
  }
  else
#endif /* FEATURE_WCDMA_DC_HSUPA */
  {
    e_dl_info_ptr = &config_ptr->l1_e_info.e_dl_info;
  }

  
  if(e_dl_info_ptr->e_serving_rl_idx < 
    e_dl_info_ptr->num_e_dl_rl_add_recfg_info)
  {
    WRRC_MSG2_MED("RRCEUL: E-srving RL psc=%d, idx=%d ",
           e_dl_info_ptr->e_dl_rl_add_recfg_info[e_dl_info_ptr->e_serving_rl_idx].e_rl_psc,
           e_dl_info_ptr->e_serving_rl_idx);
  }

  for (count=0; 
     count<e_dl_info_ptr->num_e_dl_rl_add_recfg_info;
     count++)
  {
    if (e_dl_info_ptr->e_dl_rl_add_recfg_info[count].
        e_dl_channel_mask & L1_E_AGCH_INFO_PRESENT)
    {
      /* if count is equal to serving rl index then only indicate agch add */
      if (count != e_dl_info_ptr->e_serving_rl_idx)
      {
        /* clean any ADD or RECFG bits */
        /* reset ADD and reconfig bits in AGCH */
        e_dl_info_ptr->e_dl_rl_add_recfg_info[count].
           e_dl_channel_mask &= ~(L1_E_AGCH_INFO_RECFG|L1_E_AGCH_INFO_ADD);
        WRRC_MSG2_HIGH("RRCEUL: re-set AGCH add/reconfig bit for non srving cell psc = %d,idx = %d ",
           e_dl_info_ptr->e_dl_rl_add_recfg_info[count].e_rl_psc, count);
      }
    }
    /* L1_E_AGCH_INFO_PRESENT flag is not cleared here for non serving RL. If n/w later makes this RL as serving RL without
          providing AGCH info, we can make use of this AGCH info. Ideally n/w should always provide AGCH info for serving RL, just in 
          case it doesn't provide, we can use this AGCH info though it is stale (Not per spec) */
  }
}


/*====================================================================
FUNCTION: rrcllc_set_sib5_change_in_progress_flag_to_active()

DESCRIPTION:
  This function set sib5_change_in_progress_flag.

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_set_sib5_change_in_progress_flag_to_active
(
  void
)
{

  if(is_sib5_change_in_progress == CELL_CHANGE_INACTIVE)
  {
    is_sib5_change_in_progress = CELL_CHANGE_ACTIVE;
  }
  WRRC_MSG1_HIGH("SIB5_Change: is_sib5_change_in_progress flag to %d",is_sib5_change_in_progress);

}



/*====================================================================
FUNCTION: rrcllc_clear_sib5_change_in_progress_flag()

DESCRIPTION:
  This function set sib5_change_in_progress_flag.

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_set_sib5_change_in_progress_flag
(
  void
)
{

#ifdef FEATURE_WCDMA_HS_FACH
  if(rrcllc_get_hs_status_in_e_fach(current_config_ptr) != rrcenhstate_camped_cell_supports_e_fach())
  {
    is_sib5_change_in_progress =CELL_CAP_CHANGED ;
  }
#ifdef FEATURE_WCDMA_HS_RACH
  else if(rrchsrach_get_ready_for_common_edch(current_config_ptr) != rrchsrach_camped_cell_supports_hsrach())
  {
    /*Delay Cell Update ia applicable only when CU is not active/started*/ 
    if(RRC_IS_SIB5_DELAY_CU_ENABLED &&
       rrccu_get_cell_update_started_status() == RRCCU_NOT_STARTED)
    {
      is_sib5_change_in_progress = SIB5CHANGE_HSRACH_DELAY_CU;
    }
    else
    {
      is_sib5_change_in_progress = CELL_CAP_CHANGED;
    }
  }
#endif
  else
#endif
  {
    is_sib5_change_in_progress = NO_CHANGE_IN_CELL_CAP;
  }

  WRRC_MSG1_HIGH("SIB5_Change: is_sib5_change_in_progress flag to %d",is_sib5_change_in_progress);

}
/*====================================================================
FUNCTION: rrcllc_clear_sib5_change_in_progress_flag()

DESCRIPTION:
  This function clear sib5_change_in_progress_flag.

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_clear_sib5_change_in_progress_flag
(
  void
)
{
  if(is_sib5_change_in_progress != CELL_CHANGE_INACTIVE)
  {
    WRRC_MSG1_HIGH("SIB5_Change: Clear is_sib5_change_in_progress flag to TRUE,curr val=%d",
       is_sib5_change_in_progress);
  
    is_sib5_change_in_progress = CELL_CHANGE_INACTIVE;
  }
}
/*====================================================================
FUNCTION: rrcllc_get_sib5_change_in_progress_flag()

DESCRIPTION:
  This function clear sib5_change_in_progress_flag.

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
#ifdef FEATURE_QSH_DUMP
__attribute__((section(".uncompressible.text")))
#endif
rrcllc_sib5_change_type rrcllc_get_sib5_change_in_progress_flag
(
  void
)
{
#if 0
  if(is_sib5_change_in_progress)
  {
    WRRC_MSG1_HIGH("SIB5_Change:is_sib5_change_in_progress val=%d",
     is_sib5_change_in_progress);
  }
#endif
  return (is_sib5_change_in_progress);
}
#ifdef FEATURE_WCDMA_REL9

#ifdef FEATURE_WCDMA_DC_HSUPA

/*============================================================================
FUNCTION: rrcllc_update_l1_sec_e_req_mask_for_e_ul_info()

DESCRIPTION:
  This function updates the sec_e_req_mask to be sent to layer1.
  This function is called whenever any of the EUL related UL physical layer 
  parameters are modified by reconfig message.

DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
void rrcllc_update_l1_sec_e_req_mask_for_e_ul_info
(
  boolean e_ul_info_present
)
{
  if (TRUE == e_ul_info_present)
  {
    /* set the reqeest mask with reconfig, because EUL is already up */
    /* if E-DCH transmission is START or STOP then this request mask needs to be
       modified accordingly*/    
    ordered_config_ptr->l1_sec_e_req_mask |= L1_EUL_RECFG_UL;
  }
}


/*============================================================================
FUNCTION: rrcllc_update_l1_sec_e_req_mask_for_e_dl_info()

DESCRIPTION:
  This function updates the e_req_mask to be sent to layer1.
  This function is called whenever any of the EUL related DL physical layer 
  parameters are modified by reconfig message.

DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
void rrcllc_update_l1_sec_e_req_mask_for_e_dl_info
(
  boolean e_dl_info_present
)
{
  if (TRUE == e_dl_info_present)
  {
    /* set the reqeest mask with reconfig, because SEC EUL is already up */
    /* if SEC E-DCH transmission is START or STOP then this request mask needs to be
       modified accordingly*/
    ordered_config_ptr->l1_sec_e_req_mask |= L1_EUL_RECFG_DL;
  }
}


#endif /* FEATURE_WCDMA_DC_HSUPA */


/*====================================================================
FUNCTION: rrcllc_determine_hsdpa_action_for_hsdpa_active_r9()

DESCRIPTION:
  This function determines the HSDPA action when HSDPA ia already ACTIVE. 
  
DEPENDENCIES:
  None.

RETURN VALUE:
  Sucess if HSDPA action and parameters have been set
  Failure Otherwise

SIDE EFFECTS:
====================================================================*/
uecomdef_status_e_type rrcllc_determine_hsdpa_action_for_hsdpa_active_r9
(
  rrc_DL_HSPDSCH_Information_r9* hspdsch_info_ptr
)
{
  uint8 reconfig_bit_mask = 0;
  boolean hsscch_codes_changed = FALSE;
  boolean hsdpcch_changed = FALSE;
  boolean b_table_changed = FALSE;  

  MSG_9(MSG_SSID_DFLT, MSG_LEGACY_HIGH,"hsdpa_params_present:%d,rl_link_present:%d,ifhho_involved:%d, intra_hho_involved:%d,new_rl_link:%d,hrnti_present:%d, dest_freq_present:%d, hsdpa_msg_params.hsdsch_info_present:%d, hsdpa_msg_params.hrnti_changed %d",
            hsdpa_msg_params.msg_params_present,
            hsdpa_msg_params.rl_link_present,
            hsdpa_msg_params.ifhho_involved,
            hsdpa_msg_params.intra_hho_involved,
            hsdpa_msg_params.new_rl_link,
            hsdpa_msg_params.hrnti_present,
            ordered_config_ptr->dest_freq_present,
            hsdpa_msg_params.hsdsch_info_present,
            hsdpa_msg_params.hrnti_changed
            );

  /* Now check if InterF Hard Handoff is involved */
  if ((hsdpa_msg_params.rl_link_present == FALSE) &&
    (hsdpa_msg_params.ifhho_involved == TRUE))
  {
    rrc_set_hsdpa_action(HSDPA_STOP);
    return SUCCESS;
  }

  /* Check if Intra Freq HO involved */
  if ((hsdpa_msg_params.rl_link_present == FALSE) &&
    (hsdpa_msg_params.intra_hho_involved == TRUE))
  {
    rrc_set_hsdpa_action(HSDPA_STOP);
    return SUCCESS;
  }

  /*InterF or IntraF HO is happening and RL is given*/
  if(((hsdpa_msg_params.ifhho_involved == TRUE)||(hsdpa_msg_params.intra_hho_involved == TRUE)) 
    && (hsdpa_msg_params.rl_link_present == TRUE))
  {

    /* If Re-pointing is happenning then H-RNTI should be provided */
    if (hsdpa_msg_params.hrnti_present == FALSE)
    {
      WRRC_MSG0_ERROR("REL9:H-RNTI absent for HS Hard Repointing.");
      return FAILURE;
    }
    ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc = hsdpa_msg_params.new_rl_link;
    reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_PDSCH_RL_CFG_INCL | CPHY_HS_DSCH_CFG_INCL;
  }
  else if (ordered_config_ptr->dest_freq_present == TRUE)
  {
    WRRC_MSG1_HIGH("REL9:SYNC A procedure triggered freq %d Set HS-DSCH in bit_mask ",
           ordered_config_ptr->dest_freq);
   
    reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_DSCH_CFG_INCL;
  }
  if ((hsdpa_msg_params.rl_link_present == TRUE) &&
      (hsdpa_msg_params.intra_hho_involved == FALSE) &&
      (hsdpa_msg_params.ifhho_involved == FALSE) &&
      (hsdpa_msg_params.new_rl_link != ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc))
  {
    WRRC_MSG1_HIGH("REL9: HS Soft Repointing to PSC %d", hsdpa_msg_params.new_rl_link);
    ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc = hsdpa_msg_params.new_rl_link;
    reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_PDSCH_RL_CFG_INCL;
  }

  /* Check if SRB Delay, DPCCH Power Offset & PC Preamble Information was indicated
  in the message & Sync A Procedure is not involved. If yes, then rewrite the old information from CC 
  as the new information needs to be ignored */
  if ((ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.valid == TRUE) &&
    (ordered_config_ptr->dest_freq_present == FALSE) && 
    (hsdpa_msg_params.intra_hho_involved == FALSE) &&
    (hsdpa_msg_params.ifhho_involved == FALSE))
  {
    WRRC_MSG0_HIGH("REL9: Ignore SRBDelay/PCPreamble/POffset");

    /* Get them from CC. Do validation check to be doubly sure that CC values are valid */
    if ((current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.valid == TRUE) &&
      (current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.dpcch_pwr_offset
      <= 2*RRCLLC_UL_DPCCH_PWR_OFFSET_MAX) && 
      (current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.dpcch_pwr_offset
      >= 2*RRCLLC_UL_DPCCH_PWR_OFFSET_MIN) && 
      (current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.pcp_len < 8) && 
      (current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.srb_delay < 8))
    {
      MSG_6(MSG_SSID_DIAG, MSG_LEGACY_HIGH,"RRCHS: PO Offset OC %d CC %d PCP Length OC %d CC %d SRB Delay OC %d CC %d", 
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.dpcch_pwr_offset,
        current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.dpcch_pwr_offset,
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.pcp_len,
        current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.pcp_len,
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.srb_delay,
        current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.srb_delay);
      
      /* Copy Old information from CC */
      ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.dpcch_pwr_offset =
        current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.dpcch_pwr_offset;
      
      ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.pcp_len =
        current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.pcp_len;
      
      ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.srb_delay =
        current_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.srb_delay;
    }
  }

  if ((hsdpa_msg_params.rl_link_present == TRUE) &&
      (hsdpa_msg_params.intra_hho_involved == FALSE) &&
      (hsdpa_msg_params.ifhho_involved == FALSE))
  {
    ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc = hsdpa_msg_params.new_rl_link;
  }
  
  if (hsdpa_msg_params.hspdsch_info_present == TRUE)
  {
    /*Process HS-SCCH Info*/
    if (RRC_MSG_COMMON_BITMASK_IE_PTR(hspdsch_info_ptr,rrc_DL_HSPDSCH_Information_r9,hs_scch_Info))
    {
      /* Check if HS-SCCH Info has changed */
      if (rrcllc_check_if_hsscch_changed(&hspdsch_info_ptr->hs_scch_Info,MSG_REL9) == TRUE)
      {
        hsscch_codes_changed = TRUE;
      }

      if (set_hsscch_info_r9(&hspdsch_info_ptr->hs_scch_Info) == FAILURE)
      {
        return FAILURE;
      }
      else
      {
        if (hsscch_codes_changed == TRUE)
        {
          WRRC_MSG0_HIGH("REL9:SCCH Info changed");
          reconfig_bit_mask =reconfig_bit_mask | CPHY_HS_SCCH_CFG_INCL;
        }
      }
    }

    /*Process Measurement Feedback Info.*/ 
    if(RRC_MSG_COMMON_BITMASK_IE_PTR(hspdsch_info_ptr,rrc_DL_HSPDSCH_Information_r9,measurement_feedback_Info))
    {
      /* Check if Meas Feedback Info has changed */
      rrcllc_check_if_meas_feedback_changed_r7(&hspdsch_info_ptr->measurement_feedback_Info, 
                                            &b_table_changed, &hsdpcch_changed);

      if (set_meas_feedback_info_r7(&hspdsch_info_ptr->measurement_feedback_Info) == FAILURE)
      {
        return FAILURE;
      }
      else
      {
        if(b_table_changed == TRUE)
        {
          ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 
            HS_DPCCH_BETA_HS_INFO_PRESENT_BITMASK;
          reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_DPCCH_CFG_INCL;

        }
        if(hsdpcch_changed == TRUE)
        {
          ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 
            ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask |
            HS_DPCCH_MEAS_FEEDBACK_INFO_PRESENT_BITMASK;
          reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_DPCCH_CFG_INCL;

        }
      }
    }
#ifdef FEATURE_WCDMA_64QAM
    if(current_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured !=
           ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured)
    {
      hsdpa_msg_params.hsdsch_info_present = TRUE;
      WRRC_MSG0_HIGH("Set HS-DSCh bitmask as 64 QAM config is changed ");
    }
#endif
  }/*HS-PDSCH Info is present in hsdpa_msg_params*/

  /* Check if only beta table has changed */
  if ((b_table_changed == FALSE) && (hsdpa_msg_params.beta_table_present == TRUE))
  {
    ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 
      HS_DPCCH_BETA_HS_INFO_PRESENT_BITMASK;
    reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_DPCCH_CFG_INCL;

  }

  /* Check if only beta table has changed */
  if ((hsdpcch_changed == FALSE) && (hsdpa_msg_params.hs_dpcch_info_present == TRUE))
  {
    ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 
      HS_DPCCH_MEAS_FEEDBACK_INFO_PRESENT_BITMASK;
    reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_DPCCH_CFG_INCL;
  }

  /* Final Check to make sure that everything is present */
  if (rrcllc_check_if_hsdpa_can_be_started_reconfigured(ordered_config_ptr) == FALSE)
  {
    rrc_set_hsdpa_action(HSDPA_STOP);
    return SUCCESS;
  }

  MSG_6(MSG_SSID_DIAG, MSG_LEGACY_HIGH,"RRCHS: hsdpa_msg_params.hspdsch_info_present %d hsscch_codes_changed %d,b_table_changed %d hsdpcch_changed %d,hsdpa_msg_params.beta_table_present %d hsdpa_msg_params.hs_dpcch_info_present %d", 
            hsdpa_msg_params.hspdsch_info_present,
            hsscch_codes_changed,
            b_table_changed,
            hsdpcch_changed,
            hsdpa_msg_params.beta_table_present,
            hsdpa_msg_params.hs_dpcch_info_present);

  /* Check if HS-DPCCH Info has changed */
  if (hsdpa_msg_params.hs_dpcch_info_present == TRUE)
  {
    reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_DPCCH_CFG_INCL;
    WRRC_MSG0_HIGH("REL9:HS-DPCCH info changed");
  }

  /* Set the queue information */
  if(set_hsdpa_l1_queue_info() == FAILURE)
  {
    WRRC_MSG0_ERROR("REL9:Unable to set HSDPA info in L1");
    return FAILURE;
  }
  else
  {
    if((hsdpa_msg_params.hsdsch_info_present == TRUE) || 
      ((hsdpa_msg_params.hrnti_present == TRUE) && (hsdpa_msg_params.hrnti_changed == TRUE)))
    {
      WRRC_MSG0_MED("REL9:CPHY_HS_DSCH_CFG_INCL set");
      reconfig_bit_mask = reconfig_bit_mask | CPHY_HS_DSCH_CFG_INCL;
    }
  }

  if ((reconfig_bit_mask == 0) && (ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator == FALSE) &&
      ordered_config_ptr->dest_freq_present == FALSE)
  {
    rrc_set_hsdpa_action(HSDPA_NOOP);
    return SUCCESS;
  }

  ordered_config_ptr->l1_hsdpa_info.hs_req_mask = reconfig_bit_mask;

  /* Set Action to RECONFIG */
  MSG_3(MSG_SSID_DIAG, MSG_LEGACY_HIGH,"RRCHS:HSRECONFIG bit mask/ordered_config_ptr->l1_hsdpa_info.hs_req_mask %d,HS-RESET %d, ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask %d",
		  reconfig_bit_mask,
		  ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator,
		  ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask);

  rrc_set_hsdpa_action(HSDPA_RECONFIG);
  return SUCCESS;
}


/*====================================================================
FUNCTION: rrcllc_determine_hsdpa_action_r9()

DESCRIPTION:
  This function determines the HSDPA action and sets the parameters in L1
  structure accordingly.
  
DEPENDENCIES:
  None.

RETURN VALUE:
  Sucess if HSDPA action and parameters have been set
  Failure Otherwise

SIDE EFFECTS:
====================================================================*/
uecomdef_status_e_type rrcllc_determine_hsdpa_action_r9
(
  rrc_DL_HSPDSCH_Information_r9* hspdsch_info_ptr
)
{
  /* HSDPA params have already been set in rrc_hsdpa_params.
  Check if HSDPA is already ACTIVE */
  if (rrc_get_hsdpa_status() == HSDPA_INACTIVE)
  {
    /* HSDPA is currently inactive */
    /* Check if network wants to activate HSDPA */
    if (hsdpa_msg_params.msg_params_present == TRUE)
    {
      if (hsdpa_msg_params.hspdsch_info_present == TRUE)
      {
        /* Check if channelization codes and feedback info present */
        if(RRC_MSG_COMMON_BITMASK_IE_PTR(hspdsch_info_ptr,rrc_DL_HSPDSCH_Information_r9,hs_scch_Info)) 
        {
          if (set_hsscch_info_r9(&hspdsch_info_ptr->hs_scch_Info) == FAILURE)
          {
            return FAILURE;
          }
        }
        if(RRC_MSG_COMMON_BITMASK_IE_PTR(hspdsch_info_ptr,rrc_DL_HSPDSCH_Information_r9,measurement_feedback_Info))
        {
          /* Set Meas Feedback Info */
          if (set_meas_feedback_info_r7(&hspdsch_info_ptr->measurement_feedback_Info) == FAILURE)
          {
            return FAILURE;
          }
        }
      }
      /* Set HS-RL */
      if (hsdpa_msg_params.rl_link_present == TRUE)
      {
        /* Set Radio Link in L1 HSDPA structure */
        ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc = hsdpa_msg_params.new_rl_link;
        WRRC_MSG1_MED("REL9:New HS RL %d set in L1 struct",ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc);
      }
    } /* End of if of hsdpa message params absent */
    else
    {
      rrc_set_hsdpa_action(HSDPA_NOOP);
      rrc_reset_mac_ehs_params(ordered_config_ptr);
      return SUCCESS;
    }

    /* Set Queue Info */
    if (set_hsdpa_l1_queue_info() == FAILURE)
    {
      WRRC_MSG0_ERROR("REL9:Unable to set Queue Info");
      return FAILURE;
    }

    /* Final Check to make sure that everything is present */
    if (rrcllc_check_if_hsdpa_can_be_started_reconfigured(ordered_config_ptr) == FALSE)
    {
      rrc_set_hsdpa_action(HSDPA_NOOP);
      rrc_reset_mac_ehs_params(ordered_config_ptr);
      return SUCCESS;
    }

    rrc_set_hsdpa_action(HSDPA_START);

    /* Set Bit Mask */
    ordered_config_ptr->l1_hsdpa_info.hs_req_mask = CPHY_HS_DSCH_CFG_INCL | 
      CPHY_HS_PDSCH_RL_CFG_INCL | CPHY_HS_SCCH_CFG_INCL | CPHY_HS_DPCCH_CFG_INCL;

    ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 
      HS_DPCCH_BETA_HS_INFO_PRESENT_BITMASK | HS_DPCCH_MEAS_FEEDBACK_INFO_PRESENT_BITMASK;


    WRRC_MSG2_MED("REL9:hs_req_mask 0X%x. info_present_bitmask 0X%x", ordered_config_ptr->l1_hsdpa_info.hs_req_mask,
             ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask);

#ifdef FEATURE_WCDMA_HS_FACH
     /*For EFACH to MAC-HS transitions*/
    if(current_config_ptr->hs_status_in_e_fach  == FALSE)
#endif
    {
      WRRC_MSG0_HIGH("REL9:Force HS-RESET to FALSE");
      ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator = FALSE;
    }

    return SUCCESS;
  }
  /*The following deals with the scenarios when HSDPA is already ACTIVE and HS action needs to be decided.*/
  else
  {
    ordered_config_ptr->l1_hsdpa_info.hs_req_mask = 0;
    ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 0;  

    WRRC_MSG0_MED("REL9:HSDPA already active");

    if (hsdpa_msg_params.msg_params_present == TRUE)
    {
      return rrcllc_determine_hsdpa_action_for_hsdpa_active_r9(hspdsch_info_ptr);
    }
    else
    {
      /*It means that HSDPA ia already ACTIVE but OTA hasn't provided the HSDPA parameters*/
      /* So Final Check to make sure that everything is present */
      if (rrcllc_check_if_hsdpa_can_be_started_reconfigured(ordered_config_ptr) == FALSE)
      {
        rrc_set_hsdpa_action(HSDPA_STOP);
        return SUCCESS;
      }

      if (ordered_config_ptr->dest_freq_present == TRUE)
      {
        WRRC_MSG0_HIGH("REL9: FORCED SYNC A with HSDPA_RECONFIG");
        rrc_set_hsdpa_action(HSDPA_RECONFIG);
        return SUCCESS;
      }

      /* Means No Action has to be taken for HSDPA. i.e.*/
      rrc_set_hsdpa_action(HSDPA_NOOP);

      return SUCCESS;
    }
  }
}


#endif /*FEATURE_WCDMA_REL9*/


#ifdef FEATURE_WCDMA_HS_FACH
/*====================================================================
FUNCTION: rrcllc_check_macehs_mapping_in_ordered_hanging_rb()

DESCRIPTION:


DEPENDENCIES:
  None.

RETURN VALUE:
  True/False.

SIDE EFFECTS:
  None.
====================================================================*/
boolean rrcllc_check_macehs_mapping_in_ordered_hanging_rb
(
  uint8 rb_id
)
{
  uint8 i;
  ordered_config_type *config_ptr = NULL;

  for(i=0;i<MAX_HANGING_RB_MAPPING_INFO;i++)
  {
    if(rrc_ordered_hanging_rb_mapping[i].in_use == TRUE )  
    {
      if (rrc_ordered_hanging_rb_mapping[i].rb_id == rb_id)
      {
        if (rrc_ordered_hanging_rb_mapping[i].dl_mapping_info.macehs_map_info.valid == TRUE)
        {
           WRRC_MSG1_HIGH("HSFACH: Mac-ehs mapping for rb_id %d is present",rb_id);

           /*Check for Queues accociation*/
           if((transition_config.toc_usage == TOC_FOR_DCH)||
              (transition_config.toc_usage == TOC_FOR_DCH_AND_FACH)||
              (transition_config.toc_usage == TOC_FOR_OOS_WITHOUT_DCH_INFO)||
              (transition_config.toc_usage == TOC_FOR_OOS_WITH_DCH_INFO)||
              (transition_config.toc_usage == TOC_FOR_FACH_AND_PCH)||
              (transition_config.toc_usage == TOC_FOR_FACH_AND_PCH_WITH_DCH_INFO ))
           {
             config_ptr = transition_config.toc_ptr ;
           }
           else
           {
             config_ptr = ordered_config_ptr ; 
           }

           if(rrcllc_check_if_macehs_queue_exists(config_ptr,
                rrc_ordered_hanging_rb_mapping[i].dl_mapping_info.macehs_map_info.queue_id) == FALSE)
           {
             WRRC_MSG1_HIGH("HSFACH: Mac-ehs Queue ID for rb_id %d is not present",rb_id);
             return FALSE;
           }
           else return TRUE;
        }
      }
    }
  }
  WRRC_MSG1_HIGH("HSFACH: Mac-ehs mapping for rb_id %d is not present",rb_id);
  return FALSE;
}
/*====================================================================
FUNCTION: rrcllc_check_rach_mapping_in_ordered_hanging_rb()

DESCRIPTION:


DEPENDENCIES:
  None.

RETURN VALUE:
  True/False.

SIDE EFFECTS:
  None.
====================================================================*/
boolean rrcllc_check_rach_mapping_in_ordered_hanging_rb
(
  uint8 rb_id
)
{
  uint8 i;

  for(i=0;i<MAX_HANGING_RB_MAPPING_INFO;i++)
  {
    if(rrc_ordered_hanging_rb_mapping[i].in_use == TRUE )  
    {
      if(rrc_ordered_hanging_rb_mapping[i].ul_mapping_info.rach_info.valid == TRUE)
        {
           WRRC_MSG1_HIGH("RRCHSFACH: RACH mapping for rb_id %d is present",rb_id);
           return TRUE;
        }
      }
    }
  WRRC_MSG1_HIGH("RRCHSFACH: RACH mapping for rb_id %d is present",rb_id);
  return FALSE;
}

/*====================================================================
FUNCTION: rrcllc_check_hsfach_mapping_in_ordered_hanging_rb()

DESCRIPTION:


DEPENDENCIES:
  None.

RETURN VALUE:
  True/False.

SIDE EFFECTS:
  None.
====================================================================*/
boolean rrcllc_check_hsfach_mapping_in_ordered_hanging_rb
(
  uint8 rb_id
)
{

  if(rb_id < DCCH_UM_RADIO_BEARER_ID)
    return TRUE;

  if(rrcllc_check_rach_mapping_in_ordered_hanging_rb(rb_id) && 
     rrcllc_check_macehs_mapping_in_ordered_hanging_rb(rb_id))
  {
    WRRC_MSG1_HIGH("RRCHSFACH: HSFACH mappings present for rb_id %d ",rb_id);
    return TRUE;
  }

  WRRC_MSG1_HIGH("RRCHSFACH: HSFACH mappings not present for rb_id %d ",rb_id);
  return FALSE;
}

/*====================================================================
FUNCTION: rrcllc_check_hsfach_mappings_in_channel_config_req()

DESCRIPTION:


DEPENDENCIES:
  None.

RETURN VALUE:
  True/False.

SIDE EFFECTS:
  None.
====================================================================*/
boolean rrcllc_check_hsfach_mappings_in_channel_config_req
(
rrc_channel_config_req_type *channel_config_req_ptr
)
{

  uint8 i;

  for(i=0;i<channel_config_req_ptr->num_rb_to_config;i++)
  {
    if (channel_config_req_ptr->rb[i].rb_config == RELEASE_RB) // missing rb mapping info check is not expected on release RB's
    {
      continue;
    }
    if(!rrcllc_check_hsfach_mapping_in_ordered_hanging_rb(channel_config_req_ptr->rb[i].rb_id))
    {
      return FALSE;
    }
  }
  return TRUE;
}
#endif /*FEATURE_WCDMA_HS_FACH*/

#ifdef FEATURE_WCDMA_HS_RACH
/*====================================================================
FUNCTION: rrcllc_init_hs_rach_info()

DESCRIPTION:
  This function initializes all the HS-RACH variables.

DEPENDENCIES:


RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_hs_rach_info
(
  ordered_config_type *config_ptr  
)
{
  WRRC_MSG0_MED("HSRACH initializing the hs-rach variables");
  config_ptr->ready_for_common_edch = FALSE;
  /*Dont reset this variable because we are determining this during OTA processing.
  if its reset here we wont have this value in any database*/
//  config_ptr->hspa_rnti_stored_cell_pch = FALSE;
  config_ptr->common_edch_transmission = FALSE;

}
/*====================================================================
FUNCTION: rrcllc_update_ready_for_common_edch()

DESCRIPTION:

DEPENDENCIES:
  None
  
RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_determine_and_set_ready_for_common_edch
(
  ordered_config_type *config_ptr,
  rrc_state_e_type next_rrc_state
)
{
  ordered_config_type *config_ptr1;

  if( config_ptr_in_use == CURRENT_CONFIG)
  {
    config_ptr1 = current_config_ptr;
  }
  else 
  {
    config_ptr1 = ordered_config_ptr;
  }
  
  if((config_ptr != NULL) && (config_ptr1!=NULL))
  {
    rrchsrach_set_ready_for_common_edch(config_ptr,FALSE);
	
    if((rrchsrach_camped_cell_supports_hsrach() == TRUE) && 
            (next_rrc_state == RRC_STATE_CELL_FACH || next_rrc_state == RRC_STATE_CONNECTING))
    {
      rrchsrach_set_ready_for_common_edch(config_ptr,TRUE);
    }
/*
if the UE is in CELL_PCH state:
2> the UE supports E-DCH transmission in CELL_FACH state and Idle mode;
2> the UE supports HS-DSCH reception in CELL_PCH and URA_PCH state;
2> the IE "HS-DSCH paging system information" is included in system information block type 5 or 5bis;
2> the IE "Common E-DCH system info" is included system information block type 5 or 5bis;
2> variable H-RNTI is set;
2> variable E_RNTI is set;
2> variable C_RNTI is set.
*/

    WRRC_MSG2_MED("RRCHSRACH:Set ready_for_common_edch  = %d. In use DB(0:OC/1:CC/2:TOC) %d",config_ptr->ready_for_common_edch,config_ptr_in_use);
	
  }

}

/*====================================================================
FUNCTION: rrcllc_update_hspa_rnti_stored_cell_pch()

DESCRIPTION:

DEPENDENCIES:
  None
  
RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_determine_and_set_hspa_rnti_stored_cell_pch
(
  ordered_config_type *config_ptr,
  rrc_state_e_type rrc_state
)
{

  if(config_ptr != NULL)
  {
    config_ptr->hspa_rnti_stored_cell_pch=FALSE;

    if((RRC_STATE_CELL_PCH == rrc_state) && (rrchsrach_camped_cell_supports_hsrach() == TRUE) &&
       (rrcllc_check_hsrach_mappings_for_all_rbs_present() == TRUE)&& 
       (config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present == TRUE) &&
       (DEDICATED_HRNTI ==config_ptr->efach_hrnti_status) && ((CRNTI_VALID == config_ptr->mac_ul_parms.rnti_info.rnti_valid) ||
       (BOTH_VALID == config_ptr->mac_ul_parms.rnti_info.rnti_valid)))
  {
      config_ptr->hspa_rnti_stored_cell_pch=TRUE;
    }
    WRRC_MSG2_HIGH("HSRACH:Set hspa_rnti_stored_cell_pch  = %d. In use DB(0:OC/1:CC/2:TOC) %d",config_ptr->hspa_rnti_stored_cell_pch,config_ptr_in_use);
  }

  }
/*====================================================================
FUNCTION: rrcllc_check_and_invalidate_hspa_rnti_stored_cell_pch()
  
DESCRIPTION:
  This function checks if mappings and hrnti and ernti are available
  while going to PCH state and invalidates hspa_rnti_stored_cell_pch 
  variable
DEPENDENCIES:
  None
  
RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_check_and_invalidate_hspa_rnti_stored_cell_pch
(
  ordered_config_type *config_ptr,
  rrc_state_e_type rrc_state
)
{
    
  if(config_ptr == NULL)
  {
    WRRC_MSG0_ERROR("ERR:Config Ptr is NULL");
    return;
  }

  if(!((RRC_STATE_CELL_PCH == rrc_state) && (rrchsrach_camped_cell_supports_hsrach() == TRUE) &&
    (rrcllc_check_hsrach_mappings_for_all_rbs_present() == TRUE) && 
       (config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present == TRUE) &&
       (DEDICATED_HRNTI ==config_ptr->efach_hrnti_status))
  )
  {
      WRRC_MSG2_HIGH("HSRACH:ERNTI status %d  HRNTI status %d",config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present,config_ptr->efach_hrnti_status);
      rrchsrach_set_hspa_rnti_stored_cell_pch (config_ptr,FALSE);
      config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present=FALSE;
      config_ptr->efach_hrnti_status = INVALID_HRNTI;
      transition_config.toc_ptr->efach_hrnti_status = INVALID_HRNTI;
  }

    WRRC_MSG2_HIGH("HSRACH:hspa_rnti_stored_cell_pch  = %d in check_and_invalidate_hspa_rnti_stored_cell_pch. In use DB(0:OC/1:CC/2:TOC) %d",
    config_ptr->hspa_rnti_stored_cell_pch,config_ptr_in_use);
}
/*====================================================================
FUNCTION: rrcllc_get_hspa_rnti_stored_cell_pch()

DESCRIPTION:

DEPENDENCIES:
  None
  
RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
boolean rrcllc_get_hspa_rnti_stored_cell_pch
(
  ordered_config_type *config_ptr
)
{
  boolean status = FALSE;

  if(config_ptr != NULL)
  {
    status = config_ptr->hspa_rnti_stored_cell_pch;
  }
  if(status == TRUE)
  {
    WRRC_MSG2_HIGH("HSRACH:Get hspa_rnti_stored_cell_pch Status (0:F/1:T) = %d. In use DB(0:OC/1:CC/2:TOC) = %d",status,config_ptr_in_use);
  }
  return status;
}

/*====================================================================
FUNCTION: rrcllc_copy_sib_to_oc_for_hsrach()

DESCRIPTION:

DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS
  FAILURE

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_copy_sib_to_oc_for_hsrach(rrc_state_e_type next_rrc_state)
{

  rrchsrach_set_common_edch_transmission(ordered_config_ptr, FALSE);
  rrchsrach_set_ready_for_common_edch(ordered_config_ptr, FALSE);
  /*Dont reset this variable because we are determining this during OTA processing*/
//  rrchsrach_set_hspa_rnti_stored_cell_pch(ordered_config_ptr, FALSE);


  /*
   Need to include mapping in config pointer even if next state is PCH/URA-PCH.
   In order to decide if TVI indicator has to be included in CU, HSRACH passes the
   mac_hs_rach_config address to L2 to check if data has crossed the buffer limit. In 
   cases like r99-DCH/FACH->PCH(HSRACH) mapping is only in hanging RB, this has to be restored
   into OC before building CU.
  */
  if( (rrchsrach_camped_cell_supports_hsrach() == TRUE) && 
          (next_rrc_state == RRC_STATE_CELL_FACH || 
           next_rrc_state == RRC_STATE_CONNECTING || 
           next_rrc_state == RRC_STATE_CELL_PCH || 
           next_rrc_state == RRC_STATE_URA_PCH))
  {
    if(SUCCESS == rrchsrach_get_edch_rach_info_from_sib5(ordered_config_ptr, 
                                                              next_rrc_state) &&
       next_rrc_state != RRC_STATE_CELL_PCH &&
       next_rrc_state != RRC_STATE_URA_PCH)
    {
      rrchsrach_set_common_edch_transmission(ordered_config_ptr, TRUE);
      rrchsrach_set_ready_for_common_edch(ordered_config_ptr, TRUE);
      WRRC_MSG1_HIGH("HSRACH:Set edch transmission in OC %d", ordered_config_ptr->common_edch_transmission);    
    }
  }
  else if (rrchsrach_camped_cell_supports_hsrach() == FALSE)
  {
    /*Delete ERNTI if cell doesnt support HSRACH*/
    ordered_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = FALSE;
  }
  rrcllc_determine_hsrach_action();
}

/*====================================================================
FUNCTION: rrchsrach_set_common_edch_transmission()

DESCRIPTION:

DEPENDENCIES:
  None
  
RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrchsrach_set_common_edch_transmission
(
  ordered_config_type *config_ptr,
  boolean status
)
{
  if(config_ptr != NULL)
  {
    if(config_ptr->common_edch_transmission != status)
    {
      WRRC_MSG2_HIGH("HSRACH:Set Status of common edch transmission (0:F/1:T) = %d. In use DB(0:OC/1:CC/2:TOC) %d",status,config_ptr_in_use);
      config_ptr->common_edch_transmission = status;
    }
  }

  return;
}

/*====================================================================
FUNCTION: rrchsrach_get_common_edch_transmission()

DESCRIPTION:

DEPENDENCIES:
  None
  
RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
boolean rrchsrach_get_common_edch_transmission
(
  ordered_config_type *config_ptr
)
{
  boolean status = FALSE;

  if(config_ptr != NULL)
  {
    status = config_ptr->common_edch_transmission;
  }

  WRRC_MSG2_MED("HSRACH:Get Status of common edch transmission (0:F/1:T) = %d. In use DB(0:OC/1:CC/2:TOC) = %d",status,config_ptr_in_use);

  return status;
}
/*====================================================================
FUNCTION: rrchsrach_get_common_edch_transmission_wof3()

DESCRIPTION:

DEPENDENCIES:
  None
  
RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
boolean rrchsrach_get_common_edch_transmission_wof3
(
  ordered_config_type *config_ptr
)
{
  boolean status = FALSE;

  if(config_ptr != NULL)
  {
    status = config_ptr->common_edch_transmission;
  }

  return status;
}
/*====================================================================
FUNCTION: rrchsrach_set_ready_for_common_edch()

DESCRIPTION:

DEPENDENCIES:
  None
  
RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrchsrach_set_ready_for_common_edch
(
  ordered_config_type *config_ptr,
  boolean status
)
{
  if(config_ptr != NULL)
  {
    if(config_ptr->ready_for_common_edch != status)
    {
      WRRC_MSG2_HIGH("HSRACH:Set Status of ready for common edch (0:F/1:T) = %d. In use DB(0:OC/1:CC/2:TOC) %d",status,config_ptr_in_use);
    }
    config_ptr->ready_for_common_edch = status;
  }

  return;
}
/*====================================================================
FUNCTION: rrchsrach_set_hspa_rnti_stored_cell_pch()

DESCRIPTION:

DEPENDENCIES:
  None
  
RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrchsrach_set_hspa_rnti_stored_cell_pch
(
  ordered_config_type *config_ptr,
  boolean status
)
{
  if(config_ptr != NULL)
  {
    if(config_ptr->hspa_rnti_stored_cell_pch != status)
    {
      WRRC_MSG2_HIGH("HSRACH:Set hspa_rnti_stored_cell_pch Status (0:F/1:T) = %d. In use DB(0:OC/1:CC/2:TOC) %d",status,config_ptr_in_use);
    }
    config_ptr->hspa_rnti_stored_cell_pch = status;
  }

  return;
}
/*====================================================================
FUNCTION: rrchsrach_get_ready_for_common_edch()

DESCRIPTION:

DEPENDENCIES:
  None
  
RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
boolean rrchsrach_get_ready_for_common_edch
(
  ordered_config_type *config_ptr
)
{
  boolean status = FALSE;

  if(config_ptr != NULL)
  {
    status = config_ptr->ready_for_common_edch;
  }

  WRRC_MSG2_MED("HSRACH:Get Status of ready for common edch (0:F/1:T) = %d. In use DB(0:OC/1:CC/2:TOC) = %d",status,config_ptr_in_use);

  return status;
}
/*====================================================================
FUNCTION: rrcllc_check_and_reestablish_fach_to_pch()

DESCRIPTION: This function checks if UL size changed while transitioning
from fach to pch so that start value is included in RB reconfig complete

DEPENDENCIES:
  None

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
static void  rrcllc_check_and_reestablish_fach_to_pch( void )
{

  uecomdef_status_e_type  rv = FAILURE;
  uint8 old_idx = MAX_NO_USER_RB;
  boolean reestablish_needed = FALSE;
  uint16 fixed_rlc_size =0;
  boolean fixed_size_valid = FALSE;
  uint8 rb_id = MAX_RB;
  ul_rb_mac_e_mapping_info_type hanging_ul_mace;
  uint8 i,iz,combo_index =MAX_MAPPING_COMBO;
  
  for(i=0;i<MAX_HANGING_RB_MAPPING_INFO;i++)
  {
   /* Initialize the locals */
    rv = FAILURE;
    old_idx = MAX_NO_USER_RB;
    reestablish_needed = FALSE;
    fixed_rlc_size = 0;
    fixed_size_valid = FALSE;
    combo_index =MAX_MAPPING_COMBO;

    /*Check if user RB and AM mode and if HSRACH mappings are present */
    if((rrc_ordered_hanging_rb[i].rb_id == MAX_RB) ||
      (rrc_ordered_hanging_rb[i].rb_id <= DCCH_DT_LOW_PRI_RADIO_BEARER_ID ) ||
      ((rrc_ordered_hanging_rb[i].logch_mode != UE_MODE_ACKNOWLEDGED) &&
          (rrc_ordered_hanging_rb[i].logch_mode != UE_MODE_ACKNOWLEDGED_DATA) &&
          (rrc_ordered_hanging_rb[i].logch_mode != UE_MODE_ACKNOWLEDGED_CONTROL)))
      {
        continue;
      }

    WRRC_MSG2_HIGH("HSRACH: Checking rb mapping for rb_id %d log cha mode %d combo_index ",
      rrc_ordered_hanging_rb[i].rb_id,rrc_ordered_hanging_rb[i].logch_mode);

    combo_index = rrcllc_check_mapping_in_hanging_rb(UL_EDCH_MAPPING|DL_MAC_EHS_MAPPING,i);
  
    if((MAX_MAPPING_COMBO != combo_index) && (rrc_ordered_hanging_rb[i].mapping_info[combo_index].ul_map.edch_map_info.valid == TRUE))
    {

        rb_id = rrc_ordered_hanging_rb[i].rb_id;
        hanging_ul_mace = rrc_ordered_hanging_rb[i].mapping_info[combo_index].ul_map.edch_map_info;
  
        /*Get old size */
        RRC_GET_OLD_BACKUP_SIZE_INDEX(rb_id,old_idx);
  
        if(FAILURE == rv)
        {
          MSG_ERROR("ULREESTABLISHMENT: Unable to get the old size for RB ID %d",rb_id,0,0);
        }

        /*Do the new Fixed PDU Size calculation upfront*/
        if(RLC_FIXED_PDU_SIZE == hanging_ul_mace.rlc_pdu_type)
        {
          for (iz = 0; iz < hanging_ul_mace.num_rlc_size_ddi_info; iz++) 
          {
            fixed_size_valid = TRUE;
            if (fixed_rlc_size < hanging_ul_mace.rlc_size_ddi_info[iz].rlc_pdu_size_in_bits) 
            {
              fixed_rlc_size = hanging_ul_mace.rlc_size_ddi_info[iz].rlc_pdu_size_in_bits;
            }
          }
        }
        
  
        /*Old size is flexible */
        if(RLC_FLEXIBLE_PDU_SIZE == rrc_old_ul_rlc_size_backup[old_idx].ul_rlc_pdu_type)
        {
          /*Old size is flexible and new size is also flexible*/
          if(RLC_FLEXIBLE_PDU_SIZE == hanging_ul_mace.rlc_pdu_type)
          {
            if((rrc_old_ul_rlc_size_backup[old_idx].ul_flex_li_size!=LI_UNSPECIFIED) &&(hanging_ul_mace.ul_li_size!=LI_UNSPECIFIED) &&
              (hanging_ul_mace.ul_li_size!=rrc_old_ul_rlc_size_backup[old_idx].ul_flex_li_size))
            {
              reestablish_needed = TRUE;
              MSG_HIGH("ULREESTABLISHMENT: Flexible %d [0=LI7,1=LI15] to Flexible %d [0=LI7,1=LI15] size change for RB ID %d",
                rrc_old_ul_rlc_size_backup[old_idx].ul_flex_li_size,hanging_ul_mace.ul_li_size,rb_id);
            }
            else
            {
              MSG_HIGH("ULREESTABLISHMENT: No reestablishment Flexible %d [0=LI7,1=LI15] to Flexible %d [0=LI7,1=LI15] for RB ID %d",
                rrc_old_ul_rlc_size_backup[old_idx].ul_flex_li_size,hanging_ul_mace.ul_li_size,rb_id);
            }
          }
          /*Old size is flexible and new size is fixed*/
          else if (RLC_FIXED_PDU_SIZE == hanging_ul_mace.rlc_pdu_type)
          {
            reestablish_needed = TRUE;
            MSG_HIGH("ULREESTABLISHMENT: Flexible LI %d [0=LI7,1=LI15] to Fixed %d size change for RB ID %d",
              rrc_old_ul_rlc_size_backup[old_idx].ul_flex_li_size,fixed_rlc_size,rb_id);
          }
          else
          {
            MSG_ERROR("ULREESTABLISHMENT: Flexible LI %d [0=LI7,1=LI15] to unknown new pdu size %d for RB ID %d",
                rrc_old_ul_rlc_size_backup[old_idx].ul_flex_li_size,hanging_ul_mace.rlc_pdu_type,rb_id);
          }
        }
        /*Old size is fixed*/
        else if (RLC_FIXED_PDU_SIZE == rrc_old_ul_rlc_size_backup[old_idx].ul_rlc_pdu_type)
        {
          /*Old size is fixed and new size is flexible*/
          if(RLC_FLEXIBLE_PDU_SIZE == hanging_ul_mace.rlc_pdu_type)
          {
            if(LI_15_BITS == hanging_ul_mace.ul_li_size)
            {
              reestablish_needed = TRUE;
              MSG_HIGH("ULREESTABLISHMENT: Fixed %d to Flexible LI %d [0=LI7,1=LI15] size change for RB ID %d",
                rrc_old_ul_rlc_size_backup[old_idx].ul_fixed_rlc_size,hanging_ul_mace.ul_li_size,rb_id);
            }
            else
            {
              MSG_HIGH("ULREESTABLISHMENT: No reestablishment Fixed %d  to Flexible LI %d [0=LI7,1=LI15] for RB ID %d",
                rrc_old_ul_rlc_size_backup[old_idx].ul_fixed_rlc_size,hanging_ul_mace.ul_li_size,rb_id);
            }
          }
          /*Old size is fixed and new size is also fixed*/
          else if (RLC_FIXED_PDU_SIZE == hanging_ul_mace.rlc_pdu_type)
          {
            if(( TRUE == fixed_size_valid) &&( RRCLLC_INVALID_RLC_SIZE != rrc_old_ul_rlc_size_backup[old_idx].ul_fixed_rlc_size) 
              && (fixed_rlc_size != rrc_old_ul_rlc_size_backup[old_idx].ul_fixed_rlc_size))
            {
              reestablish_needed = TRUE;
              MSG_HIGH("ULREESTABLISHMENT: Fixed %d to Fixed %d size change for RB ID %d",
                rrc_old_ul_rlc_size_backup[old_idx].ul_fixed_rlc_size,fixed_rlc_size,rb_id);
            }
            else
            {
              MSG_HIGH("ULREESTABLISHMENT: No reestablishment Fixed%d  to Fixed %d for RB ID %d",
                rrc_old_ul_rlc_size_backup[old_idx].ul_fixed_rlc_size,fixed_rlc_size,rb_id);
            }
          }
          else
          {
            MSG_ERROR("ULREESTABLISHMENT: Fixed %d to unknown new pdu size %d for RB ID %d",
              rrc_old_ul_rlc_size_backup[old_idx].ul_fixed_rlc_size,hanging_ul_mace.rlc_pdu_type,rb_id);
          }
        }
        else
        {
          MSG_HIGH("ULREESTABLISHMENT: Unknown Old PDU size %d ",rrc_old_ul_rlc_size_backup[old_idx].ul_rlc_pdu_type,0,0);
        }
        
        rrcllc_set_reestablish_entity_for_ul(rb_id,reestablish_needed);    
  
    }
    else
    {
	     WRRC_MSG1_HIGH("HSRACH: EUL-EHS mapping for rb_id %d is not present",rrc_ordered_hanging_rb[i].rb_id);
    }
  }

}
/*====================================================================
FUNCTION: rrcllc_check_and_update_hsrach_params()

DESCRIPTION:

DEPENDENCIES:
  None

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_check_and_update_hsrach_params
(
  rrc_RRC_StateIndicator rrc_StateIndicator,
  boolean validate_directed_cell_info,
  boolean validation_check,
  boolean new_ernti_present
)
{

  if(rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH)
  {
    /*If there is redirection or an out of DCH transition, no validation has to be done*/
    if(validate_directed_cell_info == FALSE ||
       rrc_get_state() ==  RRC_STATE_CELL_DCH)
      return SUCCESS;

    if(rrchsrach_camped_cell_supports_hsrach() == FALSE)
      return SUCCESS;
    
    (void)rrcllc_update_hs_rach_params(ordered_config_ptr);

    /*Will happen for RCE procedures only, for reconfiguraitons/setup UE will go to IDLE as directed by LLC*/
    if(validation_check == TRUE)  
    {
      if(new_ernti_present == FALSE ||
         rrcllc_check_hsrach_mappings_are_given_for_rbs(ordered_config_ptr) == FALSE)
      {
        WRRC_MSG0_HIGH("HSRACH: ERNTI or mappings are not present, reject OTA");
        return FAILURE;
      }
    }
    rrchsrach_set_common_edch_transmission(ordered_config_ptr, FALSE);
    if(rrcllc_check_if_hs_rach_can_be_started_reconfigured(ordered_config_ptr) == FALSE)
    {
      /*Skip determining hsrach action because we are going to reject this configuration*/
      WRRC_MSG0_HIGH("HSRACH:HS can't be Started/Reconfig in Cell-FACH");
      return FAILURE;
    }
    else
    {
      rrchsrach_set_common_edch_transmission(ordered_config_ptr, TRUE);
      rrchsrach_set_ready_for_common_edch(ordered_config_ptr, TRUE);
      WRRC_MSG0_MED("HSRACH:HSRACH is set to ACTIVE in OC");  
    }
    
      /*Determine HSRACH action even if cell doesnt support HSRACH to handle
            scenarios where when camped cell supports HSRACH is checked
            sibdb doesnt have valid contents*/
    rrcllc_determine_hsrach_action();
  }
  else
  {
    WRRC_MSG6_MED("ULREESTABLISHMENT: Current state:%d, next state:%d,validate_directed_cell_info:%d, efach_hrnti_status %d, primary_e_rnti_present:%d, hspa_rnti_stored_cell_pch:%d",
          rrc_get_state(), rrc_ordered_state,validate_directed_cell_info,ordered_config_ptr->efach_hrnti_status,ordered_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present,
          ordered_config_ptr->hspa_rnti_stored_cell_pch);

    /*Code is written for FACH to PCH transition without redirection- later if needed we can extend it for other scenarios.*/
	
    if((rrc_get_state() == RRC_STATE_CELL_FACH) &&
       (rrc_ordered_state == RRC_STATE_CELL_PCH) &&
        validate_directed_cell_info &&
       (rrchsrach_get_common_edch_transmission(ordered_config_ptr) == TRUE) &&
       (rrchsrach_camped_cell_supports_hsrach() == TRUE) &&
       (DEDICATED_HRNTI == ordered_config_ptr->efach_hrnti_status) &&
       (ordered_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present == TRUE) &&
       (ordered_config_ptr->hspa_rnti_stored_cell_pch == TRUE)
      )
    {
      rrcllc_check_and_reestablish_fach_to_pch();
      ul_reestab_for_pch_trans = TRUE;
    }
    rrchsrach_set_hsrach_action_to_stop_if_active_ota();
  }
  return SUCCESS;
}

/*====================================================================
FUNCTION: rrcllc_evaluate_hs_rach_and_set_lower_layers_action()

DESCRIPTION:

DEPENDENCIES:
  None
  
RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_evaluate_hs_rach_and_set_lower_layers_action(rrc_state_e_type next_rrc_state,ordered_config_type* config_ptr)
{

  rrchsrach_set_common_edch_transmission(config_ptr, FALSE);

  if(rrchsrach_camped_cell_supports_hsrach())
  {

    if(rrcllc_update_hs_rach_params(config_ptr) == FAILURE)
    {
      /*Skip determining hsrach action because we are going to reject this configuration*/
      WRRC_MSG0_HIGH("HSRACH:HS can't be Started/Reconfig in Cell-FACH");
      return FAILURE;
    }
    else
    {
      if(rrcllc_check_if_hs_rach_can_be_started_reconfigured(config_ptr) == FALSE)
      {
        WRRC_MSG0_HIGH("HSRACH:HS can't be Started/Reconfig in Cell-FACH");
        return FAILURE;
      }
      else
      {
        rrchsrach_set_common_edch_transmission(config_ptr, TRUE);
        rrchsrach_set_ready_for_common_edch(config_ptr, TRUE);
        WRRC_MSG0_MED("HSRACH:HSRACH is set to ACTIVE in OC");  
      }
    }
  }
  else
  {
    WRRC_MSG0_HIGH("HSRACH:Cell doesn't support HSRACH operation");
  }

/*Determine HSRACH action even if cell doesnt support HSRACH to handle
  scenarios where when camped cell supports HSRACH is checked
  sibdb doesnt have valid contents*/
  rrcllc_determine_hsrach_action();

  return SUCCESS;
}

/*====================================================================
FUNCTION: rrcllc_determine_hsrach_action_for_e_fach()

DESCRIPTION:


DEPENDENCIES:
  None.

RETURN VALUE:
  True/False.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_determine_hsrach_action
(
  void
)
{
  if(current_config_ptr->common_edch_transmission)
  {
    if(ordered_config_ptr->common_edch_transmission)
    {
      ordered_config_ptr->l1_hs_rach_req_mask = L1_HS_RACH_STOP |L1_HS_RACH_START;
      rrcllc_set_hs_rach_action(ordered_config_ptr,MAC_HS_RACH_CONFIG);
      ordered_config_ptr->mac_ul_parms.ul_pdu_type = MAC_I_PDU_HDR;
    }
    else
    {
      ordered_config_ptr->l1_hs_rach_req_mask = L1_HS_RACH_STOP;
      rrcllc_set_hs_rach_action(ordered_config_ptr,MAC_HS_RACH_STOP);
    }
  }
  else
  {
    if(ordered_config_ptr->common_edch_transmission)
    {
      ordered_config_ptr->l1_hs_rach_req_mask = L1_HS_RACH_START;
      rrcllc_set_hs_rach_action(ordered_config_ptr,MAC_HS_RACH_START);
      ordered_config_ptr->mac_ul_parms.ul_pdu_type = MAC_I_PDU_HDR;
    }
    else
    {
      ordered_config_ptr->l1_hs_rach_req_mask = L1_HS_RACH_NO_OP;
      rrcllc_set_hs_rach_action(ordered_config_ptr,MAC_HS_RACH_NOOP);           
    }
  }
WRRC_MSG2_MED("HSRACH:l1_hs_rach_req_mask %d mac_hs_rach_action %d", ordered_config_ptr->l1_hs_rach_req_mask, ordered_config_ptr->mac_hs_rach_action);
}

/*====================================================================
FUNCTION: rrcllc_set_hs_rach_action()

DESCRIPTION:

DEPENDENCIES:
  None
  
RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_set_hs_rach_action
(
  ordered_config_type *config_ptr,
  mac_hs_rach_action_e_type action
)
{
  if(config_ptr != NULL)
  {
    if(action != config_ptr->mac_hs_rach_action) 
    {
      WRRC_MSG2_HIGH("HSRACH:Set Action (0:N/1:S/2:R/4:S) = %d. In use DB(0:OC/1:CC/2:TOC) %d",action,config_ptr_in_use);
    }
    config_ptr->mac_hs_rach_action = action;
  }

  return;
}
/*====================================================================
FUNCTION: rrcllc_get_hs_rach_action()

DESCRIPTION:

DEPENDENCIES:
  None
  
RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
mac_hs_rach_action_e_type rrcllc_get_hs_rach_action
(
  ordered_config_type *config_ptr
)
{
  mac_hs_rach_action_e_type action = MAC_HS_RACH_NOOP;

  if(config_ptr != NULL)
  {
    action = config_ptr->mac_hs_rach_action;
  }

  WRRC_MSG2_HIGH("HSRACH:Get Action (0:N/1:S/2:R/3:S) = %d. In use DB(0:OC/1:CC/2:TOC) = %d",action,config_ptr_in_use);

  return action;
}

/*====================================================================
FUNCTION: rrcllc_check_if_hs_rach_can_be_started_reconfigured()

DESCRIPTION:
  This function checks if HSDPA can be started/reconfigured in e-FACH state by looking at the following
  Check whether C-RNTI is present
  Dedicated H-RNTI is present
  The MAC-ehs Re-ordering Queues are present on which RBs are mapped.

DEPENDENCIES:
  None.

RETURN VALUE:
  True/False.

SIDE EFFECTS:
  None.
====================================================================*/

boolean rrcllc_check_if_hs_rach_can_be_started_reconfigured(ordered_config_type* config_ptr)
{

  /*Check for Valid E-RNTI*/
  if(config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present == TRUE)
  {
      WRRC_MSG0_HIGH("HSRACH:Valid E-RNTI Present");

  if(rrcllc_check_hsrach_mappings_are_given_for_rbs(config_ptr) == FALSE)
  {
      WRRC_MSG0_HIGH("HSRACH:HS can't be Started/Reconfig in Cell-FACH");
    return FALSE;
  }
  }
  else
  {
  /*Below is debug code */
    if(!(rrcrb_is_cu_required() || rrccu_get_cu_initiate_reqd() || (rrccu_get_cell_update_started_status() == RRCCU_STARTED)))
    {
      WRRC_MSG0_ERROR("HSRACH:Debug code E-RNTI not present but CU flag is not TRUE");
    }

  }
  return TRUE;
}

/*====================================================================
FUNCTION: rrcllc_check_efach_hsrach_mappings_in_hanging_rb

DESCRIPTION:
  This function checks if hsrach mappings are available based on RB-ID

DEPENDENCIES:
  None.

RETURN VALUE:
  True/False.

SIDE EFFECTS:
  None.
====================================================================*/

static boolean rrcllc_check_efach_hsrach_mappings_in_hanging_rb(uint8 rb_id, uint8 ul_dl_mapping_combo)
{
  uint8 mapping_cntr_combo = MAX_MAPPING_COMBO,hrb_idx = MAX_HANGING_RB_MAPPING_INFO;
  
  hrb_idx = rrcllc_get_rb_idx_from_hrb(rb_id);

  if(hrb_idx >= MAX_HANGING_RB_MAPPING_INFO)
  {
    return FALSE;
  }

  mapping_cntr_combo = rrcllc_check_mapping_in_hanging_rb(ul_dl_mapping_combo,hrb_idx);  
  if(mapping_cntr_combo >= MAX_MAPPING_COMBO)
  {
    WRRC_MSG1_ERROR("HSRACH: HSRACH mappings not present for rb_id %d ",rb_id);
    return FALSE;
  }
  else if ((ul_dl_mapping_combo & UL_EDCH_MAPPING) 
           && (ul_dl_mapping_combo & DL_MAC_EHS_MAPPING) 
           && (rrc_ordered_hanging_rb[hrb_idx].mapping_info[mapping_cntr_combo].ul_map.edch_map_info.mac_e_flow_id == HS_RACH_CCCH_D_FLOW_ID))
  {
     /* If CCCH mac_d flow id is configured for SRBs consider this as Invalid */
     /* From section 10.3.5.3b 
           NOTE 1:   For FDD, E-DCH MAC-d flow identity 7 is reserved for CCCH transmission. */
     WRRC_MSG1_ERROR("Mac-d flow ID 7 is reserved for CCCH, RB-ID %d",rb_id);
     return FALSE;        
  }
  return TRUE;
}
/*====================================================================
FUNCTION: rrcllc_check_hsrach_mappings_for_all_rbs_present()

DESCRIPTION:
  This function checks if hsrach mappings are available for all
  srbs and rbs in established rabs.

DEPENDENCIES:
  None.

RETURN VALUE:
  True/False.

SIDE EFFECTS:
  None.
====================================================================*/
boolean rrcllc_check_hsrach_mappings_for_all_rbs_present()
{
  rlc_lc_id_type ul_rlc_lc_id = RRCLCM_RLC_LC_ID_NOT_FOUND;
  uint32 rab_count;
  uint32 rb_count;
  
  for(rb_count = DCCH_UM_RADIO_BEARER_ID; rb_count<=DCCH_DT_HIGH_PRI_RADIO_BEARER_ID; rb_count++)
  {
    if(FALSE == rrcllc_check_efach_hsrach_mappings_in_hanging_rb(rb_count,(UL_EDCH_MAPPING|DL_MAC_EHS_MAPPING)))
    {
      return FALSE;
    }
  }

    /* check whether RB4 was present or not */
  ul_rlc_lc_id = rrclcm_check_ul_rlc_lc_id(UE_LOGCHAN_DCCH, 
                                 DCCH_DT_LOW_PRI_RADIO_BEARER_ID,
                                 UE_MODE_ACKNOWLEDGED_DATA);

  if(ul_rlc_lc_id != RRCLCM_RLC_LC_ID_NOT_FOUND)
  {
    if(FALSE == rrcllc_check_efach_hsrach_mappings_in_hanging_rb(DCCH_DT_LOW_PRI_RADIO_BEARER_ID,(UL_EDCH_MAPPING|DL_MAC_EHS_MAPPING)))
    {
      return FALSE;
    }
  }

  for (rab_count=0; rab_count<MAX_RAB_TO_SETUP; rab_count++)
  {
    if (
         ((rrc_est_rabs.rabs[rab_count].cn_domain == RRC_CS_DOMAIN_CN_ID)|| 
           (rrc_est_rabs.rabs[rab_count].cn_domain == RRC_PS_DOMAIN_CN_ID))
          &&
          (rrc_est_rabs.rabs[rab_count].num_rbs_for_rab > 0)
        )
    {
      /*it is a valid established rab, now compare each rb-id in this established rab with 
      the rb-id received in the message */
      for (rb_count=0; ((rb_count<rrc_est_rabs.rabs[rab_count].num_rbs_for_rab) && 
        (rb_count < MAX_RB_PER_RAB)); rb_count++)    
      {
      if(FALSE == rrcllc_check_efach_hsrach_mappings_in_hanging_rb(rrc_est_rabs.rabs[rab_count].rb_for_rab[rb_count].rb_id,(UL_EDCH_MAPPING|DL_MAC_EHS_MAPPING)))
        {
          return FALSE;
        }
      }
    } /*end of if*/
  }/* rab_count loop */
  
  return TRUE;
}

/*====================================================================
FUNCTION: rrcllc_check_for_edch_hsrach_mapping()

DESCRIPTION:


DEPENDENCIES:
  None.

RETURN VALUE:
  True/False.

SIDE EFFECTS:
  None.
====================================================================*/
boolean rrcllc_check_for_edch_hsrach_mapping
(
  ordered_config_type *config_ptr,
  rb_id_type rb_id
)
{
  uint8 ix = 0, iy =0;

  for(ix = 0; ix < config_ptr->mac_hs_rach_config.hs_rach_config.num_e_mac_d_flow; ix++)
  {
    if(config_ptr->mac_hs_rach_config.hs_rach_config.e_mac_d_flow_info[ix].e_mac_d_flow_id != INVALID_DFLOW_ID)
    {
      for(iy = 0; iy < config_ptr->mac_hs_rach_config.hs_rach_config.e_mac_d_flow_info[ix].num_logch; iy++)
      {
        if (config_ptr->mac_hs_rach_config.hs_rach_config.e_mac_d_flow_info[ix].e_ul_logch_info[iy].rb_id == rb_id) 
        {
          return TRUE;
        }
      }
    }
  }

  WRRC_MSG1_HIGH("HSRACH: EUL mapping not found rb = %d",rb_id);
  return FALSE;
}

/*====================================================================
FUNCTION: rrcllc_check_hsrach_mappings_in_channel_config_req()

DESCRIPTION:


DEPENDENCIES:
  None.

RETURN VALUE:
  True/False.

SIDE EFFECTS:
  None.
====================================================================*/
boolean rrcllc_check_mappings_in_channel_config_req_and_srb
(
  rrc_channel_config_req_type *channel_config_req_ptr,
  uint8 ul_dl_mapping_combo
)
{
  uint8 rb_index = 0;

  for(rb_index=0;rb_index<channel_config_req_ptr->num_rb_to_config;rb_index++)
  {
    /* Skip checking mappings for SRBs in this loop as SRB mappings are checked separately */
    if((channel_config_req_ptr->rb[rb_index].rb_id <= DCCH_DT_HIGH_PRI_RADIO_BEARER_ID) ||
       (channel_config_req_ptr->rb[rb_index].rb_config == RELEASE_RB))
    {
      continue;
    }     
    if(FALSE == rrcllc_check_efach_hsrach_mappings_in_hanging_rb(channel_config_req_ptr->rb[rb_index].rb_id,ul_dl_mapping_combo))
    {
      return FALSE;
    }
  }

  /*Check mapping in SRB's as well, required for cases where channel config resquest doesnt have SRB's*/
  for(rb_index=DCCH_UM_RADIO_BEARER_ID;rb_index<=DCCH_DT_HIGH_PRI_RADIO_BEARER_ID;rb_index++)
  {
    if(FALSE == rrcllc_check_efach_hsrach_mappings_in_hanging_rb(rb_index,ul_dl_mapping_combo))
    {
      return FALSE;
    }
  }
  return TRUE;
}

/*====================================================================
FUNCTION: rrcllc_update_hsrach_e_dch_mapping_info_with_log_chl_id()

DESCRIPTION:
  This function updates the Uplink Mapping Info in EDCH RB Mapping
  Info with the passed Logical Channel ID.
  The correct entity is selected based on the passed RB ID.
  The EDCH RB mapping info in the passed Config data is updated.

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_update_hsrach_e_dch_mapping_info_with_log_chl_id
(
  ordered_config_type  *config_ptr,
  rrc_RB_Identity  rb_id,
  rlc_lc_id_type   rlc_ul_log_chl_id
)
{
  boolean rb_found = FALSE;
  int ix, iy;

  for(ix = 0; (!rb_found) && (ix < config_ptr->mac_hs_rach_config.hs_rach_config.num_e_mac_d_flow); ix++)
  {
    if(config_ptr->mac_hs_rach_config.hs_rach_config.e_mac_d_flow_info[ix].e_mac_d_flow_id != INVALID_DFLOW_ID)
    {
      for(iy = 0; (!rb_found) && (iy < config_ptr->mac_hs_rach_config.hs_rach_config.e_mac_d_flow_info[ix].num_logch); iy++)
      {
        if (config_ptr->mac_hs_rach_config.hs_rach_config.e_mac_d_flow_info[ix].e_ul_logch_info[iy].rb_id == rb_id) 
        {
          WRRC_MSG2_MED("RRCEUL: rb_id %d lc_id %d", rb_id, rlc_ul_log_chl_id);
          rb_found = TRUE;
          config_ptr->mac_hs_rach_config.hs_rach_config.e_mac_d_flow_info[ix].e_ul_logch_info[iy].rlc_id = rlc_ul_log_chl_id;
          break;
        }
      }
    }
  }
}
/*====================================================================
FUNCTION: rrchsrach_set_hsrach_action_to_stop_if_active_ota()

DESCRIPTION:

   reset the mac and l1 action if hsrach is active

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/

void rrchsrach_set_hsrach_action_to_stop_if_active_ota(void)
{
  if(rrc_ordered_state == RRC_STATE_CELL_DCH)
  {
  if(TRUE == rrchsrach_get_common_edch_transmission(current_config_ptr))
  {
    rrchsrach_set_common_edch_transmission(ordered_config_ptr, FALSE);
    ordered_config_ptr->l1_hs_rach_req_mask = L1_HS_RACH_STOP;
    rrcllc_set_hs_rach_action(ordered_config_ptr,MAC_HS_RACH_STOP);

    if((rrc_ordered_state == RRC_STATE_CELL_DCH) && (ordered_config_ptr->e_dch_transmission == TRUE))
    {
      ordered_config_ptr->hs_rach_to_eul_trans = TRUE;
    }
  }
  else
  {
    ordered_config_ptr->l1_hs_rach_req_mask = L1_HS_RACH_NO_OP;
    rrcllc_set_hs_rach_action(ordered_config_ptr,MAC_HS_RACH_NOOP);
  }
  if((ordered_config_ptr->mac_hs_rach_action != MAC_HS_RACH_NOOP) || (ordered_config_ptr->l1_hs_rach_req_mask != L1_HS_RACH_NO_OP))
  {
    WRRC_MSG2_MED("HSRACH: MAC action is = %d, L1 req mask is %d (0:N/1:S/2:R/3:S)",
    ordered_config_ptr->mac_hs_rach_action,ordered_config_ptr->l1_hs_rach_req_mask);
  }
  }
}
/*====================================================================
FUNCTION: rrchsrach_set_hsrach_action_to_stop_if_active()

DESCRIPTION:

   reset the mac and l1 action if hsrach is active

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/

void rrchsrach_set_hsrach_action_to_stop_if_active
(
  boolean clear_all_config_pointers
)
{

  if (ORDERED_CONFIG == config_ptr_in_use)
  {
    if(TRUE == rrchsrach_get_common_edch_transmission(ordered_config_ptr))
    {
      rrchsrach_set_common_edch_transmission(ordered_config_ptr, FALSE);
      ordered_config_ptr->l1_hs_rach_req_mask = L1_HS_RACH_STOP;
      rrcllc_set_hs_rach_action(ordered_config_ptr,MAC_HS_RACH_STOP);
  
  
    }
    else
    {
      ordered_config_ptr->l1_hs_rach_req_mask = L1_HS_RACH_NO_OP;
      rrcllc_set_hs_rach_action(ordered_config_ptr,MAC_HS_RACH_NOOP);
    }
    WRRC_MSG2_HIGH("HSRACH: MAC action is = %d, L1 req mask is %d (0:N/1:S/2:R/4:S)",
    ordered_config_ptr->mac_hs_rach_action,ordered_config_ptr->l1_hs_rach_req_mask);

      if (TRUE == clear_all_config_pointers)
      {
        rrcllc_init_hs_rach_info(current_config_ptr);
        rrcllc_init_hs_rach_info(transition_config.toc_ptr);
      }
      
  }
  else
  {
    if(TRUE == rrchsrach_get_common_edch_transmission(current_config_ptr))
    {
      rrchsrach_set_common_edch_transmission(current_config_ptr, FALSE);
      current_config_ptr->l1_hs_rach_req_mask = L1_HS_RACH_STOP;
      rrcllc_set_hs_rach_action(current_config_ptr,MAC_HS_RACH_STOP);
  
  
    }
    else
    {
      current_config_ptr->l1_hs_rach_req_mask = L1_HS_RACH_NO_OP;
      rrcllc_set_hs_rach_action(current_config_ptr,MAC_HS_RACH_NOOP);
    }

      if (TRUE == clear_all_config_pointers)
      {
        rrcllc_init_hs_rach_info(ordered_config_ptr);
        rrcllc_init_hs_rach_info(transition_config.toc_ptr);
      }
          
    WRRC_MSG2_HIGH("HSRACH: MAC action is = %d, L1 req mask is %d (0:N/1:S/2:R/4:S)",
    current_config_ptr->mac_hs_rach_action,current_config_ptr->l1_hs_rach_req_mask);
  }
  


}

/*====================================================================
FUNCTION: rrcllc_determine_hsrach_action_for_reselection()

DESCRIPTION:


DEPENDENCIES:
  None.

RETURN VALUE:
  True/False.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_determine_hsrach_action_for_reselection
(
  ordered_config_type* prev_ptr, ordered_config_type* next_ptr
)
{
  if(prev_ptr->common_edch_transmission)
  {
    if(next_ptr->common_edch_transmission)
    {
      next_ptr->l1_hs_rach_req_mask = L1_HS_RACH_STOP| L1_HS_RACH_START;
      rrcllc_set_hs_rach_action(next_ptr,MAC_HS_RACH_CONFIG);
      /*hs-rach to hs-rach cell we need to send reset indicator*/
      next_ptr->mac_hsrach_e_reset_indicator = TRUE;
      next_ptr->mac_ul_parms.ul_pdu_type = MAC_I_PDU_HDR;
    }
    else
    {
      next_ptr->l1_hs_rach_req_mask = L1_HS_RACH_STOP;
      rrcllc_set_hs_rach_action(next_ptr,MAC_HS_RACH_STOP);
    }
  }
  else
  {
    if(next_ptr->common_edch_transmission)
    {
      next_ptr->l1_hs_rach_req_mask = L1_HS_RACH_START;
      rrcllc_set_hs_rach_action(next_ptr,MAC_HS_RACH_START);
      next_ptr->mac_ul_parms.ul_pdu_type = MAC_I_PDU_HDR;
    }
    else
    {
      next_ptr->l1_hs_rach_req_mask = L1_HS_RACH_NO_OP;
      rrcllc_set_hs_rach_action(next_ptr,MAC_HS_RACH_NOOP);           
    }
  }

  WRRC_MSG2_MED("HSRACH:l1_hs_rach_req_mask %d mac_hs_rach_action %d", prev_ptr->l1_hs_rach_req_mask, next_ptr->mac_hs_rach_action);
  
}
/*============================================================================
DESCRIPTION:
  This funtion resets MAC and L1 hsrach actions

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
=============================================================================*/
void rrcllc_reset_mac_and_l1_for_hsrach_config_ptr
(
  ordered_config_type* config_ptr 
)
{

    config_ptr->l1_hs_rach_req_mask = L1_HS_RACH_NO_OP;
    rrcllc_set_hs_rach_action(config_ptr,MAC_HS_RACH_NOOP);
    config_ptr->mac_e_reset_indicator = FALSE;
    config_ptr->mac_e_tsn_action = MAC_E_TSN_ACTION_BACKUP;
    config_ptr->transition_to_dch = FALSE;
    config_ptr->hs_rach_to_eul_trans= FALSE;
}
/*============================================================================
DESCRIPTION:
  This funtion resets MAC and L1 hsrach actions

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
=============================================================================*/
void rrcllc_reset_mac_and_l1_for_hsrach
(
  boolean clear_all_config_pointers
)
{

  if(config_ptr_in_use == ORDERED_CONFIG)
  {

    ordered_config_ptr->l1_hs_rach_req_mask = L1_HS_RACH_NO_OP;
    rrcllc_set_hs_rach_action(ordered_config_ptr,MAC_HS_RACH_NOOP);
    ordered_config_ptr->mac_e_reset_indicator = FALSE;
    ordered_config_ptr->mac_e_tsn_action = MAC_E_TSN_ACTION_BACKUP;
    ordered_config_ptr->transition_to_dch = FALSE;
    ordered_config_ptr->hs_rach_to_eul_trans= FALSE;
  
    if(TRUE == clear_all_config_pointers)
    {
      rrcllc_init_hs_rach_info(current_config_ptr);
      rrcllc_init_hs_rach_info(transition_config.toc_ptr);
    }

  }
  else
  {

    current_config_ptr->l1_hs_rach_req_mask = L1_HS_RACH_NO_OP;
    rrcllc_set_hs_rach_action(current_config_ptr,MAC_HS_RACH_NOOP);
    current_config_ptr->mac_e_reset_indicator = FALSE;
    current_config_ptr->mac_e_tsn_action = MAC_E_TSN_ACTION_BACKUP;
    current_config_ptr->transition_to_dch = FALSE;
    current_config_ptr->hs_rach_to_eul_trans= FALSE;

  if(TRUE == clear_all_config_pointers)
  {
      rrcllc_init_hs_rach_info(ordered_config_ptr);
      rrcllc_init_hs_rach_info(transition_config.toc_ptr);
  }
  
  }

  
  return;
}
/*====================================================================
FUNCTION: rrcllc_get_hsrach_config_ptr()

DESCRIPTION:
  This function returns rrcllc_get_hsrach_config_ptr from current config

DEPENDENCIES:
  None.

RETURN VALUE:

SIDE EFFECTS:
  None.

=====================================================================*/
mac_hs_rach_config_s_type *rrcllc_get_hsrach_config_ptr
(
  void
)
{
 if(rrchsrach_camped_cell_supports_hsrach())
 {
   if(config_ptr_in_use == ORDERED_CONFIG)
   {
     return (&ordered_config_ptr->mac_hs_rach_config);
   }
   else if(config_ptr_in_use == CURRENT_CONFIG)
   {
     return (&current_config_ptr->mac_hs_rach_config);
   }
 }
 return NULL;
}
/*====================================================================
FUNCTION: rrcllc_check_if_rbid_exists_in_config_ptr()

DESCRIPTION:
  This function finds if a RB ID exists in database 

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
boolean rrcllc_check_if_rbid_exists_in_config_ptr
(
  ordered_config_type  *config_ptr,
  rrc_RB_Identity  rb_id,
  uint8    e_mac_d_flow_idx
)
{
  uint8 iy;
  
    for(iy = 0;  (iy < config_ptr->mac_e_config.e_mac_d_flow_info[e_mac_d_flow_idx].num_logch); iy++)
    {
      if (config_ptr->mac_e_config.e_mac_d_flow_info[e_mac_d_flow_idx].e_ul_logch_info[iy].rb_id == rb_id) 
      {
        return TRUE;
      }
    }
  return FALSE;
}
/*====================================================================
FUNCTION: rrcllc_init_mac_hsrach_info()

DESCRIPTION:
  This function initializes hs-rach mac mapping structures in rrc data-base except for CCCH channel
  
DEPENDENCIES:

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_mac_hsrach_mapping_info
(
  mac_hs_rach_config_s_type *mac_hs_rach_config_ptr
)
{
  uint32 count, idx;

  for (count=0; count<MAX_E_DCH_MAC_D_FLOW; count++)
  {

    /*Initialize all the mappings except for flow id 7 because this is the only mapping we will
    fill from sib. This is needed because dedicated mode configuration should not delete
    the common mode mappings*/
    
    if (mac_hs_rach_config_ptr->hs_rach_config.e_mac_d_flow_info[count].
        e_mac_d_flow_id != (INVALID_DFLOW_ID-1))
    {
        
    mac_hs_rach_config_ptr->hs_rach_config.e_mac_d_flow_info[count].
      num_logch = 0;

    for (idx=0; idx < MAX_DED_LOGCHAN_PER_TRCH; idx++)
    {
      mac_hs_rach_config_ptr->hs_rach_config.e_mac_d_flow_info[count].
        e_ul_logch_info[idx].rb_id = 0xFF;

      mac_hs_rach_config_ptr->hs_rach_config.e_mac_d_flow_info[count].
        e_ul_logch_info[idx].rlc_id = 0xF;

      mac_hs_rach_config_ptr->hs_rach_config.e_mac_d_flow_info[count].
        e_ul_logch_info[idx].lc_id = 0xF;
	  
      mac_hs_rach_config_ptr->hs_rach_config.e_mac_d_flow_info[count].
        e_ul_logch_info[idx].rlc_mode = UE_MODE_MAX_NUM;

      mac_hs_rach_config_ptr->hs_rach_config.e_mac_d_flow_info[count].
        e_ul_logch_info[idx].priority = 0xF;

      mac_hs_rach_config_ptr->hs_rach_config.e_mac_d_flow_info[count].
        e_ul_logch_info[idx].chan_type = UE_LOGCHAN_MAX_NUM;

      mac_hs_rach_config_ptr->hs_rach_config.e_mac_d_flow_info[count].
        e_ul_logch_info[idx].include_in_scheduling_info = FALSE;
	  
      mac_hs_rach_config_ptr->hs_rach_config.e_mac_d_flow_info[count].
        e_ul_logch_info[idx].num_rlc_size_ddi_info = 0;
	  
#ifdef FEATURE_MAC_I
      mac_hs_rach_config_ptr->hs_rach_config.e_mac_d_flow_info[count].
        e_ul_logch_info[idx].rlc_pdu_type = RLC_INVALID_PDU_SIZE;

      mac_hs_rach_config_ptr->hs_rach_config.e_mac_d_flow_info[count].
        e_ul_logch_info[idx].ul_li_size = LI_UNSPECIFIED;
	  
      mac_hs_rach_config_ptr->hs_rach_config.e_mac_d_flow_info[count].
        e_ul_logch_info[idx].ul_flex_min_pdu_size = RRC_UL_INVALID_RLC_SIZE;
	  
      mac_hs_rach_config_ptr->hs_rach_config.e_mac_d_flow_info[count].
        e_ul_logch_info[idx].ul_flex_max_pdu_size = RRC_UL_INVALID_RLC_SIZE;
#endif /* FEATURE_MAC_I */	

    }
    }
  }
}
/*====================================================================
FUNCTION: rrchsrach_check_ernti_status()

DESCRIPTION:
This function checks if ernti is valid in hsrach cell 
This funcion should be called during fach to fach redirection and
during dch to fach transitions only.

DEPENDENCIES:
  None.

RETURN VALUE:
  True/False.

SIDE EFFECTS:
  None.
====================================================================*/
boolean rrchsrach_check_ernti_status
(
  void
)
{
  if((rrchsrach_camped_cell_supports_hsrach() == TRUE) &&
     (rrc_get_state() == RRC_STATE_CELL_FACH ) &&
     (transition_config.toc_usage != TOC_INVALID)&&
     (transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present == FALSE))
  {
    /*Set Hrnti status as valid to keep rrcllc happy
       so that the final channel config with OTA info 
       will be passed. It doesn't cause any issue as we will be
      doing cell udpate after gettign chanel config cnf */
    WRRC_MSG0_HIGH("RRCHSRACH:E-RNTI not present so trigger CU to get it");
    return TRUE;
  }
  return FALSE;
}
/*====================================================================
FUNCTION: rrcllc_get_ul_rlc_size_in_config_ptr()

DESCRIPTION:
This function gets the UL rlc size in fach state.

DEPENDENCIES:
  None.

RETURN VALUE:
  True/False.

SIDE EFFECTS:
  None.
====================================================================*/
uint32 rrcllc_get_ul_rlc_size_in_config_ptr
(
  ordered_config_type  *config_ptr,
  rrc_RB_Identity rb_id
)
{

  uint32 rlc_size = 0;
  uint32 tf_count;
  uint32 tfi_count;
  uint32 tf_idx;
  uint32 dlch_count;
  uint8 mac_hdr_size;
  boolean  rb_found = FALSE;

    rlc_size = 0;

    /* When multiple logical channels are mapped to RACH, we need extra 4 bits in MAC header */
    
    if(config_ptr->mac_ul_parms.cctrch_ptr->rach_info.ndlchan > 1)
    {
      mac_hdr_size = RRCLLC_DED_MULTI_LOG_CHL_RACH_MAC_HDR_SIZE;
    }
    else
    {
      mac_hdr_size = RRCLLC_DED_SINGLE_LOG_CHL_RACH_MAC_HDR_SIZE;
    }

    /*We need to loop through all the logical channels that are mapped to RACH 
        and find out which logical channel has RB id same as rb_id*/
    
    for(dlch_count = 0;
     (dlch_count < config_ptr->mac_ul_parms.cctrch_ptr->rach_info.ndlchan) &&
          (rb_found == FALSE);
        dlch_count ++)
    {
      if(config_ptr->mac_ul_parms.cctrch_ptr->rach_info.dlchan_info[dlch_count].rb_id == rb_id)
      {
        rb_found = TRUE;
        
        /* Check for whether all the TFs are allowed */
        if(config_ptr->mac_ul_parms.cctrch_ptr->rach_info.dlchan_info[dlch_count].rlc_size_info.all_tfi_valid == TRUE)
        {
          /* Since there is only one RACH Channel, we use index 0 instead of looping through all the TrCHs 
           We loop through all the TFs of the RACH channel to find the max TB size. */
          for(tf_count =0;
               tf_count < config_ptr->ul_tfcs.tfs_info[0].ntf;
               tf_count ++)
          {
            /* We need to subtract MAC hdr from TB size to get RLC PDU size. */
            if((config_ptr->ul_tfcs.tfs_info[0].tf_info[tf_count].tb_size - mac_hdr_size - rlc_size) > 0)
            {
              rlc_size =  (config_ptr->ul_tfcs.tfs_info[0].tf_info[tf_count].tb_size - mac_hdr_size);
            }
          }
        } /*If all the TFs are allowed*/
        
        /*This case will arise when explicit list of TFs is given*/
        else
        {
          /* We loop through all the TFs of the RACH channel to find the max TB size. */
          
          for(tfi_count =0; 
               tfi_count < config_ptr->mac_ul_parms.cctrch_ptr->rach_info.dlchan_info[dlch_count].rlc_size_info.ntfi_per_lc; 
                tfi_count++)
          {
            /* tf_idx is the TF index that is given in explicit list of TFs for RACH Channel */
            
            tf_idx = config_ptr->mac_ul_parms.cctrch_ptr->rach_info.dlchan_info[dlch_count].rlc_size_info.lc_tfi_list[tfi_count];
            
            if((config_ptr->ul_tfcs.tfs_info[0].tf_info[tf_idx].tb_size - mac_hdr_size - rlc_size) > 0)
            {
              rlc_size =  (config_ptr->ul_tfcs.tfs_info[0].tf_info[tf_idx].tb_size - mac_hdr_size);
            }
          } /* For all the TFIs that are given for the logical channel dlch_count */
        } /*If all the TFs are not allowed*/
      } /*If this TrCH has the same RB ID mapped to it*/
    }/* For all dedicated logical channels mapped to CCTrCH*/

  if(rlc_size == 0)
  {
    /*Check if CC has a valid RLC Size, if then use it in OC*/
    for(dlch_count = 0; dlch_count< UE_MAX_AM_ENTITY; dlch_count++)
    {
      if(current_config_ptr->am_config[dlch_count].common_config.rb_id == rb_id)
      {
        rlc_size = current_config_ptr->am_config[dlch_count].rlc_ul_am_config.ul_rlc_size;
        WRRC_MSG0_HIGH("Use valid RLC Size from CC");
        break;
      }
    }
  }
  
  WRRC_MSG1_HIGH("RRCHSRACH UL size %d .",rlc_size);
  return rlc_size;
  
  }
#endif


/*====================================================================
FUNCTION: rrcllc_is_hs_repointing_happening()

DESCRIPTION:
  This function returns if hs repointing is happening or not.
  
DEPENDENCIES:
  None.

RETURN VALUE:
  TRUE : HS-repointing is happening
  FALSE HS repointing is not happening 

SIDE EFFECTS:
====================================================================*/
boolean rrcllc_is_hs_repointing_happening(void)
{
  WRRC_MSG2_HIGH("ASU HS repointing happening %d to psc %d", hsdpa_msg_params.rl_link_present,hsdpa_msg_params.new_rl_link);
  return (hsdpa_msg_params.rl_link_present);
}
