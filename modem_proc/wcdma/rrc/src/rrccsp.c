/*===========================================================================
                        R R C    C S P
DESCRIPTION

   This file contains Cell Selection Procedure.
   It also implements part of the PLMN Search mechanism. The implemented
   blocks in PLMN Search Mechanism are marked with a "=======" boundary below.

              CSP PLMN SEARCH MECHANISM

       ===========   ------------    -------------    ---------
       |         |   | CSP      |    | Acq DB    |    | Acq   |
       |CSP      |   | Initial  |    | Access    |    | DB    |
       |State    |   | And .    |<-->| Functions |<-->|       |
       |Machine  |   | Stored   |    | -PLMN     |    |       |
       |Functions|<->|Selection |    | -Acq type |    |       |
       |         |   |Controller|    -------------    ---------
       |         |   |-PLMN     |
       |         |   |-PLMN     |    ------------
       ===========   | type     |<-->| CSP      |
            |        ------------    | Frequency|
            |           |            | Scan     |
            |           |            | Algorithm|
       ===========      |            ------------
       |Internal |   ------------
       |  Data   |   |Selection |
       |         |   |          |
       ===========   |Data      |
                     ------------

EXTERNALIZED FUNCTIONS

    rrc_cell_selection_procedure()
        This is the entry point for Cell Selection procedure. All
        events for CSP come to this function from RRC Dispatcher.

    rrc_init_cell_selection_procedure()
        Initialized any global data for the Cell Selection procedure.

INITIALIZATION AND SEQUENCING REQUIREMENTS
  None

Copyright (c) 2000-2009 Qualcomm Technologies, Inc.  All Rights Reserved.
QUALCOMM Proprietary.  Export of this technology or software is regulated
by the U.S. Government. Diversion contrary to U.S. law prohibited.

===========================================================================*/


/*===========================================================================

                        EDIT HISTORY FOR MODULE

  This section contains comments describing changes made to the module.
  Notice that changes are listed in reverse chronological order.

$PVCSPath:  L:/src/asw/MSM5200/RRC/vcs/rrccsp.c_v   1.47   19 Jul 2002 14:23:52   bumatt  $
$Header: //commercial/MPSS.JO.2.0.c1.4/Main/modem_proc/wcdma/rrc/src/rrccsp.c#1 $    $DateTime: 2016/12/13 08:00:12 $ $Author: mplcsds1 $

when       who     what, where, why
--------   ---     ---------------------------------------------------------
11/10/16   sr      FR 38167: Changes to correct WTOL RESELECTION START event 
07/05/16   sn      Changes for LTE U feature
06/24/16   sr      Made changes to not acquire lock for WTOG BPLMN in RRC
06/06/16   vs      Made changes to abort update sibs event when valid inter freq/ inter RAT redirection request is received
01/12/16   sn      Changes for FR30881
05/16/16   sg      Made changes to send cell transition failure when channel config for CU is in progress
04/05/16   sg     Made changes to fail reselection when Channel configuration for CUC is in progress
05/13/16   gv      Made changes to do PCS band opt when lock timer expires and full band scan is restarted
03/17/16   vs      Intoduced a new enum of l1_resel_fail_cause_enum_type type
02/25/16   vi      Made changes to pass the correct reason in transition request to wl1 when reselection is failed due to pending l2 ack
01/19/16   sas     Made changes to not skip sending DRX_REQ to L1 when CS domain for CSFB call is released as part of DCH to PCH recfg message.
10/16/15   as      Added code to support LTA durting activation time
09/22/15   sr      Changes to use the macros provided by WL1 for lock request
09/14/15   gv      Made changes to allow LTA for 1X LTA while waiting for l2 ack and dl srb
09/03/15   sas     Made changes to Trigger OOS after receiving act_rsp, if CSFB call status is reset while waiting for ACTIVATION_RSP from NAS.
07/22/15   bc      Changes to abort BPLMN on guard timer expiry when CSP is in wait SIB pending substate.
07/13/15   sas     Made changes to honor MPLMN srch req when abort for WtoX irat procedure is active.
07/01/15   sp      Made changes to save procedure substates for LTE commands and to skip logging frequent internal commands
05/14/15   bc      Changes to read SIBs across DRX for CGI scan.
06/19/15   sas     Do not request for lock if RRC is waiting for Stop Cnf from L1.
06/16/16   sn      Changes to re-try ACQ on same frequency upon receiving DL 
                   weak indication with no lock
05/25/15   sn      Changes to increase poking duration from 60ms to 80ms for other SUB page 
05/25/15   sas     Removed gaurd check that prevents PLMN search during CSFB call.
05/18/15   sas     Made changes to indicate RLC about the LTA/QTA start/stop status.
04/19/15   vi      Made changes to stop lock wait timer when APLMN is going on and QTA is trigerred and restart when QTA is over.
04/16/15   sas     Donot Trigger OOS when CSFB call abort status is received while configuring channels during LtoW HO.
04/07/15   sn      Send transition failure when cell reselection indication 
                   from wl1 is ignored during MT call establishment
04/01/15   sas     Release Lock and perform Request and notify, instead of extending the lock with wrong priority.
07/22/15   bc      Changes to handle DL WK indication in SIB pending substate for single SIM case.
03/30/15   sr      Changes to not send BPLMN_SLEEP_ABORT_IND when WL1 is awake
03/16/15   sn      Send idle request on receving DL WK indication with no lock
02/23/15   bc      Changes to not release the channels on receiving a new service request when UE is in OOSC.
02/17/15   bc      Changes to not abort the MPLMN search which is receivesd in the middle of resume for a long tuneaway gap.
02/12/15   sa      Made changes to support QTF with JO CRM
02/06/15   sn      Changes to allow LTA even after PS RABs are released but not before
                   they are established
01/21/14   sa      Made changes for QTF with CRM
02/02/15   sn      Changes to send QTA cancel indication if unlock by timer is ignored
01/30/14   bc      Changes to not to attempt BCH drop on receiving DL_WEAK_IND with no lock.
01/29/15   bc      Changes to crash the UE if there is no response to STATE_CHANGE_IND from LLC 
                   for more than 5 seconds.
01/29/15   sn      Changes to not perform manual BPLMN till UE gets out of
                   G2W TA mode
01/16/15   vi      Made changes for FR-23280
01/21/15   vi      Fixed compilation error
01/14/15   sas     Made changes to log events for cfsb call opt feature
01/12/15   sas     Changes made to reset prev_freq, prev_psc on receving RRC_BPLMN_SUSPEND_REQ.
01/13/15   sr      Made changes to not stop lock wait timer for GTOW redirection after lock acquisition for LFS
12/26/14   bc      Made changes to replace deprecated APIs with new ones.
12/29/14   vi      Made changes to not handle unlock by timer expiry when LLC is waiting for state change indication.
08/27/14   bc      Made changes to not to perform RAW/Fine scan twice if DRX timer expires
                   while performing RAW scan/Fine scan.
12/16/14   sr      Changes to not handle MPLMN in foreground when G2W TA and RCE proc is active
12/02/14   bc      Made changes to not to handle unlock immediate during GTOW redirection if RRC 
                   is waiting for activation indication from NAS.
12/10/14   bc      Changes to use access correct structures while processing a command.
10/31/14   bc      Changes to support additional requirements in FR 20971.
11/28/14   vi      Made changes to not to log GSM redirection events when there is no NW initiated redirection
11/27/14   sr      NV control for FR23776
11/24/14   sr      Changes to not allow preemption when BPLMN search timer expiry is pending and ACQ is in progress
11/24/14   sr      Made changes to ignore OOS with no lock if WRM is already in lock requested state
11/12/14   bc      Made changes to wait for ABORT Response from L/G RATs before stopping W stack.
11/18/14   sn      Changes to not start OOS procedure when one already in
                   progress if setup request fails with no lock
11/14/14   sr      Made changes to allow preemption when waiting for L2 ack or pending DL data
11/13/14   sp      Made changes to save procedure substates in crash debug info
11/12/14   gv      Made changes to check and update sxlte mode only when in DSDA with dual standby
10/16/14   bc      Changes to enable FR21174 and FR21035
11/06/14   vi      Made changes to avoid linker errors after disabling LTE
11/03/14   bc      Made changes to stop W during GTOW BPLMN search if enough time is not available to perform ACQ
                   in the current DRX cycle.
10/28/14   bc      Made changes to not to send acq request when enough time is not available 
                   in current DRX.
10/31/14   vi      Made changes to allow QTA during IDT for PS domain
10/31/14   vi      Made changes to allow QTA during RCR procedure.
10/27/14   gv      Changes to lower TRM priority on CSFB call end only if WCDMA is already holding the TRM lock
10/24/14   sn      Changes to update CCM with cell loss before converting 
                   manual BPLMN search to foreground in case of resume failure
10/22/14   gv      Made changes to have connected mode feature set independent of TA status 
10/17/14   sn      QTA during SIB read changes
10/17/14   sr      CSFB call optimization changes
10/14/14   bc      Changes to lower the priority of lock on receiving CSFB call end indication from NAS.
10/10/14   sr      Made changes to reset the scan type if transition to idle happens when LTA resume is in progress
08/27/14   bc      Made changes to convert Background PLMN search to foreground when Resume fails during WTOX BPLMN search.
10/09/14   gv      Made changes to send IRAT abort when stop mode comes with user rat change for pcs band opt
10/08/14   sn      Changes to process pending initiate cell selection indication
                   when CSP is waiting to release lock
10/06/14   gv      Made changes to follow same feature set in DSDA irrespective of number of active subs
10/06/14   sr      Made changes to not start ASF timer if CSG is not supported
10/01/14   sn      Changes to suspend BPLMN when DRX timer expires when waiting
                   for BCH release
09/24/14   bc      Made changes to ignore inter frequency resel request when RRC is waiting
                   for L2ACK for RBRC(FACH->PCH).
09/24/14   sr      Made changes to send a new command to abort WL1 sleep when PLMN LIST REQ is received
09/23/14   sn      Changes for WRRC FR 21174
09/12/14   bc      Made changes to buffer the Manual PLMN search request received during state transitions.
08/12/14   bc      Made changes to increase the lock request times for Fine scan and RAW scans for non G2W TA cases.
09/16/14   rmn     Resolved compilation errors in WRRC for LTE removal flavor
09/15/14   sn      Changes to fill squalmin and srxlevmin CSP globals for G2W reselection
09/04/14   gv      Added code to support split acq with bplmn
09/04/14   vi      Made changes to reduce curr_scan prints in the log
09/03/14   gv      Made changes to not handle preemption beyond sib reading for reselection
08/28/14   sn      Decrement available frequency index while handling immediate
                   preemption
08/25/14   sn      Changes to fill correct RAT for LTE cell reselection failure 
07/23/14   rmn     Made changes to indicate 5min barring in case GtoW Resel is rejected due to FPLMN or FLAI  
08/11/14   sn      Update CCM with cell loss for UNLOCK BY scan so that 
                   immediate preemption requests if any will be defered
08/11/14   rmn     Made changes to free rrc_svd_plmn_req_ptr when BPLMN search is aborted
08/06/14   bc      Made changes to abort SIB reading if MIB has not been read before DRX timer expiry
                   for Manual CSG searches.
08/08/14   rmn     Made changes to request lock on supported band indicated by NAS 
                   rather than deriving it from Japan PLMN and freq.
08/04/14   vi      Made changes to avoid compiler warnings
07/28/14   vi      Made changes to set bplmn_new search flag for URA_PCH -> FACH state transition.
07/24/14   vi      Made changes to fix KW errors.
07/23/14   sp      Made changes to remove F3s as part of FR19999
07/21/14   vi      Made changes to remove duplicate W2G redirection end events
07/18/14   sp      Made changes to buffer t305 expiry/sib change indication at rrccu when RRC mode is standby.
07/17/14   vi      Made changes to add WtoW and WtoG Redirection events
07/15/14   sg      Made changes to add initialization of local variables and bound conditions 
                   to access array to avoid warnings and invalid memory access. 
07/07/14   bc      Made changes to reduce the minimum time required to perform CGI to 450 msec.
07/14/14   rmn     Made changes to attempt trm_exchange for all XtoW IRAT scenarios 
07/11/14   vi      Made changes to convert earfcn type from uint16 to unti32
07/04/13   bc      Made changes to not to prematurely end xtow plmn search in DSDS mode.
06/30/14   vi      Made changes to get rid of wcdma_is_ue_in_dual_active for better clarity
06/27/14   sn      Changes to prioritize MT call over reselection
06/27/14   bc      Made changes to send unbar request to L1 when we receive empty flai list from MM.
06/26/14   sn      WRRC changes for FR20484
06/23/14   rmn     When calling new WRM lock request API, WRRC should indicate lock requested 
                   bands with type 'sys_band_class_e_type'
06/23/14   gv      Made changes to prevent CSP substate from getting reset if there is a pending 
                   MODE CHANGE after WCDMA stack is stopped
06/19/14   bc      Added new service request cause RRC_MO_CS_ECALL and its handling.
06/19/14   rmn     Made changes for DR-DSDS Feature
06/17/14   rmn     Made changes to indicate resel fail cause in CPHY_CELL_TRANSITION_REQ
06/17/14   sn      Abort inter-frequency reselection upon receiving PLMN search request
06/16/14   rmn     Made Changes to release lock and trigger CU when waiting for L2 ACK 
                   if preemption is received for CS Voice Call on other SUB
06/03/14   bc      Made changes to reset shld_acq_be_spltd flag to FALSE while sending ACQ irrespective
                   of csfb_call_status.
05/29/14   sr      Made changes to handle initiate cell sel ind in RRCCSP_WT_RR_ABORT_CNF
05/26/14   db      Made changes to include the correct diverstiy value when the optiona IE 
                   'Primary PCCPCH info'is omitted
26/05/14   bc      Made changes to send correct failure reason to GSM during GTOW reselection 
                   failure due to either PLMN mismatch or S-criteria failure.
02/03/14   sr      Fixed compilation errors
04/18/13   ad      Made changes to buffer the UL data indication 
                   if RRC is in standby mode and trigger it after resumption
05/23/14   sr      Made changes to ignore IRAT cell reselection when OC is set for DCH
05/21/14   sn      Changes to ignore immediate preemption when split acq in progress
05/20/14   rmn     Made changes to save DS Tuneaway Status Change indication in connected state based on the concurrency NV
05/20/14   rmn     Made changes so that WRRC does a forceful expiry of RRCTMR_DSIM_BPLMN_LOCK_REL_OFFSET_TIMER 
                   if running when unlock cancelled is received
05/20/14   rmn     Made changes to log start event for blind redirection to LTE.
05/20/14   sr      Made changes to not send STOP REQ to GSM when no GSM bands are supported
05/16/14   sn      Changes to ignore OOS due to no resource when leaving 
                   connected mode scan is in progress 
05/14/14   sr      Made changes to include WCDMA RAT if LTE FP entries are present
05/14/14   vi      Made changes to update CM with invalid cell id when UE camps back on same W cell after G2W handover
05/05/14   bc      Made changes to not to handle Pre-emption during leaving connected mode scan.
04/23/14   bc      Made changes to send cell info to LTE on receiving UE capability request
                   and also to send cell info WTOL PSHO request.
05/08/14   rmn     WRRC support for new search type SYS_SERVICE_SEARCH_PRIORITY_PLMN
05/07/14   sn      Changes to ignore immediate preemption when RRC is holding lock 
                   and CSP is in other than wait for ACQ and SIB substates 
05/06/14   geg     Use safer versions of memcpy() and memmove()
05/02/14   gv      Made changes to attempt IRAT activity only after clean up of pending BPLMN
05/02/14   sr      Made changes for ignoring/ delaying preemption if IHO/CCO in progress
04/30/14   sr      Made changes to abort IRAT activity when abort is received from NAS
04/25/14   vi      Made changes to handle LTE deprioritization request in W-RRC
04/11/14   vi      Made changes to disable FE_FACH capability in DSDS/DSDA mode.
04/10/14   db      Made changes to enable/disable feature support in DSDS/DSDA/TSTS modes through NV
04/09/14   vi      Made changes to store device mode in a global wcdma_device_mode
04/09/14   vi      Made changes to update network select mode to Manual for G2W TA to make use of BST
04/09/14   gv      Made changes to allow QTA even though PS RAB is not established
03/11/14   bc      Made changes to reduce XTOW overhead time.
04/07/14   sr      Made changes to allow manual PLMN during WRLF
04/02/14   vg      Made changes to Systematically log all the internal and external primitive handled in RRC and corresponding top level action.
04/01/14   sn      LTE to pass NAS requested CSG ID in resel/redir requests
03/28/14   sn      Changes to request for lock for DSDA only when TRM mode is SGLTE
03/27/14   sn      Update CCM with cell loss and also do not reset reselection data
                   for leaving connected mode scan in cell resel wait camp substate
03/26/14   gv      Made changes to now allow TA when PS RAB is not established
03/25/14   sr      Made changes to ignore OOS ind if WRM is in lock state
03/14/14   bc      Made changes to send partial plmn results to NAS during manual plmn search
11/05/13   rmn     Changes for displaying Partial PLMN Search Results during Manual Search
03/14/14   bc      Made changes for BST optimizations including LTE,
09/02/13   sr      Made changes for BST optimizations
03/24/14   sr      Made changes to pass PN position for GTOW reselection
03/21/14   sr      Modified a msg high to new format
03/17/14   sr      Made changes to not trigger PLMN LIST REQ when no FP entries are available
03/17/14   vi      Inroduced a global which will contain tsts_mode_enabled info.
03/17/14   vg      Added code to reject and send no_service for full service req if invalid SIM
03/17/14   sn      Changes to control ASF timer with a NV 
03/05/14   bc      Changes to have similar lock mechanism with or without WRLF feature during
                   connected mode oos.
03/11/14   bc      Made changes to ignore bplmn get_specific_sibs when bplmn is suspended
                   during Manual BPLMN search.
02/10/14   bc      Made changes to not to mess up curr_scan during BPLMN.
03/13/14   rmn     Made changes so that RRC should consider acceptable cells when network select mode is 
                   “LIMITED ROUTINE” in IRAT Reselection/Redirection
03/13/14   bc      Changes to have similar lock mechanism with or without WRLF feature during
08/13/13   sg      Made changes to include pccpch tx div ind in cell transition req
03/12/14   rmn     Made changes to ignore preemption from other SUB if there is a CS Call on W SUB
03/12/14   rmn     Made changes so that function rrc_is_s_criteria_met performs s-criteria
                   check during RRC_CSP_OUT_OF_SERVICE_AREA_SCAN
02/18/14   sr      Made changes to handle cell selection trigger in wait acq/freq scan confirm state
03/11/14   rmn     Split ACQ for LtoW Redirection
02/14/14   vi      Made changes to correctly type cast internal commands while saving rrc_cmd_type variables.
01/30/14   sn      WRRC changes for FR 15265
01/29/14   bc      Made changes to avoid the KW error 
01/29/14   sr      Made changes to update bplmn variables properly when RRC is wating for lock and
                   sleep request is receuved from L1
01/24/14   bc      Made changes to use deltaQrxlevmin while calling s-criteria API.
01/23/14   gv      Made changes to allow QTA even though PS RAB is not established
01/22/14   gv      Made changes to start leaving connected mode scan only after state change to 
                   disconnected is received while waiting to camp during reselection
01/20/14   bc      Made changes to not to wait for SB2 during CGI when SB2 is not a required SIB.
01/13/14   rmn     Made changes to provide current camped band info in 
                   CM_RRC_DCH_CELL_INFO_CNF & CM_RRC_CELL_INFO_IND
01/09/14   sp      Checked-in QCHAT related changes
01/03/14   rmn     Made changes to delay preemption if RRCTMR_DSIM_BPLMN_LOCK_REL_OFFSET_TIMER is running
01/03/14   bc      Made Changes to read SIBs across DRX cycles.
01/03/14   bc      Made changes to store the PN POS sent by L1 in ACQ CNF during WTOW BPLMN.
01/02/14   rmn     Reduction of unwanted F3's
12/18/13   sn      Delay premption processing in wait for resume substate
12/26/13   sr      Made changes to abort MPLMN/APLMN if G2W TA is started
11/07/13   bc      Made changes to abort sib reading if we find that the cell is barred 
                   or la is forbidden.
12/24/13   db      Introduced new NV to allow CPC,HSFACH,HSRACH,DC-HSDPA in DSDS and DSDA mode
12/24/13   sn      Made changes to process hard abort request when waiting for lock
                   to wake up wl1 from deep sleep during connected mode OOS
12/23/13   sn      Made changes to initialize cel resel SIB event when processing
                   immediate preemption request
12/12/13   bc      Made changes to not send no service when NAS sends service req on a different plmn than
                   WRLF PLMN
09/27/13   sn      Ignore CELL RESEL indication when CSP is waiting for wl1 to release lock 
12/13/13   sn      Manual PLMN search optimizations
12/13/13   sn      Changes to set UE OOS flag only if S-criteria passes
12/12/13   vi      Added code for FR: Service Search with scan scope ACQ DB only.
12/12/13   sr      Made changes to send cell transition cnf failure when CSP is in chan config cnf handler to avoid deadlock in L1
12/11/13   sn      Indicate to LTE if WCDMA to LTE reselection is a result of 
                   ASF or legacy ranking rules
11/28/13   sn      Disable split acq for BPLMN
11/27/13   sp      Made changes to add nv support and to save time ticks for 
                   rr to/from rrc mm to/from rrc and to add msg_type for crash debug ota changes
10/24/13   sn      Changes to abort UPDATE SIBs while processing preemption
11/19/13   rmn     WRRC will now abort W2G BPLMN foreground search if it is indicated as not complete by GRR 
                   and resume failure occurs at W. 
09/16/13   sn      G2W TA feature changes
11/19/13   as      Made changes to fix CSFB issues related to DSDS
09/12/13   sn      Changes to restart service search correctly if WRM timer expires when CSP
                   is waiting for lock to try acquisition on detected PSC
10/28/13   sn      Continue with manual PLMN search on W eventhough search on 
                   other RAT is incomplete
11/16/13   sr      WRRC support for LWG DSDS
11/07/13   bc      Made changes to skip acquisition on the cell which is barred during G2W redirection
11/13/13   sr      Made changes to not send CU for 320ms BPLMN abort when WCDMA resume fails
05/30/13   gv      Made changes to reduce the timer value for an unlock required event when TA cannot be handled
11/06/13   as      Changes to ignore Tuneaway if CS RABs are present
11/06/13   rmn     Changes to delay preemption when CPHY_RESUME is in progress.
11/01/13   vi      Removing FEMTO feature while calling wl1_check_cell_barred_and_get_bar_time due to compilation issue
10/30/13   sr      Made changes to post UPDATE_SIBS for DMCR after NEW_CELL_IND
10/29/13   gv      Made changes to lift away cell barring in case Equivalent PLMN list gets updated
10/18/13   gv      Made changes to reset the CSP scan type after successful XTOW reselection
10/07/13   rmn     Changes for Feature: RAT Search Order for FDD/TDD LTE
10/04/13   gv      Added code to support seamless resumption of background PS call when interrupted by
                   short calls on the other sub
10/03/13   gv      Added code to support seamless resumption of BPLMN when interuppted by
                   short calls on other sub
09/30/13   sn      Ignore service request received in wait camp substate during 
                   connected mode OOS
09/13/13   sn      Changes to include ECNO in CGI response to LTE
08/14/13   vg      Made changes to ignore CellUpdateConfirm messages during reselection in a corner case
08/13/13   gv      Added support for FEATURE_TRIPLE_SIM
08/13/13   gv      Made changes to reduce the lock request time
08/13/13   gv      Made changes to send the DSDA status indication to WL1
08/21/13   gv      Made changes to use the correctly fill the LTE band mask before triggering ASF
08/14/13   rmn     Made changes for requirement to indicate ACQ failure because of band mismatch
08/07/13   sn      Changes for selective band scan for PLMN searches
08/07/13   sn      Invalidate CSG ID of non member hybrid cell in ASF meas request
08/02/13   db      Made changes correctly update semi permanent and cctrch id database
                   when a NBCH setup fails
07/31/13   vi      Mainlining MODEM_STATISTICS feature.
07/18/13   gv      Changes to get acquistion failure reason from wl1 for IRAT resels
07/08/13   sn      Changes for LTE CSG feature
07/01/13   sn      Not to change network select mode to ANY PLMN after 30s 
                   timer expiry if non-RLF PLMN is found
06/28/13   gv      Made changes to update the trans id for the new BPLMN search
                   only after cleaning exisiting BPLMN search
06/27/13   gv      Made changes to buffer the MM and RR commands for crash debugging
06/21/13   sr      Made changes to abort MPLMN when OOS is received with cause no lock
06/19/13   sn      Changes to include CSG ID and RSCP in CGI response
06/06/13   sr      Changes to check for S criteria for XTOW reselection after SIB3 is read
05/30/13   gv      Made changes to perform acq db only scan when requested so by higher layers
05/29/13   sr      Made changes to not free dynamic pointers when state change indication is received and MCM state is RRCMCM_WAIT_START_CNF
05/14/13   sr      Hybrid CSG changes
05/16/13   rmn     Made Changes to reset pending_type
05/14/13   gv      Made changes to delay immediate preemption when waiting for resume/chan config confirm
05/13/13   vi      Fixed compiler and KW errors for Bolt
05/08/13   sn      Start ASF timer when n/w sel mode changed from 
                   limited to manual/auto i.e ANY PLMN to Spec PLMN
04/25/13   vi      Made changes to add TTL markers to WCDMA_RRC
04/24/13   sn      WRRC side of changes to meet CSG ADAPT TCs
04/18/13   vg      made changes in RRC to release the lock on urgent access preepmption req
                   from other SUB while waiting for SRB data.
04/18/13   sr      Made changes to give priority for handling INITIATE_CELL_SELECTION rather than SERVICE_REQ/PLMN_LIST_REQ during WRLF
04/04/13   sn      Changes to restart ASF timer when PLMN search in progress and also when UE in 
                   connected mode
04/03/13   sr      Made changes to send RRC_ABORT_IND before sending SERVICE_IND 
                   when RRC goes OOS because of lock unavailability
04/02/13   gv      Made changes to abort SIB reading if atleast one cell is found in a DRX
                   during ASF search
03/27/13   sr      Made changes to correct a MSG_HIGH
03/26/13   db      Changes for unification of Cell Transition and CPHY setup handling.
03/25/13   gv      Made changes to stop GTOW redirection when the redirected cell belongs to forbidden LA
03/14/13   sn      Ignore inter frequeny/inter RAT reselections in PCH states when CU in progress
03/08/13   sr      Added changes to introduce events for CSFB redirection with SI container
03/05/13   sn      Initialize CSG ID to invalid value for CN info received from network/HO scenarios
03/04/13   gv      Made changes to handle initiate cell selection to move to disconnected state
                   in missing CSP substates
02/28/13   sn      New log packet for CSG finger printing information
02/27/13   sn      Update CCM with cell loss while processing IRAT abort indication 
02/15/13   gv      Made changes to check if QTA is allowed before resetting the current scan
02/12/13   sr      Made changes to fix the merging error for CR418778
02/04/13   vg      introduced a new api for L1 which will return a oos
                   timer based on RRC state. 
02/04/13   ad      Changes to add back the error fatal removed during f3 reduction
                   in rrccsp_cell_sel_wait_freq_scan_cnf_recvd function
01/31/13   sn      Changes for BPLMN suspend/resume for WTOW searches
01/25/13   gv      Made changes to not restart frequency scan for BPLMN after moving back
                   to Idle/PCH from connected mode while BPLMN is in progress on W
01/22/13   sn      Restart ASF timer with smaller value when it gets aborted or WRRC not in a position to handle
01/21/13   sn      Update CCM with cell loss before sending no service to MM in wait state change handler
01/19/13   sn      Changes to log BPLMN start event with service search type correctly
01/09/13   sr      Made changes to handle BPLMN scan variables properly during GTOW BPLMN lock timer expiry 
01/03/13   ad      Made changes to reduce the redundant F3s
01/03/13   sn      Removed redundant code to process BPLMN search timer expiry
12/18/12   sr      Made changes to include IE "csfbIndicator" in connection request for CSFB call 
                   and also ASN related changes
12/13/12   gv      Added code to restrict the LTOW redirection search time for a CSFB call
12/12/12   sn      Start wait lock timer before resuming PLMN search on W
12/12/12   mp      Fixing KW errors
12/10/12   sn      Changes to ignore ASF timer expiry indication when current camped
                   PLMN is not same as/EPLMN of CSG whitelist PLMNs
12/07/12   sn      Changes to fix random corruption with CSG feature
12/07/12   sn      Changes to indicate absence of FP info in ASF srch resp
12/07/12   sn      PN POS across DRX cycles is not getting saved properly.Fixed this
12/07/12   sn      CSG feature changes
12/03/12   gv      Made changes to reset aset_scr_code while handling OOS to prevent RRC from doing ASET scan
11/29/12   gv      Made changes to not indicate an invalid cell id to CM after entering DCH on the same cell
11/27/12   gv      Fixed compiler warnings when DSDS is enabled
11/26/12   sn      Changes to defer processing RRC_MODE_CHANGE_REQ when wtog abort in progress
11/09/12   gv      Made changes to not scan WCDMA bands when RAT priority list does not contain WCDMA
11/08/12   sr      Made changes to handle INITIATE_CELL_SEL_IND in SIB_WAIT_PENDING handler
11/07/12   sr      Added code changes to not trigger CU upon WCDMA mode resume when another BPLMN is buffered 
                   for 320 ms BPLMN feature
11/06/12   sr      Added code changes to remember BPLMN suspend request and send confirm when 
                   CSP is in ACQ CNF or FREQ_SCAN_CNF state and BPLMN abort is already pending
10/30/12   gv      Added code to support suspend and resume of BPLMN searches from LTE to WCDMA
10/29/12   gv      Mainline the changes under FEATURE_PPAC
10/26/12   gv      Corrected the changes under FEATURE_WCDMA_DIME_SW
10/18/12   gv      Made changes to start the redirection extension timer for an LTOW redirection only once
10/18/12   gv      Replace FEATURE_DUAL_SIM_WCDMA_TUNEAWAY with FEATURE_DUAL_SIM
10/14/12   gv      Added code to support exchange of AS ID between WRRC and GRR commands
09/21/12   sa      Made changes to indicate WL1 with proper status of wtog bplmn progress when it calls
                   rrc_can_l1_go_to_sleep()
09/24/12   ad      Corrected featurization related to FEATURE_LTE_TO_WCDMA
09/21/12   gv      Made changes to start 1s timer for fast redirection from WtoL before which ACQ is supposed to be successful.
                   If ACQ is successful before expiry of timer, it is restarted with a value of 5s for SIB reading
09/20/12   sr      Made changes to update serving cell information to CM upon receiving RRC_ACTIVATION_RSP 
                   during interrat reselection
09/14/12   sa      Fixed compilation errors
09/13/12   gv      Added support to send deact request to TDSCDMA while WCDMA is deactivated to facilitate 
                   writing of ACQ DB NV
09/12/12   gv      Made changes to reset the CSP scan type following a W2L or W2G 
                   reselection/redirection failure
09/10/12   gv      Mainline the changes under feature FEATURE_WCDMA_BPLMN_SUSPEND_RESUME
09/04/12   sks     Made changes to update CCM with cell loss when handling buffered initiate_cell_sel after
                   getting suspend_cnf from L1 for interrat redirection via RRC connection release.
09/03/12   gv      Added few comments
08/31/12   rd      Transfer dedicated priority parameters to/from WCDMA and GERAN
                   during IRAT procedure
08/31/12   gv      Mainline the changes under feature FEATURE_WCDMA_ALLOW_ECAL_AC_BARRED_CELL
08/28/12   sr      Made changes to update cell id in cell_id_dch_info after WTOL reselection failure
08/24/12   gv      Added code to request for lock when GTOW redirection request is received08/17/12   gv      Made changes to not clean BPLMN when a BPLMN_SUSPEND_REQ is received with W resumption
08/21/12   gv      Fixed compiler warning
08/17/12   gv      Made changes to not clean BPLMN when a BPLMN_SUSPEND_REQ is received with W resumption
                   already in progress after WTOG Manual BPLMN search
08/17/12   gv      Added changes to support suspension of intra/inter-W BPLMN search on entering DCH/FACH
                   and resumption of the same on entering PCH/IDLE
07/18/12   sn      Changes to ignore freq redir wait timer when we are in final stages 
                   of camping on redirected frequency
08/13/12   gv      Made changes to abort and restart the BPLMN search when suspended by CU procedure 
                   in all CSP substates with FEATURE_WCDMA_BPLMN_SUSPEND_RESUME undefined
08/13/12   gv      Made changes to abort and restart BPLMN search when suspended by CU in CSP substate RRCCSP_WT_RESPONSE_FROM_RR
08/13/12   gv      Corrected merging issue introduced with CR357817
08/13/12   gv      Made changes to stop restarting of the guard timer while restarting BPLMN 
                   for a higher layer establishment request in CSP substate RRCCSP_CELL_SEL_WT_ACQ
08/13/12   sr      Made changes to handle BPLMN_SUSPEND_REQ posted by MISC to CSP when T319 expires in PCH state
08/06/12   gv      Made changes to check for DSAC presence also in connected mode with FEATURE_PPAC enabled
08/06/12   gv      Added support to maintain W timing while performing L2W Cell reselection
07/24/12   geg     Upmerge WCDMA.MPSS.1.0 to WCDMA.MPSS.2.0
07/05/12   sks     Made changes to reset the unlock_by scan before we start the next tuneaway.
06/11/12   sn      Correctly updating RRC CSP substate after processing state change indication 
                   in RRC CSP substate RRCCSP_CELL_SEL_WT_STATE_CHANGE_PENDING
06/06/12   rv     Added support for QTA.
05/18/12   sks     Made changes to reset flag fach_tx_dest_state whenever UE camps on a cell.
05/10/12   gv      Made changes to add detected PLMN to the available list during manual scan
                   without checking for band type detection if both IMT2K and AWS bands are enabled
05/10/12   sks     Made changes to bar other RAT freq with flag non_eplmn so that these cells
                   can be un-barred on EPLMN list change.
05/04/12   gv      Made changes to check if SIB5bis is scheduled during manual bplmn search
                   and add PLMN to the list accordingly in wait for SIB pending handler
05/01/12   sks     Added changes to indicate NAS that NO SERVICE is because of no
                   resource from TRM.
05/01/12   sks     Changes were made to start a delay timer if pre-emption cannot be handled, and handle it
                   once the timer expires.
05/01/12   sks     Changes were made to not perform tuneaway when immediate pre-emption handling 
                   is in progress.
04/25/12   gv      Merged code to handle ACQ_CNF failure because of L1 not getting lock.
04/21/12   gv      Made changes to look for a cell which supports emergency call when the 
                   current cell's DSAC info does not support emergency call
04/10/12   sks     Made changes for RRC to not send START_QTA_REQ to L1 if RRC got the chance to process
                   RRC_DUAL_SIM_WRM_UNLOCK_BY_TIMER_EXP_IND after GSM already requested for UNLOCK_BY for the next page.
04/10/12   gv      Made changes to never restart the guard timer during BPLMN search
04/09/12   gv      Added code to prevent CPU hogging during G2W redirection
04/03/12   sks     For XTOW BPLMN and CGI_REQ, made changes to optimize the retry ACQ duration in the next DRX
                   by saving PSC and PN_POS.
03/30/12   gv      Added handling of RRC_INITIATE_CELL_SELECTION_IND in 
                   RRCCSP_SUIT_CELL_SEL_WT_CAMP_PENDING substate
03/19/12   sks     Made changes to update UI with limited service during WRLF search.
03/19/12   sn      Changes to ignore few commands in CSP substate RRCCSP_WT_STOP_MODE_CHANGE_CNF
03/13/12   sn      To send the Invalid cell id to CM when cell is changed in DCH state
03/12/12   gv      Fixed KW issue
03/09/12   sn      Changes to abort SIB event if active when RRC receives preemption indication
02/09/12   sn      Changes to send partial CGI info if MIB,SIB3 is read but not SIB1  
02/07/12   gv      Merged code to handle RRC_LTE_RESELECTION_ALLOWED_STATUS_IND only in disconnected state.
02/06/12   gv      Made changes to reset the ctch_setup_req_pending flag based on the next CSP substate
                   while waiting for chan config confirm
01/12/12   gv      Added code to support FEATURE_PPAC
12/20/11   gv      Merged changes to update the available PLMN list with HPLMN, for GTOW and WTOW Automatic BPLMN
                   search with bgnd service search as Manual, when DRX timer expires during SIB reading
12/16/11   gv      Fixed compilation issue
12/12/11   mn      Made changes to process ps hard abort request received when waiting for lock
12/12/11   gv      Added code to support free floating of tasks
12/05/11   pm      Added code to support cell id request by CM in DCH state"
11/30/11   sn      Created a new update_sibs cause to handle update_sib event 
                   posted by csp when csfb call is cancelled. 
11/23/11   gv      Added code to convert detected GSM cells to UARFCN in Band III (DCS)
11/18/11   mn      Made changes to disable reselection to LTE after attach reject from network
                   with cause 14.
11/16/11   vg      added code to send limited srv ind to UI if s criteria met
10/31/11   sks     Added support for FEATURE_WCDMA_FAST_RETURN_TO_LTE_AFTER_CSFB.
09/30/11   as      Made changes to allow tuneaway when PS RAB is not present
09/12/11   gv      Renamed feature flag FEATURE_WCDMA_RRC_EMERG_CALL_SUPPORT
                   to FEATURE_WCDMA_ALLOW_ECAL_AC_BARRED_CELL
09/12/11   gv      Made changes to try for finding a cell which supports emergency call
                   when an emergency call is initiated and if the current cell 
                   does not support emergency call under feature FEATURE_WCDMA_RRC_EMERG_CALL_SUPPORT
09/09/11   rl      Fixed KW errors
09/05/11   gv      Fixed KW errors
08/30/11   rl      Merged with VU_MODEM_WCDMA_RRC.01.105.00
08/24/11   mn      Made changes to start 1s timer in case of DSDS if W can't release the lock at that time
                   and unlock type is UNLOCK_REQUIRED. After timer expiry check for the status once again
08/23/11   sks     Added interrat abort guard timer of 2sec.
08/23/11   gv      Reverted change to include pre-redirection Info IE during data call 
                   (re)establishment after L2W redirection with ISR on
08/22/11   gv      Added handling of RRC_DEACT_REQ with a new cause to update NV with ACQ DB
08/18/11   gv      Fixed compilation issue when FEATURE_MODEM_STATISTICS is enabled
08/10/11   su      Added code to not invalidate the SIBDB entry 
                   when we read the SIBs through OTA during CSFB. 
08/05/11   gv      Made changes to reset LFS variable before starting LTOW redirection scan
08/05/11   gv      Made changes to update the interrrat type to GSM when W sends
                   reselection/redirection request to GSM
08/02/11   rl      Merged with VU_MODEM_WCDMA_RRC.01.103.00
07/19/11   vg      added code for not to send redirection req to RR for emergency service camping
                   if manula mode is set.
08/02/11   gv      Made changes to prevent L1 API call for psc and pn pos in aset while 
                   leaving connected mode
07/27/11   gv      Added code to include pre-redirection Info IE during data call 
                   (re)establishment after L2W redirection with ISR on
07/08/11   sks     Made changes to init first band to be scanned for interrat redirections.
07/06/11   gv      Fixed KW errors
06/30/11   gv      Increased the RRC Overhead time for WL1 start and stop to 90ms while 
                   handling the CGI request from LTE
06/21/11   rl      Merged with VU_MODEM_WCDMA_RRC.01.100.50
06/08/11   as      Made changes to ignore tuneaway if EFACH or CPC call is active
06/17/11   gv      Made changes to suspend BPLMN search when a call is initiated. And also
                   to handle PLMN_LIST_REQ during a call under the feature
                   FEATURE_WCDMA_CONTINUE_MPLMN
06/01/11   sks     Made changes to handle LTE detected cell info in GTOW PLMN list search request.
05/30/11   gv      Made changes to send CPHY_ACQ_REQ only when IRAT CGI timer value is 
                   greater than 500ms. Also increased the ACQ and SIB reading time by 300ms
05/25/11   gv      Added code to fill the shared PLMNs in CGI report sent to LTE
05/24/11   rl      Merged with VU_MODEM_WCDMA_RRC.01.98.50
05/17/11   gv      Made changes to clear the LTE PLMNs from the last PLMN list scan 
                   if we are not searching for LTE afresh in the current scan
05/19/11   rl      Fixed the compilation error
05/10/11   rl      Merged with VU_MODEM_WCDMA_RRC.01.97.50
04/28/11   sks     For initiate cell selection during IRAT, made changes to send abort req after
                   checking the correct scan type.
05/06/11   sks     Made changes to use the band_mask provided in LTOW PLMN list search
                   request for searching on W.
05/03/11   su      Added code changes to provide NV support to enable/disable
	           FEATURE_3GPP_CSFB_SKIP_OPT_WCDMA_SIBS.
05/03/11   rl      Fixed the lint error
04/26/11   rl      Merged with VU_MODEM_WCDMA_RRC.01.96.50
04/20/11   vg      added support for mdsp halt recovery
04/07/11   rl      Merged with VU_MODEM_WCDMA_RRC.01.94.52
04/06/11   sks     Made changes to derive band info for UARFCN to freq conv instead of using curr_band.
04/01/11   su      Added code to trigger OOS for DL_WK_IND in update_sibs
04/01/11   su      Added code to process DL_WK_IND for update_sib_event
03/31/11   sks     Made changes to least send the serving cell info as detected cell for WTOL BPLMN search,
                   if there has been no W search.
03/29/11   rl      Merged with VU_MODEM_WCDMA_RRC.01.94.50
03/28/11   sks     Made changes to return TRUE for can_L1_go_to_sleep(), if CTCH setup is
                   pending at LLC.
03/21/11   vg      Added code for fast redirection based on interface change
03/21/11   rl      Added code to support L2W CGI 
03/21/11   sks     Made changes to parse rat priority list from GSM-RR after GTOW procedures.
03/17/03   sks     Made use of global to start timer RRCTMR_LTE_TO_WCDMA_REDIR_SRCH_TIMER.
03/14/11   rl      Merged with VU_MODEM_WCDMA_RRC.01.93.50
03/10/11   sks     Made changes to not include pre-redir info in RRC connection request
                   msg following a LTOW redirection.
03/10/11   sks     Made changes to implement 5s guard timer for LTOW redirection.
03/04/11   sks     Fixed compilation warnings.
03/03/11   vg      added code to start 150 sec bplmn gaurd timer if lte is enable
03/02/11   vg      added code to start bplmn guard timer for 3min if UE is
                   dual sim standby enabled.
03/02/11   rl      Merged with VU_MODEM_WCDMA_RRC.01.92.50
02/25/11   sk      Changed the memcpy of saved cmd to the processed cmd to only the 
                   actual structure.
02/24/11   kp      Added code to store & precess RLC reset during tuneaway
02/24/11   rl      Fixed the KW warning
02/18/11   as      Made changes to ingore preemption in unhandled csp sub states
02/28/11   rl      Merged with VU_MODEM_WCDMA_RRC.01.91.51
02/17/11   sk      Temporary work around to unblock BPLMN with LTE
02/07/11   rl      Merged with VU_MODEM_WCDMA_RRC.01.90.50
01/27/11   rm      Added code to support BC19 under FEATURE_WCDMA_BC19
01/27/11   rm      Added code to support WCDMA to LTE events
01/27/11   rm      Made changes to check for S-criteria before stopping EOOS search timer
26/01/11   as      Made changes to call right cco function for tuneaway
01/28/11   rl      Merged with VU_MODEM_WCDMA_RRC.01.89.57
01/18/11   sks     Made changes to not start the 100ms guard timer for GSM-RR to process interrat ABORT request.
01/12/11   ad      Added changes for RRC SW decoupling
01/11/11   sks     Made changes to check correct dest freq flag  for rejecting LTOW redirection.
01/04/11   rl      Merged with VU_MODEM_WCDMA_RRC.01.87.50
12/20/10   sks     Made changes to perform acq retries on LTOW redirected freq.
12/13/10   rm      Made changes to skip reading optional SIBs during LTOW CSFB rediretion
12/06/10   sks     Made changes to restart BPLMN guard timer whenever manual BPLMN
                   search is suspended because of registration.
12/31/10   rl      Merged with VU_MODEM_WCDMA_RRC.01.86.50
12/06/10   su      Changes to update qchat on location after change in PLMN-id or cell-id.
11/29/10   rl      Merged with VU_MODEM_WCDMA_RRC.01.85.50
11/15/10   as      Added code to not allow DS tuneaway in Loob back mode
11/09/10   rl      Merged with VU_MODEM_WCDMA_RRC.01.84.50
11/02/10   rm      Added code to handle CSFB status indication
11/02/10   rm      Corrected the validation of LTOW IRAT PLMN search req
11/01/10   rm      Corrected merge error
10/29/10   as      Added changes to handle unlock-required
10/28/10   as      Added changes to check for DL ACK for Tuneaway
10/27/10   as      Added changes to save DL SDU during Tuneaway
10/26/10   as      Fixed lint issues
10/14/10   as      Removed changes for enabling Tuneaway using NV item
10/14/10   as      Fixed null pointer access issue for FEATURE_DUAL_SIM
10/11/10   rm      Added code to support 3GPP CSFB
10/08/10   as      Added changes to Enable/Disbale DS Tuneaway using NV Item
09/27/10   rm      Added missing break in switch case
09/27/10   sks     Made changes to update CCM with cell loss when starting interrat redirection via 
                   RRC connection release msg.
09/24/10   as      Added code to release lock for Immediate Preemption Ind 
                   in FACH/DCH under FEATURE_DUAL_SIM
09/23/10   as      Added code to not handle Tuneaway when CS domain is open and
                   to retain lock after extend under FEATURE_DUAL_SIM
09/23/10   kp      Added code to maintain status of Chan_config_req posted by CSP for sib5 change,
                   the status life time will be from where CSP post the cmd till LLC starts processing
09/22/10   as      Fixed issue during mode change pening hdlr under FEATURE_DUAL_SIM
09/14/10   sks     WRLF: For T314 timer expiry during initial acq-db search, made changes
                   to not send suitable_search_end_ind to NAS.
09/14/10   sks     WRLF: Made changes to call the NAS API for checking for ePLMNs during
                   LIMITED (MANUAL) seaches when following WRLF search.
11/03/10   rl      Fixed compiler warnings
10/30/10   rl      Objective systems migration changes check in 
                   on code base VU_MODEM_WCDMA_RRC.01.80.00
09/13/10   as      Added code to support FEATURE_DUAL_SIM
09/09/10   rm      Made changes to hold dedicated priorities during OOS
08/30/10   rm      Made changes to send IRAT resel request to correct RAT
08/20/10   rm      Fixed compiler warnings
08/16/10   rm      Send failure cause as cell/freq barred in LTOW failure response 
                   with remaining bar time if the cell/freq is barred at WL1
08/10/10   rm      Added code to support time to reselect in WTOL reselection failure
07/23/10   rm      Fixed compiler error when FEATURE_DUAL_SIM_BPLMN is not defined
07/17/10   rm      Corrected Debug F3
07/16/10   rm      Added  code to send PARM_REQ to WL1 when SIB11/SIB12 changes
07/14/10   su      Fixed Lint errors.
07/09/10   rm      Added code to populate LTE band_pref in LTE IRAT PLMN SRCH REQ
07/08/10   rm      Added code to send default SSB as SYS_SERVICE_SEARCH_NONE to LTE RRC in
                   IRAT BPLMN request
07/06/10   rm      Added code to put WL1 to sleep if BPLMN is suspended/cleaned up when
                   lock release offset timer is running
07/05/10   rm      Fixed compiler warnings
07/02/10   sks     Added code to support FEATURE_WRLF_SYSTEM_SEL for connected mode OOS.
06/29/10   rm      Added code to support LTE<->WCDMA Inter RAT
06/29/10   as      Removed feature flag WCDMA_UNIT_TEST for rrc stub code
06/25/10   rm      Added code to support DUAL SIM BPLMN
06/18/10   as      Fixed compiler warnings
06/14/10   rm      Added code to update UI with limited service and to indicate OOSC end to CM
                   during ANY PLMN OOSC search
06/07/10   rm      Added code to let WL1 go to sleep when processing of CTCH drop request from CSP
                   is not complete at LLC
06/07/10   as      Added code for EOOS under feature flag FEATURE_EOOS
05/27/10   as      Made changes to check DSAC in connected mode
05/24/10   sks     Made changes to support R7 spec CR related to HPLMN-VPLMN ping-pong.
05/24/10   rm      Added code to report OOSC end to CM on reception of MODE_CHANGE_REQ,
                   when leaving connected mode after OOSC is in progress
05/24/10   as      Made changes to index SIBDB with common PLMN ID for shared cell
05/18/10   sks     Made changes to not handle out_of_service_ind with cause as no resource from L1,
                   if out of service search in connected mode is already in progress.
05/13/10   sks     Fixed klockwork errors.
05/11/10   rm      Fixed compiler warnings when FEATURE_MODEM_STATISTICS is defined
05/06/10   rm      Fixed compiler warnings
05/05/10   sks     Made changes to release channels only after L1 is moved out of PCH_BPLMN state.
04/30/10   sks     Made changes to go to INACTIVE state, if resume fails in disconnected state with
                   cause as WL1_FAILED_NO_WRM_LOCK.
04/12/10   rm      Added code to support BC11
03/29/10   sks     Fixed lint errors.
03/29/10   sks     Made changes to initialize do_lfs_scan flag when starting search for
                   RRC_PLMN_LIST_REQ.
03/25/10   rm      On Resume failure due to No resource for BPLMN, added code to stop WCDMA
                   and send NO_SERVICE to NAS
03/15/10   rm      Added code to support FEATURE_RAT_PRIORITY_LIST for W<->G IRAT
03/12/10   rm      Added code to support FEATURE_DUAL_SIM
02/01/10   dm      Made changes for handling RRC_BPLMN_SUSPEND_REQ sent by RRC_PROCEDURE_MISC.
03/11/10   ss      Made changes to append HFN while sending RRC_MODE_CHANGE_CNF to NAS.
02/15/10   sks     Made changes to allow calls even when access control is enabled in
                   connected mode.
02/10/10   as      Added feature falg WCDMA_UNIT_TEST for rrc stub code
01/15/10   sks     Made changes to not reset CSP substate to no cell selected, when
                   WTOG service search redirection succeeds.
12/07/09   ss      Changes to add Stub code under feature flag TEST_FRAMEWORK
11/30/09   sks     Added the handling of RR_INTERRAT_REDIRECT_ABORT_CNF when RRC is waiting to
                   handle stop request from NAS.
11/13/09   sks     Made changes to not populate the GSM cell list for redirection search with
                   invalid redirection info.
11/05/09   sks     Fixed compilation error.
11/04/09   sks     Added code to support inter-RAT redirection via connection reject
                   and both inter-RAT and inter-freq redirection via connection release.
11/04/09   sk      Removed EF for valid scenarios of W2G when RR sends ACT IND to NAS.
11/03/09   sks     Added code to inform GSM of mode change to LPM.
11/02/09   sks     Added code to suspend handling of STOP_MODE_REQ, until current 
                   WTOG process is aborted.
11/02/09   rm      Added support for FEATURE_MODEM_STATISTICS
10/07/09   gkg     Changes for REL8 under FEATURE_WCDMA_REL8
10/05/09   rm      Modified rrc_check_wcdma_in_oos to return TRUE when start WCDMA /Resume WCDMA 
                   is in progress,when foreground PLMN search is in progess
09/11/09   ps      Made changes for reducing the internal RRC command size 
                   under FEATURE_RRC_REDUCE_CMD_SIZE
09/22/09   rm      Added code to clear L1 barring info and write ACQ DB to NV on
                   MODE_CHANGE_REQ to LPM 
08/03/09   sks     Added code to get G acq channel info after completing OOS search on G, and resetting
                   W and G acq channel info for a MODE_CHANGE_REQ from NAS.
08/03/09   sks     Removed code to not continue picking next freq for scanning or performing acquisition
                   during Manual BPLMN scan, when handling SIB_CNF in pending substate for DRX search 
                   timer expiry.
07/20/09   rm      On cell change failue during reselection in connecting state, added code to
                   initizlise RCE without RCE initiating another cell selection
07/20/09   sks     Made changes to update UI correctly with service status when leaving 
                   connected mode after being out of service. 
07/20/09   rm      Added code to not call sys_eplmn_list_equivalent_plmn when n/w sel mode is
                   LIMITED
07/02/09   rm      When BPLMN is aborted, added code to setup CTCH only when CSP is in camped states.
07/01/09   sks     Made changes to suppress lint error.
07/01/09   rm      Added code to correctly populate service_search_bgnd in LIST_CNF to NAS
                   Also added code to correctly update bplmn_band_pref from LIST_REQ
06/18/09   rm      Added code to abort Automatic BPLMN search on RRC_BPLMN_SUSPEND_REQ from CU
06/17/09   rm      Made changes to not send a CTCH drop/ADD if CTCH is not
                   supported in the cell
06/15/09   sks     Made changes to support messaging interface with RR for writing 
                   ACQ-DB to NV during power off.
06/05/09   sks     Made changes reset oosc_plmn_found everytime UE completes W+G search in
                   connected mode during conventional OOS search.
06/03/09   rm      Added code to track the window from the moment CSP posts transition req to LLC
                   to the moment LLC receivies transition CNF from L1, so that resel indcations from
                   L1 are ignored during this window
05/26/09   rm      Added code to reset bplmn_crit_sec_flag after processing the PLMN LIST req
05/22/09   rm      Added code to drop CTCH on BPLMN start and setup CTCH on BPLMN Stop/Abort
05/19/09   rm      Fixed Lint errors
05/15/09   rm      Added support to provide Freq info along with Cell id to CM
05/14/09   sks     Added code to handle RRC_NW_SEL_MODE_RESET_IND for Manual->Automatic
                   and Automatic->Manual. Also made changes to restore nw sel mode and CSP 
                   substate if they were modified internally during connected mode OOS.
05/13/09   rm      Added an API for GPS to check if W search is in progress.
05/11/09   rm      Made changes to send cell capability info whenever RRC sends 
                   a MM cmd.
05/11/09   rm      Added code to buffer the CEL RESEL IND from L1 when CSP is waiting for 
                   TRANSITION_CNF from LLC whereas LLC received TRANSITION_CNF from L1, and
                   process the buffered CEL RESEL IND on TRANSITION_CNF from LLC
05/10/09   kp      Added support for demand paging RRC code using pragma.
05/08/09   ss      Updated Copyright Information
05/07/09   rm      Added code to Abort W-Search and send SERVICE_CNF with NO_SERVICE to NAS when 
                   Rove-in request is received
05/06/09   rm      Made changes to update UI with limited service when srv is available on non-FPLMN GSM cell
                   while SPLMN search timer running
04/29/09   ss      Made changes to compiler warnings on gcc compilers.
05/01/09   rm      On BPLMN/WTOW search timer expiry, if Addl chnl scan is in progress and 
                   FEATURE_RRC_ADDL_CHNL_SCAN_OPTIMIZATION is defined, Made changes to set type_freq_scan
                   to NO_SCAN so that Addl chnl scan will be resumed on next BPLMN search cycle
04/27/09   sks     Added code to check for PLMNs available in detected cells for Manual
                   PLMN list scans.
04/27/09   rm      On BPLMN srch timer expiry, made changes to wait for GET_SPECIFIC_SIBS_CNF
                   if curr acq freq is present in available frequency list and the SIB_REQ is
                   not for detected cells.
03/28/09   rm      CMI FEATURISATION
03/25/09   rm      On BPLMN srch timer expiry, Made changes to wait for GET_SPECIFIC_SIBS_CNF
                   if curr acq freq is present in available frequency list
03/24/09   rm      Fixed Lint Errors, compiler warings when FEATURE_WTOG_BACKGROUND_PLMN_SEARCH
                   is undefined
03/23/09   rm      Made changes to reset hsdpa_hsupa_ind on sending RRC_MODE_CHANGE_CNF to MM
03/20/09   rm      Made changes to reset num_tries_on_dest_freq to zero on successful ACQ
03/17/09   rm      Made changes to ignore RRC_EQ_PLMN_LIST_CHANGE_IND when 
                   FEATURE SUPPORT FOR PARTIAL ROAMING is not defined
03/16/09   rm      Made changes to set dual_mode in LIST_REQ to FALSE when 
                   FEATURE_WTOG_BACKGROUND_PLMN_SEARCH is not defined
02/25/09   rm      Added code to send RRC_RESELECT_TO_GAN_REJ when reselection to GAN
                   is in progress and NAS sends STOP_WCDMA_MODE_REQ.
02/25/09   rm      Made changes to send correct signal_strengths in RRC_INTERRAT_PLMN_SRCH_CNF
02/04/09   sk      Set uoosc_tx_to_discon on transition to diconnected from OOS scan
02/02/09   rm      Ported List Frequency Scan (LFS) to conventional OOS
02/02/09   rm      Fixed Lint errors
02/02/09   rm      Made changes to ignore RRC_EQ_PLMN_LIST_CHANGE_IND when OOS search
                   is in progress, when RRC mode is STANDBY
01/19/08   ps      Made changes for ASn1 migration 25.331v7.9  
                   i.e.May 2008 version  (2008-05) 
01/19/09   dm      Made changes to support code when feature 
                   FEATURE_SKIP_SIB1_3_DURING_MANUAL_PLMN_SCAN is undefined.
01/16/09   rm      Made changes to send GAN_MODE_IND with RRC_MODE_RRC_EMI when
                   RRC state is either Disonnected or Connecting only
12/29/08   rm      Added support for 3G<->GAN Handover
12/29/08   rm      Added support for new Events
12/26/08   sk      If dual mode disabled and redirection to GSM, 
                   then trigger OOS and go to idle with no servce
12/18/08   rm      Made changes to handle Rove-in when UE is in OOS in connected mode
12/12/08   rm      Made changes to send GAN_MODE_IND with status RRC_MODE_RRC_EMI even when 
                   the N/W sel mode is SYS_NETWORK_SELECTION_MODE_LIMITED_ROUTINE_ACQUISITION
                   Also Made changes to Reject Rove-in request with cause BUFFER_RESEL_REQ 
                   when RRC is in DCH State
12/08/08   ns      Added support for FEATURE_RRC_BAND_TYPE_DETECTION_FOR_BPLMN
12/01/08   sks     Fixed compilation error when FEATURE SUPPORT FOR PARTIAL ROAMING is 
                   undefined.
12/01/08   sks     Made changes to update UI correctly with service status during 
                   conventional OOS search.
11/27/08   sk      Handling of BPLMN searches with 320ms DRX cycles by ignoring
                   alternate pages.
11/26/08   sks     Fixed compilation errors when FEATURE_WTOG_BACKGROUND_PLMN_SEARCH is 
                   not defined.
11/26/08   sks     Made changes to not update CCM with cell loss in case of
                   RRC_CSP_WTOG_BPLMN_AUTOMATIC_SCAN and RRC_CSP_WTOG_BPLMN_MANUAL_SCAN 
11/21/08   rm      Added code to unbar non-eplmn cells when Equivalent PLMN list changes
11/21/08   rm      Made changes to send GAN_MODE_IND after RRC_RR_STOP_WCDMA_CNF to RR
                   Also Made changes to not update CCM with cell loss in case of
                   RRC_CSP_WTOG_BPLMN_AUTOMATIC_SCAN and RRC_CSP_WTOG_BPLMN_MANUAL_SCAN
                   The changes are for GAN
11/06/08   sk      Pending stop mode cmd till W2G BPLMN is aborted
11/04/08   rm      Made Changes to support buffering of CELL_INFO_REQ while handling
                   WAKE_UP_REQ/ GO_TO_IDLE_DETACHED_REQ
11/04/08   rm      Added support for rove-in to GAN in RRC Connected mode.
                   Code changes are under FEATURE_GAN_3G_ROVE_IN_CONNECTED_STATE.
10/24/08   rm      Added support for Rove out from GAN, IDLE DETACHED MODE
                   Changes are under feature flag FEATURE_GAN_3G_ROVE_OUT_ONLY
09/12/08   ps      Added code for REl7 under FEATURE_WCDMA_REL7. Removed feature
                   FEATURE_CELLPCH_URAPCH
08/25/08   sks     Added code to handle RRC_EXIT_FROM_PWR_SAVE from NAS in connected
                   mode OOS case.
08/11/08   sks     Made chagnes to send PLMN list CNF for foreground search when aborted
                   by other NAS requests
08/01/08   pk      Report Limited_Service or No_Service to UI as soon as first cycle of
                   GSM search is done instead of waiting for whole GSM search to complete
                   when in OOS in RRC connected mode.
07/14/08   pk      Update band preferences given in LIST_REQ to RR while PLMN search is 
                   being done. Restore band preferences after the PLMN search is completed. 
07/14/08   gkg     Modified the logic for reporting Cell_Id in DCH in fucntion 
                   rrc_notify_cell_id_in_dch().
07/07/08   pk      At any time if service search triggered by RRC_SERVICE_REQ is aborted by
                   RRC_PLMN_LIST_REQ, then send RRC_SERVICE_CNF with NO_SERVICE to NAS before
                   handling on RRC_PLMN_LIST_REQ.
07/03/08   pk      Fixed compilation error when the feature FEATURE_WTOW_BACKGROUND_PLMN_SEARCH
                   is undefined.
06/30/08   ns      Made the necessary changes to enable the functionality of the feature 
                   FEATURE NETWORK SHARING only when the GCF NV is set
06/20/08   pk      Reset oosc_plmn_found only when both W & G searches are completed.
06/17/08   pk      Added code to handle NW_SELECT_MODE_RESET_IND from NAS for 
                   LIMITED_MODE->MANUAL_MODE.
06/13/08   gkg     Added code for notification of Cell_Id change through OTAs
                   in Cell_DCH state.
06/13/08   pk      Reset fach_tx_dest_state after successful cell selection of the UE
                   for frequency redirection during FACH->FACH/PCH state transitions.
06/09/08   pk      Avoid sending transition failure to L1 in case if reselection indication 
                   is being ignored at RRC when in DCH state.
06/09/08   pk      Added support for FEATURE_GTOW_REDIRECTION_AFTER_CONN_RELEASE.
05/22/08   pk      Send transition failure to L1 if cell reselection request is ignored
                   because of being in a non-suitable state.
05/16/08   pk      Added support for Rove-in to GAN. Changes are under the feature 
                   flag FEATURE_GAN.
04/17/08   pk      For automatic PLMN searches, set curr_type_acq to 
                   RRC_CSP_SPEC_PLMN on resume from sleep.
04/10/08   pk      Teardown BCCH before sending SLEEP_IND to L1, if RRC gets 
                   DEACT_REQ/STOP_MODE_REQ/MODE_CHANGE_REQ when BPLMN search is actively
                   in progress and CSP is waiting for SIBs.
03/20/08   pk      Cleanup BPLMN Database after going to DISCONNECTED state in case
                   of OOS. With UOOS UE is directly jumping to idle state with out 
                   doing any cell selection in case of OOS in connected mode and 
                   thus ending up in not sending PLMN_LIST_CNF to MM if PLMN search
                   is in suspended state. This is required for RL failure in DCH cases.
03/20/08   pk      Added support to reset reselection data after 
                   sending RRC_MODE_CHANGE_CNF to MM.
03/13/08   vm/pk   Added support for feature FEATURE_OOSC_SERVICE_STATUS_UI_UPDATE.
03/10/08   kp      Added support for SIB11bis. Code changes are under feature flag 
                   FEATURE SIB11BIS SUPPORT                   
03/07/08   vr/da   Added support for prioritization between MBMS and BPLMN under 
                   FEATURE_MODEM_MBMS
03/07/08   pk      Added support to maintain scrambling code of the currently camped cell.
                   LLC is required to send correct scr_code to L1 with new DL architecture.                                                      
03/06/08   da      Changed FEATURE_MBMS to FEATURE_MODEM_MBMS
01/11/08   pk      Don't allow L1, to go to BPLMN state if CCM is already informed of loss
                   of serving cell.                   
01/03/08   pk      During cell reselection, bar a frequency for "reselection only" if none 
                   of the shared PLMNs of the cell are equivalent to the NAS requested PLMN.
12/28/07   pk      For FEATURE NETWORK SHARING, corrected the usage of SIB DB vs BPLMN DB
                   based on curr_scan.
12/21/07   vr      Support for FEATURE_MBMS. In the current implementation, for FLC
                   redirect request is used. Hence this needs to be handled in Idle 
                   mode as well. Once the full fledged implementation is in place,
                   this will be removed
12/05/07   pk      Added support for reporting serving Cell ID, PSC to ATCOP.
10/25/07   pk      Initialize the fields release_trchls, release_phychls in chan_config_req
                   to tear down N-BCCH.                 
10/23/07   pk      Added support for network sharing feature.Changes are under feature flag 
                   FEATURE NETWORK SHARING.
10/19/07   pk      Added support for setting change mode request reason to INTERRAT_OOS
                   in case of OOS for FACH->FACH/PCH transitions. 
10/15/07   vm      Added fix for CR 105277. Add check for MCC to avoid reporting
                   PLMNs belonging to IMT band during AWS band search and vice-versa.
                   MCC check is important bcoz for Manual PLMN searches we only
                   look at MIB.
10/15/07   pk      Added support for cell selection/reselection to a access class barred cell
                   under the feature flag FEATURE_STAY_CAMPED_ON_ACCESS_CLASS_BARRED_CELL.
10/10/07   vm      Fixed a compiler warning.
10/08/07   pk      Moved the code which adds a freq to the available freq list to a 
                   new function.
10/03/07   pk      Added support to set the cell access status to ALL CALLS in case of 
                   GtoW handover.
09/28/07   vm      Removed GCF flag dependency for UOOSC
09/20/07   vm      Added support for feature FEATURE_UMTS_ACQ_CHNL_INFO_SHARING
09/20/07   pk      Added support for not to reset curr_scan if it is GtoW reselection scan while
                   handling on CELL_CHANGE_REQ(Success).
09/10/07   vm      Added support for feature FEATURE_RRC_DEFAULT_BAND_PRIORITY.
09/10/07   pk      Added support for Frequency redirection received in 
                   FACH->FACH and FACH->PCH cases under feature flag
                   FEATURE_RRC_FREQ_REDIRECTION_THRU_RB_AND_CU
08/24/07   pk      Added fix for CR 125300. Fix is to differentiate cell transition failures
                   from the general class of other failures in maintaining intra frequency cell
                   reselection counters for measuring performance during TCXO shutdown.
06/25/07   vm      Added fix for CR 119540. Added support to correctly set/reset current_band 
                   so that the band indicator check by SIB proc is done against the correct
                   current_band value.
06/22/07   vm      Corrected resetting of curr_scan to cell_selection_scan only
                   in the case of cell change success.
                   Added check for uoos_use_tmr as well when setting gsm_rem_awake_time
                   value from GSM-RR.
06/18/07   vm      Added fix for CR 113260. If CSP incorrectly receives back to back 
                   automatic plmn list requests from NAS then CSP will abort both the 
                   plmn list requests. 
06/15/07   vm      Added support for FEATURE_CONNECTED_MODE_UMTS_UNIFORM_OOS_HANDLING_UI_UPDATE
06/15/07   pk      Fixed an error in supporting WTOG cell reselection counters.
06/15/07   pk      When network selection mode is SYS_NETWORK_SELECTION_MODE_LIMITED 
                   i.e. emergency or no SIM/USIM state, If SIB change indicates no cell 
                   access then initiate cell selection by treating it as OOS.
06/06/07   pk      Report the plmn id in the INTERRAT_RESELECTION_REJ in case of 
                   RRC_WCDMA_PLMN_MISMATCH for GtoW reselection.
06/05/07   pk      Added support for checking cell access status based on the domain.
06/04/07   pk      Added support for "Partial Roaming Restrictions" under the feature 
                   flag FEATURE SUPPORT FOR PARTIAL ROAMING. For details please see
                   spec CR 151.
05/25/07   vm      Added support for handling RRC_INITIATE_CELL_SELECTION_IND in
                   WT_ACQ_PENDING and WT_FREQ_SCAN_CNF_PRENDING substates of CSP
                   for UOOS in Connected Mode Scan.
05/24/07   pk      Added support for feature FEATURE 900 FREQ SCAN OPTIMIZATION.
05/23/07   pk      Added fix for CR 117463. Now different timers are used for automatic and manual
                   searches under the feature flag FEATURE_MANUAL_SEARCH_FREQ_SCAN_SKIP_TIMER. 
                   Full frequency scans are not done for automatic and manual (both foreground 
                   and background) searches while the respective timers are running.
05/21/07   vm      Added fix to set plmn_fnd_during_fgnd_svc_srch to TRUE when 
                   CSP receives SIB cnf failure with cause SIB_EVENT_FAILED_FPLMN.
05/10/07   da      Made change not to update UE with SIB1 info in connecting state as
                   SIB1 info is to be used only in rrc state DISCONNECTED.
04/17/07   pk      Added support for maintaining intra frequency cell reselection,
                   WTOG cell reselection and OOS statistics which are needed to evaluate 
                   performance in TCXO Shutdown.
04/16/07   vm      Reverted changes made for FEATURE_UMTS_SKIP_BPLMN_FREQ_SCAN_TIMER
15/03/07   segu    starting of BPLMN full frequency scan timer is wrapped under feature
                   flag FEATURE_UMTS_SKIP_BPLMN_FREQ_SCAN_TIMER
03/30/07   vm      Added some debug messages
03/29/07   segu    When CSP received SIB_CNF failure with the cause SIB_EVENT_FAILED_FPLMN
                   then add the PLMN and cell information in ACQ DB and continue with cell 
                   selection. Changes are under the feature flag FEATURE SKIP SIBS FOR FPLMN
03/27/07   vm      Added fix for CR 114936. The contents of CPHY_CELL_TRANSITION_REQ cmd sent
                   to L1 are now properly initialized, especially req_mask. Junk value of
                   req_mask was leading to NULL ptr access in WL1.
03/27/07   vm      Added debug msg highs when CSP receives reselection indication
                   from L1.
03/22/07   vm      Added the optimization to continue reading SIBs even when
                   UOOS timer expires when CSP is waiting for acq cnf from L1 
                   and acq succeeds. Earlier, in this particular case, CSP used 
                   to wait for the next wakeup before trying acquisition on this
                   particular freq again.
                   Also removed nv_gcf_test_flag check when CSP is in wait_acq_pending.
                   This change has been made so that CSP tries the freq on which acq succeeds
                   again in the next wakeup. Earlier CSP would hv skipped acq attempt on this
                   freq in the next wakeup which is incorrect.
03/14/07   pk      Added support for resetting the BPLMN data before initializing the PLMN & band
                   information from the newly received service request.	
03/04/07   vm      Added support for FEATURE UMTS UNIFORM OOS HANDLING P2.
02/05/07   vm      Added a NULL pointer check before accessing the structure. Reported by Klocwork.
01/18/07   vm      Added fix for CR 109989. The fix is to send the correct sys_service_search_e_type
                   to NAS in PLMN_LIST_CNF even when NAS sends PLMN_LIST_REQ to RRC in wrong UE state.
01/04/07   pk      Update in SIB1/3/4 processing so that RRC will send one SERVICE_IND
                   to MM to avoid back->back service indications for each SIB change
12/18/06   pk      Added code to support a new cause RRC_TX_TO_DISCON_HARD_ABORT 
                   in the function rrc_transition_to_disconnected_state() under 
                   the feature flag FEATURE_RRC_HARD_ABORT which takes UE immediatley
                   to disconnected state in the case of hard abort scenarios                   
11/21/06   vm      Added support for the feature FEATURE UMTS BACKGROUND FULL SERVICE SEARCH.
11/21/06   vm      Added fix for CR 106306. Added UOOSI fix to update the 
                   rrc_csp_int_data.uoos_acq_status to TRUE when Acquisition 
                   succeeds, even when the GCF flag is enabled.
11/20/06   vm      Added support for the feature FEATURE_INTER_FREQ_EM_CALL_REDIRECTION.
                   Added definition of the new fn rrccsp_update_acq_type_for_em_call_ifreq_redirection()
10/26/06   vm      Added fix for CR 104768 - for BPLMN search do not reset 
                   current_band and first_band_to_be_scanned every time ACQ DB
                   is scanned from the beginning. This is to ensure that 
                   full freq scan is first done on the most recent "band entry" in the
                   ACQ DB.
10/20/06   vm      Added fix for CR 104559 - if BPLMN search timer expires when
                   RRC is waiting for RAW scan results and L1 subsequently returns
                   0 results then do not consider BPLMN search as done bcoz there
                   may be another band that needs to be scanned.
10/19/06   vm      Added fix for CR 104224 - curr_scan is reset to Cell Selection Scan
                   if PLMN_LIST_REQ is rcvd when CSP substate is "pending" and
                   original curr_scan is leaving_conn_mode_scan.
10/18/06   sgk     Fixed lint errors. 
10/16/06   segu    Set the correct n/w select mode received from NAS as part of the message 
                   RRC_NW_SEL_MODE_RESET_IND provided if the previous mode is
                   SYS_NETWORK_SELECTION_MODE_LIMITED_ROUTINE_ACQUISITION otherwise ignore
                   n/w select mode reset ind              
10/13/06   sgk     Added 7600 support under feature
                   FEATURE_UMTS_1X_HANDOVER_UMTSMSM
09/28/06   vm      Added a fix for UOOSI to reset uoos_acq_status flag to FALSE
                   if Tw timer expires and acq also succeeds.
09/25/06   segu    Added support for sib_change_ind interface change
09/12/06   segu    Check for both the current requested PLMN Id and internal PLMN Id as part 
                   of the equivaent PLMN check
09/11/06   vm      Added support to handle SCCPCH (+ PCCPCH) setup failure on
                   W resume in CSP substate RRCCSP_WT_FOR_CHAN_CFG_CNF. For details
                   please see CR 100999.
09/08/06   tkk     Added function "rrccsp_preprocess_deact_req_if_necessary"
                   to look if CSP is waiting for response from RR & do the 
                   necessary processing before handling RRC_DEACT_REQ.
09/08/06   tkk     Added code to handle RRC_DEACT_REQ when CSP is waiting
                   for response from RR during standby case.
09/05/06   vm      Added support for UOOSC.
08/28/06   vm      Added support for the feature FEATURE_DCH_TO_FACH_PCH_OUT_OF_SERVICE_ENHANCEMENT.
08/25/06   vm      Added support for FEATURE_DEEP_SLEEP_REL6_OUT_OF_SERVICE_ENHANCEMENT.
08/22/06   segu    Added new function "rrccsp_is_gtow_bplmn_srch_in_progress" 
                   to check if GtoW BPLMN search is in progress.
07/21/06   vm      Added support for UOOSI. 
07/06/06   vm      Added support to ignore the 10s no service timer, when n/w select
                   mode is SYS_NETWORK_SELECTION_MODE_LIMITED (mainly used for emergency calls
                   or when USIM is absent) or SYS_NETWORK_SELECTION_MODE_MANUAL.
06/30/06   segu    Removed few -ve indentations and updated the prints that will say
                   now signal strength >= -95db 
06/26/06   segu    Signal strength greater than (or) equal to 95db is considered as
                   SYS_SIGNAL_QUALITY_HIGH instead of usual 75db
06/15/06   vk      When SIB5 changes, then send the updated HSDPA_HSUPA_IND to MM
                   if the new HSDPA capability of the cell does not match the 
                   old HSDPA capability of the same cell
06/13/06   segu    Added support for DSAC
06/08/06   vm      Added support for new feature FEATURE_MCC_AND_850_800_BAND_COMBINATION.
                   1. Made changes to set rrc_csp_curr_select_data.current_band appropriately 
                      based on MCC and UARFCN information.
                   2. Added new function rrccsp_get_curr_type_acq() that just returns the 
                      rrc_csp_int_data.curr_acq_type that is either RRC_CSP_SPEC_PLMN or 
                      RRC_CSP_ANY_PLMN.
06/06/06   vm      Added support to start the T-barred timer if during 
                   reselection, the W cell has the UE's access class(es) as 
                   barred and additionally the W cell is reserved for operator
                   use. Please see 95247 for details.
05/31/06   segu    Added a wrapper function rrc_csp_get_curr_cell_access_status()
                   to get the current cell access status
05/26/06   vm      Added support to initialize current_band correctly when 
                   GtoW Reselection/CCO request is received.
05/24/06   segu    Removed the check for equivalent PLMN i.e. sys_eplmn_list_equivalent_plmn() 
                   while performing GTOW BPLMN searches and also incorporated few
                   code review comments 
05/11/06   vm      Removed dependence on GCF flag for setting the OOS redirection wait
                   timer to 15s. Now this timer is always set to 15s (earlier it was
                   set to 45s if GCF flag was not enabled and 15s otherwise).
05/04/06   vm      Added support to read dual mode flag from PLMN_LIST_REQ instead
                   of relying on the MCM dual mode flag (which gets updated whenever
                   service request is received). 
05/02/06   segu    Added support for single to dual mode changes
04/21/06   segu    Added support for feature equivalent HPLMN under the compiler
                   flag FEATURE_EQUIVALENT_HPLMN
03/30/06   vm      Added support to start the PLMN list full freq scan timer 
                   for 3G to 3G Automatic/Manual PLMN searches also (both 
                   background and foreground). As long as this timer is active 
                   no full scans are done. 
03/23/06   vm      Added support to correctly set CSP next substate when state change 
                   indication to CELL_FACH from Connecting state is received by
                   CSP and intra-frequency reselection is in progress.
03/22/06   vm      Added support to abort Manual PLMN search before sending inter-RAT
                   redirection request to GSM. For details pls refer to CR 90201.
03/16/06   vm      Fixed a lint error.
03/15/06   siva    Fixed the LINT warning
03/08/06   vm      Added fix to set curr_type_acq and type_acq appropriately
                   before starting manual bplmn search.
03/07/06   vm      Added support to not increment agc_threshold_cnt when service 
                   search is not done because "no service timer" is running.
03/03/06   vm      Added support for doing Manual BPLMN search in background
                   when Manual PLMN List Search request is received when CSP
                   CSP scan type is LEAVING_CONN_MODE. 
                   Also added support to NOT reject Manual PLMN list request
                   when est cause is INTERRAT_RESEL or INTERRAT_CCO.
02/28/06  da/sm    Modified code to support migration to Dec-05 Rel-6 ASN1
02/21/06   vm      Added support for sending W suspend reason to WL1. The suspend
                   cause in suspend_req is populated based on CSP current scan type.
                   For BPLMN, also added support for informing WL1 whether WTOG 
                   BPLMN search is active or not when L1 calls the function 
                   rrc_can_l1_go_to_sleep().
02/16/06   vm      Added the following BPLMN optimizations:
                   1. Doing Manual PLMN search in foreground when UE goes OOS in Idle Mode 
                      during Manual BPLMN Search. Earlier when UE went OOS during Manual 
                      BPLMN search, RRC was aborting the search and returning 0 PLMNs to the 
                      user. Now RRC automatically restarts the search if UE goes OOS in IDLE 
                      mode during Manual BPLMN search and completes it in foreground and returns 
                      the results to the user. 
                   2. Guard timer has been reduced to 120s from 180s. 
                   3. Guard timer is now not restarted when Manual BPLMN search is interrupted 
                      by LAU/RAU (earlier it was getting restarted). 
                   4. Handling of Manual/Automatic PLMN List Request when scan type is 
                      RRC_CSP_LEAVING_CONN_MODE_SCAN, and 
                   5. Checking for S-criteria during WtoW Automatic BPLMN. 
02/14/06   vm      Added fix to save curr_type_acq and type_acq also before
                   starting the BPLMN search. Otherwise, UE may reselect to a
                   non-equivalent PLMN if the frequency corresponding to the PLMN
                   is in the neighbor list. 
02/13/06   vm      Added support to check for S-criteria for the neighbor cell too
                   before transitioning to the neighbor cell.
02/13/06   kp      Added the fix to initialize Transaction I.D properly
02/09/06   vm      Added fix to properly initialize BPLMN variables when Manual
                   BPLMN search is interrupted by LAU/RAU and the feature 
                   EATURE_PCS_850_FREQ_SCAN_NEW_OPTIMIZATION is enabled.
02/06/06   vm      Added support for taking UE to idle immediately when DCH->FACH/PCH
                   timer expires and UE is reading SIBs; and also when CSP receives
                   initiate cell selection with cause tx to disconnected when it
                   is in the middle of reading SIBs for neighbor cell. Earlier CSP
                   was waiting for SIB_CNF from SIB procedure instead of going to 
                   idle immediately which was introducing unnecessary delay.
02/02/06   vm      Added support for aborting BPLMN search as soon as CHO procedure
                   sends suspend request to CSP for WTOG CCO request from the network
                   (instead of waiting for the success/failure of WTOG CCO before
                    deciding whether the BPLMN search should be aborted or not).
01/31/06   vm      Replaced SYS_PLMN_LIST_MAX_LENGTH by SYS_PRIORITY_PLMN_LIST_MAX_LENGTH
                   for Automatic BPLMN search requests.
01/30/06   vm      Added the following BPLMN fixes/optimizations
                   1. Handling of RRC_BPLMN_SEARCH_ABORT_REQ when Manual PLMN search
                      is being done in foreground.
                   2. Always adding serving PLMN to available PLMN list for Manual PLMN Search.
01/25/06   bd      Lint clean-up
01/23/06   vm      BPLMN Optimization for Automatically re-starting Manual 
                   BPLMN search after completion of LAU/RAU updates & added
                   support for not rejecting Manual PLMN search request when RRC state 
                   is Connecting/FACH/DCH and the establishment cause is Registration. 
01/23/06   kp      Added support for Transaction I.D in BPLMN Abort feature 

01/20/06   vm      Added support for getting GSM arfcns during Manual/Automatic
                   PLMN search so that acq attempt on some of the W channels can
                   be skipped to reduce freq scan times in PCS/850 bands. The 
                   changes are under feature flag FEATURE_PCS_850_FREQ_SCAN_NEW_OPTIMIZATION.
01/19/06   kp      Avoid processing other than MIB in function 
                     rrccsp_bplmn_srch_tmr_expiry_wait_sib_sib for BPLMN manual 
12/30/05   sg      Added support for handling BPLMN Abort search from NAS
12/15/05   bu      Added support to not read SIB1 and SIB3 during manual PLMN scan. Changes
                   are under FEATURE_SKIP_SIB1_3_DURING_MANUAL_PLMN_SCAN.
11/25/05   vm      Added more support related to BPLMN features - sending abort req
                   to GSM when guard timer expires in camped_suit_cell, camped_accept_cell,
                   suit_wt_trans_cnf, and accept_wt_trans_cnf substates.
11/24/05   sg      Modified rrc_is_s_criteria_met() to support for WTOW and WTOG Back
                   Ground PLMN searches, passing third parameter i.e max UL Tx Power 
                   to l1_is_s_criteria_met()                     
11/23/05   vm      Added support for feature FEATURE_PCS_850_FREQ_SCAN_NEW_OPTIMIZATION.
                   GSM now returns the ARFCNs which are then mapped to UMTS channels so that
                   acq attempt on some of the channels can be skipped to reduce frequency
                   scan time.
11/22/05   vm      Added more support related to BPLMN features
11/16/05   vm      Added more support related to BPLMN features
11/08/05   vm      Added support for WTOW and WTOG Background PLMN Search. 
11/01/05   vm      For BPLMN searches, 15mins timer is now under a GCF flag. If GCF flag
                   is set then 15mins BPLMN Full Scan timer is NOT started.
10/07/05   vm      Setting new RRC/L1 interface variable cell_type in transition request
                   with the correct value.
10/05/05   vm      Added support for feature FEATURE INTERRAT PCCO GTOW - RRC will
                   reject reselection indications from L1 and send transition confirm 
                   with failure if PCCO is in progress.
10/03/05   da      Added change to include PLMN and LAC info on top of cell ID
                   when notifying cell id change to registered callbacks.
09/28/05   vm      Added support for redirection to another frequency + psc via
                   RRC Connection Setup message.
09/27/05   vm      Added support for handling initiate cell selection for transition
                   to disconnected immediately when CSP is in reselect_wt_camp substate.
09/26/05   da      Added change to notify cell id change to registered callbacks
                   in the case of G->W reselection.
09/21/05   da      Changed funcs rrc_register_serving_cell_change_ind_cb and 
                   rrc_deregister_serving_cell_change_ind_cb to return boolean
                   value as status.  Changed name of func rrc_notify_cell_id_change_cb_func
                   to rrc_notify_cell_id_change
09/20/05   da      Added functionality that enables upper layer to register a callback 
                   function if notification of the serving cell id is required.  
                   Once the function is registered, it will be called whenever there is 
                   a serving cell id change until the callback is deregisterd.
09/15/05   vm      Moved the declaration of STATIC functions rrccsp_camped_suit_cell_hdlr()
                   and rrccsp_camped_accept_cell_hdlr from rrccspi.h to this file (rrccsp.c) 
09/09/05   vm      Changed the check for scan type from RRC_CSP_CELL_RESELECTION_SCAN to
                   RRC_CSP_WCDMA_TO_GSM_CELL_RESELECTION_SCAN. Otherwise, UE was getting stuck
                   because CSP was ignoring RRC_IRAT_ABORT_IND from MCM.
09/08/05   siva    Moved the procedure of Handling of Piggybacked cell reselection 
                   indication in cell transition confirm from L1 in response to cell 
                   transition request (failure) from RRC when reselection failure  
                   happenns to RRCCSP_SUIT_CELL_RESELECT_WT_TRANS_CNF_HDLR/
                   RRCCSP_ACCEPT_CELL_RESELECT_WT_TRANS_CNF_HDLR
09/01/05   vm      Optimization: added support for checking S-criteria also for the
                   cell during automatic background PLMN search. Added new function 
                   rrc_is_s_criteria_met().
08/30/05   siva    Handling of Piggybacked cell reselection indication in cell transition confirm 
                   from L1 in response to cell transition request (failure) from RRC when reselection 
           failure happens
08/29/05   da      Extended the handling of SIB 5 and SIB 6 change to all relevant states.
08/23/05   vm      Added ANY_PLMN support also in feature FEATURE_PCS_850_FREQ_SCAN_OPTIMIZATION.
08/18/05   vm      Added support for not barring a cell if the network select
                   mode is SYS_NETWORK_SELECTION_MODE_LIMITED, which would be 
                   the case when (a) On power up, the SIM has not been read but
                   is present, (b) SIM is absent, and (c) User attempts
                   an emergency call when UE is OOS.
08/16/05   vm      Added support for feature FEATURE_PCS_850_FREQ_SCAN_OPTIMIZATION.
08/12/05   tkk     Added check to ignore RRC_CPHY_DL_WEAK_IND primitive for 
                   neighbor cell while transitioning to DCH.
08/12/05   siva    Setting freq_incl flag to TRUE when sending Cell Transition 
                   Confirm failure to L1 as a funnel command during Cell Selection/
                   Reselection failure 
08/04/05   vm      Added support for scanning again the last camped frequency 
                   during every fine scan when UE goes OOS in Idle mode.
08/03/05   vm      Added support for barring the neighbor cell for 40s if all
                   the access classes of the neighbor cell are found to be barred.
07/27/05   vm      DRX_REQ is now sent to L1 due to SIB1 update when RRC is in
                   disconnected or connecting state.
07/26/05   vm      Made required changes to bar the serving cell for 10s if
                   UE receives a page for SIB3/4 update that bars all the 
                   access classes of the UE.
07/25/05   da      Added change to call func rrc_trigger_home_zone_ind in the case
                   of G-to-W re-selection
07/20/05   vm      Fixed a compilation error when Error Recovery Features are defined.
07/15/05   vm      Removed updating of band for GtoW handover, GtoW CCO, and 
                   inter-RAT reselections as band information is already known
                   to CSP in handover, CCO, and reselection cases; and to GSM-RR
                   for WtoG reselection case.
07/15/05   vm      Added support for handling channel config failure in CSP instead
                   of MCM.
                   1. RRC_FORBIDDEN_LAI_LIST_UPDATE_REQ is now handled outside of any of 
                      the CSP substates.
                   2. Removed handling of initiate cell selection from MCM procedure, as 
                      MCM now no longer sends initiate cell selection request to CSP procedure.
                   3. When W is successfully suspended for attempting reselection to GSM,
                      the Cell Change Manager is updated with Cell Loss. This is to avoid
                      race condition where RCE receives establishment request when CSP is
                      still configuring channels after failed WtoG reselection but successful
                      W resumption. Cell Change Manager is again updated with New Cell Selected
                      when Channel Configuration is successful; and RCE is also updated if needed.
                   4. Added handling of resume success to trigger channel configuration; and 
                      failure to trigger cell selection in CSP.
                   5. Removed definition of function rrc_get_csp_currscan() as it is no longer
                      used.
                   6. Added 2 new CSP substates RRCCSP_WT_CHAN_CFG_CNF_HDLR and 
                      RRCCSP_WT_CHAN_CFG_CNF_PENDING_HDLR and corresponding new functions
                      rrccsp_wt_chan_cfg_cnf_hdlr() and rrccsp_wt_chan_cfg_cnf_pending_hdlr().
07/08/05   vm      FEATURE_OUT_OF_SERVICE_ENHANCEMENT: Added support for OOS in 
                   Connected Mode feature.
07/06/05   siva    Start cell selection instead continue cell celection when reselection in Idle mode fails
                   and also when reselection failed due to DOWN_LINK_WK_IND then send freq and scr_code from new cell info
           instead from sib_cnf
07/05/05   vm      Used frequency information from current acq entry instead of 
                   acq_cnf command pointer for handling failure during inter-frequency
                   redirection. Also removed cmd_ptr argument from function
                   rrccsp_handle_failure_during_freq_redirection().
06/21/05   vm      Added support for trying acquisition on the best cell in the active set on
                   DCH->Idle transition. Added definition of new function rrc_csp_get_aset_scr_pn().
06/16/05   vm      Added required support in RRC to set the wait timer to 5s if a
                   wait timer of less than 5s (>0) is received by the UE in RRC
                   Connection Reject for inter-RAT redirection.
06/07/05   vm      If due to cell access restrictions, UE is not able to camp on the cell
                   then start a T-barred timer of 320s instead of 1280s for the PSC.
06/06/05   da      Removed Home zone related functions.  new functionality has moved to
                   rrcscmgr.
06/02/05   vm      Added support for inter-RAT abort handling:
                   (a) added support for handling of new command RRC_IRAT_ABORT_IND from 
                       MCM in various CSP substates during inter-RAT reselection in Idle Mode,
                   (b) added support for handling of RRC_SERVICE_REQ in various CSP
                       substates when G to W reselection is in progress,
                   (c) added definitions of new functions rrccsp_send_interrat_reselection_abort_req()
                       and rrccsp_send_interrat_reselection_abort_cnf(),
                   (d) renamed existing function rrccsp_wait_redirect_abort_cnf_hdlr() to 
                       rrccsp_wait_rr_abort_cnf_hdlr().
05/27/05   vm      Now, the function rrc_csp_find_cell_bar_status() does not send cell bar request
                   to L1 if the cell is found to be barred; and hence sending appropriate cell bar
                   request is done by the calling function.
05/26/05   vm      Since L1 should not fail HO to a barred cell but should fail GtoW reselection
                   or CCO attempts to a barred cell, RRC now sends rrc_csp_int_data.acq_mode in ACQ REQ
                   to L1 with a new enum type L1_WCDMA_INTER_S_RESEL_ACQ.
05/26/05   vm      Added handling of Downlink Weak Indication during SIB7 reading.
                   In particular, case statement for command RRC_CPHY_DL_WEAK_IND
                   has been added in RRCCSP_CAMPED_SUIT_CELL and RRCCSP_CAMPED_ACCEPT_CELL
                   substates of CSP. If SIB7 reading is active when this indication is 
                   received then SIB7 reading is aborted and RRC_SIB7_UPDATE_STATUS_IND
                   is sent by SIB procedure immediately to RCE.
05/11/05   vm      Added support for handling new NAS indication RRC_NW_SEL_MODE_RESET_IND.
                   On receiving this new indication, CSP will update the network select mode
                   to SYS_NETWORK_SELECTION_MODE_AUTOMATIC
05/10/05   vm      Added support for handling Downlink Weak Indication during
                   G to W reselection. 
05/05/05   svk     Added processing of SIB6 change indication in FACH state.
05/05/05   vm/bu   1. Added support for T-barred Feature.
                      (a) CPHY_CELL_BAR_REQ is sent to L1 if the serving cell becomes barred.
                      (b) If WtoG reselection fails because the G cell is barred, then CPHY_CELL_BAR_REQ
                          is sent to L1 with T-barred timer value of 320s.
                      (c) Defined a new function rrc_get_csp_substate() that returns the current
                          CSP substate.
                      (d) Removed dchtoidle_flag altogether from the file.
                   2. SIB change indication is now handled for either SIB3 or SIB4 but not
                      both based on RRC state and availability of SIB4.
                   3. Added a check to make sure that max entries allowed in the array
                      available_freq_list are never exceeded. Now, a check is made before adding
                      another frequency to the list. If max entries are reached, an error message is
                      printed and number of entries in the list is reset to 0.
05/02/05   vm      Added support to read MIB in foreground if MAX attempts to read
                   MIB in background have failed due to BPLMN search timer expiry.
04/27/05   vm      RRC will now send CPHY_CELL_PARM_REQ to L1 on Connecting to FACH state
                   transition so that L1 uses parameters in SIB4 (if present) instead of
                   the ones in SIB3. Notice that CPHY_CELL_PARM_REQ will be sent even when
                   SIB4 is not present.
                   Also removed function rrccsp_camped_accept_cell_state_change(); and
                   re-named function rrccsp_camped_suit_cell_state_change() to
                   rrccsp_camped_cell_state_change() which will now be a common function used
                   for state change by CSP when it is camped on a suitable cell or acceptable cell.
04/20/05   bu      Initiate cell update when SIB3/4 indicates that the current
                   serving cell has become barred or when MCM initiates cell selection
                   with cause out of service area in CELL_FACH/CELL_PCH/URA_PCH states.
04/18/05   vm      Set the scan type to RRC_CSP_WCDMA_TO_GSM_CELL_RESELECTION_SCAN
                   when W to G reselection indication is received from L1 when UE
                   is camped on an acceptable cell.
04/14/05   vm      Added support to handle Out of Service due to reselection
                   failure in Connected state. With the new implementation,
                   OOS indication is sent to CU so that appropriate timer is
                   started in CU. CU will then send initiate cell selection
                   indication to CSP and if service is found before CU's timer
                   expiry then UE's Connected state is maintained, else UE goes to
                   idle state. Earlier, UE was always going to idle.
                   Also added definition of a new function rrccsp_send_cell_update_initiate_req().
                   Since the feature FEATURE_BARRED_CELL_DURING_CELL_SELECTION is always
                   defined, un-featurized the code.
04/11/05   bu      Set the DCH->IDLE flag to TRUE on a state change from DCH->IDLE.
                   Set it to FALSE when camping on a suitable or an acceptable cell.
04/04/05   bu/vm   Added support for inter-RAT redirection feature
                   . Added new functions rrccsp_send_interrat_redirection_abort_req(),
                     rrccsp_send_interrat_redirection_req(), rrccsp_wait_response_from_rr_hdlr(),
                     rrccsp_wait_redirect_abort_cnf_hdlr(),
                     rrc_csp_cleanup_inter_freq_redirection_state().
                   . Removed substates:
                     RRCCSP_SUIT_CELL_RESELECT_WT_RESUME_MODE_CHANGE_CNF,
                     RRCCSP_ACCEPT_CELL_RESELECT_WT_SUSPEND_MODE_CHANGE_CNF,
                     RRCCSP_ACCEPT_CELL_RESELECT_WT_RESUME_MODE_CHANGE_CNF;
                     and corresponding function calls:
                     rrccsp_suit_cell_reselect_wt_resume_mode_change_cnf_hdlr(),
                     rrccsp_accept_cell_reselect_wt_suspend_mode_change_cnf_hdlr(),
                     rrccsp_accept_cell_reselect_wt_resume_mode_change_cnf_hdlr().
                   . Replaced the substates by the following new substates:
                     RRCCSP_WT_SUSPEND_MODE_CHANGE_CNF, and
                     RRCCSP_WT_RESUME_MODE_CHANGE_CNF.
                     and functions by the following new functions:
                     rrccsp_wt_suspend_mode_change_cnf_hdlr(), and
                     rrccsp_wt_resume_mode_change_cnf_hdlr().
                   . Added new substates RRCCSP_WT_RESPONSE_FROM_RR and
                     RRCCSP_WT_REDIRECT_ABORT_CNF.
                   . Included file rrcasn1i.h for Raven compilation.
03/31/05   bu      If GTOW fails due to PLMN mismatch set the timer value to max T-barred
                   timer value (1280 secs). If GTOW reselection fails due to WCDMA
                   cell/frequency being barred, set the timer value in reselection_reject
                   based on T-barred value in SIB.
03/03/05   vm      Added support for inter-frequency redirection feature.
                   Added handling of new event RRC_FREQ_REDIRECT_WAIT_TIMER_EXPIRED_IND
                   in various substates of CSP, added RRC_FREQ_REDIRECT_WAIT_TIMER_PENDING
                   to pending_command_handler function, added new functions
                   rrccsp_handle_rrc_redirect_req(), rrccsp_validate_redirection_req(),
                   rrccsp_handle_failure_during_freq_redirection(), rrccsp_send_rce_redirect_cnf(),
                   rrc_csp_start_sel_redirect_freq_in_connecting_state(),
                   rrccsp_handle_freq_redirect_wait_timer_expiry(), and
                   rrccsp_send_nbcch_teardown_req().
                   Removed functions rrccsp_camped_suit_cell_redirect_req() and
                   rrccsp_camped_accept_cell_redirect_req().
02/24/05   vm      When UE is in deep sleep and service is requested, then in addition
                   to checking for the no service timer, also check for the bands supported
                   in the request. If any of the bands in the service request were not
                   supported in earlier requests since the start of the no service
                   timer then service the request irrespective of the no service timer.
02/24/05   bu      In rrccsp_update_plmn_info_for_gtow_handover() use
                   rrc_get_frequency_band() to set the band_class to be written
                   into the ACQ DB for the acquisition entry. Additionally if
                   FEATURE_WCDMA_MULTIBAND is not enabled, set the band_class to
                   PCS/IMT2K correctly based on whether FEATURE_WCDMA_PCS is
                   defined or not.
02/15/05   vm      Added support for deep sleep. In particular, initialization
                   of new band mask, deep_sleep_band_scanned_mask, that maintains
                   the list of bands that have been scanned as part of full frequency
                   scan.
02/10/05   sgk     Added SIB_18_BIT in the sib_mask before sending
                   RRC_GET_SPECIFIC_SIBS_REQ.
01/14/05   vm      Removed SIB6 change support for CELL_PCH and URA_PCH
                   states as it was unstable.
01/04/05   sk      Added support for SIB5 and SIB6 change.
12/30/04   bu      Send RRC_SERVICE_IND to MM if SIB1 changes in DISCONNECTED
                   or CONNECTING states.
12/21/04   vm      Fixed lint error.
12/08/04   bu      Added handling of OOS indication from RCE in various
                   CSP reselection substates.
12/06/04   vm      Featurised definition of the function rrccsp_no_cell_sel_bplmn_srch_req
                   under FEATURE_GTOW_BACKGROUND_PLMN_SEARCH, to handle compiler
                   warnings when feature is not defined.
12/03/04   da      Changed code for HomeZone feature.  Changed the typedef of
                   CB func used and changed the parameters passed accordingly.
12/02/04   da      Added support for HomeZone service under feature name
                   FEATURE_HOME_ZONE_SERVICE.  Defined the following new functions
                   rrc_register_serving_cell_change_ind_cb,
                   rrc_deregister_serving_cell_change_ind_cb,
                   rrc_notify_cell_id_change_cb_func
12/02/04   vm      Modified BPLMN search timer received from RR.
12/01/04   vm      Added code for FEATURE_GTOW_BACKGROUND_PLMN_SEARCH feature.
                   Calling rrcsib_check_mib_read_status function to check and
                   see if MIB has been read or not when BPLMN timer expires.
12/01/04   bu      Process the CPHY_DL_WEAK_IND appropriately based on whether
                   it's for the serving or neighbor cell in various CSP substates.
11/23/04   vm      Fixed lint errors.
11/22/04   vm      Added feature FEATURE_GTOW_BACKGROUND_PLMN_SEARCH.
                   For the feature
                   (a) Defined new functions rrc_csp_process_pending_bplmn_srch_timer_expiry,
                       rrccsp_no_cell_sel_bplmn_srch_req,
                       rrccsp_bplmn_srch_tmr_expiry_wait_sib_sib, and
                       rccsp_send_bplmn_search_cnf_to_rr, rccsp_send_bplmn_abort_cnf_to_rr.
                   (b) Added code for handling new cases RRC_INTERRAT_PLMN_SRCH_REQ,
                       RRC_BPLMN_SRCH_TIMER_EXPIRED_IND, RRC_INTERRAT_PLMN_SRCH_ABORT_REQ,
                       RRC_BPLMN_SRCH_TIMER_PENDING, RRC_INTERRAT_PLMN_SRCH_ABORT_REQ_PENDING.
                   (c) Added code for handling new scan types RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN
                       and RRC_CSP_GTOW_BPLMN_MANUAL_SCAN.
11/22/04   bu      Support for physical channel failure handling.
11/18/04   vm      Added new variables rrc_csp_int_data.deep_sleep_no_svc_tmr_expired and
                   rrc_csp_int_data.deep_sleep_acq_db_plmn_searchloop.
                   deep_sleep_no_svc_tmr_expired: to handle the case when UE is in deep
                   sleep and consecutive service requests are received from NAS.
                   deep_sleep_acq_db_plmn_searchloop: to handle the case when UE is in
                   deep sleep and specific plmn request is received and no matching
                   PLMN is found in acq db.
11/11/04   bu      Added support to handle RRC_CPHY_DL_WEAK_IND while waiting for
                   SIBs during suitable or acceptable cell reselection.
11/10/04  sm/kc/bu Add all the SIBs to the SIB mask in RRC_GET_SPECIFIC_SIBS_REQ.
11/10/04   vm      Added code to function rrccsp_cell_sel_wait_sib_sib so that
                   no duplicate entry is made to available frequencies list.
11/08/04   bu      Added the state change (to Disconnected) processing for
                   out of service area in connected mode scan also.
10/28/04   bu      Set gtow_ho_active flag to TRUE in cell_selected_meas_req
                   for a GTOW handover.
10/13/04   vm      Removed/suppressed lint errors.
09/29/04   vm      Added support to send RRC_SERVICE_IND to NAS when the access
                   class related cell access restrictions change. Modifications
                   were made to the function rrccsp_update_sib3_4_data(void).
09/24/04   bu      Changes to not process SIB1 update if received in any RRC state
                   other than Disconnected or Connecting states.
09/23/04   bu      Added support to send CPHY_CELL_PARM_REQ to L1 when SIB3/4
                   changes. Added support to handle SIB4 change.
09/21/04   bu      Removed checks for scan types in
                   rrccsp_cell_sel_wait_state_change_hdlr(), as it's assured that
                   CSP will be getting a STATE_CHANGE_IND to IDLE in this substate.
09/16/04   bu      Send CPHY_IDLE_REQ to L1, before sending CPHY_ACQ_REQ on the
                   next best cell on the same frequency.
09/15/04   bu      Support for Out of service area handling in connected mode.
09/15/04   bu      Initialize agc_threshold_cnt in rrc_init_cell_selection_procedure().
09/09/04   bu      Added handling for RRC_CPHY_DL_WEAK_IND. Try the next best
                   cell for all scan types other than GTOW scans. Also try next
                   best cell on the same frequency (if available) for SIB failures.
09/08/04   bu      Set the correct FAILURE/SUCCESS status in the RRC_CSP_ACQ_CNF
                   which is sent to IHO procedure based on the TRUE/FALSE status
                   in ACQ_CNF from L1.
08/31/04   bu      Set the correct band mask for current_band and
                   first_band_to_be_scanned.
08/27/04   bu      Removed sending of RESET_REQ to L1 when trying next best cell.
                   Call bch release instead of release all chls when S criteria fails
                   for acceptable cell.
                   Check only for GTOW scans before calling
                   rrccsp_try_next_best_cell_if_available().
08/26/04   jh      Updated to use new L1 tx_div_ind interface.
08/24/04   bu      Instead of rrc_csp_release_chls_and_and_continue_cell_selection,
                   use rrc_csp_release_bch_and_continue_cell_selection when RRC
                   state needs to be maintained (e.g for DCH->FACH or DCH->PCH
                   transitions etc).
08/13/04   bu      Added WCDMA multiband support.
08/12/04   bu      Reset the reselection data properly in all reselection
                   substates, when going to IDLE and triggering cell selection.
                   If CELL_CHANGE_CNF (SUCCESS) was received from CCM and DCH->FACH/PCH
                   timer expiry was pending, ignore the timer expiry and continue
                   processing the DCH->FACH/PCH transition.
08/09/04   bu      Before initiating Connected to Idle mode cell selection scan,
                   update CCM with cell loss.
08/05/04   bu      If initiate cell selection command is rxed from CU with cause
                   TRANS_TO_DISCONNECTED, handle the command appropriately. If CSP is
                   waiting on some confirmation, wait for that confirmation before handling
                   the pending command. If initiate cell sel cmd was received while waiting
                   for SUSPEND_CNF/RESUME_CNF, it is processed once RESUME_CNF is received.
07/13/04   bu      If DCH->FACH/PCH timer expires, send channel release to take UE to
                   IDLE and wait for the STATE_CHANGE_IND (to IDLE) before
                   sending of NO_SERVICE indication to MM.
07/08/04   bu      If S criteria fails or cell is below expected and L1 has
                   detected another cell on the same frequency, try to acquire
                   that cell before moving to the next frequency.
06/22/04   bu      If error recovery was triggered, ensure that the last_mm_primitive
                   is set correctly. If the scan was for GTOW reselection, STOP WCDMA
                   mode and send reselection reject to RR.
06/21/04   bu      Added support for new CSP states to wait for TRANSITION_CNF
                   from L1, after a TRANSITION_REQ (Failure) is sent for a cell
                   reselection. Added the new support for both suitable and acceptable
                   cell reselections.
06/14/04   bu      Initialized ue_in_deep_sleep variable in
                   rrc_init_cell_selection_procedure().
06/14/04   bu      Call rrcccm_force_init(), on a MODE_CHANGE (FTM), or when
                   ERR_FATAL_IND is received.
06/07/04   vn      Added call to rrcsib_force_sib_event_init on an OOS Area
                   trigger handling in rrccsp_handle_out_of_service_ind.
06/01/04   bu      Added support for network_select_mode and band_pref in W<->G requests.
05/13/04   bu      Corrected the check for Inter-frequency cell reselection in
                   CELL_FACH.
05/07/04   bu      Added support for Inter-frequency cell reselections in CELL_FACH.
                   Changes are under FEATURE INTER FREQUENCY CELL FACH RE SELECTION.
05/05/04   bu      Added FREQ_SCAN timer support. RRC will initiate full frequency
                   scan only if this timer has expired.
04/29/04   bu      Check if RCE is active only if current RRC state is DISCONNNECTED while
                   processing GSM/Inter-frequency cell reselection indication.
04/28/04   bu      Removed the check to see if RCE is active for an inter-frequency
                   cell reselection indication in CELL_PCH or URA_PCH.
04/13/04   bu      Added limited support for SIB3 change. If SIB3 changes cause the cell
                   to become barred treat it as an out of service area case and start
                   cell selection.
04/02/04   bu      Moved PCCO feature definition inside rrccsp_send_camp_cnf_to_cho().
04/02/04   bu      Populate the failure reason and other information while sending
                   CAMP_CNF (FAILURE) back to CHO for GTOW PCCO.
03/31/04   bu      If NAS requested for ANY_PLMN_REQ with network select mode set to
                   SYS_NETWORK_SELECTION_MODE_LIMITED_ROUTINE_ACQUISITION, on camping
                   on an acceptable cell, set the CSP state to camped on suitable cell
                   as, from that point onwards we only want to do suitable cell
                   reselections.
03/31/04   bu      Added support to handle Inter-frequency cell reselection indication
                   from L1 while camped on a suitable cell in CELL_PCH or URA_PCH
                   states.
03/16/04   bu      Added support to handle OOS while waiting for SIBs for other
                   scan types also, apart from GTOW, WTOG and reselection scans as
                   it's not applicable to them.
03/15/04   bu      Removed the use of FEATURE DUALMODE BASELINE. This feature is
                   always defined (even for singlemode builds).
03/10/04   bu      Corrected the merge typo in rrccsp_save_req().
03/05/04   bu      Set the acq_type field in rrc_csp_int_data &
                   rrc_csp_curr_select_data based on the request from RR.
03/04/04   bu      Added support for CELL_PCH and URA_PCH states.
02/12/04   bu      Added support for ERR_FATAL recovery.
02/11/04   bu      Initialize full_scan_needed and power_up_done in
                   rrc_init_cell_selection_procedure().
02/11/04   bu      Added support to handle OOS while waiting for SIBs if it's a
                   CELL_SELECTION_SCAN.
02/10/04   bu      For GTOW handover send CELL_SELECTED_REQ to Measurement procedure
                   after a successful acquisition.
02/05/04   bu      Removed changing of scan type to CELL_SELECTION_SCAN in various
                   CSP substates.
02/04/04   bu      Added state change handling in various cell selection states,
                   if scan type is DCH->FACH. If CSP is waiting on a confirmation
                   it will start processing the STATE_CHANGE_IND only after the
                   confirmation has been received.
01/29/04   bu      For a GTOW reselection if the LAI is forbidden, fill the
                   LAI information and the failure reason in the reselection
                   reject sent to RR.
01/21/04   bu      Clear the num forbidden LAIs in rrc_init_cell_selection_procedure().
01/08/04   bu      Small change to resolve singlemode compilation issue.
12/16/03   bu      Set the curr_scan type to RRC_CSP_CELL_SELECTION_SCAN when
                   trying acquisition on the second best cell on the same frequency.
           bu      Added check to ignore Inter-frequency cell reselection if
                   RCE is active. Added a function that can be called to find out
                   if an inter-frequency cell reselection is in progress.
           bu      Added GSM quadband support.
12/10/03   bu      Added support for Inter-RAT cell reselection in CELL_FACH.
11/21/03   bu      Changed acq_mode fro L1_WCDMA_FULL to L1_WCDMA_INTER_S_HO_ACQ
                   for GTOW reselection so that L1 does list search instead of
                   STEP 1/2/3.
10/21/03   kc      Append START values to DEACT_CNF to write back latest START
                   for each domain during an abnormal call release.
10/29/03   bu      Added support to check if the BCCH PLMN is an equivalent
                   PLMN while selecting/re-selecting a cell. Changes are under
                   FEATURE_EPLMN. Set the status_mask of the acquisition entry to 0
                   while adding it to the acqusition database after a GTOW handover.
10/8/03    bu      Removed setting of wcdma_cell_squalmin and wcdma_cell_srxlevmin
                   based on the cell selection confirmation from L1. These values
                   are now set while sending the CPHY_CELL_PARM_REQ to L1.
07/24/03   vn      Selectively use a new function call rrc_ccm_update_with_cell_loss
                   to update CCM with LOSS OF CELL in place of a command I/F.
                   This closes the window for race conditions.
07/17/03   bu      Changed the way rrc_cmd_type is casted to rr_cmd_type for
                   INTERRAT_RESELECTION_REQ & INTERRAT_RESELECTION_REJ commands
                   received from RR.
07/16/03   bu      Ignore cell reselection indication if we are already in process of
                   transitioning to a new cell.
07/11/03   bu      Add the acquisition entry to the acquisition database
                   while doing re-selection only if it has met the expectations.
07/01/03   bu      Added feature definition for RRC_INTERRAT_RESELECTION_REQ case
                   in rrccsp_no_cell_selected_hdlr.
06/24/03   bu      Removed lint errors.
06/20/03   bu      Added appropriate dualmode definitions to resolve
                   singlemode compilation issues.
06/06/03   bu      Added additional check in rrccsp_cell_sel_wait_sib_sib() so that
                   if CPHY_ACQ_REQ is sent to L1 for the next best cell, UE doesn't
                   continue cell selection process on the previous cell and doesn't
                   move to the next frequency.
06/04/03   bu      Added support for acquiring the second best cell when the strongest
                   cell is barred. All changes are under
                   FEATURE_BARRED_CELL_DURING_CELL_SELECTION.
05/23/03   bu      Added support to handle RRC_MODE_CHANGE_REQ from MM and send
                   RRC_MODE_CHANGE_CNF to MM after lower layers have been stopped.
05/05/03   bu      Added support for EVENT_WCDMA_CELL_SELECTED. This event will be
                   reported whenever the UE camps on a WCDMA cell.
04/24/03   bu      Removed usage of FEATURE_L1_ACT_TIME. Activation time will be
                   initialized in the l1_cmd_hdr_type. Fixed lint errors.
04/22/03   bu      Added support for handling PLMN_LIST_REQ properly if CSP is
                   waiting on a confirmation for a previously sent request. CSP
                   goes to a pending state, waits for the confirmation and once
                   it is received will start processing the PLMN_LIST_REQ.
04/18/03   bu      Added new state to wait for the LOWER_LAYER_DEACT_CNF once a
                   RRC_DEACT_REQ is received. Once that confirm is received send
                   DEACT_CNF to MM and go to NO_CELL_SELECTED state.
04/17/03   bu      Code review changes.
04/11/03   bu      Added support for logging EVENT_WCDMA_TO_GSM_RESELECTION_START and
                   EVENT_WCDMA_TO_GSM_RESELECTION_END.
04/10/03   vn      Provided a function rrccsp_init_measurements_in_l1_on_cphy_idle
                   that indicates if Measurement Criteria in L1 is to be initialized
                   on a CPHY_IDLE_REQ. Removed call to rrcmeas_save_intra_freq_meas
                   as that has been moved to RRCLLC. On successful camping on a cell
                   due to a DCH to FACH scan, reset curr_scan to CELL_SELECTION_SCAN
04/10/03   bu      Fill in the deact_reason while sending LOWER_LAYER_DEACT_REQ
                   to LLC.
03/28/03   vk      Invoked fn rrcmeas_save_intra_freq_meas(..) to indicate to L1
                   to save intra-freq measurement reporting criteria for directed
                   cell
03/21/03   bu      Set the plmn_type based on the any_cell_selection_mode boolean
                   in the INTERRAT_RESELECTION_REQ received from RR. Removed the
                   checks in rrccsp_cell_sel_wait_sib_sib() based on
                   any_cell_selection_mode.
03/18/03   vn      Substituted calls to rrccsp_accept_cell_out_of_service_ind
                   with rrccsp_handle_out_of_service_ind.
03/17/03   vn      Added code to handle RB0 setup failure and Redirect Req when
                   waiting for SIBs or for Cell Change Confirm while a reselection
                   is in progress and UE is camped on suitable or acceptable cell.
                   Handling of OOS while in one of the Reselection substates is
                   not added as an ongoing cell reselection should be allowed to
                   complete so that it prevents an impending OOS condition.
03/12/03   bu      Added a function to reset the reselection data. This function
                   will be called from various re-selection sub-states.Corrected
                   the comparisons of frequency and scrambling code when a
                   CPHY_CELL_RESELECTION_IND is received from L1. Added separate
                   handlers for RESUME and SUSPEND mode confirmations for both
                   suitable and acceptable cells.
03/04/03   vn      Fixed an issue where CSP sub-state was being incorrectly set
                   during processing of cell reselection in acceptable cell.
02/18/03   vn      Added processing across CSP substates to process a DCH to FACH
                   Timer expiry event by updating the "pending_type" flag in
                   local internal CSP data. On receiving the response, the pending
                   commnd (Service Req or Timer Expiry) is processed. Added
                   initialization of destination freq and psc on state change to DCH.
02/14/03   kc      Changed feature defn from INTERRAT_HANDOVER_GTOW_RRC to
                   INTERRAT_HANDOVER_GTOW
02/14/03   bu      Removed the setting of PLMN Id when RRC_CSP_ACQ_REQ is received.
02/14/03   bu      Added support to handle RRC_CSP_ACQ_REQ from the handover procedure
                   while doing a GSM to WCDMA handover. Added a new state
                   RRCCSP_CELL_SEL_WT_HANDOVER_ACQ and corresponding handler function.
                   CSP will send RRC_CSP_ACQ_CNF back to handover procedure. If the
                   acquisition was successful CSP state will be set to
                   RRCCSP_CAMPED_SUIT_CELL otherwise to RRCCSP_NO_CELL_SELECTED.
                   Added rrccsp_update_plmn_info_for_gtow_handover() to update the
                   CSP internal data once the UE goes to DCH successfully. All
                   changes are under FEATURE_INTERRAT_HANDOVER_GTOW.
02/05/03   bu      Initialize the current scan type to RRC_CSP_CELL_SELECTION_SCAN
                   on a failure in RRCCSP_CELL_SEL_WT_SIB, RRCCSP_SUIT_CELL_SEL_WT_SERV_S,
                   RRCCSP_SUIT_CELL_SEL_WT_CAMP, RRCCSP_SUIT_CELL_RESELECT_WT_CAMP
                   and corresponding states for an acceptable cell. Set the current
                   scan type to RRC_CSP_CELL_RESELECTION_SCAN before sending the
                   CELL_CHANGE_REQ to CCM.
           bu      Added handling of State change indication while waiting
                   for SIBS_CNF during cell reselection.
01/28/03   bu      Made the required lint changes.
12/09/02   bu      Added new state handlers to wait for the Activation Rsp from MM after
                   sending the ACTIVATION_IND for both suitable and acceptable cell
                   camping for GSM to WCDMA cell reselection. On receiving the Activation
                   Rsp, Service indication is sent to MM. Store the PLMN Id received in
                   the cell reselection indication from RR in current requested PLMN
                   instead of the current acquisition entry.
12/04/02   bu      Some more changes related to L1-RRC interface changes. Corrected
                   a typo while converting the NAS PLMN Id to RRC PLMN Id.
11/19/02   vn      Added conditional handling of Intra frequency cell reselection
                   when FEATURE_RRC_FDD_CELL_RESEL_IN_FACH is not defined. Added checks
                   to not handle an incmoing Cell Reselection trigger from L1 if
                   RRC Connection Setup procedure is already active or if RRC state
                   is not Disconnected. Added code to disable "Cell camping" status
                   during cell reselection process to prevent going to Connecting
                   state during cell reselection. Between Reselection and Origination
                   whosoever comes first - wins.
11/20/02   bu      Convert NAS PLMN Id to RRC PLMN Id and store it in the current
                   acquisition entry when a INTERRAT_RESELECTION_REQ is received
                   from RR.
11/19/02   bu      Added support for manual PLMN selection. On receiving
                   PLMN_LIST_REQ from MM, scan the entire frequency
                   band for the available PLMNs. Send the list to MM in
                   PLMN_LIST_CNF. CSP goes go back to NO_CELL_SELECTED
                   and waits for MM to initiate a SERVICE_REQ. Added a new function
                   rrccsp_teardown_serving_cell_bch() to teardown the serving cell BCH
                   and inform SIB procedure about it.
11/18/02   vn      Handle cell selection on RB0 setup failure. For the time being
                   treat it as an Out of Service Area.
11/15/02   bu      Support for L1-RRC interface changes. Use the union for
                   cell reselection information in l1_cell_reselec_ind_type.
10/30/02   bu      Changed the reference from interrat_reselect_req to
                   interrat_reselection_req for RRC_INTERRAT_RESELECTION_REQ.
10/11/02   bu      Support for GSM to WCDMA cell reselection. Once a reselection
                   request is received from GSM RR, we try to acquire the cell
                   on the specified frequency and then proceed with the cell
                   selection process. If a failure happens at any point, the WCDMA
                   mode is stopped and a cell reselection reject is sent to RR.
                   Once the WCDMA cell is camped on, an activation indication is
                   sent to MM. All changes are under FEATURE_INTERRAT_CELL_RESELECTION_GTOW.
09/22/02   vn      Support for DCH->FACH transition: Added processing for
                   handling Initiate Cell Selection Req with a cause:
                   transitioning from CELL_DCH to CELL_FACH. Added new function
                   rrccsp_camped_suit_cell_state_transition_from_dch.
                   Do not initialize Acq Database on RRC_MODE_CHANGE_IND. This is
                   so that Acq database could be utilized on coming back to WCDMA mode.
09/26/02   xfg     Initialized RRC CSP Acquisition Database when RRC_MODE_CHANGE_IND
                   is received.
09/25/02   bu      Save the GSM information in the rrc_csp_int_data. Once we have
                   successfully SUSPENDED the WCDMA mode, send this information to RR.
                   Ignore the GSM cell reselection indications while processing
                   an existing WCDMA cell reselection indication.
09/25/03   bu      Added a break for the case when a cell reselection indication
                   is received in rrccsp_camped_suit_cell_hdlr() and
                   FEATURE_INTERRAT CELL RESELECTION WTOG is defined.
09/20/02   bu      Added support for cell reselection in CELL_FACH state when
                   the UE is camped on an acceptable cell.
           bu      Added support for cell reselection in CELL_FACH state. If
                   ordered config is set for CELL_DCH or if the current state is
                   CELL_DCH, CSP will reset all the reselection related variables.
                   Added support to handle STATE_CHANGE_IND to CELL_DCH or IDLE. On a
                   state change to CELL_DCH, CSP shall abort ongoing reselection and set
                   it's state back to the original state. Added handling of various
                   failure status enums in CELL_CHANGE_CNF and GET_SPECIFIC_SIBS_CNF.
09/19/02   vn      Send a DRX command when a CELL_CHANGE_REQ is recd with Success
                   while waiting for one during Cell selection or reselection.
09/17/02   bu      Changes to support the new l1_gsm_cell_resel_ind_info_type
                   in l1_cell_reselec_ind_type.
09/16/02   bu      Added support for Inter-RAT cell reselection. If a cell
                   reselection indication for a GSM cell is received from L1, CSP
                   sends a reselection request to GSM RR and sends mode change request
                   (SUSPEND) to MCM and waits for the WCDMA mode to be suspended.
                   CSP also handles the Inter-RAT reselect rejection from RR. It
                   sends the mode change request (RESUME) to MCM and waits for the
                   confirm. All the changes have been made under
                   FEATURE_INTERRAT CELL RESELECTION WTOG feature.
08/02/02   bu      Added new states to accept a Service Request from MM in all
                   the CSP sub-states. If a confirmation from SIB or CCM is pending,
                   it is waited before initiating cell selection due to new
                   Service Req. Print an error if the SERVICE_REQ is received in any
                   state other than DISCONNECTED state.
07/19/02   bu      Added DUALMODE support to take CSP back to NO_CELL_SELECTED when a
                   MODE_CHANGE_IND (to RRC_MODE_INACTIVE) is received. The entities in
                   RRC CSP Internal data structure are also cleared.
06/19/02   bu      Removed the sending of ACT_CNF to MM for DUALMODE in
                   rrccsp_no_cell_selected_hdlr().
06/14/02   vn      Call rrccsp_update_plmn_list to update available PLMN list
                   when SIBs are received on a cell.
06/14/02   bu      Added DUALMODE support to update the forbidden lai list in the
                   csp internal data when RRC_FORBIDDEN_LAI_LIST_UPDATE_REQ is received.
                   Removed the processing of SIB_CHANGE_IND in CELL_SEL_WAIT_SIB state.
06/03/02   bu      Added support for RRC_SIB_CHANGE_IND in various states.
                   Added function rrccsp_update_sib1_data to update SIB1 information.
                   Added function rrccsp_send_l1_drx_req to send the CPHY_DRX_REQ to L1.
05/16/02   bu      Fixed a merge mismatch.
05/16/02   bu      Merged the following from cell reselection branch:
           bu      Added support to teardown the N-BCH pipe before sending the cell
                   transition request with failure to L1. Route the cell transition
                   request through LLC instead of directly sending it to L1.
           bu      Changed the pri_scr_code to scr_code in the serving_pccpch_parms
                   and transition request. Clear the new_acq_entry after the cell
                   reselection succeeds/fails. If cell reselection indication is rxed
                   in RRCCSP_SUIT_CELL_RESELECT_WT_SIB or
                   RRCCSP_ACCEPT_CELL_RESELECT_WT_SIB substate ignore it.
           bu      Added rrccsp_send_transition_failure(). Modified the
                   rrccsp_camped_suit_cell_reselection_ind() and
                   rrccsp_camped_accept_cell_reselection_ind() to take the rrc_cmd_type
                   as input. Now we get all the SIBs using GET_SPECIFIC_SIBS_REQ.
                   Notify SIB procedure by calling rrcsib_change_serving_cell_status()
                   after sending a transition failure to L1. More changes for
                   evaluating whether the cell is suitable or acceptable.
05/13/02   bu      Added support for RRC_PLMN_LIST_REQ and sending
                   RRC_PLMN_LIST_CNF to MM. These changes have been added with
                   FEATURE DUALMODE BASELINE tag.
04/15/02   bu      Removed the usage and maintainence of candidate and rank lists.
                   Added support for the new l1_cell_select_cmd_type and
                   l1_cell_select_cnf_type structures. Removed CSP sub-states
                   RRCCSP_SUIT_CELL_SEL_WT_NEIGH_S and RRCCSP_SUIT_CELL_SEL_WT_NEIGH_SIB.
                   Removed handlers and functions related to the same. Removed
                   rrccsp_no_cell_act_req() as it's not being used.Removed the usage
                   of rrc_csp_util_parm_ptr_u_type in various functions.
03/13/02   vn      Added limited processing for RRC_INITIATE_CELL_SELECTION_IND
                   only for Out of Service Area. At present, CSP always takes
                   RRC TO Idle Disconnected state.
12/12/01   bu      Added support for cell reselection. Added handlers for
                   RRCCSP_SUIT_CELL_RESELECT_WT_SIB, RRCCSP_ACCEPT_CELL_RESELECT_WT_SIB,
                   RRCCSP_SUIT_CELL_RESELECT_WT_CAMP and RRCCSP_ACCEPT_CELL_RESELECT_WT_CAMP
                   states of CSP. Cell reselection indication is handled only in the cell
                   camped state. Multiple cell reselection indications are also handled.
                   After a cell reselection is handled, CSP processes any pending
                   cell reselection indication.
11/01/01   vn      Call new PLMN matching functions to compare NAS and BCCH PLMNs
                   when SIBs from the newly acquired cell are received.
10/25/01   bu      Added support for handling the DEACT_REQ from MM. On
                   receiving the DEACT_REQ CSP sends RRC_LOWER_LAYER_DEACT_REQ
                   to LLC and waits for the RRC_LOWER_LAYER_DEACT_CNF. On
                   receiving the confirm from LLC, CSP sends the DEACT_CNF to MM.
10/25/01   vn      Call rrc_csp_start_sel_out_of_service_area_in_idle_state when
                   Out of Service Area happens in Idle state. Added debug messages
                   to indicate start or continuation of cell selection.
10/22/01   vn      Support for Out of Service Area in camped states. Added scan
                   type to the state machine implementation to determine action
                   on lower layer channels. Added last MM primitive to keep track
                   of last primitive exchanged with MM. last MM primitives are
                   updated here on receiving a new MM command. Added new states
                   to accept a Service Request from MM in all states other than
                   the camped on state. If a confirmation from LLC or SIB is pending,
                   it is waited before initiating cell selection due to new
                   Service Req. new utilities in csputil.c used for starting and
                   continuing cell selection due to various triggers.
10/12/01   vn      If no cell could be acquired after a complete scan, continue
                   scanning forever. Added smarts at the end of each scan to
                   determine which command needs to be sent to MM or if no command
                   is needed.
09/26/01   vn      If going to try acquisition/frequency scan after establishing
                   any channels (BCCH/PCCH), release all channels and initialize
                   lower layers before sending an Acq/Freq scan request.
                   Call  rrc_csp_start_sel_leaving_conn_mode to start cell
                   selection on leaving connected mode.
09/17/01   vn      Added partial LAI_LIST_REQ support in all CSP states
                   LAI_LIST_REQ does not change state or disrupt any ongoing
                   processing by CSP.
08/31/01   vn      Support for frequency scan. Added new CSP substate
                   RRCCSP_CELL_SEL_WT_FREQ_SCAN_CNF for the frequency scan. On
                   receiving a CPHY_FREQ_SCAN_CNF, the internal scan data is
                   updated and the next freq. and scan are picked from Initail
                   Selection Controller.
08/08/01   vn      Changed rrc_csp_cell_access_e_type to
                   rrc_csp_access_control_e_type to avoid confusion with similar types.
08/06/01   vn      Added partial support for RRC_REDIRECT_REQ.
07/06/01   vn      Send a Cell Change Request with a RRC_CELL_LOSS_NO_NEW_CELL
                   status on a state change indication to IDLE_DISCONNECTED when
                   camped on a suitable or acceptable cell. This is to change the
                   camped status in CCM till a new cell is selected again.
06/25/01   vn      Before calling rrc_csp_fill_acq_entry_from_sib, added a check
                   to verify that the frequency and scrambling code returned by
                   SIB in confirmation are the same as was passed in the request.
06/13/01   vn      Added capability to do cell selection on entering
                   Idle-disconnected state from connected state. Added functions
                   rrccsp_camped_suit_cell_handler and
                   rrccsp_camped_accept_cell_handler to handle State Change Ind in
                   RRCCSP_CAMPED_SUIT_CELL and RRCCSP_CAMPED_ACCEPT_CELL states.
                   Added a macro RRC_CSP_SELECT_MM_CMD to decide between RRC_SERVICE
                   _IND and RRC_SERVICE_CNF.
06/06/01   vn      Update serving cell PCCPCH parameters in internal data on
                   receiving a CPHY_ACQ_CNF with a "Success".
05/16/01   vn      Send an RRC_ACT_CNF with "No Service" on receiving a RRC_ACT_REQ.
                   Updated to work with the new rrc_plmn_id_type.
05/09/01   vn      Store initial UE IDs from Service Request message to RRC
                   global data.
03/20/01   vn      Added changes to work with the latest rrcmmif.h (1.14). The
                   changes here are due to changes in RRC_SERVICE_REQ, RRC_SERVICE_CNF
                   and RRC_SERVICE_IND command data structures in rrcmmif.h.
                   References to forbidden RAI lists have also been removed.
03/19/01   vn      Send RRC RESET REQ to LLC before a new CPHY_ACQ_REQ.
03/16/01   vn      Changes for simplified cell selection: When original cell found,
                   no need to check neighbors for strongest cell - camp on the
                   original cell straightway.
03/02/01   vn      Fixed a bug: Candidate list was not being filled before being
                   used while sending CPHY_CELL_SELECTION_REQ. Changed to not send
                   GET_SPECIFIC_SIBS more than once if original cell has no neighbors.
02/20/01   vn      Fixed some unit test bugs: In rrccsp_suit_cell_sel_wait_sib_sib
                   do not send ACQ REQ if no frequency found.
                   Added more debug messages.
02/08/01   vn      Added code to work for Acceptable Cell Selection to support
                   "Any PLMN" request from MM.
02/06/01   vn      Updated to new names given to L1 cmds by LLC.
01/26/01   vn      Updates to work with LLC command funneling scheme.
01/22/01   vn      Changed messages for better understanding. Added a check to
                   verify the freq acquired by L1 is the same as it was asked to.
                   Corrected errors captured in Unit Testing. Changes related to
                   split of rrc_csp_stored_initial_select_ctrl to a Start and
                   Continue version.
01/18/01   vn      Expanded the state machine to include all states and processing
                   till a cell is selected for Camping. Incorporated calls to CSP
                   utilities to evaluate, search and store cells and to send to
                   and process commands from L1, SIB and MM and CCM.
12/21/00   vn      Added an internal data structure that holds data relevant to
                   CSP at all times. Added initialization of Internal data, Acq
                   Database and Selection data.
12/19/00   vn      Changed name of Get All SIB Cmd as is in rrccmd.h
12/07/00   vn      Updated to work with rrc_cmd_type which is a uniform cmd type
                   for cmds coming from all sources.
12/01/00   kmp/vn  Removed compiler errors/warnings.
12/01/00   vn      Changes as per ver 0.5 of "Usage of Cmd queues" doc.
12/01/00   vn      Migration to REX++, changed events to commands.
11/14/00   kmp     Removed extra zrex stuff to get rid of compiler warnings.
11/08/00   kmp     Updated to include l1rrcevents.h
10/31/00   vn      Modifiactions for compilation errors.
10/26/00   vn      Created file.

===========================================================================*/


/* ==========================================================================
** Includes and Variable Definitions
** ========================================================================*/


/* -----------------------------------------------------------------------
** Include Files
** ----------------------------------------------------------------------- */

#include "wcdma_variation.h"
#include "comdef.h"
#include "rex.h"
#include "msg.h"
#include "err.h"
#include "ttl_map.h"

#include "l1task_v.h"
#include "l1rrcif.h"
#include "rrccmd_v.h"
#include "rrcmmif.h"
#include "rrcscmgr.h"

#include "rrccsp.h"
#include "rrccspi.h"
#include "rrccspdb.h"
#include "rrcsibproc.h"

#include "rrccmdi.h"
#include "mmtask.h" /* To send the DEACT_CNF */
#ifdef FEATURE_CMI
#include "mmtask_v.h"
#endif
#include "rrcllc.h"
#include "rrcsibdb.h"
#include "event.h"
#include "rrclogging.h"
#include "rrcsmc.h"
#include "rrcdata_v.h"

#include "mm_umts.h"
#include "rr_rrc_if.h"
#include "rrc_rr_types.h"

#include "rrcccm.h"
#include "rrcrce.h"
#include "rrctmr.h"
#include "rrcmcm.h"
#include "rrccho.h"
#include "rrccu.h"

#include "sys_eplmn_list.h"

#ifdef FEATURE_EQUIVALENT_HPLMN
  #include "reg_sim.h"
#endif

#include "rrcrbcommon.h"

#if defined FEATURE_CGPS
#include "rrclsmif.h"
#endif
#include "cmwll.h"
#include "rrcmeas.h"
#include "rrcmeasi.h"

#ifdef FEATURE_WRLF_SYSTEM_SEL
#include "rrcmisc.h"
#endif

#if defined(FEATURE_WCDMA_TO_LTE) || defined (FEATURE_LTE_TO_WCDMA)
#include <lte_rrc_ext_api.h>
#endif
#ifdef FEATURE_DUAL_SIM
#include "rrcrcr.h"
#include "sm.h"
#include "rrclcm.h"
#include "rrcwrm.h"
#include "rrclbt.h"
#include "rrcllcoc.h"
#include "sys.h"
#include "cm.h"
#endif

#include "rrcnv.h"
#ifdef FEATURE_WCDMA_FREE_FLOATING_TASK
#include "rrcfreefloating.h"
#endif

#ifdef FEATURE_WCDMA_TO_TDSCDMA
#include "tdsrrc_rrc_if.h"
#endif

#ifdef FEATURE_TDSCDMA_TO_WCDMA
#include "rrc_tdsrrc_if.h"
#endif
#include "rrcdata.h"
#ifdef TEST_FRAMEWORK
#error code not present
#endif

/* -----------------------------------------------------------------------
** Constant / Define Declarations
** ----------------------------------------------------------------------- */
#ifdef FEATURE_DUAL_SIM
  /* This is to allow L1 some additional time to wake up if it has slept previuosuly.
   * Needed only for the first time in every DRX when lock could not be extended
   */
  boolean rrc_add_l1_wakeup_time = FALSE;
  /* This is needed to ensure that DRX timer expiry that happens for the second time is handled
   * rrc_drx_exp_when_wtng_for_mib will be set to TRUE if DRX timer expires while waiting for MIB
   * and the timer will be restarted with the remaining overhead. This is needed as the overhead
   * is different while waiting for ACQ and while waiting for SIB
   */
  boolean rrc_drx_exp_when_wtng_for_mib = FALSE;
  boolean DS_Immediate_preempt_waiting_for_init_cell_sel = FALSE;
  boolean DS_Tuneaway_for_Immediate_preempt = TRUE;
  extern rrc_ds_tuneaway_status_change_ind_type ds_tuneaway_status_change_ind;
#endif
extern sys_specialization_t  search_order_specialization;
extern boolean    nv_gcf_test_flag;

#ifdef FEATURE_UMTS_1X_HANDOVER_UMTSMSM
  #error code not present
#endif

/* Global HSDPA HSUPA Indicator */
extern sys_hs_ind_e_type hsdpa_hsupa_ind;

extern boolean rrc_high_mobility_ind_in_rcr;

#ifdef FEATURE_3GPP_CSFB
boolean rrc_csfb_call_status = FALSE;
#ifdef FEATURE_WCDMA_CSFB_CALL_OPT
boolean rrc_csfb_reset_while_waiting_for_act_rsp = FALSE;
#endif
#endif
extern boolean rrc_ifreq_rdr_in_prgrs;
#ifdef FEATURE_QCHAT
#include "rrc_qchatupk.h"
#endif /* FEATURE_QCHAT */

/* Indicates if BST band preference has valid information or not */
boolean rrc_bst_band_pref_incl = FALSE;
#ifdef FEATURE_DUAL_SIM
sys_modem_device_mode_e_type   wcdma_device_mode = SYS_MODEM_DEVICE_MODE_SINGLE_SIM;

/* As per systems recommendation, GSM lock for RACH can withstand a delay of 1 second
   A counter is maintained to keep track of the "preemption delayed" and start allowing 
   preemption if the count hits 7*/
uint8 rrc_delay_preempt_counter = 0;
#define MAX_DELAY_PREEMPTION_COUNT 7

/*Duration is ms to introduce holes in SIB mask*/
#define G_PAGE_HOLES 80

#endif
#define RRC_GSM_INFO_OCTET_COUNT_ABSENT 0

#define RRCTMR_WAIT_STATE_CHANGE_EF_IN_MS 5000

/* -----------------------------------------------------------------------
** Type Declarations
** ----------------------------------------------------------------------- */

/*===========================================================================
**                  ENUMERATED TYPES
**=========================================================================*/


/* -----------------------------------------------------------------------
** Global Constant Data Declarations
** ----------------------------------------------------------------------- */

/* -----------------------------------------------------------------------
** Global Data Declarations
** ----------------------------------------------------------------------- */

/* RRC CSP Global data, visible only to CSP */
rrc_csp_int_data_type  rrc_csp_int_data;

/* RRC CSP Global data for WTOG BPLMN search */
rrc_csp_wtog_bplmn_int_data_type rrc_csp_wtog_bplmn_int_data;

boolean bplmn_data_saved = FALSE;

/* Stores the value of rrc_csp_int_data.bplmn_new_srch while 
 * moving to connected mode with BPLMN in progress 
 */
boolean bplmn_new_srch = TRUE;

#ifdef FEATURE_FEMTO_CSG
boolean bplmn_cell_found_in_drx = FALSE;
#endif

boolean rrccsp_inter_freq_cell_resel_in_progress = FALSE;

/*Stores cell_id for each RL given in OTA msg*/
uint32  cell_id_per_rl[L1_MAX_RL];     

/*Stored the previous cell_id that was sent to registered entites.*/
uint32  prev_cell_id = INVALID_CELL_ID; 

/*Flag is set when we have LAC given in OTA in Cell_DCH state.*/
boolean lac_in_ota_present = FALSE; 

/*Stores LAC provided in OTA*/
uint8  lac_in_ota[RRC_MAX_GSMMAP_LAC_LENGTH]; 

/*Flag is set when we have RAC given in OTA in Cell_DCH state.*/
boolean rac_in_ota_present = FALSE; 

/*Stores RAC provided in OTA*/
uint8  rac_in_ota[RRC_MAX_GSMMAP_RAC_LENGTH]; 

/* pointer to callback func for cell id change notification */
RRC_SERVING_CELL_CHANGE_IND_CB_FUNC_TYPE *rrc_serving_cell_change_ind_cb_func[MAX_NUM_OF_REG_CB];

extern rrc_plmn_list_req_type *rrc_svd_plmn_req_ptr;

extern RRC_HOME_ZONE_IND_CB_TYPE *rrc_home_zone_ind_cb_func;

extern cell_info_type cell_id_dch_info;

#ifdef FEATURE_LTE_TO_WCDMA
extern boolean rrc_handle_deprio_req_pending ;
#endif

#ifdef FEATURE_GAN
#error code not present
#endif

#ifdef FEATURE_DUAL_SIM
boolean dsim_bplmn_search_complete_w_cycle = FALSE;
#else
boolean dsim_bplmn_search_complete_w_cycle = TRUE;
#endif

#ifdef FEATURE_3GPP_CSFB
rrc_System_Information_Container_list_type rrc_SIB_container;
#endif

#ifdef FEATURE_WCDMA_HANDLE_MDSP_HALT
extern rrcmcm_activation_cause rrcmcm_act_cause;
#endif

#ifdef FEATURE_WCDMA_FAST_RETURN_TO_LTE_AFTER_CSFB 
extern rrcrce_csfb_status_e_type csfb_extended_status;
#endif

extern uint32 wcdma_rrc_bplmn_freq_scan_timer_nv;

uint32 xtow_bplmn_search_overhead_timer;
/* -----------------------------------------------------------------------
** Local Object Definitions
** ----------------------------------------------------------------------- */

/* Stores the substate of RRC CSP procedure */
LOCAL  rrc_csp_substate_e_type  rrc_csp_substate;

#ifdef FEATURE_LTE_TO_WCDMA
LOCAL  boolean  fast_redirection = TRUE;
#endif

#ifdef FEATURE_BPLMN_SEARCH_320MS
LOCAL boolean wcdma_resume_failed = FALSE;
#endif

#ifdef FEATURE_TRIPLE_SIM
boolean rrc_is_tsts_mode_enabled;
#endif

extern boolean rrcrce_send_abort_cnf;

extern rrc_csp_acq_entry_type list_db[MAX_ACQ_DB_ENTRIES];

/*===========================================================================
** -----------------------------------------------------------------------
** Forward Declarations
** ----------------------------------------------------------------------- */



/*===========================================================================
** -----------------------------------------------------------------------------------
**-- ----------NON-Demand paging section Srart--------------------------------------------
** -----------------------------------------------------------------------------------
  This section will have code section that will not be demand paged. Function which should be in this section are
  -RRC functions that are called by L1/L2 which are higher priority then RRC
  -RRC functions that are called in ISR context or RTOS timer call back
  -RRC functions that indirectly gets called by L1/L2 /ISR/timer call back   
  For example: Fun1() gets called by L1. Fun2() is called by Fun1(). Now both  Fun1() & Fun2() should be NON demand paged, 
  so both should be added in this section  
  Usage of pragma 
  __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED__
  void foo(void)
  {
    function body here
  }
        __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED_END__
  If you have another function to be added in the same section then again it needs to be wrapped with these pragma 
  for example:- function bar() is just below function foo() then function bar() needs to be written like this …. 
  __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED__
  void bar(void)
  {
    function body here
  }
  __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED_END__
** ----------------------------------------------------------------------- */


/*===========================================================================


FUNCTION   RRCCSP_SEND_BPLMN_SRCH_RESUME_IND

DESCRIPTION

  This function is used by CSP to send itself an internal command
  RRC_BPLMN_SEARCH_IND after L1 calls the function can_l1_go_to_sleep()
  when it determines that BPLMN search can be performed
  
DEPENDENCIES

  None.
 
RETURN VALUE

  None.

SIDE EFFECTS

  None.

===========================================================================*/
/***/ __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED__ /***/
void rrccsp_send_bplmn_srch_resume_ind(void)
{
  rrc_cmd_type *cmd_ptr;

  /* Get a RRC internal command buffer */
  if((cmd_ptr = rrc_get_int_cmd_buf()) != NULL)
  {
  /* Fill in the command id  */
    cmd_ptr->cmd_hdr.cmd_id = RRC_BPLMN_SEARCH_RESUME_IND;

  /* Put the command on the internal queue */
    rrc_put_int_cmd( cmd_ptr );
  }
} /* end of rrccsp_send_bplmn_srch_resume_ind */
/***/ __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED_END__ /***/

/*===========================================================================

FUNCTION   RRC_CSP_RESTORE_SAVED_BPLMN_DATA

DESCRIPTION
  This function is used to restore the saved 
  data for BPLMN operation

DEPENDENCIES

  None.
 
RETURN VALUE

  None.
 
SIDE EFFECTS

  None.

===========================================================================*/
/***/ __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED__ /***/
void rrc_csp_restore_saved_bplmn_data(void)
{
  WRRC_MSG0_HIGH("BPLMN: Saved data for BPLMN is restored");
  rrc_csp_curr_select_data = prev_rrc_csp_curr_select_data;
  rrc_csp_int_data.bplmn_new_srch = bplmn_new_srch;
}
/***/ __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED_END__ /***/

/*===========================================================================

FUNCTION          RRC_CAN_L1_GO_TO_SLEEP

DESCRIPTION       This function is called by L1 in every DRX cycle to determine
                  if L1 should go to sleep or not. This function call was 
                  introduced due to WTOW and WTOG BPLMN search. If WTOW search needs to be
                  done during the DRX sleep time, then L1 should NOT go to sleep. Else
                  if WTOG search needs to be done then L1 should go to sleep.

DEPENDENCIES      NONE

RETURN VALUE      
                  TRUE:  L1 can go to sleep.
                  FALSE: Otherwise
                                  
SIDE EFFECTS

===========================================================================*/
/***/ __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED__ /***/

boolean rrc_can_l1_go_to_sleep
(
  uint32 timer_val,
  boolean *wtog_bplmn_in_progress
#ifdef FEATURE_DUAL_SIM
  ,boolean *wtow_bplmn_in_progress
#endif
)
{
  boolean status = TRUE;
#ifdef FEATURE_BPLMN_SEARCH_320MS
uint16 bplmn_curr_sfn;
#endif
  rrc_state_e_type rrc_state = rrc_get_state();

  uint32 addtnl_over_head = 0;

#ifdef FEATURE_DUAL_SIM
  uecomdef_status_e_type can_lock_be_acquired = FAILURE;
*wtow_bplmn_in_progress = FALSE;
#endif

#ifdef FEATURE_BPLMN_SEARCH_320MS
  bplmn_curr_sfn= seq_get_sfn() ;
  WRRC_MSG2_HIGH("WTOW: BPLMN start SFN: %d, curr SFN: %d",
       rrc_csp_int_data.bplmn_start_sfn,bplmn_curr_sfn); 
#endif

  WRRC_MSG2_HIGH("Can L1 go to sleep fn called by L1 with tmr %d in RRC st %d", timer_val, rrc_state);

  *wtog_bplmn_in_progress = FALSE;

#ifdef FEATURE_DUAL_SIM
  /* As per systems, automatic BPLMN should be aborted when in G2W TA mode */
  if(WRM_G2W_TA_MODE_ACTIVE())
  {
    /* If BPLMN is active, abort the PLMN search */
    if((rrc_csp_int_data.bplmn_nw_sel_mode == SYS_NETWORK_SELECTION_MODE_AUTOMATIC)&&
       (WTOW_SEARCH_STOP != rrc_csp_bplmn_srch_in_progress())
      )
    {
      /* Cleanup BPLMN */
      rrccsp_cleanup_bplmn_state();
    }
    return TRUE;    
  }  
#endif

#ifdef FEATURE_BPLMN_SEARCH_320MS
  if (rrc_csp_check_320ms_bplmn())
  {
    if ((rrc_csp_int_data.bplmn_start_sfn != 0) && 
        (rrc_sub_sfn(bplmn_curr_sfn , rrc_csp_int_data.bplmn_start_sfn ) < (MIN_WTOW_NORMAL_BPLMN_DRX_CYCLE_LEN - 4) ))
    {
      MSG_HIGH("WTOW: Duplicate call for l1 goto sleep prev sfn %d, curr sfn %d, DRX  %d",
             rrc_csp_int_data.bplmn_start_sfn,bplmn_curr_sfn,rrcllc_get_drx_info());
    }
    else
    {
      timer_val += ((MIN_WTOW_NORMAL_BPLMN_DRX_CYCLE_LEN - rrcllc_get_drx_info())*10);
      WRRC_MSG1_HIGH("WTOW: Adding %d ms to the L1 given time",
         ((MIN_WTOW_NORMAL_BPLMN_DRX_CYCLE_LEN - rrcllc_get_drx_info())*10));
    }
  }
#endif

  if((rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
     || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN)
    )
  {
    WRRC_MSG2_HIGH("curr_scan %d, prev_curr_scan %d", 
                rrc_csp_int_data.curr_scan, rrc_csp_int_data.prev_curr_scan);

#ifdef FEATURE_DUAL_SIM
    *wtow_bplmn_in_progress = TRUE;
    return FALSE;
#else
    ERR_FATAL("Can L1 go to sleep called when BPLMN is already active", 0,0,0);
#endif
  }
  else if(
           (rrc_csp_int_data.curr_scan == RRC_CSP_WTOG_BPLMN_AUTOMATIC_SCAN) ||
           (rrc_csp_int_data.curr_scan == RRC_CSP_WTOG_BPLMN_MANUAL_SCAN)
         )
  {
    WRRC_MSG2_HIGH("curr_scan %d, prev_curr_scan %d", 
           rrc_csp_int_data.curr_scan, rrc_csp_int_data.prev_curr_scan);
  
#ifdef FEATURE_DUAL_SIM
    *wtog_bplmn_in_progress = TRUE;
    return TRUE;
#else
    ERR_FATAL("Can L1 go to sleep called when BPLMN is already active", 0,0,0);
#endif
   }
  

  if(rrc_csp_int_data.bplmn_crit_sec_flag)
  {
    WRRC_MSG0_ERROR("WTOW ERR: CRITICAL SECTION FLAG IS SET!!!!!!. L1 going to sleep");
  }                                      
  else if(rrc_csp_int_data.bplmn_guard_srch_tmr_expired)
  {
    WRRC_MSG0_HIGH("WTOW BPLMN not in progress. L1 can go to sleep");
  }
  else if(timer_val < MIN_WTOW_BPLMN_SRCH_TIMER_IN_MS)
  {
    WRRC_MSG2_HIGH("tmr val %d rcvd from L1 < min %d reqd", 
                                timer_val, MIN_WTOW_BPLMN_SRCH_TIMER_IN_MS);
  }         
  /* Due to race conditions due to context switching, need
   * to check if RCE is waiting for BPLMN to complete
   */
  else if(rrcrce_is_rce_procedure_waiting_for_bplmn())
  {
    /* for cell_pch/ura_pch RCE may be in FINAL and hence
       * the function call above is not useful. Anyways,
       * RCE sends RRC_BPLMN_ABORT_IND to CSP before becoming active
       */
    WRRC_MSG0_HIGH("WTOW: RCE Procedure is Active");
  }
  else if(rrcsib_is_sib_active() || (sib_change_safe_guard  == TRUE))
  {
    WRRC_MSG0_HIGH("WTOW: Sib Procedure is Active");
  }         
  else if(RRCCU_STARTED == rrccu_get_cell_update_started_status())
  {
    WRRC_MSG0_HIGH("WTOW: Cell Update Procedure is Active");
  }
  /* This case is possible for failed intra/inter-reselections. Here
   * before transition_cnf reaches RRC, L1 can query RRC whether it
   * should go to sleep or not. CSP will receive this query in
   * wait_transition_cnf substate. So it is not an error; but only
   * a race condition. For now, RRC will ask L1 to go to sleep for this case.
   * RRC will reply to L1 to go to sleep only when CSP sstate is CAMPED_SUIT_CELL.
   * We will keep this functionality unless there is a strong case
   * against it.
   */
  else if((rrc_csp_substate != RRCCSP_CAMPED_SUIT_CELL) 
          && (rrc_csp_substate != RRCCSP_CAMPED_ACCEPT_CELL)
          && (rrc_csp_substate != RRCCSP_SUIT_CELL_RESELECT_WT_TRANS_CNF)
          && (rrc_csp_substate != RRCCSP_ACCEPT_CELL_RESELECT_WT_TRANS_CNF))
  {
    /* Printed as an error only for noticing purposes during testing */
    WRRC_MSG1_ERROR("WTOW ERR: CSP substate is %d", rrc_csp_substate);
  }
  else if((rrc_state == RRC_STATE_CELL_DCH)
            || (rrc_state == RRC_STATE_CELL_FACH)
              || (rrc_state == RRC_STATE_CONNECTING))
  {
    WRRC_MSG1_ERROR("WTOW ERR: RRC state is %d", rrc_state);
  }
  else if(timer_val > MAX_WTOW_BPLMN_SRCH_TIMER_IN_MS)
  {
    WRRC_MSG1_ERROR("WTOW ERR: Incorrect BPLMN srch timer val %d rcvd from L1.", timer_val);
  }
  /* Don't start BPLMN search if CCM is already informed of cell loss.
   * In this case, bank on L1 as L1 is guaranteed to trigger OOS/another cell reselection.
   */
  else if(RRC_NOT_CAMPED_ON == rrc_ccm_get_curr_camping_status(RRC_PROCEDURE_CSP))
  {
    WRRC_MSG0_HIGH("CCM is indicating cell loss, don't allow L1 to goto BPLMN state");
  }
  else
  {
    WRRC_MSG2_HIGH("WTOW: Start BPLMN DRX Search. Tmr rcvd from L1 %d. CSP sst %d", 
                                                      timer_val, rrc_csp_substate);
    /* We are supposed to inform bplmn progress to L1 with CSP 
     * internal data only when BPLMN is going to be started
     */
    *wtog_bplmn_in_progress = rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_active;

#ifdef FEATURE_DUAL_SIM
    if(wcdma_is_ue_in_dual_standby)
    {
      /*Add additional overhead in case of Dual standby mode*/
      addtnl_over_head = WTOW_BPLMN_SEARCH_ADDTNL_OVERHEAD_TIMER_IN_MS; 
    }
#endif

    if(bplmn_data_saved)
    {
      /* If BPLMN data is saved restore the needy ones and reset backed up data*/
      bplmn_data_saved = FALSE; 
     /* Resetting the backed up data */
      rrc_csp_restore_saved_bplmn_data();
    }

    /* WTOW BPLMN search in progress */
    if(!rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_active)
    {
#ifdef FEATURE_DUAL_SIM
      if((WCDMA_RRC_IDLE_FEATURES(RRC_ACQ_SPLIT_DURING_BPLMN)) && wcdma_is_ue_in_dual_standby)
      {
        rrctmr_start_timer(RRCTMR_WTOW_BPLMN_DRX_SRCH_TIMER, 
                           timer_val - WTOW_BPLMN_SEARCH_OVERHEAD_TIMER_WITH_SPLIT_ACQ_IN_MS);
        xtow_bplmn_search_overhead_timer = WTOW_BPLMN_SEARCH_OVERHEAD_TIMER_WITH_SPLIT_ACQ_IN_MS;
        WRRC_MSG1_HIGH("DRX timer val started %d", timer_val - WTOW_BPLMN_SEARCH_OVERHEAD_TIMER_WITH_SPLIT_ACQ_IN_MS);
      }
      else
#endif
      {
        /*Use overhead time of 180ms for ACQ DB scans and
          120ms for non ACQ DB scans*/
        if(rrc_csp_curr_select_data.acq_db_in_use)
        {
          addtnl_over_head = 60;
        }
        else
        {
            addtnl_over_head = 0;
        }
        rrctmr_start_timer(RRCTMR_WTOW_BPLMN_DRX_SRCH_TIMER, 
                           timer_val - WTOW_BPLMN_SEARCH_OVERHEAD_TIMER_IN_MS - addtnl_over_head);
        xtow_bplmn_search_overhead_timer = WTOW_BPLMN_SEARCH_OVERHEAD_TIMER_IN_MS + addtnl_over_head;
        WRRC_MSG1_HIGH("DRX timer val started %d", timer_val-WTOW_BPLMN_SEARCH_OVERHEAD_TIMER_IN_MS-addtnl_over_head);
      }
      status = FALSE;
    }
    /* WTOG BPLMN search in progress */
    else
    {
      rrctmr_start_timer(RRCTMR_WTOW_BPLMN_DRX_SRCH_TIMER, 
                       timer_val - WTOG_BPLMN_SEARCH_OVERHEAD_TIMER_IN_MS);
      WRRC_MSG1_HIGH("DRX timer val started %d", timer_val-WTOG_BPLMN_SEARCH_OVERHEAD_TIMER_IN_MS);
    }
    rrc_csp_int_data.bplmn_srch_tmr_expired = FALSE;

#ifdef FEATURE_DUAL_SIM
    if(!rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_active)
    {
      can_lock_be_acquired = rrc_check_lock_can_be_acquired(TRM_ACQUISITION);
      if(dsim_bplmn_search_complete_w_cycle)
      {
        WRRC_MSG0_HIGH("DSIM: BPLMN search complete W cycle");
        can_lock_be_acquired = SUCCESS;
      }
    }
    /* Do not start this timer when L1 not in lock. Since this is a deferrable timer and L1 goes to sleep, the timer expires late */
    if((!rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_active) && (FAILURE == can_lock_be_acquired) 
       && (WRM_CLI_STATE_IS_IN_LOCK(WCDMA_TRM, WRM_PRIMARY_CLIENT_L1)))
    {
      rrctmr_start_timer(RRCTMR_DSIM_BPLMN_LOCK_REL_OFFSET_TIMER,5);
    }
    else
#endif
    {
      /* Send internal cmd to CSP so that BPLMN search can be started/resumed */
      rrccsp_send_bplmn_srch_resume_ind();
    }
#ifdef FEATURE_BPLMN_SEARCH_320MS
    /*Initializing bplmn_start_sfn whenever a new cycle of WTOW or WTOG BPLMN search starts*/
    rrc_csp_int_data.bplmn_start_sfn = bplmn_curr_sfn;
#endif

#ifdef FEATURE_DUAL_SIM
     /*
      If WTOW BPLMN search is active, check with TRM if lock is available for minimum time
      If not available, ask L1 to go to sleep, so that we can retry on RESUME_IND.
      */
    if(!rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_active)
    {
      *wtow_bplmn_in_progress = TRUE;
      if(can_lock_be_acquired == FAILURE)
      {
        rrc_add_l1_wakeup_time = TRUE;
        status = TRUE;
      }
    }
#endif
  }

  return status;
}/* rrc_can_l1_go_to_sleep */
/***/ __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED_END__ /***/


/* =======================================================================
**                            Function Declarations
** ======================================================================= */

/*===========================================================================

FUNCTION        rrccsp_handle_plmn_list_req

DESCRIPTION
                This function processes PLMN_LIST_REQ from MM.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_handle_plmn_list_req( rrc_csp_substate_e_type csp_substate,
                             rrc_plmn_list_req_type *plmn_list_req_ptr );



/*===========================================================================

FUNCTION        RRCCSP_CAMPED_SUIT_CELL_HDLR

DESCRIPTION
                This is a handler for events received in
                RRCCSP_CAMPED_SUIT_CELL substate of the Cell Selection
                Procedure.
                Depending on the event, it further calls a function for
                processing the event in this CSP substate.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_camped_suit_cell_hdlr( rrc_cmd_type *cmd_ptr );

/*===========================================================================

FUNCTION        RRC_CSP_PROCESS_RESEL_IND

DESCRIPTION
                Processes reselection indication

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrc_csp_process_resel_ind( rrc_cmd_type *cmd_ptr );

/*===========================================================================

FUNCTION        RRCCSP_CAMPED_ACCEPT_CELL_HDLR

DESCRIPTION
                This is a handler for events received in
                RRCCSP_CAMPED_ACCEPT_CELL substate of the Cell Selection
                Procedure.
                Depending on the event, it further calls a function for
                processing the event in this CSP substate.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_camped_accept_cell_hdlr( rrc_cmd_type *cmd_ptr );


/* =======================================================================
**                            Function Definitions
** ======================================================================= */

/*===========================================================================

FUNCTION          rrccsp_is_inter_frequency_cell_resel_in_progress

DESCRIPTION       This function returns TRUE if Inter-frequency cell reselection
                  is in progress.

DEPENDENCIES
                  None

RETURN VALUE
                  FALSE: Inter-frequency cell reselection not in progress.
                  TRUE: Inter-frequency cell reselection is in progress.

SIDE EFFECTS
                  None

===========================================================================*/
boolean  rrccsp_is_inter_frequency_cell_resel_in_progress(void)
{
  return rrccsp_inter_freq_cell_resel_in_progress;
}

/*===========================================================================

FUNCTION RRC_CSP_GET_CURR_CELL_ACCESS_STATUS

DESCRIPTION

This function returns the current cell access status of CSP

DEPENDENCIES

  None.
  
RETURN VALUE
  
  returns current cell access status of CSP

SIDE EFFECTS

  None.

===========================================================================*/
mm_as_cell_access_status_T  rrc_csp_get_curr_cell_access_status(rrc_cn_domain_identity_e_type  rrc_cn_domain_id)
{
  mm_as_cell_access_status_T status = MM_AS_ACCESS_ALL_CALLS;
  rrc_state_e_type rrc_state = rrc_get_state();

  if((rrc_state != RRC_STATE_DISCONNECTED) && (rrc_state != RRC_STATE_CONNECTING))
  {
    if(rrc_csp_int_data.is_dsac_valid)
    {
      WRRC_MSG0_HIGH("DSAC: DSAC info valid, consider the DSAC in connected mode");
    }
    else
    {
      return status;
    }
  }

  if(rrc_csp_int_data.is_dsac_valid == TRUE)
  {
    if(rrc_cn_domain_id == RRC_CS_DOMAIN_CN_ID)
    {
      status = rrc_csp_int_data.curr_cs_cell_access;
    }
    else if(rrc_cn_domain_id == RRC_PS_DOMAIN_CN_ID)
    {
      status = rrc_csp_int_data.curr_ps_cell_access;
    }
    else
    {
      status = MM_AS_ACCESS_ALL_CALLS;
    }
  }
  else
  {
    status = rrc_csp_int_data.curr_cell_access_status;
  }
   MSG_4(MSG_SSID_DFLT,MSG_LEGACY_HIGH,"DSAC:DSAC params are <DSAC Present, Cell Access, CS Cell Access and PS Cell Access> %d, %d, ,%d, %d", 
                                                rrc_csp_int_data.is_dsac_valid,
                                                rrc_csp_int_data.curr_cell_access_status,
                                                rrc_csp_int_data.curr_cs_cell_access,
                                                rrc_csp_int_data.curr_ps_cell_access);

  return status;
}

/*===========================================================================

FUNCTION RRC_CSP_GET_LOC_REG_ALLOWED_STATUS

DESCRIPTION

This function returns the location/registration allowed status

DEPENDENCIES

  None.
  
RETURN VALUE
  
  returns location/registration allowed status

SIDE EFFECTS

  None.

===========================================================================*/

boolean  rrc_csp_get_loc_reg_allowed_status(rrc_cn_domain_identity_e_type  rrc_cn_domain_id)
{
  boolean status = TRUE;
  rrc_state_e_type rrc_state = rrc_get_state();

  if((rrc_state != RRC_STATE_DISCONNECTED) && (rrc_state != RRC_STATE_CONNECTING))
  {
    if(rrc_csp_int_data.is_dsac_valid & rrc_csp_int_data.is_ppac_valid)
    {
      WRRC_MSG0_HIGH("PPAC: PPAC info valid, consider the PPAC in connected mode");
    }
    else if(rrc_csp_int_data.is_dsac_valid)
    {
      status = FALSE;
      return status;
    }
    else
    {
      return status;
    }
  }

  if(rrc_csp_int_data.is_ppac_valid)
  {
    if(rrc_cn_domain_id == RRC_CS_DOMAIN_CN_ID)
    {
      WRRC_MSG1_HIGH("PPAC: PPAC info valid, cs_reg_allowed = %d",rrc_csp_int_data.curr_cell_cs_reg_allowed);
      status = rrc_csp_int_data.curr_cell_cs_reg_allowed;
    }
    else if(rrc_cn_domain_id == RRC_PS_DOMAIN_CN_ID)
    {
      WRRC_MSG1_HIGH("PPAC: PPAC info valid, ps_reg_allowed = %d",rrc_csp_int_data.curr_cell_ps_reg_allowed);
      status = rrc_csp_int_data.curr_cell_ps_reg_allowed;
    }
  }
  else
  {
    status = FALSE;
  }
  return status;
}

/*===========================================================================

FUNCTION RRC_CSP_IS_PPAC_VALID

DESCRIPTION

This function returns if PPAC is valid or not

DEPENDENCIES

  None.
  
RETURN VALUE
  
  returns ppac validity status

SIDE EFFECTS

  None.

===========================================================================*/

boolean rrc_csp_is_ppac_valid(void)
{
  boolean is_valid = FALSE;
  if(rrc_csp_int_data.is_ppac_valid)
  {
    is_valid = TRUE;
  }
  return (is_valid);
}

/*===========================================================================

FUNCTION RRC_CSP_GET_PAGE_RSP_ALLOWED_STATUS

DESCRIPTION

This function returns the location/registration allowed status

DEPENDENCIES

  None.
  
RETURN VALUE
  
  returns location/registration allowed status

SIDE EFFECTS

  None.

===========================================================================*/
boolean  rrc_csp_get_page_rsp_allowed_status(rrc_cn_domain_identity_e_type  rrc_cn_domain_id)
{
  boolean status = TRUE;
  rrc_state_e_type rrc_state = rrc_get_state();

  if((rrc_state != RRC_STATE_DISCONNECTED) && (rrc_state != RRC_STATE_CONNECTING))
  {
    if(rrc_csp_int_data.is_dsac_valid & rrc_csp_int_data.is_ppac_valid)
    {
      WRRC_MSG0_HIGH("PPAC: PPAC info valid, consider the PPAC in connected mode");
    }
    else if(rrc_csp_int_data.is_dsac_valid)
    {
      status = FALSE;
      return status;
    }
    else
    {
      return status;
    }
  }

  if(rrc_csp_int_data.is_ppac_valid)
  {
    if(rrc_cn_domain_id == RRC_CS_DOMAIN_CN_ID)
    {
      if((rrc_csp_int_data.curr_cell_page_rsp_allowed == MM_AS_NONE) || 
         (rrc_csp_int_data.curr_cell_page_rsp_allowed == MM_AS_PS_ALLOWED)
        )
      {
        status = FALSE;
      }
    }
    else if(rrc_cn_domain_id == RRC_PS_DOMAIN_CN_ID)
    {
      if((rrc_csp_int_data.curr_cell_page_rsp_allowed == MM_AS_NONE) || 
         (rrc_csp_int_data.curr_cell_page_rsp_allowed == MM_AS_CS_ALLOWED)
        )
      {
        status = FALSE;
      }
    }
    WRRC_MSG1_HIGH("PPAC: PPAC info valid, page_rsp_allowed = %d",status);
  }
  else
  {
    status = FALSE;
  }
  return status;
}

/*===========================================================================

FUNCTION        RRCCSP_TEARDOWN_SERVING_CELL_BCH

DESCRIPTION
                This function tears down the serving cell BCH and informs SIB about
                it.

DEPENDENCIES
                None

RETURN VALUE
                None

SIDE EFFECTS
                None

===========================================================================*/
static void rrccsp_teardown_serving_cell_bch( void )
{
  rrc_cmd_type *chan_config_req_ptr;

  /* Set the following to TRUE if we can go back to the existing serving
   * cell. This is only used if new_cell_selection_succeeded
   * is set to FALSE. Set to FALSE if the existing cell is
   * no longer valid and the new cell selection failed. */
  boolean existing_serving_cell_valid = FALSE;

  rrc_plmn_identity_type sib_idx_plmn_id;
  if(rrc_csp_int_data.curr_acq_entry.is_valid_nw_sharing)
  {
    sib_idx_plmn_id = rrc_csp_int_data.curr_acq_entry.shared_list_of_plmns.common_plmn_id;
  }
  else
  {
    sib_idx_plmn_id = rrc_csp_int_data.curr_acq_entry.plmn_id;
  }

  WRRC_MSG2_HIGH("Sib_idx PLMN: MCC %d-MNC %d",RRC_CSP_GET_INT_MCC(sib_idx_plmn_id),RRC_CSP_GET_INT_MNC(sib_idx_plmn_id));
  /* Teardown the S-BCCH first and then send the transition request to L1 */
  if( (chan_config_req_ptr = rrc_get_int_cmd_buf())!=NULL )
  {
    WRRC_MSG0_HIGH("Tearing down S-BCCH");
    //Fill in the relevant values for the command
    chan_config_req_ptr->cmd_hdr.cmd_id = RRC_CHANNEL_CONFIG_REQ;
    chan_config_req_ptr->cmd.chan_config_req.num_rb_to_config =1;
    chan_config_req_ptr->cmd.chan_config_req.rb[0].rb_id = BCCH_S_RADIO_BEARER_ID;
    chan_config_req_ptr->cmd.chan_config_req.rb[0].rb_config = RELEASE_RB;
    chan_config_req_ptr->cmd.chan_config_req.rrc_state_change_required = FALSE;
    chan_config_req_ptr->cmd.chan_config_req.next_state = RRC_STATE_DISCONNECTED;
    chan_config_req_ptr->cmd.chan_config_req.procedure = RRC_PROCEDURE_CSP;
    chan_config_req_ptr->cmd.chan_config_req.release_trchls = FALSE;
    chan_config_req_ptr->cmd.chan_config_req.release_phychls = FALSE;
    chan_config_req_ptr->cmd.chan_config_req.rrc_channel_config_cnf_required = FALSE;
    chan_config_req_ptr->cmd.chan_config_req.chan_config_reason =
      RRCLLC_CHAN_CFG_REASON_NONE;
    rrc_put_int_cmd( chan_config_req_ptr );
  }

  /* Indicate to SIB procedure about the reselection failure */
  if(rrcsib_change_serving_cell_status(FALSE, existing_serving_cell_valid,
                                       sib_idx_plmn_id,
                                       rrc_csp_int_data.curr_acq_entry.cell_id) == FAILURE)
  {
    WRRC_MSG0_ERROR("Could not find PLMN/CellId");
  }
} /* rrccsp_teardown_serving_cell_bch */


#ifdef FEATURE_3GPP_CSFB
/*===========================================================================

FUNCTION          rrccsp_free_sib_cont_list

DESCRIPTION       This function will free the memory allocated for SIB cont list. This will be called on 
                         LTOW redirection initialization, successful camping for LTOW redirection, CSP int data init

DEPENDENCIES      None

RETURN VALUE      None

SIDE EFFECTS      None
===========================================================================*/
void rrccsp_free_sib_cont_list
(
  void
)
{
  uint8 idx=0;
  WRRC_MSG0_HIGH("CSFB: Free SIB container list");
  for(idx =0;idx < WCDMA_RRC_MAX_UTRA_CONT;idx++)
  {
    if(rrc_SIB_container.cont[idx].cont_ptr != NULL)
    {
      rrc_free(rrc_SIB_container.cont[idx].cont_ptr);
      rrc_SIB_container.cont[idx].cont_ptr = NULL;
    }
  }
  return;
}

/*===========================================================================

FUNCTION          rrccsp_get_idx_sib_cont_list

DESCRIPTION       This function returns idx to the PSC in the SIB container list

DEPENDENCIES      None

RETURN VALUE      Index to the PSC in the SIB container list if present
                          WCDMA_RRC_MAX_UTRA_CONT Otherwise

SIDE EFFECTS      None
===========================================================================*/
uint8  rrccsp_get_idx_sib_cont_list
(
  uint16 psc
)
{
  uint8 idx=0;
  for(idx=0;idx<WCDMA_RRC_MAX_UTRA_CONT;idx++)
  {
    if((psc  == rrc_SIB_container.psc[idx]) && (NULL != rrc_SIB_container.cont[idx].cont_ptr))
    {
      WRRC_MSG2_HIGH("CSFB: Found idx %d  for PSC %d",idx,psc);
      break;
    }
  }
  return idx;
}

/*===========================================================================

FUNCTION          rrccsp_copy_sib_cont_from_redir_req

DESCRIPTION       This function copies the SIB container list from LTOW redirection request to internal structures

DEPENDENCIES      None

RETURN VALUE      None

SIDE EFFECTS      None
===========================================================================*/
static void rrccsp_copy_sib_cont_from_redir_req
(
  wcdma_rrc_lte_redir_req_type * redir_req
)
{
  uint8 num_attachments;
  rrccsp_free_sib_cont_list();
  num_attachments = msgr_get_num_attach(&redir_req->msg_hdr);

  if(0 == num_attachments)
  {
    WRRC_MSG0_HIGH("CSFB: Num of attachements are zero");
  }
  else if(num_attachments != redir_req->num_pci)
  {
    WRRC_MSG2_ERROR("CSFB: Num of attachments %d != number of PSC %d",num_attachments, redir_req->num_pci);
  }
  else
  {
    uint8 psc_idx, num_valid_entries;
    for(psc_idx = 0, num_valid_entries= 0;psc_idx < redir_req->num_pci && psc_idx < WCDMA_RRC_MAX_UTRA_CONT ; psc_idx++)
    {
      dsm_item_type *dsm_ptr;
      msgr_attach_struct_type *msgr_attach_ptr;
      uint16 dsm_pkt_len;
      rrc_SIB_container.psc[psc_idx] = redir_req->pci_list[psc_idx];
      msgr_attach_ptr = msgr_get_attach(((msgr_hdr_struct_type *)&redir_req->msg_hdr),psc_idx); /*lint !e662 */
      ASSERT(msgr_attach_ptr != NULL);
      msgr_get_dsm_attach(msgr_attach_ptr, &dsm_ptr); /*lint !e661 */
      ASSERT(dsm_ptr != NULL)
      dsm_pkt_len = dsm_length_packet(dsm_ptr);
      WRRC_MSG1_HIGH("CSFB: PKT len %d ",dsm_pkt_len);
      if(RRC_MAX_SIB_CONT_LEN < dsm_pkt_len )
      {
        WRRC_MSG2_ERROR("CSFB: SIB container length %d larget than MAX %d ",dsm_pkt_len,RRC_MAX_SIB_CONT_LEN);
        continue;
      }
      rrc_SIB_container.cont[psc_idx].cont_len = dsm_pkt_len;
      rrc_SIB_container.cont[psc_idx].cont_ptr = (uint8 *) rrc_malloc(dsm_pkt_len);
      if (dsm_pullup(&dsm_ptr,rrc_SIB_container.cont[psc_idx].cont_ptr,dsm_pkt_len) != dsm_pkt_len)
      {
        WRRC_MSG0_ERROR("CSFB: Couldn't pull up all the bytes");
        continue;
      }
      num_valid_entries++;
    }
    rrc_SIB_container.num_cont = num_valid_entries;
    WRRC_MSG1_HIGH("CSFB: Number of SIB container %d ",rrc_SIB_container.num_cont);
  }
  return;
}
#endif


/*===========================================================================

FUNCTION          rrccsp_send_acq_req_for_detected_cell

DESCRIPTION       This function tries acquisition on the next detected cell on the
                  same frequency.

DEPENDENCIES
                  None

RETURN VALUE
                  Next CSP substate.

SIDE EFFECTS
                  None

===========================================================================*/
static void rrccsp_send_acq_req_for_detected_cell(void)
{
  /* Get the next detected cell on the same frequency */
  rrc_csp_int_data.curr_acq_entry.scr_code =
    rrc_csp_int_data.scr_code_det[rrc_csp_int_data.curr_acq_count].scr_code;
  rrc_csp_int_data.pn_pos =
    rrc_csp_int_data.scr_code_det[rrc_csp_int_data.curr_acq_count++].pn_pos;

  rrc_csp_int_data.acq_mode = L1_WCDMA_FULL;
  rrc_csp_int_data.acq_type = L1_WCDMA_FREQ_SCR_POS;

  rrc_csp_int_data.bplmn_acq_succ_curr_acq_count = rrc_csp_int_data.curr_acq_count;

  /* Send CPHY_ACQ_REQ to L1 and wait for the CNF */
  rrc_csp_send_l1_cmd(RRC_PROCEDURE_CSP, CPHY_ACQ_REQ, &rrc_csp_int_data.curr_acq_entry);
  WRRC_MSG2_HIGH("ACQ_REQ on next best cell %d on freq %d",
            rrc_csp_int_data.curr_acq_entry.scr_code,
            rrc_csp_int_data.curr_acq_entry.freq);
  }
/*===========================================================================

FUNCTION          rrccsp_try_next_best_cell_if_available

DESCRIPTION       This function tries acquisition on the next best cell if
                  available.

DEPENDENCIES
                  None

RETURN VALUE
                  TRUE - If another cell was found
                  FALSE - Otherwise

SIDE EFFECTS
                  None

===========================================================================*/
static boolean rrccsp_try_next_best_cell_if_available(void)
{
  /* If cell is barred but INTRA-FREQUENCY is allowed, if there is a another cell on
   * the same frequency try acquisition on that cell
   */
  if((rrc_csp_int_data.num_scr_code_det > 0) &&
      (rrc_csp_int_data.curr_acq_count
        < rrc_csp_int_data.num_scr_code_det))
  {
    /* First call a CCM function to indicate Cell Loss - no new cell */
    /* NOTE: The functional I/F has to be used very carefully. */
    rrc_ccm_update_with_cell_loss();

    if((rrc_csp_int_data.curr_scan != RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
       && (rrc_csp_int_data.curr_scan != RRC_CSP_WTOW_BPLMN_MANUAL_SCAN))
    {
      /* Release all channels and put lower layers to Idle before sending another
       * Acquisition Req or a Frequency Scan Req.
       */
      rrccsp_teardown_serving_cell_bch();

      /* Wait for L1 to release lock before RRC releases lock(if extend lock
       * is not successful)
       */
#ifdef FEATURE_DUAL_SIM
      if(WRM_STATE_IS_IN_LOCK(WCDMA_TRM) &&
          ((rrc_csp_int_data.curr_scan == RRC_CSP_OUT_OF_SERVICE_AREA_SCAN) ||
           (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_SELECTION_SCAN) ||
           (rrc_csp_int_data.curr_scan == RRC_CSP_PLMN_LIST_SCAN)
#ifdef FEATURE_WRLF_SYSTEM_SEL
           || ((rrc_csp_int_data.curr_scan == RRC_CSP_LEAVING_CONN_MODE_SCAN) &&
                RRC_IS_CONN_MODE_OOS_SRCH_IN_PROGRESS())
#endif
          )
        )
      {
        rrc_csp_int_data.csp_waiting_for_wl1_to_release_lock = TRUE;
      }
#endif
      /* Start with sending an RRC_RESET_L1_REQ to L1 before a CPHY_ACQ_REQ */
      rrc_csp_send_l1_idle_req();
    }
    else
    {
      /* Drop BCCH before trying ACQ on next PSC to give chance for
         GSM to decode page */
#ifdef FEATURE_DUAL_SIM
      if(WRM_STATE_IS_IN_LOCK(WCDMA_TRM))
      {
        rrc_csp_int_data.csp_waiting_for_wl1_to_release_lock = TRUE;
        rrc_csp_send_bch_release(TRUE);
      }
      else
#endif
      {
      /* Release BCH and put lower layers to Idle */
        rrc_csp_send_bch_release(FALSE);
      }
    }

#ifdef FEATURE_DUAL_SIM
    if(rrc_csp_int_data.csp_waiting_for_wl1_to_release_lock == FALSE)
#endif
    {
      rrccsp_send_acq_req_for_detected_cell();
    }
    return TRUE;
  }
  else
  {
    WRRC_MSG0_HIGH("No more best cell reset BPLMN backup data");
    rrc_csp_int_data.bplmn_acq_succ_scr_code_det = 0;
    rrc_csp_int_data.bplmn_acq_succ_curr_acq_count = 0;
    return FALSE;
  }

} /* rrccsp_try_next_best_cell_if_available */


/*===========================================================================

FUNCTION          rrccsp_init_measurements_in_l1_on_cphy_idle

DESCRIPTION       This function returns a value that indicates if Measurements
                  need to be initialized in L1 on a CPHY_IDLE_REQ.

DEPENDENCIES
                  None

RETURN VALUE
                  FALSE: Intra-freq measurements and Inter-freq meas need to
                  be saved.
                  TRUE: Intra and Inter frequency measurements do not need
                  to be initialized.

SIDE EFFECTS
                  None

===========================================================================*/
boolean  rrccsp_init_measurements_in_l1_on_cphy_idle(void)
{
  /* Save measurements when going from DCH to FACH/PCH */
  if(   (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_CELL_FACH_SCAN) 
     || (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_CELL_PCH_SCAN) 
     || (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_URA_PCH_SCAN)
     /* For RL_Failure, curr_scan is changed from DCH_to_FACH to
      * OOS_Scan and hence the need.
      */
     || ((rrc_csp_int_data.curr_scan == RRC_CSP_OUT_OF_SERVICE_AREA_SCAN) 
         && (RRC_STATE_CELL_DCH == rrc_get_state()))
    )
  {
   /* Do not initialize Meas Criteria before sending CPHY_IDLE_REQ while
    * in RRC_CSP_CELL_DCH_TO_CELL_FACH_SCAN. Note once UE is camped on
    * a cell successfully in CELL_FACH state, the scan type is initialized
    * to CELL_SELECTION_SCAN so that the measurements ARE initialized
    * on any subsequent CPHY_IDLE_REQ.
    */
    return(FALSE);
  }
  else
  {
    return(TRUE);
  }
}  /* rrccsp_init_measurements_in_l1_on_idle */


/*===========================================================================

FUNCTION          RRC_INIT_CELL_SELECTION_PROCEDURE

DESCRIPTION       This function initializes any global data for the procedure.

                  NOTE: This could be used later to get NV data from NV.

DEPENDENCIES
                  None

RETURN VALUE
                  None
                  NOTE: We can have a return value of Pass/fail and tie that
                  up with deciding the Offline/Online mode ofthe UE but that
                  all is for later times.

SIDE EFFECTS
                  None

===========================================================================*/

void  rrc_init_cell_selection_procedure( void )
{
  uint8 i = 0;

  /* For now, just set the CSP procedure substate - more later */
  rrc_csp_substate = RRCCSP_NO_CELL_SELECTED;

  rrc_csp_int_data.power_up_service_req = TRUE;
  /* Set the number of forbidden LAIs to 0 */
  rrc_csp_int_data.forbid_lai_list.num_lais = 0;

#ifdef FEATURE_WCDMA_FREE_FLOATING_TASK
  /* Set the reject lai list to 0 */
  rrc_csp_int_data.lai_reject_list.length = 0;

#ifdef FEATURE_DUAL_SIM
  /* SM is ok for tuneaway by default after power up
   * In case of any change in status it will be notified by NAS
   */
  rrc_csp_int_data.sm_ok_to_tuneaway      = TRUE;
#endif
#endif
  /* Initialized to invalid value. Used when UE is OOS in idle mode */
  rrc_csp_int_data.last_camped_freq_in_idle_mode = 0;

  /* Initialized to invalid value. Used when UE is OOS in Connected mode */
  rrc_csp_int_data.last_camped_freq_in_connected_mode = 0;

#ifdef FEATURE_WRLF_SYSTEM_SEL
  /* Initialize the W-RLF flag */
  rrc_csp_int_data.ue_in_conn_oos = FALSE;
#endif

  /* Invalidate entities in RRC CSP Internal data structure */
  rrc_csp_init_int_data();

  /* Initialize RRC CSP Acquisition Database here */
  rrc_csp_init_acq_db();

#ifdef FEATURE_EOOS
  #error code not present
#endif

#ifdef FEATURE_EOOS
  #error code not present
#endif

  /* Register with the State Change Manager for all state transitions
   * from any state to Idle Disconnected and DCH states.
   */
  rrcscmgr_register_for_scn
  (
    RRC_PROCEDURE_CSP,
    RRC_STATE_WILDCARD,
    RRC_STATE_DISCONNECTED
  );

  rrcscmgr_register_for_scn
  (
    RRC_PROCEDURE_CSP,
    RRC_STATE_WILDCARD,
    RRC_STATE_CELL_DCH
  );

  /* This state change registration is added so that RRC sends CPHY_CELL_PARM_REQ
   * to L1 when there is a state transition from Connecting to FACH so that L1 uses
   * parameters in SIB4 (if present) instead of the ones in SIB3 (as is the case otherwise).
   */
  rrcscmgr_register_for_scn
  (
    RRC_PROCEDURE_CSP,
    RRC_STATE_CONNECTING,
    RRC_STATE_CELL_FACH
  );

  rrcscmgr_register_for_scn
  (
    RRC_PROCEDURE_CSP,
    RRC_STATE_CELL_PCH,
    RRC_STATE_CELL_FACH
  );


  rrcscmgr_register_for_scn
  (
    RRC_PROCEDURE_CSP,
    RRC_STATE_URA_PCH,
    RRC_STATE_CELL_FACH
  );

  rrcscmgr_register_for_scn
  (
    RRC_PROCEDURE_CSP,
    RRC_STATE_DISCONNECTED,
    RRC_STATE_CONNECTING
  );

  /* Register with the SIB procedure for SIB1 change notification */
  rrcsib_register_for_sib_change_notification
  (
    RRC_PROCEDURE_CSP,
    rrc_SIB1
  );

  /* Register with the SIB procedure for SIB3 change notification */
  rrcsib_register_for_sib_change_notification
  (
    RRC_PROCEDURE_CSP,
    rrc_SIB3
  );

  /* Register with the SIB procedure for SIB4 change notification */
  rrcsib_register_for_sib_change_notification
  (
    RRC_PROCEDURE_CSP,
    rrc_SIB4
  );

  /* Register with the SIB procedure for SIB5 and SIB6 change notification */
  rrcsib_register_for_sib_change_notification
  (
    RRC_PROCEDURE_CSP,
    rrc_SIB5
  );

  rrcsib_register_for_sib_change_notification
  (
    RRC_PROCEDURE_CSP,
    rrc_SIB6
  );

  rrcsib_register_for_sib_change_notification
  (
    RRC_PROCEDURE_CSP,
    rrc_SIB11
  );

  rrcsib_register_for_sib_change_notification
  (
    RRC_PROCEDURE_CSP,
    rrc_SIB12
  );
  
  rrc_csp_int_data.wcdma_cell_time_to_reselect = 0;
  rrc_csp_int_data.wcdma_cell_squalmin         = 0;
  rrc_csp_int_data.wcdma_cell_srxlevmin        = 0;

  rrc_csp_int_data.full_scan_needed = TRUE;
#ifdef FEATURE_EOOS
  #error code not present
#endif
  rrc_csp_int_data.plmn_list_freq_scan_needed = TRUE;
  rrc_csp_int_data.manual_plmn_list_freq_scan_needed = TRUE;
  rrc_csp_int_data.ue_in_deep_sleep = FALSE;
  rrc_csp_int_data.full_scan_in_deep_sleep_counter = 0;
  rrc_csp_int_data.deep_sleep_no_svc_tmr_expired = TRUE;
  rrc_csp_int_data.deep_sleep_acq_db_plmn_searchloop = FALSE;
  rrc_csp_int_data.agc_threshold_cnt = 0;
  rrc_csp_int_data.init_cell_sel_ind_during_wtointerrat = FALSE;


#ifdef FEATURE_WCDMA_MULTIBAND
  rrc_csp_curr_select_data.current_band                = RRC_CSP_IMT2K_BAND;

  rrc_csp_curr_select_data.first_band_to_be_scanned    = RRC_CSP_BAND_MAX;
  
  rrc_csp_int_data.deep_sleep_band_scanned_mask        = 0;
  rrc_csp_int_data.deep_sleep_no_svc_band_scanned_mask = 0;

#endif

  rrc_csp_int_data.bplmn_crit_sec_flag = FALSE;
  rrc_csp_int_data.bplmn_guard_srch_tmr_expired = TRUE;

  for (i = 0; i < MAX_NUM_OF_REG_CB; i++) 
  {
    rrc_serving_cell_change_ind_cb_func[i] = NULL;
  }

  rrc_csp_int_data.dch_to_fach_pch_tmr_expd = FALSE;

  rrc_csp_int_data.fach_to_fach_pch_tmr_expd = FALSE;

#ifdef FEATURE_UMTS_1X_HANDOVER_UMTSMSM
  #error code not present
#endif

  RRC_DEBUG_CLEAR_ALL_STATS();

  wrm_init();
  wrm_register_callback();

#ifdef FEATURE_3GPP_CSFB
  rrc_SIB_container.num_cont = 0;
  for(i=0;i<WCDMA_RRC_MAX_UTRA_CONT;i++)
  {
    rrc_SIB_container.cont[i].cont_ptr = NULL;
  }
#endif

#ifdef FEATURE_FEMTO_CSG
  rrc_csp_int_data.csg_asf_srch_in_progress = FALSE;
  memset(&rrc_csp_int_data.temp_csg_list,0,sizeof(rrc_csp_temp_csg_cell_list));
#endif
} /* rrc_init_cell_selection_procedure */


/*===========================================================================

FUNCTION          RRCCSP_RESET_RESELECTION_DATA

DESCRIPTION       This function resets all the cell reselection related variables.

DEPENDENCIES
                  None

RETURN VALUE
                  None

SIDE EFFECTS
                  None

===========================================================================*/

static void  rrccsp_reset_reselection_data( void )
{
  MSG_4(MSG_SSID_DFLT, MSG_LEGACY_HIGH,"Reset_reselection_data. new_cell_acq_entry freq %d, scr_code %d, curr_acq_entry freq %d, scr_code %d",
           rrc_csp_int_data.new_cell_acq_entry.freq,
           rrc_csp_int_data.new_cell_acq_entry.scr_code,
           rrc_csp_int_data.curr_acq_entry.freq,
           rrc_csp_int_data.curr_acq_entry.scr_code);

  /* Reset the cell reselection variables */
  rrc_csp_int_data.new_cell_acq_entry.freq = 0;
  rrc_csp_int_data.new_cell_acq_entry.scr_code = 0;

  rrccsp_inter_freq_cell_resel_in_progress = FALSE;

  rrc_csp_int_data.wcdma_cell_time_to_reselect = 0;
  rrc_csp_int_data.wcdma_cell_squalmin         = 0;
  rrc_csp_int_data.wcdma_cell_srxlevmin        = 0;

} /* rrccsp_reset_reselection_data */


/*===========================================================================

FUNCTION        rrccsp_handle_out_of_service_ind

DESCRIPTION
                This function processes Out of Service Area Indication in any
                RRC CSP camped substate

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_handle_out_of_service_ind( rrc_csp_substate_e_type csp_substate )
{

  rrc_csp_substate_e_type   next_substate =  csp_substate;
  rrc_state_e_type          rrc_state     =  rrc_get_state();

  boolean reset_dest_freq = TRUE;

  /* if OOS is detected during transition out of DCH/FACH, Don't clean up the dest_freq_
   * present flag as radio bearer control procedures need to check via 
   * rrccsp_is_selected_cell_utran_directed() whether UE camped on directed cell or 
   * not after coming back in service
   */
  if ((rrc_state == RRC_STATE_CELL_DCH)
      || (rrc_state == RRC_STATE_CELL_FACH)
     )
  {
    reset_dest_freq = FALSE;
  }

  /* Inter Frequency Redirection Scan was aborted. Clean up its state */
  if(rrc_csp_int_data.curr_scan == RRC_CSP_INTER_FREQ_REDIRECTION_SCAN)
  {
    rrc_csp_cleanup_inter_freq_redirection_state();
  }

#ifdef FEATURE_TRIPLE_SIM
  /* set falg for OOS case */
  rrcwrm_set_trm_extension_flag_for_alternate_page(TRUE);
#endif

  /* At present, we support Out of Service Area only in Idle, Connecting
   * and Cell_FACH states. Cell selection takes RRC to Idle Disconnected
   * state. TBD: Maintain RRC state and select a new cell.
   */
  if(   (rrc_state != RRC_STATE_DISCONNECTED) 
     && (rrc_state != RRC_STATE_CONNECTING) 
     && (rrc_state != RRC_STATE_CELL_FACH) 
     && (rrc_state != RRC_STATE_CELL_PCH) 
     && (rrc_state != RRC_STATE_URA_PCH)
     && (rrc_state != RRC_STATE_CELL_DCH)
    )
  {
    return(next_substate);
  }

  WRRC_MSG1_HIGH("Start cell sel, OOS in RRC st %d", rrc_state);

  /* Signal SIB procedure to clear up the active event, if any */
  rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_OOS);

  /* Reset aset_scr_code while handling OOS to prevent ASET scan. During OOS
   * if type_freq_scan is RRC_CSP_LAST_ASET_SCAN, CSP will get stuck in 
   * RRCCSP_CELL_SEL_WT_FREQ_SCAN_CNF substate. This can happen if RRC connection 
   * release is received on DCCH and UE goes OOS before L2 ack for release complete 
   * is received
   */
  rrc_csp_int_data.aset_scr_code = 8192;

  /* if OOS is detected during transition out of DCH/FACH, Don't clean up the dest_freq_
   * present flag as radio bearer control procedures need to check via 
   * rrccsp_is_selected_cell_utran_directed() whether UE camped on directed cell or 
   * not after coming back in service
   */
  if (reset_dest_freq)
  {
    rrc_csp_int_data.dest_freq_present = FALSE;
  }

  if(rrc_state == RRC_STATE_DISCONNECTED)
  {
    RRC_DEBUG_INCREMENT_STATS(OOS_IN_IDLE_MODE);
    next_substate = rrc_csp_start_sel_out_of_service_area_in_idle_state();
  }
  else if(rrc_state == RRC_STATE_CONNECTING)
  {
    RRC_DEBUG_INCREMENT_STATS(OOS_IN_IDLE_MODE);
    next_substate = rrc_csp_start_sel_out_of_service_area_in_connecting_state();
  }
  else
  {
    RRC_DEBUG_INCREMENT_STATS(OOS_IN_CONNECTED_MODE);
    next_substate = rrc_csp_start_sel_out_of_service_area();
  }


  return( next_substate );

} /* rrccsp_handle_out_of_service_ind */

/*===========================================================================

FUNCTION        rrccsp_plmn_list_req_is_valid

DESCRIPTION
                This function determines if PLMN_LIST_REQ (Automatic and Manual)
                from MM has been received in correct RRC state or not. If  
                PLMN_LIST_REQ is NOT valid then PLMN_LIST_CNF is sent to NAS 
                within this function itself.
                
DEPENDENCIES
                None

RETURN VALUE
                TRUE:  PLMN_LIST_REQ is valid
                FALSE: Otherwise

SIDE EFFECTS
                None

===========================================================================*/
boolean rrccsp_plmn_list_req_is_valid(rrc_plmn_list_req_type  *plmn_list_req_ptr)
{
  rrc_state_e_type rrc_state    = rrc_get_state();
  boolean          valid_status = TRUE;
  sys_service_search_e_type save_service_search_bgnd;

  uint8            list_req_trans_id = plmn_list_req_ptr->trans_id;

  if(   (
             (      (rrc_state == RRC_STATE_CONNECTING)
                 || (rrc_state == RRC_STATE_CELL_FACH)
                 || (rrc_state == RRC_STATE_CELL_DCH)
             )
          /* We will not abort the PLMN List Req sent by NAS if the network
           * mode is Manual for all RRC establishment causes
           */ 
          && (plmn_list_req_ptr->network_select_mode == SYS_NETWORK_SELECTION_MODE_AUTOMATIC)

        )
     || (
             (RRC_NOT_CAMPED_ON == rrc_ccm_get_curr_camping_status(RRC_PROCEDURE_CSP))
          && (!rrc_ccm_is_reselection_in_progress())
          && ((rrc_csp_int_data.curr_scan != RRC_CSP_LEAVING_CONN_MODE_SCAN) ||
              (plmn_list_req_ptr->network_select_mode != SYS_NETWORK_SELECTION_MODE_MANUAL))
          && 
             (
                (rrc_state != RRC_STATE_DISCONNECTED) || 
                (plmn_list_req_ptr->network_select_mode == SYS_NETWORK_SELECTION_MODE_AUTOMATIC)
             )
        )
      || (
              (     (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
                 || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN)
                 || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOG_BPLMN_AUTOMATIC_SCAN)
                 || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOG_BPLMN_MANUAL_SCAN)
              )
           && ((plmn_list_req_ptr->network_select_mode == SYS_NETWORK_SELECTION_MODE_AUTOMATIC) 
#ifdef FEATURE_FEMTO_CSG
                /* Automatic search is valid when CSG is in progress */
                && (!rrc_csp_int_data.csg_asf_srch_in_progress)
#endif
              )
         )

#ifdef FEATURE_DUAL_SIM
      /*Reject automatic PLMN searches when G is in data call*/
      ||(   (plmn_list_req_ptr->network_select_mode == SYS_NETWORK_SELECTION_MODE_AUTOMATIC)
          &&(WRM_G2W_TA_MODE_ACTIVE())
        )
#endif
    )
  {
    MSG_HIGH("WTOW: List Req Invalid. RRC st %d, Camped St %d, n/w sel mode %d", 
                                                 rrc_state, 
                                                 rrc_ccm_get_curr_camping_status(RRC_PROCEDURE_CSP), 
                                                 plmn_list_req_ptr->network_select_mode);

    if(plmn_list_req_ptr->network_select_mode == SYS_NETWORK_SELECTION_MODE_AUTOMATIC)
    {
      /* Send the PLMN_LIST_CNF to MM */
      rrc_csp_int_data.bplmn_nw_sel_mode   = plmn_list_req_ptr->network_select_mode;

      save_service_search_bgnd = rrc_csp_int_data.service_search_bgnd;
      rrc_csp_int_data.service_search_bgnd = plmn_list_req_ptr->service_search;
      WRRC_MSG1_HIGH("SSB: svc_srch_bgnd rcvd from NAS = %d", rrc_csp_int_data.service_search_bgnd);

      rrc_csp_bplmn_send_mm_plmn_list_cnf_cmd(WTOW_SEARCH_ABORT, list_req_trans_id);
      rrc_csp_int_data.service_search_bgnd = save_service_search_bgnd;
    }
    else
    {
      rrc_csp_send_mm_plmn_list_cnf_as_aborted(list_req_trans_id);
    }
    valid_status = FALSE;
  } 
  else
  {
    /*Reply with success if SIB19 is present*/
    if((plmn_list_req_ptr->network_select_mode == SYS_NETWORK_SELECTION_MODE_AUTOMATIC)&&
       (plmn_list_req_ptr->service_search == SYS_SERVICE_SEARCH_IRAT_PLMN))
    {
      if(rrc_sibdb_return_sib_for_srv_cell(rrc_SIB19))
      {
        rrc_csp_send_mm_plmn_list_cnf_as_success(list_req_trans_id);
        valid_status = FALSE;
      }
    }
    MSG_HIGH("WTOW: List Req Valid. RRC st %d, Camped St %d, n/w sel mode %d", 
                                                 rrc_state, 
                                                 rrc_ccm_get_curr_camping_status(RRC_PROCEDURE_CSP), 
                                                 plmn_list_req_ptr->network_select_mode);

  }


  MSG_HIGH("curr_scan %d, prev_curr_scan %d, svc_srch_bgnd %d", 
                                          rrc_csp_int_data.curr_scan, 
                                          rrc_csp_int_data.prev_curr_scan, 
                                          rrc_csp_int_data.service_search_bgnd);

  return (valid_status);
} /* rrccsp_plmn_list_req_is_valid */


/*===========================================================================

FUNCTION        RRCCSP_PLMN_LIST_REQ_WHEN_RESUME_IN_PROG_IS_VALID

DESCRIPTION
                This function determines if PLMN_LIST_REQ (Automatic and Manual)
                from MM has been received in correct RRC state or not. If  
                PLMN_LIST_REQ is NOT valid then PLMN_LIST_CNF is sent to NAS 
                within this function itself.

                This function is different from rrccsp_plmn_list_req_is_valid()
                in the sense that in this function it is not checked if UE is 
                camped or not. The reason being that CCM is always updated with
                cell loss when W is suspended and hence if PLMN List Request 
                is received when W is suspended then Plmn List Request may be
                incorrectly handled if function rrccsp_plmn_list_req_is_valid()
                is called. 

                This function is called only when W is in the process of resuming.
                
DEPENDENCIES
                None

RETURN VALUE
                TRUE:  PLMN_LIST_REQ is valid
                FALSE: Otherwise

SIDE EFFECTS
                None

===========================================================================*/
boolean rrccsp_plmn_list_req_when_resume_in_prog_is_valid(
  rrc_plmn_list_req_type  *plmn_list_req_ptr)
{
  rrc_state_e_type        rrc_state    = rrc_get_state();
  boolean                 valid_status = TRUE;
  sys_service_search_e_type save_service_search_bgnd;
  
  rrc_csp_substate_e_type    csp_state     = rrc_get_csp_substate();
  uint8                  list_req_trans_id = plmn_list_req_ptr->trans_id;
  
  if(   (
             (   (rrc_state == RRC_STATE_CONNECTING)
              || (rrc_state == RRC_STATE_CELL_FACH)
              || (rrc_state == RRC_STATE_CELL_DCH)
             )
          /* We will not abort the PLMN List Req sent by NAS if the network
           * mode is Manual for all RRC establishment causes
           */
          && (plmn_list_req_ptr->network_select_mode == SYS_NETWORK_SELECTION_MODE_AUTOMATIC)
        )
     || (
            (rrc_csp_int_data.curr_scan != RRC_CSP_WCDMA_TO_GSM_CELL_RESELECTION_SCAN)
         && (rrc_csp_int_data.curr_scan != RRC_CSP_CELL_SELECTION_SCAN)
         && (rrc_csp_int_data.curr_scan != RRC_CSP_WTOG_BPLMN_AUTOMATIC_SCAN)
         && (rrc_csp_int_data.curr_scan != RRC_CSP_WTOG_BPLMN_MANUAL_SCAN)
#ifdef FEATURE_DUAL_SIM
         && (rrc_csp_int_data.curr_scan != RRC_CSP_UNLOCK_BY_SCAN)
#endif
         /* Handle buffered PLNM_LIST_REQ when resuming on W after inter-RAT redirection
          * search due to connection release
          */
         && (rrc_csp_int_data.curr_scan != RRC_CSP_INTER_RAT_REDIRECTION_SCAN)
         && (
                 (csp_state == RRCCSP_WT_RESUME_MODE_CHANGE_CNF)
              || (csp_state == RRCCSP_WT_RESUME_MODE_CHANGE_CNF_PENDING)
            )
        )
     || (
             (     (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
                || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN)
                || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOG_BPLMN_AUTOMATIC_SCAN)
                || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOG_BPLMN_MANUAL_SCAN)
             )
          && (plmn_list_req_ptr->network_select_mode == SYS_NETWORK_SELECTION_MODE_AUTOMATIC)
        )
#ifdef FEATURE_DUAL_SIM
          /*Reject automatic PLMN searches when G is in data call*/
      ||(   (plmn_list_req_ptr->network_select_mode == SYS_NETWORK_SELECTION_MODE_AUTOMATIC)
          &&(WRM_G2W_TA_MODE_ACTIVE())
        )
#endif
    )
  {
    MSG_HIGH("WTOW: List Req Invalid. RRC st %d, n/w sel mode %d, scan type %d",
                                                 rrc_state, 
                                                 plmn_list_req_ptr->network_select_mode, 
                                                 rrc_csp_int_data.curr_scan);

    if(plmn_list_req_ptr->network_select_mode == SYS_NETWORK_SELECTION_MODE_AUTOMATIC)
    {
      /* Send the PLMN_LIST_CNF to MM */
      rrc_csp_int_data.bplmn_nw_sel_mode = plmn_list_req_ptr->network_select_mode;

      save_service_search_bgnd = rrc_csp_int_data.service_search_bgnd;
      rrc_csp_int_data.service_search_bgnd = plmn_list_req_ptr->service_search;
      WRRC_MSG1_HIGH("SSB: svc_srch_bgnd rcvd from NAS = %d", rrc_csp_int_data.service_search_bgnd);

      rrc_csp_bplmn_send_mm_plmn_list_cnf_cmd(WTOW_SEARCH_ABORT,list_req_trans_id);

      rrc_csp_int_data.service_search_bgnd = save_service_search_bgnd;
    }
    else
    {
      rrc_csp_send_mm_plmn_list_cnf_as_aborted(list_req_trans_id);
    }

    valid_status = FALSE;
  } 
  else
  {
    /*Reply with success if SIB19 is present*/
    if((plmn_list_req_ptr->network_select_mode == SYS_NETWORK_SELECTION_MODE_AUTOMATIC)&&
       (plmn_list_req_ptr->service_search == SYS_SERVICE_SEARCH_IRAT_PLMN))
    {
      if(rrc_sibdb_return_sib_for_srv_cell(rrc_SIB19))
      {
        rrc_csp_send_mm_plmn_list_cnf_as_success(list_req_trans_id);
        valid_status = FALSE;
      }
    }
    MSG_HIGH("WTOW: List Req Valid. RRC st %d, n/w sel mode %d, scan type %d", 
                                                 rrc_state, 
                                                 plmn_list_req_ptr->network_select_mode,
                                                 rrc_csp_int_data.curr_scan);
  }


  return (valid_status);
} /* rrccsp_plmn_list_req_when_resume_in_prog_is_valid */

/*===========================================================================

FUNCTION        RRCCSP_UPDATE_PLMN_LIST_REQ_DATA

DESCRIPTION
                This function updates CSP global data based on the PLMN List Request List passed

DEPENDENCIES
                None

RETURN VALUE
                None

SIDE EFFECTS
                None

===========================================================================*/
static void rrccsp_update_plmn_list_req_data(rrc_plmn_list_req_type  *plmn_list_req_ptr)
{

  rrc_csp_int_data.bplmn_scan_scope = plmn_list_req_ptr->scan_scope;
  WRRC_MSG1_HIGH("List_Req Scan Scope: %d", rrc_csp_int_data.bplmn_scan_scope);
  rrc_csp_int_data.bplmn_dual_mode_enabled = plmn_list_req_ptr->dual_mode;
  rrc_csp_int_data.bplmn_band_pref = plmn_list_req_ptr->band_pref;
  rrc_csp_int_data.bplmn_trans_id = plmn_list_req_ptr->trans_id;

#ifdef FEATURE_RAT_PRIORITY_LIST

  /* For manual PLMN search if BST information is given then ignore the band preference given in "rat_pri_list_info" */
  if((plmn_list_req_ptr->network_select_mode == SYS_NETWORK_SELECTION_MODE_MANUAL) && (plmn_list_req_ptr->mcc_mode_band_filter.num_items != 0))
  {
      rrc_bst_band_pref_incl = TRUE;

      /* Updating based on BST information (mcc_mode_band_filter) */ 
      rrc_csp_int_data.bplmn_band_pref = rrc_extract_gw_band_pref_from_rat_pri_list(&plmn_list_req_ptr->mcc_mode_band_filter);

      /* Updating based on original RAT priority list if BST has valid entries. This is used only to update GSM */
      rrc_csp_int_data.rat_pri_band_pref = rrc_extract_gw_band_pref_from_rat_pri_list(&plmn_list_req_ptr->rat_pri_list_info); 

      /* Extract the mode information based on mcc_mode_band_filter */
      rrc_csp_int_data.bplmn_dual_mode_enabled = rrcmcm_is_mode_enabled_in_rat_pri_list(
        &plmn_list_req_ptr->mcc_mode_band_filter,SYS_SYS_MODE_GSM);

     rrc_csp_int_data.bplmn_wcdma_mode_enabled = rrcmcm_is_mode_enabled_in_rat_pri_list(
        &plmn_list_req_ptr->mcc_mode_band_filter,SYS_SYS_MODE_WCDMA);
  }
  else
  {
    rrc_bst_band_pref_incl = FALSE;

    rrc_csp_int_data.bplmn_band_pref = rrc_extract_gw_band_pref_from_rat_pri_list(&plmn_list_req_ptr->rat_pri_list_info);

    rrc_csp_int_data.bplmn_dual_mode_enabled = rrcmcm_is_mode_enabled_in_rat_pri_list(
                &plmn_list_req_ptr->rat_pri_list_info,SYS_SYS_MODE_GSM);

    rrc_csp_int_data.bplmn_wcdma_mode_enabled = rrcmcm_is_mode_enabled_in_rat_pri_list(
                  &plmn_list_req_ptr->rat_pri_list_info,SYS_SYS_MODE_WCDMA);
  }

#ifdef FEATURE_WCDMA_TO_LTE
  if(rrc_bst_band_pref_incl == FALSE)
  {
    rrccsp_update_bplmn_lte_info_from_rat_pri_list(&plmn_list_req_ptr->rat_pri_list_info);
  }
  else
  {
    rrccsp_update_bplmn_lte_info_from_rat_pri_list(&plmn_list_req_ptr->mcc_mode_band_filter);
  }
#endif

#endif
  rrc_csp_int_data.bplmn_search_timer_value = plmn_list_req_ptr->search_timer_value;
  
}


/*===========================================================================

FUNCTION        RRCCSP_HANDLE_PLMN_LIST_REQ_IN_BGND

DESCRIPTION
                This function processes PLMN_LIST_REQ from MM and determines
                if PLMN list search should be done in background or foreground.
                BPLMN state is updated and appropriate timers are started within
                this function to do PLMN search in background
                
DEPENDENCIES
                None

RETURN VALUE
                TRUE: PLMN_LIST_REQ should be handled in background
                FALSE: PLMN_LIST_REQ should be handled in foreground

SIDE EFFECTS
                None

===========================================================================*/
boolean rrccsp_handle_plmn_list_req_in_bgnd(rrc_plmn_list_req_type  *plmn_list_req_ptr)
{
  rrc_state_e_type rrc_state         =  rrc_get_state();
  boolean          status            = TRUE;
  uint32 i;
  uint8    trans_id = plmn_list_req_ptr->trans_id;


  /* Process PLMN LIST REQ received from MM in background when RRC is in disconnected 
   * state, CELL_PCH or URA_PCH states
   */

  /* Automatic PLMN list request received */
  if(plmn_list_req_ptr->network_select_mode == SYS_NETWORK_SELECTION_MODE_AUTOMATIC)
  {
    rrc_csp_int_data.bplmn_nw_sel_mode = plmn_list_req_ptr->network_select_mode;

    rrc_csp_int_data.bplmn_num_req      = plmn_list_req_ptr->plmn_list.length;
    rrc_csp_int_data.wtow_bplmn_num_req = 0;
    rrc_csp_int_data.service_search_bgnd = plmn_list_req_ptr->service_search;
    WRRC_MSG2_HIGH("Automatic PLMN LIST REQ rcvd in RRC st: %d svc_srch_bgnd rcvd from NAS = %d", rrc_state, rrc_csp_int_data.service_search_bgnd);
    
    if((rrc_csp_int_data.bplmn_num_req < 1) || (rrc_csp_int_data.bplmn_num_req > SYS_PRIORITY_PLMN_LIST_MAX_LENGTH))
    {
      WRRC_MSG1_ERROR("WTOW ERR: Automatic PLMN LIST REQ rcvd with #PLMNs %d", rrc_csp_int_data.bplmn_num_req);

      rrc_csp_bplmn_send_mm_plmn_list_cnf_cmd(WTOW_SEARCH_ABORT,trans_id);
    }
    /* Initialize appropriate variables to begin background PLMN search */
    else
    {
      /* Print the Higher Priority PLMNs received from NAS */
      WRRC_MSG1_HIGH("WTOW: PLMNs in NAS request list: %d", rrc_csp_int_data.bplmn_num_req);
      for(i=0; i<rrc_csp_int_data.bplmn_num_req; ++i)
      {
        rrc_csp_int_data.bplmn_req_list[i].plmn_id =
             mmumts_convert_nas_plmn_id_to_rrc_plmn_id(plmn_list_req_ptr->plmn_list.info[i].plmn);
        rrc_csp_int_data.bplmn_req_list[i].plmn_type = RRC_GSM_MAP_SPECIFIC_PLMN_REQ;
        rrc_csp_int_data.bplmn_rat_req_list[i] = plmn_list_req_ptr->plmn_list.info[i].rat;

        /* Store W RATs in a separate list */
        if(rrc_csp_int_data.bplmn_rat_req_list[i] == SYS_RAT_UMTS_RADIO_ACCESS)
        {
          rrc_csp_int_data.wtow_bplmn_req_list[rrc_csp_int_data.wtow_bplmn_num_req].plmn_id 
                                                      = rrc_csp_int_data.bplmn_req_list[i].plmn_id;
          rrc_csp_int_data.wtow_bplmn_req_list[rrc_csp_int_data.wtow_bplmn_num_req].plmn_type 
                                                      = rrc_csp_int_data.bplmn_req_list[i].plmn_type;
          ++rrc_csp_int_data.wtow_bplmn_num_req;
        }

        MSG_HIGH("%d-%d, RAT %d", RRC_CSP_GET_INT_MCC(rrc_csp_int_data.bplmn_req_list[i].plmn_id),
                                  RRC_CSP_GET_INT_MNC(rrc_csp_int_data.bplmn_req_list[i].plmn_id), 
                                  plmn_list_req_ptr->plmn_list.info[i].rat);
      } /* end for loop */

      /* New BPLMN transaction id gets updated in the below function to the CSP
       * global data. A new Auto BPLMN search is never expected to come 
       * when a Manual BPLMN search is in progress
       */
      rrccsp_update_plmn_list_req_data(plmn_list_req_ptr);
      rrccsp_generate_rat_order_for_auto_plmn_srch();
      if(rrc_csp_int_data.plmn_srch_order.num_rats == 0)
      {
        WRRC_MSG0_ERROR("Number of RATS in order is zero");
        rrc_csp_int_data.bplmn_fnd_list_wr_index = 0;
        /* Send the PLMN_LIST_CNF to MM */
        rrc_csp_bplmn_send_mm_plmn_list_cnf_cmd(WTOW_SEARCH_STOP,trans_id);
      }
      else
      {

#ifdef FEATURE_FEMTO_CSG
        /* Clean up ASF search for a NAS requested Auto PLMN search. */
        if(rrc_csp_int_data.csg_asf_srch_in_progress)
        {
          /* Check if guard timer has expired or not. Notice that we are additionally checking
           * for scan type here to take care of the race condition where in the CSP substate
           * guard timer expired and in the same or its pending substate another PLMN_LIST_REQ
           * was received from NAS. In this case the guard timer would have expired but the
           * previous BPLMN search was in progress. Checking for scan type allows RRC to reset 
           * the BPLMN state appropriately.
           */
          if((rrc_csp_int_data.bplmn_guard_srch_tmr_expired)
               && (rrc_csp_int_data.curr_scan != RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN))
          {
            WRRC_MSG0_HIGH("CSG: No need to cleanup ASF here");
          }
          else
          {
            WRRC_MSG0_HIGH("CSG: Clean up ASF");
    
            rrccsp_cleanup_bplmn_state();
          }
        }
#endif

        /* Update appropriate variables so that 3G->3G/2G BPLMN Search can be started when 
        * L1 queries RRC whether it can go to sleep or not.
        */
        rrc_csp_int_data.bplmn_crit_sec_flag = TRUE;
        rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_START, FALSE, FALSE);
        rrccsp_generate_bplmn_rat_srch_order_update_curr_srch_rat(SYS_NETWORK_SELECTION_MODE_AUTOMATIC);

        rrc_csp_int_data.bplmn_crit_sec_flag = FALSE;
      } 
    }
  } 
  /* Manual PLMN list request received */
  else if(plmn_list_req_ptr->network_select_mode == SYS_NETWORK_SELECTION_MODE_MANUAL)
  {
    /* Get current UE camped status. If UE is camped then do Manual PLMN
     * Search in background. Also even if UE is camped on acceptable cell,
     * Manual Search should be done in background due to SIB update pages 
     */
    if(   ((RRC_CAMPED_ON == rrc_ccm_get_curr_camping_status(RRC_PROCEDURE_CSP))
           || (rrc_ccm_is_reselection_in_progress())
           || (rrc_csp_int_data.curr_scan == RRC_CSP_LEAVING_CONN_MODE_SCAN)
           || (rrccho_is_wtog_cco_active() && rrcrce_is_abort_in_progress())
           || (rrciho_return_iho_abort()==1) )/*Abort for WtoX-irat procedure in progress*/
       && (rrc_csp_substate != RRCCSP_SUIT_CELL_SEL_WT_CAMP_PENDING)
       && (rrc_csp_substate != RRCCSP_ACCEPT_CELL_SEL_WT_CAMP_PENDING)
      )
    {
      WRRC_MSG2_HIGH("WTOW: Manual req rcvd RRC st %d. Current Scan %d. bgnd", 
                                      rrc_state, rrc_csp_int_data.curr_scan);

      /* Check if guard timer has expired or not. Notice that we are additionally checking
       * for scan type here to take care of the race condition where in the CSP substate
       * guard timer expired and in the same or its pending substate another PLMN_LIST_REQ
       * was received from NAS. In this case the guard timer would have expired but the
       * previous BPLMN search was in progress. Checking for scan type allows RRC to reset 
       * the BPLMN state appropriately.
       */
      if((rrc_csp_int_data.bplmn_guard_srch_tmr_expired)
           && (rrc_csp_int_data.curr_scan != RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
             && (rrc_csp_int_data.curr_scan != RRC_CSP_WTOW_BPLMN_MANUAL_SCAN))
      {
        WRRC_MSG0_HIGH("WTOW Initialize vars to do Manual BPLMN search");
      }
      else
      {
        rrccsp_cleanup_bplmn_state();
      }

      /* Any access to the database should be under the critical section flag */
      rrc_csp_int_data.bplmn_crit_sec_flag = TRUE;

      /* Set state so that BPLMN search can be started */
      rrc_csp_int_data.bplmn_nw_sel_mode = plmn_list_req_ptr->network_select_mode;
#ifdef FEATURE_FEMTO_CSG
      rrc_csp_int_data.service_search_bgnd = plmn_list_req_ptr->service_search;
      WRRC_MSG1_HIGH("CSG: Filled service_search %d", rrc_csp_int_data.service_search_bgnd);
      /* Store current camped information for finger printing */
      rrccsp_csg_set_fp_info();
#endif
      rrccsp_update_plmn_list_req_data(plmn_list_req_ptr);
      rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_START, FALSE, FALSE);

      WRRC_MSG2_HIGH("WTOW: dual_mode_enabled = %d, wcdma_mode_enabled = %d in PLMN_LIST_REQ", 
      rrc_csp_int_data.bplmn_dual_mode_enabled,rrc_csp_int_data.bplmn_wcdma_mode_enabled);

      rrccsp_generate_bplmn_rat_srch_order_update_curr_srch_rat(SYS_NETWORK_SELECTION_MODE_MANUAL);

      rrc_csp_int_data.bplmn_crit_sec_flag = FALSE;

      if(rrc_csp_int_data.bplmn_wcdma_mode_enabled)
      {
        /* Add registered PLMN to the found list by default */
        rrccsp_update_wtow_manual_bplmn_list_with_rplmn(rrc_csp_int_data.curr_acq_entry.plmn_id,
                                                        rrc_csp_int_data.curr_acq_entry.cell_id);
      }
    }
    /* UE is not camped */
    else
    {
#ifdef FEATURE_FEMTO_CSG
      rrc_csp_int_data.service_search_bgnd = plmn_list_req_ptr->service_search;
      WRRC_MSG1_HIGH("CSG: Filled service_search %d", rrc_csp_int_data.service_search_bgnd);
      /* Store current camped information for finger printing */
      rrccsp_csg_set_fp_info();
#endif
      /* UE in disconnected state */
      if(rrc_state == RRC_STATE_DISCONNECTED)
      {
        WRRC_MSG2_HIGH("WTOW: UE NOT camped. curr nw sel %d. Manual. RRC st %d. Fgnd",
                                              rrc_csp_int_data.network_select_mode, rrc_state);
        rrc_csp_int_data.network_select_mode = SYS_NETWORK_SELECTION_MODE_MANUAL;
        rrccsp_generate_bplmn_rat_srch_order_update_curr_srch_rat(SYS_NETWORK_SELECTION_MODE_MANUAL);
        status = FALSE;
      }
      /* UE in CELL_PCH or URA_PCH States */
      else
      {
        WRRC_MSG1_ERROR("WTOW ERR: UE NOT camped. Manual list req rcvd in RRC st %d. Send list cnf imm",
                                                                            rrc_state);

        rrc_csp_int_data.bplmn_nw_sel_mode = plmn_list_req_ptr->network_select_mode;

        /* Send the PLMN_LIST_CNF to MM */
        rrc_csp_bplmn_send_mm_plmn_list_cnf_cmd(WTOW_SEARCH_ABORT,trans_id);
      }
    }
  } 
  /* Incorrect network select mode received in the PLMN list request from NAS */
  else
  {
    WRRC_MSG1_ERROR("WTOW ERR: Incorrect n/w sel mode %d rcvd in PLMN LIST REQ. Send list cnf imm",
                              plmn_list_req_ptr->network_select_mode);

    rrc_csp_int_data.bplmn_nw_sel_mode = plmn_list_req_ptr->network_select_mode;

    /* Send the PLMN_LIST_CNF to MM */
    rrc_csp_bplmn_send_mm_plmn_list_cnf_cmd(WTOW_SEARCH_ABORT,trans_id);
  }
  
  return status; 
} /* rrccsp_handle_plmn_list_req_in_bgnd */


/*===========================================================================

FUNCTION   RRCCSP_SEND_BPLMN_SLEEP_ABORT_IND

DESCRIPTION

  This function sends a CPHY_BPLMN_SLEEP_ABORT_IND to indicate L1 to wake up from sleep
          
DEPENDENCIES

  None.
 
RETURN VALUE

  None.

SIDE EFFECTS

  None.

===========================================================================*/
static void rrccsp_send_bplmn_sleep_abort_ind( void )
{
  l1_ext_cmd_type *l1_cmd_ptr;

  /* Get a L1 command buffer */
  l1_cmd_ptr = l1_get_cmd_buf();

  /* Fill in the Command Header */
  l1_cmd_ptr->cmd_hdr.cmd_id = CPHY_BPLMN_SLEEP_ABORT_IND;

#ifdef FEATURE_DUAL_SIM
  l1_cmd_ptr->cmd_hdr.sys_modem_as_id = rrc_get_as_id();
#endif

  /* Now send the primitive to L1 */
  l1_put_cmd(l1_cmd_ptr);
  WRRC_MSG0_HIGH("CPHY_BPLMN_SLEEP_ABORT_IND sent to L1");
  
} /* end of rrccsp_send_bplmn_sleep_abort_ind */

/*===========================================================================

FUNCTION        rrccsp_handle_plmn_list_req

DESCRIPTION
                This function processes PLMN_LIST_REQ from MM.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_handle_plmn_list_req( rrc_csp_substate_e_type csp_substate,
                             rrc_plmn_list_req_type *plmn_list_req_ptr )
{
  rrc_csp_substate_e_type next_substate = csp_substate;
  rrc_state_e_type curr_state = rrc_get_state(); 


  #ifdef FEATURE_UMTS_ACQ_CHNL_INFO_SHARING
  /* Clear RRC acq channel db to remove any stale information */
  rrc_clear_acq_chnl_info();
  /* Clear RR acq channel db to remove any stale information */
  rr_rrc_clear_acq_chnl_info_internal();
  #endif

  /* Reset the do_lfs_scan flag as LFS is not to be followed for PLMN list scan. */
  rrc_csp_int_data.do_lfs_scan = FALSE;

  if(rrccsp_handle_plmn_list_req_in_bgnd(plmn_list_req_ptr))
  {
    /* Send CPHY_BPLMN_SLEEP_ABORT_IND to L1 for aborting sleep so that can l1 go to sleep can be
       made sooner resulting in BPLMN search earlier. WL1 handled this command only in PCH SLEEP 
       as of now */
    if((FALSE == is_sleep_drv_not_in_sleep()) &&
       (RRC_CAMPED_ON == rrc_ccm_get_curr_camping_status(RRC_PROCEDURE_CSP)) 
       && ((curr_state == RRC_STATE_DISCONNECTED) || 
           (curr_state == RRC_STATE_CELL_PCH) || 
           (curr_state == RRC_STATE_URA_PCH)))
    {
      rrccsp_send_bplmn_sleep_abort_ind();
    }

    if(rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED)
    {
      next_substate = RRCCSP_CAMPED_ACCEPT_CELL;
    }
    else
    {
      next_substate = RRCCSP_CAMPED_SUIT_CELL;
    }
  }
  /* PLMN list search should be done in foreground */
  else
  {
    rrc_csp_int_data.plmn_list.num_plmns = 0;

    rrccsp_update_plmn_list_req_data(plmn_list_req_ptr);

    /*For foreground searches overwrite band preference blindly. 
      It will anways get updated for next service request*/
    rrc_csp_int_data.band_pref = rrc_csp_int_data.bplmn_band_pref;
    rrccsp_update_band_preference();

    next_substate = rrc_csp_start_sel_for_plmn_list();
  }
  return( next_substate );

} /* rrccsp_handle_plmn_list_req */

/*===========================================================================

FUNCTION        RRCCSP_SEND_MODE_CHANGE_REQ_TO_MCM

DESCRIPTION
                This function sends a RRC_MODE_CHANGE_REQ (with the desired
                mode) to MCM.

DEPENDENCIES
                None

RETURN VALUE
                None

SIDE EFFECTS
                None

===========================================================================*/
void rrccsp_send_mode_change_req_to_mcm( rrc_mode_e_type rrc_mode)
{
  rrc_cmd_type *csp_out_cmd_ptr;
  
  if((csp_out_cmd_ptr = rrc_get_int_cmd_buf()) != NULL)
  {
    /* Initialize the command header first */
    csp_out_cmd_ptr->cmd_hdr.cmd_id = RRC_CHANGE_MODE_REQ;
    csp_out_cmd_ptr->cmd.change_mode_req.procedure = RRC_PROCEDURE_CSP;
    csp_out_cmd_ptr->cmd.change_mode_req.mode = rrc_mode;
    
    /* Fill the irat cause based on the current scan type */
    switch(rrc_csp_int_data.curr_scan)
    {
    case RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN:
    case RRC_CSP_GTOW_BPLMN_MANUAL_SCAN:
    case RRC_CSP_WTOG_BPLMN_AUTOMATIC_SCAN:
    case RRC_CSP_WTOG_BPLMN_MANUAL_SCAN:
      csp_out_cmd_ptr->cmd.change_mode_req.reason = INTERRAT_BPLMN;
      break;
      
    case RRC_CSP_GSM_TO_WCDMA_CELL_RESELECTION_SCAN:
    case RRC_CSP_WCDMA_TO_GSM_CELL_RESELECTION_SCAN:
    case RRC_CSP_WCDMA_TO_GAN_CELL_RESELECTION_SCAN:
    case RRC_CSP_GSM_TO_WCDMA_REDIRECTION_SCAN:
    case RRC_CSP_GAN_TO_WCDMA_RESELECTION_SCAN:
    case RRC_CSP_GO_TO_IDLE_DETACHED_SCAN:
      csp_out_cmd_ptr->cmd.change_mode_req.reason = INTERRAT_RESELECTION;
      break;
      
    case RRC_CSP_INTER_RAT_REDIRECTION_SCAN:
      csp_out_cmd_ptr->cmd.change_mode_req.reason = INTERRAT_REDIRECTION;
      break;
      
    case RRC_CSP_CELL_DCH_TO_CELL_FACH_SCAN:
    case RRC_CSP_CELL_DCH_TO_CELL_PCH_SCAN:
    case RRC_CSP_CELL_DCH_TO_URA_PCH_SCAN:
      if(rrc_mode == RRC_MODE_STANDBY)
      {
        if(WTOW_SEARCH_STOP != rrc_csp_bplmn_srch_in_progress())
        {
          rrccsp_cleanup_bplmn_state();
        }
      }
    case RRC_CSP_CELL_SELECTION_SCAN:
    case RRC_CSP_OUT_OF_SERVICE_AREA_IN_IDLE_STATE_SCAN:
    case RRC_CSP_OUT_OF_SERVICE_AREA_IN_CONNECTING_STATE_SCAN:
    case RRC_CSP_OUT_OF_SERVICE_AREA_SCAN:
    case RRC_CSP_CELL_FACH_TO_CELL_FACH_SCAN:
    case RRC_CSP_CELL_FACH_TO_CELL_PCH_SCAN:
    case RRC_CSP_CELL_FACH_TO_URA_PCH_SCAN:
    case RRC_CSP_PLMN_LIST_SCAN:
      csp_out_cmd_ptr->cmd.change_mode_req.reason = INTERRAT_OOS;
      break;
#ifdef FEATURE_DUAL_SIM
    case RRC_CSP_UNLOCK_BY_SCAN:
      csp_out_cmd_ptr->cmd.change_mode_req.reason = INTERRAT_DSIM_TUNEAWAY;
      break;
#endif
      
    default:
      csp_out_cmd_ptr->cmd.change_mode_req.reason = INTERRAT_REASON_OTHER;
      break;
    }
    
    /* Send the Command */
    WRRC_MSG2_HIGH("Sending CHANGE_MODE_REQ to MCM for %d mode with reason %d", 
      rrc_mode, csp_out_cmd_ptr->cmd.change_mode_req.reason);
    rrc_put_int_cmd( csp_out_cmd_ptr );
  }
} /* rrccsp_send_mode_change_req_to_mcm */

/*===========================================================================
FUNCTION        RRCCSP_SEND_CONTINUE_STOP_MODE_REQ_TO_MCM

DESCRIPTION
                This function sends a CONTINUE STOP MODE REQ
                 to MCM.
DEPENDENCIES
                None
RETURN VALUE
                None
SIDE EFFECTS
                None
===========================================================================*/
static void rrccsp_send_continue_stop_mode_req_to_mcm(void )
{
  rrc_cmd_type *csp_out_cmd_ptr;
  
  if((csp_out_cmd_ptr = rrc_get_int_cmd_buf()) != NULL)
  {
    /* Initialize the command header first */
    csp_out_cmd_ptr->cmd_hdr.cmd_id = RRC_CONTINUE_STOP_MODE_REQ;
    /* Send the Command */
    WRRC_MSG0_HIGH("Sending RRC_CONTINUE_STOP_MODE_REQ to MCM ");
    rrc_put_int_cmd( csp_out_cmd_ptr );
  }
}
/*===========================================================================

FUNCTION          RRCCSP_UPDATE_SIB3_4_DATA

DESCRIPTION       This function is responsible for updating the SIB3/SIB4
                  information.

DEPENDENCIES


RETURN VALUE
                  None.

SIDE EFFECTS      None.
===========================================================================*/
static rrc_csp_substate_e_type rrccsp_update_sib3_4_data(void)
{
  rrc_csp_cell_bar_e_type        cell_bar_status;
  rrc_csp_access_control_e_type  access_control;
  boolean                        do_cell_selection = FALSE;
  rrc_csp_substate_e_type        next_substate = rrc_csp_substate;
  rrc_to_mm_sink_e_type          mm_cmd_id;
  rrc_dsac_info_type   rrc_dsac_info;
  rrc_state_e_type               rrc_state = rrc_get_state();
  rrc_ppac_info_type             rrc_ppac_info;


  /* Indicates if UE needs stay camped on the barred cell (or) not */
  boolean stay_on_ac_barred_cell = FALSE;

  rrc_plmn_identity_type sib_idx_plmn_id;
  if(rrc_csp_int_data.curr_acq_entry.is_valid_nw_sharing)
  {
    sib_idx_plmn_id = rrc_csp_int_data.curr_acq_entry.shared_list_of_plmns.common_plmn_id;
  }
  else
  {
    sib_idx_plmn_id = rrc_csp_int_data.curr_acq_entry.plmn_id;
  }
  WRRC_MSG2_HIGH("Sib_idx PLMN: MCC %d-MNC %d",RRC_CSP_GET_INT_MCC(sib_idx_plmn_id),RRC_CSP_GET_INT_MNC(sib_idx_plmn_id));

#ifdef FEATURE_STAY_CAMPED_ON_ACCESS_CLASS_BARRED_CELL
  /* if feature is defined then set this flag TRUE */
  stay_on_ac_barred_cell = TRUE;
#endif /* FEATURE_STAY_CAMPED_ON_ACCESS_CLASS_BARRED_CELL */

  /* First check if cell allows Emergency Calls. Cell is not selcted
   * if Emergency calls are NOT allowed.
   */
  
  if(rrc_csp_find_access_control(&access_control, &rrc_dsac_info,
                                 rrc_csp_int_data.curr_acq_entry.plmn_id,
                                 rrc_csp_int_data.curr_acq_entry.cell_id
                                 ,sib_idx_plmn_id
                                 ,&rrc_ppac_info
                                 )
    == FAILURE)
  {
    WRRC_MSG1_ERROR("Failure finding cell access status in CSP sstate %d",
                                                     rrc_csp_substate);
    do_cell_selection = TRUE;
  }

  /* Special handling of GTOW Reselection cases */
  if((rrc_dsac_info.valid == FALSE) && (access_control == RRC_CSP_NO_CELL_ACCESS) && !stay_on_ac_barred_cell)
  {
    if(rrc_csp_int_data.network_select_mode != SYS_NETWORK_SELECTION_MODE_LIMITED)
    {
      WRRC_MSG0_HIGH("No cell access on serving cell. Bar it for 10s");
      /* Send Cell bar request to L1 */
      rrccsp_send_cphy_cell_bar_req(RRC_CSP_WCDMA_PSC_BARRED, 10);
      return(next_substate);
    }
    else
    {
      do_cell_selection = TRUE;
      WRRC_MSG0_HIGH("Do Cell Selection as CELL BAR REQ is not sent to L1");
    }
  }
  else
  {
    /* Generate Cell barred status based on SIB info for this cell */
    if(rrc_csp_find_cell_bar_status(rrc_csp_int_data.curr_acq_entry.plmn_id,
                                    rrc_csp_int_data.curr_acq_entry.cell_id,
                                    &cell_bar_status
                                   ,sib_idx_plmn_id
                                    )
        == FAILURE)
    {
      WRRC_MSG0_ERROR("Failure to fill Cell Barred Status");
      do_cell_selection = TRUE;
    }
    else
    {
      /* Cell is barred. Check if Intra-frequency is allowed or not */
      if(cell_bar_status != RRC_CSP_CELL_OK)
      {
        if(rrc_csp_int_data.network_select_mode != SYS_NETWORK_SELECTION_MODE_LIMITED)
        {
          /* If cell is barred, then go to camped state. RRC should either receive
           * reselection indication or OOS indication from L1 as in the above
           * function, RRC has already sent CPHY_CELL_BAR_REQ to L1
           */
          WRRC_MSG0_HIGH("Serving Cell has become barred");
          if(cell_bar_status == RRC_CSP_CELL_BAR_INTRA_FREQ)
          {
            /* Send Cell bar request to L1 */
            rrccsp_send_cphy_cell_bar_req(RRC_CSP_WCDMA_PSC_BARRED, 
                                                  rrc_csp_int_data.wcdma_cell_time_to_reselect);
          }
          else if(cell_bar_status == RRC_CSP_CELL_BAR_NO_INTRA_FREQ)
          {
            /* Send Cell bar request to L1 */
            rrccsp_send_cphy_cell_bar_req(RRC_CSP_WCDMA_FREQ_BARRED, 
                                                  rrc_csp_int_data.wcdma_cell_time_to_reselect);
          }
          else
          {
            WRRC_MSG1_ERROR("ERR Incorrect cell_bar_status = %d", cell_bar_status);
          }

          return(next_substate);
        }
        /* We do not bar the cell if network select mode is TRUE LIMITED, i.e., when
         * it is SYS_NETWORK_SELECTION_MODE_LIMITED, but we do get-off this cell.
         */
        else
        {
          WRRC_MSG1_HIGH("Cell is barred but NOT sending cell bar req to L1, since n/w sel mode = %d", 
                                                          SYS_NETWORK_SELECTION_MODE_LIMITED);
          do_cell_selection = TRUE;
        }
      }
      else
      {
        /* Cell is not barred, Send RRC_SERVICE_IND to NAS */
        WRRC_MSG0_HIGH("Cell is not barred. Determine if RRC_SERVICE_IND to NAS is needed");

        if(rrc_csp_cmd_to_mm_needed(&mm_cmd_id,
                                    rrc_csp_int_data.last_mm_primitive,
                                    rrc_csp_int_data.curr_service_status)
          == TRUE)
        {
          rrc_csp_send_mm_cmd(mm_cmd_id,
                           rrc_csp_int_data.curr_service_status,
                           &rrc_csp_int_data.curr_sel_plmn,
                           &rrc_csp_int_data.curr_acq_entry);
        }
        else
        {
          /* If SIB3 modification does have DSAC information is present, send service indication
             to NAS always instead of not depending of the current RRC state. i.e. even the function
             rrc_csp_cmd_to_mm_needed() returns false
          */
          if(rrc_dsac_info.valid == TRUE)
          {
            mm_cmd_id =  RRC_SERVICE_IND_FROM_OTA_MSG;
            rrc_csp_send_mm_cmd(mm_cmd_id,
                           rrc_csp_int_data.curr_service_status,
                           &rrc_csp_int_data.curr_sel_plmn,
                           &rrc_csp_int_data.curr_acq_entry);
          }
          else if(rrc_ppac_info.valid == TRUE)
          {
            mm_cmd_id =  RRC_SERVICE_IND_FROM_OTA_MSG;
            rrc_csp_send_mm_cmd(mm_cmd_id,
                           rrc_csp_int_data.curr_service_status,
                           &rrc_csp_int_data.curr_sel_plmn,
                           &rrc_csp_int_data.curr_acq_entry);
          }
          else if(mm_cmd_id == RRC_SERVICE_IND)
          {
            mm_cmd_id =  RRC_SERVICE_IND_FROM_OTA_MSG;
            rrc_csp_send_mm_cmd(mm_cmd_id,
                           rrc_csp_int_data.curr_service_status,
                           &rrc_csp_int_data.curr_sel_plmn,
                           &rrc_csp_int_data.curr_acq_entry);
          }
        }
      }
    }
  }

  if(do_cell_selection)
  {
    if((rrc_state == RRC_STATE_CELL_FACH) ||
       (rrc_state == RRC_STATE_CELL_PCH) ||
       (rrc_state == RRC_STATE_URA_PCH))
    {
      next_substate = rrccsp_send_cell_update_initiate_req(RRC_REENTERED_SERVICE_AREA);
    }
    else
    {
      WRRC_MSG0_HIGH("Treating as OOS, do cell selection");
      next_substate = rrccsp_handle_out_of_service_ind( next_substate );
    }
  }
  else
  {
    WRRC_MSG0_HIGH("Sending CELL_PARM_REQ to L1");
    /* Send CPHY_CELL_PARM_REQ to L1 */
    rrc_csp_send_l1_cmd(RRC_PROCEDURE_CSP, CPHY_CELL_PARM_REQ,
                          &rrc_csp_int_data.curr_acq_entry);
    MSG_LOW("L1 cmd 0x%x sent, CSP sstate %d",
                                   CPHY_CELL_PARM_REQ, rrc_csp_substate, 0);
    }

  return next_substate;

} /* rrccsp_update_sib3_4_data */

/*===========================================================================

FUNCTION          RRCCSP_UPDATE_SIB1_DATA

DESCRIPTION       This function is responsible for updating the SIB1
                  information and sending the indication to MM.

DEPENDENCIES


RETURN VALUE
                  None.

SIDE EFFECTS      None.
===========================================================================*/
static void rrccsp_update_sib1_data(void)
{  
  
  /* Update the ordered config with SIB1 data. This function also checks if SIB1 ptr is not NULL */
  if(rrcllc_update_sib1_data() == SUCCESS)
  {
    /* Send DRX request to L1 */
    rrc_csp_send_l1_drx_req();
  }

} /* rrccsp_update_sib1_data */


/*===========================================================================

FUNCTION          RRCCSP_HANDLE_SIB_CHANGE

DESCRIPTION       This function is responsible for handling SIB1, SIB3, SIB4,
                  SIB5, and SIB6 changes.

DEPENDENCIES


RETURN VALUE
                  None.

SIDE EFFECTS      None.
===========================================================================*/
static rrc_csp_substate_e_type rrccsp_handle_sib_change(rrc_cmd_type *cmd_ptr)
{
  rrc_csp_substate_e_type next_substate = rrc_csp_substate;
  rrc_state_e_type rrc_state = rrc_get_state();
  rrc_sib_change_mask_type sib_change_bit_mask;
  rrc_SysInfoType4 *sib4_ptr ;
  /* pointer to SIB 5*/
  rrc_SysInfoType5    *sib5_ptr = NULL;
  boolean is_service_ind_sent = FALSE;
  rrc_to_mm_sink_e_type   mm_cmd_id;


  sys_hs_ind_e_type new_hs_ind = SYS_HS_IND_HSDPA_HSUPA_UNSUPP_CELL;

  boolean is_sib3_sib4_updated = FALSE;
  rrc_SysInfoType3 *sib3_ptr;

  rrc_plmn_identity_type sib_idx_plmn_id;
  if(rrc_csp_int_data.curr_acq_entry.is_valid_nw_sharing)
  {
    sib_idx_plmn_id = rrc_csp_int_data.curr_acq_entry.shared_list_of_plmns.common_plmn_id;
  }
  else
  {
    sib_idx_plmn_id = rrc_csp_int_data.curr_acq_entry.plmn_id;
  }

  WRRC_MSG2_HIGH("Sib_idx PLMN: MCC %d-MNC %d",RRC_CSP_GET_INT_MCC(sib_idx_plmn_id),RRC_CSP_GET_INT_MNC(sib_idx_plmn_id));

  sib4_ptr = (rrc_SysInfoType4 *) rrc_sibdb_return_sib_for_cell(
                                                       rrc_SIB4,
                                                       sib_idx_plmn_id,
                                                       rrc_csp_int_data.curr_acq_entry.cell_id);

  sib3_ptr = (rrc_SysInfoType3 *) rrc_sibdb_return_sib_for_cell(
                                                       rrc_SIB3, 
                                                       sib_idx_plmn_id,
                                                       rrc_csp_int_data.curr_acq_entry.cell_id);

  sib_change_bit_mask= cmd_ptr->cmd.sib_change_ind.sib_change_mask;

  if((sib_change_bit_mask & SIB_5_BIT)||(sib_change_bit_mask & SIB_6_BIT))
  {
    sib5_ptr = (rrc_SysInfoType5 *)
      rrc_sibdb_return_sib_for_srv_cell(rrc_SIB5);

    if(sib5_ptr == NULL)
    {
      /* SIB5 NOT found */
      ERR("ERR: SIB5 for MCC %d, MNC %d, Cell ID %d not present", 
                                          RRC_CSP_GET_INT_MCC(sib_idx_plmn_id),
                                          RRC_CSP_GET_INT_MNC(sib_idx_plmn_id), 
                                          rrc_csp_int_data.curr_acq_entry.cell_id);
    }
    else
    {
      if(sib_change_bit_mask & SIB_5_BIT)
      {
        WRRC_MSG2_HIGH("SIB 5 change ind st:%d rrc_st:%d",
               rrc_csp_substate,rrc_state);
      }
      if(sib_change_bit_mask & SIB_6_BIT)
      {
        /* Make sure SIB 6 indicator is TRUE in SIB 5 before sending chan_config_req*/
        if (sib5_ptr->sib6indicator == TRUE) 
        {
          WRRC_MSG2_HIGH("SIB 6 change ind st:%d rrc_st:%d",
               rrc_csp_substate,rrc_state);
        }
        else
        {
          WRRC_MSG0_HIGH("Ignore: SIB6 ind in SIB5 is FALSE");
        }
      }
      if((rrc_state != RRC_STATE_CELL_DCH)&&
          (OC_SET_FOR_CELL_DCH != rrcllc_get_ordered_config_status())&&
          (!(/*Case where only sib6 changes & rrc state is CONNECTING
               or DISCONNECTED, then do not take any action*/
                (sib_change_bit_mask & SIB_6_BIT)&&
                (!(sib_change_bit_mask & SIB_5_BIT))&&
                (sib5_ptr->sib6indicator == TRUE)&&
                (
                  (rrc_state == RRC_STATE_DISCONNECTED)||
                  (rrc_state == RRC_STATE_CONNECTING)
                )
             )
          )&&
          (!(/*Case where only sib6 changes & sib5 doesnt have 
               sib6indicator set to TRUE, then do not take any action*/
                (sib_change_bit_mask & SIB_6_BIT)&&
                (!(sib_change_bit_mask & SIB_5_BIT))&&
                (sib5_ptr->sib6indicator == FALSE)
              )
          )
        )
      {
        if (SUCCESS != rrc_csp_send_chan_reconfig())
        {
          ERR_FATAL("Could not send chan cfg req",0,0,0);
        }
        
        /*set sib5_change_in_progress_flag to ACTIVE */
        rrcllc_set_sib5_change_in_progress_flag_to_active();
        
        if ((rrc_state != RRC_STATE_CONNECTING) &&
              (rrc_state != RRC_STATE_CELL_FACH))
        {
          rrc_csp_send_l1_drx_req();
        }
      }
    } 
  }

  if(sib_change_bit_mask & SIB_4_BIT)
  {
    if((rrc_state != RRC_STATE_DISCONNECTED) && (sib4_ptr != NULL))
    {
      next_substate = rrccsp_update_sib3_4_data();
      is_sib3_sib4_updated = TRUE;
    }
    else
    {
      WRRC_MSG1_HIGH("UE in RRC state %d or SIB4 absent. Ignoring SIB4 modification", rrc_state);
    }
  }

  if(sib_change_bit_mask & SIB_3_BIT)
  {
    /* If RRC is in IDLE-DISCONNECTED always read SIB3*/
    if((rrc_state == RRC_STATE_DISCONNECTED)||(rrc_state == RRC_STATE_CONNECTING)||(sib4_ptr == NULL))
    {
      next_substate = rrccsp_update_sib3_4_data();
    }
    else if(( rrc_csp_int_data.is_curr_dsac_info_valid == TRUE ) || 
               ((sib3_ptr != NULL) && (TRUE == rrc_check_if_dsac_is_present(sib3_ptr))))
    {
      next_substate = rrccsp_update_sib3_4_data();
      is_sib3_sib4_updated = TRUE;
    }
  }

  /*If is_sib3_sib4_updated is set to true then as part of sending MM cmd, HS cap is sent in handling rrccsp_update_sib3_4_data*/
  if((sib_change_bit_mask & SIB_5_BIT)&&
        (rrc_state != RRC_STATE_CELL_DCH) && (!is_sib3_sib4_updated)
    )
  {
    /* Get HS Capability Indication */
    if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
    {
      WRRC_MSG0_HIGH("RRCHS: SIB5 Changed");
      new_hs_ind = rrc_get_3g_cell_capability_indicator();
      if (new_hs_ind == hsdpa_hsupa_ind)
      {
        WRRC_MSG1_HIGH("RRCHS:New SIB same HS Cap %d",hsdpa_hsupa_ind); 
      }
      else
      {
        hsdpa_hsupa_ind = new_hs_ind;
        WRRC_MSG1_HIGH("RRCHS:Send new HS Cap %d", hsdpa_hsupa_ind);
        rrc_send_3g_cell_capability_information(hsdpa_hsupa_ind);
      }
    }
  }

  if((sib_change_bit_mask & SIB_1_BIT) && (sib_change_bit_mask & SIB_3_BIT))
  {
    if(rrc_state == RRC_STATE_DISCONNECTED)
    {
      rrccsp_update_sib1_data();
      /* Avoid sending one more SERVICE_IND as one is already sent as part of SIB3/SIB4 modification */
      is_service_ind_sent = TRUE;
      WRRC_MSG1_HIGH("Setting is_service_ind_sent to %d",is_service_ind_sent);
    }
  }

  if((sib_change_bit_mask & SIB_1_BIT) && (is_service_ind_sent==FALSE))
  {
    if(rrc_state == RRC_STATE_DISCONNECTED)
    {
      rrccsp_update_sib1_data();
      /* Send Service Indication to MM with the NAS common information from SIB1 */
      if((rrc_csp_cmd_to_mm_needed(&mm_cmd_id,
                                rrc_csp_int_data.last_mm_primitive,
                                rrc_csp_int_data.curr_service_status)
         == TRUE))
      {
        rrc_csp_send_mm_cmd(mm_cmd_id,
                             rrc_csp_int_data.curr_service_status,
                             &rrc_csp_int_data.curr_sel_plmn,
                             &rrc_csp_int_data.curr_acq_entry);
      }
    }
    else
    {
      WRRC_MSG0_HIGH("Ignoring SIB1 change");
    }
  }

  /*If PARM_REQ is not already sent to WL1, send it if SIB11/SIB12 changed*/
  if(!(is_sib3_sib4_updated) &&
       ((sib_change_bit_mask & SIB_11_BIT) || (sib_change_bit_mask & SIB_12_BIT)))
  {
    WRRC_MSG0_HIGH("Sending CELL_PARM_REQ to L1 for SIB11/SIB12 change");
    rrc_csp_send_l1_cmd(RRC_PROCEDURE_CSP, CPHY_CELL_PARM_REQ,
                          &rrc_csp_int_data.curr_acq_entry);
      MSG_LOW("L1 cmd 0x%x sent, CSP sstate %d",
                                   CPHY_CELL_PARM_REQ, rrc_csp_substate, 0);
    }
  return next_substate;
}

/*===========================================================================

FUNCTION RRCCSP_PROCESS_LOWER_LAYER_DEACT_CNF

DESCRIPTION

  This function processes the LOWER_LAYER_DEACT_CNF received from LLC and sends
  the DEACT_CNF to MM

DEPENDENCIES

  None.

RETURN VALUE

  None.

SIDE EFFECTS

  None.

===========================================================================*/

static void rrccsp_process_lower_layer_deact_cnf(void)
{
  mm_cmd_type *mm_buf_ptr;

#ifdef FEATURE_GAN_3G_ROVE_OUT_ONLY
  #error code not present
#endif
  /* SEND THE DEACT_CNF to MM */
  /* Get a buffer from MM task */
  mm_buf_ptr = mm_rrc_get_cmd_buf(RRC_DEACT_CNF);

  /* Update the Max HFNs values to be stored in SIM or USIM */
  (void) rrcsmc_append_hfns_to_rel_ind(mm_buf_ptr->cmd.rrc_deact_cnf.hfn_cs,
                                       mm_buf_ptr->cmd.rrc_deact_cnf.hfn_ps);

#ifdef FEATURE_DUAL_SIM
  mm_buf_ptr->cmd.rrc_deact_cnf.as_id = rrc_get_as_id();
#endif

  WRRC_MSG0_HIGH("Dispatching out MM cmd RRC_DEACT_CNF / DEACT_CNF sent to MM");
  /* Put the command on MM queue */
  rrc_send_rrc_message_to_mm(mm_buf_ptr);

}

/*===========================================================================

FUNCTION        rrccsp_force_send_deact_cnf

DESCRIPTION     This function handles the subsequent DEACT_REQ came from NAS
                even .when Lower Layers are already deactivated.

DEPENDENCIES
                None

RETURN VALUE
                None

SIDE EFFECTS
                None

===========================================================================*/
void rrccsp_force_send_deact_cnf(void)
{
  mm_cmd_type *mm_buf_ptr;
  mm_buf_ptr = mm_rrc_get_cmd_buf(RRC_DEACT_CNF);
/* Update the Max HFNs values to be stored in SIM or USIM */
  (void) rrcsmc_append_hfns_to_rel_ind(mm_buf_ptr->cmd.rrc_deact_cnf.hfn_cs,
                                       mm_buf_ptr->cmd.rrc_deact_cnf.hfn_ps);

#ifdef FEATURE_DUAL_SIM
  mm_buf_ptr->cmd.rrc_deact_cnf.as_id = rrc_get_as_id();
#endif
  WRRC_MSG0_HIGH("function rrccsp_force_send_deact_cnf is called : Dispatching out MM Cmd RRC_DEACT_CNF / DEACT_CNF sent to MM(forced)");
  rrc_send_rrc_message_to_mm(mm_buf_ptr);
}

/*===========================================================================

FUNCTION        rrc_csp_process_pending_dch_fach_pch_timer_expiry

DESCRIPTION     This common function could be called from any substate when
                a pending DCH to FACH/CELL_PCH/URA_PCH timer expiry event
                needs to be processed. It puts lower layers to Idle and sends
                a response back to MM.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure
                (RRCCSP_NO_CELL_SELECTED)

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrc_csp_process_pending_dch_fach_pch_timer_expiry(void)
{
  rrc_csp_substate_e_type  next_substate;

  WRRC_MSG0_HIGH("Send ind to CU so that CU can trigger OOS");
  next_substate = rrccsp_send_cell_update_initiate_req(RRC_REENTERED_SERVICE_AREA);

  return(next_substate);
} /* rrc_csp_process_pending_dch_fach_pch_timer_expiry */

/*===========================================================================

FUNCTION        RRC_CSP_PROCESS_PENDING_FACH_TO_FACH_PCH_TIMER_EXPIRY

DESCRIPTION     This function could be called from any substate when
                a pending FACH to FACH/CELL_PCH/URA_PCH timer expiry event
                needs to be processed. It sends CELL UPDATE INITIATE request
                to CU which inturn triggers OOS.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure
                RRCCSP_CAMPED_SUIT_CELL/RRCCSP_CAMPED_ACCEPT_CELL based
                on the network select mode.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrc_csp_process_pending_fach_to_fach_pch_timer_expiry(void)
{
  rrc_csp_substate_e_type  next_substate;

  WRRC_MSG0_HIGH("Send ind to CU so that CU can trigger OOS");
  next_substate = rrccsp_send_cell_update_initiate_req(RRC_REENTERED_SERVICE_AREA);

  return(next_substate);
} /* rrc_csp_process_pending_fach_to_fach_pch_timer_expiry */

/*===========================================================================

FUNCTION        rrc_csp_process_pending_bplmn_srch_timer_expiry

DESCRIPTION     Handles pending BPLMN search timer expiry.

DEPENDENCIES
                None

RETURN VALUE
                None

SIDE EFFECTS
                None

===========================================================================*/
static void rrc_csp_process_pending_bplmn_srch_timer_expiry(void)
{
  rrc_csp_substate_e_type curr_csp_substate = rrc_csp_substate;

  WRRC_MSG1_HIGH("BPLMN:pending_bplmn_srch_tmr_exp clld in sstate=%d", rrc_csp_substate);

  switch(curr_csp_substate)
  {
    case RRCCSP_CELL_SEL_WT_ACQ_PENDING:
    case RRCCSP_CELL_SEL_WT_SIB:
      /* Acq succeeded but BPLMN Timer expired, therefore try acquistion on
       * the same freq. when BPLMN search continues.
       */
      if(rrc_csp_int_data.bplmn_acq_status)
      {
        WRRC_MSG0_HIGH("BPLMN/WTOW Timer expired: Acq Succeeded before SIBs cld be read");

        /* If acquisition scan is not part of rrccsp_try_next_best_cell_if_available()
         * and freq acquisition is part of database scan. (In case of frequency scan, rd_index
         * is not used).
         */
        if(!rrc_csp_int_data.bplmn_sib_try_next_best_cell)
        {
          if(rrc_csp_curr_select_data.acq_db_in_use)
          {
            rrccsp_bplmn_update_stored_acq_db_rd_index();
          }
          else
          {
            /* If acquisition scan is not part of rrccsp_try_next_best_cell_if_available()
             * and (fine) freq acquisition is part of frequency scan then try the same frequency again.
             */
            --rrc_csp_curr_select_data.scan_info.fine_scan.curr_freq_index;
            WRRC_MSG1_HIGH("BPLMN/WTOW updating curr_freq_index to %d", rrc_csp_curr_select_data.scan_info.fine_scan.curr_freq_index);
          }
        } /* end bplmn_sib_try_next_best_cell*/
        else
        {
          WRRC_MSG0_HIGH("BPLMN:Acq success part of try next best cell");
#ifdef FEATURE_FEMTO_CSG
          if(((rrc_csp_int_data.service_search_bgnd == SYS_SERVICE_SEARCH_CSG)&&
             ((rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN)||
              (rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_MANUAL_SCAN)))||
              (((rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN && 
               rrc_csp_int_data.service_search_bgnd == SYS_SERVICE_SEARCH_CSG)||
               (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN &&
                rrc_csp_int_data.csg_asf_srch_in_progress))))
          {
            if(rrc_csp_curr_select_data.acq_db_in_use)
            {
              /*Reset the acq db index, since this is part of next best cell there is a chance of
                ACQ list getting modified due to previous cell SIB reading.*/
              rrccsp_bplmn_set_stored_acq_db_rd_index(0);
              rrccsp_bplmn_update_stored_acq_db_rd_index();
            }
            else
            {
              --rrc_csp_curr_select_data.scan_info.fine_scan.curr_freq_index;
              WRRC_MSG1_HIGH("BPLMN/WTOW updating curr_freq_index to %d", rrc_csp_curr_select_data.scan_info.fine_scan.curr_freq_index);
            }
          }
#endif
        }
      } /* end bplmn_acq_status*/
      else
      {
        WRRC_MSG0_HIGH("BPLMN/WTOWTmrExp;AcqFailed;not updating acq_db_rd_ix/freq_ix");
      }
      break;


    case RRCCSP_CELL_SEL_WT_FREQ_SCAN_CNF_PENDING:
      /* Nothing to be done in this case */
      break;


    case RRCCSP_CELL_SEL_WT_SIB_PENDING:
       /* Update BPLMN ACQ data with next best cell*/
      if((rrc_csp_int_data.bplmn_acq_succ_scr_code_det > 0) &&
          (rrc_csp_int_data.bplmn_acq_succ_curr_acq_count
            < rrc_csp_int_data.bplmn_acq_succ_scr_code_det))
      {
        rrc_csp_int_data.bplmn_acq_succ_scr_code = 
          rrc_csp_int_data.scr_code_det[rrc_csp_int_data.bplmn_acq_succ_curr_acq_count].scr_code;
        rrc_csp_int_data.bplmn_acq_succ_freq = rrc_csp_int_data.curr_acq_entry.freq;
        rrc_csp_int_data.bplmn_acq_succ_pn_pos = 
          rrc_csp_int_data.scr_code_det[rrc_csp_int_data.bplmn_acq_succ_curr_acq_count++].pn_pos;

        rrc_csp_int_data.bplmn_sib_try_next_best_cell = TRUE;

        if(rrc_csp_curr_select_data.acq_db_in_use)
        {
          /*Reset the acq db index, since this is part of next best cell there is a chance ofACQ list getting modified due to 
                     previous cell SIB reading*/
            rrccsp_bplmn_set_stored_acq_db_rd_index(0);
            /*This will take care of MSG HIGH*/
            rrccsp_bplmn_update_stored_acq_db_rd_index();
        }
        else
        {
          --rrc_csp_curr_select_data.scan_info.fine_scan.curr_freq_index;
          WRRC_MSG1_HIGH("BPLMN/WTOW updating curr_freq_index to %d", rrc_csp_curr_select_data.scan_info.fine_scan.curr_freq_index);
        }
      }
      break;


    default:
        WRRC_MSG1_ERROR("BPLMN/WTOW ERR: TmrExp. PENDING SSTATE %d not handled", curr_csp_substate);
        break;

  } /* end switch statement */

} /* rrc_csp_process_pending_bplmn_srch_timer_expiry */


/*===========================================================================

FUNCTION        RRCCSP_SEND_CAMP_CNF_TO_CHO

DESCRIPTION
                This function sends a RRC_CSP_CAMP_CNF with the Camping
                Success or failure and failure cause.

DEPENDENCIES
                None

RETURN VALUE
                None

SIDE EFFECTS
                None

===========================================================================*/
static void rrccsp_send_camp_cnf_to_cho( uecomdef_status_e_type camping_status )
{
  rrc_cmd_type *csp_out_cmd_ptr;

  if((csp_out_cmd_ptr = rrc_get_int_cmd_buf()) != NULL)
  {
    /* Initialize the command header first */
    csp_out_cmd_ptr->cmd_hdr.cmd_id = RRC_CSP_CAMP_CNF;
  }

  /* Fill the camping status */
  csp_out_cmd_ptr->cmd.rrc_csp_camp_cnf.camping_status = camping_status;

  if(camping_status == FAILURE)
  {
    /* Fill the reason for the camping failure */
    csp_out_cmd_ptr->cmd.rrc_csp_camp_cnf.failure_cause =
      rrc_csp_int_data.interrat_reselect_failure_reason;

    switch(rrc_csp_int_data.interrat_reselect_failure_reason)
    {
      case RRC_WCDMA_CELL_QUALITY_FAILURE:
        csp_out_cmd_ptr->cmd.rrc_csp_camp_cnf.squalmin =
          rrc_csp_int_data.wcdma_cell_squalmin;
        csp_out_cmd_ptr->cmd.rrc_csp_camp_cnf.srxlevmin =
          rrc_csp_int_data.wcdma_cell_srxlevmin;
        csp_out_cmd_ptr->cmd.rrc_csp_camp_cnf.time_to_reselect =
          rrc_csp_int_data.wcdma_cell_time_to_reselect;
        break;

      case RRC_WCDMA_CELL_BARRED:
      case RRC_WCDMA_UARFCN_BARRED:
        csp_out_cmd_ptr->cmd.rrc_csp_camp_cnf.time_to_reselect =
          rrc_csp_int_data.wcdma_cell_time_to_reselect;
        break;

      case RRC_WCDMA_FORBIDDEN_LA:
        /* For now set the time to reselect to 30 mins */
        csp_out_cmd_ptr->cmd.rrc_csp_camp_cnf.time_to_reselect = 1800;
        csp_out_cmd_ptr->cmd.rrc_csp_camp_cnf.PLMN =
          mmumts_convert_rrc_plmn_id_to_nas_plmn_id(rrc_csp_int_data.forbidden_lai.plmn);
        csp_out_cmd_ptr->cmd.rrc_csp_camp_cnf.forbidden_lac[0] =
          rrc_csp_int_data.forbidden_lai.lac[0];
        csp_out_cmd_ptr->cmd.rrc_csp_camp_cnf.forbidden_lac[1] =
          rrc_csp_int_data.forbidden_lai.lac[1];
        break;

      default:
        csp_out_cmd_ptr->cmd.rrc_csp_camp_cnf.time_to_reselect =
          rrc_csp_int_data.wcdma_cell_time_to_reselect;
        break;
    }
  }

  /* Send the Command */
  WRRC_MSG0_HIGH("Sending RRC_CSP_CAMP_CNF to CHO");
  rrc_put_int_cmd( csp_out_cmd_ptr );

}

/*===========================================================================

FUNCTION        RRC_IS_S_CRITERIA_MET

DESCRIPTION
                This function is called during GTOW and WTOW Automatic BPLMN search 
                to determine if the cell satisfies S-criteria before adding the PLMN 
                to the available PLMN list. 

DEPENDENCIES
                None

RETURN VALUE
                TRUE:  S criteria met
                FALSE: S criteria not met

SIDE EFFECTS
                None

===========================================================================*/
boolean rrc_is_s_criteria_met(rrc_plmn_identity_type plmn_id, rrc_int_cell_id_type cell_id)
{
  rrc_SysInfoType3 *sib3_ptr;
  boolean status = FALSE;

  rrc_Q_QualMin_Offset Q_QualMin_offset = 0;
  rrc_Q_RxlevMin_Offset Q_RxlevMin_offset = 0;
  rrc_CellSelectReselectInfo_v590ext *sib3_ext_ptr = NULL;

  /* Check if S-criteria is met before adding this PLMN to the available
   * PLMN list 
   */

  /* For WTOW & GTOW Auto BPLMN scans, SIBs are stored in BPLMN DB */
  if((rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN)
  ||(rrc_csp_int_data.curr_scan ==RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN))
  {
    sib3_ptr = (rrc_SysInfoType3 *) rrc_bplmn_return_sib_for_cell(
                                         rrc_SIB3);
  }
  else if ((rrc_csp_int_data.curr_scan == RRC_CSP_CELL_SELECTION_SCAN)
           ||(rrc_csp_int_data.curr_scan == RRC_CSP_OUT_OF_SERVICE_AREA_SCAN)
           )
  {
    sib3_ptr = (rrc_SysInfoType3 *)rrc_sibdb_return_sib_for_cell(rrc_SIB3,plmn_id,cell_id);
  }
  /* Only for GTOW and WTOW Automatic Scans this function should be called. */
  else
  {
    WRRC_MSG1_ERROR("ERR: call to fn rrc_is_s_criteria_met() with incorrect scan type %d",
                                                      rrc_csp_int_data.curr_scan);

    return( FALSE );
  }
  if( sib3_ptr == NULL )
  {
    /* SIB3 for this PLMN, Cell ID combination not present. 
     */
    ERR("SIB3 for MCC %d, MNC %d, Cell ID %d not present", 
                                        RRC_CSP_GET_INT_MCC(plmn_id),
                                        RRC_CSP_GET_INT_MNC(plmn_id), 
                                        cell_id);
    return( FALSE );
  }
  if((sib3_ptr->m.v4b0NonCriticalExtensionsPresent) &&
     (sib3_ptr->v4b0NonCriticalExtensions.m.v590NonCriticalExtensionPresent) &&
     (sib3_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.sysInfoType3_v590ext.m. 
      cellSelectReselectInfo_v590extPresent))
  {
    sib3_ext_ptr = &(sib3_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
                   sysInfoType3_v590ext.cellSelectReselectInfo_v590ext);
  }
  if(RRC_CHECK_COMMON_MSG_TYPE(sib3_ptr->cellSelectReselectInfo.modeSpecificInfo, 
           rrc_CellSelectReselectInfoSIB_3_4_modeSpecificInfo_fdd))
  {  
    /* When UE camped on for full service on VPLMN cell, and */
    if((((rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
            && (rrc_csp_int_data.prev_network_select_mode == SYS_NETWORK_SELECTION_MODE_AUTOMATIC)) ||
        ((rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN)
            && (rrc_csp_int_data.gsm_camped_suitably)))
        && (rrc_csp_int_data.service_search_bgnd == SYS_SERVICE_SEARCH_NONE))
    {
      if((RRC_CHECK_MSG_TYPE_IE_PTR(sib3_ptr, v4b0NonCriticalExtensionsPresent)) &&
        (RRC_CHECK_MSG_TYPE_IE(sib3_ptr->v4b0NonCriticalExtensions, v590NonCriticalExtensionPresent)) &&
        (RRC_CHECK_MSG_TYPE_IE(sib3_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension, v5c0NoncriticalExtensionPresent)) &&
        (RRC_CHECK_MSG_TYPE_IE(sib3_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.v5c0NoncriticalExtension, v670NonCriticalExtensionPresent)) &&
        (RRC_CHECK_MSG_TYPE_IE(sib3_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.v5c0NoncriticalExtension.v670NonCriticalExtension, v770NonCriticalExtensionPresent)))
      {
        if(RRC_CHECK_MSG_TYPE_IE(sib3_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.v5c0NoncriticalExtension.v670NonCriticalExtension.v770NonCriticalExtension.sysInfoType3_v770ext, q_QualMin_OffsetPresent))
        {
          Q_QualMin_offset = sib3_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.v5c0NoncriticalExtension.v670NonCriticalExtension.v770NonCriticalExtension.sysInfoType3_v770ext.q_QualMin_Offset;
        }
        if(RRC_CHECK_MSG_TYPE_IE(sib3_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.v5c0NoncriticalExtension.v670NonCriticalExtension.v770NonCriticalExtension.sysInfoType3_v770ext, q_RxlevMin_OffsetPresent))
        {
          Q_RxlevMin_offset = sib3_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.v5c0NoncriticalExtension.v670NonCriticalExtension.v770NonCriticalExtension.sysInfoType3_v770ext.q_RxlevMin_Offset;
        }
      }
      if((sib3_ext_ptr != NULL) && 
         (RRC_MSG_COMMON_BITMASK_IE_TYPE2_PTR(sib3_ext_ptr,deltaQrxlevmin)))
      {
        WRRC_MSG1_HIGH("Serving Delta-Qrxlev= %d ", (sib3_ext_ptr->deltaQrxlevmin * 2));
      }

      MSG_5(MSG_SSID_DIAG, MSG_LEGACY_HIGH,
           "Qualmin %d, Rxlevmin %d, MaxULTxPower %d, Q_QualMin_offset %d, Q_RxlevMin_offset %d", 
                            (int16)sib3_ptr->cellSelectReselectInfo.modeSpecificInfo.u.fdd->q_QualMin,
                            (int16)((sib3_ptr->cellSelectReselectInfo.modeSpecificInfo.u.fdd->q_RxlevMin*2) + 1),
                            (int16)(sib3_ptr->cellSelectReselectInfo.maxAllowedUL_TX_Power),
                            (int16)(Q_QualMin_offset),
                            (int16)(Q_RxlevMin_offset));

#ifndef FEATURE_WCDMA_FREE_FLOATING_TASK
      if((sib3_ext_ptr != NULL) && 
         (RRC_MSG_COMMON_BITMASK_IE_TYPE2_PTR(sib3_ext_ptr,deltaQrxlevmin)))
      {
        status = l1_is_s_criteria_met(
                (int16)(sib3_ptr->cellSelectReselectInfo.modeSpecificInfo.u.fdd->q_QualMin + Q_QualMin_offset),
                (int16)((sib3_ptr->cellSelectReselectInfo.modeSpecificInfo.u.fdd->q_RxlevMin * 2) + 1 + 
                 (sib3_ext_ptr->deltaQrxlevmin * 2) + (Q_RxlevMin_offset * 2)), 
                (int16)(sib3_ptr->cellSelectReselectInfo.maxAllowedUL_TX_Power));
      }
      else
      {
        status = l1_is_s_criteria_met(
                (int16)(sib3_ptr->cellSelectReselectInfo.modeSpecificInfo.u.fdd->q_QualMin + Q_QualMin_offset),
                (int16)((sib3_ptr->cellSelectReselectInfo.modeSpecificInfo.u.fdd->q_RxlevMin * 2) + 1 + (Q_RxlevMin_offset * 2)), 
                (int16)(sib3_ptr->cellSelectReselectInfo.maxAllowedUL_TX_Power));
      }
#else
      if((sib3_ext_ptr != NULL) && 
         (RRC_MSG_COMMON_BITMASK_IE_TYPE2_PTR(sib3_ext_ptr,deltaQrxlevmin)))
      {
        status = rrcff_l1_is_s_criteria_met(
                 (int16)(sib3_ptr->cellSelectReselectInfo.modeSpecificInfo.u.fdd->q_QualMin + Q_QualMin_offset),
                 (int16)((sib3_ptr->cellSelectReselectInfo.modeSpecificInfo.u.fdd->q_RxlevMin * 2) + 1 +
                  (sib3_ext_ptr->deltaQrxlevmin * 2) + (Q_RxlevMin_offset * 2)), 
                 (int16)(sib3_ptr->cellSelectReselectInfo.maxAllowedUL_TX_Power));
      }
      else
      {
        status = rrcff_l1_is_s_criteria_met(
                 (int16)(sib3_ptr->cellSelectReselectInfo.modeSpecificInfo.u.fdd->q_QualMin + Q_QualMin_offset),
                 (int16)((sib3_ptr->cellSelectReselectInfo.modeSpecificInfo.u.fdd->q_RxlevMin * 2) + 1 + (Q_RxlevMin_offset * 2)), 
                 (int16)(sib3_ptr->cellSelectReselectInfo.maxAllowedUL_TX_Power));
      }
#endif
    }
    else
    {
      MSG_HIGH("Qualmin %d, Rxlevmin %d, MaxULTxPower %d", 
                            (int16)sib3_ptr->cellSelectReselectInfo.modeSpecificInfo.u.fdd->q_QualMin,
                            (int16)((sib3_ptr->cellSelectReselectInfo.modeSpecificInfo.u.fdd->q_RxlevMin*2) + 1),
                            (int16)(sib3_ptr->cellSelectReselectInfo.maxAllowedUL_TX_Power));
#ifndef FEATURE_WCDMA_FREE_FLOATING_TASK
      if((sib3_ext_ptr != NULL) && 
         (RRC_MSG_COMMON_BITMASK_IE_TYPE2_PTR(sib3_ext_ptr,deltaQrxlevmin)))
      {
        status = l1_is_s_criteria_met(
                (int16)sib3_ptr->cellSelectReselectInfo.modeSpecificInfo.u.fdd->q_QualMin,
                (int16)((sib3_ptr->cellSelectReselectInfo.modeSpecificInfo.u.fdd->q_RxlevMin*2) + 1 +
                 (sib3_ext_ptr->deltaQrxlevmin * 2)), 
                (int16)(sib3_ptr->cellSelectReselectInfo.maxAllowedUL_TX_Power));
      }
      else
      {
        status = l1_is_s_criteria_met(
                (int16)sib3_ptr->cellSelectReselectInfo.modeSpecificInfo.u.fdd->q_QualMin,
                (int16)((sib3_ptr->cellSelectReselectInfo.modeSpecificInfo.u.fdd->q_RxlevMin*2) + 1), 
                (int16)(sib3_ptr->cellSelectReselectInfo.maxAllowedUL_TX_Power));
      }
#else
      if((sib3_ext_ptr != NULL) && 
         (RRC_MSG_COMMON_BITMASK_IE_TYPE2_PTR(sib3_ext_ptr,deltaQrxlevmin)))
      {
        status = rrcff_l1_is_s_criteria_met(
                 (int16)(sib3_ptr->cellSelectReselectInfo.modeSpecificInfo.u.fdd->q_QualMin),
                 (int16)((sib3_ptr->cellSelectReselectInfo.modeSpecificInfo.u.fdd->q_RxlevMin * 2) + 1 +
                  (sib3_ext_ptr->deltaQrxlevmin * 2)), 
                 (int16)(sib3_ptr->cellSelectReselectInfo.maxAllowedUL_TX_Power));
      }
      else
      {
        status = rrcff_l1_is_s_criteria_met(
                 (int16)(sib3_ptr->cellSelectReselectInfo.modeSpecificInfo.u.fdd->q_QualMin),
                 (int16)((sib3_ptr->cellSelectReselectInfo.modeSpecificInfo.u.fdd->q_RxlevMin * 2) + 1), 
                 (int16)(sib3_ptr->cellSelectReselectInfo.maxAllowedUL_TX_Power));
      }
#endif
    }
  }
  else
  {
    WRRC_MSG1_ERROR("ERR: SIB3 mode_choice NOT FDD %d", sib3_ptr->cellSelectReselectInfo.modeSpecificInfo.t);
  }

  return (status);

} /* rrc_is_s_criteria_met */



/*===========================================================================

FUNCTION        rrc_check_serv_cell_s_crit

DESCRIPTION
                This function is called after SIB3 for the serving cell
                to determine if the cell satisfies S-criteria before proceeding
                with reading of other SIBs

DEPENDENCIES
                None

RETURN VALUE
                TRUE:  S criteria met
                FALSE: S criteria not met

SIDE EFFECTS
                None

===========================================================================*/

boolean rrc_check_serv_cell_s_crit(rrc_SysInfoType3 * sib3_ptr)
{
  rrc_CellSelectReselectInfoSIB_3_4 *sib3_4_cell_select_ptr =NULL;
  boolean    s_crit_eval  = FALSE;
  int16 q_rxlevmin,max_UL_tx_pwr;
  rrc_CellSelectReselectInfo_v590ext *sib3_ext_ptr = NULL;
  sib3_4_cell_select_ptr = &(sib3_ptr->cellSelectReselectInfo);

  if((sib3_ptr->m.v4b0NonCriticalExtensionsPresent) &&
     (sib3_ptr->v4b0NonCriticalExtensions.m.v590NonCriticalExtensionPresent) &&
     (sib3_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.sysInfoType3_v590ext.m. 
      cellSelectReselectInfo_v590extPresent))
  {
    sib3_ext_ptr = &(sib3_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
                   sysInfoType3_v590ext.cellSelectReselectInfo_v590ext);
  }

  if(RRC_CHECK_COMMON_MSG_TYPE(sib3_4_cell_select_ptr->modeSpecificInfo,
     rrc_CellSelectReselectInfoSIB_3_4_modeSpecificInfo_fdd))
  {
    rrc_csp_int_data.wcdma_cell_squalmin = (int16)sib3_4_cell_select_ptr->modeSpecificInfo.u.fdd->q_QualMin;
    q_rxlevmin = (int16)(sib3_4_cell_select_ptr->modeSpecificInfo.u.fdd->q_RxlevMin*2 + 1);
    max_UL_tx_pwr = (int16)sib3_4_cell_select_ptr->maxAllowedUL_TX_Power;

    MSG_HIGH("Qualmin %d, Rxlevmin %d, MaxULTxPower %d", 
             rrc_csp_int_data.wcdma_cell_squalmin,
             q_rxlevmin,
             max_UL_tx_pwr);
    if((sib3_ext_ptr != NULL) && 
       (RRC_MSG_COMMON_BITMASK_IE_TYPE2_PTR(sib3_ext_ptr,deltaQrxlevmin)))
    {
      WRRC_MSG1_HIGH("Serving Delta-Qrxlev= %d ", (sib3_ext_ptr->deltaQrxlevmin * 2));
      q_rxlevmin += sib3_ext_ptr->deltaQrxlevmin * 2;
    }

#ifdef RF_MULTIMODE
          rrc_csp_int_data.wcdma_cell_srxlevmin =
            q_rxlevmin + MAX((max_UL_tx_pwr - RFUMTS_UE_MAX_TX_POWER), 0 );
#else /* RF_MULTIMODE */
          rrc_csp_int_data.wcdma_cell_srxlevmin =
            q_rxlevmin + MAX((max_UL_tx_pwr - RF_UE_MAX_TX_POWER), 0 );
#endif /* RF_MULTIMODE */

#ifndef FEATURE_WCDMA_FREE_FLOATING_TASK
      s_crit_eval = l1_is_s_criteria_met(
                    rrc_csp_int_data.wcdma_cell_squalmin,
                    q_rxlevmin, 
                    max_UL_tx_pwr);
#else
      s_crit_eval = rrcff_l1_is_s_criteria_met(
                    rrc_csp_int_data.wcdma_cell_squalmin,
                    q_rxlevmin,
                    max_UL_tx_pwr);
#endif
  }
  else
  {
    WRRC_MSG1_ERROR("ERR: SIB3 mode_choice NOT FDD %d", sib3_ptr->cellSelectReselectInfo.modeSpecificInfo.t);
  }

  WRRC_MSG1_HIGH("S Criteria : %d", s_crit_eval);

  return s_crit_eval;
}


/*===========================================================================

FUNCTION        RRC_IS_NBR_S_CRITERIA_MET

DESCRIPTION
                This function is called after reading SIBs for the neighbor cell
                to determine if the cell satisfies S-criteria before proceeding
                with cell change. 

DEPENDENCIES
                None

RETURN VALUE
                TRUE:  S criteria met
                FALSE: S criteria not met

SIDE EFFECTS
                None

===========================================================================*/
static boolean rrc_is_nbr_s_criteria_met(rrc_plmn_identity_type plmn_id, rrc_int_cell_id_type cell_id)
{
  rrc_SysInfoType3   *sib3_ptr;
  rrc_SysInfoType4   *sib4_ptr;
  rrc_CellSelectReselectInfoSIB_3_4 *sib3_4_cell_select_ptr;
  rrc_state_e_type   rrc_state = rrc_get_state();
  boolean            status    = FALSE;
  rrc_CellSelectReselectInfo_v590ext *sib3_ext_ptr = NULL;


  rrc_plmn_identity_type sib_idx_plmn_id;

  if(rrc_csp_int_data.new_cell_acq_entry.is_valid_nw_sharing)
  {
    sib_idx_plmn_id = rrc_csp_int_data.new_cell_acq_entry.shared_list_of_plmns.common_plmn_id;
  }
  else
  {
    sib_idx_plmn_id = plmn_id;
  }
  WRRC_MSG2_HIGH("Sib_idx PLMN: MCC %d-MNC %d",RRC_CSP_GET_INT_MCC(sib_idx_plmn_id),RRC_CSP_GET_INT_MNC(sib_idx_plmn_id));
  /* PLMN and Cell ID of the current camped on cell are known. Get SIB3 */
  sib3_ptr = (rrc_SysInfoType3 *) rrc_sibdb_return_sib_for_cell(
                            rrc_SIB3, 
                            sib_idx_plmn_id, cell_id);
  if( sib3_ptr == NULL )
  {
    /* SIB3 for this PLMN, Cell ID combination not present 
     * This should NOT happen 
     */
    ERR("ERR SIB3 for MCC %d, MNC %d, Cell ID %d not present", 
          RRC_CSP_GET_INT_MCC(sib_idx_plmn_id), RRC_CSP_GET_INT_MNC(sib_idx_plmn_id), cell_id);
    return(FALSE);
  }
  if((sib3_ptr->m.v4b0NonCriticalExtensionsPresent) &&
     (sib3_ptr->v4b0NonCriticalExtensions.m.v590NonCriticalExtensionPresent) &&
     (sib3_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.sysInfoType3_v590ext.m. 
      cellSelectReselectInfo_v590extPresent))
  {
    sib3_ext_ptr = &(sib3_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
                   sysInfoType3_v590ext.cellSelectReselectInfo_v590ext);
  }

  if((rrc_state != RRC_STATE_DISCONNECTED) && (rrc_state != RRC_STATE_CONNECTING))
  {
    if(sib3_ptr->sib4indicator == TRUE)
    {
      /* Read SIB4. If it's not there mark an error and continue with SIB3 */
      sib4_ptr = (rrc_SysInfoType4 *) rrc_sibdb_return_sib_for_cell(
                                rrc_SIB4, 
                                sib_idx_plmn_id, cell_id);
      if( sib4_ptr == NULL )
      {
        /* SIB4 not present */
        WRRC_MSG0_ERROR("SIB4 indicated but not present, using SIB3");
        sib3_4_cell_select_ptr = &(sib3_ptr->cellSelectReselectInfo);
      }
      else
      {
        sib3_4_cell_select_ptr = &(sib4_ptr->cellSelectReselectInfo);
      }
    }
    else
    {
      sib3_4_cell_select_ptr = &(sib3_ptr->cellSelectReselectInfo);
    }
  }
  else
  {
    sib3_4_cell_select_ptr = &(sib3_ptr->cellSelectReselectInfo);
  }


  if(RRC_CHECK_COMMON_MSG_TYPE(sib3_4_cell_select_ptr->modeSpecificInfo,
           rrc_CellSelectReselectInfoSIB_3_4_modeSpecificInfo_fdd))
  {
    MSG_HIGH("Qualmin %d, Rxlevmin %d, MaxULTxPower %d", 
                            (int16)sib3_4_cell_select_ptr->modeSpecificInfo.u.fdd->q_QualMin,
                            (int16)((sib3_4_cell_select_ptr->modeSpecificInfo.u.fdd->q_RxlevMin*2) + 1),
                            (int16)(sib3_4_cell_select_ptr->maxAllowedUL_TX_Power));
    if((sib3_ext_ptr != NULL) && 
       (RRC_MSG_COMMON_BITMASK_IE_TYPE2_PTR(sib3_ext_ptr,deltaQrxlevmin)))
    {
      WRRC_MSG1_HIGH("Serving Delta-Qrxlev= %d ", (sib3_ext_ptr->deltaQrxlevmin * 2));
    }

#ifndef FEATURE_WCDMA_FREE_FLOATING_TASK
    if((sib3_ext_ptr != NULL) &&
       (RRC_MSG_COMMON_BITMASK_IE_TYPE2_PTR(sib3_ext_ptr,deltaQrxlevmin)))
    {
      status = l1_is_s_criteria_met(
                (int16)sib3_4_cell_select_ptr->modeSpecificInfo.u.fdd->q_QualMin,
                (int16)((sib3_4_cell_select_ptr->modeSpecificInfo.u.fdd->q_RxlevMin*2) + 1 +
                 (sib3_ext_ptr->deltaQrxlevmin * 2)), 
                (int16)(sib3_4_cell_select_ptr->maxAllowedUL_TX_Power));
    }
    else
    {
      status = l1_is_s_criteria_met(
                (int16)sib3_4_cell_select_ptr->modeSpecificInfo.u.fdd->q_QualMin,
                (int16)((sib3_4_cell_select_ptr->modeSpecificInfo.u.fdd->q_RxlevMin*2) + 1), 
                (int16)(sib3_4_cell_select_ptr->maxAllowedUL_TX_Power));
    }
#else
    if((sib3_ext_ptr != NULL) &&
       (RRC_MSG_COMMON_BITMASK_IE_TYPE2_PTR(sib3_ext_ptr,deltaQrxlevmin)))
    {
      status = rrcff_l1_is_s_criteria_met(
               (int16)sib3_4_cell_select_ptr->modeSpecificInfo.u.fdd->q_QualMin,
               (int16)((sib3_4_cell_select_ptr->modeSpecificInfo.u.fdd->q_RxlevMin*2) + 1 +
                (sib3_ext_ptr->deltaQrxlevmin * 2)), 
               (int16)(sib3_4_cell_select_ptr->maxAllowedUL_TX_Power));
    }
    else
    {
      status = rrcff_l1_is_s_criteria_met(
               (int16)sib3_4_cell_select_ptr->modeSpecificInfo.u.fdd->q_QualMin,
               (int16)((sib3_4_cell_select_ptr->modeSpecificInfo.u.fdd->q_RxlevMin*2) + 1), 
               (int16)(sib3_4_cell_select_ptr->maxAllowedUL_TX_Power));
    }
#endif
  }
  else
  {
    WRRC_MSG1_ERROR("ERR: SIB3 mode_choice NOT FDD %d", sib3_ptr->cellSelectReselectInfo.modeSpecificInfo.t);
  }

  return (status);
} /* rrc_is_nbr_s_criteria_met */

/*===========================================================================

FUNCTION        rrc_csp_return_pending_type

DESCRIPTION
                This function returns the CSP pending command type.

DEPENDENCIES
                None

RETURN VALUE
                CSP Pending type.

SIDE EFFECTS
                None

===========================================================================*/

rrc_csp_pending_e_type rrc_csp_return_pending_type()
{
  return rrc_csp_int_data.pending_type;
}

/* =======================================================================
**       Function Definitions for substate: RRCCSP_NO_CELL_SELECTED
** ======================================================================= */

/*===========================================================================

FUNCTION        rrccsp_no_cell_sel_srvc_req

DESCRIPTION     This function processes a Service Request when in
                RRCCSP_NO_CELL_SELECTED substate. It verifies contents of Service
                Request and sends an Acq.Req to L1.

                Note that the Stored Acquisition database will have to be
                searched for the requested PLMN.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_no_cell_sel_srvc_req( rrc_cmd_type *cmd_ptr )
{

  rrc_csp_substate_e_type  next_substate;
  rrc_to_mm_sink_e_type    mm_cmd_id;


  next_substate = RRCCSP_NO_CELL_SELECTED;

  rrccsp_cleanup_bplmn_state();

  rrc_csp_init_data_from_service_req(&cmd_ptr->cmd.rrc_service_req);

  /* Optimization (stand by time improvement) - if recently no service
   * was returned to NAS, then if another svc_req is received from NAS
   * before the no svc timer expires then return no svc immediately
   * if all bands since the start of the no service timer have been
   * serviced at least once.
   */

   if(    (rrc_csp_int_data.ue_in_deep_sleep)
       && (!rrc_csp_int_data.deep_sleep_no_svc_tmr_expired)
       && (rrc_csp_int_data.plmn_list.num_plmns==0)
       && (rrc_csp_int_data.network_select_mode != SYS_NETWORK_SELECTION_MODE_LIMITED)
       && (rrc_csp_int_data.network_select_mode != SYS_NETWORK_SELECTION_MODE_MANUAL)
#ifdef FEATURE_FEMTO_CSG
       && (rrc_csp_int_data.network_select_mode != SYS_NETWORK_SELECTION_MODE_MANUAL_CSG)
       && (rrc_csp_int_data.curr_req_plmn.csg_id == SYS_CSG_ID_INVALID)
#endif
       /* When ACQ DB only scan is requested perform ACQ DB search even though
        * deep sleep no service timer is running 
        */
       && (rrc_csp_int_data.srvc_req_scan_scope != SYS_SCAN_SCOPE_ACQ_DB)
#ifdef FEATURE_EOOS
       #error code not present
#endif
     )
   {
#ifdef FEATURE_WCDMA_MULTIBAND
     /* Check if all the supported bands have been scanned at least
      * once since the start of the no service timer
      */
     if((((rrc_csp_int_data.deep_sleep_no_svc_band_scanned_mask & rrc_csp_int_data.wcdma_band_mask)
                                                            ^ rrc_csp_int_data.wcdma_band_mask)== 0) ||
         ((rrc_lo_access_class == RRC_LO_ACCESS_CLASS_ABSENT) && (rrc_csp_int_data.curr_req_plmn.plmn_type == RRC_GSM_MAP_SPECIFIC_PLMN_REQ))
        )
     {
       WRRC_MSG2_HIGH("DS: Either No svc tmr has not expired or Low acess class is absent. deep_sleep_no_svc_band_scanned_mask=%d, wcdma_band_mask=%d",
                                    rrc_csp_int_data.deep_sleep_no_svc_band_scanned_mask,
                                    rrc_csp_int_data.wcdma_band_mask);

       if(!((rrc_lo_access_class == RRC_LO_ACCESS_CLASS_ABSENT) && (rrc_csp_int_data.curr_req_plmn.plmn_type == RRC_GSM_MAP_SPECIFIC_PLMN_REQ)))
       {
         /* The agc thresh cnt is decremented here because it is incremented in the call to
          * the function rrc_csp_init_data_from_service_req() above even when service search
          * is not done.
          */
         if(rrc_csp_int_data.agc_threshold_cnt == 0)
         {
           rrc_csp_int_data.agc_threshold_cnt = 11;
           WRRC_MSG1_HIGH("Resetting agc_threshold_cnt from 0 to %d", 
                                              rrc_csp_int_data.agc_threshold_cnt);
         }
         else
         {
           --rrc_csp_int_data.agc_threshold_cnt;
           WRRC_MSG1_HIGH("Decrementing agc_threshold_cnt to %d", 
                                              rrc_csp_int_data.agc_threshold_cnt);
         }
       }
       if(rrc_csp_cmd_to_mm_needed(&mm_cmd_id,
                              rrc_csp_int_data.last_mm_primitive,
                              rrc_csp_int_data.curr_service_status)
          == TRUE)
       {
         rrc_csp_send_mm_cmd(mm_cmd_id,
                           rrc_csp_int_data.curr_service_status,
                           &rrc_csp_int_data.curr_sel_plmn,
                           &rrc_csp_int_data.curr_acq_entry);
       }
       return (next_substate);
     }
     /* Amongst the supported bands, at least one of the bands have not been serviced
      * since the start of the no service timer. Service these bands.
      */
     else
     {
       WRRC_MSG2_HIGH("DS: No svc tmr not expired. deep_sleep_no_svc_band_scanned_mask=%d, wcdma_band_mask=%d",
                                rrc_csp_int_data.deep_sleep_no_svc_band_scanned_mask,
                                rrc_csp_int_data.wcdma_band_mask);

       next_substate = rrc_csp_start_sel_on_mm_req();
     }
#else
     WRRC_MSG0_HIGH("DS: No svc tmr has not expired. Return no_svc immediately");

     if(rrc_csp_cmd_to_mm_needed(&mm_cmd_id,
                            rrc_csp_int_data.last_mm_primitive,
                            rrc_csp_int_data.curr_service_status)
        == TRUE)
     {
       rrc_csp_send_mm_cmd(mm_cmd_id,
                         rrc_csp_int_data.curr_service_status,
                         &rrc_csp_int_data.curr_sel_plmn,
                         &rrc_csp_int_data.curr_acq_entry);
     }
#endif
   }
  /* Look for a frequency for this PLMN in RRC CSP Acquisition database now.
   * Store the Acq. entry and type returned by Stored and Initial Selection
   * Controller in the Internal Data.
   */
   else
   {
     next_substate = rrc_csp_start_sel_on_mm_req();
   }

  return( next_substate );

} /* rrccsp_no_cell_sel_srvc_req */


/*===========================================================================

FUNCTION        rrccsp_no_cell_sel_bplmn_srch_req

DESCRIPTION     This function processes RRC_INTERRAT_PLMN_SRCH_REQ when in
                RRCCSP_NO_CELL_SELECTED substate. It initializes internal
                data and sends an Acq.Req to L1.

                Note that the Stored Acquisition database will have to be
                searched for the requested PLMN.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/

static rrc_csp_substate_e_type
rrccsp_no_cell_sel_bplmn_srch_req( void )
{
  rrc_csp_substate_e_type  next_substate;

  rrclog_wcdma_bplmn_scan_start_event_type bplmn_scan_start_event;

  next_substate = RRCCSP_NO_CELL_SELECTED;
  rrc_csp_init_bplmn_data();

  if((rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN) ||
     (rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN))
  {
    //EVENT: Event_BPLMN_Scan_Start_req G2W
    bplmn_scan_start_event.scan_type = RRC_GTOW_BPLMN; 
#ifdef FEATURE_FEMTO_CSG
    if(rrc_csp_int_data.csg_asf_srch_in_progress)
    {
      event_report_payload(EVENT_ASF_SCAN_START, sizeof(bplmn_scan_start_event),
                     (void *)&bplmn_scan_start_event);
    }
    else
#endif
    {
      event_report_payload(EVENT_WCDMA_BPLMN_SCAN_START, sizeof(bplmn_scan_start_event),
                     (void *)&bplmn_scan_start_event);
    }
  }
  else
  {
    /*Event for LTOW BPLMN search*/
  }
  /* Search for the requested PLMNs in RRC CSP Acquisition database now.
   * Store the Acq. entry and type returned by Stored and Initial Selection
   * Controller in the Internal Data.
   */
  next_substate = rrc_csp_start_bplmn_srch();

  return( next_substate );

} /* rrccsp_no_cell_sel_bplmn_srch_req */


/*===========================================================================

FUNCTION        rrccsp_service_bplmn_srch_req

DESCRIPTION     This function processes RRC_BPLMN_SEARCH_RESUME_IND when in
                RRCCSP_CAMPED_SUIT_CELL or RRCCSP_CAMPED_ACCEPT_CELL substate. 
                This command is used to start WTOW and WTOG Background PLMN
                search. Before proceeding with the search, it is checked whether
                the UE should proceed with the search or not. 

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_service_bplmn_srch_req( void )
{
  rrc_csp_substate_e_type     next_substate;
  wtow_bplmn_srch_status_type bplmn_srch_status;
  rrclog_wcdma_bplmn_scan_start_event_type bplmn_scan_start_event;

  if(rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED)
  {
    next_substate = RRCCSP_CAMPED_ACCEPT_CELL;
  }
  else
  {
    next_substate = RRCCSP_CAMPED_SUIT_CELL;
  }

  rrc_csp_int_data.bplmn_crit_sec_flag = TRUE;

  bplmn_srch_status = rrc_csp_bplmn_srch_in_progress();

  if(bplmn_srch_status == WTOW_SEARCH_STOP)
  {
    WRRC_MSG0_HIGH("WTOW: Guard tmr has already expd.or BPLMN cleaned up Ignore resume ind");
  }
  else if(bplmn_srch_status == WTOW_SEARCH_SUSPEND)
  {
    WRRC_MSG0_HIGH("WTOW: BPLMN srch already suspended. Ignore resume ind");
  }
  else if(rrcrce_is_rce_procedure_waiting_for_bplmn())
  {
    if(bplmn_srch_status == WTOW_SEARCH_RESUME)
    {
      if(!rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_active)
      {
        rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_SUSPEND, FALSE, TRUE);
      }
      else
      {
        rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_SUSPEND, FALSE, FALSE);
      }
    }
    WRRC_MSG2_HIGH("WTOW: RCE is active. BPLMN srch status is %d Is BPLMN WTOG %d, Ignore resume ind",bplmn_srch_status,rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_active);
  }
  else if(rrcsib_is_sib_active())
  {
    if(bplmn_srch_status == WTOW_SEARCH_RESUME)
    {
      if(!rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_active)
      {
        rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_SUSPEND, FALSE, TRUE);
      }
      else
      {
        rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_SUSPEND, FALSE, FALSE);
      }
    }
    WRRC_MSG2_HIGH("WTOW: SIB is active. BPLMN srch status is %d Is BPLMN WTOG %d, Ignore resume ind",bplmn_srch_status,rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_active);
  }
  else if(RRCCU_STARTED == rrccu_get_cell_update_started_status())
  {
    if(bplmn_srch_status == WTOW_SEARCH_RESUME)
    {
      if(!rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_active)
      {
        rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_SUSPEND, FALSE, TRUE);
      }
      else
      {
        rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_SUSPEND, FALSE, FALSE);
      }
    }
    WRRC_MSG2_HIGH("WTOW: CU is active. BPLMN srch status is %d Is BPLMN WTOG %d, Ignore resume ind",bplmn_srch_status,rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_active);
  }
  else if(bplmn_srch_status == WTOW_SEARCH_RESUME)
  {
    rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_RESUME, FALSE, FALSE);

    /* WTOW BPLMN search is in progress */
    if(!rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_active)
    {
      WRRC_MSG0_HIGH("WTOW: continue BPLMN search on rcving RESUME_IND");
      
      rrc_csp_init_bplmn_data();
      
      //EVENT: Event_BPLMN_Scan_Start_req W2W
      bplmn_scan_start_event.scan_type = RRC_WTOW_BPLMN; 
      event_report_payload(EVENT_WCDMA_BPLMN_SCAN_START, sizeof(bplmn_scan_start_event),
                     (void *)&bplmn_scan_start_event);

      next_substate = rrc_csp_start_bplmn_srch();
    }
    /* WTOG BPLMN search is in progress */
    else
    {
      next_substate = rrc_csp_resume_wtog_bplmn_srch();
    }  
  }
#ifdef FEATURE_DUAL_SIM
  rrc_add_l1_wakeup_time = FALSE;
#endif
  rrc_csp_int_data.bplmn_crit_sec_flag = FALSE;

  return( next_substate );
} /* rrccsp_service_bplmn_srch_req */    

#ifdef FEATURE_PCS_850_FREQ_SCAN_NEW_OPTIMIZATION
/*===========================================================================

FUNCTION        RRCCSP_CONVERT_ACTIVE_GSM_CHANNELS_TO_UMTS_UARFCNS

DESCRIPTION     This function converts GSM active ARFCNS passed by GSM-RR to equivalent 
                UMTS UARFCNS.

DEPENDENCIES
                None

RETURN VALUE
                None

SIDE EFFECTS
                None

===========================================================================*/
void rrccsp_convert_active_gsm_channels_to_umts_uarfcns
(
  rr_rrc_gsm_cell_list_type  gsm_cell_list
)
{
  uint32    i;

  rrc_csp_int_data.umts_chls_from_gsm.size = 0;

  /* Save the arfcn list sent by GSM */
  rrc_csp_int_data.umts_chls_from_gsm = gsm_cell_list;

  /* Map the GSM ARFCNs to UMTS Channels */
  for(i=0; i<rrc_csp_int_data.umts_chls_from_gsm.size; ++i)
  {
  switch(gsm_cell_list.cells[i].band)
  {
    case SYS_BAND_PCS_1900:
      rrc_csp_int_data.umts_chls_from_gsm.cells[i].num 
            = gsm_cell_list.cells[i].num + GSM_ARFCN_TO_UMTS_CHL_OFFSET_1900_BAND;
      break;

    case SYS_BAND_CELL_850: 
      rrc_csp_int_data.umts_chls_from_gsm.cells[i].num 
            = gsm_cell_list.cells[i].num + GSM_ARFCN_TO_UMTS_CHL_OFFSET_850_BAND;
      break;

    case SYS_BAND_DCS_1800:
      rrc_csp_int_data.umts_chls_from_gsm.cells[i].num 
            = gsm_cell_list.cells[i].num + GSM_ARFCN_TO_UMTS_CHL_OFFSET_1800_BAND;
      break;

    case SYS_BAND_EGSM_900:
    case SYS_BAND_PGSM_900:
    {
       double umts_arfcn;
    if(gsm_cell_list.cells[i].num <= 124)
    {
      umts_arfcn = 5 * (GSM_BASE_BAND_FOR_900_BAND + (0.2 * gsm_cell_list.cells[i].num) 
      + 45 - GSM_ARFCN_TO_UMTS_CHL_OFFSET_900_BAND);
      rrc_csp_int_data.umts_chls_from_gsm.cells[i].num = (uint16)umts_arfcn;
    }
    else
    {
       umts_arfcn = 5 * (GSM_BASE_BAND_FOR_900_BAND + (0.2 * (gsm_cell_list.cells[i].num - 1024)) 
       + 45 - GSM_ARFCN_TO_UMTS_CHL_OFFSET_900_BAND);
       rrc_csp_int_data.umts_chls_from_gsm.cells[i].num = (uint16)umts_arfcn;
    }
    }
    break;

    default:
      WRRC_MSG1_ERROR("Incorrect band information %d", gsm_cell_list.cells[i].band);
      rrc_csp_int_data.umts_chls_from_gsm.cells[i].num = 0;
      break;
  }
  
  MSG_HIGH("GSM arfcn %d, UMTS Channel %d, band %d", 
            gsm_cell_list.cells[i].num, 
            rrc_csp_int_data.umts_chls_from_gsm.cells[i].num,
            gsm_cell_list.cells[i].band);
  }

}
#endif

/*===========================================================================

FUNCTION        RRCCSP_HANDLE_GTOW_REDIRECTION_REQ

DESCRIPTION     This function initiates cell selection on target FDD cell list given by RR on receipt of 
                REDIRECTION_REQ from RR after GSM channel release.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_handle_gtow_redirection_req(rrc_interrat_redirect_req_type  *rrc_redirect_req)
{
  boolean send_reject = FALSE;
  rrc_csp_freq_scan_e_type  type_freq_scan;
  rrc_csp_substate_e_type   next_substate = rrc_csp_substate;
  int i;
  int num_of_target_frequencies = 0;

  rrc_csp_int_data.curr_req_plmn.plmn_id =
    mmumts_convert_nas_plmn_id_to_rrc_plmn_id(
      rrc_redirect_req->PLMN);

  /* Set the current scan type to GSM_REDIRECTION_SCAN */
  rrc_csp_int_data.curr_scan = RRC_CSP_GSM_TO_WCDMA_REDIRECTION_SCAN;
  rrc_csp_int_data.network_select_mode =
    rrc_redirect_req->network_select_mode;

#ifdef FEATURE_RAT_PRIORITY_LIST
  rrc_csp_int_data.rat_pri_list_info = rrc_redirect_req->rat_pri_list_info;
  rrcmcm_update_mode_capability(&rrc_csp_int_data.rat_pri_list_info);
  rrc_csp_int_data.band_pref = rrc_extract_gw_band_pref_from_rat_pri_list(&rrc_csp_int_data.rat_pri_list_info);
  rrccsp_update_band_preference();
#endif

#ifdef FEATURE_WCDMA_DEDICATED_PRI_INFO
/*updating the dedicated priority info received in rrc_redirect_req into global structure (rrc_dedicated_priority_info)*/
  rrcmeas_update_dedicated_priority_info_from_irat_req(&rrc_redirect_req->dedicated_priority_info,
                                   rrc_csp_int_data.curr_req_plmn.plmn_id);

#endif
  MSG_HIGH("GtoW Redirection: N/W sel mode is %d PLMN MCC %d MNC %d", 
                              rrc_csp_int_data.network_select_mode,
                              RRC_CSP_GET_INT_MCC(rrc_csp_int_data.curr_req_plmn.plmn_id),
                              RRC_CSP_GET_INT_MNC(rrc_csp_int_data.curr_req_plmn.plmn_id));
  
  if((rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED) ||
     (rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED_ROUTINE_ACQUISITION))
  {
    rrc_csp_int_data.curr_req_plmn.plmn_type = RRC_GSM_MAP_ANY_PLMN_REQ;
    rrc_csp_int_data.curr_type_acq           = RRC_CSP_ANY_PLMN;
    rrc_csp_curr_select_data.acq_type        = RRC_CSP_ANY_PLMN;
  }
  else
  {
    rrc_csp_int_data.curr_req_plmn.plmn_type = RRC_GSM_MAP_SPECIFIC_PLMN_REQ;
    rrc_csp_int_data.curr_type_acq           = RRC_CSP_SPEC_PLMN;
    rrc_csp_curr_select_data.acq_type        = RRC_CSP_SPEC_PLMN;
  }

#ifdef FEATURE_EOOS
  #error code not present
#endif


#ifdef FEATURE_PCS_850_FREQ_SCAN_NEW_OPTIMIZATION
  /* Map ARFCNs in GSM list to UMTS channels */
  rrccsp_convert_active_gsm_channels_to_umts_uarfcns(rrc_redirect_req->gsm_cell_list);
#endif

  for(i = 0; i < rrc_redirect_req->fdd_target_info.num_of_frequencies; i++)
  {
    if(is_freq_in_overlapping_850_and_800_bands(rrc_redirect_req->fdd_target_info.fdd_cell_list[i].uarfcn))
    {
      if((TRUE == rrccsp_is_mcc_and_850_800_supported_band_comb_valid(
                            rrc_redirect_req->fdd_target_info.fdd_cell_list[i].uarfcn, 
                            rrc_csp_int_data.curr_req_plmn.plmn_id, 
                            W_UARFCN_FROM_GSM_NBR_LIST
                            , FALSE
                            )
         ))
      {
        rrc_csp_int_data.target_fdd_cell_list.fdd_cell_list[num_of_target_frequencies++] = rrc_redirect_req->fdd_target_info.fdd_cell_list[i];
      }
    }
    else if(rrccsp_is_supported_band(rrc_get_frequency_band(rrc_redirect_req->fdd_target_info.fdd_cell_list[i].uarfcn, rrc_csp_int_data.curr_req_plmn.plmn_id)))
    {
      rrc_csp_int_data.target_fdd_cell_list.fdd_cell_list[num_of_target_frequencies++] = rrc_redirect_req->fdd_target_info.fdd_cell_list[i];
    }
  }

  rrc_csp_int_data.target_fdd_cell_list.num_of_frequencies = num_of_target_frequencies;

  if(rrc_csp_int_data.target_fdd_cell_list.num_of_frequencies < 1)
  {
    send_reject = TRUE;
  }
  else
  {
    {
      int j;

      for(i = 0; i< rrc_csp_int_data.target_fdd_cell_list.num_of_frequencies; i++)
      {
        for(j = 0; j< rrc_csp_int_data.target_fdd_cell_list.fdd_cell_list[i].num_of_cells; j++)
        {
          WRRC_MSG2_HIGH("GtoW Redirection: UARFCN is :%d, scr_code is :%d",
                                rrc_csp_int_data.target_fdd_cell_list.fdd_cell_list[i].uarfcn,
                                rrc_csp_int_data.target_fdd_cell_list.fdd_cell_list[i].cell_list[j].scrambling_code);
        }
      }
    }

    rrc_csp_int_data.gtow_redirection_timer_expired = FALSE;
    rrctmr_start_timer(RRCTMR_GTOW_REDIRECTION_WAIT_TIMER, RRCTMR_GTOW_REDIRECTION_WAIT_TIMER_IN_MS);
    rrc_csp_int_data.skip_repeat_scan_for_redir = FALSE;
    rrc_csp_int_data.gtow_redir_retry_lfs_scan = FALSE;

#if defined (FEATURE_WCDMA_TO_LTE) || defined (FEATURE_LTE_TO_WCDMA)
    rrc_csp_int_data.interrat_type = RRC_CSP_INTERRAT_GSM;
#endif

    rrccsp_init_first_band_to_be_scanned();

    if(rrc_csp_start_cell_selection(&rrc_csp_int_data.curr_req_plmn, 
                                    &rrc_csp_int_data.curr_type_acq, 
                                    &rrc_csp_int_data.curr_acq_entry,
                                    &type_freq_scan) 
      == FAILURE)
    {
      /* This is unacceptable since number of target freq are more than 0 */
      ERR_FATAL("GtoW Redirection: Returned Failure", type_freq_scan, 0, 0);
    }

#ifdef FEATURE_DUAL_SIM
    /* Acquire lock before starting ACQ for GTOW redirection */
    rrc_start_lock_wait_timer(RRCTMR_WRM_LOCK_WAIT_TIMER_FOR_INTERRAT_IN_MS,TRUE);
    rrc_csp_int_data.shld_acq_be_spltd = FALSE;
    if(rrc_csp_wait_for_wrm_lock(&type_freq_scan) == RRCCSP_WT_STOP_MODE_CHANGE_CNF)
    {
      rrctmr_stop_timer(RRCTMR_WRM_LOCK_TIMER);
      return (RRCCSP_WT_STOP_MODE_CHANGE_CNF);
    }
#endif

    if(type_freq_scan == RRC_CSP_LIST_SCAN)
    {
      rrc_csp_send_next_freq_to_l1(&rrc_csp_int_data.curr_acq_entry, type_freq_scan);
      next_substate = RRCCSP_CELL_SEL_WT_FREQ_SCAN_CNF;
    }
#ifndef FEATURE_DUAL_SIM
    else
    {
      /* This is unacceptable since a SUCCESS was returned */
      ERR_FATAL("GtoW Redirection: Unexpected scan %d returned", type_freq_scan, 0, 0);
    }
#endif
  }

  if(send_reject)
  {
    rrc_csp_int_data.rsp_to_rr = SEND_GTOW_REDIRECTION_REJECT;
    rrccsp_send_mode_change_req_to_mcm(RRC_MODE_INACTIVE);
    next_substate = RRCCSP_WT_STOP_MODE_CHANGE_CNF;
  }

  return next_substate;
}

#ifdef FEATURE_FEMTO_CSG
/*===========================================================================

FUNCTION        RRCCSP_ADD_ENTRY_TO_TEMP_CSG_DB

DESCRIPTION     Temporarliy stores the CSG cells info found during ASF. Once
                ASF is done, this info is used to send meas request to wl1

DEPENDENCIES
                None

RETURN VALUE
                None

SIDE EFFECTS
                None

===========================================================================*/
static void rrccsp_add_entry_to_temp_csg_db(rrc_sib_event_cnf_type *sib_cnf)
{
  rrc_SysInfoType3 *sib3_ptr;
  uint8 csg_list_idx = rrc_csp_int_data.temp_csg_list.num_entries,i=0;
  boolean match_found = FALSE;

  sib3_ptr = (rrc_SysInfoType3 *) rrc_bplmn_return_sib_for_cell(
                                       rrc_SIB3);

  /*For hybrid cells if CSG ID is not in whitelist invalidate the CSG ID*/
  if (!rrccsp_is_csg_white(sib_cnf->csg_id,sib_cnf->plmn_id))
  {
    sib_cnf->csg_id = SYS_CSG_ID_INVALID;  
  }

  if((sib_cnf->freq == (uint32)rrc_csp_int_data.temp_csg_list.csg_cell_info[csg_list_idx].csg_cell_l1_info.rat_u.wcell.freq) &&
      (sib_cnf->scrambling_code == (rrc_csp_int_data.temp_csg_list.csg_cell_info[csg_list_idx].csg_cell_l1_info.rat_u.wcell.psc * 16))&&
      (rrc_csp_int_data.temp_csg_list.num_entries < MAX_ASF_CELLS))
  {
      rrc_csp_int_data.temp_csg_list.csg_cell_info[csg_list_idx].plmn = sib_cnf->plmn_id;
      rrc_csp_int_data.temp_csg_list.csg_cell_info[csg_list_idx].cell_id = sib_cnf->cell_id;
      rrc_csp_int_data.temp_csg_list.csg_cell_info[csg_list_idx].csg_cell_l1_info.rat_u.wcell.csg_id = sib_cnf->csg_id;

      rrc_csp_int_data.temp_csg_list.csg_cell_info[csg_list_idx].csg_cell_l1_info.rat_u.wcell.q_qualmin = 
                                 (int16)sib3_ptr->cellSelectReselectInfo.modeSpecificInfo.u.fdd->q_QualMin;
      rrc_csp_int_data.temp_csg_list.csg_cell_info[csg_list_idx].csg_cell_l1_info.rat_u.wcell.q_rxlevmin = 
                                 (int16)((sib3_ptr->cellSelectReselectInfo.modeSpecificInfo.u.fdd->q_RxlevMin*2) + 1);
      rrc_csp_int_data.temp_csg_list.csg_cell_info[csg_list_idx].csg_cell_l1_info.rat_u.wcell.max_tx_pwr = 
                                 (int16)(sib3_ptr->cellSelectReselectInfo.maxAllowedUL_TX_Power);

      rrc_csp_int_data.temp_csg_list.num_entries++;

      MSG_8(MSG_SSID_DFLT, MSG_LEGACY_HIGH,
       "num_enries: %d, CSG: PLMN %d:%d, cell_id %d, csg_id %d, q_qualmin=%d, q_rxlevmin=%d, max_tx_pwr=%d", 
         rrc_csp_int_data.temp_csg_list.num_entries,
         RRC_CSP_GET_INT_MCC(sib_cnf->plmn_id), RRC_CSP_GET_INT_MNC(sib_cnf->plmn_id),
         sib_cnf->cell_id, sib_cnf->csg_id,
         rrc_csp_int_data.temp_csg_list.csg_cell_info[csg_list_idx].csg_cell_l1_info.rat_u.wcell.q_qualmin,
         rrc_csp_int_data.temp_csg_list.csg_cell_info[csg_list_idx].csg_cell_l1_info.rat_u.wcell.q_rxlevmin,
         rrc_csp_int_data.temp_csg_list.csg_cell_info[csg_list_idx].csg_cell_l1_info.rat_u.wcell.max_tx_pwr);
  }
  else
  {
    /*It is possible that we have updated an exisitng entry */
    for(i = 0;i < rrc_csp_int_data.temp_csg_list.num_entries;i++)
    {
      if((sib_cnf->freq == (uint32)rrc_csp_int_data.temp_csg_list.csg_cell_info[i].csg_cell_l1_info.rat_u.wcell.freq) &&
         (sib_cnf->scrambling_code == (rrc_csp_int_data.temp_csg_list.csg_cell_info[i].csg_cell_l1_info.rat_u.wcell.psc * 16)))
      {
        match_found = TRUE;
        break;
      }
    }
    if(match_found)
    {
      rrc_csp_int_data.temp_csg_list.csg_cell_info[i].plmn = sib_cnf->plmn_id;
      rrc_csp_int_data.temp_csg_list.csg_cell_info[i].cell_id = sib_cnf->cell_id;
      rrc_csp_int_data.temp_csg_list.csg_cell_info[i].csg_cell_l1_info.rat_u.wcell.csg_id = sib_cnf->csg_id;

      rrc_csp_int_data.temp_csg_list.csg_cell_info[i].csg_cell_l1_info.rat_u.wcell.q_qualmin = 
                                 (int16)sib3_ptr->cellSelectReselectInfo.modeSpecificInfo.u.fdd->q_QualMin;
      rrc_csp_int_data.temp_csg_list.csg_cell_info[i].csg_cell_l1_info.rat_u.wcell.q_rxlevmin = 
                                 (int16)((sib3_ptr->cellSelectReselectInfo.modeSpecificInfo.u.fdd->q_RxlevMin*2) + 1);
      rrc_csp_int_data.temp_csg_list.csg_cell_info[i].csg_cell_l1_info.rat_u.wcell.max_tx_pwr = 
                                 (int16)(sib3_ptr->cellSelectReselectInfo.maxAllowedUL_TX_Power);

      MSG_8(MSG_SSID_DFLT, MSG_LEGACY_HIGH,
        "num_enries: %d,CSG: PLMN %d:%d, cell_id %d, csg_id %d, q_qualmin=%d, q_rxlevmin=%d, max_tx_pwr=%d",
         rrc_csp_int_data.temp_csg_list.num_entries,
         RRC_CSP_GET_INT_MCC(sib_cnf->plmn_id), RRC_CSP_GET_INT_MNC(sib_cnf->plmn_id),
         sib_cnf->cell_id, sib_cnf->csg_id,
         rrc_csp_int_data.temp_csg_list.csg_cell_info[i].csg_cell_l1_info.rat_u.wcell.q_qualmin,
         rrc_csp_int_data.temp_csg_list.csg_cell_info[i].csg_cell_l1_info.rat_u.wcell.q_rxlevmin,
         rrc_csp_int_data.temp_csg_list.csg_cell_info[i].csg_cell_l1_info.rat_u.wcell.max_tx_pwr);
    }
    else
    {
      ERR_FATAL("CSG: Info stored in tempCSG DB on ACQ SUCC is for a diff cell, ACQ SUCC: %d, SIBS_CNF: %d/or temp DB is full", 
        rrc_csp_int_data.temp_csg_list.csg_cell_info[csg_list_idx].csg_cell_l1_info.rat_u.wcell.freq, sib_cnf->freq, 0);
    }
  }

  if(rrc_csp_int_data.temp_csg_list.num_entries == MAX_ASF_CELLS)
  {
    WRRC_MSG0_HIGH("CSG: MAX limit reached for temp CSG DB.");
  }

}

#endif
/*===========================================================================

FUNCTION        RRCCSP_NO_CELL_SELECTED_HDLR

DESCRIPTION     This is a handler for events received in RRCCSP_NO_CELL_SELECTED
                substate of the Cell Selection Procedure.
                Depending on the event, it further calls a function for
                processing the event in this CSP substate.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/

static rrc_csp_substate_e_type
rrccsp_no_cell_selected_hdlr( rrc_cmd_type *cmd_ptr )
{

  rrc_csp_substate_e_type   next_substate;
  rrc_state_e_type          rrc_state;

  uint32     i;
  boolean err = FALSE;

  /* Inter-RAT command */
  rrc_rr_cmd_type *rr_cmd;

#ifdef FEATURE_DUAL_SIM
    rrc_csp_freq_scan_e_type type_freq_scan;
#endif

  boolean interrat_cmd = FALSE;

#if defined (FEATURE_LTE_TO_WCDMA) || defined (FEATURE_WCDMA_TO_LTE)
  if(cmd_ptr->cmd_hdr.cmd_id == RRC_LTE_RRC_CMD)
  {
    interrat_cmd = TRUE;
  }
#endif

  if((((uint32)cmd_ptr->cmd_hdr.cmd_id & RRC_RR_CMD_ID_BASE) == RRC_RR_CMD_ID_BASE) )
  {
    interrat_cmd = TRUE;
  }

  next_substate = RRCCSP_NO_CELL_SELECTED;

  if(!interrat_cmd )
  {
    switch( cmd_ptr->cmd_hdr.cmd_id )
    {
      case RRC_SERVICE_REQ:
        rrc_state = rrc_get_state();
        if((rrc_state != RRC_STATE_DISCONNECTED)
#ifdef FEATURE_WRLF_SYSTEM_SEL
          && (!RRC_IS_CONN_MODE_OOS_SRCH_IN_PROGRESS())
#endif
         )
        {
          WRRC_MSG1_ERROR("Service req in RRC state %d",rrc_state);
        }

        MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                           cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
        next_substate = rrccsp_no_cell_sel_srvc_req( cmd_ptr );
        break;

      case RRC_ACT_REQ:
        WRRC_MSG2_HIGH( "Cmd 0x%x recvd, CSP sstate %d",
                           cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);
        break;

      case RRC_PLMN_LIST_REQ:
        MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                           cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );

        if(rrccsp_plmn_list_req_is_valid(&(cmd_ptr->cmd.plmn_list_req)))
        {
          next_substate = rrccsp_handle_plmn_list_req(next_substate, 
                                                        &(cmd_ptr->cmd.plmn_list_req));
        }
        break;

      case RRC_CSP_ACQ_REQ:
        WRRC_MSG2_HIGH( "Cmd 0x%x recvd, CSP sstate %d",
                           cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);

        rrc_csp_int_data.curr_acq_entry.freq     = cmd_ptr->cmd.rrc_csp_acq_req.freq;
        rrc_csp_int_data.curr_acq_entry.scr_code = cmd_ptr->cmd.rrc_csp_acq_req.scr_code;
        rrc_csp_int_data.network_select_mode     = cmd_ptr->cmd.rrc_csp_acq_req.network_select_mode;

        if(rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED)
        {
          rrc_csp_int_data.curr_req_plmn.plmn_type = RRC_GSM_MAP_ANY_PLMN_REQ;
          rrc_csp_int_data.curr_type_acq           = RRC_CSP_ANY_PLMN;
          rrc_csp_curr_select_data.acq_type        = RRC_CSP_ANY_PLMN;
        }
        else
        {
          rrc_csp_int_data.curr_req_plmn.plmn_type = RRC_GSM_MAP_SPECIFIC_PLMN_REQ;
          rrc_csp_int_data.curr_type_acq           = RRC_CSP_SPEC_PLMN;
          rrc_csp_curr_select_data.acq_type        = RRC_CSP_SPEC_PLMN;
        }

        if(cmd_ptr->cmd.rrc_csp_acq_req.pn_offset_present)
        {
          rrc_csp_int_data.acq_type = L1_WCDMA_FREQ_SCR_POS;
          rrc_csp_int_data.pn_pos   = cmd_ptr->cmd.rrc_csp_acq_req.pn_pos;
        }
        else
        {
          rrc_csp_int_data.acq_type = L1_WCDMA_FREQ_SCR;
        }

        rrc_csp_int_data.sttd_indicator_present = cmd_ptr->cmd.rrc_csp_acq_req.sttd_indicator_present;
        rrc_csp_int_data.sttd_indicator         = cmd_ptr->cmd.rrc_csp_acq_req.sttd_indicator;
        rrc_csp_int_data.acq_mode               = L1_WCDMA_INTER_S_HO_ACQ;

        /* Send CPHY_ACQ_REQ to L1 and wait for the CNF */
        rrc_csp_send_l1_cmd(RRC_PROCEDURE_CSP, CPHY_ACQ_REQ, &rrc_csp_int_data.curr_acq_entry);
        MSG_MED("L1 cmd 0x%x sent", CPHY_ACQ_REQ, 0, 0);

#ifdef FEATURE_EOOS
        #error code not present
#endif

        /* Start waiting for Acquisition Confirmation */
        next_substate = RRCCSP_CELL_SEL_WT_HANDOVER_ACQ;

        break;

      case RRC_CSP_CAMP_REQ:
        MSG_MED( "RRC Cmd 0x%x recvd, CSP sstate %d",
                           cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
        rrc_csp_int_data.curr_req_plmn.plmn_id =
              cmd_ptr->cmd.rrc_csp_camp_req.requested_plmn;
        rrc_csp_int_data.curr_acq_entry.freq =
          cmd_ptr->cmd.rrc_csp_camp_req.freq;
        rrc_csp_int_data.curr_acq_entry.scr_code =
          cmd_ptr->cmd.rrc_csp_camp_req.scr_code;

        rrc_csp_int_data.acq_mode = L1_WCDMA_INTER_S_RESEL_ACQ;
        rrc_csp_int_data.acq_type = L1_WCDMA_FREQ_SCR;

        /* Send CPHY_ACQ_REQ to L1 and wait for the CNF */
        rrc_csp_send_l1_cmd(RRC_PROCEDURE_CSP, CPHY_ACQ_REQ, &rrc_csp_int_data.curr_acq_entry);
        MSG_MED("L1 cmd 0x%x sent", CPHY_ACQ_REQ, 0, 0);

        /* Set the current scan type to GTOW_CC_ORDER_SCAN */
        rrc_csp_int_data.curr_scan = RRC_CSP_GTOW_CC_ORDER_SCAN;
        rrc_csp_int_data.network_select_mode = cmd_ptr->cmd.rrc_csp_camp_req.network_select_mode;

        if(rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED)
        {
          rrc_csp_int_data.curr_req_plmn.plmn_type = RRC_GSM_MAP_ANY_PLMN_REQ;
          rrc_csp_int_data.curr_type_acq           = RRC_CSP_ANY_PLMN;
          rrc_csp_curr_select_data.acq_type        = RRC_CSP_ANY_PLMN;
        }
        else
        {
          rrc_csp_int_data.curr_req_plmn.plmn_type = RRC_GSM_MAP_SPECIFIC_PLMN_REQ;
          rrc_csp_int_data.curr_type_acq           = RRC_CSP_SPEC_PLMN;
          rrc_csp_curr_select_data.acq_type        = RRC_CSP_SPEC_PLMN;
        }

        /* Set the current band appropriately as it is used by SIB procedure 
         * after reading MIB to validate the MCC and Current Band Combination
         */
        rrc_csp_curr_select_data.current_band = rrc_get_frequency_band(
                                                  rrc_csp_int_data.curr_acq_entry.freq,
                                                  rrc_csp_int_data.curr_req_plmn.plmn_id);

        MSG_HIGH("Setting current_band to %d. PLMN-MCC-MNC sent by GSM %d %d", 
                                  rrc_csp_curr_select_data.current_band, 
                                  RRC_CSP_GET_INT_MCC(rrc_csp_int_data.curr_req_plmn.plmn_id),
                                  RRC_CSP_GET_INT_MNC(rrc_csp_int_data.curr_req_plmn.plmn_id));

#ifdef FEATURE_EOOS
        #error code not present
#endif

        /* Start waiting for Acquisition Confirmation */
        next_substate = RRCCSP_CELL_SEL_WT_ACQ;

        break;

      case RRC_BPLMN_SRCH_TIMER_EXPIRED_IND:
        rrc_csp_int_data.bplmn_srch_tmr_expired = TRUE;
        rrc_csp_int_data.rrc_rr_plmn_srch_cnf.srch_done   = TRUE;
        rrc_csp_int_data.rrc_rr_plmn_srch_cnf.hplmn_found = FALSE;
        rrccsp_send_bplmn_search_cnf_to_rr();
        next_substate = RRCCSP_NO_CELL_SELECTED;
        break;

#ifdef FEATURE_WRLF_SYSTEM_SEL
      /* Handle initiate cell selection during connected mode OOS, on
         HARD_ABORT from NAS or re-establishmen timer expiry.*/
      case RRC_INITIATE_CELL_SELECTION_IND:
        if(RRC_IS_CONN_MODE_OOS_SRCH_IN_PROGRESS())
        {
          WRRC_MSG2_HIGH("Rel chls & do cell sel, CSP sstate %d, scan %d",
                   rrc_csp_substate, rrc_csp_int_data.curr_scan);
          /* First Initialize the SIB variables 
          rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_OOS);*/
      
          rrc_csp_send_chan_release();
      
          next_substate = rrc_csp_start_sel_leaving_conn_mode();
        }
        else
        {
          WRRC_MSG2_HIGH ("Cmd RRC_INITIATE_CELL_SELECTION_IND not processed in CSP sstate %d",
                                   cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);
        }
        break;
#endif

      default:
        WRRC_MSG2_HIGH ("Cmd 0x%x not processed in CSP sstate %d",
                                 cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);
        break;
    }
  }
  else if (((uint32)cmd_ptr->cmd_hdr.cmd_id & RRC_RR_CMD_ID_BASE) == RRC_RR_CMD_ID_BASE)
  {
    rr_cmd = ((rrc_rr_cmd_type *)cmd_ptr);     /*lint !e740 */

    switch(rr_cmd->cmd_hdr.cmd_id)
    {
      case RRC_INTERRAT_RESELECTION_REQ:
        MSG_MED( "RR Cmd 0x%x recvd, CSP sstate %d",
                           rr_cmd->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
        rrc_csp_int_data.curr_req_plmn.plmn_id =
          mmumts_convert_nas_plmn_id_to_rrc_plmn_id(
              rr_cmd->cmd.interrat_reselection_req.requested_PLMN);
        rrc_csp_int_data.curr_acq_entry.freq =
          (uint16)(rr_cmd->cmd.interrat_reselection_req.UARFCN);
        rrc_csp_int_data.curr_acq_entry.scr_code =
          (uint16)(rr_cmd->cmd.interrat_reselection_req.scrambling_code);

#ifdef FEATURE_RAT_PRIORITY_LIST
        rrc_csp_int_data.rat_pri_list_info = rr_cmd->cmd.interrat_reselection_req.rat_pri_list_info;
        rrcmcm_update_mode_capability(&rrc_csp_int_data.rat_pri_list_info);
        rrc_csp_int_data.band_pref = rrc_extract_gw_band_pref_from_rat_pri_list(&rrc_csp_int_data.rat_pri_list_info);
        rrccsp_update_band_preference();
#endif

#ifdef FEATURE_WCDMA_DEDICATED_PRI_INFO
/*updating the dedicated priority info received in rrc_reselct_req into global structure (rrc_dedicated_priority_info)*/
        rrcmeas_update_dedicated_priority_info_from_irat_req(&rr_cmd->cmd.interrat_reselection_req.dedicated_priority_info,
                                rrc_csp_int_data.curr_req_plmn.plmn_id);

#endif
        /* Set the current scan type to GSM_RESELECTION_SCAN */
        rrc_csp_int_data.curr_scan = RRC_CSP_GSM_TO_WCDMA_CELL_RESELECTION_SCAN;
        rrc_csp_int_data.network_select_mode =
        rr_cmd->cmd.interrat_reselection_req.network_select_mode;

        if((rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED) ||
           (rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED_ROUTINE_ACQUISITION))
        {
          rrc_csp_int_data.curr_req_plmn.plmn_type = RRC_GSM_MAP_ANY_PLMN_REQ;
          rrc_csp_int_data.curr_type_acq           = RRC_CSP_ANY_PLMN;
          rrc_csp_curr_select_data.acq_type        = RRC_CSP_ANY_PLMN;
        }
        else
        {
          rrc_csp_int_data.curr_req_plmn.plmn_type = RRC_GSM_MAP_SPECIFIC_PLMN_REQ;
          rrc_csp_int_data.curr_type_acq           = RRC_CSP_SPEC_PLMN;
          rrc_csp_curr_select_data.acq_type        = RRC_CSP_SPEC_PLMN;
        }

#if defined (FEATURE_WCDMA_TO_LTE) || defined (FEATURE_LTE_TO_WCDMA)
        rrc_csp_int_data.interrat_type = RRC_CSP_INTERRAT_GSM;
#endif

        rrc_csp_int_data.acq_mode = L1_WCDMA_INTER_S_RESEL_ACQ;

        /* Pass the PN info to L1 if it is valid */
        if(rr_cmd->cmd.interrat_reselection_req.PN_Offset == 0xFFFF)
        {
          rrc_csp_int_data.acq_type = L1_WCDMA_FREQ_SCR;
        }
        else
        {
          rrc_csp_int_data.pn_pos = rr_cmd->cmd.interrat_reselection_req.PN_Offset;
          rrc_csp_int_data.acq_type = L1_WCDMA_FREQ_SCR_POS;
        }

#ifdef FEATURE_GAN_3G_ROVE_OUT_ONLY
        #error code not present
#endif

#ifdef FEATURE_DUAL_SIM
        /* Acquire lock before starting ACQ for GTOW reselection */
        rrc_start_lock_wait_timer(RRCTMR_WRM_LOCK_WAIT_TIMER_FOR_INTERRAT_IN_MS,TRUE);
        rrc_csp_int_data.shld_acq_be_spltd = FALSE;
        type_freq_scan = RRC_CSP_ACQ_SCAN;
        if(rrc_csp_wait_for_wrm_lock(&type_freq_scan) == RRCCSP_WT_STOP_MODE_CHANGE_CNF)
        {
          rrctmr_stop_timer(RRCTMR_WRM_LOCK_TIMER);
          return (RRCCSP_WT_STOP_MODE_CHANGE_CNF);
        }
        rrctmr_stop_timer(RRCTMR_WRM_LOCK_TIMER);
#endif

        /* Send CPHY_ACQ_REQ to L1 and wait for the CNF */
        rrc_csp_send_l1_cmd(RRC_PROCEDURE_CSP, CPHY_ACQ_REQ, &rrc_csp_int_data.curr_acq_entry);
        MSG_MED("L1 cmd 0x%x sent", CPHY_ACQ_REQ, 0, 0);

        /* Set the current band appropriately as it is used by SIB procedure 
         * after reading MIB to validate the MCC and Current Band Combination
         */
        rrc_csp_curr_select_data.current_band = rrc_get_frequency_band(
                                                  rrc_csp_int_data.curr_acq_entry.freq,
                                                  rrc_csp_int_data.curr_req_plmn.plmn_id);

        MSG_4(MSG_SSID_DFLT, MSG_LEGACY_HIGH,
            "N/W sel mode %d Setting current_band to %d. PLMN-MCC-MNC sent by GSM %d %d",
             rrc_csp_int_data.network_select_mode,
             rrc_csp_curr_select_data.current_band, 
             RRC_CSP_GET_INT_MCC(rrc_csp_int_data.curr_req_plmn.plmn_id),
             RRC_CSP_GET_INT_MNC(rrc_csp_int_data.curr_req_plmn.plmn_id));

#ifdef FEATURE_EOOS
        #error code not present
#endif

        /* Start waiting for Acquisition Confirmation */
        next_substate = RRCCSP_CELL_SEL_WT_ACQ;

        break;

      case RRC_INTERRAT_PLMN_SRCH_REQ:

        WRRC_MSG0_HIGH("BPLMN: RRC_INTERRAT_PLMN_SRCH_REQ rcvd");
        /* Check if the boolean variable bplmn_srch_tmr_expired was reset properly on returning to RR */
        if(!rrc_csp_int_data.bplmn_srch_tmr_expired)
        {
          WRRC_MSG0_ERROR("BPLMN ERR:plmn srch rcvd whn bplmn_srch_tmr_exprd=FALSE");
          rrctmr_stop_timer(RRCTMR_BPLMN_SRCH_TIMER);
          rrc_csp_int_data.bplmn_srch_tmr_expired = TRUE;
          err = TRUE;
        }
        /* Incorrect network select mode. Return immediately to RR */
        else if((rr_cmd->cmd.interrat_plmn_srch_req.network_select_mode != SYS_NETWORK_SELECTION_MODE_AUTOMATIC)
                 && (rr_cmd->cmd.interrat_plmn_srch_req.network_select_mode != SYS_NETWORK_SELECTION_MODE_MANUAL))
        {
          WRRC_MSG0_ERROR("BPLMN ERR:Incorrect N/W Select Mode");
          err = TRUE;
        }
        /* GtoW BPLMN search is always in RRC Disconnected State */
        else if((rrc_state = rrc_get_state()) != RRC_STATE_DISCONNECTED)
        {
          WRRC_MSG1_ERROR("GTOW BPLMN Srch Req in RRC state %d",rrc_state);
          err = TRUE;
        }

#if defined (FEATURE_WCDMA_TO_LTE) || defined (FEATURE_LTE_TO_WCDMA)
        rrc_csp_int_data.bplmn_interrat_type = RRC_CSP_INTERRAT_GSM;
#endif

        rrc_csp_int_data.service_search_bgnd = rr_cmd->cmd.interrat_plmn_srch_req.service_search;
        WRRC_MSG1_HIGH("SSB: service_search = %d", rrc_csp_int_data.service_search_bgnd);

        if(err)
        {
          /* stop WCDMA stack */
          rrc_csp_int_data.bplmn_new_srch          = FALSE;
          rrc_csp_int_data.bplmn_srch_cnf          = TRUE;
          rrc_csp_int_data.bplmn_fnd_list_wr_index = 0;
          rrc_csp_int_data.rrc_rr_plmn_srch_cnf.srch_done   = FALSE;
          rrc_csp_int_data.rrc_rr_plmn_srch_cnf.hplmn_found = FALSE;
          rrc_csp_int_data.curr_scan = RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN;

          rrccsp_send_mode_change_req_to_mcm(RRC_MODE_INACTIVE);
          next_substate = RRCCSP_WT_STOP_MODE_CHANGE_CNF;
          return(next_substate);
        }

        rrc_csp_int_data.gsm_camped_suitably = FALSE;
        if(rr_cmd->cmd.interrat_plmn_srch_req.camped_suitably)
        {
          WRRC_MSG1_HIGH("Camped_suitably = %d, received from RR", rr_cmd->cmd.interrat_plmn_srch_req.camped_suitably);
          rrc_csp_int_data.gsm_camped_suitably = TRUE;
        }

        /* if it is a new search then store the requested plmns */
        if(rrc_csp_int_data.bplmn_new_srch)
        {
          /* Get the number of plmns requested */
          rrc_csp_int_data.bplmn_num_req = rr_cmd->cmd.interrat_plmn_srch_req.num_plmns;
          rrc_csp_int_data.bplmn_scan_scope=rr_cmd->cmd.interrat_plmn_srch_req.scan_scope;
          rrc_csp_int_data.bplmn_req_list_rd_index = 0;
          rrc_csp_int_data.bplmn_fnd_list_wr_index = 0;
          rrc_csp_int_data.network_select_mode = rr_cmd->cmd.interrat_plmn_srch_req.network_select_mode;
          rrc_csp_int_data.bplmn_current_band_initialized = FALSE;

          rrc_csp_int_data.bplmn_bgnd_mib_rd_cnt  = 0;
          rrc_csp_int_data.bplmn_bgnd_mib_rd_freq = 0;
          WRRC_MSG2_HIGH("Inter RAT List_Req: Initialize ACQ SUCC PSC info. Scan Scope: %d, network_select_mode: %d", rrc_csp_int_data.bplmn_scan_scope,rrc_csp_int_data.network_select_mode);
          rrc_csp_int_data.bplmn_acq_succ_scr_code = 8192;
          rrc_csp_int_data.bplmn_acq_succ_freq = 0;
          rrc_csp_int_data.bplmn_acq_succ_pn_pos = 0xFFFFFFFF;
          rrc_csp_int_data.bplmn_acq_succ_scr_code_det = 0;
          rrc_csp_int_data.bplmn_acq_succ_curr_acq_count = 0;

          /* Automatic BPLMN search */
          if(rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_AUTOMATIC)
          {
            /* Empty PLMN list, return immediately to RR */
            if(rrc_csp_int_data.bplmn_num_req < 1)
            {
              WRRC_MSG0_ERROR("BPLMN ERR:Automatic PLMN req w/ empty list");

              /* stop WCDMA stack */
              rrc_csp_int_data.bplmn_new_srch          = FALSE;
              rrc_csp_int_data.bplmn_srch_cnf          = TRUE;
              rrc_csp_int_data.bplmn_fnd_list_wr_index = 0;
              rrc_csp_int_data.rrc_rr_plmn_srch_cnf.srch_done   = FALSE;
              rrc_csp_int_data.rrc_rr_plmn_srch_cnf.hplmn_found = FALSE;
              rrc_csp_int_data.curr_scan = RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN;

              rrccsp_send_mode_change_req_to_mcm(RRC_MODE_INACTIVE);
              next_substate = RRCCSP_WT_STOP_MODE_CHANGE_CNF;
              return(next_substate);
            }
            /* PLMN list is not empty. Initialise internal variables */
            else
            {
              for(i=0; i<rrc_csp_int_data.bplmn_num_req; ++i)
              {
                rrc_csp_int_data.bplmn_req_list[i].plmn_id =
                    mmumts_convert_nas_plmn_id_to_rrc_plmn_id(rr_cmd->cmd.interrat_plmn_srch_req.plmn[i]);
                rrc_csp_int_data.bplmn_req_list[i].plmn_type = RRC_GSM_MAP_SPECIFIC_PLMN_REQ;
                
                WRRC_MSG2_HIGH("%d-%d", RRC_CSP_GET_INT_MCC(rrc_csp_int_data.bplmn_req_list[i].plmn_id),
                                  RRC_CSP_GET_INT_MNC(rrc_csp_int_data.bplmn_req_list[i].plmn_id)
                                  );
              }

              /* If plmn request list is not empty then set the current scan type
               * to RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN and initiate a SPECIFIC_PLMN_SCAN.
               */
              rrc_csp_int_data.curr_scan               = RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN;
              rrc_csp_int_data.curr_req_plmn.plmn_type = RRC_GSM_MAP_SPECIFIC_PLMN_REQ;
              rrc_csp_int_data.curr_req_plmn.plmn_id   =
                  rrc_csp_int_data.bplmn_req_list[rrc_csp_int_data.bplmn_req_list_rd_index].plmn_id;
            }
          } /* end SYS_NETWORK_SELECTION_MODE_AUTOMATIC */

          /* Manual BPLMN scan */
          else if(rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_MANUAL)
          {
            /* Non-empty PLMN list, print error message. Continue with MANUAL BPLMN SCAN */
            if(rrc_csp_int_data.bplmn_num_req > 0)
            {
              WRRC_MSG0_ERROR("BPLMN ERR:Manual PLMN req w/o empty list");
            }

            /* Set the current scan type to RRC_CSP_GTOW_BPLMN_MANUAL_SCAN
             * and initiate ANY_PLMN_SCAN.
             */
#ifdef FEATURE_FEMTO_CSG
           if(rrc_csp_int_data.service_search_bgnd == SYS_SERVICE_SEARCH_CSG)
           {
             rrc_csp_int_data.last_csg_rat = RRC_CSG_GSM;
           }
#endif
            rrc_csp_int_data.curr_scan               = RRC_CSP_GTOW_BPLMN_MANUAL_SCAN;
            rrc_csp_int_data.curr_req_plmn.plmn_type = RRC_GSM_MAP_ANY_PLMN_REQ;
          }

#ifdef FEATURE_PCS_850_FREQ_SCAN_NEW_OPTIMIZATION
          /* Map ARFCNs in GSM list to UMTS channels */
          rrccsp_convert_active_gsm_channels_to_umts_uarfcns(rr_cmd->cmd.interrat_plmn_srch_req.gsm_cell_list);
#endif
#if defined (FEATURE_LTE_TO_WCDMA) || defined (FEATURE_WCDMA_TO_LTE)
          rrc_csp_int_data.detected_frequency_list.num_freqs = rr_cmd->cmd.interrat_plmn_srch_req.detected_frequency_list.num_freqs;
          WCDMA_MEMCPY(rrc_csp_int_data.detected_frequency_list.freq,
                       LTE_IRAT_MAX_DETECTED_FREQ * sizeof(detected_frequency_type),
                       rr_cmd->cmd.interrat_plmn_srch_req.detected_frequency_list.freq,
                       LTE_IRAT_MAX_DETECTED_FREQ * sizeof(detected_frequency_type));
#endif

        } /* end bplmn_new_srch*/

#ifdef FEATURE_DUAL_SIM
        if((WCDMA_RRC_IDLE_FEATURES(RRC_ACQ_SPLIT_DURING_BPLMN)) && wcdma_is_ue_in_dual_standby)
        {
          rrctmr_start_timer(RRCTMR_BPLMN_SRCH_TIMER, rr_cmd->cmd.interrat_plmn_srch_req.timer_val - XTOW_BPLMN_SEARCH_OVERHEAD_TIMER_WITH_SPLIT_ACQ_IN_MS);
          xtow_bplmn_search_overhead_timer = XTOW_BPLMN_SEARCH_OVERHEAD_TIMER_WITH_SPLIT_ACQ_IN_MS;
          rrc_csp_int_data.bplmn_srch_tmr_expired   = FALSE;
        }
        else
#endif
        if(rr_cmd->cmd.interrat_plmn_srch_req.timer_val > 500)
        {
           /* Overhead is considered as 220 because max ACQ time is 180 msec and start/stop time is 40 msec*/
          rrctmr_start_timer(RRCTMR_BPLMN_SRCH_TIMER, rr_cmd->cmd.interrat_plmn_srch_req.timer_val - 220);
          xtow_bplmn_search_overhead_timer = 220;
          rrc_csp_int_data.bplmn_srch_tmr_expired   = FALSE;
        }
        else
        {
          /* 40msec = W start/stop delay */
          rrctmr_start_timer(RRCTMR_BPLMN_SRCH_TIMER, rr_cmd->cmd.interrat_plmn_srch_req.timer_val - 40);
          xtow_bplmn_search_overhead_timer = 40;
          rrc_csp_int_data.bplmn_srch_tmr_expired   = FALSE;
        }

        /* Initialize bplmn data */
        rrc_csp_int_data.bplmn_sib_try_next_best_cell     = FALSE;
        rrc_csp_int_data.bplmn_srch_cnf                   = TRUE;
        rrc_csp_int_data.bplmn_acq_status                 = FALSE;
        rrc_csp_int_data.rrc_rr_plmn_srch_cnf.srch_done   = TRUE;
        rrc_csp_int_data.rrc_rr_plmn_srch_cnf.hplmn_found = FALSE;

#ifdef FEATURE_EOOS
        #error code not present
#endif

        next_substate = rrccsp_no_cell_sel_bplmn_srch_req();
        break;

      case RRC_INTERRAT_PLMN_SRCH_ABORT_REQ:
        WRRC_MSG0_HIGH("BPLMN:SRCH_ABORT_REQ Rcvd in NO_CELL_SELECTED sstate");

        rrccsp_send_bplmn_abort_cnf_to_rr();
        next_substate = RRCCSP_NO_CELL_SELECTED;
        break;

      case RRC_INTERRAT_REDIRECT_REQ:
        WRRC_MSG2_HIGH("RR Cmd 0x%x recvd, CSP sstate %d",
                           rr_cmd->cmd_hdr.cmd_id, rrc_csp_substate);
        next_substate = rrccsp_handle_gtow_redirection_req(&rr_cmd->cmd.interrat_redirect_req);
        break;

#ifdef FEATURE_GAN_3G_ROVE_OUT_ONLY
      #error code not present
#endif
      default:
        WRRC_MSG2_HIGH("RR cmd 0x%x not processed in CSP sstate %d",
                              rr_cmd->cmd_hdr.cmd_id, rrc_csp_substate);
        break;
    }
  }

#if defined (FEATURE_WCDMA_TO_LTE) || defined (FEATURE_LTE_TO_WCDMA)
  else if(cmd_ptr->cmd_hdr.cmd_id == RRC_LTE_RRC_CMD)
  {
    WRRC_MSG1_HIGH("LTOW: CMD %x received from LTE RRC in No cell selected substate",
        cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.msg_hdr.id);
    switch(cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.msg_hdr.id)
    {
#ifdef FEATURE_LTE_TO_WCDMA
      case WCDMA_RRC_LTE_RESEL_REQ:
        next_substate= rrccsp_handle_reselection_req_from_lte(cmd_ptr);
        break;

      case WCDMA_RRC_LTE_PLMN_SRCH_REQ:
        next_substate = rrccsp_handle_plmn_srch_req_from_lte(cmd_ptr);
        break;

      case WCDMA_RRC_LTE_REDIR_REQ:
        next_substate= rrccsp_handle_redirection_req_from_lte(cmd_ptr);
        break;
      case WCDMA_RRC_LTE_GET_CGI_REQ:
        next_substate= rrccsp_handle_cgi_req_from_lte(cmd_ptr);
        break;

#endif
      default:
        WRRC_MSG1_ERROR("LTOW: Invalid cmd id %x from LTE RRC",
            cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.msg_hdr.id);
        break;
    }
  }
#endif

  return( next_substate );
}


/*===========================================================================

FUNCTION        RRCCSP_CAMPED_CELL_STATE_CHANGE

DESCRIPTION
                This function processes State Change Indication in various
                CSP substates

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_camped_cell_state_change( rrc_cmd_type *cmd_ptr )
{
  rrc_csp_substate_e_type next_substate = rrc_csp_substate;

  if(cmd_ptr->cmd.state_change_ind.new_state == RRC_STATE_DISCONNECTED)
  {
    /* Reset reselection variables */
    rrccsp_reset_reselection_data();

    WRRC_MSG0_HIGH("Start cell sel leaving conn mode");
    next_substate = rrc_csp_start_sel_leaving_conn_mode();

  } /* If New State is IDLE_DISCONNECTED */
  else if(cmd_ptr->cmd.state_change_ind.new_state == RRC_STATE_CELL_DCH)
  {
    MSG_MED("Init data on state change to DCH",0,0,0);
    /* Reset reselection variables */
    rrccsp_reset_reselection_data();
    rrc_csp_int_data.dest_freq_present = FALSE;
    rrc_csp_int_data.dest_psc_present  = FALSE;

    if(rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED)
    {
      next_substate = RRCCSP_CAMPED_ACCEPT_CELL;
    }
    else
    {
      next_substate = RRCCSP_CAMPED_SUIT_CELL;
    }
  }
  else if((cmd_ptr->cmd.state_change_ind.new_state == RRC_STATE_CELL_FACH)
           && (cmd_ptr->cmd.state_change_ind.previous_state == RRC_STATE_CONNECTING))
  {
    WRRC_MSG0_HIGH("Send CPHY_CELL_PARM_REQ to L1 for Connecting to FACH State Tx");
    
    /* Send CPHY_CELL_PARM_REQ to L1 */
    rrc_csp_send_l1_cmd(RRC_PROCEDURE_CSP, CPHY_CELL_PARM_REQ,
                        &rrc_csp_int_data.curr_acq_entry);
  }
  else
  {
    WRRC_MSG1_HIGH("Unexpected state change to %d",cmd_ptr->cmd.state_change_ind.new_state);
  }

  return( next_substate );

} /* rrccsp_camped_cell_state_change */

/*===========================================================================

FUNCTION          rrccsp_pending_command_handler

DESCRIPTION       This function handles the pending CSP command once the
                  appropriate confirmation has been received from L1.

DEPENDENCIES
                  None

RETURN VALUE
                  Next CSP substate

SIDE EFFECTS
                  None

===========================================================================*/
static rrc_csp_substate_e_type rrccsp_pending_command_handler(void)
{
  rrc_csp_substate_e_type next_substate = rrc_csp_substate;

  if(rrc_ifreq_rdr_in_prgrs ==TRUE)
  {
     rrclog_wcdma_to_wcdma_redir_end_event_type wtow_redirct_event;
     wtow_redirct_event.status = WTOW_FAILURE;
     event_report_payload(EVENT_WCDMA_TO_WCDMA_REDIRECTION_END, sizeof(wtow_redirct_event),
                 (void *)&wtow_redirct_event);
     rrc_ifreq_rdr_in_prgrs = FALSE;
  }
  switch(rrc_csp_int_data.pending_type)
  {
    case RRC_CSP_SERVICE_REQ_PENDING:
      /* Start processing pending Service Request */
      WRRC_MSG0_HIGH("Release chls and start cell sel for pending srvc req");
      /* Added for CR 112981.
       * The last_mm_primitive and service request parameters are overwritten with 
       * their  previous value(s) as part of cleaning up the BPLMN data. As a result of this when 
       * RRC_BPLMN_SEARCH_ABORT_REQ is received followed by RRC_SERVICE_REQ, 
       * we ended up in loosing the RRC_CSP_SRVC_REQ_RCVD event, service request parameters 
       * and sending the RRC_SERVICE_IND instead of RRC_SERVICE_CNF.
       */
      rrccsp_cleanup_bplmn_state();
      rrc_csp_init_data_from_service_req(&rrc_csp_int_data.pending_srvc_req_data);

#ifdef FEATURE_WRLF_SYSTEM_SEL
      if(RRC_IS_CONN_MODE_OOS_SRCH_IN_PROGRESS())
      {
        /* Donot release channels when OOSC is in progress.*/
        next_substate = rrc_csp_start_sel_on_mm_req();
      }
      else
#endif
      {
        next_substate = rrc_csp_release_chls_and_start_sel_on_mm_req();
      }
      break;

    case RRC_CSP_DCH_TO_FACH_TIMER_PENDING:
    case RRC_CSP_DCH_TO_PCH_TIMER_PENDING:
      next_substate = rrc_csp_process_pending_dch_fach_pch_timer_expiry();
      break;

    case RRC_CSP_FACH_TO_FACH_PCH_TIMER_PENDING:
      next_substate = rrc_csp_process_pending_fach_to_fach_pch_timer_expiry();
      break;

    case RRC_CSP_PLMN_LIST_REQ_PENDING:
      /* If PLMN List Request is handled in pending state then it implies that
       * the search should be done in foreground.
       * Here we are resetting curr_scan to its initial value - RRC_CSP_CELL_SELECTION_SCAN,
       * bcoz for the curr_scan = RRC_CSP_LEAVING_CONN_MODE_SCAN, even if UE is not camped
       * the check inside the function rrccsp_handle_plmn_list_req_in_bgnd() returns 
       * "bgnd search" instead of "fgnd search". 
       * Now, in the special case where UE is not camped and curr_scan is RRC_CSP_LEAVING_CONN_MODE_SCAN
       * AND CSP SUBSTATE IS PENDING, the check inside the function shd return "fgnd search"
       * instead of "bgnd search". To achieve this, we are resetting curr_scan to  RRC_CSP_CELL_SELECTION_SCAN
       * so that the check for "UE is not camped" itself suffices to get a return value of
       * "fgnd search". This change was done as part of CR 104224.
       */
      if(rrc_csp_int_data.curr_scan == RRC_CSP_LEAVING_CONN_MODE_SCAN)
      {
        WRRC_MSG1_HIGH("Resetting curr_scan (%d) to RRC_CSP_CELL_SELECTION_SCAN", rrc_csp_int_data.curr_scan);
        rrc_csp_int_data.curr_scan = RRC_CSP_CELL_SELECTION_SCAN; 
      }

      next_substate = rrccsp_handle_plmn_list_req(next_substate,
                                                  &(rrc_csp_int_data.pending_plmn_list_req_data));
      break;

    case RRC_CSP_STATE_CHANGE_IND_PENDING:
      next_substate = rrccsp_camped_cell_state_change(&rrc_csp_int_data.saved_rrc_cmd);
      break;

    case RRC_CSP_INITIATE_CELL_SEL_PENDING:

      if((rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN) ||
           (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN))
      {
        /* To handle cases where BPLMN SRCH ABORT REQ is overwritten by INITIATE CELL SEL */
        rrccsp_cleanup_bplmn_state();
      }

      /* Do not release channels and send IDLE_REQ to L1 when BPLMN is actively in progress */
      if((rrc_csp_int_data.curr_scan != RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN) &&
           rrc_csp_int_data.curr_scan != RRC_CSP_WTOW_BPLMN_MANUAL_SCAN)
      {
        /* Release all channels and put lower layers to Idle  */
        rrc_csp_send_chan_release();
      }
      next_substate = rrc_csp_start_sel_leaving_conn_mode();
      break;

    case RRC_BPLMN_SRCH_TIMER_PENDING:

      WRRC_MSG0_HIGH("BPLMN: In BPLMN_SRCH_TIMER_PENDING handler");

      if(rrc_csp_int_data.bplmn_srch_cnf)
      {
        rrc_csp_process_pending_bplmn_srch_timer_expiry();
      }

      /* stop WCDMA stack */
      rrccsp_send_mode_change_req_to_mcm(RRC_MODE_INACTIVE);
      next_substate = RRCCSP_WT_STOP_MODE_CHANGE_CNF;
      break;
    case RRC_INTERRAT_PLMN_SRCH_ABORT_REQ_PENDING:

      WRRC_MSG0_HIGH("BPLMN: In PLMN_SRCH_ABORT_REQ_PENDING handler");
      /* Set data that needs to be reported to RR */
      rrc_csp_int_data.rrc_rr_plmn_srch_cnf.srch_done   = FALSE;
      rrc_csp_int_data.rrc_rr_plmn_srch_cnf.hplmn_found = FALSE;

      rrc_csp_int_data.bplmn_srch_cnf = FALSE;

      /* stop WCDMA stack */
      rrccsp_send_mode_change_req_to_mcm(RRC_MODE_INACTIVE);
      next_substate = RRCCSP_WT_STOP_MODE_CHANGE_CNF;
      break;

    case RRC_FREQ_REDIRECT_WAIT_TIMER_PENDING:

      /* Make the last camped frequency current for acquisition */
      rrc_csp_int_data.curr_acq_entry.freq = rrc_csp_int_data.last_camped_freq;

      switch(next_substate)
      {
        case RRCCSP_CELL_SEL_WT_ACQ_PENDING:
        case RRCCSP_CELL_SEL_WT_FREQ_SCAN_CNF_PENDING:
          WRRC_MSG0_HIGH("Start ACQ on last camped frequency");
          break;

        case RRCCSP_SUIT_CELL_SEL_WT_SERV_S_PENDING:
        case RRCCSP_ACCEPT_CELL_SEL_WT_S_PENDING:
          rrc_csp_send_bch_release(FALSE);
          break;

        case RRCCSP_SUIT_CELL_SEL_WT_CAMP_PENDING:
        case RRCCSP_ACCEPT_CELL_SEL_WT_CAMP_PENDING:
          rrc_csp_send_bch_release(FALSE);
          rrc_csp_send_tr_phy_chl_release();
          break;

        default:
          WRRC_MSG0_ERROR("Shouldn't come here");
          break;
      }

      /* Send redirected frequency to L1 for acquisition */
      rrc_csp_send_next_freq_to_l1(&rrc_csp_int_data.curr_acq_entry, RRC_CSP_ACQ_SCAN);

      /* Start waiting for Acquisition Confirmation */
      next_substate = RRCCSP_CELL_SEL_WT_ACQ;
      break;


    case RRC_CSP_WTOW_BPLMN_DRX_SRCH_TIMER_PENDING:  
      WRRC_MSG0_HIGH("WTOW BPLMN: In BPLMN_SRCH_TIMER_PENDING handler");
      
      if(!rrc_csp_int_data.bplmn_guard_srch_tmr_expired)
      {
        WRRC_MSG0_HIGH("Only DRX srch tm expd. Suspend Srch");
        rrc_csp_process_pending_bplmn_srch_timer_expiry();
        rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_SUSPEND, FALSE, TRUE);
      }
      else
      {   
        WRRC_MSG0_HIGH("Guard tmr has expd. Abort Srch");
        rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_ABORT, TRUE, TRUE);
      } 
      if(rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED)
      {
        next_substate = RRCCSP_CAMPED_ACCEPT_CELL;
      }
      else
      {
        next_substate = RRCCSP_CAMPED_SUIT_CELL;
      }
      break;

    case RRC_CSP_BPLMN_GUARD_SRCH_TIMER_PENDING:
      WRRC_MSG0_HIGH("WTOW: In BPLMN_GUARD_SRCH_TIMER_PENDING handler");

      rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_ABORT, TRUE, TRUE);
      if(rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED)
      {
        next_substate = RRCCSP_CAMPED_ACCEPT_CELL;
      }
      else
      {
        next_substate = RRCCSP_CAMPED_SUIT_CELL;
      }
      break;
      
    case RRC_CSP_BPLMN_SRCH_ABORT_REQ_PENDING:
      WRRC_MSG0_HIGH("WTOW: In BPLMN_SRCH_ABORT_REQ_PENDING handler");

      if(rrc_csp_int_data.curr_scan == RRC_CSP_PLMN_LIST_SCAN)
      {
        /* Send the PLMN_LIST_CNF to MM with status aborted */
        rrc_csp_send_mm_plmn_list_cnf_cmd(FALSE);
        next_substate = RRCCSP_NO_CELL_SELECTED;
      }
      else
      {
        if((rrc_csp_int_data.bplmn_suspend_cause != BPLMN_SUSPEND_REASON_NONE) && 
           (rrc_csp_int_data.bplmn_suspend_proc != RRC_PROCEDURE_IDT))
        {
          rrc_csp_send_bplmn_suspend_cnf(rrc_csp_int_data.bplmn_suspend_proc, SUCCESS);
        }

        rrccsp_cleanup_bplmn_state();
        if(rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED)
        {
          next_substate = RRCCSP_CAMPED_ACCEPT_CELL;
        }
        else
        {
          next_substate = RRCCSP_CAMPED_SUIT_CELL;
        }
      }
      break;

    case RRC_CSP_BPLMN_SRCH_SUSPEND_REQ_PENDING:
      WRRC_MSG1_HIGH("WTOW: Srch suspend req. Snd suspend cnf to proc rrc_proc_e_type_value%d. Snd Sleep Ind to L1",
                                               rrc_csp_int_data.bplmn_suspend_proc);

      switch(rrc_csp_int_data.bplmn_suspend_proc)
      {
        case RRC_PROCEDURE_RCE:
        case RRC_PROCEDURE_SIB:
        case RRC_PROCEDURE_CU:
        case RRC_PROCEDURE_MISC:
          if(!rrc_csp_int_data.bplmn_guard_srch_tmr_expired)
          {
            WRRC_MSG0_HIGH("Suspend req but g-tmr active. Suspend Srch");
            rrc_csp_process_pending_bplmn_srch_timer_expiry();
            rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_SUSPEND, FALSE, TRUE);
          }
          else
          {   
            WRRC_MSG0_HIGH("Guard tmr has expd. Abort Srch");
            rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_ABORT, TRUE, TRUE);
          }
          rrc_csp_send_bplmn_suspend_cnf(rrc_csp_int_data.bplmn_suspend_proc, SUCCESS);
          break;

        case RRC_PROCEDURE_IDT:
          if(!rrc_csp_int_data.bplmn_guard_srch_tmr_expired)
          {
            WRRC_MSG0_HIGH("Suspend req but g-tmr active. Suspend Srch");
            rrc_csp_process_pending_bplmn_srch_timer_expiry();
            rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_SUSPEND, FALSE, TRUE);
          }
          else
          {   
            WRRC_MSG0_HIGH("Guard tmr has expd. Abort Srch");
            rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_ABORT, TRUE, TRUE);
          }
          break;

        default:
          WRRC_MSG1_ERROR("ERR WTOW Incorrect proc id rrc_proc_e_type_value%d", rrc_csp_int_data.bplmn_suspend_proc);
          rrc_csp_send_bplmn_suspend_cnf(rrc_csp_int_data.bplmn_suspend_proc, SUCCESS);
          break;
      }

      if(rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED)
      {
        next_substate = RRCCSP_CAMPED_ACCEPT_CELL;
      }
      else
      {
        next_substate = RRCCSP_CAMPED_SUIT_CELL;
      }
      break;

#ifdef FEATURE_EOOS
    #error code not present
#endif
#ifdef FEATURE_GAN_3G_ROVE_OUT_ONLY
    #error code not present
#endif
#ifdef FEATURE_DUAL_SIM
    case  RRC_CSP_PREEMPT_IND_PENDING:
      if(DS_Tuneaway_for_Immediate_preempt)
      {
        rrccsp_send_mode_change_req_to_mcm(RRC_MODE_STANDBY);
        next_substate = RRCCSP_WT_SUSPEND_MODE_CHANGE_CNF;
        rrc_csp_int_data.curr_scan = RRC_CSP_UNLOCK_BY_SCAN;
      }
      else
      {
        next_substate = rrc_csp_initiate_CU_for_immediate_preempt_in_fach_dch();
      }
      break;
#endif

    default:
      ERR_FATAL("No pending type in %d CSP sstate",rrc_csp_substate,0,0);
      break;
  }

  rrc_csp_int_data.pending_type = RRC_CSP_NONE_PENDING;
  return next_substate;
} /* rrccsp_pending_command_handler */


/*===========================================================================

FUNCTION          RRCCSP_PRIORITIZE_PENDING_COMMANDS

DESCRIPTION       This function is called when WTOW BPLMN search is 
                  in progress and multiple commands are received by CSP when 
                  it is waiting for confirmation from L1 - acq_cnf, freq_scan_cnf 
                  etc. This function allows CSP to prioritize the commands 
                  received in its pending substates and send appropriate confirmation.
                  
DEPENDENCIES
                  None

RETURN VALUE
                  None

SIDE EFFECTS
                  None

===========================================================================*/
void rrccsp_prioritize_pending_commands(rrc_cmd_type *cmd_ptr)
{
  WRRC_MSG0_HIGH("WTOW: Prioritize Pending Cmds Fn called");

  switch(rrc_csp_int_data.pending_type)
  {
    /* ----------------------------------------------------------
     * BPLMN_SUSPEND_REQ is Pending and a new command is received 
     * ----------------------------------------------------------
     */
    case RRC_CSP_BPLMN_SRCH_SUSPEND_REQ_PENDING:

      switch(cmd_ptr->cmd_hdr.cmd_id)
      {
        case RRC_BPLMN_SUSPEND_REQ:
          MSG_HIGH("Pending Cmd %d same as Rcvd Cmd 0x%x. Send SUSPEND_CNF w failure to calling proc rrc_proc_e_type_value%d", 
                                                      rrc_csp_int_data.pending_type,
                                                      cmd_ptr->cmd_hdr.cmd_id,
                                                      rrc_csp_int_data.bplmn_suspend_proc);

          rrc_csp_send_bplmn_suspend_cnf(rrc_csp_int_data.bplmn_suspend_proc, FAILURE);
          rrccsp_save_req(cmd_ptr);
          break;

        case RRC_SERVICE_REQ:
          MSG_HIGH("Pending Cmd %d < Rcvd Cmd 0x%x. Send SUSPEND_CNF w failure to calling proc rrc_proc_e_type_value%d", 
                                                      rrc_csp_int_data.pending_type,
                                                      cmd_ptr->cmd_hdr.cmd_id,
                                                      rrc_csp_int_data.bplmn_suspend_proc);
          rrc_csp_send_bplmn_suspend_cnf(rrc_csp_int_data.bplmn_suspend_proc, FAILURE);
          rrccsp_save_req(cmd_ptr);
          break;
  
        case RRC_PLMN_LIST_REQ:
          WRRC_MSG2_HIGH("Pending Cmd %d > Rcvd Cmd 0x%x", rrc_csp_int_data.pending_type,
                                                     cmd_ptr->cmd_hdr.cmd_id
                                                     );

          rrc_csp_send_mm_plmn_list_cnf_as_aborted(cmd_ptr->cmd.plmn_list_req.trans_id);

          break;
        case RRC_BPLMN_SEARCH_ABORT_REQ:
          MSG_HIGH("Pending Cmd %d same as Rcvd Cmd 0x%x. Send SUSPEND_CNF w failure to calling proc rrc_proc_e_type_value%d", 
                                                      rrc_csp_int_data.pending_type,
                                                      cmd_ptr->cmd_hdr.cmd_id,
                                                      rrc_csp_int_data.bplmn_suspend_proc);
          rrc_csp_send_bplmn_suspend_cnf(rrc_csp_int_data.bplmn_suspend_proc, FAILURE);
          rrccsp_save_req(cmd_ptr);
          break;

        default:
          WRRC_MSG2_ERROR("Pending Cmd %d > Rcvd Cmd 0x%x. Ignore.", rrc_csp_int_data.pending_type,
                                                         cmd_ptr->cmd_hdr.cmd_id
                                                         );
          break;
      }
      break;

    /* ----------------------------------------------------
     * SERVICE_REQ is Pending and a new command is received 
     * ----------------------------------------------------
     */
    case RRC_CSP_SERVICE_REQ_PENDING:
  
      switch(cmd_ptr->cmd_hdr.cmd_id)
      {
        case RRC_SERVICE_REQ:
          WRRC_MSG2_ERROR("Pending Cmd %d = Rcvd Cmd 0x%x. Overwrite.", rrc_csp_int_data.pending_type,
                                                            cmd_ptr->cmd_hdr.cmd_id
                                                            );
          rrccsp_save_req(cmd_ptr);
          break;

        case RRC_PLMN_LIST_REQ:
          WRRC_MSG2_HIGH("Pending Cmd %d < Rcvd Cmd 0x%x", rrc_csp_int_data.pending_type,
                                                     cmd_ptr->cmd_hdr.cmd_id
                                                     );
          rrccsp_save_req(cmd_ptr);
          break;
  
        case RRC_BPLMN_SUSPEND_REQ:
          WRRC_MSG2_HIGH("Pending Cmd %d > Rcvd Cmd 0x%x", rrc_csp_int_data.pending_type,
                                                     cmd_ptr->cmd_hdr.cmd_id
                                                     );
          WRRC_MSG1_HIGH("Send SUSPEND_CNF w failure to calling proc rrc_proc_e_type_value%d", 
                                                      cmd_ptr->cmd.rrc_csp_bplmn_suspend_req.procedure);

          rrc_csp_send_bplmn_suspend_cnf(cmd_ptr->cmd.rrc_csp_bplmn_suspend_req.procedure, FAILURE);
          break;
  
        default:
          WRRC_MSG2_ERROR("Pending Cmd %d > Rcvd Cmd 0x%x. Ignore", rrc_csp_int_data.pending_type,
                                                        cmd_ptr->cmd_hdr.cmd_id
                                                        );
          break;
      }
      break;

    /* ------------------------------------------------------
     * PLMN_LIST_REQ is Pending and a new command is received 
     * ------------------------------------------------------
     */                                                      
    case RRC_CSP_PLMN_LIST_REQ_PENDING:

      switch(cmd_ptr->cmd_hdr.cmd_id)
      {
        case RRC_PLMN_LIST_REQ:
          WRRC_MSG2_ERROR("Pending Cmd %d = Rcvd Cmd 0x%x", rrc_csp_int_data.pending_type,
                                                cmd_ptr->cmd_hdr.cmd_id);
          rrc_csp_send_mm_plmn_list_cnf_as_aborted(rrc_csp_int_data.pending_plmn_list_req_data.trans_id);
          rrccsp_save_req(cmd_ptr);
          break;

        case RRC_SERVICE_REQ:
          WRRC_MSG2_HIGH("Pending Cmd %d < Rcvd Cmd 0x%x", rrc_csp_int_data.pending_type,
                                                     cmd_ptr->cmd_hdr.cmd_id
                                                     );
          rrc_csp_send_mm_plmn_list_cnf_as_aborted(rrc_csp_int_data.pending_plmn_list_req_data.trans_id);
          rrccsp_save_req(cmd_ptr);
          break;

        case RRC_BPLMN_SUSPEND_REQ:
          WRRC_MSG2_HIGH("Pending Cmd %d < Rcvd Cmd 0x%x", rrc_csp_int_data.pending_type,
                                                     cmd_ptr->cmd_hdr.cmd_id
                                                     );
          rrc_csp_send_mm_plmn_list_cnf_as_aborted(rrc_csp_int_data.pending_plmn_list_req_data.trans_id);
          rrccsp_save_req(cmd_ptr);
          break;


        case RRC_BPLMN_SEARCH_ABORT_REQ:
          WRRC_MSG2_ERROR("Pending Cmd %d = Rcvd Cmd 0x%x", rrc_csp_int_data.pending_type,
                                                cmd_ptr->cmd_hdr.cmd_id);
          rrc_csp_send_mm_plmn_list_cnf_as_aborted(rrc_csp_int_data.pending_plmn_list_req_data.trans_id);
          rrccsp_save_req(cmd_ptr);
          break;

        default:
          WRRC_MSG2_ERROR("Pending Cmd %d > Rcvd Cmd 0x%x. Ignore", rrc_csp_int_data.pending_type,
                                                        cmd_ptr->cmd_hdr.cmd_id
                                                        );
          break;
      }
      break;

   /* ---------------------------------------------------------------
     * RRC_BPLMN_SRCH_ABORT_REQ is Pending and a new command is received 
     * ---------------------------------------------------------------
     */   
      case RRC_CSP_BPLMN_SRCH_ABORT_REQ_PENDING:

       switch(cmd_ptr->cmd_hdr.cmd_id)
       {
         case RRC_BPLMN_SUSPEND_REQ:
	   rrc_csp_int_data.bplmn_suspend_proc = cmd_ptr->cmd.rrc_csp_bplmn_suspend_req.procedure;
           rrc_csp_int_data.bplmn_suspend_cause = cmd_ptr->cmd.rrc_csp_bplmn_suspend_req.cause; 

           WRRC_MSG2_HIGH("Saving SUSPEND_REQ proc rrc_proc_e_type_value%d and cause %d", 
                 rrc_csp_int_data.bplmn_suspend_proc, rrc_csp_int_data.bplmn_suspend_cause);
           break;
     
         case RRC_SERVICE_REQ:
           WRRC_MSG2_HIGH("Pending Cmd %d < Rcvd Cmd 0x%x", rrc_csp_int_data.pending_type,
                                                      cmd_ptr->cmd_hdr.cmd_id
                                                      );
           /* Save Service Request  */
           rrccsp_save_req(cmd_ptr);
           break;  
   
          case RRC_PLMN_LIST_REQ:  
 
            WRRC_MSG2_HIGH("Pending Cmd %d = Rcvd Cmd 0x%x", rrc_csp_int_data.pending_type,
                                                 cmd_ptr->cmd_hdr.cmd_id); 

           /* Save PLMN_LIST_REQ */
           rrccsp_save_req(cmd_ptr);
           break;

         case RRC_BPLMN_SEARCH_ABORT_REQ:
           WRRC_MSG2_ERROR("RRC_BPLMN_SEARCH_ABORT_REQ Shouldn't come here Pending Cmd %d = Rcvd Cmd 0x%x",
                                                              rrc_csp_int_data.pending_type,  cmd_ptr->cmd_hdr.cmd_id);
           rrccsp_save_req(cmd_ptr);
           break;

         default:
           WRRC_MSG2_ERROR("Shouldn't come here, Pending Cmd %d > Rcvd Cmd 0x%x. Ignore.", rrc_csp_int_data.pending_type,
                                                          cmd_ptr->cmd_hdr.cmd_id
                                                          );
           break;
       }
       break;

     default:
       WRRC_MSG2_HIGH("Pending Cmd %d < Rcvd Cmd 0x%x. Save rcvd cmd", rrc_csp_int_data.pending_type,
                                                                 cmd_ptr->cmd_hdr.cmd_id
                                                                );
       rrccsp_save_req(cmd_ptr);
       break;
  }
} /* rrccsp_prioritize_pending_commands */


/*===========================================================================

FUNCTION          RRCCSP_SAVE_REQ

DESCRIPTION       This function saves the new request for later. This request
                  will be processed once the appropriate confirmation on which
                  CSP was waiting on is received.

DEPENDENCIES
                  None

RETURN VALUE
                  None

SIDE EFFECTS
                  None

===========================================================================*/
void rrccsp_save_req(rrc_cmd_type *cmd_ptr)
{

  /* Inter-RAT command */
  rrc_rr_cmd_type *rr_cmd;


  boolean interrat_cmd = FALSE;

#ifdef FEATURE_LTE_TO_WCDMA
  if(cmd_ptr->cmd_hdr.cmd_id == RRC_LTE_RRC_CMD)
  {
    interrat_cmd = TRUE;
  }
#endif

  if((((uint32)cmd_ptr->cmd_hdr.cmd_id & RRC_RR_CMD_ID_BASE) == RRC_RR_CMD_ID_BASE) )
  {
    interrat_cmd = TRUE;
  }


  if(!interrat_cmd)
  {
    /* Store the contents of Service Request/PLMN LIST REQ/STATE_CHANGE_IND
     * in Internal database and wait for Acq. Confirm in the new state.
     */

    switch(cmd_ptr->cmd_hdr.cmd_id)
    {
      case RRC_SERVICE_REQ:
        if(rrc_csp_int_data.pending_type != RRC_CSP_INITIATE_CELL_SEL_PENDING)
        {
          if(rrc_csp_int_data.curr_scan == RRC_CSP_PLMN_LIST_SCAN)
          {
            rrc_csp_send_mm_plmn_list_cnf_as_aborted(rrc_csp_int_data.bplmn_trans_id);
          }
          rrc_csp_int_data.last_mm_primitive = RRC_CSP_SRVC_REQ_RCVD;
          rrc_csp_int_data.pending_srvc_req_data = cmd_ptr->cmd.rrc_service_req;
          rrc_csp_int_data.pending_type = RRC_CSP_SERVICE_REQ_PENDING;
        }
        else
        {
          /* Send SERVICE_CNF so that MM cleans up */
          rrc_csp_send_mm_cmd(RRC_SERVICE_CNF,
                                   MM_AS_NO_SERVICE,
                                   &rrc_csp_int_data.curr_sel_plmn,
                                   &rrc_csp_int_data.curr_acq_entry);
        }
        break;

      case RRC_PLMN_LIST_REQ:
        if(rrc_csp_int_data.pending_type == RRC_CSP_INITIATE_CELL_SEL_PENDING)
        {
         rrc_csp_send_mm_plmn_list_cnf_as_aborted(rrc_csp_int_data.bplmn_trans_id);
         break;
        }
        else if(rrc_csp_int_data.last_mm_primitive == RRC_CSP_SRVC_REQ_RCVD)
        {
          /* Send SERVICE_CNF so that MM cleans up */
          rrc_csp_send_mm_cmd(RRC_SERVICE_CNF,
                              MM_AS_NO_SERVICE,
                              &rrc_csp_int_data.curr_sel_plmn,
                              &rrc_csp_int_data.curr_acq_entry);
        }
        if(rrc_csp_int_data.curr_scan == RRC_CSP_PLMN_LIST_SCAN)
        {
          rrc_csp_send_mm_plmn_list_cnf_as_aborted(rrc_csp_int_data.bplmn_trans_id);
        }
        rrc_csp_int_data.last_mm_primitive = RRC_CSP_PLMN_LIST_REQ_RCVD;
        rrc_csp_int_data.pending_plmn_list_req_data = cmd_ptr->cmd.plmn_list_req;
        rrc_csp_int_data.pending_type = RRC_CSP_PLMN_LIST_REQ_PENDING;
        break;

      case RRC_STATE_CHANGE_IND:
        rrc_csp_int_data.pending_type = RRC_CSP_STATE_CHANGE_IND_PENDING;
        /* Store the RRC command information */
        WCDMA_MEMCPY(&rrc_csp_int_data.saved_rrc_cmd,
                     sizeof(rrc_cmd_type),
                     cmd_ptr,
                     sizeof(rrc_cmd_int_type));
        break;

      case RRC_DCH_FACH_CELL_SELECTION_TIMER_EXPIRED_IND:
        rrc_csp_int_data.pending_type = RRC_CSP_DCH_TO_FACH_TIMER_PENDING;
        break;

      case RRC_DCH_PCH_CELL_SELECTION_TIMER_EXPIRED_IND:
        rrc_csp_int_data.pending_type = RRC_CSP_DCH_TO_PCH_TIMER_PENDING;
        break;

      case RRC_INITIATE_CELL_SELECTION_IND:
        rrc_csp_int_data.pending_type = RRC_CSP_INITIATE_CELL_SEL_PENDING;
        break;

      case RRC_BPLMN_SRCH_TIMER_EXPIRED_IND:
        rrc_csp_int_data.pending_type = RRC_BPLMN_SRCH_TIMER_PENDING;
        break;

      case RRC_FREQ_REDIRECT_WAIT_TIMER_EXPIRED_IND:
        rrc_csp_int_data.pending_type = RRC_FREQ_REDIRECT_WAIT_TIMER_PENDING;
        break;

      case RRC_WTOW_BPLMN_DRX_SRCH_TIMER_EXPIRED_IND:
        rrc_csp_int_data.pending_type = RRC_CSP_WTOW_BPLMN_DRX_SRCH_TIMER_PENDING;
        break;                             

      case RRC_BPLMN_GUARD_SRCH_TIMER_EXPIRED_IND:
        rrc_csp_int_data.pending_type = RRC_CSP_BPLMN_GUARD_SRCH_TIMER_PENDING;
        break;                          

      case RRC_BPLMN_SEARCH_ABORT_REQ:
        rrc_csp_int_data.pending_type = RRC_CSP_BPLMN_SRCH_ABORT_REQ_PENDING;
        break;

      case RRC_BPLMN_SUSPEND_REQ:
        rrc_csp_int_data.pending_type       = RRC_CSP_BPLMN_SRCH_SUSPEND_REQ_PENDING;
        rrc_csp_int_data.bplmn_suspend_proc = cmd_ptr->cmd.rrc_csp_bplmn_suspend_req.procedure;
        rrc_csp_int_data.bplmn_suspend_cause = cmd_ptr->cmd.rrc_csp_bplmn_suspend_req.cause;
        break;                             

#ifdef FEATURE_EOOS
      #error code not present
#endif

      case RRC_FACH_TO_FACH_PCH_CELL_SELECTION_TIMER_EXPIRED_IND:
        rrc_csp_int_data.pending_type = RRC_CSP_FACH_TO_FACH_PCH_TIMER_PENDING;
        break;
#ifdef FEATURE_DUAL_SIM
      case  RRC_WRM_PREEMPT_IND:
        rrc_csp_int_data.pending_type = RRC_CSP_PREEMPT_IND_PENDING;
        WRRC_MSG0_HIGH("DSIM_TUNEAWAY: Pending type RRC_CSP_PREEMPT_IND_PENDING");
        break;
#endif

      default:
        WRRC_MSG0_ERROR("Shouldn't come here");
        break;
    }
  }
  else if(((uint32)cmd_ptr->cmd_hdr.cmd_id & RRC_RR_CMD_ID_BASE) == RRC_RR_CMD_ID_BASE)
  {
    rr_cmd = ((rrc_rr_cmd_type *)cmd_ptr);     /*lint !e740*/

    switch(rr_cmd->cmd_hdr.cmd_id)
    {
      case RRC_INTERRAT_PLMN_SRCH_ABORT_REQ:
        rrc_csp_int_data.pending_type = RRC_INTERRAT_PLMN_SRCH_ABORT_REQ_PENDING;
        break;
#ifdef FEATURE_GAN_3G_ROVE_OUT_ONLY
      #error code not present
#endif
      default:
        WRRC_MSG0_ERROR("Shouldn't come here");
        break;
    }
  }


#ifdef FEATURE_LTE_TO_WCDMA
  else if(cmd_ptr->cmd_hdr.cmd_id == RRC_LTE_RRC_CMD)
  {
    switch(cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.msg_hdr.id)
    {
      case WCDMA_RRC_LTE_ABORT_PLMN_SRCH_REQ:
        rrc_csp_int_data.pending_type = RRC_INTERRAT_PLMN_SRCH_ABORT_REQ_PENDING;
        break;
      default :
        /*Shouldnt come here, already taken care*/
        WRRC_MSG1_ERROR("LTOW: Invalid cmd %x from LTE RRC ",cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.msg_hdr.id);
        break;
    }
  }
#endif
} /* rrccsp_save_req */

#ifdef FEATURE_DUAL_SIM
/*===========================================================================

FUNCTION   RRCCSP_SEND_DRX_TIMER_EXPIRY_IND

DESCRIPTION

  This function sends a CPHY_DRX_TIMER_EXPIRY_IND to L1 to indicate the
  DRX timer expiry
          
DEPENDENCIES

  None.
 
RETURN VALUE

  None.

SIDE EFFECTS

  None.

===========================================================================*/
static void rrccsp_send_drx_timer_expiry_ind( void )
{
  l1_ext_cmd_type *l1_cmd_ptr;

  /* Get a L1 command buffer */
  l1_cmd_ptr = l1_get_cmd_buf();

  /* Fill in the Command Header */
  l1_cmd_ptr->cmd_hdr.cmd_id = CPHY_DRX_TIMER_EXPIRY_IND;

  l1_cmd_ptr->cmd_hdr.sys_modem_as_id = rrc_get_as_id();

  /* Now send the primitive to L1 */
  l1_put_cmd(l1_cmd_ptr);
  WRRC_MSG0_HIGH("CPHY_DRX_TIMER_EXPIRY_IND sent to L1");
  
} /* end of rrccsp_send_drx_timer_expiry_ind */
#endif

/* =======================================================================
**      Function Definitions for substate: RRCCSP_CELL_SEL_WT_ACQ
** ======================================================================= */


/*===========================================================================

FUNCTION        rrccsp_cell_sel_wait_acq_acq

DESCRIPTION     This function handles the ACQ Confirm event from L1 when CSP
                has been waiting on that event.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_cell_sel_wait_acq_acq( rrc_cmd_type *cmd_ptr )
{
  rrc_csp_substate_e_type  next_substate;
  uint8 i;
#ifdef FEATURE_LTE_TO_WCDMA
  uint64 ltow_redir_srch_timer;
#endif

  rrc_csp_sib_mask_type    sib_mask = 0;

#ifdef FEATURE_3GPP_CSFB
  rrc_csfb_sib_container_event_type csfb_sib_event;
#endif


  boolean is_non_white_csg;
  boolean is_bar_resel;


  l1_cell_bar_info_e_type l1_bar_status;
  rrclog_wcdma_acq_success_event_type acq_success_event;
  next_substate = RRCCSP_CELL_SEL_WT_ACQ;


  /* Read data in the received CPHY_ACQ_CNF cmd */

  /* Check if Acquisition succeeded */
  if(cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.status == TRUE)
  {
    
    /* TTL Markers to provide Modem Boot up Time*/
    TTLBOOTUP(WCDMA_ACQ_SUCCESS);
    WRRC_MSG2_HIGH("ACQ SUCCEED on freq: %d, scr: %d", 
              cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.freq, cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.scr_code);
    /* First check that there is no discrepency between frequency sent to L1 and what
     * it acquired on. It is not so bad - only that L1 decided on this freq on its own.
     */
     
    //EVENT: Event_Acquisiton_Success
    acq_success_event.uarfcn = cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.freq;
    acq_success_event.scr_code = cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.scr_code;
    acq_success_event.sttd = cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.sttd;
    event_report_payload(EVENT_WCDMA_ACQUISITON_SUCCESS, sizeof(acq_success_event),
                   (void *)&acq_success_event);
    
    if(cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.freq != rrc_csp_int_data.curr_acq_entry.freq)
    {
      WRRC_MSG2_ERROR("ERR Freq %d sent to L1, freq %d acquired by L1",
           rrc_csp_int_data.curr_acq_entry.freq, cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.freq);
    }
#ifdef FEATURE_DUAL_SIM
    if(rrc_csp_int_data.shld_acq_be_spltd)
    {
      if(WRM_CLI_STATE_IS_IN_LOCK(WCDMA_TRM, WRM_PRIMARY_CLIENT_RRC))
      {
        /*This to get immediate premption if any which are ignored during acq*/
        wrm_retain_lock_for_primary();
      }
    }
    rrc_csp_int_data.shld_acq_be_spltd = FALSE;
#endif
    /* Update the frequency anyway */
    rrc_csp_int_data.curr_acq_entry.freq = cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.freq;

    /* Important: The Scrambling code found on this freq. may be different that what was
     * stored in Acq. DB last. Update it in Internal data.
     */
    rrc_csp_int_data.curr_acq_entry.scr_code = cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.scr_code;

    if((rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN) || 
       (rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_MANUAL_SCAN) ||
       (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN) ||
       (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
#ifdef FEATURE_LTE_TO_WCDMA
       || ((rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_CELL_RESELECTION_SCAN)
            && (rrc_csp_int_data.interrat_type == RRC_CSP_INTERRAT_LTE_CGI))
#endif
      )
    {
      /* Save the pn_pos of the acquired cell, to be used in the next DRX cycle, if DRX timer
         expires before MIB is read. */
      rrc_csp_int_data.bplmn_acq_succ_pn_pos = cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.pn_pos;
      rrc_csp_int_data.cgi_rscp              = cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.rscp;
      rrc_csp_int_data.cgi_ecio              = cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.ecio_2x;
    }

    /* Now update the serving PCCPCH data */
    rrc_csp_int_data.serving_pccpch_parms.scr_code =
                              cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.scr_code;
    rrc_csp_int_data.serving_pccpch_parms.tx_div_ind =
                              cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.sttd;

    if(rrc_csp_curr_select_data.num_tries_on_dest_freq > 0)
    {
      WRRC_MSG0_HIGH("Reset Number of tries on destnation frequency");
      rrc_csp_curr_select_data.num_tries_on_dest_freq =0;
    }

    /* Update the scrambling code list if the acq_mode was L1_WCDM_ACQ_LIST */
    if((rrc_csp_int_data.acq_mode == L1_WCDMA_ACQ_DET_LIST)&&(rrc_csp_int_data.acq_type == L1_WCDMA_FREQ_ONLY))
    {
      if(cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.num_scr_code_det <= L1_WCDMA_ACQ_DET_LIST_MAX)
      {
        /* Store the number of scrambling codes received in ACQ_CNF */
        rrc_csp_int_data.num_scr_code_det =
          cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.num_scr_code_det;
      }
      else
      {
        WRRC_MSG1_ERROR("Invalid num_scr_code_det %d",
               cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.num_scr_code_det);
        /* Filling only L1_WCDMA_ACQ_DET_LIST_MAX number of entries into the detected list */
        rrc_csp_int_data.num_scr_code_det = L1_WCDMA_ACQ_DET_LIST_MAX;
      }

      WRRC_MSG1_HIGH("Number of scr_codes detected %d",rrc_csp_int_data.num_scr_code_det);
      /* Store the scrambling codes received in ACQ_CNF into the internal database */
      for(i=0; i< rrc_csp_int_data.num_scr_code_det; i++)
      {
        rrc_csp_int_data.scr_code_det[i] = cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.scr_code_det[i];
        WRRC_MSG2_HIGH("Scr code %d, PN Pos %d",rrc_csp_int_data.scr_code_det[i].scr_code,
                                          rrc_csp_int_data.scr_code_det[i].pn_pos);
      }

      /* Update BPLMN backup data */
      if((rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN)||
         (rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_MANUAL_SCAN)||
         (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN)||
         (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN))
      {
        rrc_csp_int_data.bplmn_acq_succ_scr_code_det = rrc_csp_int_data.num_scr_code_det;
        rrc_csp_int_data.bplmn_acq_succ_curr_acq_count = 0;
      }

#ifdef FEATURE_FEMTO_CSG
      if(rrccsp_asf_actively_in_prog())
      {
        rrccsp_prune_acqdb_after_acq(TRUE);
      }
#endif
    }

    /* If BPLMN is in progress then only MIB, SIB1 and SIB3 are specified in the mask.
     * CSP indicates to SIB that this request is for a background PLMN. It then waits for
     * the RRC_GET_SPECIFIC_SIBS_CNF from SIB.
     */
    if(rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN)
    {
      WRRC_MSG0_HIGH("GTOW Auto scan: Read MIB, SIB1 & SIB3");
      sib_mask = MIB_BIT|SIB_1_BIT|SIB_3_BIT;
#ifdef FEATURE_FEMTO_CSG
      /* Not reading SIB1 for now as it may cause search delay */
      if(rrc_csp_int_data.service_search_bgnd == SYS_SERVICE_SEARCH_CSG)
      {
        sib_mask = MIB_BIT|SIB_3_BIT;
      }
#endif
    }
    else if(rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_MANUAL_SCAN)
    {
#ifdef FEATURE_SKIP_SIB1_3_DURING_MANUAL_PLMN_SCAN
      WRRC_MSG0_HIGH("GTOW Manual scan: Read only MIB");
      sib_mask = MIB_BIT;
#else
      WRRC_MSG0_HIGH("GTOW Manual scan: Read MIB, SIB1 & SIB3");
      sib_mask = MIB_BIT|SIB_1_BIT|SIB_3_BIT;
#endif
#ifdef FEATURE_FEMTO_CSG
      if(rrc_csp_int_data.service_search_bgnd == SYS_SERVICE_SEARCH_CSG)
      {
        sib_mask = MIB_BIT|SIB_3_BIT;
    }
#endif
    }
    else if((rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN)||
            (rrc_csp_int_data.curr_scan == RRC_CSP_PLMN_LIST_SCAN))
    {
#ifdef FEATURE_SKIP_SIB1_3_DURING_MANUAL_PLMN_SCAN
      WRRC_MSG0_HIGH("WTOW Manual Scan: Read only MIB");
      sib_mask = MIB_BIT;
#else
      WRRC_MSG0_HIGH("WTOW Manual Scan: Read MIB, SIB1 & SIB3");
      sib_mask = MIB_BIT|SIB_1_BIT|SIB_3_BIT;
#endif
#ifdef FEATURE_FEMTO_CSG
      if(rrc_csp_int_data.service_search_bgnd == SYS_SERVICE_SEARCH_CSG)
      {
        WRRC_MSG0_HIGH("CSG: Manual CSG list request. Read MIB and SIB3");
        sib_mask = MIB_BIT|SIB_3_BIT;
      }
#endif
    }
    else if(rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
    {
      WRRC_MSG0_HIGH("WTOW Auto Scan: Read MIB, SIB1 & SIB3");
      sib_mask = MIB_BIT|SIB_1_BIT|SIB_3_BIT;
    }
#ifdef FEATURE_LTE_TO_WCDMA
    else if ( (rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_CELL_RESELECTION_SCAN)
           && (rrc_csp_int_data.interrat_type == RRC_CSP_INTERRAT_LTE_CGI) )
    {
      WRRC_MSG0_HIGH("CGI: Read MIB, SIB1 & SIB3");
      sib_mask = MIB_BIT|SIB_1_BIT|SIB_3_BIT;
    }
#endif
    else
    {
      /* Get all the SIBs here */
      sib_mask = MIB_BIT|SIB_1_BIT|SIB_2_BIT|SIB_3_BIT|SIB_4_BIT|SIB_5_BIT|SIB_6_BIT|SIB_7_BIT|SIB_11_BIT|SIB_12_BIT|SIB_18_BIT;

       /*SIB11bis is an extension type SIB, so add SIB_11BIS_BIT mask to read Sib11bis*/
      sib_mask = sib_mask|SIB_11BIS_BIT;
#ifdef FEATURE_WCDMA_TO_LTE
      sib_mask = sib_mask | SIB_19_BIT;
#endif
    }

#ifdef FEATURE_3GPP_CSFB
    if((rrc_csfb_call_status) && 
       (RRC_CSP_GSM_TO_WCDMA_REDIRECTION_SCAN == rrc_csp_int_data.curr_scan) && 
       (rrc_csp_int_data.interrat_type == RRC_CSP_INTERRAT_LTE) && (rrc_csfb_skip_sib11_opt_nv == TRUE))
    {
      /*If LTOW redirection for CSFB call is in progress, skip reading optional SIBs*/
      rrc_csp_sib_mask_type skip_sib_mask = 0;
      skip_sib_mask = SIB_2_BIT |SIB_11_BIT |SIB_12_BIT|SIB_18_BIT;
      skip_sib_mask |= SIB_11BIS_BIT;
#ifdef FEATURE_WCDMA_TO_LTE
      skip_sib_mask |= SIB_19_BIT;
#endif
      WRRC_MSG0_HIGH("CSFB: Skipping SIB2, SIB11, SIB12, SIB18, SIB19 reading");
      sib_mask &= ~skip_sib_mask;
      WRRC_MSG1_HIGH("CSFB: SIB request mask %d ",sib_mask);
    }
#endif
#ifdef FEATURE_FEMTO_CSG
    if(rrccsp_asf_actively_in_prog())
    {
      /* For inter-freq check only the best cell for ASF CSG search. */
      if((rrc_csp_int_data.curr_acq_entry.freq != rrc_ccm_get_curr_camped_freq())&&
         (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN))
      {
        WRRC_MSG0_HIGH("CSG:Setting detected scr codes to zero");
        rrc_csp_int_data.num_scr_code_det = 0;
        rrc_csp_int_data.bplmn_acq_succ_scr_code_det = 0;
        rrc_csp_int_data.bplmn_acq_succ_curr_acq_count = 0;
      }

      if(rrc_csp_int_data.temp_csg_list.num_entries != MAX_ASF_CELLS)
      {
        uint8 csg_list_idx = rrc_csp_int_data.temp_csg_list.num_entries;
        /*First check if an entry already exists. Possible during ASF suspend/resume if not perfomed properly*/
        for(i = 0;i < csg_list_idx;i++)
        {
          if((rrc_csp_int_data.temp_csg_list.csg_cell_info[i].csg_cell_l1_info.rat_u.wcell.freq == cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.freq)&&
             (rrc_csp_int_data.temp_csg_list.csg_cell_info[i].csg_cell_l1_info.rat_u.wcell.psc == cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.scr_code/16))
          {
            csg_list_idx = i;
            WRRC_MSG0_HIGH("CSG:Entry already exists update it");
            break;
          }
        }
        rrc_csp_int_data.temp_csg_list.csg_cell_info[csg_list_idx].csg_cell_l1_info.rat = SYS_RAT_UMTS_RADIO_ACCESS;
        rrc_csp_int_data.temp_csg_list.csg_cell_info[csg_list_idx].csg_cell_l1_info.rat_u.wcell.freq = cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.freq;
        rrc_csp_int_data.temp_csg_list.csg_cell_info[csg_list_idx].csg_cell_l1_info.rat_u.wcell.psc = cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.scr_code/16;
        rrc_csp_int_data.temp_csg_list.csg_cell_info[csg_list_idx].csg_cell_l1_info.rat_u.wcell.pn_pos = cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.pn_pos;
        rrc_csp_int_data.temp_csg_list.csg_cell_info[csg_list_idx].csg_cell_l1_info.rat_u.wcell.acq_tot_eng = cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.tot_eng;
        rrc_csp_int_data.temp_csg_list.csg_cell_info[csg_list_idx].csg_cell_l1_info.rat_u.wcell.acq_sfn_extended = cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.sfn_extended;
        rrc_csp_int_data.temp_csg_list.csg_cell_info[csg_list_idx].csg_cell_l1_info.rat_u.wcell.acq_rx_agc = cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.rx_agc;
        rrc_csp_int_data.temp_csg_list.csg_cell_info[csg_list_idx].csg_cell_l1_info.rat_u.wcell.ecio_2x = cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.ecio_2x;
        rrc_csp_int_data.temp_csg_list.csg_cell_info[csg_list_idx].csg_cell_l1_info.rat_u.wcell.rscp = cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.rscp;
      
        MSG_9(MSG_SSID_DFLT, MSG_LEGACY_HIGH,
         "CSG: freq %d psc %d, pn_pos %d acq_tot_eng=%d acq_sfn_extended=%d acq_rx_agc=%d",
           cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.freq, cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.scr_code/16,
           cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.pn_pos, cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.tot_eng,
           cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.sfn_extended, cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.rx_agc,0,0,0);
      }

      WRRC_MSG0_HIGH("CSG: ASF srch Read MIB & SIB3");
      sib_mask = MIB_BIT|SIB_3_BIT;
    }
#endif
#ifdef FEATURE_LTE_TO_WCDMA
    if((RRC_CSP_GSM_TO_WCDMA_REDIRECTION_SCAN == rrc_csp_int_data.curr_scan) && 
       (rrc_csp_int_data.interrat_type == RRC_CSP_INTERRAT_LTE) && rrc_csp_int_data.first_acq_on_redirected_freq)
    {
      ltow_redir_srch_timer = rrctmr_get_remaining_time(RRCTMR_LTE_TO_WCDMA_REDIR_SRCH_TIMER);
      if((ltow_redir_srch_timer < RRCTMR_LTE_TO_WCDMA_REDIR_EXT_SRCH_TIMER_IN_MS) &&
         (ltow_redir_srch_timer > 0))
     {
       rrctmr_stop_timer(RRCTMR_LTE_TO_WCDMA_REDIR_SRCH_TIMER);
       rrctmr_start_timer(RRCTMR_LTE_TO_WCDMA_REDIR_SRCH_TIMER,RRCTMR_LTE_TO_WCDMA_REDIR_EXT_SRCH_TIMER_IN_MS);
       rrc_csp_int_data.first_acq_on_redirected_freq = FALSE;
       WRRC_MSG1_HIGH("Starting ltow redir ext srch timer with value %d",RRCTMR_LTE_TO_WCDMA_REDIR_EXT_SRCH_TIMER_IN_MS);
     }
    }
#endif

    if(rrc_csp_send_sib_cmd(RRC_GET_SPECIFIC_SIBS_REQ, sib_mask,
                            &rrc_csp_int_data.curr_acq_entry, TRUE) == SUCCESS)
    {
      MSG_MED( "RRC Cmd 0x%x sent, CSP sstate %d",
                                       RRC_GET_SPECIFIC_SIBS_REQ, RRCCSP_CELL_SEL_WT_ACQ, 0 );
      /* Start waiting for SIB Confirmation */
      next_substate = RRCCSP_CELL_SEL_WT_SIB;
    }
    else
    {
      ERR_FATAL("Failure to send SIB cmd 0x%x in CSP substate %d",
                                   RRC_GET_SPECIFIC_SIBS_REQ, RRCCSP_CELL_SEL_WT_ACQ, 0);
    }
  }
  else  /* Acquisition did not succeed */
  {
    if(cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.fail_type == WL1_FAILED_BAND_MISMATCH)
    {
      /* Save the barred freq to not skip scanning of the same in other overlapping band*/
      rrc_csp_save_barred_freq();
      WRRC_MSG0_HIGH("ACQ failed at L1 because of Band Mismatch");
    }

#ifdef FEATURE_FEMTO_CSG
    if((rrc_csp_int_data.acq_mode == L1_WCDMA_ACQ_DET_LIST)&&(rrc_csp_int_data.acq_type == L1_WCDMA_FREQ_ONLY))
    {
      if(rrccsp_asf_actively_in_prog())
      {
        rrccsp_prune_acqdb_after_acq(FALSE);
      }
    }
#endif
#ifdef FEATURE_DUAL_SIM
    if(cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.fail_type == WL1_FAILED_NO_WRM_LOCK)
    {
      WRRC_MSG0_HIGH("DSIM: ACQ failed at L1 because of No Resource");
      if(rrc_csp_int_data.shld_acq_be_spltd)
      {
        rrc_csp_freq_scan_e_type  type_freq_scan = RRC_CSP_ACQ_SCAN;
        rrc_csp_int_data.shld_acq_be_spltd = FALSE;
        next_substate = rrc_csp_wait_for_wrm_lock(&type_freq_scan);
        if(type_freq_scan == RRC_CSP_NO_SCAN)
       {
         return (next_substate);
       }

        if(type_freq_scan == RRC_CSP_ACQ_SCAN)
        {
          /* Send CPHY_ACQ_REQ to L1 and wait for the CNF */
          rrc_csp_send_l1_cmd(RRC_PROCEDURE_CSP, CPHY_ACQ_REQ, &rrc_csp_int_data.curr_acq_entry);
          return (RRCCSP_CELL_SEL_WT_ACQ);
        }
        else
        {
          rrc_csp_send_next_freq_to_l1(&rrc_csp_int_data.curr_acq_entry, type_freq_scan);
          return (RRCCSP_CELL_SEL_WT_FREQ_SCAN_CNF);
        }
      }
      else
      {
      /* Set oos_due_to_no_resource flag so that NAS is updated with NO SERVICE with cause
      NO RESOURCE*/
      rrc_set_oos_due_to_no_resource_flag();

      /*
        For Phase I, Release channels and go to IDLE
        >The cases of leaving connected mode, oos in idle scan
        For Phase II, Need to take care of interRAT and others, specific to Scans
        >For interRAT before ACQ, RRC will acquire the lock, so L1 shouldn't fail with No Resource cause
        >For WTOW BPLMN also RRC will acquire the lock
      */
      if(rrc_get_state() != RRC_STATE_DISCONNECTED)
      {
        rrc_ccm_update_with_cell_loss();
      }
      else
      {
        /* Force RCE to go to INITIAL, taking care of ongoing timers
         * and required response to MM, depending on RCE substate and
         */
       rrcrce_force_initialize(FALSE);
      }
      return (rrccsp_rel_chls_and_go_to_idle());
    }
    }
#endif

#ifdef FEATURE_3GPP_CSFB
    if((RRC_CSP_GSM_TO_WCDMA_REDIRECTION_SCAN == rrc_csp_int_data.curr_scan) &&
       (RRC_CSP_INTERRAT_LTE == rrc_csp_int_data.interrat_type))
    {
      csfb_sib_event.sib_container_sts = RRC_SIB_CONTAINER_NOT_USED_ACQ_FAILURE;
      event_report_payload(EVENT_WCDMA_RRC_CSFB_SIB_CONTAINER, sizeof(csfb_sib_event),
                                                       (void *)&csfb_sib_event);
    }
#endif

    if(rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_CELL_RESELECTION_SCAN)
    {
      if(rrc_csp_int_data.acq_type == L1_WCDMA_FREQ_SCR_POS)
      {
        /* Retry ACQ with freq and scr info */
        rrc_csp_int_data.acq_type = L1_WCDMA_FREQ_SCR;

        WRRC_MSG1_HIGH("Retry ACQ once with acq_type %d",rrc_csp_int_data.acq_type);

        /* Send CPHY_ACQ_REQ to L1 and wait for the CNF */
        rrc_csp_send_l1_cmd(RRC_PROCEDURE_CSP, CPHY_ACQ_REQ, &rrc_csp_int_data.curr_acq_entry);
        MSG_MED("L1 cmd 0x%x sent", CPHY_ACQ_REQ, 0, 0);
      }
      else
      {
        /* Send CHANGE_MODE_REQ (to Inactive) to MCM and wait for the CHANGE_MODE_CNF */
        rrccsp_send_mode_change_req_to_mcm(RRC_MODE_INACTIVE);
        rrc_csp_int_data.interrat_reselect_failure_reason = RRC_WCDMA_ACQUISITION_FAIL;
        next_substate = RRCCSP_WT_STOP_MODE_CHANGE_CNF;

        l1_bar_status = wl1_check_cell_barred_and_get_bar_time
                          (rrc_csp_int_data.curr_acq_entry.freq,
                            rrc_csp_int_data.curr_acq_entry.scr_code,
                           (uint16 *)&rrc_csp_int_data.wcdma_cell_time_to_reselect
                           , &is_non_white_csg
                           , &is_bar_resel
                           );

#ifdef FEATURE_LTE_TO_WCDMA
        if(rrc_csp_int_data.interrat_type == RRC_CSP_INTERRAT_LTE)
        {

#ifdef FEATURE_FEMTO_CSG
          if(is_non_white_csg == TRUE)
          {
            rrc_csp_int_data.interrat_reselect_failure_reason = RRC_WCDMA_CSG_FORBIDDEN;
          }
          else
#endif
        if(L1_WCDMA_PSC_BARRED == l1_bar_status)
        {
          rrc_csp_int_data.interrat_reselect_failure_reason = RRC_WCDMA_CELL_BARRED;
        }
        else if (L1_WCDMA_FREQ_BARRED == l1_bar_status)
        {
          rrc_csp_int_data.interrat_reselect_failure_reason = RRC_WCDMA_UARFCN_BARRED;
        }
      }
#endif

#ifdef FEATURE_FEMTO_CSG
#ifdef FEATURE_WCDMA_TO_LTE  
        if(rrc_csp_int_data.interrat_type == RRC_CSP_INTERRAT_GSM)
#endif
        {
          if(is_non_white_csg == TRUE)
          {
            rrc_csp_int_data.interrat_reselect_failure_reason = RRC_WCDMA_CSG_FORBIDDEN;
          }
        }
#endif
      }
    }
    else if(rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_CC_ORDER_SCAN)
    {
      /* Send CAMP_CNF failure with appropriate cause to CHO */
      rrc_csp_int_data.interrat_reselect_failure_reason = RRC_WCDMA_ACQUISITION_FAIL;
      rrccsp_send_camp_cnf_to_cho(FAILURE);
      next_substate = RRCCSP_NO_CELL_SELECTED;
    }
    else if(rrc_csp_int_data.curr_scan == RRC_CSP_INTER_FREQ_REDIRECTION_SCAN)
    {
      WRRC_MSG1_HIGH("Acq failed on freq %d during freq redirect scan",
                              cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.freq);
      next_substate = rrccsp_handle_failure_during_freq_redirection();
    }
    else
    {
      WRRC_MSG1_HIGH("Acq failed on freq %d", cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.freq);
      next_substate = rrc_csp_continue_cell_selection();
    }
  } /* Acquisition did not succeed */

  return( next_substate );
} /* rrccsp_cell_sel_wait_acq_acq */


/*===========================================================================

FUNCTION        rrccsp_cell_sel_wait_acq_hdlr

DESCRIPTION
                This is a handler for events received in
                RRCCSP_CELL_SEL_WT_ACQ substate of the Cell Selection Procedure.
                Depending on the event, it further calls a function for
                processing the event in this CSP substate.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_cell_sel_wait_acq_hdlr( rrc_cmd_type *cmd_ptr )
{
  rrc_csp_substate_e_type   next_substate;
  rrc_state_e_type          rrc_state = rrc_get_state();

#ifdef FEATURE_DUAL_SIM
  rrc_csp_freq_scan_e_type type_freq_scan = RRC_CSP_ACQ_SCAN;
#endif

  /* Inter-RAT command */
  rrc_rr_cmd_type *rr_cmd;

  boolean interrat_cmd = FALSE;

#ifdef FEATURE_LTE_TO_WCDMA
  if(cmd_ptr->cmd_hdr.cmd_id == RRC_LTE_RRC_CMD)
  {
    interrat_cmd = TRUE;
  }
#endif

  if((((uint32)cmd_ptr->cmd_hdr.cmd_id & RRC_RR_CMD_ID_BASE) == RRC_RR_CMD_ID_BASE) )
  {
    interrat_cmd = TRUE;
  }

  next_substate = RRCCSP_CELL_SEL_WT_ACQ;

#ifdef FEATURE_DUAL_SIM
  if((cmd_ptr->cmd_hdr.cmd_id == RRC_LLC_CMD_CNF) && 
      (cmd_ptr->cmd.rrc_llc_cnf.ll_cnf == RRC_LL_CPHY_ACQ_CNF) &&
       (rrc_csp_int_data.csp_waiting_for_wl1_to_release_lock))
  {
    WRRC_MSG0_HIGH("DSIM: CSP waiting for WL1 to release the lock, Ignore RRC_LL_CPHY_ACQ_CNF");
    return next_substate;
  }
#endif

  if(!interrat_cmd)
  {
    switch( cmd_ptr->cmd_hdr.cmd_id )
    {
      case RRC_LLC_CMD_CNF:
        MSG_LOW( "Cmd 0x%x recvd, CSP sstate %d",
                             cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
        switch(cmd_ptr->cmd.rrc_llc_cnf.ll_cnf)
        {
          case RRC_LL_CPHY_ACQ_CNF:
            MSG_MED("L1 cmd 0x%x recvd, CSP sstate %d",
                           cmd_ptr->cmd.rrc_llc_cnf.ll_cnf, rrc_csp_substate, 0);
            next_substate = rrccsp_cell_sel_wait_acq_acq( cmd_ptr );
            break;

          default:
            WRRC_MSG2_HIGH("Unexpected L1 cmd 0x%x, CSP sstate %d",
                           cmd_ptr->cmd.rrc_llc_cnf.ll_cnf, rrc_csp_substate);
            break;
        }
        break;

      case RRC_SERVICE_REQ:
        MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                   cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );

        if(rrc_state != RRC_STATE_DISCONNECTED)
        {
          WRRC_MSG1_ERROR("Service req in RRC state %d",rrc_state);
        }

        rrccsp_save_req( cmd_ptr );
        next_substate = RRCCSP_CELL_SEL_WT_ACQ_PENDING;
        break;

      case RRC_DCH_FACH_CELL_SELECTION_TIMER_EXPIRED_IND:
        if(rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_CELL_FACH_SCAN)
        {
          rrccsp_save_req(cmd_ptr);
          next_substate = RRCCSP_CELL_SEL_WT_ACQ_PENDING;
        }
        else
        {
          WRRC_MSG1_HIGH("Ignoring Cell Sel Tmr Exp in %d scan", rrc_csp_int_data.curr_scan);
        }
        break;

      case RRC_DCH_PCH_CELL_SELECTION_TIMER_EXPIRED_IND:
        if((rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_CELL_PCH_SCAN) ||
                (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_URA_PCH_SCAN))
        {
          rrccsp_save_req(cmd_ptr);
          next_substate = RRCCSP_CELL_SEL_WT_ACQ_PENDING;
        }
        else
        {
          WRRC_MSG1_HIGH("Ignoring Cell Sel Tmr Exp in %d scan", rrc_csp_int_data.curr_scan);
        }
        break;

      case RRC_FACH_TO_FACH_PCH_CELL_SELECTION_TIMER_EXPIRED_IND:
        if((rrc_csp_int_data.curr_scan == RRC_CSP_CELL_FACH_TO_CELL_FACH_SCAN) ||
           (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_FACH_TO_CELL_PCH_SCAN) ||
           (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_FACH_TO_URA_PCH_SCAN))
        {
          rrccsp_save_req(cmd_ptr);
          next_substate = RRCCSP_CELL_SEL_WT_ACQ_PENDING;
        }
        else
        {
          WRRC_MSG1_HIGH("Ignoring Cell Sel Tmr Exp in %d scan", rrc_csp_int_data.curr_scan);
        }
        break;

      case RRC_GTOW_REDIRECTION_WAIT_TIMER_EXPIRED_IND:
        WRRC_MSG0_HIGH("Interrat Redirection: Timer expired");
        rrc_csp_int_data.gtow_redirection_timer_expired = TRUE;
        break;

      case RRC_GTOW_REDIRECTION_LFS_TIMER_EXPIRED_IND:
        WRRC_MSG0_HIGH("Interrat Redirection: LFS Timer expired");
        rrc_csp_int_data.gtow_redir_retry_lfs_scan = TRUE;
        next_substate = rrc_csp_continue_cell_selection();
        break;

      case RRC_PLMN_LIST_REQ:
        MSG_MED("Cmd 0x%x recvd, CSP sstate %d", cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0);

        if(rrccsp_plmn_list_req_is_valid(&(cmd_ptr->cmd.plmn_list_req)))
        {
          /* If Scan Type is Leaving Connected Mode Scan then do Manual PLMN
           * Search in background (after UE camps).
           */
          if(rrc_csp_int_data.curr_scan == RRC_CSP_LEAVING_CONN_MODE_SCAN)
          {
            WRRC_MSG0_HIGH("WTOW: LeavingConnModeScan. Hold Manual Srch req until UE camps");

            /* The call to the function below should always return TRUE in this case.
             * If FALSE is returned then it is an error condition. Abort the search.
             */
            if(!rrccsp_handle_plmn_list_req_in_bgnd(&(cmd_ptr->cmd.plmn_list_req)))
            {
              rrc_csp_send_mm_plmn_list_cnf_as_aborted(cmd_ptr->cmd.plmn_list_req.trans_id);
            }
          }
          /* Since scan type is not leaving connected mode, do the search in foreground */
          else
          {
            rrccsp_save_req( cmd_ptr );
            next_substate = RRCCSP_CELL_SEL_WT_ACQ_PENDING;
          }
        }
        break;

      case RRC_STATE_CHANGE_IND:
        MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                           cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
        if(((rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_CELL_FACH_SCAN) ||
           (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_CELL_PCH_SCAN) ||
           (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_URA_PCH_SCAN) ||
            (rrc_csp_int_data.curr_scan == RRC_CSP_OUT_OF_SERVICE_AREA_SCAN) ||
            (rrc_csp_int_data.curr_scan ==
             RRC_CSP_OUT_OF_SERVICE_AREA_IN_CONNECTING_STATE_SCAN) ||
            (rrc_csp_int_data.curr_scan == RRC_CSP_INTER_FREQ_REDIRECTION_SCAN) ||
            (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN) ||
            (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN)) &&
            (cmd_ptr->cmd.state_change_ind.new_state == RRC_STATE_DISCONNECTED))
        {
          rrccsp_save_req( cmd_ptr );
          next_substate = RRCCSP_CELL_SEL_WT_ACQ_PENDING;
        }
        else
        {
          WRRC_MSG1_HIGH("Ignoring state change, curr scan %d",rrc_csp_int_data.curr_scan);
        }
        break;

      case RRC_INITIATE_CELL_SELECTION_IND:
        MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                           cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );

        /* If the procedure is CU and reason for initiating cell selection is
         * TRANSITION_TO_DISCONNECTED, process the command
         */
        if(cmd_ptr->cmd.initiate_cell_sel_ind.cause == RRC_TRANSITION_TO_DISCONNECTED)
        {    
            MSG_HIGH("Saving cmd 0x%x, CSP sstate %d, scan %d",
                        cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, rrc_csp_int_data.curr_scan);
            rrccsp_save_req( cmd_ptr );
            next_substate = RRCCSP_CELL_SEL_WT_ACQ_PENDING;
        }
        else
        {
          WRRC_MSG2_HIGH( "Cmd 0x%x not processed in CSP sstate %d",
                              cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);
        }
        break;


      case RRC_BPLMN_SRCH_TIMER_EXPIRED_IND:
#ifdef FEATURE_DUAL_SIM
        if(rrc_csp_int_data.shld_acq_be_spltd)
        {
          rrccsp_send_drx_timer_expiry_ind();
        }
#endif
        rrc_csp_int_data.bplmn_srch_tmr_expired = TRUE;

        if((rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN)
            || (rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_MANUAL_SCAN))
        {
          /* Set data that needs to be reported to RR */
          rrc_csp_int_data.rrc_rr_plmn_srch_cnf.srch_done   = FALSE;
          rrc_csp_int_data.rrc_rr_plmn_srch_cnf.hplmn_found = FALSE;

          rrccsp_save_req(cmd_ptr);
          next_substate = RRCCSP_CELL_SEL_WT_ACQ_PENDING;
        }
#ifdef FEATURE_LTE_TO_WCDMA
        else if ((rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_CELL_RESELECTION_SCAN) 
                 && (rrc_csp_int_data.interrat_type == RRC_CSP_INTERRAT_LTE_CGI ))
        {
          WRRC_MSG0_ERROR("CGI: This shouldn't happen. Timer expired during ACQ.");
          rrccsp_send_mode_change_req_to_mcm( RRC_MODE_INACTIVE );        
          next_substate                     = RRCCSP_WT_STOP_MODE_CHANGE_CNF;
        }
#endif
        else
        {
          WRRC_MSG1_HIGH("Ignoring BPLMN SrchTmrExp in %d scan", rrc_csp_int_data.curr_scan);
        }
        break;

      case RRC_FREQ_REDIRECT_WAIT_TIMER_EXPIRED_IND:
        WRRC_MSG2_HIGH("Freq redirect wt tmr exprd for freq %d in CSP sstate %d",
                                  rrc_csp_int_data.last_camped_freq, rrc_csp_substate);

        /* Inter frequency redirection scan is in progress */
        if(rrc_csp_int_data.curr_scan == RRC_CSP_INTER_FREQ_REDIRECTION_SCAN)
        {
          next_substate = rrccsp_handle_freq_redirect_wait_timer_expiry(next_substate);
          if(next_substate == RRCCSP_CELL_SEL_WT_ACQ_PENDING)
          {
            rrccsp_save_req(cmd_ptr);
          }
        }
        else
        {
          WRRC_MSG2_ERROR("ERR Wt tmr exprd for freq %d in CSP sstate %d when ifreq-rdrctn not in progress",
                                                 rrc_csp_int_data.last_camped_freq, rrc_csp_substate);
          rrc_csp_int_data.start_acq_on_last_camped_freq = TRUE;
        }
        break;

      case RRC_IRAT_ABORT_IND:
        rrccsp_send_mode_change_req_to_mcm( RRC_MODE_INACTIVE );        

        if(rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_REDIRECTION_SCAN)
        {
          rrc_csp_int_data.rsp_to_rr        = SEND_GTOW_REDIRECTION_ABORT_CNF;
        }
        else
        {
          rrc_csp_int_data.rsp_to_rr        = SEND_GTOW_RESEL_ABORT_CNF;
        }

        next_substate                     = RRCCSP_WT_STOP_MODE_CHANGE_CNF;
        break;

      case RRC_WTOW_BPLMN_DRX_SRCH_TIMER_EXPIRED_IND:
#ifdef FEATURE_DUAL_SIM
        if(rrc_csp_int_data.shld_acq_be_spltd)
        {
          rrccsp_send_drx_timer_expiry_ind();
        }
#endif
        rrc_csp_int_data.bplmn_srch_tmr_expired = TRUE;
  
        /* Check if DRX srch was actualy in progress */
        if((rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
           || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN))
        {
          rrccsp_save_req(cmd_ptr);
          next_substate = RRCCSP_CELL_SEL_WT_ACQ_PENDING;
        }
        /* Can happen if there is a race condition where the timer was stopped
         * but it had already expired. Print an error msg only for testing 
         * purposes.
         */
        else
        {
          WRRC_MSG1_ERROR("WTOW ERR: Ignoring WTOW BPLMN SrchTmrExp in %d scan", rrc_csp_int_data.curr_scan);
        }
        break;

      case RRC_BPLMN_GUARD_SRCH_TIMER_EXPIRED_IND:
        if(rrctmr_get_remaining_time(RRCTMR_BPLMN_GUARD_SRCH_TIMER) == 0)
        {
          rrc_csp_int_data.bplmn_guard_srch_tmr_expired = TRUE;

          if((rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
             || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN))
          {
            rrccsp_save_req(cmd_ptr);
            next_substate = RRCCSP_CELL_SEL_WT_ACQ_PENDING;
          }
          else
          {
            WRRC_MSG1_HIGH("Cleaning BPLMN state. Scan type %d", rrc_csp_int_data.curr_scan);
            rrccsp_cleanup_bplmn_state();
          }
        }  
        else
        {
          WRRC_MSG0_HIGH("WTOW: Race condition hit. Ignoring guard tmr expiry");
        }
        break;

      case RRC_BPLMN_SEARCH_ABORT_REQ:
        if(   (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
           || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN)
           || (rrc_csp_int_data.curr_scan == RRC_CSP_PLMN_LIST_SCAN)
          )
        { 
          rrccsp_save_req(cmd_ptr);
          next_substate = RRCCSP_CELL_SEL_WT_ACQ_PENDING;
        }
        else
        {
          WRRC_MSG1_HIGH("Cleaning BPLMN state. Scan type %d", rrc_csp_int_data.curr_scan);
          rrccsp_cleanup_bplmn_state();
        }
        break;
     
      case RRC_BPLMN_SUSPEND_REQ:
        if((rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
           || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN))
        { 
          if(!rrc_csp_int_data.bplmn_srch_tmr_expired)
          {
             WRRC_MSG0_HIGH("WTOW DRX Srch tmr has not expd. Stop it");
             rrctmr_stop_timer(RRCTMR_WTOW_BPLMN_DRX_SRCH_TIMER);
             rrc_csp_int_data.bplmn_srch_tmr_expired = TRUE;
          }
          rrccsp_save_req(cmd_ptr);
          next_substate = RRCCSP_CELL_SEL_WT_ACQ_PENDING;
        }
        else
        {
          WRRC_MSG1_ERROR("WTOW ERR: BPLMN_SUSPEND_REQ rcvd in st %d when BPLMN srch not in prog",
                                                                 next_substate);
        }
        break;

#ifdef FEATURE_EOOS
      #error code not present
#endif

#ifdef FEATURE_DUAL_SIM
      case RRC_RESET_L1_CNF:
        if(rrc_csp_int_data.csp_waiting_for_wl1_to_release_lock)
        {
          rrc_csp_int_data.csp_waiting_for_wl1_to_release_lock = FALSE;
          if(rrc_csp_int_data.preemption_handling_in_progress)
          {
            rrc_csp_int_data.preemption_handling_in_progress = FALSE;
            next_substate = rrc_csp_rel_lock_and_cont_cell_sel_on_prev_preempted();
          }
          else
          {
            /* If detected cells are present try acq on them first */
            if((rrc_csp_int_data.num_scr_code_det > 0) &&
                (rrc_csp_int_data.curr_acq_count
                  < rrc_csp_int_data.num_scr_code_det))
            {
              if((rrc_csp_int_data.curr_scan == RRC_CSP_CELL_SELECTION_SCAN) ||
                 (rrc_csp_int_data.curr_scan == RRC_CSP_PLMN_LIST_SCAN) ||
                 (rrc_csp_int_data.curr_scan == RRC_CSP_OUT_OF_SERVICE_AREA_SCAN) 
#ifdef FEATURE_WRLF_SYSTEM_SEL
                 || ((rrc_csp_int_data.curr_scan == RRC_CSP_LEAVING_CONN_MODE_SCAN) &&
                   RRC_IS_CONN_MODE_OOS_SRCH_IN_PROGRESS())
#endif
                )
              {
                rrc_csp_int_data.shld_acq_be_spltd = FALSE;
                type_freq_scan = RRC_CSP_ACQ_SCAN;
                next_substate = rrc_csp_wait_for_wrm_lock(&type_freq_scan);
                if(type_freq_scan == RRC_CSP_NO_SCAN)
                {
                  return (next_substate);
                }
              }

              if(type_freq_scan == RRC_CSP_ACQ_SCAN)
              {
                rrccsp_send_acq_req_for_detected_cell();
                next_substate = RRCCSP_CELL_SEL_WT_ACQ;
              }
              /*type_freq_scan can be changed to fine/raw/list scan if WRM wait timer expires*/
              else
              {
                rrc_csp_send_next_freq_to_l1(&rrc_csp_int_data.curr_acq_entry, type_freq_scan);
                next_substate = RRCCSP_CELL_SEL_WT_FREQ_SCAN_CNF;
              }
            }
            else
            {
              next_substate = rrc_csp_continue_cell_selection();
            }
          }
        }
        else
        {
          /*Ignore*/
        }
        break;

      case RRC_CHANNEL_CONFIG_CNF:
        if(rrc_csp_int_data.csp_waiting_for_wl1_to_release_lock)
        {
          rrc_csp_int_data.csp_waiting_for_wl1_to_release_lock = FALSE;
          /* If detected cells are present try acq on them first */
          if((rrc_csp_int_data.num_scr_code_det > 0) &&
             (rrc_csp_int_data.curr_acq_count
               < rrc_csp_int_data.num_scr_code_det))
          {
            if((rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN) ||
               (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN))
            {
              type_freq_scan = RRC_CSP_ACQ_SCAN;
              next_substate = rrc_csp_wait_for_wrm_lock(&type_freq_scan);
              if(type_freq_scan == RRC_CSP_NO_SCAN)
              {
                return (next_substate);
              }
            }
            rrccsp_send_acq_req_for_detected_cell();
          }
          else
          {
            next_substate = rrc_csp_continue_cell_selection();
          }
        }
        break;

#endif
      default:
        WRRC_MSG2_HIGH( "Cmd 0x%x not processed in CSP sstate %d",
                            cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);
        break;
    }
  }
  else if(((uint32)cmd_ptr->cmd_hdr.cmd_id & RRC_RR_CMD_ID_BASE) == RRC_RR_CMD_ID_BASE)
  {
    rr_cmd = ((rrc_rr_cmd_type *)cmd_ptr);     /*lint !e740 */

    switch(rr_cmd->cmd_hdr.cmd_id)
    {
      case RRC_INTERRAT_PLMN_SRCH_ABORT_REQ:
        WRRC_MSG0_HIGH("BPLMN: SRCH_ABORT_REQ Rcvd in SEL_WT_ACQ sstate");

        rrc_csp_int_data.bplmn_srch_cnf = FALSE;
        if((rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN)
           || (rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_MANUAL_SCAN))
        {
          rrccsp_save_req(cmd_ptr);
          next_substate = RRCCSP_CELL_SEL_WT_ACQ_PENDING;
        }
        else
        {
          WRRC_MSG0_ERROR("BPLMN:Ignoring PLMN_SRCH_ABORT_REQ in CELL_SEL_WT_ACQ sstate");
        }
        break;
#ifdef FEATURE_GAN_3G_ROVE_OUT_ONLY
      #error code not present
#endif
      default:
        WRRC_MSG0_HIGH("BPLMN: Cmd not processed in CELL_SEL_WT_ACQ sstate");
        break;
    }
  }

#ifdef FEATURE_LTE_TO_WCDMA
  else if(cmd_ptr->cmd_hdr.cmd_id == RRC_LTE_RRC_CMD)
  {
    switch(cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.msg_hdr.id)
    {
      case WCDMA_RRC_LTE_ABORT_PLMN_SRCH_REQ:
        WRRC_MSG0_HIGH("LTOW:WCDMA_RRC_LTE_ABORT_PLMN_SRCH_REQ Rcvd in SEL_WT_ACQ sstate");
        rrc_csp_int_data.bplmn_srch_cnf = FALSE;
        if((rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_MANUAL_SCAN) ||
           (rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN))
        {
          rrccsp_save_req(cmd_ptr);
          next_substate = RRCCSP_CELL_SEL_WT_ACQ_PENDING;
        }
        else
        {
          WRRC_MSG0_ERROR("LTOW: Ignoring WCDMA_RRC_LTE_ABORT_PLMN_SRCH_REQ");
        }
        break;
      default:
        WRRC_MSG2_HIGH("LTOW: Invalid cmd %x from LTE RRC in CSP substate %d",
            cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.msg_hdr.id,rrc_csp_substate);
        break;
    }
  }
#endif
  return( next_substate );
} /* rrccsp_cell_sel_wait_acq_hdlr */


/* =======================================================================
** Function Definitions for substate: RRCCSP_CELL_SEL_WT_ACQ_PENDING
** ======================================================================= */

/*===========================================================================

FUNCTION        rrccsp_cell_sel_wait_acq_pending_hdlr

DESCRIPTION
                This is a handler for events received in
                RRCCSP_CELL_SEL_WT_ACQ_PENDING substate of the
                Cell Selection Procedure.
                Depending on the event, it further calls a function for
                processing the event in this CSP substate.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_cell_sel_wait_acq_pending_hdlr( rrc_cmd_type *cmd_ptr )
{

  rrc_csp_substate_e_type   next_substate;
  rrc_state_e_type          rrc_state;
  uint32 i;
  
  /* Inter-RAT command */
  rrc_rr_cmd_type *rr_cmd;


  boolean interrat_cmd = FALSE;
#ifdef FEATURE_LTE_TO_WCDMA
  if(cmd_ptr->cmd_hdr.cmd_id == RRC_LTE_RRC_CMD)
  {
    interrat_cmd = TRUE;
  }
#endif

  if((((uint32)cmd_ptr->cmd_hdr.cmd_id & RRC_RR_CMD_ID_BASE) == RRC_RR_CMD_ID_BASE) )
  {
    interrat_cmd = TRUE;
  }

  next_substate = RRCCSP_CELL_SEL_WT_ACQ_PENDING;

#ifdef FEATURE_DUAL_SIM
  if((cmd_ptr->cmd_hdr.cmd_id == RRC_LLC_CMD_CNF) && 
      (cmd_ptr->cmd.rrc_llc_cnf.ll_cnf == RRC_LL_CPHY_ACQ_CNF) &&
       (rrc_csp_int_data.csp_waiting_for_wl1_to_release_lock))
  {
    WRRC_MSG1_HIGH("DSIM: CSP waiting for WL1 to release the lock, Ignore RRC_LL_CPHY_ACQ_CNF. Pending type %d",rrc_csp_int_data.pending_type);
    /*Go ahead and handle pending cell selection initiate request. As LLC might ignore idle request when waiting for stop in WRLF*/
    if(rrc_csp_int_data.pending_type == RRC_CSP_INITIATE_CELL_SEL_PENDING)
    {
      rrc_csp_int_data.csp_waiting_for_wl1_to_release_lock = FALSE;
      rrc_csp_int_data.preemption_handling_in_progress = FALSE;
 
      next_substate = rrccsp_pending_command_handler();
    }
    return next_substate;
  }
#endif
  if(!interrat_cmd)
  {
    switch( cmd_ptr->cmd_hdr.cmd_id )
    {
    case RRC_LLC_CMD_CNF:
      MSG_LOW( "Cmd 0x%x recvd, CSP sstate %d",
        cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
      if(cmd_ptr->cmd.rrc_llc_cnf.ll_cnf == RRC_LL_CPHY_ACQ_CNF)
      {
        if((cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.status) && (rrc_csp_curr_select_data.num_tries_on_dest_freq > 0))
        {
          WRRC_MSG0_HIGH("Reset Number of tries on destnation frequency");
          rrc_csp_curr_select_data.num_tries_on_dest_freq =0;
        }
        if((rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN) || 
          (rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_MANUAL_SCAN) ||
          (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN) || 
          (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN))
        {
          if(cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.status)
          {
            WRRC_MSG2_HIGH("ACQ SUCCEED on freq: %d, scr: %d. Save PSC info to try ACQ again in the next DRX",
            cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.freq, cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.scr_code);

            rrc_csp_int_data.bplmn_acq_succ_scr_code = cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.scr_code;
            rrc_csp_int_data.bplmn_acq_succ_freq = cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.freq;
            rrc_csp_int_data.bplmn_acq_succ_pn_pos = cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.pn_pos;

            /*This is the case where timer expired on first ACQ attempt*/
            if((rrc_csp_int_data.acq_mode == L1_WCDMA_ACQ_DET_LIST)&&(rrc_csp_int_data.acq_type == L1_WCDMA_FREQ_ONLY))
            {
              WRRC_MSG0_HIGH("Saving BPLMN Acq detected list");
              if(cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.num_scr_code_det <= L1_WCDMA_ACQ_DET_LIST_MAX)
              {
                /* Store the number of scrambling codes received in ACQ_CNF */
                rrc_csp_int_data.bplmn_acq_succ_scr_code_det =
                cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.num_scr_code_det;
              }
              else
              {
                WRRC_MSG1_ERROR("Invalid num_scr_code_det %d",
                cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.num_scr_code_det);
                /* Filling only L1_WCDMA_ACQ_DET_LIST_MAX number of entries into the detected list */
                rrc_csp_int_data.bplmn_acq_succ_scr_code_det = L1_WCDMA_ACQ_DET_LIST_MAX;
              }

              /* Store the scrambling codes received in ACQ_CNF into the internal database */
              for(i=0; i< rrc_csp_int_data.bplmn_acq_succ_scr_code_det; i++)
              {
                rrc_csp_int_data.scr_code_det[i] = cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.scr_code_det[i];
                WRRC_MSG2_HIGH("Scr code %d, PN Pos %d",rrc_csp_int_data.scr_code_det[i].scr_code,
                                                     rrc_csp_int_data.scr_code_det[i].pn_pos);
              }
              rrc_csp_int_data.bplmn_acq_succ_curr_acq_count = 0;

#ifdef FEATURE_FEMTO_CSG
              if(rrccsp_asf_actively_in_prog())
              {
                rrc_csp_int_data.curr_acq_entry.freq = cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.freq;
                rrc_csp_int_data.curr_acq_entry.scr_code = cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.scr_code;
                rrccsp_prune_acqdb_after_acq(TRUE);
              }
#endif
            }
            rrc_csp_int_data.bplmn_acq_status = TRUE;
          }
          else
          {
            WRRC_MSG0_HIGH("BPLMN CMD_CNF in SEL_WT_ACQ_PENDING. Acq Failed");
            rrc_csp_int_data.bplmn_acq_status = FALSE;

#ifdef FEATURE_DUAL_SIM
            /*Decrement frequncy index for BPLMN searches. Do we want to decrement for next best cell as well?*/
            if((cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.fail_type == WL1_FAILED_NO_WRM_LOCK)&&
               ((rrc_csp_int_data.pending_type == RRC_CSP_WTOW_BPLMN_DRX_SRCH_TIMER_PENDING)||
                (rrc_csp_int_data.pending_type == RRC_BPLMN_SRCH_TIMER_PENDING)))
            {
              rrc_csp_bplmn_update_select_data_for_reattempt();
            }
#endif

#ifdef FEATURE_FEMTO_CSG
            if((rrc_csp_int_data.acq_mode == L1_WCDMA_ACQ_DET_LIST)&&(rrc_csp_int_data.acq_type == L1_WCDMA_FREQ_ONLY))
            {
              if(rrccsp_asf_actively_in_prog())
              {
                rrccsp_prune_acqdb_after_acq(FALSE);
              }
            }
#endif
          }
        }
        else if(rrc_csp_int_data.curr_scan == RRC_CSP_INTER_FREQ_REDIRECTION_SCAN)
        {
          if(cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.freq != rrc_csp_int_data.curr_acq_entry.freq)
          {
            WRRC_MSG2_ERROR("ERR Freq %d sent to L1, freq %d acquired by L1",
              rrc_csp_int_data.curr_acq_entry.freq, cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.freq);
            
            /* Update the frequency anyway */
            rrc_csp_int_data.curr_acq_entry.freq = cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.freq;
          }
        }
#ifdef FEATURE_EOOS
        #error code not present
#endif
        next_substate = rrccsp_pending_command_handler();
      }
      else
      {
        WRRC_MSG2_HIGH("Unexpected L1 cmd 0x%x, CSP sstate %d",
          cmd_ptr->cmd.rrc_llc_cnf.ll_cnf, rrc_csp_substate);
      }
      break;
      
    case RRC_SERVICE_REQ:
      rrc_state = rrc_get_state();
      if(rrc_state != RRC_STATE_DISCONNECTED)
      {
        WRRC_MSG1_ERROR("Service req in RRC state %d",rrc_state);
      }
      
      MSG_MED("Cmd 0x%x recvd, CSP sstate %d",
        cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
      
      if((rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
        || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN))
      {
        rrccsp_prioritize_pending_commands(cmd_ptr);
      }
      else
      {
        rrccsp_save_req(cmd_ptr);
      }
      break;
      
    case RRC_PLMN_LIST_REQ:
      MSG_MED("Cmd 0x%x recvd, CSP sstate %d",
        cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
      
      if(rrccsp_plmn_list_req_is_valid(&(cmd_ptr->cmd.plmn_list_req)))
      {
        if((rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
          || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN))
        {
          rrccsp_prioritize_pending_commands(cmd_ptr);
        }
        else
        {
          rrccsp_save_req( cmd_ptr );
        }
      }
      break;
      
    case RRC_BPLMN_SRCH_TIMER_EXPIRED_IND:
      if(!rrc_csp_int_data.bplmn_srch_tmr_expired && rrc_csp_int_data.bplmn_srch_cnf)
      {
        rrc_csp_process_pending_bplmn_srch_timer_expiry();
      }
      
      rrc_csp_int_data.bplmn_srch_tmr_expired = TRUE;
      /* Set data that needs to be reported to RR */
      rrc_csp_int_data.rrc_rr_plmn_srch_cnf.srch_done   = FALSE;
      rrc_csp_int_data.rrc_rr_plmn_srch_cnf.hplmn_found = FALSE;
      
      next_substate = RRCCSP_CELL_SEL_WT_ACQ_PENDING;
      break;
      
    case RRC_FREQ_REDIRECT_WAIT_TIMER_EXPIRED_IND:
      WRRC_MSG2_HIGH("Freq redirect wt tmr exprd for freq %d in pending CSP sstate %d",
        rrc_csp_int_data.last_camped_freq, rrc_csp_substate);
      
        /* In pending substate we should not care about wait timer expiry. Just to be on the
        * safe side, the variable below is set appropriately on wait timer expiry.
      */
      rrc_csp_int_data.start_acq_on_last_camped_freq = TRUE;
      break;

    case RRC_INITIATE_CELL_SELECTION_IND:
      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );

      /* If the reason for initiating cell selection is TRANSITION_TO_DISCONNECTED
       * scan is OOS in Connected Mode then process the command
       */
      if(cmd_ptr->cmd.initiate_cell_sel_ind.cause == RRC_TRANSITION_TO_DISCONNECTED)
      {    
          MSG_HIGH("Saving cmd 0x%x, CSP sstate %d, scan %d",
                      cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, rrc_csp_int_data.curr_scan);
          rrccsp_save_req( cmd_ptr );
          next_substate = RRCCSP_CELL_SEL_WT_ACQ_PENDING;
      }
      else
      {
        WRRC_MSG2_HIGH( "Cmd 0x%x not processed in CSP sstate %d",
                            cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);
      }
      break;
    case RRC_WTOW_BPLMN_DRX_SRCH_TIMER_EXPIRED_IND:
      rrc_csp_int_data.bplmn_srch_tmr_expired = TRUE;
      
      if((rrc_csp_int_data.curr_scan != RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
        && (rrc_csp_int_data.curr_scan != RRC_CSP_WTOW_BPLMN_MANUAL_SCAN))
      {
        WRRC_MSG1_ERROR("WTOW ERR: Ignoring WTOW BPLMN SrchTmrExp in %d scan", rrc_csp_int_data.curr_scan);
      }
      break;
      
    case RRC_BPLMN_GUARD_SRCH_TIMER_EXPIRED_IND:
      rrc_csp_int_data.bplmn_guard_srch_tmr_expired = TRUE;
      
      if((rrc_csp_int_data.curr_scan != RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
        && (rrc_csp_int_data.curr_scan != RRC_CSP_WTOW_BPLMN_MANUAL_SCAN))
      {
        WRRC_MSG1_HIGH("Cleaning BPLMN state. Scan type %d", rrc_csp_int_data.curr_scan);
        rrccsp_cleanup_bplmn_state();
      }
      break; 
      
    case RRC_BPLMN_SEARCH_ABORT_REQ:
      if((rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
        || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN))
      { 
        rrccsp_cleanup_bplmn_state();
      }
      else
      {
        WRRC_MSG1_ERROR("WTOW ERR: BPLMN_SUSPEND_REQ rcvd in st %d when BPLMN srch not in prog",
          next_substate);
      }
      break;
      
    case RRC_BPLMN_SUSPEND_REQ:
      if((rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
        || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN))
      { 
        rrccsp_prioritize_pending_commands(cmd_ptr);
        if(!rrc_csp_int_data.bplmn_srch_tmr_expired)
        {
           WRRC_MSG0_HIGH("WTOW DRX Srch tmr has not expd. Stop it");
           rrctmr_stop_timer(RRCTMR_WTOW_BPLMN_DRX_SRCH_TIMER);
           rrc_csp_int_data.bplmn_srch_tmr_expired = TRUE;
        }
      }
      else
      {
        WRRC_MSG1_ERROR("WTOW ERR: BPLMN_SUSPEND_REQ rcvd in st %d when BPLMN srch not in prog",
          next_substate);
      }
      break;
      
      
#ifdef FEATURE_DUAL_SIM
    case RRC_RESET_L1_CNF:
    case RRC_CHANNEL_CONFIG_CNF:
      if(rrc_csp_int_data.csp_waiting_for_wl1_to_release_lock)
      {
        rrc_csp_int_data.csp_waiting_for_wl1_to_release_lock = FALSE;
        if(rrc_csp_int_data.preemption_handling_in_progress)
        {
          rrc_csp_int_data.preemption_handling_in_progress = FALSE;
        }
        /*Release the lock*/
        rrc_release_lock();
        next_substate = rrccsp_pending_command_handler();
      }
      else
      {
        /*Ignore*/
      }
      break;
#endif
      
    default:
      WRRC_MSG2_HIGH( "Cmd 0x%x not processed in CSP sstate %d",
        cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);
      break;
    }
  }
  else if(((uint32)cmd_ptr->cmd_hdr.cmd_id & RRC_RR_CMD_ID_BASE) == RRC_RR_CMD_ID_BASE)
  {
    rr_cmd = ((rrc_rr_cmd_type *)cmd_ptr);     /*lint !e740 */
    
    switch(rr_cmd->cmd_hdr.cmd_id)
    {
    case RRC_INTERRAT_PLMN_SRCH_ABORT_REQ:
      WRRC_MSG0_HIGH("BPLMN: SRCH_ABORT_REQ Rcvd in SEL_WT_ACQ_PENDING sstate");
      rrc_csp_int_data.bplmn_srch_cnf = FALSE;
      
      next_substate = RRCCSP_CELL_SEL_WT_ACQ_PENDING;
      break;
      
    default:
      WRRC_MSG0_HIGH("BPLMN: Cmd not processed in SEL_WT_ACQ_PENDING");
      break;
    }
  }

#ifdef FEATURE_LTE_TO_WCDMA
  else if(cmd_ptr->cmd_hdr.cmd_id == RRC_LTE_RRC_CMD)
  {
    switch(cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.msg_hdr.id)
    {
      case WCDMA_RRC_LTE_ABORT_PLMN_SRCH_REQ:
        WRRC_MSG0_HIGH("LTOW:WCDMA_RRC_LTE_ABORT_PLMN_SRCH_REQ Rcvd in SEL_WT_ACQ_PENDING sstate");
        rrc_csp_int_data.bplmn_srch_cnf = FALSE;
        next_substate = RRCCSP_CELL_SEL_WT_ACQ_PENDING;
        break;

      default:
        WRRC_MSG2_HIGH("LTOW: Invalid cmd %x from LTE RRC in CSP substate %d",
            cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.msg_hdr.id,rrc_csp_substate);
        break;
    }
  }
#endif
  return( next_substate );
} /* rrccsp_cell_sel_wait_acq_pending_hdlr */

/* =======================================================================
**      Function Definitions for substate: RRCCSP_CELL_SEL_WT_FREQ_SCAN_CNF
** ======================================================================= */


/*===========================================================================

FUNCTION        RRCCSP_CELL_SEL_WAIT_FREQ_SCAN_CNF_RECVD

DESCRIPTION     This function handles the Frequency Scan Confirm event from
                L1 when CSP has been waiting on that event.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_cell_sel_wait_freq_scan_cnf_recvd( rrc_cmd_type *cmd_ptr )
{
  rrc_csp_substate_e_type  next_substate;

  next_substate = RRCCSP_CELL_SEL_WT_FREQ_SCAN_CNF;

#ifdef FEATURE_DUAL_SIM
    if(cmd_ptr->cmd.rrc_llc_cnf.cnf.freq_scan_cnf.fail_type == WL1_FAILED_NO_WRM_LOCK)
    {
      WRRC_MSG0_HIGH("DSIM: Freq Scan req failed at L1 because of No Resourece");

      /* Set oos_due_to_no_resource flag so that NAS is updated with NO SERVICE with cause
        NO RESOURCE*/
      rrc_set_oos_due_to_no_resource_flag();

      /*
        For Phase I, Release channels and go to IDLE
        >The cases of leaving connected mode, oos in idle scan
        For Phase II, Need to take care of interRAT and others, specific to Scans
        >For interRAT before ACQ, RRC will acquire the lock, so L1 shouldn't fail with No Resource cause
        >For WTOW BPLMN also RRC will acquire the lock
      */
      if(rrc_get_state() == RRC_STATE_DISCONNECTED)
      {
        /* Force RCE to go to INITIAL, taking care of ongoing timers
         * and required response to MM, depending on RCE substate and
         */
        rrcrce_force_initialize(FALSE);
        return (rrccsp_rel_chls_and_go_to_idle());
      }
      else
      {
        ERR_FATAL("DSIM:Freq CNF failure with No Resource from L1",0,0,0);
      }
    }
#endif

  /* Update data from the received CPHY_FREQ_SCAN_CNF cmd */
  if(rrc_csp_update_freq_scan_entry(&cmd_ptr->cmd.rrc_llc_cnf.cnf.freq_scan_cnf)
      == SUCCESS
    )
  {
    next_substate = rrc_csp_continue_cell_selection();
  } /* Incoming frequency scan confirm had valid data */
  else
  {
    ERR_FATAL("Freq Scan Cnf recvd with incorrect data", 0, 0, 0);
  }
  return( next_substate );
} /* rrccsp_cell_sel_wait_freq_scan_cnf_recvd */


/*===========================================================================

FUNCTION        RRCCSP_CELL_SEL_WT_FREQ_SCAN_CNF_HDLR

DESCRIPTION
                This is a handler for events received in
                RRCCSP_CELL_SEL_WT_FREQ_SCAN_CNF substate of the Cell
                Selection Procedure. Depending on the event, it further
                calls a function for
                processing the event in this CSP substate.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_cell_sel_wait_freq_scan_cnf_hdlr( rrc_cmd_type *cmd_ptr )
{

  rrc_csp_substate_e_type   next_substate;
  rrc_state_e_type           rrc_state = rrc_get_state();

  /* Inter-RAT command */
  rrc_rr_cmd_type *rr_cmd;

  boolean interrat_cmd = FALSE;
#ifdef FEATURE_LTE_TO_WCDMA
  if(cmd_ptr->cmd_hdr.cmd_id == RRC_LTE_RRC_CMD)
  {
    interrat_cmd = TRUE;
  }
#endif

  if((((uint32)cmd_ptr->cmd_hdr.cmd_id & RRC_RR_CMD_ID_BASE) == RRC_RR_CMD_ID_BASE) )
  {
    interrat_cmd = TRUE;
  }

  next_substate = RRCCSP_CELL_SEL_WT_FREQ_SCAN_CNF;

  if(!interrat_cmd)
  {
    switch( cmd_ptr->cmd_hdr.cmd_id )
    {
      case RRC_LLC_CMD_CNF:
        MSG_LOW( "Cmd 0x%x recvd, CSP sstate %d",
                             cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
        switch(cmd_ptr->cmd.rrc_llc_cnf.ll_cnf)
        {
          case RRC_LL_CPHY_FREQ_SCAN_CNF:
            MSG_MED("L1 cmd 0x%x recvd, CSP sstate %d",
                           cmd_ptr->cmd.rrc_llc_cnf.ll_cnf, rrc_csp_substate, 0);
            next_substate = rrccsp_cell_sel_wait_freq_scan_cnf_recvd( cmd_ptr );
            break;

          default:
            WRRC_MSG2_HIGH("Unexpected L1 cmd 0x%x, CSP sstate %d",
                           cmd_ptr->cmd.rrc_llc_cnf.ll_cnf, rrc_csp_substate);
            break;
        }
        break;

      case RRC_SERVICE_REQ:
        rrc_state = rrc_get_state();
        if(rrc_state != RRC_STATE_DISCONNECTED)
        {
          WRRC_MSG1_ERROR("Service req in RRC state %d",rrc_state);
        }

        MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                           cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
        rrccsp_save_req( cmd_ptr );
        next_substate = RRCCSP_CELL_SEL_WT_FREQ_SCAN_CNF_PENDING;
        break;

      case RRC_DCH_FACH_CELL_SELECTION_TIMER_EXPIRED_IND:
        if(rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_CELL_FACH_SCAN)
        {
          rrccsp_save_req(cmd_ptr);
          next_substate = RRCCSP_CELL_SEL_WT_FREQ_SCAN_CNF_PENDING;
        }
        else
        {
          WRRC_MSG1_HIGH("Ignoring Cell Sel Tmr Exp in %d scan", rrc_csp_int_data.curr_scan);
        }
        break;

      case RRC_DCH_PCH_CELL_SELECTION_TIMER_EXPIRED_IND:
        if((rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_CELL_PCH_SCAN) ||
                (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_URA_PCH_SCAN))
        {
          rrccsp_save_req(cmd_ptr);
          next_substate = RRCCSP_CELL_SEL_WT_FREQ_SCAN_CNF_PENDING;
        }
        else
        {
          WRRC_MSG1_HIGH("Ignoring Cell Sel Tmr Exp in %d scan", rrc_csp_int_data.curr_scan);
        }
        break;

      case RRC_FACH_TO_FACH_PCH_CELL_SELECTION_TIMER_EXPIRED_IND:
        if((rrc_csp_int_data.curr_scan == RRC_CSP_CELL_FACH_TO_CELL_FACH_SCAN) ||
           (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_FACH_TO_CELL_PCH_SCAN) ||
           (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_FACH_TO_URA_PCH_SCAN))
        {
          rrccsp_save_req(cmd_ptr);
          next_substate = RRCCSP_CELL_SEL_WT_FREQ_SCAN_CNF_PENDING;
        }
        else
        {
          WRRC_MSG1_HIGH("Ignoring Cell Sel Tmr Exp in %d scan", rrc_csp_int_data.curr_scan);
        }
        break;

      case RRC_GTOW_REDIRECTION_WAIT_TIMER_EXPIRED_IND:
        WRRC_MSG0_HIGH("GtoW Redirection: Timer expired");
        rrc_csp_int_data.gtow_redirection_timer_expired = TRUE;
        break;

      case RRC_IRAT_ABORT_IND:
        rrccsp_send_mode_change_req_to_mcm( RRC_MODE_INACTIVE );

        rrc_csp_int_data.rsp_to_rr        = SEND_GTOW_REDIRECTION_ABORT_CNF;
        next_substate                     = RRCCSP_WT_STOP_MODE_CHANGE_CNF;
        break;

      case RRC_PLMN_LIST_REQ:
        MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                           cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );    
        if(rrccsp_plmn_list_req_is_valid(&(cmd_ptr->cmd.plmn_list_req)))
        {
          /* If Scan Type is Leaving Connected Mode Scan then do Manual PLMN
           * Search in background (after UE camps).
           */
          if(rrc_csp_int_data.curr_scan == RRC_CSP_LEAVING_CONN_MODE_SCAN)
          {
            WRRC_MSG0_HIGH("WTOW: LeavingConnModeScan. Hold Manual Srch req until UE camps");

            /* The call to the function below should always return TRUE in this case.
             * If FALSE is returned then it is an error condition. Abort the search.
             */
            if(!rrccsp_handle_plmn_list_req_in_bgnd(&(cmd_ptr->cmd.plmn_list_req)))
            {
              rrc_csp_send_mm_plmn_list_cnf_as_aborted(cmd_ptr->cmd.plmn_list_req.trans_id);
            }
          }
          /* Since scan type is not leaving connected mode, hence do the search in foreground */
          else
          {
            rrccsp_save_req( cmd_ptr );
            next_substate = RRCCSP_CELL_SEL_WT_FREQ_SCAN_CNF_PENDING;
          }
        }
        break;
    
      case RRC_STATE_CHANGE_IND:
        MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                           cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
        if(((rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_CELL_FACH_SCAN) ||
           (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_CELL_PCH_SCAN) ||
           (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_URA_PCH_SCAN) ||
           (rrc_csp_int_data.curr_scan == RRC_CSP_OUT_OF_SERVICE_AREA_SCAN) ||
           (rrc_csp_int_data.curr_scan == RRC_CSP_OUT_OF_SERVICE_AREA_IN_CONNECTING_STATE_SCAN) ||
           (rrc_csp_int_data.curr_scan == RRC_CSP_INTER_FREQ_REDIRECTION_SCAN) ||
           (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN) ||
           (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN)) &&
            (cmd_ptr->cmd.state_change_ind.new_state == RRC_STATE_DISCONNECTED))
        {
          rrccsp_save_req( cmd_ptr );
          next_substate = RRCCSP_CELL_SEL_WT_FREQ_SCAN_CNF_PENDING;
        }
        else
        {
          WRRC_MSG1_HIGH("Ignoring state change, curr scan %d",rrc_csp_int_data.curr_scan);
        }
        break;

      case RRC_INITIATE_CELL_SELECTION_IND:
        MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                           cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );

        /* If the procedure is CU and reason for initiating cell selection is
         * TRANSITION_TO_DISCONNECTED, process the command
         */
        if(cmd_ptr->cmd.initiate_cell_sel_ind.cause == RRC_TRANSITION_TO_DISCONNECTED)
        {
          MSG_HIGH("Saving cmd 0x%x, CSP sstate %d, scan %d",
                      cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, rrc_csp_int_data.curr_scan);
          rrccsp_save_req( cmd_ptr );
          next_substate = RRCCSP_CELL_SEL_WT_FREQ_SCAN_CNF_PENDING;

        }
        else
        {
          WRRC_MSG2_HIGH( "Cmd 0x%x not processed in CSP sstate %d",
                              cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);
        }
        break;
      case RRC_BPLMN_SRCH_TIMER_EXPIRED_IND:
        rrc_csp_int_data.bplmn_srch_tmr_expired = TRUE;

        if((rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN)
            || (rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_MANUAL_SCAN))
        {
          /* Set data that needs to be reported to RR */
          rrc_csp_int_data.rrc_rr_plmn_srch_cnf.srch_done   = FALSE;
          rrc_csp_int_data.rrc_rr_plmn_srch_cnf.hplmn_found = FALSE;

          rrccsp_save_req(cmd_ptr);
          next_substate = RRCCSP_CELL_SEL_WT_FREQ_SCAN_CNF_PENDING;
        }
        else
        {
          WRRC_MSG0_HIGH("Ignoring BPLMN SrchTmrExp in WT_FREQ_SCAN_CNF");
        }
        break;
      case RRC_FREQ_REDIRECT_WAIT_TIMER_EXPIRED_IND:
        WRRC_MSG2_HIGH("Freq redirect wt tmr exprd for freq %d in CSP sstate %d",
                                  rrc_csp_int_data.last_camped_freq, rrc_csp_substate);

        /* Inter frequency redirection scan is in progress */
        if(rrc_csp_int_data.curr_scan == RRC_CSP_INTER_FREQ_REDIRECTION_SCAN)
        {
          /* Timer expired for last camped frequency */
          next_substate = rrccsp_handle_freq_redirect_wait_timer_expiry(next_substate);
          if(next_substate == RRCCSP_CELL_SEL_WT_FREQ_SCAN_CNF_PENDING)
          {
            rrccsp_save_req(cmd_ptr);
          }
        }
        else
        {
          WRRC_MSG2_ERROR("ERR Wt tmr exprd for freq %d in CSP sstate %d when ifreq-rdrctn not in progress",
                                                 rrc_csp_int_data.last_camped_freq, rrc_csp_substate);
          rrc_csp_int_data.start_acq_on_last_camped_freq = TRUE;
        }
        break;
      case RRC_WTOW_BPLMN_DRX_SRCH_TIMER_EXPIRED_IND:
        rrc_csp_int_data.bplmn_srch_tmr_expired = TRUE;
  
        /* Check if DRX srch was actualy in progress */
        if((rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
           || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN))
        {
          rrccsp_save_req(cmd_ptr);
          next_substate = RRCCSP_CELL_SEL_WT_FREQ_SCAN_CNF_PENDING;
        }
        /* Can happen if there is a race condition where the timer was stopped
         * but it had already expired. Print an error msg only for testing 
         * purposes.
         */
        else
        {
          WRRC_MSG1_ERROR("WTOW ERR: Ignoring WTOW BPLMN SrchTmrExp in %d scan", rrc_csp_int_data.curr_scan);
        }
        break;

      case RRC_BPLMN_GUARD_SRCH_TIMER_EXPIRED_IND:
        if(rrctmr_get_remaining_time(RRCTMR_BPLMN_GUARD_SRCH_TIMER) == 0)
        {
          rrc_csp_int_data.bplmn_guard_srch_tmr_expired = TRUE;

          if((rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
             || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN))
          {
            rrccsp_save_req(cmd_ptr);
            next_substate = RRCCSP_CELL_SEL_WT_FREQ_SCAN_CNF_PENDING;
          }
          else
          {
            WRRC_MSG1_HIGH("Cleaning BPLMN state. Scan type %d", rrc_csp_int_data.curr_scan);
            rrccsp_cleanup_bplmn_state();
          }
        }  
        else
        {
          WRRC_MSG0_HIGH("WTOW: Race condition hit. Ignoring guard tmr expiry");
        }
        break;

       case RRC_BPLMN_SEARCH_ABORT_REQ:
        if(   (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
           || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN)
           || (rrc_csp_int_data.curr_scan == RRC_CSP_PLMN_LIST_SCAN)
          )
        { 
          rrccsp_save_req(cmd_ptr);
          next_substate = RRCCSP_CELL_SEL_WT_FREQ_SCAN_CNF_PENDING;
        }
        else
        {
          WRRC_MSG1_HIGH("Cleaning BPLMN state. Scan type %d", rrc_csp_int_data.curr_scan);
          rrccsp_cleanup_bplmn_state();
        }
        break;

      case RRC_BPLMN_SUSPEND_REQ:
        if((rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
           || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN))
        { 
          rrccsp_save_req(cmd_ptr);
          next_substate = RRCCSP_CELL_SEL_WT_FREQ_SCAN_CNF_PENDING;
        }
        else
        {
          WRRC_MSG1_ERROR("WTOW ERR: BPLMN_SUSPEND_REQ rcvd in CSP sst %d when BPLMN srch not in prog",
                                                                 next_substate);
        }
        break;

#ifdef FEATURE_EOOS
      #error code not present
#endif

      default:
        WRRC_MSG2_HIGH( "Cmd 0x%x not processed in CSP sstate %d",
                             cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);
        break;
    }
  }
  else if(((uint32)cmd_ptr->cmd_hdr.cmd_id & RRC_RR_CMD_ID_BASE) == RRC_RR_CMD_ID_BASE)
  {
    rr_cmd = ((rrc_rr_cmd_type *)cmd_ptr);     /*lint !e740 */

    switch(rr_cmd->cmd_hdr.cmd_id)
    {
      case RRC_INTERRAT_PLMN_SRCH_ABORT_REQ:
        WRRC_MSG0_HIGH("BPLMN:PLMN_SRCH_ABORT_REQ rcvd in WT_FREQ_SCAN_CNF substate");
        rrc_csp_int_data.bplmn_srch_cnf = FALSE;

        if((rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN)
           || (rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_MANUAL_SCAN))
        {
          rrccsp_save_req(cmd_ptr);
          next_substate = RRCCSP_CELL_SEL_WT_FREQ_SCAN_CNF_PENDING;
        }
        else
        {
          WRRC_MSG0_HIGH("BPLMN:Ignoring SRCH_ABORT_REQ in WT_FREQ_SCAN_CNF substate");
        }
        break;

      default:
        WRRC_MSG0_HIGH("BPLMN: Cmd not processed in WT_FREQ_SCAN_CNF sstate");
        break;
    }
  }


#ifdef FEATURE_LTE_TO_WCDMA
  else if(cmd_ptr->cmd_hdr.cmd_id == RRC_LTE_RRC_CMD)
  {
    switch(cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.msg_hdr.id)
    {
      case WCDMA_RRC_LTE_ABORT_PLMN_SRCH_REQ:
        WRRC_MSG0_HIGH("LTOW:WCDMA_RRC_LTE_ABORT_PLMN_SRCH_REQ Rcvd in WT_FREQ_SCAN_CNF sstate");
        rrc_csp_int_data.bplmn_srch_cnf = FALSE;
        if((rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN)
           || (rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_MANUAL_SCAN))
        {
          rrccsp_save_req(cmd_ptr);
          next_substate = RRCCSP_CELL_SEL_WT_FREQ_SCAN_CNF_PENDING;
        }
        else
        {
          WRRC_MSG0_HIGH("BPLMN:Ignoring SRCH_ABORT_REQ in WT_FREQ_SCAN_CNF substate");
        }
        break;
      default:
        WRRC_MSG2_HIGH("LTOW: Invalid cmd %x from LTE RRC in CSP substate %d",
            cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.msg_hdr.id,rrc_csp_substate);
        break;
    }
  }
#endif

  return( next_substate );

} /* rrccsp_cell_sel_wait_freq_scan_cnf_hdlr */
/*===========================================================================

FUNCTION        rrccsp_reattempt_freq_scan

DESCRIPTION
                This function resets the csp freq scan variables such that RRC
                re-attempts freq scan on the same frequency in next DRX.

DEPENDENCIES
                None

RETURN VALUE
                None

SIDE EFFECTS
                None

===========================================================================*/
static void rrccsp_reattempt_freq_scan(void)
{
  if(rrc_csp_curr_select_data.scan_info.type_freq_scan == RRC_CSP_RAW_SCAN)
  {
    WRRC_MSG0_HIGH("BPLMN/WTOW TmrExp. Try Raw Freq Again.");
    rrc_csp_curr_select_data.scan_info.type_freq_scan = RRC_CSP_NO_SCAN;
  }
  else if(rrc_csp_curr_select_data.scan_info.type_freq_scan == RRC_CSP_FINE_SCAN)
  {
    WRRC_MSG0_HIGH("BPLMN/WTOW TmrExp. Try Fine Freq Again.");
    rrc_csp_curr_select_data.scan_info.fine_scan_completed = TRUE;
    --rrc_csp_curr_select_data.scan_info.raw_scan.curr_freq_index;
  }
  else if(rrc_csp_curr_select_data.scan_info.type_freq_scan == RRC_CSP_ADDL_CHLS_SCAN)
  {
    WRRC_MSG0_HIGH("BPLMN/WTOW TmrExp. Try Addl Chnl Scan again. Reset freq scan type to NO_SCAN");
    rrc_csp_curr_select_data.scan_info.type_freq_scan     = RRC_CSP_NO_SCAN;
    rrc_csp_curr_select_data.addl_chls_scan_needed        = TRUE;
  }
}
/* =======================================================================
** Function Definitions for substate:
    RRCCSP_CELL_SEL_WT_FREQ_SCAN_CNF_PENDING
** ======================================================================= */

/*===========================================================================

FUNCTION        rrccsp_cell_sel_wait_freq_scan_cnf_pending_hdlr

DESCRIPTION
                This is a handler for events received in
                RRCCSP_CELL_SEL_WT_ACQ_PENDING substate of the
                Cell Selection Procedure.
                Depending on the event, it further calls a function for
                processing the event in this CSP substate.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_cell_sel_wait_freq_scan_cnf_pending_hdlr( rrc_cmd_type *cmd_ptr )
{

  rrc_csp_substate_e_type   next_substate;
  rrc_state_e_type          rrc_state;

  /* Inter-RAT command */
  rrc_rr_cmd_type *rr_cmd;

  boolean interrat_cmd = FALSE;
#ifdef FEATURE_LTE_TO_WCDMA
  if(cmd_ptr->cmd_hdr.cmd_id == RRC_LTE_RRC_CMD)
  {
    interrat_cmd = TRUE;
  }
#endif

  if((((uint32)cmd_ptr->cmd_hdr.cmd_id & RRC_RR_CMD_ID_BASE) == RRC_RR_CMD_ID_BASE) )
  {
    interrat_cmd = TRUE;
  }

  next_substate = RRCCSP_CELL_SEL_WT_FREQ_SCAN_CNF_PENDING;

  if(!interrat_cmd)
  {
    switch( cmd_ptr->cmd_hdr.cmd_id )
    {
      case RRC_LLC_CMD_CNF:
        MSG_LOW( "Cmd 0x%x recvd, CSP sstate %d",
                             cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
        if(cmd_ptr->cmd.rrc_llc_cnf.ll_cnf == RRC_LL_CPHY_FREQ_SCAN_CNF)
        {
          WRRC_MSG1_HIGH("Num freq in FreqScanCnf %d", cmd_ptr->cmd.rrc_llc_cnf.cnf.freq_scan_cnf.num_freq);
          if((rrc_csp_int_data.pending_type == RRC_BPLMN_SRCH_TIMER_PENDING) ||
             (rrc_csp_int_data.pending_type == RRC_CSP_WTOW_BPLMN_DRX_SRCH_TIMER_PENDING))
          {
#ifdef FEATURE_DUAL_SIM
            if(cmd_ptr->cmd.rrc_llc_cnf.cnf.freq_scan_cnf.fail_type == WL1_FAILED_NO_WRM_LOCK)
            {
              rrccsp_reattempt_freq_scan();
            }
            else 
#endif
            {
              /*update the freq scan results to avoid another freq scan during next DRX cycle */
              if(rrc_csp_update_freq_scan_entry(&cmd_ptr->cmd.rrc_llc_cnf.cnf.freq_scan_cnf)== FAILURE)
              {
                ERR_FATAL("Freq Scan Cnf recvd with incorrect data", 0, 0, 0);
              }
            }
          }
          next_substate = rrccsp_pending_command_handler();
        }
        else
        {
          WRRC_MSG2_HIGH("Unexpected L1 cmd 0x%x, CSP sstate %d",
                 cmd_ptr->cmd.rrc_llc_cnf.ll_cnf, rrc_csp_substate);
        }
        break;

      case RRC_SERVICE_REQ:
        rrc_state = rrc_get_state();
        if(rrc_state != RRC_STATE_DISCONNECTED)
        {
          WRRC_MSG1_ERROR("Service req in RRC state %d",rrc_state);
        }

        MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                           cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );

        if((rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
           || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN))
        {
          rrccsp_prioritize_pending_commands(cmd_ptr);
        }
        else
        {
          rrccsp_save_req(cmd_ptr);
        }
        next_substate = RRCCSP_CELL_SEL_WT_FREQ_SCAN_CNF_PENDING;
        break;

      case RRC_PLMN_LIST_REQ:
        MSG_MED("Cmd 0x%x recvd, CSP sstate %d",
                           cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
  
        if(rrccsp_plmn_list_req_is_valid(&(cmd_ptr->cmd.plmn_list_req)))
        {
          if((rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
             || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN))
          {
            rrccsp_prioritize_pending_commands(cmd_ptr);
          }
          else
          {
            rrccsp_save_req( cmd_ptr );
          }
        }
        break;

      case RRC_INITIATE_CELL_SELECTION_IND:
        MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                           cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );

        /* If the reason for initiating cell selection is TRANSITION_TO_DISCONNECTED
         * scan is OOS in Connected Mode then process the command
         */
        if(cmd_ptr->cmd.initiate_cell_sel_ind.cause == RRC_TRANSITION_TO_DISCONNECTED)
        {
            MSG_HIGH("Saving cmd 0x%x, CSP sstate %d, scan %d",
                        cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, rrc_csp_int_data.curr_scan);
            rrccsp_save_req( cmd_ptr );
            next_substate = RRCCSP_CELL_SEL_WT_FREQ_SCAN_CNF_PENDING;
        }
        else
        {
          WRRC_MSG2_HIGH( "Cmd 0x%x not processed in CSP sstate %d",
                              cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);
        }
        break;

      case RRC_BPLMN_SRCH_TIMER_EXPIRED_IND:
        rrc_csp_int_data.bplmn_srch_tmr_expired = TRUE;

        /* Set data that needs to be reported to RR */
        rrc_csp_int_data.rrc_rr_plmn_srch_cnf.srch_done   = FALSE;
        rrc_csp_int_data.rrc_rr_plmn_srch_cnf.hplmn_found = FALSE;

        next_substate = RRCCSP_CELL_SEL_WT_FREQ_SCAN_CNF_PENDING;
        break;


      case RRC_FREQ_REDIRECT_WAIT_TIMER_EXPIRED_IND:
        WRRC_MSG2_HIGH("Freq redirect wt tmr exprd for freq %d in pending CSP sstate %d",
                                  rrc_csp_int_data.last_camped_freq, rrc_csp_substate);
        /* In pending substate we should not care about wait timer expiry. Just to be on the
         * safe side, the variable below is set appropriately on wait timer expiry.
         */
        rrc_csp_int_data.start_acq_on_last_camped_freq = TRUE;
        break;


      case RRC_WTOW_BPLMN_DRX_SRCH_TIMER_EXPIRED_IND:
        rrc_csp_int_data.bplmn_srch_tmr_expired = TRUE;
  
        if((rrc_csp_int_data.curr_scan != RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
           && (rrc_csp_int_data.curr_scan != RRC_CSP_WTOW_BPLMN_MANUAL_SCAN))
        {
          WRRC_MSG1_ERROR("WTOW ERR: Ignoring WTOW BPLMN SrchTmrExp in %d scan", rrc_csp_int_data.curr_scan);
        }
        break;

      case RRC_BPLMN_GUARD_SRCH_TIMER_EXPIRED_IND:
        rrc_csp_int_data.bplmn_guard_srch_tmr_expired = TRUE;
        
        if((rrc_csp_int_data.curr_scan != RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
           && (rrc_csp_int_data.curr_scan != RRC_CSP_WTOW_BPLMN_MANUAL_SCAN))
        {
          WRRC_MSG1_HIGH("Cleaning BPLMN state. Scan type %d", rrc_csp_int_data.curr_scan);
          rrccsp_cleanup_bplmn_state();
        }
        break;

      case RRC_BPLMN_SEARCH_ABORT_REQ:
        if((rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
           || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN))
        { 
          rrccsp_cleanup_bplmn_state();
        }
        else
        {
          WRRC_MSG1_ERROR("WTOW ERR: BPLMN_ABORT_REQ rcvd in st %d when BPLMN srch not in prog",
                                                                 next_substate);
        }
        break;  

      case RRC_BPLMN_SUSPEND_REQ:
        if((rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
           || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN))
        {
          rrccsp_prioritize_pending_commands(cmd_ptr);
        }
        else
        {
          WRRC_MSG1_ERROR("WTOW ERR: BPLMN_SUSPEND_REQ rcvd in st %d when BPLMN srch not in prog",
                                                                 next_substate);
        }
        break;   

      default:
        WRRC_MSG2_HIGH( "Cmd 0x%x not processed in CSP sstate %d",
                            cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);
        break;
    }
  }
  else if(((uint32)cmd_ptr->cmd_hdr.cmd_id & RRC_RR_CMD_ID_BASE) == RRC_RR_CMD_ID_BASE)
  {
    rr_cmd = ((rrc_rr_cmd_type *)cmd_ptr);     /*lint !e740 */

    switch(rr_cmd->cmd_hdr.cmd_id)
    {
      case RRC_INTERRAT_PLMN_SRCH_ABORT_REQ:
        WRRC_MSG0_HIGH("BPLMN:PLMN_SRCH_ABORT_REQ rcvd in WT_FREQ_SCAN_CNF_PENDING substate");
        rrc_csp_int_data.bplmn_srch_cnf = FALSE;

        next_substate = RRCCSP_CELL_SEL_WT_FREQ_SCAN_CNF_PENDING;
        break;

      default:
        WRRC_MSG0_HIGH("BPLMN:Cmd not processed in WT_FREQ_SCAN_CNF_PENDING sstate");
        break;
    }
  }

#ifdef FEATURE_LTE_TO_WCDMA
  else if(cmd_ptr->cmd_hdr.cmd_id == RRC_LTE_RRC_CMD)
  {
    switch(cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.msg_hdr.id)
    {
      case WCDMA_RRC_LTE_ABORT_PLMN_SRCH_REQ:
        WRRC_MSG0_HIGH("LTOW:WCDMA_RRC_LTE_ABORT_PLMN_SRCH_REQ Rcvd in WT_FREQ_SCAN_CNF_PENDING sstate");
        rrc_csp_int_data.bplmn_srch_cnf = FALSE;
        next_substate = RRCCSP_CELL_SEL_WT_FREQ_SCAN_CNF_PENDING;
        break;
      default:
        WRRC_MSG2_HIGH("LTOW: Invalid cmd %x from LTE RRC in CSP substate %d",
            cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.msg_hdr.id,rrc_csp_substate);
        break;
    }
  }
#endif


  return( next_substate );

} /* rrccsp_cell_sel_wait_freq_scan_cnf_pending_hdlr */


/* =======================================================================
**      Function Definitions for substate: RRCCSP_CELL_SEL_WT_SIB
** ======================================================================= */


/*===========================================================================

FUNCTION        rrccsp_cell_sel_wait_sib_sib

DESCRIPTION
                This function handles a SIB Confirm event while waiting on
                one. The Confirm event could come with a status of Pass or
                Failure.

                NOTE: The function does not do any processing for the Failure
                case due to single frequency environment. In the real environment,
                this function will pick another frequency if the ACQ Confirm
                Status indicates a failure. For now, it is presumed that the
                status is going to be a Pass.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_cell_sel_wait_sib_sib( rrc_cmd_type *cmd_ptr )
{

  rrc_csp_substate_e_type  next_substate;

  /* Temporary storage for PLMN status */
  rrc_csp_plmn_status_e_type  cell_plmn_status;
  /* Temporary Storage for Cell Access Restrictions */
  rrc_csp_access_control_e_type  access_control;
  /* Temporary storage for Cell Barred Status */
  rrc_csp_cell_bar_e_type  cell_bar_status;

  rrc_dsac_info_type rrc_dsac_info;
  rrc_ppac_info_type rrc_ppac_info;

  /* Indicates if we need to go to the next freq */
  boolean  move_to_next_freq = FALSE;

  /* Indicates if UE needs stay camped on the barred cell (or) not */
  boolean stay_on_ac_barred_cell = FALSE;

  rrc_csp_cell_actual_vs_expected_e_type cell_status = RRC_CSP_CELL_BELOW_EXPECTED;
  rrc_plmn_identity_type sib_read_plmn_id;

  rrc_MasterInformationBlock *mib_ptr;

  rrclog_wcdma_cell_selection_fail_event_type cell_sel_fail_evt;

#ifdef FEATURE_WCDMA_CSFB_CALL_OPT
  rrclog_wcdma_csfb_call_opt_event_type      event_payload;
#endif

  /* Temporary storage for "Partial Roaming Restrictions */
  boolean bar_freq_on_gtow_resel = FALSE;

  /* This variable is set to TRUE when either the lai is forbidden or 
       the PLMN is non-eplmn.
  */
  rrc_csp_int_data.bar_for_resel_only= FALSE;

#ifdef FEATURE_STAY_CAMPED_ON_ACCESS_CLASS_BARRED_CELL
  /* set this flag to TRUE if this feature is defined*/
  stay_on_ac_barred_cell = TRUE;
#endif /* FEATURE_STAY_CAMPED_ON_ACCESS_CLASS_BARRED_CELL*/

  cell_plmn_status = RRC_CSP_PLMN_SAME_AS_REQ;
  access_control = RRC_CSP_CELL_ACCESS_ALLOWED;
  cell_bar_status = RRC_CSP_CELL_OK;
  rrc_dsac_info.valid = FALSE;
  
  /* During BPLMN search reset curr_rd_index if acquisition scan
   * is not part of rrccsp_try_next_best_cell_if_available() call
   * and BPLMN timer expires before SIB read request cld be sent.
   */
  rrc_csp_int_data.bplmn_sib_try_next_best_cell = FALSE;

  /* BPLMN: reset the number of bgnd MIB reading attempts to 0
   * if GET_SPECIFIC_SIBS_CNF was received.
   */
  rrc_csp_int_data.bplmn_bgnd_mib_rd_cnt = 0;


  next_substate = RRCCSP_CELL_SEL_WT_SIB;

  if((rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN) ||
     (rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_MANUAL_SCAN) ||
     (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN) ||
     (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
#ifdef FEATURE_LTE_TO_WCDMA
         || ((rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_CELL_RESELECTION_SCAN)
            && (rrc_csp_int_data.interrat_type == RRC_CSP_INTERRAT_LTE_CGI))
#endif
    )
  {
    WRRC_MSG0_HIGH("XTOW_BPLMN:Initialize ACQ SUCC PSC info.");
    rrc_csp_int_data.bplmn_acq_succ_scr_code = 8192;
    rrc_csp_int_data.bplmn_acq_succ_freq = 0;
    rrc_csp_int_data.bplmn_acq_succ_pn_pos = 0xFFFFFFFF;
    rrc_csp_int_data.curr_acq_count = rrc_csp_int_data.bplmn_acq_succ_curr_acq_count;
    rrc_csp_int_data.num_scr_code_det = rrc_csp_int_data.bplmn_acq_succ_scr_code_det;
    rrcsib_bplmn_init_prev_freq_psc();
  }

  if(cmd_ptr->cmd.get_sibs_cnf.status != SIB_EVENT_SUCCEEDED)
  {
    WRRC_MSG0_HIGH("SIB Cnf failed");
#ifdef FEATURE_QSH_EVENT_METRIC
    wrrc_qsh_log_cell_resel_stats(CELL_SEL_FAIL, WRRC_METRIC_UPDATE);
#endif
	
    /* If if there is a another cell on the same frequency,
     * try acquisition on that cell
     */
    if((rrc_csp_int_data.curr_scan != RRC_CSP_GSM_TO_WCDMA_CELL_RESELECTION_SCAN) &&
        (rrc_csp_int_data.curr_scan != RRC_CSP_GTOW_CC_ORDER_SCAN))
    {
      if(
#ifdef FEATURE_FEMTO_CSG
        (cmd_ptr->cmd.get_sibs_cnf.status != SIB_EVENT_FAILED_FREQ_BAR) &&
#endif
        rrccsp_try_next_best_cell_if_available())
      {
        /* During BPLMN search do not reset curr_rd_index if acquisition scan
         * is part of rrccsp_try_next_best_cell_if_available() call
         * and BPLMN timer expires before SIB read request cld be sent.
         */
        if((rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN) 
           || (rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_MANUAL_SCAN)
           || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
           || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN))
        {
          rrc_csp_int_data.bplmn_sib_try_next_best_cell = TRUE;
        }

        /* Start waiting for Acquisition Confirmation */
        next_substate = RRCCSP_CELL_SEL_WT_ACQ;
      }
      else
      {
        /* If SIB event fails because of finding a FPLMN or barred cell/frequency during G2W redirection  
         * stop 10s search after one full scan of target cell list. This is needed to avoid longer duration 
           of no service.
         */
        if((rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_REDIRECTION_SCAN) &&
#ifdef FEATURE_LTE_TO_WCDMA
           (rrc_csp_int_data.interrat_type == RRC_CSP_INTERRAT_GSM) &&
#endif
           ((cmd_ptr->cmd.get_sibs_cnf.status == SIB_EVENT_FAILED_FPLMN) 
#ifdef FEATURE_FEMTO_CSG
            || (cmd_ptr->cmd.get_sibs_cnf.status == SIB_EVENT_FAILED_CELL_BAR) 
            || (cmd_ptr->cmd.get_sibs_cnf.status == SIB_EVENT_FAILED_FREQ_BAR)
#endif
          )) 
        {
          rrc_csp_int_data.skip_repeat_scan_for_redir = TRUE;
        }
        /* No more cells to try on the same frequency, move to the next freq */
        WRRC_MSG0_HIGH("No more cells, move to next freq");
        move_to_next_freq = TRUE;
        rrc_csp_int_data.curr_acq_count = 0;
      }
    }
    else
    {
      move_to_next_freq = TRUE;
      switch(cmd_ptr->cmd.get_sibs_cnf.status)
      {
        case SIB_EVENT_FAILED_LOWER_LAYERS:
          rrc_csp_int_data.interrat_reselect_failure_reason = RRC_WCDMA_SIBS_FAILED_LOWER_LAYERS;
          break;
        case SIB_EVENT_FAILED_TIMEOUT:
          rrc_csp_int_data.interrat_reselect_failure_reason = RRC_WCDMA_SIBS_TIMEOUT;
          break;
        case SIB_EVENT_FAILED_INVALID_SIBS:
          rrc_csp_int_data.interrat_reselect_failure_reason = RRC_WCDMA_INVALID_SIBS;
          break;
#ifdef FEATURE_FEMTO_CSG
        case SIB_EVENT_FAILED_CELL_BAR:
          rrc_csp_int_data.interrat_reselect_failure_reason = RRC_WCDMA_CELL_BARRED;
          break;
        case SIB_EVENT_FAILED_FREQ_BAR:
          rrc_csp_int_data.interrat_reselect_failure_reason = RRC_WCDMA_UARFCN_BARRED;
          break;
        case SIB_EVENT_FAILED_CSG_NW:
          rrc_csp_int_data.interrat_reselect_failure_reason = RRC_WCDMA_CSG_FORBIDDEN;
          break;
#endif
        case SIB_EVENT_FAILED_FB_LA:
          rrc_csp_int_data.interrat_reselect_failure_reason = RRC_WCDMA_FORBIDDEN_LA;
          break;
        case SIB_EVENT_FAILED_SCRITERIA:
          rrc_csp_int_data.interrat_reselect_failure_reason = RRC_WCDMA_CELL_QUALITY_FAILURE;
          break;
        case SIB_EVENT_FAILED_PLMN_MISMATCH:
          rrc_csp_int_data.interrat_reselect_failure_reason = RRC_WCDMA_PLMN_MISMATCH;
          break;
        default:
          rrc_csp_int_data.interrat_reselect_failure_reason = RRC_WCDMA_SIBS_FAILED_OTHER;
          break;
      }
    }
  }
  else /* SIBs have been successfully received */
  {
    /* Check if frequency and scrambling code returned by SIB in confirm
     * is the same as was passed to it.
     */
#ifdef FEATURE_FEMTO_CSG
   rrc_csp_int_data.curr_acq_entry.csg_id     =  cmd_ptr->cmd.get_sibs_cnf.csg_id;
   WRRC_MSG1_HIGH("CSG: CSG ID from SIB cnf %d", rrc_csp_int_data.curr_acq_entry.csg_id);
   if(rrccsp_asf_actively_in_prog())
   {
     bplmn_cell_found_in_drx = TRUE;
   }
#endif
    if((rrc_csp_int_data.curr_acq_entry.freq !=
        (rrc_freq_type)cmd_ptr->cmd.get_sibs_cnf.freq) ||
       (rrc_csp_int_data.curr_acq_entry.scr_code !=
        cmd_ptr->cmd.get_sibs_cnf.scrambling_code))
    {
      MSG_4(MSG_SSID_DFLT, MSG_LEGACY_HIGH,"SIB Confirm has diff freq %d or scr_code %d, Freq %d, scr_code %d was sent to SIB",
            (rrc_freq_type)cmd_ptr->cmd.get_sibs_cnf.freq,
            cmd_ptr->cmd.get_sibs_cnf.scrambling_code,
            rrc_csp_int_data.curr_acq_entry.freq,
            rrc_csp_int_data.curr_acq_entry.scr_code);
    }
#ifdef FEATURE_3GPP_CSFB
    if((rrc_csp_int_data.sib_read_csfb_active) && (rrc_csfb_skip_sib11_opt_nv == TRUE))
    {
      /*SIBs are read when CSFB call is active*/
      rrc_csp_sib_mask_type skipped_sib_mask = 0;
      skipped_sib_mask = SIB_2_BIT |SIB_11_BIT |SIB_12_BIT|SIB_18_BIT;
      skipped_sib_mask |= SIB_11BIS_BIT;
#ifdef FEATURE_WCDMA_TO_LTE
      skipped_sib_mask |= SIB_19_BIT;
#endif
      WRRC_MSG1_HIGH("CSFB: Invalidte Value tags of optional SIBS, mask %d",skipped_sib_mask);
      /*
        Call SIB function that will invalidate the value tags of the optional fields, so that
        optional SIBS that were skipped will be read in next SIB read occasion
      */
      if(cmd_ptr->cmd.get_sibs_cnf.is_sib_read_from_container == TRUE)
      {
        rrc_sibdb_invalidate_sib_v_tag_for_csfb(skipped_sib_mask,cmd_ptr->cmd.get_sibs_cnf.plmn_id,
          cmd_ptr->cmd.get_sibs_cnf.cell_id);
      }
    }
#endif

   /* Since at least SIBs were read and PLMN is available, mark this frequency
    * to eliminate scanning of other frequencies during full frequency scan
    */
    rrc_csp_add_freq_to_available_freq_list((rrc_freq_type)cmd_ptr->cmd.get_sibs_cnf.freq);

    /* This PLMN (common PLMN) should be used only if sharing is not there 
     * or if it is indicated as valid */
    sib_read_plmn_id = cmd_ptr->cmd.get_sibs_cnf.plmn_id;

    /* 1.Get the MIB ptr.
     * 2.Construct the shared PLMN list
     */
    if((rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
       || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN)
       || (rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_MANUAL_SCAN)
       || (rrc_csp_int_data.curr_scan == RRC_CSP_PLMN_LIST_SCAN)
       || (rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN)
#ifdef FEATURE_LTE_TO_WCDMA
       || ( (rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_CELL_RESELECTION_SCAN)
             &&(rrc_csp_int_data.interrat_type == RRC_CSP_INTERRAT_LTE_CGI ))
#endif
      )
    {
      mib_ptr = (rrc_MasterInformationBlock *) rrc_bplmn_return_sib_for_cell(
                                                                             rrc_MIB
                                                                             );
    }
    else
    {
      mib_ptr = (rrc_MasterInformationBlock *) rrc_sibdb_return_sib_for_cell(
                                                                            rrc_MIB,
                                                                            cmd_ptr->cmd.get_sibs_cnf.plmn_id,
                                                                            cmd_ptr->cmd.get_sibs_cnf.cell_id
                                                                           );
    }

    if( mib_ptr == NULL )
    {
      /* SIB3 is NULL This should NOT happen */
      ERR_FATAL("MIB not read but sib_cnf returned SUCCESS", 0, 0, 0);
    }

    if(rrc_is_nw_shared(mib_ptr))
    {
      rrccsp_find_shared_plmns(
                               mib_ptr,
                               cmd_ptr->cmd.get_sibs_cnf.plmn_id,
                              &rrc_csp_int_data.curr_nw_db_entry
                               );

      /* Prioritize the NAS requested PLMN/HPLMN based on the current scan type  This is because 
       * our search for good PLMNs is sequential in the list of shared PLMNs and if there is a low priority
       * PLMN (eplmn) available ahead of the needed PLMN then we may end up in camping on it even though
       * the requested PLMN is available */
      rrccsp_prioritize_the_list_of_shared_plmns();
      rrc_csp_int_data.curr_acq_entry.is_valid_nw_sharing = TRUE;
      rrc_csp_int_data.curr_acq_entry.cell_id = cmd_ptr->cmd.get_sibs_cnf.cell_id;
      rrc_csp_int_data.curr_acq_entry.plmn_id = rrc_csp_int_data.curr_nw_db_entry.shared_plmns_access_info[0].plmn_id;
      sib_read_plmn_id = rrc_csp_int_data.curr_acq_entry.plmn_id;
    }
    else
    {
      rrc_csp_int_data.curr_acq_entry.is_valid_nw_sharing = FALSE;
    }

    if((search_order_specialization  == SYS_SPECIAL_SBM_RAT_SEARCH_ORDER) &&
       ((rrc_csp_curr_select_data.current_band == RRC_CSP_IMT2K_BAND) ||
         (rrc_csp_curr_select_data.current_band == RRC_CSP_WCDMA_850_BAND)) &&
        ((RRC_CSP_GET_INT_MCC(sib_read_plmn_id) == JAPAN_MCC1) ||
         (RRC_CSP_GET_INT_MCC(sib_read_plmn_id) == JAPAN_MCC2)))  
    {
      move_to_next_freq = TRUE;
      WRRC_MSG0_HIGH("Search Order Specialization: Move to Next Frequency as Japan MCC falling on Band 1/5");
    }

#ifdef FEATURE_SKIP_SIB1_3_DURING_MANUAL_PLMN_SCAN
    if((rrc_csp_int_data.curr_scan == RRC_CSP_PLMN_LIST_SCAN)||
       (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN)||
       (rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_MANUAL_SCAN))
    {
      /* Fill the tmp_acq_entry with SIB data */
      rrc_csp_int_data.curr_acq_entry.plmn_id     = sib_read_plmn_id;
      rrc_csp_int_data.curr_acq_entry.freq        = (rrc_freq_type)cmd_ptr->cmd.get_sibs_cnf.freq;
      rrc_csp_int_data.curr_acq_entry.scr_code    = (rrc_scr_code_type)cmd_ptr->cmd.get_sibs_cnf.scrambling_code;
      rrc_csp_int_data.curr_acq_entry.cell_id     = cmd_ptr->cmd.get_sibs_cnf.cell_id;
      rrc_csp_int_data.curr_acq_entry.status_mask = 0;
#ifdef FEATURE_FEMTO_CSG
      if((rrc_csp_int_data.service_search_bgnd == SYS_SERVICE_SEARCH_CSG)&&(!(rrccsp_is_csg_white(rrc_csp_int_data.curr_acq_entry.csg_id,rrc_csp_int_data.curr_acq_entry.plmn_id))))
      {
        WRRC_MSG0_HIGH("CSG: Adding entry into temp db");
        if( rrccsp_add_acq_db_and_nw_db_entries_temp(&rrc_csp_int_data.curr_acq_entry, 
                                              &rrc_csp_int_data.curr_nw_db_entry) == FAILURE)
      {
        ERR_FATAL("Failure adding acq. entry in CSP subststate %d", next_substate, 0, 0);
      }

      }
      else
#endif
      {
        rrccsp_add_acq_db_and_nw_db_entries(&rrc_csp_int_data.curr_acq_entry,&rrc_csp_int_data.curr_nw_db_entry);
      }

      /* AWS and IMT bands overlap. Since for Manual PLMN search we read only MIB, it is not possible
       * to tell the band to which the cell belongs to w/o reading SIB5/6; and we do NOT want to report
       * AWS PLMNs during IMT band search and vice-versa. So to address this we are
       * exploiting the knowledge that currently only USA has AWS band and USA does NOT have IMT band.
       */      

      /* If both IMT2K and AWS bands are enabled simply add the found PLMN to the list. We already take care of not reporting same PLMN twice
       * This is needed when FEATURE_WCDMA_OPTIMIZED_BAND_SCAN is enabled as we skip scanning the frequencies which already
       * got scanned as a part of other band scan
       */
      if( !((rrc_csp_int_data.band_pref & SYS_BAND_MASK_WCDMA_I_IMT_2000) && (rrc_csp_int_data.band_pref & SYS_BAND_MASK_WCDMA_IV_1700))
           &&
          (((rrc_csp_curr_select_data.current_band == RRC_CSP_WCDMA_1700_2100_BAND) &&
#ifndef FEATURE_RRC_BAND_TYPE_DETECTION_FOR_BPLMN
            (!rrccsp_does_mcc_belong_to_US(rrc_csp_int_data.curr_acq_entry.plmn_id))
#else
            (!cmd_ptr->cmd.get_sibs_cnf.is_sib5bis_scheduled)
#endif 
           )
          ||
          ((rrc_csp_curr_select_data.current_band == RRC_CSP_IMT2K_BAND)&& 
#ifndef FEATURE_RRC_BAND_TYPE_DETECTION_FOR_BPLMN
            (rrccsp_does_mcc_belong_to_US(rrc_csp_int_data.curr_acq_entry.plmn_id))
#else
            (cmd_ptr->cmd.get_sibs_cnf.is_sib5bis_scheduled)
#endif
          ))
        )
      {
        MSG_HIGH("Band (%d) - PLMN (%d-%d) mismatch. do NOT add PLMN to avail plmn list", 
                                                        rrc_csp_curr_select_data.current_band,
                                                        RRC_CSP_GET_INT_MCC(rrc_csp_int_data.curr_acq_entry.plmn_id), 
                                                        RRC_CSP_GET_INT_MNC(rrc_csp_int_data.curr_acq_entry.plmn_id));
      }
      else
      {
        if(rrc_csp_int_data.curr_scan == RRC_CSP_PLMN_LIST_SCAN)
      {
          rrccsp_update_plmn_list(rrc_csp_int_data.curr_acq_entry.plmn_id, rrc_csp_int_data.curr_acq_entry.cell_id);
      }
        else if(rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN)
      {
          rrccsp_update_wtow_background_plmn_list(rrc_csp_int_data.curr_acq_entry.plmn_id, rrc_csp_int_data.curr_acq_entry.cell_id);
    }
    else if(rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_MANUAL_SCAN)
    {
          rrccsp_update_background_plmn_list(rrc_csp_int_data.curr_acq_entry.plmn_id, rrc_csp_int_data.curr_acq_entry.cell_id);
        }
      }
#if defined(FEATURE_FEMTO_CSG) || defined(FEATURE_INCLUDE_DETECTED_CELL_MANUAL_PLMN)
      /* Allow scan on detected PSCs only for manual CSG searches*/
      if(
#if defined(FEATURE_FEMTO_CSG) && !defined(FEATURE_INCLUDE_DETECTED_CELL_MANUAL_PLMN)
         (rrc_csp_int_data.service_search_bgnd == SYS_SERVICE_SEARCH_CSG)&&
#endif
         (rrccsp_try_next_best_cell_if_available()))
      {
        /* During BPLMN search do not reset curr_rd_index if acquisition scan
         * is part of rrccsp_try_next_best_cell_if_available() call
         * and BPLMN timer expires before SIB read request cld be sent.
         */
        rrc_csp_int_data.bplmn_sib_try_next_best_cell = TRUE;
    
        /* Start waiting for Acquisition Confirmation */
        next_substate = RRCCSP_CELL_SEL_WT_ACQ;
      }
      else
#endif
      {
        WRRC_MSG1_HIGH("Continuing with cell selection for %d scan",rrc_csp_int_data.curr_scan);
#if defined(FEATURE_FEMTO_CSG) || defined(FEATURE_INCLUDE_DETECTED_CELL_MANUAL_PLMN)
        rrc_csp_int_data.curr_acq_count = 0;
#endif
#ifdef FEATURE_DUAL_SIM
        if((WCDMA_RRC_IDLE_FEATURES(RRC_ACQ_SPLIT_DURING_BPLMN)) && (rrc_drx_exp_when_wtng_for_mib))
        {
          if(rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_MANUAL_SCAN)
          {
            /* stop WCDMA stack */
            rrctmr_stop_timer(RRCTMR_BPLMN_SRCH_TIMER);
            rrc_csp_int_data.bplmn_srch_tmr_expired = TRUE;
            rrc_csp_int_data.rrc_rr_plmn_srch_cnf.srch_done   = FALSE;
            rrc_csp_int_data.rrc_rr_plmn_srch_cnf.hplmn_found = FALSE;
            rrccsp_send_mode_change_req_to_mcm(RRC_MODE_INACTIVE);
            next_substate = RRCCSP_WT_STOP_MODE_CHANGE_CNF;
          }
          else if(rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN)
          {
            rrctmr_stop_timer(RRCTMR_WTOW_BPLMN_DRX_SRCH_TIMER);
            rrc_csp_int_data.bplmn_srch_tmr_expired = TRUE;
            rrc_csp_send_bch_release(FALSE);
            rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_SUSPEND, FALSE, TRUE);
            if(rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED)
            {
              next_substate = RRCCSP_CAMPED_ACCEPT_CELL;
            }
            else
            {
              next_substate = RRCCSP_CAMPED_SUIT_CELL;
            }
          }
        }
        else 
#endif
        {
          next_substate = rrc_csp_release_bch_and_continue_cell_selection();
        }
      }
      return next_substate;
    }
#ifdef FEATURE_LTE_TO_WCDMA
    else if ( (rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_CELL_RESELECTION_SCAN)
             &&(rrc_csp_int_data.interrat_type == RRC_CSP_INTERRAT_LTE_CGI ))
    {
      rrc_gsm_map_nas_sys_info_type   nas_common_info;
      rrc_SysInfoType1    *sib1_ptr = NULL;
      WRRC_MSG0_HIGH("LTOW: CGI: GET_SPEC_SIB Success");
      
      /* Fill the tmp_acq_entry with SIB data */
      rrc_csp_int_data.curr_acq_entry.plmn_id     = sib_read_plmn_id;
      rrc_csp_int_data.curr_acq_entry.freq        = (rrc_freq_type)cmd_ptr->cmd.get_sibs_cnf.freq;
      rrc_csp_int_data.curr_acq_entry.scr_code    = (rrc_scr_code_type)cmd_ptr->cmd.get_sibs_cnf.scrambling_code;
      rrc_csp_int_data.curr_acq_entry.cell_id     = cmd_ptr->cmd.get_sibs_cnf.cell_id;
      rrc_csp_int_data.curr_acq_entry.status_mask = 0;

      /* Store the Current Acq. entry in Acq. database. */
      rrccsp_add_acq_db_and_nw_db_entries(&rrc_csp_int_data.curr_acq_entry,&rrc_csp_int_data.curr_nw_db_entry);
      //rrccsp_update_cgi_info();
      rrc_csp_int_data.cgi_info_included = TRUE;     
     
      sib1_ptr = (rrc_SysInfoType1 *) rrc_bplmn_return_sib_for_cell( rrc_SIB1   );
      
      if( sib1_ptr == NULL )
      {
         /* SIB3 for this PLMN, CEll ID combination not present */
         ERR_FATAL("SIB1 not present. Returning",0, 0, 0);
      } /* SIB1 not present */
        
      rrc_csp_int_data.curr_acq_entry.rac_valid = FALSE;
      if (rrc_extract_rac_from_sib_info(&rrc_csp_int_data.curr_acq_entry.rai, &sib1_ptr->cn_DomainSysInfoList) == TRUE)
      {
        rrc_csp_int_data.curr_acq_entry.rac_valid = TRUE;
      }


      (void)rrccsp_fill_nas_common_info(sib1_ptr, &nas_common_info);
      if(mm_extract_lac_from_sib_info(&(rrc_csp_int_data.curr_acq_entry.rai.lai), &nas_common_info) == FALSE)
      {
        ERR_FATAL("Unable to extract LAC. Returning",0, 0, 0);
      }
      rrc_csp_int_data.curr_acq_entry.lac_valid = TRUE;
       
      rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_OOS);
      rrccsp_send_mode_change_req_to_mcm( RRC_MODE_INACTIVE );        
      next_substate                     = RRCCSP_WT_STOP_MODE_CHANGE_CNF;
      return  next_substate;
    }
#endif
    else
    {
      WRRC_MSG1_HIGH("Continuing with SIB Cnf processing for %d scan",rrc_csp_int_data.curr_scan);
    }
#endif

    if(rrc_csp_find_access_control(&access_control, &rrc_dsac_info,sib_read_plmn_id,
                                   (rrc_int_cell_id_type)cmd_ptr->cmd.get_sibs_cnf.cell_id
                                   ,cmd_ptr->cmd.get_sibs_cnf.plmn_id
                                   ,&rrc_ppac_info
                                   )
      == FAILURE)
    {
      ERR_FATAL("Failure finding cell access status in CSP sstate %d",
                                                       next_substate, 0, 0);
    }

    /* Fill the Current Acq. entry (including status mask) in Internal data with SIB data */
    if(rrc_csp_fill_acq_entry_from_sib(&cmd_ptr->cmd.get_sibs_cnf,
                                       &rrc_csp_int_data.curr_acq_entry,
                                       &cell_bar_status)
       == FAILURE)
    {
      ERR_FATAL("Failure filling acq. entry in CSP subststate %d", next_substate, 0, 0);
    }

    if((rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_CELL_RESELECTION_SCAN) ||
       (rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_CC_ORDER_SCAN))
    {
      /* Cell is NOT barred */
      if(cell_bar_status == RRC_CSP_CELL_OK)
      {
      if((rrc_dsac_info.valid == FALSE) && 
         (rrc_ppac_info.valid == FALSE) &&
         (access_control == RRC_CSP_NO_CELL_ACCESS) && !stay_on_ac_barred_cell)
        {
          /* Since not even Emergency calls are allowed, no point in selecting this cell.*/
          WRRC_MSG0_HIGH("No call access, return IRAT resel failure");
          move_to_next_freq = TRUE;
          rrc_csp_int_data.interrat_reselect_failure_reason = RRC_WCDMA_CELL_NOT_SUITABLE;
          rrc_csp_int_data.wcdma_cell_time_to_reselect = 40;
        }
      }
      /* Cell is Barred */
      else
      {
        /* If cell is barred, save the failure reason to be sent in the Reselection reject
         * to GSM RR/LTE RRC
         */
        WRRC_MSG0_HIGH("Cell barred, return IRAT resel failure");

        if(cell_bar_status == RRC_CSP_CELL_BAR_INTRA_FREQ)
        {
          /* Send Cell bar request to L1 */
          rrccsp_send_cphy_cell_bar_req(RRC_CSP_WCDMA_PSC_BARRED, 
                                                rrc_csp_int_data.wcdma_cell_time_to_reselect);
        }
        else if(cell_bar_status == RRC_CSP_CELL_BAR_NO_INTRA_FREQ)
        {
          /* Send Cell bar request to L1 */
          rrccsp_send_cphy_cell_bar_req(RRC_CSP_WCDMA_FREQ_BARRED, 
                                                rrc_csp_int_data.wcdma_cell_time_to_reselect);
        }
        else
        {
          WRRC_MSG1_ERROR("ERR Incorrect cell_bar_status = %d", cell_bar_status);
        }

        move_to_next_freq = TRUE;

        if(cell_bar_status == RRC_CSP_CELL_BAR_INTRA_FREQ)
        {
          rrc_csp_int_data.interrat_reselect_failure_reason = RRC_WCDMA_CELL_BARRED;
        }
        else
        {
          rrc_csp_int_data.interrat_reselect_failure_reason = RRC_WCDMA_UARFCN_BARRED;
        }
        /* The wcdma_time_to_reselect would already have been set for this case
         * based on T-barred timer value
         */
      }
    }
    else
    {
      /* Check if cell is barred */
      if(cell_bar_status == RRC_CSP_CELL_OK)
      {
        if((rrc_dsac_info.valid == FALSE) && (access_control == RRC_CSP_NO_CELL_ACCESS) && !stay_on_ac_barred_cell)
        {
          WRRC_MSG0_HIGH("Cell not barred but no cell access");
          move_to_next_freq = TRUE;
        }
        /* FEATURE_WCDMA_ALLOW_ECAL_AC_BARRED_CELL */
        /* Move to next frequency if current frequency does not support emergency call */
        if((((rrc_dsac_info.valid == FALSE) && ((access_control == RRC_CSP_REGULAR_CELL_ACCESS_ONLY) || (access_control == RRC_CSP_NO_CELL_ACCESS))) || 
             ((rrc_dsac_info.valid == TRUE) && ((rrc_dsac_info.cs_access_control == RRC_CSP_REGULAR_CELL_ACCESS_ONLY) || (rrc_dsac_info.cs_access_control == RRC_CSP_NO_CELL_ACCESS)))) &&
           (((rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED) && 
             (rrc_csp_int_data.service_req_cause == RRC_MO_CS_CALL)) ||
            (rrc_csp_int_data.service_req_cause == RRC_MO_CS_ECALL))
          )
        {
          WRRC_MSG0_HIGH("Move to Next Cell as the current cell access doesn't support emergency call");
          move_to_next_freq = TRUE;
        }
      }
      else
      {   /* Cell is barred. Check if Intra-frequency is allowed or not */
        if(cell_bar_status == RRC_CSP_CELL_BAR_NO_INTRA_FREQ)
        {
          /* If the cell found during G2W redirection is barred stop 10s search after one 
           * full scan of target cell list.This is needed to avoid longer duration of no service
           */
          if((rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_REDIRECTION_SCAN)
#ifdef FEATURE_LTE_TO_WCDMA
             &&(rrc_csp_int_data.interrat_type == RRC_CSP_INTERRAT_GSM)
#endif
            )
          {
            rrc_csp_int_data.skip_repeat_scan_for_redir = TRUE;
          }
          /* If cell is barred and INTRA-FREQUENCY is not allowed, go to next frequency*/
          WRRC_MSG0_HIGH("Intra-Freq not allowed, try next freq");

          /* Send Cell bar request to L1 */
          rrccsp_send_cphy_cell_bar_req(RRC_CSP_WCDMA_FREQ_BARRED, 
                                                rrc_csp_int_data.wcdma_cell_time_to_reselect);

          move_to_next_freq = TRUE;
        }
        else
        {
          if(cell_bar_status == RRC_CSP_CELL_BAR_INTRA_FREQ)
          {
            /* Send Cell bar request to L1 */
            rrccsp_send_cphy_cell_bar_req(RRC_CSP_WCDMA_PSC_BARRED, 
                                                  rrc_csp_int_data.wcdma_cell_time_to_reselect);
          }

          /* If cell is barred but INTRA-FREQUENCY is allowed, if there is a another cell on
           * the same frequency try acquisition on that cell
           */

          if(rrccsp_try_next_best_cell_if_available())
          {
            /* During BPLMN search do not reset curr_rd_index if acquisition scan
             * is part of rrccsp_try_next_best_cell_if_available() call
             * and BPLMN timer expires before SIB read request cld be sent.
             */
            if((rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN) 
               || (rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_MANUAL_SCAN)
               || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN) 
               || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN))
            {
              rrc_csp_int_data.bplmn_sib_try_next_best_cell = TRUE;
            }

            /* Start waiting for Acquisition Confirmation */
            next_substate = RRCCSP_CELL_SEL_WT_ACQ;
          }
          else
          {
            if((rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_REDIRECTION_SCAN)
#ifdef FEATURE_LTE_TO_WCDMA
               &&(rrc_csp_int_data.interrat_type == RRC_CSP_INTERRAT_GSM)
#endif
              )
            {
              rrc_csp_int_data.skip_repeat_scan_for_redir = TRUE;
            }
            /* No more cells to try on the same frequency, move to the next freq */
            WRRC_MSG0_HIGH("No more cells, move to next freq");
            move_to_next_freq = TRUE;
            rrc_csp_int_data.curr_acq_count = 0;
          }
        }
      }
    }

    if((move_to_next_freq == FALSE) && (next_substate == RRCCSP_CELL_SEL_WT_SIB))
    {
      /* Store the Current Acq. entry in Acq. database. */
      rrccsp_add_acq_db_and_nw_db_entries(&rrc_csp_int_data.curr_acq_entry,&rrc_csp_int_data.curr_nw_db_entry);

      if(rrc_csp_int_data.curr_scan == RRC_CSP_PLMN_LIST_SCAN)
      {

        /* For dual-mode, call the utility to update internal available PLMN list.
         * Note the utility has the intelligence to decide which PLMNs to add to this list.
         */
        rrccsp_update_plmn_list(rrc_csp_int_data.curr_acq_entry.plmn_id, rrc_csp_int_data.curr_acq_entry.cell_id);
        move_to_next_freq = TRUE;
      }
      else if(rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_MANUAL_SCAN)
      {
        /* For dual-mode, call the utility to update internal available Background PLMN list.
         * Note the utility has the intelligence to decide which PLMNs to add to this list.
         */
        rrccsp_update_background_plmn_list(rrc_csp_int_data.curr_acq_entry.plmn_id, rrc_csp_int_data.curr_acq_entry.cell_id);
        move_to_next_freq = TRUE;
      }
      else if(rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN)
      {
        /* Check for S-criteria before adding the PLMN to the available PLMN list */
        if(rrc_is_s_criteria_met(rrc_csp_int_data.curr_acq_entry.plmn_id, rrc_csp_int_data.curr_acq_entry.cell_id))
        {
          WRRC_MSG0_HIGH("BPLMN Automatic Search S-criteria met");
#ifdef FEATURE_FEMTO_CSG
          if(rrc_csp_int_data.csg_asf_srch_in_progress)
          {
            rrccsp_add_entry_to_temp_csg_db(&cmd_ptr->cmd.get_sibs_cnf);
            cell_status = RRC_CSP_CELL_BELOW_EXPECTED;
          }
          else
#endif
          {

            cell_status = rrccsp_get_cell_status_during_bplmn_search(&rrc_csp_int_data.curr_acq_entry
                                                                   ,&rrc_csp_int_data.curr_nw_db_entry
                                                                   );
          }

          if(cell_status == RRC_CSP_CELL_BELOW_EXPECTED)
          {
            if(rrc_csp_int_data.curr_acq_entry.status_mask & RRC_CSP_FORBID_REG_AREA_BIT)
            {
              /* Detected cells Requirement  Try ACQ on only highest ranked cells */
              WRRC_MSG0_HIGH("No more cells to be tried on this frequency as frequency is barred, move to next freq");
              move_to_next_freq = TRUE;
            }
            /* If if there is a another cell on the same frequency,
             * try acquisition on that cell
             */
            if(!move_to_next_freq && rrccsp_try_next_best_cell_if_available())
            {
              /* During BPLMN search do not reset curr_rd_index if acquisition scan
               * is part of rrccsp_try_next_best_cell_if_available() call
               * and BPLMN timer expires before SIB read request cld be sent.
               */
              rrc_csp_int_data.bplmn_sib_try_next_best_cell = TRUE;

              /* Start waiting for Acquisition Confirmation */
              next_substate = RRCCSP_CELL_SEL_WT_ACQ;
            }
            else
            {
              /* No more cells to try on the same frequency, move to the next freq */
              WRRC_MSG0_HIGH("No more cells, move to next freq");
              move_to_next_freq = TRUE;
              rrc_csp_int_data.curr_acq_count = 0;
            }
          } /* Cell not below expectations */
          else
          { 

            /* NAS requirement is that when Background Service Request is sent by NAS
             * when UE mode is Manual then RRC should populate the available PLMN list
             * only if the PLMNs match.
             * If UE is in Automatic Mode, then filtering of PLMNs will be done by NAS
             * and RRC should report ALL available PLMNs.
             */
            if(rrc_csp_int_data.service_search_bgnd == SYS_SERVICE_SEARCH_BACKGROUND_MANUAL)
            {
              WRRC_MSG0_HIGH("SSB: Cell is as expected. Updting Avail PLMN List for Manual UE mode");
              rrccsp_update_background_plmn_list(rrc_csp_int_data.curr_acq_entry.plmn_id,
                                                        cmd_ptr->cmd.get_sibs_cnf.cell_id);
            }

            WRRC_MSG0_HIGH("BPLMN: Matching PLMN found");
            // Set data that needs to be reported to RR

            rrc_csp_int_data.rrc_rr_plmn_srch_cnf.srch_done   = TRUE;
            rrc_csp_int_data.rrc_rr_plmn_srch_cnf.hplmn_found = TRUE;
            rrc_csp_int_data.bplmn_sib_try_next_best_cell = FALSE;

            /* stop WCDMA stack */
            rrccsp_send_mode_change_req_to_mcm(RRC_MODE_INACTIVE);
            return(next_substate = RRCCSP_WT_STOP_MODE_CHANGE_CNF);
          }
        }
        /* S-criteria not met */
        else
        {
          WRRC_MSG0_HIGH("BPLMN Automatic Search S-criteria not met");

          /* If if there is a another cell on the same frequency,
           * try acquisition on that cell
           */
          if(rrccsp_try_next_best_cell_if_available())
          {
            /* During BPLMN search do not reset curr_rd_index if acquisition scan
             * is part of rrccsp_try_next_best_cell_if_available() call
             * and BPLMN timer expires before SIB read request cld be sent.
             */
            rrc_csp_int_data.bplmn_sib_try_next_best_cell = TRUE;

            /* Start waiting for Acquisition Confirmation */
            next_substate = RRCCSP_CELL_SEL_WT_ACQ;
          }
          else
          {
            /* No more cells to try on the same frequency, move to the next freq */
            WRRC_MSG0_HIGH("No more cells, move to next freq");
            move_to_next_freq = TRUE;
            rrc_csp_int_data.curr_acq_count = 0;
          }
        }  
      } /* end RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN */
      else if(rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN)
      {
        /* For dual-mode, call the utility to update internal available Background PLMN list.
         * Note the utility has the intelligence to decide which PLMNs to add to this list.
         */
        rrccsp_update_wtow_background_plmn_list(rrc_csp_int_data.curr_acq_entry.plmn_id, rrc_csp_int_data.curr_acq_entry.cell_id);
        move_to_next_freq = TRUE;
      } /* end RRC_CSP_WTOW_BPLMN_MANUAL_SCAN */

      else if(rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
      {
        /* Check for S-criteria before adding the PLMN to the available PLMN list */
        if(rrc_is_s_criteria_met(rrc_csp_int_data.curr_acq_entry.plmn_id, rrc_csp_int_data.curr_acq_entry.cell_id))
        {

#ifdef FEATURE_FEMTO_CSG
          if(rrc_csp_int_data.csg_asf_srch_in_progress)
          {
            rrccsp_add_entry_to_temp_csg_db(&cmd_ptr->cmd.get_sibs_cnf);
            cell_status = RRC_CSP_CELL_BELOW_EXPECTED;
          }
          else
#endif
          {
            cell_status = rrccsp_get_cell_status_during_bplmn_search(&rrc_csp_int_data.curr_acq_entry
                                                                   ,&rrc_csp_int_data.curr_nw_db_entry
                                                                   );
          }

          if(cell_status == RRC_CSP_CELL_BELOW_EXPECTED)
          {
            if(rrc_csp_int_data.curr_acq_entry.status_mask & RRC_CSP_FORBID_REG_AREA_BIT)
             {
               /* Detected cells Requirement  Try ACQ on only highest ranked cells */
               WRRC_MSG0_HIGH("No more cells to be tried on this frequency as frequency is barred, move to next freq");
               move_to_next_freq = TRUE;
             }
            /* If if there is a another cell on the same frequency,
             * try acquisition on that cell
             */
            if(!move_to_next_freq && rrccsp_try_next_best_cell_if_available())
            {
              /* During BPLMN search do not reset curr_rd_index if acquisition scan
               * is part of rrccsp_try_next_best_cell_if_available() call
               * and BPLMN timer expires before SIB read request cld be sent.
               */
              rrc_csp_int_data.bplmn_sib_try_next_best_cell = TRUE;

              /* Start waiting for Acquisition Confirmation */
              next_substate = RRCCSP_CELL_SEL_WT_ACQ;
            }
            else
            {
              /* No more cells to try on the same frequency, move to the next freq */
              WRRC_MSG0_HIGH("No more cells, move to next freq");
              move_to_next_freq = TRUE;
              rrc_csp_int_data.curr_acq_count = 0;
            }                                     
          } /* Cell not below expectations */
          else
          {
            /* NAS requirement is that when Background Service Request is sent by NAS
             * when UE mode is Manual then RRC should populate the available PLMN list
             * only if the PLMNs match.
             * If UE is in Automatic Mode, then filtering of PLMNs will be done by NAS
             * and RRC should report ALL available PLMNs.
             */
            if(rrc_csp_int_data.service_search_bgnd == SYS_SERVICE_SEARCH_BACKGROUND_MANUAL)
            {
              WRRC_MSG0_HIGH("SSB: Cell is as expected. Updting Avail PLMN List for Manual UE mode");
              rrccsp_update_wtow_background_plmn_list(rrc_csp_int_data.curr_acq_entry.plmn_id,
                                                        cmd_ptr->cmd.get_sibs_cnf.cell_id);
            }

            WRRC_MSG0_HIGH("WTOW: HPLMN found!. Stop srch. Snd listcnf to NAS. Snd sleep ind to L1");

            rrc_csp_int_data.bplmn_sib_try_next_best_cell = FALSE;

            /* Release BCH and put lower layers to Idle */
            rrc_csp_send_bch_release(FALSE);

            rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_STOP, TRUE, TRUE);

            if(rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED)
            {
              next_substate = RRCCSP_CAMPED_ACCEPT_CELL;
            }
            else
            {
              next_substate = RRCCSP_CAMPED_SUIT_CELL;
            }
            return(next_substate);
          } 
        }
        /* S-criteria not met */
        else
        {
          WRRC_MSG0_HIGH("WTOW: Automatic Search S-criteria not met");

          /* If if there is a another cell on the same frequency,
           * try acquisition on that cell
           */
          if(rrccsp_try_next_best_cell_if_available())
          {
            /* During BPLMN search do not reset curr_rd_index if acquisition scan
             * is part of rrccsp_try_next_best_cell_if_available() call
             * and BPLMN timer expires before SIB read request cld be sent.
             */
            rrc_csp_int_data.bplmn_sib_try_next_best_cell = TRUE;

            /* Start waiting for Acquisition Confirmation */
            next_substate = RRCCSP_CELL_SEL_WT_ACQ;
          }
          else
          {
            /* No more cells to try on the same frequency, move to the next freq */
            WRRC_MSG0_HIGH("No more cells, move to next freq");
            move_to_next_freq = TRUE;
            rrc_csp_int_data.curr_acq_count = 0;
          }
        }  
      } /* end RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN */
      else
      {
        /* For dual-mode, call the utility to update internal available PLMN list.
         * Note the utility has the intelligence to decide which PLMNs to add to this list.
         */
        rrccsp_update_plmn_list(rrc_csp_int_data.curr_acq_entry.plmn_id,
                                rrc_csp_int_data.curr_acq_entry.cell_id);

        cell_status = rrccsp_get_cell_status(&cell_plmn_status,
                                             &rrc_csp_int_data.curr_acq_entry
                                             ,&rrc_csp_int_data.curr_nw_db_entry
                                             );

        bar_freq_on_gtow_resel = rrc_csp_int_data.bar_for_resel_only;
        rrc_csp_int_data.bar_for_resel_only = FALSE;

        /* For this scenario when all PLMNs in the shared list are forbidden but the cell bar 
         * status is FALSE then we should treat this as expected for ANY PLMN */
        if( (cell_status == RRC_CSP_CELL_BELOW_EXPECTED) && 
            (rrc_csp_int_data.curr_type_acq == RRC_CSP_ANY_PLMN) &&
            (!(rrc_csp_int_data.curr_acq_entry.status_mask & RRC_CSP_IDLE_CELL_BAR_BIT))
#ifdef FEATURE_WRLF_SYSTEM_SEL
             && !(RRC_IS_CONN_MODE_OOS_SRCH_IN_PROGRESS() &&
                  !((rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED)
                  && (rrc_csp_int_data.service_req_cause == RRC_MO_CS_CALL)))
#endif
             )
        {
          /* Forbidden LAI */
          /* As non forbidden LAI is not found allow limited service on the current LAI */
          cell_status = RRC_CSP_CELL_AS_EXPECTED;
        }

        /* Send SERVICE_AVAILABLE to NAS for NAS to update UI with limited service */
#ifdef FEATURE_WRLF_SYSTEM_SEL
        if(RRC_IS_CONN_MODE_OOS_SRCH_IN_PROGRESS() &&
           (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_SELECTION_SCAN) &&
           (cell_status == RRC_CSP_CELL_BELOW_EXPECTED) &&
           (rrc_csp_int_data.curr_type_acq == RRC_CSP_ANY_PLMN) &&
           (!(rrc_csp_int_data.curr_acq_entry.status_mask & RRC_CSP_IDLE_CELL_BAR_BIT)))
        {
          rrc_selected_plmn_type curr_sel_plmn;
          /* Release BCH and put lower layers to Idle */
          rrc_csp_send_bch_release(FALSE);

          rrc_csp_int_data.curr_service_status = MM_AS_SERVICE_AVAILABLE;

          curr_sel_plmn.plmn_type = RRC_GSM_MAP_PLMN_SEL;
          curr_sel_plmn.plmn_id = rrc_csp_int_data.curr_acq_entry.plmn_id;

          rrc_csp_send_mm_cmd(RRC_SERVICE_CNF,
                              rrc_csp_int_data.curr_service_status, 
                              &curr_sel_plmn,
                              &rrc_csp_int_data.curr_acq_entry);

          next_substate = RRCCSP_NO_CELL_SELECTED;
          return next_substate;
        }
#endif

        if(cell_status == RRC_CSP_CELL_BELOW_EXPECTED)
        {
           if((rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_CELL_RESELECTION_SCAN) ||
              (rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_CC_ORDER_SCAN))
           {
             if((rrc_csp_int_data.interrat_reselect_failure_reason != RRC_WCDMA_FORBIDDEN_LA) &&
                (rrc_csp_int_data.interrat_reselect_failure_reason != RRC_WCDMA_PLMN_MISMATCH))
             {
               rrc_csp_int_data.interrat_reselect_failure_reason = RRC_WCDMA_CELL_NOT_SUITABLE;
             }

             if(rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_CELL_RESELECTION_SCAN)
             {
               if(rrc_csp_int_data.curr_acq_entry.status_mask & RRC_CSP_FORBID_REG_AREA_BIT) 
               {
                 WRRC_MSG0_HIGH("CR151: forbidden LAI found during IRAT reselection.");
                 bar_freq_on_gtow_resel = TRUE;
               }

               if (bar_freq_on_gtow_resel)
               {
                 WRRC_MSG0_HIGH("CR151: sending CPHY_CELL_BAR_REQ to L1 ");
                 rrc_csp_int_data.bar_for_resel_only = TRUE;
                 /* Send Cell bar request to L1 */
                 rrccsp_send_cphy_cell_bar_req(RRC_CSP_WCDMA_FREQ_BARRED, 
                                                                           FORBIDDEN_RESEL_FREQ_BAR_TIMER_IN_SEC);
                 rrc_csp_int_data.bar_for_resel_only = FALSE;
                 
                 rrc_csp_int_data.non_eq_plmn_barred = FALSE;                                                               
               }
             }

             /* If this cell is NOT good enough, move to the next freq */
             WRRC_MSG0_HIGH("Cell below expected, move to next freq");
             move_to_next_freq = TRUE;

           }
           else
           {


             /* The case where UE releases RRC Connection bcoz the 2nd strongest 
              * cell is good for camping can lead to a problem when UE transitions 
              * to disconnected bcoz on transition to disconnected UE will again 
              * find the strongest cell which has no cell access and UE may camp on it.
              * We need to avoid the above case and hence RRC will move to the next frequency
              * in this case instead of trying the next best cell.
              */
             if(((rrc_csp_int_data.curr_scan == RRC_CSP_OUT_OF_SERVICE_AREA_SCAN)
#ifdef FEATURE_WRLF_SYSTEM_SEL
                    || (RRC_IS_CONN_MODE_OOS_SRCH_IN_PROGRESS())
#endif
                ) && 
                ((rrc_dsac_info.valid == FALSE) && (access_control == RRC_CSP_NO_CELL_ACCESS))
               )
             {
               /* No more cells to try on the same frequency, move to the next freq */
               WRRC_MSG0_HIGH("OOS: Do NOT try ACQ on next best cell. No more cells, move to next freq");

               move_to_next_freq = TRUE;
               rrc_csp_int_data.curr_acq_count = 0;
             }
             else if(rrc_csp_int_data.curr_acq_entry.status_mask & RRC_CSP_FORBID_REG_AREA_BIT)
             {
               /* It was observed that a particular GSM NW is redirecting the UE to a cell belonging 
                * to forbidden LA in WCDMA resulting in longer duration of no service because of 10s target 
                * cell search followed by suitable cell search. In such a scenario we want to get to back to 
                * GSM immediately
                */
               if((rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_REDIRECTION_SCAN)
#ifdef FEATURE_LTE_TO_WCDMA
               &&(rrc_csp_int_data.interrat_type == RRC_CSP_INTERRAT_GSM)
#endif
                 )
               {
                 rrc_csp_int_data.skip_repeat_scan_for_redir = TRUE;
               }
               /* Detected cells Requirement  Try ACQ on only highest ranked cells */
               WRRC_MSG0_HIGH("No more cells to be tried on this frequency as frequency is barred, move to next freq");
               move_to_next_freq = TRUE;
             }
             /* If if there is a another cell on the same frequency,
             * try acquisition on that cell
             */
             else if(rrccsp_try_next_best_cell_if_available())
             {
               /* Start waiting for Acquisition Confirmation */
               next_substate = RRCCSP_CELL_SEL_WT_ACQ;
             }

             else
             {
               /* No more cells to try on the same frequency, move to the next freq */
               WRRC_MSG0_HIGH("No more cells, move to next freq");
               move_to_next_freq = TRUE;
               rrc_csp_int_data.curr_acq_count = 0;
             }
           }
        }
        else if((rrc_csp_int_data.curr_scan == RRC_CSP_CELL_SELECTION_SCAN) &&
                (rrc_csp_int_data.continue_cell_selection)
#ifdef FEATURE_EOOS
                 #error code not present
#endif
               )
        {
          /*S-criteria is not met, continue with cell selection*/
          WRRC_MSG0_HIGH("S-Criteria is not met, continue with cell selection");
          if(rrccsp_try_next_best_cell_if_available())
          {
            /* Start waiting for Acquisition Confirmation */
            next_substate = RRCCSP_CELL_SEL_WT_ACQ;
          }
          else
          {
            /*No more entries on the frequency, move to next frequency*/
            move_to_next_freq = TRUE;
            rrc_csp_int_data.curr_acq_count = 0;
          }
        }
        else  /* Cell not below expectation */
        {
#ifdef FEATURE_WCDMA_CSFB_CALL_OPT
          /* If CSFB call is in progress and S criteris api returns SUCCESS post CELL CHANGE REQ 
             and move to CELL_WT_CAMP */
          if(
              (WCDMA_RRC_IDLE_FEATURES(RRC_CSFB_CALL_TIMELINE_OPT)) &&
              (rrc_csfb_call_status) && 
              (TRUE == rrc_check_serv_cell_s_crit((rrc_SysInfoType3 *) rrc_sibdb_return_sib_for_cell(
                rrc_SIB3, cmd_ptr->cmd.get_sibs_cnf.plmn_id,cmd_ptr->cmd.get_sibs_cnf.cell_id)))
            )
          {
            WRRC_MSG0_HIGH("S criteria for CSFB call");

            event_payload.status = RRC_S_CRITERION_API_CHECK_PASSED;
            event_report_payload(EVENT_WCDMA_CSFB_CALL_OPT, sizeof(event_payload), (void *)&event_payload);

            /* Send a CELL_CHANGE_REQ for Cell Change Manager */
            if(rrc_csp_send_ccm_cmd(RRC_CELL_CHANGE_REQ,
                 RRC_NEW_CELL_SELECTED,
                 &rrc_csp_int_data.curr_acq_entry)
                 ==FAILURE)
            {
              /* Since we couldn't send cmd to CCM, ERR_FATAL here */
              ERR_FATAL("Could not send Int Cmd %d in CSP substate %d",
                RRC_CELL_CHANGE_REQ, rrc_csp_substate, 0);
            }
            else /* Cell Change Req successfully sent */
            {
              /* Determine if to go to Suitable or Acceptable cell selection at this point */
              if(rrc_csp_int_data.curr_req_plmn.plmn_type == RRC_GSM_MAP_ANY_PLMN_REQ)
              {
                /* If requested PLMN Type is "Any PLMN" we will go to acceptable cell
                 * selection
                 */
                next_substate = RRCCSP_ACCEPT_CELL_SEL_WT_CAMP;
              }
              else /* Requested PLMN type is for a Specific PLMN */
              {
                /* Determine at this point if based on SIBs of the received cell, we
                 * are still in Suitable Cell Selection
                 */
                if(RRC_CSP_IN_SUIT_SEL(cell_plmn_status,
                                     rrc_csp_int_data.curr_acq_entry.status_mask))
                {
                  next_substate = RRCCSP_SUIT_CELL_SEL_WT_CAMP;
                }
                else
                {
                  WRRC_MSG0_HIGH("OOS: Changing CSP sst to Acceptable");
                  next_substate = RRCCSP_ACCEPT_CELL_SEL_WT_CAMP;
                }
              }   /* Requested PLMN type is for a Specific PLMN */
            }
          }
          else
#endif
          {

#ifdef FEATURE_WCDMA_CSFB_CALL_OPT
          if(
              (WCDMA_RRC_IDLE_FEATURES(RRC_CSFB_CALL_TIMELINE_OPT)) &&
              (rrc_csfb_call_status)
            )
          {
            event_payload.status = RRC_S_CRITERION_API_CHECK_FAILED;
            event_report_payload(EVENT_WCDMA_CSFB_CALL_OPT, sizeof(event_payload), (void *)&event_payload);
          }
#endif
            /* Cell meets expectations - lets send Cell Parms to L1 */
            rrc_csp_send_l1_cmd(RRC_PROCEDURE_CSP, CPHY_CELL_PARM_REQ,
                              &rrc_csp_int_data.curr_acq_entry);
            MSG_LOW("L1 cmd 0x%x sent, CSP sstate %d", CPHY_CELL_PARM_REQ, rrc_csp_substate, 0);

            rrc_csp_send_l1_cmd(RRC_PROCEDURE_CSP, CPHY_CELL_SELECTION_REQ,
                                     &rrc_csp_int_data.curr_acq_entry);
            MSG_LOW("L1 cmd 0x%x sent, CSP sstate %d",
                           CPHY_CELL_SELECTION_REQ, rrc_csp_substate, 0);

            /* Determine if to go to Suitable or Acceptable cell selection at this point */
            if(rrc_csp_int_data.curr_req_plmn.plmn_type == RRC_GSM_MAP_ANY_PLMN_REQ)
            {
              /* If requested PLMN Type is "Any PLMN" we will go to acceptable cell
               * selection
               */
              next_substate = RRCCSP_ACCEPT_CELL_SEL_WT_S;
            }
            else /* Requested PLMN type is for a Specific PLMN */
            {
              /* Determine at this point if based on SIBs of the received cell, we
               * are still in Suitable Cell Selection
               */
              if(RRC_CSP_IN_SUIT_SEL(cell_plmn_status,
                                     rrc_csp_int_data.curr_acq_entry.status_mask))
              {
                 next_substate = RRCCSP_SUIT_CELL_SEL_WT_SERV_S;
              }
              else
              {
                WRRC_MSG0_HIGH("OOS: Changing CSP sst to Acceptable");
                next_substate = RRCCSP_ACCEPT_CELL_SEL_WT_S;
              }
            }   /* Requested PLMN type is for a Specific PLMN */
          }
        }  /* Cell NOT below expectations */
      }
    } /* At least Emergency calls are allowed on this cell */
  }  /* SIBs successfully received */

  if(move_to_next_freq)
  {
#ifdef FEATURE_LTE_TO_WCDMA
    /* Reset ACQ retry counter so that no more ACQ attempts are made on the redirected freq and we can move ahead
        with list scan on the neighour frequencies.*/
    if((rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_REDIRECTION_SCAN) &&
        (rrc_csp_curr_select_data.dest_freq_in_use))
    {
      rrc_csp_curr_select_data.num_tries_on_dest_freq = 0;
    }
#endif

    //EVENT: Event_Cell_Selection_Fail : Reason required
    if (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_SELECTION_SCAN)
    {
      cell_sel_fail_evt.reason = RRC_CS_CELL_UNKNOWN; 
      if(cmd_ptr->cmd.get_sibs_cnf.status != SIB_EVENT_SUCCEEDED)
      {
        cell_sel_fail_evt.reason = RRC_CS_SIB_READ_FAIL; 
      }
      else if (cell_bar_status != RRC_CSP_CELL_OK)
      {
        cell_sel_fail_evt.reason = RRC_CS_CELL_BARRED; 
      }
      else if((rrc_dsac_info.valid == FALSE) && (access_control == RRC_CSP_NO_CELL_ACCESS) && !stay_on_ac_barred_cell)
      {
        cell_sel_fail_evt.reason = RRC_CS_CELL_NO_ACCESS; 
      }
      else if (cell_status == RRC_CSP_CELL_BELOW_EXPECTED)
      {
        cell_sel_fail_evt.reason = RRC_CS_CELL_BELOW_EXPECTED; 
        if (cell_plmn_status == RRC_CSP_PLMN_DIFF_THAN_REQ)
        {
          cell_sel_fail_evt.reason = RRC_CS_CELL_DIFFERENT_PLMN; 
        }
        else if (rrc_csp_int_data.curr_acq_entry.status_mask & RRC_CSP_FORBID_REG_AREA_BIT)
        {
          cell_sel_fail_evt.reason = RRC_CS_CELL_FORBIDDEN_LA; 
        }
#ifdef FEATURE_EOOS
        #error code not present
#endif
      }
      
      event_report_payload(EVENT_WCDMA_CELL_SELECTION_FAIL, sizeof(cell_sel_fail_evt),
                     (void *)&cell_sel_fail_evt);
    }

    if(rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_CELL_RESELECTION_SCAN)
    {
      /* Send CHANGE_MODE_REQ (to Inactive) to MCM and wait for the CHANGE_MODE_CNF */
      rrccsp_send_mode_change_req_to_mcm(RRC_MODE_INACTIVE);
      next_substate = RRCCSP_WT_STOP_MODE_CHANGE_CNF;
    }
    else if(rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_CC_ORDER_SCAN)
    {
      /* Send Camping failure to CHO */
      rrccsp_send_camp_cnf_to_cho(FAILURE);
      next_substate = RRCCSP_NO_CELL_SELECTED;
    }
    else if(rrc_csp_int_data.curr_scan == RRC_CSP_INTER_FREQ_REDIRECTION_SCAN)
    {
      WRRC_MSG1_HIGH("Cell not as expected on freq %d during freq redirect scan",
                                        rrc_csp_int_data.curr_acq_entry.freq);

      /* Release BCH and put lower layers to Idle */
      rrc_csp_send_bch_release(FALSE);

      next_substate = rrccsp_handle_failure_during_freq_redirection();
    }
    else
    {
      WRRC_MSG0_HIGH("Continuing with cell selection");
      next_substate = rrc_csp_release_bch_and_continue_cell_selection();
    }
  }
  return( next_substate );
}  /* rrccsp_cell_sel_wait_sib_sib */



/*===========================================================================

FUNCTION        rrccsp_bplmn_srch_tmr_expiry_wait_sib_sib

DESCRIPTION
                This function handles a SIB Confirm event while waiting on
                one. The Confirm event could come with a status of Pass or
                Failure.

                NOTE: The function does not do any processing for the Failure
                case due to single frequency environment. In the real environment,
                this function will pick another frequency if the ACQ Confirm
                Status indicates a failure. For now, it is presumed that the
                status is going to be a Pass.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_bplmn_srch_tmr_expiry_wait_sib_sib( rrc_cmd_type *cmd_ptr )
{

  rrc_csp_substate_e_type  next_substate;

  /* Temporary Storage for Cell Access Restrictions */
  rrc_csp_access_control_e_type  access_control;
  /* Temporary storage for Cell Barred Status */
  rrc_csp_cell_bar_e_type  cell_bar_status;

  rrc_dsac_info_type rrc_dsac_info;
  rrc_ppac_info_type rrc_ppac_info;

  /* Indicates if we need to go to the next freq */
  boolean  look_for_hplmn = TRUE;

  rrc_csp_cell_actual_vs_expected_e_type cell_status = RRC_CSP_CELL_BELOW_EXPECTED;
  rrc_plmn_identity_type sib_read_plmn_id;

  rrc_MasterInformationBlock *mib_ptr;

  /* Indicates if UE needs stay camped on the access class barred cell (or) not */
  boolean stay_on_ac_barred_cell = FALSE;

#ifdef FEATURE_STAY_CAMPED_ON_ACCESS_CLASS_BARRED_CELL
  /* set this flag as TRUE if this feature is defined */
  stay_on_ac_barred_cell = TRUE;
#endif /* FEATURE_STAY_CAMPED_ON_ACCESS_CLASS_BARRED_CELL */

  /* During BPLMN search reset curr_rd_index if acquisition scan
   * is not part of rrccsp_try_next_best_cell_if_available() call
   * and BPLMN timer expires before SIB read request cld be sent.
   */
  rrc_csp_int_data.bplmn_sib_try_next_best_cell = FALSE;

  /* BPLMN: reset the number of bgnd MIB reading attempts to 0
   * if GET_SPECIFIC_SIBS_CNF was received.
   */
  rrc_csp_int_data.bplmn_bgnd_mib_rd_cnt = 0;

  next_substate = RRCCSP_CELL_SEL_WT_SIB_PENDING;

  /* SIB event has failed */
  if(cmd_ptr->cmd.get_sibs_cnf.status != SIB_EVENT_SUCCEEDED)
  {
    WRRC_MSG0_HIGH("SIB Cnf failed");
    /* return to the calling function */
    look_for_hplmn = FALSE;
  }

  /* SIBs have been successfully received */
  else
  {
#ifdef FEATURE_FEMTO_CSG
    rrc_csp_int_data.curr_acq_entry.csg_id = cmd_ptr->cmd.get_sibs_cnf.csg_id;
    WRRC_MSG1_HIGH("CSG: CSG ID from SIB cnf %d", rrc_csp_int_data.curr_acq_entry.csg_id);
#endif
    /* Check if frequency and scrambling code returned by SIB in confirm
     * is the same as was passed to it.
     */
    if((rrc_csp_int_data.curr_acq_entry.freq !=
        (rrc_freq_type)cmd_ptr->cmd.get_sibs_cnf.freq) ||
       (rrc_csp_int_data.curr_acq_entry.scr_code !=
        cmd_ptr->cmd.get_sibs_cnf.scrambling_code))
    {
      MSG_4(MSG_SSID_DFLT, MSG_LEGACY_HIGH,"SIB Confirm has diff freq %d or scr_code %d, Freq %d, scr_code %d was sent to SIB",
            (rrc_freq_type)cmd_ptr->cmd.get_sibs_cnf.freq,
            cmd_ptr->cmd.get_sibs_cnf.scrambling_code,
            rrc_csp_int_data.curr_acq_entry.freq,
            rrc_csp_int_data.curr_acq_entry.scr_code);
    }

   /* Since at least SIBs were read and PLMN is available, mark this frequency
    * to eliminate scanning of other frequencies during full frequency scan
    */
    rrc_csp_add_freq_to_available_freq_list((rrc_freq_type)cmd_ptr->cmd.get_sibs_cnf.freq);

    /* This PLMN (common PLMN) should be used only if sharing is not there 
     * or if it is indicated as valid */
    sib_read_plmn_id = cmd_ptr->cmd.get_sibs_cnf.plmn_id;

    /* 1.Get the MIB ptr.
     * 2.Construct the shared PLMN list
     */
    if((rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
       || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN)
       || (rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_MANUAL_SCAN)
       || (rrc_csp_int_data.curr_scan == RRC_CSP_PLMN_LIST_SCAN)
       || (rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN))
    {
      mib_ptr = (rrc_MasterInformationBlock *) rrc_bplmn_return_sib_for_cell(
                                                                             rrc_MIB
                                                                             );
    }
    else
    {
      mib_ptr = (rrc_MasterInformationBlock *) rrc_sibdb_return_sib_for_cell(
                                                                            rrc_MIB,
                                                                            cmd_ptr->cmd.get_sibs_cnf.plmn_id,
                                                                            cmd_ptr->cmd.get_sibs_cnf.cell_id
                                                                           );
    }

    if( mib_ptr == NULL )
    {
      /* SIB3 is NULL This should NOT happen */
      ERR_FATAL("MIB not read but sib_cnf returned SUCCESS", 0, 0, 0);
    }

    if(rrc_is_nw_shared(mib_ptr))
    {
      rrccsp_find_shared_plmns(
                               mib_ptr,
                               cmd_ptr->cmd.get_sibs_cnf.plmn_id,
                               &rrc_csp_int_data.curr_nw_db_entry
                               );

      /* Prioritize the NAS requested PLMN/HPLMN based on the current scan type  This is because 
       * our search for good PLMNs is sequential in the list of shared PLMNs and if there is a low priority
       * PLMN (eplmn) available ahead of the needed PLMN then we may end up in camping on it even though
       * the requested PLMN is available */
      rrccsp_prioritize_the_list_of_shared_plmns();
      rrc_csp_int_data.curr_acq_entry.is_valid_nw_sharing = TRUE;
      rrc_csp_int_data.curr_acq_entry.cell_id = cmd_ptr->cmd.get_sibs_cnf.cell_id;
      rrc_csp_int_data.curr_acq_entry.plmn_id = rrc_csp_int_data.curr_nw_db_entry.shared_plmns_access_info[0].plmn_id;
      sib_read_plmn_id = rrc_csp_int_data.curr_acq_entry.plmn_id;
    }
    else
    {
      rrc_csp_int_data.curr_acq_entry.is_valid_nw_sharing = FALSE;
    }

#ifdef FEATURE_SKIP_SIB1_3_DURING_MANUAL_PLMN_SCAN

    WRRC_MSG0_HIGH(" Avoid processing other than MIB ");
    if(rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN)
    {
      /* Fill the tmp_acq_entry with SIB data */
      rrc_csp_int_data.curr_acq_entry.plmn_id     = sib_read_plmn_id;
      rrc_csp_int_data.curr_acq_entry.freq        = (rrc_freq_type)cmd_ptr->cmd.get_sibs_cnf.freq;
      rrc_csp_int_data.curr_acq_entry.scr_code    = (rrc_scr_code_type)cmd_ptr->cmd.get_sibs_cnf.scrambling_code;
      rrc_csp_int_data.curr_acq_entry.cell_id     = cmd_ptr->cmd.get_sibs_cnf.cell_id;
      rrc_csp_int_data.curr_acq_entry.status_mask = 0;

      /* At least Emergency calls allowed on this cell */
      /* Store the Current Acq. entry in Acq. database. */
#ifdef FEATURE_FEMTO_CSG
      if((rrc_csp_int_data.service_search_bgnd == SYS_SERVICE_SEARCH_CSG)&&(!(rrccsp_is_csg_white(rrc_csp_int_data.curr_acq_entry.csg_id,rrc_csp_int_data.curr_acq_entry.plmn_id))))
      {
        WRRC_MSG0_HIGH("CSG: Adding entry into temp db");
        if( rrccsp_add_acq_db_and_nw_db_entries_temp(&rrc_csp_int_data.curr_acq_entry, 
                                               &rrc_csp_int_data.curr_nw_db_entry) == FAILURE)
        {
          ERR_FATAL("Failure adding acq. entry in CSP subststate %d", next_substate, 0, 0);
        }

      }
      else
#endif
      {
        rrccsp_add_acq_db_and_nw_db_entries(&rrc_csp_int_data.curr_acq_entry,&rrc_csp_int_data.curr_nw_db_entry);
      }

      /* AWS and IMT bands overlap. Since for Manual PLMN search we read only MIB, it is not possible
       * to tell the band to which the cell belongs to w/o reading SIB5/6; and we do NOT want to report
       * AWS PLMNs during IMT band search and vice-versa. So to address this we are
       * exploiting the knowledge that currently only USA has AWS band and USA does NOT have IMT band.
       */      
      /* If both IMT2K and AWS bands are enabled simply add the found PLMN to the list. We already take care of not reporting same PLMN twice
       * This is needed when FEATURE_WCDMA_OPTIMIZED_BAND_SCAN is enabled as we skip scanning the frequencies which already
       * got scanned as a part of other band scan
       */
      if( !((rrc_csp_int_data.band_pref & SYS_BAND_MASK_WCDMA_I_IMT_2000) && (rrc_csp_int_data.band_pref & SYS_BAND_MASK_WCDMA_IV_1700))
           &&
          (((rrc_csp_curr_select_data.current_band == RRC_CSP_WCDMA_1700_2100_BAND) && 
#ifndef FEATURE_RRC_BAND_TYPE_DETECTION_FOR_BPLMN
            (!rrccsp_does_mcc_belong_to_US(rrc_csp_int_data.curr_acq_entry.plmn_id))
#else
            (!cmd_ptr->cmd.get_sibs_cnf.is_sib5bis_scheduled)
#endif 
           )
          ||
          ((rrc_csp_curr_select_data.current_band == RRC_CSP_IMT2K_BAND)&& 
#ifndef FEATURE_RRC_BAND_TYPE_DETECTION_FOR_BPLMN
            (rrccsp_does_mcc_belong_to_US(rrc_csp_int_data.curr_acq_entry.plmn_id))
#else
            (cmd_ptr->cmd.get_sibs_cnf.is_sib5bis_scheduled)
#endif
          ))
        )
      {
        MSG_HIGH("Band (%d) - PLMN (%d-%d) mismatch. do NOT add PLMN to avail plmn list", 
                                                        rrc_csp_curr_select_data.current_band,
                                                        RRC_CSP_GET_INT_MCC(rrc_csp_int_data.curr_acq_entry.plmn_id), 
                                                        RRC_CSP_GET_INT_MNC(rrc_csp_int_data.curr_acq_entry.plmn_id));
      }
      else
      {
        /* For dual-mode, call the utility to update internal available Background PLMN list.
         * Note the utility has the intelligence to decide which PLMNs to add to this list.
         */
        rrccsp_update_wtow_background_plmn_list(rrc_csp_int_data.curr_acq_entry.plmn_id, rrc_csp_int_data.curr_acq_entry.cell_id);
      }
      return next_substate;
    }
    else if(rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_MANUAL_SCAN)
    {
      /* Fill the tmp_acq_entry with SIB data */
      rrc_csp_int_data.curr_acq_entry.plmn_id     = sib_read_plmn_id;
      rrc_csp_int_data.curr_acq_entry.freq        = (rrc_freq_type)cmd_ptr->cmd.get_sibs_cnf.freq;
      rrc_csp_int_data.curr_acq_entry.scr_code    = (rrc_scr_code_type)cmd_ptr->cmd.get_sibs_cnf.scrambling_code;
      rrc_csp_int_data.curr_acq_entry.cell_id     = cmd_ptr->cmd.get_sibs_cnf.cell_id;
      rrc_csp_int_data.curr_acq_entry.status_mask = 0;

      /* At least Emergency calls allowed on this cell */
      /* Store the Current Acq. entry in Acq. database. */
#ifdef FEATURE_FEMTO_CSG
      if((rrc_csp_int_data.service_search_bgnd == SYS_SERVICE_SEARCH_CSG)&&(!(rrccsp_is_csg_white(rrc_csp_int_data.curr_acq_entry.csg_id,rrc_csp_int_data.curr_acq_entry.plmn_id))))
      {
        WRRC_MSG0_HIGH("CSG: Adding entry into temp db");
        if( rrccsp_add_acq_db_and_nw_db_entries_temp(&rrc_csp_int_data.curr_acq_entry, 
                                               &rrc_csp_int_data.curr_nw_db_entry) == FAILURE)
        {
          ERR_FATAL("Failure adding acq. entry in CSP subststate %d", next_substate, 0, 0);
        }

      }
      else
#endif
      {
        rrccsp_add_acq_db_and_nw_db_entries(&rrc_csp_int_data.curr_acq_entry,&rrc_csp_int_data.curr_nw_db_entry);
      }

      /* AWS and IMT bands overlap. Since for Manual PLMN search we read only MIB, it is not possible
       * to tell the band to which the cell belongs to w/o reading SIB5/6; and we do NOT want to report
       * AWS PLMNs during IMT band search and vice-versa. So to address this we are
       * exploiting the knowledge that currently only USA has AWS band and USA does NOT have IMT band.
       */      
      /* If both IMT2K and AWS bands are enabled simply add the found PLMN to the list. We already take care of not reporting same PLMN twice
       * This is needed when FEATURE_WCDMA_OPTIMIZED_BAND_SCAN is enabled as we skip scanning the frequencies which already
       * got scanned as a part of other band scan
       */
      if( !((rrc_csp_int_data.band_pref & SYS_BAND_MASK_WCDMA_I_IMT_2000) && (rrc_csp_int_data.band_pref & SYS_BAND_MASK_WCDMA_IV_1700))
           &&
          (((rrc_csp_curr_select_data.current_band == RRC_CSP_WCDMA_1700_2100_BAND) &&
#ifndef FEATURE_RRC_BAND_TYPE_DETECTION_FOR_BPLMN
            (!rrccsp_does_mcc_belong_to_US(rrc_csp_int_data.curr_acq_entry.plmn_id))
#else
            (!cmd_ptr->cmd.get_sibs_cnf.is_sib5bis_scheduled)
#endif 
           )
          ||
          ((rrc_csp_curr_select_data.current_band == RRC_CSP_IMT2K_BAND)&& 
#ifndef FEATURE_RRC_BAND_TYPE_DETECTION_FOR_BPLMN
            (rrccsp_does_mcc_belong_to_US(rrc_csp_int_data.curr_acq_entry.plmn_id))
#else
            (cmd_ptr->cmd.get_sibs_cnf.is_sib5bis_scheduled)
#endif
          ))
        )
      {
        MSG_HIGH("Band (%d) - PLMN (%d-%d) mismatch. do NOT add PLMN to avail plmn list", 
                                                        rrc_csp_curr_select_data.current_band,
                                                        RRC_CSP_GET_INT_MCC(rrc_csp_int_data.curr_acq_entry.plmn_id), 
                                                        RRC_CSP_GET_INT_MNC(rrc_csp_int_data.curr_acq_entry.plmn_id));
      }
      else
      {
        /* For dual-mode, call the utility to update internal available Background PLMN list.
         * Note the utility has the intelligence to decide which PLMNs to add to this list.
         */
        rrccsp_update_background_plmn_list(rrc_csp_int_data.curr_acq_entry.plmn_id, rrc_csp_int_data.curr_acq_entry.cell_id);
      }
      return next_substate;
    }
    else
    {
      WRRC_MSG1_HIGH("Continuing with SIB Cnf processing for %d scan",rrc_csp_int_data.curr_scan);
    }
#endif

    if(rrc_csp_find_access_control(&access_control, &rrc_dsac_info,sib_read_plmn_id,
                                   (rrc_int_cell_id_type)cmd_ptr->cmd.get_sibs_cnf.cell_id
                                   ,cmd_ptr->cmd.get_sibs_cnf.plmn_id
                                   ,&rrc_ppac_info
                                   )
      == FAILURE)
    {
      ERR_FATAL("Failure finding cell access status in CSP sstate %d",
                                                       next_substate, 0, 0);
    }


    /* Fill the Current Acq. entry (including status mask) in Internal data with SIB data */
    if(rrc_csp_fill_acq_entry_from_sib(&cmd_ptr->cmd.get_sibs_cnf,
                                        &rrc_csp_int_data.curr_acq_entry,
                                         &cell_bar_status)
       == FAILURE)
    {
      ERR_FATAL("Failure filling acq. entry in CSP subststate %d", next_substate, 0, 0);
    }

    /* Cell is NOT barred */
    if(cell_bar_status == RRC_CSP_CELL_OK)
    {
      if((rrc_dsac_info.valid == FALSE) && (access_control == RRC_CSP_NO_CELL_ACCESS) && !stay_on_ac_barred_cell)
      {
        WRRC_MSG0_HIGH("Cell not barred but no cell access");
        look_for_hplmn = FALSE;
      }
    }
    else
    {
      if(cell_bar_status == RRC_CSP_CELL_BAR_INTRA_FREQ)
      {
         /* Send Cell bar request to L1 */
         rrccsp_send_cphy_cell_bar_req(RRC_CSP_WCDMA_PSC_BARRED, 
                                              rrc_csp_int_data.wcdma_cell_time_to_reselect);
      }
      else if(cell_bar_status == RRC_CSP_CELL_BAR_NO_INTRA_FREQ)
      {
        /* Send Cell bar request to L1 */
        rrccsp_send_cphy_cell_bar_req(RRC_CSP_WCDMA_FREQ_BARRED, 
                                              rrc_csp_int_data.wcdma_cell_time_to_reselect);
      }
      else
      {
        WRRC_MSG1_ERROR("ERR Incorrect cell_bar_status = %d", cell_bar_status);
      }
    }
  
    if(look_for_hplmn)
    {
      /* Store the Current Acq. entry in Acq. database. */
      rrccsp_add_acq_db_and_nw_db_entries(&rrc_csp_int_data.curr_acq_entry,&rrc_csp_int_data.curr_nw_db_entry);

      if(rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_MANUAL_SCAN)
      {
        /* For dual-mode, call the utility to update internal available Background PLMN list.
         * Note the utility has the intelligence to decide which PLMNs to add to this list.
         */
        rrccsp_update_background_plmn_list(cmd_ptr->cmd.get_sibs_cnf.plmn_id,
                                          cmd_ptr->cmd.get_sibs_cnf.cell_id);
        look_for_hplmn = FALSE;
      }
      else if(rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN)
      {
        /* Check if S-criteria is met before adding the PLMN to the available PLMN list */
        if(rrc_is_s_criteria_met(cmd_ptr->cmd.get_sibs_cnf.plmn_id, cmd_ptr->cmd.get_sibs_cnf.cell_id))
        {
          WRRC_MSG0_HIGH("BPLMN Automatic Search S-criteria met");

#ifdef FEATURE_FEMTO_CSG
          if(rrc_csp_int_data.csg_asf_srch_in_progress)
          {
            rrccsp_add_entry_to_temp_csg_db(&cmd_ptr->cmd.get_sibs_cnf);
            cell_status = RRC_CSP_CELL_BELOW_EXPECTED;
          }
          else
#endif
          {
            cell_status = rrccsp_get_cell_status_during_bplmn_search(&rrc_csp_int_data.curr_acq_entry
                                                                   ,&rrc_csp_int_data.curr_nw_db_entry
                                                                   );
          }

          if(cell_status == RRC_CSP_CELL_BELOW_EXPECTED)
          {
               /* If this cell is NOT good enough, return to the calling function */
               WRRC_MSG0_HIGH("Cell below expected, return to the calling function");
               look_for_hplmn = FALSE;
          }
          else  /* Cell not below expectations */
          {
            /* NAS requirement is that when Background Service Request is sent by NAS
             * when UE mode is Manual then RRC should populate the available PLMN list
             * only if the PLMNs match.
             * If UE is in Automatic Mode, then filtering of PLMNs will be done by NAS
             * and RRC should report ALL available PLMNs.
             */
            if(rrc_csp_int_data.service_search_bgnd == SYS_SERVICE_SEARCH_BACKGROUND_MANUAL)
            {
              WRRC_MSG0_HIGH("SSB: Cell is as expected. Updting Avail PLMN List for Manual UE mode");
              rrccsp_update_background_plmn_list(rrc_csp_int_data.curr_acq_entry.plmn_id,
                                                        cmd_ptr->cmd.get_sibs_cnf.cell_id);
            }
            WRRC_MSG0_HIGH("BPLMN: Matching PLMN found");
            // Set data that needs to be reported to RR
            rrc_csp_int_data.rrc_rr_plmn_srch_cnf.srch_done   = TRUE;
            rrc_csp_int_data.rrc_rr_plmn_srch_cnf.hplmn_found = TRUE;

            rrc_csp_int_data.bplmn_sib_try_next_best_cell = FALSE;

            /* stop WCDMA stack */
            rrccsp_send_mode_change_req_to_mcm(RRC_MODE_INACTIVE);
            return(next_substate = RRCCSP_WT_STOP_MODE_CHANGE_CNF);
          }
        }             /* S-criteria not met */
        else
        {
          WRRC_MSG0_HIGH("BPLMN Automatic Search S-criteria not met");
          look_for_hplmn = FALSE;
        }
      }
      if(rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN)
      {
        /* For dual-mode, call the utility to update internal available Background PLMN list.
         * Note the utility has the intelligence to decide which PLMNs to add to this list.
         */
        rrccsp_update_wtow_background_plmn_list(cmd_ptr->cmd.get_sibs_cnf.plmn_id,
                                          cmd_ptr->cmd.get_sibs_cnf.cell_id);
        look_for_hplmn = FALSE;
      } /* end RRC_CSP_WTOW_BPLMN_MANUAL_SCAN */
      else if(rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
      { 
        /* Check if S-criteria is met before adding the PLMN to the available PLMN list */
        if(rrc_is_s_criteria_met(cmd_ptr->cmd.get_sibs_cnf.plmn_id, cmd_ptr->cmd.get_sibs_cnf.cell_id))
        {

#ifdef FEATURE_FEMTO_CSG
          if(rrc_csp_int_data.csg_asf_srch_in_progress)
          {
            rrccsp_add_entry_to_temp_csg_db(&cmd_ptr->cmd.get_sibs_cnf);
            cell_status = RRC_CSP_CELL_BELOW_EXPECTED;
          }
          else
#endif
          {
            cell_status = rrccsp_get_cell_status_during_bplmn_search(&rrc_csp_int_data.curr_acq_entry
                                                                   ,&rrc_csp_int_data.curr_nw_db_entry
                                                                   );
          }

          if(cell_status == RRC_CSP_CELL_BELOW_EXPECTED)
          {
               /* If this cell is NOT good enough, return to the calling function */
               WRRC_MSG0_HIGH("Cell below expected, return to the calling function");
               look_for_hplmn = FALSE;
          }
          else  /* Cell not below expectations */
          {
            /* NAS requirement is that when Background Service Request is sent by NAS
             * when UE mode is Manual then RRC should populate the available PLMN list
             * only if the PLMNs match.
             * If UE is in Automatic Mode, then filtering of PLMNs will be done by NAS
             * and RRC should report ALL available PLMNs.
             */
            if(rrc_csp_int_data.service_search_bgnd == SYS_SERVICE_SEARCH_BACKGROUND_MANUAL)
            {
              WRRC_MSG0_HIGH("SSB: Cell is as expected. Updting Avail PLMN List for Manual UE mode");
              rrccsp_update_wtow_background_plmn_list(rrc_csp_int_data.curr_acq_entry.plmn_id,
                                                        cmd_ptr->cmd.get_sibs_cnf.cell_id);
            }
            WRRC_MSG0_HIGH("WTOW: HPLMN found!");

            rrc_csp_int_data.bplmn_sib_try_next_best_cell = FALSE;

            /* Release BCH and put lower layers to Idle */
            rrc_csp_send_bch_release(FALSE);

            rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_STOP, TRUE, TRUE);

            if(rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED)
            {
              next_substate = RRCCSP_CAMPED_ACCEPT_CELL;
            }
            else
            {
              next_substate = RRCCSP_CAMPED_SUIT_CELL;
            }

            return(next_substate);
          }
        }  
        /* S-criteria is not met */
        else
        {
          WRRC_MSG0_HIGH("WTOW: Automatic Search S-criteria not met");
          look_for_hplmn = FALSE;
        }
      } /* end RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN */
    } /* end look_for_hplmn */
  } /* SIBs successfully received */

  if(!look_for_hplmn)
  {

    WRRC_MSG0_HIGH("BPLMN:Goto WT_SIB_PENDING substate");

    /* Set data that needs to be reported to RR */
    rrc_csp_int_data.rrc_rr_plmn_srch_cnf.srch_done   = FALSE;
    rrc_csp_int_data.rrc_rr_plmn_srch_cnf.hplmn_found = FALSE;

    rrc_csp_int_data.bplmn_sib_try_next_best_cell = FALSE;
    next_substate = RRCCSP_CELL_SEL_WT_SIB_PENDING;
    return(next_substate);
  }
  return(next_substate);
}  /* rrccsp_bplmn_srch_tmr_expiry_wait_sib_sib */

/*===========================================================================

FUNCTION        RRCCSP_CELL_SEL_WAIT_SIB_HDLR

DESCRIPTION
                This is a handler for events received in
                RRCCSP_CELL_SEL_WT_SIB substate of the Cell Selection Procedure.
                Depending on the event, it further calls a function for
                processing the event in this CSP substate.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/

static rrc_csp_substate_e_type
rrccsp_cell_sel_wait_sib_hdlr( rrc_cmd_type *cmd_ptr )
{
  rrc_csp_substate_e_type   next_substate;
  rrc_state_e_type          rrc_state = rrc_get_state();


  /* Inter-RAT command */
  rrc_rr_cmd_type *rr_cmd;
  boolean         for_serving_cell = TRUE;
  uint8 freq_idx=0;

  boolean interrat_cmd = FALSE;
#ifdef FEATURE_LTE_TO_WCDMA
  if(cmd_ptr->cmd_hdr.cmd_id == RRC_LTE_RRC_CMD)
  {
    interrat_cmd = TRUE;
  }
#endif

  if((((uint32)cmd_ptr->cmd_hdr.cmd_id & RRC_RR_CMD_ID_BASE) == RRC_RR_CMD_ID_BASE) )
  {
    interrat_cmd = TRUE;
  }

  next_substate = RRCCSP_CELL_SEL_WT_SIB;

#ifdef FEATURE_DUAL_SIM
  if((cmd_ptr->cmd_hdr.cmd_id == RRC_GET_SPECIFIC_SIBS_CNF) && 
       (rrc_csp_int_data.csp_waiting_for_wl1_to_release_lock))
  {
    WRRC_MSG0_HIGH("DSIM: CSP waiting for WL1 to release the lock, Ignore GET_SPECIFIC_SIBS_CNF");
    return next_substate;
  }
#endif

  if(!interrat_cmd)
  {
    switch( cmd_ptr->cmd_hdr.cmd_id )
    {
      case RRC_GET_SPECIFIC_SIBS_CNF:
        MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                       cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
        next_substate = rrccsp_cell_sel_wait_sib_sib( cmd_ptr );
#ifdef FEATURE_DUAL_SIM
        rrc_drx_exp_when_wtng_for_mib = FALSE;
#endif

        break;

      case RRC_SERVICE_REQ:
        rrc_state = rrc_get_state();
        if(rrc_state != RRC_STATE_DISCONNECTED)
        {
          WRRC_MSG1_ERROR("Service req in RRC state %d",rrc_state);
        }

        MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                           cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
        rrccsp_save_req( cmd_ptr );
        next_substate = RRCCSP_CELL_SEL_WT_SIB_PENDING;
        break;

      case RRC_DCH_FACH_CELL_SELECTION_TIMER_EXPIRED_IND:
        if(rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_CELL_FACH_SCAN)
        {
          /* Signal SIB procedure to clear up the active event, if any */
          rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_OOS);

          /* First call a CCM function to indicate Cell Loss - no new cell */
          rrc_ccm_update_with_cell_loss();

          next_substate = rrccsp_send_cell_update_initiate_req(RRC_REENTERED_SERVICE_AREA);

        }
        else
        {
          WRRC_MSG1_HIGH("Ignoring Cell Sel Tmr Exp in %d scan", rrc_csp_int_data.curr_scan);
        }
        break;

      case RRC_DCH_PCH_CELL_SELECTION_TIMER_EXPIRED_IND:
        if((rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_CELL_PCH_SCAN) ||
                (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_URA_PCH_SCAN))
        {
          /* Signal SIB procedure to clear up the active event, if any */
          rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_OOS);

          /* First call a CCM function to indicate Cell Loss - no new cell */
          rrc_ccm_update_with_cell_loss();

          next_substate = rrccsp_send_cell_update_initiate_req(RRC_REENTERED_SERVICE_AREA);

        }
        else
        {
          WRRC_MSG1_HIGH("Ignoring Cell Sel Tmr Exp in %d scan", rrc_csp_int_data.curr_scan);
        }
        break;

      case RRC_FACH_TO_FACH_PCH_CELL_SELECTION_TIMER_EXPIRED_IND:
        if((rrc_csp_int_data.curr_scan == RRC_CSP_CELL_FACH_TO_CELL_FACH_SCAN) ||
           (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_FACH_TO_CELL_PCH_SCAN) ||
           (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_FACH_TO_URA_PCH_SCAN))
        {
          /* Signal SIB procedure to clear up the active event, if any */
          rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_OOS);

          /* First call a CCM function to indicate Cell Loss - no new cell */
          rrc_ccm_update_with_cell_loss();

          next_substate = rrccsp_send_cell_update_initiate_req(RRC_REENTERED_SERVICE_AREA);
        }
        else
        {
          WRRC_MSG1_HIGH("Ignoring Cell Sel Tmr Exp in %d scan", rrc_csp_int_data.curr_scan);
        }
        break;

      case RRC_GTOW_REDIRECTION_WAIT_TIMER_EXPIRED_IND:
        WRRC_MSG0_HIGH("GtoW Redirection: Timer expired while waiting for SIBs");
        rrc_csp_int_data.gtow_redirection_timer_expired = TRUE;
        break;

      case RRC_PLMN_LIST_REQ:
        MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                           cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );

        if(rrccsp_plmn_list_req_is_valid(&(cmd_ptr->cmd.plmn_list_req)))
        {
          /* If Scan Type is Leaving Connected Mode Scan then do Manual PLMN
           * Search in background (after UE camps).
           */
          if(rrc_csp_int_data.curr_scan == RRC_CSP_LEAVING_CONN_MODE_SCAN)
          {
            WRRC_MSG0_HIGH("WTOW: LeavingConnModeScan. Hold Manual Srch req until UE camps");

            /* The call to the function below should always return TRUE in this case.
             * If FALSE is returned then it is an error condition. Abort the search.
             */
            if(!rrccsp_handle_plmn_list_req_in_bgnd(&(cmd_ptr->cmd.plmn_list_req)))
            {
              rrc_csp_send_mm_plmn_list_cnf_as_aborted(cmd_ptr->cmd.plmn_list_req.trans_id);
            }
          }
          /* Since scan type is not leaving connected mode, hence do the search in foreground */
          else
          {
            rrccsp_save_req( cmd_ptr );
            next_substate = RRCCSP_CELL_SEL_WT_SIB_PENDING;
          }
        }
        break;


      case RRC_STATE_CHANGE_IND:
        MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                           cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
        if(((rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_CELL_FACH_SCAN) ||
           (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_CELL_PCH_SCAN) ||
           (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_URA_PCH_SCAN) ||
           (rrc_csp_int_data.curr_scan == RRC_CSP_OUT_OF_SERVICE_AREA_SCAN) ||
           (rrc_csp_int_data.curr_scan ==
              RRC_CSP_OUT_OF_SERVICE_AREA_IN_CONNECTING_STATE_SCAN) ||
           (rrc_csp_int_data.curr_scan == RRC_CSP_INTER_FREQ_REDIRECTION_SCAN) ||
           (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN) ||
           (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN)) &&
            (cmd_ptr->cmd.state_change_ind.new_state == RRC_STATE_DISCONNECTED))
        {
          rrccsp_save_req( cmd_ptr );
          next_substate = RRCCSP_CELL_SEL_WT_SIB_PENDING;
        }
        else
        {
          WRRC_MSG1_HIGH("Ignoring state change, curr scan %d",rrc_csp_int_data.curr_scan);
        }
        break;

      case RRC_INITIATE_CELL_SELECTION_IND:
        MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                           cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );

        if(cmd_ptr->cmd.initiate_cell_sel_ind.cause == RRC_TRANSITION_TO_DISCONNECTED)
        {
          /* First Initialize the SIB variables */
          /* Signal SIB procedure to clear up the active event, if any */
          rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_OOS);

          /* Do not release channels and send IDLE_REQ to L1 when BPLMN is actively in progress */
          if((rrc_csp_int_data.curr_scan != RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN) &&
               rrc_csp_int_data.curr_scan != RRC_CSP_WTOW_BPLMN_MANUAL_SCAN)
          {
            /* Release all channels and put lower layers to Idle  */
            rrc_csp_send_chan_release();
          }

#ifdef FEATURE_DISCONNECT_ON_UNSUPPORTED_IRAT_REDIRECTION
          /*If dual mode disabled and redirection to GSM, then trigger OOS and go to idle with no servce*/
          if (cmd_ptr->cmd.initiate_cell_sel_ind.tx_to_discon_reason == RRC_TX_TO_DISCON_UNSUPPORTED_REDIRECTION)
          {
            /* First call a CCM function to indicate Cell Loss - no new cell */
            rrc_ccm_update_with_cell_loss();
            next_substate = rrccsp_rel_chls_and_go_to_idle();
          }
          else
#endif  
            next_substate = rrc_csp_start_sel_leaving_conn_mode();
        }
        else
        {
          WRRC_MSG1_HIGH("Cause %d for Initiate Cell Selection not handled",
                            cmd_ptr->cmd.initiate_cell_sel_ind.cause);
        }
        break;

      case RRC_CPHY_DL_WEAK_IND:
        if(!(cmd_ptr->cmd.dl_weak_ind.serving_cell))
        {
          WRRC_MSG0_HIGH("DL_WK_IND for neigh cell. Ignored");
        }
        else
        {
          if(rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_CELL_RESELECTION_SCAN)
          {
            WRRC_MSG2_HIGH("DL_WEAK_IND during IRAT Resel Scan %d, and CSP st %d. Return to GSM.",
                                        rrc_csp_int_data.curr_scan, rrc_csp_substate);
            /* Send CHANGE_MODE_REQ (to Inactive) to MCM and wait for the CHANGE_MODE_CNF */
            rrccsp_send_mode_change_req_to_mcm(RRC_MODE_INACTIVE);
            rrc_csp_int_data.interrat_reselect_failure_reason = RRC_WCDMA_SIBS_FAILED_LOWER_LAYERS;
            next_substate = RRCCSP_WT_STOP_MODE_CHANGE_CNF;
          }
          else if(rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_CC_ORDER_SCAN)
          { 
            WRRC_MSG2_HIGH("DL_WEAK_IND during GtoW CCO Scan %d, and CSP st %d",
                                        rrc_csp_int_data.curr_scan, rrc_csp_substate);
            rrc_csp_int_data.interrat_reselect_failure_reason = RRC_WCDMA_SIBS_FAILED_LOWER_LAYERS;
            rrccsp_send_camp_cnf_to_cho(FAILURE);
            next_substate = RRCCSP_NO_CELL_SELECTED;
          }
          else if((rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
                 || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN))
          { 
            WRRC_MSG2_HIGH("WTOW: DL_WEAK_IND during BPLMN Search. Scan %d and CSP st %d",
                                        rrc_csp_int_data.curr_scan, rrc_csp_substate);

            /* Signal SIB procedure to clear up the active event */
            rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_WTOW_BPLMN);

            rrc_csp_int_data.curr_acq_count = rrc_csp_int_data.bplmn_acq_succ_curr_acq_count;
            rrc_csp_int_data.num_scr_code_det = rrc_csp_int_data.bplmn_acq_succ_scr_code_det;


            if(rrccsp_try_next_best_cell_if_available())
            {
              WRRC_MSG0_HIGH("WTOW: Continue ACQ on next best cell");
              rrc_csp_int_data.bplmn_sib_try_next_best_cell = TRUE;

              /* Start waiting for Acquisition Confirmation */
              next_substate = RRCCSP_CELL_SEL_WT_ACQ;
            }
            else
            {
              WRRC_MSG0_HIGH("WTOW: Move to next frequency");
              next_substate = rrc_csp_release_bch_and_continue_cell_selection();            
            }
          } 
          else
          {
            /* If there is another cell on the same frequency,
             * try acquisition on that cell
             */
            WRRC_MSG0_HIGH("OOS in SIB_WAIT, continue cell sel");
#ifdef FEATURE_DUAL_SIM
            /*Retry acquisition and SIB reading on same frequency*/
            if(cmd_ptr->cmd.dl_weak_ind.no_resource == TRUE)
            {
              if(rrcsib_check_mib_read_status(TRUE))
              {
                /*Safety check*/
                if(rrc_csp_curr_select_data.num_available_freq > 0)
                {
                  --rrc_csp_curr_select_data.num_available_freq;
                }
              }
            }
#endif
            /* First Initialize the SIB variables */
            /* Signal SIB procedure to clear up the active event, if any */
            rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_OOS);
            
            if((rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN)
               ||(rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_MANUAL_SCAN))
            {
              rrc_csp_int_data.curr_acq_count = rrc_csp_int_data.bplmn_acq_succ_curr_acq_count;
              rrc_csp_int_data.num_scr_code_det = rrc_csp_int_data.bplmn_acq_succ_scr_code_det;
            }

#ifdef FEATURE_DUAL_SIM
            /*Retry acquisition and SIB reading on same frequency*/
            if(cmd_ptr->cmd.dl_weak_ind.no_resource == TRUE)
            {
              rrc_csp_int_data.rrc_dl_wk_no_res = TRUE;
              rrc_csp_int_data.curr_acq_count = rrc_csp_int_data.num_scr_code_det = 0;
              rrc_csp_bplmn_update_select_data_for_reattempt();
              next_substate = rrc_csp_release_chls_and_continue_cell_selection();
              return next_substate;
            }
#endif

            if(rrccsp_try_next_best_cell_if_available())
            {
              /* Start waiting for Acquisition Confirmation */
              next_substate = RRCCSP_CELL_SEL_WT_ACQ;
            }
            else
            {
              /* No more cells to try on the same frequency, move to the next freq */
              WRRC_MSG0_HIGH("No more cells, move to next freq");
              rrc_csp_int_data.curr_acq_count = 0;

              if(rrc_csp_int_data.curr_scan == RRC_CSP_INTER_FREQ_REDIRECTION_SCAN)
              {
                WRRC_MSG1_HIGH("dl_weak_ind for s-cell %d during ifreq redirect scan",
                                                  rrc_csp_int_data.curr_acq_entry.freq);
                /* Release BCH and put lower layers to Idle */
                rrc_csp_send_bch_release(FALSE);

                next_substate = rrccsp_handle_failure_during_freq_redirection();
              }
              else
              {
                next_substate = rrc_csp_release_bch_and_continue_cell_selection();
              }
            }
          }
        }
        break;

      case RRC_BPLMN_SRCH_TIMER_EXPIRED_IND:
        rrc_csp_int_data.bplmn_srch_tmr_expired = TRUE;
        if((rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN)
            || (rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_MANUAL_SCAN))
        {

#ifdef FEATURE_DUAL_SIM
          if(rrc_csp_int_data.csp_waiting_for_wl1_to_release_lock)
          {
            rrc_csp_int_data.csp_waiting_for_wl1_to_release_lock = FALSE;
            /* Set data that needs to be reported to RR */
            rrc_csp_int_data.rrc_rr_plmn_srch_cnf.srch_done   = FALSE;
            rrc_csp_int_data.rrc_rr_plmn_srch_cnf.hplmn_found = FALSE;
            /*This is the case where SIB reading is done and we are waiting for BCH release confirm
              Behave as if DRX timer expired in SIB pending substate*/

            if(rrc_csp_int_data.bplmn_srch_cnf)
            {
              rrc_csp_substate = RRCCSP_CELL_SEL_WT_SIB_PENDING;
              rrc_csp_process_pending_bplmn_srch_timer_expiry();
              rrc_csp_substate = RRCCSP_CELL_SEL_WT_SIB;
            }
            /* stop WCDMA stack */
            rrccsp_send_mode_change_req_to_mcm(RRC_MODE_INACTIVE);
            next_substate = RRCCSP_WT_STOP_MODE_CHANGE_CNF;
            return (next_substate);
          }
#endif

          /* Set data that needs to be reported to RR */
          rrc_csp_int_data.rrc_rr_plmn_srch_cnf.srch_done   = FALSE;
          rrc_csp_int_data.rrc_rr_plmn_srch_cnf.hplmn_found = FALSE;

          for(freq_idx=0;freq_idx<rrc_csp_curr_select_data.num_available_freq; freq_idx++)
          {
            if(rrc_csp_curr_select_data.available_freq_list[freq_idx] == rrc_csp_int_data.curr_acq_entry.freq)
            {
              if(rrc_csp_int_data.bplmn_sib_try_next_best_cell)
              {
                WRRC_MSG0_HIGH("BPLMN: Waiting for SIBS of try next best cell");
              }
              else
              {
                /*If ACQ Entry freq is added to avail freq list, then SIB reading has been successful*/
                WRRC_MSG1_HIGH("Curr ACQ Entry Freq %d is present in avail freq list, wt for SIB CNF",rrc_csp_int_data.curr_acq_entry.freq);
              }
              break;
            }
          }
          /* Check if MIB was read before timer expiry
           */
          if(((!(rrcsib_check_mib_read_status(for_serving_cell)))&&
             ((freq_idx == rrc_csp_curr_select_data.num_available_freq) || 
              (rrc_csp_int_data.bplmn_sib_try_next_best_cell))
             ))
          {
            /* MIB was not read before timer expiry */
            /* Here 120 msec is considered as minimum time because 40 is W start/stop time and 
             we require a minimum of 80 msec to receive MIB */
#ifdef FEATURE_DUAL_SIM
            if((WCDMA_RRC_IDLE_FEATURES(RRC_ACQ_SPLIT_DURING_BPLMN)) && wcdma_is_ue_in_dual_standby &&
               (rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_MANUAL_SCAN) &&
               (rrc_drx_exp_when_wtng_for_mib == FALSE))
            {
              /*Before 60ms of PICH occasion, WRRC should abort SIB reading.
                Restart DRX timer to keep track of this duration. 60ms accounts for BCH Setup/Drop(20ms) + Start/Stop WCDMA(40ms)*/ 
              rrctmr_start_timer(RRCTMR_BPLMN_SRCH_TIMER, XTOW_BPLMN_SEARCH_OVERHEAD_TIMER_WITH_SPLIT_ACQ_IN_MS - XTOW_BPLMN_SIB_DROP_OVERHEAD_TIMER_IN_MS);
              rrc_csp_int_data.bplmn_srch_tmr_expired = FALSE;
              xtow_bplmn_search_overhead_timer = XTOW_BPLMN_SIB_DROP_OVERHEAD_TIMER_IN_MS;
              rrc_drx_exp_when_wtng_for_mib = TRUE;
              next_substate = RRCCSP_CELL_SEL_WT_SIB;
              return(next_substate);
            }
            else
#endif
            if((rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_MANUAL_SCAN) &&
               (xtow_bplmn_search_overhead_timer > 120))
            {
              rrccsp_save_req(cmd_ptr);
              next_substate = RRCCSP_CELL_SEL_WT_SIB_PENDING;
              return(next_substate);
            }

            WRRC_MSG2_HIGH("BPLMN: Wt tmr expd for freq: %d, last_freq: %d",
                         rrc_csp_int_data.curr_acq_entry.freq, rrc_csp_int_data.bplmn_bgnd_mib_rd_freq);

            if(rrc_csp_int_data.bplmn_bgnd_mib_rd_freq == rrc_csp_int_data.curr_acq_entry.freq)
            {
              /* Check if maximum attempts to acquire the freq in background have been
               * exceeded. This would be the case if the wait timer is so small that
               * successful acquisition (~200ms) and MIB reading (~100ms) can not be completed
               * before timer expiry, e.g., with wait timer value of 246ms; or if MIB is never
               * transmitted. If consecutive attempts to read MIB for the same freq have failed
               * MAX_BPLMN_FREQ_SEL_ATTEMPTS times then read MIB in foreground.
               */
              if(rrc_csp_int_data.bplmn_bgnd_mib_rd_cnt >= MAX_BPLMN_FREQ_SEL_ATTEMPTS)
              {
                WRRC_MSG0_HIGH("BPLMN:tmr exp. MIB not read. Max bgnd attmpts exceeded. Srch in fgnd");
                rrc_csp_int_data.bplmn_bgnd_mib_rd_cnt = 0;

                rrccsp_save_req(cmd_ptr);
                next_substate = RRCCSP_CELL_SEL_WT_SIB_PENDING;

                return(next_substate);
              }
              /* Max attempts to read MIB in background have not been exceeded.
               * Return immediately to RR. In this case RRC_GET_SPECIFIC_SIBS_CNF is ignored, if any.
               */
              else
              {
                ++rrc_csp_int_data.bplmn_bgnd_mib_rd_cnt;
                if(rrc_csp_int_data.bplmn_srch_cnf)
                {
                  rrc_csp_int_data.bplmn_acq_succ_scr_code = rrc_csp_int_data.curr_acq_entry.scr_code;
                  rrc_csp_int_data.bplmn_acq_succ_freq = rrc_csp_int_data.curr_acq_entry.freq;
                }
              }
            }
            /* On a new frequency then set the number of attempts to 1 */
            else
            {
              WRRC_MSG2_HIGH("BPLMN: Wt tmr expd during MIB wait for new freq: %d, last_freq: %d",
                          rrc_csp_int_data.curr_acq_entry.freq, rrc_csp_int_data.bplmn_bgnd_mib_rd_freq);
              rrc_csp_int_data.bplmn_bgnd_mib_rd_cnt = 1;
              rrc_csp_int_data.bplmn_bgnd_mib_rd_freq = rrc_csp_int_data.curr_acq_entry.freq;

              WRRC_MSG2_HIGH("XTOW_BPLMN:Save PSC info(%d) to try ACQ again in the next DRX.PN_POS already saved: %d", 
                          rrc_csp_int_data.curr_acq_entry.scr_code,
                          rrc_csp_int_data.bplmn_acq_succ_pn_pos);
                          rrc_csp_int_data.bplmn_acq_succ_scr_code = rrc_csp_int_data.curr_acq_entry.scr_code;
                          rrc_csp_int_data.bplmn_acq_succ_freq = rrc_csp_int_data.curr_acq_entry.freq;
            }

            if(rrc_csp_int_data.bplmn_srch_cnf)
            {
              rrc_csp_int_data.bplmn_acq_status = TRUE;
              rrc_csp_process_pending_bplmn_srch_timer_expiry();
            }
            /* Signal SIB procedure to clear up the active event */
            rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_OOS);

            /* stop WCDMA stack */
            rrccsp_send_mode_change_req_to_mcm(RRC_MODE_INACTIVE);
            next_substate = RRCCSP_WT_STOP_MODE_CHANGE_CNF;
          }
          /* if MIB has been read but waiting for SIBs; or MIB reading should
           * be done in foreground then wait for RRC_GET_SPECIFIC_SIBS_CNF.
           */
          else
          {
            rrccsp_save_req(cmd_ptr);
            next_substate = RRCCSP_CELL_SEL_WT_SIB_PENDING;
          }
#ifdef FEATURE_DUAL_SIM
          rrc_drx_exp_when_wtng_for_mib = FALSE;
#endif
        }
#ifdef FEATURE_LTE_TO_WCDMA
        else if ((rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_CELL_RESELECTION_SCAN) 
                 && (rrc_csp_int_data.interrat_type == RRC_CSP_INTERRAT_LTE_CGI ))
        {
          rrc_csp_fill_cgi_bplmn_tmr_exp();
          WRRC_MSG2_HIGH("CGI: Timer expiry. Save PSC info(%d) to try ACQ again in the next DRX.PN_POS already saved: %d", 
                     rrc_csp_int_data.curr_acq_entry.scr_code,
                     rrc_csp_int_data.bplmn_acq_succ_pn_pos);
                     rrc_csp_int_data.bplmn_acq_succ_scr_code = rrc_csp_int_data.curr_acq_entry.scr_code;
                     rrc_csp_int_data.bplmn_acq_succ_freq = rrc_csp_int_data.curr_acq_entry.freq;
          rrc_csp_int_data.remaining_time_during_bplmn = 0;
          rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_OOS);
          rrccsp_send_mode_change_req_to_mcm( RRC_MODE_INACTIVE );        
          next_substate                     = RRCCSP_WT_STOP_MODE_CHANGE_CNF;
        }
#endif
        else
        {
          WRRC_MSG0_HIGH("Ignoring BPLMN SrchTmrExp in WT_SIB sstate");
        }
        break;

      case RRC_FREQ_REDIRECT_WAIT_TIMER_EXPIRED_IND:
        WRRC_MSG2_HIGH("Freq redirect wt tmr exprd for freq %d in CSP sstate %d",
                                  rrc_csp_int_data.last_camped_freq, rrc_csp_substate);

        /* Inter frequency redirection scan is in progress */
        if(rrc_csp_int_data.curr_scan == RRC_CSP_INTER_FREQ_REDIRECTION_SCAN)
        {
          /* Timer expired for last camped frequency */
          next_substate = rrccsp_handle_freq_redirect_wait_timer_expiry(next_substate);
          if(next_substate == RRCCSP_CELL_SEL_WT_SIB_PENDING)
          {
            /* First Initialize the SIB variables */
            /* Signal SIB procedure to clear up the active event, if any */
            rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_OOS);

            /* Release BCCH/BCH/S_PCCPCH pipe and put lower layers to Idle
             * before sending another acq req
             */
            rrc_csp_send_bch_release(FALSE);

            rrc_csp_int_data.curr_acq_entry.freq = rrc_csp_int_data.last_camped_freq;

            /* Send redirected frequency to L1 for acquisition */
            rrc_csp_send_next_freq_to_l1(&rrc_csp_int_data.curr_acq_entry, RRC_CSP_ACQ_SCAN);

            /* Start waiting for Acquisition Confirmation */
            next_substate = RRCCSP_CELL_SEL_WT_ACQ;
          }
        }
        else
        {
          WRRC_MSG2_ERROR("ERR Wt tmr exprd for freq %d in CSP sstate %d when ifreq-rdrctn not in progress",
                                                 rrc_csp_int_data.last_camped_freq, rrc_csp_substate);
          rrc_csp_int_data.start_acq_on_last_camped_freq = TRUE;
        }
        break;

      case RRC_IRAT_ABORT_IND:
        rrccsp_send_mode_change_req_to_mcm( RRC_MODE_INACTIVE );        

        if(rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_REDIRECTION_SCAN)
        {
          rrc_csp_int_data.rsp_to_rr        = SEND_GTOW_REDIRECTION_ABORT_CNF;
        }
        else
        {
          rrc_csp_int_data.rsp_to_rr        = SEND_GTOW_RESEL_ABORT_CNF;
        }
        next_substate                     = RRCCSP_WT_STOP_MODE_CHANGE_CNF;
        break;

      case RRC_WTOW_BPLMN_DRX_SRCH_TIMER_EXPIRED_IND:
        rrc_csp_int_data.bplmn_srch_tmr_expired = TRUE;
  
        /* Check if DRX srch was actualy in progress */
        if((rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
           || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN))
        {
#ifdef FEATURE_DUAL_SIM
          if(rrc_csp_int_data.csp_waiting_for_wl1_to_release_lock)
          {
            rrc_csp_int_data.csp_waiting_for_wl1_to_release_lock = FALSE;

            /*This is the case where SIB reading is done and we are waiting for BCH release confirm
              Behave as if DRX timer expired in SIB pending substate*/
            rrc_csp_substate = RRCCSP_CELL_SEL_WT_SIB_PENDING;
            rrc_csp_process_pending_bplmn_srch_timer_expiry();
            rrc_csp_substate = RRCCSP_CELL_SEL_WT_SIB;
            rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_SUSPEND, FALSE, TRUE);
            if(rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED)
            {
              next_substate = RRCCSP_CAMPED_ACCEPT_CELL;
            }
            else
            {
              next_substate = RRCCSP_CAMPED_SUIT_CELL;
            }
            return (next_substate);
          }
#endif
          for(freq_idx=0;freq_idx<rrc_csp_curr_select_data.num_available_freq; freq_idx++)
          {
            if(rrc_csp_curr_select_data.available_freq_list[freq_idx] == rrc_csp_int_data.curr_acq_entry.freq)
            {
              if(rrc_csp_int_data.bplmn_sib_try_next_best_cell)
              {
                WRRC_MSG0_HIGH("BPLMN: Waiting for SIBS of try next best cell");
              }
              else
              {
                /*If ACQ Entry freq is added to avail freq list, then SIB reading has been successful*/
                WRRC_MSG1_HIGH("Curr ACQ Entry Freq %d is present in avail freq list, wt for SIB CNF",rrc_csp_int_data.curr_acq_entry.freq);
              }
              break;
            }
          }
          if(((!(rrcsib_check_mib_read_status(for_serving_cell)))&&
             ((freq_idx == rrc_csp_curr_select_data.num_available_freq) || 
             (rrc_csp_int_data.bplmn_sib_try_next_best_cell))))
          {
#ifdef FEATURE_DUAL_SIM
            if((WCDMA_RRC_IDLE_FEATURES(RRC_ACQ_SPLIT_DURING_BPLMN)) && wcdma_is_ue_in_dual_standby &&
               (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN) &&
               (rrc_drx_exp_when_wtng_for_mib == FALSE))
            {
              /*Before 30ms of PICH occasion, WRRC should abort SIB reading.
                Restart DRX timer to keep track of this duration. 30ms accounts for BCH Setup+BCH Drop(20ms)+PICH Setup(10ms)*/
              rrctmr_start_timer(RRCTMR_WTOW_BPLMN_DRX_SRCH_TIMER, WTOW_BPLMN_SEARCH_OVERHEAD_TIMER_WITH_SPLIT_ACQ_IN_MS - WTOW_BPLMN_SIB_DROP_OVERHEAD_TIMER_IN_MS);
              rrc_csp_int_data.bplmn_srch_tmr_expired = FALSE;
              rrc_drx_exp_when_wtng_for_mib = TRUE;
              xtow_bplmn_search_overhead_timer = WTOW_BPLMN_SIB_DROP_OVERHEAD_TIMER_IN_MS;
              next_substate = RRCCSP_CELL_SEL_WT_SIB;
              return(next_substate);
            }
            else
#endif
            if((rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN) &&
               (!(rrc_csp_int_data.service_search_bgnd == SYS_SERVICE_SEARCH_CSG)) &&
               (xtow_bplmn_search_overhead_timer > 80))
            {
              rrccsp_save_req(cmd_ptr);
              next_substate = RRCCSP_CELL_SEL_WT_SIB_PENDING;
              return(next_substate);
            }
            /* MIB was not read before timer expiry */
            WRRC_MSG2_HIGH("BPLMN: Wt tmr expd during MIB wait for freq: %d, last_freq: %d",
            rrc_csp_int_data.curr_acq_entry.freq, rrc_csp_int_data.bplmn_bgnd_mib_rd_freq);
            if(rrc_csp_int_data.bplmn_bgnd_mib_rd_freq == rrc_csp_int_data.curr_acq_entry.freq)
            {
              if(rrc_csp_int_data.bplmn_bgnd_mib_rd_cnt >= MAX_BPLMN_FREQ_SEL_ATTEMPTS)
              {
                WRRC_MSG0_HIGH("BPLMN:tmr exp. MIB not read. Max bgnd attmpts exceeded. Srch in fgnd");
                rrc_csp_int_data.bplmn_bgnd_mib_rd_cnt = 0;
                rrccsp_save_req(cmd_ptr);
                next_substate = RRCCSP_CELL_SEL_WT_SIB_PENDING;
                return(next_substate);
              }
              else
              {
                ++rrc_csp_int_data.bplmn_bgnd_mib_rd_cnt;
              }
            }
            else
            {
              WRRC_MSG2_HIGH("BPLMN: Wt tmr expd during MIB wait for new freq: %d, last_freq: %d",
                        rrc_csp_int_data.curr_acq_entry.freq, rrc_csp_int_data.bplmn_bgnd_mib_rd_freq);
              rrc_csp_int_data.bplmn_bgnd_mib_rd_cnt = 1;
              rrc_csp_int_data.bplmn_bgnd_mib_rd_freq = rrc_csp_int_data.curr_acq_entry.freq;
              WRRC_MSG2_HIGH("XTOW_BPLMN:Save PSC info(%d) to try ACQ again in the next DRX.N_POS already saved: %d",
              rrc_csp_int_data.curr_acq_entry.scr_code, rrc_csp_int_data.bplmn_acq_succ_pn_pos);
            }
            rrc_csp_int_data.bplmn_acq_status = TRUE;
            rrc_csp_process_pending_bplmn_srch_timer_expiry();
            rrc_csp_int_data.bplmn_acq_succ_scr_code = rrc_csp_int_data.curr_acq_entry.scr_code;
            rrc_csp_int_data.bplmn_acq_succ_freq = rrc_csp_int_data.curr_acq_entry.freq;
            rrc_csp_int_data.remaining_time_during_bplmn = rrctmr_get_remaining_time(RRCTMR_SIB_WAIT_TIMER);
            /* Signal SIB procedure to clear up the active event */
            rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_WTOW_BPLMN);
            rrc_csp_send_bch_release(FALSE);
            rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_SUSPEND, FALSE, TRUE);
            if(rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED)
            {
              next_substate = RRCCSP_CAMPED_ACCEPT_CELL;
            }
            else
            {
              next_substate = RRCCSP_CAMPED_SUIT_CELL;
            }
          }
          else
          {
            if(rrcsib_check_if_sibs_scheduled_during_pich())
            {
              rrccsp_save_req(cmd_ptr);
              next_substate = RRCCSP_CELL_SEL_WT_SIB_PENDING;
            }
            else
            {
              rrc_csp_int_data.bplmn_acq_succ_scr_code = rrc_csp_int_data.curr_acq_entry.scr_code;
              rrc_csp_int_data.bplmn_acq_succ_freq = rrc_csp_int_data.curr_acq_entry.freq;
              rrc_csp_int_data.bplmn_acq_status = TRUE;
              rrc_csp_process_pending_bplmn_srch_timer_expiry();
              /* Remaining time in the sib wait timer is saved so that we can start the sib wait timer with
               * this value in the next DRX while starting sib reading on the same cell 
               * If the timer is not saved, and if a fake network doesnt broadcast required sibs, then the 
               * sib event will never end.
              */
              rrc_csp_int_data.remaining_time_during_bplmn = rrctmr_get_remaining_time(RRCTMR_SIB_WAIT_TIMER);
              rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_WTOW_BPLMN);
              rrc_csp_send_bch_release(FALSE);
              rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_SUSPEND, FALSE, TRUE);
              if(rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED)
              {
                next_substate = RRCCSP_CAMPED_ACCEPT_CELL;
              }
              else
              {
               next_substate = RRCCSP_CAMPED_SUIT_CELL;
              }
            }
          }
#ifdef FEATURE_DUAL_SIM
          rrc_drx_exp_when_wtng_for_mib = FALSE;
#endif
        }
        /* Can happen if there is a race condition where the timer was stopped
         * but it had already expired. Print an error msg only for testing 
         * purposes.
         */
        else
        {
          WRRC_MSG1_ERROR("WTOW ERR: Ignoring WTOW BPLMN SrchTmrExp in %d scan", rrc_csp_int_data.curr_scan);
        }
        break;

      case RRC_BPLMN_GUARD_SRCH_TIMER_EXPIRED_IND:
        rrc_csp_int_data.bplmn_guard_srch_tmr_expired = TRUE;
        
        if((rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
           || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN))
        {
          /* Signal SIB procedure to clear up the active event */
          rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_WTOW_BPLMN);

          rrc_csp_send_bch_release(FALSE);

          rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_ABORT, TRUE, TRUE);
          if(rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED)
          {
            next_substate = RRCCSP_CAMPED_ACCEPT_CELL;
          }
          else
          {
            next_substate = RRCCSP_CAMPED_SUIT_CELL;
          }
        }
        else
        {
          WRRC_MSG1_HIGH("Cleaning BPLMN state. Scan type %d", rrc_csp_int_data.curr_scan);
          rrccsp_cleanup_bplmn_state();
        }
        break;

      case RRC_BPLMN_SEARCH_ABORT_REQ:
         /* Check if DRX srch was actualy in progress */
         if((rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
           || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN))
         {
            rrc_csp_int_data.bplmn_acq_status = TRUE;
            rrc_csp_process_pending_bplmn_srch_timer_expiry();
            /* Signal SIB procedure to clear up the active event */
            rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_WTOW_BPLMN);
            rrc_csp_send_bch_release(FALSE);
            rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_ABORT, TRUE, TRUE);
            if(rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED)
            {
              next_substate = RRCCSP_CAMPED_ACCEPT_CELL;
            }
            else
            {
              next_substate = RRCCSP_CAMPED_SUIT_CELL;
            }        
         }
         /* Abort Req rcvd during Manual PLMN Search in foreground */
         else if(rrc_csp_int_data.curr_scan == RRC_CSP_PLMN_LIST_SCAN)
         {
           /* Signal SIB procedure to clear up the active event */
           rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_WTOW_BPLMN);

           rrc_csp_send_bch_release(FALSE);

           /* Send the PLMN_LIST_CNF to MM with status aborted */
           rrc_csp_send_mm_plmn_list_cnf_cmd(FALSE);
           next_substate = RRCCSP_NO_CELL_SELECTED;
         }
         else
         {
           WRRC_MSG1_HIGH("Cleaning BPLMN state. Scan type %d", rrc_csp_int_data.curr_scan);
           rrccsp_cleanup_bplmn_state();
         }
         break;

      case RRC_BPLMN_SUSPEND_REQ:
        if((rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
           || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN))
        {  
          /*decrement to allow freq to be re-acquired when BPLMN is resumed*/
          if(rrcsib_check_mib_read_status(TRUE))
          {
            --rrc_csp_curr_select_data.num_available_freq;
          }

          rrcsib_bplmn_init_prev_freq_psc();
          rrc_csp_int_data.bplmn_acq_succ_scr_code = rrc_csp_int_data.curr_acq_entry.scr_code;
          rrc_csp_int_data.bplmn_acq_succ_freq = rrc_csp_int_data.curr_acq_entry.freq;

          switch(cmd_ptr->cmd.rrc_csp_bplmn_suspend_req.procedure)
          {
            case RRC_PROCEDURE_RCE:
            case RRC_PROCEDURE_SIB:
            case RRC_PROCEDURE_CU:
              /* Signal SIB procedure to clear up the active event */
              rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_WTOW_BPLMN);

              rrc_csp_send_bch_release(FALSE);

              rrc_csp_int_data.bplmn_acq_status = TRUE;
              rrc_csp_process_pending_bplmn_srch_timer_expiry();
              rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_SUSPEND, FALSE, TRUE);
              rrc_csp_send_bplmn_suspend_cnf(cmd_ptr->cmd.rrc_csp_bplmn_suspend_req.procedure, SUCCESS);
              break;

            case RRC_PROCEDURE_IDT:
              /* Signal SIB procedure to clear up the active event */
              rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_WTOW_BPLMN);
              rrc_csp_send_bch_release(FALSE);

              rrc_csp_int_data.bplmn_acq_status = TRUE;
              rrc_csp_process_pending_bplmn_srch_timer_expiry();
              rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_SUSPEND, FALSE, TRUE);
              break;


            case RRC_PROCEDURE_MISC:
              /* Signal SIB procedure to clear up the active event */
              rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_WTOW_BPLMN);
              rrc_csp_send_bch_release(FALSE);

              if(rrc_csp_int_data.bplmn_nw_sel_mode == SYS_NETWORK_SELECTION_MODE_AUTOMATIC)
              {
                rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_ABORT, TRUE, TRUE);
              }
              else
              {
                /* re-try acquisition on the same frequency */
                rrc_csp_int_data.bplmn_acq_status = TRUE;
                rrc_csp_process_pending_bplmn_srch_timer_expiry();
                rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_SUSPEND, FALSE, TRUE);
              }
              /* Send suspend confirmation */
              rrc_csp_send_bplmn_suspend_cnf(cmd_ptr->cmd.rrc_csp_bplmn_suspend_req.procedure, SUCCESS);
              break;

            default:
              WRRC_MSG1_ERROR("ERR WTOW Incorrect proc id %d", cmd_ptr->cmd.rrc_csp_bplmn_suspend_req.procedure);
              /* Send suspend confirmation Anyways */
              rrc_csp_send_bplmn_suspend_cnf(cmd_ptr->cmd.rrc_csp_bplmn_suspend_req.procedure, SUCCESS);
              break;
          }
          if(rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED)
          {
            next_substate = RRCCSP_CAMPED_ACCEPT_CELL;
          }
          else
          {
            next_substate = RRCCSP_CAMPED_SUIT_CELL;
          }
        }
        else
        {
          WRRC_MSG1_ERROR("WTOW ERR: BPLMN_SUSPEND_REQ rcvd in CSP sst %d when BPLMN srch not in prog",
                                                                      next_substate);
        }
        break;


#ifdef FEATURE_DUAL_SIM

      case RRC_RESET_L1_CNF:
      case RRC_CHANNEL_CONFIG_CNF:
        if(rrc_csp_int_data.csp_waiting_for_wl1_to_release_lock)
        {
          rrc_csp_int_data.csp_waiting_for_wl1_to_release_lock = FALSE;
          if(rrc_csp_int_data.preemption_handling_in_progress)
          {
            rrc_csp_int_data.preemption_handling_in_progress = FALSE;
            next_substate = rrc_csp_rel_lock_and_cont_cell_sel_on_prev_preempted();
          }
          else
          {
            next_substate = rrc_csp_continue_cell_selection();
          }
        }
        else
        {
          /*Ignore*/
        }
        break;

#ifdef FEATURE_QTA
      case RRC_DUAL_SIM_WRM_UNLOCK_BY_TIMER_EXP_IND:
        rrcwrm_handle_qta_during_sib_read(wl1_qta_overhead_time_in_ms()+W_QTA_DURATION);
        break;
#endif
#endif

      default:
        WRRC_MSG2_HIGH( "Cmd 0x%x not processed in CSP sstate %d",
                       cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);
        break;
    }
  }
  else if(((uint32)cmd_ptr->cmd_hdr.cmd_id & RRC_RR_CMD_ID_BASE) == RRC_RR_CMD_ID_BASE)
  {
    rr_cmd = ((rrc_rr_cmd_type *)cmd_ptr);    /*lint !e740 */

    switch(rr_cmd->cmd_hdr.cmd_id)
    {
      case RRC_INTERRAT_PLMN_SRCH_ABORT_REQ:
        WRRC_MSG0_HIGH("BPLMN:PLMN_SRCH_ABORT_REQ rcvd in WT_SIB sstate");

        rrc_csp_int_data.bplmn_srch_cnf = FALSE;
        if((rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN)
            || (rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_MANUAL_SCAN))
        {
          WRRC_MSG0_HIGH("BPLMN: calling force_sib_event_init function");
          /* Signal SIB procedure to clear up the active event */
          rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_OOS);

          /* stop WCDMA stack */
          rrccsp_send_mode_change_req_to_mcm(RRC_MODE_INACTIVE);
          return(next_substate = RRCCSP_WT_STOP_MODE_CHANGE_CNF);
        }
        else
        {
          WRRC_MSG0_HIGH("BPLMN:Ignoring PLMN_SRCH_ABORT_REQ in WT_SIB sstate");
        }
        break;
#ifdef FEATURE_GAN_3G_ROVE_OUT_ONLY
      #error code not present
#endif
      default:
        WRRC_MSG0_HIGH("BPLMN: Cmd not processed in WT_SIB sstate");
        break;
    }
  }


#ifdef FEATURE_LTE_TO_WCDMA
  else if(cmd_ptr->cmd_hdr.cmd_id == RRC_LTE_RRC_CMD)
  {
    switch(cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.msg_hdr.id)
    {
      case WCDMA_RRC_LTE_ABORT_PLMN_SRCH_REQ:
        WRRC_MSG0_HIGH("LTOW:WCDMA_RRC_LTE_ABORT_PLMN_SRCH_REQ Rcvd in WT_SIB sstate");
        rrc_csp_int_data.bplmn_srch_cnf = FALSE;
        if((rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_MANUAL_SCAN) ||
           (rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN))
        {
          WRRC_MSG0_HIGH("BPLMN: calling force_sib_event_init function");
          rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_OOS);
          rrccsp_send_mode_change_req_to_mcm(RRC_MODE_INACTIVE);
          return(next_substate = RRCCSP_WT_STOP_MODE_CHANGE_CNF);
        }
        else
        {
          WRRC_MSG0_ERROR("LTOW: Ignoring WCDMA_RRC_LTE_ABORT_PLMN_SRCH_REQ");
        }
        break;
      default:
        WRRC_MSG2_HIGH("LTOW: Invalid cmd %x from LTE RRC in CSP substate %d",
            cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.msg_hdr.id,rrc_csp_substate);
        break;
    }
  }
#endif

  return( next_substate );

} /* rrccsp_cell_sel_wait_sib_hdlr */


/* =======================================================================
** Function Definitions for substate:
    RRCCSP_CELL_SEL_WT_SIB_PENDING
** ======================================================================= */

/*===========================================================================

FUNCTION        rrccsp_cell_sel_wait_sib_pending_hdlr

DESCRIPTION
                This is a handler for events received in
                RRCCSP_CELL_SEL_WT_SIB_PENDING substate of the
                Cell Selection Procedure.
                Depending on the event, it further calls a function for
                processing the event in this CSP substate.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_cell_sel_wait_sib_pending_hdlr( rrc_cmd_type *cmd_ptr )
{
  rrc_csp_substate_e_type   next_substate;
  rrc_state_e_type          rrc_state;

  /* Inter-RAT command */
  rrc_rr_cmd_type *rr_cmd;


  boolean interrat_cmd = FALSE;
#ifdef FEATURE_LTE_TO_WCDMA
  if(cmd_ptr->cmd_hdr.cmd_id == RRC_LTE_RRC_CMD)
  {
    interrat_cmd = TRUE;
  }
#endif

  if((((uint32)cmd_ptr->cmd_hdr.cmd_id & RRC_RR_CMD_ID_BASE) == RRC_RR_CMD_ID_BASE) )
  {
    interrat_cmd = TRUE;
  }

  next_substate = RRCCSP_CELL_SEL_WT_SIB_PENDING;

#ifdef FEATURE_DUAL_SIM
  if((cmd_ptr->cmd_hdr.cmd_id == RRC_GET_SPECIFIC_SIBS_CNF) && 
       (rrc_csp_int_data.csp_waiting_for_wl1_to_release_lock))
  {
    WRRC_MSG0_HIGH("DSIM: CSP waiting for WL1 to release the lock, Ignore GET_SPECIFIC_SIBS_CNF");
    return next_substate;
  }
#endif

  if(!interrat_cmd)
  {
    switch( cmd_ptr->cmd_hdr.cmd_id )
    {
      case RRC_GET_SPECIFIC_SIBS_CNF:
        MSG_LOW( "Cmd 0x%x recvd, CSP sstate %d",
                             cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );

#ifdef FEATURE_DUAL_SIM
        rrc_drx_exp_when_wtng_for_mib = FALSE;
#endif
        /* if automatic BPLMN srch is in progress */
        if(((rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN)
           || (rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_MANUAL_SCAN))
            && (rrc_csp_int_data.bplmn_srch_cnf))
        {
          WRRC_MSG0_HIGH("XTOW_BPLMN:Initialize ACQ SUCC PSC info.");
          rrc_csp_int_data.bplmn_acq_succ_scr_code = 8192;
          rrc_csp_int_data.bplmn_acq_succ_freq = 0;
          rrc_csp_int_data.bplmn_acq_succ_pn_pos = 0xFFFFFFFF;
          next_substate = rrccsp_bplmn_srch_tmr_expiry_wait_sib_sib(cmd_ptr);

          /* if highest priority plmn is not found, next state will
           * be RRCCSP_CELL_SEL_WT_SIB_PENDING. In case hplmn is
           * found, the new state will be RRCCSP_WT_STOP_MODE_CHANGE_CNF.
           */
          if(next_substate == RRCCSP_CELL_SEL_WT_SIB_PENDING)
          {
            next_substate = rrccsp_pending_command_handler();
          }
        }
        else if((rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
                || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN))
        {
          WRRC_MSG0_HIGH("XTOW_BPLMN:Initialize ACQ SUCC PSC info.");
          rrc_csp_int_data.bplmn_acq_succ_scr_code = 8192;
          rrc_csp_int_data.bplmn_acq_succ_freq = 0;
          rrc_csp_int_data.bplmn_acq_succ_pn_pos = 0xFFFFFFFF;
          if((rrc_csp_int_data.pending_type != RRC_CSP_WTOW_BPLMN_DRX_SRCH_TIMER_PENDING)&&
             (rrc_csp_int_data.pending_type != RRC_CSP_BPLMN_GUARD_SRCH_TIMER_PENDING))
          {
            rrc_csp_process_pending_bplmn_srch_timer_expiry();
          }
          next_substate = rrccsp_bplmn_srch_tmr_expiry_wait_sib_sib(cmd_ptr);

          /* If highest priority plmn is found, next state will
           * be RRCCSP_CAMPED_ACCEPT_CELL or RRCCSP_CAMPED_SUIT_CELL. 
           * In the above case bch would be released before sending
           * sleep ind to L1. If hplmn is not found then next substate
           * would be RRCCSP_CELL_SEL_WT_SIB_PENDING in which case we
           * want to release BCH.
           */
          if((next_substate == RRCCSP_CAMPED_ACCEPT_CELL)
              || (next_substate == RRCCSP_CAMPED_SUIT_CELL))
          {
            if((rrc_csp_int_data.pending_type == RRC_CSP_WTOW_BPLMN_DRX_SRCH_TIMER_PENDING)
               || (rrc_csp_int_data.pending_type == RRC_CSP_BPLMN_GUARD_SRCH_TIMER_PENDING))
            {
              WRRC_MSG1_HIGH("WTOW: Ignore pending type %d as HPLMN already fnd", 
                                                      rrc_csp_int_data.pending_type);
            }
            else if(rrc_csp_int_data.pending_type == RRC_CSP_BPLMN_SRCH_SUSPEND_REQ_PENDING)
            {
              WRRC_MSG0_HIGH("WTOW: HPLMN already fnd. Snd suspend_cnf only");
              rrc_csp_send_bplmn_suspend_cnf(rrc_csp_int_data.bplmn_suspend_proc, SUCCESS);
            }
            else
            {
              next_substate = rrccsp_pending_command_handler();
            }
          }
          else
          {
            rrc_csp_send_bch_release(FALSE);

            next_substate = rrccsp_pending_command_handler();
          }
        }
        else
        {
          next_substate = rrccsp_pending_command_handler();
        }
        break;

      case RRC_SERVICE_REQ:
        rrc_state = rrc_get_state();
        if(rrc_state != RRC_STATE_DISCONNECTED)
        {
          WRRC_MSG1_ERROR("Service req in RRC state %d",rrc_state);
        }

        MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                           cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
        rrccsp_save_req(cmd_ptr);
        next_substate = RRCCSP_CELL_SEL_WT_SIB_PENDING;
        break;

      case RRC_PLMN_LIST_REQ:        
        MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                           cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );

        if(rrccsp_plmn_list_req_is_valid(&(cmd_ptr->cmd.plmn_list_req)))
        {
          rrccsp_save_req( cmd_ptr );
          next_substate = RRCCSP_CELL_SEL_WT_SIB_PENDING;
        }
        break;

      case RRC_BPLMN_SRCH_TIMER_EXPIRED_IND:
#ifdef FEATURE_DUAL_SIM
        rrc_drx_exp_when_wtng_for_mib = FALSE;
#endif
        rrc_csp_int_data.bplmn_srch_tmr_expired = TRUE;

        /* Set data that needs to be reported to RR */
        rrc_csp_int_data.rrc_rr_plmn_srch_cnf.srch_done   = FALSE;
        rrc_csp_int_data.rrc_rr_plmn_srch_cnf.hplmn_found = FALSE;
#ifdef FEATURE_FEMTO_CSG
        rrc_csp_int_data.pending_type = RRC_BPLMN_SRCH_TIMER_PENDING;
        WRRC_MSG0_HIGH("CSG: This may not be needed or needs better handling");
#endif

        next_substate = RRCCSP_CELL_SEL_WT_SIB_PENDING;
        break;

      case RRC_FREQ_REDIRECT_WAIT_TIMER_EXPIRED_IND:
        WRRC_MSG2_HIGH("Freq redirect wt tmr exprd for freq %d in pending CSP sstate %d",
                                  rrc_csp_int_data.last_camped_freq, rrc_csp_substate);

        /* In pending substate we should not care about wait timer expiry. Just to be on the
         * safe side, the variable below is set appropriately on wait timer expiry.
         */
        rrc_csp_int_data.start_acq_on_last_camped_freq = TRUE;
        break;
      case RRC_WTOW_BPLMN_DRX_SRCH_TIMER_EXPIRED_IND:
        rrc_csp_int_data.bplmn_srch_tmr_expired = TRUE;
#ifdef FEATURE_DUAL_SIM
        rrc_drx_exp_when_wtng_for_mib = FALSE;
#endif
        if((rrc_csp_int_data.curr_scan != RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
           && (rrc_csp_int_data.curr_scan != RRC_CSP_WTOW_BPLMN_MANUAL_SCAN))
        {
          WRRC_MSG1_ERROR("WTOW ERR: Ignoring WTOW BPLMN SrchTmrExp in %d scan", rrc_csp_int_data.curr_scan);
        }
        break;

      case RRC_BPLMN_SEARCH_ABORT_REQ:
        /* Check if DRX srch was actualy in progress */
        if((rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
          || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN))
        {
          rrc_csp_int_data.bplmn_acq_status = TRUE;
          rrc_csp_process_pending_bplmn_srch_timer_expiry();
          /* Signal SIB procedure to clear up the active event */
          rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_WTOW_BPLMN);
          rrc_csp_send_bch_release(FALSE);
          rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_ABORT, TRUE, TRUE);
          if(rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED)
          {
            next_substate = RRCCSP_CAMPED_ACCEPT_CELL;
          }
          else
          {
            next_substate = RRCCSP_CAMPED_SUIT_CELL;
          }        
        }

      /* Can happen if there is a race condition where the timer was stopped
         * but it had already expired. Print an error msg only for testing 
         * purposes.
         */
        else
        {
          WRRC_MSG1_ERROR("WTOW ERR: Ignoring WTOW BPLMN SEARCH ABORT REQ in %d scan", rrc_csp_int_data.curr_scan);
        }
        break;

      case RRC_BPLMN_GUARD_SRCH_TIMER_EXPIRED_IND:
        rrc_csp_int_data.bplmn_guard_srch_tmr_expired = TRUE;
        
        if((rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
           || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN))
        {
          /* Signal SIB procedure to clear up the active event */
          rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_WTOW_BPLMN);

          rrc_csp_send_bch_release(FALSE);

          rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_ABORT, TRUE, TRUE);
          if(rrc_csp_int_data.pending_type == RRC_CSP_WTOW_BPLMN_DRX_SRCH_TIMER_PENDING)
          {
            if(rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED)
            {
              next_substate = RRCCSP_CAMPED_ACCEPT_CELL;
            }
            else
            {
              next_substate = RRCCSP_CAMPED_SUIT_CELL;
            }
          }
          else
          {
            next_substate = rrccsp_pending_command_handler();
          }
        }
        else
        {
          WRRC_MSG1_HIGH("Cleaning BPLMN state. Scan type %d", rrc_csp_int_data.curr_scan);
          rrccsp_cleanup_bplmn_state();
        }
        break;

      case RRC_BPLMN_SUSPEND_REQ:
        if((rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
           || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN))
        {  
          /*To decrement ACQ DB read index in pending processing bplmn search timer expiry function*/
          rrc_csp_substate = RRCCSP_CELL_SEL_WT_SIB;
          /*decrement to allow freq to be re-acquired when BPLMN is resumed*/
          if(rrcsib_check_mib_read_status(TRUE))
          {
            --rrc_csp_curr_select_data.num_available_freq;
          }

          rrcsib_bplmn_init_prev_freq_psc();
          rrc_csp_int_data.bplmn_acq_succ_scr_code = rrc_csp_int_data.curr_acq_entry.scr_code;
          rrc_csp_int_data.bplmn_acq_succ_freq = rrc_csp_int_data.curr_acq_entry.freq;

          switch(cmd_ptr->cmd.rrc_csp_bplmn_suspend_req.procedure)
          {
            case RRC_PROCEDURE_RCE:
            case RRC_PROCEDURE_SIB:
            case RRC_PROCEDURE_CU:
            case RRC_PROCEDURE_MISC:

              /* Signal SIB procedure to clear up the active event */
              rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_WTOW_BPLMN);
  
              rrc_csp_send_bch_release(FALSE);

              rrc_csp_int_data.bplmn_acq_status = TRUE;
              rrc_csp_process_pending_bplmn_srch_timer_expiry();
              rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_SUSPEND, FALSE, TRUE);
              rrc_csp_send_bplmn_suspend_cnf(cmd_ptr->cmd.rrc_csp_bplmn_suspend_req.procedure, SUCCESS);
              break;

            case RRC_PROCEDURE_IDT:
              /* Signal SIB procedure to clear up the active event */
              rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_WTOW_BPLMN);
  
              rrc_csp_send_bch_release(FALSE);
  
              rrc_csp_int_data.bplmn_acq_status = TRUE;
              rrc_csp_process_pending_bplmn_srch_timer_expiry();
              rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_SUSPEND, FALSE, TRUE);
              break;
  
            default:
              WRRC_MSG1_ERROR("ERR WTOW Incorrect proc id rrc_proc_e_type_value%d", cmd_ptr->cmd.rrc_csp_bplmn_suspend_req.procedure);
              /* Send suspend confirmation Anyways */
              rrc_csp_send_bplmn_suspend_cnf(cmd_ptr->cmd.rrc_csp_bplmn_suspend_req.procedure, SUCCESS);
              break;
          }

          if(rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED)
          {
            next_substate = RRCCSP_CAMPED_ACCEPT_CELL;
          }
          else
          {
            next_substate = RRCCSP_CAMPED_SUIT_CELL;
          }
        }
        else
        {
          WRRC_MSG1_ERROR("WTOW ERR: BPLMN_SUSPEND_REQ rcvd in CSP sst %d when BPLMN srch not in prog",
                                                                      next_substate);
        }
        break;


      case RRC_CPHY_DL_WEAK_IND:
#ifdef FEATURE_DUAL_SIM
        /*Wait for idle confirmation before acting on pending command*/
        if(cmd_ptr->cmd.dl_weak_ind.no_resource == TRUE)
        {
          rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_OOS);
          rrc_csp_int_data.csp_waiting_for_wl1_to_release_lock = TRUE;
          rrc_csp_send_l1_idle_req();
          return RRCCSP_CELL_SEL_WT_SIB_PENDING;
        }
#endif
        if((rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
          || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN))
        { 
          WRRC_MSG2_HIGH("WTOW: DL_WEAK_IND during BPLMN Search. Scan %d and CSP st %d",
                                      rrc_csp_int_data.curr_scan, rrc_csp_substate);

          /* Signal SIB procedure to clear up the active event */
          rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_WTOW_BPLMN);
          rrc_csp_send_bch_release(FALSE);
          next_substate = rrccsp_pending_command_handler();
        } 
        else if((rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN)
               ||(rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_MANUAL_SCAN))
        {
          rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_OOS);
          rrc_csp_send_bch_release(FALSE);
          next_substate = rrccsp_pending_command_handler();
        }
        break;

#ifdef FEATURE_DUAL_SIM
      case RRC_RESET_L1_CNF:
      case RRC_CHANNEL_CONFIG_CNF:
        if(rrc_csp_int_data.csp_waiting_for_wl1_to_release_lock)
        {
          rrc_csp_int_data.csp_waiting_for_wl1_to_release_lock = FALSE;
          if(rrc_csp_int_data.preemption_handling_in_progress)
          {
            rrc_csp_int_data.preemption_handling_in_progress = FALSE;
          }
          /*Release the lock*/
          rrc_release_lock();
          next_substate = rrccsp_pending_command_handler();
        }
        else
        {
          /*Ignore*/
        }
        break;
#ifdef FEATURE_QTA
      case RRC_DUAL_SIM_WRM_UNLOCK_BY_TIMER_EXP_IND:
        rrcwrm_handle_qta_during_sib_read(wl1_qta_overhead_time_in_ms()+W_QTA_DURATION);
        break;
#endif
#endif

      case RRC_INITIATE_CELL_SELECTION_IND:
        MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                           cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );

        if(cmd_ptr->cmd.initiate_cell_sel_ind.cause == RRC_TRANSITION_TO_DISCONNECTED)
        {
          /* First Initialize the SIB variables */
          /* Signal SIB procedure to clear up the active event, if any */
          rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_OOS);

          /* Do not release channels and send IDLE_REQ to L1 when BPLMN is actively in progress */
          if((rrc_csp_int_data.curr_scan != RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN) &&
               rrc_csp_int_data.curr_scan != RRC_CSP_WTOW_BPLMN_MANUAL_SCAN)
          {
            /* Release all channels and put lower layers to Idle  */
            rrc_csp_send_chan_release();
          }

#ifdef FEATURE_DISCONNECT_ON_UNSUPPORTED_IRAT_REDIRECTION
          /*If dual mode disabled and redirection to GSM, then trigger OOS and go to idle with no servce*/
          if (cmd_ptr->cmd.initiate_cell_sel_ind.tx_to_discon_reason == RRC_TX_TO_DISCON_UNSUPPORTED_REDIRECTION)
          {
            /* First call a CCM function to indicate Cell Loss - no new cell */
            rrc_ccm_update_with_cell_loss();
            next_substate = rrccsp_rel_chls_and_go_to_idle();
          }
          else
#endif  
            next_substate = rrc_csp_start_sel_leaving_conn_mode();
        }
        else
        {
          WRRC_MSG1_HIGH("Cause %d for Initiate Cell Selection not handled",
                            cmd_ptr->cmd.initiate_cell_sel_ind.cause);
        }
        break;

      default:
        WRRC_MSG1_HIGH( "Cmd 0x%x not processed in WT_SIB_PENDING sstate",cmd_ptr->cmd_hdr.cmd_id);
        break;
    }
  }
  else if(((uint32)cmd_ptr->cmd_hdr.cmd_id & RRC_RR_CMD_ID_BASE) == RRC_RR_CMD_ID_BASE)
  {
    rr_cmd = ((rrc_rr_cmd_type *)cmd_ptr);    /*lint !e740 */

    switch(rr_cmd->cmd_hdr.cmd_id)
    {
      case RRC_INTERRAT_PLMN_SRCH_ABORT_REQ:
        WRRC_MSG0_HIGH("BPLMN:PLMN_SRCH_ABORT_REQ rcvd in WT_SIB_PENDING sstate");
        rrc_csp_int_data.bplmn_srch_cnf = FALSE;
        next_substate = RRCCSP_CELL_SEL_WT_SIB_PENDING;
        break;

      default:
        WRRC_MSG0_HIGH("BPLMN: Cmd not processed in WT_SIB_PENDING sstate");
        break;
    }
  }

#ifdef FEATURE_LTE_TO_WCDMA
  if(cmd_ptr->cmd_hdr.cmd_id == RRC_LTE_RRC_CMD)
  {
    switch(cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.msg_hdr.id)
    {
      case WCDMA_RRC_LTE_ABORT_PLMN_SRCH_REQ:
        WRRC_MSG0_HIGH("LTOW:WCDMA_RRC_LTE_ABORT_PLMN_SRCH_REQ Rcvd in WT_SIB_PENDING sstate");
        rrc_csp_int_data.bplmn_srch_cnf = FALSE;
        next_substate = RRCCSP_CELL_SEL_WT_SIB_PENDING;
        break;
      default:
        WRRC_MSG2_HIGH("LTOW: Invalid cmd %x from LTE RRC in CSP substate %d",
            cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.msg_hdr.id,rrc_csp_substate);
        break;
    }
  }
#endif

  return( next_substate );

} /* rrccsp_cell_sel_wait_sib_pending_hdlr */


/*===========================================================================

FUNCTION        rrccsp_cell_sel_wait_state_change_hdlr

DESCRIPTION     This is a handler for events received in
                RRCCSP_CELL_SEL_WT_STATE_CHANGE substate of the
                Cell Selection Procedure.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_cell_sel_wait_state_change_hdlr( rrc_cmd_type *cmd_ptr )
{

  rrc_csp_substate_e_type   next_substate;
  rrc_state_e_type          rrc_state;
  rrc_cmd_type *rrc_cmd_ptr = NULL;
  next_substate = RRCCSP_CELL_SEL_WT_STATE_CHANGE;

  switch( cmd_ptr->cmd_hdr.cmd_id )
  {
    case RRC_STATE_CHANGE_IND:
      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );

      /* Anyhow CSP is taken to No_CELL_SELECTED handler and so no need 
       * of keeping the PLMN search */
      rrccsp_cleanup_bplmn_state();

#ifdef FEATURE_WRLF_SYSTEM_SEL
      /* Reset the ue_in_conn_oos flag . */
      if(RRC_IS_CONN_MODE_OOS_SRCH_IN_PROGRESS())
      {
        WRRC_MSG0_HIGH("WRLF: Resetting ue_in_conn_oos flag");
        rrc_csp_int_data.ue_in_conn_oos = FALSE;
        if(RRC_MODE_INACTIVE == rrcmcm_get_rrc_mode()
          && (rrcmcm_get_substate() != RRCMCM_WAIT_START_CNF))
        {
          WRRC_MSG0_HIGH("WRLF: Freeing dynamic pointers");
          rrc_free_dynamic_ptrs();
        }
        if(!rrc_csp_int_data.oos_splmn_srch_tmr_expd)
        {
          rrctmr_stop_timer(RRCTMR_CONN_MODE_OOS_TIMER);
          rrc_csp_int_data.oos_splmn_srch_tmr_expd = TRUE;
        }

        if(rrc_svd_plmn_req_ptr!=NULL)
        {
          WRRC_MSG0_HIGH("WRLF: MPLMN in COOS: Handle saved PLMN_LIST_REQ");
          rrc_cmd_ptr = rrc_get_mm_cmd_buf();
          rrc_cmd_ptr->cmd_hdr.cmd_id = RRC_PLMN_LIST_REQ;

          WCDMA_MEMCPY(&rrc_cmd_ptr->cmd.plmn_list_req,
                       sizeof(rrc_plmn_list_req_type),
                       rrc_svd_plmn_req_ptr, 
                       sizeof(rrc_plmn_list_req_type));

          rrc_free(rrc_svd_plmn_req_ptr);

          rrc_put_mm_cmd(rrc_cmd_ptr);
        }
      }
#endif

      /* CSP will come to this state only when it knows there will a
       * a state change from Connected -> Disconnected,
       * no further checks are required here
       */
      /* Send NO_SERVICE to MM */
      rrc_ccm_update_with_cell_loss();
      rrc_csp_handle_no_available_freq();

      /* CSP goes back to NO_CELL_SELECTED state */
      next_substate = RRCCSP_NO_CELL_SELECTED;
      break;

    case RRC_SERVICE_REQ:
      rrc_state = rrc_get_state();
      if((rrc_state != RRC_STATE_DISCONNECTED)
#ifdef FEATURE_WRLF_SYSTEM_SEL
         && !RRC_IS_CONN_MODE_OOS_SRCH_IN_PROGRESS()
#endif
        )
      {
        WRRC_MSG1_ERROR("Service req in RRC state %d",rrc_state);
      }

      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
      
#ifdef FEATURE_WRLF_SYSTEM_SEL
      if(RRC_IS_CONN_MODE_OOS_SRCH_IN_PROGRESS())
      {
        rrctmr_start_timer(RRCTMR_WT_STATE_CHANGE_EF_TIMER,RRCTMR_WAIT_STATE_CHANGE_EF_IN_MS);
      }
#endif
      rrccsp_save_req(cmd_ptr);
      next_substate = RRCCSP_CELL_SEL_WT_STATE_CHANGE_PENDING;
      break;

    case RRC_PLMN_LIST_REQ:
      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );

      if(rrccsp_plmn_list_req_is_valid(&(cmd_ptr->cmd.plmn_list_req)))
      {
        rrccsp_save_req( cmd_ptr );
        next_substate = RRCCSP_CELL_SEL_WT_STATE_CHANGE_PENDING;
      }
      break;

    case RRC_BPLMN_GUARD_SRCH_TIMER_EXPIRED_IND:
      rrccsp_cleanup_bplmn_state();
      break;

    case RRC_BPLMN_SEARCH_ABORT_REQ:
      rrccsp_cleanup_bplmn_state();
      break;

    case RRC_BPLMN_SUSPEND_REQ:
      rrccsp_handle_passive_bplmn_suspend_req( cmd_ptr );        
      break;

    default:
      WRRC_MSG2_HIGH( "Cmd 0x%x not processed in CSP sstate %d",
                          cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);
      break;
  }

  return( next_substate );

} /* rrccsp_cell_sel_wait_state_change_hdlr */


/*===========================================================================

FUNCTION        rrccsp_cell_sel_wait_state_change_pending_hdlr

DESCRIPTION
                This is a handler for events received in
                RRCCSP_CELL_SEL_WT_STATE_CHANGE_PENDING substate of the
                Cell Selection Procedure.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_cell_sel_wait_state_change_pending_hdlr( rrc_cmd_type *cmd_ptr )
{

  rrc_csp_substate_e_type   next_substate;
  rrc_state_e_type          rrc_state;

  next_substate = RRCCSP_CELL_SEL_WT_STATE_CHANGE_PENDING;

  switch( cmd_ptr->cmd_hdr.cmd_id )
  {
    case RRC_STATE_CHANGE_IND:
      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
     rrctmr_stop_timer(RRCTMR_WT_STATE_CHANGE_EF_TIMER);
     if(((rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_CELL_FACH_SCAN) ||
         (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_CELL_PCH_SCAN) ||
         (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_URA_PCH_SCAN) ||
         (rrc_csp_int_data.curr_scan == RRC_CSP_OUT_OF_SERVICE_AREA_SCAN) ||
         (rrc_csp_int_data.curr_scan == RRC_CSP_OUT_OF_SERVICE_AREA_IN_CONNECTING_STATE_SCAN) ||
         (rrc_csp_int_data.curr_scan == RRC_CSP_INTER_FREQ_REDIRECTION_SCAN) ||
         (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN) ||
         (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN)) &&
          (cmd_ptr->cmd.state_change_ind.new_state == RRC_STATE_DISCONNECTED))
      {
        next_substate = rrccsp_pending_command_handler();
      }
#ifdef FEATURE_WRLF_SYSTEM_SEL
      /* If service request is received when waiting for state change to disconn, during connected 
          mode OOS search, send service_cnf back to NAS */
      else if((rrc_csp_int_data.curr_scan == RRC_CSP_CELL_SELECTION_SCAN) &&
         (rrc_csp_int_data.pending_type == RRC_CSP_SERVICE_REQ_PENDING) &&
         (cmd_ptr->cmd.state_change_ind.new_state == RRC_STATE_DISCONNECTED))
      {
        rrc_csp_int_data.curr_service_status     = MM_AS_NO_SERVICE;
        rrc_csp_int_data.curr_sel_plmn.plmn_type = RRC_GSM_MAP_PLMN_SEL;

        rrc_csp_send_mm_cmd(RRC_SERVICE_CNF,
                            rrc_csp_int_data.curr_service_status, 
                            &rrc_csp_int_data.curr_sel_plmn,
                            &rrc_csp_int_data.curr_acq_entry);
        /* Reset the ue_in_conn_oos flag if UE finds a suitable W cell during OOS search. */
        if(RRC_IS_CONN_MODE_OOS_SRCH_IN_PROGRESS())
        {
          WRRC_MSG0_HIGH("WRLF: Resetting ue_in_conn_oos flag");
          rrc_csp_int_data.ue_in_conn_oos = FALSE;
          if(RRC_MODE_INACTIVE == rrcmcm_get_rrc_mode()
            && (rrcmcm_get_substate() != RRCMCM_WAIT_START_CNF))
          {
            WRRC_MSG0_HIGH("WRLF: Freeing dynamic pointers");
            rrc_free_dynamic_ptrs();
          }
          if(!rrc_csp_int_data.oos_splmn_srch_tmr_expd)
          {
            rrctmr_stop_timer(RRCTMR_CONN_MODE_OOS_TIMER);
            rrc_csp_int_data.oos_splmn_srch_tmr_expd = TRUE;
          }
          if(rrc_svd_plmn_req_ptr != NULL) 
          {
            rrc_csp_send_mm_plmn_list_cnf_as_aborted(rrc_svd_plmn_req_ptr->trans_id);
            rrc_free(rrc_svd_plmn_req_ptr);
          }
        }
        next_substate = RRCCSP_NO_CELL_SELECTED;
      }
#endif
      else
      {
        WRRC_MSG2_ERROR("Unexp st change to %d, curr scan %d",cmd_ptr->cmd.state_change_ind.new_state,
                rrc_csp_int_data.curr_scan);
      }
      break;

    case RRC_SERVICE_REQ:
      rrc_state = rrc_get_state();
      if(rrc_state != RRC_STATE_DISCONNECTED)
      {
        WRRC_MSG1_ERROR("Service req in RRC state %d",rrc_state);
      }

      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
      rrccsp_save_req(cmd_ptr);
      next_substate = RRCCSP_CELL_SEL_WT_STATE_CHANGE_PENDING;
      break;

    case RRC_PLMN_LIST_REQ:
      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );

      if(rrccsp_plmn_list_req_is_valid(&(cmd_ptr->cmd.plmn_list_req)))
      {
        rrccsp_save_req( cmd_ptr );
        next_substate = RRCCSP_CELL_SEL_WT_STATE_CHANGE_PENDING;
      }
      break;

    case RRC_BPLMN_GUARD_SRCH_TIMER_EXPIRED_IND:
      rrccsp_cleanup_bplmn_state();
      break;

    case RRC_BPLMN_SEARCH_ABORT_REQ:
      rrccsp_cleanup_bplmn_state();
      break;

    case RRC_BPLMN_SUSPEND_REQ:
      rrccsp_handle_passive_bplmn_suspend_req( cmd_ptr );
      break;

    case RRCTMR_WT_STATE_CHANGE_EF_TIMER_EXPIRED_IND:
      ERR_FATAL("STATE_CHANGE_IND from LLC is not received for more than 5 second",0,0,0);
      break;

    default:
      WRRC_MSG2_HIGH( "Cmd 0x%x not processed in CSP sstate %d",
                          cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);
      break;
  }

  return( next_substate );

} /* rrccsp_cell_sel_wait_state_change_pending_hdlr */


/* =======================================================================
**      Function Definitions for substate: RRCCSP_SUIT_CELL_SEL_WT_SERV_S
** ======================================================================= */


/*===========================================================================

FUNCTION        rrccsp_suit_cell_sel_wait_serv_s_recvd

DESCRIPTION
                This function processes the Cell Selection Cnf from L1 when
                waiting for it during Suitable Cell Selection Process.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_suit_cell_sel_wait_serv_s_recvd( rrc_cmd_type *cmd_ptr )
{
  rrc_csp_substate_e_type   next_substate;
  rrc_plmn_identity_type    nas_plmn_id;
  boolean dual_mode_enabled = rrcmcm_is_dualmode_enabled();

  /* Indicates if we need to move on to the next freq */
  boolean  move_to_new_freq = FALSE;

  rrclog_wcdma_cell_selection_fail_event_type cell_sel_fail_evt;

  next_substate = RRCCSP_SUIT_CELL_SEL_WT_SERV_S;

  if(cmd_ptr->cmd.rrc_llc_cnf.cnf.cell_sel_cnf.evaluated == FALSE)
  {
#ifdef FEATURE_QSH_EVENT_METRIC
      wrrc_qsh_log_cell_resel_stats(CELL_SEL_FAIL ,WRRC_METRIC_UPDATE);
#endif
    /* The cell was not evaluated by L1. Move on to the next frequency */
     WRRC_MSG0_HIGH("S values not evaluated");

    /* If if there is a another cell on the same frequency,
     * try acquisition on that cell
     */
    if((rrc_csp_int_data.curr_scan != RRC_CSP_GSM_TO_WCDMA_CELL_RESELECTION_SCAN) &&
        (rrc_csp_int_data.curr_scan != RRC_CSP_GTOW_CC_ORDER_SCAN))
    {
      if(rrccsp_try_next_best_cell_if_available())
      {
        /* Start waiting for Acquisition Confirmation */
        next_substate = RRCCSP_CELL_SEL_WT_ACQ;
      }
      else
      {
        /* No more cells to try on the same frequency, move to the next freq */
        WRRC_MSG0_HIGH("No more cells, move to next freq");
        move_to_new_freq = TRUE;
        rrc_csp_int_data.curr_acq_count = 0;
      }
    }
    else
    {
      move_to_new_freq = TRUE;
      rrc_csp_int_data.curr_acq_count = 0;

      WRRC_MSG0_HIGH("Send reject to InterRAT");

      rrc_csp_int_data.interrat_reselect_failure_reason = RRC_WCDMA_CELL_NOT_EVALUATED;
    }
  }
  else  /* The cell was evaluated by L1 */
  {
    /* The cell was evaluated.Check to see if this meets the suitability criteria */
    if((cmd_ptr->cmd.rrc_llc_cnf.cnf.cell_sel_cnf.s_qual <= 0) ||
       (cmd_ptr->cmd.rrc_llc_cnf.cnf.cell_sel_cnf.s_rxlev <= 0))
    {
      WRRC_MSG0_HIGH("S criteria not met");
#ifdef FEATURE_QSH_EVENT_METRIC
	      wrrc_qsh_log_cell_resel_stats(CELL_SEL_FAIL,WRRC_METRIC_UPDATE);
#endif

      //EVENT: Event_Cell_Selection_Fail
      if (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_SELECTION_SCAN)
      {
        cell_sel_fail_evt.reason = RRC_CS_S_FAIL; 
        event_report_payload(EVENT_WCDMA_CELL_SELECTION_FAIL, sizeof(cell_sel_fail_evt),
                       (void *)&cell_sel_fail_evt);
      }

      /* If if there is a another cell on the same frequency,
       * try acquisition on that cell
       */
      if((rrc_csp_int_data.curr_scan != RRC_CSP_GSM_TO_WCDMA_CELL_RESELECTION_SCAN) &&
          (rrc_csp_int_data.curr_scan != RRC_CSP_GTOW_CC_ORDER_SCAN))
      {
        if(rrccsp_try_next_best_cell_if_available())
        {
          /* Start waiting for Acquisition Confirmation */
          next_substate = RRCCSP_CELL_SEL_WT_ACQ;
        }
        else
        {
          /* No more cells to try on the same frequency, move to the next freq */
          WRRC_MSG0_HIGH("No more cells, move to next freq");
          move_to_new_freq = TRUE;
          rrc_csp_int_data.curr_acq_count = 0;
        }
      }
      else
      {
        /* No more cells to try on the same frequency, move to the next freq */
        WRRC_MSG0_HIGH("No more cells. S crit not met, send reject to InterRAT");
        move_to_new_freq = TRUE;
        rrc_csp_int_data.curr_acq_count = 0;

        rrc_csp_int_data.interrat_reselect_failure_reason = RRC_WCDMA_CELL_QUALITY_FAILURE;
        /* The wcdma_cell_squalmin and wcdma_cell_srxlevmin values should have been set
         * while sending the CPHY_CELL_PARM_REQ to L1
         */
      }
    }
    else  /* The cell meets suitability criteria */
    {
      MSG_HIGH("S criteria is met. curr_scan %d, splmn %d, g_srch_done %d", rrc_csp_int_data.curr_scan, 
                rrc_csp_int_data.oos_splmn_srch_tmr_expd, rrc_csp_int_data.oos_gsm_srch_done);
      MSG_HIGH("bcch_nas_match = %d, nas_eplmn = %d, bcch_eplmn = %d", 
                rrc_bcch_and_nas_plmns_match(rrc_csp_int_data.curr_acq_entry.plmn_id,
                                             rrc_csp_int_data.curr_req_plmn.plmn_id),
                rrccsp_check_for_eplmn(
                 mmumts_convert_rrc_plmn_id_to_nas_plmn_id(rrc_csp_int_data.curr_req_plmn.plmn_id)),
                rrccsp_check_for_eplmn(
                 mmumts_convert_rrc_plmn_id_to_nas_plmn_id(rrc_csp_int_data.curr_acq_entry.plmn_id))
              );

      /* CSP should not proceed with cell selection and should release all
       * channels and go to idle if:
       *     Cell Selection is part of OOS_Scan 
       * and 30s timer has expired 
       * and atleast 1 GSM search is done
       * and the PLMN found is NOT ERPLMN                               
       */

#ifdef FEATURE_WRLF_SYSTEM_SEL
      if(RRC_IS_CONN_MODE_OOS_SRCH_IN_PROGRESS())
      {
        nas_plmn_id = rrc_csp_int_data.rlf_plmn_id;
      }
      else
#endif
      {
        nas_plmn_id = rrc_csp_int_data.curr_req_plmn.plmn_id;
      }
      if( ((  (rrc_csp_int_data.curr_scan == RRC_CSP_OUT_OF_SERVICE_AREA_SCAN)
          && (rrc_csp_int_data.oos_splmn_srch_tmr_expd)
          && (   ((dual_mode_enabled) && (rrc_csp_int_data.oos_gsm_srch_done))
              || (!dual_mode_enabled)
             )
             )
#ifdef FEATURE_WRLF_SYSTEM_SEL
           || (RRC_IS_CONN_MODE_OOS_SRCH_IN_PROGRESS() && rrc_csp_int_data.oos_splmn_srch_tmr_expd)
#endif
          )
          && (!rrc_bcch_and_nas_plmns_match(rrc_csp_int_data.curr_acq_entry.plmn_id, nas_plmn_id))
          && (!((rrccsp_check_for_eplmn(
                 mmumts_convert_rrc_plmn_id_to_nas_plmn_id(nas_plmn_id))) &&
                 (rrccsp_check_for_eplmn(
                 mmumts_convert_rrc_plmn_id_to_nas_plmn_id(rrc_csp_int_data.curr_acq_entry.plmn_id)))))
        )
      {    
        WRRC_MSG0_HIGH("OOS: S-crit met. Rel RRC Conn and go to idle");

        /* Release all channels and put lower layers to Idle  */
        rrc_csp_send_chan_release();
        rrc_csp_int_data.prev_network_select_mode = rrc_csp_int_data.network_select_mode;
#ifdef FEATURE_WRLF_SYSTEM_SEL
        if(!(RRC_IS_CONN_MODE_OOS_SRCH_IN_PROGRESS()))
#endif
        {
          WRRC_MSG0_HIGH("OOS: Change type of PLMN Selection to ANY so that UE camps on an acceptable cell");
          rrc_csp_int_data.curr_req_plmn.plmn_type = RRC_GSM_MAP_ANY_PLMN_REQ;
          rrc_csp_int_data.network_select_mode     = SYS_NETWORK_SELECTION_MODE_LIMITED_ROUTINE_ACQUISITION;
          rrc_csp_int_data.curr_type_acq           = RRC_CSP_ANY_PLMN;
        }

        next_substate = rrc_csp_start_sel_leaving_conn_mode();
      }
      else
      {
        /* We have selected a Suitable Cell. Send a CELL_CHANGE_REQ to Cell Change Manager
         * and proceed directly to start waiting for CELL_CHANGE_CNF.
         */

        /* Send a CELL_CHANGE_REQ for Cell Change Manager */
        if(rrc_csp_send_ccm_cmd(RRC_CELL_CHANGE_REQ,
                                RRC_NEW_CELL_SELECTED,
                                &rrc_csp_int_data.curr_acq_entry)
           ==FAILURE)
        {
          /* Since we couldn't send cmd to CCM, ERR_FATAL here */
          ERR_FATAL("Could not send Int Cmd %d in CSP substate %d",
                                 RRC_CELL_CHANGE_REQ, rrc_csp_substate, 0);
        }
        else /* Cell Change Req successfully sent */
        {
          next_substate = RRCCSP_SUIT_CELL_SEL_WT_CAMP;
        }
      }
    } /* The cell meets suitability criteria */
  } /* The cell was evaluated by L1 */

  if(move_to_new_freq)
  {
    if(rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_CELL_RESELECTION_SCAN)
    {
      /* Send CHANGE_MODE_REQ (to Inactive) to MCM and wait for the CHANGE_MODE_CNF */
      rrccsp_send_mode_change_req_to_mcm(RRC_MODE_INACTIVE);
      next_substate = RRCCSP_WT_STOP_MODE_CHANGE_CNF;
    }
    else if(rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_CC_ORDER_SCAN)
    {
      /* Send Camp failure to CHO */
      rrccsp_send_camp_cnf_to_cho(FAILURE);
      next_substate = RRCCSP_NO_CELL_SELECTED;
    }
    else if(rrc_csp_int_data.curr_scan == RRC_CSP_INTER_FREQ_REDIRECTION_SCAN)
    {
      WRRC_MSG1_HIGH("S-criteria not met on freq %d during freq redirect scan",
                              rrc_csp_int_data.curr_acq_entry.freq);

      /* Release BCH and put lower layers to Idle before sending another
       * Acquisition Req or a Frequency Scan Req.
       */
      rrc_csp_send_bch_release(FALSE);
      next_substate = rrccsp_handle_failure_during_freq_redirection();
    }
    else
    {
      WRRC_MSG0_HIGH("Continuing with cell selection");
      next_substate = rrc_csp_release_bch_and_continue_cell_selection();
    }
  }

  return(next_substate);

} /* rrccsp_suit_cell_sel_wait_serv_s_recvd */


/* =======================================================================
**      Function Definitions for substate: RRCCSP_SUIT_CELL_SEL_WT_CAMP
** ======================================================================= */


/*===========================================================================

FUNCTION        RRCCSP_SUIT_CELL_SEL_WAIT_CAMP_CELL_CHANGE

DESCRIPTION
                This function processes Cell Change CNF while waiting in
                RRCCSP_SUIT_CELL_SEL_WT_CAMP substate.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_suit_cell_sel_wait_camp_cell_change( rrc_cmd_type *cmd_ptr )
{
  rrc_csp_substate_e_type   next_substate =  RRCCSP_SUIT_CELL_SEL_WT_CAMP;

  rrc_to_mm_sink_e_type   mm_cmd_id;

  rrclog_wcdma_cell_selected_event_type wcdma_cell_selected_event;

  rrc_state_e_type        rrc_state = rrc_get_state();

  if(cmd_ptr->cmd.cell_change_cnf.req_proc_id != RRC_PROCEDURE_CSP)
  {
    WRRC_MSG1_ERROR("Cell Change CNF for proc rrc_proc_e_type_value%d sent to CSP",
                    cmd_ptr->cmd.cell_change_cnf.req_proc_id);
    return(next_substate);
  }

  /* The command belongs to CSP - dissect it */
  if(cmd_ptr->cmd.cell_change_cnf.cell_change_status != RRC_CELL_CHANGE_SUCCESS)
  {
    if(rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_CELL_RESELECTION_SCAN)
    {
      rrc_csp_int_data.interrat_reselect_failure_reason = RRC_WCDMA_CELL_CHANGE_FAILURE;
      /* Send CHANGE_MODE_REQ (to Inactive) to MCM and wait for the CHANGE_MODE_CNF */
      rrccsp_send_mode_change_req_to_mcm(RRC_MODE_INACTIVE);
      next_substate = RRCCSP_WT_STOP_MODE_CHANGE_CNF;
    }
    else if(rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_CC_ORDER_SCAN)
    {
      rrc_csp_int_data.interrat_reselect_failure_reason = RRC_WCDMA_CELL_CHANGE_FAILURE;
      /* Send Camp failure to CHO */
      rrccsp_send_camp_cnf_to_cho(FAILURE);
      next_substate = RRCCSP_NO_CELL_SELECTED;
    }
    else if(rrc_csp_int_data.curr_scan == RRC_CSP_INTER_FREQ_REDIRECTION_SCAN)
    {
      WRRC_MSG1_HIGH("Cell Change failure on freq %d during freq redirect scan",
                              rrc_csp_int_data.curr_acq_entry.freq);

      /* Release BCH, tr & phy channels and put lower layers to Idle before sending another
       * Acquisition Req or a Frequency Scan Req.
       */
      rrc_csp_send_bch_release(FALSE);
      rrc_csp_send_tr_phy_chl_release();
      next_substate = rrccsp_handle_failure_during_freq_redirection();
    }
    else
    {
      /* Since the Cell Change has not been successful, treat this as Failure */
      /* TBD: Other status like a different PLMN/Cell ID could be handled
       * differently from failure but that is for later.
       */

      /* Go back to Cell Selection
       * Controller to get the next cell.
       */
      WRRC_MSG0_HIGH("Cell change failed, continue cell sel");
      next_substate = rrc_csp_release_chls_and_continue_cell_selection();
    }
  } /* Cell Change CNF does NOT have a Success status */
  else  /* Cell Change CNF has a Success status */
  {
    /* Successfully Camped on a Cell Now */
    /* Update the Internal data with Selected PLMN, Send a RRC_SERVICE_CNF to
     * MM and move on to the Camped substate
     */

    /* Fill in the freq and scrambling code information and report
     * the EVENT_WCDMA_CELL_SELECTED event
     */
    wcdma_cell_selected_event.freq = rrc_csp_int_data.curr_acq_entry.freq;
    wcdma_cell_selected_event.scr_code = (uint16)(rrc_csp_int_data.curr_acq_entry.scr_code/16);
#ifdef FEATURE_FEMTO_CSG
    wcdma_cell_selected_event.csg_id = rrc_csp_int_data.curr_acq_entry.csg_id;
#endif
    event_report_payload(EVENT_WCDMA_CELL_SELECTED, sizeof(wcdma_cell_selected_event),
                   (void *)&wcdma_cell_selected_event);
    if(rrc_ifreq_rdr_in_prgrs == TRUE)
    {
        rrclog_wcdma_to_wcdma_redir_end_event_type wtow_redirect_event;
        wtow_redirect_event.status = WTOW_SUCCESS;
        event_report_payload(EVENT_WCDMA_TO_WCDMA_REDIRECTION_END, sizeof(wtow_redirect_event),
                 (void *)&wtow_redirect_event);
        rrc_ifreq_rdr_in_prgrs = FALSE;
    }

    WRRC_MSG1_HIGH("Camped on suitable cellID %d",
                 rrc_csp_int_data.curr_acq_entry.cell_id);

    rrc_csp_int_data.curr_sel_plmn.plmn_type = RRC_GSM_MAP_PLMN_SEL;
    rrc_csp_int_data.curr_sel_plmn.plmn_id = rrc_csp_int_data.curr_acq_entry.
                                             plmn_id;

    /* Save the last suit cell frequency UE camps on. This frequency is then 
     * added to the fine scan list when UE goes OOS in Idle mode, since the 
     * probability of UE finding the service on this frequency is higher.
     */
    rrc_csp_int_data.last_camped_freq_in_idle_mode = rrc_csp_int_data.curr_acq_entry.freq;

    /* Update the current requested PLMN with the camped PLMN */
    rrc_csp_int_data.curr_req_plmn.plmn_id  = rrc_csp_int_data.curr_acq_entry.plmn_id;

    rrc_csp_int_data.curr_service_status = MM_AS_SERVICE_AVAILABLE;

    /* Update UI with full service when camped on a cell after T314 or T315 timer
     * expiry, before sending SERVICE_IND to NAS 
     */
#ifdef FEATURE_OOSC_SERVICE_STATUS_UI_UPDATE
    if((rrc_csp_int_data.curr_scan == RRC_CSP_LEAVING_CONN_MODE_SCAN)&&
              (rrc_csp_int_data.prev_curr_scan == RRC_CSP_OUT_OF_SERVICE_AREA_SCAN))
    {
      WRRC_MSG0_HIGH("SVC_ST: Update UI w/ full svc");
      rrc_csp_send_svc_status_to_mm(SYS_SRV_STATUS_SRV, SYS_RAT_UMTS_RADIO_ACCESS, rrc_csp_int_data.oosc_l1_rssi);
    }
#endif

#ifdef FEATURE_UMTS_1X_HANDOVER_UMTSMSM
    #error code not present
#endif
    /* Here send a DRX command if in DISCONNECTED, CELL_PCH or URA_PCH state */
    if(  ((rrc_state == RRC_STATE_DISCONNECTED)
#ifdef FEATURE_WCDMA_CSFB_CALL_OPT
        /* Skip sending during CSFB call bceause error indication will be sent
           since WL1 will not be in PCH state */
         && !((WCDMA_RRC_IDLE_FEATURES(RRC_CSFB_CALL_TIMELINE_OPT)) && rrc_csfb_call_status)
#endif
         )||
         (rrc_state == RRC_STATE_CELL_PCH) ||
         (rrc_state == RRC_STATE_URA_PCH)
       )
    {
      rrc_csp_send_l1_drx_req();
    }

#ifdef FEATURE_EOOS
    #error code not present
#endif

#ifdef FEATURE_WCDMA_DEFERRED_SIB11_12_READING
#ifdef FEATURE_WCDMA_CSFB_CALL_OPT
    /* Call is imminent so skip posting UPATE SIBS */
    if(!(WCDMA_RRC_IDLE_FEATURES(RRC_CSFB_CALL_TIMELINE_OPT) && rrc_csfb_call_status))
#endif
    {
   WRRC_MSG0_HIGH("Deferred SIB: UPDATE_SIBS activated");
   rrcsib_update_sib_for_deferred_sib();
    }
#endif

    if(rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_CELL_RESELECTION_SCAN)
    {
      rrc_csp_int_data.interrat_reselect_failure_reason = RRC_WCDMA_NONE;
#ifdef FEATURE_GAN_3G_ROVE_OUT_ONLY
      #error code not present
#endif
      {
        /* Send ACT_IND to MM */
        rrc_csp_send_mm_act_ind();
        next_substate = RRCCSP_SUIT_CELL_WT_ACTIVATION_RSP;
      }
    }
    else if(rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_REDIRECTION_SCAN)
    {
      /* Send ACT_IND to MM */
      rrc_csp_send_mm_act_ind();
      next_substate = RRCCSP_SUIT_CELL_WT_ACTIVATION_RSP;
    }
#ifdef FEATURE_GAN_3G_ROVE_OUT_ONLY
    #error code not present
#endif
    else if(rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_CC_ORDER_SCAN)
    {
      /* Send Camp Success to CHO */
      rrccsp_send_camp_cnf_to_cho(SUCCESS);
      next_substate = RRCCSP_CAMPED_SUIT_CELL;
    }
    else if(rrc_csp_int_data.curr_scan == RRC_CSP_INTER_FREQ_REDIRECTION_SCAN)
    {
      /* Camped on redirected frequency - return success */
      if(rrc_csp_int_data.curr_acq_entry.freq == rrc_csp_int_data.redirected_freq)
      {
        if(rrc_csp_int_data.curr_acq_entry.scr_code == rrc_csp_int_data.redirected_psc*16)
        {
          WRRC_MSG2_HIGH("Camped on redirected freq %d and redirected psc %d. Sending REDIRECT_SUCCESS to RCE",
                                  rrc_csp_int_data.curr_acq_entry.freq, rrc_csp_int_data.redirected_psc);
          rrccsp_send_rce_redirect_cnf(RRC_REDIRECT_SUCCESS, RRC_CAMPED_ON_REDIRECTED_CELL);
        }
        else
        {
          WRRC_MSG1_HIGH("Camped on redirected freq %d. Sending REDIRECT_SUCCESS to RCE",
                                  rrc_csp_int_data.curr_acq_entry.freq);
          rrccsp_send_rce_redirect_cnf(RRC_REDIRECT_SUCCESS, RRC_CAMPED_ON_REDIRECTED_FREQ);
        }
      }
      /* Not camped on redirected frequency or last camped frequency */
      else if(rrc_csp_int_data.curr_acq_entry.freq != rrc_csp_int_data.last_camped_freq)
      {
        WRRC_MSG1_HIGH("Camped on a diff freq %d. Sending REDIRECT_FAILURE to RCE",
                                rrc_csp_int_data.curr_acq_entry.freq);
        rrccsp_send_rce_redirect_cnf(RRC_REDIRECT_FAILURE, RRC_CAMPED_ON_DIFFERENT_FREQ);
      }
      /* Camped on last camped frequency */
      else
      {
        WRRC_MSG1_HIGH("Camped on last camped freq %d. Sending REDIRECT_FAILURE to RCE",
                                          rrc_csp_int_data.curr_acq_entry.freq);
        rrccsp_send_rce_redirect_cnf(RRC_REDIRECT_FAILURE, RRC_CAMPED_ON_ORIGINAL_FREQ);
      }

      if(rrc_csp_cmd_to_mm_needed(&mm_cmd_id,
                            rrc_csp_int_data.last_mm_primitive,
                            rrc_csp_int_data.curr_service_status)
         == TRUE)
      {
        rrc_csp_send_mm_cmd(mm_cmd_id,
                            rrc_csp_int_data.curr_service_status,
                            &rrc_csp_int_data.curr_sel_plmn,
                            &rrc_csp_int_data.curr_acq_entry);
      }
      else
      {
           /* If SIB3 modification does have DSAC information is present, send service indication
              to NAS always instead of not depending of the current RRC state. i.e. even the function
              rrc_csp_cmd_to_mm_needed() returns false
           */
            if(rrc_csp_int_data.is_curr_dsac_info_valid == TRUE)
            {
              mm_cmd_id =  RRC_SERVICE_IND_FROM_OTA_MSG;
              rrc_csp_send_mm_cmd(mm_cmd_id,
                           rrc_csp_int_data.curr_service_status,
                           &rrc_csp_int_data.curr_sel_plmn,
                           &rrc_csp_int_data.curr_acq_entry);
            }              
            else if(mm_cmd_id == RRC_SERVICE_IND)
            {
              mm_cmd_id =  RRC_SERVICE_IND_FROM_OTA_MSG;
              rrc_csp_send_mm_cmd(mm_cmd_id,
                           rrc_csp_int_data.curr_service_status,
                           &rrc_csp_int_data.curr_sel_plmn,
                           &rrc_csp_int_data.curr_acq_entry);
            }
        }

      next_substate = RRCCSP_CAMPED_SUIT_CELL;
    } /* Inter frequency redirection scan */
    else
    {
      if(rrc_csp_cmd_to_mm_needed(&mm_cmd_id,
                                  rrc_csp_int_data.last_mm_primitive,
                                  rrc_csp_int_data.curr_service_status)
         == TRUE)
      {
        rrc_csp_send_mm_cmd(mm_cmd_id,
                               rrc_csp_int_data.curr_service_status,
                               &rrc_csp_int_data.curr_sel_plmn,
                               &rrc_csp_int_data.curr_acq_entry);
      }
      else
      {
           /* If SIB3 modification does have DSAC information is present, send service indication
              to NAS always instead of not depending of the current RRC state. i.e. even the function
              rrc_csp_cmd_to_mm_needed() returns false
           */
            if(rrc_csp_int_data.is_curr_dsac_info_valid == TRUE)
            {
              mm_cmd_id =  RRC_SERVICE_IND_FROM_OTA_MSG;
              rrc_csp_send_mm_cmd(mm_cmd_id,
                           rrc_csp_int_data.curr_service_status,
                           &rrc_csp_int_data.curr_sel_plmn,
                           &rrc_csp_int_data.curr_acq_entry);
            }
            else if(mm_cmd_id == RRC_SERVICE_IND)
            {
              mm_cmd_id =  RRC_SERVICE_IND_FROM_OTA_MSG;
              rrc_csp_send_mm_cmd(mm_cmd_id,
                           rrc_csp_int_data.curr_service_status,
                           &rrc_csp_int_data.curr_sel_plmn,
                           &rrc_csp_int_data.curr_acq_entry);
            }
        }   
      /* Stop cell selection timer if we are in DCH->FACH scan */
      if(rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_CELL_FACH_SCAN)
      {
        rrctmr_stop_timer(RRCTMR_DCH_FACH_CELL_SELECTION_TIMER);
      }
      else if((rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_CELL_PCH_SCAN) ||
              (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_URA_PCH_SCAN))
      {
        rrctmr_stop_timer(RRCTMR_DCH_PCH_CELL_SELECTION_TIMER);
      }
      else if((rrc_csp_int_data.curr_scan == RRC_CSP_CELL_FACH_TO_CELL_FACH_SCAN) ||
              (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_FACH_TO_CELL_PCH_SCAN) ||
              (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_FACH_TO_URA_PCH_SCAN))
      {
        rrctmr_stop_timer(RRCTMR_FACH_TO_FACH_PCH_CELL_SELECTION_TIMER);
      }
      else if (rrc_csp_int_data.curr_scan == RRC_CSP_OUT_OF_SERVICE_AREA_SCAN)
      {
        if( !rrc_csp_int_data.oos_splmn_srch_tmr_expd)
        {
          rrctmr_stop_timer(RRCTMR_CONN_MODE_OOS_TIMER);
          rrc_csp_int_data.oos_splmn_srch_tmr_expd = TRUE;
        }
      /* Stop the initial Tmins timer if it is running as UE has found service 
       */
        if(!rrc_csp_int_data.oos_initial_no_deep_sleep_tmr_expd)
        {
          rrctmr_stop_timer(RRCTMR_CONN_MODE_OOS_INITIAL_NO_DS_TIMER);
          rrc_csp_int_data.oos_initial_no_deep_sleep_tmr_expd = TRUE;
        }

#ifdef FEATURE_OOSC_SERVICE_STATUS_UI_UPDATE
        WRRC_MSG0_HIGH("SVC_ST: Update UI w/ full svc");
        rrc_csp_send_svc_status_to_mm(SYS_SRV_STATUS_SRV, SYS_RAT_UMTS_RADIO_ACCESS, rrc_csp_int_data.oosc_l1_rssi);
#endif
      }

      next_substate = RRCCSP_CAMPED_SUIT_CELL;
    }

    rrc_csp_int_data.fach_tx_dest_state = RRC_STATE_MAX;

    #ifdef FEATURE_UMTS_ACQ_CHNL_INFO_SHARING
    /* Clear RRC acq channel db to remove any stale information */
    rrc_clear_acq_chnl_info();
    /* Clear RR acq channel db to remove any stale information */
    rr_rrc_clear_acq_chnl_info_internal();
    #endif


    if(rrc_csp_int_data.curr_scan == RRC_CSP_LEAVING_CONN_MODE_SCAN)
    {
      WRRC_MSG0_HIGH("CPHY_UPD_OTA_PARMS_IND may be due to RCR");
      if(rrc_high_mobility_ind_in_rcr == TRUE)
      {
        rrcrb_send_upd_ota_parms_ind(RRC_PROCEDURE_CSP, CPHY_HIGH_MOBILITY_INCL);
        rrc_high_mobility_ind_in_rcr = FALSE;
      }
    }

    /* Added as a fix for CR # 128660.
     * Curr_scan should not be reset if it is GtoW reselection scan. Because we still need to wait
     * for ACTIVAION_RSP from NAS for the RRC_ACTIVATION_IND and NAS can also ignore RRC_ACTIVATION_IND 
     * if it had already sent a PLMN_LIST_REQ etc to RR in which case we end up loosing the current scan
     * and will not respond to RR for RESELECTION_ABORT_REQ.
     */

    if((rrc_csp_int_data.curr_scan != RRC_CSP_GSM_TO_WCDMA_CELL_RESELECTION_SCAN) &&
       (rrc_csp_int_data.curr_scan != RRC_CSP_GSM_TO_WCDMA_REDIRECTION_SCAN) && 
        (rrc_csp_int_data.curr_scan != RRC_CSP_GAN_TO_WCDMA_RESELECTION_SCAN)&&
        (rrc_csp_int_data.curr_scan != RRC_CSP_GO_TO_IDLE_DETACHED_SCAN))
    {
      WRRC_MSG0_HIGH("Resetting Current Scan to Cell Selection Scan");
      rrc_csp_int_data.curr_scan = RRC_CSP_CELL_SELECTION_SCAN;
    }

#ifdef FEATURE_LTE_TO_WCDMA
    if((RRC_CSP_GSM_TO_WCDMA_REDIRECTION_SCAN == rrc_csp_int_data.curr_scan) &&
        (RRC_CSP_INTERRAT_LTE == rrc_csp_int_data.interrat_type))
    {
      rrctmr_stop_timer(RRCTMR_LTE_TO_WCDMA_REDIR_SRCH_TIMER);
#ifdef FEATURE_3GPP_CSFB
      /*Clear the SIB container list, UE camped on W for LTOW redirection scan*/
      rrccsp_free_sib_cont_list();
      if(rrc_csp_int_data.sib_read_csfb_active && !rrc_csfb_call_status)
      {
#ifdef FEATURE_WCDMA_CSFB_CALL_OPT
        /* Trigger OOS if CSFB call status is reset before connection establishment */
        /* We have not setup PCH channel since its a CSFB call so trigger OOS for now */
        if(WCDMA_RRC_IDLE_FEATURES(RRC_CSFB_CALL_TIMELINE_OPT))
        {
          next_substate = rrc_csp_start_sel_out_of_service_area_in_idle_state();
        }
        else
#endif
        {
          WRRC_MSG0_HIGH("CSFB: CSFB call cancelled, Read the SIBs");
          rrccsp_post_update_sibs_ind(RRCSIB_CSFB_CALL_CANCL);
        }
        rrc_csp_int_data.sib_read_csfb_active = FALSE;
      }
#endif
    }
#endif

#ifdef FEATURE_GAN
    #error code not present
#endif

  } /* Cell Change CNF has a Success status */
  
  return(next_substate);
} /* rrccsp_suit_cell_sel_wait_camp_cell_change */


/* =======================================================================
**      Function Definitions for substate: RRCCSP_ACCEPT_CELL_SEL_WT_S
** ======================================================================= */

/*===========================================================================

FUNCTION        rrccsp_accept_cell_sel_wait_s_recvd

DESCRIPTION
                This function processes the Cell Selection Cnf from L1 when
                waiting for it during Acceptable Cell Selection Process.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_accept_cell_sel_wait_s_recvd( rrc_cmd_type *cmd_ptr )
{
  rrc_csp_substate_e_type   next_substate;

  boolean dual_mode_enabled = rrcmcm_is_dualmode_enabled();
#ifdef FEATURE_WRLF_SYSTEM_SEL
  rrc_plmn_identity_type    nas_plmn_id;
#endif

  /* Indicates if we need to move on to the next freq */
  boolean  move_to_new_freq = FALSE;

  next_substate = RRCCSP_ACCEPT_CELL_SEL_WT_S;

  if(cmd_ptr->cmd.rrc_llc_cnf.cnf.cell_sel_cnf.evaluated == FALSE)
  {
    /* The cell was not evaluated by L1. Move on to the next frequency */
    WRRC_MSG0_HIGH("S value not evaluated");
#ifdef FEATURE_QSH_EVENT_METRIC
    wrrc_qsh_log_cell_resel_stats(CELL_SEL_FAIL,WRRC_METRIC_UPDATE);
#endif

    /* If if there is a another cell on the same frequency,
     * try acquisition on that cell
     */
    if((rrc_csp_int_data.curr_scan != RRC_CSP_GSM_TO_WCDMA_CELL_RESELECTION_SCAN) &&
         (rrc_csp_int_data.curr_scan != RRC_CSP_GTOW_CC_ORDER_SCAN))
    {
      if(rrccsp_try_next_best_cell_if_available())
      {
        /* Start waiting for Acquisition Confirmation */
        next_substate = RRCCSP_CELL_SEL_WT_ACQ;
      }
      else
      {
        /* No more cells to try on the same frequency, move to the next freq */
        WRRC_MSG0_HIGH("No more cells, move to next freq");
        move_to_new_freq = TRUE;
        rrc_csp_int_data.curr_acq_count = 0;
      }
    }
    else
    {
      move_to_new_freq = TRUE;

      WRRC_MSG0_HIGH("Send reject to InterRAT");

      rrc_csp_int_data.interrat_reselect_failure_reason = RRC_WCDMA_CELL_NOT_EVALUATED;

    }
  }
  else  /* The cell was evaluated by L1 */
  {
    /* The cell was evaluated.Check to see if this meets the suitability criteria */
    if((cmd_ptr->cmd.rrc_llc_cnf.cnf.cell_sel_cnf.s_qual <= 0) ||
       (cmd_ptr->cmd.rrc_llc_cnf.cnf.cell_sel_cnf.s_rxlev <= 0))
    {
      WRRC_MSG0_HIGH("S criteria not met");
#ifdef FEATURE_QSH_EVENT_METRIC
	      wrrc_qsh_log_cell_resel_stats(CELL_SEL_FAIL,WRRC_METRIC_UPDATE);
#endif

      /* If if there is a another cell on the same frequency,
       * try acquisition on that cell
       */
      if((rrc_csp_int_data.curr_scan != RRC_CSP_GSM_TO_WCDMA_CELL_RESELECTION_SCAN) &&
           (rrc_csp_int_data.curr_scan != RRC_CSP_GTOW_CC_ORDER_SCAN))
      {
        if(rrccsp_try_next_best_cell_if_available())
        {
          /* Start waiting for Acquisition Confirmation */
          next_substate = RRCCSP_CELL_SEL_WT_ACQ;
        }
        else
        {
          /* No more cells to try on the same frequency, move to the next freq */
          WRRC_MSG0_HIGH("No more cells, move to next freq");
          move_to_new_freq = TRUE;
          rrc_csp_int_data.curr_acq_count = 0;
        }
      }
      else
      {
        /* No more cells to try on the same frequency, move to the next freq */
        WRRC_MSG0_HIGH("No more cells. S crit not met, send reject to InterRAT");
        move_to_new_freq = TRUE;
        rrc_csp_int_data.curr_acq_count = 0;

        rrc_csp_int_data.interrat_reselect_failure_reason = RRC_WCDMA_CELL_QUALITY_FAILURE;
        /* The wcdma_cell_squalmin and wcdma_cell_srxlevmin values should have been set
         * while sending the CPHY_CELL_PARM_REQ to L1
         */
      }
    }
    else  /* The cell meets suitability criteria */
    {
      MSG_HIGH("S criteria is met. curr_scan %d, splmn %d, g_srch_done %d", rrc_csp_int_data.curr_scan, 
                rrc_csp_int_data.oos_splmn_srch_tmr_expd, rrc_csp_int_data.oos_gsm_srch_done);

      MSG_HIGH("bcch_nas_match = %d, nas_eplmn = %d, bcch_eplmn = %d", 
                rrc_bcch_and_nas_plmns_match(rrc_csp_int_data.curr_acq_entry.plmn_id,
                                             rrc_csp_int_data.curr_req_plmn.plmn_id),
                rrccsp_check_for_eplmn(
                 mmumts_convert_rrc_plmn_id_to_nas_plmn_id(rrc_csp_int_data.curr_req_plmn.plmn_id)),
                rrccsp_check_for_eplmn(
                 mmumts_convert_rrc_plmn_id_to_nas_plmn_id(rrc_csp_int_data.curr_acq_entry.plmn_id))
              );

      /* CSP should not proceed with cell selection and should release all
       * channels and go to idle if:
       *     Cell Selection is part of OOS_Scan 
       * and 30s timer has expired 
       * and atleast 1 GSM search is done
       */

#ifdef FEATURE_WRLF_SYSTEM_SEL
      if(RRC_IS_CONN_MODE_OOS_SRCH_IN_PROGRESS())
      {
        nas_plmn_id = rrc_csp_int_data.rlf_plmn_id;
      }
#endif

      if(  (  (rrc_csp_int_data.curr_scan == RRC_CSP_OUT_OF_SERVICE_AREA_SCAN)
          && (rrc_csp_int_data.oos_splmn_srch_tmr_expd)
          && (   ((dual_mode_enabled) && (rrc_csp_int_data.oos_gsm_srch_done))
              || (!dual_mode_enabled)
             )
        )
#ifdef FEATURE_WRLF_SYSTEM_SEL
           || (RRC_IS_CONN_MODE_OOS_SRCH_IN_PROGRESS() && 
                 (((rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED)
                      && rrc_csp_int_data.service_req_cause == RRC_MO_CS_CALL) ||
                      (rrc_csp_int_data.oos_splmn_srch_tmr_expd 
                      && (!rrc_bcch_and_nas_plmns_match(rrc_csp_int_data.curr_acq_entry.plmn_id, nas_plmn_id))
                      && (!((rrccsp_check_for_eplmn(
                             mmumts_convert_rrc_plmn_id_to_nas_plmn_id(nas_plmn_id))) &&
                             (rrccsp_check_for_eplmn(
                             mmumts_convert_rrc_plmn_id_to_nas_plmn_id(rrc_csp_int_data.curr_acq_entry.plmn_id)))))
                       )
               ))
#endif
        )
      {    
        WRRC_MSG0_HIGH("OOS: S-crit met. Rel RRC Conn and go to idle");

        /* Release all channels and put lower layers to Idle  */
        rrc_csp_send_chan_release();
        rrc_csp_int_data.prev_network_select_mode = rrc_csp_int_data.network_select_mode;
        WRRC_MSG0_HIGH("OOS: Change type of PLMN Selection to ANY so that UE camps on an acceptable cell");
        rrc_csp_int_data.curr_req_plmn.plmn_type = RRC_GSM_MAP_ANY_PLMN_REQ;
        rrc_csp_int_data.network_select_mode     = SYS_NETWORK_SELECTION_MODE_LIMITED_ROUTINE_ACQUISITION;
        rrc_csp_int_data.curr_type_acq           = RRC_CSP_ANY_PLMN;

        next_substate = rrc_csp_start_sel_leaving_conn_mode();
      }
      else
      {
        /* Send a CELL_CHANGE_REQ for Cell Change Manager */
        if(rrc_csp_send_ccm_cmd(RRC_CELL_CHANGE_REQ,
                                RRC_NEW_CELL_SELECTED,
                                &rrc_csp_int_data.curr_acq_entry)
           ==FAILURE)
        {
          /* Since we couldn't send cmd to CCM, ERR_FATAL here */
          ERR_FATAL("Could not send Int Cmd %d in CSP substate %d",
                                 RRC_CELL_CHANGE_REQ, rrc_csp_substate, 0);
        }
        else /* Cell Change Req successfully sent */
        {
          next_substate = RRCCSP_ACCEPT_CELL_SEL_WT_CAMP;
        }

      }

    } /* The cell meets suitability criteria */

  } /* The cell was evaluated by L1 */

  if(move_to_new_freq)
  {
    if(rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_CELL_RESELECTION_SCAN)
    {
      /* Send CHANGE_MODE_REQ (to Inactive) to MCM and wait for the CHANGE_MODE_CNF */
      rrccsp_send_mode_change_req_to_mcm(RRC_MODE_INACTIVE);
      next_substate = RRCCSP_WT_STOP_MODE_CHANGE_CNF;
    }
    else if(rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_CC_ORDER_SCAN)
    {
      /* Send Camping failure to CHO */
      rrccsp_send_camp_cnf_to_cho(FAILURE);
      next_substate = RRCCSP_NO_CELL_SELECTED;
    }
    else if(rrc_csp_int_data.curr_scan == RRC_CSP_INTER_FREQ_REDIRECTION_SCAN)
    {
      WRRC_MSG1_HIGH("S-criteria not met on freq %d during freq redirect scan",
                              rrc_csp_int_data.curr_acq_entry.freq);

      /* Release BCH and put lower layers to Idle before sending another
       * Acquisition Req or a Frequency Scan Req.
       */
      rrc_csp_send_bch_release(FALSE);
      next_substate = rrccsp_handle_failure_during_freq_redirection();
    }
    else
    {
      WRRC_MSG0_HIGH("Continuing with cell selection");
      next_substate = rrc_csp_release_bch_and_continue_cell_selection();
    }
  }

  return(next_substate);

} /* rrccsp_accept_cell_sel_wait_s_recvd */


/* =======================================================================
**      Function Definitions for substate: RRCCSP_ACCEPT_CELL_SEL_WT_CAMP
** ======================================================================= */


/*===========================================================================

FUNCTION        RRCCSP_ACCEPT_CELL_SEL_WAIT_CAMP_CELL_CHANGE

DESCRIPTION
                This function processes Cell Change CNF while waiting in
                RRCCSP_ACCEPT_CELL_SEL_WT_CAMP substate.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_accept_cell_sel_wait_camp_cell_change( rrc_cmd_type *cmd_ptr )
{
  rrc_csp_substate_e_type   next_substate =  RRCCSP_ACCEPT_CELL_SEL_WT_CAMP;

  rrc_to_mm_sink_e_type  mm_cmd_id;
  rrclog_wcdma_cell_selected_event_type wcdma_cell_selected_event;
  rrc_state_e_type       rrc_state = rrc_get_state();

  if(cmd_ptr->cmd.cell_change_cnf.req_proc_id != RRC_PROCEDURE_CSP)
  {
    WRRC_MSG1_ERROR("Cell Change CNF for proc rrc_proc_e_type_value%d sent to CSP",
                    cmd_ptr->cmd.cell_change_cnf.req_proc_id);
    return(next_substate);
  }

  /* The command belongs to CSP - dissect it */
  if(cmd_ptr->cmd.cell_change_cnf.cell_change_status != RRC_CELL_CHANGE_SUCCESS)
  {
    if(rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_CELL_RESELECTION_SCAN)
    {
      /* Send CHANGE_MODE_REQ (to Inactive) to MCM and wait for the CHANGE_MODE_CNF */
      rrccsp_send_mode_change_req_to_mcm(RRC_MODE_INACTIVE);
      next_substate = RRCCSP_WT_STOP_MODE_CHANGE_CNF;
      rrc_csp_int_data.interrat_reselect_failure_reason = RRC_WCDMA_CELL_CHANGE_FAILURE;
    }
    else if(rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_CC_ORDER_SCAN)
    {
      rrc_csp_int_data.interrat_reselect_failure_reason = RRC_WCDMA_CELL_CHANGE_FAILURE;
      rrccsp_send_camp_cnf_to_cho(FAILURE);
      next_substate = RRCCSP_NO_CELL_SELECTED;
    }
    else if(rrc_csp_int_data.curr_scan == RRC_CSP_INTER_FREQ_REDIRECTION_SCAN)
    {
      WRRC_MSG1_HIGH("Cell Change failure on freq %d during freq redirect scan",
                              rrc_csp_int_data.curr_acq_entry.freq);

      /* Release BCH, tr & phy channels and put lower layers to Idle before sending another
       * Acquisition Req or a Frequency Scan Req.
       */
      rrc_csp_send_bch_release(FALSE);
      rrc_csp_send_tr_phy_chl_release();
      next_substate = rrccsp_handle_failure_during_freq_redirection();
    }
    else
    {
      /* Since the Cell Change has not been successful, treat this as Failure and
       * move on to the next frequency.
       */
      /* TBD: Other status like a different PLMN/Cell ID could be handled
       * differently from failure but that is for later.
       */

      /* Go back to Cell Selection Controller to get the next cell.
       */
      WRRC_MSG0_HIGH("Cell change failed, continue cell sel");
#ifdef FEATURE_QSH_EVENT_METRIC
	      wrrc_qsh_log_cell_resel_stats(CELL_SEL_FAIL,WRRC_METRIC_UPDATE);
#endif
      next_substate = rrc_csp_release_chls_and_continue_cell_selection();
    }
  }

  else  /* Cell Change CNF has a Success status */
  {
    /* Successfully Camped on a Cell Now */
    /* Update the Internal data with Selected PLMN, Send a RRC_SERVICE_CNF to
     * MM and move on to the Camped substate
     */

    /* Fill in the freq and scrambling code information and report
     * the EVENT_WCDMA_CELL_SELECTED event
     */
    wcdma_cell_selected_event.freq = rrc_csp_int_data.curr_acq_entry.freq;
    wcdma_cell_selected_event.scr_code = (uint16)(rrc_csp_int_data.curr_acq_entry.scr_code/16);
#ifdef FEATURE_FEMTO_CSG
    wcdma_cell_selected_event.csg_id = rrc_csp_int_data.curr_acq_entry.csg_id;
#endif
    event_report_payload(EVENT_WCDMA_CELL_SELECTED, sizeof(wcdma_cell_selected_event),
                   (void *)&wcdma_cell_selected_event);
    if(rrc_ifreq_rdr_in_prgrs == TRUE)
    {
      rrclog_wcdma_to_wcdma_redir_end_event_type wtow_redirect_event;
      wtow_redirect_event.status = WTOW_SUCCESS;
      event_report_payload(EVENT_WCDMA_TO_WCDMA_REDIRECTION_END, sizeof(wtow_redirect_event),
                 (void *)&wtow_redirect_event);
      rrc_ifreq_rdr_in_prgrs = FALSE;
    }

    MSG_HIGH("Camped on acceptable cellID %d PLMN.MCC %d, PLMN.MNC %d",
                rrc_csp_int_data.curr_acq_entry.cell_id,
                RRC_CSP_GET_INT_MCC(rrc_csp_int_data.curr_acq_entry.plmn_id),
                RRC_CSP_GET_INT_MNC(rrc_csp_int_data.curr_acq_entry.plmn_id));

    rrc_csp_int_data.curr_service_status = MM_AS_SERVICE_AVAILABLE;
    rrc_csp_int_data.curr_sel_plmn.plmn_type = RRC_GSM_MAP_PLMN_SEL;
    rrc_csp_int_data.curr_sel_plmn.plmn_id   = rrc_csp_int_data.curr_acq_entry.
                                               plmn_id;

    /* Update the current requested PLMN with the camped PLMN */
    rrc_csp_int_data.curr_req_plmn.plmn_id  = rrc_csp_int_data.curr_acq_entry.plmn_id;

#ifdef FEATURE_OOSC_SERVICE_STATUS_UI_UPDATE
    if((rrc_csp_int_data.curr_scan == RRC_CSP_LEAVING_CONN_MODE_SCAN)&&
        (rrc_csp_int_data.prev_curr_scan == RRC_CSP_OUT_OF_SERVICE_AREA_SCAN))
    {
      /* Update UI with full service when camped on a non-ERPLMN cell found during connected mode OOS
       * search, before sending SERVICE_IND to NAS 
       */
      if(rrc_csp_int_data.prev_network_select_mode == SYS_NETWORK_SELECTION_MODE_AUTOMATIC)
      {
        WRRC_MSG0_HIGH("SVC_ST: Update UI w/ full svc");
        rrc_csp_send_svc_status_to_mm(SYS_SRV_STATUS_SRV, SYS_RAT_UMTS_RADIO_ACCESS, rrc_csp_int_data.oosc_l1_rssi);
      }
      /* Update UI with connected mode OOS as FALSE when camped on a limited srvc cell after T314 timer expiry during 
       * connected mode OOS, before sending SERVICE_IND to NAS. But with SERVICE IND MM is updated with full service which 
       * may lead to out of sync between MM and CM for emergency call OOS scenarios. Changes are required for such scenarios.
       */
#ifdef FEATURE_OOSC_USER_ACTION
      else
      {
        WRRC_MSG0_HIGH("SVC_ST: Update UI with connected mode OOS status as FALSE");
        rrc_csp_send_svc_status_to_mm(SYS_SRV_STATUS_NONE, SYS_RAT_UMTS_RADIO_ACCESS, rrc_csp_int_data.oosc_l1_rssi);
      }
#endif
    }
#ifdef FEATURE_OOSC_USER_ACTION
    if (rrc_csp_int_data.curr_scan == RRC_CSP_OUT_OF_SERVICE_AREA_SCAN)
    {
      /*Send OOSC end indication to CM
         CM is currently ignoring the service status other than SYS_SRV_STATUS_SRV if is_connected_mode_oos is FALSE, so send
         SYS_SRV_STATUS_NO_SRV
      */
      WRRC_MSG0_HIGH("SVC_ST: Update UI with connected mode OOS status as FALSE");
      rrc_csp_send_svc_status_to_mm(SYS_SRV_STATUS_NONE, SYS_RAT_UMTS_RADIO_ACCESS, rrc_csp_int_data.oosc_l1_rssi);
    }
#endif

#endif

#ifdef FEATURE_UMTS_1X_HANDOVER_UMTSMSM
    #error code not present
#endif

    /* Here send a DRX command if in DISCONNECTED, CELL_PCH or URA_PCH state */
    if(  ((rrc_state == RRC_STATE_DISCONNECTED)
#ifdef FEATURE_WCDMA_CSFB_CALL_OPT
        /* Skip sending during CSFB call bceause error indication will be sent
           since WL1 will not be in PCH state */
         && !((WCDMA_RRC_IDLE_FEATURES(RRC_CSFB_CALL_TIMELINE_OPT)) && rrc_csfb_call_status)
#endif
         )||
         (rrc_state == RRC_STATE_CELL_PCH) ||
         (rrc_state == RRC_STATE_URA_PCH)
       )
    {
      rrc_csp_send_l1_drx_req();
    }

#ifdef FEATURE_EOOS
    #error code not present
#endif

#ifdef FEATURE_WCDMA_DEFERRED_SIB11_12_READING
#ifdef FEATURE_WCDMA_CSFB_CALL_OPT
    /* Call is imminent so skip posting UPATE SIBS */
    if(!(WCDMA_RRC_IDLE_FEATURES(RRC_CSFB_CALL_TIMELINE_OPT) && rrc_csfb_call_status))
#endif
    {
      WRRC_MSG0_HIGH("Deferred SIB: UPDATE_SIBS activated");
      rrcsib_update_sib_for_deferred_sib();
    }
#endif


    if(rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_CELL_RESELECTION_SCAN)
    {
      rrc_csp_int_data.interrat_reselect_failure_reason = RRC_WCDMA_NONE;
#ifdef FEATURE_GAN_3G_ROVE_OUT_ONLY
      #error code not present
#endif
      {
        /* Send ACT_IND to MM */
        rrc_csp_send_mm_act_ind();
        next_substate = RRCCSP_ACCEPT_CELL_WT_ACTIVATION_RSP;
      }
    }
    else if(rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_REDIRECTION_SCAN)
    {
      /* Send ACT_IND to MM */
      rrc_csp_send_mm_act_ind();
      next_substate = RRCCSP_ACCEPT_CELL_WT_ACTIVATION_RSP;
    }
#ifdef FEATURE_GAN_3G_ROVE_OUT_ONLY
    #error code not present
#endif
    else if(rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_CC_ORDER_SCAN)
    {
      /* Send Camping success to CHO */
      rrccsp_send_camp_cnf_to_cho(SUCCESS);
      next_substate = RRCCSP_CAMPED_ACCEPT_CELL;
    }
    else if(rrc_csp_int_data.curr_scan == RRC_CSP_INTER_FREQ_REDIRECTION_SCAN)
    {
#ifdef FEATURE_INTER_FREQ_EM_CALL_REDIRECTION
      /* The flag em_call_acq_type_updated is set to TRUE only when n/w sel mode
       * is NOT limited_only. If n/w sel mode is NOT limited_only, then 
       * em_call_acq_type_updated is set to TRUE and n/w sel mode is set to 
       * limited Only. So after camping on the cell, the n/w sel mode needs
       * to be changed back to the original value. Hence, CSP substate also
       * needs to be updated here to RRCCSP_CAMPED_SUIT_CELL.
       */
      if(rrc_csp_int_data.em_call_acq_type_updated)
      {
        /* Set the CSP substate to camped on suitable cell, since we want to do
         * suitable cell reselections only from this point on
         */
        next_substate = RRCCSP_CAMPED_SUIT_CELL;
      } 
      else
      {
        next_substate = RRCCSP_CAMPED_ACCEPT_CELL;
      }
#else
      next_substate = RRCCSP_CAMPED_ACCEPT_CELL;
#endif

      /* Camped on redirected frequency - return success */
      if(rrc_csp_int_data.curr_acq_entry.freq == rrc_csp_int_data.redirected_freq)
      {
        WRRC_MSG1_HIGH("Camped on redirected freq %d. Sending REDIRECT_SUCCESS to RCE",
                                rrc_csp_int_data.curr_acq_entry.freq);
        rrccsp_send_rce_redirect_cnf(RRC_REDIRECT_SUCCESS, RRC_CAMPED_ON_REDIRECTED_FREQ);
      }
      /* Not camped on redirected frequency or last camped frequency */
      else if(rrc_csp_int_data.curr_acq_entry.freq != rrc_csp_int_data.last_camped_freq)
      {
        WRRC_MSG1_HIGH("Camped on a diff freq %d. Sending REDIRECT_FAILURE to RCE",
                                rrc_csp_int_data.curr_acq_entry.freq);
        rrccsp_send_rce_redirect_cnf(RRC_REDIRECT_FAILURE, RRC_CAMPED_ON_DIFFERENT_FREQ);
      }
      /* Camped on last camped frequency */
      else
      {
        WRRC_MSG1_HIGH("Camped on last camped freq %d. Sending REDIRECT_FAILURE to RCE",
                                          rrc_csp_int_data.curr_acq_entry.freq);
        rrccsp_send_rce_redirect_cnf(RRC_REDIRECT_FAILURE, RRC_CAMPED_ON_ORIGINAL_FREQ);
      }

      if(rrc_csp_cmd_to_mm_needed(&mm_cmd_id,
                            rrc_csp_int_data.last_mm_primitive,
                            rrc_csp_int_data.curr_service_status)
         == TRUE)
      {
        rrc_csp_send_mm_cmd(mm_cmd_id,
                            rrc_csp_int_data.curr_service_status,
                            &rrc_csp_int_data.curr_sel_plmn,
                            &rrc_csp_int_data.curr_acq_entry);
      }
      else
      {
           /* If SIB3 modification does have DSAC information is present, send service indication
              to NAS always instead of not depending of the current RRC state. i.e. even the function
              rrc_csp_cmd_to_mm_needed() returns false
           */
            if(rrc_csp_int_data.is_curr_dsac_info_valid == TRUE)
            {
              mm_cmd_id =  RRC_SERVICE_IND_FROM_OTA_MSG;
              rrc_csp_send_mm_cmd(mm_cmd_id,
                                  rrc_csp_int_data.curr_service_status,
                                  &rrc_csp_int_data.curr_sel_plmn,
                                  &rrc_csp_int_data.curr_acq_entry);
            }
            else if(mm_cmd_id == RRC_SERVICE_IND)
            {
              mm_cmd_id =  RRC_SERVICE_IND_FROM_OTA_MSG;
              rrc_csp_send_mm_cmd(mm_cmd_id,
                                  rrc_csp_int_data.curr_service_status,
                                  &rrc_csp_int_data.curr_sel_plmn,
                                  &rrc_csp_int_data.curr_acq_entry);
            }
        }
    } /* inter frequency redirection scan */
    else
    {
      if(rrc_csp_cmd_to_mm_needed(&mm_cmd_id,
                                  rrc_csp_int_data.last_mm_primitive,
                                  rrc_csp_int_data.curr_service_status)
         == TRUE)
      {
        rrc_csp_send_mm_cmd(mm_cmd_id,
                            rrc_csp_int_data.curr_service_status,
                            &rrc_csp_int_data.curr_sel_plmn,
                            &rrc_csp_int_data.curr_acq_entry);
      }
      else
      {
           /* If SIB3 modification does have DSAC information is present, send service indication
              to NAS always instead of not depending of the current RRC state. i.e. even the function
              rrc_csp_cmd_to_mm_needed() returns false
           */
            if(rrc_csp_int_data.is_curr_dsac_info_valid == TRUE)
            {
              mm_cmd_id =  RRC_SERVICE_IND_FROM_OTA_MSG;
              rrc_csp_send_mm_cmd(mm_cmd_id,
                                  rrc_csp_int_data.curr_service_status,
                                  &rrc_csp_int_data.curr_sel_plmn,
                                  &rrc_csp_int_data.curr_acq_entry);
            }
            else if(mm_cmd_id == RRC_SERVICE_IND)
            {
              mm_cmd_id =  RRC_SERVICE_IND_FROM_OTA_MSG;
              rrc_csp_send_mm_cmd(mm_cmd_id,
                                  rrc_csp_int_data.curr_service_status,
                                  &rrc_csp_int_data.curr_sel_plmn,
                                  &rrc_csp_int_data.curr_acq_entry);
            }
      }
      /* Stop cell selection timer if we are in DCH->FACH scan */
      if(rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_CELL_FACH_SCAN)
      {
        rrctmr_stop_timer(RRCTMR_DCH_FACH_CELL_SELECTION_TIMER);
      }
      else if((rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_CELL_PCH_SCAN) ||
              (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_URA_PCH_SCAN))
      {
        rrctmr_stop_timer(RRCTMR_DCH_PCH_CELL_SELECTION_TIMER);
      }
      else if((rrc_csp_int_data.curr_scan == RRC_CSP_CELL_FACH_TO_CELL_FACH_SCAN) ||
              (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_FACH_TO_CELL_PCH_SCAN) ||
              (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_FACH_TO_URA_PCH_SCAN))
      {
        rrctmr_stop_timer(RRCTMR_FACH_TO_FACH_PCH_CELL_SELECTION_TIMER);
      }
      /* If current scan is leaving connected mode scan restore the nw sel mode and the 
         CSP substate if they were modified internally during connected mode OOS, when UE 
         found a non-ERPLMN cell on which NAS will attempt registration. 
      */
      if((rrc_csp_int_data.curr_scan == RRC_CSP_LEAVING_CONN_MODE_SCAN)&&
         (rrc_csp_int_data.prev_network_select_mode != SYS_NETWORK_SELECTION_MODE_NONE))
      {
        rrc_csp_int_data.network_select_mode = rrc_csp_int_data.prev_network_select_mode;
        rrc_csp_int_data.prev_network_select_mode = SYS_NETWORK_SELECTION_MODE_NONE; 
        if(rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_AUTOMATIC)
        {
          next_substate = RRCCSP_CAMPED_SUIT_CELL;
          rrc_csp_int_data.curr_req_plmn.plmn_type = RRC_GSM_MAP_SPECIFIC_PLMN_REQ;
          rrc_csp_int_data.curr_type_acq           = RRC_CSP_SPEC_PLMN;
          rrc_csp_curr_select_data.acq_type        = RRC_CSP_SPEC_PLMN;

          WRRC_MSG1_HIGH("Setting accept->suit cell, n/w sel mode = %d",
                     rrc_csp_int_data.network_select_mode);
        }
        else
        {
          next_substate = RRCCSP_CAMPED_ACCEPT_CELL;
        }
      }
      else
      {
        next_substate = RRCCSP_CAMPED_ACCEPT_CELL;
      }
    }

    rrc_csp_int_data.fach_tx_dest_state = RRC_STATE_MAX;

#ifdef FEATURE_UMTS_ACQ_CHNL_INFO_SHARING
    /* Clear RRC acq channel db to remove any stale information */
    rrc_clear_acq_chnl_info();
    /* Clear RR acq channel db to remove any stale information */
    rr_rrc_clear_acq_chnl_info_internal();
#endif

    if(rrc_csp_int_data.curr_scan == RRC_CSP_LEAVING_CONN_MODE_SCAN)
    {
      WRRC_MSG0_HIGH("CPHY_UPD_OTA_PARMS_IND may be due to RCR");
      if(rrc_high_mobility_ind_in_rcr == TRUE)
      {
        rrcrb_send_upd_ota_parms_ind(RRC_PROCEDURE_CSP, CPHY_HIGH_MOBILITY_INCL);
        rrc_high_mobility_ind_in_rcr = FALSE;
      }
    }

    /* Added as a fix for CR # 128660.
     * Curr_scan should not be reset if it is GtoW reselection scan. Because we still need to wait
     * for ACTIVAION_RSP from NAS for the RRC_ACTIVATION_IND and NAS can also ignore RRC_ACTIVATION_IND 
     * if it had already sent a PLMN_LIST_REQ etc to RR in which case we end up loosing the current scan
     * and will not respond to RR for RESELECTION_ABORT_REQ.
     */

    if((rrc_csp_int_data.curr_scan != RRC_CSP_GSM_TO_WCDMA_CELL_RESELECTION_SCAN) &&
       (rrc_csp_int_data.curr_scan != RRC_CSP_GSM_TO_WCDMA_REDIRECTION_SCAN) &&
        (rrc_csp_int_data.curr_scan != RRC_CSP_GAN_TO_WCDMA_RESELECTION_SCAN) &&
        (rrc_csp_int_data.curr_scan != RRC_CSP_GO_TO_IDLE_DETACHED_SCAN))
    {
      WRRC_MSG0_HIGH("Resetting Current Scan to Cell Selection Scan");
      rrc_csp_int_data.curr_scan = RRC_CSP_CELL_SELECTION_SCAN;
    }

#ifdef FEATURE_LTE_TO_WCDMA
    if((RRC_CSP_GSM_TO_WCDMA_REDIRECTION_SCAN == rrc_csp_int_data.curr_scan) &&
        (RRC_CSP_INTERRAT_LTE == rrc_csp_int_data.interrat_type))
    {
      rrctmr_stop_timer(RRCTMR_LTE_TO_WCDMA_REDIR_SRCH_TIMER);
#ifdef FEATURE_3GPP_CSFB
      /*Clear the SIB container list, UE camped on W for LTOW redirection scan*/
      rrccsp_free_sib_cont_list();
      if(rrc_csp_int_data.sib_read_csfb_active && !rrc_csfb_call_status)
      {
#ifdef FEATURE_WCDMA_CSFB_CALL_OPT
        /* Trigger OOS if CSFB call status is reset before connection establishment */
        /* We have not setup PCH channel since its a CSFB call so trigger OOS for now */
        if(WCDMA_RRC_IDLE_FEATURES(RRC_CSFB_CALL_TIMELINE_OPT))
        {
          next_substate = rrc_csp_start_sel_out_of_service_area_in_idle_state();
        }
        else
#endif
        {
          WRRC_MSG0_HIGH("CSFB: CSFB call cancelled, Read the SIBs");
          rrccsp_post_update_sibs_ind(RRCSIB_CSFB_CALL_CANCL);
        }

        rrc_csp_int_data.sib_read_csfb_active = FALSE;
      }
#endif
    }
#endif

#ifdef FEATURE_GAN
    #error code not present
#endif

  } /* Cell Change CNF has a Success status */

  return(next_substate);

} /* rrccsp_accept_cell_sel_wait_camp_cell_change */


/*===========================================================================

FUNCTION        RRCCSP_CELL_SEL_WAIT_CAMP_HDLR

DESCRIPTION
                This is a handler for events received in
                RRCCSP_SUIT/ACCEPT_CELL_SEL_WT_CAMP substate of the Cell Selection
                Procedure.
                Depending on the event, it further calls a function for
                processing the event in this CSP substate.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_cell_sel_wait_camp_hdlr( rrc_cmd_type *cmd_ptr )
{
  rrc_csp_substate_e_type   next_substate;
  rrc_state_e_type          rrc_state;

  next_substate = rrc_csp_substate;

  switch( cmd_ptr->cmd_hdr.cmd_id )
  {
    case RRC_CELL_CHANGE_CNF:
      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
      if(rrc_csp_substate == RRCCSP_ACCEPT_CELL_SEL_WT_CAMP)
      {
        next_substate = rrccsp_accept_cell_sel_wait_camp_cell_change( cmd_ptr );
      }
      else if(rrc_csp_substate == RRCCSP_SUIT_CELL_SEL_WT_CAMP)
      {
         next_substate = rrccsp_suit_cell_sel_wait_camp_cell_change( cmd_ptr );
      }
      break;

    case RRC_SERVICE_REQ:
      rrc_state = rrc_get_state();
      if(rrc_state != RRC_STATE_DISCONNECTED)
      {
        WRRC_MSG1_ERROR("Service req in RRC state %d",rrc_state);
                #ifdef FEATURE_WRLF_SYSTEM_SEL
        if(rrc_csp_substate == RRCCSP_SUIT_CELL_SEL_WT_CAMP)
        {
           
          /*If PLMN/network select mode doesnt change in new service request. Ignore it*/
           if (RRC_IS_CONN_MODE_OOS_SRCH_IN_PROGRESS())
           {
             if((rrc_csp_int_data.network_select_mode == cmd_ptr->cmd.rrc_service_req.network_select_mode)&&
               (rrc_bcch_plmns_match(rrc_csp_int_data.curr_req_plmn.plmn_id,cmd_ptr->cmd.rrc_service_req.requested_plmn.plmn_id)))
             {
               WRRC_MSG0_HIGH("Trashing service request as similar request is in final stages");
               return next_substate;
             }
             else
             /*Reset OOS flag so that all channels will be released upon processing saved service request*/
             {
                rrc_csp_int_data.ue_in_conn_oos = FALSE;
             }
           }
          
       }
       #endif
      }

      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
      rrccsp_save_req( cmd_ptr );
      if(rrc_csp_substate == RRCCSP_ACCEPT_CELL_SEL_WT_CAMP)
      {
        next_substate = RRCCSP_ACCEPT_CELL_SEL_WT_CAMP_PENDING;
      }
      else if(rrc_csp_substate == RRCCSP_SUIT_CELL_SEL_WT_CAMP)
      {
         next_substate = RRCCSP_SUIT_CELL_SEL_WT_CAMP_PENDING;
      }
      break;

    case RRC_DCH_FACH_CELL_SELECTION_TIMER_EXPIRED_IND:
      if(rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_CELL_FACH_SCAN)
      {
        rrccsp_save_req(cmd_ptr);
        if(rrc_csp_substate == RRCCSP_ACCEPT_CELL_SEL_WT_CAMP)
        {
          next_substate = RRCCSP_ACCEPT_CELL_SEL_WT_CAMP_PENDING;
        }
        else if(rrc_csp_substate == RRCCSP_SUIT_CELL_SEL_WT_CAMP)
        {
           next_substate = RRCCSP_SUIT_CELL_SEL_WT_CAMP_PENDING;
        }
      }
      else
      {
        WRRC_MSG1_HIGH("Ignoring Cell Sel Tmr Exp in %d scan", rrc_csp_int_data.curr_scan);
      }
      break;

    case RRC_DCH_PCH_CELL_SELECTION_TIMER_EXPIRED_IND:
      if((rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_CELL_PCH_SCAN) ||
              (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_URA_PCH_SCAN))
      {
        rrccsp_save_req(cmd_ptr);
        if(rrc_csp_substate == RRCCSP_ACCEPT_CELL_SEL_WT_CAMP)
        {
          next_substate = RRCCSP_ACCEPT_CELL_SEL_WT_CAMP_PENDING;
        }
        else if(rrc_csp_substate == RRCCSP_SUIT_CELL_SEL_WT_CAMP)
        {
          next_substate = RRCCSP_SUIT_CELL_SEL_WT_CAMP_PENDING;
        }
      }
      else
      {
        WRRC_MSG1_HIGH("Ignoring Cell Sel Tmr Exp in %d scan", rrc_csp_int_data.curr_scan);
      }
      break;

    case RRC_FACH_TO_FACH_PCH_CELL_SELECTION_TIMER_EXPIRED_IND:
      if((rrc_csp_int_data.curr_scan == RRC_CSP_CELL_FACH_TO_CELL_FACH_SCAN) ||
         (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_FACH_TO_CELL_PCH_SCAN) ||
         (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_FACH_TO_URA_PCH_SCAN))
      {
        rrccsp_save_req(cmd_ptr);
        if(rrc_csp_substate == RRCCSP_ACCEPT_CELL_SEL_WT_CAMP)
        {
           next_substate = RRCCSP_ACCEPT_CELL_SEL_WT_CAMP_PENDING;
        }
        else if(rrc_csp_substate == RRCCSP_SUIT_CELL_SEL_WT_CAMP)
        {
           next_substate = RRCCSP_SUIT_CELL_SEL_WT_CAMP_PENDING;
        }
      }
      else
      {
        WRRC_MSG1_HIGH("Ignoring Cell Sel Tmr Exp in %d scan", rrc_csp_int_data.curr_scan);
      }
      break;

    case RRC_PLMN_LIST_REQ:
      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
      if(rrccsp_plmn_list_req_is_valid(&(cmd_ptr->cmd.plmn_list_req)))
      {
        /* If Scan Type is Leaving Connected Mode Scan then do Manual PLMN
         * Search in background (after UE camps).
         */
        if(rrc_csp_int_data.curr_scan == RRC_CSP_LEAVING_CONN_MODE_SCAN)
        {
          WRRC_MSG0_HIGH("WTOW: LeavingConnModeScan. Hold Manual Srch req until UE camps");

          /* The call to the function below should always return TRUE in this case.
           * If FALSE is returned then it is an error condition. Abort the search.
           */
          if(!rrccsp_handle_plmn_list_req_in_bgnd(&(cmd_ptr->cmd.plmn_list_req)))
          {
            rrc_csp_send_mm_plmn_list_cnf_as_aborted(cmd_ptr->cmd.plmn_list_req.trans_id);
          }
        }
        /* Since scan type is not leaving connected mode, hence do the search in foreground */
        else
        {
          rrccsp_save_req( cmd_ptr );
          if(rrc_csp_substate == RRCCSP_ACCEPT_CELL_SEL_WT_CAMP)
          {
            next_substate = RRCCSP_ACCEPT_CELL_SEL_WT_CAMP_PENDING;
          }
          else if(rrc_csp_substate == RRCCSP_SUIT_CELL_SEL_WT_CAMP)
          {
             next_substate = RRCCSP_SUIT_CELL_SEL_WT_CAMP_PENDING;
          }
      }
      }
      break;

    case RRC_STATE_CHANGE_IND:
      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
      if(((rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_CELL_FACH_SCAN) ||
         (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_CELL_PCH_SCAN) ||
         (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_URA_PCH_SCAN) ||
         (rrc_csp_int_data.curr_scan == RRC_CSP_OUT_OF_SERVICE_AREA_SCAN) ||
         (rrc_csp_int_data.curr_scan ==
            RRC_CSP_OUT_OF_SERVICE_AREA_IN_CONNECTING_STATE_SCAN)) &&
          (cmd_ptr->cmd.state_change_ind.new_state == RRC_STATE_DISCONNECTED))
      {
        rrccsp_save_req( cmd_ptr );
        if(rrc_csp_substate == RRCCSP_ACCEPT_CELL_SEL_WT_CAMP)
        {
          next_substate = RRCCSP_ACCEPT_CELL_SEL_WT_CAMP_PENDING;
        }
        else if(rrc_csp_substate == RRCCSP_SUIT_CELL_SEL_WT_CAMP)
        {
           next_substate = RRCCSP_SUIT_CELL_SEL_WT_CAMP_PENDING;
        }
      }
      else
      {
        WRRC_MSG1_HIGH("Ignoring state change, curr scan %d",rrc_csp_int_data.curr_scan);
      }
      break;

    case RRC_INITIATE_CELL_SELECTION_IND:
      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );

      /* If the procedure is CU and reason for initiating cell selection is
       * TRANSITION_TO_DISCONNECTED, process the command
       */
      if(cmd_ptr->cmd.initiate_cell_sel_ind.cause == RRC_TRANSITION_TO_DISCONNECTED)
      {
        MSG_HIGH("Saving cmd 0x%x, CSP sstate %d, scan %d",
                    cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, rrc_csp_int_data.curr_scan);
        rrccsp_save_req( cmd_ptr );
        if(rrc_csp_substate == RRCCSP_ACCEPT_CELL_SEL_WT_CAMP)
        {
          next_substate = RRCCSP_ACCEPT_CELL_SEL_WT_CAMP_PENDING;
        }
        else if(rrc_csp_substate == RRCCSP_SUIT_CELL_SEL_WT_CAMP)
        {
           next_substate = RRCCSP_SUIT_CELL_SEL_WT_CAMP_PENDING;
        }
      }
      else
      {
        WRRC_MSG2_HIGH( "Cmd 0x%x not processed in CSP sstate %d",
                            cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);
      }
      break;


    case RRC_FREQ_REDIRECT_WAIT_TIMER_EXPIRED_IND:
      WRRC_MSG2_HIGH("Freq redirect wt tmr exprd for freq %d in CSP sstate %d",
                                rrc_csp_int_data.last_camped_freq, rrc_csp_substate);

      /* Inter frequency redirection scan is in progress */
      if(rrc_csp_int_data.curr_scan == RRC_CSP_INTER_FREQ_REDIRECTION_SCAN)
      {
        /* Timer expired for last camped frequency */
        next_substate = rrccsp_handle_freq_redirect_wait_timer_expiry(next_substate);
        if(next_substate == RRCCSP_ACCEPT_CELL_SEL_WT_CAMP_PENDING
          || next_substate == RRCCSP_SUIT_CELL_SEL_WT_CAMP_PENDING
          )
        {
          rrccsp_save_req(cmd_ptr);
        }
      }
      else
      {
        WRRC_MSG2_ERROR("ERR Wt tmr exprd for freq %d in CSP sstate %d when ifreq-rdrctn not in progress",
                                               rrc_csp_int_data.last_camped_freq, rrc_csp_substate);
        rrc_csp_int_data.start_acq_on_last_camped_freq = TRUE;
      }
      break;

    case RRC_GTOW_REDIRECTION_WAIT_TIMER_EXPIRED_IND:
      WRRC_MSG0_HIGH("Interrat Redirection: Timer expired");
      rrc_csp_int_data.gtow_redirection_timer_expired = TRUE;
      break;

    case RRC_IRAT_ABORT_IND:
      rrccsp_send_mode_change_req_to_mcm( RRC_MODE_INACTIVE );        

      if(rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_REDIRECTION_SCAN)
      {
        rrc_csp_int_data.rsp_to_rr        = SEND_GTOW_REDIRECTION_ABORT_CNF;
      }
      else
      {
        rrc_csp_int_data.rsp_to_rr        = SEND_GTOW_RESEL_ABORT_CNF;
      }


      next_substate                     = RRCCSP_WT_STOP_MODE_CHANGE_CNF;
      break;

    case RRC_BPLMN_SEARCH_ABORT_REQ:
      rrccsp_cleanup_bplmn_state();
      break;

    case RRC_BPLMN_GUARD_SRCH_TIMER_EXPIRED_IND:
      rrccsp_cleanup_bplmn_state();
      break;

/*lint -e408*/
#ifdef FEATURE_GAN_3G_ROVE_OUT_ONLY
    #error code not present
#endif
/*lint +e408*/
#ifdef FEATURE_DUAL_SIM
      case RRC_RESET_L1_CNF:
        WRRC_MSG1_HIGH("DSIM:Recvd RRC_RESET_L1_CNF from LLC in CSP substate %d",rrc_csp_substate);
        if(rrc_csp_int_data.csp_waiting_for_wl1_to_release_lock)
        {
          rrc_csp_int_data.csp_waiting_for_wl1_to_release_lock = FALSE;
          next_substate = rrc_csp_continue_cell_selection();
        }
        else
        {
          /*Ignore*/
        }
        break;
#endif

    default:
      WRRC_MSG2_HIGH( "Cmd 0x%x not processed in CSP sstate %d",
                            cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);
      break;
  }
  return( next_substate );
} /* rrccsp_cell_sel_wait_camp_hdlr */

/*===========================================================================

FUNCTION        RRCCSP_CELL_SEL_WAIT_S_HDLR

DESCRIPTION
                This is a handler for events received in
                RRCCSP_CELL_SEL_WT_S substate of the Cell Selection Procedure.
                Depending on the event, it further calls a function for
                processing the event in this CSP substate.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/

static rrc_csp_substate_e_type
rrccsp_cell_sel_wait_s_hdlr( rrc_cmd_type *cmd_ptr )
{

  rrc_csp_substate_e_type   next_substate;
  rrc_state_e_type          rrc_state;

  next_substate = rrc_csp_substate;

  switch( cmd_ptr->cmd_hdr.cmd_id )
  {
    case RRC_LLC_CMD_CNF:
      MSG_LOW( "Cmd 0x%x recvd, CSP sstate %d",
                           cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
      switch(cmd_ptr->cmd.rrc_llc_cnf.ll_cnf)
      {
        case RRC_LL_CPHY_CELL_SELECTION_CNF:
          MSG_MED("L1 cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd.rrc_llc_cnf.ll_cnf, rrc_csp_substate, 0);
          if(rrc_csp_substate == RRCCSP_ACCEPT_CELL_SEL_WT_S)
          {
          next_substate = rrccsp_accept_cell_sel_wait_s_recvd( cmd_ptr );
          }
          else if(rrc_csp_substate == RRCCSP_SUIT_CELL_SEL_WT_SERV_S)
          {
             next_substate = rrccsp_suit_cell_sel_wait_serv_s_recvd( cmd_ptr );
          }
          break;

        default:
          WRRC_MSG2_HIGH("Unexpected L1 cmd 0x%x, CSP sstate %d",
                         cmd_ptr->cmd.rrc_llc_cnf.ll_cnf, rrc_csp_substate);
          break;
      }
      break;

    case RRC_SERVICE_REQ:
      rrc_state = rrc_get_state();
      if(rrc_state != RRC_STATE_DISCONNECTED)
      {
        WRRC_MSG1_ERROR("Service req in RRC state %d",rrc_state);
      }

      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
      rrccsp_save_req( cmd_ptr );
      if(rrc_csp_substate == RRCCSP_ACCEPT_CELL_SEL_WT_S)
      {
      next_substate = RRCCSP_ACCEPT_CELL_SEL_WT_S_PENDING;
      }
      else if(rrc_csp_substate == RRCCSP_SUIT_CELL_SEL_WT_SERV_S)
      {
         next_substate = RRCCSP_SUIT_CELL_SEL_WT_SERV_S_PENDING;
      }
      break;

    case RRC_DCH_FACH_CELL_SELECTION_TIMER_EXPIRED_IND:
      if(rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_CELL_FACH_SCAN)
      {
        rrccsp_save_req(cmd_ptr);
        if(rrc_csp_substate == RRCCSP_ACCEPT_CELL_SEL_WT_S)
        {
        next_substate = RRCCSP_ACCEPT_CELL_SEL_WT_S_PENDING;
      }
        else if(rrc_csp_substate == RRCCSP_SUIT_CELL_SEL_WT_SERV_S)
        {
          next_substate = RRCCSP_SUIT_CELL_SEL_WT_SERV_S_PENDING;
        }
      }
      else
      {
        WRRC_MSG1_HIGH("Ignoring Cell Sel Tmr Exp in %d scan", rrc_csp_int_data.curr_scan);
      }
      break;

    case RRC_DCH_PCH_CELL_SELECTION_TIMER_EXPIRED_IND:
      if((rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_CELL_PCH_SCAN) ||
              (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_URA_PCH_SCAN))
      {
        rrccsp_save_req(cmd_ptr);
        if(rrc_csp_substate == RRCCSP_ACCEPT_CELL_SEL_WT_S)
        {
        next_substate = RRCCSP_ACCEPT_CELL_SEL_WT_S_PENDING;
      }
        else if(rrc_csp_substate == RRCCSP_SUIT_CELL_SEL_WT_SERV_S)
        {
           next_substate = RRCCSP_SUIT_CELL_SEL_WT_SERV_S_PENDING;
        }
      }
      else
      {
        WRRC_MSG1_HIGH("Ignoring Cell Sel Tmr Exp in %d scan", rrc_csp_int_data.curr_scan);
      }
      break;

    case RRC_FACH_TO_FACH_PCH_CELL_SELECTION_TIMER_EXPIRED_IND:
      if((rrc_csp_int_data.curr_scan == RRC_CSP_CELL_FACH_TO_CELL_FACH_SCAN) ||
         (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_FACH_TO_CELL_PCH_SCAN) ||
         (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_FACH_TO_URA_PCH_SCAN))
      {
        rrccsp_save_req(cmd_ptr);
        if(rrc_csp_substate == RRCCSP_ACCEPT_CELL_SEL_WT_S)
        {
        next_substate = RRCCSP_ACCEPT_CELL_SEL_WT_S_PENDING;
      }
        else if(rrc_csp_substate == RRCCSP_SUIT_CELL_SEL_WT_SERV_S)
        {
           next_substate = RRCCSP_SUIT_CELL_SEL_WT_SERV_S_PENDING;
        }
      }
      else
      {
        WRRC_MSG1_HIGH("Ignoring Cell Sel Tmr Exp in %d scan", rrc_csp_int_data.curr_scan);
      }
      break;

    case RRC_PLMN_LIST_REQ:
      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
      if(rrccsp_plmn_list_req_is_valid(&(cmd_ptr->cmd.plmn_list_req)))
      {
        /* If Scan Type is Leaving Connected Mode Scan then do Manual PLMN
         * Search in background (after UE camps).
         */
        if(rrc_csp_int_data.curr_scan == RRC_CSP_LEAVING_CONN_MODE_SCAN)
        {
          WRRC_MSG0_HIGH("WTOW: LeavingConnModeScan. Hold Manual Srch req until UE camps");

          /* The call to the function below should always return TRUE in this case.
           * If FALSE is returned then it is an error condition. Abort the search.
           */
          if(!rrccsp_handle_plmn_list_req_in_bgnd(&(cmd_ptr->cmd.plmn_list_req)))
          {
            rrc_csp_send_mm_plmn_list_cnf_as_aborted(cmd_ptr->cmd.plmn_list_req.trans_id);
          }
        }
        /* Since scan type is not leaving connected mode, hence do the search in foreground */
        else
        {
          rrccsp_save_req( cmd_ptr );
          if(rrc_csp_substate == RRCCSP_ACCEPT_CELL_SEL_WT_S)
          {
          next_substate = RRCCSP_ACCEPT_CELL_SEL_WT_S_PENDING;
        }
          else if(rrc_csp_substate == RRCCSP_SUIT_CELL_SEL_WT_SERV_S)
          {
             next_substate = RRCCSP_SUIT_CELL_SEL_WT_SERV_S_PENDING;
          }
        }
      }
      break;

    case RRC_STATE_CHANGE_IND:
      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
      if(((rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_CELL_FACH_SCAN) ||
         (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_CELL_PCH_SCAN) ||
         (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_URA_PCH_SCAN) ||
         (rrc_csp_int_data.curr_scan == RRC_CSP_OUT_OF_SERVICE_AREA_SCAN) ||
         (rrc_csp_int_data.curr_scan ==
            RRC_CSP_OUT_OF_SERVICE_AREA_IN_CONNECTING_STATE_SCAN)) &&
          (cmd_ptr->cmd.state_change_ind.new_state == RRC_STATE_DISCONNECTED))
      {
        rrccsp_save_req( cmd_ptr );
        if(rrc_csp_substate == RRCCSP_ACCEPT_CELL_SEL_WT_S)
        {
        next_substate = RRCCSP_ACCEPT_CELL_SEL_WT_S_PENDING;
      }
        else if(rrc_csp_substate == RRCCSP_SUIT_CELL_SEL_WT_SERV_S)
        {
           next_substate = RRCCSP_SUIT_CELL_SEL_WT_SERV_S_PENDING;
        }
      }
      else
      {
        WRRC_MSG1_HIGH("Ignoring state change, curr scan %d",rrc_csp_int_data.curr_scan);
      }
      break;

    case RRC_INITIATE_CELL_SELECTION_IND:
      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );

      /* If the procedure is CU and reason for initiating cell selection is
       * TRANSITION_TO_DISCONNECTED, process the command
       */
      if(cmd_ptr->cmd.initiate_cell_sel_ind.cause == RRC_TRANSITION_TO_DISCONNECTED)
      {
        MSG_HIGH("Saving cmd 0x%x, CSP sstate %d, scan %d",
                    cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, rrc_csp_int_data.curr_scan);
        rrccsp_save_req( cmd_ptr );
        if(rrc_csp_substate == RRCCSP_ACCEPT_CELL_SEL_WT_S)
        {
        next_substate = RRCCSP_ACCEPT_CELL_SEL_WT_S_PENDING;
      }
        else if(rrc_csp_substate == RRCCSP_SUIT_CELL_SEL_WT_SERV_S)
        {
           next_substate = RRCCSP_SUIT_CELL_SEL_WT_SERV_S_PENDING;
        }
      }
      else
      {
        WRRC_MSG2_HIGH("Cmd 0x%x not processed in CSP sstate %d",
                            cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);
      }
      break;


    case RRC_FREQ_REDIRECT_WAIT_TIMER_EXPIRED_IND:
      WRRC_MSG2_HIGH("Freq redirect wt tmr exprd for freq %d in CSP sstate %d",
                                rrc_csp_int_data.last_camped_freq, rrc_csp_substate);

      /* Inter frequency redirection scan is in progress */
      if(rrc_csp_int_data.curr_scan == RRC_CSP_INTER_FREQ_REDIRECTION_SCAN)
      {
        /* Timer expired for last camped frequency */
        next_substate = rrccsp_handle_freq_redirect_wait_timer_expiry(next_substate);
        if(next_substate == RRCCSP_ACCEPT_CELL_SEL_WT_S_PENDING 
           || next_substate == RRCCSP_SUIT_CELL_SEL_WT_SERV_S_PENDING
          )
        {
          rrccsp_save_req(cmd_ptr);
        }
      }
      else
      {
        WRRC_MSG2_ERROR("ERR Wt tmr exprd for freq %d in CSP sstate %d when ifreq-rdrctn not in progress",
                                               rrc_csp_int_data.last_camped_freq, rrc_csp_substate);
        rrc_csp_int_data.start_acq_on_last_camped_freq = TRUE;
      }
      break;   

    case RRC_GTOW_REDIRECTION_WAIT_TIMER_EXPIRED_IND:
      WRRC_MSG0_HIGH("Interrat Redirection: Timer expired");
      rrc_csp_int_data.gtow_redirection_timer_expired = TRUE;
      break;

    case RRC_IRAT_ABORT_IND:
      rrccsp_send_mode_change_req_to_mcm( RRC_MODE_INACTIVE );        

      if(rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_REDIRECTION_SCAN)
      {
        rrc_csp_int_data.rsp_to_rr        = SEND_GTOW_REDIRECTION_ABORT_CNF;
      }
      else
      {
        rrc_csp_int_data.rsp_to_rr        = SEND_GTOW_RESEL_ABORT_CNF;
      }


      next_substate                     = RRCCSP_WT_STOP_MODE_CHANGE_CNF;
      break;

    case RRC_BPLMN_SEARCH_ABORT_REQ:
      rrccsp_cleanup_bplmn_state();
      break;

    case RRC_BPLMN_GUARD_SRCH_TIMER_EXPIRED_IND:
      rrccsp_cleanup_bplmn_state();
      break;
/*lint -e408*/
#ifdef FEATURE_GAN_3G_ROVE_OUT_ONLY
    #error code not present
#endif
/*lint +e408*/
#ifdef FEATURE_DUAL_SIM
      case RRC_RESET_L1_CNF:
        WRRC_MSG1_HIGH("DSIM:Recvd RRC_RESET_L1_CNF from LLC in CSP substate %d",rrc_csp_substate);
        if(rrc_csp_int_data.csp_waiting_for_wl1_to_release_lock)
        {
          rrc_csp_int_data.csp_waiting_for_wl1_to_release_lock = FALSE;
          next_substate = rrc_csp_continue_cell_selection();
        }
        else
        {
          /*Ignore*/
        }
        break;
#endif

    default:
      WRRC_MSG2_HIGH("Cmd 0x%x not processed in CSP sstate %d",
                      cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);
      break;
  }

  return( next_substate );
} /* rrccsp_cell_sel_wait_s_hdlr */


/*===========================================================================

FUNCTION        rrccsp_cell_sel_wait_s_pending_hdlr

DESCRIPTION
                This is a handler for events received in
                RRCCSP_CELL_SEL_WT_SIB_PENDING substate of the
                Cell Selection Procedure.
                Depending on the event, it further calls a function for
                processing the event in this CSP substate.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_cell_sel_wait_s_pending_hdlr( rrc_cmd_type *cmd_ptr )
{

  rrc_csp_substate_e_type   next_substate;
  rrc_state_e_type          rrc_state;

  next_substate = rrc_csp_substate;

  switch( cmd_ptr->cmd_hdr.cmd_id )
  {
    case RRC_LLC_CMD_CNF:
      MSG_LOW( "Cmd 0x%x recvd, CSP sstate %d",
                           cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
      if(cmd_ptr->cmd.rrc_llc_cnf.ll_cnf == RRC_LL_CPHY_CELL_SELECTION_CNF)
      {
        next_substate = rrccsp_pending_command_handler();
      }
      else
      {
        WRRC_MSG2_HIGH("Unexpected L1 cmd 0x%x, CSP sstate %d",
                       cmd_ptr->cmd.rrc_llc_cnf.ll_cnf, rrc_csp_substate);
      }
      break;
      

    case RRC_SERVICE_REQ:
      rrc_state = rrc_get_state();
      if(rrc_state != RRC_STATE_DISCONNECTED)
      {
        WRRC_MSG1_ERROR("Service req in RRC state %d",rrc_state);
      }

      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
      rrccsp_save_req(cmd_ptr);
      
      break;


    case RRC_PLMN_LIST_REQ:
      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
      if(rrccsp_plmn_list_req_is_valid(&(cmd_ptr->cmd.plmn_list_req)))
      {
        rrccsp_save_req( cmd_ptr );

      }
      break;

    case RRC_FREQ_REDIRECT_WAIT_TIMER_EXPIRED_IND:
      WRRC_MSG2_HIGH("Freq redirect wt tmr exprd for freq %d in CSP sstate %d",
                                rrc_csp_int_data.last_camped_freq, rrc_csp_substate);

      /* In pending substate we should not care about wait timer expiry. Just to be on the
       * safe side, the variable below is set appropriately on wait timer expiry.
       */
      rrc_csp_int_data.start_acq_on_last_camped_freq = TRUE;
      break;

    case RRC_BPLMN_GUARD_SRCH_TIMER_EXPIRED_IND:
      rrccsp_cleanup_bplmn_state();
      break;
#ifdef FEATURE_DUAL_SIM
      case RRC_RESET_L1_CNF:
        WRRC_MSG1_HIGH("DSIM:Recvd RRC_RESET_L1_CNF from LLC in CSP substate %d",rrc_csp_substate);
        if(rrc_csp_int_data.csp_waiting_for_wl1_to_release_lock)
        {
          rrc_csp_int_data.csp_waiting_for_wl1_to_release_lock = FALSE;
          /*Release the lock*/
          rrc_release_lock();
          next_substate = rrccsp_pending_command_handler();
        }
        else
        {
          /*Ignore*/
        }
        break;
#endif

    case RRC_INITIATE_CELL_SELECTION_IND:
      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );

      /* If the procedure is CU and reason for initiating cell selection is
       * TRANSITION_TO_DISCONNECTED, process the command
       */
      if(cmd_ptr->cmd.initiate_cell_sel_ind.cause == RRC_TRANSITION_TO_DISCONNECTED)
      {
        MSG_HIGH("Saving cmd 0x%x, CSP sstate %d, scan %d",
                    cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, rrc_csp_int_data.curr_scan);
        rrccsp_save_req( cmd_ptr );

      }
      else
      {
        WRRC_MSG2_HIGH("Cmd 0x%x not processed in CSP sstate %d",
                            cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);
      }
      break;

    default:
      WRRC_MSG2_HIGH("Cmd 0x%x not processed in CSP sstate %d",
                          cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);
      break;
  }

  return( next_substate );

} /* rrccsp_cell_sel_wait_s_pending_hdlr */






/* =======================================================================
** Function Definitions for substate:
    RRCCSP_ACCEPT_CELL_SEL_WT_CAMP_PENDING
** ======================================================================= */

/*===========================================================================

FUNCTION        rrccsp_accept_cell_sel_wait_camp_pending_hdlr

DESCRIPTION
                This is a handler for events received in
                RRCCSP_ACCEPT_CELL_SEL_WT_CAMP_PENDING substate of
                Cell Selection Procedure.
                Depending on the event, it further calls a function for
                processing the event in this CSP substate.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_cell_sel_wait_camp_pending_hdlr( rrc_cmd_type *cmd_ptr )
{

  rrc_csp_substate_e_type   next_substate;
  rrc_state_e_type          rrc_state;

  next_substate = rrc_csp_substate;

  switch( cmd_ptr->cmd_hdr.cmd_id )
  {
    case RRC_CELL_CHANGE_CNF:
      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );

      if((cmd_ptr->cmd.cell_change_cnf.cell_change_status == RRC_CELL_CHANGE_SUCCESS) &&
            ((rrc_csp_int_data.pending_type == RRC_CSP_DCH_TO_FACH_TIMER_PENDING) ||
              (rrc_csp_int_data.pending_type == RRC_CSP_DCH_TO_PCH_TIMER_PENDING)
              || (rrc_csp_int_data.pending_type == RRC_CSP_FACH_TO_FACH_PCH_TIMER_PENDING)
            ))
      {
        WRRC_MSG1_HIGH("Cell chg cnf(SUCCESS), pending type %d",
                    rrc_csp_int_data.pending_type);
        if(rrc_csp_substate == RRCCSP_ACCEPT_CELL_SEL_WT_CAMP_PENDING)
        {
           next_substate = rrccsp_accept_cell_sel_wait_camp_cell_change( cmd_ptr );
        }
        else if(rrc_csp_substate == RRCCSP_SUIT_CELL_SEL_WT_CAMP_PENDING)
        {
           next_substate = rrccsp_suit_cell_sel_wait_camp_cell_change( cmd_ptr );
        }
      }
      else
      {
        next_substate = rrccsp_pending_command_handler();
      }
      break;

    case RRC_SERVICE_REQ:
      rrc_state = rrc_get_state();
      if(rrc_state != RRC_STATE_DISCONNECTED)
      {
        WRRC_MSG1_ERROR("Service req in RRC state %d",rrc_state);
      }

      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
      rrccsp_save_req(cmd_ptr);
       next_substate = rrc_csp_substate;
      
      break;


    case RRC_PLMN_LIST_REQ:
      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
      if(rrccsp_plmn_list_req_is_valid(&(cmd_ptr->cmd.plmn_list_req)))
      {
        rrccsp_save_req( cmd_ptr );
        next_substate = rrc_csp_substate;
      }
      break;

    case RRC_FREQ_REDIRECT_WAIT_TIMER_EXPIRED_IND:
      WRRC_MSG2_HIGH("Freq redirect wt tmr exprd for freq %d in CSP sstate %d",
                                rrc_csp_int_data.last_camped_freq, rrc_csp_substate);

      /* In pending substate we should not care about wait timer expiry. Just to be on the
       * safe side, the variable below is set appropriately on wait timer expiry.
       */
      rrc_csp_int_data.start_acq_on_last_camped_freq = TRUE;
      break;

    case RRC_BPLMN_GUARD_SRCH_TIMER_EXPIRED_IND:
      rrccsp_cleanup_bplmn_state();
      break;

    case RRC_INITIATE_CELL_SELECTION_IND:
      if(rrc_csp_substate == RRCCSP_SUIT_CELL_SEL_WT_CAMP_PENDING)
      {
          MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );

         /* If the procedure is CU and reason for initiating cell selection is
          * TRANSITION_TO_DISCONNECTED, process the command
          */
         if(cmd_ptr->cmd.initiate_cell_sel_ind.cause == RRC_TRANSITION_TO_DISCONNECTED)
         {
           MSG_HIGH("Saving cmd 0x%x, CSP sstate %d, scan %d",
             cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, rrc_csp_int_data.curr_scan);
          rrccsp_save_req( cmd_ptr );
          next_substate = RRCCSP_SUIT_CELL_SEL_WT_CAMP_PENDING;
         }
         else
         {
           WRRC_MSG2_HIGH( "Cmd 0x%x not processed in CSP sstate %d",
                    cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);
         }
      }
      break;
#ifdef FEATURE_DUAL_SIM
      case RRC_RESET_L1_CNF:
        WRRC_MSG1_HIGH("DSIM:Recvd RRC_RESET_L1_CNF from LLC in CSP substate %d",rrc_csp_substate);
        if(rrc_csp_int_data.csp_waiting_for_wl1_to_release_lock)
        {
          rrc_csp_int_data.csp_waiting_for_wl1_to_release_lock = FALSE;
          /*Release the lock*/
          rrc_release_lock();
          next_substate = rrccsp_pending_command_handler();
        }
        else
        {
          /*Ignore*/
        }
        break;
#endif

    default:
      WRRC_MSG2_HIGH( "Cmd 0x%x not processed in CSP sstate %d",
                          cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);
      break;
  }

  return( next_substate );

} /* rrccsp_accept_cell_sel_wait_camp_pending_hdlr */


/* =======================================================================
**      Function Definitions for substate: RRCCSP_CAMPED_SUIT_CELL
** ======================================================================= */


/*===========================================================================

FUNCTION        rrccsp_camped_cell_state_transition_from_dch

DESCRIPTION
                This function processes Initiate Cell Selection due to a
                State Transition from DCH while in RRCCSP_CAMPED_SUIT_CELL
                or RRCCSP_CAMPED_ACCEPT_CELL substate.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_camped_cell_state_transition_from_dch(rrc_cmd_type *rrc_cmd_ptr)
{
  rrc_csp_substate_e_type   next_substate =  rrc_csp_substate;

  /* This function is to be called only when the current state is CELL_DCH
   */
  if(rrc_get_state() != RRC_STATE_CELL_DCH)
  {
    return(next_substate);
  }

  if(rrc_cmd_ptr->cmd.initiate_cell_sel_ind.dest_state == RRC_STATE_CELL_FACH)
  {
    WRRC_MSG0_HIGH("Start cell sel, transition DCH to FACH");
    next_substate = rrc_csp_start_sel_from_dch_to_fach(rrc_cmd_ptr);
  }
  else if((rrc_cmd_ptr->cmd.initiate_cell_sel_ind.dest_state == RRC_STATE_CELL_PCH) ||
    (rrc_cmd_ptr->cmd.initiate_cell_sel_ind.dest_state == RRC_STATE_URA_PCH))
  {
    WRRC_MSG0_HIGH("Start cell sel, transition DCH to PCH");
    next_substate = rrc_csp_start_sel_from_dch_to_pch(rrc_cmd_ptr);
  }
  else
  {
    WRRC_MSG1_ERROR("Do not handle des state %d",
        rrc_cmd_ptr->cmd.initiate_cell_sel_ind.dest_state);
  }

  return( next_substate );
} /* rrccsp_camped_cell_state_transition_from_dch */


/*===========================================================================

FUNCTION        RRCCSP_HANDLE_FREQ_REDIRECT_IN_CELL_FACH

DESCRIPTION
                This function processes Initiate Cell Selection due to a
                State Transition from FACH while in RRCCSP_CAMPED_SUIT_CELL
                or RRCCSP_CAMPED_ACCEPT_CELL substate.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_handle_freq_redirect_in_cell_fach(rrc_cmd_type *rrc_cmd_ptr)
{
  rrc_csp_substate_e_type   next_substate =  rrc_csp_substate;

  /* This function is to be called only when the current state is CELL_FACH
   */
  if(rrc_get_state() != RRC_STATE_CELL_FACH)
  {
    return(next_substate);
  }

  if(rrc_cmd_ptr->cmd.initiate_cell_sel_ind.dest_state == RRC_STATE_CELL_FACH)
  {
    WRRC_MSG0_HIGH("Start cell sel, transition FACH to FACH");
    next_substate = rrc_csp_start_sel_from_fach_to_fach(rrc_cmd_ptr);
  }
  else if((rrc_cmd_ptr->cmd.initiate_cell_sel_ind.dest_state == RRC_STATE_CELL_PCH) ||
    (rrc_cmd_ptr->cmd.initiate_cell_sel_ind.dest_state == RRC_STATE_URA_PCH))
  {
    WRRC_MSG0_HIGH("Start cell sel, transition FACH to PCH");
    next_substate = rrc_csp_start_sel_from_fach_to_pch(rrc_cmd_ptr);
  }
  else
  {
    ERR_FATAL("Do not handle des state %d",
                                           rrc_cmd_ptr->cmd.initiate_cell_sel_ind.dest_state, 0, 0);
  }

  return( next_substate );
} /* rrccsp_handle_freq_redirect_in_cell_fach */

/*===========================================================================

FUNCTION        RRCCSP_HANDLE_RRC_REDIRECT_REQ

DESCRIPTION
                This function processes redirect request in various substates
                of CSP when RRC is in CONNECTING state only.
                The wait timer is started in this function.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_handle_rrc_redirect_req(rrc_csp_substate_e_type curr_substate)
{
  rrclog_wcdma_to_wcdma_redir_start_event_type wtow_redir_event;
  rrc_csp_substate_e_type   next_substate = curr_substate;

  rrc_csp_init_inter_freq_redirection_data();

  rrctmr_start_timer(RRCTMR_FREQ_REDIRECT_WAIT_TIMER,
                              rrc_csp_int_data.freq_redirect_wait_time*1000);

  rrc_csp_int_data.curr_acq_entry.freq = rrc_csp_int_data.redirected_freq;
  WRRC_MSG1_HIGH("Start cell sel on redirected freq %d", rrc_csp_int_data.curr_acq_entry.freq);

  next_substate = rrc_csp_start_sel_redirect_freq_in_connecting_state();

  wtow_redir_event.redir_cause = WTOW_REDIR_CONN_REJECT;
  wtow_redir_event.target_freq = rrc_csp_int_data.redirected_freq;
  event_report_payload(EVENT_WCDMA_TO_WCDMA_REDIRECTION_START, sizeof(wtow_redir_event),
                 (void *)&wtow_redir_event);
  return(next_substate);
} /* rrccsp_handle_rrc_redirect_req */


/*===========================================================================

FUNCTION        RRCCSP_SEND_TRANSITION_FAILURE

DESCRIPTION
                This function sends a CELL_TRANSITION_REQ with the reselection
                failure cause.

DEPENDENCIES
                None

RETURN VALUE
                None

SIDE EFFECTS
                None

===========================================================================*/
static void rrccsp_send_transition_failure(l1_resel_fail_cause_enum_type fail_cause)
{
  rrc_cmd_type *chan_config_req_ptr;
  rrc_cmd_type *csp_out_cmd_ptr;

  /* set the following to TRUE if a new cell has been selected through
   * cell selection or reselection. Set to FALSE if a new
   * cell reselection failed.
   */
  boolean cell_reselection_status = FALSE;

  /* Set the following to TRUE if we can go back to the existing serving
   * cell. This is only used if new_cell_selection_succeeded
   * is set to FALSE. Set to FALSE if the existing cell is
   * no longer valid and the new cell selection failed. */
  boolean existing_serving_cell_valid = TRUE;

  rrc_plmn_identity_type sib_idx_plmn_id;
#ifdef FEATURE_QSH_EVENT_METRIC
  wrrc_qsh_log_cell_resel_stats(CELL_RESEL_FAIL,WRRC_METRIC_UPDATE);  
#endif

  
  if(rrc_csp_int_data.curr_acq_entry.is_valid_nw_sharing)
  {
    sib_idx_plmn_id = rrc_csp_int_data.curr_acq_entry.shared_list_of_plmns.common_plmn_id;
  }
  else
  {
    sib_idx_plmn_id = rrc_csp_int_data.curr_acq_entry.plmn_id;
  }
  WRRC_MSG2_HIGH("Sib_idx PLMN: MCC %d-MNC %d",RRC_CSP_GET_INT_MCC(sib_idx_plmn_id),RRC_CSP_GET_INT_MNC(sib_idx_plmn_id));
  if(rrcllc_get_n_bcch_setup_status() == FALSE)
  {
    WRRC_MSG0_HIGH("N-BCCH Physical channel setup failed for reselection");
  }
   /* Teardown the N-BCH first and then send the transition request to L1 */
  else if( (chan_config_req_ptr = rrc_get_int_cmd_buf())!=NULL )
  {
    WRRC_MSG0_HIGH("Sending Channel Config to tear down N-BCCH");
    //Fill in the relevant values for the command
    chan_config_req_ptr->cmd_hdr.cmd_id = RRC_CHANNEL_CONFIG_REQ;
    chan_config_req_ptr->cmd.chan_config_req.num_rb_to_config =1;
    chan_config_req_ptr->cmd.chan_config_req.rb[0].rb_id = BCCH_N_RADIO_BEARER_ID;
    chan_config_req_ptr->cmd.chan_config_req.rb[0].rb_config = RELEASE_RB;
    chan_config_req_ptr->cmd.chan_config_req.rrc_state_change_required = FALSE;
    chan_config_req_ptr->cmd.chan_config_req.procedure = RRC_PROCEDURE_CSP;
    chan_config_req_ptr->cmd.chan_config_req.rrc_channel_config_cnf_required = FALSE;
    chan_config_req_ptr->cmd.chan_config_req.chan_config_reason =
      RRCLLC_CHAN_CFG_REASON_NONE;
    chan_config_req_ptr->cmd.chan_config_req.release_trchls = FALSE;
    chan_config_req_ptr->cmd.chan_config_req.release_phychls = FALSE;
    rrc_put_int_cmd( chan_config_req_ptr );
  }
  if((csp_out_cmd_ptr = rrc_get_int_cmd_buf()) != NULL)
  {
    l1_req_cmd * csp_cmd_l1_req = NULL;
    RRC_GET_POINTER_L1_REQ_VALUE(csp_out_cmd_ptr->cmd.rrc_llc_req.l1_req,csp_cmd_l1_req);

    /* Initialize the LLC command header first */
    csp_out_cmd_ptr->cmd_hdr.cmd_id= RRC_LLC_CMD_REQ;
    csp_out_cmd_ptr->cmd.rrc_llc_req.procedure = RRC_PROCEDURE_CSP;
    csp_out_cmd_ptr->cmd.rrc_llc_req.cmd_dest = LAYER1_PHY;

    /* Now fill the L1 cmd header */
    csp_out_cmd_ptr->cmd.rrc_llc_req.l1_cmd.cmd_id = CPHY_CELL_TRANSITION_REQ;
    csp_out_cmd_ptr->cmd.rrc_llc_req.l1_cmd.act_time_type =
                                                L1_ACTIVATION_TIME_NONE;

    csp_cmd_l1_req->cell_transition.cell_trans_params.select_type = L1_ASET_UPD_CELL_RESELECTION_FAILURE;
    csp_cmd_l1_req->cell_transition.cell_trans_params.resel_fail_cause = fail_cause;

    csp_cmd_l1_req->cell_transition.setup_cmd.req_mask  = 0;

    /* Always use current cell freq and scrambling code instead from sib_cnf */
    csp_cmd_l1_req->cell_transition.cell_trans_params.cell_type = L1_RESEL_WCDMA;

    csp_cmd_l1_req->cell_transition.setup_cmd.rf_chan = rrc_csp_int_data.new_cell_acq_entry.freq;
    csp_cmd_l1_req->cell_transition.cell_trans_params.scr_code  = rrc_csp_int_data.new_cell_acq_entry.scr_code;
    csp_cmd_l1_req->cell_transition.setup_cmd.freq_incl= TRUE;

    csp_cmd_l1_req->cell_transition.setup_cmd.dl_cctrch_info    = NULL;
    csp_cmd_l1_req->cell_transition.setup_cmd.dl_phychan_db = NULL;
    csp_cmd_l1_req->cell_transition.setup_cmd.dl_ctfc_info      = NULL;
    csp_cmd_l1_req->cell_transition.setup_cmd.ul_cctrch_info    = NULL;
    csp_cmd_l1_req->cell_transition.setup_cmd.ul_phychan_db = NULL;
    csp_cmd_l1_req->cell_transition.setup_cmd.tfcs_ptr          = NULL;

    csp_cmd_l1_req->cell_transition.cell_trans_params.tg_freq_excl = FALSE;
    csp_cmd_l1_req->cell_transition.cell_trans_params.tg_cell_excl = FALSE;
    
    csp_cmd_l1_req->cell_transition.setup_cmd.mac_e_reset_indicator = FALSE;
    csp_cmd_l1_req->cell_transition.setup_cmd.call_type_mask = 0;
    csp_cmd_l1_req->cell_transition.setup_cmd.is_emergency_call = FALSE;
    csp_cmd_l1_req->cell_transition.setup_cmd.transition_to_dch = FALSE;
    csp_cmd_l1_req->cell_transition.setup_cmd.dl_phychan_db = NULL;
    csp_cmd_l1_req->cell_transition.setup_cmd.ul_phychan_db = NULL;
    csp_cmd_l1_req->cell_transition.setup_cmd.e_info_ptr = NULL;
#ifdef FEATURE_WCDMA_HS_RACH
    csp_cmd_l1_req->cell_transition.setup_cmd.hs_rach_e_info_ptr = NULL;
#endif
    csp_cmd_l1_req->cell_transition.setup_cmd.l1_hs_scch_order_action = L1_HS_SCCH_ORDER_ACTION_BACKUP;
    csp_cmd_l1_req->cell_transition.cell_trans_params.pccpch_tx_div_ind = rrcllc_get_correct_pccpch_tx_diversity_from_sibs(rrc_get_state());

    /* Send the Internal RRC Command - LLC should directly handle it */
    WRRC_MSG1_HIGH("Sending L1 cmd 0x%x", csp_out_cmd_ptr->cmd_hdr.cmd_id);
    rrc_put_int_cmd( csp_out_cmd_ptr );
  }

#ifdef FEATURE_WCDMA_DEFERRED_SIB11_12_READING
    WRRC_MSG0_HIGH("Deferred SIB: UPDATE_SIBS activated");
    rrcsib_update_sib_for_deferred_sib();
#endif

  /* Indicate to SIB procedure about the reselection failure */
  if(rrcsib_change_serving_cell_status(cell_reselection_status, existing_serving_cell_valid,
                                    sib_idx_plmn_id,
                                    rrc_csp_int_data.curr_acq_entry.cell_id) == FAILURE)
  {
    WRRC_MSG0_ERROR("Could not find PLMN/CellId");
  }
  rrc_csp_int_data.cel_trans_cnf_recvd_at_llc = FALSE;
}


/*===========================================================================

FUNCTION        RRCCSP_SEND_TRANSITION_FAILURE_ON_RECEIPT_OF_RESEL_IND

DESCRIPTION
                This function sends a CELL_TRANSITION_REQ with the reselection
                failure cause. This function is called when PCCO is in progress
                or Manual BPLMN search is in progress or when RRC is in compatible state
                and L1 sends reselection indication to RRC. In this case, RRC will always 
                reject reselection indication until RRC reaches to a suitable state. 

DEPENDENCIES
                None

RETURN VALUE
                None

SIDE EFFECTS
                None

===========================================================================*/
static void rrccsp_send_transition_failure_on_receipt_of_resel_ind(rrc_cmd_type *cmd_ptr, l1_resel_fail_cause_enum_type fail_cause)
{
  rrc_cmd_type *csp_out_cmd_ptr;
 
#ifdef FEATURE_QSH_EVENT_METRIC
  wrrc_qsh_log_cell_resel_stats(CELL_RESEL_FAIL,WRRC_METRIC_UPDATE);   
#endif
  if((csp_out_cmd_ptr = rrc_get_int_cmd_buf()) != NULL)
  {
    l1_req_cmd * csp_cmd_l1_req = NULL;
    RRC_GET_POINTER_L1_REQ_VALUE(csp_out_cmd_ptr->cmd.rrc_llc_req.l1_req,csp_cmd_l1_req);

    /* Initialize the LLC command header first */
    csp_out_cmd_ptr->cmd_hdr.cmd_id= RRC_LLC_CMD_REQ;
    csp_out_cmd_ptr->cmd.rrc_llc_req.procedure = RRC_PROCEDURE_CSP;
    csp_out_cmd_ptr->cmd.rrc_llc_req.cmd_dest = LAYER1_PHY;

    /* Now fill the L1 cmd header */
    csp_out_cmd_ptr->cmd.rrc_llc_req.l1_cmd.cmd_id = CPHY_CELL_TRANSITION_REQ;
    csp_out_cmd_ptr->cmd.rrc_llc_req.l1_cmd.act_time_type = L1_ACTIVATION_TIME_NONE;

    csp_cmd_l1_req->cell_transition.cell_trans_params.select_type = L1_ASET_UPD_CELL_RESELECTION_FAILURE;
    csp_cmd_l1_req->cell_transition.cell_trans_params.resel_fail_cause = fail_cause;

    csp_cmd_l1_req->cell_transition.setup_cmd.req_mask  = 0;
    csp_cmd_l1_req->cell_transition.setup_cmd.freq_incl = TRUE;

    csp_cmd_l1_req->cell_transition.setup_cmd.dl_cctrch_info    = NULL;
    csp_cmd_l1_req->cell_transition.setup_cmd.dl_phychan_db = NULL;
    csp_cmd_l1_req->cell_transition.setup_cmd.dl_ctfc_info      = NULL;
    csp_cmd_l1_req->cell_transition.setup_cmd.ul_cctrch_info    = NULL;
    csp_cmd_l1_req->cell_transition.setup_cmd.ul_phychan_db = NULL;
    csp_cmd_l1_req->cell_transition.setup_cmd.tfcs_ptr          = NULL;

    csp_cmd_l1_req->cell_transition.cell_trans_params.tg_freq_excl = FALSE;
    csp_cmd_l1_req->cell_transition.cell_trans_params.tg_cell_excl = FALSE;
    csp_cmd_l1_req->cell_transition.setup_cmd.mac_e_reset_indicator = FALSE;
    csp_cmd_l1_req->cell_transition.setup_cmd.call_type_mask = 0;
    csp_cmd_l1_req->cell_transition.setup_cmd.is_emergency_call = FALSE;
    csp_cmd_l1_req->cell_transition.setup_cmd.transition_to_dch = FALSE;
    csp_cmd_l1_req->cell_transition.setup_cmd.dl_phychan_db = NULL;
    csp_cmd_l1_req->cell_transition.setup_cmd.ul_phychan_db = NULL;
    csp_cmd_l1_req->cell_transition.setup_cmd.e_info_ptr = NULL;
#ifdef FEATURE_WCDMA_HS_RACH
    csp_cmd_l1_req->cell_transition.setup_cmd.hs_rach_e_info_ptr = NULL;
#endif

    csp_cmd_l1_req->cell_transition.setup_cmd.l1_hs_scch_order_action = L1_HS_SCCH_ORDER_ACTION_BACKUP;

    csp_cmd_l1_req->cell_transition.cell_trans_params.pccpch_tx_div_ind = rrcllc_get_correct_pccpch_tx_diversity_from_sibs(rrc_get_state());

    if(cmd_ptr->cmd.cell_rsel_ind.cell == L1_RESEL_WCDMA)
    {
      csp_cmd_l1_req->cell_transition.cell_trans_params.cell_type = L1_RESEL_WCDMA;
      csp_cmd_l1_req->cell_transition.setup_cmd.rf_chan=
                                      cmd_ptr->cmd.cell_rsel_ind.u.wcdma_info.freq;
      csp_cmd_l1_req->cell_transition.cell_trans_params.scr_code =
                                      cmd_ptr->cmd.cell_rsel_ind.u.wcdma_info.scr_code;
    } 
    else if (cmd_ptr->cmd.cell_rsel_ind.cell == L1_RESEL_GSM)
    {
      csp_cmd_l1_req->cell_transition.cell_trans_params.cell_type = L1_RESEL_GSM;
      csp_cmd_l1_req->cell_transition.cell_trans_params.gsm_info.bsic = 
                                         cmd_ptr->cmd.cell_rsel_ind.u.gsm_info.cell_info.bsic;
      csp_cmd_l1_req->cell_transition.cell_trans_params.gsm_info.bcch_arfcn = 
                                   cmd_ptr->cmd.cell_rsel_ind.u.gsm_info.cell_info.bcch_arfcn;
    }
    else if (cmd_ptr->cmd.cell_rsel_ind.cell == L1_RESEL_LTE)
    {
      csp_cmd_l1_req->cell_transition.cell_trans_params.cell_type = L1_RESEL_LTE;
    }
    else
    {
      WRRC_MSG1_ERROR("Incorrect cell system type %d", cmd_ptr->cmd.cell_rsel_ind.cell);
      csp_cmd_l1_req->cell_transition.cell_trans_params.cell_type = L1_RESEL_WCDMA;
      /* Always use current cell freq and scrambling code instead from sib_cnf */
      csp_cmd_l1_req->cell_transition.setup_cmd.rf_chan= 0;
      csp_cmd_l1_req->cell_transition.cell_trans_params.scr_code = 0;
    }
      
    /* Send the Internal RRC Command - LLC should directly handle it */
    WRRC_MSG1_HIGH("Sending L1 cmd 0x%x", csp_out_cmd_ptr->cmd_hdr.cmd_id);
    rrc_put_int_cmd( csp_out_cmd_ptr );
  }
  rrc_csp_int_data.cel_trans_cnf_recvd_at_llc = FALSE;
} /* rrccsp_send_transition_failure_on_receipt_of_resel_ind */


/*===========================================================================

FUNCTION        RRCCSP_SEND_NBCCH_TEARDOWN_REQ

DESCRIPTION
                This function sends a neighbor BCCH tear down request.


DEPENDENCIES
                None

RETURN VALUE
                None

SIDE EFFECTS
                None

===========================================================================*/
static void rrccsp_send_nbcch_teardown_req(void)
{
  rrc_cmd_type *chan_config_req_ptr;

  /* set the following to TRUE if a new cell has been selected through
   * cell selection or reselection. Set to FALSE if a new
   * cell reselection failed.
   */
  boolean cell_reselection_status = FALSE;

  /* Set the following to TRUE if we can go back to the existing serving
   * cell. This is only used if new_cell_selection_succeeded
   * is set to FALSE. Set to FALSE if the existing cell is
   * no longer valid and the new cell selection failed. */
  boolean existing_serving_cell_valid = TRUE;

  rrc_plmn_identity_type sib_idx_plmn_id;
  if(rrc_csp_int_data.curr_acq_entry.is_valid_nw_sharing)
  {
    sib_idx_plmn_id = rrc_csp_int_data.curr_acq_entry.shared_list_of_plmns.common_plmn_id;
  }
  else
  {
    sib_idx_plmn_id = rrc_csp_int_data.curr_acq_entry.plmn_id;
  }
  WRRC_MSG2_HIGH("Sib_idx PLMN: MCC %d-MNC %d",RRC_CSP_GET_INT_MCC(sib_idx_plmn_id),RRC_CSP_GET_INT_MNC(sib_idx_plmn_id));
  /* Teardown the N-BCCH */
  if( (chan_config_req_ptr = rrc_get_int_cmd_buf())!=NULL )
  {
    WRRC_MSG0_HIGH("Tearing down N-BCCH");
    //Fill in the relevant values for the command
    chan_config_req_ptr->cmd_hdr.cmd_id = RRC_CHANNEL_CONFIG_REQ;
    chan_config_req_ptr->cmd.chan_config_req.num_rb_to_config =1;
    chan_config_req_ptr->cmd.chan_config_req.rb[0].rb_id = BCCH_N_RADIO_BEARER_ID;
    chan_config_req_ptr->cmd.chan_config_req.rb[0].rb_config = RELEASE_RB;
    chan_config_req_ptr->cmd.chan_config_req.rrc_state_change_required = FALSE;
    chan_config_req_ptr->cmd.chan_config_req.procedure = RRC_PROCEDURE_CSP;
    chan_config_req_ptr->cmd.chan_config_req.rrc_channel_config_cnf_required = FALSE;
    chan_config_req_ptr->cmd.chan_config_req.chan_config_reason =
      RRCLLC_CHAN_CFG_REASON_NONE;
    chan_config_req_ptr->cmd.chan_config_req.release_trchls = FALSE;
    chan_config_req_ptr->cmd.chan_config_req.release_phychls = FALSE;
    rrc_put_int_cmd( chan_config_req_ptr );
  }

    /* Indicate to SIB procedure about the reselection failure */
  if(rrcsib_change_serving_cell_status(cell_reselection_status, existing_serving_cell_valid,
                                    sib_idx_plmn_id,
                                    rrc_csp_int_data.curr_acq_entry.cell_id) == FAILURE)
  {
    WRRC_MSG0_ERROR("Could not find PLMN/CellId");
  }

} /* rrccsp_send_nbcch_teardown_req */


/*===========================================================================

FUNCTION        RRCCSP_CAMPED_SUIT_CELL_RESELECTION_IND

DESCRIPTION
                This function processes a Reselection Indication while
                waiting in RRCCSP_CAMPED_SUIT_CELL substate.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_camped_suit_cell_reselection_ind( rrc_cmd_type *cmd_ptr )
{
  rrc_csp_substate_e_type  next_substate;
  rrc_csp_sib_mask_type    sib_mask = 0;

  next_substate = RRCCSP_CAMPED_SUIT_CELL;
  /* Store the information for the new cell to be selected */
  rrc_csp_int_data.new_cell_acq_entry.freq = cmd_ptr->cmd.cell_rsel_ind.u.wcdma_info.freq;
  rrc_csp_int_data.new_cell_acq_entry.scr_code = cmd_ptr->cmd.cell_rsel_ind.u.wcdma_info.scr_code;


   /* Get all the SIBs here */
  sib_mask = MIB_BIT|SIB_1_BIT|SIB_2_BIT|SIB_3_BIT|SIB_4_BIT|SIB_5_BIT|SIB_6_BIT|SIB_7_BIT|SIB_11_BIT|SIB_12_BIT|SIB_18_BIT;

  /*SIB11bis is an extension type SIB, so add SIB_11BIS_BIT mask to read Sib11bis*/
  sib_mask = sib_mask|SIB_11BIS_BIT;

#ifdef FEATURE_WCDMA_TO_LTE
  sib_mask = sib_mask | SIB_19_BIT;
#endif

  if(rrc_csp_send_sib_cmd(RRC_GET_SPECIFIC_SIBS_REQ, sib_mask,
                          &rrc_csp_int_data.new_cell_acq_entry,
                          FALSE ) == SUCCESS)
  {
    MSG_MED( "RRC Cmd 0x%x sent, CSP sstate %d",
                                     RRC_GET_SPECIFIC_SIBS_REQ, RRCCSP_CAMPED_SUIT_CELL, 0 );
    /* Start waiting for SIB Confirmation */
    next_substate = RRCCSP_SUIT_CELL_RESELECT_WT_SIB;
  }
  else
  {
    ERR_FATAL("Failure to send SIB cmd 0x%x in CSP substate %d",
                                 RRC_GET_SPECIFIC_SIBS_REQ, RRCCSP_CAMPED_SUIT_CELL, 0);
  }

  return next_substate;

}/* rrccsp_camped_suit_cell_reselection_ind */

/*===========================================================================

FUNCTION        rrc_csp_handle_initiate_cell_sel_in_wait_for_sib_for_resel

DESCRIPTION     This function handles the initiate cell selection indication received 
                while waiting for sibs during reselection
                CSP is waiting for SIB Confirm.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/

static rrc_csp_substate_e_type rrc_csp_handle_initiate_cell_sel_in_wait_for_sib_for_resel(rrc_cmd_type *cmd_ptr)
{
  rrc_csp_substate_e_type  next_substate = rrc_csp_substate;

  if(cmd_ptr->cmd.initiate_cell_sel_ind.cause == RRC_CELL_SEL_RB0_SETUP_FAILURE)
  {
    WRRC_MSG0_HIGH("Start cell sel RB0 failure, treat as OOS");
    /* Reset the reselection data */
    rrccsp_reset_reselection_data();
    next_substate =
    rrccsp_handle_out_of_service_ind( rrc_csp_substate );
  }
  else if(cmd_ptr->cmd.initiate_cell_sel_ind.cause == RRC_OUT_OF_SERVICE_AREA_IND)
  {
    WRRC_MSG1_HIGH("OOS initiated by proc rrc_proc_e_type_value%d",
    cmd_ptr->cmd.initiate_cell_sel_ind.proc);
    /* Reset the reselection data */
    rrccsp_reset_reselection_data();
    next_substate =
    rrccsp_handle_out_of_service_ind( rrc_csp_substate );
  }
  else if(cmd_ptr->cmd.initiate_cell_sel_ind.cause == RRC_TRANSITION_TO_DISCONNECTED)
  {
    /* First Initialize the SIB variables */
    /* Signal SIB procedure to clear up the active event, if any */
    rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_NGH_OOS);
  
    /* Reset the reselection data */
    rrccsp_reset_reselection_data();
  
    /* Release all channels and put lower layers to Idle  */
    rrc_csp_send_chan_release();

  #ifdef FEATURE_DISCONNECT_ON_UNSUPPORTED_IRAT_REDIRECTION
  /*If dual mode disabled and redirection to GSM, then trigger OOS and go to idle with no servce*/
    if (cmd_ptr->cmd.initiate_cell_sel_ind.tx_to_discon_reason == RRC_TX_TO_DISCON_UNSUPPORTED_REDIRECTION)
    {
  /* First call a CCM function to indicate Cell Loss - no new cell */
      rrc_ccm_update_with_cell_loss();
      next_substate = rrccsp_rel_chls_and_go_to_idle();
    }
    else
  #endif
      next_substate = rrc_csp_start_sel_leaving_conn_mode();
  }
  else
  {
    WRRC_MSG2_HIGH("Cause %d not handled %d CSP sstate ",
    cmd_ptr->cmd.initiate_cell_sel_ind.cause, rrc_csp_substate);
  }
  return next_substate;
}

/*===========================================================================

FUNCTION        rrccsp_cell_resel_wait_sib_sib

DESCRIPTION
                This function handles a SIB Confirm event while waiting on
                one. The Confirm event could come with a status of Pass or
                Failure. If the status indicates a Failure then we continue to
                camp on the previous suitable cell.


DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_cell_resel_wait_sib_sib( rrc_cmd_type *cmd_ptr )
{
  rrc_csp_substate_e_type  next_substate;

  /* Temporary storage for PLMN status */
  rrc_csp_plmn_status_e_type  cell_plmn_status;
  /* Temporary Storage for Cell Access Restrictions */
  rrc_csp_access_control_e_type  access_control;
  /* Temporary storage for Cell Barred Status */
  rrc_csp_cell_bar_e_type  cell_bar_status;

  rrc_dsac_info_type rrc_dsac_info;
  rrc_ppac_info_type rrc_ppac_info;

  /* Indicates if UE needs stay camped on the barred cell (or) not */
  boolean stay_on_ac_barred_cell = FALSE;

  /* Indicates if we need to remain on the current cell */
  boolean  remain_on_current_cell = FALSE;
  boolean  is_nbr_s_criteria_failed = FALSE;

  rrc_csp_cell_actual_vs_expected_e_type cell_status = RRC_CSP_CELL_BELOW_EXPECTED;
  rrc_plmn_identity_type sib_read_plmn_id;

  rrc_MasterInformationBlock *mib_ptr;

  boolean  bar_freq_for_resel_only = FALSE;
  /* This variable is set to TRUE when either the lai is forbidden or 
       the PLMN is non-eplmn.
  */

  l1_resel_fail_cause_enum_type fail_cause = L1_RESEL_FAIL_CAUSE_NONE;
  
  rrc_csp_int_data.bar_for_resel_only= FALSE;
  
  rrc_csp_int_data.non_eq_plmn_barred = FALSE;

#ifdef FEATURE_STAY_CAMPED_ON_ACCESS_CLASS_BARRED_CELL
  /* set this flag as TRUE if this feature is defined */
  stay_on_ac_barred_cell = TRUE;
#endif /* FEATURE_STAY_CAMPED_ON_ACCESS_CLASS_BARRED_CELL */

  next_substate = rrc_csp_substate;

  /* Check if frequency and scrambling code returned by SIB in confirm
   * is the same as was passed to it.
   */
  if((rrc_csp_int_data.new_cell_acq_entry.freq !=
      (rrc_freq_type)cmd_ptr->cmd.get_sibs_cnf.freq) ||
     (rrc_csp_int_data.new_cell_acq_entry.scr_code !=
      cmd_ptr->cmd.get_sibs_cnf.scrambling_code))
  {
    MSG_4(MSG_SSID_DFLT,MSG_LEGACY_HIGH,"SIB Confirm has diff freq %d or scr_code %d, Freq %d, scr_code %d was sent to SIB",
          (rrc_freq_type)cmd_ptr->cmd.get_sibs_cnf.freq,
          cmd_ptr->cmd.get_sibs_cnf.scrambling_code,
          rrc_csp_int_data.new_cell_acq_entry.freq,
          rrc_csp_int_data.new_cell_acq_entry.scr_code);

    /* Send a TRANSITION_REQ to L1 with failure */
    rrccsp_send_transition_failure(RRC_RESEL_FAIL_CAUSE_INTERNAL);
    if(rrc_csp_substate == RRCCSP_SUIT_CELL_RESELECT_WT_SIB)
    {
      next_substate = RRCCSP_SUIT_CELL_RESELECT_WT_TRANS_CNF;
    }
    else
    {
      next_substate = RRCCSP_ACCEPT_CELL_RESELECT_WT_TRANS_CNF;
    }
    remain_on_current_cell = TRUE;
  }
  else
  {
    /* When Channel config for CU is in progress, do not allow reselection */
    if(rrccu_is_channel_config_in_process() == TRUE)
    {
      WRRC_MSG0_HIGH("Channel config for CU is in progress, fail sib even for reselection");
      cmd_ptr->cmd.get_sibs_cnf.status = SIB_EVENT_FAILED_LOWER_LAYERS;
    }
    if (cmd_ptr->cmd.get_sibs_cnf.status == SIB_EVENT_SUCCEEDED)
    { /* SIBs have been successfully received */

      /* Check if OC has been set for DCH by a Reconfig message. If it has
       * been set for DCH drop the reselection and go back to cell camped
       * state
       */
      if(rrcllc_get_ordered_config_status() == OC_SET_FOR_CELL_DCH) 
      {
        WRRC_MSG0_HIGH("OC set for DCH drop cell reselection");
        remain_on_current_cell = TRUE;
      }
      else
      {
        /* This PLMN (common PLMN) should be used only if sharing is not there or
         * if it is indicated as valid */
        sib_read_plmn_id = cmd_ptr->cmd.get_sibs_cnf.plmn_id;

        /* 1.Get the MIB ptr.
          * 2.Construct the shared PLMN list
          */
        mib_ptr = (rrc_MasterInformationBlock *) rrc_sibdb_return_sib_for_cell(
                                                                                rrc_MIB,
                                                                                cmd_ptr->cmd.get_sibs_cnf.plmn_id,
                                                                                cmd_ptr->cmd.get_sibs_cnf.cell_id
                                                                               );

        if( mib_ptr == NULL )
        {
          /* SIB3 is NULL This should NOT happen */
          ERR_FATAL("MIB not read but sib_cnf returned w SUCCESS", 0, 0, 0);
        }

        if(rrc_is_nw_shared(mib_ptr))
        {
          rrccsp_find_shared_plmns(
                                   mib_ptr,
                                   cmd_ptr->cmd.get_sibs_cnf.plmn_id,
                                   &rrc_csp_int_data.curr_nw_db_entry
                                   );

          /* Prioritize the NAS requested PLMN/HPLMN based on the current scan type  This is because 
           * our search for good PLMNs is sequential in the list of shared PLMNs and if there is a low priority
           * PLMN (eplmn) available ahead of the needed PLMN then we may end up in camping on it even though
           * the requested PLMN is available */
          rrccsp_prioritize_the_list_of_shared_plmns();
          rrc_csp_int_data.new_cell_acq_entry.is_valid_nw_sharing = TRUE;
          rrc_csp_int_data.new_cell_acq_entry.cell_id = cmd_ptr->cmd.get_sibs_cnf.cell_id;
#ifdef FEATURE_FEMTO_CSG
          rrc_csp_int_data.new_cell_acq_entry.csg_id = cmd_ptr->cmd.get_sibs_cnf.csg_id;
#endif
          rrc_csp_int_data.new_cell_acq_entry.plmn_id = rrc_csp_int_data.curr_nw_db_entry.shared_plmns_access_info[0].plmn_id;
          sib_read_plmn_id = rrc_csp_int_data.new_cell_acq_entry.plmn_id;
        }
        else
        {
          rrc_csp_int_data.new_cell_acq_entry.is_valid_nw_sharing = FALSE;
        }

#ifdef FEATURE_FEMTO_CSG
        rrc_csp_int_data.new_cell_acq_entry.cell_is_hybrid = rrc_csp_int_data.curr_acq_entry.cell_is_hybrid;
#endif


        if(rrc_csp_find_access_control(&access_control, &rrc_dsac_info,sib_read_plmn_id,
                                       (rrc_int_cell_id_type)cmd_ptr->cmd.get_sibs_cnf.cell_id
                                       ,cmd_ptr->cmd.get_sibs_cnf.plmn_id
                                       ,&rrc_ppac_info
                                       )
          == FAILURE)
        {
          WRRC_MSG1_HIGH("Failure finding cell access status in CSP sstate %d",
                                                     next_substate);
          rrccsp_send_transition_failure(RRC_RESEL_FAIL_CAUSE_INTERNAL);
          if(rrc_csp_substate == RRCCSP_SUIT_CELL_RESELECT_WT_SIB)
          {
            next_substate = RRCCSP_SUIT_CELL_RESELECT_WT_TRANS_CNF;
          }
          else
          {
            next_substate = RRCCSP_ACCEPT_CELL_RESELECT_WT_TRANS_CNF;
          }
          remain_on_current_cell = TRUE;
        }
        /* Fill the Neigh Acq. entry (including status mask) in Internal data with SIB data */
        else if(rrc_csp_fill_acq_entry_from_sib(&cmd_ptr->cmd.get_sibs_cnf,
                                           &rrc_csp_int_data.new_cell_acq_entry,
                                           &cell_bar_status)
           == FAILURE)
        {
          rrccsp_send_transition_failure(RRC_RESEL_FAIL_CAUSE_INTERNAL);
          if(rrc_csp_substate == RRCCSP_SUIT_CELL_RESELECT_WT_SIB)
          {
            next_substate = RRCCSP_SUIT_CELL_RESELECT_WT_TRANS_CNF;
          }
          else
          {
            next_substate = RRCCSP_ACCEPT_CELL_RESELECT_WT_TRANS_CNF;
          }
          remain_on_current_cell = TRUE;
          WRRC_MSG1_ERROR("Failure filling acq. entry in CSP subststate %d", next_substate);
        }
        else if((rrc_dsac_info.valid == FALSE) && (access_control == RRC_CSP_NO_CELL_ACCESS) && !stay_on_ac_barred_cell)
        {
          /* Since not even Emergency calls are allowed, no point in selecting this cell.
           * Move to the next one.
           */
          WRRC_MSG0_HIGH("During resel no cell access on ncell. Remain on c-cell");
          rrccsp_send_transition_failure(L1_RESEL_FAIL_CAUSE_BARRED_CELL);

          /* Cell is not barred */
          if(cell_bar_status == RRC_CSP_CELL_OK)
          {
            WRRC_MSG0_HIGH("bar neighbor cell for 40s");
            /* Send Cell bar request to L1 */
            rrccsp_send_cphy_cell_bar_req(RRC_CSP_WCDMA_PSC_BARRED, 40);
          }
          /* Cell is barred also */
          else
          {
            if(cell_bar_status == RRC_CSP_CELL_BAR_INTRA_FREQ)
            {
              /* Send Cell bar request to L1 */
              rrccsp_send_cphy_cell_bar_req(RRC_CSP_WCDMA_PSC_BARRED, 
                                                    rrc_csp_int_data.wcdma_cell_time_to_reselect);
            }
            else
            {
              /* Send Cell bar request to L1 */
              rrccsp_send_cphy_cell_bar_req(RRC_CSP_WCDMA_FREQ_BARRED, 
                                                    rrc_csp_int_data.wcdma_cell_time_to_reselect);
            }
          }
          if(rrc_csp_substate == RRCCSP_SUIT_CELL_RESELECT_WT_SIB)
          {
            next_substate = RRCCSP_SUIT_CELL_RESELECT_WT_TRANS_CNF;
          }
          else
          {
            next_substate = RRCCSP_ACCEPT_CELL_RESELECT_WT_TRANS_CNF;
          }
          remain_on_current_cell = TRUE;
        }
        else 
        {
          /* Caution: Cell bar request is sent later - after calling the 
           * function rrc_csp_compare_expected_cell() below. Notice that
           * it is determined (after reading SIB3) that the cell is 
           * barred or not when function rrc_csp_fill_acq_entry_from_sib()
           * above is called. Just that the actual cell bar request is 
           * sent to L1 after transition failure - it was a requirement
           * from L1.
           */

          cell_status = rrccsp_get_cell_status(&cell_plmn_status,
                                               &rrc_csp_int_data.new_cell_acq_entry
                                               ,&rrc_csp_int_data.curr_nw_db_entry
                                               );
          if(rrc_csp_substate == RRCCSP_SUIT_CELL_RESELECT_WT_SIB)
          {
            bar_freq_for_resel_only = rrc_csp_int_data.bar_for_resel_only;
            rrc_csp_int_data.bar_for_resel_only = FALSE;
          }

          if( (cell_status == RRC_CSP_CELL_BELOW_EXPECTED) && 
              (rrc_csp_int_data.curr_type_acq == RRC_CSP_ANY_PLMN) &&
              (!(rrc_csp_int_data.new_cell_acq_entry.status_mask & RRC_CSP_IDLE_CELL_BAR_BIT)) )
          {
             /* Forbidden LAI */
             /* As non forbidden LAI is not found allow limited service on the current LAI */
             cell_status = RRC_CSP_CELL_AS_EXPECTED;
          }

          if(cell_status == RRC_CSP_CELL_BELOW_EXPECTED)
          {
            /* If this cell is NOT good enough, move to the next freq */
             WRRC_MSG0_HIGH("Cell below expected, remain on curr cell");
             rrccsp_send_transition_failure(L1_RESEL_FAIL_CAUSE_BARRED_CELL);

             if(cell_bar_status == RRC_CSP_CELL_BAR_INTRA_FREQ)
             {
               /* Send Cell bar request to L1 */
               rrccsp_send_cphy_cell_bar_req(RRC_CSP_WCDMA_PSC_BARRED, 
                                                     rrc_csp_int_data.wcdma_cell_time_to_reselect);
             }
             else if(cell_bar_status == RRC_CSP_CELL_BAR_NO_INTRA_FREQ)
             {
               /* Send Cell bar request to L1 */
               rrccsp_send_cphy_cell_bar_req(RRC_CSP_WCDMA_FREQ_BARRED, 
                                                     rrc_csp_int_data.wcdma_cell_time_to_reselect);
             }
             else if(rrc_csp_substate == RRCCSP_SUIT_CELL_RESELECT_WT_SIB)
             {
               if(rrc_csp_int_data.new_cell_acq_entry.status_mask & RRC_CSP_FORBID_REG_AREA_BIT) 
               {
                 WRRC_MSG0_HIGH("CR151: LAI is forbidden. Bar freq.");
                 bar_freq_for_resel_only = TRUE;
               }
               if (bar_freq_for_resel_only)
               {
                 WRRC_MSG0_HIGH("CR151: sending CPHY_CELL_BAR_REQ to L1 ");
                  rrc_csp_int_data.bar_for_resel_only = TRUE;
                 /* Send Cell bar request to L1 */
                 rrccsp_send_cphy_cell_bar_req(RRC_CSP_WCDMA_FREQ_BARRED, 
                                                                            FORBIDDEN_RESEL_FREQ_BAR_TIMER_IN_SEC);
                 rrc_csp_int_data.non_eq_plmn_barred = FALSE;                                                               
                 rrc_csp_int_data.bar_for_resel_only = FALSE;
               }
             }
             if(rrc_csp_substate == RRCCSP_SUIT_CELL_RESELECT_WT_SIB)
             {
               next_substate = RRCCSP_SUIT_CELL_RESELECT_WT_TRANS_CNF;
             }
             else
             {
               next_substate = RRCCSP_ACCEPT_CELL_RESELECT_WT_TRANS_CNF;
             }
             remain_on_current_cell = TRUE;
          }
          else  /* Cell not below expectation */
          {
            rrccsp_add_acq_db_and_nw_db_entries(&rrc_csp_int_data.new_cell_acq_entry,&rrc_csp_int_data.curr_nw_db_entry);
            /* Check if the neighbor cell satisfies S-criteria */
            if(rrc_is_nbr_s_criteria_met(rrc_csp_int_data.new_cell_acq_entry.plmn_id,
                                         (rrc_int_cell_id_type)cmd_ptr->cmd.get_sibs_cnf.cell_id))
            {
              /* Cell meets expectations. Send Cell Change Req to Cell Change Manager */

              /* Set the current scan type to CELL_RESELECTION */
              rrc_csp_int_data.curr_scan = RRC_CSP_CELL_RESELECTION_SCAN;

              if(rrc_csp_send_ccm_cmd(RRC_CELL_CHANGE_REQ,
                                      RRC_NEW_CELL_SELECTED,
                                      &rrc_csp_int_data.new_cell_acq_entry)
                 ==FAILURE)
              {
                /* Since we couldn't send cmd to CCM, ERR_FATAL here */
                ERR_FATAL("Could not send Int Cmd %d in CSP substate %d",
                                       RRC_CELL_CHANGE_REQ, rrc_csp_substate, 0);
              }
              else /* Cell Change Req successfully sent */
              {
                if(rrc_csp_int_data.curr_req_plmn.plmn_type == RRC_GSM_MAP_ANY_PLMN_REQ)
                {
                  /* If requested PLMN type is "Any PLMN", we will go to Acceptable
                   * Cell Selection.
                   */
                  next_substate = RRCCSP_ACCEPT_CELL_RESELECT_WT_CAMP;
                }
                else 
                {
                  /* Determine at this point if based on SIBs of the received cell, we
                   * are still in Suitable Cell Selection
                   */
                  if(RRC_CSP_IN_SUIT_SEL(cell_plmn_status,
                               rrc_csp_int_data.new_cell_acq_entry.status_mask))
                  {
                    next_substate = RRCCSP_SUIT_CELL_RESELECT_WT_CAMP;
                  }
                  else
                  {
                     next_substate = RRCCSP_ACCEPT_CELL_RESELECT_WT_CAMP;
                  }
                }

                if(rrc_csp_substate == RRCCSP_SUIT_CELL_RESELECT_WT_SIB)
                {
                next_substate = RRCCSP_SUIT_CELL_RESELECT_WT_CAMP;
              }
            }
            }
            /* S-criteria not met. Stay on serving cell */
            else
            {
              is_nbr_s_criteria_failed = TRUE;
              WRRC_MSG0_HIGH("S-criteria not met for nbr cell");
              rrccsp_send_transition_failure(L1_RESEL_FAIL_CAUSE_S_CRITERIA);
              if(!rrccsp_inter_freq_cell_resel_in_progress)
              {
                RRC_DEBUG_INCREMENT_STATS(INTRA_FREQ_CEL_RESEL_TRANSITION_FAILURE);
              }

              if(rrc_csp_substate == RRCCSP_SUIT_CELL_RESELECT_WT_SIB)
              {
                next_substate = RRCCSP_SUIT_CELL_RESELECT_WT_TRANS_CNF;
              }
              else
              {
                next_substate = RRCCSP_ACCEPT_CELL_RESELECT_WT_TRANS_CNF;
              }
              remain_on_current_cell = TRUE;
            }
          } /* Cell NOT below expectations */
        } /* At least Emergency calls are allowed on the new cell */
      } /* OC not set for DCH by a Reconfig message */
    } /* SIBs successfully received */
    else if(cmd_ptr->cmd.get_sibs_cnf.status == SIB_EVENT_FAILED_INCOMPATIBLE_STATE)
    {
      if(!rrccsp_inter_freq_cell_resel_in_progress)
      {
        RRC_DEBUG_INCREMENT_STATS(INTRA_FREQ_CEL_RESEL_FAILED_OTHER_CAUSE);
      }
      WRRC_MSG0_HIGH("SIB Cnf failed, Incompatible state");
      remain_on_current_cell = TRUE;
    }
    else /* Other cases can be handled here as needed - SIB_TIMEOUT, INVALID_SIBS, etc. */
    {
      if((cmd_ptr->cmd.get_sibs_cnf.status == SIB_EVENT_FAILED_CELL_BAR) ||
        (cmd_ptr->cmd.get_sibs_cnf.status == SIB_EVENT_FAILED_FREQ_BAR))
      {
        fail_cause = L1_RESEL_FAIL_CAUSE_BARRED_CELL;
      }
      else if(cmd_ptr->cmd.get_sibs_cnf.status == SIB_EVENT_FAILED_L2_ACK_WAIT)
      {
        fail_cause = L1_RESEL_FAIL_L2_ACK_WAIT;
      }
      else
      {
        fail_cause = L1_RESEL_FAIL_CAUSE_SIB_READING_FAILED;
      }
      if(!rrccsp_inter_freq_cell_resel_in_progress) 
      {
        if(cmd_ptr->cmd.get_sibs_cnf.status == SIB_EVENT_FAILED_TIMEOUT)
        {
          RRC_DEBUG_INCREMENT_STATS(INTRA_FREQ_CEL_RESEL_SIB_WAIT_TIMEOUT);
        }
        else if(cmd_ptr->cmd.get_sibs_cnf.status == SIB_EVENT_FAILED_LOWER_LAYERS)
        {
          RRC_DEBUG_INCREMENT_STATS(INTRA_FREQ_CEL_RESEL_NBCCH_SETUP_FAILURE);
        }
        else
        {
          RRC_DEBUG_INCREMENT_STATS(INTRA_FREQ_CEL_RESEL_FAILED_OTHER_CAUSE);
        }
      }

      WRRC_MSG0_HIGH("SIB Cnf failed, remain on current cell");
      /* Send a TRANSITION_REQ to L1 with failure if OC not set for DCH or current RRC
       * state is not DCH
       */
      if((rrcllc_get_ordered_config_status() == OC_SET_FOR_CELL_DCH) ||
        (rrc_get_state() == RRC_STATE_CELL_DCH))
      {
        remain_on_current_cell = TRUE;
        WRRC_MSG0_HIGH("OC set for DCH or RRC state is DCH");
      }
      else
      {
        rrccsp_send_transition_failure(fail_cause);

        if(rrc_csp_substate == RRCCSP_SUIT_CELL_RESELECT_WT_SIB)
        {
          next_substate = RRCCSP_SUIT_CELL_RESELECT_WT_TRANS_CNF;
        }
        else
        {
          next_substate = RRCCSP_ACCEPT_CELL_RESELECT_WT_TRANS_CNF;
        }
        remain_on_current_cell = TRUE;
      }
    }
  } /* SIBs received for the correct cell */

  if (remain_on_current_cell)
  {
    if((!rrccsp_inter_freq_cell_resel_in_progress) 
         && (cmd_ptr->cmd.get_sibs_cnf.status == SIB_EVENT_SUCCEEDED)
         && !is_nbr_s_criteria_failed)
    {
      RRC_DEBUG_INCREMENT_STATS(INTRA_FREQ_CEL_RESEL_FAILED_OTHER_CAUSE);
    }

    /* No need to stop DCH->FACH cell selection timer as it should not be active
     * while in cell reselection
     */
    /* Reset reselection variables */
    rrccsp_reset_reselection_data();

    if((rrc_csp_substate == RRCCSP_SUIT_CELL_RESELECT_WT_SIB)&&
       (next_substate != RRCCSP_SUIT_CELL_RESELECT_WT_TRANS_CNF))
    {
      next_substate = RRCCSP_CAMPED_SUIT_CELL;
    }
    else if((rrc_csp_substate == RRCCSP_ACCEPT_CELL_RESELECT_WT_SIB)&&
            (next_substate != RRCCSP_ACCEPT_CELL_RESELECT_WT_TRANS_CNF))
    {
      next_substate = RRCCSP_CAMPED_ACCEPT_CELL;
    }
  }

  return( next_substate );
} /* rrccsp_camped_suit_cell_resel_wait_sib_sib */


/*===========================================================================

FUNCTION        RRCCSP_CELL_RESEL_WAIT_SIB_HDLR

DESCRIPTION
                This is a handler for events received in
                RRCCSP_SUIT_CELL_RESELECT_WT_SIB substate of the Cell
                Selection Procedure.
                Depending on the event, it further calls a function for
                processing the event in this CSP substate.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_cell_resel_wait_sib_hdlr( rrc_cmd_type *cmd_ptr )
{
  rrc_csp_substate_e_type   next_substate;
  rrc_state_e_type          rrc_state;


  next_substate = rrc_csp_substate;

  switch( cmd_ptr->cmd_hdr.cmd_id )
  {
    case RRC_CPHY_CELL_RESELECTION_IND:
      /* Ignore the cell reselection indication for now */
      WRRC_MSG0_HIGH("Rxed a new cell-resel-ind in SIB wait");
      break;

    case RRC_SERVICE_REQ:
      rrc_state = rrc_get_state();
      if(rrc_state != RRC_STATE_DISCONNECTED)
      {
        WRRC_MSG1_ERROR("Service req in RRC state %d",rrc_state);
      }

      WRRC_MSG0_HIGH("Start cell sel for service request");
      rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_NGH_OOS);
      rrc_csp_init_data_from_service_req(&cmd_ptr->cmd.rrc_service_req);

      /* Reset reselection variables */
      rrccsp_reset_reselection_data();

      /* Release the established channels and start cell selection */
      next_substate = rrc_csp_release_chls_and_start_sel_on_mm_req();
      break;

    case RRC_GET_SPECIFIC_SIBS_CNF:
      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                     cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
      next_substate = rrccsp_cell_resel_wait_sib_sib( cmd_ptr );

      break;


    case RRC_PLMN_LIST_REQ:
      MSG_MED("Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
      if(rrccsp_plmn_list_req_is_valid(&(cmd_ptr->cmd.plmn_list_req)))
      {

        if(!rrccsp_handle_plmn_list_req_in_bgnd(&(cmd_ptr->cmd.plmn_list_req)))
        { 
          WRRC_MSG0_ERROR("ERR: Invalid PLMN_LIST_REQ rcvd");
        }
      }
      break;

    case RRC_STATE_CHANGE_IND:
      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
      next_substate = rrccsp_camped_cell_state_change( cmd_ptr );
      break;

    case RRC_REDIRECT_REQ:
      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );

      if(rrccsp_validate_redirection_req( cmd_ptr ))
      {
        WRRC_MSG0_HIGH("Rdrct Req rcvd when wting for SIBs for neighbor cell.Force SIB init, reset resel data, send NBCCH t-down req to L1");

        /* First Initialize the SIB variables */
        /* Signal SIB procedure to clear up the active event, if any */
        rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_NGH_OOS);

        /* Reset the reselection data */
        rrccsp_reset_reselection_data();

        /* Send N-BCCH tear down req to L1 */
        rrccsp_send_nbcch_teardown_req();

        rrc_csp_int_data.freq_redirect_wait_time = cmd_ptr->cmd.redirect_req.wait_time;

        /* Release all channels before starting redirection search due to connection release
        */
        if(cmd_ptr->cmd.redirect_req.proc_id == RRC_PROCEDURE_RCR)
        {
          rrc_csp_send_chan_release();
        }

        /* Inter Frequency Redirection */
        if(cmd_ptr->cmd.redirect_req.choice == RRC_FREQ_REDIRECTION)
        {
          /* Attempt acquisition on the designated frequency */
          rrc_csp_int_data.redirected_freq = cmd_ptr->cmd.redirect_req.u.freq.uarfcn_DL;
          /* Start acquisition on redirected freq and start wait timer for last camped freq */
          next_substate = rrccsp_handle_rrc_redirect_req(next_substate);
        }
        /* Inter RAT Redirection */
        else
        {
          /* Set the current scan to inter RAT redirection scan */
          rrc_csp_int_data.curr_scan     = RRC_CSP_INTER_RAT_REDIRECTION_SCAN;
          /* Store the Internal RRC command information */
          WCDMA_MEMCPY(&rrc_csp_int_data.saved_rrc_cmd,
                       sizeof(rrc_cmd_type),
                       cmd_ptr,
                       sizeof(rrc_cmd_int_type));

          /* Send change mode request to MCM */
          rrccsp_send_mode_change_req_to_mcm(RRC_MODE_STANDBY);
          next_substate = RRCCSP_WT_SUSPEND_MODE_CHANGE_CNF;
        }
      }
      break;

    case RRC_INITIATE_CELL_SELECTION_IND:
      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
      next_substate = rrc_csp_handle_initiate_cell_sel_in_wait_for_sib_for_resel(cmd_ptr);
      break;

    case RRC_CPHY_DL_WEAK_IND:
      if(cmd_ptr->cmd.dl_weak_ind.serving_cell)
      {
        WRRC_MSG0_HIGH("DL_WK_IND for serving cell. Ignored");
      }
      else
      {
        if((rrcllc_get_ordered_config_status() != OC_SET_FOR_CELL_DCH)  &&
           (rrc_get_state() != RRC_STATE_CELL_DCH))
        {
          WRRC_MSG1_HIGH("DL_WK_IND for neighbour cell in CSP st %d, remain on current cell", 
                                                     rrc_csp_substate);

          /* First Initialize the SIB variables */
          /* Signal SIB procedure to clear up the active event, if any */
          rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_NGH_OOS);

          /* Send a TRANSITION_REQ to L1 with failure */
          rrccsp_send_transition_failure(L1_RESEL_FAIL_CAUSE_DL_WK_IND);
          
          /* Reset the reselection data */
          rrccsp_reset_reselection_data();
          
          if(rrc_csp_substate == RRCCSP_SUIT_CELL_RESELECT_WT_SIB)
          {
             next_substate = RRCCSP_SUIT_CELL_RESELECT_WT_TRANS_CNF;
          }
          else
          {
            next_substate = RRCCSP_ACCEPT_CELL_RESELECT_WT_TRANS_CNF;
          }
        }
        else
        {
          WRRC_MSG0_HIGH("DL_WK_IND for neighboring cell. Ignored - OC set for DCH"); 
        }
      }
      break;


    case RRC_BPLMN_GUARD_SRCH_TIMER_EXPIRED_IND:
      rrccsp_cleanup_bplmn_state();
      break;

    case RRC_BPLMN_SEARCH_ABORT_REQ:
      rrccsp_cleanup_bplmn_state();
      break;

    case RRC_BPLMN_SUSPEND_REQ:
      rrccsp_handle_passive_bplmn_suspend_req( cmd_ptr );      
      break;
/*lint -e408*/
#ifdef FEATURE_GAN_3G_ROVE_OUT_ONLY
    #error code not present
#endif
/*lint +e408*/

#ifdef FEATURE_DUAL_SIM
      case RRC_DUAL_SIM_WRM_UNLOCK_BY_TIMER_EXP_IND:
        if(rrc_get_state() == RRC_STATE_CELL_FACH)
        {
#ifdef FEATURE_QTA
          rrcwrm_handle_qta_during_sib_read(wl1_qta_overhead_time_in_ms()+W_QTA_DURATION);
#endif
        }
        else
        {
          /*Check if W is holding lock,as we might be already sleeping.
            Even if we call get current SFN it returns invalid value.We cannot
            build SIB sleep table*/
          if(WRM_STATE_IS_IN_LOCK(WCDMA_TRM))
          {
            rrcsib_introduce_holes_for_g_page(G_PAGE_HOLES);
          }
        }
        break;
#endif

    default:
      WRRC_MSG2_HIGH( "Cmd 0x%x not processed in CSP sstate %d",
                            cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);
      break;
  }
  return( next_substate );
} /* rrccsp__cell_resel_wait_sib_hdlr */


/*===========================================================================

FUNCTION        rrccsp_cell_resel_wait_camp_req

DESCRIPTION     This function handles a SERVICE Request from MM while
                CSP is waiting for CELL_CHANGE Confirm from CCM.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_cell_resel_wait_camp_req( rrc_cmd_type *cmd_ptr )
{

  rrc_csp_substate_e_type  next_substate;

  if((rrc_csp_substate == RRCCSP_SUIT_CELL_RESELECT_WT_CAMP)||
     (rrc_csp_substate == RRCCSP_SUIT_CELL_RESELECT_WT_CAMP_PENDING))
  {
     next_substate = RRCCSP_SUIT_CELL_RESELECT_WT_CAMP_PENDING;
  }
  else
  {
    next_substate = RRCCSP_ACCEPT_CELL_RESELECT_WT_CAMP_PENDING;
  }

  /* Store the contents of Service Request or PLMN LIST REQ in Internal database
   * and wait for Acq. Confirm in the new state.
   */

  if(cmd_ptr->cmd_hdr.cmd_id == RRC_SERVICE_REQ)
  {
    rrc_csp_int_data.last_mm_primitive = RRC_CSP_SRVC_REQ_RCVD;
    rrc_csp_int_data.pending_srvc_req_data = cmd_ptr->cmd.rrc_service_req;
    rrc_csp_int_data.pending_type = RRC_CSP_SERVICE_REQ_PENDING;
  }
  else if(cmd_ptr->cmd_hdr.cmd_id == RRC_PLMN_LIST_REQ)
  {
    rrc_csp_int_data.last_mm_primitive = RRC_CSP_PLMN_LIST_REQ_RCVD;
    rrc_csp_int_data.pending_plmn_list_req_data = cmd_ptr->cmd.plmn_list_req;
    rrc_csp_int_data.pending_type = RRC_CSP_PLMN_LIST_REQ_PENDING;
  }
  else if(cmd_ptr->cmd_hdr.cmd_id == RRC_INITIATE_CELL_SELECTION_IND)
  {
    rrc_csp_int_data.pending_type = RRC_CSP_INITIATE_CELL_SEL_PENDING;
  }
  else if(cmd_ptr->cmd_hdr.cmd_id == RRC_REDIRECT_REQ)
  {
    rrc_csp_int_data.pending_type = RRC_REDIRECT_REQ_PENDING;
  }
  else
  {
    WRRC_MSG0_ERROR("Shouldn't come here");
  }

  return( next_substate );
} /* rrccsp_camped_suit_cell_resel_wait_camp_req */



/*===========================================================================

FUNCTION        rrccsp_cell_resel_wait_camp_cell_change

DESCRIPTION
                This function processes Cell Change CNF while waiting in
                RRCCSP_SUIT_CELL_RESELECT_WT_CAMP substate.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_cell_resel_wait_camp_cell_change( rrc_cmd_type *cmd_ptr )
{
  rrc_csp_substate_e_type   next_substate =  rrc_csp_substate;
  rrc_to_mm_sink_e_type     mm_cmd_id;
  rrc_state_e_type rrc_current_state = rrc_get_state();
  rrclog_wcdma_cell_selected_event_type wcdma_cell_selected_event;

  rrc_state_e_type          rrc_state = rrc_get_state();

  if(cmd_ptr->cmd.cell_change_cnf.req_proc_id != RRC_PROCEDURE_CSP)
  {
    WRRC_MSG1_ERROR("Cell Change CNF for proc rrc_proc_e_type_value%d sent to CSP",
                    cmd_ptr->cmd.cell_change_cnf.req_proc_id);
    return(next_substate);
  }

  /* The command belongs to CSP - dissect it */
  if(cmd_ptr->cmd.cell_change_cnf.cell_change_status == RRC_CELL_CHANGE_SUCCESS)
  { /* Cell Change CNF has a Success status */

    /* Successfully Camped on a Cell Now */
    /* Update the Internal data with Selected PLMN, Send a RRC_SERVICE_CNF to
     * MM and move on to the Camped substate
     */

    /* Fill in the freq and scrambling code information and report
     * the EVENT_WCDMA_CELL_SELECTED event
     */
    wcdma_cell_selected_event.freq = rrc_csp_int_data.new_cell_acq_entry.freq;
    wcdma_cell_selected_event.scr_code = (uint16)(rrc_csp_int_data.new_cell_acq_entry.scr_code/16);
#ifdef FEATURE_FEMTO_CSG
    wcdma_cell_selected_event.csg_id = rrc_csp_int_data.new_cell_acq_entry.csg_id;
#endif
    event_report_payload(EVENT_WCDMA_CELL_SELECTED, sizeof(wcdma_cell_selected_event),
                   (void *)&wcdma_cell_selected_event);

    /* Update the Serving PCCPCH params */
    WRRC_MSG1_HIGH("Updating Serving PCCPCH params with scr_code: %d",rrc_csp_int_data.new_cell_acq_entry.scr_code);
    rrc_csp_int_data.serving_pccpch_parms.scr_code = rrc_csp_int_data.new_cell_acq_entry.scr_code;

    /* Store the new cell information in the curr_acq_entry */
    rrc_csp_int_data.curr_acq_entry = rrc_csp_int_data.new_cell_acq_entry;

    WRRC_MSG1_HIGH("Camped on suitable cellID %d",
                 rrc_csp_int_data.curr_acq_entry.cell_id);

    WRRC_MSG2_HIGH("PLMN.MCC %d, PLMN.MNC %d",
                RRC_CSP_GET_INT_MCC(rrc_csp_int_data.curr_acq_entry.plmn_id),
                RRC_CSP_GET_INT_MNC(rrc_csp_int_data.curr_acq_entry.plmn_id));

    if((!rrccsp_inter_freq_cell_resel_in_progress) 
       && (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_RESELECTION_SCAN))
    {
      RRC_DEBUG_INCREMENT_STATS(INTRA_FREQ_CEL_RESEL_SUCCESS);
    }

    rrc_csp_int_data.curr_sel_plmn.plmn_type = RRC_GSM_MAP_PLMN_SEL;
    rrc_csp_int_data.curr_sel_plmn.plmn_id = rrc_csp_int_data.curr_acq_entry.
                                             plmn_id;

    /* Save the last suit cell frequency UE camps on. This frequency is then 
     * added to the fine scan list when UE goes OOS in Idle mode, since the 
     * probability of UE finding the service on this frequency is higher.
     */
    if(rrc_csp_substate == RRCCSP_SUIT_CELL_RESELECT_WT_CAMP)
    {
       rrc_csp_int_data.last_camped_freq_in_idle_mode = rrc_csp_int_data.curr_acq_entry.freq;
    }

    /* Update the current requested PLMN with the camped PLMN */
    rrc_csp_int_data.curr_req_plmn.plmn_id  = rrc_csp_int_data.curr_acq_entry.plmn_id;

    rrc_csp_int_data.curr_service_status = MM_AS_SERVICE_AVAILABLE;

    /* Here send a DRX command if in DISCONNECTED, CELL_PCH or URA_PCH state */
    if((rrc_state == RRC_STATE_DISCONNECTED) ||
       (rrc_state == RRC_STATE_CELL_PCH) ||
        (rrc_state == RRC_STATE_URA_PCH))
    {
      rrc_csp_send_l1_drx_req();
    }

#ifdef FEATURE_WCDMA_DEFERRED_SIB11_12_READING
    WRRC_MSG0_HIGH("Deferred SIB: UPDATE_SIBS activated");
    rrcsib_update_sib_for_deferred_sib();
#endif

    if(rrc_csp_cmd_to_mm_needed(&mm_cmd_id,
                                rrc_csp_int_data.last_mm_primitive,
                                rrc_csp_int_data.curr_service_status)
       == TRUE)
    {
      rrc_csp_send_mm_cmd(mm_cmd_id,
                             rrc_csp_int_data.curr_service_status,
                             &rrc_csp_int_data.curr_sel_plmn,
                             &rrc_csp_int_data.curr_acq_entry);
    }
    else if(mm_cmd_id == RRC_SERVICE_IND)
    {
           /* If SIB3 modification does have DSAC information is present, send service indication
              to NAS always instead of not depending of the current RRC state. i.e. even the function
              rrc_csp_cmd_to_mm_needed() returns false
           */
            if(rrc_csp_int_data.is_curr_dsac_info_valid == TRUE)
            {
              mm_cmd_id =  RRC_SERVICE_IND_FROM_OTA_MSG;
              rrc_csp_send_mm_cmd(mm_cmd_id,
                           rrc_csp_int_data.curr_service_status,
                           &rrc_csp_int_data.curr_sel_plmn,
                           &rrc_csp_int_data.curr_acq_entry);
            }
            else if(mm_cmd_id == RRC_SERVICE_IND)
            {
              mm_cmd_id =  RRC_SERVICE_IND_FROM_OTA_MSG;
              rrc_csp_send_mm_cmd(mm_cmd_id,
                           rrc_csp_int_data.curr_service_status,
                           &rrc_csp_int_data.curr_sel_plmn,
                           &rrc_csp_int_data.curr_acq_entry);
            }
        }


    /* No need to stop DCH->FACH cell selection timer as none should be active
     * at this point during cell reselection.
     */
    if(rrc_csp_substate == RRCCSP_SUIT_CELL_RESELECT_WT_CAMP)
    {
      next_substate = RRCCSP_CAMPED_SUIT_CELL; 
    }
    else
    {
      next_substate = RRCCSP_CAMPED_ACCEPT_CELL;
    }
    WRRC_MSG0_HIGH("Reselected to the new cell successfully");

    /* Reset reselection variables */
    rrccsp_reset_reselection_data();
  } /* Cell Change CNF has a Success status */
  else if(cmd_ptr->cmd.cell_change_cnf.cell_change_status == RRC_CELL_CHANGE_FAILURE_INCOMPATIBLE_STATE)
  {

#ifdef FEATURE_QSH_EVENT_METRIC
      wrrc_qsh_log_cell_resel_stats(CELL_RESEL_FAIL,WRRC_METRIC_UPDATE);
#endif
    if((!rrccsp_inter_freq_cell_resel_in_progress) 
       && (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_RESELECTION_SCAN))
    {
      RRC_DEBUG_INCREMENT_STATS(INTRA_FREQ_CEL_RESEL_TRANSITION_FAILURE);
    }
    /* Since the Cell Change has not been successful, treat this as Failure and
     * stay camped on the current serving cell
     */
    WRRC_MSG0_HIGH("Cell change failed, Incompatible state");
    /* No need to stop DCH->FACH cell selection timer as none should
     * be active at this point during cell reselection.
     */

    /* Reset the reselection variables */
    rrccsp_reset_reselection_data();

    if(rrc_csp_substate == RRCCSP_SUIT_CELL_RESELECT_WT_CAMP)
    {
      next_substate = RRCCSP_CAMPED_SUIT_CELL;
    }
    else
    {
      next_substate = RRCCSP_CAMPED_ACCEPT_CELL;
    }
  } /* Cell Change CNF does NOT have a Success status */
  else
  {
  
#ifdef FEATURE_QSH_EVENT_METRIC
      wrrc_qsh_log_cell_resel_stats(CELL_RESEL_FAIL,WRRC_METRIC_UPDATE);
#endif
    /* Cell Change has not been successful */
    if((!rrccsp_inter_freq_cell_resel_in_progress) 
       && (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_RESELECTION_SCAN))
    {
      RRC_DEBUG_INCREMENT_STATS(INTRA_FREQ_CEL_RESEL_TRANSITION_FAILURE);
    }
    /* Reset the reselection variables */
    rrccsp_reset_reselection_data();

    /* In Connected State send OOS indication to CU so that
     * appropriate timer is started in CU. CU will then send
     * initiate cell selection indication to CSP
     */
    if(   (rrc_current_state == RRC_STATE_CELL_FACH)
       || (rrc_current_state == RRC_STATE_CELL_PCH)
       || (rrc_current_state == RRC_STATE_URA_PCH))
    {
      next_substate = rrccsp_send_cell_update_initiate_req(RRC_REENTERED_SERVICE_AREA);
    }
    else if(rrc_csp_int_data.curr_scan == RRC_CSP_CELL_RESELECTION_SCAN)
    {
      WRRC_MSG0_HIGH("Cell change failed, start cell sel in OOS_idle_state scan");
      if(rrc_current_state == RRC_STATE_CONNECTING)
      {
        rrcrce_force_initialize(FALSE);
      }
      next_substate = rrc_csp_start_sel_out_of_service_area_in_idle_state();
    }
    else
    {
      WRRC_MSG0_HIGH("Cell change failed, continue cell sel in OOS_idle_state scan");
      next_substate = rrc_csp_release_chls_and_continue_cell_selection();
    }
  } /* Cell Change CNF does NOT have a Success status */

#ifdef FEATURE_GAN
    #error code not present
#endif

  return(next_substate);
} /* rrccsp_cell_resel_wait_camp_cell_change */


/*===========================================================================

FUNCTION        RRCCSP_SUIT_CELL_RESELECT_WT_CAMP_HDLR

DESCRIPTION
                This is a handler for events received in
                RRCCSP_SUIT_CELL_RESELECT_WT_CAMP substate of the Cell
                Selection Procedure.
                Depending on the event, it further calls a function for
                processing the event in this CSP substate.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_cell_resel_wait_camp_hdlr( rrc_cmd_type *cmd_ptr )
{
  rrc_csp_substate_e_type   next_substate;
  rrc_state_e_type          rrc_state = rrc_get_state();

  next_substate = rrc_csp_substate;

  switch( cmd_ptr->cmd_hdr.cmd_id )
  {
    case RRC_CPHY_CELL_RESELECTION_IND:
      /* Ignore the cell reselection indication for now */
      WRRC_MSG0_HIGH("Rxed cell-resel-ind in suit-wt-camp st");
      break;

    case RRC_SERVICE_REQ:
      if(rrc_state != RRC_STATE_DISCONNECTED)
      {
        WRRC_MSG1_ERROR("Service req in RRC state %d",rrc_state);
      }

      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
      next_substate = rrccsp_cell_resel_wait_camp_req( cmd_ptr );
      break;

    case RRC_CELL_CHANGE_CNF:
      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                     cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
      next_substate = rrccsp_cell_resel_wait_camp_cell_change( cmd_ptr );
      break;


    case RRC_PLMN_LIST_REQ:
      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );

      if(rrccsp_plmn_list_req_is_valid(&(cmd_ptr->cmd.plmn_list_req)))
      {
        if(!rrccsp_handle_plmn_list_req_in_bgnd(&(cmd_ptr->cmd.plmn_list_req)))
        { 
          WRRC_MSG0_ERROR("ERR: Invalid PLMN_LIST_REQ rcvd");
        }
      }
      break;

    case RRC_STATE_CHANGE_IND:
      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );

      if((cmd_ptr->cmd.state_change_ind.new_state == RRC_STATE_CELL_FACH)
           && (cmd_ptr->cmd.state_change_ind.previous_state == RRC_STATE_CONNECTING))
      {
        /* We do not send CPHY_CELL_PARM_REQ in this case because in the case of
         * successful CELL_CHANGE_CNF, CCM has already sent CPHY_CELL_PARM_REQ for
         * the new cell. If we send another CPHY_CELL_PARM_REQ it will go for the
         * previous cell which will be incorrect.
         */
        WRRC_MSG1_HIGH("Not sndng CPHY_CELL_PARM_REQ for Conn to FACH tx in CSP state %d",
                                                                    next_substate);
      }
      else
      {
        next_substate = rrccsp_camped_cell_state_change( cmd_ptr );
      }
      break;

    case RRC_REDIRECT_REQ:
      MSG_MED("Cmd 0x%x (RRC_REDIRECT_REQ) recvd, CSP sstate %d",
                        cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );

      if(rrccsp_validate_redirection_req( cmd_ptr ))
      {
        rrc_csp_int_data.freq_redirect_wait_time = cmd_ptr->cmd.redirect_req.wait_time;
        /* Store the Internal RRC command information */
        WCDMA_MEMCPY(&rrc_csp_int_data.saved_rrc_cmd,
                     sizeof(rrc_cmd_type),
                     cmd_ptr,
                     sizeof(rrc_cmd_int_type));

        /* Inter Frequency Redirection */
        if(cmd_ptr->cmd.redirect_req.choice == RRC_FREQ_REDIRECTION)
        {
          WRRC_MSG0_HIGH("FREQ_REDIRECT_REQ rcvd in RESELECT_WT_CAMP. Go to pending");
          rrc_csp_int_data.redirected_freq = cmd_ptr->cmd.redirect_req.u.freq.uarfcn_DL;
        }
        else
        {
          WRRC_MSG0_HIGH("INTER_RAT_REDIRECT_REQ rcvd in RESELECT_WT_CAMP. Go to pending");

          /* Set the current scan to inter RAT redirection scan */
          rrc_csp_int_data.curr_scan = RRC_CSP_INTER_RAT_REDIRECTION_SCAN;
        }

        next_substate = rrccsp_cell_resel_wait_camp_req( cmd_ptr );
      }
      break;

    case RRC_INITIATE_CELL_SELECTION_IND:
      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                        cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );

      if(cmd_ptr->cmd.initiate_cell_sel_ind.cause == RRC_CELL_SEL_RB0_SETUP_FAILURE)
      {
       WRRC_MSG0_HIGH("Start cell sel RB0 failure, treat as OOS");
       /* Reset reselection variables */
       rrccsp_reset_reselection_data();

       next_substate =
         rrccsp_handle_out_of_service_ind( rrc_csp_substate );
      }
      else if(cmd_ptr->cmd.initiate_cell_sel_ind.cause == RRC_OUT_OF_SERVICE_AREA_IND)
      {
        WRRC_MSG1_HIGH("OOS initiated by proc rrc_proc_e_type_value%d",
                   cmd_ptr->cmd.initiate_cell_sel_ind.proc);
        /* Reset the reselection data */
        rrccsp_reset_reselection_data();
        next_substate =
          rrccsp_handle_out_of_service_ind( rrc_csp_substate );
      }
      else if(cmd_ptr->cmd.initiate_cell_sel_ind.cause == RRC_TRANSITION_TO_DISCONNECTED)
      {
        WRRC_MSG1_HIGH("Tx to discon initiated by proc rrc_proc_e_type_value%d", cmd_ptr->cmd.initiate_cell_sel_ind.proc);

        rrc_csp_send_chan_release();

        /* Transition CNF will be ignored by updating CCM with cell loss*/
        rrc_ccm_update_with_cell_loss();
#ifdef FEATURE_DISCONNECT_ON_UNSUPPORTED_IRAT_REDIRECTION
        /*If dual mode disabled and redirection to GSM, then trigger OOS and go to idle with no servce*/

        if (cmd_ptr->cmd.initiate_cell_sel_ind.tx_to_discon_reason == RRC_TX_TO_DISCON_UNSUPPORTED_REDIRECTION)
        {
          rrccsp_reset_reselection_data();
          next_substate = rrccsp_rel_chls_and_go_to_idle();
        }
        else
#endif
        {
        /* Do nothing. UE will perform leaving connected mode scan after state change to idle is received
         * This is to prevent a corner case where cell reselection is in progress in FACH and FR2LTE is kicked
         * in as LLC cannot process back to back channel config to disconnect state and wcdma suspend request
         * after cell transition confirm is received for reselection and while waiting for new cell indication
         * from CCM. LLC trashes the suspend request after receiving new cell indication from CCM
         */
        }
      }
      else
      {
       WRRC_MSG2_HIGH("Cause %d not handled %d CSP sstate ",
                 cmd_ptr->cmd.initiate_cell_sel_ind.cause, rrc_csp_substate);
      }
      break;

    case RRC_BPLMN_GUARD_SRCH_TIMER_EXPIRED_IND:
      rrccsp_cleanup_bplmn_state();
      break;

    case RRC_BPLMN_SEARCH_ABORT_REQ:
      rrccsp_cleanup_bplmn_state();
      break;

    case RRC_BPLMN_SUSPEND_REQ:
      rrccsp_handle_passive_bplmn_suspend_req( cmd_ptr );  
      break;
/*lint -e408*/
#ifdef FEATURE_GAN_3G_ROVE_OUT_ONLY
    #error code not present
#endif
/*lint +e408*/
    default:
      WRRC_MSG2_HIGH( "Cmd 0x%x not processed in CSP sstate %d",
                            cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);
      break;
  }
  return( next_substate );
} /* rrccsp_cell_resel_wait_camp_hdlr */



/* =======================================================================
** Function Definitions for substate:
    RRCCSP_SUIT_CELL_RESEL_WT_CAMP_PENDING
** ======================================================================= */

/*===========================================================================

FUNCTION        rrccsp_suit_cell_resel_wait_camp_pending_hdlr

DESCRIPTION
                This is a handler for events received in
                RRCCSP_SUIT_CELL_RESEL_WT_CAMP_PENDING substate of
                Cell Selection Procedure.
                Depending on the event, it further calls a function for
                processing the event in this CSP substate.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_suit_cell_resel_wait_camp_pending_hdlr( rrc_cmd_type *cmd_ptr )
{
  rrc_csp_substate_e_type   next_substate;
  rrc_state_e_type          rrc_state;

  next_substate = RRCCSP_SUIT_CELL_RESELECT_WT_CAMP_PENDING;

  switch( cmd_ptr->cmd_hdr.cmd_id )
  {
    case RRC_CELL_CHANGE_CNF:
      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );

      switch(rrc_csp_int_data.pending_type)
      {
        case RRC_CSP_SERVICE_REQ_PENDING:
          /* Reset reselection variables */
          rrccsp_reset_reselection_data();

          /* Start processing pending Service Request */
          WRRC_MSG0_HIGH("Start cell sel for pending srvc req");
          rrc_csp_init_data_from_service_req(&rrc_csp_int_data.pending_srvc_req_data);
          /* Release the established channels and start cell selection */
          next_substate = rrc_csp_release_chls_and_start_sel_on_mm_req();
          break;

        case RRC_CSP_PLMN_LIST_REQ_PENDING:
          /* Reset reselection variables */
          rrccsp_reset_reselection_data();
          next_substate = rrccsp_handle_plmn_list_req(next_substate,
                                                      &(rrc_csp_int_data.pending_plmn_list_req_data));
          break;

        case RRC_REDIRECT_REQ_PENDING:
          /* Reset reselection variables */
          rrccsp_reset_reselection_data();

          /* Release all channels before starting redirection search due to connection release
          */
          if((rrc_csp_int_data.saved_rrc_cmd).cmd.redirect_req.proc_id == RRC_PROCEDURE_RCR)
          {
            rrc_csp_send_chan_release();
          }

          /* Inter Frequency Redirection */
          if((rrc_csp_int_data.saved_rrc_cmd).cmd.redirect_req.choice == RRC_FREQ_REDIRECTION)
          {
            WRRC_MSG0_HIGH("In FREQ_REDIRECT_REQ pending handler for RESELECT_WT_CAMP");

            /* Start acquisition on redirected freq and start wait timer for last camped freq */
            next_substate = rrccsp_handle_rrc_redirect_req(next_substate);
          }
          else
          {
            WRRC_MSG0_HIGH("In INTER_RAT_REDIRECT_REQ pending handler for RESELECT_WT_CAMP");
            /* Send change mode request to MCM */
            rrccsp_send_mode_change_req_to_mcm(RRC_MODE_STANDBY);
            next_substate = RRCCSP_WT_SUSPEND_MODE_CHANGE_CNF;
          }
          break;
#ifdef FEATURE_GAN_3G_ROVE_OUT_ONLY
        #error code not present
#endif
        default:
          ERR_FATAL("No pending type in %d CSP sstate",rrc_csp_substate,0,0);
          break;
      }
      break;

    case RRC_SERVICE_REQ:
      rrc_state = rrc_get_state();
      if(rrc_state != RRC_STATE_DISCONNECTED)
      {
        WRRC_MSG1_ERROR("Service req in RRC state %d",rrc_state);
      }

      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
      next_substate = rrccsp_cell_resel_wait_camp_req(cmd_ptr);
      break;


    case RRC_PLMN_LIST_REQ:
      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );

      if(rrccsp_plmn_list_req_is_valid(&(cmd_ptr->cmd.plmn_list_req)))
      {
        if(!rrccsp_handle_plmn_list_req_in_bgnd(&(cmd_ptr->cmd.plmn_list_req)))
        { 
          WRRC_MSG0_ERROR("ERR: Invalid PLMN_LIST_REQ rcvd");
        }
      }
      break;

    case RRC_REDIRECT_REQ:
      WRRC_MSG0_ERROR("ERR RRC_REDIRECT_REQ rcvd in resel wt camp pndng. Ignore it");
      break;

    case RRC_BPLMN_GUARD_SRCH_TIMER_EXPIRED_IND:
      rrccsp_cleanup_bplmn_state();
      break;

    case RRC_BPLMN_SEARCH_ABORT_REQ:
      rrccsp_cleanup_bplmn_state();
      break;

    case RRC_BPLMN_SUSPEND_REQ:
      rrccsp_handle_passive_bplmn_suspend_req( cmd_ptr );  
      break;

    case RRC_INITIATE_CELL_SELECTION_IND:
      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                        cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );

      if(cmd_ptr->cmd.initiate_cell_sel_ind.cause == RRC_CELL_SEL_RB0_SETUP_FAILURE)
      {
       WRRC_MSG0_HIGH("Start cell sel RB0 failure, treat as OOS");
       /* Reset reselection variables */
       rrccsp_reset_reselection_data();

       next_substate =
         rrccsp_handle_out_of_service_ind( rrc_csp_substate );
      }
      else if(cmd_ptr->cmd.initiate_cell_sel_ind.cause == RRC_OUT_OF_SERVICE_AREA_IND)
      {
        WRRC_MSG1_HIGH("OOS initiated by proc rrc_proc_e_type_value%d",
                   cmd_ptr->cmd.initiate_cell_sel_ind.proc);
        /* Reset the reselection data */
        rrccsp_reset_reselection_data();
        next_substate =
          rrccsp_handle_out_of_service_ind( rrc_csp_substate );
      }
      else if(cmd_ptr->cmd.initiate_cell_sel_ind.cause == RRC_TRANSITION_TO_DISCONNECTED)
      {
        WRRC_MSG1_HIGH("Tx to discon initiated by proc rrc_proc_e_type_value%d", cmd_ptr->cmd.initiate_cell_sel_ind.proc);

       /* Transition CNF will be ignored by updating CCM with cell loss*/
        rrc_ccm_update_with_cell_loss();
        rrc_csp_send_chan_release();

#ifdef FEATURE_DISCONNECT_ON_UNSUPPORTED_IRAT_REDIRECTION
        /*If dual mode disabled and redirection to GSM, then trigger OOS and go to idle with no servce*/

        if (cmd_ptr->cmd.initiate_cell_sel_ind.tx_to_discon_reason == RRC_TX_TO_DISCON_UNSUPPORTED_REDIRECTION)
        {
          rrccsp_reset_reselection_data();
          next_substate = rrccsp_rel_chls_and_go_to_idle();
        }
        else
#endif
        {
        /* Do nothing. UE will perform leaving connected mode scan after state change to idle is received
         * This is to prevent a corner case where cell reselection is in progress in FACH and FR2LTE is kicked
         * in as LLC cannot process back to back channel config to disconnect state and wcdma suspend request
         * after cell transition confirm is received for reselection and while waiting for new cell indication
         * from CCM. LLC trashes the suspend request after receiving new cell indication from CCM
         */
        }
      }
      else
      {
       WRRC_MSG2_HIGH("Cause %d not handled %d CSP sstate ",
                 cmd_ptr->cmd.initiate_cell_sel_ind.cause, rrc_csp_substate);
      }
      break;


    default:
      WRRC_MSG2_HIGH( "Cmd 0x%x not processed in CSP sstate %d",
                          cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);
      break;
  }

  return( next_substate );

} /* rrccsp_suit_cell_resel_wait_camp_pending_hdlr */

/*===========================================================================

FUNCTION        RRCCSP_HANDLE_PASSIVE_BPLMN_SUSPEND_REQ

DESCRIPTION
                This function sends RRC_BPLMN_SUSPEND_CNF to the procedure
                that sent RRC_BPLMN_SUSPEND_REQ and also determines if BPLMN
                search should be suspended or aborted based on the procedure
                that sent the suspend request.
                This function is only called when BPLMN search is passively 
                in progress

DEPENDENCIES
                None

RETURN VALUE
                None

SIDE EFFECTS
                None

===========================================================================*/
void rrccsp_handle_passive_bplmn_suspend_req( rrc_cmd_type *cmd_ptr )
{
  MSG_HIGH("curr_scan %d, prev_curr_scan %d, svc_srch_bgnd %d", 
                                          rrc_csp_int_data.curr_scan, 
                                          rrc_csp_int_data.prev_curr_scan, 
                                          rrc_csp_int_data.service_search_bgnd);

  /* This IF stmt has been added for testing purposes only and will be deleted before
   * checking in the code
   */
  if((rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
     || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN))
  { 
    ERR_FATAL("WTOW ERR: Incorrect current scan %d", rrc_csp_int_data.curr_scan, 0, 0);
  }
  else
  {
    WRRC_MSG1_HIGH("WTOW: Srch suspend req. Snd suspend cnf to proc rrc_proc_e_type_value%d",
                                 cmd_ptr->cmd.rrc_csp_bplmn_suspend_req.procedure);

#ifdef FEATURE_DUAL_SIM
    rrc_csp_handle_bplmn_suspend_lock_rel_offset_tmr_running();
#endif

    switch(cmd_ptr->cmd.rrc_csp_bplmn_suspend_req.procedure)
    {
      case RRC_PROCEDURE_RCE:
      case RRC_PROCEDURE_SIB:
      case RRC_PROCEDURE_CU:
        /* No opeartion is needed when BPLMN suspend request is received in passive state*/
        rrc_csp_send_bplmn_suspend_cnf(cmd_ptr->cmd.rrc_csp_bplmn_suspend_req.procedure, SUCCESS);
        break;

      case RRC_PROCEDURE_IDT:
        /* IDT does not handle BPLMN suspend confirm*/
       break;

      case RRC_PROCEDURE_MISC:
        /* If WTOG Automatic BPLMN search is active then send INTERRAT_PLMN_ABORT_REQ to GSM
         * before sending SUSPEND_CNF to CU. This is to avoid the case where WTOG
         * CCO request is received by GSM when it is in WTOG BPLMN state.
         */
        if(rrc_csp_int_data.bplmn_nw_sel_mode == SYS_NETWORK_SELECTION_MODE_AUTOMATIC)
        {
          if(rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_active)
          {
            rrccsp_send_irat_bplmn_abort_req();

            /* If GSM/LTE search is not actively in progress then abort PLMN search and
             * send PLMN_LIST_CNF to NAS. Else, if GSM/LTE search is actively in progress
             * then PLMN_LIST_CNF will be sent to NAS on W resume so we don't need to
             * call the BPLMN cleanup function in the "else" case.
             */
            if((rrc_csp_int_data.curr_scan != RRC_CSP_WTOG_BPLMN_AUTOMATIC_SCAN)
               && (rrc_csp_int_data.curr_scan != RRC_CSP_WTOG_BPLMN_MANUAL_SCAN))
            {
              rrccsp_cleanup_bplmn_state();
            }
          }
          else
          {
            rrccsp_cleanup_bplmn_state();
          }
        }
        rrc_csp_send_bplmn_suspend_cnf(cmd_ptr->cmd.rrc_csp_bplmn_suspend_req.procedure, SUCCESS);
        break;

      case RRC_PROCEDURE_CHO:
        /* If WTOG/WTOL BPLMN search is active then send ABORT_REQ to GSM/LTE
         * before sending SUSPEND_CNF to CU. This is to avoid the case where WTOG/WTOL
         * CCO request is received by GSM/WTOL when it is in WTOG/WTOL BPLMN state.
         */
        if(rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_active)
        {
          rrccsp_send_irat_bplmn_abort_req();
        }

        /* If GSM/LTE search is not actively in progress then abort PLMN search and
         * send PLMN_LIST_CNF to NAS. Else, if GSM/LTE search is actively in progress
         * then PLMN_LIST_CNF will be sent to NAS on W resume so we don't need to
         * call the BPLMN cleanup function in the "else" case.
         */
        if((rrc_csp_int_data.curr_scan != RRC_CSP_WTOG_BPLMN_AUTOMATIC_SCAN)
           && (rrc_csp_int_data.curr_scan != RRC_CSP_WTOG_BPLMN_MANUAL_SCAN))
        {
          rrccsp_cleanup_bplmn_state();
        }
        rrc_csp_send_bplmn_suspend_cnf(cmd_ptr->cmd.rrc_csp_bplmn_suspend_req.procedure, SUCCESS);
        break;

      default:
        WRRC_MSG1_ERROR("ERR: Suspend req rcvd by CSP from Unexpected procedure %d", cmd_ptr->cmd.rrc_csp_bplmn_suspend_req.procedure);
        rrc_csp_send_bplmn_suspend_cnf(cmd_ptr->cmd.rrc_csp_bplmn_suspend_req.procedure, SUCCESS);
        break;
    }
  }
} /* rrccsp_handle_passive_bplmn_suspend_req */


/*===========================================================================

FUNCTION        RRCCSP_CELL_RESELECT_WT_TRANS_CNF_HDLR

DESCRIPTION
                This is a handler for events received in
                RRCCSP_SUIT_CELL_RESELECT_WT_TRANS_CNF substate of the Cell
                Selection Procedure. Depending on the event, it further
                calls a function for processing the event in this CSP substate.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_cell_resel_wait_trans_cnf_hdlr( rrc_cmd_type *cmd_ptr )
{
  rrc_csp_substate_e_type   next_substate;
  rrc_state_e_type          rrc_state = rrc_get_state();
#ifdef FEATURE_GAN_3G_ROVE_OUT_ONLY
  #error code not present
#endif
  next_substate = rrc_csp_substate;

  MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                       cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );

  switch( cmd_ptr->cmd_hdr.cmd_id )
  {
    case RRC_LLC_CMD_CNF:
      if(cmd_ptr->cmd.rrc_llc_cnf.ll_cnf == RRC_LL_CPHY_CELL_TRANSITION_CNF)
      {
        WRRC_MSG0_HIGH("Cell Trans Cnf rxed from L1");

        if(!(cmd_ptr->cmd.rrc_llc_cnf.cnf.cell_tran_cnf.status))
        {
          WRRC_MSG0_HIGH("Rxed Cell Trans Cnf (Failure)");
        }
        if(rrc_csp_substate == RRCCSP_SUIT_CELL_RESELECT_WT_TRANS_CNF)
        {
          next_substate = RRCCSP_CAMPED_SUIT_CELL;
        }
        else
        {
          next_substate = RRCCSP_CAMPED_ACCEPT_CELL;
        }
      }
      else
      {
        WRRC_MSG2_HIGH("Rxed %d in CSP sstate %d",cmd_ptr->cmd.rrc_llc_cnf.ll_cnf,rrc_csp_substate);
      }

      if(cmd_ptr->cmd.rrc_llc_cnf.cnf.cell_tran_cnf.cell_rsel_ind.status == L1_RESEL_SUCCESS)
      {                             
        /* pointer to confirmation buffer */
        rrc_cmd_type * trans_cnf_resel_ind;
        WRRC_MSG0_HIGH("Piggybacked Resel Ind is received in cell trans cnf <failure>");    
        /* Allocate memory */
        if( (trans_cnf_resel_ind = (rrc_cmd_type *)rrc_malloc(sizeof(rrc_cmd_type))) == NULL )
        {
          ERR_FATAL("Could not allocate memory for RRC-L1 cmd q!", 0, 0, 0);
        }
        /* The cause is set to RRC_CPHY_CELL_RESELECTION_IND so that csp expects as this is 
           received from L1
        */    
        trans_cnf_resel_ind->cmd_hdr.cmd_id = RRC_CPHY_CELL_RESELECTION_IND;        
        /* Pack the reselection related info into the buffer from cell transition_cnf message received from L1 */
        WCDMA_MEMCPY(&(trans_cnf_resel_ind->cmd.cell_rsel_ind),
                     sizeof(l1_cell_reselec_ind_type),
                     &((cmd_ptr->cmd).rrc_llc_cnf.cnf.cell_tran_cnf.cell_rsel_ind), 
                     sizeof(l1_cell_reselec_ind_type));

        if(rrc_csp_substate == RRCCSP_SUIT_CELL_RESELECT_WT_TRANS_CNF)
        {
          next_substate = rrccsp_camped_suit_cell_hdlr(trans_cnf_resel_ind);
        }
        else
        {
          next_substate = rrccsp_camped_accept_cell_hdlr(trans_cnf_resel_ind);
        }
        rrc_free(trans_cnf_resel_ind);
      } 
      else if(rrc_csp_int_data.cel_resel_ind_rcvd_waiting_trans_cnf)
      {
        rrc_cmd_type *cel_resel_ind;
        WRRC_MSG0_HIGH("Process the Pending CEL RESEL IND");
        rrc_csp_int_data.cel_resel_ind_rcvd_waiting_trans_cnf = FALSE;
        /* Allocate memory */
        if( (cel_resel_ind = (rrc_cmd_type *)rrc_malloc(sizeof(rrc_cmd_type))) == NULL )
        {
          ERR_FATAL("Could not allocate memory for RRC-L1 cmd q!", 0, 0, 0);
        }
        /* The cause is set to RRC_CPHY_CELL_RESELECTION_IND so that csp expects as this is 
           received from L1
        */    
        cel_resel_ind->cmd_hdr.cmd_id = RRC_CPHY_CELL_RESELECTION_IND;        
        /* Pack the reselection related info into the buffer from cell transition_cnf message received from L1 */
        WCDMA_MEMCPY(&(cel_resel_ind->cmd.cell_rsel_ind),
                     sizeof(l1_cell_reselec_ind_type),
                     &(rrc_csp_int_data.saved_rrc_cmd.cmd.cell_rsel_ind),
                     sizeof(l1_cell_reselec_ind_type));

        if(rrc_csp_substate == RRCCSP_SUIT_CELL_RESELECT_WT_TRANS_CNF)
        {
          next_substate = rrccsp_camped_suit_cell_hdlr(cel_resel_ind);
        }
        else
        {
          next_substate = rrccsp_camped_accept_cell_hdlr(cel_resel_ind);
        }
        rrc_free(cel_resel_ind);
      }

#ifdef FEATURE_GAN
      #error code not present
#endif
      break;

    case RRC_CPHY_CELL_RESELECTION_IND:
      if(!rrc_csp_int_data.cel_trans_cnf_recvd_at_llc)
      {
        /* Ignore the cell reselection indication */
        WRRC_MSG0_HIGH("Ignored resel-ind in suit_wt_trans_cnf st");
      }
      else
      {
        WRRC_MSG0_HIGH("Don't Ignore the request, Process the request after receiving TRANSITION_CNF");
        rrc_csp_int_data.saved_rrc_cmd = *cmd_ptr;
        rrc_csp_int_data.cel_resel_ind_rcvd_waiting_trans_cnf = TRUE;
      }
      break;

    case RRC_SERVICE_REQ:

      if(rrc_state != RRC_STATE_DISCONNECTED)
      {
        WRRC_MSG1_ERROR("Service req in RRC state %d",rrc_state);
      }

      /* Process the Service Request */
      WRRC_MSG0_HIGH("Start cell sel for srvc req");
      rrc_csp_init_data_from_service_req(&cmd_ptr->cmd.rrc_service_req);
      /* Release the established channels and start cell selection */
      next_substate = rrc_csp_release_chls_and_start_sel_on_mm_req();
      break;


    case RRC_PLMN_LIST_REQ:
      if(rrccsp_plmn_list_req_is_valid(&(cmd_ptr->cmd.plmn_list_req)))
      {
        if(!rrccsp_handle_plmn_list_req_in_bgnd(&(cmd_ptr->cmd.plmn_list_req)))
        { 
          WRRC_MSG0_ERROR("ERR: Invalid PLMN_LIST_REQ rcvd");
        }
      }
      break;

    case RRC_STATE_CHANGE_IND:
      next_substate = rrccsp_camped_cell_state_change( cmd_ptr );
      break;

    case RRC_REDIRECT_REQ:
      WRRC_MSG2_HIGH("Cmd 0x%x (RRC_REDIRECT_REQ) recvd in WT_TRANS_CNF sstate %d",
                                      cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);

      if(rrccsp_validate_redirection_req( cmd_ptr ))
      {
        rrc_csp_int_data.freq_redirect_wait_time = cmd_ptr->cmd.redirect_req.wait_time;
        /* Release all channels before starting redirection search due to connection release
        */
        if(cmd_ptr->cmd.redirect_req.proc_id == RRC_PROCEDURE_RCR)
        {
          rrc_csp_send_chan_release();
        }

        /* Inter Frequency Redirection */
        if(cmd_ptr->cmd.redirect_req.choice == RRC_FREQ_REDIRECTION)
        {
          WRRC_MSG0_HIGH("INTER_FREQ_REDIRECT_REQ rcvd in WT_TRANS_CNF");

          /* Attempt acquisition on the designated frequency */
          rrc_csp_int_data.redirected_freq         = cmd_ptr->cmd.redirect_req.u.freq.uarfcn_DL;
          /* Start acquisition on redirected freq and start wait timer for last camped freq */
          next_substate = rrccsp_handle_rrc_redirect_req(next_substate);
        }
        else
        {
          WRRC_MSG0_HIGH("INTER_RAT_REDIRECT_REQ rcvd in WT_TRANS_CNF");

          /* Set the current scan to inter RAT redirection scan */
          rrc_csp_int_data.curr_scan     = RRC_CSP_INTER_RAT_REDIRECTION_SCAN;
          /* Store the Internal RRC command information */
          WCDMA_MEMCPY(&rrc_csp_int_data.saved_rrc_cmd,
                       sizeof(rrc_cmd_type),
                       cmd_ptr,
                       sizeof(rrc_cmd_int_type));

          /* Send change mode request to MCM */
          rrccsp_send_mode_change_req_to_mcm(RRC_MODE_STANDBY);
          next_substate = RRCCSP_WT_SUSPEND_MODE_CHANGE_CNF;
        }
      }
      break;

    case RRC_INITIATE_CELL_SELECTION_IND:
      if(cmd_ptr->cmd.initiate_cell_sel_ind.cause == RRC_CELL_SEL_RB0_SETUP_FAILURE)
      {
       WRRC_MSG0_HIGH("Start cell sel RB0 failure, treat as OOS");
       next_substate =
         rrccsp_handle_out_of_service_ind( rrc_csp_substate );
      }
      else if(cmd_ptr->cmd.initiate_cell_sel_ind.cause == RRC_OUT_OF_SERVICE_AREA_IND)
      {
        WRRC_MSG1_HIGH("OOS initiated by proc rrc_proc_e_type_value%d",
                   cmd_ptr->cmd.initiate_cell_sel_ind.proc);
        next_substate =
          rrccsp_handle_out_of_service_ind( rrc_csp_substate );
      }
      else if(cmd_ptr->cmd.initiate_cell_sel_ind.cause == RRC_TRANSITION_TO_DISCONNECTED)
      {
        WRRC_MSG1_HIGH("Handling initiate cell sel, proc rrc_proc_e_type_value%d",
                   cmd_ptr->cmd.initiate_cell_sel_ind.proc);
        rrc_csp_send_chan_release();
#ifdef FEATURE_DISCONNECT_ON_UNSUPPORTED_IRAT_REDIRECTION
        /*If dual mode disabled and redirection to GSM, then trigger OOS and go to idle with no servce*/
        if (cmd_ptr->cmd.initiate_cell_sel_ind.tx_to_discon_reason == RRC_TX_TO_DISCON_UNSUPPORTED_REDIRECTION)
        {
          /* First call a CCM function to indicate Cell Loss - no new cell */
          rrc_ccm_update_with_cell_loss();
          next_substate = rrccsp_rel_chls_and_go_to_idle();
        }
        else
#endif

          next_substate = rrc_csp_start_sel_leaving_conn_mode();
      }
      else
      {
       WRRC_MSG2_HIGH("Cause %d not handled %d CSP sstate ",
                 cmd_ptr->cmd.initiate_cell_sel_ind.cause, rrc_csp_substate);
      }
      break;

    case RRC_BPLMN_SEARCH_RESUME_IND:
      next_substate = rrccsp_service_bplmn_srch_req();
      break;

    case RRC_WTOW_BPLMN_DRX_SRCH_TIMER_EXPIRED_IND:
      rrc_csp_int_data.bplmn_crit_sec_flag = TRUE;
      /* Again this is a race condition and we should check if BPLMN search is actually
       * in progress before sending go to sleep ind to L1
       */
      if(WTOW_SEARCH_RESUME == rrc_csp_bplmn_srch_in_progress())
      {
        WRRC_MSG0_HIGH("WTOW BPLMN actively in prog. Send sleep ind to L1");
        rrc_csp_int_data.bplmn_srch_tmr_expired = TRUE;
        rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_SUSPEND, FALSE, TRUE);
      } 
      /* This is NOT an error. It is only a race condition that we might encounter.
       * ERR added to only check it
       */
      else
      {
        WRRC_MSG0_ERROR("WTOW ERR: race cond hit. Ignoring drx tmr expiry");
      }
      rrc_csp_int_data.bplmn_crit_sec_flag = FALSE;
      break;

    case RRC_BPLMN_GUARD_SRCH_TIMER_EXPIRED_IND:
      rrc_csp_int_data.bplmn_crit_sec_flag = TRUE;
      /* Again this is a race condition and we should check if BPLMN search is actually
       * in progress before sending go to sleep ind to L1
       */                                             
      if(WTOW_SEARCH_RESUME == rrc_csp_bplmn_srch_in_progress())
      {
        if(rrctmr_get_remaining_time(RRCTMR_BPLMN_GUARD_SRCH_TIMER) == 0)
        {
          WRRC_MSG0_HIGH("WTOW BPLMN actively in prog. Send sleep ind to L1");
          rrc_csp_int_data.bplmn_guard_srch_tmr_expired = TRUE;

          /* WTOG BPLMN search is in progress */
          if(rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_active)
          {
            if(!rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_aborted)
            {
              rrccsp_send_irat_bplmn_abort_req();
            }

            rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_ABORT, TRUE, FALSE);
          }
          /* WTOW BPLMN search is in progress */
          else
          {
            rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_ABORT, TRUE, TRUE);
          }      
        }
        else
        {
          WRRC_MSG0_ERROR("WTOW ERR: race cond hit. Ignoring guard tmr expiry");
        }
      } 
      else if(WTOW_SEARCH_SUSPEND == rrc_csp_bplmn_srch_in_progress())
      {
        if(rrctmr_get_remaining_time(RRCTMR_BPLMN_GUARD_SRCH_TIMER) == 0)
        {
          WRRC_MSG0_HIGH("WTOW BPLMN passively in prog. Do NOT send sleep ind to L1");
          rrc_csp_int_data.bplmn_guard_srch_tmr_expired = TRUE;

          if(rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_active
             && !(rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_aborted))
          {
            rrccsp_send_irat_bplmn_abort_req();
          }

          rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_ABORT, TRUE, FALSE);
        }
        else
        {
          WRRC_MSG0_ERROR("WTOW ERR: race cond hit. Ignoring guard tmr expiry");
        }
      }
      /* This is NOT an error. It is only a race condition that we might encounter.
       * ERR added to only check it
       */
      else
      {
        WRRC_MSG0_ERROR("WTOW ERR: race cond hit. Ignoring guard tmr expiry");
      }
      rrc_csp_int_data.bplmn_crit_sec_flag = FALSE;
      break;

    case RRC_BPLMN_SEARCH_ABORT_REQ:
       rrccsp_cleanup_bplmn_state();
       break;

    case RRC_BPLMN_SUSPEND_REQ:
      rrccsp_handle_passive_bplmn_suspend_req( cmd_ptr );
      break;
/*lint -e408*/
#ifdef FEATURE_GAN_3G_ROVE_OUT_ONLY
    #error code not present
#endif
/*lint +e408*/
    default:
      WRRC_MSG2_HIGH( "Cmd 0x%x not processed in CSP sstate %d",
                            cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);
      break;
  }
  if((cmd_ptr->cmd_hdr.cmd_id != RRC_CPHY_CELL_RESELECTION_IND) && 
     (next_substate !=rrc_csp_substate))
  {
    if(rrc_csp_int_data.cel_resel_ind_rcvd_waiting_trans_cnf)
    {
      WRRC_MSG0_HIGH("Resetting cel_resel_ind_rcvd_waiting_trans_cnf");
      rrc_csp_int_data.cel_resel_ind_rcvd_waiting_trans_cnf = FALSE;
    }
  }
  if(next_substate !=rrc_csp_substate)
  {
    rrc_csp_int_data.cel_trans_cnf_recvd_at_llc = TRUE;
  }
  return( next_substate );
} /* rrccsp_cell_resel_wait_trans_cnf_hdlr */



/*===========================================================================

FUNCTION        RRCCSP_CAMPED_SUIT_CELL_HDLR

DESCRIPTION
                This is a handler for events received in
                RRCCSP_CAMPED_SUIT_CELL substate of the Cell Selection
                Procedure.
                Depending on the event, it further calls a function for
                processing the event in this CSP substate.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_camped_suit_cell_hdlr( rrc_cmd_type *cmd_ptr )
{
  rrc_csp_substate_e_type   next_substate;
  rrc_state_e_type          rrc_state = rrc_get_state();

#ifdef FEATURE_GAN_3G_ROVE_OUT_ONLY
  #error code not present
#endif

#ifdef FEATURE_DUAL_SIM
  rrc_proc_e_type                 proc_id;
  rrcllc_oc_process_state_e_type  process_state;
  rrcllc_oc_set_status_e_type     oc_status;
#endif
  next_substate = RRCCSP_CAMPED_SUIT_CELL;

#ifdef FEATURE_DUAL_SIM
  if(cmd_ptr->cmd_hdr.cmd_id == RRC_RESET_L1_CNF)
  {
    if(rrc_csp_int_data.csp_waiting_for_wl1_to_release_lock)
    {
      rrc_csp_int_data.csp_waiting_for_wl1_to_release_lock = FALSE;
      if(rrc_csp_int_data.preemption_handling_in_progress)
      {
        rrc_csp_int_data.preemption_handling_in_progress = FALSE;
        /* Save the Reset L1 cmd in temp pointer so that it will be restored after prcessing Initiate  Cell select ind cmd,
           for proper free in dispatcher */
        if(rrc_csp_int_data.saved_rrc_cmd.cmd_hdr.cmd_id  == RRC_INITIATE_CELL_SELECTION_IND)
        {
          /*Restore the saved Initiate  Cell select ind cmd*/
          cmd_ptr->cmd_hdr.cmd_id = RRC_INITIATE_CELL_SELECTION_IND;
          cmd_ptr->cmd.initiate_cell_sel_ind = rrc_csp_int_data.saved_rrc_cmd.cmd.initiate_cell_sel_ind;
        }
        else
        {
          WRRC_MSG0_ERROR("This shouldn't happen:cmd id is not RRC_INITIATE_CELL_SELECTION_IND ");
        }
      }
    }
  }
#endif


  switch( cmd_ptr->cmd_hdr.cmd_id )
  {
    case RRC_CPHY_CELL_RESELECTION_IND:
      next_substate = rrc_csp_process_resel_ind(cmd_ptr);
      break;

    case RRC_SERVICE_REQ:
      if(rrc_state != RRC_STATE_DISCONNECTED)
      {
        WRRC_MSG1_ERROR("Service req in RRC state %d",rrc_state);
      }

      /* Process the Service Request */
      WRRC_MSG0_HIGH("Start cell sel for srvc req");
      rrc_csp_init_data_from_service_req(&cmd_ptr->cmd.rrc_service_req);
#ifdef FEATURE_WRLF_SYSTEM_SEL
      if(RRC_IS_CONN_MODE_OOS_SRCH_IN_PROGRESS())
      {
        /* Donot release channels when OOSC is in progress.*/
        next_substate = rrc_csp_start_sel_on_mm_req();
      }
      else
#endif
      {
        /* Release the established channels and start cell selection */
        next_substate = rrc_csp_release_chls_and_start_sel_on_mm_req();
      }
      break;

    case RRC_STATE_CHANGE_IND:
      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
      next_substate = rrccsp_camped_cell_state_change( cmd_ptr );
      break;

    case RRC_REDIRECT_REQ:
      WRRC_MSG2_HIGH("Cmd 0x%x (RRC_REDIRECT_REQ) recvd in CAMPED_SUIT_CELL sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);

      if(rrccsp_validate_redirection_req( cmd_ptr ))
      {
        rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_OOS);
        rrc_csp_int_data.freq_redirect_wait_time = cmd_ptr->cmd.redirect_req.wait_time;
        /* Release all channels before starting redirection search due to connection release
        */
        if(cmd_ptr->cmd.redirect_req.proc_id == RRC_PROCEDURE_RCR)
        {
          rrc_csp_send_chan_release();
        }

        /* Inter Frequency Redirection */
        if(cmd_ptr->cmd.redirect_req.choice == RRC_FREQ_REDIRECTION)
        {
          /* Attempt acquisition on the designated frequency */
          rrc_csp_int_data.redirected_freq = cmd_ptr->cmd.redirect_req.u.freq.uarfcn_DL;
          rrc_csp_int_data.redirected_psc  = cmd_ptr->cmd.redirect_req.psc;

          /* Start acquisition on redirected freq and start wait timer for last camped freq */
          next_substate = rrccsp_handle_rrc_redirect_req(next_substate);
        }

        /* Inter RAT Redirection */
        else
        {
          rrc_csp_int_data.curr_scan = RRC_CSP_INTER_RAT_REDIRECTION_SCAN;
          /* Store the Internal RRC command information */
          WCDMA_MEMCPY(&rrc_csp_int_data.saved_rrc_cmd,
                       sizeof(rrc_cmd_type),
                       cmd_ptr,
                       sizeof(rrc_cmd_int_type));
          /* Send change mode request to MCM */
          rrccsp_send_mode_change_req_to_mcm(RRC_MODE_STANDBY);
          next_substate = RRCCSP_WT_SUSPEND_MODE_CHANGE_CNF;
        }
      }
      break;

    case RRC_PLMN_LIST_REQ:
      MSG_MED("Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );

      if(rrccsp_plmn_list_req_is_valid(&(cmd_ptr->cmd.plmn_list_req)))
      {
        next_substate = rrccsp_handle_plmn_list_req(next_substate,
                                              &(cmd_ptr->cmd.plmn_list_req));
      }
      break;

    case RRC_INITIATE_CELL_SELECTION_IND:
      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
#ifdef FEATURE_DUAL_SIM
      if(DS_Immediate_preempt_waiting_for_init_cell_sel)
      {
         /* During NW triggered DCH to FACH transition if immediate preemption is triggered
             Idle request should not be sent to L1 as LLC sends fake cphy setup request
             to L1 in Idle state. Procedures check is added to makre sure the call is not released
             because of RL_FAILURE  */
        oc_status = rrcllc_get_ordered_config_state_and_proc(&proc_id, &process_state);
        if((OC_SET_FOR_DCH_FACH_TRANS == oc_status) &&
           ((proc_id == RRC_PROCEDURE_RBE) ||
            (proc_id == RRC_PROCEDURE_RBR) ||
            (proc_id == RRC_PROCEDURE_RBRC) ||
            (proc_id == RRC_PROCEDURE_TCR) ||
            (proc_id == RRC_PROCEDURE_PCR)))
        {
          return rrccsp_rel_chls_and_go_to_idle();
        }
        else
        {
          /* Store the RRC command information */
          WCDMA_MEMCPY(&rrc_csp_int_data.saved_rrc_cmd,
                       sizeof(rrc_cmd_type),
                       cmd_ptr,
                       sizeof(rrc_cmd_int_type));
          DS_Immediate_preempt_waiting_for_init_cell_sel = FALSE;
          rrc_csp_int_data.preemption_handling_in_progress = TRUE;
          rrc_csp_int_data.csp_waiting_for_wl1_to_release_lock = TRUE;
          rrc_csp_send_l1_idle_req();
          return next_substate;
        }
      }
#endif
      if(cmd_ptr->cmd.initiate_cell_sel_ind.cause == RRC_OUT_OF_SERVICE_AREA_IND)
      {
        next_substate = rrccsp_handle_out_of_service_ind( rrc_csp_substate );
      }
      else if(cmd_ptr->cmd.initiate_cell_sel_ind.cause == RRC_TRANSITION_FROM_DCH)
      {
        next_substate = rrccsp_camped_cell_state_transition_from_dch( cmd_ptr );
      }
      else if(cmd_ptr->cmd.initiate_cell_sel_ind.cause == RRC_TRANSITION_FROM_FACH)
      {
        next_substate = rrccsp_handle_freq_redirect_in_cell_fach( cmd_ptr );
      }
      else if(cmd_ptr->cmd.initiate_cell_sel_ind.cause == RRC_CELL_SEL_RB0_SETUP_FAILURE)
      {
        WRRC_MSG0_HIGH("Start cell sel RB0 failure, treat as OOS");
        next_substate = rrccsp_handle_out_of_service_ind( rrc_csp_substate );
      }
      else if(cmd_ptr->cmd.initiate_cell_sel_ind.cause == RRC_TRANSITION_TO_DISCONNECTED)
      {
        /* If the procedure is CU and reason for initiating cell selection is
         * TRANSITION_TO_DISCONNECTED, process the command
         */
        if(rrccho_is_wtog_cco_in_progress() == TRUE)
        {
          WRRC_MSG0_HIGH("CCO active, wt for WCDMA resume/stop");
        }
        else
        {
    
          /* Determine if UE needs to be woken up before handling this command.
           * In Connected Mode, UE goes to deep sleep only when scan type is OOS.
           * Here, if the deep sleep timer is running then it implies that UE is
           * in deep sleep and hence needs to be woken up.
           *
           */
          if(    (rrc_csp_int_data.curr_scan == RRC_CSP_OUT_OF_SERVICE_AREA_SCAN)
              && (!rrc_csp_int_data.oos_conn_mode_ds_tmr_expd)
              && (!nv_gcf_test_flag)
            )
          {
            WRRC_MSG0_HIGH("OOS: UE needs to be woken up for Conn->Idle Tx");

            /* Stop deep sleep timer */
            rrctmr_stop_timer(RRCTMR_CONN_MODE_OOS_DS_TIMER);
            rrc_csp_int_data.oos_conn_mode_ds_tmr_expd = TRUE;

            /* Send wake up request to LLC which in turn sends the request to L1 */
            if(rrccsp_send_conn_mode_oos_ds_wakeup_req() == FAILURE)
            {
#ifdef FEATURE_DUAL_SIM
              /*Failure will be returned only for hard abort from NAS.
                Simply return and let hard abort request take care of further processing*/
              rrc_csp_int_data.oos_conn_mode_ds_tmr_expd = FALSE;
              WRRC_MSG0_HIGH("DSIM: Failed to acquire lock for DS Wakeup.");
              return RRCCSP_CAMPED_SUIT_CELL;
#else
              WRRC_MSG0_HIGH("DSIM: This should never happen !");
#endif
            }
          }
          WRRC_MSG2_HIGH("Rel chls & do cell sel, CSP sstate %d, scan %d",
                      rrc_csp_substate, rrc_csp_int_data.curr_scan);

          /* First Initialize the SIB variables */
          rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_OOS);

          rrc_csp_send_chan_release();
#ifdef FEATURE_DISCONNECT_ON_UNSUPPORTED_IRAT_REDIRECTION
          /*If dual mode disabled and redirection to GSM, then trigger OOS and go to idle with no servce*/

          if (cmd_ptr->cmd.initiate_cell_sel_ind.tx_to_discon_reason == RRC_TX_TO_DISCON_UNSUPPORTED_REDIRECTION)
          {
          /* First call a CCM function to indicate Cell Loss - no new cell */
            rrc_ccm_update_with_cell_loss();
            next_substate = rrccsp_rel_chls_and_go_to_idle();
          }
          else
#endif

            next_substate = rrc_csp_start_sel_leaving_conn_mode();

        }

     }
      else
      {
        WRRC_MSG1_HIGH("Cause %d for Initiate Cell Selection not handled",
                          cmd_ptr->cmd.initiate_cell_sel_ind.cause);
      }
      break;

    case RRC_CONN_MODE_OOS_DS_TIMER_EXPIRED_IND:
      rrc_csp_int_data.oos_conn_mode_ds_tmr_expd = TRUE;

      WRRC_MSG0_HIGH("OOS: DS tmr expd. Wakeup UE. Srch all enabled RATs");

      /* Handle the DS expiry only when curr scan is OOS_Scan */
      if(rrc_csp_int_data.curr_scan == RRC_CSP_OUT_OF_SERVICE_AREA_SCAN)
      {
        /* Send wake up request to LLC which in turn sends the request to L1 */
        if(rrccsp_send_conn_mode_oos_ds_wakeup_req() == FAILURE)
        {
#ifdef FEATURE_DUAL_SIM
          /*Failure will be returned only for hard abort from NAS.
            Simply return and let hard abort request take care of further processing*/
            rrc_csp_int_data.oos_conn_mode_ds_tmr_expd = FALSE;
          WRRC_MSG0_HIGH("DSIM: Failed to acquire lock for DS Wakeup.");
            return RRCCSP_CAMPED_SUIT_CELL;
#else
          WRRC_MSG0_HIGH("DSIM: This should never happen !");
#endif
        }

        
        /* Start again with Stored and Initial cell selection. Initiate Selection
         * data so that Selection Controller starts from the beginning.
         */
        if(rrc_csp_init_select_data(&rrc_csp_curr_select_data.req_plmn) == SUCCESS)
        {
          next_substate = rrc_csp_continue_cell_selection();
        }
        else
        { 
          WRRC_MSG0_ERROR("ERR: Initialization of data failed");
          next_substate = rrc_csp_continue_cell_selection();
        }
      }
      /* Ignore the DS timer expiry */
      else
      {
        WRRC_MSG1_HIGH("Ignoring DS timer expiry. curr_scan(%d) != OOS_Scan", rrc_csp_int_data.curr_scan);
      }
      break;


    case RRC_SIB_CHANGE_IND:
      MSG_MED("Cmd 0x%x recvd, CSP sstate %d",
                        cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0);

      WRRC_MSG1_HIGH("SIBs changed in RRC state:%d",rrc_state);

      next_substate = rrccsp_handle_sib_change(cmd_ptr);

      break;

    case RRC_CSP_WCDMA_RESUMED_IND:
      WRRC_MSG0_HIGH("Rxed WCDMA_RESUMED_IND from CHO");

      rrc_csp_send_chan_release();
      next_substate = rrc_csp_start_sel_leaving_conn_mode();
      break;

    case RRC_CPHY_DL_WEAK_IND:
      if(!(cmd_ptr->cmd.dl_weak_ind.serving_cell))
      {
        WRRC_MSG0_HIGH("DL_WK_IND for neigh cell. Ignored");
      }
      else
      {
        WRRC_MSG0_HIGH("DL_WK_IND for srving cell in camped st");
        if(SUCCESS == rrcsib_get_sib_7_update_status())
        {
          /* Call SIB fn to forcefully initialize its active event if any */
          rrcsib_force_sib_event_init(RRCSIB_ABORT_SIB7_UPDATE);
        }
        else if(rrcsib_is_event_update_sibs_active() == TRUE)
        {  
          /* Call SIB fn to forcefully initialize its active event if any */
          rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_DL_WK_IND);
        }
      }
      break;
#ifdef FEATURE_DUAL_SIM
      case RRC_DUAL_SIM_WRM_UNLOCK_BY_TIMER_EXP_IND:
        /*Allow preemption if tuneaway feature is enabled */
        if(ds_tuneaway_status_change_ind.tuneaway_status == TRUE)
        {
#ifdef FEATURE_QTA
          /* RRC to not send START_QTA_REQ to L1 if RRC got the chance to process
             RRC_DUAL_SIM_WRM_UNLOCK_BY_TIMER_EXP_IND after GSM already 
             requested for UNLOCK_BY for the next page. */
          if (rrctmr_get_remaining_time(RRCTMR_WRM_UNLOCK_BY_TIMER) != 0)
          {
            WRRC_MSG0_HIGH("Ignore QTA. RRC task delay. Handle next");
            return next_substate;
          }

          if(wrm_is_next_tuneaway_qta())
          {
            if(rrcwrm_validate_qta_handling())
            {
              rrc_csp_int_data.curr_scan = RRC_CSP_UNLOCK_BY_SCAN;
              /* WARNING: This QTA function causes freeze of RRC task. */
              rrc_freeze_for_qta();
              rrc_csp_int_data.curr_scan = RRC_CSP_CELL_SELECTION_SCAN;

              /* Do a retain lock to get a pre-emption call back for the case when W didnt released the lock as G changed
                 its stance and made another request for LTA. */
               wrm_retain_lock_for_primary();
            }
          }
          else if(rrc_is_ps_domain_rab_present() || rrc_allow_lta)
#endif
          {
            /*  Allow Preemption only if UE is in stable state*/
            if (rrc_check_preemption_can_be_handled_in_fach_dch())
            {
             /* Cell id in DCH should be aborted when LTA collides */
             if(rrc_sib_is_current_event_sib_read_in_dch())
             {
               rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_SIB_READ_IN_DCH);
             }
              rrc_csp_int_data.curr_scan = RRC_CSP_UNLOCK_BY_SCAN;
              /* Send change mode request to MCM */
              rrccsp_send_mode_change_req_to_mcm(RRC_MODE_STANDBY);
              next_substate = RRCCSP_WT_SUSPEND_MODE_CHANGE_CNF;
            }
            else if (rrcwrm_is_unlock_required_received())
            {
              rrctmr_start_timer(RRCTMR_WRM_UNLOCK_BY_TIMER, 300);
              WRRC_MSG0_HIGH("DSIM_TUNEAWAY: Can't handle now. Started 300ms unlock required timer");
            }
            else
            {
              WRRC_MSG0_HIGH("DSIM_TUNEAWAY: UE is not in stable state Ignoring RRC_DUAL_SIM_WRM_UNLOCK_BY_TIMER_EXP_IND");
            }
          }
          else
          {
            WRRC_MSG0_HIGH("DSIM_TUNEAWAY: LTA is ignored as PS RAB is not yet up");
          }
        }
        else
        {
          WRRC_MSG0_HIGH("DSIM_TUNEAWAY: Ignoring RRC_DUAL_SIM_WRM_UNLOCK_BY_TIMER_EXP_IND as Tuneaway is disabled ");
        }
        break;
#endif


    case RRC_BPLMN_SEARCH_RESUME_IND:
      next_substate = rrccsp_service_bplmn_srch_req();
      break;

    case RRC_WTOW_BPLMN_DRX_SRCH_TIMER_EXPIRED_IND:
      rrc_csp_int_data.bplmn_crit_sec_flag = TRUE;
      /* Again this is a race condition and we should check if BPLMN search is actually
       * in progress before sending go to sleep ind to L1
       */
      if(WTOW_SEARCH_RESUME == rrc_csp_bplmn_srch_in_progress())
      {
        WRRC_MSG0_HIGH("WTOW BPLMN actively in prog. Send sleep ind to L1");
        rrc_csp_int_data.bplmn_srch_tmr_expired = TRUE;
        rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_SUSPEND, FALSE, TRUE);
      } 
      /* This is NOT an error. It is only a race condition that we might encounter.
       * ERR added to only check it
       */
      else
      {
        WRRC_MSG0_ERROR("WTOW ERR: race cond hit. Ignoring drx tmr expiry");
      }
      rrc_csp_int_data.bplmn_crit_sec_flag = FALSE;
      break;

    case RRC_BPLMN_GUARD_SRCH_TIMER_EXPIRED_IND:
      rrc_csp_int_data.bplmn_crit_sec_flag = TRUE;
      /* Again this is a race condition and we should check if BPLMN search is actually
       * in progress before sending go to sleep ind to L1
       */                                             
      if(WTOW_SEARCH_RESUME == rrc_csp_bplmn_srch_in_progress())
      {
        if(rrctmr_get_remaining_time(RRCTMR_BPLMN_GUARD_SRCH_TIMER) == 0)
        {
          WRRC_MSG0_HIGH("WTOW/WTOG BPLMN actively in prog. Send sleep ind to L1");
          rrc_csp_int_data.bplmn_guard_srch_tmr_expired = TRUE;

          /* WTOG BPLMN search is in progress */
          if(rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_active)
          {
            if(!rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_aborted)
            {
              rrccsp_send_irat_bplmn_abort_req();
            }

            rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_ABORT, TRUE, FALSE);
          }
          /* WTOW BPLMN search is in progress */
          else
          {
            rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_ABORT, TRUE, TRUE);
          }      
        }
        else
        {
          WRRC_MSG0_ERROR("WTOW ERR: race cond hit. Ignoring guard tmr expiry");
        }
      } 
      else if(WTOW_SEARCH_SUSPEND == rrc_csp_bplmn_srch_in_progress())
      {
        if(rrctmr_get_remaining_time(RRCTMR_BPLMN_GUARD_SRCH_TIMER) == 0)
        {
          WRRC_MSG0_HIGH("WTOW BPLMN passively in prog. Do NOT send sleep ind to L1");
          rrc_csp_int_data.bplmn_guard_srch_tmr_expired = TRUE;

          if(rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_active
             && !(rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_aborted))
          {
            rrccsp_send_irat_bplmn_abort_req();
          }

          rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_ABORT, TRUE, FALSE);
        }
        else
        {
          WRRC_MSG0_ERROR("WTOW ERR: race cond hit. Ignoring guard tmr expiry");
        }
      }
      /* This is NOT an error. It is only a race condition that we might encounter.
       * ERR added to only check it
       */
      else
      {
        WRRC_MSG0_ERROR("WTOW ERR: race cond hit. Ignoring guard tmr expiry");
      }
      rrc_csp_int_data.bplmn_crit_sec_flag = FALSE;
      break;

    case RRC_BPLMN_SEARCH_ABORT_REQ:
       rrccsp_cleanup_bplmn_state();
       break;

    case RRC_BPLMN_SUSPEND_REQ:
      rrccsp_handle_passive_bplmn_suspend_req( cmd_ptr );
      break;

#ifdef FEATURE_OOSC_USER_ACTION
    case RRC_EXIT_FROM_PWR_SAVE:
      if((rrc_csp_int_data.curr_scan == RRC_CSP_OUT_OF_SERVICE_AREA_SCAN)
         && (!rrc_csp_int_data.oos_conn_mode_ds_tmr_expd))
      {
        /* Stop deep sleep timer */
        rrctmr_stop_timer(RRCTMR_CONN_MODE_OOS_DS_TIMER);

        /* Send wake up request to LLC which in turn sends the request to L1 */
        if(rrccsp_send_conn_mode_oos_ds_wakeup_req() == FAILURE)
        {
#ifdef FEATURE_DUAL_SIM
          WRRC_MSG0_HIGH("DSIM: Failed to acquire lock for DS Wakeup.");
          /*Failure will be returned only for hard abort from NAS.
                     Simply return and let hard abort request take care of further processing*/
          rrc_csp_int_data.oos_conn_mode_ds_tmr_expd = FALSE;
          return RRCCSP_CAMPED_SUIT_CELL;
#else
          WRRC_MSG0_HIGH("DSIM: This should never happen !");
#endif
        }

         /* Start again with Stored and Initial cell selection. Initiate Selection
         * data so that Selection Controller starts from the beginning.
         */
        if(rrc_csp_init_select_data(&rrc_csp_curr_select_data.req_plmn) == SUCCESS)
        {
          next_substate = rrc_csp_continue_cell_selection();
        }
        else
        { 
          WRRC_MSG0_ERROR("ERR: Initialization of data failed");
          next_substate = rrc_csp_continue_cell_selection();
        }
      }
      else
      {
        WRRC_MSG0_HIGH("Ignoring key press event");
      }
    break;
#endif
/*lint -e408*/
#ifdef FEATURE_GAN_3G_ROVE_OUT_ONLY
    #error code not present
#endif
/*lint +e408*/
    default:
      WRRC_MSG2_HIGH( "Cmd 0x%x not processed in CSP sstate %d",
                            cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);
      break;
  }
  return( next_substate );
} /* rrccsp_camped_suit_cell_hdlr */







/*===========================================================================

FUNCTION        RRCCSP_CAMPED_ACCEPT_CELL_RESELECTION_IND

DESCRIPTION
                This function processes a Reselection Indication while
                waiting in RRCCSP_CAMPED_ACCEPT_CELL substate.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_camped_accept_cell_reselection_ind( rrc_cmd_type *cmd_ptr )
{
  rrc_csp_substate_e_type  next_substate;
  rrc_csp_sib_mask_type    sib_mask = 0;

  next_substate = RRCCSP_CAMPED_ACCEPT_CELL;

  /* Store the information for the new cell to be selected */
  rrc_csp_int_data.new_cell_acq_entry.freq = cmd_ptr->cmd.cell_rsel_ind.u.wcdma_info.freq;
  rrc_csp_int_data.new_cell_acq_entry.scr_code = cmd_ptr->cmd.cell_rsel_ind.u.wcdma_info.scr_code;

  /* Get all the SIBs here */
  sib_mask = MIB_BIT|SIB_1_BIT|SIB_2_BIT|SIB_3_BIT|SIB_4_BIT|SIB_5_BIT|SIB_6_BIT|SIB_7_BIT|SIB_11_BIT|SIB_12_BIT|SIB_18_BIT;

  /*SIB11bis is an extension type SIB, so add SIB_11BIS_BIT mask to read Sib11bis*/
  sib_mask = sib_mask|SIB_11BIS_BIT;

#ifdef FEATURE_WCDMA_TO_LTE
  sib_mask = sib_mask | SIB_19_BIT;
#endif

  if(rrc_csp_send_sib_cmd(RRC_GET_SPECIFIC_SIBS_REQ, sib_mask,
                          &rrc_csp_int_data.new_cell_acq_entry,
                          FALSE ) == SUCCESS)
  {
    MSG_MED( "RRC Cmd 0x%x sent, CSP sstate %d",
                                     RRC_GET_SPECIFIC_SIBS_REQ, RRCCSP_CAMPED_ACCEPT_CELL, 0 );
    /* Start waiting for SIB Confirmation */
    next_substate = RRCCSP_ACCEPT_CELL_RESELECT_WT_SIB;
  }
  else
  {
    ERR_FATAL("Failure to send SIB cmd 0x%x in CSP substate %d",
                                 RRC_GET_SPECIFIC_SIBS_REQ, RRCCSP_CAMPED_ACCEPT_CELL, 0);
  }

  return next_substate;

}/* rrccsp_camped_accept_cell_reselection_ind */

/*===========================================================================

FUNCTION        RRC_CSP_PROCESS_RESEL_IND

DESCRIPTION
                Processes reselection indication

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrc_csp_process_resel_ind( rrc_cmd_type *cmd_ptr )
{

  boolean send_transition_failure = FALSE;
  rrc_state_e_type      rrc_state = rrc_get_state();
  boolean           rrccho_active = rrccho_is_gtow_pcco_in_progress();
  boolean           rrcrce_active = (!(rrcrce_is_rce_procedure_inactive()));
  l1_resel_fail_cause_enum_type  fail_cause = L1_RESEL_FAIL_CAUSE_NONE;
  
  MSG_MED( "Cmd 0x%x recvd, CSP sstate %d", cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );

#ifdef FEATURE_DUAL_SIM
  if(rrc_csp_int_data.csp_waiting_for_wl1_to_release_lock)
  {
    WRRC_MSG0_HIGH("RRC waiting for wl1 to release lock. Ignore cell resel ind");
    return rrc_csp_substate;
  }
#endif

  if(cmd_ptr->cmd.cell_rsel_ind.cell == L1_RESEL_WCDMA)
  {
#ifdef FEATURE_QSH_EVENT_METRIC
    wrrc_qsh_log_cell_resel_stats(WCDMA_RAT_MOB, WRRC_METRIC_UPDATE);  
#endif
    /* First check if OC has been set for DCH by a Reconfig message */
    if((rrcllc_get_ordered_config_status() == OC_SET_FOR_CELL_DCH) ||
       (rrc_state == RRC_STATE_CELL_DCH))
    {
      WRRC_MSG0_HIGH("Incompatible state, ignore cell resel");
    }
    else if(rrcrce_ignore_resel(cmd_ptr->cmd.cell_rsel_ind.u.wcdma_info.freq,cmd_ptr->cmd.cell_rsel_ind.u.wcdma_info.scr_code))
    {
      WRRC_MSG0_HIGH("MT call establishment in progress. Ignore cell reselection");
      fail_cause = RRC_RESEL_FAIL_CAUSE_INTERNAL;
      send_transition_failure = TRUE;
    }
    else if(((cmd_ptr->cmd.cell_rsel_ind.u.wcdma_info.freq == rrc_csp_int_data.curr_acq_entry.freq) &&
             (cmd_ptr->cmd.cell_rsel_ind.u.wcdma_info.scr_code == rrc_csp_int_data.curr_acq_entry.scr_code)) ||
             ((cmd_ptr->cmd.cell_rsel_ind.u.wcdma_info.freq == rrc_csp_int_data.new_cell_acq_entry.freq) &&
              (cmd_ptr->cmd.cell_rsel_ind.u.wcdma_info.scr_code == rrc_csp_int_data.new_cell_acq_entry.scr_code)))
    {

      WRRC_MSG2_ERROR("Duplicate cell reselection ind received. resel_freq %d, resel_scr_code %d",
                                           cmd_ptr->cmd.cell_rsel_ind.u.wcdma_info.freq,
                                           cmd_ptr->cmd.cell_rsel_ind.u.wcdma_info.scr_code
                                           );

      WRRC_MSG2_ERROR("curr_acq_entry freq %d, scr_code %d", rrc_csp_int_data.curr_acq_entry.freq,
                                                 rrc_csp_int_data.curr_acq_entry.scr_code
                                                 );

      WRRC_MSG2_ERROR("new_cell_acq_entry freq %d, scr_code %d", rrc_csp_int_data.new_cell_acq_entry.freq,
                                                     rrc_csp_int_data.new_cell_acq_entry.scr_code
                                                     );
      fail_cause = RRC_RESEL_FAIL_CAUSE_INTERNAL;
      send_transition_failure = TRUE;
    }
    else if(rrccho_active) 
    {
      WRRC_MSG0_HIGH("GtoW CCO in Progress. Sending RRC->L1 Tx_Failure for W resel");
      fail_cause = L1_RESEL_FAIL_CAUSE_RRC_PROC_ACTIVE;
      send_transition_failure = TRUE;
    }
    else
    {
      if((cmd_ptr->cmd.cell_rsel_ind.u.wcdma_info.freq !=
                          rrc_csp_int_data.curr_acq_entry.freq))

      {
        /* It's an inter-frequency cell reselection */
        /* Send transition failure if CU is active*/
        if(((rrc_state == RRC_STATE_DISCONNECTED) && (!rrcrce_active))
           ||((rrc_state == RRC_STATE_CELL_PCH) && (rrccu_get_cell_update_started_status() == RRCCU_NOT_STARTED))
           ||((rrc_state == RRC_STATE_URA_PCH) && (rrccu_get_cell_update_started_status() == RRCCU_NOT_STARTED))
           || ((rrc_state == RRC_STATE_CELL_FACH) && (rrctmr_get_remaining_time(RRCTMR_WAIT_FOR_L2_ACK_FOR_PCH_TRANSITION_TIMER) == 0)))
        {
          /* Set the boolean indicating inter-freq is in progress to TRUE */
          rrccsp_inter_freq_cell_resel_in_progress = TRUE;

          if(rrc_csp_substate == RRCCSP_CAMPED_SUIT_CELL)
          {
            return(rrccsp_camped_suit_cell_reselection_ind( cmd_ptr ));
          }
          else
          {
            return (rrccsp_camped_accept_cell_reselection_ind(cmd_ptr));
          }
        }
        else
        {
          WRRC_MSG2_HIGH("Ignored Inter-freq Resel st %d RCE %d",
                                 rrc_state, rrcrce_active);
          fail_cause = L1_RESEL_FAIL_CAUSE_RRC_PROC_ACTIVE;
          send_transition_failure = TRUE;
        }
      }
      else
      {
        /* Process the Intra-frequency cell reselection indication */
        if(rrc_csp_substate == RRCCSP_CAMPED_SUIT_CELL)
        {
          return(rrccsp_camped_suit_cell_reselection_ind( cmd_ptr ));
        }
        else
        {
          return (rrccsp_camped_accept_cell_reselection_ind(cmd_ptr));
        }
      }
    }
  }
  else if((cmd_ptr->cmd.cell_rsel_ind.cell == L1_RESEL_GSM)
#ifdef FEATURE_WCDMA_TO_LTE
        ||(cmd_ptr->cmd.cell_rsel_ind.cell == L1_RESEL_LTE)
#endif
         )
 {
 
#ifdef FEATURE_QSH_EVENT_METRIC
   if(cmd_ptr->cmd.cell_rsel_ind.cell == L1_RESEL_GSM)
   	{
      wrrc_qsh_log_cell_resel_stats(GSM_RAT_MOB, WRRC_METRIC_UPDATE);  
   	}
   else
   	{
      wrrc_qsh_log_cell_resel_stats(LTE_RAT_MOB, WRRC_METRIC_UPDATE);	
   	}
#endif
   /* First check if OC has been set for DCH by a Reconfig message */
   if((rrcllc_get_ordered_config_status() == OC_SET_FOR_CELL_DCH) ||
      (rrc_state == RRC_STATE_CELL_DCH))
   {
     WRRC_MSG0_HIGH("Incompatible state, ignore cell resel");
   }
   else if(rrccho_active) 
   {
     WRRC_MSG0_HIGH("GtoW CCO in Progress. Sending RRC->L1 Tx_Failure for InterRAT resel");
     fail_cause = L1_RESEL_FAIL_CAUSE_RRC_PROC_ACTIVE;
     send_transition_failure = TRUE;
   }
   else
   if((WTOW_SEARCH_STOP != rrc_csp_bplmn_srch_in_progress())
      && (rrc_csp_int_data.bplmn_nw_sel_mode == SYS_NETWORK_SELECTION_MODE_MANUAL))
   {
     WRRC_MSG0_HIGH("Manual BPLMN Srch in prog. Sending RRC->L1 Tx_Failure for InterRAT resel");
     fail_cause = L1_RESEL_FAIL_CAUSE_RRC_PROC_ACTIVE;
     send_transition_failure = TRUE;
   }
   else if((rrcrce_send_abort_cnf) && (rrc_state != RRC_STATE_DISCONNECTED))
   {
     WRRC_MSG2_HIGH("Abort request in in progress...Ignore IRAT reselection", rrcrce_send_abort_cnf, rrc_state);
     fail_cause = L1_RESEL_FAIL_CAUSE_RRC_PROC_ACTIVE;
     send_transition_failure = TRUE;    
   }
   else
   /* Send transition failure if CU is active*/
   if(((rrc_state == RRC_STATE_DISCONNECTED) && (!rrcrce_active))
        ||((rrc_state == RRC_STATE_CELL_PCH) && (rrccu_get_cell_update_started_status() == RRCCU_NOT_STARTED))
        ||((rrc_state == RRC_STATE_URA_PCH) && (rrccu_get_cell_update_started_status() == RRCCU_NOT_STARTED))
        || (rrc_state == RRC_STATE_CELL_FACH))
   {
     /* Store the GSM cell reselection information */
     rrc_csp_int_data.saved_rrc_cmd = *cmd_ptr;

     /* Before sending WTOG reselection ind to GSM, cleanup BPLMN state */
     rrccsp_cleanup_bplmn_state();

     if(cmd_ptr->cmd.cell_rsel_ind.cell == L1_RESEL_GSM)
     {
       /* Increment WTOG cell reselection triggered count */
       RRC_DEBUG_INCREMENT_STATS(WTOG_CEL_RESEL_TRIGGERED);

       /* Start WCDMA -> GSM cell reselection. Send Mode change request
        * to MCM to suspend the WCDMA mode and wait for the confirmation
        */
       rrc_csp_int_data.curr_scan = RRC_CSP_WCDMA_TO_GSM_CELL_RESELECTION_SCAN;
#ifdef FEATURE_WCDMA_TO_LTE
       rrc_csp_int_data.interrat_type = RRC_CSP_INTERRAT_GSM;
#endif
      }

#ifdef FEATURE_WCDMA_TO_LTE
      if(cmd_ptr->cmd.cell_rsel_ind.cell == L1_RESEL_LTE)
      {
        rrc_csp_int_data.curr_scan = RRC_CSP_WCDMA_TO_GSM_CELL_RESELECTION_SCAN;
        rrc_csp_int_data.interrat_type = RRC_CSP_INTERRAT_LTE;
      }
#endif
      rrccsp_send_mode_change_req_to_mcm(RRC_MODE_STANDBY);
      rrc_csp_int_data.init_cell_sel_ind_during_wtointerrat = FALSE;
      return(RRCCSP_WT_SUSPEND_MODE_CHANGE_CNF);
    }
    else
    {
       WRRC_MSG2_HIGH("Ignored Inter-RAT Resel in st %d RCE %d",
                               rrc_state, rrcrce_active);
       fail_cause = L1_RESEL_FAIL_CAUSE_RRC_PROC_ACTIVE;
       send_transition_failure = TRUE;
    }
  }
  else
  {
    WRRC_MSG0_HIGH("Cell System not supported");
    fail_cause = RRC_RESEL_FAIL_CAUSE_INTERNAL;
    send_transition_failure = TRUE;
  }

  if(send_transition_failure == TRUE)
  {
    rrccsp_send_transition_failure_on_receipt_of_resel_ind(cmd_ptr,fail_cause);
    if(rrc_csp_substate == RRCCSP_CAMPED_SUIT_CELL)
    {
      return RRCCSP_SUIT_CELL_RESELECT_WT_TRANS_CNF;
    }
    else
    {
      return RRCCSP_ACCEPT_CELL_RESELECT_WT_TRANS_CNF;
    }
  }
  return rrc_csp_substate;
}



/* =======================================================================
** Function Definitions for substate:
    RRCCSP_ACCEPT_CELL_RESEL_WT_CAMP_PENDING
** ======================================================================= */

/*===========================================================================

FUNCTION        rrccsp_accept_cell_resel_wait_camp_pending_hdlr

DESCRIPTION
                This is a handler for events received in
                RRCCSP_ACCEPT_CELL_RESEL_WT_CAMP_PENDING substate of
                Cell Selection Procedure.
                Depending on the event, it further calls a function for
                processing the event in this CSP substate.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_accept_cell_resel_wait_camp_pending_hdlr( rrc_cmd_type *cmd_ptr )
{

  rrc_csp_substate_e_type   next_substate;
  rrc_state_e_type          rrc_state;

  next_substate = RRCCSP_ACCEPT_CELL_RESELECT_WT_CAMP_PENDING;

  switch( cmd_ptr->cmd_hdr.cmd_id )
  {
    case RRC_CELL_CHANGE_CNF:
      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );

      switch(rrc_csp_int_data.pending_type)
      {
        case RRC_CSP_SERVICE_REQ_PENDING:
          /* Reset reselection variables */
          rrccsp_reset_reselection_data();

          /* Start processing pending Service Request */
          WRRC_MSG0_HIGH("Start cell sel for pending srvc req");
          rrc_csp_init_data_from_service_req(&rrc_csp_int_data.pending_srvc_req_data);
          /* Release the established channels and start cell selection */
          next_substate = rrc_csp_release_chls_and_start_sel_on_mm_req();
          break;

        case RRC_CSP_PLMN_LIST_REQ_PENDING:
          /* Reset reselection variables */
          rrccsp_reset_reselection_data();
          next_substate = rrccsp_handle_plmn_list_req(next_substate,
                                                      &(rrc_csp_int_data.pending_plmn_list_req_data));
          break;

        case RRC_REDIRECT_REQ_PENDING:
          /* Reset reselection variables */
          rrccsp_reset_reselection_data();

          /* Release all channels before starting redirection search due to connection release
          */
          if(cmd_ptr->cmd.cell_change_cnf.req_proc_id == RRC_PROCEDURE_RCR)
          {
            rrc_csp_send_chan_release();
          }
          /* Inter Frequency Redirection */
          if((rrc_csp_int_data.saved_rrc_cmd).cmd.redirect_req.choice == RRC_FREQ_REDIRECTION)
          {
            WRRC_MSG0_HIGH("In FREQ_REDIRECT_REQ pending handler for RESELECT_WT_CAMP");

            /* Start acquisition on redirected freq and start wait timer for last camped freq */
            next_substate = rrccsp_handle_rrc_redirect_req(next_substate);
          }
          else
          {
            WRRC_MSG0_HIGH("In INTER_RAT_REDIRECT_REQ pending handler for RESELECT_WT_CAMP");
            /* Send change mode request to MCM */
            rrccsp_send_mode_change_req_to_mcm(RRC_MODE_STANDBY);
            next_substate = RRCCSP_WT_SUSPEND_MODE_CHANGE_CNF;
          }
          break;
#ifdef FEATURE_GAN_3G_ROVE_OUT_ONLY
        #error code not present
#endif
        default:
          ERR_FATAL("No pending type in %d CSP sstate",rrc_csp_substate,0,0);
          break;
      }
      break;

    case RRC_SERVICE_REQ:
      rrc_state = rrc_get_state();
      if(rrc_state != RRC_STATE_DISCONNECTED)
      {
        WRRC_MSG1_ERROR("Service req in RRC state %d",rrc_state);
      }

      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
      next_substate = rrccsp_cell_resel_wait_camp_req(cmd_ptr);
      break;


    case RRC_PLMN_LIST_REQ:
      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );

      if(rrccsp_plmn_list_req_is_valid(&(cmd_ptr->cmd.plmn_list_req)))
      {
        if(!rrccsp_handle_plmn_list_req_in_bgnd(&(cmd_ptr->cmd.plmn_list_req)))
        { 
          WRRC_MSG0_ERROR("ERR: Invalid PLMN_LIST_REQ rcvd");
        }
      }
      break;

    case RRC_REDIRECT_REQ:
      WRRC_MSG0_ERROR("RRC_REDIRECT_REQ rcvd in ACCEPT_RESEL_WT_CAMP_PENDING. Ignore it");
      break;

    case RRC_BPLMN_GUARD_SRCH_TIMER_EXPIRED_IND:
      rrccsp_cleanup_bplmn_state();
      break;

    case RRC_BPLMN_SEARCH_ABORT_REQ:
      if((rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
          || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN))
      { 
        rrccsp_prioritize_pending_commands(cmd_ptr);
      }
      else
      {
        WRRC_MSG1_ERROR("WTOW ERR: BPLMN_SUSPEND_REQ rcvd in st %d when BPLMN srch not in prog",
                                                                 next_substate);
      }
      break;

    case RRC_BPLMN_SUSPEND_REQ:
      rrccsp_handle_passive_bplmn_suspend_req( cmd_ptr );  
      break;

    default:
      WRRC_MSG2_HIGH( "Cmd 0x%x not processed in CSP sstate %d",
                          cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);
      break;
  }

  return( next_substate );

} /* rrccsp_accept_cell_resel_wait_camp_pending_hdlr */

/*===========================================================================

FUNCTION        RRCCSP_CAMPED_ACCEPT_CELL_HDLR

DESCRIPTION
                This is a handler for events received in
                RRCCSP_CAMPED_ACCEPT_CELL substate of the Cell Selection
                Procedure.
                Depending on the event, it further calls a function for
                processing the event in this CSP substate.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_camped_accept_cell_hdlr( rrc_cmd_type *cmd_ptr )
{
  rrc_csp_substate_e_type   next_substate;
  rrc_state_e_type          rrc_state = rrc_get_state();

#ifdef FEATURE_GAN_3G_ROVE_OUT_ONLY
  #error code not present
#endif
  next_substate = RRCCSP_CAMPED_ACCEPT_CELL;

  switch( cmd_ptr->cmd_hdr.cmd_id )
  {
    case RRC_CPHY_CELL_RESELECTION_IND:
      next_substate = rrc_csp_process_resel_ind(cmd_ptr);
      break;

    case RRC_SERVICE_REQ:
      if(rrc_state != RRC_STATE_DISCONNECTED)
      {
        WRRC_MSG1_ERROR("Service req in RRC state %d",rrc_state);
      }

      /* Process the Service Request */
      WRRC_MSG0_HIGH("Start cell sel for srvc req");
      rrc_csp_init_data_from_service_req(&cmd_ptr->cmd.rrc_service_req);
      /* Release the established channels and start cell selection */
      next_substate = rrc_csp_release_chls_and_start_sel_on_mm_req();
      break;

    case RRC_STATE_CHANGE_IND:
      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
      next_substate = rrccsp_camped_cell_state_change( cmd_ptr );
      break;

    case RRC_REDIRECT_REQ:
      WRRC_MSG2_HIGH("Cmd 0x%x (RRC_REDIRECT_REQ) recvd in CAMPED_ACCEPT_CELL sstate %d",
                                      cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);

      if(rrccsp_validate_redirection_req( cmd_ptr ))
      {
        rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_OOS);
        rrc_csp_int_data.freq_redirect_wait_time = cmd_ptr->cmd.redirect_req.wait_time;
        /* Release all channels before starting redirection search due to connection release
        */
        if(cmd_ptr->cmd.redirect_req.proc_id == RRC_PROCEDURE_RCR)
        {
          rrc_csp_send_chan_release();
        }

        /* Inter Frequency Redirection */
        if(cmd_ptr->cmd.redirect_req.choice == RRC_FREQ_REDIRECTION)
        {
          /* Attempt acquisition on the designated frequency */
          rrc_csp_int_data.redirected_freq = cmd_ptr->cmd.redirect_req.u.freq.uarfcn_DL;
          /* Start acquisition on redirected freq and start wait timer for last camped freq */
          next_substate = rrccsp_handle_rrc_redirect_req(next_substate);
        }

        /* Inter RAT Redirection */
        else
        {
          rrc_csp_int_data.curr_scan = RRC_CSP_INTER_RAT_REDIRECTION_SCAN;
          /* Store the Internal RRC command information */
          WCDMA_MEMCPY(&rrc_csp_int_data.saved_rrc_cmd,
                       sizeof(rrc_cmd_type),
                       cmd_ptr,
                       sizeof(rrc_cmd_int_type));
          /* Send change mode request to MCM */
          rrccsp_send_mode_change_req_to_mcm(RRC_MODE_STANDBY);
          next_substate = RRCCSP_WT_SUSPEND_MODE_CHANGE_CNF;
        }
      }
      break;

    case RRC_PLMN_LIST_REQ:
      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
      if(rrccsp_plmn_list_req_is_valid(&(cmd_ptr->cmd.plmn_list_req)))
      {
        next_substate = rrccsp_handle_plmn_list_req(next_substate,
                                              &(cmd_ptr->cmd.plmn_list_req));
      }
      break;


    case RRC_INITIATE_CELL_SELECTION_IND:
      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
      if(cmd_ptr->cmd.initiate_cell_sel_ind.cause == RRC_OUT_OF_SERVICE_AREA_IND)
      {
        next_substate = rrccsp_handle_out_of_service_ind( rrc_csp_substate );
      }
      else if(cmd_ptr->cmd.initiate_cell_sel_ind.cause == RRC_TRANSITION_FROM_DCH)
      {
        next_substate = rrccsp_camped_cell_state_transition_from_dch( cmd_ptr );
      }
      else if(cmd_ptr->cmd.initiate_cell_sel_ind.cause == RRC_CELL_SEL_RB0_SETUP_FAILURE)
      {
        WRRC_MSG0_HIGH("Start cell sel RB0 failure, treat as OOS");
        next_substate = rrccsp_handle_out_of_service_ind( rrc_csp_substate );
      }
      else if(cmd_ptr->cmd.initiate_cell_sel_ind.cause == RRC_TRANSITION_TO_DISCONNECTED)
      {
        /* If the procedure is CU and reason for initiating cell selection is
         * TRANSITION_TO_DISCONNECTED, process the command
         */
        if(rrccho_is_wtog_cco_in_progress() == TRUE)
        {
          WRRC_MSG0_HIGH("CCO active, wt for WCDMA resume/stop");
        }
        else
        {
 
          /* Determine if UE needs to be woken up before handling this command.
           * In Connected Mode, UE goes to deep sleep only when scan type is OOS.
           * Here, if the deep sleep timer is running then it implies that UE is
           * in deep sleep and hence needs to be woken up.
           */
          if(    (rrc_csp_int_data.curr_scan == RRC_CSP_OUT_OF_SERVICE_AREA_SCAN)
              && (!rrc_csp_int_data.oos_conn_mode_ds_tmr_expd)
              && (!nv_gcf_test_flag))
          {
            WRRC_MSG0_HIGH("OOS: UE needs to be woken up for Conn->Idle Tx");
  
            /* Stop deep sleep timer */
            rrctmr_stop_timer(RRCTMR_CONN_MODE_OOS_DS_TIMER);
            rrc_csp_int_data.oos_conn_mode_ds_tmr_expd = TRUE;
  
            /* Send wake up request to LLC which in turn sends the request to L1 */
        if(rrccsp_send_conn_mode_oos_ds_wakeup_req() == FAILURE)
        {
#ifdef FEATURE_DUAL_SIM
          /*Failure will be returned only for hard abort from NAS.
            Simply return and let hard abort request take care of further processing*/
          rrc_csp_int_data.oos_conn_mode_ds_tmr_expd = FALSE;
          WRRC_MSG0_HIGH("DSIM: Failed to acquire lock for DS Wakeup.");
          return RRCCSP_CAMPED_ACCEPT_CELL;
#else
          WRRC_MSG0_HIGH("DSIM: This should never happen !");
#endif
        }
          }

          WRRC_MSG2_HIGH("Rel chls & do cell sel, CSP sstate %d, scan %d",
                      rrc_csp_substate, rrc_csp_int_data.curr_scan);
  
          /* First Initialize the SIB variables */
          rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_OOS);
  
          rrc_csp_send_chan_release();
          next_substate = rrc_csp_start_sel_leaving_conn_mode();
       }
      }
      else
      {
        WRRC_MSG1_HIGH("Cause %d for Initiate Cell Selection not handled",
                          cmd_ptr->cmd.initiate_cell_sel_ind.cause);
      }
      break;


    case RRC_CONN_MODE_OOS_DS_TIMER_EXPIRED_IND:
      rrc_csp_int_data.oos_conn_mode_ds_tmr_expd = TRUE;

      WRRC_MSG0_HIGH("OOS: DS tmr expd. Wakeup UE. Srch all enabled RATs");

      /* Handle the DS expiry only when curr scan is OOS_Scan */
      if(rrc_csp_int_data.curr_scan == RRC_CSP_OUT_OF_SERVICE_AREA_SCAN)
      {
        /* Send wake up request to LLC which in turn sends the request to L1 */
        if(rrccsp_send_conn_mode_oos_ds_wakeup_req() == FAILURE)
        {
#ifdef FEATURE_DUAL_SIM
          /*Failure will be returned only for hard abort from NAS.
            Simply return and let hard abort request take care of further processing*/
          rrc_csp_int_data.oos_conn_mode_ds_tmr_expd = FALSE;
          WRRC_MSG0_HIGH("DSIM: Failed to acquire lock for DS Wakeup.");
          return RRCCSP_CAMPED_ACCEPT_CELL;
#else
          WRRC_MSG0_HIGH("DSIM: This should never happen !");
#endif
        }      

        
        /* Start again with Stored and Initial cell selection. Initiate Selection
         * data so that Selection Controller starts from the beginning.
         */
        if(rrc_csp_init_select_data(&rrc_csp_curr_select_data.req_plmn) == SUCCESS)
        {
          next_substate = rrc_csp_continue_cell_selection();
        }
        else
        { 
          WRRC_MSG0_ERROR("ERR: Initialization of data failed");
          next_substate = rrc_csp_continue_cell_selection();
        }
      }
      /* Ignore the DS timer expiry */
      else
      {
        WRRC_MSG1_HIGH("Ignoring DS timer expiry. curr_scan(%d) != OOS_Scan", rrc_csp_int_data.curr_scan);
      }
      break;


    case RRC_SIB_CHANGE_IND:
      MSG_MED("Cmd 0x%x recvd, CSP sstate %d",
                        cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0);

      WRRC_MSG1_HIGH("SIBs changed in RRC state:%d",rrc_state);

      next_substate = rrccsp_handle_sib_change(cmd_ptr);
      break;

    case RRC_CSP_WCDMA_RESUMED_IND:
      WRRC_MSG0_HIGH("Rxed WCDMA_RESUMED_IND from CHO");

      rrc_csp_send_chan_release();
      next_substate = rrc_csp_start_sel_leaving_conn_mode();
      break;

    case RRC_CPHY_DL_WEAK_IND:
      if(!(cmd_ptr->cmd.dl_weak_ind.serving_cell))
      {
        WRRC_MSG0_HIGH("DL_WK_IND for neigh cell. Ignored");
      }
      else
      {
        WRRC_MSG0_HIGH("DL_WK_IND for srving cell in camped st");
        if(SUCCESS == rrcsib_get_sib_7_update_status())
        {
          /* Call SIB fn to forcefully initialize its active event if any */
          rrcsib_force_sib_event_init(RRCSIB_ABORT_SIB7_UPDATE);
        }
        else if(rrcsib_is_event_update_sibs_active() == TRUE)
        {  
          /* Call SIB fn to forcefully initialize its active event if any */
          rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_DL_WK_IND);
        }
      }
      break;

    case RRC_BPLMN_SEARCH_RESUME_IND:
      next_substate = rrccsp_service_bplmn_srch_req();
      break;

    case RRC_WTOW_BPLMN_DRX_SRCH_TIMER_EXPIRED_IND:
      rrc_csp_int_data.bplmn_crit_sec_flag = TRUE;
      /* Again this is a race condition and we should check if BPLMN search is actually
       * in progress before sending go to sleep ind to L1
       */
      if(WTOW_SEARCH_RESUME == rrc_csp_bplmn_srch_in_progress())
      {
        WRRC_MSG0_HIGH("WTOW BPLMN actively in prog. Send sleep ind to L1");
        rrc_csp_int_data.bplmn_srch_tmr_expired = TRUE;
        rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_SUSPEND, FALSE, TRUE);
      } 
      /* This is NOT an error. It is only a race condition that we might encounter.
       * ERR added to only check it
       */
      else
      {
        WRRC_MSG0_ERROR("WTOW ERR: race cond hit. Ignoring drx tmr expiry");
      }
      rrc_csp_int_data.bplmn_crit_sec_flag = FALSE;
      break;

    case RRC_BPLMN_GUARD_SRCH_TIMER_EXPIRED_IND:
      rrc_csp_int_data.bplmn_crit_sec_flag = TRUE;
      /* Again this is a race condition and we should check if BPLMN search is actually
       * in progress before sending go to sleep ind to L1
       */                                             
      if(WTOW_SEARCH_RESUME == rrc_csp_bplmn_srch_in_progress())
      {
        if(rrctmr_get_remaining_time(RRCTMR_BPLMN_GUARD_SRCH_TIMER) == 0)
        {
          WRRC_MSG0_HIGH("WTOW BPLMN actively in prog. Send sleep ind to L1");
          rrc_csp_int_data.bplmn_guard_srch_tmr_expired = TRUE;
          
          /* WTOG BPLMN search is in progress */
          if(rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_active)
          {
            if(!rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_aborted)
            {
              rrccsp_send_irat_bplmn_abort_req();
            }

            rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_ABORT, TRUE, FALSE);
          }
          /* WTOW BPLMN search is in progress */
          else
          {
            rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_ABORT, TRUE, TRUE);
          }      
        }
        else
        {
          WRRC_MSG0_ERROR("WTOW ERR: race cond hit. Ignoring guard tmr expiry");
        }
      } 
      else if(WTOW_SEARCH_SUSPEND == rrc_csp_bplmn_srch_in_progress())
      {
        if(rrctmr_get_remaining_time(RRCTMR_BPLMN_GUARD_SRCH_TIMER) == 0)
        {
          WRRC_MSG0_HIGH("WTOW BPLMN passively in prog. Do NOT send sleep ind to L1");
          rrc_csp_int_data.bplmn_guard_srch_tmr_expired = TRUE;
          rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_ABORT, TRUE, FALSE);
        }
        else
        {
          WRRC_MSG0_ERROR("WTOW ERR: race cond hit. Ignoring guard tmr expiry");
        }
      }
      /* This is NOT an error. It is only a race condition that we might encounter.
       * ERR added to only check it
       */
      else
      {
        WRRC_MSG0_ERROR("WTOW ERR: race cond hit. Ignoring guard tmr expiry");
      }
      rrc_csp_int_data.bplmn_crit_sec_flag = FALSE;
      break;

    case RRC_BPLMN_SEARCH_ABORT_REQ:
       rrccsp_cleanup_bplmn_state();
       break;

    case RRC_BPLMN_SUSPEND_REQ:
      rrccsp_handle_passive_bplmn_suspend_req( cmd_ptr );     
      break;

#ifdef FEATURE_OOSC_USER_ACTION
    case RRC_EXIT_FROM_PWR_SAVE:
      if((rrc_csp_int_data.curr_scan == RRC_CSP_OUT_OF_SERVICE_AREA_SCAN)
         && (!rrc_csp_int_data.oos_conn_mode_ds_tmr_expd))
      {
        /* Stop deep sleep timer */
        rrctmr_stop_timer(RRCTMR_CONN_MODE_OOS_DS_TIMER);

        /* Send wake up request to LLC which in turn sends the request to L1 */
        if(rrccsp_send_conn_mode_oos_ds_wakeup_req() == FAILURE)
        {
#ifdef FEATURE_DUAL_SIM
          /*Failure will be returned only for hard abort from NAS.
            Simply return and let hard abort request take care of further processing*/
          rrc_csp_int_data.oos_conn_mode_ds_tmr_expd = FALSE;
          WRRC_MSG0_HIGH("DSIM: Failed to acquire lock for DS Wakeup.");
          return RRCCSP_CAMPED_ACCEPT_CELL;
#else
          WRRC_MSG0_HIGH("DSIM: This should never happen !");
#endif
        }

        
        /* Start again with Stored and Initial cell selection. Initiate Selection
         * data so that Selection Controller starts from the beginning.
         */
        if(rrc_csp_init_select_data(&rrc_csp_curr_select_data.req_plmn) == SUCCESS)
        {
          next_substate = rrc_csp_continue_cell_selection();
        }
        else
        { 
          WRRC_MSG0_ERROR("ERR: Initialization of data failed");
          next_substate = rrc_csp_continue_cell_selection();
        }
      }
      else
      {
        WRRC_MSG0_HIGH("Ignoring key press event");
      }
    break;
#endif
/*lint -e408*/
#ifdef FEATURE_GAN_3G_ROVE_OUT_ONLY
    #error code not present
#endif
/*lint +e408*/
    default:
      WRRC_MSG2_HIGH( "Cmd 0x%x not processed in CSP sstate %d",
                            cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);
      break;
  }
  return( next_substate );
} /* rrccsp_camped_accept_cell_hdlr */
/*===========================================================================

FUNCTION RRCCSP_PROCESS_DEACTIVATE_REQ

DESCRIPTION

  This function processes the DEACT_REQ received from MM, sends
  LOWER_LAYER_DEACT_REQ command to LLC to deactivate the lower layers

DEPENDENCIES

  None.

RETURN VALUE

  None.

SIDE EFFECTS

  None.

===========================================================================*/
static void rrccsp_process_deactivate_req(rrc_cmd_type  *cmd_ptr)
{

  rrc_cmd_type   *csp_out_cmd_ptr;

  rrccsp_cleanup_bplmn_state();

  if(SYS_STOP_MODE_REASON_LPM_POWER_OFF == cmd_ptr->cmd.deact_req.deact_reason)
  {
    WRRC_MSG0_HIGH("Update NV with ACQ DB and send STOP_MODE_REQ to GSM with cause power off");
    rrc_csp_write_nv_acq_info();

    if(rrc_check_gsm_bands_supported())
    {
      rrccsp_send_rr_rrc_stop_gsm_req(POWER_OFF);
      rrc_csp_substate = RRCCSP_WT_LOWER_LAYER_DEACT_CNF;
    }
    else
    {
      rrccsp_process_lower_layer_deact_cnf();
      rrc_csp_substate = RRCCSP_NO_CELL_SELECTED;
    }
    return;
  }

  if((csp_out_cmd_ptr = rrc_get_int_cmd_buf()) != NULL)
  {
    /* Fill the RRC_LOWER_LAYER_DEACT_REQ to be sent to LLC asking it to
       put the lower layers to Idle Disconnected mode */

    csp_out_cmd_ptr->cmd_hdr.cmd_id = RRC_LOWER_LAYER_DEACT_REQ;
    csp_out_cmd_ptr->cmd.lower_layer_deact_req.deact_reason =
    cmd_ptr->cmd.deact_req.deact_reason;
    rrc_csp_substate = RRCCSP_WT_LOWER_LAYER_DEACT_CNF;
  }
  /* Send the Internal RRC Command - LLC should directly handle it */
  rrc_put_int_cmd( csp_out_cmd_ptr );

}

#ifdef FEATURE_INTERRAT_CELL_RESELECTION_GTOW
/*===========================================================================

FUNCTION          RRCCSP_SEND_INTERRAT_RESELECTION_REJECT

DESCRIPTION       This function is responsible for sending
                  RR_INTERRAT_RESELECTION_REJ to RR.

DEPENDENCIES
                  None.

RETURN VALUE
                  None.

SIDE EFFECTS      None.
===========================================================================*/
void rrccsp_send_interrat_reselection_reject(void)
{
  rrc_interrat_reselect_rej_type rrc_interrat_reselect_rej;

  rrc_interrat_reselect_rej.reject_reason    = rrc_csp_int_data.interrat_reselect_failure_reason;

  switch(rrc_csp_int_data.interrat_reselect_failure_reason)
  {
    case RRC_WCDMA_CELL_BARRED:
    case RRC_WCDMA_UARFCN_BARRED:
      rrc_interrat_reselect_rej.time_to_reselect =
        rrc_csp_int_data.wcdma_cell_time_to_reselect;
      break;

    case RRC_WCDMA_FORBIDDEN_LA:
      /* For now set the time to reselect to 5 min's */
      rrc_interrat_reselect_rej.time_to_reselect = 300;
      rrc_interrat_reselect_rej.PLMN = mmumts_convert_rrc_plmn_id_to_nas_plmn_id(
                                              rrc_csp_int_data.forbidden_lai.plmn);
      rrc_interrat_reselect_rej.forbidden_lac[0] = rrc_csp_int_data.forbidden_lai.lac[0];
      rrc_interrat_reselect_rej.forbidden_lac[1] = rrc_csp_int_data.forbidden_lai.lac[1];
      break;

    case RRC_WCDMA_PLMN_MISMATCH:
      rrc_interrat_reselect_rej.time_to_reselect = 300;
      WRRC_MSG2_HIGH("PLMN being reported to RR as Non eplmn is MCC %d MNC %d ", 
                            RRC_CSP_GET_INT_MCC(rrc_csp_int_data.curr_acq_entry.plmn_id),
                            RRC_CSP_GET_INT_MNC(rrc_csp_int_data.curr_acq_entry.plmn_id));
      rrc_interrat_reselect_rej.PLMN = mmumts_convert_rrc_plmn_id_to_nas_plmn_id(
                                              rrc_csp_int_data.curr_acq_entry.plmn_id);
      break;

    case RRC_WCDMA_CELL_QUALITY_FAILURE:
      rrc_interrat_reselect_rej.squalmin  = rrc_csp_int_data.wcdma_cell_squalmin;
      rrc_interrat_reselect_rej.srxlevmin = rrc_csp_int_data.wcdma_cell_srxlevmin;
      rrc_interrat_reselect_rej.time_to_reselect =
        rrc_csp_int_data.wcdma_cell_time_to_reselect;
      break;

    default:
      rrc_interrat_reselect_rej.time_to_reselect = rrc_csp_int_data.wcdma_cell_time_to_reselect;
      break;

  }

  WRRC_MSG1_HIGH("wcdma_time_to_reselect is set to %d secs",
             rrc_interrat_reselect_rej.time_to_reselect);

  /* Send the RRC_INTERRAT_RESELECT_REJ message to RR */
  rr_send_rrc_message_to_rr_internal((void *)(&(rrc_interrat_reselect_rej)), RRC_INTERRAT_RESELECTION_REJ,
          sizeof(rrc_interrat_reselect_rej_type));

  WRRC_MSG0_HIGH("RRC_INTERRAT_RESELECT_REJ sent to GSM RR");

#ifdef FEATURE_DUAL_SIM
  rrc_release_lock();
#endif
} /* rrccsp_send_interrat_reselection_reject */

#endif

/*===========================================================================

FUNCTION          RRCCSP_SEND_INTERRAT_RESELECTION_REQ

DESCRIPTION       This function is responsible for sending
                  RR_INTERRAT_RESELECTION_REQ to RR.

DEPENDENCIES
                  None.

RETURN VALUE
                  None.

SIDE EFFECTS      None.
===========================================================================*/
static void rrccsp_send_interrat_reselection_req(rrc_cmd_type *cmd_ptr)
{
  rr_interrat_reselect_req_type *rr_interrat_reselect_req = rrc_malloc(sizeof(rr_interrat_reselect_req_type));
  rrclog_wcdma_to_gsm_reselection_start_event_type wtog_resel_start_event;
  rrclog_wcdma_to_gsm_redir_end_event_type wtog_redir_event;

#ifdef FEATURE_WCDMA_DEDICATED_PRI_INFO
/*copying the dedicated priority info from global structure(rrc_dedicated_priority_info) to rr_interrat_reselect_req*/
  memset(&rr_interrat_reselect_req->dedicated_priority_info,0,sizeof(lte_irat_dedicated_priority_info_s));
  
  rrcmeas_populate_dedicated_priority_info_for_irat_req(&rr_interrat_reselect_req->dedicated_priority_info);
#endif
  rr_interrat_reselect_req->network_select_mode = rrc_csp_int_data.network_select_mode;
  rr_interrat_reselect_req->BCCH_ARFCN          =
    cmd_ptr->cmd.cell_rsel_ind.u.gsm_info.cell_info.bcch_arfcn;
  rr_interrat_reselect_req->BSIC_NCC            =
    cmd_ptr->cmd.cell_rsel_ind.u.gsm_info.cell_info.bsic.ncc;
  rr_interrat_reselect_req->BSIC_BCC            =
    cmd_ptr->cmd.cell_rsel_ind.u.gsm_info.cell_info.bsic.bcc;
  rr_interrat_reselect_req->RXLEV_average       =
    (byte)cmd_ptr->cmd.cell_rsel_ind.u.gsm_info.rxlev_meas;
  rr_interrat_reselect_req->requested_PLMN      =
    mmumts_convert_rrc_plmn_id_to_nas_plmn_id(rrc_csp_int_data.curr_req_plmn.plmn_id);

#ifdef FEATURE_RAT_PRIORITY_LIST
  rr_interrat_reselect_req->rat_pri_list_info = rrc_csp_int_data.rat_pri_list_info;
#endif

#ifdef FEATURE_WCDMA_TO_LTE
  rrc_csp_int_data.interrat_type = RRC_CSP_INTERRAT_GSM;
#endif
  /* Send the RR_INTERRAT_RESELECT_REQ message to RR */
  rr_send_rrc_message_to_rr_internal((void *)((rr_interrat_reselect_req)), RR_INTERRAT_RESELECTION_REQ,
          sizeof(rr_interrat_reselect_req_type));

    /* Send out an event */
  wtog_resel_start_event.arfcn     = CONVERT_ARFCN_TO_NUM(cmd_ptr->cmd.cell_rsel_ind.u.gsm_info.cell_info.bcch_arfcn);
  wtog_resel_start_event.ncc       = rr_interrat_reselect_req->BSIC_NCC;
  wtog_resel_start_event.bcc       = rr_interrat_reselect_req->BSIC_BCC;
  event_report_payload(EVENT_WCDMA_TO_GSM_RESELECTION_START, sizeof(wtog_resel_start_event),
                     (void *)&wtog_resel_start_event);
  rrc_csp_int_data.curr_scan = RRC_CSP_WCDMA_TO_GSM_CELL_RESELECTION_SCAN;
  rrc_free(rr_interrat_reselect_req);

  WRRC_MSG0_HIGH("RR_INTERRAT_RESELECT_REQ sent to GSM RR");

} /* rrccsp_send_interrat_reselection_req */

/*===========================================================================

FUNCTION          RRCCSP_SEND_INTERRAT_REDIRECTION_ABORT_REQ

DESCRIPTION       This function is responsible for sending
                  RR_INTERRAT_REDIRECTION_ABORT_REQ to RR.

DEPENDENCIES
                  None.

RETURN VALUE
                  None.

SIDE EFFECTS      None.
===========================================================================*/
static void rrccsp_send_interrat_redirection_abort_req( void )
{
#ifdef FEATURE_WCDMA_TO_LTE
  if(rrc_csp_int_data.interrat_type == RRC_CSP_INTERRAT_LTE)
  {
    lte_rrc_wcdma_abort_redir_req_s abort_redir_req;
    rrclog_wcdma_to_lte_redir_end_event_type wtol_redir_event;
    rrc_send_lte_cmd(&abort_redir_req.msg_hdr,LTE_RRC_WCDMA_ABORT_REDIR_REQ,sizeof(lte_rrc_wcdma_abort_redir_req_s));
    WRRC_MSG0_HIGH("WTOL: LTE_RRC_WCDMA_ABORT_REDIR_REQ sent to LTE RRC");
    wtol_redir_event.status = WTOL_ABORTED;
    event_report_payload(EVENT_WCDMA_TO_LTE_REDIRECTION_END, sizeof(wtol_redir_event),
                   (void *)&wtol_redir_event);
  }
  else
#endif
  {
    rr_interrat_redirect_abort_req_type rr_interrat_redirect_abort_req;
    rrclog_wcdma_to_gsm_redir_end_event_type wtog_redir_event;
    /* Send the RR_INTERRAT_REDIRECT_ABORT_REQ message to RR */
    rr_send_rrc_message_to_rr_internal((void *)(&(rr_interrat_redirect_abort_req)),
                             RR_INTERRAT_REDIRECT_ABORT_REQ,
                             sizeof(rr_interrat_redirect_abort_req_type));
    wtog_redir_event.status = WTOG_ABORTED;
    if((rrc_csp_int_data.curr_scan != RRC_CSP_CELL_SELECTION_SCAN)
      && (rrc_csp_int_data.curr_scan != RRC_CSP_OUT_OF_SERVICE_AREA_SCAN))
    {
      event_report_payload(EVENT_WCDMA_TO_GSM_REDIRECTION_END, sizeof(wtog_redir_event),
                     (void *)&wtog_redir_event);
    }

    WRRC_MSG0_HIGH("RR_INTERRAT_REDIRECT_ABORT_REQ sent to GSM RR");
  }

} /* rrccsp_send_interrat_redirection_abort_req */

/*===========================================================================

FUNCTION          RRCCSP_SEND_INTERRAT_REDIRECTION_REQ

DESCRIPTION       This function is responsible for sending
                  RR_INTERRAT_REDIRECTION_REQ to RR.

DEPENDENCIES
                  None.

RETURN VALUE
                  None.

SIDE EFFECTS      None.
===========================================================================*/
static void rrccsp_send_interrat_redirection_req(void)
{
  /* Declare Variables */
  uint32 i;
  rrclog_wcdma_to_gsm_redir_start_event_type wtog_redirect_event;
  rr_interrat_redirect_req_type *rr_interrat_redirect_req = rrc_malloc(sizeof(rr_interrat_redirect_req_type));
  sys_band_T gsm_band;
  rrc_rr_frequence_band_e_type freq_band;
  rrc_SysInfoType11   *sib11_ptr;
  rrc_NewInterRATCellList *inter_rat_cell_list_ptr = NULL;
  rrc_NewInterRATCellList_B* inter_rat_non_hcs_cell_list_ptr = NULL;
  /* Initialize Variables */
  rr_interrat_redirect_req->PLMN                  =
                           mmumts_convert_rrc_plmn_id_to_nas_plmn_id(rrc_csp_int_data.curr_req_plmn.plmn_id);
  rr_interrat_redirect_req->network_select_mode   = rrc_csp_int_data.network_select_mode;
  rr_interrat_redirect_req->gsm_ncell_list.size   = 0;

#ifdef FEATURE_RAT_PRIORITY_LIST
  rr_interrat_redirect_req->rat_pri_list_info = rrc_csp_int_data.rat_pri_list_info;
#endif

  rr_interrat_redirect_req->is_emergency_call = FALSE;

#ifdef FEATURE_WCDMA_DEDICATED_PRI_INFO
/*copying the dedicated priority info from global structure (rrc_dedicated_priority_info) to rr_interrat_redirect_req*/
  memset(&rr_interrat_redirect_req->dedicated_priority_info,0,sizeof(lte_irat_dedicated_priority_info_s));
	
  rrcmeas_populate_dedicated_priority_info_for_irat_req(&rr_interrat_redirect_req->dedicated_priority_info);

#endif
  /* For inter-RAT redirection via RRC Connection Reject, if wait timer is < 5s
   * then set it to 5s
   */
  if(rrc_csp_int_data.curr_scan == RRC_CSP_INTER_RAT_REDIRECTION_SCAN) 
  {
    if(rrc_csp_int_data.saved_rrc_cmd.cmd.redirect_req.wait_time < 10)
    {
      WRRC_MSG1_HIGH("wait_time = %d. Setting it to 10s", 
                          rrc_csp_int_data.saved_rrc_cmd.cmd.redirect_req.wait_time);
      rrc_csp_int_data.saved_rrc_cmd.cmd.redirect_req.wait_time = 10;
    }
    rr_interrat_redirect_req->wait_timer = rrc_csp_int_data.saved_rrc_cmd.cmd.redirect_req.wait_time;

    if(rrc_csp_int_data.saved_rrc_cmd.cmd.redirect_req.proc_id == RRC_PROCEDURE_RCR)
    {
      rr_interrat_redirect_req->cell_srch_reason = RRC_RR_REDIRECTION_AFTER_CONN_RELEASE;

      /* Also update CCM with cell loss for redirection via conn release msg. This is required for the scenario
         where buffered EST_REQ has to be handled after resume failure. This chnage will make sure that RCE waits for
         UE to camp while CSP preforms ACQ-DB search after resume failure. */
      rrc_ccm_update_with_cell_loss();
    }
    else
    {
      rr_interrat_redirect_req->cell_srch_reason  = RRC_RR_REDIRECTION_SEARCH;
    }
  }

  if((rrc_csp_int_data.curr_scan == RRC_CSP_INTER_RAT_REDIRECTION_SCAN) &&
     (rrc_csp_int_data.saved_rrc_cmd.cmd.redirect_req.u.GSM_cell_info_list.size != 0))
  {
    for(i = 0;i < rrc_csp_int_data.saved_rrc_cmd.cmd.redirect_req.u.GSM_cell_info_list.size;i++)
    {
           /* Get bcch_ARFCN */
           rr_interrat_redirect_req->gsm_ncell_list.arfcns[i].num
              = rrc_csp_int_data.saved_rrc_cmd.cmd.redirect_req.u.GSM_cell_info_list.arfcns[i].num;

           rr_interrat_redirect_req->gsm_ncell_list.arfcns[i].band
              = rrc_csp_int_data.saved_rrc_cmd.cmd.redirect_req.u.GSM_cell_info_list.arfcns[i].band;
 
           rr_interrat_redirect_req->gsm_ncell_list.BSIC[i].BSIC_NCC 
              = rrc_csp_int_data.saved_rrc_cmd.cmd.redirect_req.u.GSM_cell_info_list.BSIC[i].BSIC_NCC;

           rr_interrat_redirect_req->gsm_ncell_list.BSIC[i].BSIC_BCC
              = rrc_csp_int_data.saved_rrc_cmd.cmd.redirect_req.u.GSM_cell_info_list.BSIC[i].BSIC_BCC;
    }
    rr_interrat_redirect_req->gsm_ncell_list.size = rrc_csp_int_data.saved_rrc_cmd.cmd.redirect_req.u.GSM_cell_info_list.size;
  }
  else 
  if(rrc_get_state() == RRC_STATE_CONNECTING)
  {
    sib11_ptr = (rrc_SysInfoType11*)rrc_sibdb_return_sib_for_srv_cell(rrc_SIB11);
  
    if ( sib11_ptr == NULL )
    {
      WRRC_MSG0_ERROR("SIB 11 from SIB DB is NULL");
    }
    else
    {
      /* Check if HCS is in use. */
      if (RRC_CHECK_COMMON_MSG_TYPE(sib11_ptr->measurementControlSysInfo.use_of_HCS,
                                    rrc_MeasurementControlSysInfo_use_of_HCS_hcs_used))
      {
        if (!((sib11_ptr->measurementControlSysInfo.use_of_HCS.u.
			hcs_used->m.interRATMeasurementSysInfoPresent) &&
          (sib11_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_used->interRATMeasurementSysInfo.m.
          interRATCellInfoListPresent) &&(sib11_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_used->
          interRATMeasurementSysInfo.interRATCellInfoList.newInterRATCellList.n > 0)))
        {
          WRRC_MSG0_HIGH("Inter-RAT list absent in SIB11");
        }
        else
        {
          uint32 idx =0;
          /* Store ptr given by UTRAN */
          inter_rat_cell_list_ptr = &sib11_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_used->
            interRATMeasurementSysInfo.interRATCellInfoList.newInterRATCellList;
  
          while (inter_rat_cell_list_ptr->n > idx)
          {
            /* Let first check the type of the cell to find if we
             * really need to give this cell to L1 */
            if(inter_rat_cell_list_ptr->elem[idx].technologySpecificInfo.t ==
                                          T_rrc_NewInterRATCell_technologySpecificInfo_gsm)
            {
              switch(inter_rat_cell_list_ptr->elem[idx].technologySpecificInfo.u.gsm->frequency_band)
              {
                case rrc_Frequency_Band_dcs1800BandUsed:
                  freq_band = RRC_RR_DCS_1800;
                  break;
  
                case rrc_Frequency_Band_pcs1900BandUsed:
                  freq_band = RRC_RR_PCS_1900;
                  break;
  
                default:
                  WRRC_MSG1_ERROR("Unsupported Band %d rcvd",inter_rat_cell_list_ptr->elem[idx].technologySpecificInfo.u.gsm->frequency_band);
                  freq_band = RRC_RR_MAX_BANDS;
                  break;
              }
  
              if((gsm_band
                   = rr_rrc_get_arfcn_band_internal((uint16)inter_rat_cell_list_ptr->elem[idx].technologySpecificInfo.u.gsm->bcch_ARFCN, freq_band))
                  != INVALID_BAND)
              {
                WRRC_MSG2_HIGH("Adding ARFCN %d and band %d to the list to be sent to RR",
                         inter_rat_cell_list_ptr->elem[idx].technologySpecificInfo.u.gsm->bcch_ARFCN, freq_band);
  
                /* Get bcch_ARFCN */
                rr_interrat_redirect_req->gsm_ncell_list.arfcns[rr_interrat_redirect_req->gsm_ncell_list.size].num
                   = (uint16) inter_rat_cell_list_ptr->elem[idx].technologySpecificInfo.u.gsm->bcch_ARFCN;
  
                rr_interrat_redirect_req->gsm_ncell_list.arfcns[rr_interrat_redirect_req->gsm_ncell_list.size++].band
                   = gsm_band;
              }
              else
              {
                WRRC_MSG2_HIGH("Band %d for ARFCN %d is invalid. Not adding to list",
                          (rrc_rr_frequence_band_e_type)inter_rat_cell_list_ptr->elem[idx].technologySpecificInfo.u.gsm->frequency_band,
                          (uint16) inter_rat_cell_list_ptr->elem[idx].technologySpecificInfo.u.gsm->bcch_ARFCN);
              }
            }
            idx++;
          }
        }
      }
      else
      {
        uint32 idx =0;
        if (!((sib11_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->m. 
          interRATMeasurementSysInfoPresent) &&
          (sib11_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->interRATMeasurementSysInfo.m.
          interRATCellInfoListPresent) &&
          (sib11_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->
          interRATMeasurementSysInfo.interRATCellInfoList.newInterRATCellList.n > 0)))
        {
          WRRC_MSG0_HIGH("Inter-RAT list absent in SIB11");
        }
  
        /* Store ptr given by UTRAN */
        inter_rat_non_hcs_cell_list_ptr = &sib11_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->
          interRATMeasurementSysInfo.interRATCellInfoList.newInterRATCellList;
  
        if (inter_rat_non_hcs_cell_list_ptr == NULL)
        {
          WRRC_MSG0_HIGH("inter_rat_non_hcs_cell_list_ptr is NULL");
        }
        else
        {
          while (inter_rat_non_hcs_cell_list_ptr->n > idx)
          {
           /* Let first check the type of the cell to find if we
            * really need to give this cell to L1 */
            if (inter_rat_non_hcs_cell_list_ptr->elem[idx].technologySpecificInfo.t ==
                                                  T_rrc_NewInterRATCell_B_technologySpecificInfo_gsm)
            {
              switch(inter_rat_non_hcs_cell_list_ptr->elem[idx].technologySpecificInfo.u.gsm->frequency_band)
              {
                case rrc_Frequency_Band_dcs1800BandUsed:
                  freq_band = RRC_RR_DCS_1800;
                  break;
  
                case rrc_Frequency_Band_pcs1900BandUsed:
                  freq_band = RRC_RR_PCS_1900;
                  break;
  
                default:
                  WRRC_MSG1_ERROR("Unsupported Band %d rcvd",inter_rat_non_hcs_cell_list_ptr->elem[idx].technologySpecificInfo.u.gsm->frequency_band);
                  freq_band = RRC_RR_MAX_BANDS;
                  break;
              }
  
              if((gsm_band = rr_rrc_get_arfcn_band_internal(
                                  (uint16)inter_rat_non_hcs_cell_list_ptr->elem[idx].technologySpecificInfo.u.gsm->bcch_ARFCN, freq_band))
                  != INVALID_BAND)
              {
                WRRC_MSG2_HIGH("Adding ARFCN %d and band %d to the list to be sent to RR",
                         inter_rat_non_hcs_cell_list_ptr->elem[idx].technologySpecificInfo.u.gsm->bcch_ARFCN,
                         gsm_band);
  
                /* Get bcch_ARFCN */
                rr_interrat_redirect_req->gsm_ncell_list.arfcns[rr_interrat_redirect_req->gsm_ncell_list.size].num
                   = (uint16) inter_rat_non_hcs_cell_list_ptr->elem[idx].technologySpecificInfo.u.gsm->bcch_ARFCN;
  
                rr_interrat_redirect_req->gsm_ncell_list.arfcns[rr_interrat_redirect_req->gsm_ncell_list.size++].band
                   = gsm_band;
              }
              else
              {
                WRRC_MSG2_HIGH("Frequency Band %d for ARFCN %d is invalid. Not adding to list",
                          (rrc_rr_frequence_band_e_type)inter_rat_non_hcs_cell_list_ptr->elem[idx].technologySpecificInfo.u.gsm->frequency_band,
                          (uint16) inter_rat_non_hcs_cell_list_ptr->elem[idx].technologySpecificInfo.u.gsm->bcch_ARFCN);
              }
            }
            idx++;
          }
        }
      }
    }
  }

  /* OOS Handling in RRC Connected Mode */
  if(rrc_csp_int_data.curr_scan == RRC_CSP_OUT_OF_SERVICE_AREA_SCAN)
  {
    /* Wait timer value is initialized here as a guard value just to ensure that
     * GSM returns control to WCDMA if a "single" cell selection power scan takes
     * more time than what is acceptable 
     */
    rr_interrat_redirect_req->wait_timer = 15;

    rr_interrat_redirect_req->cell_srch_reason = RRC_RR_OUT_OF_SERVICE_SEARCH;

    /* If 30s have expired (oos_spec_srch_tmr_exp) and at least one SPEC_PLMN search 
     * has been done on GSM (oos_gsm_srch_done) and at least one PLMN was found
     * in the previous SPEC_PLMN request to GSM then search for ANY_PLMN on GSM
     */
    if(rrc_csp_int_data.oos_splmn_srch_tmr_expd 
        && rrc_csp_int_data.oos_gsm_srch_done
          && (rrc_csp_int_data.oos_gsm_num_avail_plmns > 0)
          && (rrc_csp_int_data.network_select_mode != SYS_NETWORK_SELECTION_MODE_MANUAL))
    {
      rr_interrat_redirect_req->is_emergency_call = TRUE;
    }

    MSG_HIGH("OOS: srch_tmr_expd = %d, srch_any_plmn = %d, gsm_num_plmns = %d", 
                rrc_csp_int_data.oos_splmn_srch_tmr_expd, rr_interrat_redirect_req->is_emergency_call, 
                rrc_csp_int_data.oos_gsm_num_avail_plmns);
  }
  else if(    (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_CELL_FACH_SCAN)
           || (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_CELL_PCH_SCAN)
           || (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_URA_PCH_SCAN)
           || (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_FACH_TO_CELL_FACH_SCAN)
           || (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_FACH_TO_CELL_PCH_SCAN)
           || (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_FACH_TO_URA_PCH_SCAN)
         )
  {
    /* Wait timer value is initialized here as a guard value just to ensure that
     * GSM returns control to WCDMA if a "single" cell selection power scan takes
     * more time than what is acceptable 
     */
    rr_interrat_redirect_req->wait_timer = 15;
    rr_interrat_redirect_req->cell_srch_reason = RRC_RR_OUT_OF_SERVICE_SEARCH;
  }
  /* Redirection in RRC Connecting Mode */
  else 

  if(rrc_csp_int_data.curr_scan == RRC_CSP_INTER_RAT_REDIRECTION_SCAN)
  {
    if(rrc_establishment_cause == RRC_EST_EMERGENCY_CALL)
    {
      WRRC_MSG0_HIGH("UE attempting an emergency call");
      rr_interrat_redirect_req->is_emergency_call   = TRUE;

      WRRC_MSG1_HIGH("NOT Setting network sel mode to Limited. Nw_Sel_Mode = %d",
                                  rr_interrat_redirect_req->network_select_mode);
    }
    else
    {
      WRRC_MSG0_HIGH("UE not attempting an emergency call");
    }
  }
#ifdef FEATURE_PCS_850_FREQ_SCAN_OPTIMIZATION
  else if(rrc_csp_int_data.curr_scan == RRC_CSP_CELL_SELECTION_SCAN)
  {
    rr_interrat_redirect_req->wait_timer       = 30;
    rr_interrat_redirect_req->cell_srch_reason = RRC_RR_SERVICE_SEARCH;

    rr_interrat_redirect_req->is_ehplmn_to_be_camped = rrc_csp_int_data.can_ehplmn_be_camped;

    if(rrc_csp_int_data.curr_req_plmn.plmn_type == RRC_GSM_MAP_ANY_PLMN_REQ)
    {
      rr_interrat_redirect_req->is_emergency_call = TRUE;
    }

    MSG_HIGH("Sending redirect req to GSM with wt_time %d, scantype %d, any_plmn = %d",
                                                    rr_interrat_redirect_req->wait_timer,
                                                    rrc_csp_int_data.curr_scan,
                                                    rr_interrat_redirect_req->is_emergency_call);
  }
#endif
  /* Incorrect current scan. Print error message */
  else
  {
    WRRC_MSG1_ERROR("ERR: Inter-RAT redirection attempt when CSP curr_scan = %d", rrc_csp_int_data.curr_scan);
  }
  
#ifdef FEATURE_WCDMA_TO_LTE
  rrc_csp_int_data.interrat_type = RRC_CSP_INTERRAT_GSM;
#endif
  /* Send the RR_INTERRAT_REDIRECT_REQ message to RR */
  rr_send_rrc_message_to_rr_internal((void *)((rr_interrat_redirect_req)), RR_INTERRAT_REDIRECT_REQ,
          sizeof(rr_interrat_redirect_req_type));
  wtog_redirect_event.redir_cause = WTOG_REDIR_NONE;
  if(rr_interrat_redirect_req->cell_srch_reason == RRC_RR_REDIRECTION_AFTER_CONN_RELEASE)
  {
     wtog_redirect_event.redir_cause = WTOG_REDIR_CONN_RELEASE;
  }
  else if(rr_interrat_redirect_req->cell_srch_reason == RRC_RR_REDIRECTION_SEARCH)
  {
     wtog_redirect_event.redir_cause = WTOG_REDIR_CONN_REJECT;
  }
  wtog_redirect_event.wait_timer_in_secs = rr_interrat_redirect_req->wait_timer;
  /*Copy the three byte MCC*/
  WCDMA_MEMCPY(wtog_redirect_event.MCC,sizeof(uint8) * 3,
               rrc_csp_int_data.curr_req_plmn.plmn_id.mcc,sizeof(uint8) * 3);
  /*Copy the three byte MNC*/
  WCDMA_MEMCPY(wtog_redirect_event.MNC,sizeof(uint8) * 3,
               rrc_csp_int_data.curr_req_plmn.plmn_id.mnc,sizeof(uint8) * 3);
  if(rrc_csp_int_data.curr_req_plmn.plmn_id.num_mnc_digits == 2)
  {
    wtog_redirect_event.MNC[2] = 0xF;
  }
  if((rrc_csp_int_data.curr_scan != RRC_CSP_CELL_SELECTION_SCAN)
      && (rrc_csp_int_data.curr_scan != RRC_CSP_OUT_OF_SERVICE_AREA_SCAN))
  {
    event_report_payload(EVENT_WCDMA_TO_GSM_REDIRECTION_START, sizeof(wtog_redirect_event),
                   (void *)&wtog_redirect_event);
  }
  rrc_free(rr_interrat_redirect_req);

  WRRC_MSG0_HIGH("RR_INTERRAT_REDIRECT_REQ sent to GSM RR");

} /* rrccsp_send_interrat_redirection_req */

/*===========================================================================

FUNCTION          rrccsp_send_gsm_interrat_reselection_abort_req

DESCRIPTION       This function is responsible for sending
                  RR_INTERRAT_RESELECTION_ABORT_REQ to RR.

DEPENDENCIES
                  None.

RETURN VALUE
                  None.

SIDE EFFECTS      None.
===========================================================================*/
static void rrccsp_send_gsm_interrat_reselection_abort_req( void )
{
  rr_interrat_reselection_abort_req_type rr_interrat_resel_abort_req;

  /* Send the RR_INTERRAT_RESELECTION_ABORT_REQ message to RR */
  rr_send_rrc_message_to_rr_internal((void *)(&(rr_interrat_resel_abort_req)), 
                             RR_INTERRAT_RESELECTION_ABORT_REQ,
                             sizeof(rr_interrat_reselection_abort_req_type));

  WRRC_MSG0_HIGH("RR_INTERRAT_RESELECTION_ABORT_REQ sent to GSM RR");

} /* rrccsp_send_gsm_interrat_reselection_abort_req */


/*===========================================================================

FUNCTION          RRCCSP_SEND_INTERRAT_RESELECTION_ABORT_CNF

DESCRIPTION       This function is responsible for sending
                  RRC_INTERRAT_RESELECTION_ABORT_CNF to RR.

DEPENDENCIES
                  None.

RETURN VALUE
                  None.

SIDE EFFECTS      None.
===========================================================================*/
void rrccsp_send_interrat_reselection_abort_cnf( void )
{
  rrc_interrat_reselection_abort_cnf_type rrc_interrat_resel_abort_cnf;

  /* Send the RRC_INTERRAT_RESELECTION_ABORT_CNF message to RR */
  rr_send_rrc_message_to_rr_internal((void *)(&(rrc_interrat_resel_abort_cnf)), 
                             RRC_INTERRAT_RESELECTION_ABORT_CNF,
                             sizeof(rrc_interrat_reselection_abort_cnf_type));

  WRRC_MSG0_HIGH("RRC_INTERRAT_RESELECTION_ABORT_CNF sent to GSM RR");

#ifdef FEATURE_DUAL_SIM
  rrc_release_lock();
#endif
} /* rrccsp_send_interrat_reselection_abort_cnf */


/*===========================================================================

FUNCTION          RRCCSP_SEND_INTERRAT_RESELECTION_ABORT_REQ

DESCRIPTION       This function is responsible for sending
                  RR_INTERRAT_RESELECTION_ABORT_REQ to RR.

DEPENDENCIES
                  None.

RETURN VALUE
                  None.

SIDE EFFECTS      None.
===========================================================================*/
static void rrccsp_send_gsm_interrat_bplmn_search_req(void)
{
  rr_interrat_plmn_srch_req_type *rr_interrat_plmn_srch_req = rrc_malloc(sizeof(rr_interrat_plmn_srch_req_type));
  uint32 i;
  rrclog_wcdma_bplmn_scan_start_event_type bplmn_scan_start_event;

  rr_interrat_plmn_srch_req->scan_scope = rrc_csp_int_data.bplmn_scan_scope;
  WRRC_MSG1_HIGH("Scan Scope: %d", rrc_csp_int_data.bplmn_scan_scope);
  switch(rrc_csp_int_data.curr_scan)
  {
    case RRC_CSP_WTOG_BPLMN_AUTOMATIC_SCAN:
      WRRC_MSG0_HIGH("WTOG: Automatic PLMN Search being sent to GSM");
      rr_interrat_plmn_srch_req->num_plmns = 0;

      /* Populate the structure and print the PLMNs sent to GSM */
      WRRC_MSG0_HIGH("WTOG: PLMNs sent to GSM from NAS request list");
      for(i=0; (i < rrc_csp_int_data.bplmn_num_req) && (i < SYS_PRIORITY_PLMN_LIST_MAX_LENGTH); ++i)
      {
        if(rrc_csp_int_data.bplmn_rat_req_list[i] == SYS_RAT_GSM_RADIO_ACCESS)
        {
          rr_interrat_plmn_srch_req->plmn[rr_interrat_plmn_srch_req->num_plmns] = 
               mmumts_convert_rrc_plmn_id_to_nas_plmn_id(rrc_csp_int_data.bplmn_req_list[i].plmn_id);
        
          WRRC_MSG2_HIGH("WTOG GSM PLMN %d-%d", RRC_CSP_GET_INT_MCC(rrc_csp_int_data.bplmn_req_list[i].plmn_id),
                                          RRC_CSP_GET_INT_MNC(rrc_csp_int_data.bplmn_req_list[i].plmn_id)
                                          );

          ++(rr_interrat_plmn_srch_req->num_plmns);
        } 
      }
      
      rr_interrat_plmn_srch_req->network_select_mode = SYS_NETWORK_SELECTION_MODE_AUTOMATIC;
      rr_interrat_plmn_srch_req->timer_val           = rrc_csp_wtog_bplmn_int_data.wtog_rem_drx_tmr_value;
      rr_interrat_plmn_srch_req->service_search      = rrc_csp_int_data.service_search_bgnd;
      break;
  
    case RRC_CSP_WTOG_BPLMN_MANUAL_SCAN: 
      WRRC_MSG0_HIGH("WTOG: Manual PLMN Search being sent to GSM");  
      rr_interrat_plmn_srch_req->num_plmns           = 0;
      rr_interrat_plmn_srch_req->network_select_mode = SYS_NETWORK_SELECTION_MODE_MANUAL;
      rr_interrat_plmn_srch_req->timer_val           = rrc_csp_wtog_bplmn_int_data.wtog_rem_drx_tmr_value;
      break;

    case RRC_CSP_PLMN_LIST_SCAN: 
      WRRC_MSG0_HIGH("WTOG OOS: Manual PLMN Search being sent to GSM for fgnd srch");  
      rr_interrat_plmn_srch_req->num_plmns           = 0;
      rr_interrat_plmn_srch_req->network_select_mode = SYS_NETWORK_SELECTION_MODE_MANUAL;
      /* Send 50s timer as PLMN seach should be done in fgnd on GSM */
      rr_interrat_plmn_srch_req->timer_val           = 50000;
      break;

    default:
      WRRC_MSG1_ERROR("WTOG ERR: Incorrect scan type for WtoG BPLMN Search", rrc_csp_int_data.curr_scan);
      rr_interrat_plmn_srch_req->num_plmns           = 0;
      rr_interrat_plmn_srch_req->network_select_mode = SYS_NETWORK_SELECTION_MODE_MANUAL;
      rr_interrat_plmn_srch_req->timer_val           = 0;
      break;
  }

  /* Send the RR_INTERRAT_PLMN_SRCH_REQ message to RR */
  rr_send_rrc_message_to_rr_internal((void *)((rr_interrat_plmn_srch_req)), 
                             RR_INTERRAT_PLMN_SRCH_REQ,
                             sizeof(rr_interrat_plmn_srch_req_type));
  rrc_free(rr_interrat_plmn_srch_req);

  WRRC_MSG0_HIGH("WTOG: RR_INTERRAT_PLMN_SRCH_REQ sent to GSM RR");

  //EVENT: Event_BPLMN_Scan_Start_req  W2G Start
  bplmn_scan_start_event.scan_type = RRC_WTOG_BPLMN; 
  event_report_payload(EVENT_WCDMA_BPLMN_SCAN_START, sizeof(bplmn_scan_start_event),
                 (void *)&bplmn_scan_start_event);

} /* rrccsp_send_gsm_interrat_bplmn_search_req */


/*===========================================================================

FUNCTION          rrccsp_send_gsm_interrat_bplmn_abort_req

DESCRIPTION       This function is responsible for sending
                  RR_INTERRAT_PLMN_SRCH_ABORT_REQ to RR for aborting
                  WTOG BPLMN search

DEPENDENCIES
                  None.

RETURN VALUE
                  None.

SIDE EFFECTS      None.
===========================================================================*/
void rrccsp_send_gsm_interrat_bplmn_abort_req( void )
{
  rr_interrat_plmn_srch_abort_req_type rr_interrat_plmn_srch_abort_req;
  rrclog_wcdma_bplmn_scan_end_event_type bplmn_scan_end_event;

  /* Send the RR_INTERRAT_PLMN_SRCH_ABORT_REQ message to RR */
  rr_send_rrc_message_to_rr_internal((void *)(&(rr_interrat_plmn_srch_abort_req)), 
                             RR_INTERRAT_PLMN_SRCH_ABORT_REQ,
                             sizeof(rr_interrat_plmn_srch_abort_req_type));

  WRRC_MSG0_HIGH("RR_INTERRAT_PLMN_SRCH_ABORT_REQ sent to GSM RR");

  //EVENT: Event_BPLMN_Scan_End_req  W2G End
  bplmn_scan_end_event.scan_complete = RRC_BPLMN_ABORTED; /*TBD: timeout,complete,Abort*/
  event_report_payload(EVENT_WCDMA_BPLMN_SCAN_END, sizeof(bplmn_scan_end_event),
                 (void *)&bplmn_scan_end_event);

  rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_aborted = TRUE;

} /* rrccsp_send_gsm_interrat_bplmn_abort_req */

/*===========================================================================

FUNCTION          rrccsp_send_gsm_interrat_bplmn_suspend_ind

DESCRIPTION       This function is responsible for sending
                  RR_INTERRAT_PLMN_SRCH_SUSPEND_IND to RR for suspending
                  WTOG BPLMN search

DEPENDENCIES
                  None.

RETURN VALUE
                  None.

SIDE EFFECTS      None.
===========================================================================*/
void rrccsp_send_gsm_interrat_bplmn_suspend_ind( void )
{
  rr_interrat_plmn_srch_suspend_ind_type rr_interrat_plmn_srch_suspend_ind;

  /* Send the RR_INTERRAT_PLMN_SRCH_SUSPEND_IND message to RR */
  rr_send_rrc_message_to_rr_internal((void *)(&(rr_interrat_plmn_srch_suspend_ind)), 
                             RR_INTERRAT_PLMN_SRCH_SUSPEND_IND,
                             sizeof(rr_interrat_plmn_srch_suspend_ind_type));

  WRRC_MSG0_HIGH("RR_INTERRAT_PLMN_SRCH_SUSPEND_IND sent to GSM RR");

  rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_suspended = TRUE;
} /* rrccsp_send_gsm_interrat_bplmn_suspend_ind */

/*===========================================================================

FUNCTION          RRCCSP_SEND_IRAT_BPLMN_SUSPEND_IND

DESCRIPTION       This function is responsible for sending SUSPEND_IND to the RAT by checking the BPLMN RAT TYPE

DEPENDENCIES
                  None.

RETURN VALUE
                  None.

SIDE EFFECTS      None.
===========================================================================*/
void rrccsp_send_irat_bplmn_suspend_ind
(
  void
)
{
#ifdef FEATURE_WCDMA_TO_LTE
  if(rrc_csp_int_data.bplmn_interrat_type == RRC_CSP_INTERRAT_LTE)
  {
    rrccsp_send_lte_interrat_bplmn_suspend_ind();
  }
  else
#endif
  {
    rrccsp_send_gsm_interrat_bplmn_suspend_ind();
  }
} /* rrccsp_send_irat_bplmn_suspend_ind */

/*===========================================================================

FUNCTION          RRCCSP_SEND_IRAT_BPLMN_ABORT_REQ

DESCRIPTION       This function is responsible for sending ABORT_REQ to the RAT by checking the BPLMN RAT TYPE

DEPENDENCIES
                  None.

RETURN VALUE
                  None.

SIDE EFFECTS      None.
===========================================================================*/
void rrccsp_send_irat_bplmn_abort_req
(
  void
)
{
#ifdef FEATURE_WCDMA_TO_LTE
  if(rrc_csp_int_data.bplmn_interrat_type == RRC_CSP_INTERRAT_LTE)
  {
    rrccsp_send_lte_interrat_bplmn_abort_req();
  }
  else
#endif
  {
    rrccsp_send_gsm_interrat_bplmn_abort_req();
  }
}
/*===========================================================================

FUNCTION          RRCCSP_SEND_GTOW_REDIRECTION_ABORT_CNF

DESCRIPTION       This function is responsible for sending
                  RRC_INTERRAT_REDIRECT_ABORT_CNF to RR after getting 
                  RRC_INTERRAT_REDIRECT_ABORT_REQ from RR to abort GtoW redirection.

DEPENDENCIES
                  None.

RETURN VALUE
                  None.

SIDE EFFECTS      None.
===========================================================================*/
void rrccsp_send_gtow_redirection_abort_cnf()
{
  rrc_interrat_redirect_abort_cnf_type  rrc_interrat_redirect_abort_cnf;

  /* Send the RRC_INTERRAT_RESELECT_REJ message to RR */
  rr_send_rrc_message_to_rr_internal((void *)(&(rrc_interrat_redirect_abort_cnf)), RRC_INTERRAT_REDIRECT_ABORT_CNF,
          sizeof(rrc_interrat_redirect_abort_cnf_type));

  WRRC_MSG0_HIGH("RRC_INTERRAT_REDIRECT_ABORT_CNF sent to GSM RR");

#ifdef FEATURE_DUAL_SIM
  rrc_stop_lock_wait_timer();
  rrc_release_lock();
#endif
}

/*===========================================================================

FUNCTION          RRCCSP_SEND_GTOW_REDIRECTION_REJECT

DESCRIPTION       This function is responsible for sending
                  RRC_INTERRAT_REDIRECT_REJ to RR when no WCDMA cell is found for 
                  GtoW redirection search

DEPENDENCIES
                  None.

RETURN VALUE
                  None.

SIDE EFFECTS      None.
===========================================================================*/
void rrccsp_send_gtow_redirection_reject()
{
  rrc_interrat_redirect_rej_type rrc_interrat_redirect_rej;

  /* Send the RRC_INTERRAT_RESELECT_REJ message to RR */
  rr_send_rrc_message_to_rr_internal((void *)(&(rrc_interrat_redirect_rej)), RRC_INTERRAT_REDIRECT_REJ,
          sizeof(rrc_interrat_redirect_rej_type));

  WRRC_MSG0_HIGH("RRC_INTERRAT_REDIRECT_REJ sent to GSM RR");

#ifdef FEATURE_DUAL_SIM
  rrc_stop_lock_wait_timer();
  rrc_release_lock();
#endif
}

#ifdef FEATURE_WCDMA_TO_LTE
/*===========================================================================

FUNCTION          RRCCSP_SEND_LTE_INTERRAT_RESELECTION_REQ

DESCRIPTION       This function is responsible for sending
                  LTE_RRC_WCDMA_RESEL_REQ to LTE RRC.

DEPENDENCIES
                  None.

RETURN VALUE
                  None.

SIDE EFFECTS      None.
===========================================================================*/
static void rrccsp_send_lte_interrat_reselection_req
(
  rrc_cmd_type *cmd_ptr
)
{

  lte_rrc_wcdma_resel_req_s *resel_req = rrc_malloc(sizeof(lte_rrc_wcdma_resel_req_s));
  rrclog_wcdma_to_lte_resel_start_event_type wtol_resel_event;

  memset(resel_req,0,sizeof(lte_rrc_wcdma_resel_req_s));
  resel_req->irat_nas_info.network_select_mode = rrc_csp_int_data.network_select_mode;
  resel_req->irat_nas_info.req_plmn = 
    mmumts_convert_rrc_plmn_id_to_nas_plmn_id(rrc_csp_int_data.curr_req_plmn.plmn_id);
  
#ifdef FEATURE_FEMTO_CSG
  resel_req->irat_nas_info.csg_id = rrc_csp_int_data.curr_req_plmn.csg_id;
#endif

  resel_req->irat_nas_info.rat_pri_list = rrc_csp_int_data.rat_pri_list_info;
  resel_req->earfcn = (lte_earfcn_t)cmd_ptr->cmd.cell_rsel_ind.u.eutra_info.cell_info.EARFCN;
  resel_req->lte_cell_id = (lte_phy_cell_id_t)cmd_ptr->cmd.cell_rsel_ind.u.eutra_info.cell_info.physical_cell_identity;


#ifdef FEATURE_FEMTO_CSG
    /*Send current camped information in resel request. LTE will use it for finger printing*/
    resel_req->serving_cell_info.frequency      = rrc_ccm_get_curr_camped_freq();
    resel_req->serving_cell_info.phy_cell_id    = rrc_ccm_get_curr_camped_psc();
    resel_req->serving_cell_info.cell_identity  = rrc_ccm_get_curr_camped_cell_id();
    resel_req->serving_cell_info.plmn           = mmumts_convert_rrc_plmn_id_to_nas_plmn_id(rrc_ccm_get_curr_camped_plmn());
    resel_req->serving_cell_info.csg_id         = rrc_ccm_get_curr_camped_csg_id();
    resel_req->csg_resel                        = cmd_ptr->cmd.cell_rsel_ind.csg_resel;
#endif

#ifdef FEATURE_WCDMA_ABSOLUTE_PRIORITY
  rrcmeas_populate_dedicated_priority_info_for_irat_req(&resel_req->dedicated_priority_info);
#endif

  /*LTE_RRC_WCDMA_RESEL_REQ*/
  rrc_send_lte_cmd(&resel_req->msg_hdr,LTE_RRC_WCDMA_RESEL_REQ,sizeof(lte_rrc_wcdma_resel_req_s));
  WRRC_MSG0_HIGH("WTOL: LTE_RRC_WCDMA_RESEL_REQ sent to LTE RRC");

  wtol_resel_event.earfcn =  cmd_ptr->cmd.cell_rsel_ind.u.eutra_info.cell_info.EARFCN;
  wtol_resel_event.cell_id = cmd_ptr->cmd.cell_rsel_ind.u.eutra_info.cell_info.physical_cell_identity;
  /*Copy the three byte MCC*/
  WCDMA_MEMCPY(wtol_resel_event.MCC,
               sizeof(uint8) * 3,
               rrc_csp_int_data.curr_req_plmn.plmn_id.mcc,
               3);
  /*Copy the three byte MNC*/
  WCDMA_MEMCPY(wtol_resel_event.MNC,
               sizeof(uint8) * 3,
               rrc_csp_int_data.curr_req_plmn.plmn_id.mnc,
               3);
  if(rrc_csp_int_data.curr_req_plmn.plmn_id.num_mnc_digits == 2)
  {
    wtol_resel_event.MNC[2] = 0xF;
  }
  event_report_payload(EVENT_WCDMA_TO_LTE_RESELECTION_START, sizeof(wtol_resel_event),
                 (void *)&wtol_resel_event);
  rrc_free(resel_req);
}

/*===========================================================================

FUNCTION          RRCCSP_SEND_LTE_INTERRAT_RESELECTION_ABORT_REQ

DESCRIPTION       This function is responsible for sending
                  LTE_RRC_WCDMA_ABORT_RESEL_REQ to LTE RRC.

DEPENDENCIES
                  None.

RETURN VALUE
                  None.

SIDE EFFECTS      None.
===========================================================================*/
static void rrccsp_send_lte_interrat_reselection_abort_req
(
  void
)
{
  lte_rrc_wcdma_abort_resel_req_s abort_resel_req;
  rrclog_wcdma_to_lte_resel_end_event_type wtol_resel_event;
  rrc_send_lte_cmd(&abort_resel_req.msg_hdr,LTE_RRC_WCDMA_ABORT_RESEL_REQ,sizeof(lte_rrc_wcdma_abort_resel_req_s));
  WRRC_MSG0_HIGH("WTOL: LTE_RRC_WCDMA_ABORT_RESEL_REQ sent to LTE RRC");

  wtol_resel_event.status = WTOL_ABORTED;
  wtol_resel_event.failure_cause = 0xFF; /*Cause not needed for ABORT*/

  event_report_payload(EVENT_WCDMA_TO_LTE_RESELECTION_END, sizeof(wtol_resel_event),
                 (void *)&wtol_resel_event);
}

/*===========================================================================

FUNCTION          RRCCSP_SEND_LTE_INTERRAT_RESELECTION_ABORT_REQ

DESCRIPTION       This function is responsible for sending
                  LTE_RRC_WCDMA_PLMN_SRCH_REQ to RR.

DEPENDENCIES
                  None.

RETURN VALUE
                  None.

SIDE EFFECTS      None.
===========================================================================*/
static void rrccsp_send_lte_interrat_bplmn_search_req(void)
{
  lte_irat_plmn_srch_req_s *interrat_plmn_srch_req = rrc_malloc(sizeof(lte_irat_plmn_srch_req_s));
  uint32 i;

  memset(interrat_plmn_srch_req,0, sizeof(lte_irat_plmn_srch_req_s));
  interrat_plmn_srch_req->detected_frequency_list.num_freqs = rrc_csp_int_data.detected_frequency_list.num_freqs;
  WCDMA_MEMCPY(interrat_plmn_srch_req->detected_frequency_list.freq,
               LTE_IRAT_MAX_DETECTED_FREQ * sizeof(detected_frequency_type),
               rrc_csp_int_data.detected_frequency_list.freq,
               LTE_IRAT_MAX_DETECTED_FREQ * sizeof(detected_frequency_type));

#ifdef FEATURE_FEMTO_CSG
  if(rrc_csp_int_data.curr_scan != RRC_CSP_PLMN_LIST_SCAN)
  {
    /*Send current camped information. LTE will use it for finger printing*/
    interrat_plmn_srch_req->serving_cell_info.frequency      = rrc_ccm_get_curr_camped_freq();
    interrat_plmn_srch_req->serving_cell_info.phy_cell_id    = rrc_ccm_get_curr_camped_psc();
    interrat_plmn_srch_req->serving_cell_info.cell_identity  = rrc_ccm_get_curr_camped_cell_id();
    interrat_plmn_srch_req->serving_cell_info.plmn           = mmumts_convert_rrc_plmn_id_to_nas_plmn_id(rrc_ccm_get_curr_camped_plmn());
    interrat_plmn_srch_req->serving_cell_info.csg_id         = rrc_ccm_get_curr_camped_csg_id();
  }
#endif

  if ( rrc_csp_int_data.detected_frequency_list.num_freqs == 0)
  {
    interrat_plmn_srch_req->detected_frequency_list.num_freqs = 1;
    interrat_plmn_srch_req->detected_frequency_list.freq[0].frequency = 
        rrccsp_derive_freq_from_uarfcn(rrc_csp_int_data.curr_acq_entry.freq,
                                        rrc_get_frequency_band( rrc_csp_int_data.curr_acq_entry.freq,
                                          rrc_csp_int_data.curr_req_plmn.plmn_id));
    interrat_plmn_srch_req->detected_frequency_list.freq[0].bandwidth = 50;/*50*100KHz*/
    interrat_plmn_srch_req->detected_frequency_list.freq[0].rat = SYS_RAT_UMTS_RADIO_ACCESS;
    WRRC_MSG1_HIGH("WTOL: adding curr camped freq %d in bplmn req to LTE",
             interrat_plmn_srch_req->detected_frequency_list.freq[0].frequency);
  }

  interrat_plmn_srch_req->search_type = SYS_SERVICE_SEARCH_NONE;
#ifdef LTE_BAND_NUM
  interrat_plmn_srch_req->band_pref.lte_band_cap = rrc_csp_int_data.bplmn_lte_band_pref;
#else
  interrat_plmn_srch_req->band_pref = rrc_csp_int_data.bplmn_lte_band_pref;
#endif
  interrat_plmn_srch_req->scan_scope = rrc_csp_int_data.bplmn_scan_scope;
  WRRC_MSG1_HIGH("Scan Scope: %d", rrc_csp_int_data.bplmn_scan_scope);

  switch(rrc_csp_int_data.curr_scan)
  {
    case RRC_CSP_WTOG_BPLMN_AUTOMATIC_SCAN:
      WRRC_MSG0_HIGH("WTOL: Automatic PLMN Search being sent to LTE RRC");
      interrat_plmn_srch_req->num_plmns = 0;

      /* Populate the structure and print the PLMNs sent to GSM */
      WRRC_MSG0_HIGH("WTOL: PLMNs sent to GSM from NAS request list");
      for(i=0; (i < rrc_csp_int_data.bplmn_num_req) && (i < SYS_PRIORITY_PLMN_LIST_MAX_LENGTH); ++i)
      {
        if(rrc_csp_int_data.bplmn_rat_req_list[i] == SYS_RAT_LTE_RADIO_ACCESS)
        {
          interrat_plmn_srch_req->plmn[interrat_plmn_srch_req->num_plmns] = 
               mmumts_convert_rrc_plmn_id_to_nas_plmn_id(rrc_csp_int_data.bplmn_req_list[i].plmn_id);
        
          WRRC_MSG2_HIGH("WTOL LTE PLMN %d-%d", RRC_CSP_GET_INT_MCC(rrc_csp_int_data.bplmn_req_list[i].plmn_id),
                                          RRC_CSP_GET_INT_MNC(rrc_csp_int_data.bplmn_req_list[i].plmn_id)
                                          );

          ++(interrat_plmn_srch_req->num_plmns);
        } 
      }
      
      interrat_plmn_srch_req->network_select_mode = SYS_NETWORK_SELECTION_MODE_AUTOMATIC;
      interrat_plmn_srch_req->timer_val           = rrc_csp_wtog_bplmn_int_data.wtog_rem_drx_tmr_value;
      interrat_plmn_srch_req->search_type      = rrc_csp_int_data.service_search_bgnd;

#ifdef FEATURE_FEMTO_CSG
      /*Set service search type for ASF*/
      if(rrc_csp_int_data.csg_asf_srch_in_progress == TRUE)
      {
        interrat_plmn_srch_req->search_type      = SYS_SERVICE_SEARCH_CSG;
      }
#endif
      break;
  
    case RRC_CSP_WTOG_BPLMN_MANUAL_SCAN: 
      WRRC_MSG0_HIGH("WTOL: Manual PLMN Search being sent to LTE");  
      interrat_plmn_srch_req->num_plmns           = 0;
      interrat_plmn_srch_req->network_select_mode = SYS_NETWORK_SELECTION_MODE_MANUAL;
      interrat_plmn_srch_req->timer_val           = rrc_csp_wtog_bplmn_int_data.wtog_rem_drx_tmr_value;
#ifdef FEATURE_FEMTO_CSG
      interrat_plmn_srch_req->search_type         = rrc_csp_int_data.service_search_bgnd;
#endif
      break;

    case RRC_CSP_PLMN_LIST_SCAN: 
      WRRC_MSG0_HIGH("WTOL OOS: Manual PLMN Search being sent to LTE for fgnd srch");  
      interrat_plmn_srch_req->num_plmns           = 0;
      interrat_plmn_srch_req->network_select_mode = SYS_NETWORK_SELECTION_MODE_MANUAL;
      /* Send 50s timer as PLMN seach should be done in fgnd on GSM */
      interrat_plmn_srch_req->timer_val           = 50000;
#ifdef FEATURE_FEMTO_CSG
      interrat_plmn_srch_req->search_type         = rrc_csp_int_data.service_search_bgnd;
#endif
      break;

    default:
      WRRC_MSG1_ERROR("WTOL ERR: Incorrect scan type for WtoL BPLMN Search", rrc_csp_int_data.curr_scan);
      interrat_plmn_srch_req->num_plmns           = 0;
      interrat_plmn_srch_req->network_select_mode = SYS_NETWORK_SELECTION_MODE_MANUAL;
      interrat_plmn_srch_req->timer_val           = 0;
      break;
  }

  rrc_send_lte_cmd(&interrat_plmn_srch_req->msg_hdr,LTE_RRC_WCDMA_PLMN_SRCH_REQ,sizeof(lte_irat_plmn_srch_req_s));
  rrc_free(interrat_plmn_srch_req);

  WRRC_MSG0_HIGH("WTOL: LTE_RRC_WCDMA_PLMN_SRCH_REQ sent to LTE RRC");


}


/*===========================================================================

FUNCTION          RRCCSP_SEND_LTE_INTERRAT_BPLMN_ABORT_REQ

DESCRIPTION       This function is responsible for sending
                  LTE_RRC_WCDMA_ABORT_PLMN_SRCH_REQ to LTE RRC for aborting
                  WTOG BPLMN search

DEPENDENCIES
                  None.

RETURN VALUE
                  None.

SIDE EFFECTS      None.
===========================================================================*/
void rrccsp_send_lte_interrat_bplmn_abort_req
(
  void
)
{
  lte_irat_abort_plmn_srch_req_s interrat_abort_plmn_srch_req;
  rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_aborted = TRUE;
  rrc_send_lte_cmd(&interrat_abort_plmn_srch_req.msg_hdr,LTE_RRC_WCDMA_ABORT_PLMN_SRCH_REQ,sizeof(lte_irat_abort_plmn_srch_req_s));
  WRRC_MSG0_HIGH("WTOL: LTE_RRC_WCDMA_ABORT_PLMN_SRCH_REQ sent to LTE RRC");
}

/*===========================================================================

FUNCTION          RRCCSP_SEND_LTE_INTERRAT_BPLMN_SUSPEND_IND

DESCRIPTION       This function is responsible for sending
                  LTE_RRC_WCDMA_SUSPEND_PLMN_SRCH_IND to LTE RRC for suspending
                  WTOL BPLMN search

DEPENDENCIES
                  None.

RETURN VALUE
                  None.

SIDE EFFECTS      None.
===========================================================================*/
void rrccsp_send_lte_interrat_bplmn_suspend_ind
(
  void
)
{
  lte_irat_suspend_plmn_srch_ind_s interrat_suspend_plmn_srch_ind;
  rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_suspended = TRUE;
  rrc_send_lte_cmd(&interrat_suspend_plmn_srch_ind.msg_hdr,LTE_RRC_WCDMA_SUSPEND_PLMN_SRCH_IND,sizeof(lte_irat_suspend_plmn_srch_ind_s));
  WRRC_MSG0_HIGH("WTOL: LTE_RRC_WCDMA_SUSPEND_PLMN_SRCH_IND sent to LTE RRC");
}

/*===========================================================================

FUNCTION          RRCCSP_SEND_LTE_INTERRAT_REDIRECTION_REQ

DESCRIPTION       This function is responsible for sending
                  LTE_RRC_WCDMA_REDIR_REQ to LTE-RRC.

DEPENDENCIES
                  None.

RETURN VALUE
                  None.

SIDE EFFECTS      None.
===========================================================================*/
static void rrccsp_send_lte_interrat_redirection_req
(
  void
)
{
  rrc_SysInfoType19 *sib19_ptr = NULL;
  lte_rrc_wcdma_redir_req_s *lte_interrat_redir_req = rrc_malloc(sizeof(lte_rrc_wcdma_redir_req_s));
  rrclog_wcdma_to_lte_redir_start_event_type wtol_redir_event;

  memset(lte_interrat_redir_req,0,sizeof(lte_rrc_wcdma_redir_req_s));

#ifdef FEATURE_FEMTO_CSG
  /*If network select mode is manual CSG. LTE will look into CSG ID and PLMN Id field*/
  lte_interrat_redir_req->serving_cell_info.frequency      = rrc_ccm_get_curr_camped_freq();
  lte_interrat_redir_req->serving_cell_info.phy_cell_id    = rrc_ccm_get_curr_camped_psc();
  lte_interrat_redir_req->serving_cell_info.cell_identity  = rrc_ccm_get_curr_camped_cell_id();
  lte_interrat_redir_req->serving_cell_info.plmn           = mmumts_convert_rrc_plmn_id_to_nas_plmn_id(rrc_ccm_get_curr_camped_plmn());
  lte_interrat_redir_req->serving_cell_info.csg_id         = rrc_ccm_get_curr_camped_csg_id();
#endif

  lte_interrat_redir_req->irat_nas_info.network_select_mode = rrc_csp_int_data.network_select_mode;
  lte_interrat_redir_req->irat_nas_info.req_plmn = 
    mmumts_convert_rrc_plmn_id_to_nas_plmn_id(rrc_csp_int_data.curr_req_plmn.plmn_id);
  lte_interrat_redir_req->irat_nas_info.rat_pri_list = rrc_csp_int_data.rat_pri_list_info;

#ifdef FEATURE_FEMTO_CSG
  lte_interrat_redir_req->irat_nas_info.csg_id = rrc_csp_int_data.curr_req_plmn.csg_id;
#endif

  memset(&lte_interrat_redir_req->dedicated_priority_info,0,sizeof(lte_irat_dedicated_priority_info_s));
#ifdef FEATURE_WCDMA_ABSOLUTE_PRIORITY
  rrcmeas_populate_dedicated_priority_info_for_irat_req(&lte_interrat_redir_req->dedicated_priority_info);
#endif

  lte_interrat_redir_req->redir_earfcn_list = rrc_csp_int_data.saved_rrc_cmd.cmd.redirect_req.u.EUTRA_target_cell_info;

  if(rrc_csp_int_data.saved_rrc_cmd.cmd.redirect_req.proc_id == RRC_PROCEDURE_RCR)
  {
    lte_interrat_redir_req->cause = LTE_RRC_IRAT_WCDMA_REDIR_CAUSE_CONN_RELEASE;
    lte_interrat_redir_req->t_wait_time_ms = 10*1000;

      /* Also update CCM with cell loss for redirection via conn release msg. This is required for the scenario
         where buffered EST_REQ has to be handled after resume failure. This chnage will make sure that RCE waits for
         UE to camp while CSP preforms ACQ-DB search after resume failure. */
    rrc_ccm_update_with_cell_loss();
  }
  else if(rrc_csp_int_data.saved_rrc_cmd.cmd.redirect_req.proc_id == RRC_PROCEDURE_RCE)
  {
    lte_interrat_redir_req->cause = LTE_RRC_IRAT_WCDMA_REDIR_CAUSE_CONN_REJECT;
    lte_interrat_redir_req->t_wait_time_ms = rrc_csp_int_data.saved_rrc_cmd.cmd.redirect_req.wait_time * 1000;
  }
  else
  {
    WRRC_MSG0_ERROR("Invalid procedure ID");
    rrc_free(lte_interrat_redir_req);
    return;    
  }

  /* Send LTE neighbour EARFCN's from SIB19 to optimize search on LTE */
  lte_interrat_redir_req->nbr_earfcn_list.earfcn_count = 0;
  sib19_ptr = (rrc_SysInfoType19 *)rrc_sibdb_return_sib_for_srv_cell(rrc_SIB19);
  if(sib19_ptr == NULL)
  {
    WRRC_MSG0_HIGH("WTOL: SIB19 is NULL. No neighbour cell freqs added to redirection req.");
  }
  else
  {
    if(sib19_ptr->m.eutra_FrequencyAndPriorityInfoListPresent)
    {
      rrc_EUTRA_FrequencyAndPriorityInfoList *eutra_freq_pri_list_ptr = &sib19_ptr->eutra_FrequencyAndPriorityInfoList;
      uint8 num_eutra_freqs = 0;
	  uint32 idx = 0;
  
      while((eutra_freq_pri_list_ptr->n > idx) && (num_eutra_freqs < LTE_RRC_IRAT_MAX_NBR_FREQ))
      {
        lte_interrat_redir_req->nbr_earfcn_list.earfcn[num_eutra_freqs++] = eutra_freq_pri_list_ptr->elem[idx].earfcn;
        idx++;
      }
      lte_interrat_redir_req->nbr_earfcn_list.earfcn_count = num_eutra_freqs;
    }
  }

  /*Send the message to MSGR*/
  /*LTE_RRC_WCDMA_REDIRL_REQ*/
  rrc_send_lte_cmd(&lte_interrat_redir_req->msg_hdr,LTE_RRC_WCDMA_REDIR_REQ,sizeof(lte_rrc_wcdma_redir_req_s));
  WRRC_MSG0_HIGH("WTOL: LTE_RRC_WCDMA_REDIR_REQ sent to LTE RRC");

  wtol_redir_event.redir_cause = WTOL_REDIR_NONE;
  if(lte_interrat_redir_req->cause == LTE_RRC_IRAT_WCDMA_REDIR_CAUSE_CONN_RELEASE)
  {
    wtol_redir_event.redir_cause = WTOL_REDIR_CONN_RELEASE;
  }
  else if (lte_interrat_redir_req->cause == LTE_RRC_IRAT_WCDMA_REDIR_CAUSE_CONN_REJECT)
  {
    wtol_redir_event.redir_cause = WTOL_REDIR_CONN_REJECT;
  }
  wtol_redir_event.wait_timer_in_secs = lte_interrat_redir_req->t_wait_time_ms / 1000;
  /*Copy the three byte MCC*/
  WCDMA_MEMCPY(wtol_redir_event.MCC,
               sizeof(uint8) * 3,
               rrc_csp_int_data.curr_req_plmn.plmn_id.mcc,
               3);
  /*Copy the three byte MNC*/
  WCDMA_MEMCPY(wtol_redir_event.MNC,
               sizeof(uint8) * 3,
               rrc_csp_int_data.curr_req_plmn.plmn_id.mnc,
               3);
  if(rrc_csp_int_data.curr_req_plmn.plmn_id.num_mnc_digits == 2)
  {
    wtol_redir_event.MNC[2] = 0xF;
  }
  event_report_payload(EVENT_WCDMA_TO_LTE_REDIRECTION_START, sizeof(wtol_redir_event),
                 (void *)&wtol_redir_event);
  rrc_free(lte_interrat_redir_req);
}

#ifdef FEATURE_WCDMA_FAST_RETURN_TO_LTE_AFTER_CSFB 
/*===========================================================================

FUNCTION          rrccsp_send_lte_blind_redirection_req

DESCRIPTION       This function is responsible for sending
                  Blind redirection to LTE RRC.

DEPENDENCIES
                  None.

RETURN VALUE
                  None.

SIDE EFFECTS      None.
===========================================================================*/
static void rrccsp_send_lte_blind_redirection_req
(
 void
)
{
  lte_rrc_wcdma_redir_req_s *lte_interrat_redir_req = rrc_malloc(sizeof(lte_rrc_wcdma_redir_req_s));
  rrclog_wcdma_to_lte_redir_start_event_type wtol_redir_event;

  rrc_ccm_update_with_cell_loss();

  lte_interrat_redir_req->cause = LTE_RRC_IRAT_WCDMA_REDIR_CAUSE_BLIND;

  lte_interrat_redir_req->irat_nas_info.network_select_mode = rrc_csp_int_data.network_select_mode;
  lte_interrat_redir_req->irat_nas_info.req_plmn = 
    mmumts_convert_rrc_plmn_id_to_nas_plmn_id(rrc_csp_int_data.curr_req_plmn.plmn_id);
  lte_interrat_redir_req->irat_nas_info.rat_pri_list = rrc_csp_int_data.rat_pri_list_info;
  
  memset(&lte_interrat_redir_req->dedicated_priority_info,0,sizeof(lte_irat_dedicated_priority_info_s));
#ifdef FEATURE_WCDMA_ABSOLUTE_PRIORITY
  rrcmeas_populate_dedicated_priority_info_for_irat_req(&lte_interrat_redir_req->dedicated_priority_info);
#endif

#ifdef FEATURE_FEMTO_CSG
  /*If network select mode is manual CSG. LTE will look into CSG ID and PLMN Id field*/
 /*Dont see a use case*/
  lte_interrat_redir_req->serving_cell_info.frequency      = rrc_ccm_get_curr_camped_freq();
  lte_interrat_redir_req->serving_cell_info.phy_cell_id    = rrc_ccm_get_curr_camped_psc();
  lte_interrat_redir_req->serving_cell_info.cell_identity  = rrc_ccm_get_curr_camped_cell_id();
  lte_interrat_redir_req->serving_cell_info.plmn           = mmumts_convert_rrc_plmn_id_to_nas_plmn_id(rrc_ccm_get_curr_camped_plmn());
  lte_interrat_redir_req->serving_cell_info.csg_id         = rrc_ccm_get_curr_camped_csg_id();
#endif

  /* Initialize remaining fields */
  lte_interrat_redir_req->redir_earfcn_list.earfcn_count = 0;
  lte_interrat_redir_req->nbr_earfcn_list.earfcn_count = 0;
  lte_interrat_redir_req->t_wait_time_ms = 0;

  /*Send the message to MSGR*/
  /*LTE_RRC_WCDMA_REDIRL_REQ*/
  rrc_send_lte_cmd(&lte_interrat_redir_req->msg_hdr,LTE_RRC_WCDMA_REDIR_REQ,sizeof(lte_rrc_wcdma_redir_req_s));
  WRRC_MSG0_HIGH("CSFB_HACK: LTE_RRC_WCDMA_REDIR_REQ sent to LTE RRC");
  wtol_redir_event.redir_cause = WTOL_REDIR_BLIND;
  wtol_redir_event.wait_timer_in_secs = 0;
  /*Copy the three byte MCC*/
  WCDMA_MEMCPY(wtol_redir_event.MCC,sizeof(uint8) * 3,
                rrc_csp_int_data.curr_req_plmn.plmn_id.mcc,sizeof(uint8) * 3);
  /*Copy the three byte MNC*/
  WCDMA_MEMCPY(wtol_redir_event.MNC,sizeof(uint8) * 3,
                 rrc_csp_int_data.curr_req_plmn.plmn_id.mnc,sizeof(uint8) * 3);
  if(rrc_csp_int_data.curr_req_plmn.plmn_id.num_mnc_digits == 2)
  {
    wtol_redir_event.MNC[2] = 0xF;
  }
  event_report_payload(EVENT_WCDMA_TO_LTE_REDIRECTION_START, sizeof(wtol_redir_event),
                 (void *)&wtol_redir_event);

  
  rrc_free(lte_interrat_redir_req);

}
#endif
#endif

#ifdef FEATURE_LTE_TO_WCDMA
/*===========================================================================

FUNCTION          RRCCSP_SEND_LTE_INTERRAT_RESELECTION_ABORT_RSP

DESCRIPTION       This function is responsible for sending
                  WCDMA_RRC_LTE_ABORT_RESEL_RSP to LTE RRC.

DEPENDENCIES
                  None.

RETURN VALUE
                  None.

SIDE EFFECTS      None.
===========================================================================*/
void rrccsp_send_lte_interrat_reselection_abort_rsp
(
  void
)
{
  wcdma_rrc_lte_abort_resel_rsp_type abort_resel_rsp;
  rrc_send_lte_cmd(&abort_resel_rsp.msg_hdr,WCDMA_RRC_LTE_ABORT_RESEL_RSP,sizeof(wcdma_rrc_lte_abort_resel_rsp_type));
  WRRC_MSG0_HIGH("LTOW: WCDMA_RRC_LTE_ABORT_RESEL_RSP sent to LTE RRC");
}


/*===========================================================================

FUNCTION          RRCCSP_UPDATE_LTE_INTERRAT_FAILURE_CAUSE

DESCRIPTION       This function is poupulate LTE failure cause for LTOW, from internal failure cause

DEPENDENCIES
                  None.

RETURN VALUE
                  None.

SIDE EFFECTS      None.
===========================================================================*/
static void rrccsp_update_lte_interrat_failure_cause
(
  rrc_interrat_reject_reason_T interrat_reselect_failure_reason,
  wcdma_rrc_irat_failure_cause_e_type *lte_irat_failure_cause
)
{
  switch(interrat_reselect_failure_reason)
  {
    case RRC_WCDMA_CELL_BARRED:
      *lte_irat_failure_cause = WCDMA_RRC_CELL_BARRED;
      break;
    case RRC_WCDMA_UARFCN_BARRED:
      *lte_irat_failure_cause = WCDMA_RRC_UARFCN_BARRED;
      break;

    case RRC_WCDMA_FORBIDDEN_LA:
      *lte_irat_failure_cause = WCDMA_RRC_FORBIDDEN_LA;
      break;

    case RRC_WCDMA_PLMN_MISMATCH:
      *lte_irat_failure_cause = WCDMA_RRC_PLMN_MISMATCH;
      break;

    case RRC_WCDMA_CELL_QUALITY_FAILURE:
      *lte_irat_failure_cause = WCDMA_RRC_CELL_QUALITY_FAILURE;
      break;

    case RRC_WCDMA_ACQUISITION_FAIL:
      *lte_irat_failure_cause = WCDMA_RRC_ACQUISITION_FAIL;
      break;
      
    case RRC_WCDMA_SIBS_FAILED_LOWER_LAYERS:
    case RRC_WCDMA_INVALID_SIBS:
    case RRC_WCDMA_SIBS_TIMEOUT:
    case RRC_WCDMA_SIBS_FAILED_OTHER:
      *lte_irat_failure_cause= WCDMA_RRC_SIBS_FAILURE;
      break;

    case RRC_WCDMA_CELL_NOT_SUITABLE:
      *lte_irat_failure_cause = WCDMA_RRC_CELL_NOT_SUITABLE;
      break;

    case RRC_WCDMA_CELL_CHANGE_FAILURE:
      *lte_irat_failure_cause = WCDMA_RRC_CELL_CHANGE_FAILURE;
      break;

#ifdef FEATURE_FEMTO_CSG
    case RRC_WCDMA_CSG_FORBIDDEN:
      *lte_irat_failure_cause = WCDMA_RRC_CSG_FORBIDDEN;
       break;
#endif

    default:
      break;
  }
}
/*===========================================================================

FUNCTION          RRCCSP_SEND_LTE_INTERRAT_RESELECTION_FAILED_RSP

DESCRIPTION       This function is responsible for sending
                  WCDMA_RRC_LTE_RESEL_FAILED_RSP to LTE RRC.

DEPENDENCIES
                  None.

RETURN VALUE
                  None.

SIDE EFFECTS      None.
===========================================================================*/
void rrccsp_send_lte_interrat_reselection_failed_rsp
(
  void
)
{
  wcdma_rrc_lte_resel_failed_rsp_type resel_failed_rsp;
  rrccsp_update_lte_interrat_failure_cause(rrc_csp_int_data.interrat_reselect_failure_reason,
     &resel_failed_rsp.failure_cause);
  resel_failed_rsp.time_to_reselect = 0;
  if((resel_failed_rsp.failure_cause == WCDMA_RRC_CELL_BARRED)||
     (resel_failed_rsp.failure_cause == WCDMA_RRC_UARFCN_BARRED) ||
     (resel_failed_rsp.failure_cause == WCDMA_RRC_FORBIDDEN_LA) ||
     (resel_failed_rsp.failure_cause == WCDMA_RRC_PLMN_MISMATCH)
#ifdef FEATURE_FEMTO_CSG
     ||(resel_failed_rsp.failure_cause == WCDMA_RRC_CSG_FORBIDDEN)
#endif
     )
  {
    resel_failed_rsp.time_to_reselect = rrc_csp_int_data.wcdma_cell_time_to_reselect;
  }
  rrc_send_lte_cmd(&resel_failed_rsp.msg_hdr,WCDMA_RRC_LTE_RESEL_FAILED_RSP,sizeof(wcdma_rrc_lte_resel_failed_rsp_type));
  WRRC_MSG1_HIGH("LTOW: WCDMA_RRC_LTE_RESEL_FAILED_RSP sent to LTE RRC, cause %d",resel_failed_rsp.failure_cause);
  
#ifdef FEATURE_FEMTO_CSG
  WRRC_MSG0_HIGH("CSG: Invalidate FP info as LTOW resel failed");
  rrc_csp_int_data.last_csg_rat = RRC_CSG_NONE;
  rrc_csp_int_data.csg_resel = FALSE;
#endif
}

/*===========================================================================

FUNCTION          RRCCSP_SEND_LTE_INTERRAT_PLMN_SRCH_ABORT_RSP

DESCRIPTION       This function is responsible for sending
                  WCDMA_RRC_LTE_ABORT_PLMN_SRCH_RSP to LTE RRC.

DEPENDENCIES
                  None.

RETURN VALUE
                  None.

SIDE EFFECTS      None.
===========================================================================*/
void rrccsp_send_lte_interrat_plmn_srch_abort_rsp
(
  void
)
{
  lte_irat_abort_plmn_srch_rsp_s abort_plmn_srch_rsp;
#ifdef FEATURE_FEMTO_CSG
  rrclog_wcdma_bplmn_end_event_type bplmn_end_event;
#endif

  if(!rrc_csp_int_data.bplmn_srch_tmr_expired)
  {
    rrctmr_stop_timer(RRCTMR_BPLMN_SRCH_TIMER);
    rrc_csp_int_data.bplmn_srch_tmr_expired = TRUE;
  }

  rrc_send_lte_cmd(&abort_plmn_srch_rsp.msg_hdr,WCDMA_RRC_LTE_ABORT_PLMN_SRCH_RSP,sizeof(lte_irat_abort_plmn_srch_rsp_s));
  WRRC_MSG0_HIGH("LTOW: WCDMA_RRC_LTE_ABORT_PLMN_SRCH_RSP sent to LTE RRC");
#ifdef FEATURE_FEMTO_CSG
  if(rrc_csp_int_data.csg_asf_srch_in_progress)
  {
    bplmn_end_event.bplmn_end_reason = RRC_BPLMN_TIMEOUT;
    event_report_payload(EVENT_ASF_SCAN_END, sizeof(bplmn_end_event),
                   (void *)&bplmn_end_event);
  }
#endif
  rrc_csp_init_int_data();
}

/*===========================================================================

FUNCTION          RRCCSP_SEND_LTE_INTERRAT_PLMN_SRCH_RSP

DESCRIPTION       This function is responsible for sending
                  WCDMA_RRC_LTE_PLMN_SRCH_RSP to LTE RRC.

DEPENDENCIES
                  None.

RETURN VALUE
                  None.

SIDE EFFECTS      None.
===========================================================================*/
void rrccsp_send_lte_interrat_plmn_srch_rsp
(
  boolean send_partial_results
)
{
  lte_irat_plmn_srch_rsp_s *plmn_srch_rsp = rrc_malloc(sizeof(lte_irat_plmn_srch_rsp_s));
  uint32 i;
  rrc_plmn_identity_type nas_to_rrc_plmn_id;
#ifdef FEATURE_FEMTO_CSG
  rrclog_wcdma_bplmn_end_event_type bplmn_end_event;
#endif
  if(send_partial_results != TRUE)
  {
    /* Stop BPLMN timer if active */
    if(!rrc_csp_int_data.bplmn_srch_tmr_expired)
    {
      rrctmr_stop_timer(RRCTMR_BPLMN_SRCH_TIMER);
      rrc_csp_int_data.bplmn_srch_tmr_expired = TRUE;
    }
  }

  memset(plmn_srch_rsp,0,sizeof(lte_irat_plmn_srch_rsp_s));
  plmn_srch_rsp->srch_done   = rrc_csp_int_data.rrc_rr_plmn_srch_cnf.srch_done;
  plmn_srch_rsp->hplmn_found = rrc_csp_int_data.rrc_rr_plmn_srch_cnf.hplmn_found;

  if(rrc_csp_int_data.bplmn_fnd_list_wr_index == 0)
  {
    WRRC_MSG0_HIGH("LTOW:BPLMN: no PLMNs found yet.");
  }
  else
  {
    WRRC_MSG0_HIGH("LTOW:BPLMN: following PLMNs have been fnd till now");
    WRRC_MSG0_HIGH("-----------------------------");
  }

  for(i=0; i<rrc_csp_int_data.bplmn_fnd_list_wr_index; ++i)
  {
    plmn_srch_rsp->available_plmn_list.info[i].plmn_service_capability
        = rrc_csp_int_data.rrc_rr_plmn_srch_cnf.available_plmn_list.info[i].plmn_service_capability;
    plmn_srch_rsp->available_plmn_list.info[i].plmn
        = rrc_csp_int_data.rrc_rr_plmn_srch_cnf.available_plmn_list.info[i].plmn;
#ifdef FEATURE_FEMTO_CSG    
    plmn_srch_rsp->available_plmn_list.info[i].csg_info.csg_id
        = rrc_csp_int_data.rrc_rr_plmn_srch_cnf.available_plmn_list.info[i].csg_info.csg_id;
    plmn_srch_rsp->available_plmn_list.info[i].csg_info.hybrid_cell
        = rrc_csp_int_data.rrc_rr_plmn_srch_cnf.available_plmn_list.info[i].csg_info.hybrid_cell;

    WRRC_MSG2_HIGH("CSG: CSG ID in srch resp %d, is_hybrid : %d", plmn_srch_rsp->available_plmn_list.info[i].csg_info.csg_id,plmn_srch_rsp->available_plmn_list.info[i].csg_info.hybrid_cell);

#endif
    plmn_srch_rsp->available_plmn_list.info[i].rat
        = rrc_csp_int_data.rrc_rr_plmn_srch_cnf.available_plmn_list.info[i].rat;
    plmn_srch_rsp->available_plmn_list.info[i].signal_quality
        = rrc_csp_int_data.rrc_rr_plmn_srch_cnf.available_plmn_list.info[i].signal_quality;
    WRRC_MSG0_HIGH("signal strength >= -95db is considered as SYS_SIGNAL_QUALITY_HIGH");        
    plmn_srch_rsp->available_plmn_list.info[i].signal_strength
        = rrc_csp_int_data.rrc_rr_plmn_srch_cnf.available_plmn_list.info[i].signal_strength;
    plmn_srch_rsp->available_plmn_list.info[i].list_category = SYS_DETAILED_PLMN_LIST_CATEGORY_OTHER;
    plmn_srch_rsp->available_plmn_list.info[i].plmn_forbidden = FALSE;
    nas_to_rrc_plmn_id = mmumts_convert_nas_plmn_id_to_rrc_plmn_id(plmn_srch_rsp->available_plmn_list.info[i].plmn);

    WRRC_MSG2_HIGH("BPLMN: plmns in list PLMN %d-%d", RRC_CSP_GET_INT_MCC(nas_to_rrc_plmn_id),
                                                RRC_CSP_GET_INT_MNC(nas_to_rrc_plmn_id));
  }


  plmn_srch_rsp->available_plmn_list.length = rrc_csp_int_data.bplmn_fnd_list_wr_index;

  /*Populate WCDMA detected frequency list to LTE*/
  plmn_srch_rsp->detected_frequency_list.num_freqs = 0;

#ifdef FEATURE_FEMTO_CSG
  plmn_srch_rsp->detected_csg_cell_list.num_cells = 0;
#endif
  if(rrc_csp_int_data.rrc_rr_plmn_srch_cnf.srch_done)
  {
    for(i=0;i<rrc_csp_int_data.detected_frequency_list.num_freqs && i < LTE_IRAT_MAX_DETECTED_FREQ;i++)
    {
      if(rrc_csp_int_data.detected_frequency_list.freq[i].rat == SYS_RAT_UMTS_RADIO_ACCESS)
      {
        plmn_srch_rsp->detected_frequency_list.freq[plmn_srch_rsp->detected_frequency_list.num_freqs++] = 
          rrc_csp_int_data.detected_frequency_list.freq[i];
      }
    }
#ifdef FEATURE_FEMTO_CSG
    if(rrc_csp_int_data.csg_asf_srch_in_progress)
    {
      for(i=0;i<rrc_csp_int_data.temp_csg_list.num_entries; i++)
      {
        plmn_srch_rsp->detected_csg_cell_list.cell[i].rat = SYS_RAT_UMTS_RADIO_ACCESS;
        plmn_srch_rsp->detected_csg_cell_list.cell[i].rat_u.wcell.psc =
          rrc_csp_int_data.temp_csg_list.csg_cell_info[i].csg_cell_l1_info.rat_u.wcell.psc;

        plmn_srch_rsp->detected_csg_cell_list.cell[i].rat_u.wcell.uarfcn =
          rrc_csp_int_data.temp_csg_list.csg_cell_info[i].csg_cell_l1_info.rat_u.wcell.freq;

        plmn_srch_rsp->detected_csg_cell_list.cell[i].rat_u.wcell.timing_present = TRUE;

        plmn_srch_rsp->detected_csg_cell_list.cell[i].rat_u.wcell.pn_pos =
          rrc_csp_int_data.temp_csg_list.csg_cell_info[i].csg_cell_l1_info.rat_u.wcell.pn_pos;

        plmn_srch_rsp->detected_csg_cell_list.cell[i].rat_u.wcell.ecno_2x =
			rrc_csp_int_data.temp_csg_list.csg_cell_info[i].csg_cell_l1_info.rat_u.wcell.ecio_2x;

        plmn_srch_rsp->detected_csg_cell_list.cell[i].rat_u.wcell.rscp =
          rrc_csp_int_data.temp_csg_list.csg_cell_info[i].csg_cell_l1_info.rat_u.wcell.rscp;

        plmn_srch_rsp->detected_csg_cell_list.cell[i].rat_u.wcell.q_rx_lev_min_actual =
          rrc_csp_int_data.temp_csg_list.csg_cell_info[i].csg_cell_l1_info.rat_u.wcell.q_rxlevmin;

        plmn_srch_rsp->detected_csg_cell_list.cell[i].rat_u.wcell.p_max =
			rrc_csp_int_data.temp_csg_list.csg_cell_info[i].csg_cell_l1_info.rat_u.wcell.max_tx_pwr;

        plmn_srch_rsp->detected_csg_cell_list.cell[i].rat_u.wcell.q_qual_min =
          rrc_csp_int_data.temp_csg_list.csg_cell_info[i].csg_cell_l1_info.rat_u.wcell.q_qualmin;
      }
      plmn_srch_rsp->detected_csg_cell_list.num_cells = rrc_csp_int_data.temp_csg_list.num_entries;
    }
#endif
  }

  plmn_srch_rsp->partial_srch = send_partial_results;

  rrc_send_lte_cmd(&plmn_srch_rsp->msg_hdr,WCDMA_RRC_LTE_PLMN_SRCH_RSP,sizeof(lte_irat_plmn_srch_rsp_s));

  rrc_free(plmn_srch_rsp);

  WRRC_MSG0_HIGH("LTOW:Sent WCDMA_RRC_LTE_PLMN_SRCH_RSP to LTE RRC");

  if(send_partial_results != TRUE)
  {
    if(rrc_csp_int_data.rrc_rr_plmn_srch_cnf.srch_done)
    {
      rrc_csp_int_data.bplmn_new_srch = TRUE;

      if(!rrc_csp_int_data.rrc_rr_plmn_srch_cnf.hplmn_found)
      {
        rrccsp_check_and_start_plmn_list_full_freq_scan_timer();
      }
#ifdef FEATURE_FEMTO_CSG
      if(rrc_csp_int_data.csg_asf_srch_in_progress)
      {
        bplmn_end_event.bplmn_end_reason = RRC_BPLMN_COMPLETED;
        event_report_payload(EVENT_ASF_SCAN_END, sizeof(bplmn_end_event),
                       (void *)&bplmn_end_event);
      }
#endif
      /* Invalidate entities in RRC CSP Internal data structure */
      rrc_csp_init_int_data();
    }
  
    rrc_csp_int_data.bplmn_srch_cnf = TRUE;
  }

}

/*===========================================================================

FUNCTION          RRCCSP_SEND_LTE_INTERRAT_REDIRECTION_ABORT_RSP

DESCRIPTION       This function is responsible for sending
                  WCDMA_RRC_LTE_ABORT_REDIR_RSP to LTE RRC.

DEPENDENCIES
                  None.

RETURN VALUE
                  None.

SIDE EFFECTS      None.
===========================================================================*/
void rrccsp_send_lte_interrat_redirection_abort_rsp
(
  void
)
{

  wcdma_rrc_lte_abort_redir_rsp_type abort_redir_rsp;
#ifdef FEATURE_DUAL_SIM
  /* CSFB call is a failure hence the lock needs to be exchanged with IRAT client if TRM exchange
     was success earlier */   
  rrc_check_and_perform_trm_exchange();
  rrc_release_lock();
#endif
  rrc_send_lte_cmd(&abort_redir_rsp.msg_hdr,WCDMA_RRC_LTE_ABORT_REDIR_RSP,sizeof(wcdma_rrc_lte_abort_redir_rsp_type));
  WRRC_MSG0_HIGH("LTOW: WCDMA_RRC_LTE_ABORT_REDIR_RSP sent to LTE RRC");
}

/*===========================================================================

FUNCTION          RRCCSP_SEND_LTE_INTERRAT_REDIRECTION_FAILED_RSP

DESCRIPTION       This function is responsible for sending
                  WCDMA_RRC_LTE_REDIR_FAILED_RSP to LTE RRC.

DEPENDENCIES
                  None.

RETURN VALUE
                  None.

SIDE EFFECTS      None.
===========================================================================*/
void rrccsp_send_lte_interrat_redirection_failed_rsp
(
  void
)
{
  wcdma_rrc_lte_redir_failed_rsp_type redir_failed_rsp;
#ifdef FEATURE_DUAL_SIM
  /* CSFB call is a failure hence the lock needs to be exchanged with IRAT client if TRM exchange
     was success earlier */   
  rrc_check_and_perform_trm_exchange();
  rrc_release_lock();
#endif
  rrc_send_lte_cmd(&redir_failed_rsp.msg_hdr,WCDMA_RRC_LTE_REDIR_FAILED_RSP,sizeof(wcdma_rrc_lte_redir_failed_rsp_type));
  WRRC_MSG0_HIGH("LTOW: WCDMA_RRC_LTE_REDIR_FAILED_RSP sent to LTE RRC");

}
/*===========================================================================

FUNCTION          RRCCSP_HANDLE_RESELECTION_REQ_FROM_LTE

DESCRIPTION       This function process the reselection request from LTE

DEPENDENCIES      None

RETURN VALUE      Next CSP Substate

SIDE EFFECTS      None
===========================================================================*/
rrc_csp_substate_e_type rrccsp_handle_reselection_req_from_lte
(
  rrc_cmd_type *cmd_ptr
)
{
  rrc_csp_substate_e_type next_substate = rrc_csp_substate;
  wcdma_rrc_lte_resel_req_type *lte_resel_req = 
    &cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.wcdma_rrc_lte_resel_req;

#ifdef FEATURE_DUAL_SIM
  rrc_csp_freq_scan_e_type type_freq_scan;
#endif

  WRRC_MSG0_HIGH("LTOW:Processing WCDMA_RRC_LTE_RESEL_REQ ");
  rrc_csp_int_data.curr_req_plmn.plmn_id =
    mmumts_convert_nas_plmn_id_to_rrc_plmn_id(lte_resel_req->requested_PLMN);
  rrc_csp_int_data.curr_acq_entry.freq =
    (rrc_freq_type)(lte_resel_req->UARFCN);
  rrc_csp_int_data.curr_acq_entry.scr_code =
    (rrc_scr_code_type)(lte_resel_req->scrambling_code);


  rrc_csp_int_data.rat_pri_list_info = lte_resel_req->rat_pri_list_info;
  rrcmcm_update_mode_capability(&rrc_csp_int_data.rat_pri_list_info);
  rrc_csp_int_data.band_pref = rrc_extract_gw_band_pref_from_rat_pri_list(&rrc_csp_int_data.rat_pri_list_info);

  rrccsp_update_band_preference();
  rr_rrc_set_band_pref_internal(rrc_csp_int_data.band_pref);

#ifdef FEATURE_WCDMA_ABSOLUTE_PRIORITY
  rrcmeas_update_dedicated_priority_info_from_irat_req(&lte_resel_req->dedicated_priority_info,
                                rrc_csp_int_data.curr_req_plmn.plmn_id);

#endif

  rrc_csp_int_data.curr_scan = RRC_CSP_GSM_TO_WCDMA_CELL_RESELECTION_SCAN;
  rrc_csp_int_data.network_select_mode = lte_resel_req->network_select_mode;

  WRRC_MSG1_HIGH("LTOW reselection : N/W sel mode %d", rrc_csp_int_data.network_select_mode);

  if((rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED) ||
     (rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED_ROUTINE_ACQUISITION))
  {
    rrc_csp_int_data.curr_req_plmn.plmn_type = RRC_GSM_MAP_ANY_PLMN_REQ;
    rrc_csp_int_data.curr_type_acq           = RRC_CSP_ANY_PLMN;
    rrc_csp_curr_select_data.acq_type        = RRC_CSP_ANY_PLMN;
  }
  else
  {
    rrc_csp_int_data.curr_req_plmn.plmn_type = RRC_GSM_MAP_SPECIFIC_PLMN_REQ;
    rrc_csp_int_data.curr_type_acq           = RRC_CSP_SPEC_PLMN;
    rrc_csp_curr_select_data.acq_type        = RRC_CSP_SPEC_PLMN;
#ifdef FEATURE_FEMTO_CSG
    /*Manual CSG network select mode. WRRC should camp only on CSG cell which LRRC passes*/
    if(rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_MANUAL_CSG)
    {
      rrc_csp_int_data.curr_req_plmn.csg_id = lte_resel_req->nas_csg_id;
    }
    else
    {
      rrc_csp_int_data.curr_req_plmn.csg_id = SYS_CSG_ID_INVALID;
    }
#endif
  }

#ifdef FEATURE_FEMTO_CSG
  /* copy LTE macro information for finger printing */
  rrc_csp_int_data.fp_macro.freq = lte_resel_req->serving_cell_info.frequency;
  rrc_csp_int_data.fp_macro.pci = lte_resel_req->serving_cell_info.phy_cell_id;
  rrc_csp_int_data.fp_macro.cell_id = lte_resel_req->serving_cell_info.cell_identity;
  rrc_csp_int_data.fp_macro.plmn = mmumts_convert_nas_plmn_id_to_rrc_plmn_id(lte_resel_req->serving_cell_info.plmn);
  rrc_csp_int_data.fp_macro.csg_id = lte_resel_req->serving_cell_info.csg_id;
  MSG_HIGH("CSG: FP: LTE macro info frequency %d, pci %d, cell_id %d",
                 rrc_csp_int_data.fp_macro.freq,
                 rrc_csp_int_data.fp_macro.pci,
                 rrc_csp_int_data.fp_macro.cell_id);
  
  /*Only LTE macro cells should be fingerprinted*/
  if((rrc_csp_int_data.fp_macro.freq)&&(lte_resel_req->serving_cell_info.csg_id == SYS_CSG_ID_INVALID))
  {
    rrc_csp_int_data.last_csg_rat = RRC_CSG_LTE;
  }
  else
  {
    rrc_csp_int_data.last_csg_rat = RRC_CSG_NONE;
  }
  rrc_csp_int_data.csg_resel = lte_resel_req->csg_resel;
#endif
  rrc_csp_int_data.rsp_to_rr = SEND_GTOW_RESEL_REJECT;
  rrc_csp_int_data.interrat_type = RRC_CSP_INTERRAT_LTE;

  rrc_csp_int_data.acq_mode = L1_WCDMA_INTER_S_RESEL_ACQ;

  if(lte_resel_req->PN_Offset == 0xFFFF)
  {
    rrc_csp_int_data.acq_type = L1_WCDMA_FREQ_SCR;
  }
  else
  {
    rrc_csp_int_data.pn_pos = lte_resel_req->PN_Offset;
    rrc_csp_int_data.acq_type = L1_WCDMA_FREQ_SCR_POS;
  }

  if(lte_resel_req->diversity == DIVERSITY_ON)
  {
    rrc_csp_int_data.sttd_indicator_present = TRUE;
    rrc_csp_int_data.sttd_indicator = TRUE;
  }
  else if(lte_resel_req->diversity == DIVERSITY_OFF)
  {
    rrc_csp_int_data.sttd_indicator_present = TRUE;
    rrc_csp_int_data.sttd_indicator = FALSE;
  }
  else
  {
    rrc_csp_int_data.sttd_indicator_present = FALSE;
    rrc_csp_int_data.sttd_indicator = FALSE;
  }

#ifdef FEATURE_DUAL_SIM
  /* Acquire lock before starting ACQ for LTOW reselection */
  rrc_start_lock_wait_timer(RRCTMR_WRM_LOCK_WAIT_TIMER_FOR_INTERRAT_IN_MS,TRUE);
  if(rrc_csp_wait_for_wrm_lock(&type_freq_scan) == RRCCSP_WT_STOP_MODE_CHANGE_CNF)
  {
    rrctmr_stop_timer(RRCTMR_WRM_LOCK_TIMER);
    return (RRCCSP_WT_STOP_MODE_CHANGE_CNF);
  }
  rrctmr_stop_timer(RRCTMR_WRM_LOCK_TIMER);
#endif


#ifdef FEATURE_GAN_3G_ROVE_OUT_ONLY
  #error code not present
#endif
  /* Send CPHY_ACQ_REQ to L1 and wait for the CNF */
  rrc_csp_send_l1_cmd(RRC_PROCEDURE_CSP, CPHY_ACQ_REQ, &rrc_csp_int_data.curr_acq_entry);
  MSG_MED("L1 cmd 0x%x sent", CPHY_ACQ_REQ, 0, 0);

  /* Set the current band appropriately as it is used by SIB procedure 
   * after reading MIB to validate the MCC and Current Band Combination
   */
  rrc_csp_curr_select_data.current_band = rrc_get_frequency_band(
                                            rrc_csp_int_data.curr_acq_entry.freq,
                                            rrc_csp_int_data.curr_req_plmn.plmn_id);

  WRRC_MSG2_HIGH("Setting current_band to %d. PLMN-MCC sent by GSM %d", 
                            rrc_csp_curr_select_data.current_band, 
                            RRC_CSP_GET_INT_MCC(rrc_csp_int_data.curr_req_plmn.plmn_id));
 

  /* Start waiting for Acquisition Confirmation */
  next_substate = RRCCSP_CELL_SEL_WT_ACQ;

  return next_substate;
}


/*===========================================================================

FUNCTION          RRCCSP_HANDLE_PLMN_SRCH_REQ_FROM_LTE

DESCRIPTION       This function process the plmn search request from LTE

DEPENDENCIES      None

RETURN VALUE      Next CSP Substate

SIDE EFFECTS      None
===========================================================================*/
rrc_csp_substate_e_type rrccsp_handle_plmn_srch_req_from_lte
(
  rrc_cmd_type *cmd_ptr
)
{
  rrc_csp_substate_e_type next_substate = rrc_csp_substate;
  boolean process_plmn_srch_req = TRUE;
  lte_irat_plmn_srch_req_s *plmn_list_req = &cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.wcmd_rrc_lte_plmn_srch_req;

  WRRC_MSG0_HIGH("LTOW:Processing WCDMA_RRC_LTE_PLMN_SRCH_REQ ");

  if(!rrc_csp_int_data.bplmn_srch_tmr_expired)
  {
    WRRC_MSG0_ERROR("LTOW: BPLMN ERR:plmn srch rcvd whn bplmn_srch_tmr_exprd=FALSE");
    rrctmr_stop_timer(RRCTMR_BPLMN_SRCH_TIMER);
    rrc_csp_int_data.bplmn_srch_tmr_expired = TRUE;
    process_plmn_srch_req = FALSE;
  }
  else if((plmn_list_req->network_select_mode != SYS_NETWORK_SELECTION_MODE_AUTOMATIC) &&
            (plmn_list_req->network_select_mode != SYS_NETWORK_SELECTION_MODE_MANUAL))
  {
    WRRC_MSG0_ERROR("LTOW: Invalid N/W select mode");
    process_plmn_srch_req = FALSE;
  }
  else if((rrc_csp_int_data.bplmn_new_srch) &&
            (plmn_list_req->network_select_mode == SYS_NETWORK_SELECTION_MODE_AUTOMATIC) &&
             (plmn_list_req->num_plmns == 0))
  {
    WRRC_MSG0_ERROR("LTOW: Number of plmns in automatic LTOW plmn request is zero");
    process_plmn_srch_req = FALSE;
  }


  rrc_csp_int_data.bplmn_interrat_type = RRC_CSP_INTERRAT_LTE;

  rrc_csp_int_data.service_search_bgnd = plmn_list_req->search_type;
  WRRC_MSG1_HIGH("SSB: Filling service_search %d",rrc_csp_int_data.service_search_bgnd);

  if(!process_plmn_srch_req)
  {
    /* stop WCDMA stack */
    rrc_csp_int_data.bplmn_new_srch          = FALSE;
    rrc_csp_int_data.bplmn_srch_cnf          = TRUE;
    rrc_csp_int_data.bplmn_fnd_list_wr_index = 0;
    rrc_csp_int_data.rrc_rr_plmn_srch_cnf.srch_done   = FALSE;
    rrc_csp_int_data.rrc_rr_plmn_srch_cnf.hplmn_found = FALSE;
    rrc_csp_int_data.curr_scan = RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN;

    rrccsp_send_mode_change_req_to_mcm(RRC_MODE_INACTIVE);
    next_substate = RRCCSP_WT_STOP_MODE_CHANGE_CNF;
    return(next_substate);
  }

  /* if it is a new search then store the requested plmns */
  if(rrc_csp_int_data.bplmn_new_srch)
  {
    /* Get the number of plmns requested */
    rrc_csp_int_data.bplmn_num_req = plmn_list_req->num_plmns;
  
    rrc_csp_int_data.bplmn_scan_scope  = plmn_list_req->scan_scope;
    WRRC_MSG1_HIGH("Inter RAT PLMN Srch_Req Scan Scope: %d", rrc_csp_int_data.bplmn_scan_scope);
    rrc_csp_int_data.bplmn_req_list_rd_index = 0;
    rrc_csp_int_data.bplmn_fnd_list_wr_index = 0;
    rrc_csp_int_data.network_select_mode = plmn_list_req->network_select_mode;
    rrc_csp_int_data.bplmn_current_band_initialized = FALSE;
  
    rrc_csp_int_data.bplmn_bgnd_mib_rd_cnt  = 0;
    rrc_csp_int_data.bplmn_bgnd_mib_rd_freq = 0;
    WRRC_MSG0_HIGH("XTOW_BPLMN:Initialize ACQ SUCC PSC info.");
    rrc_csp_int_data.bplmn_acq_succ_scr_code = 8192;
    rrc_csp_int_data.bplmn_acq_succ_freq = 0;
    rrc_csp_int_data.bplmn_acq_succ_pn_pos = 0xFFFFFFFF;
    rrc_csp_int_data.bplmn_acq_succ_scr_code_det = 0;
    rrc_csp_int_data.bplmn_acq_succ_curr_acq_count = 0;
#ifdef LTE_BAND_NUM
    rrc_csp_int_data.band_pref = plmn_list_req->band_pref.chgwt_band_cap;
#else
    rrc_csp_int_data.band_pref = plmn_list_req->band_pref;
#endif
    rrccsp_update_band_preference();

    if(rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_AUTOMATIC)
    {
      uint8 plmns_idx;
      WRRC_MSG0_HIGH("LTOW:BPLMN:ScanType=RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN");
      WRRC_MSG0_HIGH("LTOW: BPLMN:PLMNs in NAS request list:");
      for(plmns_idx=0; plmns_idx<rrc_csp_int_data.bplmn_num_req; ++plmns_idx)
      {
        rrc_csp_int_data.bplmn_req_list[plmns_idx].plmn_id =
            mmumts_convert_nas_plmn_id_to_rrc_plmn_id(plmn_list_req->plmn[plmns_idx]);
        rrc_csp_int_data.bplmn_req_list[plmns_idx].plmn_type = RRC_GSM_MAP_SPECIFIC_PLMN_REQ;
        
        WRRC_MSG2_HIGH("%d-%d", RRC_CSP_GET_INT_MCC(rrc_csp_int_data.bplmn_req_list[plmns_idx].plmn_id),
                          RRC_CSP_GET_INT_MNC(rrc_csp_int_data.bplmn_req_list[plmns_idx].plmn_id)
                          );
      }
#ifdef FEATURE_FEMTO_CSG
      /*For ASF, service search will be set to CSG*/
      if(rrc_csp_int_data.service_search_bgnd == SYS_SERVICE_SEARCH_CSG)
      {
        rrc_csp_int_data.csg_asf_srch_in_progress = TRUE;
        rrc_csp_int_data.lte_macro_asf.freq = plmn_list_req->serving_cell_info.frequency;
        rrc_csp_int_data.lte_macro_asf.pci = plmn_list_req->serving_cell_info.phy_cell_id;
        rrc_csp_int_data.lte_macro_asf.cell_id = plmn_list_req->serving_cell_info.cell_identity;
        rrc_csp_int_data.lte_macro_asf.plmn = mmumts_convert_nas_plmn_id_to_rrc_plmn_id(plmn_list_req->serving_cell_info.plmn);
        MSG_HIGH("CSG: FP: ASF LTE macro info frequency %d, pci %d, cell_id %d",
                      rrc_csp_int_data.lte_macro_asf.freq,
                      rrc_csp_int_data.lte_macro_asf.pci,
                      rrc_csp_int_data.lte_macro_asf.cell_id);

        rrccsp_log_macro_fp_info(W_ASF_RAT_LTE);

      }
#endif
      rrc_csp_int_data.curr_scan               = RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN;
      rrc_csp_int_data.curr_req_plmn.plmn_type = RRC_GSM_MAP_SPECIFIC_PLMN_REQ;
      rrc_csp_int_data.curr_req_plmn.plmn_id   =
          rrc_csp_int_data.bplmn_req_list[rrc_csp_int_data.bplmn_req_list_rd_index].plmn_id;
    }
    else if(rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_MANUAL)
    {
      WRRC_MSG0_HIGH("LTOW:BPLMN:ScanType = RRC_CSP_GTOW_BPLMN_MANUAL_SCAN");
      rrc_csp_int_data.curr_scan               = RRC_CSP_GTOW_BPLMN_MANUAL_SCAN;
      rrc_csp_int_data.curr_req_plmn.plmn_type = RRC_GSM_MAP_ANY_PLMN_REQ;
#ifdef FEATURE_FEMTO_CSG
      if(rrc_csp_int_data.service_search_bgnd == SYS_SERVICE_SEARCH_CSG)
      {
        rrc_csp_int_data.fp_macro.freq = plmn_list_req->serving_cell_info.frequency;
        rrc_csp_int_data.fp_macro.pci = plmn_list_req->serving_cell_info.phy_cell_id;
        rrc_csp_int_data.fp_macro.cell_id = plmn_list_req->serving_cell_info.cell_identity;
        rrc_csp_int_data.fp_macro.plmn = mmumts_convert_nas_plmn_id_to_rrc_plmn_id(plmn_list_req->serving_cell_info.plmn);
        MSG_HIGH("CSG: FP: LTE macro info frequency %d, pci %d, cell_id %d",
                       rrc_csp_int_data.fp_macro.freq,
                       rrc_csp_int_data.fp_macro.pci,
                       rrc_csp_int_data.fp_macro.cell_id);

        /*Only LTE macro cells should be fingerprinted*/
        if((rrc_csp_int_data.fp_macro.freq)&&(plmn_list_req->serving_cell_info.csg_id == SYS_CSG_ID_INVALID))
        {
          rrc_csp_int_data.last_csg_rat = RRC_CSG_LTE;
        }
        else
        {
          rrc_csp_int_data.last_csg_rat = RRC_CSG_NONE;
        }

      }
#endif
    }
    rrc_csp_int_data.umts_chls_from_gsm.size = 0;
    rrc_csp_int_data.detected_frequency_list.num_freqs = plmn_list_req->detected_frequency_list.num_freqs;
    WCDMA_MEMCPY(rrc_csp_int_data.detected_frequency_list.freq,
                 LTE_IRAT_MAX_DETECTED_FREQ * sizeof(detected_frequency_type),
                 plmn_list_req->detected_frequency_list.freq,
                 LTE_IRAT_MAX_DETECTED_FREQ * sizeof(detected_frequency_type));
  }

  WRRC_MSG0_HIGH("LTOW:BPLMN: RRCTMR_BPLMN_SEARCH_TIMER Started ");
  /*Timer overheads taken from GTOW*/
#ifdef FEATURE_DUAL_SIM
  if((WCDMA_RRC_IDLE_FEATURES(RRC_ACQ_SPLIT_DURING_BPLMN)) && wcdma_is_ue_in_dual_standby)
  {
    rrctmr_start_timer(RRCTMR_BPLMN_SRCH_TIMER, plmn_list_req->timer_val - XTOW_BPLMN_SEARCH_OVERHEAD_TIMER_WITH_SPLIT_ACQ_IN_MS);
    xtow_bplmn_search_overhead_timer = XTOW_BPLMN_SEARCH_OVERHEAD_TIMER_WITH_SPLIT_ACQ_IN_MS;
    rrc_csp_int_data.bplmn_srch_tmr_expired   = FALSE;
  }
  else
#endif
  if(plmn_list_req->timer_val > 500)
  {
    /* Overhead is considered as 220 because max ACQ time is 180 msec + start/stop time is 40 msec*/
    rrctmr_start_timer(RRCTMR_BPLMN_SRCH_TIMER, plmn_list_req->timer_val - 220);
    xtow_bplmn_search_overhead_timer = 220;
    rrc_csp_int_data.bplmn_srch_tmr_expired   = FALSE;
  }
  else
  {
    /* 40msec = W start/stop delay */
    rrctmr_start_timer(RRCTMR_BPLMN_SRCH_TIMER, plmn_list_req->timer_val - 40);
    xtow_bplmn_search_overhead_timer = 40;
    rrc_csp_int_data.bplmn_srch_tmr_expired   = FALSE;
  }

  rrc_csp_int_data.bplmn_sib_try_next_best_cell     = FALSE;
  rrc_csp_int_data.bplmn_srch_cnf                   = TRUE;
  rrc_csp_int_data.bplmn_acq_status                 = FALSE;
  rrc_csp_int_data.rrc_rr_plmn_srch_cnf.srch_done   = TRUE;
  rrc_csp_int_data.rrc_rr_plmn_srch_cnf.hplmn_found = FALSE;

  next_substate = rrccsp_no_cell_sel_bplmn_srch_req();

  return next_substate;
}

/*===========================================================================

FUNCTION          RRCCSP_HANDLE_REDIRECTION_REQ_FROM_LTE

DESCRIPTION       This function process the redirection request from LTE

DEPENDENCIES      None

RETURN VALUE      Next CSP Substate

SIDE EFFECTS      None
===========================================================================*/
rrc_csp_substate_e_type rrccsp_handle_redirection_req_from_lte
(
  rrc_cmd_type *cmd_ptr
)
{
  boolean send_reject = FALSE;
  rrc_csp_freq_scan_e_type  type_freq_scan;
  rrc_csp_substate_e_type next_substate = rrc_csp_substate;
  wcdma_rrc_lte_redir_req_type *lte_redir_req = 
    &cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.wcdma_rrc_lte_redir_req;
  uint8 i,j;
  uint8 num_of_target_frequencies = 0;
  boolean update_list = FALSE;

  WRRC_MSG0_HIGH("LTOW:Processing WCDMA_RRC_LTE_REDIR_REQ ");
  rrc_csp_int_data.curr_req_plmn.plmn_id =
    mmumts_convert_nas_plmn_id_to_rrc_plmn_id(lte_redir_req->PLMN);

  rrc_csp_int_data.rat_pri_list_info = lte_redir_req->rat_pri_list_info;
  rrcmcm_update_mode_capability(&rrc_csp_int_data.rat_pri_list_info);
  rrc_csp_int_data.band_pref = rrc_extract_gw_band_pref_from_rat_pri_list(&rrc_csp_int_data.rat_pri_list_info);

  rrccsp_update_band_preference();
  rr_rrc_set_band_pref_internal(rrc_csp_int_data.band_pref);

  rrc_csp_int_data.first_acq_on_redirected_freq = FALSE;
#ifdef FEATURE_WCDMA_ABSOLUTE_PRIORITY
  rrcmeas_update_dedicated_priority_info_from_irat_req(&lte_redir_req->priority_info,rrc_csp_int_data.curr_req_plmn.plmn_id);
#endif

  /* Set the current scan type to GSM_REDIRECTION_SCAN */
  rrc_csp_int_data.curr_scan = RRC_CSP_GSM_TO_WCDMA_REDIRECTION_SCAN;
  rrc_csp_int_data.network_select_mode = lte_redir_req->network_select_mode;
  rrc_csp_int_data.interrat_type = RRC_CSP_INTERRAT_LTE;


  WRRC_MSG1_HIGH("LTOW Redirection: N/W sel mode %d", rrc_csp_int_data.network_select_mode);

  if((rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED) ||
     (rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED_ROUTINE_ACQUISITION))
  {
    rrc_csp_int_data.curr_req_plmn.plmn_type = RRC_GSM_MAP_ANY_PLMN_REQ;
    rrc_csp_int_data.curr_type_acq           = RRC_CSP_ANY_PLMN;
    rrc_csp_curr_select_data.acq_type        = RRC_CSP_ANY_PLMN;
  }
  else
  {
    rrc_csp_int_data.curr_req_plmn.plmn_type = RRC_GSM_MAP_SPECIFIC_PLMN_REQ;
    rrc_csp_int_data.curr_type_acq           = RRC_CSP_SPEC_PLMN;
    rrc_csp_curr_select_data.acq_type        = RRC_CSP_SPEC_PLMN;

#ifdef FEATURE_FEMTO_CSG
    /*Manual CSG network select mode. WRRC should camp only on CSG cell which LRRC passes*/
    if(rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_MANUAL_CSG)
    {
      rrc_csp_int_data.curr_req_plmn.csg_id = lte_redir_req->nas_csg_id;
    }
    else
    {
      rrc_csp_int_data.curr_req_plmn.csg_id = SYS_CSG_ID_INVALID;
    }
#endif
  }

  WRRC_MSG2_HIGH("LTOW Redirection: for PLMN MCC %d MNC %d", 
                              RRC_CSP_GET_INT_MCC(rrc_csp_int_data.curr_req_plmn.plmn_id), 
                              RRC_CSP_GET_INT_MNC(rrc_csp_int_data.curr_req_plmn.plmn_id));

  if(lte_redir_req->fdd_target_info.num_of_frequencies > WCDMA_RRC_LTE_MAX_UTRAN_FDD_FREQ)
  {
    send_reject = TRUE;
  }

  /* Reset destination frequency flag. */
  rrc_csp_int_data.dest_freq_present = FALSE;

  WRRC_MSG0_HIGH("LTOW: FDD target cell list given by LTE-RRC .");
  for(i = 0; i < lte_redir_req->fdd_target_info.num_of_frequencies && !send_reject; i++)
  {
    update_list = FALSE;
    if(is_freq_in_overlapping_850_and_800_bands(lte_redir_req->fdd_target_info.fdd_cell_list[i].uarfcn))
    {
      if((TRUE == rrccsp_is_mcc_and_850_800_supported_band_comb_valid(
                            lte_redir_req->fdd_target_info.fdd_cell_list[i].uarfcn, 
                            rrc_csp_int_data.curr_req_plmn.plmn_id, 
                            W_UARFCN_FROM_GSM_NBR_LIST
                            , FALSE
                            )
         ))
      {
        update_list = TRUE;
      }
    }
    else if(rrccsp_is_supported_band(rrc_get_frequency_band((rrc_freq_type)lte_redir_req->fdd_target_info.fdd_cell_list[i].uarfcn, rrc_csp_int_data.curr_req_plmn.plmn_id)))
    {
      update_list = TRUE;
    }

    if(update_list)
    {
      /* Try ACQ attemps on the redirected freq before trying on the neighbour freqs. */
      if(i == 0)
      {
        rrc_csp_int_data.dest_freq = lte_redir_req->fdd_target_info.fdd_cell_list[i].uarfcn;
        rrc_csp_int_data.dest_freq_present = TRUE;
        WRRC_MSG1_HIGH("LTOW: Redirected freq %d",rrc_csp_int_data.dest_freq);
      }
      /* Add neighbour freq entries to target fdd cell list to perform list scan on them. */
      else
      {
        rrc_csp_int_data.target_fdd_cell_list.fdd_cell_list[num_of_target_frequencies].uarfcn = lte_redir_req->fdd_target_info.fdd_cell_list[i].uarfcn;
        rrc_csp_int_data.target_fdd_cell_list.fdd_cell_list[num_of_target_frequencies].num_of_cells = lte_redir_req->fdd_target_info.fdd_cell_list[i].num_of_cells;

        if(lte_redir_req->fdd_target_info.fdd_cell_list[i].num_of_cells > WCDMA_RRC_LTE_MAX_UTRAN_FDD_CELLS_PER_FREQ)
        {
          WRRC_MSG0_ERROR("LTOW: Invalid number of cells in redirection req. .");
          send_reject = TRUE;
          break;
        }
        for(j = 0; j< lte_redir_req->fdd_target_info.fdd_cell_list[i].num_of_cells; j++)
        {
          rrc_csp_int_data.target_fdd_cell_list.fdd_cell_list[num_of_target_frequencies].cell_list[j].scrambling_code = 
               lte_redir_req->fdd_target_info.fdd_cell_list[i].scrambling_code[j];
            WRRC_MSG2_HIGH("LTOW: UARFCN is :%d, scr_code is :%d",
                                  rrc_csp_int_data.target_fdd_cell_list.fdd_cell_list[i].uarfcn,
                                  rrc_csp_int_data.target_fdd_cell_list.fdd_cell_list[i].cell_list[j].scrambling_code);
        }
        num_of_target_frequencies++;
      }
    }
  }

  rrc_csp_int_data.target_fdd_cell_list.num_of_frequencies = num_of_target_frequencies;

  if(!rrc_csp_int_data.dest_freq_present && (rrc_csp_int_data.target_fdd_cell_list.num_of_frequencies < 1))
  {
    WRRC_MSG0_ERROR("LTOW: Target FDD cell list not valid.");
    send_reject = TRUE;
  }

  if(!send_reject)
  {
    rrc_csp_int_data.gtow_redirection_timer_expired = TRUE;
#ifdef FEATURE_3GPP_CSFB
    /*Copy the SIB container from Redirection request*/
    rrccsp_copy_sib_cont_from_redir_req(lte_redir_req);
#endif

    rrccsp_init_first_band_to_be_scanned();

    /* Reset LFS before starting redirection scan */ 
    rrc_csp_curr_select_data.scan_info.list_scan.num_freq = 0;


    if(rrc_csp_start_cell_selection(&rrc_csp_int_data.curr_req_plmn, 
                                    &rrc_csp_int_data.curr_type_acq, 
                                    &rrc_csp_int_data.curr_acq_entry,
                                    &type_freq_scan) 
      == FAILURE)
    {
      /* This is unacceptable since number of target freq are more than 0 */
      ERR_FATAL("LTOW: Returned Failure", type_freq_scan, 0, 0);
    }

#ifdef FEATURE_DUAL_SIM
#ifdef FEATURE_3GPP_CSFB
   /* Request for lock only for non-CSFB. For CSFB lock is already taken in MCM */
    if(!rrc_csfb_call_status)
#endif
    {
      rrc_csp_int_data.shld_acq_be_spltd=TRUE;
      /* Acquire lock before starting ACQ for LTOW redirection */
      rrc_start_lock_wait_timer(RRCTMR_WRM_LOCK_WAIT_TIMER_FOR_INTERRAT_IN_MS,TRUE);
      if(rrc_csp_wait_for_wrm_lock(&type_freq_scan) == RRCCSP_WT_STOP_MODE_CHANGE_CNF)
      {
        rrctmr_stop_timer(RRCTMR_WRM_LOCK_TIMER);
        return (RRCCSP_WT_STOP_MODE_CHANGE_CNF);
      }
    }
#endif


    if((type_freq_scan == RRC_CSP_LIST_SCAN) || (type_freq_scan == RRC_CSP_ACQ_SCAN))
    {
      rrc_csp_send_next_freq_to_l1(&rrc_csp_int_data.curr_acq_entry, type_freq_scan);

      if(type_freq_scan == RRC_CSP_LIST_SCAN)
      {
        next_substate = RRCCSP_CELL_SEL_WT_FREQ_SCAN_CNF;
      }
      else
      {
        next_substate = RRCCSP_CELL_SEL_WT_ACQ;
      }
    }
    else
    {
      /* This is unacceptable since a SUCCESS was returned */
      ERR_FATAL("LTOW: Unexpected scan %d returned", type_freq_scan, 0, 0);
    }
  }
  else
  {
    rrc_csp_int_data.rsp_to_rr = SEND_GTOW_REDIRECTION_REJECT;
    rrccsp_send_mode_change_req_to_mcm(RRC_MODE_INACTIVE);
    next_substate = RRCCSP_WT_STOP_MODE_CHANGE_CNF;
  }
  if(lte_redir_req->fast_redirection)
  {
    /* For now start 1s timer before which ACQ is supposed to be successful.
     * We will restart the timer with a value of 5s once ACQ is successful
     * If ACQ is not successful before expiry of 1s timer control is returned back to LTE
     */
    rrctmr_start_timer(RRCTMR_LTE_TO_WCDMA_REDIR_SRCH_TIMER,
               RRCTMR_LTE_TO_WCDMA_REDIR_SRCH_TIMER_IN_MS);
    rrc_csp_int_data.first_acq_on_redirected_freq = TRUE;
  }
  /* Below is the case when redirection is triggered for CSFB call in absence of GSM neighbours
   * In presence of GSM neighbours fast_redirection flag will be set to TRUE
   */
#ifdef FEATURE_3GPP_CSFB
  else if(rrc_csfb_call_status)
  {
   /* When  WTOL redirection is triggered for CSFB call the redirection search on WCDMA
    * is limited to a configurable value (~25s) to facilitate quick movement back to LTE
    * In adverse radio conditions it was seen that WCDMA search can go beyond 1 min and 
    * though a cell is found finally the call can anyway not be completed 
    */
    rrctmr_start_timer(RRCTMR_LTE_TO_WCDMA_REDIR_SRCH_TIMER,
               RRCTMR_LTE_TO_WCDMA_REDIR_SRCH_TIMER_FOR_CSFB_IN_MS);
  }
#endif

  return next_substate;
}
/*===========================================================================

FUNCTION          RRCCSP_HANDLE_CGI_REQ_FROM_LTE

DESCRIPTION       This function process the cgi request from LTE

DEPENDENCIES      None

RETURN VALUE      Next CSP Substate

SIDE EFFECTS      None
===========================================================================*/
rrc_csp_substate_e_type rrccsp_handle_cgi_req_from_lte
(
  rrc_cmd_type *cmd_ptr
)
{
  rrc_plmn_identity_type      DEFAULT_PLMN_ID;
  sys_rat_pri_list_info_s_type DEFAULT_LTE_IRAT_PRIO_LIST;
  rrc_csp_substate_e_type next_substate = rrc_csp_substate;
  wcdma_rrc_lte_get_cgi_req_type *lte_cgi_req = 
    &cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.wcdma_rrc_lte_cgi_req;

#ifdef FEATURE_DUAL_SIM
  rrc_csp_freq_scan_e_type  type_freq_scan;
#endif

  WRRC_MSG0_HIGH("LTOW:Processing WCDMA_RRC_LTE_GET_CGI_REQ ");
  rrc_csp_int_data.curr_acq_entry.freq =  (rrc_freq_type)(lte_cgi_req->uarfcn);
  rrc_csp_int_data.curr_acq_entry.scr_code =  (rrc_scr_code_type)(lte_cgi_req->scr_code);

  rrc_csp_int_data.curr_scan = RRC_CSP_GSM_TO_WCDMA_CELL_RESELECTION_SCAN;
  rrc_csp_int_data.rsp_to_rr = SEND_GTOW_RESEL_REJECT;
  rrc_csp_int_data.interrat_type = RRC_CSP_INTERRAT_LTE_CGI;

  rrc_csp_int_data.network_select_mode = SYS_NETWORK_SELECTION_MODE_LIMITED;
    rrc_csp_int_data.curr_req_plmn.plmn_type = RRC_GSM_MAP_ANY_PLMN_REQ;
    rrc_csp_int_data.curr_type_acq           = RRC_CSP_ANY_PLMN;
    rrc_csp_curr_select_data.acq_type        = RRC_CSP_ANY_PLMN;

  rrc_csp_int_data.acq_mode = L1_WCDMA_INTER_S_RESEL_ACQ;
  rrc_csp_int_data.acq_type = L1_WCDMA_FREQ_SCR;
  rrc_csp_int_data.cgi_info_included = FALSE;

/* THe below code may not be needed*/
  DEFAULT_PLMN_ID.mcc[0] = 0;
  DEFAULT_PLMN_ID.mcc[1] = 0;
  DEFAULT_PLMN_ID.mcc[2] = 1;
  DEFAULT_PLMN_ID.num_mnc_digits  = 3;
  DEFAULT_PLMN_ID.mnc[0] = 0;
  DEFAULT_PLMN_ID.mnc[1] = 0;
  DEFAULT_PLMN_ID.mnc[2] = 1;
  DEFAULT_LTE_IRAT_PRIO_LIST.num_items = 2;

  DEFAULT_LTE_IRAT_PRIO_LIST.priority_list_info[0].acq_sys_mode = SYS_SYS_MODE_WCDMA;
  DEFAULT_LTE_IRAT_PRIO_LIST.priority_list_info[1].acq_sys_mode = SYS_SYS_MODE_LTE;
#ifdef LTE_BAND_NUM
  DEFAULT_LTE_IRAT_PRIO_LIST.priority_list_info[0].band_cap.chgwt_band_cap = rrccsp_get_sys_wcdma_band_mask();
  SYS_LTE_BAND_MASK_CLR_ALL_BANDS(&(DEFAULT_LTE_IRAT_PRIO_LIST.priority_list_info[1].band_cap.lte_band_cap)); 
  SYS_LTE_BAND_MASK_ADD_BAND(&(DEFAULT_LTE_IRAT_PRIO_LIST.priority_list_info[1].band_cap.lte_band_cap),0x1);
  SYS_LTE_BAND_MASK_ADD_BAND(&(DEFAULT_LTE_IRAT_PRIO_LIST.priority_list_info[1].band_cap.lte_band_cap),0x2);
  SYS_LTE_BAND_MASK_ADD_BAND(&(DEFAULT_LTE_IRAT_PRIO_LIST.priority_list_info[1].band_cap.lte_band_cap),0x4);
  SYS_LTE_BAND_MASK_ADD_BAND(&(DEFAULT_LTE_IRAT_PRIO_LIST.priority_list_info[1].band_cap.lte_band_cap),0x8);
#else
  DEFAULT_LTE_IRAT_PRIO_LIST.priority_list_info[0].band_cap = rrccsp_get_sys_wcdma_band_mask();
  DEFAULT_LTE_IRAT_PRIO_LIST.priority_list_info[1].band_cap = 0xF;//some value
#endif

/* Memset */
  DEFAULT_LTE_IRAT_PRIO_LIST.scan_type.new_scan = FALSE;
  DEFAULT_LTE_IRAT_PRIO_LIST.next_acq_sys_index = 0;
  DEFAULT_LTE_IRAT_PRIO_LIST.scan_type.use_timer = FALSE;

  rrc_csp_int_data.curr_req_plmn.plmn_id = DEFAULT_PLMN_ID; /* This may not matter since plmn_type is ANY. Correct later*/

  rrc_csp_int_data.rat_pri_list_info = DEFAULT_LTE_IRAT_PRIO_LIST;
  rrc_csp_int_data.band_pref = rrc_extract_gw_band_pref_from_rat_pri_list(&rrc_csp_int_data.rat_pri_list_info);

  rrccsp_update_band_preference();

  if ((rrc_csp_int_data.bplmn_acq_succ_scr_code != rrc_csp_int_data.curr_acq_entry.scr_code) ||
      ( rrc_csp_int_data.bplmn_acq_succ_freq != rrc_csp_int_data.curr_acq_entry.freq))
  {
    WRRC_MSG0_HIGH("CGI:Initialize PN POsition.");
    rrc_csp_int_data.bplmn_acq_succ_scr_code = 8192;
    rrc_csp_int_data.bplmn_acq_succ_freq = 0;
    rrc_csp_int_data.bplmn_acq_succ_pn_pos = 0xFFFFFFFF;
  }

   /* Set the current band appropriately as it is used by SIB procedure 
   * after reading MIB to validate the MCC and Current Band Combination
   */
   /* The minimum time requried to perform CGI is reduced by 50 msec because start/stop time
      has reduced by 50 msec */
      
  if (lte_cgi_req->time_available_for_cgi > 450)
  {
#ifdef FEATURE_DUAL_SIM
    /* Acquire lock before starting ACQ for CGI request from LTE */
    /* 140ms = 100 + 40 where 100ms is the min time needed for ACQ and 40ms for start/stop*/
    rrc_start_lock_wait_timer(lte_cgi_req->time_available_for_cgi - 140,TRUE);
    if(rrc_csp_wait_for_wrm_lock(&type_freq_scan) == RRCCSP_WT_STOP_MODE_CHANGE_CNF)
    {
      rrctmr_stop_timer(RRCTMR_WRM_LOCK_TIMER);
      rrc_csp_int_data.rsp_to_rr = SEND_GTOW_RESEL_REJECT;
      rrccsp_send_mode_change_req_to_mcm(RRC_MODE_INACTIVE);
      next_substate = RRCCSP_WT_STOP_MODE_CHANGE_CNF;
      return next_substate;
    }
    /* Lock timer can be stopped here because we only look for one frequency */
    rrctmr_stop_timer(RRCTMR_WRM_LOCK_TIMER);
#endif

    /* Send CPHY_ACQ_REQ to L1 and wait for the CNF */
    rrc_csp_send_l1_cmd(RRC_PROCEDURE_CSP, CPHY_ACQ_REQ, &rrc_csp_int_data.curr_acq_entry);

    rrc_csp_curr_select_data.current_band = rrc_get_frequency_band(
                                            rrc_csp_int_data.curr_acq_entry.freq,
                                            rrc_csp_int_data.curr_req_plmn.plmn_id);

    /* Start waiting for Acquisition Confirmation */
    next_substate = RRCCSP_CELL_SEL_WT_ACQ;
    rrctmr_stop_timer(RRCTMR_BPLMN_SRCH_TIMER);
    /* 40 ms of time should be enough for start and stop of W-CDMA. 20+ms to start, 20ms to stop,
    *  10-15ms for RRC demand paged start. Remaining time to be used for ACQ and SIB reading. 
    *  There should not be any situation where ACQ needs to be suspended 
    */
    rrctmr_start_timer(RRCTMR_BPLMN_SRCH_TIMER, lte_cgi_req->time_available_for_cgi - 40);

  }
  else
  {
    rrc_csp_int_data.rsp_to_rr = SEND_GTOW_RESEL_REJECT;
    rrccsp_send_mode_change_req_to_mcm(RRC_MODE_INACTIVE);
    next_substate = RRCCSP_WT_STOP_MODE_CHANGE_CNF;
  }

  return next_substate;
}

/*===========================================================================

FUNCTION          RRCCSP_SEND_LTE_INTERRAT_CGI_RSP

DESCRIPTION       This function is responsible for sending
                  WCDMA_RRC_LTE_CGI_RSP to LTE RRC.

DEPENDENCIES
                  None.

RETURN VALUE
                  None.

SIDE EFFECTS      None.
===========================================================================*/
void rrccsp_send_lte_interrat_cgi_rsp
(
  void
)
{
  wcdma_rrc_lte_get_cgi_rsp_type cgi_rsp;

  /* Stop BPLMN timer if active */
  if(!rrc_csp_int_data.bplmn_srch_tmr_expired)
  {
    rrctmr_stop_timer(RRCTMR_BPLMN_SRCH_TIMER);
    rrc_csp_int_data.bplmn_srch_tmr_expired = TRUE;
  }
  cgi_rsp.uarfcn = rrc_csp_int_data.curr_acq_entry.freq;
  cgi_rsp.scr_code = rrc_csp_int_data.curr_acq_entry.scr_code;
  cgi_rsp.cgi_info_included = rrc_csp_int_data.cgi_info_included;
  if (cgi_rsp.cgi_info_included)
  {
    cgi_rsp.cgi_info.rscp = rrccsp_convert_rcsp_meas_to_report(rrc_csp_int_data.cgi_rscp);
    cgi_rsp.cgi_info.ecno = rrccsp_convert_ecio_meas_to_report(rrc_csp_int_data.cgi_ecio);
    
    cgi_rsp.cgi_info.cell_id = rrc_csp_int_data.curr_acq_entry.cell_id;
#ifdef FEATURE_FEMTO_CSG
    cgi_rsp.cgi_info.csg_id = rrc_csp_int_data.curr_acq_entry.csg_id;
#endif
    cgi_rsp.cgi_info.plmn_id = mmumts_convert_rrc_plmn_id_to_nas_plmn_id(rrc_csp_int_data.curr_acq_entry.plmn_id);
    cgi_rsp.cgi_info.lac_included = rrc_csp_int_data.curr_acq_entry.lac_valid;
    cgi_rsp.cgi_info.lac[0] = rrc_csp_int_data.curr_acq_entry.rai.lai.lac[0];
    cgi_rsp.cgi_info.lac[1] = rrc_csp_int_data.curr_acq_entry.rai.lai.lac[1];
    cgi_rsp.cgi_info.rac_included= rrc_csp_int_data.curr_acq_entry.rac_valid;
    cgi_rsp.cgi_info.rac = rrc_csp_int_data.curr_acq_entry.rai.rac[0];

    if (rrc_csp_int_data.curr_acq_entry.is_valid_nw_sharing)
    {
      uint16 i;
      uint16 out_idx = 0;
      for(i = 0; (i < rrc_csp_int_data.curr_acq_entry.shared_list_of_plmns.num_of_shared_plmns); i++)
      {
        if (rrc_bcch_plmns_match(rrc_csp_int_data.curr_acq_entry.shared_list_of_plmns.shared_plmns_access_info[i].plmn_id,
              rrc_csp_int_data.curr_acq_entry.plmn_id) == FALSE)
        {
          cgi_rsp.cgi_info.shared_plmn_list[out_idx] = 
		    mmumts_convert_rrc_plmn_id_to_nas_plmn_id(rrc_csp_int_data.curr_acq_entry.shared_list_of_plmns.shared_plmns_access_info[i].plmn_id);
          WRRC_MSG2_HIGH(" MCC:MNC - %d:%d",RRC_CSP_GET_INT_MCC(rrc_csp_int_data.curr_acq_entry.shared_list_of_plmns.shared_plmns_access_info[i].plmn_id),
                                                      RRC_CSP_GET_INT_MNC(rrc_csp_int_data.curr_acq_entry.shared_list_of_plmns.shared_plmns_access_info[i].plmn_id)
                                                      );
          out_idx++;
          if (out_idx >= WCDMA_RRC_MAX_SHARED_PLMN) 
          break; 
        }
      }
      cgi_rsp.cgi_info.num_of_shared_plmns = out_idx;
    }
    else
    {
      cgi_rsp.cgi_info.num_of_shared_plmns=0;
    }
  
    /* Will include shared PLMN list later*/

#ifdef FEATURE_LTE_TO_WCDMA
    if ((rrc_csp_int_data.curr_scan != RRC_CSP_GSM_TO_WCDMA_CELL_RESELECTION_SCAN)
             && (rrc_csp_int_data.interrat_type != RRC_CSP_INTERRAT_LTE_CGI) )
    {
      WRRC_MSG0_HIGH("XTOW_BPLMN:Initialize ACQ SUCC PSC info.");
      rrc_csp_int_data.bplmn_acq_succ_scr_code = 8192;
      rrc_csp_int_data.bplmn_acq_succ_freq = 0;
      rrc_csp_int_data.bplmn_acq_succ_pn_pos = 0xFFFFFFFF;
    }
#endif
    
  }
  rrc_send_lte_cmd(&cgi_rsp.msg_hdr,WCDMA_RRC_LTE_GET_CGI_RSP,sizeof(wcdma_rrc_lte_get_cgi_rsp_type));

  WRRC_MSG0_HIGH("LTOW:Sent WCDMA_RRC_LTE_GET_CGI_RSP to LTE RRC");

}
/*===========================================================================

FUNCTION          RRCCSP_SEND_LTE_INTERRAT_CGI_ABORT_RSP

DESCRIPTION       This function is responsible for sending
                  WCDMA_RRC_LTE_ABORT_CGI_RSP to LTE RRC.

DEPENDENCIES
                  None.

RETURN VALUE
                  None.

SIDE EFFECTS      None.
===========================================================================*/
void rrccsp_send_lte_interrat_cgi_abort_rsp
(
  void
)
{
  wcdma_rrc_lte_abort_cgi_rsp_type abort_cgi_rsp;


  if(!rrc_csp_int_data.bplmn_srch_tmr_expired)
  {
    rrctmr_stop_timer(RRCTMR_BPLMN_SRCH_TIMER);
    rrc_csp_int_data.bplmn_srch_tmr_expired = TRUE;
  }

  rrc_send_lte_cmd(&abort_cgi_rsp.msg_hdr,WCDMA_RRC_LTE_ABORT_CGI_RSP,sizeof(wcdma_rrc_lte_abort_cgi_rsp_type));
  WRRC_MSG0_HIGH("LTOW: WCDMA_RRC_LTE_ABORT_CGI_RSP sent to LTE RRC");
  rrcsib_bplmn_init_prev_freq_psc();
  rrc_csp_init_int_data();

}
/*===========================================================================

FUNCTION          RRCCSP_CHECK_CGI_SCAN

DESCRIPTION       This function checks whether cgi scan is enabled

DEPENDENCIES      None

RETURN VALUE      Next CSP Substate

SIDE EFFECTS      None
===========================================================================*/
boolean rrccsp_check_cgi_scan(void)
{
  if ((rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_CELL_RESELECTION_SCAN) 
     &&(rrc_csp_int_data.interrat_type == RRC_CSP_INTERRAT_LTE_CGI ))
  {
    return TRUE;
  }
  else
  {
    return FALSE;
  }
}


#endif

/*===========================================================================

FUNCTION          RRCCSP_SEND_IRAT_RESELECTION_ABORT_REQ

DESCRIPTION       This function is responsible for sending reselection abort req to the current interRAT

DEPENDENCIES
                  None.

RETURN VALUE
                  None.

SIDE EFFECTS      None.
===========================================================================*/
static void rrccsp_send_irat_reselection_abort_req( void )
{
#ifdef FEATURE_WCDMA_TO_LTE
  if(rrc_csp_int_data.interrat_type == RRC_CSP_INTERRAT_LTE)
  {
    rrccsp_send_lte_interrat_reselection_abort_req();
  }
  else
#endif
  {
    rrccsp_send_gsm_interrat_reselection_abort_req();
  }
}
/*===========================================================================

FUNCTION          RRCCSP_SEND_IRAT_BPLMN_SEARCH_REQ

 DESCRIPTION       This function is responsible for sending PLMN SRCH REQ to the curr inter RAT
 
DEPENDENCIES
                  None.

RETURN VALUE
                  None.

SIDE EFFECTS      None.
===========================================================================*/
static void rrccsp_send_irat_bplmn_search_req(void)
{
#ifdef FEATURE_WCDMA_TO_LTE
  if(rrc_csp_int_data.bplmn_interrat_type == RRC_CSP_INTERRAT_LTE)
  {
    rrccsp_send_lte_interrat_bplmn_search_req();
  }
  else
#endif
  {
    rrccsp_send_gsm_interrat_bplmn_search_req();
  }
}

/*===========================================================================

FUNCTION          RRCCSP_SEND_IRAT_RESELECTION_ABORT_RSP

DESCRIPTION       This function is responsible for sending reselection ABORT RSP to the current interRAT

DEPENDENCIES
                  None.

RETURN VALUE
                  None.

SIDE EFFECTS      None.
===========================================================================*/
static void rrccsp_send_irat_reselection_abort_rsp( void )
{
#ifdef FEATURE_LTE_TO_WCDMA
  if(rrc_csp_int_data.interrat_type == RRC_CSP_INTERRAT_LTE)
  {
    rrccsp_send_lte_interrat_reselection_abort_rsp();
  }
  else if (rrc_csp_int_data.interrat_type == RRC_CSP_INTERRAT_LTE_CGI)
  {
    rrccsp_send_lte_interrat_cgi_abort_rsp();
  }
  else
#endif
  {
    /* Send the Reselection abort confirmation to GSM RR */
    rrccsp_send_interrat_reselection_abort_cnf();
  }
}

/*===========================================================================

FUNCTION          RRCCSP_SEND_IRAT_RESELECTION_RSP

DESCRIPTION       This function is responsible for sending reselection RSP to the current interRAT

DEPENDENCIES
                  None.

RETURN VALUE
                  None.

SIDE EFFECTS      None.
===========================================================================*/
static void rrccsp_send_irat_reselection_rsp( void )
{
#ifdef FEATURE_LTE_TO_WCDMA
  if(rrc_csp_int_data.interrat_type == RRC_CSP_INTERRAT_LTE)
  {
    rrccsp_send_lte_interrat_reselection_failed_rsp();
  }
  else if (rrc_csp_int_data.interrat_type == RRC_CSP_INTERRAT_LTE_CGI)
  {
    rrccsp_send_lte_interrat_cgi_rsp();
  }

  else
#endif
  {
    /* Send the Reselection Rej to GSM RR */
    rrccsp_send_interrat_reselection_reject();
  }
}

/*===========================================================================

FUNCTION          RRCCSP_SEND_IRAT_BPLMN_SRCH_ABORT_RSP

DESCRIPTION       This function is responsible for sending BPLMN SRCH ABORT RSP to the current interRAT

DEPENDENCIES
                  None.

RETURN VALUE
                  None.

SIDE EFFECTS      None.
===========================================================================*/
static void rrccsp_send_irat_bplmn_srch_abort_rsp( void )
{
#ifdef FEATURE_LTE_TO_WCDMA
  if(rrc_csp_int_data.bplmn_interrat_type == RRC_CSP_INTERRAT_LTE)
  {
    rrccsp_send_lte_interrat_plmn_srch_abort_rsp();
  }
  else
#endif
  {
    rrccsp_send_bplmn_abort_cnf_to_rr();
  }
}

/*===========================================================================

FUNCTION          RRCCSP_SEND_IRAT_BPLMN_SRCH_RSP

DESCRIPTION       This function is responsible for sending BPLMN SRCH RSP to the current interRAT

DEPENDENCIES
                  None.

RETURN VALUE
                  None.

SIDE EFFECTS      None.
===========================================================================*/
static void rrccsp_send_irat_bplmn_srch_rsp( void )
{
#ifdef FEATURE_LTE_TO_WCDMA
  if(rrc_csp_int_data.bplmn_interrat_type == RRC_CSP_INTERRAT_LTE)
  {
    rrccsp_send_lte_interrat_plmn_srch_rsp(FALSE);
  }
  else
#endif
  {
    rrccsp_send_bplmn_search_cnf_to_rr();
  }
}

/*===========================================================================

FUNCTION        RRCCSP_WAIT_RESPONSE_FROM_RR_HDLR

DESCRIPTION
                This is a handler for events received in
                RRCCSP_WT_RESPONSE_FROM_RR substate of
                the Cell Selection Procedure.
                Depending on the event, it further calls a function for
                processing the event in this CSP substate.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_wait_response_from_rr_hdlr( rrc_cmd_type *cmd_ptr )
{
  rrc_csp_substate_e_type   next_substate;
  /* Inter-RAT command */
  rrc_rr_cmd_type *rr_cmd;
  uint32 i;
  rrclog_wcdma_to_gsm_redir_end_event_type wtog_rdr_evnt;

#ifdef FEATURE_PCS_850_FREQ_SCAN_OPTIMIZATION
  rrc_to_mm_sink_e_type   mm_cmd_id;
#endif

  rrclog_wcdma_to_gsm_reselection_end_event_type wtog_resel_end_event;
  rrclog_wcdma_bplmn_scan_end_event_type bplmn_scan_end_event;

  boolean interrat_cmd = FALSE;

  boolean oos_enhancement_in_state_tx = FALSE;

  if(  (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_CELL_FACH_SCAN )
    || (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_CELL_PCH_SCAN  )
    || (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_URA_PCH_SCAN   )  
    || (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_FACH_TO_CELL_FACH_SCAN )
    || (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_FACH_TO_CELL_PCH_SCAN  )
    || (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_FACH_TO_URA_PCH_SCAN   ) 
    )
    {
      oos_enhancement_in_state_tx = TRUE;
    }

#if defined (FEATURE_LTE_TO_WCDMA) || defined (FEATURE_WCDMA_TO_LTE)
  if(cmd_ptr->cmd_hdr.cmd_id == RRC_LTE_RRC_CMD)
  {
    interrat_cmd = TRUE;
  }
#endif

  if((((uint32)cmd_ptr->cmd_hdr.cmd_id & RRC_RR_CMD_ID_BASE) == RRC_RR_CMD_ID_BASE) )
  {
    interrat_cmd = TRUE;
  }

  next_substate = RRCCSP_WT_RESPONSE_FROM_RR;

  if(!interrat_cmd)
  {
    switch( cmd_ptr->cmd_hdr.cmd_id )
    {
      case RRC_INITIATE_CELL_SELECTION_IND:
        MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                           cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
        if(cmd_ptr->cmd.initiate_cell_sel_ind.cause == RRC_TRANSITION_TO_DISCONNECTED)
        {
            WRRC_MSG1_HIGH("Saving initiate cell sel, proc rrc_proc_e_type_value%d",
                       cmd_ptr->cmd.initiate_cell_sel_ind.proc);
            rrc_csp_int_data.init_cell_sel_ind_during_wtointerrat = TRUE;

            /* Send Inter-RAT redirection abort request to RR and wait for confirmation
             * from RR
             */
            if(rrc_csp_int_data.curr_scan == RRC_CSP_WCDMA_TO_GSM_CELL_RESELECTION_SCAN)
            {
              rrccsp_send_irat_reselection_abort_req();
              next_substate = RRCCSP_WT_RR_ABORT_CNF;
            }
            else if(rrc_csp_int_data.curr_scan == RRC_CSP_INTER_RAT_REDIRECTION_SCAN)
            {
              rrccsp_send_interrat_redirection_abort_req();
              next_substate = RRCCSP_WT_RR_ABORT_CNF;
            }
#ifdef FEATURE_PCS_850_FREQ_SCAN_OPTIMIZATION
            else if(rrc_csp_int_data.curr_scan == RRC_CSP_CELL_SELECTION_SCAN)
            {
              rrccsp_send_interrat_redirection_abort_req();
              next_substate = RRCCSP_WT_RR_ABORT_CNF;
            }
#endif
            else
            {
              WRRC_MSG1_ERROR("Invalid scan type %d", rrc_csp_int_data.curr_scan);
              rrccsp_send_interrat_redirection_abort_req();
              next_substate = RRCCSP_WT_RR_ABORT_CNF;
            }

        }
        else
        {
          WRRC_MSG2_HIGH("Cause %d not handled %d CSP sstate ",
                    cmd_ptr->cmd.initiate_cell_sel_ind.cause, rrc_csp_substate);
        }
        break;

      case RRC_IRAT_ABORT_IND:
        if(rrc_csp_int_data.curr_scan == RRC_CSP_WCDMA_TO_GSM_CELL_RESELECTION_SCAN)
        {
#ifdef FEATURE_GAN
          #error code not present
#endif

          rrccsp_send_irat_reselection_abort_req();

          rrccsp_reset_reselection_data();
          next_substate = RRCCSP_WT_RR_ABORT_CNF;
        }
#ifdef FEATURE_GAN
        #error code not present
#endif
#ifdef FEATURE_GAN_3G_ROVE_OUT_ONLY
        #error code not present
#endif
#ifdef FEATURE_PCS_850_FREQ_SCAN_OPTIMIZATION
        else if(rrc_csp_int_data.curr_scan == RRC_CSP_CELL_SELECTION_SCAN)
        {
          /* Send Inter-RAT redirection abort request to RR and wait for confirmation
           * from RR
           */
          rrccsp_send_interrat_redirection_abort_req();
          next_substate = RRCCSP_WT_RR_ABORT_CNF;
        }
#endif

        else if((rrc_csp_int_data.curr_scan == RRC_CSP_WTOG_BPLMN_AUTOMATIC_SCAN) ||
                (rrc_csp_int_data.curr_scan == RRC_CSP_WTOG_BPLMN_MANUAL_SCAN))
        {
          rrccsp_send_irat_bplmn_suspend_ind();
          next_substate = RRCCSP_WT_RESPONSE_FROM_RR;
        }
        else if(rrc_csp_int_data.curr_scan == RRC_CSP_PLMN_LIST_SCAN)
        {
          rrccsp_send_irat_bplmn_abort_req();
          next_substate = RRCCSP_WT_RR_ABORT_CNF;
        }
        else if(rrc_csp_int_data.curr_scan == RRC_CSP_INTER_RAT_REDIRECTION_SCAN)
        {
          /* Send Inter-RAT redirection abort request to RR and wait for confirmation
           */
          rrccsp_send_interrat_redirection_abort_req();
          next_substate = RRCCSP_WT_RR_ABORT_CNF;
        }
        else
        {
          WRRC_MSG1_ERROR("ERR: ABORT_IND incorrectly rcvd from MCM for scantype %d", rrc_csp_int_data.curr_scan);
          next_substate = RRCCSP_WT_RESPONSE_FROM_RR;
        }
        break;

      case RRC_BPLMN_SUSPEND_REQ:
        /* This IF stmt has been added for testing purposes only and will be deleted before
         * checking in the code
         */                                                  
        if((rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
           || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN))
        { 
          WRRC_MSG1_ERROR("WTOW ERR: Incorrect current scan %d", rrc_csp_int_data.curr_scan);
        }
        else
        {
          WRRC_MSG1_HIGH("WTOW: Srch suspend req. Snd suspend cnf to proc rrc_proc_e_type_value%d",
                                            cmd_ptr->cmd.rrc_csp_bplmn_suspend_req.procedure);

          switch(cmd_ptr->cmd.rrc_csp_bplmn_suspend_req.procedure)
          {
            case RRC_PROCEDURE_RCE:
            case RRC_PROCEDURE_SIB:
              WRRC_MSG1_ERROR("ERR: Unexpected suspend request from rrc_proc_e_type_value%d",
                                            cmd_ptr->cmd.rrc_csp_bplmn_suspend_req.procedure);
              rrc_csp_send_bplmn_suspend_cnf(cmd_ptr->cmd.rrc_csp_bplmn_suspend_req.procedure, SUCCESS);
              break;

            case RRC_PROCEDURE_CU:
            case RRC_PROCEDURE_IDT:
             /* Below condition check is added to ensure that W-RRC never sends back to back SUSPEND_IND to GSM.*/
              if(!rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_suspended)
              {
                rrccsp_send_irat_bplmn_suspend_ind();
                next_substate = RRCCSP_WT_RESPONSE_FROM_RR;
              }
              rrc_csp_send_bplmn_suspend_cnf(cmd_ptr->cmd.rrc_csp_bplmn_suspend_req.procedure, SUCCESS);
              break;

            case RRC_PROCEDURE_MISC:
              if(rrc_csp_int_data.bplmn_nw_sel_mode == SYS_NETWORK_SELECTION_MODE_AUTOMATIC)
              {
                WRRC_MSG0_HIGH("CSP rcvd Suspend request from CU. Snd abort req to GSM/LTE");

                rrccsp_send_irat_bplmn_abort_req();
                next_substate = RRCCSP_WT_RR_ABORT_CNF;
              }
              else
              {
                WRRC_MSG0_HIGH("CSP rcvd Suspend request from CU. Snd suspend cnf to CU");
              }
              rrc_csp_send_bplmn_suspend_cnf(cmd_ptr->cmd.rrc_csp_bplmn_suspend_req.procedure, SUCCESS);
              break;

            default:
              WRRC_MSG1_ERROR("ERR: Suspend request from unexp procedure %d", 
                                            cmd_ptr->cmd.rrc_csp_bplmn_suspend_req.procedure);
              rrc_csp_send_bplmn_suspend_cnf(cmd_ptr->cmd.rrc_csp_bplmn_suspend_req.procedure, SUCCESS);
              break;
           }
         }
        break;

      case RRC_BPLMN_GUARD_SRCH_TIMER_EXPIRED_IND:
        /* If WTOG BPLMN search is in progress then send abort request to GSM */
        if((rrc_csp_int_data.curr_scan == RRC_CSP_WTOG_BPLMN_AUTOMATIC_SCAN)
            || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOG_BPLMN_MANUAL_SCAN))
        {
          rrccsp_send_irat_bplmn_abort_req();
          next_substate = RRCCSP_WT_RR_ABORT_CNF;
        }
        /* Else, cleanup BPLMN state */
        else
        {
          rrccsp_cleanup_bplmn_state();
        }
        break;

      case RRC_BPLMN_SEARCH_ABORT_REQ:
        /* If WTOG BPLMN search is in progress then send abort request to GSM */
        if(    (rrc_csp_int_data.curr_scan == RRC_CSP_WTOG_BPLMN_AUTOMATIC_SCAN)
            || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOG_BPLMN_MANUAL_SCAN)
            || (rrc_csp_int_data.curr_scan == RRC_CSP_PLMN_LIST_SCAN)
          )
        {
          rrccsp_send_irat_bplmn_abort_req();
          next_substate = RRCCSP_WT_RR_ABORT_CNF;
        }
        /* Else, cleanup BPLMN state */
        else
        {
          rrccsp_cleanup_bplmn_state();
        }
        break;


      case RRC_DCH_FACH_CELL_SELECTION_TIMER_EXPIRED_IND:
        if(rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_CELL_FACH_SCAN)
        {
          rrc_csp_int_data.dch_to_fach_pch_tmr_expd = TRUE;

          /* Send Inter-RAT redirection abort request to RR and wait for confirmation
           * from RR
           */
          rrccsp_send_interrat_redirection_abort_req();
          next_substate = RRCCSP_WT_RR_ABORT_CNF;
        }
        else
        {
          WRRC_MSG1_HIGH("Ignoring Cell Sel Tmr Exp in %d scan", rrc_csp_int_data.curr_scan);
        }
        break;
  
      case RRC_DCH_PCH_CELL_SELECTION_TIMER_EXPIRED_IND:
        if(   (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_CELL_PCH_SCAN) 
           || (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_URA_PCH_SCAN))
        {
          rrc_csp_int_data.dch_to_fach_pch_tmr_expd = TRUE;

          /* Send Inter-RAT redirection abort request to RR and wait for confirmation
           * from RR
           */
          rrccsp_send_interrat_redirection_abort_req();
          next_substate = RRCCSP_WT_RR_ABORT_CNF;
        }
        else
        {
          WRRC_MSG1_HIGH("Ignoring Cell Sel Tmr Exp in %d scan", rrc_csp_int_data.curr_scan);
        }
        break;

      case RRC_FACH_TO_FACH_PCH_CELL_SELECTION_TIMER_EXPIRED_IND:
        if( (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_FACH_TO_CELL_FACH_SCAN)
           || (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_FACH_TO_CELL_PCH_SCAN)
           || (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_FACH_TO_URA_PCH_SCAN) )
        {
          rrc_csp_int_data.fach_to_fach_pch_tmr_expd = TRUE;

          /* Send Inter-RAT redirection abort request to RR and wait for confirmation
           * from RR
           */
          rrccsp_send_interrat_redirection_abort_req();
          next_substate = RRCCSP_WT_RR_ABORT_CNF;
        }
        else
        {
          WRRC_MSG1_HIGH("Ignoring Cell Sel Tmr Exp in %d scan", rrc_csp_int_data.curr_scan);
        }
        break;

      default:
        WRRC_MSG2_HIGH( "Cmd 0x%x not processed in CSP sstate %d",
                              cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);
        break;
    }
  }
  else if(((uint32)cmd_ptr->cmd_hdr.cmd_id & RRC_RR_CMD_ID_BASE) == RRC_RR_CMD_ID_BASE)
  {
    rr_cmd = ((rrc_rr_cmd_type *)cmd_ptr);    /*lint !e740 */

    switch(rr_cmd->cmd_hdr.cmd_id)
    {
      case RR_INTERRAT_RESELECTION_REJ:
        WRRC_MSG1_HIGH("Interrat resel rej from RR, cause - %d",
                    rr_cmd->cmd.interrat_reselection_rej.failure_reason);
        RRC_DEBUG_INCREMENT_STATS(WTOG_CEL_RESEL_FAILURE);
#ifdef FEATURE_QSH_EVENT_METRIC
		wrrc_qsh_log_cell_resel_stats(CELL_RESEL_FAIL,WRRC_METRIC_UPDATE);
#endif


#ifdef FEATURE_GAN
        #error code not present
#endif

        rrc_csp_int_data.bar_for_resel_only = FALSE;
        rrc_csp_int_data.non_eq_plmn_barred = FALSE;

        /* If W to G reselection failed due to the G cell being barred, then
         * inform L1 so that it does not perform reselection measurements on
         * the G cell for at least 320s.
         */
        if(rr_cmd->cmd.interrat_reselection_rej.failure_reason == RR_GSM_CELL_BARRED)
        {
          WRRC_MSG0_HIGH("W2G InterRAT resel fail. GSM cell barred. Send bar req to L1");
          rrccsp_send_cphy_cell_bar_req(RRC_CSP_GSM_CELL_BARRED, 320);
        }
        else if((rr_cmd->cmd.interrat_reselection_rej.failure_reason == RR_GSM_CELL_FORBIDDEN) ||
                   (rr_cmd->cmd.interrat_reselection_rej.failure_reason == RR_GSM_PLMN_MISMATCH)) 
        {
          WRRC_MSG1_HIGH("CR 151: W2G Cell Reselection failure reason: %d",rr_cmd->cmd.interrat_reselection_rej.failure_reason);
          WRRC_MSG0_HIGH("Sending CPHY_CELL_BAR_REQ to L1 since curr LAI is barred for roaming ");
          rrc_csp_int_data.bar_for_resel_only = TRUE;

          if(rr_cmd->cmd.interrat_reselection_rej.failure_reason == RR_GSM_PLMN_MISMATCH)
          {
            rrc_csp_int_data.non_eq_plmn_barred = TRUE;
          }
          /* Send Cell bar request to L1 */
          rrccsp_send_cphy_cell_bar_req(RRC_CSP_GSM_CELL_BARRED, 
                                        FORBIDDEN_RESEL_FREQ_BAR_TIMER_IN_SEC);
          rrc_csp_int_data.bar_for_resel_only = FALSE;          
          
          rrc_csp_int_data.non_eq_plmn_barred = FALSE;                                                               
        }

        /* Send Mode change request to MCM to resume the WCDMA mode
              * and wait for the confirmation from MCM if RRC mode is not ACTIVE
              */
        /* Log EVENT_WCDMA_TO_GSM_RE_SELECTION_END */
        wtog_resel_end_event.status = 0;
        wtog_resel_end_event.failure_reason = (uint8)rr_cmd->cmd.interrat_reselection_rej.failure_reason;
        event_report_payload(EVENT_WCDMA_TO_GSM_RESELECTION_END, sizeof(wtog_resel_end_event),
          (void *)&wtog_resel_end_event);
#ifdef FEATURE_GAN_3G_ROVE_OUT_ONLY
        #error code not present
#endif
        {
          rrccsp_send_mode_change_req_to_mcm(RRC_MODE_ACTIVE);
          next_substate = RRCCSP_WT_RESUME_MODE_CHANGE_CNF;
        }
        /* Reset reselection variables */
        rrccsp_reset_reselection_data();
        break;

      case RR_INTERRAT_REDIRECT_REJ:
        WRRC_MSG2_HIGH("Interrat redirect rej from RR, cause - %d. curr_scan %d",
                            rr_cmd->cmd.interrat_redirect_rej.failure_reason, rrc_csp_int_data.curr_scan);

       wtog_rdr_evnt.status = WTOG_FAILURE;
       if((rrc_csp_int_data.curr_scan != RRC_CSP_CELL_SELECTION_SCAN)
          && (rrc_csp_int_data.curr_scan != RRC_CSP_OUT_OF_SERVICE_AREA_SCAN))
       {
          event_report_payload(EVENT_WCDMA_TO_GSM_REDIRECTION_END, sizeof(wtog_rdr_evnt),
             (void *)&wtog_rdr_evnt);
       }

        if(rrc_csp_int_data.curr_scan == RRC_CSP_OUT_OF_SERVICE_AREA_SCAN)
        {
          rrc_csp_int_data.oos_gsm_srch_done       = TRUE;
          rrc_csp_int_data.oos_gsm_num_avail_plmns = rr_cmd->cmd.interrat_redirect_rej.num_avail_plmns;

          if(rrc_csp_int_data.oos_splmn_srch_tmr_expd 
              && (rrc_csp_int_data.oos_gsm_num_avail_plmns > 0)
              && (rrc_csp_int_data.network_select_mode != SYS_NETWORK_SELECTION_MODE_MANUAL))
          {
            WRRC_MSG1_HIGH("OOS: #G-PLMNs = %d", rrc_csp_int_data.oos_gsm_num_avail_plmns);

            rrccsp_send_interrat_redirection_req();
            next_substate = RRCCSP_WT_RESPONSE_FROM_RR;
          }
          else
          {
            MSG_HIGH("OOS: srch_tmr_expd = %d, gsm_num_avail_plmns = %d, n/w sel mode %d", 
                      rrc_csp_int_data.oos_splmn_srch_tmr_expd, rrc_csp_int_data.oos_gsm_num_avail_plmns, 
                      rrc_csp_int_data.network_select_mode); 

            /* reset number of GSM plmns found to 0 */
            rrc_csp_int_data.oos_gsm_num_avail_plmns = 0;

            /* Send Mode change request to MCM to resume the WCDMA mode
             * and wait for the confirmation from MCM if RRC mode is not ACTIVE
             */
            rrccsp_send_mode_change_req_to_mcm(RRC_MODE_ACTIVE);
            next_substate = RRCCSP_WT_RESUME_MODE_CHANGE_CNF;
          }

#ifdef FEATURE_OOSC_SERVICE_STATUS_UI_UPDATE
          WRRC_MSG1_HIGH("SRV_ST: num of 2G FPLMNs available is:%d ",rr_cmd->cmd.interrat_redirect_rej.num_available_fplmns);
          if( (rr_cmd->cmd.interrat_redirect_rej.num_avail_plmns > 0) || 
              ( rr_cmd->cmd.interrat_redirect_rej.num_available_fplmns > 0)
            )
          {
            WRRC_MSG0_HIGH("SRV_ST: GSM PLMN found");

            /* Update UI with Limited Service */
            if(!rrc_csp_int_data.oosc_plmn_found)
            {
              rrc_csp_int_data.oosc_plmn_found = TRUE;

              rrc_csp_int_data.curr_acq_entry.plmn_id =
                      mmumts_convert_nas_plmn_id_to_rrc_plmn_id(rr_cmd->cmd.interrat_redirect_rej.plmn[0]);

              WRRC_MSG0_HIGH("SRV_ST: Update UI w/ GSM Lim SERVICE");
              rrc_csp_send_svc_status_to_mm(SYS_SRV_STATUS_LIMITED, 
                                            SYS_RAT_GSM_RADIO_ACCESS, 
                                            rr_cmd->cmd.interrat_redirect_rej.signal_strength[0]);
            }
            else
            {
              WRRC_MSG0_HIGH("SRV_ST: UI already updated with Lim SERVICE");
            }
          }
#endif

        } /* RRC_CSP_OUT_OF_SERVICE_AREA_SCAN */
        else


        
        if(rrc_csp_int_data.curr_scan == RRC_CSP_INTER_RAT_REDIRECTION_SCAN)
        {
          /* Send Mode change request to MCM to resume the WCDMA mode
           * and wait for the confirmation from MCM if RRC mode is not ACTIVE
           */
          rrccsp_send_mode_change_req_to_mcm(RRC_MODE_ACTIVE);
          next_substate = RRCCSP_WT_RESUME_MODE_CHANGE_CNF;
        }
#ifdef FEATURE_PCS_850_FREQ_SCAN_OPTIMIZATION
        else if(rrc_csp_int_data.curr_scan == RRC_CSP_CELL_SELECTION_SCAN)
        {
          if(rr_cmd->cmd.interrat_redirect_rej.num_avail_plmns > 0)
          {
            WRRC_MSG1_HIGH("#G-PLMNs fnd during GSM srch = %d", 
                                 rr_cmd->cmd.interrat_redirect_rej.num_avail_plmns);

            /* Send a Service Confirmation back to MM informing that no PLMN was found */
            rrc_csp_int_data.curr_service_status = MM_AS_NO_SERVICE;
            
            /* Send no service to NAS as requested PLMN was found on GSM */
            if(rrc_csp_cmd_to_mm_needed(&mm_cmd_id,
                                  rrc_csp_int_data.last_mm_primitive,
                                  rrc_csp_int_data.curr_service_status)
              == TRUE)
            {
              rrc_csp_send_mm_cmd(mm_cmd_id,
                             rrc_csp_int_data.curr_service_status,
                             &rrc_csp_int_data.curr_sel_plmn,
                             &rrc_csp_int_data.curr_acq_entry);
            }
          }
          else
          {
            WRRC_MSG0_HIGH("RPLMN/EPLMN not found on GSM. Do acq-db/full-scan on W");

#ifdef FEATURE_PCS_850_FREQ_SCAN_NEW_OPTIMIZATION
            /* Map ARFCNs in GSM list to UMTS channels */
            rrccsp_convert_active_gsm_channels_to_umts_uarfcns(rr_cmd->cmd.interrat_redirect_rej.gsm_cell_list);
#endif

            /* Send Mode change request to MCM to resume the WCDMA mode
             * and wait for the confirmation from MCM if RRC mode is not ACTIVE
             */
            rrccsp_send_mode_change_req_to_mcm(RRC_MODE_ACTIVE);
            next_substate = RRCCSP_WT_RESUME_MODE_CHANGE_CNF;
          }
          rrc_csp_int_data.gsm_svc_srch_done = TRUE;
        }
#endif
        /* For DCH_to_FACH/PCH scan or FACH_to_FACH/PCH scan, UE should always resume 
         * search on W even if acceptable G PLMNs are found because for such a scan, UE should only
         * search for suitable PLMNs. If suitable PLMN was available on GSM, GSM-RR
         * would have camped on such a PLMN instead of sending a reject. Hence there
         * is no need to check if any PLMN was found on GSM or not.
         */
        else if(oos_enhancement_in_state_tx)
        {
          WRRC_MSG0_HIGH("Resume W for DCH->FACH/PCH scan or FACH->FACH/PCH scan");
          /* Send Mode change request to MCM to resume the WCDMA mode
           * and wait for the confirmation from MCM if RRC mode is not ACTIVE
           */
          rrccsp_send_mode_change_req_to_mcm(RRC_MODE_ACTIVE);
          next_substate = RRCCSP_WT_RESUME_MODE_CHANGE_CNF;
        }
        else
        {
          WRRC_MSG1_ERROR("ERR RR_INTERRAT_REDIRECT_REJ rcvd when CSP curr_scan = %d", rrc_csp_int_data.curr_scan);
        }
        break;


    case RR_INTERRAT_PLMN_SRCH_CNF:
        //EVENT: Event_BPLMN_Scan_End_req  W2G End
        bplmn_scan_end_event.scan_complete = rr_cmd->cmd.interrat_plmn_srch_cnf.srch_done; /*TBD: incomplete,complete*/
        event_report_payload(EVENT_WCDMA_BPLMN_SCAN_END, sizeof(bplmn_scan_end_event),
                     (void *)&bplmn_scan_end_event);

        rrc_csp_wtog_bplmn_int_data.wtog_srch_done   = rr_cmd->cmd.interrat_plmn_srch_cnf.srch_done;
        rrc_csp_wtog_bplmn_int_data.wtog_hplmn_found = rr_cmd->cmd.interrat_plmn_srch_cnf.hplmn_found;

        if(rr_cmd->cmd.interrat_plmn_srch_cnf.srch_done)
        {
          WRRC_MSG1_HIGH("WTOG: Srch done. #PLMNs found %d. Resume W",
                        rr_cmd->cmd.interrat_plmn_srch_cnf.available_plmn_list.length);

          for(i=0; i < rr_cmd->cmd.interrat_plmn_srch_cnf.available_plmn_list.length; ++i)
          {
            rrc_csp_wtog_bplmn_int_data.plmn_list.plmn[i].plmn = 
                  mmumts_convert_nas_plmn_id_to_rrc_plmn_id(
                    rr_cmd->cmd.interrat_plmn_srch_cnf.available_plmn_list.info[i].plmn);

            MSG_HIGH("%d-%d, GSM RAT %d", 
                                       RRC_CSP_GET_INT_MCC(rrc_csp_wtog_bplmn_int_data.plmn_list.plmn[i].plmn),
                                       RRC_CSP_GET_INT_MNC(rrc_csp_wtog_bplmn_int_data.plmn_list.plmn[i].plmn), 
                                       rr_cmd->cmd.interrat_plmn_srch_cnf.available_plmn_list.info[i].rat);

            rrc_csp_wtog_bplmn_int_data.plmn_list.plmn[i].rat = 
                    rr_cmd->cmd.interrat_plmn_srch_cnf.available_plmn_list.info[i].rat;

            rrc_csp_wtog_bplmn_int_data.plmn_list.plmn[i].service_capability = 
                    rr_cmd->cmd.interrat_plmn_srch_cnf.available_plmn_list.info[i].plmn_service_capability;

            rrc_csp_wtog_bplmn_int_data.plmn_list.plmn[i].signal_quality = 
                    rr_cmd->cmd.interrat_plmn_srch_cnf.available_plmn_list.info[i].signal_quality;

            rrc_csp_wtog_bplmn_int_data.plmn_list.plmn[i].signal_strength = 
                    rr_cmd->cmd.interrat_plmn_srch_cnf.available_plmn_list.info[i].signal_strength;
          }

          rrc_csp_wtog_bplmn_int_data.wtog_gsm_plmns_found = 
                                      rr_cmd->cmd.interrat_plmn_srch_cnf.available_plmn_list.length;

#ifdef FEATURE_PCS_850_FREQ_SCAN_NEW_OPTIMIZATION
          /* Map ARFCNs in GSM list to UMTS channels */
          rrccsp_convert_active_gsm_channels_to_umts_uarfcns(rr_cmd->cmd.interrat_plmn_srch_cnf.gsm_cell_list);
#endif

        }
        else
        {
          WRRC_MSG0_HIGH("WTOG: Srch NOT completed on GSM. Wait for next DRX. Resume W");
        }
#ifdef FEATURE_WCDMA_TO_LTE
        if((rrc_csp_int_data.curr_scan == RRC_CSP_PLMN_LIST_SCAN) &&
          (((rrc_csp_int_data.plmn_srch_order.curr_rat_srch_idx + 1) < rrc_csp_int_data.plmn_srch_order.num_rats)
              &&(rrc_csp_int_data.plmn_srch_order.rat[rrc_csp_int_data.plmn_srch_order.curr_rat_srch_idx + 1] ==
              SYS_RAT_LTE_RADIO_ACCESS)))
        {
          if(!rr_cmd->cmd.interrat_plmn_srch_cnf.srch_done)
          {
            rrccsp_send_irat_bplmn_abort_req();
          }
          /*GSM is searched and LTE is next RAT to be searched, do no do suspend and resume procedure again*/
          rrc_csp_init_wtog_plmn_srch_int_data_across_rats();
          rrc_csp_int_data.plmn_srch_order.curr_rat_srch_idx++;
          rrc_csp_int_data.bplmn_interrat_type = RRC_CSP_INTERRAT_LTE;
          rrccsp_send_irat_bplmn_search_req();
          next_substate = RRCCSP_WT_RESPONSE_FROM_RR;
        }
        else
#endif
        {
          /* No need to send Inter-RAT BPLMN Search request to RR */
          rrccsp_send_mode_change_req_to_mcm(RRC_MODE_ACTIVE);
          next_substate = RRCCSP_WT_RESUME_MODE_CHANGE_CNF;
        }
        break;

#ifdef FEATURE_GAN_3G_ROVE_OUT_ONLY
      #error code not present
#endif
        default:
        WRRC_MSG2_HIGH("Cmd 0x%x not processed in CSP sstate %d",
                              rr_cmd->cmd_hdr.cmd_id, rrc_csp_substate);
        break;
    }
  }

#ifdef FEATURE_WCDMA_TO_LTE
  else if (cmd_ptr->cmd_hdr.cmd_id == RRC_LTE_RRC_CMD)
  {
    switch(cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.msg_hdr.id)
    {
      case LTE_RRC_WCDMA_RESEL_FAILED_RSP:
        {
          lte_rrc_wcdma_resel_failed_rsp_s * resel_rsp = &cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.lte_rrc_wcdma_resel_failed_rsp;
          rrc_csp_cell_bar_info_e_type bar_type = RRC_CSP_LTE_CELL_BARRED;
          uint32 bar_time = 0;
          rrclog_wcdma_to_lte_resel_end_event_type wtol_resel_event;
#ifdef FEATURE_QSH_EVENT_METRIC
		  wrrc_qsh_log_cell_resel_stats(CELL_RESEL_FAIL,WRRC_METRIC_UPDATE);
#endif

          wtol_resel_event.status = WTOL_FAILURE;
          wtol_resel_event.failure_cause = resel_rsp->cause; 
          /*Need to fill the failure cause*/
          event_report_payload(EVENT_WCDMA_TO_LTE_RESELECTION_END, sizeof(wtol_resel_event),
                         (void *)&wtol_resel_event);

          WRRC_MSG1_HIGH("WTOL: LTE_RRC_WCDMA_RESEL_FAILED_RSP from LTE RRC, cause %d",resel_rsp->cause);

          if(0 != resel_rsp->time_to_reselect )
          {
            bar_time = resel_rsp->time_to_reselect;
          }

          rrc_csp_int_data.bar_for_resel_only = FALSE;
          rrc_csp_int_data.non_eq_plmn_barred = FALSE;

          switch(resel_rsp->cause)
          {
            case LTE_RRC_IRAT_TO_LTE_RESEL_FAILURE_CAUSE_FREQ_BARRED:
              bar_type = RRC_CSP_LTE_FREQ_BARRED;
              break;
            case LTE_RRC_IRAT_TO_LTE_RESEL_FAILURE_CAUSE_PLMN_MISMATCH:
              rrc_csp_int_data.non_eq_plmn_barred = TRUE;
              rrc_csp_int_data.bar_for_resel_only = TRUE;
              bar_time = FORBIDDEN_RESEL_FREQ_BAR_TIMER_IN_SEC;
              bar_type = RRC_CSP_LTE_FREQ_BARRED;
              break;
       
            case LTE_RRC_IRAT_TO_LTE_RESEL_FAILURE_CAUSE_FORBIDDEN_TA:
              rrc_csp_int_data.bar_for_resel_only = TRUE;
              bar_time = FORBIDDEN_RESEL_FREQ_BAR_TIMER_IN_SEC;
              bar_type = RRC_CSP_LTE_FREQ_BARRED;
            break;

#ifdef FEATURE_FEMTO_CSG
            case LTE_RRC_IRAT_TO_LTE_RESEL_FAILURE_CAUSE_FORBIDDEN_CSG_ID:
              bar_time = FORBIDDEN_RESEL_FREQ_BAR_TIMER_IN_SEC;
              bar_type = RRC_CSP_LTE_CELL_BARRED;
              rrc_csp_int_data.bar_non_white_csg = TRUE;
            break;
#endif
            default : 
            break;
          }
          if(0 != bar_time )
          {
            rrccsp_send_cphy_cell_bar_req(bar_type, bar_time);
            rrc_csp_int_data.bar_for_resel_only = FALSE;
            rrc_csp_int_data.non_eq_plmn_barred = FALSE;
          }

          rrccsp_send_mode_change_req_to_mcm(RRC_MODE_ACTIVE);
          next_substate = RRCCSP_WT_RESUME_MODE_CHANGE_CNF;
          /* Reset reselection variables */
          rrccsp_reset_reselection_data();
        }
        break;

      case LTE_RRC_WCDMA_PLMN_SRCH_RSP:
        {
          lte_irat_plmn_srch_rsp_s *plmn_srch_rsp = 
              &(cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.lte_rrc_wcdma_plmn_srch_rsp);
          WRRC_MSG0_HIGH("WTOL: LTE_RRC_WCDMA_PLMN_SRCH_RSP from LTE RRC");
          rrc_csp_wtog_bplmn_int_data.wtog_srch_done   = plmn_srch_rsp->srch_done;
          rrc_csp_wtog_bplmn_int_data.wtog_hplmn_found = plmn_srch_rsp->hplmn_found;

#ifdef FEATURE_FEMTO_CSG
         if(rrc_csp_int_data.csg_asf_srch_in_progress && rrc_csp_wtog_bplmn_int_data.wtog_hplmn_found)
         {
           ERR_FATAL("HPLM found shouldnt be set to true for ASF",0,0,0);
         }
#endif

          if(plmn_srch_rsp->srch_done)
          {
            WRRC_MSG1_HIGH("WTOL: Srch done. #PLMNs found %d",
                          plmn_srch_rsp->available_plmn_list.length);
            for(i=0; i < plmn_srch_rsp->available_plmn_list.length; ++i)
            {
              rrc_csp_wtog_bplmn_int_data.lte_plmn_list.plmn[i].plmn = 
                    mmumts_convert_nas_plmn_id_to_rrc_plmn_id(
                      plmn_srch_rsp->available_plmn_list.info[i].plmn);
              MSG_HIGH("%d-%d, LTE RAT %d", 
                                         RRC_CSP_GET_INT_MCC(rrc_csp_wtog_bplmn_int_data.lte_plmn_list.plmn[i].plmn),
                                         RRC_CSP_GET_INT_MNC(rrc_csp_wtog_bplmn_int_data.lte_plmn_list.plmn[i].plmn), 
                                         plmn_srch_rsp->available_plmn_list.info[i].rat);
              rrc_csp_wtog_bplmn_int_data.lte_plmn_list.plmn[i].rat = 
                      plmn_srch_rsp->available_plmn_list.info[i].rat;
              rrc_csp_wtog_bplmn_int_data.lte_plmn_list.plmn[i].service_capability = 
                      plmn_srch_rsp->available_plmn_list.info[i].plmn_service_capability;
              rrc_csp_wtog_bplmn_int_data.lte_plmn_list.plmn[i].signal_quality = 
                      plmn_srch_rsp->available_plmn_list.info[i].signal_quality;
              rrc_csp_wtog_bplmn_int_data.lte_plmn_list.plmn[i].signal_strength = 
                      plmn_srch_rsp->available_plmn_list.info[i].signal_strength;
#ifdef FEATURE_FEMTO_CSG
              rrc_csp_wtog_bplmn_int_data.lte_plmn_list.plmn[i].csg_info.csg_id = 
                      plmn_srch_rsp->available_plmn_list.info[i].csg_info.csg_id;
#endif
              rrc_csp_wtog_bplmn_int_data.lte_plmn_list.plmn[i].earfcn = 
                      plmn_srch_rsp->available_plmn_list.info[i].earfcn;
            }
            rrc_csp_wtog_bplmn_int_data.wtol_plmns_found = 
                                        plmn_srch_rsp->available_plmn_list.length;
            rrccsp_update_irat_detected_frequencies(&plmn_srch_rsp->detected_frequency_list);
#ifdef FEATURE_FEMTO_CSG
               /*Append LTE CSG cells information to W CSG cells ASF DB to send meas request to wl1*/
            if(rrccsp_asf_actively_in_prog())
            {
              uint8 num_w_entries = rrc_csp_int_data.temp_csg_list.num_entries;

              for(i = 0; i < plmn_srch_rsp->detected_csg_cell_list.num_cells; i++)
              {
                if(num_w_entries + i >= MAX_ASF_CELLS)
                {
                  WRRC_MSG1_ERROR("%d allowed CSG cells detected. Discard remaining!!",MAX_ASF_CELLS);
                  break;
                }
                rrc_csp_int_data.temp_csg_list.csg_cell_info[num_w_entries + i].csg_cell_l1_info.rat = SYS_RAT_LTE_RADIO_ACCESS;
                rrc_csp_int_data.temp_csg_list.csg_cell_info[num_w_entries + i].csg_cell_l1_info.rat_u.lcell.phy_cell_id 
                  = plmn_srch_rsp->detected_csg_cell_list.cell[i].rat_u.lcell.pci;
                rrc_csp_int_data.temp_csg_list.csg_cell_info[num_w_entries + i].csg_cell_l1_info.rat_u.lcell.earfcn 
                  = plmn_srch_rsp->detected_csg_cell_list.cell[i].rat_u.lcell.earfcn;
                rrc_csp_int_data.temp_csg_list.csg_cell_info[num_w_entries + i].csg_cell_l1_info.rat_u.lcell.rsrp 
                  = plmn_srch_rsp->detected_csg_cell_list.cell[i].rat_u.lcell.rsrp;
                rrc_csp_int_data.temp_csg_list.csg_cell_info[num_w_entries + i].csg_cell_l1_info.rat_u.lcell.rsrq 
                  = plmn_srch_rsp->detected_csg_cell_list.cell[i].rat_u.lcell.rsrq;
                rrc_csp_int_data.temp_csg_list.csg_cell_info[num_w_entries + i].csg_cell_l1_info.rat_u.lcell.rssi 
                  = plmn_srch_rsp->detected_csg_cell_list.cell[i].rat_u.lcell.rssi;
                rrc_csp_int_data.temp_csg_list.csg_cell_info[num_w_entries + i].csg_cell_l1_info.rat_u.lcell.q_rxlevmin 
                  = plmn_srch_rsp->detected_csg_cell_list.cell[i].rat_u.lcell.q_rxlevmin;
                rrc_csp_int_data.temp_csg_list.csg_cell_info[num_w_entries + i].csg_cell_l1_info.rat_u.lcell.p_max 
                  = plmn_srch_rsp->detected_csg_cell_list.cell[i].rat_u.lcell.p_max;
                rrc_csp_int_data.temp_csg_list.csg_cell_info[num_w_entries + i].csg_cell_l1_info.rat_u.lcell.q_qualmin 
                  = plmn_srch_rsp->detected_csg_cell_list.cell[i].rat_u.lcell.q_qualmin;
              }
              rrc_csp_int_data.temp_csg_list.num_entries = num_w_entries + i;
            }
#endif
          }
          else
          {
            WRRC_MSG0_HIGH("WTOL: Srch NOT completed on LTE. Wait for next DRX.");
          }
          if((rrc_csp_int_data.send_prtl_results_from_lte_due_to_guard_timer_expiry == TRUE ||
              rrc_csp_int_data.send_partial_results)&&
              plmn_srch_rsp->srch_done)
          {
            /* If RRC is waiting for partial results from LTE and LTE has sent srch done response
               then consider these results as the response for partial results req as well and send them to NAS */
            rrc_csp_int_data.send_prtl_results_from_lte_due_to_guard_timer_expiry = FALSE;
            rrc_csp_bplmn_send_mm_plmn_list_cnf_cmd(WTOW_SEARCH_PARTIAL, rrc_csp_int_data.bplmn_trans_id);
          }
          if((rrc_csp_int_data.curr_scan == RRC_CSP_PLMN_LIST_SCAN) &&
            (((rrc_csp_int_data.plmn_srch_order.curr_rat_srch_idx + 1) < rrc_csp_int_data.plmn_srch_order.num_rats)
                &&(rrc_csp_int_data.plmn_srch_order.rat[rrc_csp_int_data.plmn_srch_order.curr_rat_srch_idx + 1] ==
                SYS_RAT_GSM_RADIO_ACCESS)))
          {
            if(!plmn_srch_rsp->srch_done)
            {
              rrccsp_send_irat_bplmn_abort_req();
            }
            /*LTE is searched and GSM is next RAT to be searched, do no do suspend and resume procedure again*/
            rrc_csp_init_wtog_plmn_srch_int_data_across_rats();
            rrc_csp_int_data.plmn_srch_order.curr_rat_srch_idx++;
            rrc_csp_int_data.bplmn_interrat_type = RRC_CSP_INTERRAT_GSM;
            rrccsp_send_irat_bplmn_search_req();
            next_substate = RRCCSP_WT_RESPONSE_FROM_RR;
          }
          else
          {
            /* No need to send Inter-RAT BPLMN Search request to RR */
            rrccsp_send_mode_change_req_to_mcm(RRC_MODE_ACTIVE);
            next_substate = RRCCSP_WT_RESUME_MODE_CHANGE_CNF;
          }
        }
        break;

      case LTE_RRC_WCDMA_REDIR_FAILED_RSP:
        {
          /* Send Mode change request to MCM to resume the WCDMA mode
           * and wait for the confirmation from MCM if RRC mode is not ACTIVE
           */
          rrclog_wcdma_to_lte_redir_end_event_type wtol_redir_event;
          rrccsp_send_mode_change_req_to_mcm(RRC_MODE_ACTIVE);
          next_substate = RRCCSP_WT_RESUME_MODE_CHANGE_CNF;
          wtol_redir_event.status = WTOL_FAILURE;
          event_report_payload(EVENT_WCDMA_TO_LTE_REDIRECTION_END, sizeof(wtol_redir_event),
                         (void *)&wtol_redir_event);
        }
        break;
      default:
        WRRC_MSG1_HIGH("LTE_IRAT: Invalid cmd %x from LTE RRC",cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.msg_hdr.id);
        break;
    }
  }
#endif

  return( next_substate );
} /* rrccsp_wait_response_from_rr_hdlr */


#ifdef FEATURE_GAN
#error code not present
#endif /* FEATURE_GAN */

#ifdef FEATURE_GAN_3G_ROVE_OUT_ONLY
#error code not present
#endif

#ifdef FEATURE_GAN_3G
#error code not present
#endif

/*===========================================================================

FUNCTION        RRCCSP_SEND_RRC_RR_STOP_WCDMA_CNF

DESCRIPTION     This function sends RRC_RR_STOP_WCDMA_CNF to RR

DEPENDENCIES
                None

RETURN VALUE
                None

SIDE EFFECTS
                None

===========================================================================*/
void rrccsp_send_rrc_rr_stop_wcdma_cnf
(
  rrc_rr_stop_wcdma_cause_e_type stop_cause
)
{
  rrc_rr_stop_wcdma_cnf_type stop_wcdma_cnf;
  stop_wcdma_cnf.stop_cnf_cause = stop_cause;
  /* Send the RRC_RR_STOP_WCDMA_CNF message to RR */
  rr_send_rrc_message_to_rr_internal((void *)(&(stop_wcdma_cnf)), RRC_RR_STOP_WCDMA_CNF,
          sizeof(rrc_rr_stop_wcdma_cnf_type));

  WRRC_MSG1_HIGH("RRC_RR_STOP_WCDMA_CNF sent to GSM RR stop_cause = %d ", stop_cause);
}

/*===========================================================================

FUNCTION        RRCCSP_SEND_RR_RRC_STOP_GSM_REQ

DESCRIPTION     This function sends RR_RRC_STOP_GSM_REQ to RR

DEPENDENCIES
                None

RETURN VALUE
                None

SIDE EFFECTS
                None

===========================================================================*/
void rrccsp_send_rr_rrc_stop_gsm_req
(
  rrc_rr_stop_wcdma_cause_e_type stop_cause
)
{
  rr_rrc_stop_gsm_req_type rr_rrc_stop_gsm_req;

  rr_rrc_stop_gsm_req.stop_req_cause = stop_cause;

  /* Send the RRC_RESELECT_FROM_GAN_REJ message to RR */
  rr_send_rrc_message_to_rr_internal((void *)(&(rr_rrc_stop_gsm_req)), RR_RRC_STOP_GSM_REQ,
          sizeof(rr_rrc_stop_gsm_req_type));

  WRRC_MSG1_HIGH("RR_RRC_STOP_GSM_REQ sent to GSM RR, stop cause = %d", stop_cause);
}

#ifdef FEATURE_WCDMA_TO_TDSCDMA
/*===========================================================================

FUNCTION        RRCCSP_SEND_TDSRRC_RRC_STOP_TDS_REQ

DESCRIPTION     This function sends TDSRRC_RRC_STOP_TDS_REQ to TDS RRC

DEPENDENCIES
                None

RETURN VALUE
                None

SIDE EFFECTS
                None

===========================================================================*/
void rrccsp_send_tdsrrc_rrc_stop_tds_req
(
  rrc_rr_stop_wcdma_cause_e_type stop_cause
)
{
  tdsrrc_rrc_cmd_type *tdsrrc_cmd_buf;

  /* SEND the TDSRRC_RRC_STOP_TDS_REQ to TDS RRC */
  /* Get a buffer from TDS RRC task */
  if((tdsrrc_cmd_buf = tdsrrc_get_rrc_cmd_buf()) == NULL)
  {
    ERR_FATAL("No TDS RRC buffer for TDS RRC cmd 0x%x",TDSRRC_RRC_STOP_TDS_REQ,0,0);
  }

  tdsrrc_cmd_buf->cmd_hdr.cmd_id = TDSRRC_RRC_STOP_TDS_REQ;
  tdsrrc_cmd_buf->cmd.tdsrrc_rrc_stop_tds_req.stop_req_cause = stop_cause;

  /* Put the command on TDS RRC queue */
  tdsrrc_put_rrc_cmd(tdsrrc_cmd_buf);

  WRRC_MSG1_HIGH("TDSRRC_RRC_STOP_TDS_REQ sent to TDS RRC, stop cause = %d", stop_cause);
}

/*===========================================================================

FUNCTION        RRCCSP_SEND_RRC_TDSRRC_STOP_WCDMA_CNF

DESCRIPTION     This function sends RRC_TDSRRC_STOP_WCDMA_CNF to TDS RRC

DEPENDENCIES
                None

RETURN VALUE
                None

SIDE EFFECTS
                None

===========================================================================*/
void rrccsp_send_rrc_tdsrrc_stop_wcdma_cnf
(
  rrc_rr_stop_wcdma_cause_e_type stop_cause
)
{
  tdsrrc_rrc_cmd_type *tdsrrc_cmd_buf;
  
  /* SEND the RRC_TDSRRC_STOP_WCDMA_CNF to TDS RRC */
  /* Get a buffer from TDS RRC task */
  if((tdsrrc_cmd_buf = tdsrrc_get_rrc_cmd_buf()) == NULL)
  {
    ERR_FATAL("No TDS RRC buffer for TDS RRC cmd 0x%x",RRC_TDSRRC_STOP_WCDMA_CNF,0,0);
  }

  tdsrrc_cmd_buf->cmd_hdr.cmd_id = RRC_TDSRRC_STOP_WCDMA_CNF;
  tdsrrc_cmd_buf->cmd.rrc_tdsrrc_stop_wcdma_cnf.stop_cnf_cause = stop_cause;

  /* Put the command on TDS RRC queue */
  tdsrrc_put_rrc_cmd(tdsrrc_cmd_buf);
  
  WRRC_MSG1_HIGH("RRC_TDSRRC_STOP_WCDMA_CNF sent to TDS RRC, stop cause = %d", stop_cause);
}
#endif

/*===========================================================================

FUNCTION        RRCCSP_WAIT_RR_ABORT_CNF_HDLR

DESCRIPTION
                This is a handler for events received in
                RRCCSP_WT_RR_ABORT_CNF substate of
                the Cell Selection Procedure.
                Depending on the event, it further calls a function for
                processing the event in this CSP substate.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_wait_rr_abort_cnf_hdlr( rrc_cmd_type *cmd_ptr )
{
  rrc_csp_substate_e_type   next_substate;
  /* Inter-RAT command */
  rrc_rr_cmd_type *rr_cmd;

  boolean interrat_cmd = FALSE;

#if defined (FEATURE_LTE_TO_WCDMA) || defined (FEATURE_WCDMA_TO_LTE)
  if(cmd_ptr->cmd_hdr.cmd_id == RRC_LTE_RRC_CMD)
  {
    interrat_cmd = TRUE;
  }
#endif

  if((((uint32)cmd_ptr->cmd_hdr.cmd_id & RRC_RR_CMD_ID_BASE) == RRC_RR_CMD_ID_BASE) )
  {
    interrat_cmd = TRUE;
  }


  next_substate = RRCCSP_WT_RR_ABORT_CNF;
/*lint -e58*/
  /* If RRC is waiting to process STOP_WCDMA_MODE_REQ from NAS, resume stopping
     W if ABORT_CNF is received from RR or the guard timer has expired.*/
  if((rrc_csp_int_data.stop_pending_for_wtog_abort == TRUE) && ((interrat_cmd) || (cmd_ptr->cmd_hdr.cmd_id == RRC_WTOG_ABORT_GUARD_TIMER_EXPIRED_IND)))
  {
    rrctmr_stop_timer(RRCTMR_WTOG_ABORT_GUARD_TIMER); /* Fall through*/

#ifdef FEATURE_WCDMA_TO_LTE
    if(cmd_ptr->cmd_hdr.cmd_id == RRC_LTE_RRC_CMD)
    {
      switch(cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.msg_hdr.id)
      {
        case LTE_RRC_WCDMA_ABORT_RESEL_RSP:
#ifdef FEATURE_QSH_EVENT_METRIC
          wrrc_qsh_log_cell_resel_stats(CELL_RESEL_FAIL,WRRC_METRIC_UPDATE);
#endif
          WRRC_MSG0_HIGH("WTOL: Received LTE_RRC_WCDMA_ABORT_RESEL_RSP from LTE RRC");
          break;
        case LTE_RRC_WCDMA_ABORT_REDIR_RSP:
          WRRC_MSG0_HIGH("WTOL: Received LTE_RRC_WCDMA_ABORT_REDIR_RSP from LTE RRC");
          break;
        case LTE_RRC_WCDMA_ABORT_PLMN_SRCH_RSP:
          WRRC_MSG0_HIGH("WTOL: Received LTE_RRC_WCDMA_ABORT_PLMN_SRCH_RSP from LTE RRC");
          break;
        default:
          WRRC_MSG2_HIGH("LTE cmd 0x%x not processed in CSP sstate %d",
                       cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.msg_hdr.id, rrc_csp_substate);
          break;
      }
    }
#endif

    MSG_HIGH("Cmd 0x%x recvd, CSP sstate %d stop pending %d",
                   cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 
                   rrc_csp_int_data.stop_pending_for_wtog_abort);
  
    rrccsp_send_continue_stop_mode_req_to_mcm();
    rrc_csp_int_data.stop_pending_for_wtog_abort = FALSE;
    if(rrc_csp_int_data.pending_type == RRC_CSP_MODE_CHANGE_REQ_PENDING)
    {
      rrccsp_send_mode_change_req_to_mcm(RRC_MODE_CHANGE);
      return (RRCCSP_WT_STOP_MODE_CHANGE_CNF);
    }
    return (RRCCSP_WT_RESUME_MODE_CHANGE_CNF);
  }
/*lint +e58*/
  if(!interrat_cmd)
  {
    switch( cmd_ptr->cmd_hdr.cmd_id )
    {
      case RRC_BPLMN_SUSPEND_REQ:
        rrccsp_handle_passive_bplmn_suspend_req( cmd_ptr );
        break;

      case RRC_BPLMN_GUARD_SRCH_TIMER_EXPIRED_IND:
        if((rrc_csp_int_data.curr_scan == RRC_CSP_WTOG_BPLMN_AUTOMATIC_SCAN)
            || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOG_BPLMN_MANUAL_SCAN))
        {
          if(!rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_aborted)
          {
            rrccsp_send_irat_bplmn_abort_req();
          }
          else
          {
            WRRC_MSG0_HIGH("WTOG: search already aborted");
          }
          rrc_csp_wtog_bplmn_int_data.restart_bplmn_search = FALSE;
        }
        else
        {
          rrccsp_cleanup_bplmn_state();
        }
        break;

      case RRC_BPLMN_SEARCH_ABORT_REQ:
        if(    (rrc_csp_int_data.curr_scan == RRC_CSP_WTOG_BPLMN_AUTOMATIC_SCAN)
            || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOG_BPLMN_MANUAL_SCAN)
            || (rrc_csp_int_data.curr_scan == RRC_CSP_PLMN_LIST_SCAN)
          )
        {
          if(!rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_aborted)
          {
            rrccsp_send_irat_bplmn_abort_req();
          }
          else
          {
            WRRC_MSG0_HIGH("WTOG: search already aborted");
          }
          rrc_csp_wtog_bplmn_int_data.restart_bplmn_search = FALSE;
        }
        else
        {
          rrccsp_cleanup_bplmn_state();
        }
        break;

        /* Added handling for RRC_INITIATE_CELL_SELECTION_IND here for CR651569 
         * RRC receives abort from NAS when redirection to GSM/LTE is in progress. 
         * RRC aborts redirection and posts initiate cell sel indication.
         * CSP moves to WT_RR_ABORT_CNF and initiate cell sel indication is not handled here 
         */
      case RRC_INITIATE_CELL_SELECTION_IND:
        MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                           cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
        if(cmd_ptr->cmd.initiate_cell_sel_ind.cause == RRC_TRANSITION_TO_DISCONNECTED)
        {
            WRRC_MSG1_HIGH("Saving initiate cell sel, proc %d",
                       cmd_ptr->cmd.initiate_cell_sel_ind.proc);
            rrc_csp_int_data.init_cell_sel_ind_during_wtointerrat = TRUE;
        }
        else
        {
          WRRC_MSG2_HIGH("Cause %d not handled %d CSP sstate ",
                    cmd_ptr->cmd.initiate_cell_sel_ind.cause, rrc_csp_substate);
        }
        break;

      default:
        WRRC_MSG2_HIGH("Cmd 0x%x not processed in CSP sstate %d",
                              cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);
        break;
    }
  }
  else if(((uint32)cmd_ptr->cmd_hdr.cmd_id & RRC_RR_CMD_ID_BASE) == RRC_RR_CMD_ID_BASE)
  {
    rr_cmd = ((rrc_rr_cmd_type *)cmd_ptr);    /*lint !e740 */

    switch(rr_cmd->cmd_hdr.cmd_id)
    {
      case RR_INTERRAT_REDIRECT_ABORT_CNF:
        if(rr_cmd->cmd.interrat_redirect_abort_cnf.abort_status == RRC_RR_SUCCESS)
        {
          /* Send Mode change request to MCM to resume WCDMA
           * and wait for the confirmation from MCM
           */
          WRRC_MSG0_HIGH("rr_redirect_abort_cnf(SUCCESS), resume WCDMA");


          rrccsp_send_mode_change_req_to_mcm(RRC_MODE_ACTIVE);
          next_substate = RRCCSP_WT_RESUME_MODE_CHANGE_CNF;
        }
        else
        {
          WRRC_MSG0_HIGH("rr_redirect_abort_cnf(FAILURE), wait for STOP from MM");
          next_substate = RRCCSP_NO_CELL_SELECTED;
        }
        break;

      case RR_INTERRAT_RESELECTION_ABORT_CNF:
        WRRC_MSG0_HIGH("Rcvd RR_INTERRAT_RESELECTION_ABORT_CNF from RR in CSP st WT_ABORT_CNF");
#ifdef FEATURE_QSH_EVENT_METRIC
		wrrc_qsh_log_cell_resel_stats(CELL_RESEL_FAIL,WRRC_METRIC_UPDATE);
#endif
        rrccsp_send_mode_change_req_to_mcm(RRC_MODE_ACTIVE);
        next_substate = RRCCSP_WT_RESUME_MODE_CHANGE_CNF;
        break;

      case RR_INTERRAT_PLMN_SRCH_ABORT_CNF:
        WRRC_MSG0_HIGH("Rcvd PLMN_SRCH_ABORT_CNF. Send list_cnf to NAS");

        rrccsp_send_mode_change_req_to_mcm(RRC_MODE_ACTIVE);
        next_substate = RRCCSP_WT_RESUME_MODE_CHANGE_CNF;
        break;

      default:
        WRRC_MSG2_HIGH("Cmd 0x%x not processed in CSP sstate %d",
                              rr_cmd->cmd_hdr.cmd_id, rrc_csp_substate);
        break;
    }
  }
#ifdef FEATURE_WCDMA_TO_LTE
  else if(cmd_ptr->cmd_hdr.cmd_id == RRC_LTE_RRC_CMD)
  {
    switch(cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.msg_hdr.id)
    {
      case LTE_RRC_WCDMA_ABORT_RESEL_RSP:
      case LTE_RRC_WCDMA_ABORT_REDIR_RSP:
        WRRC_MSG0_HIGH("WTOL: Received interrat abort resp from LTE RRC. Resume W.");
        rrccsp_send_mode_change_req_to_mcm(RRC_MODE_ACTIVE);
        next_substate = RRCCSP_WT_RESUME_MODE_CHANGE_CNF;
        break;
      case LTE_RRC_WCDMA_ABORT_PLMN_SRCH_RSP:
        WRRC_MSG0_HIGH("WTOL: Received LTE_RRC_WCDMA_ABORT_PLMN_SRCH_RSP from LTE RRC");
        rrccsp_send_mode_change_req_to_mcm(RRC_MODE_ACTIVE);
        next_substate = RRCCSP_WT_RESUME_MODE_CHANGE_CNF;
        break;
      default :
        WRRC_MSG1_HIGH("WTOL: Received Invalid cmd %x from LTE RRC",
            cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.msg_hdr.id);
        break;
    }
  }
#endif
  return( next_substate );
} /* rrccsp_wait_rr_abort_cnf_hdlr */

/*===========================================================================

FUNCTION        RRCCSP_WT_SUSPEND_MODE_CHANGE_CNF_HDLR

DESCRIPTION
                This is a handler for events received in
                RRCCSP_WT_SUSPEND_MODE_CHANGE_CNF substate of
                the Cell Selection Procedure.
                Depending on the event, it further calls a function for
                processing the event in this CSP substate.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_wt_suspend_mode_change_cnf_hdlr( rrc_cmd_type *cmd_ptr )
{
  rrc_csp_substate_e_type   next_substate;

  next_substate = RRCCSP_WT_SUSPEND_MODE_CHANGE_CNF;

  switch( cmd_ptr->cmd_hdr.cmd_id )
  {
    case RRC_CHANGE_MODE_CNF:
      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
      if(cmd_ptr->cmd.change_mode_cnf.mode == RRC_MODE_STANDBY)
      {
        switch(rrc_csp_int_data.curr_scan)
        {
          case RRC_CSP_WCDMA_TO_GSM_CELL_RESELECTION_SCAN:
            /* Update CCM with cell loss */
            rrc_ccm_update_with_cell_loss();            
#ifdef FEATURE_WCDMA_TO_LTE
            if(rrc_csp_int_data.interrat_type == RRC_CSP_INTERRAT_LTE)
            {
              rrccsp_send_lte_interrat_reselection_req(&rrc_csp_int_data.saved_rrc_cmd);
            }
            else
#endif
            {
              rrccsp_send_interrat_reselection_req(&rrc_csp_int_data.saved_rrc_cmd);
            }
            next_substate = RRCCSP_WT_RESPONSE_FROM_RR;
            break;

#ifdef FEATURE_GAN
          #error code not present
#endif /* FEATURE_GAN */

          case RRC_CSP_INTER_RAT_REDIRECTION_SCAN:
            if(rrc_csp_int_data.init_cell_sel_ind_during_wtointerrat)
            {
#ifdef FEATURE_WCDMA_FAST_RETURN_TO_LTE_AFTER_CSFB
              /* Also update CCM with cell loss for redirection via conn release msg. This is
                 required for the scenario where buffered EST_REQ has to be handled after 
                 resume failure. This chnage will make sure that RCE waits for UE to camp 
                 while CSP preforms ACQ-DB search after resume failure. */

              if((rrc_csp_int_data.saved_rrc_cmd.cmd.redirect_req.proc_id == RRC_PROCEDURE_RCR)
                 || (rrc_csp_int_data.saved_rrc_cmd.cmd.redirect_req.proc_id == RRC_PROCEDURE_CSP))
              {
                rrc_ccm_update_with_cell_loss();
              }
#endif
              /* No need to send Inter-RAT redirection request to RR */
              rrccsp_send_mode_change_req_to_mcm(RRC_MODE_ACTIVE);
              next_substate = RRCCSP_WT_RESUME_MODE_CHANGE_CNF;
            }
            else
            {
#ifdef FEATURE_WCDMA_FAST_RETURN_TO_LTE_AFTER_CSFB
              WRRC_MSG1_HIGH("CSFB_HACK: Proc which initiated redirection req: rrc_proc_e_type_value%d",
                 rrc_csp_int_data.saved_rrc_cmd.cmd.redirect_req.proc_id);
              if((rrc_csp_int_data.saved_rrc_cmd.cmd.redirect_req.proc_id == RRC_PROCEDURE_CSP) &&
                  (rrc_csp_int_data.interrat_type == RRC_CSP_INTERRAT_LTE))
              {
                WRRC_MSG0_HIGH("CSFB_HACK: Send blind redirection to LTE");
                rrccsp_send_lte_blind_redirection_req();
                csfb_extended_status = CSFB_INVALID;
              }
              else
#endif
#ifdef FEATURE_WCDMA_TO_LTE
              if(rrc_csp_int_data.saved_rrc_cmd.cmd.redirect_req.choice == RRC_INTER_SYSTEM_LTE)
              {
                rrc_csp_int_data.interrat_type = RRC_CSP_INTERRAT_LTE;
                rrccsp_send_lte_interrat_redirection_req();
              }
              else
#endif
              {
                rrccsp_send_interrat_redirection_req();
              }
              next_substate = RRCCSP_WT_RESPONSE_FROM_RR;
            }
            break;

          case RRC_CSP_OUT_OF_SERVICE_AREA_SCAN:
            WRRC_MSG0_HIGH("OOS: Md Chg Success. Sending redirection req to G");
            if(rrc_csp_int_data.init_cell_sel_ind_during_wtointerrat)
            {
              /* No need to send Inter-RAT redirection request to RR */
              rrccsp_send_mode_change_req_to_mcm(RRC_MODE_ACTIVE);
              next_substate = RRCCSP_WT_RESUME_MODE_CHANGE_CNF;
            }
            else
            {
              rrccsp_send_interrat_redirection_req();
              next_substate = RRCCSP_WT_RESPONSE_FROM_RR;
            }
            break;

          case RRC_CSP_CELL_DCH_TO_CELL_FACH_SCAN:
          case RRC_CSP_CELL_DCH_TO_CELL_PCH_SCAN:
          case RRC_CSP_CELL_DCH_TO_URA_PCH_SCAN:
            if(rrc_csp_int_data.dch_to_fach_pch_tmr_expd)
            {
              WRRC_MSG0_HIGH("DCH->FACH/PCH tmr already expd. Resuming W");
              /* No need to send Inter-RAT redirection request to RR */
              rrccsp_send_mode_change_req_to_mcm(RRC_MODE_ACTIVE);
              next_substate = RRCCSP_WT_RESUME_MODE_CHANGE_CNF;
            }
            else
            {
              WRRC_MSG0_HIGH("DCH->FACH/PCH Md Chg Success. Sending redirection req to G");
              rrccsp_send_interrat_redirection_req();
              next_substate = RRCCSP_WT_RESPONSE_FROM_RR;
            }
            break;

          case RRC_CSP_CELL_FACH_TO_CELL_FACH_SCAN:
          case RRC_CSP_CELL_FACH_TO_CELL_PCH_SCAN:
          case RRC_CSP_CELL_FACH_TO_URA_PCH_SCAN:
            if(rrc_csp_int_data.fach_to_fach_pch_tmr_expd)
            {
              WRRC_MSG0_HIGH("FACH->FACH/PCH tmr already expd. Resuming W");
              /* No need to send Inter-RAT redirection request to RR */
              rrccsp_send_mode_change_req_to_mcm(RRC_MODE_ACTIVE);
              next_substate = RRCCSP_WT_RESUME_MODE_CHANGE_CNF;
            }
            else
            {
              WRRC_MSG0_HIGH("FACH->FACH/PCH Md Chg Success. Sending redirection req to G");
              rrccsp_send_interrat_redirection_req();
              next_substate = RRCCSP_WT_RESPONSE_FROM_RR;
            }
            break;

#ifdef FEATURE_PCS_850_FREQ_SCAN_OPTIMIZATION
          case RRC_CSP_CELL_SELECTION_SCAN:
            WRRC_MSG0_HIGH("Md Chg Success. Snding Service Search Request to GSM-RR");
            if(rrc_csp_int_data.init_cell_sel_ind_during_wtointerrat)
            {
              /* No need to send Inter-RAT redirection request to RR */
              rrccsp_send_mode_change_req_to_mcm(RRC_MODE_ACTIVE);
              next_substate = RRCCSP_WT_RESUME_MODE_CHANGE_CNF;
            }
            else
            {
              rrccsp_send_interrat_redirection_req();
              next_substate = RRCCSP_WT_RESPONSE_FROM_RR;
            }
            break;
#endif

          case RRC_CSP_WTOG_BPLMN_AUTOMATIC_SCAN:
            WRRC_MSG0_HIGH("WTOG:: Md Chg Success. Snding WTOG Auto Scan to GSM");
            if((rrc_csp_int_data.init_cell_sel_ind_during_wtointerrat)
               || (rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_aborted)
               || (rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_suspended)
              )
            {
              /* No need to send Inter-RAT BPLMN Search request to RR */
              rrccsp_send_mode_change_req_to_mcm(RRC_MODE_ACTIVE);
              next_substate = RRCCSP_WT_RESUME_MODE_CHANGE_CNF;
            }
            else
            {
              rrccsp_send_irat_bplmn_search_req();
              next_substate = RRCCSP_WT_RESPONSE_FROM_RR;
            }
            break;

          case RRC_CSP_WTOG_BPLMN_MANUAL_SCAN:
            WRRC_MSG0_HIGH("WTOG: Md Chg Success. Snding WTOG Manual Scan to GSM");
            if((rrc_csp_int_data.init_cell_sel_ind_during_wtointerrat)
               || (rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_aborted)
               || (rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_suspended)
              )
            {
              /* No need to send Inter-RAT BPLMN Search request to RR */
              rrccsp_send_mode_change_req_to_mcm(RRC_MODE_ACTIVE);
              next_substate = RRCCSP_WT_RESUME_MODE_CHANGE_CNF;
            }
            else
            {
              rrccsp_send_irat_bplmn_search_req();
              next_substate = RRCCSP_WT_RESPONSE_FROM_RR;
            }
            break;

          case RRC_CSP_PLMN_LIST_SCAN:
            WRRC_MSG0_HIGH("WTOG OOS: Md Chg Success. Snding WTOG Manual Scan to GSM");
            if((rrc_csp_int_data.init_cell_sel_ind_during_wtointerrat)
               || (rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_aborted))
            {
              /* No need to send Inter-RAT BPLMN Search request to RR */
              rrccsp_send_mode_change_req_to_mcm(RRC_MODE_ACTIVE);
              next_substate = RRCCSP_WT_RESUME_MODE_CHANGE_CNF;
            }
            else
            {
              rrccsp_send_irat_bplmn_search_req();
              next_substate = RRCCSP_WT_RESPONSE_FROM_RR;
            }
            break;
#ifdef FEATURE_DUAL_SIM
          case RRC_CSP_UNLOCK_BY_SCAN:
            rrc_ccm_update_with_cell_loss();
            /* Send change mode request to MCM to resume*/
            rrccsp_send_mode_change_req_to_mcm(RRC_MODE_ACTIVE);
            next_substate = RRCCSP_WT_RESUME_MODE_CHANGE_CNF;
            break;
#endif

          default:
            WRRC_MSG1_ERROR("ERR: Unexp Standby cnf, scan = %d",rrc_csp_int_data.curr_scan);
            break;
        }
      }
      else
      {
        /* TBD: Any action if mode change to another mode is received */
        WRRC_MSG2_ERROR("ERR Unexpected Chg Mode CNF to %d in %d state",cmd_ptr->cmd.change_mode_cnf.mode,
                                                                      rrc_csp_substate);
      }
      break;

    case RRC_INITIATE_CELL_SELECTION_IND:
      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
      if(cmd_ptr->cmd.initiate_cell_sel_ind.cause == RRC_TRANSITION_TO_DISCONNECTED)
      {
          WRRC_MSG1_HIGH("Saving initiate cell sel, proc rrc_proc_e_type_value%d",
                     cmd_ptr->cmd.initiate_cell_sel_ind.proc);
          rrc_csp_int_data.init_cell_sel_ind_during_wtointerrat = TRUE;

      }
      else
      {
        WRRC_MSG2_HIGH("Cause %d not handled %d CSP sstate ",
                  cmd_ptr->cmd.initiate_cell_sel_ind.cause, rrc_csp_substate);
      }
      break;

    case RRC_DCH_FACH_CELL_SELECTION_TIMER_EXPIRED_IND:
      if(rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_CELL_FACH_SCAN)
      {
        rrc_csp_int_data.dch_to_fach_pch_tmr_expd = TRUE;
      }
      else
      {
        WRRC_MSG1_HIGH("Ignoring Cell Sel Tmr Exp in %d scan", rrc_csp_int_data.curr_scan);
      }
      break;

    case RRC_DCH_PCH_CELL_SELECTION_TIMER_EXPIRED_IND:
      if(   (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_CELL_PCH_SCAN) 
         || (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_URA_PCH_SCAN))
      {
        rrc_csp_int_data.dch_to_fach_pch_tmr_expd = TRUE;
      }
      else
      {
        WRRC_MSG1_HIGH("Ignoring Cell Sel Tmr Exp in %d scan", rrc_csp_int_data.curr_scan);
      }
      break;


    case RRC_FACH_TO_FACH_PCH_CELL_SELECTION_TIMER_EXPIRED_IND:
      if(   (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_FACH_TO_CELL_FACH_SCAN) 
         || (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_FACH_TO_CELL_PCH_SCAN)
         || (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_FACH_TO_URA_PCH_SCAN) )
      {
        rrc_csp_int_data.fach_to_fach_pch_tmr_expd = TRUE;
      }
      else
      {
        WRRC_MSG1_HIGH("Ignoring Cell Sel Tmr Exp in %d scan", rrc_csp_int_data.curr_scan);
      }
      break;


    case RRC_IRAT_ABORT_IND:
      if((rrc_csp_int_data.curr_scan == RRC_CSP_WTOG_BPLMN_AUTOMATIC_SCAN) ||
         (rrc_csp_int_data.curr_scan == RRC_CSP_WTOG_BPLMN_MANUAL_SCAN))
      {
        /* This variable set indicates that BPLMN search is suspended */
        rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_suspended = TRUE;
      }
      else if(rrc_csp_int_data.curr_scan == RRC_CSP_PLMN_LIST_SCAN)
      {
        rrccsp_send_irat_bplmn_abort_req();
      }
      else
      {
        rrccsp_reset_reselection_data();
      }  
      /*This is to take care of scenarios where resume fails and 
        we need to process buffered establishment request if any
        If resume passes LLC updates CCM with camp status after
        receiving channel config CNF*/
      rrc_ccm_update_with_cell_loss();
      rrccsp_send_mode_change_req_to_mcm(RRC_MODE_ACTIVE);
      next_substate = RRCCSP_WT_RESUME_MODE_CHANGE_CNF;
      break;

    case RRC_BPLMN_SUSPEND_REQ:
      if((cmd_ptr->cmd.rrc_csp_bplmn_suspend_req.procedure == RRC_PROCEDURE_IDT) ||
         (cmd_ptr->cmd.rrc_csp_bplmn_suspend_req.procedure == RRC_PROCEDURE_CU))
      {
        /* This varaible set indicates that BPLMN search is suspended */
        rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_suspended = TRUE;
      }
      rrccsp_handle_passive_bplmn_suspend_req( cmd_ptr );
      break;

    case RRC_BPLMN_GUARD_SRCH_TIMER_EXPIRED_IND:
      if((rrc_csp_int_data.curr_scan == RRC_CSP_WTOG_BPLMN_AUTOMATIC_SCAN)
         || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOG_BPLMN_MANUAL_SCAN))
      {
        rrccsp_send_irat_bplmn_abort_req();
      }
      else
      {
        rrccsp_cleanup_bplmn_state();
      }
      break;

    case RRC_BPLMN_SEARCH_ABORT_REQ:
      if(   (rrc_csp_int_data.curr_scan == RRC_CSP_WTOG_BPLMN_AUTOMATIC_SCAN)
         || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOG_BPLMN_MANUAL_SCAN)
         || (rrc_csp_int_data.curr_scan == RRC_CSP_PLMN_LIST_SCAN)
        )
      {
        rrccsp_send_irat_bplmn_abort_req();
      }
      else
      {
        rrccsp_cleanup_bplmn_state();
      }
      break;

    default:
      WRRC_MSG2_HIGH( "Cmd 0x%x not processed in CSP sstate %d",
                            cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);
      break;
  }
  return( next_substate );
} /* rrccsp_wt_suspend_mode_change_cnf_hdlr */


/*===========================================================================

FUNCTION          RRCCSP_SEND_CELL_UPDATE_INITIATE_REQ

DESCRIPTION       This function sends cell update initiate request to CU procedure
                  when UE goes Out of Service Area in Connected State
                  
                  
DEPENDENCIES      NONE

RETURN VALUE
                  CSP substate
                  
SIDE EFFECTS          
                  NONE
===========================================================================*/
rrc_csp_substate_e_type
rrccsp_send_cell_update_initiate_req(rrc_cell_update_cause_e_type cause)
{  
  rrc_cmd_type *csp_out_cmd_ptr;

  if((csp_out_cmd_ptr = rrc_get_int_cmd_buf()) != NULL)
  {
    csp_out_cmd_ptr->cmd_hdr.cmd_id = RRC_CELL_UPDATE_INITIATE_REQ;
    csp_out_cmd_ptr->cmd.initiate_cell_update.cause = cause;
    csp_out_cmd_ptr->cmd.initiate_cell_update.cu_complete_cnf_required = FALSE;
    csp_out_cmd_ptr->cmd.initiate_cell_update.procedure = RRC_PROCEDURE_CSP;

    WRRC_MSG2_HIGH("CELL_UPDATE_INITIATE_REQ with cause %d sent by CSP to CU in rrc state %d",cause,rrc_get_state());
    rrc_put_int_cmd(csp_out_cmd_ptr);     
  }
  if(rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED)
  {
    return(RRCCSP_CAMPED_ACCEPT_CELL);
  }
  else
  {
    return(RRCCSP_CAMPED_SUIT_CELL);
  } 
} /* rrccsp_send_cell_update_initiate_req */

/*===========================================================================

FUNCTION        RRCCSP_SEND_CHANNEL_CONFIG_REQ_ON_WCDMA_RESUME

DESCRIPTION
                This function sends channel config request to L1 for
                SCCPCH setup after successful WCDMA resume

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_send_channel_config_req_on_wcdma_resume(void)
{
  rrc_cmd_type *csp_out_cmd_ptr;
  rrc_state_e_type rrc_current_state = rrc_get_state();
  rrc_csp_substate_e_type next_substate;


  /* If it is for inter-RAT cell reselection, then
     inform LLC to resume */
  if(   (rrc_current_state == RRC_STATE_DISCONNECTED)
     || (rrc_current_state == RRC_STATE_CELL_FACH) 
     || (rrc_current_state == RRC_STATE_CELL_PCH) 
     || (rrc_current_state == RRC_STATE_URA_PCH)
#ifdef FEATURE_DUAL_SIM
    /* Send Channel config req in DCH to resume WCDMA for supporing Preemption in DCH state, */
     || ((rrc_csp_int_data.curr_scan == RRC_CSP_UNLOCK_BY_SCAN) && (rrc_current_state == RRC_STATE_CELL_DCH))
#endif
    )
  {
    /* Inform LLC to set up physical channels */
    /* Allocates the buffer to RRC Internal command */
    if((csp_out_cmd_ptr =  rrc_get_int_cmd_buf()) != NULL)
    {     
      WRRC_MSG0_HIGH("CSP Sending Channel Config Req");
      /* Fill in the command parameters for RRC_CHANNEL_CONFIG_REQ */
      csp_out_cmd_ptr->cmd_hdr.cmd_id                                      = RRC_CHANNEL_CONFIG_REQ;
      csp_out_cmd_ptr->cmd.chan_config_req.procedure                       = RRC_PROCEDURE_CSP;

      /* Fill in parameters for RRC_CHANNEL_CONFIG_REQ command */
      csp_out_cmd_ptr->cmd.chan_config_req.rrc_state_change_required       = FALSE;
      csp_out_cmd_ptr->cmd.chan_config_req.next_state                      = rrc_current_state;
      csp_out_cmd_ptr->cmd.chan_config_req.chan_config_reason              = RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP;
      csp_out_cmd_ptr->cmd.chan_config_req.rrc_channel_config_cnf_required = TRUE;
      csp_out_cmd_ptr->cmd.chan_config_req.num_rb_to_config                = 0;
      csp_out_cmd_ptr->cmd.chan_config_req.release_phychls                 = FALSE;
      csp_out_cmd_ptr->cmd.chan_config_req.release_trchls                  = FALSE;

      rrc_put_int_cmd(csp_out_cmd_ptr);         
    }
    next_substate = RRCCSP_WT_FOR_CHAN_CFG_CNF;
  } 
  else
  {
    WRRC_MSG1_ERROR("ERR change mode succ when RRC in STATE %d for WtoG_BPLMN", rrc_current_state);

    if(rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED)
    {
      next_substate = RRCCSP_CAMPED_ACCEPT_CELL;
    }
    else
    {
      next_substate = RRCCSP_CAMPED_SUIT_CELL;
    } 
  }         

  return next_substate;
} /* rrccsp_send_channel_config_req_on_wcdma_resume */


/*===========================================================================

FUNCTION        RRCCSP_WT_RESUME_MODE_CHANGE_CNF_HDLR

DESCRIPTION
                This is a handler for events received in
                RRCCSP_WT_RESUME_MODE_CHANGE_CNF substate of
                the Cell Selection Procedure.
                Depending on the event, it further calls a function for
                processing the event in this CSP substate.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_wt_resume_mode_change_cnf_hdlr( rrc_cmd_type *cmd_ptr )
{
  rrc_csp_substate_e_type next_substate = RRCCSP_WT_RESUME_MODE_CHANGE_CNF;
  rrc_state_e_type rrc_current_state = rrc_get_state();

  switch( cmd_ptr->cmd_hdr.cmd_id )
  {
    case RRC_CHANGE_MODE_CNF:
      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
      if(cmd_ptr->cmd.change_mode_cnf.mode == RRC_MODE_ACTIVE)
      {
        if(rrc_csp_int_data.init_cell_sel_ind_during_wtointerrat)
        {
          WRRC_MSG0_HIGH("initiate_cell_sel (trans to discon)");

#ifdef FEATURE_DUAL_SIM
          /* With optimization to move to idle if TA duration > re-est timers
             initiate cell selection is posted when LTA resume is in progress 
             TRM extension flag is not reset when releasing the lock since curr scan is UNLOCK BY */
          if(rrc_csp_int_data.curr_scan == RRC_CSP_UNLOCK_BY_SCAN)
          {
            rrc_csp_int_data.curr_scan = RRC_CSP_CELL_SELECTION_SCAN;
          }
#endif

          rrc_csp_send_chan_release();

          next_substate = rrc_csp_start_sel_leaving_conn_mode();
          rrc_csp_int_data.init_cell_sel_ind_during_wtointerrat = FALSE;
        }
        else 
        {
          if(cmd_ptr->cmd.change_mode_cnf.status == TRUE)
          {
           /* No need to stop DCH->FACH cell selection timer as it should
            * not be active at this point during cell reselection.
            */
            switch(rrc_csp_int_data.curr_scan)
            {
              case RRC_CSP_WCDMA_TO_GSM_CELL_RESELECTION_SCAN:
                /* Reset reselection variables */
                rrccsp_reset_reselection_data();
                /* Reset CSP scan type. This is needed to drop CTCH if there
                 * is a BPLMN search request after a W2X reselection failure
                 */
                rrc_csp_int_data.curr_scan = RRC_CSP_CELL_SELECTION_SCAN;
                next_substate = rrccsp_send_channel_config_req_on_wcdma_resume();
                break;

#ifdef FEATURE_GAN
              #error code not present
#endif
#ifdef FEATURE_DUAL_SIM
              case RRC_CSP_UNLOCK_BY_SCAN:
                next_substate = rrccsp_send_channel_config_req_on_wcdma_resume();
                break;
#endif

              case RRC_CSP_INTER_RAT_REDIRECTION_SCAN:
                /* For redirection failure through connection release, release all channels
                 * and start leaving connected mode scan.
                 */
                if(rrc_get_state() != RRC_STATE_CONNECTING)
                {
                  next_substate = rrc_csp_start_sel_leaving_conn_mode();
                }
                else
                {
                  /* Send RRC_REDIRECT_CNF (Failure) to RCE */
                  rrccsp_send_rce_redirect_cnf(RRC_REDIRECT_FAILURE, RRC_REDIRECT_GSM_FAILURE);
                  /* Reset CSP scan type. This is needed to drop CTCH if there
                   * is a BPLMN search request after a W2X redirection failure
                   */
                  rrc_csp_int_data.curr_scan = RRC_CSP_CELL_SELECTION_SCAN;
                  if(rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED)
                  {
                    next_substate = RRCCSP_CAMPED_ACCEPT_CELL;
                  }
                  else
                  {
                    next_substate = RRCCSP_CAMPED_SUIT_CELL;
                  }
                  WRRC_MSG0_HIGH("Sent REDIRECT_CNF (INTERRAT_FAILURE) to RCE");
                }
                break;

              case RRC_CSP_OUT_OF_SERVICE_AREA_SCAN:
                ERR_FATAL("ERR: Resume with success from L1 when UE is OOS", 0, 0, 0);
                break;

              case RRC_CSP_CELL_DCH_TO_CELL_FACH_SCAN:
              case RRC_CSP_CELL_DCH_TO_CELL_PCH_SCAN:
              case RRC_CSP_CELL_DCH_TO_URA_PCH_SCAN:
                ERR_FATAL("ERR: resume succ not expected.UE stuck", 0, 0, 0);
                break;


              case RRC_CSP_CELL_FACH_TO_CELL_FACH_SCAN:
              case RRC_CSP_CELL_FACH_TO_CELL_PCH_SCAN:
              case RRC_CSP_CELL_FACH_TO_URA_PCH_SCAN:
                ERR_FATAL("ERR: resume succ not expected.UE stuck", 0, 0, 0);
                break;

#ifdef FEATURE_PCS_850_FREQ_SCAN_OPTIMIZATION
              case RRC_CSP_CELL_SELECTION_SCAN:
                ERR_FATAL("ERR: Resume with success from L1 when UE is OOS in Idle Mode", 0, 0, 0);
                break;
#endif

              case RRC_CSP_WTOG_BPLMN_AUTOMATIC_SCAN:
                WRRC_MSG0_HIGH("WTOG: Resume succ after rcving Auto BPLMN Srch Cnf from RR");

                /* This flag is set when Abort Confirmation is received from IAT.
                 * We do not call the bplmn_cleanup function on receiving abort cnf
                 * as that also clears the scan type which is a problem when
                 * resume cnf is received in this substate.
                 */
                if(!rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_aborted)
                {
                  if(rrc_csp_wtog_bplmn_int_data.wtog_srch_done)
                  {
                    if(rrc_csp_wtog_bplmn_int_data.wtog_hplmn_found)
                    {
                      WRRC_MSG0_HIGH("WTOG: HPLMN found on GSM. Send PLMN_LIST_CNF to NAS");
                      rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_STOP, TRUE, FALSE);
                    }
                    else 
                    {
                      WRRC_MSG0_HIGH("WTOG: Srch done but GSM HPLMN !Fnd");
                      if(rrc_csp_int_data.plmn_srch_order.curr_rat_srch_idx >= (rrc_csp_int_data.plmn_srch_order.num_rats -1))
                      {
                        WRRC_MSG0_HIGH("WTOG: Send PLMN_LIST_CNF to NAS");
                        rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_STOP, TRUE, FALSE);
                      }
                      else
                      {
                        WRRC_MSG0_HIGH("WTOG: Search on W");
                        rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_SUSPEND, FALSE, FALSE);
                        rrc_csp_int_data.plmn_srch_order.curr_rat_srch_idx++;
#ifdef FEATURE_WCDMA_TO_LTE
                        if((rrc_csp_int_data.bplmn_interrat_type == RRC_CSP_INTERRAT_GSM) && 
                           (rrc_csp_int_data.plmn_srch_order.rat[rrc_csp_int_data.plmn_srch_order.curr_rat_srch_idx] 
                             == SYS_RAT_LTE_RADIO_ACCESS))
                        {
                          rrc_csp_init_wtog_plmn_srch_int_data_across_rats();
                          rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_active = TRUE;
                          rrc_csp_int_data.bplmn_interrat_type = RRC_CSP_INTERRAT_LTE;
                        }
                        else if((rrc_csp_int_data.bplmn_interrat_type == RRC_CSP_INTERRAT_LTE) && 
                                   (rrc_csp_int_data.plmn_srch_order.rat[rrc_csp_int_data.plmn_srch_order.curr_rat_srch_idx] 
                                      == SYS_RAT_GSM_RADIO_ACCESS))
                        {
                          rrc_csp_init_wtog_plmn_srch_int_data_across_rats();
                          rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_active = TRUE;
                          rrc_csp_int_data.bplmn_interrat_type = RRC_CSP_INTERRAT_GSM;
                        }
                        else
#endif
                        {
                          rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_active = FALSE;
                        }
                      }
                    } 
                  }
                  else
                  {
                    WRRC_MSG0_HIGH("WTOG: Srch NOT completed on GSM. Wait for next DRX");
                    rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_SUSPEND, FALSE,  FALSE);
                  }
                }
                /* Search has been aborted. Cleanup BPLMN state */
                else
                {
                  WRRC_MSG0_HIGH("WTOG: Srch already aborted. Cleanup BPLMN state");
                  rrccsp_cleanup_bplmn_state();
                }
                next_substate = rrccsp_send_channel_config_req_on_wcdma_resume();
                break;

              case RRC_CSP_WTOG_BPLMN_MANUAL_SCAN: 
                WRRC_MSG0_HIGH("WTOG: Resume succ after rcving Manual BPLMN Srch Cnf from RR");
  
                /* This flag is set when Abort Confirmation is received from GSM.
                 * We do not call the bplmn_cleanup function on receiving abort cnf
                 * as that also clears the scan type which is a problem when
                 * resume cnf is received in this substate.
                 */
                if(!rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_aborted)
                {
                  if(rrc_csp_wtog_bplmn_int_data.wtog_srch_done)
                  {
                    if(rrc_csp_int_data.plmn_srch_order.curr_rat_srch_idx >= (rrc_csp_int_data.plmn_srch_order.num_rats -1))
                    {
                      WRRC_MSG0_HIGH("WTOG: Srch done on GSM for Manual Srch. Send PLMN_LIST_CNF to NAS");
                      rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_STOP, TRUE, FALSE);
                    }
                    else
                    {
                      rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_SUSPEND, FALSE, FALSE);
                      rrc_csp_int_data.plmn_srch_order.curr_rat_srch_idx++;
  #ifdef FEATURE_WCDMA_TO_LTE
                      if((rrc_csp_int_data.bplmn_interrat_type == RRC_CSP_INTERRAT_GSM) && 
                         (rrc_csp_int_data.plmn_srch_order.rat[rrc_csp_int_data.plmn_srch_order.curr_rat_srch_idx] 
                           == SYS_RAT_LTE_RADIO_ACCESS))
                      {
                        rrc_csp_init_wtog_plmn_srch_int_data_across_rats();
                        rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_active = TRUE;
                        rrc_csp_int_data.bplmn_interrat_type = RRC_CSP_INTERRAT_LTE;
                      }
                      else if((rrc_csp_int_data.bplmn_interrat_type == RRC_CSP_INTERRAT_LTE) && 
                                 (rrc_csp_int_data.plmn_srch_order.rat[rrc_csp_int_data.plmn_srch_order.curr_rat_srch_idx] 
                                    == SYS_RAT_GSM_RADIO_ACCESS))
                      {
                        rrc_csp_init_wtog_plmn_srch_int_data_across_rats();
                        rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_active = TRUE;
                        rrc_csp_int_data.bplmn_interrat_type = RRC_CSP_INTERRAT_GSM;
                      }
                      else
  #endif
                      {
                        rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_active = FALSE;
                      }
                    }
                  }
                  else
                  {
                    WRRC_MSG0_HIGH("WTOG: Srch NOT done on GSM for Manual Search. Wait for next DRX");
                    rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_SUSPEND, FALSE, FALSE);
                  }
                }
                /* Search has already been aborted. Cleanup and restart BPLMN state */
                else
                {
                  if(rrc_csp_wtog_bplmn_int_data.restart_bplmn_search)
                  {
                    WRRC_MSG0_HIGH("WTOG: wtog srch already aborted. Cleanup & Restart BPLMN");
                    rrccsp_cleanup_and_restart_bplmn();        
                  }
                  else
                  {
                    WRRC_MSG0_HIGH("WTOG: wtog srch already aborted. Cleanup BPLMN");
                    rrccsp_cleanup_bplmn_state();        
                  }
                }

                next_substate = rrccsp_send_channel_config_req_on_wcdma_resume();
                break;

              case RRC_CSP_PLMN_LIST_SCAN:
                ERR_FATAL("ERR: Resume success from L1 when GSM PLMN srch in fgnd", 0, 0, 0);
                break;

              default:
                WRRC_MSG1_HIGH("Unexp resume cnf when curr_scan = %d",rrc_csp_int_data.curr_scan);
                break;
            }
          }
          /* Resume Failed */
          else
          {
            switch(rrc_csp_int_data.curr_scan)
            {
              case RRC_CSP_WCDMA_TO_GSM_CELL_RESELECTION_SCAN:
#ifdef FEATURE_GAN
              #error code not present
#endif
                WRRC_MSG0_HIGH("Resume failure for WtoG / WtoGAN reselection rcvd by CSP");
                
                /* Reset reselection variables */
                rrccsp_reset_reselection_data();

                /* ------------------------------------------------ */
                /* Trigger OOS handling in Idle/Connected RRC state */
                /* ------------------------------------------------ */

                /* In Idle State start cell selection */
                if(rrc_current_state == RRC_STATE_DISCONNECTED)
                { 
#ifdef FEATURE_DUAL_SIM
                  if(cmd_ptr->cmd.change_mode_cnf.fail_type == WL1_FAILED_NO_WRM_LOCK)
                  {
                    /* Set oos_due_to_no_resource flag so that NAS is updated with NO SERVICE with cause
                       NO RESOURCE*/
                    rrc_set_oos_due_to_no_resource_flag();
                    WRRC_MSG0_HIGH("DSIM: Resume failed with cause no_wrm_lock. Go to INACTIVE.");
                    /*As WL1 failed Resuming, it is still in SUSPEND state, Initiate mode change to Inactive*/
                    rrc_ccm_update_with_cell_loss();
                    rrccsp_send_mode_change_req_to_mcm(RRC_MODE_INACTIVE);
                    next_substate = RRCCSP_WT_STOP_MODE_CHANGE_CNF;
                    rrc_csp_handle_no_available_freq();
                  }
                  else
#endif
                  {
                    next_substate = rrc_csp_start_sel_out_of_service_area_in_idle_state();
                  }
                }

                /* In Connected State send OOS indication to CU so that
                 * appropriate timers are started in CU. CU will then send
                 * initiate cell selection indication to CSP
                 */
                else if(   (rrc_current_state == RRC_STATE_CELL_FACH) 
                        || (rrc_current_state == RRC_STATE_CELL_PCH) 
                        || (rrc_current_state == RRC_STATE_URA_PCH))
                {
                  next_substate = rrccsp_send_cell_update_initiate_req(RRC_REENTERED_SERVICE_AREA);
                }
                
                /* In Connecting State, W to G reselection cannot be in progress 
                 * because we do not support inter-freq or inter-RAT reselections
                 * in Connecting State (intra-freq reselections are supported though) 
                 */
                else
                {
                  WRRC_MSG1_ERROR("ERR Mode Resume in wrong RRC state %d", rrc_current_state);
                  if(rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED)
                  {
                    next_substate = RRCCSP_CAMPED_ACCEPT_CELL;
                  }
                  else
                  {
                    next_substate = RRCCSP_CAMPED_SUIT_CELL;
                  } 
                }   
                break;

              case RRC_CSP_INTER_RAT_REDIRECTION_SCAN:
                /* For redirection failure due to connection release, release all channels
                 * and start leaving connected mode scan.
                 */
                if(rrc_get_state() != RRC_STATE_CONNECTING)
                {
#ifdef FEATURE_DUAL_SIM
                  if(cmd_ptr->cmd.change_mode_cnf.fail_type == WL1_FAILED_NO_WRM_LOCK)
                  {
                    WRRC_MSG0_HIGH("DSIM: Resume failed with cause no_wrm_lock. Go to INACTIVE.");

                    /* Set oos_due_to_no_resource flag so that NAS is updated with NO SERVICE with cause
                       NO RESOURCE*/
                    rrc_set_oos_due_to_no_resource_flag();
                    /*As WL1 failed Resuming, it is still in SUSPEND state, Initiate mode change to Inactive*/
                    rrc_ccm_update_with_cell_loss();
                    rrccsp_send_mode_change_req_to_mcm(RRC_MODE_INACTIVE);
                    next_substate = RRCCSP_WT_STOP_MODE_CHANGE_CNF;
                    rrc_csp_handle_no_available_freq();
                  }
                  else
#endif
                  {
                    WRRC_MSG0_HIGH("ModeCnf Failure rcvd by CSP. Start leaving conn mode scan.");
                    next_substate = rrc_csp_start_sel_leaving_conn_mode();
                  }
                }
                else
                {
                  WRRC_MSG0_HIGH("ModeCnf Failure rcvd by CSP. Sndng Resume Failure to RCE");
                  /* Send RRC_REDIRECT_CNF (RESUME_FAILURE) to RCE */
                  rrccsp_send_rce_redirect_cnf(RRC_REDIRECT_FAILURE, RRC_REDIRECT_RESUME_FAILURE);
  
                  if(rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED)
                  {
                    next_substate = RRCCSP_CAMPED_ACCEPT_CELL;
                  }
                  else
                  {
                    next_substate = RRCCSP_CAMPED_SUIT_CELL;
                  }
                  WRRC_MSG0_HIGH("Sent REDIRECT_CNF (RESUME_FAILURE) to RCE");
                }
                break;
#ifdef FEATURE_DUAL_SIM
              case RRC_CSP_UNLOCK_BY_SCAN:
                if(cmd_ptr->cmd.change_mode_cnf.fail_type == WL1_FAILED_NO_WRM_LOCK)
                {
                  rrccsp_cleanup_bplmn_state();
                   /* Set oos_due_to_no_resource flag so that NAS is updated with NO SERVICE with cause
                     NO RESOURCE*/
                  rrc_set_oos_due_to_no_resource_flag();

                  WRRC_MSG0_HIGH("DSIM_TUNEAWAY: Resume failed with cause no_wrm_lock. Go to INACTIVE.");
                  /*As WL1 failed Resuming, it is still in SUSPEND state, Initiate mode change to Inactive*/
                  rrc_ccm_update_with_cell_loss();
                  rrccsp_send_mode_change_req_to_mcm(RRC_MODE_INACTIVE);
                  next_substate = RRCCSP_WT_STOP_MODE_CHANGE_CNF;
                  rrc_csp_handle_no_available_freq();
                }
                else
                {
                  if(rrc_current_state == RRC_STATE_DISCONNECTED)
                  {
                    next_substate = rrc_csp_start_sel_out_of_service_area_in_idle_state();
                  }
                  else if((rrc_current_state == RRC_STATE_CELL_PCH) ||
                          (rrc_current_state == RRC_STATE_URA_PCH))
                  {
                    rrc_csp_int_data.curr_scan = RRC_CSP_CELL_SELECTION_SCAN;
                    next_substate = rrccsp_send_cell_update_initiate_req(RRC_REENTERED_SERVICE_AREA);
                  }
                  else
                  {
                next_substate = rrc_csp_initiate_CU_for_immediate_preempt_in_fach_dch();
                }
              }
                break;
#endif

              case RRC_CSP_OUT_OF_SERVICE_AREA_SCAN:
                WRRC_MSG0_HIGH("OOS: Resume failed on W");


                /* Get the GSM ACQ-info as OOS G search is over. Also clear RR ACQ-info. */
#ifdef FEATURE_UMTS_ACQ_CHNL_INFO_SHARING
                WRRC_MSG0_HIGH("Get GSM Acquired ARFCNs info");
                rrc_csp_get_gsm_rr_arfcns();
                /* Clear RR acq channel db after using it once*/
                WRRC_MSG0_HIGH("Clearing GSM Acquired ARFCNs info after using it once");
                rr_rrc_clear_acq_chnl_info_internal();
#endif

                /* Determine if UE should be put to deep sleep or not. UE is not put into
                 * deep sleep if GCF flag is enabled
                 */
                if(   (rrc_csp_int_data.oos_splmn_srch_tmr_expd) 
                   && (rrc_csp_int_data.oos_initial_no_deep_sleep_tmr_expd)
                   && (!nv_gcf_test_flag)
                  )
                {
                  /* Start sleep timer of 30s */
                  WRRC_MSG0_HIGH("OOS: Put UE in Deep Sleep. Start sleep tmr");
        
                  rrctmr_start_timer(RRCTMR_CONN_MODE_OOS_DS_TIMER, 
                                     RRCTMR_CONN_MODE_OOS_DS_TIMER_IN_MS);
                  rrc_csp_int_data.oos_conn_mode_ds_tmr_expd = FALSE;

                  rrccsp_send_conn_mode_oos_ds_req();
#ifdef FEATURE_DUAL_SIM
                  rrc_release_lock();
#endif
                  if(rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED)
                  {
                    next_substate = RRCCSP_CAMPED_ACCEPT_CELL;
                  }
                  else
                  {
                    next_substate = RRCCSP_CAMPED_SUIT_CELL;
                  } 
                }
                else
                {
                WRRC_MSG0_HIGH("OOS: Continue Cell Selection on W");

                /* Start again with Stored and Initial cell selection. Initiate Selection
                 * data so that Selection Controller starts from the beginning.
                 */
                if(rrc_csp_init_select_data(&rrc_csp_curr_select_data.req_plmn) == SUCCESS)
                {
                  next_substate = rrc_csp_continue_cell_selection();
                }
                else
                { 
                  WRRC_MSG0_ERROR("ERR: Initialization of data failed");
                  next_substate = rrc_csp_continue_cell_selection();
                }

                }
/* Update UI with service status before going to sleep or continuing with the search */
#ifdef FEATURE_OOSC_SERVICE_STATUS_UI_UPDATE
                if(rrc_csp_int_data.curr_scan == RRC_CSP_OUT_OF_SERVICE_AREA_SCAN)
                {
                  /* Update UI with No Service if No PLMN was found */
                  if(!rrc_csp_int_data.oosc_plmn_found)
                  {
                    WRRC_MSG0_HIGH("SRV_ST: Update UI w/ No SERVICE");
                    rrc_csp_send_svc_status_to_mm(SYS_SRV_STATUS_NO_SRV,SYS_RAT_UMTS_RADIO_ACCESS, 0);
                  }
                  rrc_csp_int_data.oosc_plmn_found = FALSE;
                }
#endif
                break;



              case RRC_CSP_CELL_DCH_TO_CELL_FACH_SCAN:
              case RRC_CSP_CELL_DCH_TO_CELL_PCH_SCAN:
              case RRC_CSP_CELL_DCH_TO_URA_PCH_SCAN:
                /* if DCH->FACH/PCH timer has expired then send indication to CU proc */
                if(rrc_csp_int_data.dch_to_fach_pch_tmr_expd)
                {
                  WRRC_MSG0_HIGH("DCH->FACH/PCH tmr already expd. Send ind to CU for OOS search");
                  next_substate = rrccsp_send_cell_update_initiate_req(RRC_REENTERED_SERVICE_AREA);
                }
                /* re-start the search on both W and G till DCH->FACH/PCH timer expires */
                else
                {
                  /* Start again with Stored and Initial cell selection. Initiate Selection
                   * data so that Selection Controller starts from the beginning.
                   */
                  if(rrc_csp_init_select_data(&rrc_csp_curr_select_data.req_plmn) == SUCCESS)
                  {
                    next_substate = rrc_csp_continue_cell_selection();
                  }
                  else
                  { 
                    WRRC_MSG0_ERROR("ERR: Initialization of data failed");
                    next_substate = rrc_csp_continue_cell_selection();
                  }
                }
                break;

              case RRC_CSP_CELL_FACH_TO_CELL_FACH_SCAN:
              case RRC_CSP_CELL_FACH_TO_CELL_PCH_SCAN:
              case RRC_CSP_CELL_FACH_TO_URA_PCH_SCAN:
                /* if DCH->FACH/PCH timer has expired then send indication to CU proc */
                if(rrc_csp_int_data.fach_to_fach_pch_tmr_expd)
                {
                  WRRC_MSG0_HIGH("FACH->FACH/PCH tmr already expd. Send ind to CU for OOS search");
                  next_substate = rrccsp_send_cell_update_initiate_req(RRC_REENTERED_SERVICE_AREA);
                }
                /* re-start the search on both W and G till FACH->FACH/PCH timer expires */
                else
                {
                  /* Start again with Stored and Initial cell selection. Initiate Selection
                   * data so that Selection Controller starts from the beginning.
                   */
                  if(rrc_csp_init_select_data(&rrc_csp_curr_select_data.req_plmn) == SUCCESS)
                  {
                    next_substate = rrc_csp_continue_cell_selection();
                  }
                  else
                  { 
                    WRRC_MSG0_ERROR("ERR: Initialization of data failed");
                    next_substate = rrc_csp_continue_cell_selection();
                  }
                }
                break;

#ifdef FEATURE_PCS_850_FREQ_SCAN_OPTIMIZATION
              case RRC_CSP_CELL_SELECTION_SCAN:
#ifdef FEATURE_DUAL_SIM
                if(cmd_ptr->cmd.change_mode_cnf.fail_type == WL1_FAILED_NO_WRM_LOCK)
                {
                  WRRC_MSG0_HIGH("DSIM: Resume failed with cause no_wrm_lock. Go to INACTIVE.");
                  /* Set oos_due_to_no_resource flag so that NAS is updated with NO SERVICE with cause
                     NO RESOURCE*/
                  rrc_set_oos_due_to_no_resource_flag();

                  /*As WL1 failed Resuming, it is still in SUSPEND state, Initiate mode change to Inactive*/
                  rrc_ccm_update_with_cell_loss();
                  rrccsp_send_mode_change_req_to_mcm(RRC_MODE_INACTIVE);
                  next_substate = RRCCSP_WT_STOP_MODE_CHANGE_CNF;
                  rrc_csp_handle_no_available_freq();
                }
                else
#endif
                {
                  WRRC_MSG0_HIGH("Idle OOS: Resume failed on W. Continue Cell Sel");
#ifndef FEATURE_EOOS
#ifdef FEATURE_GAN
                  #error code not present
#endif /* FEATURE_GAN */
#endif
                  /* Skip the ACQ DB scan and initialize freq scan data as the list db scan has been finished */
                  WRRC_MSG0_HIGH("LFS_COOS: Initialization done for RAW/FINE frequency scan ");
                  rrc_csp_init_freq_scan_data();
                  next_substate = rrc_csp_continue_cell_selection();
                }
                break;
#endif

              case RRC_CSP_WTOG_BPLMN_AUTOMATIC_SCAN:
                WRRC_MSG0_ERROR("WTOG: Resume Failure after rcving Auto BPLMN Srch Cnf from RR");

                /* ------------------------------------------------ */
                /* Send ABORT TO GSM and PLMN_LIST_CNF to NAS as    */
                /* Resume on W Failed                               */
                /* ------------------------------------------------ */
#ifdef FEATURE_BPLMN_SEARCH_320MS
                wcdma_resume_failed = TRUE;
#endif
                if(!rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_aborted)
                {
                  if(rrc_csp_wtog_bplmn_int_data.wtog_srch_done)
                  {
                    if(rrc_csp_wtog_bplmn_int_data.wtog_hplmn_found)
                    {
                      WRRC_MSG0_HIGH("WTOG: HPLMN found on GSM");
                    }
                    else 
                    {
                      WRRC_MSG0_HIGH("WTOG: Srch done but GSM HPLMN NOT Fnd");
                    } 

                    if(rrc_csp_int_data.plmn_srch_order.curr_rat_srch_idx >= (rrc_csp_int_data.plmn_srch_order.num_rats -1))
                    {
                      WRRC_MSG0_HIGH("WTOG: Send PLMN_LIST_CNF to NAS");
                      rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_STOP, TRUE, FALSE);
                    }
                    /* Since resume failed, send plmn list cnf to NAS with status aborted */
                    else
                    {
                      rrccsp_cleanup_bplmn_state();
                    } 
                  }
                  else
                  {
                    WRRC_MSG0_HIGH("WTOG: Srch NOT completed on GSM. Abort Search. Send List_Cnf");

                    rrccsp_cleanup_bplmn_state();
                  }
                }
                /* Search has been aborted. Cleanup BPLMN state */
                else
                {
                  WRRC_MSG0_HIGH("WTOG: Srch already aborted. Cleanup BPLMN state");
                  rrccsp_cleanup_bplmn_state();
                }

                /* ------------------------------------------------ */
                /* Trigger OOS handling in Idle/Connected RRC state */
                /* ------------------------------------------------ */

                /* In Idle State start cell selection */
                if(rrc_current_state == RRC_STATE_DISCONNECTED)
                { 
#ifdef FEATURE_DUAL_SIM
                  if(cmd_ptr->cmd.change_mode_cnf.fail_type == WL1_FAILED_NO_WRM_LOCK)
                  {
                    /* Set oos_due_to_no_resource flag so that NAS is updated with NO SERVICE with cause
                       NO RESOURCE*/
                    rrc_set_oos_due_to_no_resource_flag();

                    /*As WL1 failed Resuming, it is still in SUSPEND state, Initiate mode change to Inactive*/
                    rrc_ccm_update_with_cell_loss();
                    rrccsp_send_mode_change_req_to_mcm(RRC_MODE_INACTIVE);
                    next_substate = RRCCSP_WT_STOP_MODE_CHANGE_CNF;
                    rrc_csp_handle_no_available_freq();
                  }
                  else
#endif
                  {
                    next_substate = rrc_csp_start_sel_out_of_service_area_in_idle_state();
                  }
                }

                /* In Connected State send OOS indication to CU so that
                 * appropriate timers are started in CU. CU will then send
                 * initiate cell selection indication to CSP
                 */
                else if((rrc_current_state == RRC_STATE_CELL_PCH) 
                        || (rrc_current_state == RRC_STATE_URA_PCH))
                {
                  next_substate = rrccsp_send_cell_update_initiate_req(RRC_REENTERED_SERVICE_AREA);
                }

                /* In Connecting or FACH State, BPLMN search cannot be in progress */
                else
                {
                  WRRC_MSG1_ERROR("ERR Mode Resume in wrong RRC state %d", rrc_current_state);
                  if(rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED)
                  {
                    next_substate = RRCCSP_CAMPED_ACCEPT_CELL;
                  }
                  else
                  {
                    next_substate = RRCCSP_CAMPED_SUIT_CELL;
                  } 
                }   
                break;

              case RRC_CSP_WTOG_BPLMN_MANUAL_SCAN: 
                WRRC_MSG0_ERROR("WTOG: Resume failure after rcving Manual BPLMN Srch Cnf from RR");

#ifdef FEATURE_BPLMN_SEARCH_320MS
                wcdma_resume_failed = TRUE;
#endif
                /* ------------------------------------------------ */
                /* Send PLMN_LIST_CNF to NAS as Resume on W Failed  */
                /* ------------------------------------------------ */
                if(!rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_aborted)
                {
                  if(rrc_csp_wtog_bplmn_int_data.wtog_srch_done)
                  {
                    if(rrc_csp_int_data.plmn_srch_order.curr_rat_srch_idx >= (rrc_csp_int_data.plmn_srch_order.num_rats -1))
                    {
                      WRRC_MSG0_HIGH("WTOG: Srch done on GSM for Manual Srch. Send PLMN_LIST_CNF to NAS");
                      rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_STOP, TRUE, FALSE);
                    }
                    else
                    {
                      rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_SUSPEND, FALSE, FALSE);
                      rrc_csp_int_data.plmn_srch_order.curr_rat_srch_idx++;
  #ifdef FEATURE_WCDMA_TO_LTE
                      if((rrc_csp_int_data.bplmn_interrat_type == RRC_CSP_INTERRAT_GSM) && 
                         (rrc_csp_int_data.plmn_srch_order.rat[rrc_csp_int_data.plmn_srch_order.curr_rat_srch_idx] 
                           == SYS_RAT_LTE_RADIO_ACCESS))
                      {
                        rrc_csp_init_wtog_plmn_srch_int_data_across_rats();
                        rrc_csp_int_data.bplmn_interrat_type = RRC_CSP_INTERRAT_LTE;
                      }
                      else if((rrc_csp_int_data.bplmn_interrat_type == RRC_CSP_INTERRAT_LTE) && 
                                 (rrc_csp_int_data.plmn_srch_order.rat[rrc_csp_int_data.plmn_srch_order.curr_rat_srch_idx] 
                                    == SYS_RAT_GSM_RADIO_ACCESS))
                      {
                        rrc_csp_init_wtog_plmn_srch_int_data_across_rats();
                        rrc_csp_int_data.bplmn_interrat_type = RRC_CSP_INTERRAT_GSM;
                      }
                      else
  #endif
                      {
                        rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_active = FALSE;
                      }
                    }
                  }
                  else
                  {
                    WRRC_MSG0_HIGH("WTOG: Srch NOT done on GSM for Manual Search.");
                    rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_SUSPEND, FALSE, FALSE);
                  }
                }
                /* Search has been aborted. Cleanup BPLMN state */
                else
                {
                  if(rrc_csp_wtog_bplmn_int_data.restart_bplmn_search)
                  {
                    WRRC_MSG0_HIGH("WTOG: wtog srch already aborted. Cleanup & Restart BPLMN");
                    rrccsp_cleanup_and_restart_bplmn();        
                  }
                  else
                  {
                    WRRC_MSG0_HIGH("WTOG: wtog srch already aborted. Cleanup BPLMN");
                    rrccsp_cleanup_bplmn_state();
                  }
                }

                /* ------------------------------------------------ */
                /* Trigger OOS handling in Idle/Connected RRC state */
                /* ------------------------------------------------ */

                /* In Idle State start cell selection */
                if(rrc_current_state == RRC_STATE_DISCONNECTED)
                {
                  /*Updated CCM with cell loss before starting search. 
                    This is to make sure that we dont process any establishment request that is sent immediately
                    after updating with PLMN list confirmation*/
                  rrc_ccm_update_with_cell_loss();
#ifdef FEATURE_DUAL_SIM
                  if(cmd_ptr->cmd.change_mode_cnf.fail_type == WL1_FAILED_NO_WRM_LOCK)
                  {
                    /* Set oos_due_to_no_resource flag so that NAS is updated with NO SERVICE with cause
                       NO RESOURCE*/
                    rrc_set_oos_due_to_no_resource_flag();

                    if(WTOW_SEARCH_SUSPEND == rrc_csp_bplmn_srch_in_progress())
                    {
                      next_substate = rrccsp_continue_bplmn_in_frgrnd();
                    }
                    else
                    {
                      rrccsp_send_mode_change_req_to_mcm(RRC_MODE_INACTIVE);
                      next_substate = RRCCSP_WT_STOP_MODE_CHANGE_CNF;
                      rrc_csp_handle_no_available_freq();
                    }
                  }
                  else
#endif
                  {
                    if(WTOW_SEARCH_SUSPEND == rrc_csp_bplmn_srch_in_progress())
                    {
                      next_substate = rrccsp_continue_bplmn_in_frgrnd();
                    }
                    else
                    {
                      next_substate = rrc_csp_start_sel_out_of_service_area_in_idle_state();
                    }
                  }
                }

                /* In Connected State send OOS indication to CU so that
                 * appropriate timers are started in CU. CU will then send
                 * initiate cell selection indication to CSP
                 */
                else if((rrc_current_state == RRC_STATE_CELL_PCH) 
                        || (rrc_current_state == RRC_STATE_URA_PCH))
                {
                  next_substate = rrccsp_send_cell_update_initiate_req(RRC_REENTERED_SERVICE_AREA);
                }

                /* In Connecting or FACH State, BPLMN search cannot be in progress */
                else
                {
                  WRRC_MSG1_ERROR("ERR Mode Resume in wrong RRC state %d", rrc_current_state);
                  if(rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED)
                  {
                    next_substate = RRCCSP_CAMPED_ACCEPT_CELL;
                  }
                  else
                  {
                    next_substate = RRCCSP_CAMPED_SUIT_CELL;
                  } 
                }   
                break;

              case RRC_CSP_PLMN_LIST_SCAN:
  
                WRRC_MSG0_HIGH("WTOG OOS: Resume failure as expected");
  

#ifdef FEATURE_DUAL_SIM
                if(cmd_ptr->cmd.change_mode_cnf.fail_type == WL1_FAILED_NO_WRM_LOCK)
                {
                  /* Set oos_due_to_no_resource flag so that NAS is updated with NO SERVICE with cause
                     NO RESOURCE*/
                  rrc_set_oos_due_to_no_resource_flag();

                  /*As WL1 failed Resuming, it is still in SUSPEND state, Initiate mode change to Inactive*/
                  rrc_ccm_update_with_cell_loss();
                }
#endif
                /* --------------------------*/
                /* Send PLMN_LIST_CNF to NAS */
                /* --------------------------*/
                if(!rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_aborted)
                {
                  if(!rrc_csp_wtog_bplmn_int_data.wtog_srch_done)
                  {
                    WRRC_MSG0_ERROR("WTOG OOS ERR: Srch incomplete on GSM when UE OOS. Continue with W.");
                    rrccsp_send_irat_bplmn_abort_req();
                  }
                  WRRC_MSG0_HIGH("WTOG OOS: Manual Srch completed on GSM");
                  if((rrc_csp_int_data.plmn_srch_order.curr_rat_srch_idx+1 ) >= rrc_csp_int_data.plmn_srch_order.num_rats)
                  {
                    /* Send the PLMN_LIST_CNF to MM */
                    rrc_csp_send_mm_plmn_list_cnf_cmd(TRUE);
                  }
                  else
                  {
                    /*If G follows L or L follows G in search order already taken care, so has to take care of only W */
                    /* Start again with Stored and Initial cell selection. Initiate Selection
                     * data so that Selection Controller starts from the beginning.
                     */
                    rrc_csp_int_data.plmn_srch_order.curr_rat_srch_idx++;
                  #ifdef FEATURE_DUAL_SIM
                    /* Start lock wait timer before resuming PLMN search on W */
                    rrc_start_lock_wait_timer(RRCTMR_DEFAULT_SEARCH_TIME_IN_MS,TRUE);
                  #endif
                    if(rrc_csp_init_select_data(&rrc_csp_int_data.curr_req_plmn) == SUCCESS)
                    {
                      next_substate = rrc_csp_continue_cell_selection();
                    }
                    else
                    { 
                      WRRC_MSG0_ERROR("ERR: Initialization of data failed");
                      next_substate = rrc_csp_continue_cell_selection();
                    }
                    return (next_substate);
                  }
                }
                /* Search has been aborted. Cleanup BPLMN state */
                else
                {
                  WRRC_MSG0_HIGH("WTOG OOS: Srch already aborted. Send list cnf to NAS");

                  /* Send the PLMN_LIST_CNF to MM with status aborted */
                  rrc_csp_send_mm_plmn_list_cnf_cmd(FALSE);
                }

                /* CSP should go back to NO_CELL_SELECTED substate as UE is OOS */
                next_substate = RRCCSP_NO_CELL_SELECTED;
                break;

              default:
                WRRC_MSG1_HIGH("Unexp resume cnf when curr_scan = %d",rrc_csp_int_data.curr_scan);
                break;
            }
          }
        }
      }
      else
      {
        /* TBD: Any action if mode change to another mode is received */
        WRRC_MSG2_ERROR("ERR Unexpected Chg Mode CNF to %d in %d state",cmd_ptr->cmd.change_mode_cnf.mode,
                                                                      rrc_csp_substate);
      }
      break;

    case RRC_INITIATE_CELL_SELECTION_IND:
      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
      if(cmd_ptr->cmd.initiate_cell_sel_ind.cause == RRC_TRANSITION_TO_DISCONNECTED)
      {
        WRRC_MSG1_HIGH("Saving initiate cell sel, proc rrc_proc_e_type_value%d",
                   cmd_ptr->cmd.initiate_cell_sel_ind.proc);
        rrc_csp_int_data.init_cell_sel_ind_during_wtointerrat = TRUE;

      }
      else
      {
        WRRC_MSG2_HIGH("Cause %d not handled %d CSP sstate ",
                  cmd_ptr->cmd.initiate_cell_sel_ind.cause, rrc_csp_substate);
      }
      break;

    case RRC_PLMN_LIST_REQ:
      MSG_MED("Cmd 0x%x recvd, CSP sstate %d", cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );

      if(rrc_csp_int_data.curr_scan == RRC_CSP_PLMN_LIST_SCAN)
      {
        rrc_csp_send_mm_plmn_list_cnf_as_aborted(rrc_csp_int_data.bplmn_trans_id);
      }

      /* if not camped on, current scan is plmn_list_scan  and state is disconnected then this is 
          * back to back PLMN list scan. We shouldnt abort the new scan. 
          */
      if ((rrc_csp_int_data.curr_scan == RRC_CSP_PLMN_LIST_SCAN)
          && (rrc_get_state() == RRC_STATE_DISCONNECTED)
          && (RRC_NOT_CAMPED_ON == rrc_ccm_get_curr_camping_status(RRC_PROCEDURE_CSP))
          && ( cmd_ptr->cmd.plmn_list_req.network_select_mode == SYS_NETWORK_SELECTION_MODE_MANUAL)
            )
      {
        WRRC_MSG0_HIGH("Back to Back PLMN List Req, Handling second one");
        rrc_csp_int_data.curr_scan = RRC_CSP_CELL_SELECTION_SCAN;
      }

      if(RRC_MODE_ACTIVE == rrcmcm_get_rrc_mode())
      {
#ifdef FEATURE_PCS_850_FREQ_SCAN_OPTIMIZATION
        if((rrc_csp_int_data.last_mm_primitive == RRC_CSP_SRVC_REQ_RCVD) &&
            (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_SELECTION_SCAN))
        {
          /* Send SERVICE_CNF so that MM cleans up */
          rrc_csp_send_mm_cmd(RRC_SERVICE_CNF,
                              MM_AS_NO_SERVICE,
                              &rrc_csp_int_data.curr_sel_plmn,
                              &rrc_csp_int_data.curr_acq_entry);
        }
#endif

        if(rrccsp_plmn_list_req_when_resume_in_prog_is_valid(&(cmd_ptr->cmd.plmn_list_req)))
        {
          /* UE is OOS in Idle State */
          if(rrc_csp_int_data.curr_scan == RRC_CSP_CELL_SELECTION_SCAN)
          {
            WRRC_MSG0_HIGH("UE is OOS in Idle State. Do Manual Srch in Fgnd");
            rrccsp_cleanup_bplmn_state();

            /* Start scanning the frequency band for PLMNs */
            rrc_csp_int_data.plmn_list.num_plmns = 0;
#ifdef FEATURE_FEMTO_CSG
            rrc_csp_int_data.service_search_bgnd = cmd_ptr->cmd.plmn_list_req.service_search;
            WRRC_MSG1_HIGH("CSG: Filling service_search %d",rrc_csp_int_data.service_search_bgnd);
            rrccsp_csg_set_fp_info();
#endif
            rrccsp_update_plmn_list_req_data(&cmd_ptr->cmd.plmn_list_req);

            /*For foreground searches overwrite band preference blindly. 
              It will anways get updated for next service request*/
            rrc_csp_int_data.band_pref = rrc_csp_int_data.bplmn_band_pref;
            rrccsp_update_band_preference();

            next_substate = rrc_csp_start_sel_for_plmn_list();
          }
          /* Cleanup BPLMN state in case a plmn list search is pending. Also
           * save the new plmn list request
           */
          else if((rrc_csp_int_data.curr_scan != RRC_CSP_WTOG_BPLMN_AUTOMATIC_SCAN)
                  && (rrc_csp_int_data.curr_scan != RRC_CSP_WTOG_BPLMN_MANUAL_SCAN))
          {

#ifdef FEATURE_DUAL_SIM
          /*If G is in data call reject manual PLMN search in this substate*/
          /*If we want to handle in foreground then we might have to pend the command
            till we receive channel config confirm. Not sure if we can start right after
            receiving resume confirm */
          if(WRM_G2W_TA_MODE_ACTIVE() && (cmd_ptr->cmd.plmn_list_req.network_select_mode == SYS_NETWORK_SELECTION_MODE_AUTOMATIC))
          {
            rrc_csp_send_mm_plmn_list_cnf_as_aborted(cmd_ptr->cmd.plmn_list_req.trans_id);
            return next_substate;
          }
#endif
            rrccsp_cleanup_bplmn_state();
            /* Set state so that BPLMN search can be started */
            rrc_csp_int_data.bplmn_nw_sel_mode = cmd_ptr->cmd.plmn_list_req.network_select_mode;

            rrc_csp_int_data.service_search_bgnd = cmd_ptr->cmd.plmn_list_req.service_search;
            WRRC_MSG1_HIGH("SSB: svc_srch_bgnd rcvd from NAS = %d", rrc_csp_int_data.service_search_bgnd);
            /* If Automatic BPLMN search is requested then reject it in this CSP substate,
             * since anyways another Automatic BPLMN search request will be received by CSP in
             * 10s.
             */
            if(rrc_csp_int_data.bplmn_nw_sel_mode == SYS_NETWORK_SELECTION_MODE_AUTOMATIC)
            {
              WRRC_MSG1_HIGH("WTOW: Rejecting APLS req in CSP sst %d", next_substate);

              rrc_csp_bplmn_send_mm_plmn_list_cnf_cmd(WTOW_SEARCH_ABORT,cmd_ptr->cmd.plmn_list_req.trans_id);
            }
            /* Handle Manual Search in this CSP substate */
            else
            {
              rrccsp_update_plmn_list_req_data(&cmd_ptr->cmd.plmn_list_req);
              rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_START, FALSE, FALSE);
#ifdef FEATURE_FEMTO_CSG
              rrccsp_csg_set_fp_info();
#endif

              WRRC_MSG2_HIGH("WTOW: dual_mode_enabled = %d, wcdma_mode_enabled = %d in PLMN_LIST_REQ", 
                                      rrc_csp_int_data.bplmn_dual_mode_enabled,rrc_csp_int_data.bplmn_wcdma_mode_enabled);
              rrccsp_generate_bplmn_rat_srch_order_update_curr_srch_rat(SYS_NETWORK_SELECTION_MODE_MANUAL);

              if(rrc_csp_int_data.bplmn_wcdma_mode_enabled)
              {
                rrccsp_update_wtow_manual_bplmn_list_with_rplmn(rrc_csp_int_data.curr_acq_entry.plmn_id,
                                                                rrc_csp_int_data.curr_acq_entry.cell_id);
              }
            }
          }
          /* Save the req so that the ongoing plmn list search 
           * can be cleaned up appropriately.
           */
          else
          {
            rrccsp_save_req(cmd_ptr);
            next_substate = RRCCSP_WT_RESUME_MODE_CHANGE_CNF_PENDING;
          }
        }
      }
      else
      {
        WRRC_MSG1_ERROR("ERR PLMN_LIST_REQ rcvd when RRC mode is not active %d", rrcmcm_get_rrc_mode());
      }
      break;  

    case RRC_SERVICE_REQ:
      if(RRC_MODE_ACTIVE == rrcmcm_get_rrc_mode())
      {
        if(rrc_current_state != RRC_STATE_DISCONNECTED)
        {
          WRRC_MSG1_ERROR("Service req in RRC state %d",rrc_current_state);
        }   
    
        if(rrc_csp_int_data.curr_scan == RRC_CSP_PLMN_LIST_SCAN)
        {
          rrc_csp_send_mm_plmn_list_cnf_as_aborted(rrc_csp_int_data.bplmn_trans_id);
        }

        /* Process the Service Request */
        WRRC_MSG0_HIGH("Start cell sel for srvc req");
        rrc_csp_init_data_from_service_req(&(cmd_ptr->cmd.rrc_service_req));
        /* Release the established channels and start cell selection */
        next_substate = rrc_csp_release_chls_and_start_sel_on_mm_req();
      }
      else
      {
        WRRC_MSG1_ERROR("Err RRC_SERVICE_REQ rcvd when RRC mode is not active %d", rrcmcm_get_rrc_mode());
      }
      break;

    case RRC_BPLMN_GUARD_SRCH_TIMER_EXPIRED_IND:
      if((rrc_csp_int_data.curr_scan == RRC_CSP_WTOG_BPLMN_AUTOMATIC_SCAN)
          || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOG_BPLMN_MANUAL_SCAN))
      {
        if(!rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_aborted)
        {
          rrccsp_send_irat_bplmn_abort_req();
        }
        else
        {
          WRRC_MSG0_HIGH("WTOG: search already aborted");
        }
        rrc_csp_wtog_bplmn_int_data.restart_bplmn_search = FALSE;
      }
      else
      {
        rrccsp_cleanup_bplmn_state();
      }
      break;

    case RRC_BPLMN_SEARCH_ABORT_REQ:
      if(   (rrc_csp_int_data.curr_scan == RRC_CSP_WTOG_BPLMN_AUTOMATIC_SCAN)
         || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOG_BPLMN_MANUAL_SCAN)
         || (rrc_csp_int_data.curr_scan == RRC_CSP_PLMN_LIST_SCAN)
        )
      {
        if(!rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_aborted)
        {
          rrccsp_send_irat_bplmn_abort_req();
        }
        else
        {
          WRRC_MSG0_HIGH("WTOG:/WTOL search already aborted");
        }
        rrc_csp_wtog_bplmn_int_data.restart_bplmn_search = FALSE;
      }
      else
      {
        rrccsp_cleanup_bplmn_state();
      }
      break;

    case RRC_BPLMN_SUSPEND_REQ:
      rrccsp_handle_passive_bplmn_suspend_req( cmd_ptr );
      break;

      case RRC_DCH_FACH_CELL_SELECTION_TIMER_EXPIRED_IND:
        if(rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_CELL_FACH_SCAN)
        {
          rrc_csp_int_data.dch_to_fach_pch_tmr_expd = TRUE;
        }
        else
        {
          WRRC_MSG1_HIGH("Ignoring Cell Sel Tmr Exp in %d scan", rrc_csp_int_data.curr_scan);
        }
        break;
  
      case RRC_DCH_PCH_CELL_SELECTION_TIMER_EXPIRED_IND:
        if(   (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_CELL_PCH_SCAN) 
           || (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_DCH_TO_URA_PCH_SCAN))
        {
          rrc_csp_int_data.dch_to_fach_pch_tmr_expd = TRUE;
        }
        else
        {
          WRRC_MSG1_HIGH("Ignoring Cell Sel Tmr Exp in %d scan", rrc_csp_int_data.curr_scan);
        }
        break;


    case RRC_FACH_TO_FACH_PCH_CELL_SELECTION_TIMER_EXPIRED_IND:
      if(   (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_FACH_TO_CELL_FACH_SCAN) 
         || (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_FACH_TO_CELL_PCH_SCAN)
         || (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_FACH_TO_URA_PCH_SCAN) )
      {
        rrc_csp_int_data.fach_to_fach_pch_tmr_expd = TRUE;
      }
      else
      {
        WRRC_MSG1_HIGH("Ignoring Cell Sel Tmr Exp in %d scan", rrc_csp_int_data.curr_scan);
      }
      break;


    default:
      WRRC_MSG2_HIGH( "Cmd 0x%x not processed in CSP sstate %d",
                            cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);
      break;
  }
  return( next_substate );
} /* rrccsp_wt_resume_mode_change_cnf_hdlr */


/*===========================================================================

FUNCTION        RRCCSP_WT_RESUME_MODE_CHANGE_CNF_PENDING_HDLR

DESCRIPTION
                This is a handler for events received in
                RRCCSP_WT_RESUME_MODE_CHANGE_CNF_PENDING substate of
                the Cell Selection Procedure.
                Depending on the event, it further calls a function for
                processing the event in this CSP substate.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_wt_resume_mode_change_cnf_pending_hdlr( rrc_cmd_type *cmd_ptr )
{
  rrc_csp_substate_e_type next_substate = RRCCSP_WT_RESUME_MODE_CHANGE_CNF_PENDING;
  rrc_state_e_type rrc_current_state = rrc_get_state();

  switch( cmd_ptr->cmd_hdr.cmd_id )
  {
    case RRC_CHANGE_MODE_CNF:
      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
      if(cmd_ptr->cmd.change_mode_cnf.mode == RRC_MODE_ACTIVE)
      {
        if(rrc_csp_int_data.init_cell_sel_ind_during_wtointerrat)
        {
          WRRC_MSG0_HIGH("initiate_cell_sel (trans to discon)");

#ifdef FEATURE_DUAL_SIM
          /* With optimization to move to idle if TA duration > re-est timers
             initiate cell selection is posted when LTA resume is in progress 
             TRM extension flag is not reset when releasing the lock since curr scan is UNLOCK BY */
          if(rrc_csp_int_data.curr_scan == RRC_CSP_UNLOCK_BY_SCAN)
          {
            rrc_csp_int_data.curr_scan = RRC_CSP_CELL_SELECTION_SCAN;
          }
#endif

          rrc_csp_send_chan_release();

          next_substate = rrc_csp_start_sel_leaving_conn_mode();
          rrc_csp_int_data.init_cell_sel_ind_during_wtointerrat = FALSE;
        }
        else 
        {
          if(cmd_ptr->cmd.change_mode_cnf.status == TRUE)
          {
           /* No need to stop DCH->FACH cell selection timer as it should
            * not be active at this point during cell reselection.
            */
            switch(rrc_csp_int_data.curr_scan)
            {

              case RRC_CSP_WTOG_BPLMN_AUTOMATIC_SCAN:
                WRRC_MSG0_HIGH("WTOG: Resume succ after rcving Auto BPLMN Srch Cnf from RR");

                /* This flag is set when Abort Confirmation is received from GSM.
                 * We do not call the bplmn_cleanup function on receiving abort cnf
                 * as that also clears the scan type which is a problem when
                 * resume cnf is received in this substate.
                 */
                if(!rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_aborted)
                {
                  if(rrc_csp_wtog_bplmn_int_data.wtog_srch_done)
                  {
                    if(rrc_csp_wtog_bplmn_int_data.wtog_hplmn_found)
                    {
                      WRRC_MSG0_HIGH("WTOG: HPLMN found on GSM. Send PLMN_LIST_CNF to NAS");
                      rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_STOP, TRUE, FALSE);
                    }
                    else 
                    {
                      WRRC_MSG0_HIGH("WTOG: Srch done but GSM HPLMN !Fnd");

                      if(rrc_csp_int_data.plmn_srch_order.curr_rat_srch_idx >= (rrc_csp_int_data.plmn_srch_order.num_rats -1))
                      {
                        WRRC_MSG0_HIGH("WTOG: Send PLMN_LIST_CNF to NAS");
                        rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_STOP, TRUE, FALSE);
                      }
                      else
                      {
                        rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_SUSPEND, FALSE, FALSE);
                        rrc_csp_int_data.plmn_srch_order.curr_rat_srch_idx++;
  #ifdef FEATURE_WCDMA_TO_LTE
                        if((rrc_csp_int_data.bplmn_interrat_type == RRC_CSP_INTERRAT_GSM) && 
                           (rrc_csp_int_data.plmn_srch_order.rat[rrc_csp_int_data.plmn_srch_order.curr_rat_srch_idx] 
                             == SYS_RAT_LTE_RADIO_ACCESS))
                        {
                          rrc_csp_init_wtog_plmn_srch_int_data_across_rats();
                          rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_active = TRUE;
                          rrc_csp_int_data.bplmn_interrat_type = RRC_CSP_INTERRAT_LTE;
                        }
                        else if((rrc_csp_int_data.bplmn_interrat_type == RRC_CSP_INTERRAT_LTE) && 
                                   (rrc_csp_int_data.plmn_srch_order.rat[rrc_csp_int_data.plmn_srch_order.curr_rat_srch_idx] 
                                      == SYS_RAT_GSM_RADIO_ACCESS))
                        {
                          rrc_csp_init_wtog_plmn_srch_int_data_across_rats();
                          rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_active = TRUE;
                          rrc_csp_int_data.bplmn_interrat_type = RRC_CSP_INTERRAT_GSM;
                        }
                        else
  #endif
                        {
                          /* Add code here to check if W search should be done or not */
                          WRRC_MSG0_HIGH("WTOG: Search on W");
                          rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_active = FALSE;
                        }
                      } 
                    } 
                  }
                  else
                  {
                    WRRC_MSG0_HIGH("WTOG: Srch NOT completed on GSM. Wait for next DRX");
                    rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_SUSPEND, FALSE,  FALSE);
                  }
                }
                /* Search has been aborted. Cleanup BPLMN state */
                else
                {
                  WRRC_MSG0_HIGH("WTOG: Srch already aborted. Cleanup BPLMN state");
                  rrccsp_cleanup_bplmn_state();
                }

                if(rrc_csp_int_data.pending_type == RRC_CSP_PLMN_LIST_REQ_PENDING)
                {
                  rrccsp_cleanup_bplmn_state();
                  WRRC_MSG0_HIGH("Handle Pending Manual PLMN List Request");

                  /* Set state so that BPLMN search can be started */
                  rrc_csp_int_data.bplmn_nw_sel_mode = rrc_csp_int_data.pending_plmn_list_req_data.network_select_mode;
                  rrc_csp_int_data.service_search_bgnd = rrc_csp_int_data.pending_plmn_list_req_data.service_search;
                  rrccsp_update_plmn_list_req_data(&rrc_csp_int_data.pending_plmn_list_req_data);
                  rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_START, FALSE, FALSE);
                  WRRC_MSG1_HIGH("SSB: svc_srch_bgnd rcvd from NAS = %d", rrc_csp_int_data.service_search_bgnd);
#ifdef FEATURE_FEMTO_CSG
                  rrccsp_csg_set_fp_info();
#endif

                  WRRC_MSG2_HIGH("WTOW: dual_mode_enabled = %d,wcdma_mode_enabled = %d in PLMN_LIST_REQ", 
                                          rrc_csp_int_data.bplmn_dual_mode_enabled,rrc_csp_int_data.bplmn_wcdma_mode_enabled);
                  if(rrc_csp_int_data.bplmn_nw_sel_mode != SYS_NETWORK_SELECTION_MODE_MANUAL) 
                  {
                    WRRC_MSG1_ERROR("ERR: nw sel mode %d is not Manual when it shd be. Recover",
                                                        rrc_csp_int_data.bplmn_nw_sel_mode);
                    rrccsp_cleanup_bplmn_state();
                  }
                  else
                  {
                    rrccsp_generate_bplmn_rat_srch_order_update_curr_srch_rat(SYS_NETWORK_SELECTION_MODE_MANUAL);
                    if(rrc_csp_int_data.bplmn_wcdma_mode_enabled)
                    {
                      rrccsp_update_wtow_manual_bplmn_list_with_rplmn(rrc_csp_int_data.curr_acq_entry.plmn_id,
                                                                      rrc_csp_int_data.curr_acq_entry.cell_id);
                    }
                  }
                }
                else
                {
                  ERR_FATAL("Unexp pending type %d", rrc_csp_int_data.pending_type , 0, 0);
                }

                next_substate = rrccsp_send_channel_config_req_on_wcdma_resume();
                break;

              case RRC_CSP_WTOG_BPLMN_MANUAL_SCAN: 
                WRRC_MSG0_HIGH("WTOG: Resume succ after rcving Manual BPLMN Srch Cnf from RR");

                /* This flag is set when Abort Confirmation is received from GSM.
                 * We do not call the bplmn_cleanup function on receiving abort cnf
                 * as that also clears the scan type which is a problem when
                 * resume cnf is received in this substate.
                 */
                if(!rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_aborted)
                {
                  if(rrc_csp_wtog_bplmn_int_data.wtog_srch_done)
                  {
                    if(rrc_csp_int_data.plmn_srch_order.curr_rat_srch_idx >= (rrc_csp_int_data.plmn_srch_order.num_rats -1))
                    {
                      WRRC_MSG0_HIGH("WTOG: Srch done on GSM for Manual Srch. Send PLMN_LIST_CNF to NAS");
                      rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_STOP, TRUE, FALSE);
                    }
                    else
                    {
                      rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_SUSPEND, FALSE, FALSE);
                      rrc_csp_int_data.plmn_srch_order.curr_rat_srch_idx++;
#ifdef FEATURE_WCDMA_TO_LTE
                      if((rrc_csp_int_data.bplmn_interrat_type == RRC_CSP_INTERRAT_GSM) && 
                         (rrc_csp_int_data.plmn_srch_order.rat[rrc_csp_int_data.plmn_srch_order.curr_rat_srch_idx] 
                           == SYS_RAT_LTE_RADIO_ACCESS))
                      {
                        rrc_csp_init_wtog_plmn_srch_int_data_across_rats();
                        rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_active = TRUE;
                        rrc_csp_int_data.bplmn_interrat_type = RRC_CSP_INTERRAT_LTE;
                      }
                      else if((rrc_csp_int_data.bplmn_interrat_type == RRC_CSP_INTERRAT_LTE) && 
                                 (rrc_csp_int_data.plmn_srch_order.rat[rrc_csp_int_data.plmn_srch_order.curr_rat_srch_idx] 
                                    == SYS_RAT_GSM_RADIO_ACCESS))
                      {
                        rrc_csp_init_wtog_plmn_srch_int_data_across_rats();
                        rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_active = TRUE;
                        rrc_csp_int_data.bplmn_interrat_type = RRC_CSP_INTERRAT_GSM;
                      }
                      else
#endif
                      {
                         rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_active = FALSE;
                      }
                    }
                  }
                  else
                  {
                    WRRC_MSG0_HIGH("WTOG: Srch NOT done on GSM for Manual Search. Wait for next DRX");
                    rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_SUSPEND, FALSE, FALSE);
                  }
                }
                /* Search has already been aborted. Cleanup and restart BPLMN state */
                else
                {
                  if(rrc_csp_wtog_bplmn_int_data.restart_bplmn_search)
                  {
                    WRRC_MSG0_HIGH("WTOG: wtog srch already aborted. Cleanup & Restart BPLMN");
                    rrccsp_cleanup_and_restart_bplmn();        
                  }
                  else
                  {
                    WRRC_MSG0_HIGH("WTOG: wtog srch already aborted. Cleanup BPLMN");
                    rrccsp_cleanup_bplmn_state();
                  }
                }

                if(rrc_csp_int_data.pending_type == RRC_CSP_PLMN_LIST_REQ_PENDING)
                {
                  WRRC_MSG0_HIGH("Handle Pending PLMN List Request");
                  rrccsp_cleanup_bplmn_state();

                  /* Set state so that BPLMN search can be started */
                  rrc_csp_int_data.bplmn_nw_sel_mode = rrc_csp_int_data.pending_plmn_list_req_data.network_select_mode;
                  rrc_csp_int_data.service_search_bgnd = rrc_csp_int_data.pending_plmn_list_req_data.service_search;
                  WRRC_MSG1_HIGH("SSB: svc_srch_bgnd rcvd from NAS = %d", rrc_csp_int_data.service_search_bgnd);
                  rrccsp_update_plmn_list_req_data(&rrc_csp_int_data.pending_plmn_list_req_data);
                  rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_START, FALSE, FALSE);

                  WRRC_MSG2_HIGH("WTOW: dual_mode_enabled = %d,wcdma_mode_enabled = %d in PLMN_LIST_REQ", 
                                          rrc_csp_int_data.bplmn_dual_mode_enabled,rrc_csp_int_data.bplmn_wcdma_mode_enabled);
                  if(rrc_csp_int_data.bplmn_nw_sel_mode != SYS_NETWORK_SELECTION_MODE_MANUAL) 
                  {
                    WRRC_MSG1_ERROR("ERR: nw sel mode %d is not Manual when it shd be. Recover",
                                                        rrc_csp_int_data.bplmn_nw_sel_mode);
                    rrccsp_cleanup_bplmn_state();
                  }
                  else
                  {
                    rrccsp_generate_bplmn_rat_srch_order_update_curr_srch_rat(SYS_NETWORK_SELECTION_MODE_MANUAL);

                    if(rrc_csp_int_data.bplmn_wcdma_mode_enabled)
                    {
                      rrccsp_update_wtow_manual_bplmn_list_with_rplmn(rrc_csp_int_data.curr_acq_entry.plmn_id,
                                                                      rrc_csp_int_data.curr_acq_entry.cell_id);
                    }
                  }
                }
                else
                {
                  ERR_FATAL("Unexp pending type %d", rrc_csp_int_data.pending_type , 0, 0);
                }

                next_substate = rrccsp_send_channel_config_req_on_wcdma_resume();
                break;

#ifdef FEATURE_DUAL_SIM
              case RRC_CSP_UNLOCK_BY_SCAN:
                next_substate = rrccsp_pending_command_handler();
                break;
#endif

              default:
                ERR_FATAL("Unexp resume cnf when curr_scan = %d",rrc_csp_int_data.curr_scan,0,0);
                break;
            }
          }
          /* Resume Failed */
          else
          {
            switch(rrc_csp_int_data.curr_scan)
            {
              case RRC_CSP_WTOG_BPLMN_AUTOMATIC_SCAN:
                WRRC_MSG0_ERROR("WTOG: Resume Failure after rcving Auto BPLMN Srch Cnf from RR");

                /* ------------------------------------------------ */
                /* Send ABORT TO GSM and PLMN_LIST_CNF to NAS as    */
                /* Resume on W Failed                               */
                /* ------------------------------------------------ */
#ifdef FEATURE_BPLMN_SEARCH_320MS
                wcdma_resume_failed = TRUE;
#endif
                if(!rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_aborted)
                {
                  if(rrc_csp_wtog_bplmn_int_data.wtog_srch_done)
                  {
                    if(rrc_csp_wtog_bplmn_int_data.wtog_hplmn_found)
                    {
                      WRRC_MSG0_HIGH("WTOG: HPLMN found on GSM");
                    }
                    else 
                    {
                      WRRC_MSG0_HIGH("WTOG: Srch done but GSM HPLMN !Fnd");
                    } 

                    if(rrc_csp_int_data.plmn_srch_order.curr_rat_srch_idx >= (rrc_csp_int_data.plmn_srch_order.num_rats -1))
                    {
                      WRRC_MSG0_HIGH("WTOG: Send PLMN_LIST_CNF to NAS");
                      rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_STOP, TRUE, FALSE);
                    }
                    /* Since resume failed, send plmn list cnf to NAS with status aborted */
                    else
                    {
                      rrccsp_cleanup_bplmn_state();                    
                    } 
                  }
                  else
                  {
                    WRRC_MSG0_HIGH("WTOG: Srch NOT completed on GSM. Abort Search. Send List_Cnf");

                    /* Send RR_INTERRAT_PLMN_SRCH_ABORT_REQ to GSM and Send PLMN_LIST_CNF to NAS */
                    rrccsp_cleanup_bplmn_state();
                  }
                }
                /* Search has been aborted. Cleanup BPLMN state */
                else
                {
                  WRRC_MSG0_HIGH("WTOG: Srch already aborted. Cleanup BPLMN state");
                  rrccsp_cleanup_bplmn_state();
                }

                if(rrc_csp_int_data.pending_type == RRC_CSP_PLMN_LIST_REQ_PENDING)
                {
                  WRRC_MSG0_HIGH("Handle Pending PLMN List Request");
                  rrccsp_cleanup_bplmn_state();
                  /* Set state so that BPLMN search can be started */
                  rrc_csp_int_data.bplmn_nw_sel_mode = rrc_csp_int_data.pending_plmn_list_req_data.network_select_mode;
                  rrc_csp_int_data.service_search_bgnd = rrc_csp_int_data.pending_plmn_list_req_data.service_search;
                  rrccsp_update_plmn_list_req_data(&rrc_csp_int_data.pending_plmn_list_req_data);
                  rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_START, FALSE, FALSE);
                  WRRC_MSG1_HIGH("SSB: svc_srch_bgnd rcvd from NAS = %d", rrc_csp_int_data.service_search_bgnd);
                  
                  WRRC_MSG2_HIGH("WTOW: dual_mode_enabled = %d, wcdma_mode_enabled = %d in PLMN_LIST_REQ", 
                                          rrc_csp_int_data.bplmn_dual_mode_enabled,rrc_csp_int_data.bplmn_wcdma_mode_enabled);
                  if(rrc_csp_int_data.bplmn_nw_sel_mode != SYS_NETWORK_SELECTION_MODE_MANUAL) 
                  {
                    WRRC_MSG1_ERROR("ERR: nw sel mode %d is not Manual when it shd be. Recover",
                                                        rrc_csp_int_data.bplmn_nw_sel_mode);
                    rrccsp_cleanup_bplmn_state();
                  }
                  else
                  {
                    rrccsp_generate_bplmn_rat_srch_order_update_curr_srch_rat(SYS_NETWORK_SELECTION_MODE_MANUAL);
                    if(rrc_csp_int_data.bplmn_wcdma_mode_enabled)
                    {
                      rrccsp_update_wtow_manual_bplmn_list_with_rplmn(rrc_csp_int_data.curr_acq_entry.plmn_id,
                                                                      rrc_csp_int_data.curr_acq_entry.cell_id);
                    }
                  }
                }
                else
                {
                  ERR_FATAL("Unexp pending type %d", rrc_csp_int_data.pending_type , 0, 0);
                }

                /* ------------------------------------------------ */
                /* Trigger OOS handling in Idle/Connected RRC state */
                /* ------------------------------------------------ */

                /* In Idle State start cell selection */
                if(rrc_current_state == RRC_STATE_DISCONNECTED)
                { 
                  next_substate = rrc_csp_start_sel_out_of_service_area_in_idle_state();
                }

                /* In Connected State send OOS indication to CU so that
                 * appropriate timers are started in CU. CU will then send
                 * initiate cell selection indication to CSP
                 */
                else if((rrc_current_state == RRC_STATE_CELL_PCH) 
                        || (rrc_current_state == RRC_STATE_URA_PCH))
                {
                  next_substate = rrccsp_send_cell_update_initiate_req(RRC_REENTERED_SERVICE_AREA);
                }

                /* In Connecting or FACH State, BPLMN search cannot be in progress */
                else
                {
                  WRRC_MSG1_ERROR("ERR Mode Resume in wrong RRC state %d", rrc_current_state);
                  if(rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED)
                  {
                    next_substate = RRCCSP_CAMPED_ACCEPT_CELL;
                  }
                  else
                  {
                    next_substate = RRCCSP_CAMPED_SUIT_CELL;
                  } 
                }   
                break;

              case RRC_CSP_WTOG_BPLMN_MANUAL_SCAN: 
                WRRC_MSG0_ERROR("WTOG: Resume failure after rcving Manual BPLMN Srch Cnf from RR");

#ifdef FEATURE_BPLMN_SEARCH_320MS
                wcdma_resume_failed = TRUE;
#endif
                /* ------------------------------------------------ */
                /* Send PLMN_LIST_CNF to NAS as Resume on W Failed  */
                /* ------------------------------------------------ */
                if(!rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_aborted)
                {
                  if(rrc_csp_wtog_bplmn_int_data.wtog_srch_done)
                  {
                    if(rrc_csp_int_data.plmn_srch_order.curr_rat_srch_idx >= (rrc_csp_int_data.plmn_srch_order.num_rats -1))
                    {
                      WRRC_MSG0_HIGH("WTOG: Srch done on GSM for Manual Srch. Send PLMN_LIST_CNF to NAS");
                      rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_STOP, TRUE, FALSE);
                    }
                    else
                    {
                      WRRC_MSG0_HIGH("WTOG: Srch done on GSM for Manual Srch. Send PLMN_LIST_CNF to NAS as aborted");
                      rrccsp_cleanup_bplmn_state();
                    }
                  }
                  else
                  {
                    WRRC_MSG0_HIGH("WTOG: Srch incomplete on GSM for Manual Srch. Snd LIST CNF to NAS");
                    rrccsp_cleanup_bplmn_state();
                  }
                }
                /* Search has been aborted. Cleanup BPLMN state */
                else
                {
                  WRRC_MSG0_HIGH("WTOG:/WTOL Srch already aborted. Cleanup BPLMN state");
                  rrccsp_cleanup_bplmn_state();
                }

                if(rrc_csp_int_data.pending_type == RRC_CSP_PLMN_LIST_REQ_PENDING)
                {
                  WRRC_MSG0_HIGH("Handle Pending PLMN List Request");
                  rrccsp_cleanup_bplmn_state();
                  /* Set state so that BPLMN search can be started */
                  rrc_csp_int_data.bplmn_nw_sel_mode = rrc_csp_int_data.pending_plmn_list_req_data.network_select_mode;
                  rrc_csp_int_data.service_search_bgnd = rrc_csp_int_data.pending_plmn_list_req_data.service_search;
                  rrccsp_update_plmn_list_req_data(&rrc_csp_int_data.pending_plmn_list_req_data);
                  rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_START, FALSE, FALSE);
                  WRRC_MSG1_HIGH("SSB: svc_srch_bgnd rcvd from NAS = %d", rrc_csp_int_data.service_search_bgnd);

                  WRRC_MSG2_HIGH("WTOW: dual_mode_enabled = %d, wcdma_mode_enabled = %d in PLMN_LIST_REQ", 
                                          rrc_csp_int_data.bplmn_dual_mode_enabled,rrc_csp_int_data.bplmn_wcdma_mode_enabled);
                  if(rrc_csp_int_data.bplmn_nw_sel_mode != SYS_NETWORK_SELECTION_MODE_MANUAL) 
                  {
                    WRRC_MSG1_ERROR("ERR: nw sel mode %d is not Manual when it shd be. Recover",
                                                        rrc_csp_int_data.bplmn_nw_sel_mode);
                    rrccsp_cleanup_bplmn_state();
                  }
                  else
                  {
                    rrccsp_generate_bplmn_rat_srch_order_update_curr_srch_rat(SYS_NETWORK_SELECTION_MODE_MANUAL);
                    if(rrc_csp_int_data.bplmn_wcdma_mode_enabled)
                    {
                      rrccsp_update_wtow_manual_bplmn_list_with_rplmn(rrc_csp_int_data.curr_acq_entry.plmn_id,
                                                                      rrc_csp_int_data.curr_acq_entry.cell_id);
                    }
                  }
                }
                else
                {
                  ERR_FATAL("Unexp pending type %d", rrc_csp_int_data.pending_type , 0, 0);
                }

                /* ------------------------------------------------ */
                /* Trigger OOS handling in Idle/Connected RRC state */
                /* ------------------------------------------------ */

                /* In Idle State start cell selection */
                if(rrc_current_state == RRC_STATE_DISCONNECTED)
                { 
                  next_substate = rrc_csp_start_sel_out_of_service_area_in_idle_state();
                }

                /* In Connected State send OOS indication to CU so that
                 * appropriate timers are started in CU. CU will then send
                 * initiate cell selection indication to CSP
                 */
                else if((rrc_current_state == RRC_STATE_CELL_PCH) 
                        || (rrc_current_state == RRC_STATE_URA_PCH))
                {
                  next_substate = rrccsp_send_cell_update_initiate_req(RRC_REENTERED_SERVICE_AREA);
                }

                /* In Connecting or FACH State, BPLMN search cannot be in progress */
                else
                {
                  WRRC_MSG1_ERROR("ERR Mode Resume in wrong RRC state %d", rrc_current_state);
                  if(rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED)
                  {
                    next_substate = RRCCSP_CAMPED_ACCEPT_CELL;
                  }
                  else
                  {
                    next_substate = RRCCSP_CAMPED_SUIT_CELL;
                  } 
                }   
                break;
#ifdef FEATURE_DUAL_SIM
              case RRC_CSP_UNLOCK_BY_SCAN:
                next_substate = rrccsp_pending_command_handler();
                break;
#endif

              default:
                WRRC_MSG1_HIGH("Unexp resume cnf when curr_scan = %d",rrc_csp_int_data.curr_scan);
                break;
            }
          }
        }
      }
      else
      {
        /* TBD: Any action if mode change to another mode is received */
        WRRC_MSG2_ERROR("ERR Unexpected Chg Mode CNF to %d in %d state",cmd_ptr->cmd.change_mode_cnf.mode,
                                                                      rrc_csp_substate);
      }
      break;

    case RRC_INITIATE_CELL_SELECTION_IND:
      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
      if(cmd_ptr->cmd.initiate_cell_sel_ind.cause == RRC_TRANSITION_TO_DISCONNECTED)
      {
        WRRC_MSG1_HIGH("Saving initiate cell sel, proc rrc_proc_e_type_value%d",
                   cmd_ptr->cmd.initiate_cell_sel_ind.proc);
        rrc_csp_int_data.init_cell_sel_ind_during_wtointerrat = TRUE;
      }
      else
      {
        WRRC_MSG2_HIGH("Cause %d not handled %d CSP sstate ",
                  cmd_ptr->cmd.initiate_cell_sel_ind.cause, rrc_csp_substate);
      }
      break;

    case RRC_PLMN_LIST_REQ:
      MSG_MED("Cmd 0x%x recvd, CSP sstate %d", cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );

      /* if not camped on, current scan is plmn_list_scan  and state is disconnected then this is 
          * back to back PLMN list scan. We shouldnt abort the new scan. 
          */
      if ((rrc_csp_int_data.curr_scan == RRC_CSP_PLMN_LIST_SCAN)
          && (rrc_get_state() == RRC_STATE_DISCONNECTED)
          && (RRC_NOT_CAMPED_ON == rrc_ccm_get_curr_camping_status(RRC_PROCEDURE_CSP))
          && ( cmd_ptr->cmd.plmn_list_req.network_select_mode == SYS_NETWORK_SELECTION_MODE_MANUAL)
            )
      {
        WRRC_MSG0_HIGH("Back to Back PLMN List Req, Handling second one");
        rrc_csp_int_data.curr_scan = RRC_CSP_CELL_SELECTION_SCAN;
      }

      if(RRC_MODE_ACTIVE == rrcmcm_get_rrc_mode())
      {
        if(rrccsp_plmn_list_req_when_resume_in_prog_is_valid(&(cmd_ptr->cmd.plmn_list_req)))
        {
          /* UE is OOS in Idle State */
          if(rrc_csp_int_data.curr_scan == RRC_CSP_CELL_SELECTION_SCAN)
          {
            WRRC_MSG0_HIGH("UE is OOS in Idle State. Do Manual Srch in Fgnd");
            rrccsp_cleanup_bplmn_state();

            /* Start scanning the frequency band for PLMNs */
            rrc_csp_int_data.plmn_list.num_plmns = 0;
#ifdef FEATURE_FEMTO_CSG
            rrc_csp_int_data.service_search_bgnd = cmd_ptr->cmd.plmn_list_req.service_search;
            WRRC_MSG1_HIGH("CSG: Filling service_search %d",rrc_csp_int_data.service_search_bgnd);
            rrccsp_csg_set_fp_info();
#endif
            rrccsp_update_plmn_list_req_data(&cmd_ptr->cmd.plmn_list_req);
            /*For foreground searches overwrite band preference blindly. 
              It will anways get updated for next service request*/
            rrc_csp_int_data.band_pref = rrc_csp_int_data.bplmn_band_pref;
            rrccsp_update_band_preference();
            next_substate = rrc_csp_start_sel_for_plmn_list();
          }
          /* Cleanup BPLMN state in case a plmn list search is pending. Also
           * save the new plmn list request
           */
          else if((rrc_csp_int_data.curr_scan != RRC_CSP_WTOG_BPLMN_AUTOMATIC_SCAN)
                   && (rrc_csp_int_data.curr_scan != RRC_CSP_WTOG_BPLMN_MANUAL_SCAN))
          {
#ifdef FEATURE_DUAL_SIM
          /*If G is in data call reject manual PLMN search in this substate*/
          /*If we want to handle in foreground then we might have to pend the command
            till we receive channel config confirm. Not sure if we can start right after
            receiving resume confirm. */
          if(WRM_G2W_TA_MODE_ACTIVE() && (cmd_ptr->cmd.plmn_list_req.network_select_mode == SYS_NETWORK_SELECTION_MODE_AUTOMATIC))
          {
            rrc_csp_send_mm_plmn_list_cnf_as_aborted(cmd_ptr->cmd.plmn_list_req.trans_id);
            return next_substate;
          }
#endif
            rrccsp_cleanup_bplmn_state();
            /* Set state so that BPLMN search can be started */
            rrc_csp_int_data.bplmn_nw_sel_mode = cmd_ptr->cmd.plmn_list_req.network_select_mode;

            rrc_csp_int_data.service_search_bgnd = cmd_ptr->cmd.plmn_list_req.service_search;
            WRRC_MSG1_HIGH("SSB: svc_srch_bgnd rcvd from NAS = %d", rrc_csp_int_data.service_search_bgnd);

            /* If Automatic BPLMN search is requested then reject it in this CSP substate,
             * since anyways another Automatic BPLMN search request will be received by CSP in
             * 10s.
             */
            if(rrc_csp_int_data.bplmn_nw_sel_mode == SYS_NETWORK_SELECTION_MODE_AUTOMATIC)
            {
              WRRC_MSG1_HIGH("WTOW: Rejecting APLS req in CSP sst %d", next_substate);

              rrc_csp_bplmn_send_mm_plmn_list_cnf_cmd(WTOW_SEARCH_ABORT,cmd_ptr->cmd.plmn_list_req.trans_id);
            }
            /* Handle Manual Search in this CSP substate */
            else
            {
              rrccsp_update_plmn_list_req_data(&cmd_ptr->cmd.plmn_list_req);
              rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_START, FALSE, FALSE);
#ifdef FEATURE_FEMTO_CSG
              rrccsp_csg_set_fp_info();
#endif

              WRRC_MSG2_HIGH("WTOW: dual_mode_enabled = %d,wcdma_mode_enabled = %d in PLMN_LIST_REQ", 
                                      rrc_csp_int_data.bplmn_dual_mode_enabled,rrc_csp_int_data.bplmn_wcdma_mode_enabled);
              rrccsp_generate_bplmn_rat_srch_order_update_curr_srch_rat(SYS_NETWORK_SELECTION_MODE_MANUAL);

              if(rrc_csp_int_data.bplmn_wcdma_mode_enabled)
              {
                rrccsp_update_wtow_manual_bplmn_list_with_rplmn(rrc_csp_int_data.curr_acq_entry.plmn_id,
                                                                rrc_csp_int_data.curr_acq_entry.cell_id);
              }
            }
          }
          else
          {
            rrccsp_save_req(cmd_ptr);
            next_substate = RRCCSP_WT_RESUME_MODE_CHANGE_CNF_PENDING;
          }
        }
      }
      else
      {
        WRRC_MSG1_ERROR("ERR PLMN_LIST_REQ rcvd when RRC mode is not active %d", rrcmcm_get_rrc_mode());
      }
      break;  

    case RRC_SERVICE_REQ:
      if(RRC_MODE_ACTIVE == rrcmcm_get_rrc_mode())
      {
        if(rrc_current_state != RRC_STATE_DISCONNECTED)
        {
          WRRC_MSG1_ERROR("Service req in RRC state %d",rrc_current_state);
        }   

        rrccsp_prioritize_pending_commands(cmd_ptr);

        /* Process the Service Request */
        WRRC_MSG0_HIGH("Start cell sel for srvc req");
        rrc_csp_init_data_from_service_req(&(cmd_ptr->cmd.rrc_service_req));
        /* Release the established channels and start cell selection */
        next_substate = rrc_csp_release_chls_and_start_sel_on_mm_req();
      }
      else
      {
        WRRC_MSG1_ERROR("Err RRC_SERVICE_REQ rcvd when RRC mode is not active %d", rrcmcm_get_rrc_mode());
      }
      break;

    case RRC_BPLMN_GUARD_SRCH_TIMER_EXPIRED_IND:
      if((rrc_csp_int_data.curr_scan == RRC_CSP_WTOG_BPLMN_AUTOMATIC_SCAN)
          || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOG_BPLMN_MANUAL_SCAN))
      {
        if(!rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_aborted)
        {
          rrccsp_send_irat_bplmn_abort_req();
        }
        else
        {
          WRRC_MSG0_HIGH("WTOG: search already aborted");
        }
        rrc_csp_wtog_bplmn_int_data.restart_bplmn_search = FALSE;
      }
      else
      {
        rrccsp_cleanup_bplmn_state();
      }
      break;

    case RRC_BPLMN_SEARCH_ABORT_REQ:
      if(   (rrc_csp_int_data.curr_scan == RRC_CSP_WTOG_BPLMN_AUTOMATIC_SCAN)
         || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOG_BPLMN_MANUAL_SCAN)
         || (rrc_csp_int_data.curr_scan == RRC_CSP_PLMN_LIST_SCAN)
        )
      {
        if(!rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_aborted)
        {
          rrccsp_send_irat_bplmn_abort_req();
        }
        else
        {
          WRRC_MSG0_HIGH("WTOG: search already aborted");
        }
        rrc_csp_wtog_bplmn_int_data.restart_bplmn_search = FALSE;
      }
      else
      {
        rrccsp_cleanup_bplmn_state();
      }
      break;

    case RRC_BPLMN_SUSPEND_REQ:
      rrccsp_handle_passive_bplmn_suspend_req( cmd_ptr );
      break;

    default:
      WRRC_MSG2_HIGH( "Cmd 0x%x not processed in CSP sstate %d",
                            cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);
      break;
  }
  return( next_substate );
} /* rrccsp_wt_resume_mode_change_cnf_pending_hdlr */


#ifdef FEATURE_GAN_3G_ROVE_OUT_ONLY
#error code not present
#endif /*FEATURE_GAN_3G_ROVE_OUT_ONLY*/
/*===========================================================================

FUNCTION RRCCSP_SEND_RRC_MODE_CHANGE_CNF_TO_MM

DESCRIPTION

  This function sends RRC_MODE_CHANGE_CNF to MM

DEPENDENCIES

  None.

RETURN VALUE

  None.

SIDE EFFECTS

  None.

===========================================================================*/
static void rrccsp_send_mode_change_cnf_to_mm(void)
{
  mm_cmd_type *mm_buf_ptr;

  /* SEND the RRC_MODE_CHANGE_CNF to MM */
  /* Get a buffer from MM task */
  mm_buf_ptr = mm_rrc_get_cmd_buf(RRC_MODE_CHANGE_CNF);

  /* Update the Max HFNs values to be stored in SIM or USIM */
  (void) rrcsmc_append_hfns_to_rel_ind(mm_buf_ptr->cmd.rrc_deact_cnf.hfn_cs,
                                       mm_buf_ptr->cmd.rrc_deact_cnf.hfn_ps);

#ifdef FEATURE_DUAL_SIM
  mm_buf_ptr->cmd.rrc_deact_cnf.as_id = rrc_get_as_id();
#endif

  WRRC_MSG0_HIGH("Dispatching out MM cmd RRC_MODE_CHANGE_CNF sent to MM");
  /* Put the command on MM queue */
  rrc_send_rrc_message_to_mm(mm_buf_ptr);

  if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5)
  {
    WRRC_MSG0_HIGH("Resetting hsdpa_hsupa_ind");
    hsdpa_hsupa_ind = SYS_HS_IND_HSDPA_HSUPA_UNSUPP_CELL;
  }

#ifdef FEATURE_DUAL_SIM
  rrc_stop_lock_wait_timer();
  rrc_release_lock();
#endif

#ifdef FEATURE_WCDMA_ABSOLUTE_PRIORITY
  rrcmeas_invalidate_dedicated_priority_info();
#endif
} /* rrccsp_send_mode_change_cnf_to_mm */

#ifdef FEATURE_INTERRAT_CELL_RESELECTION_GTOW
/*===========================================================================

FUNCTION        RRCCSP_WT_STOP_MODE_CHANGE_CNF_HDLR

DESCRIPTION
                This is a handler for events received in
                RRCCSP_WT_STOP_MODE_CHANGE_CNF substate of
                the Cell Selection Procedure.
                Depending on the event, it further calls a function for
                processing the event in this CSP substate.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_wt_stop_mode_change_cnf_hdlr( rrc_cmd_type *cmd_ptr )
{
  rrc_csp_substate_e_type   next_substate;

  /* Inter-RAT command */
  rrc_rr_cmd_type *rr_cmd;

  boolean interrat_cmd = FALSE;
#ifdef FEATURE_LTE_TO_WCDMA
  if(cmd_ptr->cmd_hdr.cmd_id == RRC_LTE_RRC_CMD)
  {
    interrat_cmd = TRUE;
  }
#endif

  if((((uint32)cmd_ptr->cmd_hdr.cmd_id & RRC_RR_CMD_ID_BASE) == RRC_RR_CMD_ID_BASE))
  {
    interrat_cmd = TRUE;
  }

  next_substate = rrc_csp_substate;


  if(!interrat_cmd)
  {
    switch( cmd_ptr->cmd_hdr.cmd_id )
    {
      case RRC_CHANGE_MODE_CNF:
        MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                           cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
        if(cmd_ptr->cmd.change_mode_cnf.mode == RRC_MODE_INACTIVE)
        {
          if((rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN) ||
                (rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_MANUAL_SCAN))
          {
            /* If BPLMN timer expired, or PLMN found or frequency scan exhausted
             * send search confirmation to RR
             */
            if(rrc_csp_int_data.bplmn_srch_cnf)
            {
              rrccsp_send_irat_bplmn_srch_rsp();
            }
            /* If abort request received then send abort confirmation to RR */
            else
            {
              rrccsp_send_irat_bplmn_srch_abort_rsp();
            }

            /* CSP goes back to NO_CELL_SELECTED state */
            next_substate = RRCCSP_NO_CELL_SELECTED;
          }
          else if(rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_CELL_RESELECTION_SCAN)
          {
#ifdef FEATURE_WCDMA_ABSOLUTE_PRIORITY
            rrcmeas_invalidate_dedicated_priority_info();
#endif
            if(rrc_csp_int_data.rsp_to_rr == SEND_GTOW_RESEL_ABORT_CNF)
            {
              rrccsp_send_irat_reselection_abort_rsp();
            }
            else if(rrc_csp_int_data.rsp_to_rr == SEND_GTOW_RESEL_REJECT)
            {
              rrccsp_send_irat_reselection_rsp();
            }
            else
            {
              WRRC_MSG1_ERROR("ERR Incorrect enum value for rsp_to_rr = %d", rrc_csp_int_data.rsp_to_rr);
            }

            /* Invalidate entities in RRC CSP Internal data structure */
            rrc_csp_init_int_data();
            /* CSP goes back to NO_CELL_SELECTED state */
            next_substate = RRCCSP_NO_CELL_SELECTED;
          }

          else if(rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_REDIRECTION_SCAN)
          {
#ifdef FEATURE_WCDMA_ABSOLUTE_PRIORITY
            rrcmeas_invalidate_dedicated_priority_info();
#endif
            if(rrc_csp_int_data.rsp_to_rr == SEND_GTOW_REDIRECTION_ABORT_CNF)
            {

#ifdef FEATURE_LTE_TO_WCDMA
              if(rrc_csp_int_data.interrat_type == RRC_CSP_INTERRAT_LTE)
              {
                rrccsp_send_lte_interrat_redirection_abort_rsp();
              }
              else
#endif
              {
                /* Send the Redirection abort confirmation to GSM RR */
                rrccsp_send_gtow_redirection_abort_cnf();
              }
            }
            else if(rrc_csp_int_data.rsp_to_rr == SEND_GTOW_REDIRECTION_REJECT)
            {
              WRRC_MSG0_HIGH("rsp_to_rr = Interrat REDIRECTION_REJECT");

#ifdef FEATURE_LTE_TO_WCDMA
              if(rrc_csp_int_data.interrat_type == RRC_CSP_INTERRAT_LTE)
              {
                /* Send the Redirection failed response to LTE RRC */
                rrccsp_send_lte_interrat_redirection_failed_rsp();
              }
              else
#endif
              {
                /* Send the Redirection Rej to GSM RR */
                rrccsp_send_gtow_redirection_reject();
              }
            }
            else
            {
              WRRC_MSG1_ERROR("ERR Incorrect enum value for rsp_to_rr = %d", rrc_csp_int_data.rsp_to_rr);
            }

            /* Invalidate entities in RRC CSP Internal data structure */
            rrc_csp_init_int_data();
            /* CSP goes back to NO_CELL_SELECTED state */
            next_substate = RRCCSP_NO_CELL_SELECTED;
          }

#ifdef FEATURE_GAN_3G_ROVE_OUT_ONLY
          #error code not present
#endif
          else
          {
            WRRC_MSG1_HIGH("Change Mode Cnf to Inactive rcvd in csp scan %d", rrc_csp_int_data.curr_scan);

            /* Invalidate entities in RRC CSP Internal data structure */
            rrc_csp_init_int_data();
            /* CSP goes back to NO_CELL_SELECTED state */
            next_substate = RRCCSP_NO_CELL_SELECTED;
          }
#if defined(FEATURE_WCDMA_TO_LTE) || defined (FEATURE_LTE_TO_WCDMA)
          if(LTE_RRC_DEDICATED_PRI_OWNER_WCDMA != lte_rrc_dedicated_pri_get_owner())
          {
            rrcmeas_invalidate_dedicated_priority_info();
          }
#endif
        }
        else if(cmd_ptr->cmd.change_mode_cnf.mode == RRC_MODE_CHANGE)
        {
          if(rrc_csp_int_data.mode_change_reason == SYS_STOP_MODE_REASON_LPM)
          {
            if(rrc_check_gsm_bands_supported())
            {
              rrccsp_send_rr_rrc_stop_gsm_req(MODE_LPM);
            }
            else
            {
              rrc_csp_write_nv_acq_info();
              wl1_clear_barred_cells();
              /* Inter Frequency Redirection Scan was aborted. Clean up its state */
              if(rrc_csp_int_data.curr_scan == RRC_CSP_INTER_FREQ_REDIRECTION_SCAN)
              {
                rrc_csp_cleanup_inter_freq_redirection_state();
              }

              rrcccm_force_init();
              /* Send RRC_MODE_CHANGE_CNF to MM */
              rrccsp_send_mode_change_cnf_to_mm();
             /* CSP goes back to NO_CELL_SELECTED state */
              next_substate = RRCCSP_NO_CELL_SELECTED;
              /* Invalidate entities in RRC CSP Internal data structure */
              rrc_csp_init_int_data();
              rrccsp_reset_reselection_data();
              return next_substate;
            }
          }
          else
          {
            /* Inter Frequency Redirection Scan was aborted. Clean up its state */
            if(rrc_csp_int_data.curr_scan == RRC_CSP_INTER_FREQ_REDIRECTION_SCAN)
            {
              rrc_csp_cleanup_inter_freq_redirection_state();
            }
    
            rrcccm_force_init();
            /* Send RRC_MODE_CHANGE_CNF to MM */
            rrccsp_send_mode_change_cnf_to_mm();
            /* CSP goes back to NO_CELL_SELECTED state */
            next_substate = RRCCSP_NO_CELL_SELECTED;
            /* Invalidate entities in RRC CSP Internal data structure */
            rrc_csp_init_int_data();
            rrccsp_reset_reselection_data();

#ifdef FEATURE_WCDMA_ABSOLUTE_PRIORITY
            rrcmeas_invalidate_dedicated_priority_info();
#if defined(FEATURE_LTE_TO_WCDMA) || defined (FEATURE_WCDMA_TO_LTE)
            rrcmeas_handle_clear_dedicated_pri_ind();
#endif
#endif

          }
        }
        else
        {
          WRRC_MSG2_ERROR("ERR Unexpected Chg Mode CNF to %d in %d state",cmd_ptr->cmd.change_mode_cnf.mode,
                                                                        rrc_csp_substate);
        }
        break;

      case RRC_BPLMN_SRCH_TIMER_EXPIRED_IND:
        rrc_csp_int_data.bplmn_srch_tmr_expired = TRUE;
        break;

      case RRC_IRAT_ABORT_IND:
        if(rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_REDIRECTION_SCAN)
        {
          rrc_csp_int_data.rsp_to_rr        = SEND_GTOW_REDIRECTION_ABORT_CNF;
        }
        else
        {
          rrc_csp_int_data.rsp_to_rr        = SEND_GTOW_RESEL_ABORT_CNF;
        }

        break;
    
      default:
        WRRC_MSG2_HIGH( "Cmd 0x%x not processed in CSP sstate %d",
                              cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);
        break;
    }
  }
  else if(((uint32)cmd_ptr->cmd_hdr.cmd_id & RRC_RR_CMD_ID_BASE) == RRC_RR_CMD_ID_BASE)
  {
    rr_cmd = ((rrc_rr_cmd_type *)cmd_ptr);     /*lint !e740 */

    switch(rr_cmd->cmd_hdr.cmd_id)
    {
      case RRC_INTERRAT_PLMN_SRCH_ABORT_REQ:
        WRRC_MSG0_HIGH("BPLMN:SRCH_ABORT_REQ rcvd in STOP_MODE_CHNGE_CNF substate");
        rrc_csp_int_data.bplmn_srch_cnf = FALSE;
        next_substate = RRCCSP_WT_STOP_MODE_CHANGE_CNF;
        break;

      case RR_RRC_STOP_GSM_CNF:
        WRRC_MSG0_HIGH("Rcvd RR_RRC_STOP_GSM_CNF in CSP");
        rrc_csp_write_nv_acq_info();
        wl1_clear_barred_cells();
        /* Inter Frequency Redirection Scan was aborted. Clean up its state */
        if(rrc_csp_int_data.curr_scan == RRC_CSP_INTER_FREQ_REDIRECTION_SCAN)
        {
          rrc_csp_cleanup_inter_freq_redirection_state();
        }

        rrcccm_force_init();
        /* Send RRC_MODE_CHANGE_CNF to MM */
        rrccsp_send_mode_change_cnf_to_mm();
        /* CSP goes back to NO_CELL_SELECTED state */
        next_substate = RRCCSP_NO_CELL_SELECTED;
        /* Invalidate entities in RRC CSP Internal data structure */
        rrc_csp_init_int_data();
        rrccsp_reset_reselection_data();
        break;

      default:
        WRRC_MSG0_HIGH("BPLMN: Cmd not processed in STOP_MODE_CHNGE_CNF sstate");
        break;
    }
  }
#ifdef FEATURE_LTE_TO_WCDMA
  else if(cmd_ptr->cmd_hdr.cmd_id == RRC_LTE_RRC_CMD)
  {
    switch(cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.msg_hdr.id)
    {
      case WCDMA_RRC_LTE_ABORT_PLMN_SRCH_REQ:
        WRRC_MSG0_HIGH("LTOW:WCDMA_RRC_LTE_ABORT_PLMN_SRCH_REQ Rcvd in STOP_MODE_CHNGE_CNF sstate");
        rrc_csp_int_data.bplmn_srch_cnf = FALSE;
        next_substate = RRCCSP_WT_STOP_MODE_CHANGE_CNF;
        break;
      default:
        WRRC_MSG2_HIGH("LTOW: Invalid cmd %x from LTE RRC in CSP substate %d",
            cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.msg_hdr.id,rrc_csp_substate);
        break;
    }
  }
#endif
  return( next_substate );
} /* rrccsp_wt_stop_mode_change_cnf_hdlr */


/*===========================================================================

FUNCTION        RRCCSP_SUIT_CELL_WT_ACTIVATION_RSP_HDLR

DESCRIPTION
                This is a handler for events received in
                RRCCSP_SUIT_CELL_WT_ACTIVATION_RSP substate of
                the Cell Selection Procedure.
                Depending on the event, it further calls a function for
                processing the event in this CSP substate.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_suit_cell_wt_activation_rsp_hdlr( rrc_cmd_type *cmd_ptr )
{
  rrc_csp_substate_e_type   next_substate;
  rrc_state_e_type          rrc_state;

  next_substate = rrc_csp_substate;

  switch( cmd_ptr->cmd_hdr.cmd_id )
  {
    case RRC_ACTIVATION_RSP:
      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );

      /* Send Service Indication to MM */
      rrc_csp_send_mm_cmd(RRC_SERVICE_IND,
                          rrc_csp_int_data.curr_service_status,
                          &rrc_csp_int_data.curr_sel_plmn,
                          &rrc_csp_int_data.curr_acq_entry);

      /* In case of G-to-W re-selection, Notify location information change to the 
       * registered callback if UE is not in Cell_DCH State */
      if (rrc_get_state() != RRC_STATE_CELL_DCH && rrc_home_zone_ind_cb_func)
      {
        rrc_trigger_home_zone_ind();
      }

      /* Notify the serving cell id change indication to the registered callbacks */
      rrc_notify_cell_id_change();

      /* Updating the EcIo/RSSI to CM */
      rrctmr_stop_timer(RRCTMR_RSSI_BER_TIMER);
      rrc_rssi_ber_timeout_handler();

#ifdef FEATURE_GAN
      #error code not present
#endif

      if(rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_REDIRECTION_SCAN)
      {
        WRRC_MSG0_HIGH("GtoW Redirection: stopping the GtoW redirection timer");
        rrctmr_stop_timer(RRCTMR_GTOW_REDIRECTION_WAIT_TIMER);

        rrctmr_stop_timer(RRCTMR_GTOW_REDIRECTION_LFS_TIMER);

        /* Reset the timer flag */
        rrc_csp_int_data.gtow_redirection_timer_expired = TRUE;
        rrc_csp_int_data.skip_repeat_scan_for_redir = FALSE;
        /* Reset the LFS scan retry flag */
        rrc_csp_int_data.gtow_redir_retry_lfs_scan = FALSE;

        /* Reset current_scan */
        rrc_csp_int_data.curr_scan = RRC_CSP_CELL_SELECTION_SCAN;

#ifdef FEATURE_WCDMA_TO_LTE
        if(rrc_csp_int_data.interrat_type  == RRC_CSP_INTERRAT_LTE)
        {
#ifdef FEATURE_WCDMA_CSFB_CALL_OPT
          if(rrc_csfb_reset_while_waiting_for_act_rsp == TRUE)
          {
            rrc_csfb_reset_while_waiting_for_act_rsp = FALSE;
            next_substate = rrc_csp_start_sel_out_of_service_area_in_idle_state();
            break;
          }
#endif
          /* Set the flag to not include pre-redirection info in connection request message */
          WRRC_MSG0_HIGH("LTOW Redirection:set flag to not include pre-redir info in conn request msg");
          rrc_csp_int_data.exclude_preredir_info_in_conn_req_msg = TRUE;
        }
#endif
      }

      if(rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_CELL_RESELECTION_SCAN)
      {
        WRRC_MSG0_HIGH("GtoW Resel: reset the scan");

        /* Reset current_scan */
        rrc_csp_int_data.curr_scan = RRC_CSP_CELL_SELECTION_SCAN;
      }

      /* No need to stop DCH->FACH cell selection timer as it should
       * not be active at this point during cell reselection.
       */

#ifdef FEATURE_DUAL_SIM
      /* Release the lock for interrat procedures except for GTOW CCO*/
      if(rrc_csp_int_data.curr_scan != RRC_CSP_GTOW_CC_ORDER_SCAN)
      {
        /* Do not release the lock for CSFB call */
        rrc_stop_lock_wait_timer();

#ifdef FEATURE_3GPP_CSFB
        if(!rrc_csfb_call_status)
        {
          rrc_release_lock();
        }
        else
        {
          WRRC_MSG0_HIGH("DSIM: CSFB call status is set. Do not release the lock");
        }
#else
        rrc_release_lock();
#endif
      }
     
#endif
#if defined (FEATURE_WCDMA_TO_LTE) || defined (FEATURE_LTE_TO_WCDMA) || defined (FEATURE_WCDMA_DEDICATED_PRI_INFO)
      if(rrc_csp_int_data.curr_scan != RRC_CSP_GTOW_CC_ORDER_SCAN)
      {
        rrcmeas_send_clear_ded_pri_ind_set_owner();
      }
#endif
      next_substate = RRCCSP_CAMPED_SUIT_CELL;

      break;

    case RRC_IRAT_ABORT_IND:
      rrccsp_send_mode_change_req_to_mcm( RRC_MODE_INACTIVE);

        if(rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_REDIRECTION_SCAN)
        {
          rrc_csp_int_data.rsp_to_rr        = SEND_GTOW_REDIRECTION_ABORT_CNF;
        }
        else
        {
          rrc_csp_int_data.rsp_to_rr        = SEND_GTOW_RESEL_ABORT_CNF;
        }


      next_substate                     = RRCCSP_WT_STOP_MODE_CHANGE_CNF;
      break;

    case RRC_SERVICE_REQ:
      WRRC_MSG0_HIGH("Rcvd RRC_SVC_REQ in WT_ACTIVATION_RSP");
      rrc_state = rrc_get_state();

      if(rrc_state != RRC_STATE_DISCONNECTED)
      {
        WRRC_MSG1_ERROR("Service req in RRC state %d",rrc_state);
      }

      /* Process the Service Request */
      rrc_csp_init_data_from_service_req(&cmd_ptr->cmd.rrc_service_req);
      /* Release the established channels and start cell selection */
      next_substate = rrc_csp_release_chls_and_start_sel_on_mm_req();
      break;

    default:
      WRRC_MSG2_HIGH( "Cmd 0x%x not processed in CSP sstate %d",
                            cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);
      break;
  }
  return( next_substate );
} /* rrccsp_suit_cell_wt_activation_rsp_hdlr */


/*===========================================================================

FUNCTION        RRCCSP_ACCEPT_CELL_WT_ACTIVATION_RSP_HDLR

DESCRIPTION
                This is a handler for events received in
                RRCCSP_ACCEPT_CELL_WT_ACTIVATION_RSP substate of
                the Cell Selection Procedure.
                Depending on the event, it further calls a function for
                processing the event in this CSP substate.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_accept_cell_wt_activation_rsp_hdlr( rrc_cmd_type *cmd_ptr )
{
  rrc_csp_substate_e_type   next_substate;
  rrc_state_e_type          rrc_state;

  next_substate = rrc_csp_substate;

  switch( cmd_ptr->cmd_hdr.cmd_id )
  {
    case RRC_ACTIVATION_RSP:
      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );

      rrc_csp_send_mm_cmd(RRC_SERVICE_IND,
                          rrc_csp_int_data.curr_service_status,
                          &rrc_csp_int_data.curr_sel_plmn,
                          &rrc_csp_int_data.curr_acq_entry);

      /* In case of G-to-W re-selection, Notify location information change to the 
       * registered callback if UE is not in Cell_DCH State */
      if (rrc_get_state() != RRC_STATE_CELL_DCH && rrc_home_zone_ind_cb_func)
      {
        rrc_trigger_home_zone_ind();
      }

      /* Notify the serving cell id change indication to the registered callbacks */
      rrc_notify_cell_id_change();

      /* Updating the EcIo/RSSI to CM */
      rrctmr_stop_timer(RRCTMR_RSSI_BER_TIMER);
      rrc_rssi_ber_timeout_handler();

#ifdef FEATURE_GAN
      #error code not present
#endif

      if(rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_REDIRECTION_SCAN)
      {
        WRRC_MSG0_HIGH("GtoW Redirection: stopping the GtoW redirection timer");
        rrctmr_stop_timer(RRCTMR_GTOW_REDIRECTION_WAIT_TIMER);

       rrctmr_stop_timer(RRCTMR_GTOW_REDIRECTION_LFS_TIMER);

        /* Reset the timer flag */
        rrc_csp_int_data.gtow_redirection_timer_expired = TRUE;

        rrc_csp_int_data.skip_repeat_scan_for_redir = FALSE;
        /* Reset the LFS scan retry flag */
        rrc_csp_int_data.gtow_redir_retry_lfs_scan = FALSE;

        /* Reset current_scan */
        rrc_csp_int_data.curr_scan = RRC_CSP_CELL_SELECTION_SCAN;

#ifdef FEATURE_WCDMA_TO_LTE
        if(rrc_csp_int_data.interrat_type  == RRC_CSP_INTERRAT_LTE)
        {
#ifdef FEATURE_WCDMA_CSFB_CALL_OPT
          if(rrc_csfb_reset_while_waiting_for_act_rsp == TRUE)
          {
            rrc_csfb_reset_while_waiting_for_act_rsp = FALSE;
            next_substate = rrc_csp_start_sel_out_of_service_area_in_idle_state();
            break;
          }
#endif
          /* Set the flag to not include pre-redirection info in connection request message */
          WRRC_MSG0_HIGH("LTOW Redirection:set flag to not include pre-redir info in conn request msg");
          rrc_csp_int_data.exclude_preredir_info_in_conn_req_msg = TRUE;
        }
#endif
      }

      if(rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_CELL_RESELECTION_SCAN)
      {
        WRRC_MSG0_HIGH("GtoW Resel: reset the scan");

        /* Reset current_scan */
        rrc_csp_int_data.curr_scan = RRC_CSP_CELL_SELECTION_SCAN;
      }

#ifdef FEATURE_DUAL_SIM
      /* Release the lock for interrat procedures except for GTOW CCO*/
      if(rrc_csp_int_data.curr_scan != RRC_CSP_GTOW_CC_ORDER_SCAN)
      {
        rrc_stop_lock_wait_timer();

#ifdef FEATURE_3GPP_CSFB
        if(!rrc_csfb_call_status)
        {
          rrc_release_lock();
        }
        else
        {
          WRRC_MSG0_HIGH("DSIM: CSFB call status is set. Do not release the lock");
        }
#else
        rrc_release_lock();
#endif
      }
     
#endif
#if defined (FEATURE_WCDMA_TO_LTE) || defined (FEATURE_LTE_TO_WCDMA)|| defined (FEATURE_WCDMA_DEDICATED_PRI_INFO)
      if(rrc_csp_int_data.curr_scan != RRC_CSP_GTOW_CC_ORDER_SCAN)
      {
        rrcmeas_send_clear_ded_pri_ind_set_owner();
      }
#endif
      next_substate = RRCCSP_CAMPED_ACCEPT_CELL;

      break;

    case RRC_IRAT_ABORT_IND:
      rrccsp_send_mode_change_req_to_mcm( RRC_MODE_INACTIVE);

        if(rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_REDIRECTION_SCAN)
        {
          rrc_csp_int_data.rsp_to_rr        = SEND_GTOW_REDIRECTION_ABORT_CNF;
        }
        else
        {
          rrc_csp_int_data.rsp_to_rr        = SEND_GTOW_RESEL_ABORT_CNF;
        }


      next_substate                     = RRCCSP_WT_STOP_MODE_CHANGE_CNF;
      break;

    case RRC_SERVICE_REQ:
      WRRC_MSG0_HIGH("Rcvd RRC_SVC_REQ in WT_ACTIVATION_RSP");
      rrc_state = rrc_get_state();

      if(rrc_state != RRC_STATE_DISCONNECTED)
      {
        WRRC_MSG1_ERROR("Service req in RRC state %d",rrc_state);
      }

      /* Process the Service Request */
      rrc_csp_init_data_from_service_req(&cmd_ptr->cmd.rrc_service_req);
      /* Release the established channels and start cell selection */
      next_substate = rrc_csp_release_chls_and_start_sel_on_mm_req();
      break;

    default:
      WRRC_MSG2_HIGH( "Cmd 0x%x not processed in CSP sstate %d",
                            cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);
      break;
  }
  return( next_substate );
} /* rrccsp_accept_cell_wt_activation_rsp_hdlr */


#endif

/*===========================================================================

FUNCTION        rrccsp_cell_sel_wait_handover_acq_acq

DESCRIPTION     This function handles the ACQ Confirm event from L1 when CSP
                has been waiting on that event.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_cell_sel_wait_handover_acq_acq( rrc_cmd_type *cmd_ptr )
{
  rrc_csp_substate_e_type  next_substate;
  rrc_cmd_type *csp_out_cmd_ptr;
  rrc_cmd_type *meas_cmd_ptr;

  next_substate = RRCCSP_NO_CELL_SELECTED;

  if((csp_out_cmd_ptr = rrc_get_int_cmd_buf()) != NULL)
  {
    /* Check if Acquisition succeeded */
    if(cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.status == TRUE)
    {

      /* First check that there is no discrepency between frequency sent to L1 and what
       * it acquired on. It is not so bad - only that L1 decided on this freq on its own.
       */
      if(cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.freq != rrc_csp_int_data.curr_acq_entry.freq)
      {
        WRRC_MSG2_HIGH("Freq %d sent to L1, freq %d acquired by L1",
             rrc_csp_int_data.curr_acq_entry.freq, cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.freq);
      }

      /* Update the frequency anyway */
      rrc_csp_int_data.curr_acq_entry.freq = cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.freq;

      /* Important: The Scrambling code found on this freq. may be different that what was
       * stored in Acq. DB last. Update it in Internal data.
       */
      rrc_csp_int_data.curr_acq_entry.scr_code = cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.scr_code;

      /* Now update the serving PCCPCH data */
      rrc_csp_int_data.serving_pccpch_parms.scr_code =
                                cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.scr_code;
      rrc_csp_int_data.serving_pccpch_parms.tx_div_ind =
                                cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.sttd;

      /* Set the state to RRCCSP_CAMPED_SUIT_CELL as we will now go directly to DCH */
      next_substate = RRCCSP_CAMPED_SUIT_CELL;

    }
    else  /* Acquisition did not succeed */
    {
      WRRC_MSG2_ERROR("ACQ failed - freq %d, scr_code %d", rrc_csp_int_data.curr_acq_entry.freq,
                                              rrc_csp_int_data.curr_acq_entry.scr_code
                                              );
    } /* Acquisition did not succeed */

    /* Now fill in the information to be sent to Handover procedure */
    csp_out_cmd_ptr->cmd_hdr.cmd_id = RRC_CSP_ACQ_CNF;
    if(cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.status)
    {
      csp_out_cmd_ptr->cmd.rrc_csp_acq_cnf.acq_status = SUCCESS;
    }
    else
    {
      csp_out_cmd_ptr->cmd.rrc_csp_acq_cnf.acq_status = FAILURE;
    }

    /* Send the Internal RRC Command */
    WRRC_MSG1_HIGH("Sending RRC cmd 0x%x", csp_out_cmd_ptr->cmd_hdr.cmd_id);
    rrc_put_int_cmd( csp_out_cmd_ptr );
  }
  if(cmd_ptr->cmd.rrc_llc_cnf.cnf.acq_cnf.status == TRUE)
  {
    /* Send a Cell measurement Req to L1 */
    WRRC_MSG0_HIGH("Sending cell meas request to Meas proc");
    if((meas_cmd_ptr = rrc_get_int_cmd_buf()) != NULL)
    {
      meas_cmd_ptr->cmd_hdr.cmd_id = RRC_CELL_SELECTED_MEAS_REQ;
      meas_cmd_ptr->cmd.cell_selected_meas_req.gtow_ho_active = TRUE;
      rrc_put_int_cmd(meas_cmd_ptr);
    }
  }

  return( next_substate );
} /* rrccsp_cell_sel_wait_handover_acq_acq */


/*===========================================================================

FUNCTION        RRCCSP_CELL_SEL_WT_HANDOVER_ACQ_HDLR

DESCRIPTION
                This is a handler for events received in
                RRCCSP_CELL_SEL_WT_HANDOVER_ACQ substate of
                the Cell Selection Procedure.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_cell_sel_wt_handover_acq_hdlr( rrc_cmd_type *cmd_ptr )
{
  rrc_csp_substate_e_type   next_substate;

  next_substate = RRCCSP_CELL_SEL_WT_HANDOVER_ACQ;

  switch( cmd_ptr->cmd_hdr.cmd_id )
  {
    case RRC_LLC_CMD_CNF:
      MSG_LOW( "Cmd 0x%x recvd, CSP sstate %d",
                           cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
      switch(cmd_ptr->cmd.rrc_llc_cnf.ll_cnf)
      {
        case RRC_LL_CPHY_ACQ_CNF:
          MSG_MED("L1 cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd.rrc_llc_cnf.ll_cnf, rrc_csp_substate, 0);
          next_substate = rrccsp_cell_sel_wait_handover_acq_acq( cmd_ptr );
          break;

        default:
          WRRC_MSG2_HIGH("Unexpected L1 cmd 0x%x, CSP sstate %d",
                         cmd_ptr->cmd.rrc_llc_cnf.ll_cnf, rrc_csp_substate);
          break;
      }
      break;

    default:
      WRRC_MSG2_HIGH( "Cmd 0x%x not processed in CSP sstate %d",
                          cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);
      break;
  }

  return( next_substate );

}


/*===========================================================================

FUNCTION          RRCCSP_UPDATE_PLMN_INFO_FOR_GTOW_HANDOVER

DESCRIPTION       This function updates the CSP internal data with the PLMN Id
                  and PLMN type information. It further updates CCM camping
          information.

DEPENDENCIES
                  None

RETURN VALUE
                  None

SIDE EFFECTS
                  None

===========================================================================*/
void rrccsp_update_plmn_info_for_gtow_handover
(
  /* Cell selection mode */
  rrc_activation_rsp_type *rrc_activation
)
{
  rrc_csp_int_data.curr_req_plmn.plmn_id      = rrc_activation->plmn_id;
  rrc_csp_int_data.last_mm_primitive          = RRC_CSP_SRVC_CNF_WITH_SRVC_SENT;
  rrc_csp_int_data.curr_acq_entry.plmn_id     = rrc_activation->plmn_id;
  rrc_csp_int_data.curr_acq_entry.status_mask = 0;

#ifdef FEATURE_WCDMA_MULTIBAND
  rrc_csp_int_data.curr_acq_entry.band_class  = rrc_get_frequency_band(
                                                  rrc_csp_int_data.curr_acq_entry.freq,
                                                  rrc_csp_int_data.curr_acq_entry.plmn_id);
  WRRC_MSG2_HIGH("Setting band_class %d for freq %d",
             rrc_csp_int_data.curr_acq_entry.band_class,
             rrc_csp_int_data.curr_acq_entry.freq);

#else
   rrc_csp_int_data.curr_acq_entry.band_class = RRC_CSP_PCS_BAND;
   WRRC_MSG2_HIGH("Setting band_class %d for freq %d",
              rrc_csp_int_data.curr_acq_entry.band_class,
              rrc_csp_int_data.curr_acq_entry.freq);
#endif

  rrc_csp_int_data.curr_acq_entry.is_valid_nw_sharing = FALSE;

#ifdef FEATURE_FEMTO_CSG
  rrc_csp_int_data.curr_acq_entry.csg_id = SYS_CSG_ID_INVALID;
#endif

  /* Store the Current Acq. entry in Acq. database. */
  (void)rrc_csp_add_acq_entry(&rrc_csp_int_data.curr_acq_entry);

  rrc_csp_int_data.curr_cell_access_status = MM_AS_ACCESS_ALL_CALLS;
  WRRC_MSG1_HIGH(" GTOW HO: Setting curr_cell_access_status to %d",rrc_csp_int_data.curr_cell_access_status);

  rrc_csp_int_data.curr_cs_cell_access = MM_AS_ACCESS_ALL_CALLS;
  rrc_csp_int_data.curr_ps_cell_access = MM_AS_ACCESS_ALL_CALLS;
  rrc_csp_int_data.is_dsac_valid = TRUE;
  WRRC_MSG2_HIGH(" GTOW HO: Setting curr_cs_cell_access to %d, curr_ps_cell_access: %d",
                                                                         rrc_csp_int_data.curr_cs_cell_access,
                                                                         rrc_csp_int_data.curr_ps_cell_access);

  /* Update CCM now */
  rrc_ccm_update_for_gtow_handover(&rrc_csp_int_data.curr_acq_entry);

} /* rrccsp_update_plmn_info_for_gtow_handover */


/*===========================================================================

FUNCTION        RRCCSP_WT_LOWER_LAYER_DEACT_CNF_HDLR

DESCRIPTION
                This is a handler for events received in
                RRCCSP_WT_LOWER_LAYER_DEACT_CNF substate of
                the Cell Selection Procedure.

DEPENDENCIES
                None

RETURN VALUE
                Next substate of RRC Cell Selection Procedure.

SIDE EFFECTS
                None

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_wt_lower_layer_deact_cnf_hdlr( rrc_cmd_type *cmd_ptr )
{
  rrc_csp_substate_e_type   next_substate = rrc_csp_substate;

  #if defined(FEATURE_WCDMA_TO_TDSCDMA) && defined(FEATURE_TDSCDMA_TO_WCDMA)
  if((rrc_rr_cmd_e_type)cmd_ptr->cmd_hdr.cmd_id == RR_RRC_STOP_GSM_CNF)
  {
      WRRC_MSG0_HIGH("Received STOP_CNF from GSM. Sending STOP_REQ to TDS");
      rrccsp_send_tdsrrc_rrc_stop_tds_req(POWER_OFF);
  }
  else if((rrc_tdsrrc_cmd_e_type)cmd_ptr->cmd_hdr.cmd_id == TDSRRC_RRC_STOP_TDS_CNF)
  {
      rrccsp_process_lower_layer_deact_cnf();
      next_substate = RRCCSP_NO_CELL_SELECTED;
  }
  #else
  if((rrc_rr_cmd_e_type)cmd_ptr->cmd_hdr.cmd_id == RR_RRC_STOP_GSM_CNF)
  {
      rrccsp_process_lower_layer_deact_cnf();
      next_substate = RRCCSP_NO_CELL_SELECTED;
  }
  #endif
  else
  {
   switch( cmd_ptr->cmd_hdr.cmd_id )
   {
    case RRC_LOWER_LAYER_DEACT_CNF:
      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
#ifdef FEATURE_GAN_3G_ROVE_OUT_ONLY
      #error code not present
#endif
      {
        if(rrc_check_gsm_bands_supported())
        {
          rrccsp_send_rr_rrc_stop_gsm_req(POWER_OFF);
        }
        else
        {
          rrccsp_process_lower_layer_deact_cnf();
          next_substate = RRCCSP_NO_CELL_SELECTED;
        }
      }
      break;
/*lint -e408*/

    default:
      WRRC_MSG2_HIGH( "Cmd 0x%x not processed in CSP sstate %d",
                          cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);
      break;
   }
  }
  return( next_substate );

} /* rrccsp_wt_lower_layer_deact_cnf_hdlr */


/*===========================================================================

FUNCTION          RRCCSP_CHECK_AND_START_PLMN_LIST_FULL_FREQ_SCAN_TIMER

DESCRIPTION       CSP uses this function to start the PLMN full scan timer.
                  As long as the timer is active, no full scans are done during
                  2G->3G and 3G->3G PLMN searches. 
                  This timer is started when PLMN full (raw/fine) scan search 
                  completes (in background or in foreground). This timer is never stopped. 
                  Additional check has been added for the NV GCF flag. If this flag 
                  is set then the timer is not started. 

DEPENDENCIES      NONE

RETURN VALUE      NONE

SIDE EFFECTS      NONE

===========================================================================*/
void rrccsp_check_and_start_plmn_list_full_freq_scan_timer()
{
    if((((rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN) ||
         (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)) && 
       ((rrc_csp_int_data.service_search_bgnd == SYS_SERVICE_SEARCH_BACKGROUND_AUTOMATIC)
        || (rrc_csp_int_data.service_search_bgnd == SYS_SERVICE_SEARCH_BACKGROUND_MANUAL)
        ||(rrc_csp_int_data.bplmn_scan_scope == SYS_SCAN_SCOPE_ACQ_DB)
        ||(rrc_csp_int_data.service_search_bgnd == SYS_SERVICE_SEARCH_PRIORITY_PLMN)))
          /* The new search type is for a customer requirement where if the UE is camped on HPLMN,
           * NAS has to periodically trigger Automatic search(SYS_SERVICE_SEARCH_PRIORITY_PLMN) for 
           * searching another customer's PLMN*/
#ifdef FEATURE_FEMTO_CSG
        || (rrccsp_asf_actively_in_prog())
        || ((rrc_csp_int_data.service_search_bgnd == SYS_SERVICE_SEARCH_CSG) &&
             ((rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN) ||
              (rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_MANUAL_SCAN)))
#endif
      )
    {
      WRRC_MSG0_HIGH("SSB: Don't need to start the Full Scan Tmr");
      return;
    }

  if(((rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN) ||
         (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)))
  {
    if(rrc_csp_int_data.plmn_list_freq_scan_needed)
    {
      /* If GCF flag is NOT set only then 15 mins NO BPLMN FULL SCAN timer should be 
       * started. 
       */
      if(!nv_gcf_test_flag)
      {
        WRRC_MSG0_HIGH("BPLMN: Starting FreqScan timer");
        rrctmr_start_timer( RRCTMR_BPLMN_FREQ_SCAN_TIMER, (unsigned long) wcdma_rrc_bplmn_freq_scan_timer_nv );
        rrc_csp_int_data.plmn_list_freq_scan_needed = FALSE;
      }
      /* GCF flag is set, so 15mins timer should NOT be started */
      else
      {
        WRRC_MSG0_HIGH("BPLMN: NOT Starting FreqScan timer as GCF flag is ON");
      }
    }
    else
    {
      WRRC_MSG0_HIGH("BPLMN Full Freq Scan Tmr already active. NOT restarting.");
    }
  }

  else if(((rrc_csp_int_data.curr_scan == RRC_CSP_PLMN_LIST_SCAN) ||
           (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN) ||
           (rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_MANUAL_SCAN))
         )
  {
    if(rrc_csp_int_data.manual_plmn_list_freq_scan_needed)
    {
      WRRC_MSG0_HIGH("BPLMN: Starting Manual PLMN FreqScan timer");
      rrctmr_start_timer( RRCTMR_MANUAL_PLMN_FREQ_SCAN_TIMER, RRCTMR_MANUAL_PLMN_FREQ_SCAN_TIMER_IN_MS );
      rrc_csp_int_data.manual_plmn_list_freq_scan_needed = FALSE;
    }
    else
    {
       WRRC_MSG0_HIGH("BPLMN: NOT Starting Manual PLMN FreqScan timer");
    }
  }
  else
  {
    WRRC_MSG1_ERROR("ERR: BPLMN Incorrect call to the function, curr_scan = %d", rrc_csp_int_data.curr_scan);
  }

} /* rrccsp_check_and_start_bplmn_full_freq_scan_timer */

/*===========================================================================

FUNCTION          RRCCSP_SEND_BPLMN_SEARCH_CNF_TO_RR

DESCRIPTION       This function is used by CSP to send RRC_INTERRAT_PLMN_SRCH_CNF
                  to RR when BPLMN search timer expires, or highest priority PLMN
                  is found, or all frequencies are exhausted.

DEPENDENCIES      NONE

RETURN VALUE

SIDE EFFECTS

===========================================================================*/
void
rrccsp_send_bplmn_search_cnf_to_rr( void )
{
  rrc_interrat_plmn_srch_cnf_type *interrat_plmn_srch_cnf =  rrc_malloc(sizeof(rrc_interrat_plmn_srch_cnf_type));
  uint32 i;
  rrc_plmn_identity_type nas_to_rrc_plmn_id;
  rrclog_wcdma_bplmn_scan_end_event_type bplmn_scan_end_event;
  rrclog_wcdma_bplmn_end_event_type bplmn_end_event;

  /* Stop BPLMN timer if active */
  if(!rrc_csp_int_data.bplmn_srch_tmr_expired)
  {
    rrctmr_stop_timer(RRCTMR_BPLMN_SRCH_TIMER);
    rrc_csp_int_data.bplmn_srch_tmr_expired = TRUE;
  }
  bplmn_end_event.bplmn_end_reason = RRC_BPLMN_COMPLETED;
  bplmn_scan_end_event.scan_complete = RRC_BPLMN_COMPLETED;
  if(rrc_csp_int_data.rrc_rr_plmn_srch_cnf.srch_done)
  {
    event_report_payload(EVENT_WCDMA_BPLMN_END, sizeof(bplmn_end_event),
                    (void *)&bplmn_end_event);
  }
  else
  {
  event_report_payload(EVENT_WCDMA_BPLMN_SCAN_END, sizeof(bplmn_scan_end_event),
                 (void *)&bplmn_scan_end_event);
  }
  interrat_plmn_srch_cnf->srch_done   = rrc_csp_int_data.rrc_rr_plmn_srch_cnf.srch_done;
  interrat_plmn_srch_cnf->hplmn_found = rrc_csp_int_data.rrc_rr_plmn_srch_cnf.hplmn_found;

  if(rrc_csp_int_data.bplmn_fnd_list_wr_index == 0)
  {
    WRRC_MSG0_HIGH("BPLMN: no PLMNs found yet.");
  }
  else
  {
    WRRC_MSG0_HIGH("BPLMN: following PLMNs have been fnd till now");
    WRRC_MSG0_HIGH("-----------------------------");
  }

  for(i=0; i<rrc_csp_int_data.bplmn_fnd_list_wr_index; ++i)
  {
    interrat_plmn_srch_cnf->available_plmn_list.info[i].plmn_service_capability
        = rrc_csp_int_data.rrc_rr_plmn_srch_cnf.available_plmn_list.info[i].plmn_service_capability;
    interrat_plmn_srch_cnf->available_plmn_list.info[i].plmn
        = rrc_csp_int_data.rrc_rr_plmn_srch_cnf.available_plmn_list.info[i].plmn;
#ifdef FEATURE_FEMTO_CSG
    interrat_plmn_srch_cnf->available_plmn_list.info[i].csg_info.csg_id
        = rrc_csp_int_data.rrc_rr_plmn_srch_cnf.available_plmn_list.info[i].csg_info.csg_id;

    interrat_plmn_srch_cnf->available_plmn_list.info[i].csg_info.hybrid_cell
        = rrc_csp_int_data.rrc_rr_plmn_srch_cnf.available_plmn_list.info[i].csg_info.hybrid_cell;

    WRRC_MSG2_HIGH("CSG: CSG ID in resp %d, is_hybrid : %d",interrat_plmn_srch_cnf->available_plmn_list.info[i].csg_info.csg_id,interrat_plmn_srch_cnf->available_plmn_list.info[i].csg_info.hybrid_cell);
#endif

    interrat_plmn_srch_cnf->available_plmn_list.info[i].rat
        = rrc_csp_int_data.rrc_rr_plmn_srch_cnf.available_plmn_list.info[i].rat;
    interrat_plmn_srch_cnf->available_plmn_list.info[i].signal_quality
        = rrc_csp_int_data.rrc_rr_plmn_srch_cnf.available_plmn_list.info[i].signal_quality;
    WRRC_MSG0_HIGH("signal strength >= -95db is considered as SYS_SIGNAL_QUALITY_HIGH");        
    interrat_plmn_srch_cnf->available_plmn_list.info[i].signal_strength
        = rrc_csp_int_data.rrc_rr_plmn_srch_cnf.available_plmn_list.info[i].signal_strength;
    interrat_plmn_srch_cnf->available_plmn_list.info[i].list_category = SYS_DETAILED_PLMN_LIST_CATEGORY_OTHER;
    interrat_plmn_srch_cnf->available_plmn_list.info[i].plmn_forbidden = FALSE;
    nas_to_rrc_plmn_id = mmumts_convert_nas_plmn_id_to_rrc_plmn_id(interrat_plmn_srch_cnf->available_plmn_list.info[i].plmn);

    WRRC_MSG2_HIGH("BPLMN: plmns in list PLMN %d-%d", RRC_CSP_GET_INT_MCC(nas_to_rrc_plmn_id),
                                                RRC_CSP_GET_INT_MNC(nas_to_rrc_plmn_id));
  }

  interrat_plmn_srch_cnf->available_plmn_list.length = rrc_csp_int_data.bplmn_fnd_list_wr_index;

  WRRC_MSG0_HIGH("BPLMN: Sending Srch Cnf to RR");
  rr_send_rrc_message_to_rr_internal((void *)(interrat_plmn_srch_cnf), RRC_INTERRAT_PLMN_SRCH_CNF,
                                    sizeof(rrc_interrat_plmn_srch_cnf_type));
  rrc_free(interrat_plmn_srch_cnf);

  if(rrc_csp_int_data.rrc_rr_plmn_srch_cnf.srch_done)
  {
    rrc_csp_int_data.bplmn_new_srch = TRUE;

    if(!rrc_csp_int_data.rrc_rr_plmn_srch_cnf.hplmn_found)
    {
      rrccsp_check_and_start_plmn_list_full_freq_scan_timer();
    }

    /* Invalidate entities in RRC CSP Internal data structure */
    rrc_csp_init_int_data();
  }
  rrc_csp_int_data.bplmn_srch_cnf = TRUE;
}

/*===========================================================================

FUNCTION          RRCCSP_SEND_BPLMN_ABORT_CNF_TO_RR

DESCRIPTION       This function is used by CSP to send
                  RRC_INTERRAT_PLMN_SRCH_ABORT_CNF
                  to RR when CSP receives RRC_INTERRAT_PLMN_SRCH_ABORT_REQ
                  from RR (via MCM)

DEPENDENCIES      NONE

RETURN VALUE

SIDE EFFECTS

===========================================================================*/
void
rrccsp_send_bplmn_abort_cnf_to_rr( void )
{
  rrc_interrat_plmn_srch_abort_cnf_type interrat_plmn_srch_abort_cnf;
  rrclog_wcdma_bplmn_scan_end_event_type bplmn_scan_end_event;
  /* Stop BPLMN timer if active */
  if(!rrc_csp_int_data.bplmn_srch_tmr_expired)
  {
    rrctmr_stop_timer(RRCTMR_BPLMN_SRCH_TIMER);
    rrc_csp_int_data.bplmn_srch_tmr_expired = TRUE;
  }

  //EVENT: Event_BPLMN_Scan_End_req G2W
  bplmn_scan_end_event.scan_complete = RRC_BPLMN_ABORTED; /*TBD: incomplete,complete*/
  event_report_payload(EVENT_WCDMA_BPLMN_SCAN_END, sizeof(bplmn_scan_end_event),
                 (void *)&bplmn_scan_end_event);

  WRRC_MSG0_HIGH("BPLMN: Sending Abort Cnf to RR");
  rr_send_rrc_message_to_rr_internal((void *)(&interrat_plmn_srch_abort_cnf), RRC_INTERRAT_PLMN_SRCH_ABORT_CNF,
                                     sizeof(rrc_interrat_plmn_srch_abort_cnf_type));

  rrc_csp_init_int_data();
}

/*===========================================================================

FUNCTION          RRCCSP_HANDLE_FREQ_REDIRECT_WAIT_TIMER_EXPIRY

DESCRIPTION       This function handles expiry of wait timer started due to
                  inter frequency redirection request received from RCE.
                  Till the expiry of the wait timer, RRC does not allow
                  cell selections/reselections to the last camped frequency.

                  If timer expires when redirection is in progress, this
                  function determines if UE should continue camping on the
                  current frequency which would be the case if cell selection
                  is being attempted on the redirected frequency for the first time;
                  or UE should go to pending substate and wait for the appropriate
                  confirmation and on receiving the confirmation start acquisition
                  on the last camped frequency.

DEPENDENCIES      NONE

RETURN VALUE
                  CSP substate

SIDE EFFECTS

===========================================================================*/
rrc_csp_substate_e_type
rrccsp_handle_freq_redirect_wait_timer_expiry(rrc_csp_substate_e_type curr_substate)
{
  rrc_csp_substate_e_type next_substate = curr_substate;

  rrc_csp_int_data.start_acq_on_last_camped_freq = TRUE;

  /* Timer for last camped freq expired when "first" acquisition attempt
   * on redirected frequency was in progress. Continue acquisition.
   */
  if((rrc_csp_int_data.curr_acq_entry.freq == rrc_csp_int_data.redirected_freq)
       && (rrc_csp_int_data.first_acq_on_redirected_freq == TRUE))
  {
    WRRC_MSG1_HIGH("Wt tmr exprd when first acq on redirected freq %d was in progress",
                                         rrc_csp_int_data.curr_acq_entry.freq);
  }
  /* Acq attempt was not the first on redirected frequency or acq was not on the
   * redirected freq then abort current process and attempt acq on last camped freq.
   */
  else
  {
    WRRC_MSG1_HIGH("Wt tmr expd for last camped freq %d. Go to pending and start acq on it",
                                                          rrc_csp_int_data.last_camped_freq);
    /*wait timer expired in the middle of camping to the redirected cell. So postpone camping back 
      to last camped cell till this camping is over */
    if((rrc_csp_int_data.freq_redirect_wait_time == RRC_MAX_NO_ABORT_TIME) &&
       (rrc_csp_int_data.curr_acq_entry.freq == rrc_csp_int_data.redirected_freq) &&
       (curr_substate != RRCCSP_CELL_SEL_WT_ACQ) &&
       (curr_substate != RRCCSP_CELL_SEL_WT_FREQ_SCAN_CNF))
    {
      WRRC_MSG1_HIGH("Inter-Freq Redirection: Ignoring %d s wait timer. As we are in final stages of camping",RRC_MAX_NO_ABORT_TIME);
      return curr_substate;
    }

    switch(curr_substate)
    {
      case RRCCSP_CELL_SEL_WT_ACQ:
        next_substate = RRCCSP_CELL_SEL_WT_ACQ_PENDING;
        break;

      case RRCCSP_CELL_SEL_WT_FREQ_SCAN_CNF:
        next_substate = RRCCSP_CELL_SEL_WT_FREQ_SCAN_CNF_PENDING;
        break;

      case RRCCSP_CELL_SEL_WT_SIB:
        next_substate = RRCCSP_CELL_SEL_WT_SIB_PENDING;
        break;

      case RRCCSP_SUIT_CELL_SEL_WT_SERV_S:
        next_substate = RRCCSP_SUIT_CELL_SEL_WT_SERV_S_PENDING;
        break;

      case RRCCSP_SUIT_CELL_SEL_WT_CAMP:
        next_substate = RRCCSP_SUIT_CELL_SEL_WT_CAMP_PENDING;
        break;

      case RRCCSP_ACCEPT_CELL_SEL_WT_S:
        next_substate = RRCCSP_ACCEPT_CELL_SEL_WT_S_PENDING;
        break;

      case RRCCSP_ACCEPT_CELL_SEL_WT_CAMP:
        next_substate = RRCCSP_ACCEPT_CELL_SEL_WT_CAMP_PENDING;
        break;

      default:
        WRRC_MSG1_ERROR("Switch case for substate %d, not handled!", curr_substate);
        break;
    }
  }
  return( next_substate );
} /* rrccsp_handle_freq_redirect_wait_timer_expiry */


/*===========================================================================

FUNCTION          RRCCSP_SEND_RCE_REDIRECT_CNF

DESCRIPTION       This function send REDIRECT_CNF to RCE with appropriate
                  cause for successful or unsuccessful redirection.
                  The wait timer is stopped only in this function (if it
                  was active).

DEPENDENCIES      NONE

RETURN VALUE
                  NONE

SIDE EFFECTS

===========================================================================*/
void
rrccsp_send_rce_redirect_cnf(rrc_redirect_status_e_type redirect_status,
                             rrc_redirect_cause_e_type  redirect_cause)
{
  rrc_cmd_type  *csp_out_cmd_ptr;
/*Here we dont want to print WTOW event when there is WTOG redirection reject from G*/
  if((redirect_status == RRC_REDIRECT_FAILURE) &&
     !((redirect_cause == RRC_REDIRECT_GSM_FAILURE) || (redirect_cause == RRC_REDIRECT_RESUME_FAILURE)))
  {

      rrclog_wcdma_to_wcdma_redir_end_event_type wtow_redirct_event;
      wtow_redirct_event.status = WTOW_FAILURE;
      event_report_payload(EVENT_WCDMA_TO_WCDMA_REDIRECTION_END, sizeof(wtow_redirct_event),
                 (void *)&wtow_redirct_event);

  }
  if(redirect_status == RRC_REDIRECT_SUCCESS)
  {
    rrclog_wcdma_to_wcdma_redir_end_event_type wtow_redirct_event;
    wtow_redirct_event.status = WTOW_SUCCESS;
    event_report_payload(EVENT_WCDMA_TO_WCDMA_REDIRECTION_END, sizeof(wtow_redirct_event),
                 (void *)&wtow_redirct_event);
  }
  /* Stop the wait timer when sending RRC_REDIRECT_CNF to RCE, since we
   * are not allowed to run multiple wait timers and no inter-frequency
   * cell reselection can happen when RRC state is CONNECTING.
   */
  if(rrc_csp_int_data.curr_scan == RRC_CSP_INTER_FREQ_REDIRECTION_SCAN)
  {
    rrc_csp_cleanup_inter_freq_redirection_state();
  }

  if((csp_out_cmd_ptr = rrc_get_int_cmd_buf()) != NULL)
  {
    /* Populate the cmd data */
    csp_out_cmd_ptr->cmd_hdr.cmd_id          = RRC_REDIRECT_CNF;
    csp_out_cmd_ptr->cmd.redirect_cnf.status = redirect_status;
    csp_out_cmd_ptr->cmd.redirect_cnf.cause  = redirect_cause;

    /* Send the Internal cmd to RRC */
    rrc_put_int_cmd( csp_out_cmd_ptr );
  }
} /* rrccsp_send_rce_redirect_cnf */


/*===========================================================================

FUNCTION          RRCCSP_VALIDATE_REDIRECTION_REQ

DESCRIPTION       This function checks whether inter frequency redirection
                  or inter-RAT redirection request received by CSP has correct
                  arguments and that the request has been received in correct
                  RRC state (which is connecting).

                  Additionally, this function sends REDIRECT_CNF to RCE with
                  failure if redirection is not supported or if any of the above
                  checks fail.


DEPENDENCIES      NONE

RETURN VALUE
                  TRUE:  Implies start acq on redirected freq.
                  FALSE: Implies ignore redirection request (because in this
                         case redirect confirm has already been sent inside this
                         function).

SIDE EFFECTS

===========================================================================*/
boolean
rrccsp_validate_redirection_req( rrc_cmd_type *cmd_ptr )
{
  rrc_state_e_type rrc_curr_state = rrc_get_state();

  /* Inter frequency redirection is received */
  if(cmd_ptr->cmd.redirect_req.choice == RRC_FREQ_REDIRECTION)
  {
    /* Inter frequency redirection received by CSP */

    if((rrc_csp_int_data.curr_acq_entry.freq == cmd_ptr->cmd.redirect_req.u.freq.uarfcn_DL)
       || (rrc_curr_state != RRC_STATE_CONNECTING))
    {
      ERR("ERR: Freq Redirect Req for freq %d psc %d rcvd with incrrct data or in incrrct RRC state %d",
                                                          cmd_ptr->cmd.redirect_req.u.freq.uarfcn_DL, 
                                                          cmd_ptr->cmd.redirect_req.psc, 
                                                          rrc_curr_state);

      MSG_HIGH("wait_time = %d, Camped_freq = %d, Camped_Scr_Code = %d", 
                                                          cmd_ptr->cmd.redirect_req.wait_time, 
                                                          rrc_csp_int_data.curr_acq_entry.freq,
                                                          rrc_csp_int_data.curr_acq_entry.scr_code);

      rrccsp_send_rce_redirect_cnf(RRC_REDIRECT_FAILURE, RRC_RCE_INCOMPATIBLE);
      return (FALSE);
    }
    else
    {
      WRRC_MSG1_HIGH("Valid Inter Freq Redirection req with wt tmr %d rcvd by CSP",
                                    cmd_ptr->cmd.redirect_req.wait_time);
      return (TRUE);
    }
  }

  /* Inter RAT redirection is received */
  else if((cmd_ptr->cmd.redirect_req.choice == RRC_INTER_SYSTEM_GSM) 
#ifdef FEATURE_WCDMA_TO_LTE
           || (cmd_ptr->cmd.redirect_req.choice == RRC_INTER_SYSTEM_LTE)
#endif
         )
  {

    #ifdef FEATURE_INTERRAT_REDIRECTION_WTOG

    /* Inter RAT redirection received by CSP with incorrect data or in incorrect RRC state */
    if((rrc_curr_state != RRC_STATE_CONNECTING)
      && (rrc_curr_state != RRC_STATE_CELL_DCH) && (rrc_curr_state != RRC_STATE_CELL_FACH)
      )
    {
      ERR("ERR InterRAT Rdrct Req rcvd with wt tmr %d, RRC state %d and system %d",
                                        cmd_ptr->cmd.redirect_req.wait_time,
                                        rrc_curr_state, cmd_ptr->cmd.redirect_req.choice);

      if(cmd_ptr->cmd.redirect_req.proc_id == RRC_PROCEDURE_RCE)
      {
        rrccsp_send_rce_redirect_cnf(RRC_REDIRECT_FAILURE, RRC_RCE_INCOMPATIBLE);
      }
      return (FALSE);
    }
    /* Inter RAT redirection to GSM received by CSP with correct data */
    else
    {
      WRRC_MSG1_HIGH("iRAT Redirection Req with wt tmr %d rcvd by CSP",
                                                    cmd_ptr->cmd.redirect_req.wait_time);

      /* Abort Manual PLMN Search if it was in progress before going to GSM */
      rrccsp_cleanup_bplmn_state();

      return (TRUE);
    }

    #else

    WRRC_MSG0_HIGH("InterRAT redirection not supported. Send failure to RCE");
    if(cmd_ptr->cmd.redirect_req.proc_id == RRC_PROCEDURE_RCE)
    {
      rrccsp_send_rce_redirect_cnf(RRC_REDIRECT_FAILURE, RRC_RAT_REDIRECTION_NOT_SUPPORTED);
    }
    return (FALSE);

    #endif

  }

  /* Unsupported redirection received */
  else
  {
    WRRC_MSG1_ERROR("ERR Unsupported redirection request %d rcvd by CSP. Send failure to RCE",
                                                  cmd_ptr->cmd.redirect_req.choice);
    if(cmd_ptr->cmd.redirect_req.proc_id == RRC_PROCEDURE_RCE)
    {
      rrccsp_send_rce_redirect_cnf(RRC_REDIRECT_FAILURE, RRC_REDIRECTION_NOT_SUPPORTED);
    }
    return(FALSE);
  }
} /* rrccsp_validate_redirection_req */

/*===========================================================================

FUNCTION          RRCCSP_HANDLE_FAILURE_DURING_FREQ_REDIRECTION

DESCRIPTION       This function handles failure when inter frequency redirection
                  scan is in progress. The failure could be due to acquisition
                  failure, or cell may not be suitable/acceptable, or S-criteria
                  was not met, etc.

                  Either acquisition is attempted on next frequency or
                  REDIRECT_CNF is returned to RCE with appropriate
                  cause.

DEPENDENCIES      NONE

RETURN VALUE
                  CSP substate which can only be one of the following:
                  RRCCSP_CAMPED_SUIT_CELL, or RRCCSP_CAMPED_ACCEPT_CELL, or
                  RRCCSP_CELL_SEL_WT_ACQ.

SIDE EFFECTS

===========================================================================*/
rrc_csp_substate_e_type
rrccsp_handle_failure_during_freq_redirection()
{
  rrc_csp_substate_e_type next_substate;

  /* Since now other frequencies in ACQ DB/FULL SCAN might be attempted,
   * initialize relevant data.
   */
  if(rrc_csp_int_data.first_acq_on_redirected_freq)
  {
    rrc_csp_int_data.first_acq_on_redirected_freq = FALSE;

    /* Initialize Selection data so as to start with the correct Acq. type
     * corresponding to Requested PLMN type.
     */
    if(FAILURE == rrc_csp_init_select_data(&rrc_csp_curr_select_data.req_plmn))
    {
      WRRC_MSG0_ERROR("Failure init Select Data during Inter Freq Redirection Scan");
      rrccsp_send_rce_redirect_cnf(RRC_REDIRECT_FAILURE, RRC_FAILED_TO_CAMP);

      if(rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED)
      {
        return(next_substate = RRCCSP_CAMPED_ACCEPT_CELL);
      }
      else
      {
        return(next_substate = RRCCSP_CAMPED_SUIT_CELL);
      }
    }
  }

  /* Try acquisition on the next frequency if wait timer
   * has not expired.
   */
  if((rrc_csp_int_data.start_acq_on_last_camped_freq != TRUE)
      && (rrc_csp_int_data.curr_acq_entry.freq != rrc_csp_int_data.last_camped_freq))
  {
    WRRC_MSG1_HIGH("cell sel attempt on freq %d failed. Continue acq on next freq",
                          rrc_csp_int_data.curr_acq_entry.freq);

    next_substate = rrc_csp_continue_cell_selection();
  }

  /* Wait timer for last camped freq has already expired. Start
   * acquisition on last camped frequency.
   */
  else if((rrc_csp_int_data.start_acq_on_last_camped_freq == TRUE)
      && (rrc_csp_int_data.curr_acq_entry.freq == rrc_csp_int_data.redirected_freq))
  {
    WRRC_MSG1_HIGH("Start acq on Last Camped Freq %d", rrc_csp_int_data.last_camped_freq);
    rrc_csp_int_data.curr_acq_entry.freq = rrc_csp_int_data.last_camped_freq;

    /* Send redirected frequency to L1 for acquisition */
    rrc_csp_send_next_freq_to_l1(&rrc_csp_int_data.curr_acq_entry, RRC_CSP_ACQ_SCAN);

    /* Start waiting for Acquisition Confirmation */
    next_substate = RRCCSP_CELL_SEL_WT_ACQ;
  }

  /* Failure on last camped frequency. Return redirect failure to RCE. */
  else if((rrc_csp_int_data.start_acq_on_last_camped_freq == TRUE)
           && (rrc_csp_int_data.curr_acq_entry.freq == rrc_csp_int_data.last_camped_freq))
  {
    WRRC_MSG1_HIGH("cell sel on last camped freq %d failed. Send RRC_REDIRECT_FAILURE to RCE",
                                        rrc_csp_int_data.curr_acq_entry.freq);

    rrccsp_send_rce_redirect_cnf(RRC_REDIRECT_FAILURE, RRC_FAILED_TO_CAMP);

    if(rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED)
    {
      next_substate = RRCCSP_CAMPED_ACCEPT_CELL;
    }
    else
    {
      next_substate = RRCCSP_CAMPED_SUIT_CELL;
    }
  }

  /* Implies that one of the above conditions did not hold, which should never be
   * the case. Possible incorrect logic.
   */
  else
  {
    WRRC_MSG1_ERROR("ERR Acq on last camped freq %d but wait tmr not exprd. Send FAILURE to RCE",
                                                rrc_csp_int_data.curr_acq_entry.freq);

    rrccsp_send_rce_redirect_cnf(RRC_REDIRECT_FAILURE, RRC_FAILED_TO_CAMP);

    if(rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED)
    {
      next_substate = RRCCSP_CAMPED_ACCEPT_CELL;
    }
    else
    {
      next_substate = RRCCSP_CAMPED_SUIT_CELL;
    }
  }
  return (next_substate);
}/* rrccsp_handle_failure_during_freq_redirection */


/*===========================================================================

FUNCTION RRC_GET_CSP_SUBSTATE

DESCRIPTION
  This function returns the current substate of CSP.

DEPENDENCIES
  None

RETURN VALUE
  Current sub-state of CSP.

SIDE EFFECTS
  None

===========================================================================*/
#ifdef FEATURE_QSH_DUMP
    __attribute__((section(".uncompressible.text")))
#endif
rrc_csp_substate_e_type  rrc_get_csp_substate( void )
{
  return( rrc_csp_substate );
}

/*===========================================================================

FUNCTION RRC_CSP_GET_ASET_SCR_PN

DESCRIPTION
  This function gets the scrambling code and pn position of the best cell
  in the active set.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void rrc_csp_get_aset_scr_pn()
{
  uint16 scr_code;
  uint32 pn_pos;

  /* Get scr and pn info for the best cell in the active
   * set so that acquisition can be tried on this cell
   * when UE transitions from DCH to Idle state. 
   */
  if(rrc_csp_int_data.curr_scan == RRC_CSP_LEAVING_CONN_MODE_SCAN)
  {
    WRRC_MSG0_ERROR("We are not supposed to call the L1 API while leaving connected mode");
    return;
  }
  
  if(l1_get_best_psc_in_aset(&scr_code, &pn_pos))
  {
    rrc_csp_int_data.aset_scr_code = scr_code;
    rrc_csp_int_data.aset_pn_pos   = pn_pos;
  }
  else
  {
    WRRC_MSG1_ERROR("ERR active set is empty in L1. RRC state %d", rrc_get_state());
    rrc_csp_int_data.aset_scr_code = 8192;
  }
} /* rrc_csp_get_aset_scr_pn */


/*===========================================================================

FUNCTION          RRCCSP_WT_CHAN_CFG_CNF_HDLR

DESCRIPTION       This is a handler for events received in RRCCSP_WT_FOR_CHAN_CFG_CNF
                  substate of the Cell Selection Procedure. CSP enters this substate 
                  when resume on W succeeds and CSP sends channel configuration request
                  to LLC.
                  
                  If channel configuration succeeds then CSP goes to camped substate.
                  Else if channel configuration fails then 
                  (i) if Error Recovery Feature is defined then all channels are released
                      and cell selection is performed.
                  (ii) Else, if Error Recovery Feature is not defined UE hits an Error Fatal.
                  
DEPENDENCIES      NONE

RETURN VALUE      CSP substate
                  
SIDE EFFECTS      NONE
                  
===========================================================================*/
static  rrc_csp_substate_e_type
rrccsp_wt_chan_cfg_cnf_hdlr(rrc_cmd_type *cmd_ptr)
{  
  rrc_csp_substate_e_type next_substate;
  rrc_state_e_type        rrc_state = rrc_get_state();


  next_substate = RRCCSP_WT_FOR_CHAN_CFG_CNF;
  
  switch(cmd_ptr->cmd_hdr.cmd_id) 
  {
    case RRC_CHANNEL_CONFIG_CNF:
      /* Channel Configuration Passed */
      if(RRCLLC_CHAN_CFG_SUCCESS == cmd_ptr->cmd.chan_config_cnf.chan_cfg_status)
      {
        /* 1. When W was suspended, the cell camped status was changed to RRC_CELL_LOSS_NO_NEW_CELL.
         * 2. Since resume and channel config have been successful, change the cell camped status
         *    back to RRC_NEW_CELL_SELECTED.
         * 3. The reason for changing the cell camped status to RRC_CELL_LOSS_NO_NEW_CELL on suspending
         *    W was to take care of the race condition where during channel config, RCE receives 
         *    RRC_EST_REQ from NAS. 
         * 4. The following function also takes care of informing RCE if it was waiting for UE to camp on.
         */
        rrc_ccm_update_cell_camped_status(RRC_NEW_CELL_SELECTED);

        /* Restoring cell_id to handle the case when WTOL reselection fails and GPS is requesting for cell_id */ 
        cell_id_dch_info.cell_id = rrc_ccm_get_curr_camped_cell_id();

        if(rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED)
        {
          next_substate = RRCCSP_CAMPED_ACCEPT_CELL;
        }
        else
        {
          next_substate = RRCCSP_CAMPED_SUIT_CELL;
        }

#ifdef FEATURE_GAN
        #error code not present
#endif

#ifdef FEATURE_DUAL_SIM
        if(rrc_csp_int_data.curr_scan == RRC_CSP_UNLOCK_BY_SCAN)
        {
          rrc_send_rlc_ta_status(RLC_LTA_STOP_IND, RLC_SUCC_IND);
          rrc_csp_int_data.curr_scan = RRC_CSP_CELL_SELECTION_SCAN;
          wrm_retain_lock_for_primary();
          rrcwrm_post_pending_cmd();
        }
#endif

        /* Changing the CSP substate to WT_TRANS_CNF for the case where CELL_TRANS_CNF is sent 
           when waiting for channel config config confirm. Once channel config is handled 
           we move CSP substate such that trans cnf can be handled */
        if(!rrc_csp_int_data.cel_trans_cnf_recvd_at_llc)
        {
          if(rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED)
          {
            next_substate = RRCCSP_ACCEPT_CELL_RESELECT_WT_TRANS_CNF;
          }
          else
          {
            next_substate = RRCCSP_SUIT_CELL_RESELECT_WT_TRANS_CNF;
          }
        }

        /*check if any command is buffered and trigger the indication*/
        rrccu_post_buffered_commands();
#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
        if(rrcdata_misc_info.rrc_buffered_ota_activation_time_expired_during_lta == TRUE)
        {
          rrcdata_post_buffer_ota_after_activation_time_expiry();
        }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
      }

      /* Channel Configuration Failed. This is not a common case. Handle this case by triggering OOS.
       * LLC will send channel config failure when
       * (i)  SCCPCH setup fails in Idle Mode, Or
       * (ii) SCCPCH setup succeeds but PCCPCH setup (if it was up before suspending W) fails in 
       *      Idle/FACH/PCH states.
       * (iii) If SCCPCH setup fails in Connected Mode then instead of sending Channel Config with
       *      failure, LLC will send RRC_INITIATE_CELL_SELECTION_IND with tx to disconnected request
       *      to CSP. This is because LLC currently does not have the support to handle SCCPCH setup
       *      failure in Connected Mode.
       */
      else
      {
        WRRC_MSG0_HIGH("CSP rcvd ch cfg with failure after resume. Trigger OOS");

        /* Initialize RCE just in case it was waiting for UE to camp on,
         * e.g., RRC_EST_REQ. Abort is sent to MM by this function, if needed.
         */
        rrcrce_force_initialize(TRUE);

        if(rrc_state == RRC_STATE_DISCONNECTED)
        {
          next_substate = rrc_csp_start_sel_out_of_service_area_in_idle_state();
        }
        /* Send cell update initiate request to CU with cause OOS so that appropriate
         * timers can be started in CU. CU subsequently sends initiate cell sel indication
         * to CSP with cause OOS.
         */
        else if(   (rrc_state == RRC_STATE_CELL_FACH)
                || (rrc_state == RRC_STATE_CELL_PCH)
                || (rrc_state == RRC_STATE_URA_PCH))
        {
          next_substate = rrccsp_send_cell_update_initiate_req(RRC_REENTERED_SERVICE_AREA);
        }
        
#ifdef FEATURE_DUAL_SIM
        else if((rrc_csp_int_data.curr_scan == RRC_CSP_UNLOCK_BY_SCAN) && (rrc_state == RRC_STATE_CELL_DCH))
        {
          next_substate = rrccsp_send_cell_update_initiate_req(RRC_RADIO_LINK_FAILURE);
        }
#endif
        else
        {
          ERR_FATAL("ERR channel config resume rcvd in rrc state %d", rrc_state, 0, 0);
        }
#ifdef FEATURE_DUAL_SIM
      if(rrc_csp_int_data.curr_scan == RRC_CSP_UNLOCK_BY_SCAN)
      {
          rrc_send_rlc_ta_status(RLC_LTA_STOP_IND, RLC_FAIL_IND);
        rrc_csp_int_data.curr_scan = RRC_CSP_CELL_SELECTION_SCAN;
      }
#endif
      }
      break;

    case RRC_INITIATE_CELL_SELECTION_IND:
      WRRC_MSG0_HIGH("Init Cel Sel cmd rcvd in CSP sstate WT_FOR_CHAN_CFG_CNF");
                         
      if(cmd_ptr->cmd.initiate_cell_sel_ind.cause == RRC_TRANSITION_TO_DISCONNECTED)
      {
        WRRC_MSG2_HIGH("Rel chls & do cell sel, CSP sstate %d, scan %d",
                                          rrc_csp_substate, rrc_csp_int_data.curr_scan);

        rrc_csp_send_chan_release();
#ifdef FEATURE_DISCONNECT_ON_UNSUPPORTED_IRAT_REDIRECTION
        /*If dual mode disabled and redirection to GSM, then trigger OOS and go to idle with no servce*/
        if (cmd_ptr->cmd.initiate_cell_sel_ind.tx_to_discon_reason == RRC_TX_TO_DISCON_UNSUPPORTED_REDIRECTION)
        {
          /* First call a CCM function to indicate Cell Loss - no new cell */
          rrc_ccm_update_with_cell_loss();
          next_substate = rrccsp_rel_chls_and_go_to_idle();
        }
        else
#endif
          next_substate = rrc_csp_start_sel_leaving_conn_mode();
      }
      else
      {
        WRRC_MSG1_ERROR("ERR Cause %d for Initiate Cell Selection not handled",
                          cmd_ptr->cmd.initiate_cell_sel_ind.cause);
      }
      break;

    case RRC_SERVICE_REQ:
      if(rrc_state != RRC_STATE_DISCONNECTED)
      {
        WRRC_MSG1_ERROR("ERR Service/PLMN_LIST req in RRC state %d",rrc_state);
      }

      WRRC_MSG1_HIGH("Service/PLMN_LIST req rcvd in CSP sstate %d", rrc_csp_substate);
      rrccsp_save_req( cmd_ptr );
      next_substate = RRCCSP_WT_FOR_CHAN_CFG_CNF_PENDING;
      break;
      
    case RRC_PLMN_LIST_REQ:
      WRRC_MSG1_HIGH("Service/PLMN_LIST req rcvd in CSP sstate %d", rrc_csp_substate);
      if(rrccsp_plmn_list_req_when_resume_in_prog_is_valid(&(cmd_ptr->cmd.plmn_list_req)))
      {
        rrccsp_cleanup_bplmn_state();

        rrc_csp_int_data.bplmn_crit_sec_flag = TRUE;

        /* Set state so that BPLMN search can be started */
        rrc_csp_int_data.bplmn_nw_sel_mode = cmd_ptr->cmd.plmn_list_req.network_select_mode;

        rrc_csp_int_data.service_search_bgnd = cmd_ptr->cmd.plmn_list_req.service_search;
        WRRC_MSG1_HIGH("SSB: svc_srch_bgnd rcvd from NAS = %d", rrc_csp_int_data.service_search_bgnd);

        /* If Automatic BPLMN search is requested then reject it in this CSP substate,
         * since anyways another Automatic BPLMN search request will be received by CSP in
         * 10s.
         */
        if(rrc_csp_int_data.bplmn_nw_sel_mode == SYS_NETWORK_SELECTION_MODE_AUTOMATIC)
        {
          WRRC_MSG1_HIGH("WTOW: Rejecting APLS req in CSP sst %d", next_substate);
          rrc_csp_bplmn_send_mm_plmn_list_cnf_cmd(WTOW_SEARCH_ABORT,cmd_ptr->cmd.plmn_list_req.trans_id);
          rrc_csp_int_data.bplmn_crit_sec_flag = FALSE;
        }
        /* Handle Manual Search in this CSP substate */
        else
        {
#ifdef FEATURE_DUAL_SIM
          /*If G is in data call reject manual PLMN search in this substate*/
          if(WRM_G2W_TA_MODE_ACTIVE() && (cmd_ptr->cmd.plmn_list_req.network_select_mode == SYS_NETWORK_SELECTION_MODE_AUTOMATIC))
          {
            rrc_csp_send_mm_plmn_list_cnf_as_aborted(cmd_ptr->cmd.plmn_list_req.trans_id);
            return next_substate;
          }
#endif
          rrccsp_update_plmn_list_req_data(&cmd_ptr->cmd.plmn_list_req);
          rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_START, FALSE, FALSE);
#ifdef FEATURE_FEMTO_CSG
          rrccsp_csg_set_fp_info();
#endif

          WRRC_MSG2_HIGH("WTOW: dual_mode_enabled = %d,wcdma_mode_enabled = %d in PLMN_LIST_REQ", 
                                  rrc_csp_int_data.bplmn_dual_mode_enabled,rrc_csp_int_data.bplmn_wcdma_mode_enabled);

          rrccsp_generate_bplmn_rat_srch_order_update_curr_srch_rat(SYS_NETWORK_SELECTION_MODE_MANUAL);
          rrc_csp_int_data.bplmn_crit_sec_flag = FALSE;

          if(rrc_csp_int_data.bplmn_wcdma_mode_enabled)
          {
            rrccsp_update_wtow_manual_bplmn_list_with_rplmn(rrc_csp_int_data.curr_acq_entry.plmn_id,
                                                            rrc_csp_int_data.curr_acq_entry.cell_id);
          }
        }
      }
      break;

    case RRC_BPLMN_GUARD_SRCH_TIMER_EXPIRED_IND:
      rrccsp_cleanup_bplmn_state();
      break;

    case RRC_BPLMN_SEARCH_ABORT_REQ:
      rrccsp_cleanup_bplmn_state();
      break;

    case RRC_BPLMN_SUSPEND_REQ:
      rrccsp_handle_passive_bplmn_suspend_req( cmd_ptr );      
      break;
/*lint -e408*/
#ifdef FEATURE_GAN_3G_ROVE_OUT_ONLY
    #error code not present
#endif

    case RRC_CPHY_CELL_RESELECTION_IND:
        /* Sending trans cnf is for a corner case scenario where CEL RESEL IND
           from L1 is already put in queue when processing channel config cnf.
           Here CSP substate is not changed to handle CELL_TRANS_RSP unlike 
           other cases because we need to process CHAN_CONFIG_CNF for W resume */
        rrccsp_send_transition_failure_on_receipt_of_resel_ind(cmd_ptr, RRC_RESEL_FAIL_CAUSE_INTERNAL);
    break;
/*lint +e408*/
    default:
      WRRC_MSG2_ERROR("ERR Cmd 0x%x not processed in CSP sstate %d",
                            cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);
      break;
  }

  return (next_substate);
} /* rrccsp_wt_chan_cfg_cnf_hdlr  */


/*===========================================================================

FUNCTION          RRCCSP_WT_CHAN_CFG_CNF_PENDING_HDLR

DESCRIPTION       This is a handler for events received in RRCCSP_WT_FOR_CHAN_CFG_CNF_PENDING
                  substate of the Cell Selection Procedure. CSP enters this substate 
                  when waiting for channel config confirmation from lower layers, CSP
                  receives RRC_SERVICE_REQ or PLMN_LIST_REQ.
                  
DEPENDENCIES      NONE

RETURN VALUE      CSP substate

SIDE EFFECTS      NONE

===========================================================================*/
static rrc_csp_substate_e_type
rrccsp_wt_chan_cfg_cnf_pending_hdlr(rrc_cmd_type *cmd_ptr)
{  
  rrc_csp_substate_e_type next_substate;
  rrc_state_e_type        rrc_state = rrc_get_state();

  next_substate = RRCCSP_WT_FOR_CHAN_CFG_CNF_PENDING;
  
  switch(cmd_ptr->cmd_hdr.cmd_id) 
  {
    case RRC_CHANNEL_CONFIG_CNF:

      /* Channel Configuration Passed */
      if(RRCLLC_CHAN_CFG_SUCCESS == cmd_ptr->cmd.chan_config_cnf.chan_cfg_status)
      {
        /* 1. When W was suspended, the cell camped status was changed to RRC_CELL_LOSS_NO_NEW_CELL.
         * 2. Since resume and channel config have been successful, change the cell camped status
         *    back to RRC_NEW_CELL_SELECTED.
         * 3. The reason for changing the cell camped status to RRC_CELL_LOSS_NO_NEW_CELL on suspending
         *    W was to take care of the race condition where during channel config, RCE receives 
         *    RRC_EST_REQ from NAS. 
         * 4. The following function also takes care of informing RCE if it was waiting for UE to camp on.
         */
        rrc_ccm_update_cell_camped_status(RRC_NEW_CELL_SELECTED);
#ifdef FEATURE_DUAL_SIM
        if((rrc_csp_int_data.curr_scan == RRC_CSP_UNLOCK_BY_SCAN)
         && (rrc_csp_int_data.pending_type != RRC_CSP_PREEMPT_IND_PENDING)
         )
        {
          rrc_csp_int_data.curr_scan = RRC_CSP_CELL_SELECTION_SCAN;
          wrm_retain_lock_for_primary();
          rrcwrm_post_pending_cmd();
        }
#endif
        next_substate = rrccsp_pending_command_handler();
      }

      /* Channel Configuration Failed. This is not a common case. Handle pending command */
      else
      {
        WRRC_MSG0_HIGH("CSP rcvd ch cfg with failure after resume. Trigger OOS");
#ifdef FEATURE_DUAL_SIM
         if((rrc_csp_int_data.curr_scan == RRC_CSP_UNLOCK_BY_SCAN)&& 
            (rrc_csp_int_data.pending_type != RRC_CSP_PREEMPT_IND_PENDING))
         {
           rrc_csp_int_data.curr_scan = RRC_CSP_CELL_SELECTION_SCAN;
         }
#endif

        if(rrc_state == RRC_STATE_DISCONNECTED)
        {
          next_substate = rrccsp_pending_command_handler();
        }
        /* Ideally, CSP should NOT come to pending state in Connected Mode. The only commands for which
         * CSP is coming to this state are RRC_SERVICE_REQ and PLMN_LIST_REQ. RRC_SERVICE_REQ
         * is always rcvd in Idle Mode. PLMN_LIST_REQ is also always received in Idle Mode
         * if WTOW BPLMN feature is NOT defined. If WTOW feature is defined then due to PLMN_LIST_REQ
         * CSP state does NOT change to Pending. 
         */
        else
        {
          WRRC_MSG2_ERROR("ERR: channel config resume failed. RRC state %d and CSP pending sst %d ",
                                                                 rrc_state, next_substate);

          WRRC_MSG1_HIGH("Handle pending command in CSP sst %d", next_substate); 

          next_substate = rrccsp_pending_command_handler();
        }
      }
      break;
      
    case RRC_INITIATE_CELL_SELECTION_IND:
      /* Ignore this command as pending command has a higher priority here */
      MSG_HIGH("Ignoring INIT_CELL_SEL cmd from proc rrc_proc_e_type_value%d with cause %d rcvd in pending CSP sstate %d",
                                                             cmd_ptr->cmd.initiate_cell_sel_ind.proc, 
                                                             cmd_ptr->cmd.initiate_cell_sel_ind.cause, 
                                                             rrc_csp_substate);
      break;

    case RRC_SERVICE_REQ:
      if(rrc_state != RRC_STATE_DISCONNECTED)
      {
        WRRC_MSG1_ERROR("ERR Service/PLMN_LIST req in RRC state %d",rrc_state);
      }
 
      WRRC_MSG2_HIGH("Svc Req Req rcvd %d, in CSP pending sstate %d", 
                                        cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);
      rrccsp_save_req( cmd_ptr );
      break;

    case RRC_PLMN_LIST_REQ:
      WRRC_MSG1_HIGH("Service/PLMN_LIST req rcvd in CSP sstate %d", rrc_csp_substate);
      if(rrccsp_plmn_list_req_when_resume_in_prog_is_valid(&(cmd_ptr->cmd.plmn_list_req)))
      {
        rrccsp_cleanup_bplmn_state();

        rrc_csp_int_data.bplmn_crit_sec_flag = TRUE;

        /* Set state so that BPLMN search can be started */
        rrc_csp_int_data.bplmn_nw_sel_mode = cmd_ptr->cmd.plmn_list_req.network_select_mode;

        rrc_csp_int_data.service_search_bgnd = cmd_ptr->cmd.plmn_list_req.service_search;
        WRRC_MSG1_HIGH("SSB: svc_srch_bgnd rcvd from NAS = %d", rrc_csp_int_data.service_search_bgnd);

        /* If Automatic BPLMN search is requested then reject it in this CSP substate,
         * since anyways another Automatic BPLMN search request will be received by CSP in
         * 10s.
         */
        if(rrc_csp_int_data.bplmn_nw_sel_mode == SYS_NETWORK_SELECTION_MODE_AUTOMATIC)
        { 
          WRRC_MSG1_HIGH("WTOW: Rejecting APLS req in CSP sst %d", next_substate);

          rrc_csp_bplmn_send_mm_plmn_list_cnf_cmd(WTOW_SEARCH_ABORT,cmd_ptr->cmd.plmn_list_req.trans_id);
          rrc_csp_int_data.bplmn_crit_sec_flag = FALSE;
        }
        /* Handle Manual Search in this CSP substate */
        else
        {
#ifdef FEATURE_DUAL_SIM
          /*If G is in data call reject manual PLMN search in this substate*/
          if(WRM_G2W_TA_MODE_ACTIVE() && (cmd_ptr->cmd.plmn_list_req.network_select_mode == SYS_NETWORK_SELECTION_MODE_AUTOMATIC))
          {
            rrc_csp_send_mm_plmn_list_cnf_as_aborted(cmd_ptr->cmd.plmn_list_req.trans_id);
            return next_substate;
          }
#endif
          rrccsp_update_plmn_list_req_data(&cmd_ptr->cmd.plmn_list_req);
          rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_START, FALSE, FALSE);
#ifdef FEATURE_FEMTO_CSG
          rrccsp_csg_set_fp_info();
#endif

          WRRC_MSG2_HIGH("WTOW: dual_mode_enabled = %d,wcdma_mode_enabled = %d in PLMN_LIST_REQ", 
                                  rrc_csp_int_data.bplmn_dual_mode_enabled,rrc_csp_int_data.bplmn_wcdma_mode_enabled);

          rrccsp_generate_bplmn_rat_srch_order_update_curr_srch_rat(SYS_NETWORK_SELECTION_MODE_MANUAL);

          rrc_csp_int_data.bplmn_crit_sec_flag = FALSE;

          if(rrc_csp_int_data.bplmn_wcdma_mode_enabled)
          {
            rrccsp_update_wtow_manual_bplmn_list_with_rplmn(rrc_csp_int_data.curr_acq_entry.plmn_id,
                                                            rrc_csp_int_data.curr_acq_entry.cell_id);
          }
        }
      }
      break;

    case RRC_BPLMN_GUARD_SRCH_TIMER_EXPIRED_IND:
      rrccsp_cleanup_bplmn_state();      
      break;

    case RRC_BPLMN_SEARCH_ABORT_REQ:
      rrccsp_cleanup_bplmn_state();      
      break;

    case RRC_BPLMN_SUSPEND_REQ:
      rrccsp_handle_passive_bplmn_suspend_req( cmd_ptr );      
      break;

    default:
      WRRC_MSG2_ERROR("ERR Cmd 0x%x not processed in CSP sstate %d",
                            cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate);
      break;
  }
  return (next_substate);
} /* rrccsp_wt_chan_cfg_cnf_pending_hdlr  */



/*===========================================================================

FUNCTION          RRCCSP_RESET_BPLMN_LIST_SEARCH_STATE

DESCRIPTION       This function sends PLMN_LIST_CNF to NAS (if need be),
                  updates the BPLMN database, and also sends sleep indication
                  to L1 (if need be).
                  
DEPENDENCIES      NONE

RETURN VALUE      NONE
                      
SIDE EFFECTS      NONE

===========================================================================*/
void rrccsp_reset_bplmn_list_search_state(
    wtow_bplmn_srch_status_type status, 
    boolean                     send_list_cnf,  
    boolean                     send_sleep_ind)
{
  /* Check if RRC needs to send Sleep Indication to L1 */
  if(send_sleep_ind)
  {
    /* Send Sleep indication to L1 */
    rrc_csp_send_l1_cmd(RRC_PROCEDURE_CSP, CPHY_GO_TO_SLEEP_IND, &rrc_csp_int_data.curr_acq_entry);
#ifdef FEATURE_LTE_TO_WCDMA
    if(rrc_handle_deprio_req_pending == TRUE)
    {
       WRRC_MSG0_HIGH("Processing pending deprio request after sleep ind");
       rrcmeas_configure_l1_with_priority_info_eutra_cell_list();
       rrc_handle_deprio_req_pending = FALSE;
    }
#endif
  }
  else
  {
    WRRC_MSG0_HIGH("Sleep Ind not sent to L1");
  }

  /* If search has been aborted then send PLMN_LIST_CNF to NAS */
  if(send_list_cnf)
  {
    if((status == WTOW_SEARCH_ABORT) || (status == WTOW_SEARCH_STOP))
    {
#ifdef FEATURE_BPLMN_SEARCH_320MS
      /*INITIATE CELL UPDATE HERE WITH CAUSE LOSSY_PAGE_RECEPTION if no pending PLMN_LIST_REQ is present*/
      /* If W resume fails then CU shouldn't be triggered here as CU with reentered service area will be triggered
         for resume fail */
      if (rrc_csp_check_320ms_bplmn() && 
         (rrc_csp_int_data.pending_type != RRC_CSP_PLMN_LIST_REQ_PENDING) &&
         (wcdma_resume_failed == FALSE))
      {
        (void) rrccsp_send_cell_update_initiate_req(RRC_LOSSY_PAGE_RECEPTION);
      }
      else
      {
        wcdma_resume_failed = FALSE;
      }
#endif
#ifdef FEATURE_FEMTO_CSG
      if(rrc_csp_int_data.csg_asf_srch_in_progress)
      {
        if(status != WTOW_SEARCH_ABORT)
        {
          WRRC_MSG0_HIGH("CSG: sending meas req to wl1");
          rrcmeas_send_csg_mes_info_to_l1(&rrc_csp_int_data.temp_csg_list);
        }
      }
      else
#endif
      {
        rrc_csp_bplmn_send_mm_plmn_list_cnf_cmd(status, rrc_csp_int_data.bplmn_trans_id);
      }
    }
    else
    {
      ERR_FATAL("Unexpected srch status %d",status,0,0);
    }
  }

  rrccsp_update_bplmn_srch_vars(status, rrc_csp_int_data.bplmn_nw_sel_mode);
} /* rrccsp_reset_bplmn_list_search_state */

/*===========================================================================

FUNCTION          RRCCSP_UPDATE_BPLMN_SRCH_VARS

DESCRIPTION       This function is used by CSP to update/re-store appropriate 
                  variables during different stages of 3G->3G Background PLMN search.
                  
DEPENDENCIES      NONE

RETURN VALUE
                  
SIDE EFFECTS

===========================================================================*/
void rrccsp_update_bplmn_srch_vars(
    wtow_bplmn_srch_status_type       status,
    sys_network_selection_mode_e_type nw_sel_mode)
{
  rrclog_wcdma_bplmn_start_event_type bplmn_start_event;
  rrclog_wcdma_bplmn_scan_end_event_type bplmn_scan_end_event;
  rrclog_wcdma_bplmn_end_event_type bplmn_end_event;
  boolean guard_timer_started=FALSE;

  MSG_4(MSG_SSID_DIAG,MSG_LEGACY_HIGH,"curr_scan %d, prev_curr_scan %d, svc_srch_bgnd %d, status %d", 
                                          rrc_csp_int_data.curr_scan, 
                                          rrc_csp_int_data.prev_curr_scan, 
                                          rrc_csp_int_data.service_search_bgnd,
                                          status);

#ifdef FEATURE_DUAL_SIM
  if(((status == WTOW_SEARCH_SUSPEND) || (status == WTOW_SEARCH_STOP) || (status == WTOW_SEARCH_ABORT)) &&
    (rrc_csp_int_data.bplmn_srch_vars_status == WTOW_SEARCH_RESUME) &&
    (!rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_active))
  {
    WRRC_MSG0_HIGH("DSIM: Stop the wait lock timer, release the lock");
    rrctmr_stop_timer(RRCTMR_WRM_LOCK_TIMER);
    rrc_release_lock();
  }
#endif

  switch(status)
  {
    case WTOW_SEARCH_START:
      WRRC_MSG0_HIGH("WTOW: BPLMN srch vars init to start BPLMN search");
      rrc_csp_int_data.bplmn_acq_succ_scr_code = 8192;
      rrc_csp_int_data.bplmn_acq_succ_freq = 0;
      rrc_csp_int_data.bplmn_acq_succ_pn_pos = 0xFFFFFFFF;
      
      drx_inform_l1_abt_bplmn_status(TRUE);

      //EVENT: Event_BPLMN_Start
      if (rrc_csp_int_data.bplmn_srch_vars_status != WTOW_SEARCH_SUSPEND)
      {
#ifdef FEATURE_FEMTO_CSG
        if(rrc_csp_int_data.csg_asf_srch_in_progress)
        {
          bplmn_start_event.network_select_mode = RRC_WTOW_BPLMN;
          event_report_payload(EVENT_ASF_SCAN_START, sizeof(bplmn_start_event),
                         (void *)&bplmn_start_event);
        }
        else
#endif
        {
        bplmn_start_event.network_select_mode = nw_sel_mode;
          bplmn_start_event.search_type = (uint8)rrc_csp_int_data.service_search_bgnd;
        event_report_payload(EVENT_WCDMA_BPLMN_START, sizeof(bplmn_start_event),
                       (void *)&bplmn_start_event);
      }
      }

      rrc_csp_int_data.bplmn_srch_vars_status  = WTOW_SEARCH_START;
      rrc_csp_int_data.bplmn_new_srch          = TRUE;
      rrc_csp_int_data.bplmn_req_list_rd_index = rrc_csp_int_data.bplmn_fnd_list_wr_index = 0;
      rrc_csp_int_data.bplmn_current_band_initialized = FALSE;

      /* Initialize bplmn data */
      rrc_csp_int_data.bplmn_sib_try_next_best_cell = FALSE;
      rrc_csp_int_data.bplmn_acq_status             = FALSE;

      rrc_csp_int_data.bplmn_bgnd_mib_rd_cnt  = 0;
      rrc_csp_int_data.bplmn_bgnd_mib_rd_freq = 0;

      rrc_csp_int_data.bplmn_nw_sel_mode      = nw_sel_mode;
      rrc_csp_int_data.bplmn_suspend_cause = BPLMN_SUSPEND_REASON_NONE;	  

      rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_active  = FALSE;
      rrc_csp_wtog_bplmn_int_data.wtog_srch_done          = FALSE;
      rrc_csp_wtog_bplmn_int_data.wtog_hplmn_found        = FALSE;
      rrc_csp_wtog_bplmn_int_data.wtog_gsm_plmns_found    = 0;
      rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_aborted = FALSE;

      /*Take backup of current band preferences*/
      rrc_csp_int_data.prev_band_pref                     = rrc_csp_int_data.band_pref;
      rrc_csp_int_data.prev_wcdma_band_mask               = rrc_csp_int_data.wcdma_band_mask;

      /*Generate BPLMN band mask*/
      rrc_csp_int_data.band_pref                          = rrc_csp_int_data.bplmn_band_pref;
      rrccsp_update_band_preference();
      rrc_csp_int_data.bplmn_band_mask                    = rrc_csp_int_data.wcdma_band_mask;

      /*Restore current band preference*/
      rrc_csp_int_data.band_pref                          = rrc_csp_int_data.prev_band_pref;
      rrc_csp_int_data.wcdma_band_mask                    = rrc_csp_int_data.prev_wcdma_band_mask;

#ifdef FEATURE_WCDMA_TO_LTE
      rrc_csp_wtog_bplmn_int_data.wtol_plmns_found = 0;
#endif

      rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_suspended = FALSE;

#ifdef FEATURE_BPLMN_SEARCH_320MS
      rrc_csp_int_data.bplmn_start_sfn=0;
#endif

#ifdef FEATURE_PCS_850_FREQ_SCAN_NEW_OPTIMIZATION
      rrc_csp_int_data.umts_chls_from_gsm.size = 0;
#endif

#if defined (FEATURE_WCDMA_TO_LTE) || defined (FEATURE_LTE_TO_WCDMA)
      rrc_csp_int_data.detected_frequency_list.num_freqs = 0;
#endif

      if(!rrc_csp_wtog_bplmn_int_data.restart_bplmn_search)
      {
        if(!rrc_csp_int_data.bplmn_guard_srch_tmr_expired)
        {
          rrctmr_stop_timer(RRCTMR_BPLMN_GUARD_SRCH_TIMER);
        }

        /* Start First PLMN Timer for BPLMN search */
        if((rrc_csp_int_data.bplmn_nw_sel_mode == SYS_NETWORK_SELECTION_MODE_MANUAL) &&
           (rrc_csp_int_data.bplmn_search_timer_value.FirstPLMNTimer >0))
        {
          rrc_csp_int_data.send_partial_results = FALSE;
          WRRC_MSG0_HIGH("MPLMN Opt: Starting FirstPLMNtimer");
          rrctmr_start_timer(RRCTMR_BPLMN_PARTIAL_REPORT_TIMER, (unsigned long)(1000*rrc_csp_int_data.bplmn_search_timer_value.FirstPLMNTimer)); 

          if(rrc_csp_int_data.bplmn_search_timer_value.MaxManualPLMNTimer>0)
          {
            guard_timer_started=TRUE;
            rrctmr_start_timer(RRCTMR_BPLMN_GUARD_SRCH_TIMER, (unsigned long)(1000*rrc_csp_int_data.bplmn_search_timer_value.MaxManualPLMNTimer));
          }
        }
        
        if(!guard_timer_started)
        {
          /* Start Guard BPLMN Srch timer for BPLMN search */
#ifdef FEATURE_DUAL_SIM 
          if(wcdma_is_ue_in_dual_standby)
          {
            rrctmr_start_timer(RRCTMR_BPLMN_GUARD_SRCH_TIMER, RRCTMR_DUAL_SIM_BPLMN_GUARD_SRCH_TIMER_IN_MS);
          }
          else
#endif            
#ifdef FEATURE_WCDMA_TO_LTE
          if(rrc_csp_int_data.bplmn_lte_mode_enabled)
          {
            rrctmr_start_timer(RRCTMR_BPLMN_GUARD_SRCH_TIMER, RRCTMR_LTE_BPLMN_GUARD_SRCH_TIMER_IN_MS);
          }
          else
#endif   
          {
            rrctmr_start_timer(RRCTMR_BPLMN_GUARD_SRCH_TIMER, RRCTMR_BPLMN_GUARD_SRCH_TIMER_IN_MS);
          }        
        }
        rrc_csp_int_data.bplmn_guard_srch_tmr_expired = FALSE;
      }
      else
      {
        WRRC_MSG0_HIGH("WTOW: Not Starting Guard Timer");
      }

     /* Please intialize Trans I.D out side this function*/ 
      break;

    case WTOW_SEARCH_RESUME:

      if(!rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_active)
      {
        /* Save the original vars */
        rrc_csp_int_data.prev_curr_scan           = rrc_csp_int_data.curr_scan; 
  
        rrc_csp_int_data.prev_curr_req_plmn       = rrc_csp_int_data.curr_req_plmn;
        rrc_csp_int_data.prev_curr_acq_entry      = rrc_csp_int_data.curr_acq_entry;
        rrc_csp_curr_select_data.prev_acq_type    = rrc_csp_curr_select_data.acq_type;
        rrc_csp_int_data.prev_curr_type_acq       = rrc_csp_int_data.curr_type_acq;

        rrc_csp_int_data.prev_network_select_mode = rrc_csp_int_data.network_select_mode;
        rrc_csp_int_data.prev_curr_service_status = rrc_csp_int_data.curr_service_status;
        rrc_csp_int_data.prev_last_mm_primitive   = rrc_csp_int_data.last_mm_primitive;

        /*Update with BPLMN band preference*/
        rrc_csp_int_data.band_pref                = rrc_csp_int_data.bplmn_band_pref;
        rrc_csp_int_data.wcdma_band_mask          = rrc_csp_int_data.bplmn_band_mask;

        WRRC_MSG1_HIGH("Saving scr_code: %d",rrc_csp_int_data.serving_pccpch_parms.scr_code);
        rrc_csp_int_data.prev_scr_code    = rrc_csp_int_data.serving_pccpch_parms.scr_code;
  
        /* Update the vars appropriately for BPLMN search */
        if(rrc_csp_int_data.bplmn_nw_sel_mode == SYS_NETWORK_SELECTION_MODE_AUTOMATIC)
        {
          WRRC_MSG0_HIGH("Automatic plmn list srch in progress");
  
          rrc_csp_int_data.curr_scan               = RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN;
          rrc_csp_int_data.curr_req_plmn.plmn_type = RRC_GSM_MAP_SPECIFIC_PLMN_REQ;
          rrc_csp_int_data.network_select_mode     = SYS_NETWORK_SELECTION_MODE_AUTOMATIC;

          rrc_csp_curr_select_data.acq_type        = RRC_CSP_SPEC_PLMN;
          rrc_csp_int_data.curr_type_acq           = RRC_CSP_SPEC_PLMN;

          rrc_csp_int_data.curr_req_plmn.plmn_id = 
                      rrc_csp_int_data.wtow_bplmn_req_list[rrc_csp_int_data.bplmn_req_list_rd_index].plmn_id;
          MSG_HIGH("PLMN %d-%d. bplmn_rd_ix %d", 
                         RRC_CSP_GET_INT_MCC(
                          rrc_csp_int_data.wtow_bplmn_req_list[rrc_csp_int_data.bplmn_req_list_rd_index].plmn_id),
                         RRC_CSP_GET_INT_MNC(
                          rrc_csp_int_data.wtow_bplmn_req_list[rrc_csp_int_data.bplmn_req_list_rd_index].plmn_id),
                         rrc_csp_int_data.bplmn_req_list_rd_index);
        }
        else
        {
          WRRC_MSG0_HIGH("Manual plmn list srch in progress");
          rrc_csp_int_data.curr_scan               = RRC_CSP_WTOW_BPLMN_MANUAL_SCAN;
          rrc_csp_int_data.curr_req_plmn.plmn_type = RRC_GSM_MAP_ANY_PLMN_REQ;
          rrc_csp_int_data.network_select_mode     = SYS_NETWORK_SELECTION_MODE_MANUAL;

          rrc_csp_curr_select_data.acq_type        = RRC_CSP_ANY_PLMN;
          rrc_csp_int_data.curr_type_acq           = RRC_CSP_ANY_PLMN;
        } 
  
        rrc_csp_int_data.curr_service_status = MM_AS_NO_SERVICE;
        rrc_csp_int_data.last_mm_primitive   = RRC_CSP_NO_EVENT_RCVD;  
      }
      else
      {
        rrc_csp_int_data.prev_curr_scan = rrc_csp_int_data.curr_scan; 
        rrc_csp_wtog_bplmn_int_data.wtog_rem_drx_tmr_value = 
                    (uint32)rrctmr_get_remaining_time(RRCTMR_WTOW_BPLMN_DRX_SRCH_TIMER);

       rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_suspended = FALSE;

        if(rrc_csp_int_data.bplmn_nw_sel_mode == SYS_NETWORK_SELECTION_MODE_AUTOMATIC)
        {
          WRRC_MSG0_HIGH("WTOG: Automatic plmn list srch in progress");
          rrc_csp_int_data.curr_scan = RRC_CSP_WTOG_BPLMN_AUTOMATIC_SCAN;
        }
        else
        {
          WRRC_MSG0_HIGH("WTOG: Manual plmn list srch in progress");
          rrc_csp_int_data.curr_scan = RRC_CSP_WTOG_BPLMN_MANUAL_SCAN;
        } 

        /* Update GSM with UE's band preference */
        WRRC_MSG0_HIGH("WTOG: Updating GSM with band preferences for PLMN search");
        if(rrc_csp_int_data.bplmn_nw_sel_mode == SYS_NETWORK_SELECTION_MODE_MANUAL)
        {
          WRRC_MSG1_HIGH("BST band pref incl %d",rrc_bst_band_pref_incl);
          if(rrc_bst_band_pref_incl)
          {
            /* Update GSM with UE's band preference */
            rr_rrc_set_band_pref_internal(rrc_csp_int_data.rat_pri_band_pref);

            /* Update GSM with BST band preference */
            rr_rrc_set_bst_band_pref_internal(rrc_csp_int_data.bplmn_band_pref);
          }
          else
          {
            /* Update GSM with UE's band preference */
            rr_rrc_set_band_pref_internal(rrc_csp_int_data.bplmn_band_pref);

            /* Update GSM with BST band preference */
            rr_rrc_set_bst_band_pref_internal(0);
          }
        }
        else
        {
          /* Update GSM with UE's band preference */
          rr_rrc_set_band_pref_internal(rrc_csp_int_data.bplmn_band_pref);
        }
      }

/*  Needed to support LFS.
#ifdef FEATURE_FEMTO_CSG
      if((rrc_csp_int_data.csg_asf_srch_in_progress) &&
          (rrc_csp_int_data.curr_scan == RRC_CSP_WTOG_BPLMN_AUTOMATIC_SCAN))
      {
        rrc_csp_int_data.do_lfs_scan = TRUE;
      }
#endif
*/
      rrc_csp_int_data.bplmn_srch_vars_status = WTOW_SEARCH_RESUME;
      break;

    case WTOW_SEARCH_SUSPEND:
      WRRC_MSG0_HIGH("WTOW: Suspending BPLMN search");
      
      if(rrc_csp_int_data.bplmn_srch_vars_status == WTOW_SEARCH_RESUME)
      {
        if(!rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_active)
        {
          rrc_csp_int_data.bplmn_new_srch = FALSE;

          /* Restore the original vars */
          rrc_csp_int_data.curr_scan               = rrc_csp_int_data.prev_curr_scan; 
  
          rrc_csp_int_data.curr_req_plmn       = rrc_csp_int_data.prev_curr_req_plmn;
          rrc_csp_int_data.curr_acq_entry      = rrc_csp_int_data.prev_curr_acq_entry;
          rrc_csp_curr_select_data.acq_type    = rrc_csp_curr_select_data.prev_acq_type;
          rrc_csp_int_data.curr_type_acq       = rrc_csp_int_data.prev_curr_type_acq;

          rrc_csp_int_data.network_select_mode     = rrc_csp_int_data.prev_network_select_mode; 
          rrc_csp_int_data.curr_service_status     = rrc_csp_int_data.prev_curr_service_status;
          rrc_csp_int_data.last_mm_primitive       = rrc_csp_int_data.prev_last_mm_primitive;

          /*Restore band preference*/
          rrc_csp_int_data.band_pref           = rrc_csp_int_data.prev_band_pref;
          rrc_csp_int_data.wcdma_band_mask     = rrc_csp_int_data.prev_wcdma_band_mask;

          //EVENT: Event_BPLMN_Scan_End_Req W2W end
          bplmn_scan_end_event.scan_complete = RRC_BPLMN_TIMEOUT; 
          event_report_payload(EVENT_WCDMA_BPLMN_SCAN_END, sizeof(bplmn_scan_end_event),
                         (void *)&bplmn_scan_end_event);

          WRRC_MSG1_HIGH("Restoring scr_code: %d",rrc_csp_int_data.prev_scr_code);
          rrc_csp_int_data.serving_pccpch_parms.scr_code    = rrc_csp_int_data.prev_scr_code;
        }
        else
        {
          WRRC_MSG2_HIGH("WTOG: Suspending BPLMN Search. Change Scan type %d -> %d", 
                                     rrc_csp_int_data.curr_scan, rrc_csp_int_data.prev_curr_scan);
          rrc_csp_int_data.curr_scan = rrc_csp_int_data.prev_curr_scan; 

          /* Update GSM with UE's band preference */
          WRRC_MSG0_HIGH("WTOG: Restoring GSM band preferences for PLMN selection");
          rr_rrc_set_band_pref_internal(rrc_csp_int_data.band_pref);
        }                            
      }
      else
      {
        WRRC_MSG1_ERROR("WTOW ERR: race cond hit. src_vars_st = %d. NOT updating vars",
                                                  rrc_csp_int_data.bplmn_srch_vars_status);
      }

      /* Stop DRX search timer as other procedures SIB and CU can initiate
       * suspension of BPLMN search
       */
      if(!rrc_csp_int_data.bplmn_srch_tmr_expired)
      {
        WRRC_MSG0_HIGH("WTOW DRX Srch tmr has not expd. Stop it");
        rrctmr_stop_timer(RRCTMR_WTOW_BPLMN_DRX_SRCH_TIMER);
        rrc_csp_int_data.bplmn_srch_tmr_expired = TRUE;
      }

      /* This stmt is for testing purposes only and will be removed 
       * before check-in
       */
      if(rrc_csp_int_data.bplmn_guard_srch_tmr_expired)
      {
        WRRC_MSG0_ERROR("WTOW ERR: BPLMN srch is suspended instead of aborted when guard tmr expd");
      }

/*  Needed to support LFS.
#ifdef FEATURE_FEMTO_CSG
      if((rrc_csp_int_data.csg_asf_srch_in_progress) &&
          (rrc_csp_int_data.curr_scan == RRC_CSP_WTOG_BPLMN_AUTOMATIC_SCAN))
      {
        rrc_csp_int_data.do_lfs_scan = FALSE;
      }
#endif
*/
      rrc_csp_int_data.bplmn_srch_vars_status = WTOW_SEARCH_SUSPEND;
      break;

    case WTOW_SEARCH_STOP:
    case WTOW_SEARCH_ABORT:

#ifdef FEATURE_GAN
      #error code not present
#endif
      rrcsib_bplmn_init_prev_freq_psc();

      drx_inform_l1_abt_bplmn_status(FALSE);
      //EVENT: Event_BPLMN_End
      if (rrc_csp_int_data.bplmn_guard_srch_tmr_expired)
      {
        bplmn_end_event.bplmn_end_reason = RRC_BPLMN_TIMEOUT;
      }
      else if (status == WTOW_SEARCH_ABORT)
      {
        bplmn_end_event.bplmn_end_reason = RRC_BPLMN_ABORTED;
      }
      else 
      {
        bplmn_end_event.bplmn_end_reason = RRC_BPLMN_COMPLETED;
      }
#ifdef FEATURE_FEMTO_CSG
      if(rrc_csp_int_data.csg_asf_srch_in_progress)
      {
        event_report_payload(EVENT_ASF_SCAN_END, sizeof(bplmn_end_event),
                         (void *)&bplmn_end_event);
      }
      else
#endif
      {
      event_report_payload(EVENT_WCDMA_BPLMN_END, sizeof(bplmn_end_event),
                       (void *)&bplmn_end_event);
      }

      WRRC_MSG0_HIGH("WTOW: Aborting/Stopping BPLMN search");
      rrc_csp_int_data.bplmn_acq_succ_scr_code = 8192;
      rrc_csp_int_data.bplmn_acq_succ_freq = 0;
      rrc_csp_int_data.bplmn_acq_succ_pn_pos = 0xFFFFFFFF;
      rrc_csp_int_data.bplmn_new_srch = TRUE;
      rrc_csp_int_data.bplmn_req_list_rd_index = rrc_csp_int_data.bplmn_fnd_list_wr_index = 0;
      rrc_csp_int_data.bplmn_current_band_initialized = FALSE;
      rrc_csp_int_data.bplmn_sib_try_next_best_cell = FALSE;
      rrc_csp_int_data.bplmn_acq_status             = FALSE;
      rrc_csp_int_data.bplmn_bgnd_mib_rd_cnt  = 0;
      rrc_csp_int_data.bplmn_bgnd_mib_rd_freq = 0;
      rrc_csp_int_data.bplmn_nw_sel_mode      = SYS_NETWORK_SELECTION_MODE_NONE;
      rrc_csp_int_data.bplmn_suspend_cause = BPLMN_SUSPEND_REASON_NONE;
      rrc_csp_int_data.bplmn_trans_id=INVALID_LIST_TRANS_ID;

      rrc_csp_int_data.service_search_bgnd = SYS_SERVICE_SEARCH_NONE;

      if(rrc_csp_int_data.bplmn_srch_vars_status == WTOW_SEARCH_RESUME)
      {
        if(!rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_active)
        {
          /* Restore the original vars */
          rrc_csp_int_data.curr_scan           = rrc_csp_int_data.prev_curr_scan; 
  
          rrc_csp_int_data.curr_req_plmn       = rrc_csp_int_data.prev_curr_req_plmn;
          rrc_csp_int_data.curr_acq_entry      = rrc_csp_int_data.prev_curr_acq_entry;
          rrc_csp_curr_select_data.acq_type    = rrc_csp_curr_select_data.prev_acq_type;
          rrc_csp_int_data.curr_type_acq       = rrc_csp_int_data.prev_curr_type_acq;

          rrc_csp_int_data.network_select_mode = rrc_csp_int_data.prev_network_select_mode; 
          rrc_csp_int_data.curr_service_status = rrc_csp_int_data.prev_curr_service_status;
          rrc_csp_int_data.last_mm_primitive   = rrc_csp_int_data.prev_last_mm_primitive;

          /*Restore band preference*/
          rrc_csp_int_data.band_pref           = rrc_csp_int_data.prev_band_pref;
          rrc_csp_int_data.wcdma_band_mask     = rrc_csp_int_data.prev_wcdma_band_mask;

          //EVENT: Event_BPLMN_Scan_End_Req W2W end
          if(status == WTOW_SEARCH_STOP)
          {
            bplmn_scan_end_event.scan_complete = RRC_BPLMN_COMPLETED; 
          }
          else
          {
            bplmn_scan_end_event.scan_complete = RRC_BPLMN_ABORTED; 
          }
          event_report_payload(EVENT_WCDMA_BPLMN_SCAN_END, sizeof(bplmn_scan_end_event),
                         (void *)&bplmn_scan_end_event);

          WRRC_MSG1_HIGH("Restoring scr_code: %d",rrc_csp_int_data.prev_scr_code);
          rrc_csp_int_data.serving_pccpch_parms.scr_code    = rrc_csp_int_data.prev_scr_code;
        }
        else
        {
          WRRC_MSG2_HIGH("WTOG: Aborting/Stopping BPLMN Search. Change Scan type %d -> %d", 
                                     rrc_csp_int_data.curr_scan, rrc_csp_int_data.prev_curr_scan);

          rrc_csp_int_data.curr_scan                          = rrc_csp_int_data.prev_curr_scan; 
          rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_aborted = FALSE;

          /* Update GSM with UE's band preference */
          WRRC_MSG0_HIGH("WTOG: Restoring GSM band preferences for PLMN selection");
          rr_rrc_set_band_pref_internal(rrc_csp_int_data.band_pref);
        }
      }
      /* Reset the flag when BPLMN is stopped/aborted */
      rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_active  = FALSE;

      if(!rrc_csp_int_data.bplmn_srch_tmr_expired)
      {
        rrctmr_stop_timer(RRCTMR_WTOW_BPLMN_DRX_SRCH_TIMER);
        rrc_csp_int_data.bplmn_srch_tmr_expired = TRUE;
      }

      if(!rrc_csp_int_data.bplmn_guard_srch_tmr_expired)
      {
        rrctmr_stop_timer(RRCTMR_BPLMN_GUARD_SRCH_TIMER);
        rrc_csp_int_data.bplmn_guard_srch_tmr_expired = TRUE;
      }
      bplmn_data_saved = FALSE;
/*
      rrc_csp_int_data.plmn_srch_order.curr_rat_srch_idx = -1;
      rrc_csp_int_data.plmn_srch_order.num_rats = 0;
*/
#ifdef FEATURE_PCS_850_FREQ_SCAN_NEW_OPTIMIZATION
      rrc_csp_int_data.umts_chls_from_gsm.size = 0;
#endif

#if defined (FEATURE_WCDMA_TO_LTE) || defined (FEATURE_LTE_TO_WCDMA)
      rrc_csp_int_data.detected_frequency_list.num_freqs = 0;
#endif

#ifdef FEATURE_FEMTO_CSG
      if(rrc_csp_int_data.csg_asf_srch_in_progress)
      {
        WRRC_MSG0_HIGH("CSG: Resetting ASF srch flag");
        rrc_csp_int_data.csg_asf_srch_in_progress = FALSE;
        rrc_csp_int_data.do_lfs_scan = FALSE;
        if(status == WTOW_SEARCH_ABORT)
        {
          WRRC_MSG1_HIGH("CSG: ASF got aborted restart ASF timer for %d",RRC_CSG_DISCONN_TRANS_ASF_SRCH_TIMER_IN_MS);
          rrctmr_stop_timer(RRCTMR_CSG_ASF_SRCH_TIMER);
          rrctmr_start_timer(RRCTMR_CSG_ASF_SRCH_TIMER, RRC_CSG_DISCONN_TRANS_ASF_SRCH_TIMER_IN_MS);
        }
      }
#endif

      rrc_csp_wtog_bplmn_int_data.restart_bplmn_search = FALSE;
      rrc_csp_int_data.bplmn_srch_vars_status = WTOW_SEARCH_ABORT;
      break;

    default:
      WRRC_MSG0_ERROR("WTOW ERR: Incorrect Status Type. Programming Error");
      break;
  }         

  MSG_HIGH("curr_scan %d, prev_curr_scan %d, svc_srch_bgnd %d", 
                                          rrc_csp_int_data.curr_scan, 
                                          rrc_csp_int_data.prev_curr_scan, 
                                          rrc_csp_int_data.service_search_bgnd);
} /* rrccsp_update_bplmn_srch_vars */


/*===========================================================================

FUNCTION          RRC_CSP_BPLMN_SRCH_IN_PROGRESS

DESCRIPTION       This function is called by procedures CSP, RCE, SIB, and CU
                  to determine if BPLMN search is in progress.
                  
DEPENDENCIES      NONE

RETURN VALUE      TRUE:  BPLMN search is in progress
                  FALSE: Otherwise
                  
SIDE EFFECTS      NONE
===========================================================================*/
wtow_bplmn_srch_status_type rrc_csp_bplmn_srch_in_progress()
{
  wtow_bplmn_srch_status_type srch_status;

  /* Search is in progress - actively or passively */
  if(!rrc_csp_int_data.bplmn_guard_srch_tmr_expired)
  {
    if(!rrc_csp_int_data.bplmn_srch_tmr_expired)
    {
      WRRC_MSG0_HIGH("WTOW BPLMN srch actively in prog");
      srch_status = WTOW_SEARCH_RESUME;
    }
    else
    {
      WRRC_MSG0_HIGH("WTOW BPLMN srch passively in prog");
      srch_status = WTOW_SEARCH_SUSPEND;
    }
  }
  else
  {
    WRRC_MSG0_HIGH("WTOW BPLMN srch NOT initiated");
    srch_status = WTOW_SEARCH_STOP;
  }


  return srch_status;
} /* rrc_csp_bplmn_srch_in_progress */


/*===========================================================================

FUNCTION   RRC_CSP_SEND_BPLMN_SUSPEND_REQ

DESCRIPTION

  This function sends RRC_BPLMN_SUSPEND_REQ to CSP
  to suspend the ongoing Manual or Automatic Background PLMN Search.
  If RCE sends the suspend request then the ongoing BPLMN search is aborted
  while for other procedures such as SIB and CU, BPLMN search is only
  suspended
  
  
DEPENDENCIES

  None.
 
RETURN VALUE

  None.
 
SIDE EFFECTS

  None.

===========================================================================*/
void rrc_csp_send_bplmn_suspend_req(rrc_proc_e_type proc, rrc_bplmn_suspend_cause_e_type cause)
{
  rrc_cmd_type *cmd_ptr;
   
  /* Get a RRC internal command buffer */
  if((cmd_ptr = rrc_get_int_cmd_buf()) != NULL)
  {
  /* Fill in the command id  */
    cmd_ptr->cmd_hdr.cmd_id = RRC_BPLMN_SUSPEND_REQ;

    /* Fill in procedure id that will receive this indication */
    cmd_ptr->cmd.rrc_csp_bplmn_suspend_req.procedure = proc;
  
    /* Fill in procedure id that will receive this indication */
    cmd_ptr->cmd.rrc_csp_bplmn_suspend_req.cause = cause;

    /* Put the command in the internal queue */
    rrc_put_int_cmd( cmd_ptr );
  }
} /* end of rrc_csp_send_bplmn_suspend_req */


/*===========================================================================

FUNCTION   RRC_CSP_SEND_BPLMN_SUSPEND_CNF

DESCRIPTION

  This function is called by CSP and it sends RRC_BPLMN_SUSPEND_CNF to 
  the procedure that sent RRC_BPLMN_SUSPEND_REQ to CSP
  
  
DEPENDENCIES

  None.
 
RETURN VALUE

  None.
 
SIDE EFFECTS

  None.

===========================================================================*/
void rrc_csp_send_bplmn_suspend_cnf(rrc_proc_e_type proc, uecomdef_status_e_type status)
{
  rrc_cmd_type *cmd_ptr;
  
  /* Get a RRC internal command buffer */
  if((cmd_ptr = rrc_get_int_cmd_buf()) != NULL)
  {
    /* Fill in the command id  */
    cmd_ptr->cmd_hdr.cmd_id = RRC_BPLMN_SUSPEND_CNF;

    /* Fill in procedure id that will receive this indication */
    cmd_ptr->cmd.rrc_csp_bplmn_suspend_cnf.procedure = proc;

    cmd_ptr->cmd.rrc_csp_bplmn_suspend_cnf.status = status;
  
    /* Put the command in the internal queue */
    rrc_put_int_cmd( cmd_ptr );
  }
} /* end of rrc_csp_send_bplmn_suspend_cnf */

/*===========================================================================

FUNCTION   RRCCSP_IS_GTOW_BPLMN_SRCH_IN_PROGRESS

DESCRIPTION

  This function checks if there is GTOW BPLMN search is in progress (or) not
  
DEPENDENCIES

  None.
 
RETURN VALUE

  return TRUE if GTOW BPLMN search is in progress otherwise
         FALSE
 
SIDE EFFECTS

  None.

===========================================================================*/
boolean rrccsp_is_gtow_bplmn_srch_in_progress()
{
  boolean gtow_bplmn_in_progess = FALSE;
  rrc_csp_scan_e_type csp_curr_scan_type;

  csp_curr_scan_type = rrc_csp_int_data.curr_scan;
  
  if((RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN == csp_curr_scan_type) || 
     (RRC_CSP_GTOW_BPLMN_MANUAL_SCAN == csp_curr_scan_type))
  {
    gtow_bplmn_in_progess = TRUE;
  }
  return gtow_bplmn_in_progess;
} /* rrccsp_is_gtow_bplmn_srch_in_progress */

/*===========================================================================

FUNCTION   RRCCSP_GET_CURR_SCAN

DESCRIPTION

  This function returns the current scan type in CSP
  
  
DEPENDENCIES

  None.
 
RETURN VALUE

  rrc_csp_scan_e_type
 
SIDE EFFECTS

  None.

===========================================================================*/
#ifdef FEATURE_QSH_DUMP
    __attribute__((section(".uncompressible.text")))
#endif
rrc_csp_scan_e_type rrccsp_get_curr_scan()
{
//  WRRC_MSG1_HIGH("RRCCSP: curr_scan = %d", rrc_csp_int_data.curr_scan); 
  return rrc_csp_int_data.curr_scan;
}


/*===========================================================================

FUNCTION   RRCCSP_GET_CURR_SCAN

DESCRIPTION

  This function returns the current scan type in CSP
  
  
DEPENDENCIES

  None.
 
RETURN VALUE

  rrc_csp_scan_e_type
 
SIDE EFFECTS

  None.

===========================================================================*/
rrc_csp_scan_e_type rrccsp_get_curr_scan_no_f3()
{
  
  return rrc_csp_int_data.curr_scan;
}


/*===========================================================================

FUNCTION   RRCCSP_GET_CURR_TYPE_ACQ

DESCRIPTION

  This function returns the current acq type - RRC_CSP_SPEC_PLMN or
  RRC_CSP_ANY_PLMN      
  
DEPENDENCIES 
  None.
  
RETURN VALUE 

  rrc_csp_acq_e_type: RRC_CSP_SPEC_PLMN or RRC_CSP_ANY_PLMN
 
SIDE EFFECTS

  None.

===========================================================================*/
rrc_csp_acq_e_type rrccsp_get_curr_type_acq()
{
  WRRC_MSG1_HIGH("curr_type_acq = %d", rrc_csp_int_data.curr_type_acq);
  return rrc_csp_int_data.curr_type_acq;
}


/*===========================================================================

FUNCTION   RRCCSP_CHECK_IF_3G_BAND_PREF_CHANGED

DESCRIPTION

  This function returns TRUE if the NAS Band mask is same 
  as CSP internal band mask
  
  
DEPENDENCIES

  None.
 
RETURN VALUE

  TRUE/FALSE
 
SIDE EFFECTS

  None.

===========================================================================*/
boolean rrccsp_check_if_3g_band_pref_changed(sys_band_mask_type nas_band_mask)
{
  boolean ret_val = FALSE;

  /*Define a local band mask */
  sys_band_mask_type local_band_mask= rrccsp_get_sys_wcdma_band_mask();

  local_band_mask = local_band_mask & nas_band_mask;

  if(local_band_mask == rrc_csp_int_data.band_pref)
  {  
    ret_val = TRUE;
  }
  MSG_HIGH("DUAL: Recd NAS band mask = 0x%x, CSP Int band mask =0x%x, WCDMA static mask=0x%x",
               nas_band_mask,rrc_csp_int_data.band_pref,local_band_mask);
  return ret_val;
}

/*===========================================================================

FUNCTION RRC_REGISTER_SERVING_CELL_CHANGE_IND_CB

DESCRIPTION

This function enables upper layer to register a callback function if notification
of the serving cell id is required.  Once the function is registered, it will be 
called whenever there is a serving cell change.


DEPENDENCIES

  None.
  
RETURN VALUE
  
  BOOLEAN:  TRUE signifies that registration has succeeded.  FALSE signifies
            that registration failed.

SIDE EFFECTS

  None.

===========================================================================*/

boolean rrc_register_serving_cell_change_ind_cb
(
  RRC_SERVING_CELL_CHANGE_IND_CB_FUNC_TYPE *cb_ptr
)
{
  uint32 i = 0;

  if (cb_ptr)
  {
    /* First go thru the list to make sure func does 
     * not get registered twice.
     */
    for (i = 0; i < MAX_NUM_OF_REG_CB; i++) 
    {
      if (rrc_serving_cell_change_ind_cb_func[i] == cb_ptr)
      {
        WRRC_MSG2_HIGH("Function already registered i:%d cb:%d",i,cb_ptr);
        return TRUE;
      }
    }

    for (i = 0; i < MAX_NUM_OF_REG_CB; i++) 
    {
      if (rrc_serving_cell_change_ind_cb_func[i] == NULL)
      {
        WRRC_MSG2_HIGH ("Registering rrc_serving_cell_change_ind_cb ind: %d cb: %d",i,cb_ptr);
        rrc_serving_cell_change_ind_cb_func[i] = cb_ptr;
        return TRUE;
      }
    }
    if (i == MAX_NUM_OF_REG_CB) 
    {
      WRRC_MSG0_ERROR("Cannot register cell change ind cb func ");
    }
  }
  else
  {
    WRRC_MSG0_ERROR("Cannot Register NULL CC Callback");
  }
  return FALSE;
}

/*===========================================================================

FUNCTION RRC_DEREGISTER_SERCING_CELL_CHANGE_IND_CB

DESCRIPTION

This function enables upper layer to deregister the callback function that was
registered for notification of serving cell id.


DEPENDENCIES

  None.
  
RETURN VALUE

  BOOLEAN:  TRUE signifies that deregistration has succeeded.  FALSE signifies
            that deregistration failed.  

SIDE EFFECTS

  None.

===========================================================================*/

boolean rrc_deregister_serving_cell_change_ind_cb
(
   RRC_SERVING_CELL_CHANGE_IND_CB_FUNC_TYPE *cb_ptr
)
{
  uint32 i = 0;
  
  for (i = 0; i < MAX_NUM_OF_REG_CB; i++) 
  {
    if (rrc_serving_cell_change_ind_cb_func[i] == cb_ptr) 
    {
      WRRC_MSG2_HIGH ("Deregistering rrc_serving_cell_change_ind_cb ind %d cb: %d",i,cb_ptr);
      rrc_serving_cell_change_ind_cb_func[i] = NULL;
      return TRUE;
    }
  }
  
  if (i == MAX_NUM_OF_REG_CB) 
  {
    WRRC_MSG0_ERROR("Cannot de-register cell change ind cb func ");
  }

  return FALSE;
}
/*===========================================================================
FUNCTION rrc_get_lac_id_in_dch

DESCRIPTION
  This function is called to retrieve LAC from CN Info.

DEPENDENCIES
  None.
  
RETURN VALUE
  SUCCESS - LAC was extracted from CN Info.
  FAILURE - LAC couldn't be ectracted from CN Info.

SIDE EFFECTS
  None.
===========================================================================*/
uecomdef_status_e_type rrc_get_lac_id_in_dch
(
   rrc_gsm_map_nas_sys_info_type   * nas_common_info
)
{
  rrc_lai_type lai;

  /* Get the LAI status from local utility */
  if(mm_extract_lac_from_sib_info(&lai, nas_common_info) == FALSE)
  {
    WRRC_MSG0_ERROR("Could not extract LAI from NAS Common sys info");
    return FAILURE;
  }
  else
  {
    lac_in_ota[0] = lai.lac[0];
    lac_in_ota[1] = lai.lac[1];
    lac_in_ota_present = TRUE;
    return SUCCESS;	
  }
}

/*===========================================================================
FUNCTION rrc_get_rac_id_in_dch

DESCRIPTION
  This function is called to retrieve RAC from CN Info.

DEPENDENCIES
  None.
  
RETURN VALUE
  None

SIDE EFFECTS
  None.
===========================================================================*/

void rrc_get_rac_id_in_dch
(
  rrc_CN_DomainInformationList *cn_domain_info_list_ptr
)
{
  /* This stores the GSM-MAP NAS system info */
  rrc_gsm_map_nas_sys_info_type   nas_domain_spec_info;
  boolean rac_found = FALSE;
  rrc_rai_type rai;
  uint32 idx = 0;

  memset(&nas_domain_spec_info,0,sizeof(rrc_gsm_map_nas_sys_info_type));

  do
  {
    if(cn_domain_info_list_ptr->elem[idx].cn_DomainIdentity == rrc_CN_DomainIdentity_ps_domain)
    {
      unsigned char  *data_ptr;
      uint32          i;
      if((cn_domain_info_list_ptr->elem[idx].cn_DomainSpecificNAS_Info.numocts > RRC_MAX_GSM_INFO_OCTET_COUNT)||
          (cn_domain_info_list_ptr->elem[idx].cn_DomainSpecificNAS_Info.numocts <= RRC_GSM_INFO_OCTET_COUNT_ABSENT))
      {
        break;
      }
      data_ptr = cn_domain_info_list_ptr->elem[idx].cn_DomainSpecificNAS_Info.data;
      for(i=0;i<cn_domain_info_list_ptr->elem[idx].cn_DomainSpecificNAS_Info.numocts; i++)
      {
        nas_domain_spec_info.value[i] = *data_ptr;
        data_ptr ++;
      }
      rai.rac[0] = nas_domain_spec_info.value[0];
      rac_found = TRUE;
      break;
    }
    idx++;
  }while (cn_domain_info_list_ptr->n > idx);

  if(rac_found)
  {
    rac_in_ota[0] = rai.rac[0];
    rac_in_ota_present = TRUE;
  }
}

/*===========================================================================

FUNCTION  rrc_extract_network_operating_mode

DESCRIPTION This function extracts Network Operating mode from NAS CN Domain System Information List.

DEPENDENCIES
  None
  
RETURN VALUE          
  TRUE: RAC is found
  FALSE: RAC is not found

===========================================================================*/

static void rrc_extract_network_operating_mode(sys_network_op_mode_e_type* nw_operating_mode,rrc_CN_DomainSysInfoList *cn_domain_sys_info_list_ptr)
{
  //Extract RAC from NAS CN domain specific info in SIB1
  /* This stores the GSM-MAP NAS system info */
  rrc_gsm_map_nas_sys_info_type   nas_domain_spec_info;
  boolean rac_found = FALSE;
  uint32 idx = 0;

  *nw_operating_mode = SYS_PS_DOMAIN_SYS_INFO_UNAVAILABLE;
  memset(&nas_domain_spec_info,0,sizeof(rrc_gsm_map_nas_sys_info_type));

  do
  {
    /* First check if Core network is GSM MAP. */
    if(cn_domain_sys_info_list_ptr->elem[idx].cn_Type.t == 
                                      T_rrc_CN_DomainSysInfo_cn_Type_gsm_MAP)
    {
      unsigned char  *data_ptr;
      uint32          i;
  
      if(cn_domain_sys_info_list_ptr->elem[idx].cn_DomainIdentity == rrc_CN_DomainIdentity_ps_domain)
      {
        /* Check if the RRC MM interface structure array can hold this info */
        if((cn_domain_sys_info_list_ptr->elem[idx].cn_Type.u.gsm_MAP->numocts > 
            RRC_MAX_GSM_INFO_OCTET_COUNT) ||
            (cn_domain_sys_info_list_ptr->elem[idx].cn_Type.u.gsm_MAP->numocts < 2))
        {
          WRRC_MSG1_ERROR("Not enough space for NAS Sys Info (%d bytes)", 
                                                              cn_domain_sys_info_list_ptr->elem[idx].cn_Type.u.gsm_MAP->numocts);
          return ;
        }

        data_ptr = cn_domain_sys_info_list_ptr->elem[idx].cn_Type.u.gsm_MAP->data;
  
        for( i = 0; i < cn_domain_sys_info_list_ptr->elem[idx].cn_Type.u.gsm_MAP->numocts; i ++)
        {
          nas_domain_spec_info.value[i] = *data_ptr;
          data_ptr ++;
        }
        rac_found = TRUE;
        break;
      }
    } /* If CN type is GSM MAP */ 
    idx++;
  }while(cn_domain_sys_info_list_ptr->n > idx);
  
  if(rac_found)
  {
    if((nas_domain_spec_info.value[1] & 0x01) == 0)
    {
      *nw_operating_mode = SYS_NETWORK_OP_MODE_1;
    }
    else
    {
      *nw_operating_mode = SYS_NETWORK_OP_MODE_2;
    }
  }
  WRRC_MSG1_HIGH("FTD_DBG:NMO: %d",*nw_operating_mode);
}

/*===========================================================================
FUNCTION rrc_update_serving_cell_wcdma_UI_event_info

DESCRIPTION
  This function is invoked on cell changes in IDLE/FACH/PCH state.
  It populates the serving cell info global data to report to CM
DEPENDENCIES
  None.
  
RETURN VALUE
  None.

SIDE EFFECTS
  None.
===========================================================================*/
static void rrc_update_serving_cell_wcdma_UI_event_info
(
  void
)
{
  rrc_SysInfoType1 *sib1_ptr;
  rrc_rai_type rai;
  rrc_lai_type  lai;
  wcdma_serving_cell_info_type* serving_cell_info;
  rrc_state_e_type rrc_curr_state = rrc_get_state();
  sib1_ptr = (rrc_SysInfoType1 *) rrc_sibdb_return_sib_for_srv_cell(rrc_SIB1);
  serving_cell_info = &(wcdma_UI_event_info.wcdma_event_info.wcdma_serving_cell_info);

  rai.rac[0] = 0;
  lai.lac[0] = 0;
  lai.lac[1] = 0;

  if(RRC_IS_WCDMA_UI_EVENT_ENABLED(SYS_WCDMA_SERVING_CELL_INFO_BIT_MASK))
  {
    if(RRC_CELL_LOSS_NO_NEW_CELL == rrc_ccm_get_serv_plmn_cellid(&(serving_cell_info->cell_id), &(serving_cell_info->plmn_id)))
    {
      WRRC_MSG0_HIGH("FTD_DBG: Cell loss, Don't update Serving cell info");
      return;
    }
    (void)rrc_get_lac_id(&lai);
    serving_cell_info->lac[0] = lai.lac[0];
    serving_cell_info->lac[1] = lai.lac[1];
    serving_cell_info->psc = rrc_ccm_get_curr_camped_psc();
    serving_cell_info->uarfcn = rrc_ccm_get_curr_camped_freq();
  
    if((sib1_ptr != NULL) &&
      (rrc_extract_rac_from_sib_info(&rai,&(sib1_ptr->cn_DomainSysInfoList))))
    {
      serving_cell_info->is_rac_present = TRUE;
      serving_cell_info->rac[0] = rai.rac[0];
    }
    else
    {
      serving_cell_info->is_rac_present = FALSE;
    }

    if(sib1_ptr != NULL)
    {
      rrc_extract_network_operating_mode(&(serving_cell_info->nw_operation_mode)
                                                               ,&(sib1_ptr->cn_DomainSysInfoList));
    }
    else
    {
      WRRC_MSG0_ERROR("SIB1 not read.");
      serving_cell_info->nw_operation_mode = SYS_PS_DOMAIN_SYS_INFO_UNAVAILABLE;
    }
    /*In case of URA PCH state, should send URA also, for now set it to invalid*/
    serving_cell_info->ura = WCDMA_INVALID_URA;
    if(rrc_curr_state == RRC_STATE_URA_PCH)
    {
      rrccu_get_ura_id(&serving_cell_info->ura);
    }
    wcdma_UI_event_info.bitmask |= SYS_WCDMA_SERVING_CELL_INFO_BIT_MASK;
    /*Call the CM API to set the Signals*/
#ifdef FEATURE_DUAL_SIM
    cm_per_subs_stats_set_modem_info_signal(SYS_MODEM_MODULE_WCDMA, rrc_get_as_id());
#else
    cm_stats_set_modem_info_signal(SYS_MODEM_MODULE_WCDMA);
#endif
    WRRC_MSG1_HIGH("FTD_DBG: Serving cell info bit mask set, bit_mask %x",wcdma_UI_event_info.bitmask);

#ifdef FEATURE_DEBUG_MODEM_STATISTICS
    MSG_4(MSG_SSID_DIAG, MSG_LEGACY_HIGH,
        "FTD_DBG: Serving cell info PSC %d, Freq %d, cell id %d, URA %d ",
        serving_cell_info->psc,serving_cell_info->uarfcn,serving_cell_info->cell_id,serving_cell_info->ura
        );
    PRINT_PLMN_ID(serving_cell_info->plmn_id);
    MSG_4(MSG_SSID_DIAG, MSG_LEGACY_HIGH,
        "FTD_DBG: LAC[0] %d, LAC[1] %d, rac_present %d, rac[0] %d",
        serving_cell_info->lac[0],serving_cell_info->lac[1],serving_cell_info->is_rac_present,serving_cell_info->rac[0]
        );
#endif	

  }

}

/*===========================================================================
FUNCTION rrc_update_active_set_reference_cell_wcdma_UI_event_info

DESCRIPTION
  This function is invoked on ASET change in DCH state.
  It populates the active set reference cell info global data to report to CM
DEPENDENCIES
  None.
  
RETURN VALUE
  None.

SIDE EFFECTS
  None.
===========================================================================*/
static void rrc_update_active_set_reference_cell_wcdma_UI_event_info
(
  void
)
{
  uint8 idx = 0;
  rrc_lai_type  lai;
  wcdma_active_set_reference_rl_info_type* aset_ref_rl_info = NULL;

  lai.lac[0] = 0;
  lai.lac[1] = 0;

  aset_ref_rl_info = &(wcdma_UI_event_info.wcdma_event_info.wcdma_active_set_reference_rl_info);
  if((RRC_IS_WCDMA_UI_EVENT_ENABLED(SYS_WCDMA_ACTIVE_SET_REFERENCE_CELL_INFO_BIT_MASK)) && 
      (l1_get_reference_cell_info(&(aset_ref_rl_info->uarfcn),
                                             &(aset_ref_rl_info->psc))))
  {
    aset_ref_rl_info->plmn_id = rrc_csp_int_data.curr_req_plmn.plmn_id;
    if(rac_in_ota_present)
    {
      aset_ref_rl_info->is_rac_present = TRUE;
      aset_ref_rl_info->rac[0] = rac_in_ota[0];
      WRRC_MSG0_HIGH("FTD_DBG: RAC present in OTA");
    }
    else
    {
      rrc_SysInfoType1 *sib1_ptr;
      rrc_rai_type rai;
      rai.rac[0] = 0;

      sib1_ptr = (rrc_SysInfoType1 *) rrc_sibdb_return_sib_for_srv_cell(rrc_SIB1);

      if((sib1_ptr != NULL) &&
        (rrc_extract_rac_from_sib_info(&rai,&(sib1_ptr->cn_DomainSysInfoList))))
      {
        aset_ref_rl_info->is_rac_present = TRUE;
        aset_ref_rl_info->rac[0] = rai.rac[0];
      }
      else
      {
        aset_ref_rl_info->is_rac_present = FALSE;
      }
    }

    if(lac_in_ota_present)
    {
      aset_ref_rl_info->lac[0] = lac_in_ota[0];
      aset_ref_rl_info->lac[1] = lac_in_ota[1];
      WRRC_MSG0_HIGH("FTD_DBG: LAC Present in OTA");
    }
    else
    {
      (void)rrc_get_lac_id(&lai);
      aset_ref_rl_info->lac[0] = lai.lac[0];
      aset_ref_rl_info->lac[1] = lai.lac[1];
    }

    aset_ref_rl_info->cell_id = WCDMA_INVALID_CELL_ID;

    for(idx=0; idx < L1_MAX_RL; idx++)  
    {
      if((aset_ref_rl_info->psc == ordered_config_ptr->l1_dl_chan_parms.dl_per_rl[idx].pri_cpich_scr_code) &&
                (cell_id_per_rl[idx] != WCDMA_INVALID_CELL_ID))
      {
        aset_ref_rl_info->cell_id = cell_id_per_rl[idx];
        break;
      }
    }

    wcdma_UI_event_info.bitmask |= SYS_WCDMA_ACTIVE_SET_REFERENCE_CELL_INFO_BIT_MASK;
    /*Call CM API to set the signal*/
#ifdef FEATURE_DUAL_SIM
    cm_per_subs_stats_set_modem_info_signal(SYS_MODEM_MODULE_WCDMA, rrc_get_as_id());
#else
    cm_stats_set_modem_info_signal(SYS_MODEM_MODULE_WCDMA);
#endif
    WRRC_MSG1_HIGH("FTD_DBG: Active set reference cell bit mask set, bit_mask %x",wcdma_UI_event_info.bitmask);

#ifdef FEATURE_DEBUG_MODEM_STATISTICS
	  MSG_HIGH("FTD_DBG: Aset ref cell info,  PSC %d, Freq %d, cell id %d",
		  aset_ref_rl_info->psc,aset_ref_rl_info->uarfcn,aset_ref_rl_info->cell_id
		  );
	  PRINT_PLMN_ID(aset_ref_rl_info->plmn_id);
	  MSG_4(MSG_SSID_DIAG, MSG_LEGACY_HIGH,
		  "FTD_DBG: LAC[0] %d, LAC[1] %d, rac_present %d, rac[0] %d",
		  aset_ref_rl_info->lac[0],aset_ref_rl_info->lac[1],aset_ref_rl_info->is_rac_present,aset_ref_rl_info->rac[0]
		  );
#endif

  }

}


/*===========================================================================
FUNCTION rrc_notify_cell_id_in_dch

DESCRIPTION
  This function is called to notify the registered callback of the serving
  cell_id in Cell_DCH state.

DEPENDENCIES
  None.
  
RETURN VALUE
  None.

SIDE EFFECTS
  None.
===========================================================================*/
void rrc_notify_cell_id_in_dch
(
  void
)
{
  uint8 idx = 0, no_of_callbacks = 0;
  
  /*Arguments to L1 function l1_get_reference_cell_info(). L1 fills them.*/
  uint16 freq =0, psc =0;

  /*Variable to store cell id to be reported through callbacks.*/
  uint32 new_cell_id = WCDMA_INVALID_CELL_ID;
  
  /* This stores cell location info to be given to Callbacks*/
  cell_info_type cell_info;
  
  /* This stores the LAI received in SIB1 */
  rrc_lai_type  lai;

  ordered_config_type *config_ptr;

  memset(&cell_info, 0, sizeof(cell_info_type));


  rrc_update_active_set_reference_cell_wcdma_UI_event_info();


#ifdef FEATURE_DUAL_SIM
  cell_info.as_id = rrc_get_as_id();
#endif

  if(config_ptr_in_use == ORDERED_CONFIG)
  {
    config_ptr = ordered_config_ptr;
  }
  else
  {
    config_ptr = current_config_ptr;
  }
  /*Get the cell_id and PLMN-id from CCM*/
  (void)rrc_ccm_get_serv_plmn_cellid(&cell_info.cell_id, &cell_info.plmn_id);

  /*Call L1 to get PSC of the reference Cell*/
  if(l1_get_reference_cell_info(&freq, &psc))
  {
    WRRC_MSG2_HIGH("Freq %d and PSC %d returned from L1.",freq, psc);
    for(idx=0; idx < L1_MAX_RL; idx++)  
    {
      if((psc == config_ptr->l1_dl_chan_parms.dl_per_rl[idx].pri_cpich_scr_code) &&
                (cell_id_per_rl[idx] != WCDMA_INVALID_CELL_ID))
      {
        new_cell_id = cell_id_per_rl[idx];
        cell_info.psc = psc;
        WRRC_MSG2_HIGH("new cell id from cell_id_per_rl %d and PSC %d ",new_cell_id, cell_info.psc);
        break;
      }
    }
  }


  WRRC_MSG1_HIGH("new cell id local is %d ",new_cell_id);

  /*We will come here, if we don't have a valid cell_id for reference RL returned by L1.
  In this case, we will invoke callbacks with any valid cell id in our database.*/
  if(new_cell_id == WCDMA_INVALID_CELL_ID)
  {
    for(idx=0; idx < L1_MAX_RL; idx++)  
    {
      if(cell_id_per_rl[idx] != WCDMA_INVALID_CELL_ID)
      {
        new_cell_id = cell_id_per_rl[idx];		
        cell_info.psc = config_ptr->l1_dl_chan_parms.dl_per_rl[idx].pri_cpich_scr_code;
        WRRC_MSG1_HIGH("Cell Id to be reported is %d.",new_cell_id);
        break;
      }
    }
  }

    cell_info.cell_id = new_cell_id;

    cell_info.plmn_id = rrc_csp_int_data.curr_req_plmn.plmn_id;
    PRINT_PLMN_ID(cell_info.plmn_id);
    if(lac_in_ota_present)
    {
      cell_info.lac[0] = lac_in_ota[0];
      cell_info.lac[1] = lac_in_ota[1];
    }
    else if (SUCCESS == rrc_get_lac_id(&lai))
    {
      cell_info.lac[0] = lai.lac[0];
      cell_info.lac[1] = lai.lac[1];
    }
    else
    {
      WRRC_MSG0_HIGH("Failed to get LAC");
    }
    if(freq == 0)
    {
      freq = rrc_ccm_get_curr_camped_freq();
    }
    if (cell_info.psc == 0)
    {
      cell_info.psc = psc;
    }
    cell_info.uarfcn_dl = freq;
    cell_info.uarfcn_ul = (uint16)rrc_ccm_calculate_ul_uarfcn((uint32)freq,rrc_ccm_get_curr_camped_plmn());

  cell_info.current_band=rrc_convert_band_to_sys_band(rrc_get_frequency_band(cell_info.uarfcn_dl, cell_info.plmn_id));

  /*We will invoke callbacks only if we have valid cell_id and the same cell_id wasn't sent in previous invocation.*/
  if(new_cell_id != prev_cell_id )
  {
    WRRC_MSG2_HIGH("New Cell Id = %d and Old Cell Id %d.",new_cell_id, prev_cell_id);
    prev_cell_id = new_cell_id;

    cell_id_dch_info = cell_info;
    rrc_send_cell_id_ind_to_cm();

    if(new_cell_id != WCDMA_INVALID_CELL_ID)
    {
    #ifdef FEATURE_QCHAT
    WRRC_MSG0_HIGH("Notify cell id change to QChat UPK");
    qchatupk_update_location_cell_dch(SYS_SYS_MODE_WCDMA, (void*)&cell_info);
    #endif /* FEATURE_QCHAT */

    /*Now we call all the registered callbacks.*/
    for (idx = 0; idx < MAX_NUM_OF_REG_CB; idx++) 
    { 
      if (rrc_serving_cell_change_ind_cb_func[idx]) 
      {
        no_of_callbacks++;
        rrc_serving_cell_change_ind_cb_func[idx](cell_info);
      }
    }
    WRRC_MSG2_HIGH("Notified Cell Id %d to %d Callbacks", cell_info.cell_id, no_of_callbacks);	  
  }
}
  else if(new_cell_id == WCDMA_INVALID_CELL_ID)
  {
    /* To make sure we dont send notification when the cell hasnt changed*/
    boolean is_prev_freq_psc_present = FALSE;

    for(idx=0; idx < L1_MAX_RL; idx++)  
    {
      if((cell_id_dch_info.psc == config_ptr->l1_dl_chan_parms.dl_per_rl[idx].pri_cpich_scr_code)&&
        (freq == cell_id_dch_info.uarfcn_dl))
      {
        is_prev_freq_psc_present = TRUE;
        MSG_HIGH("is_prev_freq_psc_present is set to %d cell_id_dch_info.psc : %d freq %d ", is_prev_freq_psc_present, cell_id_dch_info.psc, cell_id_dch_info.uarfcn_dl);
        break;
      }
    }
    if(is_prev_freq_psc_present == FALSE)
    {
      cell_id_dch_info = cell_info;
      prev_cell_id = new_cell_id;
      rrc_send_cell_id_ind_to_cm();
    }
  }
  return;
}
/*===========================================================================

FUNCTION RRC_NOTIFY_CELL_ID_CHANGE

DESCRIPTION

This function is called to notify the registered callback of the serving
cell change id.

DEPENDENCIES

  None.
  
RETURN VALUE
  
  None.

SIDE EFFECTS

  None.

===========================================================================*/

void rrc_notify_cell_id_change(void)
{
  uint8 i = 0;
  /* This stores cell location info */
  cell_info_type cell_info;
  uint8 no_of_callbacks = 0;

  /* This stores the LAI received in SIB1 */
  rrc_lai_type  lai;
  memset(&cell_info, 0, sizeof(cell_info_type));

  rrc_update_serving_cell_wcdma_UI_event_info();


#ifdef FEATURE_DUAL_SIM
  cell_info.as_id = rrc_get_as_id();
#endif

  if(RRC_CELL_LOSS_NO_NEW_CELL == rrc_ccm_get_serv_plmn_cellid(&cell_info.cell_id, &cell_info.plmn_id))
  {
    WRRC_MSG0_HIGH("Cell Loss.  No need to call registered cb");
    return;
  }

  if (SUCCESS == rrc_get_lac_id(&lai))
  {
    cell_info.lac[0] = lai.lac[0];
    cell_info.lac[1] = lai.lac[1];
  }
  else
  {
    WRRC_MSG0_ERROR("Failed to get LAC");
  }


  cell_info.psc = rrc_ccm_get_curr_camped_psc();
  WRRC_MSG1_HIGH("Reporting PSC: %d to registered call back functions.",cell_info.psc);

  cell_info.uarfcn_dl = rrc_ccm_get_curr_camped_freq();
  cell_info.uarfcn_ul = rrc_ccm_calculate_ul_uarfcn(rrc_ccm_get_curr_camped_freq(),rrc_ccm_get_curr_camped_plmn());
  cell_info.current_band=rrc_convert_band_to_sys_band(rrc_get_frequency_band(cell_info.uarfcn_dl, cell_info.plmn_id));
#ifdef FEATURE_QCHAT
  WRRC_MSG0_HIGH("Notify cell id change to QChat UPK");
  qchatupk_update_location_cell_dch(SYS_SYS_MODE_WCDMA, (void*)&cell_info);
#endif /* FEATURE_QCHAT */

  cell_id_dch_info = cell_info;
  prev_cell_id = WCDMA_INVALID_CELL_ID;
  rrc_send_cell_id_ind_to_cm();

  for (i = 0; i < MAX_NUM_OF_REG_CB; i++) 
  { 
    if (rrc_serving_cell_change_ind_cb_func[i]) 
    {
      no_of_callbacks++;
      rrc_serving_cell_change_ind_cb_func[i](cell_info);
    }
  }
  WRRC_MSG2_HIGH("Notified serving cell Id %d to %d callbacks", cell_info.cell_id, no_of_callbacks);
} 


#ifdef FEATURE_EOOS
#error code not present
#endif


/*===========================================================================
FUNCTION: RRCCSP_CHECK_AND_TEARDOWN_SBCCH_DURING_BPLMN

DESCRIPTION: This function is called when RRC receives DEACT_REQ / MODE_CHANGE_REQ 
             / STOP_WCDMA_MODE_REQ . If BPLMN is actively in progress and CSP is waiting for SIBs,
             it sends SBCCH release req.

DEPENDENCIES: NONE

RETURN VALUE: NONE

SIDE EFFECTS: NONE
=============================================================================*/
void rrccsp_check_and_teardown_sbcch_during_bplmn(void)
{
  if( (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)
      || (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN) )
  {
    if( (rrc_csp_substate == RRCCSP_CELL_SEL_WT_SIB) ||
        (rrc_csp_substate == RRCCSP_CELL_SEL_WT_SIB_PENDING) )
    {
      rrc_csp_send_bch_release(FALSE);
    }
  }
}

#ifdef FEATURE_WRLF_SYSTEM_SEL
/*===========================================================================
FUNCTION: RRCCSP_CHECK_AND_TEARDOWN_SBCCH_DURING_WRLF

DESCRIPTION: This function is called when RRC receives DEACT_REQ / MODE_CHANGE_REQ 
             / STOP_WCDMA_MODE_REQ . If WRLF in progress and CSP is waiting for SIBs,
             it sends SBCCH release req.

DEPENDENCIES: NONE

RETURN VALUE: NONE

SIDE EFFECTS: NONE
=============================================================================*/
void rrccsp_check_and_teardown_sbcch_during_wrlf(void)
{
    if( (rrc_csp_substate == RRCCSP_CELL_SEL_WT_SIB) ||
        (rrc_csp_substate == RRCCSP_CELL_SEL_WT_SIB_PENDING) )
    {
      rrc_csp_send_bch_release(FALSE);

      /* Signal SIB procedure to clear up the active event, if any */
      rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_OOS);
    }
}
#endif

/*===========================================================================

FUNCTION RRCCSP_PREPROCESS_DEACT_REQ_IF_NECESSARY

DESCRIPTION

  This function gets called as before processing RRC_DEACT_REQ.
  When waiting for any response from RR, do the associated steps as per 
  the current scan type.

DEPENDENCIES

  None.
  
RETURN VALUE
  
  None.

SIDE EFFECTS

  None.

===========================================================================*/
static void rrccsp_preprocess_deact_req_if_necessary(void)
{
  /* We call MCM function for getting est cause (instead of RCE function) because 
   * the est req is blocked at MCM and has not yet reached RCE procedure.
   */
  rrc_establish_cause_e_type rrc_est_cause = rrcmcm_get_rrc_est_cause();
  
  if(rrc_csp_substate == RRCCSP_WT_RESPONSE_FROM_RR)
  {
    /* Send Inter-RAT redirection abort request to RR and wait for confirmation
     * from RR
     */
    if(rrc_csp_int_data.curr_scan == RRC_CSP_WCDMA_TO_GSM_CELL_RESELECTION_SCAN)
    {
      rrccsp_send_irat_reselection_abort_req();
      rrccsp_reset_reselection_data();
    }
#ifdef FEATURE_PCS_850_FREQ_SCAN_OPTIMIZATION
    else if(rrc_csp_int_data.curr_scan == RRC_CSP_CELL_SELECTION_SCAN)
    {
      /* Send Inter-RAT redirection abort request to RR and wait for confirmation
       * from RR
       */
      rrccsp_send_interrat_redirection_abort_req();
    }
#endif

    else if(rrc_csp_int_data.curr_scan == RRC_CSP_WTOG_BPLMN_AUTOMATIC_SCAN)
    {
      /* Send RR_INTERRAT_PLMN_SRCH_ABORT_REQ to GSM */
       rrccsp_send_irat_bplmn_abort_req();
    }
    else if(rrc_csp_int_data.curr_scan == RRC_CSP_WTOG_BPLMN_MANUAL_SCAN)
    {
      /* Send RR_INTERRAT_PLMN_SRCH_ABORT_REQ to GSM */
      rrccsp_send_irat_bplmn_abort_req();

      /* If MCM sent ABORT_IND due to establishment request and est cause
       * is registration then automatically re-start BPLMN search after 
       * completion of registration.
       */
      if(   (rrc_est_cause == RRC_EST_REGISTRATION)
         || (rrc_est_cause == RRC_EST_INTER_RAT_CELL_RESELECT)
         || (rrc_est_cause == RRC_EST_INTER_RAT_CELL_CHANGE_ORDER))
      {
         WRRC_MSG0_HIGH("Est Cause is Registration. Suspend & Restart BPLMN search");
         rrc_csp_wtog_bplmn_int_data.restart_bplmn_search = TRUE;
      }
    }
    else if(rrc_csp_int_data.curr_scan == RRC_CSP_PLMN_LIST_SCAN)
    {
      /* Send RR_INTERRAT_PLMN_SRCH_ABORT_REQ to GSM */
      rrccsp_send_irat_bplmn_abort_req();
    }
    else if(rrc_csp_int_data.curr_scan == RRC_CSP_INTER_RAT_REDIRECTION_SCAN)
    {
      /* Send Inter-RAT redirection abort request to RR and wait for confirmation
       * from RR
       */
      rrccsp_send_interrat_redirection_abort_req();
    }
  }

  if(rrc_csp_int_data.curr_scan == RRC_CSP_PLMN_LIST_SCAN)
  {
    rrc_csp_send_mm_plmn_list_cnf_as_aborted(rrc_csp_int_data.bplmn_trans_id);
  }

  rrccsp_check_and_teardown_sbcch_during_bplmn();

} /* rrccsp_preprocess_deact_req_if_necessary */



#ifdef FEATURE_INTER_FREQ_EM_CALL_REDIRECTION

/*===========================================================================

FUNCTION          RRCCSP_UPDATE_ACQ_TYPE_FOR_EM_CALL_IFREQ_REDIRECTION

DESCRIPTION       Updates appropriate variables so that cell selection for
                  inter freq redirection is done for any plmn. Currently 
                  this function is called only when Emergency call is made 
                  and it is redirected to another frequency via RRC Connection 
                  Reject message.

DEPENDENCIES      NONE

RETURN VALUE      NONE

SIDE EFFECTS      NONE

===========================================================================*/
void
rrccsp_update_acq_type_for_em_call_ifreq_redirection(rrc_csp_acq_e_type type_of_acq)
{
  /* Update variables if emergency call is redirected to another frequency
   * so that UE tries acquisition on ANY_PLMN as opposed to SPEC_PLMN since
   * it is an emergency call.
   *
   * The updated variables are reverted back to their original values as soon
   * as redirection completes - successfully or unsuccessfully; or it is 
   * aborted.
   */
  MSG_HIGH("iFreq: acq_type_updated %d, n/w sel mode = %d, type of acq %d", 
                                            rrc_csp_int_data.em_call_acq_type_updated, 
                                            rrc_csp_int_data.network_select_mode, 
                                            type_of_acq);

  /* Update to ANY_PLMN */
  if(type_of_acq == RRC_CSP_ANY_PLMN)
  { 
    if((rrc_establishment_cause == RRC_EST_EMERGENCY_CALL)
       && (rrc_csp_int_data.network_select_mode != SYS_NETWORK_SELECTION_MODE_LIMITED))
    {
      rrc_csp_int_data.curr_type_acq            = RRC_CSP_ANY_PLMN;
      rrc_csp_int_data.curr_req_plmn.plmn_type  = RRC_GSM_MAP_ANY_PLMN_REQ;
      rrc_csp_curr_select_data.acq_type         = RRC_CSP_ANY_PLMN;

      rrc_csp_int_data.ifreq_orig_nw_select_mode = rrc_csp_int_data.network_select_mode;
      rrc_csp_int_data.network_select_mode       = SYS_NETWORK_SELECTION_MODE_LIMITED;
      rrc_csp_int_data.ifreq_orig_plmn_id        = rrc_csp_int_data.curr_req_plmn.plmn_id;

      rrc_csp_int_data.em_call_acq_type_updated = TRUE;
      WRRC_MSG0_HIGH("iFreq: Values Set to ANY");
    }
    else
    {
      WRRC_MSG0_HIGH("iFreq: Values NOT updated to ANY");
    } 
  }
  /* Revert back to SPEC_PLMN */
  else if(type_of_acq == RRC_CSP_SPEC_PLMN)
  {
    if(rrc_csp_int_data.em_call_acq_type_updated)
    {
      MSG_HIGH("bcch_nas_match = %d, acq_entry_in_eplmn = %d, nas_entry_in_eplmn = %d", 
                rrc_bcch_and_nas_plmns_match(rrc_csp_int_data.curr_acq_entry.plmn_id,
                                            rrc_csp_int_data.ifreq_orig_plmn_id),
                rrccsp_check_for_eplmn(
                 mmumts_convert_rrc_plmn_id_to_nas_plmn_id(rrc_csp_int_data.curr_acq_entry.plmn_id)),
                rrccsp_check_for_eplmn(mmumts_convert_rrc_plmn_id_to_nas_plmn_id(rrc_csp_int_data.ifreq_orig_plmn_id))
               );

      WRRC_MSG2_HIGH("UE camped status: %d. status_mask %d", rrc_ccm_get_curr_camping_status(RRC_PROCEDURE_CSP), 
                                                       rrc_csp_int_data.curr_acq_entry.status_mask);

      rrc_csp_int_data.curr_type_acq            = RRC_CSP_SPEC_PLMN;
      rrc_csp_int_data.curr_req_plmn.plmn_type  = RRC_GSM_MAP_SPECIFIC_PLMN_REQ;
      rrc_csp_curr_select_data.acq_type         = RRC_CSP_SPEC_PLMN;
 
      /* If camped PLMN is the same or equivalent to the original PLMN */
      if(
         /* In case the cell selection is aborted. in this case, original vars need to be used */
         (
           (RRC_NOT_CAMPED_ON == rrc_ccm_get_curr_camping_status(RRC_PROCEDURE_CSP))
         )
         ||
         (
           ((
              rrc_bcch_and_nas_plmns_match(rrc_csp_int_data.curr_acq_entry.plmn_id, rrc_csp_int_data.ifreq_orig_plmn_id)
           )
           ||
           (
              (rrccsp_check_for_eplmn(mmumts_convert_rrc_plmn_id_to_nas_plmn_id(
                                                      rrc_csp_int_data.ifreq_orig_plmn_id)))
           && (rrccsp_check_for_eplmn(mmumts_convert_rrc_plmn_id_to_nas_plmn_id(
                                                      rrc_csp_int_data.curr_acq_entry.plmn_id)))
           ))
         &&
           (!(rrc_csp_int_data.curr_acq_entry.status_mask & RRC_CSP_FORBID_REG_AREA_BIT))
         )
        )
      {
        rrc_csp_int_data.network_select_mode = rrc_csp_int_data.ifreq_orig_nw_select_mode;
        WRRC_MSG1_HIGH("iFreq: setting n/w sel mode to %d", rrc_csp_int_data.network_select_mode);
      }
      else
      {
        rrc_csp_int_data.network_select_mode = SYS_NETWORK_SELECTION_MODE_LIMITED_ROUTINE_ACQUISITION;
        WRRC_MSG1_HIGH("iFreq: setting n/w sel mode to %d", rrc_csp_int_data.network_select_mode);
      }
      
      rrc_csp_int_data.em_call_acq_type_updated = FALSE;

      WRRC_MSG0_HIGH("iFreq: Resetting to original values");
    }
  }
  /* Wrong enum type is passed. Print an error message and do nothing */
  else
  {
    WRRC_MSG1_ERROR("Incorrect type_of_acq %d. Ignoring", type_of_acq);
  }
} /* rrccsp_update_acq_type_for_em_call_ifreq_redirection */

#endif /* FEATURE_INTER_FREQ_EM_CALL_REDIRECTION */


#if defined (FEATURE_CGPS)
/*===========================================================================

FUNCTION  rrc_check_wcdma_in_oos

DESCRIPTION

  This function is called by GPS to check if W searching is in progress
    
DEPENDENCIES

  None.
 
RETURN VALUE

  TRUE If W search is in progress
  else
  FALSE.

SIDE EFFECTS

  None.

===========================================================================*/
boolean rrc_check_wcdma_in_oos
(
  void
)
{
  rrc_mode_e_type    rrc_curr_mode = rrcmcm_get_rrc_mode();
  rrcmcm_state_e_type rrcmcm_substate = rrcmcm_get_substate();
  
  boolean status = FALSE;

  switch(rrc_curr_mode)
  {
    case RRC_MODE_INACTIVE:
    case RRC_MODE_INTERRAT_IN_PROGRESS:
      if(rrcmcm_substate == RRCMCM_WAIT_START_CNF)
      {
        status = TRUE;
      }
      else
      {
        status = FALSE;
      }
      break;

    case RRC_MODE_STANDBY:
      /*If W resume is in progress*/
      if(rrcmcm_substate == RRCMCM_WAIT_RESUME_CNF)
      {
        status = TRUE;
      }
      else
      {
        /*Other Cases of WTOG*/
        status = FALSE;
      }
      break;

    case RRC_MODE_ACTIVE:
      /*If OOS, cell sel scan in progress and CSP is waiting for ACQ/FREQ cnf*/
      /*In case of WTOW BPLMN */
      if(((rrc_csp_int_data.curr_scan == RRC_CSP_CELL_SELECTION_SCAN) || 
           (rrc_csp_int_data.curr_scan == RRC_CSP_OUT_OF_SERVICE_AREA_SCAN) || 
           (rrc_csp_int_data.curr_scan == RRC_CSP_OUT_OF_SERVICE_AREA_IN_IDLE_STATE_SCAN) ||
           (rrc_csp_int_data.curr_scan == RRC_CSP_OUT_OF_SERVICE_AREA_IN_CONNECTING_STATE_SCAN)||
           (rrc_csp_int_data.curr_scan == RRC_CSP_PLMN_LIST_SCAN)) &&
         ((rrc_csp_substate == RRCCSP_CELL_SEL_WT_ACQ) || 
          (rrc_csp_substate == RRCCSP_CELL_SEL_WT_ACQ_PENDING) ||
          (rrc_csp_substate == RRCCSP_CELL_SEL_WT_FREQ_SCAN_CNF) ||
          (rrc_csp_substate == RRCCSP_CELL_SEL_WT_FREQ_SCAN_CNF_PENDING))
        )
      {
        status = TRUE;
      }
      /*If MCM is waiting for STOP_WCDMA_CNF*/
      else if (((rrc_csp_substate == RRCCSP_CAMPED_ACCEPT_CELL) || (rrc_csp_substate == RRCCSP_CAMPED_SUIT_CELL)) &&
                 (rrcmcm_substate == RRCMCM_WAIT_STOP_CNF))
      {
        status = TRUE;
      }
      else if (rrc_csp_substate == RRCCSP_WT_STOP_MODE_CHANGE_CNF)
      {
        status = TRUE;
      }
      else
      {
        status = FALSE;
      }
      break;

    default :
      status = FALSE;
      break;
  }

  return status;
}
#endif

/*===========================================================================

FUNCTION        RRCCSP_CHECK_FOR_EPLMN

DESCRIPTION     This function checks the network select mode, and accordingly calls the NAS fucntion to check the
                EPLMN list

DEPENDENCIES
                None

RETURN VALUE    If the network select mode is
                >LIMITED     returns TRUE
                >Otherwise   return the return value of sys_eplmn_list_equivalent_plmn

SIDE EFFECTS
                None

===========================================================================*/
boolean rrccsp_check_for_eplmn
(
  sys_plmn_id_s_type nas_plmn_id
)
{
  sys_network_selection_mode_e_type curr_network_sel_mode = rrc_csp_int_data.network_select_mode;

  if(rrc_csp_int_data.em_call_acq_type_updated)
  {
    curr_network_sel_mode = rrc_csp_int_data.ifreq_orig_nw_select_mode;
  }

  /* During WRLF search, for LIMITED_MANUAL service req (nw_sel_mode: LIMITED,
     service_req_cause != RRC_MO_CS_CALL) call NAS API to check EPLMN list.*/
  if((curr_network_sel_mode == SYS_NETWORK_SELECTION_MODE_LIMITED)
#ifdef FEATURE_WRLF_SYSTEM_SEL
      && !(RRC_IS_CONN_MODE_OOS_SRCH_IN_PROGRESS()
           && (rrc_csp_int_data.service_req_cause != RRC_MO_CS_CALL))
#endif
    )
  {
    return TRUE;
  }
  else
  {
#ifdef FEATURE_DUAL_SIM
    return (sys_eplmn_per_subs_list_equivalent_plmn(nas_plmn_id,rrc_get_as_id()));
#else
    return (sys_eplmn_list_equivalent_plmn(nas_plmn_id));
#endif
  }
}

/*===========================================================================

FUNCTION          rrccsp_check_wtog_abort_in_progress

DESCRIPTION       This function checks if W2G search abort is in progress.
                  If so, STOP WCDMA should be pended till WTOG search abort is 
                  completed
                             
DEPENDENCIES
                  None
RETURN VALUE
                  None
SIDE EFFECTS
                  None

===========================================================================*/
boolean rrccsp_check_wtog_abort_in_progress
(
  rrc_stop_cause_e_type stop_cause
)
{
  boolean ret_val = FALSE;
  rrc_csp_int_data.stop_pending_for_wtog_abort=FALSE;

#ifdef FEATURE_WCDMA_ABSOLUTE_PRIORITY
  if( (RRC_USER_RAT_CHANGE == stop_cause) ||
       (RRC_DUAL_SWITCH == stop_cause))
  {
    /*
      NAS is stopping WCDMA for user triggered RAT change or Dual Switch
      New PLMN selection will start, so clear the dedicated priorites
    */
    rrcmeas_invalidate_dedicated_priority_info();
#if defined(FEATURE_LTE_TO_WCDMA) || defined (FEATURE_WCDMA_TO_LTE)|| defined (FEATURE_WCDMA_DEDICATED_PRI_INFO)
    rrcmeas_handle_clear_dedicated_pri_ind();
    /*As W is already cleared, the call to below API will do nothing but sending the clear req to the owner if any*/
    rrcmeas_send_clear_ded_pri_ind_set_owner();
#endif
  }
#endif

  /* If WTOG proc is already aborted, wait for cnf from RR */
  if(rrc_csp_substate == RRCCSP_WT_RR_ABORT_CNF)
  {
    ret_val = TRUE;
    rrc_csp_int_data.stop_pending_for_wtog_abort = TRUE;
    rrc_csp_substate = RRCCSP_WT_RR_ABORT_CNF;
  }
  /* If WTOG proc has not been aborted, abot the procedure now and wait for cnf from RR.*/
  else if(rrc_csp_substate == RRCCSP_WT_RESPONSE_FROM_RR)
  {
    switch(rrc_csp_int_data.curr_scan)
    {
      case RRC_CSP_WTOG_BPLMN_AUTOMATIC_SCAN:
      case RRC_CSP_WTOG_BPLMN_MANUAL_SCAN:
        MSG_HIGH("WTOG: wtog_bplmn_srch_active %d, wtog_bplmn_srch_aborted %d curr_scan %d",
          rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_active,
          rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_aborted,rrc_csp_int_data.curr_scan);

        if((rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_active) &&
            (!rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_aborted))
        {
          rrccsp_send_irat_bplmn_abort_req();
        }
        break;


      case RRC_CSP_WCDMA_TO_GSM_CELL_RESELECTION_SCAN:
        if(stop_cause != RRC_RAT_CHANGE)
        {
          rrccsp_send_irat_reselection_abort_req();
          rrccsp_reset_reselection_data();
        }
        else
        {
#ifdef FEATURE_WCDMA_TO_LTE
          if(rrc_csp_int_data.interrat_type == RRC_CSP_INTERRAT_LTE)
          {
            rrclog_wcdma_to_lte_resel_end_event_type wtol_resel_event;
            wtol_resel_event.status = WTOL_SUCCESS;
            wtol_resel_event.failure_cause = 0xFF; 
            /*Do not fill failure cause as WTOL is success*/
            event_report_payload(EVENT_WCDMA_TO_LTE_RESELECTION_END, sizeof(wtol_resel_event),
                           (void *)&wtol_resel_event);
          }
#endif
          return ret_val;
        }
        break;

#ifdef FEATURE_PCS_850_FREQ_SCAN_OPTIMIZATION
      case RRC_CSP_CELL_SELECTION_SCAN:
        /* Send Inter-RAT redirection abort request to RR and wait for confirmation
         * from RR
         */
        if((stop_cause != RRC_RAT_CHANGE) && (!rrc_csp_int_data.gsm_svc_srch_done))
        {
          rrccsp_send_interrat_redirection_abort_req();
        }
        else
        {
          return ret_val;
        }
        break;
#endif

      case RRC_CSP_INTER_RAT_REDIRECTION_SCAN:
        /* Send Inter-RAT redirection abort request to RR and wait for confirmation
         * from RR
         */
        if(stop_cause != RRC_RAT_CHANGE)
        {
          rrccsp_send_interrat_redirection_abort_req();
        }
        else
        {
#ifdef FEATURE_WCDMA_TO_LTE
          if(rrc_csp_int_data.interrat_type == RRC_CSP_INTERRAT_LTE)
          {
            rrclog_wcdma_to_lte_redir_end_event_type wtol_redir_event;
            wtol_redir_event.status = WTOL_SUCCESS;
            event_report_payload(EVENT_WCDMA_TO_LTE_REDIRECTION_END, sizeof(wtol_redir_event),
                           (void *)&wtol_redir_event);
          }
          else
#endif
          {
             rrclog_wcdma_to_gsm_redir_end_event_type wtog_rdr_evnt;
             wtog_rdr_evnt.status = WTOG_SUCCESS;
             event_report_payload(EVENT_WCDMA_TO_GSM_REDIRECTION_END, sizeof(wtog_rdr_evnt),
                 (void *)&wtog_rdr_evnt);
          }
          return ret_val;
        }
        break;

      case RRC_CSP_PLMN_LIST_SCAN:
        rrccsp_send_irat_bplmn_abort_req();
        break;

      default:
        if(stop_cause == RRC_RAT_CHANGE)
        {
          WRRC_MSG2_HIGH("No abort for RAT change in csp substate %d %d",
                    rrc_csp_substate, rrc_csp_int_data.curr_scan);
        }
        else
        {
          /*we can err-fatal after testing out*/
          WRRC_MSG2_ERROR("Invalid scan type in csp substate %d %d", 
                    rrc_csp_substate, rrc_csp_int_data.curr_scan);
        }
        return ret_val; /* For other scans no need to abort RR*/

    }

    rrctmr_start_timer(RRCTMR_WTOG_ABORT_GUARD_TIMER,
                     RRCTMR_WTOG_ABORT_GUARD_TIMER_IN_MS);

    ret_val = TRUE;
    rrc_csp_int_data.stop_pending_for_wtog_abort = TRUE;
    rrc_csp_substate = RRCCSP_WT_RR_ABORT_CNF;
  }

  return ret_val;
}
#ifdef FEATURE_WCDMA_TO_LTE
/*===========================================================================

FUNCTION          rrccsp_reset_flag_for_excluding_pre_redir_info

DESCRIPTION       This function resets the flag to not include pre-redir info in 
                  connection request message.

DEPENDENCIES
                  None
RETURN VALUE
                  None
SIDE EFFECTS
                  None

===========================================================================*/
void rrccsp_reset_flag_for_excluding_pre_redir_info(void)
{
  WRRC_MSG1_HIGH("LTOW:reset flag to not include pre-redir info in conn request msg. Flag = %d", 
        rrc_csp_int_data.exclude_preredir_info_in_conn_req_msg);
  rrc_csp_int_data.exclude_preredir_info_in_conn_req_msg = FALSE;
}

/*===========================================================================

FUNCTION          rrccsp_exclude_preredirection_info

DESCRIPTION       This function checks if pre-redirection info has to be excluded
                  from RRC connection request message.
                             
DEPENDENCIES
                  None
RETURN VALUE
                  None
SIDE EFFECTS
                  None

===========================================================================*/
boolean rrccsp_is_preredirection_info_to_be_excluded(void)
{
  WRRC_MSG1_HIGH("LTOW: exclude_preredir_info_in_conn_req_msg = %d", 
        rrc_csp_int_data.exclude_preredir_info_in_conn_req_msg);
  return rrc_csp_int_data.exclude_preredir_info_in_conn_req_msg;
}
#endif
#ifdef FEATURE_WCDMA_HANDLE_MDSP_HALT
/*===========================================================================

FUNCTION rrc_csp_handle_cell_selection_for_mdsp_halt

DESCRIPTION 
    This function handles initiate cell selection for mDSP halt.

DEPENDENCIES
    None.

RETURN VALUE
    None.

===========================================================================*/
static void rrc_csp_handle_cell_selection_for_mdsp_halt(void)
{
  boolean ind_can_be_handled = TRUE;
  boolean release_channels_and_update_state = FALSE;
  boolean handle_ind_at_csp = TRUE; /*For future use*/

  /*If GTOW IHO is in progress, call IHO function to do actions at IHO*/
  if(rrciho_is_gtow_ho_active())
  {
    /*RAJEEVM_TBD: For now dont handle the cell selection initiation*/
    WRRC_MSG0_HIGH("GTOW IIHO is in progress,");
    if(!rrciho_check_and_handle_mdsp_halt_during_gtow_handover())
    {
      WRRC_MSG0_ERROR("Cannot handle MDSP halt at IHO");
      ind_can_be_handled = FALSE;
    }
    else
    {
      handle_ind_at_csp = FALSE;
    }
  }

  /* If GTOW CCO is in progress, call CHO function to do actions at CHO*/
  /* If RRC waiting for activation rsp, wait the rsp before triggering channel release */
  if(rrccho_is_gtow_pcco_in_progress() &&
      (rrcmcm_act_cause != RRCMCM_INTERRAT_CC_ORDER_GTOW))
  {
    WRRC_MSG0_HIGH("GTOW PCCO is in progress,");
    rrccho_handle_mdsp_halt();
    handle_ind_at_csp = FALSE;
  }

  /*If WTOG is in progress cannot handle*/
  if(rrciho_is_wtog_ho_active())
  {
    WRRC_MSG0_HIGH("WTOG IHO in progress");
    if(rrciho_check_and_handle_mdsp_halt_during_wtog_handover())
    {
      release_channels_and_update_state = TRUE;
      handle_ind_at_csp = FALSE;
    }
    else
    {
      WRRC_MSG0_ERROR("Cannot handle MDSP halt at IHO");
      ind_can_be_handled = FALSE;
    }
  }

  if(rrccho_is_wtog_cco_active())
  {
    WRRC_MSG0_HIGH("WTOG CCO in progress");
    rrccho_handle_mdsp_halt();
    release_channels_and_update_state = TRUE;
    handle_ind_at_csp = FALSE;
  }

  /*
    If MCM mode is IRAT in progress and scan is not cell selection scan, then 
    >Activation cause if GTOW handover, i.e RRC has sent ACTIVATION_IND to NAS
    >>Cannot handle the case as of now because RRC and RR will be hanging
    >Activation cause is None
    >If GTOW CCO is not in progress, then IHO is still in progress
    >>Cannot handle as RR is already sent a CNF
  */
  if((RRC_MODE_INTERRAT_IN_PROGRESS == rrcmcm_get_rrc_mode()) &&
      (RRC_CSP_CELL_SELECTION_SCAN == rrc_csp_int_data.curr_scan))
  {
    if(rrcmcm_act_cause == RRCMCM_INTERRAT_HANDOVER_GTOW)
    {
      WRRC_MSG0_HIGH("Activation IND sent to NAS for GTOW HO. Wait for RSP from NAS");
      rrc_csp_int_data.waiting_for_activation_rsp = TRUE;
      handle_ind_at_csp = FALSE;
    }
    else if(rrcmcm_act_cause == RRCMCM_INTERRAT_CC_ORDER_GTOW)
    {
      WRRC_MSG0_HIGH("Activation IND sent to NAS for GTOW CCO. Wait for RSP from NAS");
      rrc_csp_int_data.waiting_for_activation_rsp = TRUE;
      handle_ind_at_csp = FALSE;
    }
    else if(rrcmcm_act_cause == RRCMCM_INTERRAT_CC_ORDER_WTOG_FAILED)
    {
      WRRC_MSG0_HIGH("Activation IND sent to NAS for WTOG CCO failure. Wait for RSP from NAS");
      rrc_csp_int_data.waiting_for_activation_rsp = TRUE;
      handle_ind_at_csp = FALSE;
    }
    else if(!rrccho_is_gtow_pcco_in_progress() && !rrciho_is_gtow_ho_active())
    {
      WRRC_MSG0_HIGH("GTOW HO CNF sent to RR. Activation Ind not sent out yet. Wait for RSP from NAS");
      rrc_csp_int_data.waiting_for_activation_rsp = TRUE;
      handle_ind_at_csp = FALSE;
    }
  }
   
  if(ind_can_be_handled && handle_ind_at_csp)
  {
    switch(rrc_csp_substate)
    {
      case RRCCSP_WT_SUSPEND_MODE_CHANGE_CNF:
      case RRCCSP_WT_RESPONSE_FROM_RR:
      case RRCCSP_SUIT_CELL_WT_ACTIVATION_RSP:
      case RRCCSP_ACCEPT_CELL_WT_ACTIVATION_RSP:
      case RRCCSP_WT_RR_ABORT_CNF:
      case RRCCSP_WT_IDLE_DETACHED_MODE_CHANGE_CNF:
      case RRCCSP_WT_LOWER_LAYER_DEACT_CNF:
      case RRCCSP_WT_STOP_MODE_CHANGE_CNF:
        ind_can_be_handled = FALSE;
        WRRC_MSG1_HIGH("Cannot handle initiate cell selection in substate %d",rrc_csp_substate);
        break;
      default:
        break;
    }
    if(ind_can_be_handled && handle_ind_at_csp)
    {
      switch(rrc_csp_int_data.curr_scan)
      {
        case RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN:
        case RRC_CSP_GTOW_BPLMN_MANUAL_SCAN:
          /*Stop corresponding timers and initiate change mode to inactive*/
          rrctmr_stop_timer(RRCTMR_BPLMN_SRCH_TIMER);
          rrc_csp_int_data.rrc_rr_plmn_srch_cnf.srch_done   = FALSE;
          rrc_csp_int_data.rrc_rr_plmn_srch_cnf.hplmn_found = FALSE;
          rrccsp_send_mode_change_req_to_mcm(RRC_MODE_INACTIVE);
          rrc_csp_substate = RRCCSP_WT_STOP_MODE_CHANGE_CNF;
          break;
  
        case RRC_CSP_GSM_TO_WCDMA_REDIRECTION_SCAN:
          /*Stop timers if any running and initiate change mode to inactive*/
          rrctmr_stop_timer(RRCTMR_GTOW_REDIRECTION_WAIT_TIMER);
          rrctmr_stop_timer(RRCTMR_GTOW_REDIRECTION_LFS_TIMER);
        case RRC_CSP_GSM_TO_WCDMA_CELL_RESELECTION_SCAN:
          if(RRC_MODE_INTERRAT_IN_PROGRESS == rrcmcm_get_rrc_mode())
          {
            rrccsp_send_mode_change_req_to_mcm(RRC_MODE_INACTIVE);
            rrc_csp_substate = RRCCSP_WT_STOP_MODE_CHANGE_CNF;
          }
          break;
  
        case RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN:
        case RRC_CSP_WTOW_BPLMN_MANUAL_SCAN:
        case RRC_CSP_WTOG_BPLMN_AUTOMATIC_SCAN:
        case RRC_CSP_WTOG_BPLMN_MANUAL_SCAN:
          rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_ABORT,TRUE,FALSE);
        case RRC_CSP_PLMN_LIST_SCAN:
          release_channels_and_update_state = TRUE;
          break;

        case RRC_CSP_CELL_RESELECTION_SCAN:
        case RRC_CSP_WCDMA_TO_GSM_CELL_RESELECTION_SCAN:
          rrccsp_reset_reselection_data();
        case RRC_CSP_CELL_SELECTION_SCAN:
        case RRC_CSP_OUT_OF_SERVICE_AREA_IN_IDLE_STATE_SCAN:
        case RRC_CSP_LEAVING_CONN_MODE_SCAN:
        case RRC_CSP_OUT_OF_SERVICE_AREA_IN_CONNECTING_STATE_SCAN:
        case RRC_CSP_INTER_RAT_REDIRECTION_SCAN:
        case RRC_CSP_INTER_FREQ_REDIRECTION_SCAN:
          release_channels_and_update_state = TRUE;
          break;
        case RRC_CSP_CELL_DCH_TO_CELL_FACH_SCAN:
          rrctmr_stop_timer(RRCTMR_DCH_FACH_CELL_SELECTION_TIMER); 
          release_channels_and_update_state = TRUE;
          break;
        case RRC_CSP_CELL_DCH_TO_CELL_PCH_SCAN:
        case RRC_CSP_CELL_DCH_TO_URA_PCH_SCAN:
          rrctmr_stop_timer( RRCTMR_DCH_PCH_CELL_SELECTION_TIMER);
          release_channels_and_update_state = TRUE;
          break;
        case RRC_CSP_CELL_FACH_TO_CELL_FACH_SCAN:
          rrctmr_stop_timer(RRCTMR_FACH_TO_FACH_PCH_CELL_SELECTION_TIMER);
          release_channels_and_update_state = TRUE;
          break;
        case RRC_CSP_CELL_FACH_TO_CELL_PCH_SCAN:
        case RRC_CSP_CELL_FACH_TO_URA_PCH_SCAN:
          release_channels_and_update_state = TRUE;
          rrctmr_stop_timer(RRCTMR_FACH_TO_FACH_PCH_CELL_SELECTION_TIMER);
          break;
        case RRC_CSP_OUT_OF_SERVICE_AREA_SCAN:
          rrctmr_stop_timer(RRCTMR_CONN_MODE_OOS_INITIAL_NO_DS_TIMER);
          if(!rrc_csp_int_data.oos_conn_mode_ds_tmr_expd)
          {
            /*
              WCDMA was in deep sleep when MDSP halt happened, after recovery it moved to IDLE
              will not be able to handle wake up request, do not send connected mode wake up request
              to WL1
            */
            WRRC_MSG0_HIGH("WCDMA was in deep sleep");
            rrctmr_stop_timer(RRCTMR_CONN_MODE_OOS_DS_TIMER);
            rrc_csp_int_data.oos_conn_mode_ds_tmr_expd = TRUE;
          }
#ifdef FEATURE_OUT_OF_SERVICE_ENHANCEMENT
          rrctmr_stop_timer(RRCTMR_CONN_MODE_OOS_TIMER);
#endif
          release_channels_and_update_state = TRUE;
          break;
        default:
          WRRC_MSG1_HIGH("Cannot handle scan %d ",rrc_csp_int_data.curr_scan);
          ind_can_be_handled = FALSE;
          break;
      }
    }
  }
  if(ind_can_be_handled && (handle_ind_at_csp || release_channels_and_update_state))
  {
    /*Update CCM with cell loss*/
    rrc_ccm_update_with_cell_loss();
    if(release_channels_and_update_state)
    {
        rrc_csp_substate = rrccsp_rel_chls_and_go_to_idle();
    }
    if((rrc_get_state() == RRC_STATE_DISCONNECTED) ||
        (rrc_get_state() == RRC_STATE_CONNECTING))
    {
      /*Initialize RCE to make sure it isnt stuck*/
      rrcrce_force_initialize(FALSE);
    }
    /*Initialize the SIB event*/
    rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_OOS);
  }
  else if(ind_can_be_handled)
  {
    WRRC_MSG0_HIGH("MDSP halt not handled at CSP");
  }
  if(!ind_can_be_handled)
  {
    ERR_FATAL("Cannot handle MDSP halt recovery",0,0,0);
  }
  else
  {
    /*
      Send Response to the pending commands to NAS.
      Had service request was bending, then when sending MM cmd it is taken care.
      So check for pending list request
    */
     if(rrc_csp_int_data.pending_type == RRC_CSP_PLMN_LIST_REQ_PENDING)
    {
      rrcmcm_send_plmn_list_cnf_with_failure(
        rrc_csp_int_data.pending_plmn_list_req_data.network_select_mode,
        rrc_csp_int_data.pending_plmn_list_req_data.trans_id,
        rrc_csp_int_data.pending_plmn_list_req_data.service_search
        );
    }
  }
}

/*===========================================================================

FUNCTION rrccsp_handle_activation_rsp_for_mdsp_halt

DESCRIPTION 
    This function handles activation response from NAS
    when mDSP halt recovery is pending at CSP.

DEPENDENCIES
    None.

RETURN VALUE
    None.

===========================================================================*/
void rrccsp_handle_activation_rsp_for_mdsp_halt()
{
  WRRC_MSG0_HIGH("Act resp from NAS, RRC to handle mDSP halt.");
  /*Update CCM with cell loss*/
  rrc_ccm_update_with_cell_loss();
  rrc_csp_substate = rrccsp_rel_chls_and_go_to_idle();
  
  if((rrc_get_state() == RRC_STATE_DISCONNECTED) ||
      (rrc_get_state() == RRC_STATE_CONNECTING))
  {
    /*Initialize RCE to make sure it isnt stuck*/
    rrcrce_force_initialize(FALSE);
  }
  /*Initialize the SIB event*/
  rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_OOS);
  rrc_csp_int_data.waiting_for_activation_rsp = FALSE;
}

/*===========================================================================

FUNCTION rrccsp_is_rrc_waiting_for_act_rsp_to_handle_mdsp_halt

DESCRIPTION 
    This function returns the status whether CSP is waiting for
    activation responce from NAS, to start mDSP halt recovery.

DEPENDENCIES
    None.

RETURN VALUE
    boolean.

===========================================================================*/
boolean rrccsp_is_rrc_waiting_for_act_rsp_to_handle_mdsp_halt()
{
  WRRC_MSG1_HIGH("waiting_for_activation_rsp = %d.", rrc_csp_int_data.waiting_for_activation_rsp);
  return (rrc_csp_int_data.waiting_for_activation_rsp);
}
#endif

#ifdef FEATURE_FEMTO_CSG
/*===========================================================================

FUNCTION rrccsp_construct_plmn_list_for_csg_asf

DESCRIPTION 
    Generates list of PLMNs to be included in ASF BPLMN request

DEPENDENCIES
    None.

RETURN VALUE
    boolean.

===========================================================================*/
static void rrccsp_construct_plmn_list_for_csg_asf(rrc_plmn_list_req_type *plmn_list_req, 
#ifdef FEATURE_LTE_TO_WCDMA
              boolean search_on_lte, 
#endif
              boolean search_on_wcdma )
{
  int8 i,j;
  boolean duplicate_plmn = FALSE;
  rrc_plmn_identity_type serving_plmn;
  rrc_int_cell_id_type serving_cell_id;
  
  plmn_list_req->band_pref = rrc_csp_int_data.band_pref;
  plmn_list_req->dual_mode = FALSE;
  plmn_list_req->network_select_mode = SYS_NETWORK_SELECTION_MODE_AUTOMATIC;
  plmn_list_req->service_search = SYS_SERVICE_SEARCH_BACKGROUND_AUTOMATIC;
  plmn_list_req->plmn_list.length = 0;

  if(rrc_ccm_get_serv_plmn_cellid(&serving_cell_id,&serving_plmn) == RRC_CELL_LOSS_NO_NEW_CELL)
  {
    WRRC_MSG0_ERROR("CSG: This is not expected");
    return;
  }

  for(i=0 ; i<rrc_csg_white_list.length ; i++)
  {
    duplicate_plmn = FALSE;
    if(rrc_bcch_and_nas_plmns_match(serving_plmn,
         mmumts_convert_nas_plmn_id_to_rrc_plmn_id(rrc_csg_white_list.csg_list[i].plmn_id)) == FALSE)
    {
      if(rrccsp_check_for_eplmn(rrc_csg_white_list.csg_list[i].plmn_id) == FALSE)
      {
        continue;
      }
    }
    for(j=0 ; j < plmn_list_req->plmn_list.length ; j++)
    {
      if(sys_plmn_match(plmn_list_req->plmn_list.info[j].plmn, rrc_csg_white_list.csg_list[i].plmn_id))
      {
        duplicate_plmn = TRUE;
        break;
      }
    }

    if(!duplicate_plmn)
    {
#ifdef FEATURE_LTE_TO_WCDMA
      if(search_on_lte)
      {
        plmn_list_req->plmn_list.info[plmn_list_req->plmn_list.length].plmn = rrc_csg_white_list.csg_list[i].plmn_id;
        plmn_list_req->plmn_list.info[plmn_list_req->plmn_list.length++].rat = SYS_RAT_LTE_RADIO_ACCESS;
      }
#endif
      if(search_on_wcdma)
      {
        plmn_list_req->plmn_list.info[plmn_list_req->plmn_list.length].plmn = rrc_csg_white_list.csg_list[i].plmn_id;
        plmn_list_req->plmn_list.info[plmn_list_req->plmn_list.length++].rat = SYS_RAT_UMTS_RADIO_ACCESS;
      }
    }
  }
  
  plmn_list_req->rat_pri_list_info.num_items = 0;

  if(search_on_wcdma)
  { 
    plmn_list_req->rat_pri_list_info.priority_list_info[plmn_list_req->rat_pri_list_info.num_items].acq_sys_mode = SYS_SYS_MODE_WCDMA;
#ifdef LTE_BAND_NUM
    plmn_list_req->rat_pri_list_info.priority_list_info[plmn_list_req->rat_pri_list_info.num_items].band_cap.chgwt_band_cap = rrc_csp_int_data.band_pref;
#else
    plmn_list_req->rat_pri_list_info.priority_list_info[plmn_list_req->rat_pri_list_info.num_items].band_cap = rrc_csp_int_data.band_pref;
#endif
    plmn_list_req->rat_pri_list_info.num_items++;
  }

#ifdef FEATURE_LTE_TO_WCDMA
  if (search_on_lte)
  {
    plmn_list_req->rat_pri_list_info.priority_list_info[plmn_list_req->rat_pri_list_info.num_items].acq_sys_mode = SYS_SYS_MODE_LTE;
#ifdef LTE_BAND_NUM
    plmn_list_req->rat_pri_list_info.priority_list_info[plmn_list_req->rat_pri_list_info.num_items].band_cap.lte_band_cap = rrccsp_get_lte_band_pref();
    memset(&rrc_csp_int_data.bplmn_lte_band_pref, 0, sizeof(sys_lte_band_mask_e_type));
#else
    plmn_list_req->rat_pri_list_info.priority_list_info[plmn_list_req->rat_pri_list_info.num_items].band_cap = rrccsp_get_lte_band_pref();
    rrc_csp_int_data.bplmn_lte_band_pref = 0;
#endif
    plmn_list_req->rat_pri_list_info.num_items++;
  }
#endif
}

/*===========================================================================

FUNCTION rrccsp_handle_csg_asf_srch_timer_expiry

DESCRIPTION 
    This function returns the whether ASF search needs to be performed or not.

DEPENDENCIES
    None.

RETURN VALUE
    boolean.

===========================================================================*/
static void rrccsp_handle_csg_asf_srch_timer_expiry(rrc_cmd_type  *cmd_ptr)
{
  boolean perform_asf = TRUE;
  boolean restart_timer = TRUE;
  rrc_mode_e_type  rrc_mode = rrcmcm_get_rrc_mode();
  rrc_state_e_type  rrc_state = rrc_get_state();
  rrc_cmd_type *cmd;
  source_cell_info_type w_macro;
#ifdef FEATURE_LTE_TO_WCDMA
  boolean search_on_lte;
#endif
  boolean search_on_wcdma = FALSE;

  if(rrc_mode != RRC_MODE_ACTIVE)
  {
    perform_asf = FALSE;
    WRRC_MSG1_HIGH("CSG: Can not perform ASF in rrc mode %d", rrc_mode);
    if(rrc_mode == RRC_MODE_INACTIVE)
      restart_timer = FALSE;
  }
  /* DO not perform ASF when camped for limited service  */
  else if(rrc_csp_int_data.curr_type_acq == RRC_CSP_ANY_PLMN)
  {
    perform_asf = FALSE;
    WRRC_MSG0_HIGH("CSG: Can not perform ASF in acceptable cell state.");
    /*We can be in acceptable state when manual PLMN in progress. Restart timer in that cases*/
    if(WTOW_SEARCH_STOP == rrc_csp_bplmn_srch_in_progress())
    {
      restart_timer = FALSE;
    }
  }
  /* Do not handle in connected mode states */
  else if((rrc_state == RRC_STATE_CONNECTING) ||
          (rrc_state == RRC_STATE_CELL_DCH) ||
          (rrc_state == RRC_STATE_CELL_FACH))
  {
    perform_asf = FALSE;
    restart_timer = FALSE;
    WRRC_MSG1_HIGH("CSG: Can not perform ASF in rrc state %d", rrc_state);
  }
  /* Do not handle in non-initial MCM substate. */
  else if(RRCMCM_INITIAL != rrcmcm_get_substate())
  {
    perform_asf = FALSE;
    WRRC_MSG1_HIGH("CSG: Can not perform ASF in MCM substate %d", rrcmcm_get_substate());
  }
  /* this is added for the case where suspend request has not yet reached MCM,
     or resume cnf has not reached CSP, so RRC mode is will be ACTIVE for both */
  else if((rrc_csp_substate == RRCCSP_WT_SUSPEND_MODE_CHANGE_CNF) ||
          (rrc_csp_substate == RRCCSP_WT_RESUME_MODE_CHANGE_CNF))
  {
    perform_asf = FALSE;
    WRRC_MSG1_HIGH("CSG: Can not perform ASF when W is getting suspended or resuming. CSP sstate %d", rrc_csp_substate);
  }
  /* ASF is low priority as compared to normal BPLMN searches */
  else if((WTOW_SEARCH_STOP != rrc_csp_bplmn_srch_in_progress()) ||
           (rrc_csp_int_data.csg_asf_srch_in_progress))
  {
    perform_asf = FALSE;
    WRRC_MSG1_HIGH("CSG: Can not perform ASF when NAS requested BPLMN search/ASF is in progress. Cur_scan %d", rrc_csp_int_data.curr_scan);
  }
  else if(RRC_NOT_CAMPED_ON == rrc_ccm_get_curr_camping_status(RRC_PROCEDURE_CSP)) /* May need to restart timer for temp search procedures */
  {
    perform_asf = FALSE;
    restart_timer = FALSE;
    WRRC_MSG1_HIGH("CSG: Can not perform ASF when UE not camped on. Cur_scan %d", rrc_csp_int_data.curr_scan);
  }
#ifdef FEATURE_WRLF_SYSTEM_SEL
  else if(RRC_IS_CONN_MODE_OOS_SRCH_IN_PROGRESS())
  {
    perform_asf = FALSE;
    WRRC_MSG1_HIGH("CSG: Can not perform ASF when conn OOS srch in progress.", rrc_csp_int_data.curr_scan);
  }
#endif
  else if(!rrccsp_is_csg_white_empty())
  {
    perform_asf = FALSE;
    restart_timer = FALSE;
    WRRC_MSG0_HIGH("CSG: White list is empty cannot perform ASF");
  }
  else if(rrc_ccm_get_curr_camped_csg_id() != SYS_CSG_ID_INVALID)
  {
    perform_asf = FALSE;
    restart_timer = FALSE;
    WRRC_MSG0_HIGH("CSG: Do not perform ASF as we are camped on a femto");
  }
  else
  {
#ifdef FEATURE_LTE_TO_WCDMA
    w_macro.frequency     = rrc_ccm_get_curr_camped_freq();
    w_macro.phy_cell_id   = rrc_ccm_get_curr_camped_psc();
    w_macro.cell_identity = rrc_ccm_get_curr_camped_cell_id();
    w_macro.plmn          = mmumts_convert_rrc_plmn_id_to_nas_plmn_id(rrc_ccm_get_curr_camped_plmn());
    w_macro.csg_id        = SYS_CSG_ID_INVALID;

    /*If we want list of fingerprinted LTE CSG cells. Pass an array to second arguement*/
     search_on_lte = lte_rrc_csg_get_fp_lcsg_info_for_w(&w_macro,NULL);
     search_on_wcdma = rrccsp_check_wcdma_fp_info();

     if(rrcmcm_is_lte_mode_enabled() && search_on_lte)
     {
       search_on_lte = TRUE;

       /* This is done to prevent an issue where MEAS REQ is sent to WL1 when W is trying to resume
          after ASF for LTE only FP entry is completed */	   
       search_on_wcdma = TRUE;
     }
     else
     {
       search_on_lte = FALSE;
     }
#endif

    if((FALSE == search_on_wcdma) 
#ifdef FEATURE_LTE_TO_WCDMA
      && (FALSE == search_on_lte)
#endif
    )
    {
      WRRC_MSG0_HIGH("CSG: No FPed CSG cells available either in LTE or WCDMA");
      return;
    }

    /* Perform ASF and send PLMN_LIST_REQ to CSP substate processing */
    cmd = (rrc_cmd_type *)rrc_malloc(sizeof(rrc_cmd_type));
    cmd->cmd_hdr.cmd_id = RRC_PLMN_LIST_REQ;
    rrccsp_construct_plmn_list_for_csg_asf(&cmd->cmd.plmn_list_req, 
#ifdef FEATURE_LTE_TO_WCDMA
                                            search_on_lte,
#endif
                                            search_on_wcdma);

    /* Restart the periodic ASF timer */
    rrctmr_start_timer(RRCTMR_CSG_ASF_SRCH_TIMER, (wcdma_asf_timer_nv)*60000);

    memset(&rrc_csp_int_data.temp_csg_list,0,sizeof(rrc_csp_temp_csg_cell_list));
    if(cmd->cmd.plmn_list_req.plmn_list.length != 0)
    {
      rrccsp_log_macro_fp_info(W_ASF_RAT_WCDMA);
      rrc_csp_int_data.csg_asf_srch_in_progress = TRUE;
      rrc_cell_selection_procedure(cmd);
    }
    rrc_free(cmd);
  }



  /* Restart ASF timer for below scenarios even if ASF search is not performed now */
  if(!perform_asf && restart_timer)
  {

    /* Starting a 10s timer for the case where ASF cannot be handled */

    rrctmr_start_timer(RRCTMR_CSG_ASF_SRCH_TIMER, RRC_CSG_DISCONN_TRANS_ASF_SRCH_TIMER_IN_MS);
  }

}
#endif

/*===========================================================================

FUNCTION   RRC_CSP_CLEANUP_NEEDED_BPLMN_DATA

DESCRIPTION

  This function cleans the needed BPLMN data after sending RRC_BPLMN_SUSPEND_REQ to CSP
  to suspend the ongoing Manual or Automatic Background PLMN Search.
  
DEPENDENCIES

  None.
 
RETURN VALUE

  None.
 
SIDE EFFECTS

  None.

===========================================================================*/


void rrc_csp_cleanup_needed_bplmn_data(void)
{
  WRRC_MSG1_HIGH("bplmn_new_srch is %d",rrc_csp_int_data.bplmn_new_srch);
  rrc_csp_int_data.bplmn_new_srch = TRUE;
}
/* =======================================================================
**       Event Handler for Cell Selection Procedure
** ======================================================================= */

/*===========================================================================

FUNCTION          RRC_CELL_SELECTION_PROCEDURE

DESCRIPTION       This is the entry point for Cell Selection procedure. All
                  events for CSP come to this function from RRC Dispatcher.
                  Depending on the substate of Cell Selection Procedure, it
                  calls the corresponding substate handler. It also maintains
                  the CSP substate and updates it with the retuned value from
                  CSP substate handler.

DEPENDENCIES
                  None

RETURN VALUE
                  None

SIDE EFFECTS
                  None

===========================================================================*/
void  rrc_cell_selection_procedure (rrc_cmd_type  *cmd_ptr)
{
  rrclog_wcdma_to_gsm_reselection_end_event_type wtog_resel_end_event;
   sys_detailed_plmn_list_s_type available_plmn_list;
#ifdef FEATURE_WCDMA_TO_LTE  	
  lte_irat_plmn_srch_rsp_s *plmn_srch_rsp;
#endif
#ifdef FEATURE_GAN_3G_ROVE_OUT_ONLY
  #error code not present
#endif
  int i;
 boolean nw_sel_mode_reset_ind_valid = FALSE;
  WRRC_MSG1_HIGH_OPT("function rrc_cell_selection_procedure is called in rrc_csp_substate rrc_csp_substate_e_type_value%d",rrc_csp_substate);
  rrc_crash_debug_log_proc_substates(RRC_PROCEDURE_CSP, rrc_csp_substate, cmd_ptr);

#ifdef FEATURE_DUAL_SIM
  if(cmd_ptr->cmd_hdr.cmd_id == RRC_DUAL_SIM_WRM_UNLOCK_BY_TIMER_EXP_IND)
  {
    if(rrc_csp_substate != RRCCSP_CAMPED_SUIT_CELL)
    {
      /*Send QTA cancel indication for unlock by timer expiry ignore cases
        Except for preemption case where idle request will be sent anyways*/
      if(!(((rrc_csp_substate == RRCCSP_CELL_SEL_WT_SIB)||
          (rrc_csp_substate == RRCCSP_CELL_SEL_WT_SIB_PENDING)||
          (rrc_csp_substate == RRCCSP_ACCEPT_CELL_RESELECT_WT_SIB)||
          (rrc_csp_substate == RRCCSP_SUIT_CELL_RESELECT_WT_SIB))&&
          (WCDMA_RRC_IDLE_FEATURES(RRC_QTA_SIB_READ))))
      {
        WRRC_MSG1_HIGH("DSIM_TUNEAWAY: Ignored RRC_DUAL_SIM_WRM_UNLOCK_BY_TIMER_EXP_IND in state %d",rrc_csp_substate);
        if(wrm_is_next_tuneaway_qta())
        {
          wl1_qta_cancel_ind();
        }
        return;
      }
    }
    if(DS_Immediate_preempt_waiting_for_init_cell_sel || rrc_csp_int_data.preemption_handling_in_progress)
    {
      WRRC_MSG0_HIGH("DSIM_TUNEAWAY: Ignored RRC_DUAL_SIM_WRM_UNLOCK_BY_TIMER_EXP_IND as immediate pre-emption in progress");
      return;
    }
  }
#endif

#ifdef FEATURE_WCDMA_HANDLE_MDSP_HALT
  if((RRC_INITIATE_CELL_SELECTION_IND == cmd_ptr->cmd_hdr.cmd_id) &&
     (RRC_CELL_SEL_ON_MDSP_HALT == cmd_ptr->cmd.initiate_cell_sel_ind.cause))
  {
    WRRC_MSG0_HIGH("Initiate cell selection from MDSP halt");
    rrc_csp_handle_cell_selection_for_mdsp_halt();
    return;
  }
#endif

  /* Call in the CSP substate handler to process the event
   * Update the CSP substate with the returned value from the substate handler
   */
#ifdef FEATURE_WCDMA_TO_LTE
  if(cmd_ptr->cmd_hdr.cmd_id == RRC_LTE_RRC_CMD)
  {
    if(cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.msg_hdr.id == WCDMA_RRC_LTE_GET_PLMN_PRTL_RESULTS_REQ)
    {
      WRRC_MSG0_HIGH("received WCDMA_RRC_LTE_GET_PLMN_PRTL_RESULTS_REQ and processing");
      rrccsp_send_lte_interrat_plmn_srch_rsp(TRUE);
      return;
    }
    else if(cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.msg_hdr.id == LTE_RRC_WCDMA_PLMN_SRCH_RSP)
    {
      WRRC_MSG0_HIGH("WTOL: LTE_RRC_WCDMA_PLMN_SRCH_RSP from LTE RRC");
      plmn_srch_rsp = &(cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.lte_rrc_wcdma_plmn_srch_rsp);
      /* If partial results are received from LTE and we are not waiting for them, then ignore the results */
      if((plmn_srch_rsp->partial_srch) &&
         (rrc_csp_int_data.send_partial_results == FALSE) &&
         (rrc_csp_int_data.send_prtl_results_from_lte_due_to_guard_timer_expiry == FALSE))
      {
        WRRC_MSG0_HIGH("WTOL: patial results are received from LTE, but W is not waitng for them. Ignore the results");
        return;
      }
      if(plmn_srch_rsp->partial_srch)
      {
        WRRC_MSG0_HIGH("received partial results");
        for(i=0; i < plmn_srch_rsp->available_plmn_list.length; ++i)
        {
          rrc_csp_wtog_bplmn_int_data.lte_plmn_list.plmn[i].plmn = 
               mmumts_convert_nas_plmn_id_to_rrc_plmn_id(
               plmn_srch_rsp->available_plmn_list.info[i].plmn);
          MSG_HIGH("%d-%d, LTE RAT %d", 
                    RRC_CSP_GET_INT_MCC(rrc_csp_wtog_bplmn_int_data.plmn_list.plmn[i].plmn),
                    RRC_CSP_GET_INT_MNC(rrc_csp_wtog_bplmn_int_data.plmn_list.plmn[i].plmn), 
                    plmn_srch_rsp->available_plmn_list.info[i].rat);
          rrc_csp_wtog_bplmn_int_data.lte_plmn_list.plmn[i].rat = 
                    plmn_srch_rsp->available_plmn_list.info[i].rat;
          rrc_csp_wtog_bplmn_int_data.lte_plmn_list.plmn[i].service_capability = 
                    plmn_srch_rsp->available_plmn_list.info[i].plmn_service_capability;
          rrc_csp_wtog_bplmn_int_data.lte_plmn_list.plmn[i].signal_quality = 
                    plmn_srch_rsp->available_plmn_list.info[i].signal_quality;
          rrc_csp_wtog_bplmn_int_data.lte_plmn_list.plmn[i].signal_strength = 
                    plmn_srch_rsp->available_plmn_list.info[i].signal_strength;
        }
        rrc_csp_wtog_bplmn_int_data.wtol_plmns_found = 
                    plmn_srch_rsp->available_plmn_list.length;
        rrccsp_update_irat_detected_frequencies(&plmn_srch_rsp->detected_frequency_list);
        /* If partial results are received due to the partial plmn request sent after guard timer expiry,
           then send abort req to LTE */
        if(rrc_csp_int_data.send_prtl_results_from_lte_due_to_guard_timer_expiry == TRUE)
        {
          WRRC_MSG1_HIGH("WTOW Guard Srch Tmr exprd in CSP sstate %d",rrc_csp_substate );
          /* If WTOG BPLMN search is in progress then send abort request to GSM */
          if(rrc_csp_int_data.curr_scan == RRC_CSP_WTOG_BPLMN_MANUAL_SCAN)
          {
            
            rrccsp_send_irat_bplmn_abort_req();
            rrc_csp_substate = RRCCSP_WT_RR_ABORT_CNF;
          }
          /* Else, cleanup BPLMN state */
          else
          {
            WRRC_MSG1_HIGH("cleaning bplmn substate %d",rrc_csp_substate );
            rrccsp_cleanup_bplmn_state();
          }
          rrc_csp_int_data.send_prtl_results_from_lte_due_to_guard_timer_expiry = FALSE;
          return;
        }
        /* send the partial results to MM */
        rrc_csp_bplmn_send_mm_plmn_list_cnf_cmd(WTOW_SEARCH_PARTIAL, rrc_csp_int_data.bplmn_trans_id);
        return;
      }
    }
  }
#endif  
  if(cmd_ptr->cmd_hdr.cmd_id == RRC_STATE_CHANGE_IND)
  {
    if(!rrc_csp_int_data.bplmn_guard_srch_tmr_expired && (!bplmn_data_saved))
    {
      if((((cmd_ptr->cmd.state_change_ind.previous_state == RRC_STATE_CELL_PCH) ||
           (cmd_ptr->cmd.state_change_ind.previous_state == RRC_STATE_URA_PCH)) &&
          ((cmd_ptr->cmd.state_change_ind.new_state == RRC_STATE_CELL_DCH) ||
           (cmd_ptr->cmd.state_change_ind.new_state == RRC_STATE_CELL_FACH)))||
         ((cmd_ptr->cmd.state_change_ind.previous_state== RRC_STATE_DISCONNECTED) &&
          (cmd_ptr->cmd.state_change_ind.new_state == RRC_STATE_CONNECTING))
        )
      {
        WRRC_MSG1_HIGH("Save the BPLMN data now. bplmn_data_saved is %d",bplmn_data_saved);
        /* Save BPLMN data here and call a specialized clean up function which is going to clean the needed variables for BPLMN */
        prev_rrc_csp_curr_select_data = rrc_csp_curr_select_data;
        bplmn_data_saved = TRUE;
        bplmn_new_srch = rrc_csp_int_data.bplmn_new_srch;
        rrc_csp_cleanup_needed_bplmn_data();
      }
    }
  }

#if defined (FEATURE_WCDMA_TO_LTE) || defined (FEATURE_LTE_TO_WCDMA)
if((cmd_ptr->cmd_hdr.cmd_id == RRC_LTE_RRC_CMD) && 
   (cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.msg_hdr.id == WCDMA_RRC_LTE_PLMN_SRCH_SUSPEND_IND)
  )
  {
    WRRC_MSG0_HIGH("WCDMA_RRC_LTE_PLMN_SRCH_SUSPEND_IND received from LTE RRC");
    if(rrctmr_get_remaining_time(RRCTMR_BPLMN_SRCH_TIMER) > 0)
    {
      rrc_cmd_type *cmd_ptr;
      rrctmr_stop_timer(RRCTMR_BPLMN_SRCH_TIMER);
      /* Get a RRC internal command buffer */
      if((cmd_ptr = rrc_get_int_cmd_buf()) != NULL)
      {
         /* Fill in the command id  */
        cmd_ptr->cmd_hdr.cmd_id = RRC_BPLMN_SRCH_TIMER_EXPIRED_IND;
        /* Put the command in the internal queue */
        rrc_put_int_cmd( cmd_ptr );
        WRRC_MSG0_HIGH("RRC_BPLMN_SRCH_TIMER_EXPIRED_IND posted to internal cmd queue");
      }
      return;
    }
  }
#endif

#ifdef FEATURE_FEMTO_CSG
  if(cmd_ptr->cmd_hdr.cmd_id == RRC_CSG_ASF_SRCH_TIMER_EXPIRY_IND)
  {
    rrccsp_handle_csg_asf_srch_timer_expiry(cmd_ptr);
    return;
  }

/*Add finger printing information only for W CSG to L macro reselection*/
if((cmd_ptr->cmd_hdr.cmd_id == RRC_LTE_RRC_CMD) && 
   (cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.msg_hdr.id == LTE_RRC_WCDMA_RESEL_RSP)
  )
  {
    if((cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.lte_rrc_wcdma_resel_rsp.lte_cell_info.csg_id == SYS_CSG_ID_INVALID)&&
       (cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.lte_rrc_wcdma_resel_rsp.w_cell_info.csg_id != SYS_CSG_ID_INVALID))
    {
      rrc_csp_acq_entry_type femto_info;

      /*Copy LTE macro information*/
      rrc_csp_int_data.last_csg_rat = RRC_CSG_LTE;
      rrc_csp_int_data.fp_macro.freq = cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.lte_rrc_wcdma_resel_rsp.lte_cell_info.frequency;
      rrc_csp_int_data.fp_macro.pci = cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.lte_rrc_wcdma_resel_rsp.lte_cell_info.phy_cell_id;
      rrc_csp_int_data.fp_macro.cell_id = cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.lte_rrc_wcdma_resel_rsp.lte_cell_info.cell_identity;
      rrc_csp_int_data.fp_macro.plmn = mmumts_convert_nas_plmn_id_to_rrc_plmn_id(
                                         cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.lte_rrc_wcdma_resel_rsp.lte_cell_info.plmn);

      /*Copy W CSG information*/
      femto_info.freq    = cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.lte_rrc_wcdma_resel_rsp.w_cell_info.frequency;
      femto_info.scr_code     = cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.lte_rrc_wcdma_resel_rsp.w_cell_info.phy_cell_id;
      femto_info.cell_id = cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.lte_rrc_wcdma_resel_rsp.w_cell_info.cell_identity;
      femto_info.csg_id  = cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.lte_rrc_wcdma_resel_rsp.w_cell_info.csg_id;
      femto_info.plmn_id    = mmumts_convert_nas_plmn_id_to_rrc_plmn_id(
                             cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.lte_rrc_wcdma_resel_rsp.w_cell_info.plmn);

      /*Establishes finger print*/
      rrccsp_add_macro_fp_info_in_acq_db(&femto_info);
    }
    return;
  }
#endif
  if((cmd_ptr->cmd_hdr.cmd_id == RRC_LTE_RRC_CMD) &&
     (cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.msg_hdr.id == LTE_RRC_UTRA_SERVING_CELL_INFO_REQ))
  {
    lte_rrc_utra_serving_cell_info_rsp_s serving_cell_info;
    WRRC_MSG0_HIGH("LTE_RRC_UTRA_SERVING_CELL_INFO_REQ received");

    if(rrc_ccm_get_curr_camping_status(RRC_PROCEDURE_CSP) == RRC_CAMPED_ON)
    {
      serving_cell_info.utra_cell_info.rat = SYS_RAT_UMTS_RADIO_ACCESS;
      serving_cell_info.utra_cell_info.is_rat_active = TRUE;
      serving_cell_info.utra_cell_info.frequency = rrc_ccm_get_curr_camped_freq();
      serving_cell_info.utra_cell_info.phy_cell_id = rrc_ccm_get_curr_camped_psc();
      serving_cell_info.utra_cell_info.is_cell_global_id_present = TRUE;
      serving_cell_info.utra_cell_info.serving_cell_global_id.plmn_id = mmumts_convert_rrc_plmn_id_to_nas_plmn_id(rrc_ccm_get_curr_camped_plmn());
      serving_cell_info.utra_cell_info.serving_cell_global_id.cell_id = rrc_ccm_get_curr_camped_cell_id();
      MSG_HIGH("Camped on PLMN: %d-%d CELL I.D# %d",RRC_CSP_GET_INT_MCC(rrc_ccm_get_curr_camped_plmn()),
                RRC_CSP_GET_INT_MNC(rrc_ccm_get_curr_camped_plmn()), rrc_ccm_get_curr_camped_cell_id());
    }
    else
    {
     serving_cell_info.utra_cell_info.rat = SYS_RAT_UMTS_RADIO_ACCESS;
     serving_cell_info.utra_cell_info.is_rat_active = FALSE;
    }
    rrc_send_lte_cmd(&serving_cell_info.msg_hdr, LTE_RRC_UTRA_SERVING_CELL_INFO_RSP, sizeof(lte_rrc_utra_serving_cell_info_rsp_s));
    return;
  }

 /*If FirstPLMNTimer is not configured, RRC shall fallback to legacy of only providing complete results*/
  if((cmd_ptr->cmd_hdr.cmd_id == RRC_BPLMN_GUARD_SRCH_TIMER_EXPIRED_IND) &&
     (rrc_csp_int_data.bplmn_nw_sel_mode == SYS_NETWORK_SELECTION_MODE_MANUAL) &&
     (rrc_csp_int_data.bplmn_search_timer_value.FirstPLMNTimer > 0))
  {
    available_plmn_list.length=0;
#ifdef FEATURE_WCDMA_TO_LTE
    if(rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_active
    && rrc_csp_int_data.bplmn_interrat_type == RRC_CSP_INTERRAT_LTE)
    {
      /* WTOL manual search is going on. send partial plmn results req to LTE */
      lte_irat_get_plmn_prtl_results_req_s plmn_srch_req;
      rrc_send_lte_cmd(&plmn_srch_req.msg_hdr, LTE_RRC_WCDMA_GET_PLMN_PRTL_RESULTS_REQ, sizeof(lte_irat_get_plmn_prtl_results_req_s));
      rrc_csp_int_data.send_prtl_results_from_lte_due_to_guard_timer_expiry = TRUE;
      rrc_csp_int_data.send_partial_results = TRUE;
      return;
    }
    else 
#endif
    if(rrc_csp_wtog_bplmn_int_data.wtog_bplmn_srch_active
       && rrc_get_rr_inter_rat_bplmn_prtl_result(&available_plmn_list)) 
    {
      for(i=0; i < available_plmn_list.length; ++i)
      {
        rrc_csp_wtog_bplmn_int_data.plmn_list.plmn[i].plmn = 
              mmumts_convert_nas_plmn_id_to_rrc_plmn_id(
                available_plmn_list.info[i].plmn);
     
        MSG_HIGH("%d-%d, GSM RAT %d", 
                                   RRC_CSP_GET_INT_MCC(rrc_csp_wtog_bplmn_int_data.plmn_list.plmn[i].plmn),
                                   RRC_CSP_GET_INT_MNC(rrc_csp_wtog_bplmn_int_data.plmn_list.plmn[i].plmn), 
                                   available_plmn_list.info[i].rat);
     
        rrc_csp_wtog_bplmn_int_data.plmn_list.plmn[i].rat = 
                available_plmn_list.info[i].rat;
   
        rrc_csp_wtog_bplmn_int_data.plmn_list.plmn[i].service_capability = 
                available_plmn_list.info[i].plmn_service_capability;
     
        rrc_csp_wtog_bplmn_int_data.plmn_list.plmn[i].signal_quality = 
                available_plmn_list.info[i].signal_quality;
   
        rrc_csp_wtog_bplmn_int_data.plmn_list.plmn[i].signal_strength = 
                available_plmn_list.info[i].signal_strength;
      }
      
      rrc_csp_wtog_bplmn_int_data.wtog_gsm_plmns_found = 
                                  available_plmn_list.length;
    }

    rrc_csp_int_data.send_partial_results = TRUE;
  }

  switch(cmd_ptr->cmd_hdr.cmd_id)
  {
    case RRC_DEACT_REQ:
      MSG_MED( "Cmd 0x%x recvd, CSP sstate %d",
                    cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
#ifdef FEATURE_GAN_3G_ROVE_OUT_ONLY
      #error code not present
#endif
      rrccsp_preprocess_deact_req_if_necessary();
      rrccsp_process_deactivate_req( cmd_ptr );
      break;

    case RRC_MODE_CHANGE_IND:
      if(cmd_ptr->cmd.mode_change_ind.to_mode == RRC_MODE_INACTIVE && (!rrc_csp_int_data.ignore_csp_change_mode_ind))
      {
        if((rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN) ||
           (rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_MANUAL_SCAN))
        {
          WRRC_MSG0_HIGH("BPLMN:RRC_MODE_CHG_IND ignored. Handled in WT_STP_MD_CHNG_CNF");
        }
        else
        {
          if((rrc_csp_int_data.curr_scan == RRC_CSP_WCDMA_TO_GSM_CELL_RESELECTION_SCAN)
#ifdef FEATURE_WCDMA_TO_LTE
             && (rrc_csp_int_data.interrat_type == RRC_CSP_INTERRAT_GSM)
#endif
            )
          {
            /* Log EVENT_WCDMA_TO_GSM_RE_SELECTION_END */
            wtog_resel_end_event.status = 1;
            event_report_payload(EVENT_WCDMA_TO_GSM_RESELECTION_END, sizeof(wtog_resel_end_event),
                    (void *)&wtog_resel_end_event);
          }
          /* Inter Frequency Redirection Scan was aborted. Clean up its state */
          if(rrc_csp_int_data.curr_scan == RRC_CSP_INTER_FREQ_REDIRECTION_SCAN)
          {
            rrc_csp_cleanup_inter_freq_redirection_state();
          }
          /* Out of Service Area Scan */

          else if(rrc_csp_int_data.curr_scan == RRC_CSP_OUT_OF_SERVICE_AREA_SCAN)
          {
            if(!rrc_csp_int_data.oos_splmn_srch_tmr_expd)
            {
              rrctmr_stop_timer(RRCTMR_CONN_MODE_OOS_TIMER);
              rrc_csp_int_data.oos_splmn_srch_tmr_expd = TRUE;
            }

            if(!rrc_csp_int_data.oos_initial_no_deep_sleep_tmr_expd)
            {
              rrctmr_stop_timer(RRCTMR_CONN_MODE_OOS_INITIAL_NO_DS_TIMER);
              rrc_csp_int_data.oos_initial_no_deep_sleep_tmr_expd = TRUE;
            }   
          }   

          rrccsp_cleanup_bplmn_state();

          /* Invalidate entities in RRC CSP Internal data structure */
          rrc_csp_init_int_data();

          rrccsp_reset_reselection_data();

#ifdef FEATURE_EOOS
          #error code not present
#endif

        /* In case CSP waiting for state chng during WRLF do not reset CSP substate */
#ifdef FEATURE_WRLF_SYSTEM_SEL
          if(!(RRC_IS_CONN_MODE_OOS_SRCH_IN_PROGRESS() &&
                 (rrc_csp_substate == RRCCSP_CELL_SEL_WT_STATE_CHANGE)))
#endif
          {
            /* CSP goes back to NO_CELL_SELECTED state */
            rrc_csp_substate = RRCCSP_NO_CELL_SELECTED;
          }
        }
#if defined(FEATURE_WCDMA_TO_LTE) || defined (FEATURE_LTE_TO_WCDMA)
        if(LTE_RRC_DEDICATED_PRI_OWNER_WCDMA != lte_rrc_dedicated_pri_get_owner())
        {
          rrcmeas_invalidate_dedicated_priority_info();
        }
#endif
      }
      else
      {
        /* TBD - Processing for other mode changes */
        WRRC_MSG2_HIGH("Mode change to %d not supported or ignore_csp_change_mode_ind flag set %d", cmd_ptr->cmd.mode_change_ind.to_mode,rrc_csp_int_data.ignore_csp_change_mode_ind);
      }
      break;

    case RRC_MODE_CHANGE_REQ:
      rrc_csp_int_data.mode_change_reason = cmd_ptr->cmd.deact_req.deact_reason;
      /* Clear W and G ACQ info as the current values may become stale for next service search */
#ifdef FEATURE_UMTS_ACQ_CHNL_INFO_SHARING
      rrc_clear_acq_chnl_info();
      WRRC_MSG0_HIGH("Clearing GSM Acquired ARFCNs for MODE_CHANGE_REQ");
      rr_rrc_clear_acq_chnl_info_internal();
#endif

#ifdef FEATURE_OOSC_USER_ACTION
#ifdef FEATURE_OOSC_SERVICE_STATUS_UI_UPDATE
      if((rrc_csp_int_data.curr_scan == RRC_CSP_LEAVING_CONN_MODE_SCAN)&&
           (rrc_csp_int_data.prev_curr_scan == RRC_CSP_OUT_OF_SERVICE_AREA_SCAN))
      {
        WRRC_MSG0_HIGH("SVC_ST: Update UI with connected mode OOS status as FALSE");
        rrc_csp_send_svc_status_to_mm(SYS_SRV_STATUS_NONE, SYS_RAT_UMTS_RADIO_ACCESS, 0);
      }
#endif
#endif

      if(rrc_csp_int_data.curr_scan == RRC_CSP_PLMN_LIST_SCAN)
      {
        rrc_csp_send_mm_plmn_list_cnf_as_aborted(rrc_csp_int_data.bplmn_trans_id);
      }

      rrccsp_check_and_teardown_sbcch_during_bplmn();
      /* RRC gets mode change from MM for Factory Test Mode or 1X */
      /* Send CHANGE_MODE_REQ (RRC_MODE_CHANGE) to MCM and wait for the CHANGE_MODE_CNF */
      /* Store MODE CHANGE REQUEST if CSP is waiting for response from RR. This is to handle
         the scenario where back to back stop WCDMA and Mode change request are received
         when service search on G is in progress 
      */
      if(rrc_csp_int_data.stop_pending_for_wtog_abort == TRUE)
      {
        rrc_csp_int_data.pending_type = RRC_CSP_MODE_CHANGE_REQ_PENDING;
      }
      else
      {
        rrccsp_send_mode_change_req_to_mcm(RRC_MODE_CHANGE);
        rrc_csp_int_data.ignore_csp_change_mode_ind = TRUE;
        rrc_csp_substate = RRCCSP_WT_STOP_MODE_CHANGE_CNF;
      }
      break;

#ifdef FEATURE_RRC_L1_ERROR_RECOVERY_P1
    case RRC_ERR_FATAL_IND:
    if(rrc_csp_substate != RRCCSP_WT_STOP_MODE_CHANGE_CNF) 
    {
    
#if defined (FEATURE_INTERRAT_CELL_RESELECTION_GTOW) || defined (FEATURE_LTE_TO_WCDMA)
      if(rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_CELL_RESELECTION_SCAN) 
      {
        rrc_csp_int_data.interrat_reselect_failure_reason = RRC_WCDMA_CELL_NOT_SUITABLE;
        /* Send CHANGE_MODE_REQ (to Inactive) to MCM and wait for the CHANGE_MODE_CNF */
        rrccsp_send_mode_change_req_to_mcm(RRC_MODE_INACTIVE);
        rrc_csp_substate = RRCCSP_WT_STOP_MODE_CHANGE_CNF;
      }
      else
      {
        if(rrc_csp_int_data.last_mm_primitive ==  RRC_CSP_NO_EVENT_RCVD)
        {
          rrc_csp_int_data.last_mm_primitive = RRC_CSP_SRVC_IND_WITH_SRVC_SENT;
          WRRC_MSG2_ERROR("Force mm_primitive to %d, curr_scan %d",rrc_csp_int_data.last_mm_primitive,
                                                     rrc_csp_int_data.curr_scan);
        }

        /* Send NO_SERVICE to MM */
        rrc_csp_handle_no_available_freq();

        /* Re-initialize CCM */
        rrcccm_force_init();

        /* CSP goes back to NO_CELL_SELECTED state */
        rrc_csp_substate = RRCCSP_NO_CELL_SELECTED;

        /* Invalidate entities in RRC CSP Internal data structure */
        rrc_csp_init_int_data();
        rrccsp_reset_reselection_data();

#ifndef FEATURE_EOOS 
        rrc_csp_init_uniform_oos_int_data();
#endif

      }
#else

      if(rrc_csp_int_data.last_mm_primitive ==  RRC_CSP_NO_EVENT_RCVD)
      {
        rrc_csp_int_data.last_mm_primitive = RRC_CSP_SRVC_IND_WITH_SRVC_SENT;
        WRRC_MSG2_ERROR("Force mm_primitive to %d, curr_scan %d",rrc_csp_int_data.last_mm_primitive,
                                                   rrc_csp_int_data.curr_scan);
      }

      /* Send NO_SERVICE to MM */
      rrc_csp_handle_no_available_freq();

      /* Re-initialize CCM */
      rrcccm_force_init();

      /* CSP goes back to NO_CELL_SELECTED state */
      rrc_csp_substate = RRCCSP_NO_CELL_SELECTED;

      /* Invalidate entities in RRC CSP Internal data structure */
      rrc_csp_init_int_data();
      rrccsp_reset_reselection_data();

#ifndef FEATURE_EOOS
      rrc_csp_init_uniform_oos_int_data();
#endif

#endif /* FEATURE_INTERRAT_CELL_RESELECTION_GTOW */
    }
      break;

#endif /* FEATURE_RRC_L1_ERROR_RECOVERY_P1 */

    case RRC_FREQ_SCAN_TIMER_EXPIRED_IND:
      WRRC_MSG0_HIGH("Full scan timer expired");
      rrc_csp_int_data.full_scan_needed = TRUE;
      
#ifdef FEATURE_WCDMA_MULTIBAND
      rrc_csp_int_data.deep_sleep_band_scanned_mask = 0;
#endif
      break;

#ifdef FEATURE_EOOS
    #error code not present
#endif

    case RRC_DEEP_SLEEP_NO_SVC_TIMER_EXPIRED_IND:
      WRRC_MSG0_HIGH("Deep Sleep: No_Svc_Tmr Expired; DSTmrExp=TRUE");
      rrc_csp_int_data.deep_sleep_no_svc_tmr_expired = TRUE;
#ifdef FEATURE_WCDMA_MULTIBAND
      rrc_csp_int_data.deep_sleep_no_svc_band_scanned_mask = 0;
#endif
      break;


    case RRC_BPLMN_FREQ_SCAN_TIMER_EXPIRED_IND:
      WRRC_MSG0_HIGH("BPLMN Full Freq Scan Timer expired");
      rrc_csp_int_data.plmn_list_freq_scan_needed = TRUE;
      break;

    case RRC_MANUAL_PLMN_FREQ_SCAN_TIMER_EXPIRED_IND:
      WRRC_MSG0_HIGH("Manual PLMN Full Freq Scan Timer expired");
      rrc_csp_int_data.manual_plmn_list_freq_scan_needed = TRUE;
      break;



    case RRC_NW_SEL_MODE_RESET_IND:
      WRRC_MSG2_HIGH("n/w sel mode reset ind rcvd from NAS. is %d, Old %d",
                             cmd_ptr->cmd.rrc_nw_sel_mode_reset_ind.network_select_mode, 
                             rrc_csp_int_data.network_select_mode);

      if(rrc_csp_bplmn_srch_in_progress() != WTOW_SEARCH_RESUME)
      {
        if((rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED_ROUTINE_ACQUISITION) ||
              ((rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED) &&
                (cmd_ptr->cmd.rrc_nw_sel_mode_reset_ind.network_select_mode == SYS_NETWORK_SELECTION_MODE_MANUAL)) ||
              ((rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_AUTOMATIC) &&
                (cmd_ptr->cmd.rrc_nw_sel_mode_reset_ind.network_select_mode == SYS_NETWORK_SELECTION_MODE_MANUAL)) ||
              ((rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_MANUAL) &&
                (cmd_ptr->cmd.rrc_nw_sel_mode_reset_ind.network_select_mode == SYS_NETWORK_SELECTION_MODE_AUTOMATIC))
              )
        {
          nw_sel_mode_reset_ind_valid = TRUE;
        }
        else
        {
          WRRC_MSG0_HIGH("Ignoring as changing current mode to new mode is not allowed");
        }
        /* Save the last suit cell frequency UE camps on. This frequency is then 
         * added to the fine scan list when UE goes OOS in Idle mode, since the 
         * probability of UE finding the service on this frequency is higher.*/
        rrc_csp_int_data.last_camped_freq_in_idle_mode = rrc_csp_int_data.curr_acq_entry.freq;

        if(nw_sel_mode_reset_ind_valid == TRUE)
        {
#ifdef FEATURE_WCDMA_ABSOLUTE_PRIORITY
          if(rrc_csp_int_data.curr_req_plmn.plmn_type == RRC_GSM_MAP_ANY_PLMN_REQ)
          {
            WRRC_MSG0_HIGH("ABSOL_PRI:PLMN Req type changed from Any to SPEC");
            rrcmeas_post_dedicated_priority_change_indication();
          }
#endif
          /* If RRC_NW_SEL_MODE_RESET_IND is valid that means that new mode is 
           * either SYS_NETWORK_SELECTION_MODE_AUTOMATIC or SYS_NETWORK_SELECTION_MODE_MANUAL .
           * In either case only suitable cell re-selection is allowed further */
          rrc_csp_int_data.curr_req_plmn.plmn_type = RRC_GSM_MAP_SPECIFIC_PLMN_REQ;
          rrc_csp_int_data.curr_type_acq           = RRC_CSP_SPEC_PLMN;
          rrc_csp_curr_select_data.acq_type        = RRC_CSP_SPEC_PLMN;

          WRRC_MSG2_HIGH("Current nw select mode :%d, New nw select mode: %d",
                                                    rrc_csp_int_data.network_select_mode,
                                                    cmd_ptr->cmd.rrc_nw_sel_mode_reset_ind.network_select_mode);

          rrc_csp_int_data.network_select_mode = cmd_ptr->cmd.rrc_nw_sel_mode_reset_ind.network_select_mode;

          if(rrc_csp_substate == RRCCSP_CAMPED_ACCEPT_CELL)
          {
            WRRC_MSG0_HIGH("Setting accept->suit cell");
            rrc_csp_substate = RRCCSP_CAMPED_SUIT_CELL;
          }
#ifdef FEATURE_GAN
          #error code not present
#endif
        }
      }
      else
      {
        if((rrc_csp_int_data.prev_network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED_ROUTINE_ACQUISITION) ||
              ((rrc_csp_int_data.prev_network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED) &&
                (cmd_ptr->cmd.rrc_nw_sel_mode_reset_ind.network_select_mode == SYS_NETWORK_SELECTION_MODE_MANUAL)) ||
              ((rrc_csp_int_data.prev_network_select_mode == SYS_NETWORK_SELECTION_MODE_AUTOMATIC) &&
                (cmd_ptr->cmd.rrc_nw_sel_mode_reset_ind.network_select_mode == SYS_NETWORK_SELECTION_MODE_MANUAL)) ||
              ((rrc_csp_int_data.prev_network_select_mode == SYS_NETWORK_SELECTION_MODE_MANUAL) &&
                (cmd_ptr->cmd.rrc_nw_sel_mode_reset_ind.network_select_mode == SYS_NETWORK_SELECTION_MODE_AUTOMATIC))
              )
        {
          nw_sel_mode_reset_ind_valid = TRUE;
        }
        else
        {
          WRRC_MSG0_HIGH("Ignoring as changing current mode to new mode is not allowed");
        }
        rrc_csp_int_data.last_camped_freq_in_idle_mode = rrc_csp_int_data.prev_curr_acq_entry.freq;

        if(nw_sel_mode_reset_ind_valid == TRUE)
        {
#ifdef FEATURE_WCDMA_ABSOLUTE_PRIORITY
          if(rrc_csp_int_data.prev_curr_req_plmn.plmn_type == RRC_GSM_MAP_ANY_PLMN_REQ)
          {
            WRRC_MSG0_HIGH("ABSOL_PRI:PLMN Req type changed from Any to SPEC");
            rrcmeas_post_dedicated_priority_change_indication();
          }
#endif
          /* If RRC_NW_SEL_MODE_RESET_IND is valid that means that new mode is 
           * either SYS_NETWORK_SELECTION_MODE_AUTOMATIC or SYS_NETWORK_SELECTION_MODE_MANUAL .
           * In either case only suitable cell re-selection is allowed further */
          rrc_csp_int_data.prev_curr_req_plmn.plmn_type = RRC_GSM_MAP_SPECIFIC_PLMN_REQ;
          rrc_csp_int_data.prev_curr_type_acq           = RRC_CSP_SPEC_PLMN;
          rrc_csp_curr_select_data.prev_acq_type        = RRC_CSP_SPEC_PLMN;

          WRRC_MSG2_HIGH("Current nw select mode :%d, New nw select mode: %d",
                                                    rrc_csp_int_data.prev_network_select_mode,
                                                    cmd_ptr->cmd.rrc_nw_sel_mode_reset_ind.network_select_mode);

          rrc_csp_int_data.prev_network_select_mode = cmd_ptr->cmd.rrc_nw_sel_mode_reset_ind.network_select_mode;
        }
      } 

#ifdef FEATURE_FEMTO_CSG
      /*Start ASF timer when n/w sel mode changed from limited to manual/auto i.e ANY PLMN to Spec PLMN*/
      if((TRUE == is_whitelist_valid) &&
        (nw_sel_mode_reset_ind_valid == TRUE)&&
         (rrctmr_get_remaining_time(RRCTMR_CSG_ASF_SRCH_TIMER) == 0))
      {
        rrctmr_start_timer(RRCTMR_CSG_ASF_SRCH_TIMER, (wcdma_asf_timer_nv)*60000);
      }
#endif
      break;


    case RRC_CONN_MODE_OOS_TIMER_EXPIRED_IND:
      WRRC_MSG0_HIGH("OOS: 30s oos tmr expired");
#ifdef FEATURE_WRLF_SYSTEM_SEL
      /* Send SUITABLE_SRCH_END_IND to NAS to indicate end of suit srch period and CM can
         attempt limited routine search requests. */
      rrc_csp_check_n_send_suitable_srch_end_ind();
#endif
      rrc_csp_int_data.oos_splmn_srch_tmr_expd = TRUE;
      break;

    case RRC_CONN_MODE_OOS_INITIAL_NO_DS_TIMER_EXPIRED_IND:
      WRRC_MSG0_HIGH("OOS: Initial Tmins continuous no deep sleep srch tmr expd");
      rrc_csp_int_data.oos_initial_no_deep_sleep_tmr_expd = TRUE;
      break;

    case RRC_FORBIDDEN_LAI_LIST_UPDATE_REQ:
      MSG_MED("Cmd 0x%x recvd, CSP sstate %d",
                         cmd_ptr->cmd_hdr.cmd_id, rrc_csp_substate, 0 );
      /* Replace the existing forbidden LAI list with the new list. If the
       * list is empty, there is no need to verify the suitability of a
       * selected cell against the list.
       */
      rrc_csp_int_data.forbid_lai_list = cmd_ptr->cmd.forbid_lai_list_update_req.forbid_lai_list;
      if(rrc_csp_int_data.forbid_lai_list.num_lais == 0)
      {
        rrc_csp_int_data.bar_for_resel_only = TRUE;
        WRRC_MSG0_HIGH("CSG: Send unbar request upon FLAI update indication");
        rrccsp_send_cphy_cell_bar_req(RRC_CSP_WCDMA_FREQ_BARRED,0);
        rrc_csp_int_data.bar_for_resel_only = FALSE;
      }

      break;
#ifdef FEATURE_WCDMA_FREE_FLOATING_TASK
    case RRC_LAI_REJECT_LIST_IND:
      rrc_csp_int_data.lai_reject_list = cmd_ptr->cmd.rrc_lai_reject_list_ind.nas_lai_reject_list;
      break;

    /* Indicates if SM allows tuneaway */
    case RRC_TUNEAWAY_ALLOWED_IND:
#ifdef FEATURE_DUAL_SIM
      rrc_csp_int_data.sm_ok_to_tuneaway = cmd_ptr->cmd.rrc_sm_tuneaway_allowed_ind.sm_ok_to_tuneaway;
      break;
#endif
#endif
/*lint -e408*/
#ifdef FEATURE_GAN
    #error code not present
#endif

#ifdef FEATURE_GAN_3G_ROVE_OUT_ONLY
    #error code not present
#endif
/*lint +e408*/

    case RRC_EQ_PLMN_LIST_CHANGE_IND:
      if((rrcmcm_get_rrc_mode() == RRC_MODE_STANDBY)||
          (rrc_csp_int_data.curr_scan == RRC_CSP_OUT_OF_SERVICE_AREA_SCAN))
      {
        WRRC_MSG0_HIGH("Ignore RRC_EQ_PLMN_LIST_CHANGE_IND");
      }
      else
      {
        rrc_csp_int_data.non_eq_plmn_barred = TRUE;
        rrc_csp_int_data.bar_for_resel_only = TRUE;
        rrccsp_send_cphy_cell_bar_req(RRC_CSP_WCDMA_FREQ_BARRED,0);
        rrc_csp_int_data.bar_for_resel_only = FALSE;
      }
      break;

#ifdef FEATURE_DUAL_SIM
    case RRC_DS_STATUS_CHANGE_IND:
      /*CMD should be directly sent to L1, funneled is not needed*/
      rrc_send_ds_status_ind_to_l1(cmd_ptr);
      break;

    case RRC_CPHY_OUT_OF_SERVICE_AREA_IND:
    case RRC_NO_RESOURCE_AVAILABLE_FROM_L1:
      if((rrc_csp_substate != RRCCSP_WT_STOP_MODE_CHANGE_CNF) &&
         (rrc_csp_int_data.curr_scan != RRC_CSP_LEAVING_CONN_MODE_SCAN)&&
         (!WRM_STATE_IS_IN_LOCK(WCDMA_TRM)) &&
         (!WRM_STATE_IS_LOCK_REQ(WCDMA_TRM))
        )
      {
        rrc_csp_substate = rrc_csp_handle_no_resource_from_l1();
      }
      else
      {
        MSG_HIGH("Ignoring command %x, CSP substate:%d, curr scan %d", cmd_ptr->cmd_hdr.cmd_id,rrc_csp_substate,rrc_csp_int_data.curr_scan);
      }
      break;

      case RRC_WRM_PREEMPT_IND:
      rrctmr_stop_timer(RRCTMR_WRM_DELAY_PREEMPTION_TIMER);
      if((!rrc_csp_int_data.preemption_handling_in_progress) &&
         (!rrc_csp_int_data.csp_waiting_for_wl1_to_release_lock) &&
         (rrc_csp_substate != RRCCSP_WT_STOP_MODE_CHANGE_CNF)&&
         (rrc_csp_substate != RRCCSP_WT_SUSPEND_MODE_CHANGE_CNF))
      {
        rrc_csp_substate = rrc_handle_preemtpion_ind(cmd_ptr);
      }
      else
      {
        WRRC_MSG1_HIGH("DSIM: Ignore Preemption, RRC is already waiting to release the lock. CSP substate: %d",rrc_csp_substate);
      }
      break;
#ifdef FEATURE_DUAL_SIM
      case RRC_DS_TUNEAWAY_STATUS_CHANGE_IND:
        if(ds_tuneaway_status_change_ind.tuneaway_status != cmd_ptr->cmd.rrc_ds_tuneaway_status_change_ind.tuneaway_status)
        {
            WRRC_MSG1_HIGH("DSIM_TUNEAWAY: Received RRC_DS_TUNEAWAY_STATUS_CHANGE_IND value: %d ",cmd_ptr->cmd.rrc_ds_tuneaway_status_change_ind.tuneaway_status);
            ds_tuneaway_status_change_ind.tuneaway_status = cmd_ptr->cmd.rrc_ds_tuneaway_status_change_ind.tuneaway_status;
            if(WRM_CLI_STATE_IS_IN_LOCK(WCDMA_TRM, WRM_PRIMARY_CLIENT_RRC))
            {
              if(ds_tuneaway_status_change_ind.tuneaway_status == TRUE)
              {
                if((rrc_get_state() == RRC_STATE_CELL_DCH) || (rrc_get_state() == RRC_STATE_CELL_FACH))
                {
                  rrc_check_send_change_priority();
                }
              }
              else
              {
                rrc_change_priority_on_tuneaway_disable();
              }
            }
            else
            {
              WRRC_MSG0_HIGH("DSIM_TUNEAWAY: Ignored RRC_DS_TUNEAWAY_STATUS_CHANGE_IND as RRC doesn't have lock ");
            }
          }
          else
          {
          WRRC_MSG0_HIGH("DSIM_TUNEAWAY: Ignored RRC_DS_TUNEAWAY_STATUS_CHANGE_IND, No change in status ");
        }
        break;
#endif
#endif

#ifdef FEATURE_3GPP_CSFB
      case RRC_CSFB_CALL_STATUS_IND:
        WRRC_MSG1_HIGH("CSFB: CSFB Call status indicated by NAS %d ",cmd_ptr->cmd.rrc_csfb_call_status_ind.csfb_call_status);
        if(rrc_csfb_call_status && !cmd_ptr->cmd.rrc_csfb_call_status_ind.csfb_call_status)
        {
          if(((RRCCSP_CAMPED_SUIT_CELL == rrc_csp_substate) ||
             (RRCCSP_CAMPED_ACCEPT_CELL == rrc_csp_substate)) &&
             (!rrcrce_is_rce_procedure_active()))
          {
#ifdef FEATURE_WCDMA_CSFB_CALL_OPT
            if(WCDMA_RRC_IDLE_FEATURES(RRC_CSFB_CALL_TIMELINE_OPT) &&
               (RRC_MODE_INTERRAT_IN_PROGRESS != rrcmcm_get_rrc_mode()))
            {
              /* Trigger OOS if CSFB call status is reset before connection establishment */
              rrc_csp_substate = rrc_csp_start_sel_out_of_service_area_in_idle_state();
            }
            else
#endif
            {
#ifdef FEATURE_DUAL_SIM          
              /* Release the lock since there is no CSFB */
              rrc_release_lock();
#endif
               /*RCE is not active, indicates that UE is in IDLE*/
              rrccsp_post_update_sibs_ind(RRCSIB_CSFB_CALL_CANCL);
            }
            rrc_csfb_call_status = cmd_ptr->cmd.rrc_csfb_call_status_ind.csfb_call_status;
          }
#ifdef FEATURE_WCDMA_CSFB_CALL_OPT
          else if(((RRCCSP_SUIT_CELL_WT_ACTIVATION_RSP == rrc_csp_substate) ||
                   (RRCCSP_ACCEPT_CELL_WT_ACTIVATION_RSP == rrc_csp_substate)) &&
                   (!rrcrce_is_rce_procedure_active())&&
                   WCDMA_RRC_IDLE_FEATURES(RRC_CSFB_CALL_TIMELINE_OPT))
          {
             /* CSFB call status is reset while waiting for Activation Response from NAS*/
             rrc_csfb_reset_while_waiting_for_act_rsp = TRUE;
             rrc_csfb_call_status = cmd_ptr->cmd.rrc_csfb_call_status_ind.csfb_call_status;
             WRRC_MSG0_HIGH("CSFB call status is Reset while waiting for ActivationRsp. Trigger OOS after ACT_RSP");
          }
#endif
          else if(!rrcrce_is_rce_procedure_active())
          {
            rrc_csfb_call_status = cmd_ptr->cmd.rrc_csfb_call_status_ind.csfb_call_status;
#ifdef FEATURE_DUAL_SIM 
            /* Release the lock here only when service cnf or service ind has been sent */
            if((rrc_csp_int_data.last_mm_primitive == RRC_CSP_SRVC_CNF_WITH_SRVC_SENT) ||
               (rrc_csp_int_data.last_mm_primitive == RRC_CSP_SRVC_IND_WITH_SRVC_SENT))
            {
              /* Release the lock since there is no CSFB */
              rrc_release_lock();
            }
            else if (WRM_STATE_IS_IN_LOCK(WCDMA_TRM))
            {
              /* Lower the priority of Lock to accomodate page decode on other SUB(GSM) */
              rrc_wrm_change_priority(TRM_ACQUISITION);
            }
#endif
          }

          WRRC_MSG1_HIGH("CSFB: rrc_csfb_call_status_ind %d ",rrc_csfb_call_status);
          /* Don't update the rrc_csfb_call_status if RCE is active */
          /* This is used to set CSFB Indicator in connection request OTA */
        }
        else
        {
          rrc_csfb_call_status = cmd_ptr->cmd.rrc_csfb_call_status_ind.csfb_call_status;
        }  

         /* CSFB call is ended */
        if(!rrc_csfb_call_status)
        {
          if(rrctmr_get_remaining_time(RRCTMR_LTE_TO_WCDMA_REDIR_SRCH_TIMER) > 0)
          {
            rrc_cmd_type *cmd_ptr;
            rrctmr_stop_timer(RRCTMR_LTE_TO_WCDMA_REDIR_SRCH_TIMER);
            /* Get a RRC internal command buffer */
            if((cmd_ptr = rrc_get_int_cmd_buf()) != NULL)
            {
              /* Fill in the command id  */
              cmd_ptr->cmd_hdr.cmd_id = RRC_LTE_TO_WCDMA_SRCH_TIMER_EXPIRY_IND;
              /* Put the command in the internal queue */
              rrc_put_int_cmd( cmd_ptr );
              WRRC_MSG0_HIGH("RRC_LTE_TO_WCDMA_SRCH_TIMER_EXPIRY_IND posted to internal cmd queue");
            }
          }
        }

#ifdef FEATURE_WCDMA_FAST_RETURN_TO_LTE_AFTER_CSFB 
        if((rrc_fast_return_to_lte_after_csfb_nv) && (rrc_csfb_call_status))
        {
          csfb_extended_status = CSFB_STARTED;
          WRRC_MSG0_HIGH("CSFB_HACK: CSFB call status is TRUE.");
        }
        else if((rrc_fast_return_to_lte_after_csfb_nv) && (!rrc_csfb_call_status) 
               && (RRC_MODE_INACTIVE == rrcmcm_get_rrc_mode()))
        {
          csfb_extended_status = CSFB_INVALID;
          WRRC_MSG0_HIGH("CSFB_HACK: CSFB call status is FALSE.");
        }
#endif
        break;
#endif
#ifdef FEATURE_LTE_TO_WCDMA
      case RRC_LTE_TO_WCDMA_SRCH_TIMER_EXPIRY_IND:
        WRRC_MSG1_HIGH("RRC_LTE_TO_WCDMA_SRCH_TIMER_EXPIRY_IND processing at CSP in substate %d",rrc_csp_substate);
        if((rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_REDIRECTION_SCAN) &&
            (rrc_csp_int_data.interrat_type == RRC_CSP_INTERRAT_LTE) &&
            (rrc_csp_substate != RRCCSP_WT_STOP_MODE_CHANGE_CNF) && 
            (rrc_csp_substate != RRCCSP_SUIT_CELL_WT_ACTIVATION_RSP) &&
            (rrc_csp_substate != RRCCSP_ACCEPT_CELL_WT_ACTIVATION_RSP))
        {
          /*If CSP is not waiting for STOP WCDMA CNF or activation response for LTOW redirection, handle the search timer expiry*/
          rrc_csp_int_data.rsp_to_rr = SEND_GTOW_REDIRECTION_REJECT;
          rrccsp_send_mode_change_req_to_mcm( RRC_MODE_INACTIVE );
          rrc_csp_substate = RRCCSP_WT_STOP_MODE_CHANGE_CNF;
        }
        else
        {
          WRRC_MSG0_HIGH("Ignore processing of RRC_LTE_TO_WCDMA_SRCH_TIMER_EXPIRY_IND");
        }
        break;
#endif

      case RRC_LTE_RESELECTION_ALLOWED_STATUS_IND:
        MSG_HIGH("lte_reselection_allowed: %d in CSP substate %d, prev flag value: %d",
              cmd_ptr->cmd.rrc_lte_resel_allowed_status_ind.lte_reselection_allowed ,rrc_csp_substate,
              rrc_csp_int_data.allow_lte_resel);

        if((RRC_MODE_ACTIVE == rrcmcm_get_rrc_mode()) &&
            (rrc_csp_substate == RRCCSP_CAMPED_SUIT_CELL) &&
            (rrctmr_get_remaining_time(RRCTMR_WTOW_BPLMN_DRX_SRCH_TIMER) == 0) &&
             (rrc_get_state() == RRC_STATE_DISCONNECTED))
        {
          if(rrc_csp_int_data.allow_lte_resel != 
              cmd_ptr->cmd.rrc_lte_resel_allowed_status_ind.lte_reselection_allowed)
          {
            rrc_cmd_type *cmd_ptr_buff;
            
            /* Get a RRC internal command buffer */
            if((cmd_ptr_buff = rrc_get_int_cmd_buf()) != NULL)
            {
            /* Fill in the command id  */
              cmd_ptr_buff->cmd_hdr.cmd_id = RRC_MODE_STATUS_IND;  
            
              /* Put the command in the internal queue */
              rrc_put_int_cmd(cmd_ptr_buff );
              WRRC_MSG0_HIGH("RRC_MODE_STATUS_IND is sent to dispatcher ");
            }
          }
        }

        /* Store the block status from NAS, and if MODE_STATUS_IND is not sent, apply it whenever UE gets into proper state. */
        rrc_csp_int_data.allow_lte_resel = 
           cmd_ptr->cmd.rrc_lte_resel_allowed_status_ind.lte_reselection_allowed;
        WRRC_MSG1_HIGH("Setting allow lte resel flag to %d ", rrc_csp_int_data.allow_lte_resel);
        break;

     case RRC_BPLMN_PARTIAL_REPORT_TIMER_EXPIRED_IND:
      if(rrctmr_get_remaining_time(RRCTMR_BPLMN_GUARD_SRCH_TIMER) == 0)
      {
        /* Race Condition: BPLMN Search ended and Partial Report Timer expired*/
        WRRC_MSG0_HIGH("MPLMN Opt: Ignoring Partial timer expiry");
        memset(&rrc_csp_int_data.bplmn_search_timer_value,0,sizeof(sys_manual_search_timer_value_type));
      }
      else
      { 
        WRRC_MSG0_HIGH("MPLMN Opt: RRC_BPLMN_PARTIAL_REPORT_TIMER_EXPIRED_IND expired");
        rrccsp_send_mplmn_partial_report_to_mm();
      }
      break;

    default:
      switch( rrc_csp_substate )
      {
        case RRCCSP_NO_CELL_SELECTED:
          rrc_csp_substate = rrccsp_no_cell_selected_hdlr (cmd_ptr);
          break;
        case RRCCSP_CELL_SEL_WT_ACQ:
          rrc_csp_substate = rrccsp_cell_sel_wait_acq_hdlr (cmd_ptr);
          break;
        case RRCCSP_CELL_SEL_WT_ACQ_PENDING:
          rrc_csp_substate = rrccsp_cell_sel_wait_acq_pending_hdlr (cmd_ptr);
          break;
        case RRCCSP_CELL_SEL_WT_FREQ_SCAN_CNF:
          rrc_csp_substate = rrccsp_cell_sel_wait_freq_scan_cnf_hdlr (cmd_ptr);
          break;
        case RRCCSP_CELL_SEL_WT_FREQ_SCAN_CNF_PENDING:
          rrc_csp_substate = rrccsp_cell_sel_wait_freq_scan_cnf_pending_hdlr (cmd_ptr);
          break;
        case RRCCSP_CELL_SEL_WT_SIB:
          rrc_csp_substate = rrccsp_cell_sel_wait_sib_hdlr (cmd_ptr);
          break;
        case RRCCSP_CELL_SEL_WT_SIB_PENDING:
          rrc_csp_substate = rrccsp_cell_sel_wait_sib_pending_hdlr (cmd_ptr);
          break;
        case RRCCSP_SUIT_CELL_SEL_WT_SERV_S:
        case RRCCSP_ACCEPT_CELL_SEL_WT_S:
          rrc_csp_substate = rrccsp_cell_sel_wait_s_hdlr (cmd_ptr);
          break;
        case RRCCSP_SUIT_CELL_SEL_WT_SERV_S_PENDING:
        case RRCCSP_ACCEPT_CELL_SEL_WT_S_PENDING:
          rrc_csp_substate = rrccsp_cell_sel_wait_s_pending_hdlr (cmd_ptr);
          break;
        case RRCCSP_SUIT_CELL_SEL_WT_CAMP:
        case RRCCSP_ACCEPT_CELL_SEL_WT_CAMP:
          rrc_csp_substate = rrccsp_cell_sel_wait_camp_hdlr(cmd_ptr);
          break;
        case RRCCSP_SUIT_CELL_SEL_WT_CAMP_PENDING:
        case RRCCSP_ACCEPT_CELL_SEL_WT_CAMP_PENDING:
          rrc_csp_substate = rrccsp_cell_sel_wait_camp_pending_hdlr (cmd_ptr);
          break;
        case RRCCSP_CAMPED_SUIT_CELL:
          rrc_csp_substate = rrccsp_camped_suit_cell_hdlr (cmd_ptr);
          break;
        case RRCCSP_CAMPED_ACCEPT_CELL:
          rrc_csp_substate = rrccsp_camped_accept_cell_hdlr (cmd_ptr);
          break;
        case RRCCSP_SUIT_CELL_RESELECT_WT_SIB:
        case RRCCSP_ACCEPT_CELL_RESELECT_WT_SIB:
          rrc_csp_substate = rrccsp_cell_resel_wait_sib_hdlr (cmd_ptr);
          break;
        case RRCCSP_SUIT_CELL_RESELECT_WT_CAMP:
        case RRCCSP_ACCEPT_CELL_RESELECT_WT_CAMP:
          rrc_csp_substate = rrccsp_cell_resel_wait_camp_hdlr (cmd_ptr);
          break;
        case RRCCSP_SUIT_CELL_RESELECT_WT_CAMP_PENDING:
          rrc_csp_substate = rrccsp_suit_cell_resel_wait_camp_pending_hdlr (cmd_ptr);
          break;
        case RRCCSP_SUIT_CELL_RESELECT_WT_TRANS_CNF:
        case RRCCSP_ACCEPT_CELL_RESELECT_WT_TRANS_CNF:
          rrc_csp_substate = rrccsp_cell_resel_wait_trans_cnf_hdlr (cmd_ptr);  
          break;
        case RRCCSP_ACCEPT_CELL_RESELECT_WT_CAMP_PENDING:
          rrc_csp_substate = rrccsp_accept_cell_resel_wait_camp_pending_hdlr (cmd_ptr);
          break;
        case RRCCSP_WT_SUSPEND_MODE_CHANGE_CNF:
          rrc_csp_substate = rrccsp_wt_suspend_mode_change_cnf_hdlr(cmd_ptr);
          break;
        case RRCCSP_WT_RESUME_MODE_CHANGE_CNF:
          rrc_csp_substate = rrccsp_wt_resume_mode_change_cnf_hdlr(cmd_ptr);
          break;
        case RRCCSP_WT_RESUME_MODE_CHANGE_CNF_PENDING:
          rrc_csp_substate = rrccsp_wt_resume_mode_change_cnf_pending_hdlr(cmd_ptr);
          break;
        case RRCCSP_WT_FOR_CHAN_CFG_CNF:
          rrc_csp_substate = rrccsp_wt_chan_cfg_cnf_hdlr(cmd_ptr);
          break;
        case RRCCSP_WT_FOR_CHAN_CFG_CNF_PENDING:
          rrc_csp_substate = rrccsp_wt_chan_cfg_cnf_pending_hdlr(cmd_ptr);
          break;
        case RRCCSP_WT_STOP_MODE_CHANGE_CNF:
          rrc_csp_substate = rrccsp_wt_stop_mode_change_cnf_hdlr(cmd_ptr);
          break;
        case RRCCSP_SUIT_CELL_WT_ACTIVATION_RSP:
          rrc_csp_substate = rrccsp_suit_cell_wt_activation_rsp_hdlr(cmd_ptr);
          break;
        case RRCCSP_ACCEPT_CELL_WT_ACTIVATION_RSP:
          rrc_csp_substate = rrccsp_accept_cell_wt_activation_rsp_hdlr(cmd_ptr);
          break;

        case RRCCSP_CELL_SEL_WT_HANDOVER_ACQ:
          rrc_csp_substate = rrccsp_cell_sel_wt_handover_acq_hdlr(cmd_ptr);
          break;

        case RRCCSP_WT_LOWER_LAYER_DEACT_CNF:
          rrc_csp_substate = rrccsp_wt_lower_layer_deact_cnf_hdlr(cmd_ptr);
          break;

        case RRCCSP_CELL_SEL_WT_STATE_CHANGE:
          rrc_csp_substate = rrccsp_cell_sel_wait_state_change_hdlr(cmd_ptr);
          break;

        case RRCCSP_CELL_SEL_WT_STATE_CHANGE_PENDING:
          rrc_csp_substate = rrccsp_cell_sel_wait_state_change_pending_hdlr(cmd_ptr);
          break;

        case RRCCSP_WT_RESPONSE_FROM_RR:
          rrc_csp_substate = rrccsp_wait_response_from_rr_hdlr(cmd_ptr);
          break;

        case RRCCSP_WT_RR_ABORT_CNF:
          rrc_csp_substate = rrccsp_wait_rr_abort_cnf_hdlr(cmd_ptr);
          break;
#ifdef FEATURE_GAN_3G_ROVE_OUT_ONLY
        #error code not present
#endif
        default:
          /* Just Print a message for now */
          WRRC_MSG1_HIGH("RRC CSP Substate %d not supported", rrc_csp_substate);
          break;
      }

      break;
  }

  /* Release of buffer is not procedure's responsibility  */
}  /* rrc_cell_selection_procedure */

#ifdef FEATURE_DUAL_SIM
/*===========================================================================

FUNCTION  RRC_CHECK_CAN_PREEMPTION_BE_HANDLED

DESCRIPTION

  This function checks if preemption can be handled.
    
DEPENDENCIES

  None.
 
RETURN VALUE

  TRUE If pre-emption can be handled.
  else
  FALSE.

SIDE EFFECTS

  None.

===========================================================================*/
boolean rrc_check_can_preemption_be_handled(void)
{
  rrc_state_e_type curr_state = rrc_get_state();
  boolean handle_preemption = FALSE;
  rrcrce_substate_e_type rce_substate = rrcrce_get_rce_sub_state();
  rrc_csp_scan_e_type curr_scan = rrccsp_get_curr_scan();
  rrc_csp_substate_e_type csp_substate = rrc_get_csp_substate();
  WRRC_MSG1_HIGH("DSIM: RRC state %d",curr_state);

  if(WRM_CLI_STATE_IS_IN_LOCK(WCDMA_TRM, WRM_PRIMARY_CLIENT_RRC))
  {
    WRRC_MSG0_HIGH("DSIM: RRC holding the lock");
    switch (curr_state)
    {
      case RRC_STATE_DISCONNECTED:
        if(
            !(rce_substate == RRCRCE_WAIT_FOR_RB0_SETUP_CNF) &&
            !((
                 (curr_scan == RRC_CSP_GSM_TO_WCDMA_CELL_RESELECTION_SCAN) ||
                 (curr_scan == RRC_CSP_CELL_SELECTION_SCAN) ||
                 (curr_scan == RRC_CSP_GSM_TO_WCDMA_REDIRECTION_SCAN) ||
                 (curr_scan == RRC_CSP_PLMN_LIST_SCAN)) &&
                !(
                   (csp_substate== RRCCSP_CELL_SEL_WT_ACQ) ||
                   (csp_substate == RRCCSP_CELL_SEL_WT_ACQ_PENDING) ||
                   (csp_substate == RRCCSP_CELL_SEL_WT_SIB) ||
                   (csp_substate == RRCCSP_CELL_SEL_WT_SIB_PENDING))
              ) &&
            !(
               (curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN) ||
               (curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN) ||
               (curr_scan == RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN) ||
               (curr_scan == RRC_CSP_GTOW_BPLMN_MANUAL_SCAN) 
             ) &&
            !((rrciho_is_gtow_ho_active()) || (TRUE == rrccho_is_gtow_pcco_in_progress())) 
          )
        {
          handle_preemption = TRUE;
        }
        break;

      case RRC_STATE_CELL_DCH:
      case RRC_STATE_CELL_FACH:
      case RRC_STATE_CELL_PCH:
      case RRC_STATE_URA_PCH:
        if((curr_scan == RRC_CSP_OUT_OF_SERVICE_AREA_SCAN) 
#ifdef FEATURE_WRLF_SYSTEM_SEL
           || (((rrc_csp_int_data.curr_scan == RRC_CSP_LEAVING_CONN_MODE_SCAN) ||
               (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_SELECTION_SCAN)) &&
                RRC_IS_CONN_MODE_OOS_SRCH_IN_PROGRESS())
#endif
          )
        {
          handle_preemption = TRUE;
        }
        break;

      default:
        handle_preemption = FALSE;
        break;
    }
  }
  else if (WRM_CLI_STATE_IS_IN_LOCK(WCDMA_TRM, WRM_PRIMARY_CLIENT_L1))
  {
    WRRC_MSG0_HIGH("DSIM: WL1 is holding the lock");
    switch (curr_state)
    {
      /* Do not handle preemption during leaving connected mode scan or OOS in idle scan and CSP is not waiting for ACQ or SIB read.*/
      case RRC_STATE_DISCONNECTED:
        if(!((
             (curr_scan == RRC_CSP_GSM_TO_WCDMA_CELL_RESELECTION_SCAN) ||
             (curr_scan == RRC_CSP_CELL_SELECTION_SCAN) ||
             (curr_scan == RRC_CSP_PLMN_LIST_SCAN) ||
             (curr_scan == RRC_CSP_LEAVING_CONN_MODE_SCAN) ||
             (curr_scan == RRC_CSP_OUT_OF_SERVICE_AREA_IN_IDLE_STATE_SCAN) ||
             (curr_scan == RRC_CSP_GSM_TO_WCDMA_REDIRECTION_SCAN) ||
             (curr_scan == RRC_CSP_CELL_RESELECTION_SCAN)) &&
              !(
                (csp_substate== RRCCSP_CELL_SEL_WT_ACQ) ||
                (csp_substate == RRCCSP_CELL_SEL_WT_ACQ_PENDING) ||
                (csp_substate == RRCCSP_CELL_SEL_WT_SIB) ||
                (csp_substate == RRCCSP_CELL_SEL_WT_SIB_PENDING) ||
                (csp_substate == RRCCSP_SUIT_CELL_RESELECT_WT_SIB) ||
                (csp_substate == RRCCSP_ACCEPT_CELL_RESELECT_WT_SIB))
             ) &&
           !(
              (csp_substate == RRCCSP_WT_RESUME_MODE_CHANGE_CNF) ||
              (csp_substate == RRCCSP_WT_FOR_CHAN_CFG_CNF)
            ) &&
          !(
            (curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN) ||
            (curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN) ||
            (curr_scan == RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN) ||
            (curr_scan == RRC_CSP_GTOW_BPLMN_MANUAL_SCAN) 
             )
          )
        {
          handle_preemption = TRUE;
        }
        break;

      case RRC_STATE_CELL_PCH:
      case RRC_STATE_URA_PCH:
       /* Do not handle immediate preemption while in wait for resume or wait for chan config
        * This is needed to ensure that WCDMA doesn't get stuck by holding the lock
        */
       /* In the case of cell reselection in PCH state handle immediate preemption only while 
        * waiting for SIBs. Otherwise delay the preemption as lock release is going to happen
        * shortly
        */
        if(
           !(
              (csp_substate == RRCCSP_WT_RESUME_MODE_CHANGE_CNF) ||
              (csp_substate == RRCCSP_WT_FOR_CHAN_CFG_CNF) ||
              !(csp_substate == RRCCSP_SUIT_CELL_RESELECT_WT_SIB)
            ) &&
           !(
              (curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN) ||
              (curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN) ||
              (curr_scan == RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN) ||
              (curr_scan == RRC_CSP_GTOW_BPLMN_MANUAL_SCAN) ||
              (curr_scan == RRC_CSP_CELL_RESELECTION_SCAN)
            )
          )
        {
          handle_preemption = TRUE;
        }
        break;

      default:
        handle_preemption = FALSE;
        break;
    }
  }
  else
  {
    WRRC_MSG0_HIGH("DSIM: WCDMA is not holding the lock,ignore the preemption");
  }
  if((csp_substate == RRCCSP_WT_STOP_MODE_CHANGE_CNF) 
    || (csp_substate == RRCCSP_WT_LOWER_LAYER_DEACT_CNF)
    || (csp_substate == RRCCSP_WT_SUSPEND_MODE_CHANGE_CNF)
    || (rrctmr_get_remaining_time(RRCTMR_DSIM_BPLMN_LOCK_REL_OFFSET_TIMER) > 0)
    )
  {
    WRRC_MSG2_HIGH("DSIM: Ignore Preemption in csp_substate = %d, handle_preemption = %d",csp_substate,handle_preemption);
    handle_preemption = FALSE;
  }

  if((curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN) ||
     (curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN))
  {
    /* Stop the lock wait timer. Earlier lock wait timer during BPLMN was always supposed to expire */
    rrc_stop_lock_wait_timer();
    if(rrctmr_get_remaining_time(RRCTMR_WTOW_BPLMN_DRX_SRCH_TIMER) > 0)
    {
      rrc_cmd_type *cmd_ptr;
      rrctmr_stop_timer(RRCTMR_WTOW_BPLMN_DRX_SRCH_TIMER);
      /* Get a RRC internal command buffer */
      if((cmd_ptr = rrc_get_int_cmd_buf()) != NULL)
      {
         /* Fill in the command id  */
        cmd_ptr->cmd_hdr.cmd_id = RRC_WTOW_BPLMN_DRX_SRCH_TIMER_EXPIRED_IND;
        /* Put the command in the internal queue */
        rrc_put_int_cmd( cmd_ptr );
        WRRC_MSG0_HIGH("RRC_WTOW_BPLMN_DRX_SRCH_TIMER_EXPIRED_IND posted to internal cmd queue");
      }
    }
  }
  /* deliberately removed check for GTOW MANUAL SCAN as the scan type is same for foreground search as well
   * during manual scan TRM lock will anyway get released shortly. if we stop the timer then foregound search
   * gets unnecessarily ended
   */
  else if(curr_scan == RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN)
  {
    if(rrctmr_get_remaining_time(RRCTMR_BPLMN_SRCH_TIMER) > 0)
    {
      rrc_cmd_type *cmd_ptr;
      rrctmr_stop_timer(RRCTMR_BPLMN_SRCH_TIMER);
      /* Get a RRC internal command buffer */
      if((cmd_ptr = rrc_get_int_cmd_buf()) != NULL)
      {
         /* Fill in the command id  */
        cmd_ptr->cmd_hdr.cmd_id = RRC_BPLMN_SRCH_TIMER_EXPIRED_IND;
        /* Put the command in the internal queue */
        rrc_put_int_cmd( cmd_ptr );
        WRRC_MSG0_HIGH("RRC_BPLMN_SRCH_TIMER_EXPIRED_IND posted to internal cmd queue");
      }
    }
  }

  WRRC_MSG1_HIGH("DSIM: Handle Preemption = %d ",handle_preemption);
  return handle_preemption;
}

/*===========================================================================

FUNCTION  rrc_check_preemption_can_be_handled_in_fach_dch

DESCRIPTION

  This function checks if preemption can be handled in FACH & DCH states
    
DEPENDENCIES

  None.
 
RETURN VALUE

  TRUE If pre-emption can be handled.
  else
  FALSE.

SIDE EFFECTS

  None.
===========================================================================*/

boolean rrc_check_preemption_can_be_handled_in_fach_dch(void)
{
  if((rrc_check_can_rrc_handle_preemption_in_fach_dch(CAUSE_TA)) &&
      (rrc_check_can_l1_handle_preemption_in_fach_dch() ) &&
      (rrc_check_can_nas_handle_preemption_in_fach_dch(CAUSE_TA))
    )
  {
    WRRC_MSG0_HIGH("DSIM_TUNEAWAY: Preemption can be handled");
    return TRUE;
  }
  else
  {
    return FALSE;
  }
}

/*===========================================================================

FUNCTION  rrc_check_can_rrc_handle_preemption_in_fach_dch

DESCRIPTION

  This function checks if RRC can handle preemption  in FACH & DCH states
    
DEPENDENCIES

  None.
 
RETURN VALUE

  TRUE If pre-emption can be handled.
  else
  FALSE.

SIDE EFFECTS

  None.
===========================================================================*/

boolean rrc_check_can_rrc_handle_preemption_in_fach_dch(rrccsp_preemption_cause_e_type cause_preemption )
{
  rrc_state_e_type rrc_state = rrc_get_state();
  boolean          return_value = TRUE;
  cm_call_type_mask_type   call_type = CM_CALL_TYPE_VOICE_MASK|CM_CALL_TYPE_EMERG_MASK;

  DS_Tuneaway_for_Immediate_preempt = TRUE;

  if(!((rrc_state == RRC_STATE_CELL_DCH) || (rrc_state == RRC_STATE_CELL_FACH) ||
      ((cause_preemption == CAUSE_QTA)&&((rrc_csp_substate == RRCCSP_CELL_SEL_WT_SIB)||(rrc_csp_substate == RRCCSP_CELL_SEL_WT_SIB_PENDING)))))
  {
    WRRC_MSG2_HIGH("DSIM_TUNEAWAY: Preemption can't be handled in rrc state: %d CSP substate %d",rrc_state,rrc_csp_substate);
    return_value = FALSE;
  }
  else if((rrc_ccm_is_reselection_in_progress() == TRUE) && (cause_preemption != CAUSE_IMMEDIATE))
  {
    WRRC_MSG0_HIGH("DSIM_TUNEAWAY: Preemption can't be handled as CCM reselection in progress");
    return_value = FALSE;
  }
  else if(!((rrcllc_get_ordered_config_status() == OC_NOT_SET) || 
         ((WCDMA_RRC_IDLE_FEATURES(RRC_QTA_DURING_SIGNALLING))&&(cause_preemption == CAUSE_QTA) && (wrm_is_next_tuneaway_page_decode() == TRUE) &&(rrcllc_get_ordered_config_status() == OC_SET_FOR_CELL_DCH) && (rrc_state == RRC_STATE_CELL_DCH))||
         ((cause_preemption == CAUSE_QTA)&&((rrc_csp_substate == RRCCSP_CELL_SEL_WT_SIB)||(rrc_csp_substate == RRCCSP_CELL_SEL_WT_SIB_PENDING)))
        )
       )
  {
    WRRC_MSG1_HIGH("DSIM_TUNEAWAY: Preemption can't be handled as OC status is SET to rrcllc_oc_set_status_e_type_value%d",rrcllc_get_ordered_config_status());
    return_value = FALSE;
  }
  else if((rrc_ccm_get_curr_camping_status(RRC_PROCEDURE_CSP) != RRC_CAMPED_ON)&&
  !((cause_preemption == CAUSE_QTA)&&((rrc_csp_substate == RRCCSP_CELL_SEL_WT_SIB)||(rrc_csp_substate == RRCCSP_CELL_SEL_WT_SIB_PENDING))))
  {
    WRRC_MSG0_HIGH("DSIM_TUNEAWAY: Preemption can't be handled as CCM camping status is not CAMPED ON");
    return_value = FALSE;
  }
  else if((rrccu_get_cell_update_started_status() == RRCCU_STARTED)&&
  !((cause_preemption == CAUSE_QTA)&&((rrc_csp_substate == RRCCSP_CELL_SEL_WT_SIB)||(rrc_csp_substate == RRCCSP_CELL_SEL_WT_SIB_PENDING))))
  {
    WRRC_MSG0_HIGH("DSIM_TUNEAWAY: Preemption can't be handled as CU update started");
    return_value = FALSE;
  }
  else if((rrcrcr_is_proc_active() == TRUE) && !((WCDMA_RRC_IDLE_FEATURES(RRC_QTA_DURING_SIGNALLING))&&(cause_preemption == CAUSE_QTA)&&(wrm_is_next_tuneaway_page_decode() == TRUE) ))
  {
    WRRC_MSG0_HIGH("DSIM_TUNEAWAY: Preemption can't be handled as rrcrcr proc is active");
    return_value = FALSE;
  }
  else if(rrccho_is_wtog_cco_active() == TRUE)
  {
    WRRC_MSG0_HIGH("DSIM_TUNEAWAY: Preemption can't be handled as wtog cco in progress");
    return_value = FALSE;
  }
  else if(rrccho_is_gtow_pcco_in_progress() == TRUE)
  {
    WRRC_MSG0_HIGH("DSIM_TUNEAWAY: Preemption can't be handled as gtow pcco in progress");
    return_value = FALSE;
  }
  else if(rrcdt_is_cs_domain_open() == TRUE)
  {
    WRRC_MSG0_HIGH("DSIM_TUNEAWAY: Preemption can't be handled as CS domain is open");
    return_value = FALSE;
  }
  else if(rrclbt_is_lb_on() == TRUE)
  {
    WRRC_MSG0_HIGH("DSIM_TUNEAWAY: Preemption can't be handled in Loob back mode");
    return_value = FALSE;
  }
  else if(rrc_csp_substate == RRCCSP_WT_SUSPEND_MODE_CHANGE_CNF)
  {
    WRRC_MSG0_HIGH("DSIM_TUNEAWAY: Ignore Preemption. anyway rrc is releasing the lock fter suspend cnf");
    return_value = FALSE;
  }
  else if((rrc_query_mac_rab_status() == CS_PLUS_PS_RABS) || (rrc_query_mac_rab_status() == CS_RABS))
  {
    WRRC_MSG0_HIGH("DSIM_TUNEAWAY: Ignoring Preemption as CS RABS are up ");
    return_value = FALSE; 
  }
  /*Delay premption so that CSP gets chance to send channel config after resume*/
  else if(rrc_csp_substate == RRCCSP_WT_RESUME_MODE_CHANGE_CNF)
  {
    WRRC_MSG0_HIGH("DSIM: Delay premption processing till channel config.");
    return_value = FALSE;
  }
  /*Avoid sending RRC to move to standby if LLC state is wait for state change ind*/
  else if((cause_preemption != CAUSE_QTA) && (rrcllc_return_current_substate() == LLC_WAIT_FOR_STATE_CHG_IND))
  {
    WRRC_MSG0_HIGH("DSIM_TUNEAWAY: Preemption can't be handled as LLC state is wait state chg ind");
    return_value = FALSE;
  }
  /* Allow LTA for 1X page. No need to check for 1X client as GSM is not going to ask for LTA for page */
  else if(rrc_check_for_pending_dl_srb_data() && !((WCDMA_RRC_IDLE_FEATURES(RRC_QTA_DURING_SIGNALLING))&&(cause_preemption == CAUSE_QTA)&&(wrm_is_next_tuneaway_page_decode() == TRUE))
          && !((cause_preemption == CAUSE_TA) && (wrm_is_next_tuneaway_page_decode() == TRUE)))
  {
    if((cause_preemption == CAUSE_IMMEDIATE) && (rrc_delay_preempt_counter > MAX_DELAY_PREEMPTION_COUNT))
    {
      WRRC_MSG0_HIGH("DSIM_TUNEAWAY: Despite pending dl srb data, trigger OOS as CS Call on other SUB");
      DS_Tuneaway_for_Immediate_preempt = FALSE;
    }
    else
    {
      WRRC_MSG0_HIGH("DSIM_TUNEAWAY: Preemption can't be handled as RRC is waiting for pending DL data");
      return_value = FALSE;
    }
  }
  /* Allow LTA for 1X page. No need to check for 1X client as GSM is not going to ask for LTA for page */
  else if(rrc_check_for_pending_l2_ack() && !((WCDMA_RRC_IDLE_FEATURES(RRC_QTA_DURING_SIGNALLING))&&(cause_preemption == CAUSE_QTA)&&(wrm_is_next_tuneaway_page_decode() == TRUE))
          && !((cause_preemption == CAUSE_TA) && (wrm_is_next_tuneaway_page_decode() == TRUE)))
  {
    if((cause_preemption == CAUSE_IMMEDIATE) && (rrc_delay_preempt_counter > MAX_DELAY_PREEMPTION_COUNT))
    {
      WRRC_MSG0_HIGH("DSIM_TUNEAWAY: Despite pending L2 ACK, trigger OOS as CS Call on other SUB");
      DS_Tuneaway_for_Immediate_preempt = FALSE;
    }
    else
    {
      WRRC_MSG0_HIGH("DSIM_TUNEAWAY: Preemption can't be handled as RRC is waiting for pending L2 ACK");
      return_value = FALSE;
    }
  }
#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  else if((TRUE == rrcdata_misc_info.rrc_buffer_ota_message) &&
    (NULL != rrcdata_misc_info.rrc_buffered_ota.cmd.downlink_sdu_ind.dl_sdu))
  {
    if(cause_preemption == CAUSE_IMMEDIATE)
    {
      WRRC_MSG0_HIGH("DSIM_TUNEAWAY: Despite OTA is buffered trigger OOS due to CS Call on other SUB");
      DS_Tuneaway_for_Immediate_preempt = FALSE;
    }
    else if((cause_preemption == CAUSE_TA) && (wrm_is_next_tuneaway_page_decode() == FALSE))
    {
      WRRC_MSG0_HIGH("DSIM_TUNEAWAY: Preemption can't be handled as tune-away is not requested for page decode");
      return_value = FALSE;
    }
  }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/ 
  return return_value;
}

/*===========================================================================

FUNCTION  rrc_check_can_l1_handle_preemption_in_fach_dch

DESCRIPTION

  This function checks if L1 can handle preemption  in FACH & DCH states
    
DEPENDENCIES

  None.
 
RETURN VALUE

  TRUE If pre-emption can be handled.
  else
  FALSE.

SIDE EFFECTS

  None.
===========================================================================*/

boolean rrc_check_can_l1_handle_preemption_in_fach_dch(void)
{
  if( (wl1_ok_for_tuneaway()) || (rrcwrm_is_unlock_required_received())) /* call L1 API to confirm L1 is ready to preempt or not */
  {
    return TRUE;
  }
  else
  {
    WRRC_MSG0_HIGH("DSIM_TUNEAWAY: Preemption can't be handled as L1 is not ready to handle Preemption");
    return FALSE;
  }
}

#ifdef FEATURE_WCDMA_FREE_FLOATING_TASK
/*===========================================================================

FUNCTION  rrc_sm_tuneaway_allowed

DESCRIPTION
  This function checks if tuneaway is allowed

DEPENDENCIES
  None.
 
RETURN VALUE
  TRUE If SM allows tuneaway
  else
  FALSE.

SIDE EFFECTS
  None.

===========================================================================*/

boolean rrc_sm_tuneaway_allowed(void)
{
  boolean status;
  status = rrc_csp_int_data.sm_ok_to_tuneaway;
  return status;
}
#endif
/*===========================================================================

FUNCTION  rrc_check_can_nas_handle_preemption_in_fach_dch

DESCRIPTION

  This function checks if NAS can handle preemption  in FACH & DCH states
    
DEPENDENCIES

  None.
 
RETURN VALUE

  TRUE If pre-emption can be handled.
  else
  FALSE.

SIDE EFFECTS

  None.
===========================================================================*/

boolean rrc_check_can_nas_handle_preemption_in_fach_dch(rrccsp_preemption_cause_e_type cause_preemption )
{
  boolean          return_value = TRUE;

  if(rrc_is_voice_rab_present() == TRUE)
  {
    WRRC_MSG0_HIGH("DSIM_TUNEAWAY:Preemption can't be handled as CS RAB is present");
    return_value = FALSE;
  }
  else if(rrcidt_is_idt_active(RRC_CS_DOMAIN_CN_ID) == TRUE)
  {
    WRRC_MSG0_HIGH("DSIM_TUNEAWAY:Preemption can't be handled as CS RAB IDT actively in progress");
    return_value = FALSE;
  }
  else if((rrcidt_is_idt_active(RRC_PS_DOMAIN_CN_ID) == TRUE) && !((WCDMA_RRC_IDLE_FEATURES(RRC_QTA_DURING_SIGNALLING))&&(cause_preemption == CAUSE_QTA)&&(wrm_is_next_tuneaway_page_decode() == TRUE) ))
  {
    WRRC_MSG0_HIGH("DSIM_TUNEAWAY:Preemption can't be handled as PS RAB IDT actively in progress");
    return_value = FALSE;
  }
#ifndef FEATURE_WCDMA_FREE_FLOATING_TASK
  else if(sm_ok_for_tuneaway() == FALSE)/* Call NAS API* to check whehter Tune away is allowed nor not */
#else
  else if(rrc_sm_tuneaway_allowed() == FALSE)
#endif
  {
    WRRC_MSG0_HIGH("DSIM_TUNEAWAY: Preemption can't be handled as CONVERSATION/STREAMING PS RAB is present");
    return_value = FALSE;
  }

  return return_value;
}

/*===========================================================================

FUNCTION  rrc_csp_handle_tuneaway_for_preemption_in_fach_dch

DESCRIPTION

  This function determines the next sub state in FACH & DCH states
    
DEPENDENCIES

  None.
 
RETURN VALUE

Next sub state

SIDE EFFECTS

  None.
===========================================================================*/

rrc_csp_substate_e_type rrc_csp_handle_tuneaway_for_preemption_in_fach_dch(rrc_cmd_type *cmd_ptr)
{
  rrc_csp_substate_e_type next_sub_state = rrc_csp_substate;

  if(rrc_csp_substate == RRCCSP_CAMPED_SUIT_CELL)
  {
    rrc_csp_int_data.curr_scan = RRC_CSP_UNLOCK_BY_SCAN;
    /* Send change mode request to MCM */
    if(rrc_sib_is_current_event_sib_read_in_dch())
    {
      rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_SIB_READ_IN_DCH);
    }
    rrccsp_send_mode_change_req_to_mcm(RRC_MODE_STANDBY);
    next_sub_state = RRCCSP_WT_SUSPEND_MODE_CHANGE_CNF;
  }
  else if(rrc_csp_substate == RRCCSP_WT_FOR_CHAN_CFG_CNF)
  {
    rrccsp_save_req(cmd_ptr);
    next_sub_state = RRCCSP_WT_FOR_CHAN_CFG_CNF_PENDING;
    rrc_csp_int_data.curr_scan = RRC_CSP_UNLOCK_BY_SCAN;
  }
  else if(rrc_csp_substate == RRCCSP_SUIT_CELL_RESELECT_WT_SIB)
  {
    /* First Initialize the SIB variables */
    /* Signal SIB procedure to clear up the active event, if any */
    rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_NGH_OOS);

    /* Reset the reselection data */
    rrccsp_reset_reselection_data();
    rrccsp_send_nbcch_teardown_req();
    rrc_csp_int_data.curr_scan = RRC_CSP_UNLOCK_BY_SCAN;
    /* Send change mode request to MCM */
    rrccsp_send_mode_change_req_to_mcm(RRC_MODE_STANDBY);
    next_sub_state = RRCCSP_WT_SUSPEND_MODE_CHANGE_CNF;
  }
  else
  {
    WRRC_MSG1_ERROR("DSIM_TUNEAWAY:Preemption is not handled in RRC state %d",rrc_csp_substate);
  }
  
  return next_sub_state;
}

/*===========================================================================

FUNCTION  rrc_csp_handle_preemption_in_FACH_DCH

DESCRIPTION

  This function determines the next sub state in FACH & DCH states
    
DEPENDENCIES

  None.
 
RETURN VALUE

Next sub state

SIDE EFFECTS

  None.
===========================================================================*/

rrc_csp_substate_e_type rrc_csp_handle_preemption_in_fach_dch(rrc_cmd_type *cmd_ptr)
{
  rrc_csp_substate_e_type next_sub_state = rrc_csp_substate;

  if(rrc_csp_substate == RRCCSP_WT_RESUME_MODE_CHANGE_CNF)
  {
    rrccsp_save_req(cmd_ptr);
    next_sub_state = RRCCSP_WT_RESUME_MODE_CHANGE_CNF_PENDING;
    rrc_csp_int_data.curr_scan = RRC_CSP_UNLOCK_BY_SCAN;
    DS_Immediate_preempt_waiting_for_init_cell_sel = TRUE;
  }
  else if(rrc_csp_substate == RRCCSP_WT_FOR_CHAN_CFG_CNF)
  {
    rrccsp_save_req(cmd_ptr);
    next_sub_state = RRCCSP_WT_FOR_CHAN_CFG_CNF_PENDING;
    rrc_csp_int_data.curr_scan = RRC_CSP_UNLOCK_BY_SCAN;
    DS_Immediate_preempt_waiting_for_init_cell_sel = TRUE;
  }
  else if(rrc_csp_substate == RRCCSP_CAMPED_SUIT_CELL)
  {
    next_sub_state = rrc_csp_initiate_CU_for_immediate_preempt_in_fach_dch();
    DS_Immediate_preempt_waiting_for_init_cell_sel = TRUE;
  }
  else
  {
    WRRC_MSG1_HIGH("DSIM_TUNEAWAY:Preemption is not handled in RRC state %d",rrc_csp_substate);
  }
  return next_sub_state;
}

/*===========================================================================

FUNCTION  rrc_csp_initiate_CU_for_immediate_preempt_in_FACH_DCH

DESCRIPTION

  This function iniiates Cell update req in FACH & DCH states
    
DEPENDENCIES

  None.
 
RETURN VALUE

Next sub state

SIDE EFFECTS

  None.
===========================================================================*/

rrc_csp_substate_e_type rrc_csp_initiate_CU_for_immediate_preempt_in_fach_dch(void)
{
  rrc_state_e_type          rrc_state = rrc_get_state();
  rrc_csp_substate_e_type next_sub_state = rrc_csp_substate;
  
  if(rrc_state == RRC_STATE_CELL_DCH)
  {
    /* Set oos_due_to_no_resource flag so that NAS is updated with NO SERVICE with cause
       NO RESOURCE*/
    rrc_set_oos_due_to_no_resource_flag();  
    next_sub_state = rrccsp_send_cell_update_initiate_req(RRC_RADIO_LINK_FAILURE);
  }
  else if(rrc_state == RRC_STATE_CELL_FACH)
  {
    /* Set oos_due_to_no_resource flag so that NAS is updated with NO SERVICE with cause
       NO RESOURCE*/
    rrc_set_oos_due_to_no_resource_flag();
    next_sub_state = rrccsp_send_cell_update_initiate_req(RRC_REENTERED_SERVICE_AREA);
  }
  else
  {
    WRRC_MSG1_HIGH("DSIM_TUNEAWAY:Ignoring IMMEDIATE_PREEMPT_IND in RRC state%d", rrc_get_state());
  }
  rrc_csp_int_data.curr_scan = RRC_CSP_CELL_SELECTION_SCAN;
  
  rrcwrm_check_and_trash_pending_cmd();

  return next_sub_state;
}

/*===========================================================================

FUNCTION  RRC_CSP_IS_PREEMPTION_HANDLED

DESCRIPTION

  This function checks the CSP substate and sends RESET_L1_REQ to L1.
    
DEPENDENCIES

  None.
 
RETURN VALUE

  boolean
  Indicates whether preemption handling is taken care or not

SIDE EFFECTS

  None.

===========================================================================*/
boolean rrc_csp_is_preemption_handled()
{
  boolean preemption_handled = TRUE;
  /*Currently Add for SIB substate only*/
  switch(rrc_csp_substate)
  {
    case RRCCSP_CELL_SEL_WT_SIB:
    case RRCCSP_CELL_SEL_WT_SIB_PENDING:
      /*Decrement frequency index so that we can retry on same frequency*/
      if(rrcsib_check_mib_read_status(TRUE))
      {
        /*Safety check*/
        if(rrc_csp_curr_select_data.num_available_freq > 0)
        {
          --rrc_csp_curr_select_data.num_available_freq;
        }
      }
      rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_OOS);

      rrc_csp_send_bch_release(FALSE);
     /* No break needed here */
    case RRCCSP_CELL_SEL_WT_ACQ:
    case RRCCSP_CELL_SEL_WT_ACQ_PENDING:
      rrc_csp_int_data.preemption_handling_in_progress = TRUE;
      rrc_csp_int_data.csp_waiting_for_wl1_to_release_lock = TRUE;
      rrc_csp_send_l1_idle_req();
      break;

    default :
      /*Ignore preemption if RRC is holding the lock for other CSP substates*/
      if(!WRM_CLI_STATE_IS_IN_LOCK(WCDMA_TRM, WRM_PRIMARY_CLIENT_RRC))
      {
        preemption_handled = FALSE;
      }
      break;
  }

  return preemption_handled;
}

/*===========================================================================

FUNCTION  RRC_HANDLE_PREEMPTION_IND

DESCRIPTION

  This function handles pre-emption indication and aborts the ongoing procedure.
    
DEPENDENCIES

  None.
 
RETURN VALUE

  Cell Selection Procedure substate.

SIDE EFFECTS

  None.

===========================================================================*/
rrc_csp_substate_e_type rrc_handle_preemtpion_ind(rrc_cmd_type *cmd_ptr)
{
  rrc_state_e_type curr_state = rrc_get_state();
  rrc_csp_substate_e_type next_sub_state = rrc_csp_substate;

  boolean handle_preemption = rrc_check_can_preemption_be_handled();
  rrc_csp_int_data.preemption_handling_in_progress = FALSE;


  /*Ignore immediate preemption when split acq in progress, as wl1 releases lock after step1/2 
    If step#3 is in progress, retain lock performed by RRC after ACQ CNF will help*/
  if(
      ((rrc_csp_int_data.shld_acq_be_spltd == TRUE) || 
      (rrc_csp_int_data.pending_type == RRC_CSP_WTOW_BPLMN_DRX_SRCH_TIMER_PENDING) || 
      (rrc_csp_int_data.pending_type == RRC_CSP_BPLMN_GUARD_SRCH_TIMER_PENDING)) && 
     ((rrc_csp_substate == RRCCSP_CELL_SEL_WT_ACQ)||
      (rrc_csp_substate == RRCCSP_CELL_SEL_WT_ACQ_PENDING))
    )
  {
    return next_sub_state;
  }

  if(handle_preemption)
  {
    if((rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN) ||
        (rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_MANUAL_SCAN) ||
        (rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_CELL_RESELECTION_SCAN)
      || (rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_REDIRECTION_SCAN)
      )
    {
      rrc_csp_int_data.preemption_handling_in_progress = TRUE;
      next_sub_state = rrc_csp_handle_gtow_lock_failure_or_preemption(RRC_WRM_LOCK_MAX,TRUE);
    }
    else
    {
      /* Do not rely on which client is holding the lock for preemption handling
       * as with Acq split and inter-sib sleep RRC client will no more be holding 
       * the lock for the complete duration of Acq or SIB reading 
       */
      if(!rrc_csp_is_preemption_handled())
      {
        /*We come here only for update SIBs and cell reselection events */
        if(rrcsib_is_sib_active())
        {
          if(!((rrc_csp_substate == RRCCSP_SUIT_CELL_RESELECT_WT_SIB) ||
             (rrc_csp_substate == RRCCSP_ACCEPT_CELL_RESELECT_WT_SIB)))
          {
            rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_OOS);
          }
          else
          {
            rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_NGH_OOS);
          }
        }

        switch (curr_state)
        {
          case RRC_STATE_DISCONNECTED:
            rrccsp_reset_reselection_data();
            rrc_ccm_update_with_cell_loss();
            if( (WTOW_SEARCH_STOP != rrc_csp_bplmn_srch_in_progress())
               && (rrc_csp_int_data.bplmn_nw_sel_mode == SYS_NETWORK_SELECTION_MODE_MANUAL))
            {
              WRRC_MSG0_HIGH("Do a Suspend/Resume for Manual BPLMN");
              if((rrc_csp_substate == RRCCSP_SUIT_CELL_RESELECT_WT_SIB) ||
                 (rrc_csp_substate == RRCCSP_ACCEPT_CELL_RESELECT_WT_SIB)
                )
              {
                rrccsp_send_nbcch_teardown_req();
              }
              rrc_csp_int_data.curr_scan = RRC_CSP_UNLOCK_BY_SCAN;
              /* Send change mode request to MCM */
              rrccsp_send_mode_change_req_to_mcm(RRC_MODE_STANDBY);
              next_sub_state = RRCCSP_WT_SUSPEND_MODE_CHANGE_CNF;
            }
            else
            {
              /* Set the flag oos_due_to_no_resource, so that service_ind will carry this and UI is not updated with no service */
              rrc_set_oos_due_to_no_resource_flag();
              next_sub_state = rrccsp_rel_chls_and_go_to_idle();
            }
            break;

          case RRC_STATE_CELL_PCH:
          case RRC_STATE_URA_PCH:
            rrccsp_reset_reselection_data();
            if( (WTOW_SEARCH_STOP != rrc_csp_bplmn_srch_in_progress())
               && (rrc_csp_int_data.bplmn_nw_sel_mode == SYS_NETWORK_SELECTION_MODE_MANUAL))
            {
              WRRC_MSG0_HIGH("Do a Suspend/Resume for Manual BPLMN");
              if((rrc_csp_substate == RRCCSP_SUIT_CELL_RESELECT_WT_SIB) ||
                 (rrc_csp_substate == RRCCSP_ACCEPT_CELL_RESELECT_WT_SIB)
                )
              {
                rrccsp_send_nbcch_teardown_req();
              }
              rrc_ccm_update_with_cell_loss();
              rrc_csp_int_data.curr_scan = RRC_CSP_UNLOCK_BY_SCAN;
              /* Send change mode request to MCM */
              rrccsp_send_mode_change_req_to_mcm(RRC_MODE_STANDBY);
              next_sub_state = RRCCSP_WT_SUSPEND_MODE_CHANGE_CNF;
            }
            else
            {
              /* Set the flag oos_due_to_no_resource, so that service_ind will carry this and UI is not updated with no service */
              rrc_set_oos_due_to_no_resource_flag();
              next_sub_state = rrccsp_send_cell_update_initiate_req(RRC_REENTERED_SERVICE_AREA);
            }
            break;

          default :
            WRRC_MSG1_ERROR("We should never come here. RRC State %d", curr_state);
            break;
        }
      }
    }
  }
  else if(rrc_check_can_rrc_handle_preemption_in_fach_dch(CAUSE_IMMEDIATE) && rrc_check_can_nas_handle_preemption_in_fach_dch(CAUSE_IMMEDIATE))
  {
    /* Reset preemption counter */
    rrc_delay_preempt_counter = 0;
    if(DS_Tuneaway_for_Immediate_preempt)
    {
      next_sub_state = rrc_csp_handle_tuneaway_for_preemption_in_fach_dch(cmd_ptr);
    }
    else
    {
      next_sub_state = rrc_csp_handle_preemption_in_fach_dch(cmd_ptr);
    }
  }
  else if(WRM_CLI_STATE_IS_IN_LOCK(WCDMA_TRM, WRM_PRIMARY_CLIENT_RRC) || WRM_CLI_STATE_IS_IN_LOCK(WCDMA_TRM, WRM_PRIMARY_CLIENT_L1))
  {
    if((rrcdt_is_cs_domain_open() == TRUE) || (rrciho_is_cs_data_rab_present() == TRUE))
    {
      WRRC_MSG0_HIGH("DSIM: Ignored Pre-emption as CS domain/RAB is present");
    }
    else
    {
      /* Increament the counter if preemption is to be delayed */
      rrc_delay_preempt_counter++;
      WRRC_MSG0_HIGH("DSIM: Pre-emption cannot be handled now. Start delay_preemption time of 100ms.");
      rrctmr_start_timer(RRCTMR_WRM_DELAY_PREEMPTION_TIMER, 100);
    }
  }

  if(rrc_csp_int_data.preemption_handling_in_progress)
  {
     WRRC_MSG0_HIGH("DSIM: CSP waiting for L1 to release the Lock");
  }
  return next_sub_state;
}


/*===========================================================================

FUNCTION  RRC_CSP_MAP_FREQ_SCAN_TO_LOCK_DUR

DESCRIPTION

  This function maps frequency scan to lock duration
    
DEPENDENCIES

  None.
 
RETURN VALUE

  None

SIDE EFFECTS

  None.

===========================================================================*/
void rrc_csp_map_freq_scan_to_lock_dur(rrc_csp_freq_scan_e_type type_freq_scan, uint32 *lock_time)
{
  /* If lock_time needs modification based on G2W TA it can be done in this function */
  switch(type_freq_scan)
  {
    /*If we decide to go for different values*/
    case RRC_CSP_ACQ_SCAN:
      if(rrc_csp_int_data.shld_acq_be_spltd)
      {
        *lock_time = WL1_TRM_SPLIT_ACQ_LOCK_TIME_MSEC;
      }
      else
      {
        *lock_time = WL1_TRM_ACQ_LOCK_TIME_MSEC;
      }
      break;

    case RRC_CSP_RAW_SCAN:
      *lock_time = WL1_TRM_RAW_SCAN_LOCK_TIME_MSEC;
      break;

    case RRC_CSP_FINE_SCAN:
      *lock_time = WL1_TRM_FINE_SCAN_LOCK_TIME_MSEC;

      break;
    case RRC_CSP_ADDL_CHLS_SCAN:
      *lock_time = WL1_TRM_ADD_CHNL_SCAN_LOCK_TIME_MSEC;
       break;

    default:
      *lock_time = WL1_TRM_ACQ_LOCK_TIME_MSEC;
      break;
  }
}


/*===========================================================================

FUNCTION  RRC_CSP_CONTINUE_WAIT_FOR_WRM_LOCK

DESCRIPTION

  This function starts cells seletion afresh when RRC is not able to acquire lock
  long time.
    
DEPENDENCIES

  None.
 
RETURN VALUE

  CSP substate

SIDE EFFECTS

  None.

===========================================================================*/
rrc_csp_substate_e_type rrc_csp_continue_wait_for_wrm_lock(rrc_csp_freq_scan_e_type *type_freq_scan)
{
  rrc_out_of_lock_wait_e_type wrm_lock_status;
  boolean dont_wait_for_lock = FALSE;
  uint32 lock_time; /*Constant lock time in ms*/
  rrc_csp_substate_e_type next_sub_state = rrc_csp_substate;
  wrm_freq_input_type lock_req_bands;

#ifdef FEATURE_PCS_850_FREQ_SCAN_OPTIMIZATION
  rrc_csp_int_data.gsm_svc_srch_done = FALSE;
#endif

  if(rrc_csp_start_cell_selection(&rrc_csp_int_data.curr_req_plmn, 
                                  &rrc_csp_int_data.curr_type_acq, 
                                  &rrc_csp_int_data.curr_acq_entry,
                                  type_freq_scan) 
    == FAILURE)
  {
    WRRC_MSG0_ERROR("ERR No freq by Stored Initial cell selection");
    rrc_ccm_update_with_cell_loss();
    *type_freq_scan = RRC_CSP_NO_SCAN;
    return (rrccsp_rel_chls_and_go_to_idle());
  }
  /*Use the constant lock time*/
  rrccsp_populate_req_bands_for_lock_during_cell_sel(*type_freq_scan, &lock_req_bands);
  do
  {
    /*Start the timer, continue if it is already running*/
    /*TBD: Timer value based on scans*/
    rrc_start_lock_wait_timer(RRCTMR_DEFAULT_SEARCH_TIME_IN_MS,FALSE);
    rrc_csp_map_freq_scan_to_lock_dur(*type_freq_scan, &lock_time);

    wrm_lock_status = rrc_acquire_wrm_lock(TRM_ACQUISITION, lock_time, lock_req_bands);
    if(wrm_lock_status == RRC_WRM_LOCK_NOT_ACQUIRED)
    {
      ERR_FATAL("DSIM:Lock is denied",0,0,0);
    }
    else if (wrm_lock_status == RRC_WRM_LOCK_ACQUIRED)
    {
      dont_wait_for_lock = TRUE;
      WRRC_MSG0_HIGH("DSIM:Lock is Acquired");
    }
    else if (wrm_lock_status == RRC_WRM_TIMER_EXPIRED)
    {
      WRRC_MSG0_HIGH("DSIM: Lock Wait timer expired");
    }
    else
    {
      dont_wait_for_lock = TRUE;
      *type_freq_scan = RRC_CSP_NO_SCAN;
      if(rrc_get_state() == RRC_STATE_DISCONNECTED)
      {
        next_sub_state = rrccsp_rel_chls_and_go_to_idle();
      }
      else
      {
        /*Go to the camped states, and be ready to process the STOP cmds from NAS or OOS from L1*/
        if(rrc_csp_int_data.curr_req_plmn.plmn_type == RRC_GSM_MAP_ANY_PLMN_REQ)
        {
          next_sub_state = RRCCSP_CAMPED_ACCEPT_CELL;
        }
        else
        {
          next_sub_state = RRCCSP_CAMPED_SUIT_CELL;
        }
      }
    }
  }while (!dont_wait_for_lock);
  return next_sub_state;
}

/*===========================================================================

FUNCTION  RRC_CSP_WAIT_FOR_WRM_LOCK

DESCRIPTION

  This function calls another function to request WRM for lock and takes action
  according to the lock status returned.
    
DEPENDENCIES

  None.
 
RETURN VALUE

  CSP substate.

SIDE EFFECTS

  None.

===========================================================================*/
rrc_csp_substate_e_type rrc_csp_wait_for_wrm_lock
(
  rrc_csp_freq_scan_e_type *type_freq_scan
)
{
  rrc_out_of_lock_wait_e_type wrm_lock_status;
  /*Constant Lock time in ms*/
  uint32 lock_time;
  rrc_csp_substate_e_type next_sub_state = rrc_csp_substate;
  wrm_freq_input_type lock_req_bands;

  /*Do not request for lock if we are waiting for W to stop*/
  if(rrcmcm_get_substate() == RRCMCM_WAIT_STOP_CNF)
  {
      WRRC_MSG0_HIGH("Do not request for lock as RRC is waiting for stop cnf");
     *type_freq_scan = RRC_CSP_NO_SCAN;
      return RRCCSP_NO_CELL_SELECTED;
  }

/*If UE is SS mode do not set acq split flag*/
  if(((!WCDMA_RRC_IDLE_FEATURES(RRC_ACQ_SPLIT_DURING_BPLMN)) && 
      ((rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN)||
       (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN) ||
       (rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_MANUAL_SCAN) ||
       (rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN))) || 
     (!wcdma_is_ue_in_dual_standby)||
#ifdef FEATURE_3GPP_CSFB
     (rrc_csfb_call_status) || /* Do not set ACQ SPLIT flag for CSFB and ECALL cases */
#endif
     ((rrc_csp_int_data.service_req_cause == RRC_MO_CS_CALL) && (rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED))
    )
  {
    rrc_csp_int_data.shld_acq_be_spltd = FALSE;
  }

#if defined (FEATURE_DUAL_SIM) && defined (FEATURE_3GPP_CSFB)
  if(rrc_csfb_call_status)
  {
    /* Do not modify the priority */
    if(WRM_CLI_STATE_IS_IN_LOCK(WCDMA_TRM, WRM_PRIMARY_CLIENT_RRC))
    {
      return next_sub_state;
    }
    /* Only in this case where RRC_SERVICE_REQ is received WRRC client will
     * not have lock during CSFB call
     */
    else if(rrc_csp_int_data.service_req_cause != RRC_MO_CS_CALL)
    {
      WRRC_MSG0_HIGH("Lock is not with WRRC when CSFB call is going on");
    }
  }
#endif

  rrc_csp_map_freq_scan_to_lock_dur(*type_freq_scan, &lock_time);

  if(WCDMA_RRC_IDLE_FEATURES(RRC_ACQ_SPLIT_DURING_BPLMN) && rrc_add_l1_wakeup_time)
  {
    /*Add 30 ms to lock wait time as L1 needs 30ms to wake up from Sleep state.*/
    lock_time = lock_time + 30;
    rrc_add_l1_wakeup_time = FALSE;
  }

  WRRC_MSG0_HIGH("DSIM: Do request and notify for TRM lock");
  rrccsp_populate_req_bands_for_lock_during_cell_sel(*type_freq_scan, &lock_req_bands);

  /* For the case of CSFB call through RRC_SERVICE_REQ and Ecall reuqest lock with urgent access */
  if(((rrc_csp_int_data.service_req_cause == RRC_MO_CS_CALL) &&
     (rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED))
#ifdef FEATURE_3GPP_CSFB
     || (rrc_csfb_call_status)
#endif
     )
  {
    wrm_lock_status = rrc_acquire_wrm_lock(TRM_ACCESS_URGENT, 0xFFFFFFFF, lock_req_bands);
  }
  else
  {
    wrm_lock_status = rrc_acquire_wrm_lock(TRM_ACQUISITION,lock_time, lock_req_bands);
  }

  if((wrm_lock_status == RRC_WRM_LOCK_NOT_ACQUIRED) || (wrm_lock_status == RRC_WRM_TIMER_EXPIRED))
  {
    if(wrm_lock_status == RRC_WRM_TIMER_EXPIRED)
    {
      if((rrc_csp_int_data.curr_scan == RRC_CSP_CELL_SELECTION_SCAN) ||
        (rrc_csp_int_data.curr_scan == RRC_CSP_OUT_OF_SERVICE_AREA_SCAN) 
#ifdef FEATURE_WRLF_SYSTEM_SEL
        || ((rrc_csp_int_data.curr_scan == RRC_CSP_LEAVING_CONN_MODE_SCAN) &&
        RRC_IS_CONN_MODE_OOS_SRCH_IN_PROGRESS())
#endif
        )
      {
        next_sub_state = rrc_csp_continue_wait_for_wrm_lock(type_freq_scan);
      }
      else  if((rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN) ||
        (rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_MANUAL_SCAN) ||
        (rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_CELL_RESELECTION_SCAN)
              || (rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_REDIRECTION_SCAN)
        )
      {
        *type_freq_scan = RRC_CSP_NO_SCAN;
        next_sub_state = rrc_csp_handle_gtow_lock_failure_or_preemption(wrm_lock_status,FALSE);
      }
      else if((rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN) ||
                (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN)
               )
      {
        *type_freq_scan = RRC_CSP_NO_SCAN;
        next_sub_state = rrc_csp_handle_wtow_bplmn_lock_failure(wrm_lock_status);
      }
      else
      {
        rrc_ccm_update_with_cell_loss();
        *type_freq_scan = RRC_CSP_NO_SCAN;
        next_sub_state = rrccsp_rel_chls_and_go_to_idle();
      }
    }
    else
    {
      ERR_FATAL("DSIM:Lock is denied",0,0,0);
    }
  }
  else if (wrm_lock_status == RRC_WRM_LOCK_ACQUIRED)
  {
    WRRC_MSG0_HIGH("DSIM:Lock is Acquired");
  }
  else if(wrm_lock_status == RRC_ABORT_FROM_RR)
  {
    *type_freq_scan = RRC_CSP_NO_SCAN;
    if((rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN) ||
        (rrc_csp_int_data.curr_scan == RRC_CSP_GTOW_BPLMN_MANUAL_SCAN) ||
        (rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_CELL_RESELECTION_SCAN)
      || (rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_REDIRECTION_SCAN)
      )
    {
      next_sub_state = rrc_csp_handle_gtow_lock_failure_or_preemption(wrm_lock_status,FALSE);
    }
  }
  else
  {
    *type_freq_scan = RRC_CSP_NO_SCAN;
    if((rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN) ||
              (rrc_csp_int_data.curr_scan == RRC_CSP_WTOW_BPLMN_MANUAL_SCAN)
             )
    {
      *type_freq_scan = RRC_CSP_NO_SCAN;
      next_sub_state = rrc_csp_handle_wtow_bplmn_lock_failure(wrm_lock_status);
    }
    else if(rrc_get_state() == RRC_STATE_DISCONNECTED)
    {
      next_sub_state = rrccsp_rel_chls_and_go_to_idle();
    }
    else
    {
      /*Go to the camped states, and be ready to process the STOP cmds from NAS or OOS from L1*/
      if(rrc_csp_int_data.curr_req_plmn.plmn_type == RRC_GSM_MAP_ANY_PLMN_REQ)
      {
        next_sub_state = RRCCSP_CAMPED_ACCEPT_CELL;
      }
      else
      {
        next_sub_state = RRCCSP_CAMPED_SUIT_CELL;
      }
    }
  }
  if((rrc_csp_int_data.curr_scan != RRC_CSP_CELL_SELECTION_SCAN) &&
    (rrc_csp_int_data.curr_scan != RRC_CSP_OUT_OF_SERVICE_AREA_SCAN) &&
    (rrc_csp_int_data.curr_scan != RRC_CSP_PLMN_LIST_SCAN) &&
     (rrc_csp_int_data.curr_scan != RRC_CSP_WTOW_BPLMN_AUTOMATIC_SCAN) &&
     (rrc_csp_int_data.curr_scan != RRC_CSP_WTOW_BPLMN_MANUAL_SCAN) &&
     (rrc_csp_int_data.curr_scan != RRC_CSP_GTOW_BPLMN_MANUAL_SCAN) &&
     (rrc_csp_int_data.curr_scan != RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN)
#ifdef FEATURE_WRLF_SYSTEM_SEL
     && (!((rrc_csp_int_data.curr_scan == RRC_CSP_LEAVING_CONN_MODE_SCAN) && 
          RRC_IS_CONN_MODE_OOS_SRCH_IN_PROGRESS()))
#endif
    && (!((rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_REDIRECTION_SCAN)
#ifdef FEATURE_3GPP_CSFB
         &&(!rrc_csfb_call_status)
#endif        
        ))
    )
  {
    rrc_stop_lock_wait_timer();
  }
  return next_sub_state;
}

/*===========================================================================

FUNCTION  RRC_SEND_DS_STATUS_IND_TO_L1

DESCRIPTION

  This function sends dual standby status informed by NAS to L1.
    
DEPENDENCIES

  None.
 
RETURN VALUE

  None.

SIDE EFFECTS

  None.

===========================================================================*/
void rrc_send_ds_status_ind_to_l1
(
  rrc_cmd_type * cmd_ptr
)
{
  /* local cmd var to send to L1 */
  l1_ext_cmd_type  *req_cmd_ptr;

#if defined(FEATURE_SGLTE_DUAL_SIM) || defined(FEATURE_SVLTE_DUAL_SIM)
  trm_get_info_input_type input_info;
  trm_get_info_return_type output_info;
  input_info.client_id = TRM_UMTS;
  input_info.info_type = TRM_SIMUL_CAPABILITY;
  uint32 trm_modes = 0;
#endif

  #ifdef FEATURE_TRIPLE_SIM
  rrc_is_tsts_mode_enabled = FALSE;
  #endif
  /* Get a L1 command buffer */
  req_cmd_ptr = l1_get_cmd_buf();

  wcdma_is_ue_in_sxlte_mode = FALSE;

#ifdef FEATURE_TRIPLE_SIM
    WRRC_MSG1_HIGH("DSIM: Received dual_standby_mode_info %d from MM",cmd_ptr->cmd.rrc_ds_status_change_ind.dual_standby_mode_info);
    switch(cmd_ptr->cmd.rrc_ds_status_change_ind.dual_standby_mode_info)
    {
      case SYS_MODEM_DS_PREF_SINGLE_STANDBY:
        req_cmd_ptr->cmd.ds_status_change_ind.multi_sim_mode = RRC_DUAL_STANBY_MODE_SINGLE;
      break;
      case SYS_MODEM_DS_PREF_DUAL_STANDBY:
      case SYS_MODEM_DS_PREF_DUAL_STANDBY_NO_TUNEAWAY:
        req_cmd_ptr->cmd.ds_status_change_ind.multi_sim_mode = RRC_DUAL_STANBY_MODE_DUAL;
  
      break;
      case SYS_MODEM_DS_PREF_TRIPLE_STANDBY:
      case SYS_MODEM_DS_PREF_TRIPLE_STANDBY_NO_TUNEAWAY:
        req_cmd_ptr->cmd.ds_status_change_ind.multi_sim_mode = RRC_DUAL_STANBY_MODE_TRIPLE;
        rrc_is_tsts_mode_enabled = TRUE;
  
      break;
      default:
        req_cmd_ptr->cmd.ds_status_change_ind.multi_sim_mode = RRC_DUAL_STANBY_MODE_NO_CHANGE;
  
      break;
    }
    WRRC_MSG1_HIGH("DSIM: Dual standy type %d",req_cmd_ptr->cmd.ds_status_change_ind.multi_sim_mode);
#endif

  wcdma_is_ue_in_dual_standby = cmd_ptr->cmd.rrc_ds_status_change_ind.dual_standby_mode;
  /* For device mode being DSDA we will downgrade single standby feature set to that 
   * of DSDA as there is no involvement of stack stop/start due to which any change of
   * of active subscriptions during W data call can result in erroneous behavior
   */
  wcdma_look_for_concurrency_nv = wcdma_is_ue_in_dual_standby;
  wcdma_device_mode = cmd_ptr->cmd.rrc_ds_status_change_ind.device_mode;
  if(wcdma_device_mode == SYS_MODEM_DEVICE_MODE_DUAL_SIM_DUAL_ACTIVE)
  {
    wcdma_is_ue_in_dual_standby = FALSE;
    wcdma_look_for_concurrency_nv = TRUE;
  }
  req_cmd_ptr->cmd_hdr.cmd_id = CPHY_DS_STATUS_CHANGE_IND;
  req_cmd_ptr->cmd.ds_status_change_ind.dual_standby_mode = cmd_ptr->cmd.rrc_ds_status_change_ind.dual_standby_mode;

#if defined(FEATURE_SGLTE_DUAL_SIM) || defined(FEATURE_SVLTE_DUAL_SIM)
  if((wcdma_device_mode == SYS_MODEM_DEVICE_MODE_DUAL_SIM_DUAL_ACTIVE) && cmd_ptr->cmd.rrc_ds_status_change_ind.dual_standby_mode)
  {
    trm_get_info(&input_info, &output_info);
    trm_modes = output_info.info.simul_cap_info;
    if ((trm_modes & TRM_SVLTE_IS_ENABLED) || 
          (trm_modes & TRM_SGLTE_SGTDS_IS_ENABLED)
       )
    {
      wcdma_is_ue_in_sxlte_mode = TRUE;
    }
  }
  req_cmd_ptr->cmd.ds_status_change_ind.trm_modes = trm_modes;
#endif

  MSG_HIGH("DSIM: Dual standy status %d is_in_sxlte %d  device mode %d",
               wcdma_is_ue_in_dual_standby,wcdma_is_ue_in_sxlte_mode,wcdma_device_mode);

  if(cmd_ptr->cmd.rrc_ds_status_change_ind.device_mode == SYS_MODEM_DEVICE_MODE_DUAL_SIM_DUAL_ACTIVE)
  {
    req_cmd_ptr->cmd.ds_status_change_ind.is_dual_active = TRUE;
  }
  WRRC_MSG1_HIGH("Dispatching out PHY cmd CPHY_DS_STATUS_CHANGE_IND: Sending L1 cmd 0x%x", req_cmd_ptr->cmd_hdr.cmd_id);
  l1_put_cmd( req_cmd_ptr );
}

/*===========================================================================

FUNCTION  RRC_SP_HANDLE_NO_RESOURCE_FROM_L1

DESCRIPTION

  This function handles no resource from L1 ,i.e the case when L1 is not able
  to acquire lock. RRC starts out of service search for such cases.
    
DEPENDENCIES

  None.
 
RETURN VALUE

  CSP substate

SIDE EFFECTS

  None.

===========================================================================*/
rrc_csp_substate_e_type rrc_csp_handle_no_resource_from_l1(void)
{
  rrc_state_e_type rrc_state = rrc_get_state();
  rrc_csp_substate_e_type next_substate = rrc_csp_substate;

  /* Set oos_due_to_no_resource flag so that NAS is updated with NO SERVICE with cause
     NO RESOURCE*/
  rrc_set_oos_due_to_no_resource_flag();

  /*
    >If RRC state is disconnected, start OOS search in IDLE state
    >If RRC state is Connecting, Force intialize RCE, start OOS search in IDLE state
    >If RRC state is connected, initiate CU with cause OOS
  */

  /*Re try mechanism for BCH setup failure due to no lock*/
  if(rrc_csp_substate == RRCCSP_CELL_SEL_WT_SIB)
  {
    rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_OOS);
    rrc_csp_int_data.curr_acq_count = rrc_csp_int_data.num_scr_code_det = 0;
    rrc_csp_bplmn_update_select_data_for_reattempt();
    next_substate = rrc_csp_release_bch_and_continue_cell_selection();
    return next_substate;
  }
  
  switch(rrc_state)
  {
    case RRC_STATE_CONNECTING:
      /*DSIMP2*/
      rrcrce_force_initialize(FALSE);
      next_substate = rrc_csp_start_sel_out_of_service_area_in_idle_state();
      break;
    case RRC_STATE_DISCONNECTED:
      /* If no resource from L1 is received, when RRC started processing a new service request, do not handle this indication from L1 */
      if(rrc_csp_int_data.last_mm_primitive != RRC_CSP_SRVC_REQ_RCVD) 
      {
        next_substate = rrc_csp_start_sel_out_of_service_area_in_idle_state(); /*Can have release channel and go to idle*/
      }
      else
      {
        WRRC_MSG2_ERROR("DSIM: No resource from L1 recvd in csp substate %d and curr_scan %d", 
                  rrc_csp_substate, rrc_csp_int_data.curr_scan);
      }
      break;
    default :
      /*Do not take any action if OOS procedure in progress*/
      if (!((rrc_csp_int_data.curr_scan == RRC_CSP_OUT_OF_SERVICE_AREA_SCAN)
#ifdef FEATURE_WRLF_SYSTEM_SEL
        || (((rrc_csp_int_data.curr_scan == RRC_CSP_LEAVING_CONN_MODE_SCAN) ||
              (rrc_csp_int_data.curr_scan == RRC_CSP_CELL_SELECTION_SCAN))  &&
              RRC_IS_CONN_MODE_OOS_SRCH_IN_PROGRESS())
#endif
         ))
      {
        next_substate = rrccsp_send_cell_update_initiate_req(RRC_REENTERED_SERVICE_AREA);
      }
      else
      {
        WRRC_MSG0_HIGH("DSIM: Do not handle no resource from L1 when OOSC is already in progress.");
      }
      break;
  }
  return next_substate;
}

/*===========================================================================

FUNCTION  RRC_CSP_REL_LOCK_AND_CONT_CELL_SEL_ON_PREV_PREEMPTED

DESCRIPTION

  This function is called after L1 has released lock due to preemption. This function then releases
  RRC lock and starts cell selection from the previous state.
    
DEPENDENCIES

  None.
 
RETURN VALUE

  CSP substate

SIDE EFFECTS

  None.

===========================================================================*/
rrc_csp_substate_e_type rrc_csp_rel_lock_and_cont_cell_sel_on_prev_preempted(void)
{
  rrc_release_lock();
  
  if((rrc_csp_int_data.curr_acq_count > 0) && (rrc_csp_int_data.curr_acq_count < rrc_csp_int_data.num_scr_code_det))
  {
    WRRC_MSG0_HIGH("DSIM: Detected cell being searched, dont decrement the ACQ DB index");
  }
  else
  {
    if(rrc_csp_curr_select_data.acq_db_in_use == TRUE)
    {
      rrccsp_bplmn_update_stored_acq_db_rd_index();
    }
    else if(rrc_csp_curr_select_data.scan_info.type_freq_scan == RRC_CSP_ACQ_SCAN)
    {
      --rrc_csp_curr_select_data.scan_info.fine_scan.curr_freq_index;
    }
    else if (rrc_csp_curr_select_data.scan_info.type_freq_scan == RRC_CSP_LIST_SCAN)
    {
      --rrc_csp_curr_select_data.scan_info.list_scan.curr_freq_index;
    }
  }

  /*Continue cell selection from Previous and return that substate*/
  return (rrc_csp_continue_cell_selection());
}

/*===========================================================================

FUNCTION  RRC_CSP_WAITING_TO_RELEASE_LOCK

DESCRIPTION

  This function is called to check if RRC is waiting for L1 to release lock.
    
DEPENDENCIES

  None.
 
RETURN VALUE

  TRUE: RRC is waiting for L1 to release lock.
  else
  FALSE

SIDE EFFECTS

  None.

===========================================================================*/
boolean rrc_csp_waiting_to_release_lock(void)
{
  return rrc_csp_int_data.preemption_handling_in_progress;
}

/*===========================================================================

FUNCTION        RRC_CSP_BPLMN_UPDATE_SELECT_DATA_FOR_REATTEMPT

DESCRIPTION     This function will update the indices of the ACQ DB/rrc_csp_curr_select_data so that search is attempted on the currently
                       populated entry

DEPENDENCIES
                None

RETURN VALUE
                None

SIDE EFFECTS
                None

===========================================================================*/
void rrc_csp_bplmn_update_select_data_for_reattempt(void)
{
  if((rrc_csp_int_data.curr_acq_count > 0) && (rrc_csp_int_data.curr_acq_count < rrc_csp_int_data.num_scr_code_det))
  {
    WRRC_MSG0_HIGH("DSIM: Detected cell being searched, dont decrement the ACQ DB index");
  }
  else
  {
    if(rrc_csp_curr_select_data.acq_db_in_use == TRUE)
    {
      rrccsp_bplmn_update_stored_acq_db_rd_index();
    }
    else if(rrc_csp_curr_select_data.scan_info.type_freq_scan == RRC_CSP_ACQ_SCAN)
    {
      --rrc_csp_curr_select_data.scan_info.fine_scan.curr_freq_index;
    }
    else if(rrc_csp_curr_select_data.scan_info.type_freq_scan == RRC_CSP_RAW_SCAN)
    {
      WRRC_MSG0_HIGH("BPLMN. Try Raw Freq Again.");
      rrc_csp_curr_select_data.scan_info.type_freq_scan = RRC_CSP_NO_SCAN;
    }
    else if(rrc_csp_curr_select_data.scan_info.type_freq_scan == RRC_CSP_FINE_SCAN)
    {
      WRRC_MSG0_HIGH("BPLMN Try Fine Freq Again.");
      rrc_csp_curr_select_data.scan_info.fine_scan_completed = TRUE;
      --rrc_csp_curr_select_data.scan_info.raw_scan.curr_freq_index;
    }
    else if(rrc_csp_curr_select_data.scan_info.type_freq_scan == RRC_CSP_ADDL_CHLS_SCAN)
    {
      WRRC_MSG0_HIGH("BPLMNTry Addl Chnl Scan again. Reset freq scan type to NO_SCAN");
      rrc_csp_curr_select_data.scan_info.type_freq_scan     = RRC_CSP_NO_SCAN;
      rrc_csp_curr_select_data.addl_chls_scan_needed        = TRUE;
    }
    else if(rrc_csp_curr_select_data.scan_info.type_freq_scan == RRC_CSP_LIST_SCAN)
    {
      WRRC_MSG0_HIGH("Retry LFS");
      rrccsp_bplmn_update_stored_acq_db_rd_index();
      --rrc_csp_curr_select_data.scan_info.list_scan.curr_freq_index;
    }
  }
}


/*===========================================================================

FUNCTION  RRC_CSP_HANDLE_GTOW_LOCK_FAILURE_OR_PREEMPTION

DESCRIPTION

  This function aborts the ongoing inter-RAT procedure in case of pre-emption
  or abort requests from RR.
    
DEPENDENCIES

  None.
 
RETURN VALUE

  CSP substate.

SIDE EFFECTS

  None.

===========================================================================*/
rrc_csp_substate_e_type rrc_csp_handle_gtow_lock_failure_or_preemption(rrc_out_of_lock_wait_e_type wrm_lock_status, boolean abort_due_to_preemption)
{
  rrc_csp_substate_e_type next_substate = rrc_csp_substate;

  if((wrm_lock_status != RRC_ABORT_FROM_RR) && (wrm_lock_status != RRC_WRM_TIMER_EXPIRED) && (!abort_due_to_preemption))
  {
    ERR_FATAL("DSIM: Invalid cause for GTOW lock failure",0,0,0);
  }

  switch(rrc_csp_int_data.curr_scan)
  {
    case RRC_CSP_GTOW_BPLMN_AUTOMATIC_SCAN:
    case RRC_CSP_GTOW_BPLMN_MANUAL_SCAN:
      if(wrm_lock_status == RRC_ABORT_FROM_RR)
      {
        rrc_csp_int_data.bplmn_srch_cnf = FALSE;
      }
      else
      {
        rrc_csp_int_data.bplmn_srch_cnf = TRUE;
        rrc_csp_int_data.rrc_rr_plmn_srch_cnf.srch_done   = FALSE;
        rrc_csp_int_data.rrc_rr_plmn_srch_cnf.hplmn_found = FALSE;

        if(!rrc_csp_int_data.bplmn_srch_tmr_expired)
        {
          rrctmr_stop_timer(RRCTMR_BPLMN_SRCH_TIMER);
          rrc_csp_int_data.bplmn_srch_tmr_expired = TRUE;
        }

        /* Handling the lock failure case as similar to BPLMN timer expiry 
           to properly reset the variables when FS/ACQ REQ fails due to
           unavailability of lock */
        rrc_csp_bplmn_update_select_data_for_reattempt();
      }

      /* stop WCDMA stack */
      rrc_csp_send_bch_release(FALSE);
      break;

    case RRC_CSP_GSM_TO_WCDMA_CELL_RESELECTION_SCAN:
      if(wrm_lock_status == RRC_ABORT_FROM_RR)
      {
        rrc_csp_int_data.rsp_to_rr        = SEND_GTOW_RESEL_ABORT_CNF;
      }
      else
      {
        rrc_csp_int_data.rsp_to_rr        = SEND_GTOW_RESEL_REJECT;
        rrc_csp_int_data.interrat_reselect_failure_reason = RRC_WCDMA_INAVALID_STATE;
      }
      break;

    case RRC_CSP_GSM_TO_WCDMA_REDIRECTION_SCAN:
      if(wrm_lock_status == RRC_ABORT_FROM_RR)
      {
        rrc_csp_int_data.rsp_to_rr        = SEND_GTOW_REDIRECTION_ABORT_CNF;
      }
      else
      {
        rrc_csp_int_data.rsp_to_rr        = SEND_GTOW_REDIRECTION_REJECT;
      }
      break;
    default :
      ERR_FATAL("DSIM: Invalid GTOW scan",0,0,0);
  }

  rrccsp_send_mode_change_req_to_mcm(RRC_MODE_INACTIVE);
  next_substate = RRCCSP_WT_STOP_MODE_CHANGE_CNF;

  return next_substate;
}

/*===========================================================================

FUNCTION        rrc_csp_handle_wtow_bplmn_lock_failure

DESCRIPTION     This function will handle the case of lock not granted for WTOW BPLMN

DEPENDENCIES
                None

RETURN VALUE
                Next CSP substate

SIDE EFFECTS
                None

===========================================================================*/
rrc_csp_substate_e_type rrc_csp_handle_wtow_bplmn_lock_failure
(
  rrc_out_of_lock_wait_e_type wrm_lock_status /*For now no use of this, can plan to use this later*/
)
{
  rrc_csp_substate_e_type next_substate;
  rrc_csp_bplmn_update_select_data_for_reattempt();
  rrccsp_reset_bplmn_list_search_state(WTOW_SEARCH_SUSPEND, FALSE, TRUE);
  if(rrc_csp_int_data.network_select_mode == SYS_NETWORK_SELECTION_MODE_LIMITED)
  {
    next_substate = RRCCSP_CAMPED_ACCEPT_CELL;
  }
  else
  {
    next_substate = RRCCSP_CAMPED_SUIT_CELL;
  }
  return next_substate;
}

/*==========================================================================
FUNCTION rrccsp_populate_req_bands_for_lock_during_cell_sel

DESCRIPTION
  This function is called to populate bands on which lock is required.
  During Cell Selection. based on the scan type, this function will populates band information

DEPENDENCIES
  None

RETURN VALUE
  Void

SIDE EFFECTS
  None
===========================================================================*/

void rrccsp_populate_req_bands_for_lock_during_cell_sel(rrc_csp_freq_scan_e_type type_freq_scan, wrm_freq_input_type *lock_req_bands)
{
  rrc_csp_band_class_type band_class;
  sys_band_class_e_type sys_band;
  uint8 i,j;
  boolean new_band = TRUE;
  rrc_plmn_identity_type temp_plmn_id;
  memset(temp_plmn_id.mcc, 0, RRC_MAX_MCC_DIGITS * sizeof(byte));
  
  memset(lock_req_bands,0,sizeof(wrm_freq_input_type));

  if(type_freq_scan == RRC_CSP_ACQ_SCAN)
  {
    rrc_wrm_populate_bands_for_lock_req(lock_req_bands, rrc_csp_int_data.curr_acq_entry.freq);
  }
  else
  { 
    if(type_freq_scan == RRC_CSP_LIST_SCAN)
    {
      if(rrc_csp_int_data.curr_scan == RRC_CSP_GSM_TO_WCDMA_REDIRECTION_SCAN)
      {
        for(i = 0; (i < rrc_csp_int_data.num_freq_in_list_db) && (lock_req_bands->num_bands < MAX_BAND_INFO); i++)
        {
          band_class = rrc_get_frequency_band(list_db[i].freq, temp_plmn_id);

          sys_band = rrc_convert_band_to_sys_band_class(band_class);
          for(j = 0; j < lock_req_bands->num_bands; j++)
          {
            if(lock_req_bands->bands[j].band==sys_band)
            {
              new_band = FALSE;
              break;
            }
          }
          if(new_band)
          {
            lock_req_bands->bands[lock_req_bands->num_bands].band = sys_band;
            lock_req_bands->num_bands++;
          }
          new_band = TRUE;
        }
      }  
      else
      {
        for(i = 0; (i < rrc_csp_curr_select_data.scan_info.list_scan.num_freq) && (lock_req_bands->num_bands < MAX_BAND_INFO); i++)
        {
          band_class = rrc_get_frequency_band(rrc_csp_curr_select_data.scan_info.list_scan.freq_result[i].ctr_freq, 
                                                                              temp_plmn_id);

          sys_band = rrc_convert_band_to_sys_band_class(band_class);
          for(j = 0; j < lock_req_bands->num_bands; j++)
          {
            if(lock_req_bands->bands[j].band == sys_band)
            {
              new_band = FALSE;
              break;
            }
          }
          if(new_band)
          {
            lock_req_bands->bands[lock_req_bands->num_bands].band = sys_band;
            lock_req_bands->num_bands++;
          }
          new_band = TRUE;
        }
      }
    }  
    else if((type_freq_scan == RRC_CSP_RAW_SCAN) || (type_freq_scan == RRC_CSP_FINE_SCAN) || (type_freq_scan == RRC_CSP_ADDL_CHLS_SCAN))
    {
      lock_req_bands->num_bands = 1;
      lock_req_bands->bands[0].band = rrc_convert_band_to_sys_band_class(rrc_csp_curr_select_data.current_band);
    }
  }
}
#endif

#ifdef FEATURE_LTE_TO_WCDMA
/*===========================================================================

FUNCTION        rrc_csp_fill_cgi_bplmn_tmr_exp

DESCRIPTION     This function will fill cgi info from MIB and SIB3 if available 
                upon BPLMN CGI timer expiry

DEPENDENCIES
                None

RETURN VALUE
                None

SIDE EFFECTS
                None

===========================================================================*/
void rrc_csp_fill_cgi_bplmn_tmr_exp
(
  void
)
{
  rrc_MasterInformationBlock *mib;
  rrc_SysInfoType3           *sib3;
  rrc_plmn_identity_type plmn;
  mib = (rrc_MasterInformationBlock *)rrc_bplmn_return_sib_for_cell(rrc_MIB);
  sib3 = (rrc_SysInfoType3 *)rrc_bplmn_return_sib_for_cell(rrc_SIB3);
  if((mib != NULL)&&(sib3 != NULL)&&(RRC_CHECK_COMMON_MSG_TYPE(mib->plmn_Type, rrc_PLMN_Type_gsm_MAP )))
  {
    WRRC_MSG0_HIGH("CGI: Filling the CGI partial info");
    rrc_translate_gsm_map_plmn_id(&(mib->plmn_Type.u.gsm_MAP->plmn_Identity), &plmn);
    rrc_csp_int_data.curr_acq_entry.plmn_id = plmn;
    rrc_csp_int_data.curr_acq_entry.cell_id = rrc_translate_cell_id(&sib3->cellIdentity);
#ifdef FEATURE_FEMTO_CSG
    rrc_csp_int_data.curr_acq_entry.csg_id = SYS_CSG_ID_INVALID;
    if(CSG_ID_IN_SIB3(sib3))
    {
      rrc_csp_int_data.curr_acq_entry.csg_id = rrc_translate_cell_id
                      ( &(sib3->v4b0NonCriticalExtensions.v590NonCriticalExtension.
                          v5c0NoncriticalExtension.v670NonCriticalExtension.v770NonCriticalExtension.
                          v830NonCriticalExtension.v860NonCriticalExtension.sysInfoType3_v860ext.csgIdentity));
    }
#endif
    rrc_csp_int_data.curr_acq_entry.status_mask = 0;
    rrc_csp_int_data.cgi_info_included = TRUE;
    rrc_csp_int_data.curr_acq_entry.rac_valid = FALSE;
    rrc_csp_int_data.curr_acq_entry.lac_valid = FALSE;

    if(rrc_is_nw_shared(mib))
    {
      rrccsp_find_shared_plmns(mib,plmn,&rrc_csp_int_data.curr_nw_db_entry);
      rrccsp_prioritize_the_list_of_shared_plmns();
      rrc_csp_int_data.curr_acq_entry.is_valid_nw_sharing = TRUE;
      /* Store the Current Acq. entry in Acq. database. */
      rrccsp_add_acq_db_and_nw_db_entries(&rrc_csp_int_data.curr_acq_entry,&rrc_csp_int_data.curr_nw_db_entry);
      rrc_csp_int_data.curr_acq_entry.plmn_id = rrc_csp_int_data.curr_nw_db_entry.shared_plmns_access_info[0].plmn_id;
    }
    else
    {
      rrc_csp_int_data.curr_acq_entry.is_valid_nw_sharing = FALSE;
    }
  }
}
#endif

/*===========================================================================

FUNCTION        RR_SEND_RRC_MESSAGE_TO_RR_INTERNAL

DESCRIPTION     This function will add AS ID to the messages sent from RRC to RR
                and calls the function which actually sends the message

DEPENDENCIES
                None

RETURN VALUE
                None

SIDE EFFECTS
                None

===========================================================================*/

void rr_send_rrc_message_to_rr_internal(
  void *            message_ptr,
  rrc_rr_cmd_e_type rrc_cmd_id,
  word              length
)
{
if(!(rrc_disable_crash_debug_info_nv & NV_CRASH_DEBUG_INFO_DISABLE))
{
  rrc_crash_debug_set_rrc_to_rr_cmd_id(rrc_cmd_id);
}
#ifdef FEATURE_QSH_EVENT_METRIC
  wrrc_qsh_log_rrc_to_rr_params((uint32)rrc_cmd_id);
#endif

#ifdef FEATURE_DUAL_SIM
  ((rrc_interrat_handover_abort_cnf_type *)message_ptr)->as_id = rrc_get_as_id();
#endif
   rr_send_rrc_message_to_rr(message_ptr, rrc_cmd_id, length );
  return;
}

/*===========================================================================

FUNCTION        RR_RRC_GET_ARFCN_BAND_INTERNAL

DESCRIPTION     This function will call appropriate RR function based on DSDS flag

DEPENDENCIES
                None

RETURN VALUE
                None

SIDE EFFECTS
                None

===========================================================================*/
sys_band_T rr_rrc_get_arfcn_band_internal(
  uint16                       arfcn,
  rrc_rr_frequence_band_e_type band_ind
)
{
#ifdef FEATURE_DUAL_SIM
  return  rr_rrc_get_arfcn_band_sub_id(arfcn, band_ind, rrc_get_as_id());
#else
  return  rr_rrc_get_arfcn_band(arfcn, band_ind);
#endif
}

/*===========================================================================

FUNCTION        RR_RRC_SET_BAND_PREF_INTERNAL

DESCRIPTION     This function will call appropriate RR function based on DSDS flag

DEPENDENCIES
                None

RETURN VALUE
                None

SIDE EFFECTS
                None

===========================================================================*/
void rr_rrc_set_band_pref_internal(sys_band_mask_type band_pref)
{
#ifdef FEATURE_DUAL_SIM
  rr_rrc_set_band_pref_sub_id(band_pref, rrc_get_as_id());
#else
  rr_rrc_set_band_pref(band_pref);
#endif
}

/*===========================================================================

FUNCTION        RR_RRC_SET_BST_BAND_PREF_INTERNAL

DESCRIPTION     This function will call appropriate RR function based on DSDS flag

DEPENDENCIES
                None

RETURN VALUE
                None

SIDE EFFECTS
                None

===========================================================================*/
void rr_rrc_set_bst_band_pref_internal(sys_band_mask_type band_pref)
{
#ifdef FEATURE_DUAL_SIM
  rr_rrc_set_bst_band_pref_sub_id(band_pref, rrc_get_as_id());
#else
  rr_rrc_set_bst_band_pref(band_pref);
#endif
}


/*===========================================================================

FUNCTION        RR_RRC_CLEAR_ACQ_CHNL_INFO_INTERNAL

DESCRIPTION     This function will call appropriate RR function based on DSDS flag

DEPENDENCIES
                None

RETURN VALUE
                None

SIDE EFFECTS
                None

===========================================================================*/
void rr_rrc_clear_acq_chnl_info_internal(void)
{
#ifdef FEATURE_DUAL_SIM
  rr_rrc_clear_acq_chnl_info_sub_id(rrc_get_as_id());
#else
  rr_rrc_clear_acq_chnl_info();
#endif
}

/*===========================================================================

FUNCTION        rrc_get_oos_timer_value

DESCRIPTION     This function will be called by L1 in idle/pch
                state.

DEPENDENCIES
                None

RETURN VALUE
                None

SIDE EFFECTS
                None

===========================================================================*/


uint32 rrc_get_oos_timer_value()
{
  return 12000; //in ms
}
/*==========================================================================
FUNCTION rrccsp_ignore_cu_due_to resel_cell_change_in_progress

DESCRIPTION
  This function is called to know if reselection is in progress to ignore CUC.

Scenario: Cell reslection is triggered during cell_update.
 
          CUC config and new cell config collision causes crash in L1. 
          So it is required to ignore CUC when reselecting to new cell and 
          UE database is getting updated due to that.
          There are two scenario henceforth and according fix added in the function -

          1. CUC is recieved just before CELL_CHANGE_REQ could reach CCM. 
              At this point CCM status still not set to indicate 
              reselection as cell_change_req is not reached to CCM yet.
              Hence This function is written to ignore CUC based on CSP substate indicating 
              reselection in progress. 

          2. CUC is received after CCM status updated to indicate reselection
              This is when cell_change_req already reached CCM. 
              To take care this, new function also has check on existing function 
              rrc_ccm_is_reselection_in_progress as well.

DEPENDENCIES
  None

RETURN VALUE
  TRUE : reselection is in progress
  FALSE: reselection is not in progress 

SIDE EFFECTS
  None
===========================================================================*/
boolean rrccsp_ignore_cu_due_to_resel_cell_change_in_progress(void)
{
  rrc_csp_substate_e_type  csp_sstate = rrc_get_csp_substate();

  if(   (csp_sstate == RRCCSP_SUIT_CELL_RESELECT_WT_CAMP)
     || (csp_sstate == RRCCSP_ACCEPT_CELL_RESELECT_WT_CAMP)
     || (csp_sstate == RRCCSP_SUIT_CELL_RESELECT_WT_CAMP_PENDING)
     || (csp_sstate == RRCCSP_ACCEPT_CELL_RESELECT_WT_CAMP_PENDING)
     || (rrc_ccm_is_reselection_in_progress() == TRUE)
    )
  {
    return(TRUE);
  }
  return(FALSE);    
}

/*===========================================================================

FUNCTION          rrc_get_rr_inter_rat_bplmn_prtl_result

DESCRIPTION       WRRC Calls the respective RR API to get Partial PLMN results from RR during ongoing WtoG
                  Manual PLMN Search

DEPENDENCIES
                  None
                  
RETURN VALUE
                  None

SIDE EFFECTS
                  None
===========================================================================*/
boolean rrc_get_rr_inter_rat_bplmn_prtl_result(sys_detailed_plmn_list_s_type *available_plmn_list)
{

#ifdef FEATURE_DUAL_SIM
          return(rr_get_inter_rat_bplmn_prtl_result_sub_id(available_plmn_list,rrc_get_as_id()));
#else
          return(rr_get_inter_rat_bplmn_prtl_result(available_plmn_list));
#endif
}



