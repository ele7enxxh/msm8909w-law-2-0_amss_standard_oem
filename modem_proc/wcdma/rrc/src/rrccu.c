/*===========================================================================

                          R R C   C E L L  U P D A T E  

DESCRIPTION

   This module supports Cell Update procedure for RRC layer as per 25.331
   Specification. In addition, this procedure also addresses Out of service 
   Area command from L1 in all RRC states.
   
   
EXTERNALIZED FUNCTIONS   

  rrccu_get_cell_update_started_status
    This function checks whether Cell Update procedure is started or not.  

  rrccu_get_cell_update_complete_status
    This function checks whether Cell Update procedure is active or not and 
    returns the status to the procedure.
  
  rrccu_procedure_event_handler
    This procedure is the event handler for the Cell Update  procedure.

  rrccu_init_procedure
    This function will initialize the Cell Update procedure substate to 
    RRCCU_INITIAL Substate. This will called in the RRCTASK modules 
    along with other Init Procedures.

   
INITIALIZATION AND SEQUENCING REQUIREMENTS
  
   RRC Task must have been started. All RRC command queues must
   have been initialized. All RRC signals must have been cleared
   at task startup.

Copyright (c) 2001-2009 Qualcomm Technologies, Inc.  All Rights Reserved.
QUALCOMM Proprietary.  Export of this technology or software is regulated
by the U.S. Government. Diversion contrary to U.S. law prohibited.

===========================================================================*/


/*===========================================================================

                        EDIT HISTORY FOR MODULE

  This section contains comments describing changes made to the module.
  Notice that changes are listed in reverse chronological order.

$PVCSPath:  L:/src/asw/MSM5200/RRC/vcs/rrccu.c_v   1.31   02 Jul 2002 17:13:48   rjeenaga  $   
$Header: //commercial/MPSS.JO.2.0.c1.4/Main/modem_proc/wcdma/rrc/src/rrccu.c#1 $    $DateTime: 2016/12/13 08:00:12 $ $Author: mplcsds1 $

when       who     what, where, why
--------   ---     ----------------------------------------------------------
11/03/16   sp     Made changes to reset CU registration info once reconfig procedure is successful
06/20/16   sg      Made changes to reduce F3s
05/25/16   sp      Made changes to add call end metrics - FR#30856
05/25/16   sp      Made changes to convert ota metric msg_id to enum
05/25/16   ad      Made changes to log important parms from OTAs
05/25/16   sp      Made changes for Mav debug snapshot
04/05/16   sg     Made changes to fail reselection when Channel configuration for CUC is in progress
05/12/16   sp      Made changes to reset oc set by cu flag if ORDERED_CONFIG variable gets cleared while Cell Update procedure waits for Layer-2 
                   level acknowledgement when Out Of Service indication is received so that cell selection is initiated for recovery
02/24/16   sr      API to indicate ordered state
12/08/15   nr      Made changes to get EFACH DRX status from config ptr in use
12/03/15   sp      Made changes to reject Cell update confirm if new configuration is given in CUC, during DCH to FACH timer expiry.
11/27/15   as      Made changes to trigger cphy act cancel only if cphy setup is in progress for procedure which set OC
10/19/15   sp      Made changes to trigger OOS if L2 ack for transition to PCH is received when inter freq resel is in progress
10/16/15   as      Added code to support LTA durting activation time
09/15/15   sp      Made changes to buffer RLC reset indicaiton in stand by mode.
09/04/15   sg      Made changes to ignore 'RRC_SIB7_UPDATE_STATUS_IND' in FACH state to avoid wrong security revert
09/03/15   sp      Made changes to map the cell update cause from the buffered comamnds if resume failure happens
06/03/15   sp      Made changes to accept new configuration in CUC after fach to dch physical channel failure.
04/17/15   sg      Made changes to transition to idle if CU initiate request is triggered in wait for rb proc complete indication
03/27/15   sp      Made changes to register the Cell update initiating procedure to receive cell update complete notification when RRC is in stand by mode.
01/13/15   ag      Made changes to update staus properly when trimming CU message for security_revert status set to revert.
01/08/14   sg      Made changes to mainline early implementable rel 10 spec CRs
12/12/14   sg      Made changes to start T302 after CMAC STATUS IND for CU
11/17/14   aa      Made Changes to remove the redundant reports of out of service event.
11/13/14   sp      Made changes to save procedure substates in crash debug info
11/12/14   aa      Made changes to avoid sending rab release indication when going to idle in the case of RL failure or RLC reset
11/11/14   sp      Made changes to increase the L2 ack timer value to 850 msec if EFACH_DRX is configured.
10/11/14   sg      Made changes to add validations for 3C window size
10/10/14   sr      Made changes to trigger tranistion to idle if TA duraitonis mroe than re-establishment timer values
09/30/14   sg      Made changes to send SCRI after response to CU confirm
09/25/14   sa      Made changes to configure the logical channel in pending config state
09/24/14   sp      Made changes to trim rel-10 non critical extensions if required.
09/17/14   sp      Made changes to return failure major when OC is set and RL failure is triggered.
09/15/14   sp      Made changes to reset delay CU flag and unregister with RLC at CU procedure cleanup
08/08/14   ad      Made changes to trigger reconfiguration failure after cell update
                   procedure gets finished due to SIB5 change
08/27/14   sp      Made changes to buffer cell update initiate req if WCDMA mode is suspended
08/06/14   ad      Made changes not to configure C/ERNTI during the channel configuration from CU and 
                   reconfigure MAC later when RNTI update happens.
08/06/14   ad      Made changes to include transport channel type as DCH instead of RACH.
08/04/14   sp      Made changes to fix compilation errors
07/28/14   sg      Made changes to add comments for delay CU 
07/21/14   sg      Made changes to reduce F3s
07/21/14   sp      Made changes to avoid triggering CU in URA PCH state if the cause is set as re-entered service area.
07/18/14   sp      Made changes to buffer t305 expiry/sib change indication at rrccu when RRC mode is standby.
07/15/14   sg      Made changes to release RBs associated to T314/T315 expiry on sending CU
07/08/13   ad      Made changes to buffer the UL data indication when free floating is enabled
                   if RRC is in standby mode and trigger it after resumption 
06/10/14   sg      Made changes to transmit SCRI after CU is completed if close_session 
                   is received in PCH or URA PCH states
06/19/14   sg      Made changes to revert the cipher config db if cipher config type is
                   updated to step1 but later message validation failed.
06/23/14   ad      Made changes to mainline SIB5 delay cell update and add NV control
06/18/14   as      Made changes to delay reselection while waiting for L2 ACK for PCH transition
06/17/14   rmn     Made changes so that after Cell Reselection completion in PCH State, 
                   Lock will only be released if CU is not active
06/17/14   sp      Made changes to mainline RLC-restablihment redesign changes
06/06/14   sg      Made changes to ignore RL Failure in W suspend mode
06/04/14   as      Made changes for DCH-FACH transition time optimization
06/02/14   sp      Made changes for FR19997 - UL rlc re-establishment redesign
04/18/13   ad      Made changes to buffer the UL data indication 
                   if RRC is in standby mode and trigger it after resumption
05/16/14   vi      Made changes to support MOB framework
05/14/14   ymu     Feature name FEATURE_WCDMA_DC_HSUPA_FRAME replacement with FEATURE_WCDMA_DC_HSUPA 
04/29/14   sp      Made changes to avoid saving CRNTI while going to cell_DCH state
04/10/14   sg     Made changes to correct the feature flag used for rel 10 spec CRs
04/02/14   vg      Made changes to Systematically log all the internal and external primitive handled in RRC and corresponding top level action.
04/01/14   sp      Fixed KW errors
03/28/14   vi      Made changes to set drx to 320ms if rrc_constant_320ms_drx_nv is set
03/13/14   sp      Made changes to update CU cause as cell-reselection when UE camps back after OOS in PCH and before T316 expiry
03/14/14   sp      Made changes to init re-establish entity on Procedure cleanup
03/14/14   sp      Made changes to avoid unnecessary re-establishment while coming out of pch state
03/13/14   sp      Removed code under FEATURE_WCDMA_HS_PCH feature flag
24/01/13   sg      Made changes to log CU and UU status as external event
02/04/14   db      Made changes to send cell update upon rentry into same URA
01/28/14   sp      Made changes to transition to disconnected if RLC reset is received when security is active
01/20/14   db      Made changes to not clear re-est entity in config pointer when CU is cleared
01/09/14   sp      Removed code under FEATURE_CS_VOICE_OVER_HSPA feature
01/02/14   sp      Made changes to fix CU cause appropriately based on priority when cause is RRC_UL_DATA_TRANSMISSION
12/24/13   db      Made changes to configure lower layers properly and detect size re-establishment for SIB5 change
12/24/13   sp      Made changes to reset reestab entity at procedure cleanup
12/13/13   db      Made changes to delay Cell Update when HSRACH Capability changes until Uplink Data Arrives 
12/09/13   sp      Made changes for OSYS 6.6.5 migration
12/05/13   db      Missing R9 Upmerge
12/03/13   mn      Moved all declarations to top of the code.
12/03/13   sp      Made changes to add nv support and to save time ticks for 
                   rr to/from rrc mm to/from rrc and to add msg_type for crash debug ota changes
11/07/13   as      Made changes to indicate security status ind as part of CU for Rel10 spe CR
10/30/13   as      Made changes to add feature code for FEATURE_WCDMA_3C_HSDPA
10/27/13   as      Made changes to backup OTAs for crash debugging
10/18/13   ad      Revert changes to init the reestablish entity during RL failure 
                   and also during clearing procedure
10/10/13   ad      Made changes to init the reestablish entity during RL failure 
                   and also during clearing procedure
10/07/13   db      Made changes to configure downlink properly upon PCH to FACH thorugh MR
09/29/13   db      Made changes to update failure status of procedure upon registration with CU and OC reset
09/16/13   mp      Added code for REL10 signalling under feature FEATURE_WCDMA_REL10
08/18/13   vg      Made changes to implement rel10 CR RP-130235
07/25/13   sg      Made changes to reset OC when intitate CU is received
                   when CU is waiting for RB1_RB4_EST_CNF and copy rlc params to 
                   CC from toc in chan_config_within fach fr RL failure
08/14/13   vg      Made changes to ignore CellUpdateConfirm messages during reselection in a corner case
07/26/13   vg      UE Not Including FailureCause IE Upon Radio Link Failure Leading To RLC Reset
07/31/13   vi      Mainlining the MODEM_STATISTICS feature
07/19/13   db      Made changes to Swap OC and CC after channel config by CU when
                   a procedure is registered and it fails
06/27/13   gv      Made changes to buffer the MM and RR commands for crash debugging
06/20/13   sg      Made changes not to set rrc_rlc_re_est_hs_rach_to_legacy and
                   rrc_rlc_re_est_legacy_to_hsrach during normal DCH to FACH 
                   transition.
05/31/13   sg      Made changes to register the procedured for CUC if waiting 
                   for L2 ACK during RLC reset.
06/12/13   ad      Made changes to configure from OC when cell update confirm takes to 
                   PCH state and OC is set.This will remove the use of 
                   RRCLLC_CHAN_CFG_EPCH_HRNTI_ONLY cause.
06/07/13   vi      Replaced ALLOC_ASN1ARRAY1 with ALLOC_ASN1ARRAY2
05/30/13   db      Made changes to ignore Cu-Cnf when RAB release is in progress
05/29/13   sa      Made changes to send the CU by omitting the 2drx scheme optional IE when CU oversized
05/22/13   md      Added code changes to support FEATURE_WCDMA_DC_HSUPA
05/22/13   sa      Made changes for spec CR5235
05/10/13   sg      Made changes to fix the compilation errors
05/08/13   db       Multiple mapping support for EFACH
04/22/13   ad      Made changes to set hspa_rnti_stored_cell_pch to TRUE when cell update/ura update
                   confirm’s response is UMIC
04/25/13   sg      Added code for REL9 under FEATURE_WCDMA_REL9
04/03/13   sg      Made changes to notify cell id in DCH state after chan 
                   config cnf
03/29/13   ad      Made changes to trigger transition to disconnected if cell reselection 
                   happens when CU is waiting for L2 ack for response message during SRNS 
                   relocation
03/28/13   db      to trigger RNTI update when URA-cnf is with dl-prot info and without 
                   integ/ciph info
03/22/13   mp      Removed tmc.h include file
03/06/13   ad      Made changes to stop T316 when UE comes back to service
                   in FACH state and during state change to idle
03/06/13   db      Made changes to reset the debug counter and stop timer upon transition to disconnected
03/04/13   db      Made changes to not release both domains when timer expires upon RL fail and no RABs are established
01/24/13   sg      Made changes to handle "RRCCU_WAIT_FOR_SRB2_RE_EST_CNF" in DCH and To send "RRC_CELL_UPDATE_COMPLETE_CNF"
                   when L2 ACK for CUC RSP is received in DCH state.
01/03/13   ad      Made changes to reduce the redundant F3s
01/03/13   db      Made changes to not Swap OC and CC  when DCH_FACH timer expires to an EFACH cell
12/27/12   db      Made changes to check RNTI's in cell update confirm
12/25/12   db      Made changes to requeue transition to disconnected, triggered by CU when there is no response
12/17/12   sg      Made changes to handle cell update initiate request from UECI when CU is in
                   WAIT_FOR_UE_TO_CAMP_ON
12/05/12   sg      Made changes to send PCRC complete if any one of the IEs "maxAllowedUL_TX_Power", 
                   "dtx_drx_Info" and "dtx_drx_TimingInfo" is included in CUC
12/04/12   ad      Fixed compilation errors in hsrach feature
11/28/12   db      Made changes not to send channel_config twice if OC is getting set
11/28/12   db      Made changes to retry CU if ERNTI is not provided if response is 
                   any message
11/20/12   mp      Fixed KW errors
11/09/12   ad      Made changes to release the RABs when OOS happens after T314 
                   or T315 expires while T302 is running
11/2/12    sg      Corrected the condition to check if the RBs are already added in chan_config 
                   before adding in rrccu_update_chan_config_rb_r7_for_efach function.
10/31/12   db      Fixed compilation error
10/26/12   db      EFACH Redesign changes
10/23/12   pm      Made changes to assign pointer to NULL after de-allocation
10/18/12   gv      Replace FEATURE_DUAL_SIM_WCDMA_TUNEAWAY with FEATURE_DUAL_SIM
10/16/12   db      Missing changes for QCHAT on Dime 
10/05/12   md      Fixed compilation error 
10/04/12   md      Made changes to detect RLC size change during state transitions via CELL PCH state.
10/04/12   pm      Made sure SRB's are present in Chan_config_req during FACH to DCH transition
10/03/12   pm      Made changes to convert the rlc-reestablishment code during cell 
                   resel into function, moved the code of ready_for_common_edch under 
                   hs_pch code, removed code which skips unregisteting RLC while coming
                   out of pch state
09/28/12   ad      Made changes to incorporate the review comments of CRs 377231,389499
09/28/12   pm      Added NV support for MAC_I
09/24/12   ad      Made changes to trigger Tx to idle if If UE is waiting for L2 Ack during SRNS relocation and 
                   OC is set by any procedure and then OOS happens
09/24/12   ad      Made changes to check hsrach/hsfach mapping only if cell supports hsrach.
08/28/12   db      Made changes to trigger closse session indication when RL fail occurs and T314 expires with no RAB established
08/21/12   ad      Made changes to check the L1 API if an resource is in use
                   or not when T305 expires
08/29/12   sa      Made changes to detect missing RB mappings for cell FACH state
08/16/12   sa      Made the changes to update the CU cause on missing C-NRTI
07/20/12   ad      Made changes to do rlc-reestablishment during reselections.
08/13/12   md      Added code changes to trim CU message size by skipping rel8 capability indication
                   in CU if CU is triggered for PS/CS session establishment.
08/13/12   db      Added code changes to trim CU message size by nullifying EDRX capability indication 
08/13/12   db      Added code changes to trim CU message size by nullifying EDRX capability indication 
                   when CU is triggered for CS call.
06/25/12   sks     Made changes to reduce (half) the number of CU retries if TA is enabled.
06/19/12   ad      Fixed bug to update the CU cause when CU is initiated
                   while waiting for SIB7
07/24/12   geg     Upmerge WCDMA.MPSS.1.0 to WCDMA.MPSS.2.0
11/07/12   ad      Made changes to handle ERNTI correctly. Changes to avoid starting MAC
                   for a HSRACH to HSRACH SIB5 change.Increased the handing rb size.
06/29/12   ad      Made changes for triggering CU if E-RNTI is not given.
                   Skipped the de-registration of WMs if HS-RACH is ON and RRC is 
                   triggering MR while coming out of PCH. Fixed bug to updated E-RNTI
                   in OC correctly. Added code to trigger CU if R99 or R5 CUCNF is received. 
                   Added code to keep L1 and MAC in sync wrt HS-RACH actions.
06/08/12   hs      Made changes for not to abort SRNS relocation procedure incorrectly 
                   based on CU initiate req flag set due to cell reselection in PCH state.
04/25/12   as      Made changes to trigger cell update/drx req when UE recived OTA with 
                   redirection info and cell reselection in progress
04/06/12   ad      Changes for HS-RACH feature
05/24/12   db      Made changes to restore HRNTI and mapping info on fach to dch phy chn failure
05/10/12   md      Added code changes to support FEATURE_MAC_I
03/28/12   db      Leftover feature cleanup of FEATURE_MODEM_MBMS
26/03/12   ad      Added changes to set the TOC for OOS if DCH to FACH timer expiry 
                   happens before OOS indication comes from L1. Also added code to 
                   send channel config request from procedure after recovery from OOS.
03/21/12   ad      Added changes to retry BPLMN if BPLMN suspension fails instead of crashing
03/19/12   db      Made changes to configure HRNTI when CU-Cnf moves non-EPCH UE to PCH state
03/14/12   sa      Made changes to acquire the lock during PCH to FACH state transistion
03/01/12   db      Added code to handle primary_plmn_Identity in R7 URA update confirm
02/17/12   db      Fixed Compiler errors and warnings
02/14/12   db      Fixed bug, memory being accessed without allocation
19/01/12   md      Fixed klocwork errors.
10/01/12   sa      Made changes to call rrc_acquire_lock_for_pch_to_fach() while waiting for SIB7
12/12/11   gv      Added code to support free floating of tasks
12/09/11   ad      Added code to log WCDMA_RRC_PROTOCOL_ERRORS packet
12/08/11   db      Made changes to trigger cell update if H-RNTI is missing 
11/30/11   db      Missed part of fix for ::Added code to include the reconfig_status indicator in a 
                   corner scenario where TOC is reset from TOC_FOR_OOS to TOC_FOR_DCH
11/20/11   db      Added code to include the reconfig_status indicator in a 
                   corner scenario where TOC is reset from TOC_FOR_OOS to TOC_FOR_DCH
11/15/11   db      Fixed Compilation Errors
11/15/11   sa      Ignoring the URA update confirm message while waiting for CU confirm message
10/17/11   ad      Added code to update the correct drx coefficient for R8 CUCNF
10/04/11   gv      Added code to provide call termination cause to NAS when RL Failure happens
09/21/11   gv      Fixed memory leaks
09/08/11   as      Fixed compilation error for R8
09/08/11   as      Made changes to properly extract directed freq info 
08/18/11   ad      Made changes to block rab establish indication if rabs have 
                   already been released under WRLF feature
08/02/11   rl      Merged with VU_MODEM_WCDMA_RRC.01.103.00
20/07/11   as      Made changes to fill correct L1 params for EFACH-DRX
07/19/11   rl      Merged with VU_MODEM_WCDMA_RRC.01.102.00
07/14/11   ad      Added changes to ignore the duplicate RB IDs when releasing RBs in CU
06/20/11   as      Made changes to ignore cell update confirm if reselection is in progress
05/10/11   rl      Merged with VU_MODEM_WCDMA_RRC.01.97.50
04/26/11   as      Made changes to handle cell update confirm with efach mapping
05/03/11   rl      Fixed the lint error
04/26/11   rl      Merged with VU_MODEM_WCDMA_RRC.01.96.50
04/20/11   vg      added suport for mdsp halt recovery
04/07/11   ad      Reset the OC when RNTI Update fails when OC is set
04/20/11   as      Made changes to handle cell update confirm with dhrnti and epch state
04/18/11   as      Added code to support feature EFACH-DRX 
04/07/11   as      Made changes to use proper loop check for rb affected list
04/07/11   rl      Merged with VU_MODEM_WCDMA_RRC.01.94.52
04/06/11   kp      Made changes to store HR-NTI in TOC from CU CNF for HS-FACH
03/28/11   rl      Merged the HS-FACH/PCH changes from mainline
03/14/11   rl      Merged with VU_MODEM_WCDMA_RRC.01.93.50
03/11/11   ad      Made changes to handle rlc_Re_establishIndicator IEs when there is
                   no UL response to cell update confirm for R6 and above cases 
03/10/11   kp      Added code to carry Rb.id & RLC buffer info in MR for 
                   ePCH to eFACH transition.
03/04/11   kp      During processing of R5 CU confirm message, If the OTA gives 
                   any mapping clear OC status, before processing the OTA. 
03/02/11   kp      Made changes to configure dH-RNTI for eFACH to ePCH
03/02/11   rl      Merged with VU_MODEM_WCDMA_RRC.01.92.50
02/18/11   as      Made changes to ingore RL Failure Ind when tuneaway is in progress
01/25/11   kp      added code for QCHAT to carry est_cause in cu
02/15/11   kp      Made changes to update TOC with H-RNTI.
01/28/11   rl      Merged with VU_MODEM_WCDMA_RRC.01.89.57
01/18/11   ad      Made changes to remove warning
01/12/11   ad      Added changes for RRC SW decoupling
12/31/10   rl      Merged with VU_MODEM_WCDMA_RRC.01.86.50
03/11/10   as      Made changes to recover CU when Cell update is initiated
                   and CU is in Pending state
11/29/10   rl      Merged with VU_MODEM_WCDMA_RRC.01.85.50
11/19/10   prk     Indicate e-fach capability if UE supports e-fach, irrespective
                   of network support.
11/09/10   rl      Merged with VU_MODEM_WCDMA_RRC.01.84.50
11/02/10   sks     Fixed KW errors.
10/25/10   ss      Added code changes to support SRNS through URA Update message
10/25/10   prk     Update CU cause for Epch to Efach transition.
10/08/10   prk     Fixes for e-fach scenario. Whenever CU intiates, configure 
                   lower layers with c-hrnti.
10/04/10   prk     Added code to support FEATURE_WCDMA_HS_PCH.
09/20/10   prk/kp  Added code to support FEATURE_WCDMA_HS_FACH
11/03/10   rl      Fixed compiler warnings. Unused variables removed.
10/30/10   rl      Objective systems migration changes check in 
                   on code base VU_MODEM_WCDMA_RRC.01.80.00
09/13/10   as      Added code to support FEATURE_DUAL_SIM
08/27/10   kp      Added code to indicate rrc_reconfigurationStatusIndicator_present
                   in CU for cause rrc_rlc_unrecoverableError, this will make our 
                   UE support spec cr-3742.
07/14/10   su      Fixed Lint errors.
06/29/10   rm      Added code to support LTE<->WCDMA Inter RAT
06/29/10   as      Removed feature flag WCDMA_UNIT_TEST for rrc stub code
06/18/10   as      Fixed compiler warnings
06/16/10   kp      Added code to indicate UE support of feature “Two DRX schemes in 
                   URA_PCH and CELL_PCH” and “E-DPDCH power interpolation formula”
                   for Rel-7 & above UE's.
06/07/10   ss      Added code to reset SVTHHO in case of failure message
05/28/10   prk     Fixed lint warning. Used rrc_malloc function call instead 
                   of macro RRC_GET_POINTER_L1_REQ_VALUE.
05/27/10   prk     Suppressed Lint warning. Since llc_cmd_l1_req is dummy which 
                   is declared to reuse the old function RRC_GET_POINTER_L1_REQ_VALUE.
05/26/10   dm      Made changes to put the code for allocating memory for WL1
                   cmd payload under feature FEATURE_RRC_REDUCE_CMD_SIZE.
05/26/10   gkg     Fixed a bug where memomry wasn't allocated for WL1 cmd payload 
                   while sending CPHY_ACT_TIME_CANCEL_REQ to WL1. The issue was 
                   happening only if feature FEATURE_RRC_REDUCE_CMD_SIZE is defined.
05/07/10   prk     Fixed compiler warnings.
04/26/10   ss      Added code changes for Fast Dormancy feature under feature flag
                   FEATURE_3GPP_FAST_DORMANCY
04/23/10   as      Fixed Klocwork issues
04/15/10   gkg     Fixed KW Errors in R8 Code.
04/08/10   gkg     Made changes to featurize T320 code for non-MBMS targets.
03/17/10   gkg     To comply with CMI, featurize Callback function pointer 
                   rrccu_rlc_ul_data_ind with feature FEATURE_DSM_WM_CB
03/17/10   as      Resolved Errors due to ASN.1 8.9 Migration
03/15/10   as      Updated RRC Code to support ASN.1 8.9 version
03/15/10   gkg     Made changes to put changes for "Multiple DRX Cycles" and 
                   "CU wait Timer" under feature R7. 
03/12/10   rm      Added code to support FEATURE_DUAL_SIM
02/01/10   dm      Made changes for handling DRX cycle length coefficient2 sent in CU 
                   confirm and URA Update confirm OTAs.
02/23/10   gkg     When CU CNF takes UE to Cell_DCH state, register with RLC for L2ACK 
                   of the response message of CU CNF.
02/18/10   ss      Made Changes to properly update pointers and bit_masks while removing 
                   monitored cells in CU trimming
02/11/10   gkg     Made changes for Opt Timer for CSoHS.
02/10/10   as      Added feature falg WCDMA_UNIT_TEST for rrc stub code
01/22/10   rm      Modified the usage of qchatupk_wcdma.h with rrc_qchatupk.h
                   (at the request of QCHAT team)
01/22/10   ss      Made changes in Start-Value calculation for CU in DCH to FACH with RAB est
01/20/10   gkg     Corrected a typo in ASN.1 migration for feature CU wait timer.
12/28/09   kp      Changes to implement rel-5 RRC spec rel 5.9.0 (2004/06) spec CR-2328.
12/22/09   gkg     Made changes for CSoHS so that NV 6878 controls CSoHS operation.
12/21/09   gkg     Made changes for CSoHSPA under feature FEATURE_CS_VOICE_OVER_HSPA.
12/07/09   ss      Changes to add Stub code under feature flag TEST_FRAMEWORK
12/03/09   gkg     Fixed Lint errors for QCHAT changes. (at the request if QCHAT team)
11/27/09   gkg     RRC changes required to integrate QChat Porting Kit Optimizations 
                   into AMSS. The changes are under feature FEATURE_QCHAT.
11/09/09   kp      Added code to relese SRB-4 through CU cnf.
11/07/09   gkg     Fixed LINT warnings.
11/02/09   rm      Added support for FEATURE_MODEM_STATISTICS
10/28/09   gkg     Fixed KW Errors.
10/29/09   gkg     In PCH state, when UE recovers in-service before the expiry of
                   T316, the CU cause is not prioritized from cell_reselection to 
                   re-entered service area.
10/07/09   gkg     Changes for REL8 under FEATURE_WCDMA_REL8
10/01/09   gkg     Made changes so that CS RAB Type is provided to MM in case
                   a RAB is released.
09/25/09   gkg/ps  Made changes to not intiate cell selection for FACH->FACH or
                   FACH->PCH redirection, if cell reselction is ongoing.
09/11/09   ps      Made changes for reducing the internal RRC command size 
                   under FEATURE_RRC_REDUCE_CMD_SIZE
06/31/09   gkg     Featurized the changes of R7 Spec CR 2910 under feature flag
                   FEATURE_RRC_DISABLE_R7_SPEC_CR_2910 [UE behaviour in RRC Connection 
                   Re-establishment scenarios]
08/17/09   ss      Added code to provide ciphering ON/OFF indication to UI 
                   under feature flag FEATURE_UMTS_VOICE_CIPHERING_IND.
07/27/09   gkg     Made changes so that CU procedure waits for SIB7
                   to be current whenever CU goes from Cell_PCH/URA_PCH to Cell_FACH.
08/06/09   ps      Fixed Lint warning
07/30/09   gkg     Corrected the compilation issue with previous check-in.
07/30/09   gkg     Made changes to handle the corner scenario when L1 triggers OOS 
                   IND just after UE has recovered from OOS due to RLF/RLC unrecoverable 
                   error.
06/05/09   ps      Made changes to not start the T305 timer if value is infinity
05/18/09   gkg     Corrected the oc_status which is used in the OOS area handling
                   for FACH->FACH or FACH->PCH Freq Redirection.
05/10/09   kp      Added support for demand paging RRC code using pragma.
05/08/09   ss      Updated Copyright Information
04/29/09   ss      Made changes to compiler warnings on gcc compilers.
04/23/09   gkg     When RLC unrecoverable error/RL Failure occurs while ASU procedure has
                   already set OC, we don't do error recovery through CU. We simply take RRC
                   Connection down.
04/09/09   ps      Made changes to send reconfig ind in CU/or go to idle
                   if RL failure is triggered while l2 ack for reconfig complete
03/28/09   rm      CMI Featurisation
03/25/09   gkg     Featurized code changes for High Mobility Indication. If 
                   FEATURE_WCDMA_REL7_SPECRS is not defined, no need to send
                   High Mobility Indication IE in Cell Update.
03/19/09   kp      Added support for handling clash between close_session_ind 
                   from CU due to local release of signalling connection & 
                   pending close_session_req from NAS.
03/05/09   kp      Added security related SRNS relocation support for DCCH message 
                   URA update cnf. 
02/18/09   ps      Made changes to to indicate L2 ack not required, if Cu is not
                   waiting for the response msg
02/18/09   gkg     Made changes to initialize invalid URA Id to RRC_INVALID_URA_ID.
                   This is defined as 0xFFFFFFFF which can't be a valid URA_ID because
                   URA_ID is 16 bits long.
01/19/08   ps      Made changes for ASn1 migration 25.331v7.9  
                   i.e.May 2008 version  (2008-05) 
12/17/08   gkg     When RLC RESET or RL Failure happens during DCH -> FACH transition, 
                   made changes so that procedure triggers Cell Update after receiving 
                   successful channel config cnf.
11/27/08   sk      Handling for new CU cause for pages lost during BPLMN 320ms
11/10/08   gkg     During Cell_DCH -> Cell_PCH state transition, if RL Failure occurs, and
                   UE recoveres to setup signaling RBs, there's no need to copy Standalone 
                   RB Mapping from ordered to current hanging database.
11/07/08   ps      Corrected to set the correct priority as Reentered service
                   area for OOS in rrccu_map_cu_cause_based_on_priority
09/12/08   ps      Added code for REl7 under FEATURE_WCDMA_REL7. Removed feature
                   flags FEATURE_OUT_OF_SERVICE_AREA
07/22/08   ps      Made correction to check for validation failure for rb release
                   and reconfig list only if no other validation failure exists
07/21/08   ps      Made changes to reject Cu Cnf, if the same RB ID exists in 
                   Rb Release list and RB Reconfig List
06/13/08   gkg     Made changes so that if RLC PDU size changes for RBs through
                   Transport Channel IEs of CU Confirm OTA, those RBs are reconfigured
                   and therefore their RLC entity is notified for new RLC PDU size.
06/05/08   ns      Added code to store the maximum of Count C values of RBs to be released.
                   This max value will be used later to calculate START
05/30/08   gkg     In case of Cell_FACH->Cell_DCH state transition, ignore
                   RRC_T305_EXPIRED_IND
04/23/08   ps      Made changes to set TOC for OOS, when OC is set for DCH_FACH 
                   transition, and OOS happnes when CU is in Wait for srb2_re_est_cnf
                   and wait for rnti update cnf
04/11/08   ps      Made changes to stop T302 timer irrespective of CU sub-state  
                   while going to disconnected state.
03/06/08   da      Added MBMS phase 2C changes.  MBMS support in CELL_DCH.  
                   Includes mobility and dynamic resource management.
03/06/08   da      Changed FEATURE_MBMS to FEATURE_MODEM_MBMS
02/13/08   rm      Made changes to set Traffic volume indicator in cell update message
                   under FEATURE_TVM_IND_IN_CU
02/06/08   rm      Made changes to set the reconfig indicator in cell update message
                   if cell update cause is rrc_re_enteredServiceArea and procedure is
                   waiting for L2 ACK for the reconfig message                 
01/10/08   ps      Fix to take care of missing  break statement
                   in rrccu_process_cu_wait_for_pcch_rb_est_cnf()
01/09/08   ps      Added code to resend a CU with Failure cause, on receiving
                   back to back Cell Update Confirm with directed info
12/21/07   da      Support for FEATURE_MBMS
11/28/07   da      In case OOS area gets detected during DCH->FACH transitions,
                   made change to setup DCCH+DTCH once returning in service before
                   sending CU message with cause "re-entered service area"
11/28/07   ps      Corrected merge issues introduced during checkin of 
                   version 8 of this file, due to which some code got 
                   missed out.   
11/28/07   rm      Added support for handling multiple RLC operations on a
                   single RB under FEATURE MULTIPLE RLC OPERATIONS   
11/14/07   rm      Made changes to configure the vocoder when CUCNF has taken UE to DCH
11/05/07   ps      Made modification to send a PCRC Complete as response 
                   if Frequency Info is present in Cell Update Confirm.
                   Also OC needs to be reset if Intiate Cell Update is sent
                   by procedure with cause as Physical Channel Failure in 
                   FACH->DCH case
10/23/07   kp      Added support for network sharing feature. Code changes to handle 
                   primary PLMN I.D in OTA message. Changes are under feature flag 
                   FEATURE NETWORK SHARING.
10/03/07   ns      Bug fix to take care of a race condition to put through 
                   emergency call in cell DCH state & UE is OOS. 
09/11/07   rm      Made changes to Set the Reconfig Indicator in Cell Update message
                   when UE re enters sevice during DCH to FACH Transition
09/10/07   ps      Added support for Frequency redirection received in 
                   FACH->FACH and FACH->PCH cases under feature flag
                   FEATURE_RRC_FREQ_REDIRECTION_THRU_RB_AND_CU
08/28/07   kp      Added support for capturing RACH transmission Statistic.
08/08/07   ps      Added support for feature cell id reading in DCH state, 
                   under feature flag FEATURE_WCDMA_GPS_CELL_ID_READING.
07/17/07   rm      Added support for FEATURE_WCDMA_INTER_FREQ_RACH_REPORTING feature.
06/13/07   kp      Added support for trimming CU message if it exceed UL TM RLC size.
                   currently we will remove monitored cell list, then try to see if it
                   can be sent on UL. If it fails then we will remove entire measurement
                   on RACH I.E. This is a general frame work if needed we may have to 
                   remove some more I.E’s to fit in UL RLC TM TB size
09/02/07   ps      Made changes to fill the RB config type in the correct pointer
                   before sending it to LLC in Channel Config Request
02/08/07   rm      Made Changes to send Periodic URA Update if T307 is running
                   after coming in service even though no Change of URA
02/07/07   ps      Made changes to handle Standalone Rb-Mappings
02/02/07   da      Added change to handle RLC unrecoverable error during DCH->FACH
                   transition
01/02/07   rm      Added changes to support Reconfiguration Status Indicator 
                   field in CU.
12/22/06   ps      Made changes to handle postVerificationPeriod and the
                           timingMaintainedSynchInd IE received in OTA messages
12/18/06   da      Fixed compiler warnings on 7200.
11/24/06   kp      Added additional check before setting RB Timer Indicator to 
                   see if T314/T315 is running while building cell update message.
11/21/06   da      Correct check to resend CU when CUCNF doesn't carry CRNTI.
11/20/06   da      Made change to handle OOS during DCH->FACH transition in 
                   RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM substate.
11/15/06   sm      Added code to make use of function rrcllc_validate_rb_info_reconfig_
                   list_r6() to avoid code duplication.
11/10/06   kp      Added the code to release CN signalling connection locally 
                   when all RAB's related to this CN domain are released due
                   to T314/T315 expiry.  
11/06/06   sgk     Fixed compilation errors when FEATURE RLC ONE SIDE RE ESTABLISHMENT
                   is turned on. 
10/04/06   kp      Added the code to release CS signaling connection locally after 
                   T314 expiries in case of RL fail.  
09/20/06   tkk     Indicating new release cause to NAS to prevent it incrementing
                   attempt counter during OOS.
09/12/06   sm/da   Fix code review comments and general clean-up for REL6 and HSUPA
09/11/06   da      Added support for FEATURE RLC ONE SIDE RE ESTABLISHMENT
09/11/06   kp      Added support for filling start list only per active cn-domain.
09/05/06   da      Using func rrc_transition_to_disconnected_state() which is 
                   a more general func than rrccu_transition_to_disconnected_state().
                   Removed rrccu_transition_to_disconnected_state()
09/05/06   da      When OOS is detected during transition from DCH, made change 
                   not to reject CUCNF when it doesn't have a CRNTI and the active RB 
                   procedure included a CRNTI and UE is camped on the directed cell.
                   In RRCCU_WAIT_FOR_RB_PROC_COMPL_IND substate, set flag
                   rrccu_cell_update_started if not already set.
08/29/06   sm/da   Made changes required for R6 ASN.1 migration.  Also merged
                   FEATURE_WCDMA_REL6 and FEATURE WCDMA HSUPA.
08/28/06   da      Added support for OOS area handling during transition from DCH.
08/21/06   tkk     Added SRB#5 support.
08/14/06   kp      Added support to avoid duplicate registration from procedures 
                   when CU is active in function rrccu_get_cell_update_complete_status
06/13/06   da      Made change to ignore non-existent RB_ID in rb release list.
06/05/06   sgk     Made changes to include rel5 non HSDPA functionality under 
                   FEATURE REL5 while retaining the HSDPA specifc processing 
                   under FEATURE HSDPA.
05/30/06   tkk/kp  Added fix to inform all registered RRC procedures that Cell
                   Update is completed when CU gets back to service on same cell
                   after OOS before T316 timer expiry.
05/01/06   da      If RLC re-est is indicated in CUCNF msg, then send RLC request
                   to re-established.  This was missing in R5 part of code when
                   the response to CUCNF is no response.
04/25/06   da      Removed function rrccu_is_sccpch_selection_required().  SCCPCH
                   selection when URNTI changes is now taken care of by rrcllc
                   when sending RNTI_UPDATE_REQ.  Also, check the status of 
                   RNTI_UPDATE_CNF.  If failed, re-send cell update msg.
04/18/06   da      Modified code to support migration to Mar-06 Rel-5 ASN1 +
                   R6 Hacks
03/15/06   tkk     Lint warnings/errors cleanup
03/10/06   da      Added Initial support for PDCP under FEATURE_UMTS_PDCP
03/07/06   vr      Moved the #defines used for purging WM from rrccu.c to rrcdata.h
                   since it is now being used outside CU also
03/03/06   da      Removed function rrccu_convert_t317_to_ms
02/28/06  da/sm    Modified code to support migration to Dec-05 Rel-6 ASN1
02/15/06   sgk     Added code to handle rl failure and rlc unrecoverable error
                   when there is an ongoing config with pending activation time. 
01/25/06   bd      Lint clean-up
01/23/06   vm      BPLMN Optimization for Automatically re-starting Manual 
                   BPLMN search after completion of LAU/RAU updates & added
                   support for not rejecting Manual PLMN search request when RRC state 
                   is Connecting/FACH/DCH and the establishment cause is Registration. 
12/22/05   tkk     Added support to register for CU complete confirm
                   (for certain causes) while reconfig procedures are waiting 
                   for L2 ack indication.
12/21/05   da      Wrapped fn rrccu_is_sccpch_selection_required_r5 under feature 
                   FEATURE HSDPA
12/18/05   da      Added workaround for selecting fresh SCCPCH when URNTI changes through 
                   cell update confirm.  Calling function rrc_send_rb_rate_info_packet()
                   after sending rsp to CUCNF to log rb rate info.
11/23/05   vr      Moved handling of InterRAT Vocoder optimization feature to
                   rrcdata.c
11/18/05   da      When RLC reset is detected, check if CCM is waiting for 
                   re-selection cnf.  If so, dequeue cmds in LLC-Q and go to 
                   cu substate RRCCU_WAIT_FOR_UE_TO_CAMP_ON.  This is done to give
                   UE the chance to reselect and camp on a good cell before sending the 
                   cell update.  Otherwise, cell update may not reach NW causing
                   UE to go to idle after MAX re-tries.
11/11/05   da      Check for nv_rel equal to rel 5 before setting est_cause in 
                   cell update msg.
11/10/05   da      Removed extern definition of nv_rel_ind;
11/10/05   da      Checking global flag rrc_nv_rel_indicator before doing R5 related
                   processing.
11/08/05   da      In CELL_PCH, URA_PCH, CU shall check with CSP if BPLMN search
                   is in progress before sending Cell Update msg or URA Update msg.
                   If BPLMN is in progress, CU shall send RRC_BPLMN_SUSPEND_REQ cmd
                   and wait for CNF before sending CU or URAU msg to NW.
09/26/05   ss      Added support for mac-d-HFN
09/26/05   ss      added the fix for transaction id not getting intialised
                   from message in URA update confirm (DL-CCCH processing)
09/14/05   tkk     Added Rel5 support for URA update confirm processing.
09/12/05   ss      Added the function rrccu_fill_est_cause to populate the establishment
                   cause in over the air message.
09/02/05   vr      Fix for rollback security config feature.Security config should
                   be rolled back only if a Cell Update is being intiated.Added extra checks
                   before calling the rrcsmc_check_and_abort_ongoing_security_configuration()
                   in CU initial substate handler.This function will not be called if the 
                   command under process does not initiate a cell update.
08/31/05   da      Added support for timer T316.  IF UE detects OOS in CELL_PCH or URA_PCH 
                   UE shall start T316.  If UE detects in service on same cell it was on
                   before going out of service and T316 is not expired, UE shall remain in 
                   PCH.  Else UE shall do a CELL UPDATE with cause re-entered service area.
08/30/05   da      In case of RL failure, made change to send rab_rel_ind to upper layers
                   immediatly if the associated re-est timer is set to 0 or  
                   as soon as timer expires.  Releasing the channel will still be done
                   upon re-entering service or when all timers [t314 and t315] expire.
08/15/05   da      Added check to take UE to idle when Cell update is initiated 
                   due to OOS [either indicated by L1 or other RRC procedures]
                   and re-establishment timers have expired.
08/05/05   da      Made change to limit the measuredResultsOnRACH IE in CU msg 
                   to just serving cell and exclude the monitored cell whenever 
                   CU msg includes failureCause.  This is so that CU msg doesn't
                   exceed the max rlc size limit.
07/29/05   da      Made change to update var mac_rab_status
07/22/05   da      Made changes to start min(T305,Toos) in certain sub-states 
                   where T305 is not active,  Change is under 
                   FEATURE_OUT_OF_SERVICE_ENHANCEMENT.
07/15/05   da      Setting IEs t314_expired and t315_expired in cell update msg
                   to TRUE if their values is set to 0.
07/08/05   vm      FEATURE_OUT_OF_SERVICE_ENHANCEMENT: Added support for OOS in 
                   Connected Mode feature.
                   OOS timer is now started only when remaining T305 > 30 minutes; and
                   UE will now go to idle if OOS timer expires even when UE is 
                   in W only mode.
07/07/05   da      At the time of RRC_T302_EXPIRED_IND, added a check to get the 
                   remaining time of T302.  If this remaining time is 0, then CU is 
                   re-sent else, CU must have been initiated again so ignore.
06/30/05   Sh      Added the function rrccu_purge_rlc_wm_rb3_rb4 to purge 
                   based on IDT message transmission.
06/27/05   vr      Support Cell Update with cause Re-entering service area from SIB 
                   procedure also.SIB proc will trigger CU when Update SIBS Ind event
                   fails(BCCH Modification).
06/27/05   da      Changed func rrccu_build_cell_update_msg to return rrccu_status_e_type.
                   Returns RRCCU_FAILURE_MINOR when URNTI is not present.  When URNTI is not
                   present, CU procedure shall clean up and go to initial substate without 
                   building Cell update msg for NW.
06/15/05   da      Handling OOS Area ind from L1 when RB proc is waiting for L2 ack.
06/07/05   da      Remapping CU cause CU is intiatiate with cause OOS and CU substate is in
                   wait_for_cu_cnf or wait_for_ura_cnf.
06/03/05   da      Setting var rl_cause to RL_FAILURE_DUE_TO_L1 before calling
                   event_report_payload when RL failure ind is due to a missed RCR 
                   in CU initial substate.
05/23/05   da      Resetting T305 when entering PCH state from FACH. Changed only under
                   FEATURE HSDPA.
05/03/05   sm      Added check to determine whether SMC is active or not before initiating
                   cell update. If SMC is active then abort ongoing security configuration.
04/14/05   da      Added code to handle cell update initate request, with cause 
                   RRC_REENTERED_SERVICE_AREA, from CSP to trigger out of service area 
                   handling.
04/01/05   sk      Do not re-transmit cellupdate or ura update if the cucnf
                   or uraupdate cnf is received on ccch and asn.1 decode fails.
03/23/05   da      Added check to stop t302 if UE  gets a state change ind to idle
                   when CU substate is RRCCU_WAIT_FOR_URA_UPDATE_CONFIRM
03/11/05   vk      Merged HSDPA code in Mainline from RRC_MSM6275 branch under FEATURE HSDPA
03/11/05   sk      Set "t314 expired" and/or "t315 expired"  as TRUE when the timer is
                   set to zero.
03/02/05     ttl         Support RRC ASN1 Release 5.
02/23/05   kc      Interrat HO optimization support.  Call IHO function to indicate
                   release of Voice-call
02/22/05   sk      Added functionality to purge RLC watermark for srb1 and 2 after rl failure
                   and purge srb0 watermark after detecting OOS
02/18/05   da      Added optimization for missed RRC connection release under 
                   feature name FEATURE_RRC_RELEASE_OPT
01/21/05   da      Added new function rrccu_get_max_timer_t314_t315
                   that returns the max of T314 and T315 timers.
01/12/05   da      Added a check to see if dl_CommonInformation and dl_InformationPerRL_List
                   are present if state indicated in cell update cnf is DCH 
01/10/05   sgk     Added procedure id as second parameter to function call
                   rrcmeas_append_meas_rpt_on_rach, in function
                   rrccu_build_cell_update_msg. 
01/04/05   da      Added Support for phase 1 of Physical channel establishment 
                   failure handling within DCH. 
12/23/04   sk      Remap the cu cause when oos is detected.
12/22/04   da      Put in fix to process rlc_Re_establishIndicatorRb2_3or4 and 
                   rlc_Re_establishIndicatorRb5orAbove in the case where UE gets a cell 
                   update cnf where no response is needed to be sent back to network.
12/21/04   da      Fixed Lint errors
12/15/04   svk     Copied the STOP_RB, CONTINUE_RB values to the correct structure while processing the
                   rb information to reconfigure list in the cell update confirm message.
12/06/04   da      Added check to validate the RB ids in rb_reconfig_list, rb_release_list
                   and rb_affected_list received in cell update confirm 
12/02/04   sm      Corrected argument to function 'rrcueci_check_and_send_ue_
                   capability_info_msg()' which is called after sending response to CU cnf
12/01/04   da      Added couple MSG_HIGH for debuging purpose
11/23/04   sm      Support for Dynamic Power Class and UL TPC power limiting
11/23/04   da      Changed Toos to use RRCTMR_CPHYCHANFAIL_TIMER_IN_MS with value 8s
                   rather than RRCTMR_PHYCHANFAILURE_TIMER_IN_MS with value 10s
11/22/04   da      Added support for phy chan setup fail and phy chan est fail in 
                   CELL_FACH->DCH from a cell update cnf msg and rb setup/reconfig.
11/11/04   da      Made fix to stop t307 and t305 after re-entering service area in URA/CELL_PCH
10/21/04   da      Removed FEATURE_CELLPCH_URAPCH.  CELLPCH and URAPCH states should always
                   be handled.  Deleted code that handles case when CELLPCH and URAPCH are not
                   defined.
                   Removed FEATURE_RL_FAILURE_HANDLING.  RL_FAILURE should always
                   be handled.  Deleted code that handles case when RL_FAILURE is not
                   supported.
10/19/04   da      Removed FEATURE SRNS RELOCATION.  SRNS_RELOCATION should always be
                   handled.  Deleted code that handles case when SRNS_RELOCATION is not
                   defined. 
10/18/04   sk      Removed the check that rejects cell update confirm when cu was
                   triggered due to RLC unrecoverable error on SRBs.
                   Added support to handle the scenarios where one of the re-establishment
                   timer is expired while other is still running.
                   Do not delete C-RNTI when OOS is detected. rrcllc will take care of it
                   during chan_config after re-entering service area. rrcllc will check
                   whether UE re-acquired the same cell or not and retain the old C-RNTI
                   if it is TRUE.
10/11/04   da      Removed Lint errors: handled Ignored return value of function 
                   rrcllc_reset_ordered_config.  fixed indentations errors. 
                   Handle ignored return value of function 'rrcllc_reset_ordered_config
10/01/04   sk      Made fixes to re-transmit cell update or ura update with the
                   right protocol error cause when cell update confirm or ura update
                   confirm is received with critical extensions. This issue was found
                   during GCF testing.
                   Set the right value for timer t307 when rrc_s5 is chosen.
10/01/04   da      Fixed the channel config cnf with failure that took UE automatically
                   to idle.  Added check to see if failure was due to a 
                   RRCLLC_CHAN_CFG_FAILURE_PHY_CHL which case UE initiate cell selection
                   with oos as cause, if cause was RRCLLC_CHAN_CFG_FAILURE_OTHER, UE goes
                   to idle and if RRCLLC_CHAN_CFG_FAILURE_INCOMPATIBLE_STATE, UE resends
                   the channel config request msg. 
                   Added a check to see if srb4 exits in rrccu_register_with_rlc_for_ul_data_in dication
09/28/04   svk     Handled stop and continue ie in cell udpaet confirm message.        
09/23/04   sk      Ignore Toos expired indication if UE is in WCDMA only mode.
09/22/04   sk      Fixed the OOS definition in cu_wait_for_ura_update_cnf state.
                   Do not include the failure cause while resending the cell update
                   message because there is no valid CRNTI. 
                   Do not register/unregister for ul data indication for RBs belonging to
                   CS domain RAB
09/21/04   sk      Added missing Toos expiry handling in CELL_PCH state when cu is 
                   waiting for UE to camp on.
                   stop all OOS related timers when CU is waiting for RB to be released
                   and it gets a state change indication to IDLE
09/15/04   sk      Added Out of service area handling support under feature definition
                   FEATURE_OUT_OF_SERVICE_AREA
                   Added Toos timer support.
                   Enhanced the existing substates to handle OOS indication from L1.
                   Added new function to check for OOS handling restrictions.
08/19/04   sgk     Included header file rrcrcr.h to fix lint error 
                   rrcrcr_is_proc_active' undeclared, assumed to return int
                   and call to function 'rrcrcr_is_proc_active()' not made in
                   the presence of a prototype.
                   Commented out check  if(cell_update_confirm == NULL) in 
                   function rrccu_find_response_to_cell_update_confirm and 
                   rrccu_process_cell_update_confirm to fix lint error Boolean
                   within 'if' always evaluates to False.
                   Commented out variable declarations for 'uu_cause', 'rab_id',
                   'cn_domain', 'num_rbs_for_rab', 'rb_for_rab', 'rab_info', 
                   'rb_release_in_cucnf' to fix lint error not referenced.
                   Removed break after return in switch statement in function 
                   rrccu_check_proc_waiting_for_l2_ack to fix lint warning
                   'unreachable'.
                   Type cast MAX_NUM_OF_PROCEDURES to uint32 in functions
                   rrccu_init_procedure, rrccu_reset_registration_info,  
                   rrccu_get_cell_update_complete_status and 
                   rrccu_register_for_cell_update_to_complete to fix lint 
                   warning Converting enum to int.
                   Removed the else part of 
                   if((int_cmd_ptr =  rrc_get_int_cmd_buf()) != NULL) in
                   function rrccu_send_rnti_update_req. If memory allocation
                   fails then the code err fatals in the rrc_get_int_cmd_buf().
                   Change done to fix lint warning 'unreachable'.
                   Removed return after ERR_FATAL in functions 
                   rrccu_remove_rbs_from_est_rabs, rrccu_send_rab_rel_ind_to_nas,
                   rrccu_build_cell_update_msg, rrccu_process_re_est_timers,
                   rrccu_find_response_to_ura_update_confirm, 
                   rrccu_process_ura_update_confirm,
                   rrccu_find_response_to_cell_update_confirm,
                   rrccu_process_cell_update_confirm, rrccu_send_response_msg,
                   rrccu_process_cu_wait_for_rb_est_cnf to fix lint warning 
                   'unreachable'.
                   Changed code to compare RRC_GET_T314 and RRC_GET_T315 with
                   the right enum rrc_T_314_s0 and rrc_T_315_s0 respectively 
                   in function rrccu_check_re_est_timers to fix the lint warning
                   Converting enum to int.
                   Removed local variables cause in function rrccu_send_response_msg,
                   sub_st in function rrccu_check_proc_waiting_for_l2_ack,
                   rrc_state in function 
                   rrccu_process_rlc_status_ind_in_non_initial_sub_states to 
                 fix lint warning 'not subsequently referenced'
08/09/04   kc      Complete support for RB-Re-est of TM-bearers after RL-failure.
08/05/04   bu      In rrccu_transition_to_disconnected_state(), instead of sending
                   CHANNEL_CONFIG_REQ (to take UE to IDLE), send 
                   INITIATE_CELL_SELECTION_IND to CSP, which will take UE to IDLE
                   and trigger cell selection.

07/21/04   sk      Added missing return statement in cucnf handling procedure 
                   when cu has to be retransmitted.
                   Populate chan_config_reason field with none in chan_config_req 
                   for fach->ura_pch transition.
07/20/04   sk      Set urnti action in rnti_update req properly when new URNTI
                   is received in ura_update_cnf message.
07/20/04   sk      Enter idle if OOS is detected in CELL_PCH/URA_PCH state.
07/19/04   sk      If rlc unrecoverable error had happened on signalling RBs
                   and if UE receives cucnf then discard cucnf and resend
                   cellupdate.
                   Added proc info in debug print when cu is initiated.
07/15/04   sk      Added support to handle RL failure/RLC unrecoverable error
                   Added new subatate CU_WAIT_FOR_RNTI_UPDATE_CNF
                   Added function to check and clear OC restrictions.
                   Enhanced each substate handling function.
                   created a separate functio to handle RLC error in non initial
                   substate.
                   Modifications for NEW_CELL_IND handling in cu substates. 
                   Send RNTIupdate req before channel config req if rlc has tobe
                   re-established. 
                   Check for rlc error status and re-establishment ind in cucnf
                   before accepting the message.
06/01/04   sk      Added a new function that checks whether Security reconfiguration
                   is active or rrc connection release proc is active.
                   If there is RL failure indication or RLC unrecoverable error
                   indication and if SMC or RRCRCR are active then enter idle
04/20/04   sk      Added the check to see V302*t302 >= T314/T315 when there is 
                   cell update re-transmission due to RL failure.
                   Fixed merge issue with the switch statement while establishing rb1-rb4
04/13/04   sk      Moved the CRNTI check to rrccu_process_cell_update_confirm message
                   so that we can remove all redundant checks.
                   Modified the new_cell_ind handling when UE has sent cell update
                   with cause rl failure. Instead of ignoring new_cell_ind re-send the
                   cell update on new cell.
04/08/04   sk      Modified the RL failure handling. Now UE goes to idle immediately
                   after sending the first cell update message when there is no
                   PS rab established.
                  
03/22/04   sk      Added missing support for RRCCU_WAIT_FOR_RB_EST_CNF substate
                   handling in CELL_DCH state.
03/10/04   bu      Changed ERR_FATAL to MSG_HIGHs when URNTI is not present.
                   In certain race condition scenarios it's possible that the
                   URNTI gets cleared by LLC and immediately after that cell update
                   tries to access it before it has got the STATE_CHANGE_IND to go
                   to IDLE.
03/04/04   ttl     Added FEATURE_CELLPCH_URAPCH for code of Cell_PCH/URA_PCH.
02/25/03   svk     When SRNS relocation is defined and if the msg does not have srns related info
                   send the UMI msg if CN information elements have changed even if CRNTI or URNTI
                   is not changed.
02/02/03   sk      Added RB IEs handling support in cellupdate confirm
                   Modified l2ack handling functionality. procedure will wait
                   for L2 ack only when security procedure is involved or next 
                   state is Cell_PCH/URA_PCH.
                   Delete RBs from Est_RABs variable when rb release info is 
                   present in cucnf message.
                   Handle state change indication to Cell_DCH state.
01/21/03   sk      Added missing freq and scr code parms in initiate_cell_selection
                   command and set them to false.
01/21/03   sk      Fixed an issue with a switch statement while establishing rb1-rb4
                   Set default values of T314 and T315 expiry to FALSE
12/05/03   vn      Fixed so that Cell Update is not triggered twice on T302 expiry.
11/19/03   sk      Modified L2ack handling. Go to idle if failed to get L2ack for
                   response message when procedure involves SRNS relocation. Otherwise
                   do not take any action.
11/17/03   sk      Added SRNS relocation support under feature FEATURE SRNS RELOCATION
                   Added funtion rrccu_clear_procedure to clear global variables.
                   Added SRNS relocation related IE handling in 
                   rrccu_process_cell_update_confirm function 
                   Added SRNS relocation handling support in send_response_message
                   Added new function rrccu_process_cu_wait_for_srb2_re_est_cnf
10/14/03   kc      Added support to sync up to new rrcsmc_append_start_list
                   interface.
09/30/03   sk      Added a check for "rrc state indicator" in cellupdate confirm 
                   message. If it is cell_PCH or URA_PCH then resend the cell
                   update message with cause "configuration unsupported" 
08/21/03   sk      Added a check for "dl counter sync info". If presenet then
                   discard the cellupdate confirm message and resend the 
                   cellupdate message.
08/04/03   vn      Indicate to RRCLLC when RLC entities need to be re-established
                   based on contents of Cell Update Confirm.
06/05/03   kc      Added Procedure_ID to rrcsmc_append_start_list function to
                   sync up to interface changes in SMC procedure.
05/23/03   svk     Added EVENT_WCDMA_OUT_OF_SERVICE, EVENT_WCDMA_RL_FAILURE
04/24/03   rj      Added code not to process Cell Update Confirm if does not
                   contain C-RNTI and UE does not have one. In this case
                   up on T302 expiry another Cell Update will be sent OTA.
03/18/03   rj      Added work-around to reset the Cell Update state machine
                   in case RRC goes to DISCONNECTED state.
03/05/02   rj      Added code to start T305 timer in case UE transitions to
                   CELL_FACH state from CELL_DCH state with a directed cell.
                   Added code so that Cell Update does not direct CSP to
                   do Cell Selection in either CONNECTING_STATE or 
                   CELL_FACH state if fetaure
                   FEATURE_RRC_CELL_UPDATE_ERRORS_SUPPORTED is not defined.
02/18/02   rj      Added code to check duplicate registration and fixed
                   return variable type for function
                   rrccu_register_for_cell_update_to_complete
02/05/03   sk      March2002Rel specific changes 
                       Changed rrc_CellUpdateCause_re_enteredServiceArea to
                       rrc_re_enteredServiceArea
                   Changed am_RLC_ErrorIndicationRb2or3 to
                   am_RLC_ErrorIndicationRb2_3or4
                   Changed am_RLC_ErrorIndicationRb4orAbove to
                   am_RLC_ErrorIndicationRb5orAbove
02/04.03   rj      Merged revision #39 changes that are lost during linted
                   changes check-in.
02/04/03   ram     Checked in lint changes.
01/10/03   vn      Added new parameter proc_id in rrcllc_set_ordered_config.
11/01/02   rj      Added code not to print MSG_HIGH when T305 expired in CELL_DCH
                   state.
10/31/02   vn/rj   Added code to process  State Change Indication in
                   rrccu_process_cu_wait_for_rb_rel_cnf for Disconnected state 
                   also. Added break at the end of processing for CELL_DCH in 
                   rrcu_process_cu_wait_for_ue_to_camp_on.
10/24/02   rj      Updated to use rrc_malloc and rrc_free to use dual heaps 
                   in place of mem_malloc and mem_free to avoid memory
                   fragmentation
09/20/02   bu      Changed l1_status to chan_cfg_status in chan_config_cnf &
                   call rrcllc_get_ordered_config_status() instead of 
                   rrcllc_is_ordered_config_set().
08/07/02   rj      Added code reset the registration info if Cell Update is
                   unsuccessful or some other procedure brings down
                   RRC Connection.
08/07/02   rj      Updated function rrccu_get_cell_update_complete_status to
                   perform range checking on number of procedures that are
                   registered with Cell Update procedure and Added generic
                   function rrccu_register_for_cell_update_to_complete to 
                   register for Cell Update during Cell Reselction.
07/02/02   rj      Added code to not to drop call if RLC RESET is successful.
06/28/02   rj      Added code to start T305 after Cell Update Confirm message
                   processing and there is no response to Cell Update Confirm
                   message. Re-arranged code to remove some redundancy.
06/24/02   rj      Added code to process CN Information IE received through
                   Cell Update Confirm.
06/24/02   rj      Updated function rrccu_process_cell_update_confirm not to
                   declare err-fatal if CN information IE is present for
                   periodic Cell Update.
06/18/02   rj      Updated function rrccu_process_rlc_status_ind to go to
                   RRCCU_WAIT_FOR_RB_REL_CNF substate while bringing down
                   RRC Connection.
06/17/02   rj      Added code to process RRC_CRLC_STATUS_IND command received
                   from RLC when RLC RESET occurs and bring down RRC Connection.
                   Also fixed a potential memory leak in function
                   rrccu_process_cell_update_confirm.
06/13/02   rj      Updated code to use U_RNTI from the ORDERED_CONFIG instead
                   of from RRCDATA module.
05/16/02   rj      Included reconfig header files and updated F3 messages.
03/29/02   rj      Included rrcsmc.h and renamed function rrc_append_start_list
                   to rrcsmc_append_start_list for Integrity Protection support.
03/13/02   rj      Fixed typos and added F3 messages.
03/13/02   rj      Added code to Ignore the RRC_STATE_CHANGE_IND in 
                   RRCCU_INITIAL substate.
03/12/02   rj      Modified function rrccu_inform_cell_update_completed to 
                   properly distribute RRC_CELL_UPDATE_COMPLETE_CNF command.
                   Added more F3 messages and delete an unused variable.
03/08/02   bu      Included rrcrbe.h.
03/07/02   rj      Added code to send RRC_CELL_UPDATE_COMPLETE_CNF command
                   to all registered RRC procedures. Modified code not to set
                   Ordered Config at the end of Cell Update Confirm Msg
                   processing by LLC.
                   Added code for functions rrccu_get_cell_update_started_status
                   and rrccu_get_cell_update_complete_status.
03/06/02   rj      Filled procedure variable while sending RRC_RNTI_UPDATE_REQ
                   command to LLC.
03/05/02   rj      Added code to start T305 if UE fails to Xmit Cell Update
                   message and fixed a bug while checking for RB2 RLC LC Id.
03/05/02   rj      Renamed varible rrc_u_rnti to rrc_u_rnti_internal.
03/05/02   rj      Added code to delete C-RNTI when RRC_CPHY_OUT_OF_SERVICE_AREA_IND
                   command is received fron the L1. Also fixed logic in 
                   identifying response for Cell Update Confirm message. Modified
                   code not to call Orderd Config if the response message is Utran
                   Mobility Confirm message.  Instead code is added to send
                   RRC_RNTI_UPDATE_REQ command to LLC to use new C-RNTI received 
                   through Cell Update Confirm message. Added code to initialize
                   transaction id for failure cases. Fixed logical channel type for
                   RB2 in function rrccu_send_response_msg.
03/04/02   rj      Fixed missing break statements and uncommented the code 
                   for T316 infinity value in function rrccu_convert_t316_to_ms.
02/28/02   rj      Added code for complete Cell Update procedure implementation.
                   This implementation includes state machine for all RRC states
                   and takes care of Radio Link Failure and Out of Service Area
                   inter-task commands from the L1.
02/14/02   rj      Updated function rrccu_get_cell_update_complete_status to
                   assume RRC always has a valid C-RNTI in CELL_FACH state.
02/14/02   rj      Modified rrccu_get_cell_update_status into two interfaces
                   rrccu_get_cell_update_started_status and 
                   rrccu_get_cell_update_complete_status. Updated code to read
                   Timers T314 and T315 from the IE"rrc_UE_ConnTimersAndConstants"
                   instead of SIB database.
11/06/01   rj      Initialized local variables to remove warnings.
10/24/01   rj      Removed embedded comments.
10/22/01   rj      Fixed ARM Compilation errors.
10/17/01   rj      Added code check timers T314 and T315. Added code to process
                   RRC_CPHY_RL_FAILURE_IND command and re-arranged some of 
                   the code.
08/07/01   rj      Corrected previous check in.
08/06/01   rj      Updated function rrccu_get_cell_update_status so that
                   UE transitions to Disconnected State whenever Cell
                   Update procedure is initiated.
07/27/01   rj      Updated function rrccu_procedure_event_handler with 
                   uecomdef.h define constants
07/15/01   rj      Created file.

===========================================================================*/


/* ==========================================================================
** Includes and Variable Definitions
** ========================================================================*/

/* -----------------------------------------------------------------------
** Include Files
** ----------------------------------------------------------------------- */

#include "wcdma_variation.h"
#include "comdef.h"

#include "rrcintif.h"
#include "rrccu.h"
#include "rrccmd_v.h"
#include "rrcdt.h"
#include "rrcdata_v.h"
#include "err.h"
#include "uecomdef.h"
#include "msg.h"
#include "rrcasn1.h"
#include "rrcsibdb.h"
#include "rrcscmgr.h"
#include "rrctmr.h"
#include "rrclcm.h"
#include "rrcsend.h"
#include "rrcmeas.h"
#include "rrcllc.h"
#include "rrcumi.h"
#include "rrccui.h"
#include "rrcrbcommon.h"
#include "rrcrbr.h"
#include "rrcrbe.h"
#include "rrcrbreconfig.h"
#include "rrctcreconfig.h"
#include "rrcpcreconfig.h"
#include "rrcsmc.h"
#include "rrcccm.h"
#include "rrcmcm.h"
#include "event.h"
#include "mmtask.h"
#ifdef FEATURE_CMI
#include "mmtask_v.h"
#endif
#include "rabmtask.h"
#include "rrclogging.h"
#include "rrcrcr.h"
#include "rrclogging.h"
#include "rrccspi.h"
#include "rrcllcoc.h"
#include "rrclog.h"
#include "rrcmisc.h"
#include "rrcasn1util.h"
#ifdef  FEATURE_WCDMA_INTER_FREQ_RACH_REPORTING
#error code not present
#endif /*FEATURE_WCDMA_INTER_FREQ_RACH_REPORTING*/


#ifdef FEATURE_UPDATE_SIB7_FOR_PCH_TO_FACH
#include "rrcsibproc.h"
#endif /*FEATURE_UPDATE_SIB7_FOR_PCH_TO_FACH*/

#ifdef FEATURE_QCHAT
#include "rrc_qchatupk.h"
#endif /*FEATURE_QCHAT*/



#include "rrcdormancy.h"

#include "rrcasn1util.h"

#ifdef FEATURE_WCDMA_HS_RACH
#include "rrcenhstatecfg.h"
#include "rrcenhstateproc.h"
#ifdef FEATURE_QCHAT
#include "rrcmeasi.h"
#endif
#endif
#ifdef TEST_FRAMEWORK
#error code not present
#endif
#ifdef FEATURE_WCDMA_HS_RACH
#include "rrchsrachcfg.h"
#include "l1rrcif.h"
#include "rlcrrcif.h"
#endif
/* -----------------------------------------------------------------------
** Constant / Define Declarations
** ----------------------------------------------------------------------- */

/* -----------------------------------------------------------------------
** Type Declarations
** ----------------------------------------------------------------------- */
#ifdef FEATURE_WCDMA_HS_RACH
#ifdef FEATURE_QCHAT
  typedef struct
  {
    /* Radio bearer identity */
    uint32  rb_id;
  
    /* Raw rlc buffer payload value */
    uint32  raw_rlc_payload; 
  }rrc_rb_id_list_type;
  
    
  typedef struct
  {
    uint16  num_rbs;
  
   rrc_rb_id_list_type  rb_id_list[MAX_RB];
  }rrc_rb_id_info_type;
#endif
#endif

typedef struct {
  boolean              cu_reqd;
  rrc_CellUpdateCause  cu_cause;
}rrccu_cu_initiate_reqd_type;

typedef struct {
  boolean error_on_srb;
  boolean error_on_urb;
}rrccu_rlc_unrecoverable_error_info_type;

                                       
typedef enum {
  RE_EST_TIMER_NOT_STARTED,
  RE_EST_TIMER_STARTED,
  RE_EST_TIMER_EXPIRED
}rrccu_re_est_timer_status_type;

/*typedef struct
{
  rrc_rab_id_type rab_id;           //GSM-MAP RAB Identity                
  rrc_CN_DomainIdentity cn_domain;  //CN domain for this RAB              
  uint32 num_rbs_for_rab;           //Number of RBs mapped to this RAB    
//NAS-Sync indicator may need to be stored later. It's not needed for now.
  rrc_rb_for_rab_type rb_for_rab[MAX_RB_PER_RAB];
}rrccu_rab_info_type; */

typedef struct {
  rrccu_re_est_timer_status_type timer_status;
  boolean need_to_release_rabs;
  boolean need_rab_release_ind;
 /* rrccu_rab_info_type rab_info[6]; */
}rrccu_re_est_timer_info_type;



typedef struct {
  rrccu_re_est_timer_info_type t314_info;
  rrccu_re_est_timer_info_type t315_info;
}rrccu_rlfailure_info_type;


typedef struct {
  uint32 rb_id; /* Hold the ids of the RBs */
  rrc_rb_cfg_e_type rb_config;
  uint16 ul_cfg_mask;
  uint16 dl_cfg_mask;
}rrccu_rb_id_action;




typedef struct {
  uint32 num_rbs;       /* Number of RBs tobe configured by the message          */
  rrc_rb_config_type rb_info[MAX_RB];
}rrccu_chan_config_info_type;


typedef struct {
/*  boolean  rb_release_in_cucnf  ;      */
  uint32 num_rbs;       /* Number of RBs released by the message          */
  uint32 rb_id[MAX_RB];
boolean  rrccu_rb_release_in_cucnf  ;      
}rrccu_rb_release_info_type;


/* This contains some of  the internal variables of CU 
 * Introducing the generic internal structure for CU.
 * So that in future all internal variables added in CU 
 * to can be added to this  structure. As it is easier to
 * maintain
 */
typedef struct
{
  /*Indicates if Cu Cnf was recieved conating Freq re-direction for FACH->FACH or FACH->PCH*/  
   boolean rrccu_cell_selection_trans_from_fach;
   /* If a Freq Redirection info is received in Cell Update confirm, then remember
    *  the Response message type, as it needs to be sent after successful reselection
    * on the new cell. And if the new cell is not the directed cell, then the response
    * of the first Cell Update confirm needs to be sent after a Cell update procedure  
    *  message for  cell reselection is complete on new cell
    */
   rrccu_resp_msg_e_type       rrccu_cell_selection_last_response_msg ;
   rrc_RRC_TransactionIdentifier   rrccu_cell_selection_last_trans_id ;
   boolean rrccu_last_cucnf_for_srns_relocation ;
   boolean  rrccu_last_cucnf_cipher_update_required ;

  /*This variable keeps track of the cause of CU for wait timer T320
  Basically, it stores the cause if it's Uplink Data Transfer or MBMS P2P RB
  Request.*/
  rrc_cell_update_cause_e_type cu_cause_for_wait_timer;

   /*This variable stores the value of wait timer given in R7 CU CNF OTA.*/
  uint8 wait_time_in_pch;
}rrccu_int_data_type;

/* -----------------------------------------------------------------------
** Global Constant Data Declarations
** ----------------------------------------------------------------------- */
 

/* -----------------------------------------------------------------------
** Global Data Declarations
** ----------------------------------------------------------------------- */
/*===========================================================================

      Cell Update procedure Substate variable        

===========================================================================*/
LOCAL boolean rrc_cu_uu_log_event_started = FALSE;
LOCAL rrc_cu_uu_failure_cause_e_type rrc_cu_uu_log_event_failure_cause = RRC_CU_UU_FAILURE_CAUSE_NONE;
LOCAL rrccu_rlfailure_info_type               rrccu_rl_failure_info;
LOCAL rrccu_rlc_unrecoverable_error_info_type rrccu_rlc_error_info;

LOCAL rrccu_substate_e_type                   rrccu_substate;

LOCAL rrccu_reg_proc_type                     rrccu_reg_info;

LOCAL rrc_CellUpdateCause                     rrccu_cell_update_cause;

LOCAL rrc_URA_UpdateCause                     rrccu_ura_update_cause;

LOCAL rrc_FailureCauseWithProtErrTrId         rrccu_failure_cause;
LOCAL rrc_ProtocolErrorIndicatorWithMoreInfo  rrccu_uu_failure_cause;

LOCAL rrccu_resp_msg_e_type                   rrccu_resp_msg;

LOCAL rrc_RRC_StateIndicator                  rrccu_state_indicator;

LOCAL rrc_RRC_TransactionIdentifier           rrccu_trans_id;

LOCAL rrc_state_e_type                        rrccu_failure_state;

LOCAL boolean                                 rrccu_chan_config_reqd;

LOCAL rrccu_chan_config_info_type             rrccu_chan_config_info;

LOCAL boolean                                 rrccu_oc_set_by_cu;
LOCAL boolean                                 rrccu_physical_channel_failure;

LOCAL rrccu_rb_release_info_type              rrccu_rb_release_info;

LOCAL boolean                                 rrccu_cell_update_started;
LOCAL boolean                                 rrccu_ura_update_started;
LOCAL boolean                                 rrccu_ura_update_required;
LOCAL boolean                                 rrccu_cipher_update_required;
LOCAL uint32                                  rrccu_current_ura_id;

LOCAL rrccu_cu_initiate_reqd_type             rrccu_cu_initiate_reqd;
LOCAL boolean rrccu_revert_back_to_old_config;

#ifdef FEATURE_UMTS_PDCP
extern boolean rrc_pdcp_enabled;
#endif /* FEATURE_UMTS_PDCP */
LOCAL rrc_int_c_rnti_type      rrccu_new_crnti;
LOCAL boolean                  rrccu_new_crnti_valid;          /* Indicates if a valid U-RNTI was recd */ 

LOCAL rrc_int_u_rnti_type      rrccu_new_urnti;
LOCAL boolean                  rrccu_new_urnti_valid;          /* Indicates if a valid U-RNTI was recd */ 
LOCAL boolean                  rrccu_cucnf_for_srns_relocation;  /* Indicates SRNS reloc involved with this msg */
LOCAL boolean                  rrccu_reestablish_srb;          /* Indicates if a valid U-RNTI was recd */ 
LOCAL boolean                  rrccu_reestablish_rab;          /* Indicates if a valid U-RNTI was recd */ 

LOCAL rrc_UTRAN_DRX_CycleLengthCoefficient     rrccu_utran_drx_coef;          /* Indicates if a valid U-RNTI was recd */ 

LOCAL boolean                                  rrccu_phy_chan_failure_from_rb;  /*Indicates CU was initiate with failure
                                                                             cause phy chan failure from RB procedure */
LOCAL rrc_RB_Identity rb_id_unrec_error = RRC_INVALID_RB_ID;         /* RB_ID with unrecoverable error */
LOCAL rrc_proc_e_type pending_config_proc_id = RRC_PROCEDURE_NONE;  /* proc id that set OC */

LOCAL boolean rrccu_do_not_acpt_nw_conf_in_cuc;

LOCAL boolean need_to_incl_failure_cause_in_next_cu = FALSE;
/*"Bit mask used to trim CU message */
uint32 trim_cu_msg_status = 0x00;

/* This contains some of  the internal variables of CU 
 * Introcucing the generic internal structure for CU.
 * So that in future all internal variables added in CU 
 * to can be added to this  structure. As it is easier to
 * maintain
 */
LOCAL rrccu_int_data_type rrccu_int_data;

#ifdef FEATURE_WCDMA_HANDLE_MDSP_HALT      
boolean rrccu_mdsp_recov_active = FALSE;
#endif  

boolean rrccu_is_bplmn_suspend_retried = FALSE;
uint8 rrccu_tran_to_discon_counter = 0;

#ifdef FEATURE_WCDMA_HS_RACH
/*This variable indicates if Cell Update is delayed either until uplink data is triggered or 
  cell update is triggered due to some other cause like OOS, reselection etc..
  Set to true when LLC determines HSFACH<->HSRACH switch has occured.
  Set to false when Cell Update substate changes from initial ,this indicates that Cell Update has 
  been trigged and delay cell update is no longer active.*/
boolean rrccu_hsrach_delay_cu_sib_change = FALSE;
#endif

#define UL_DATA_IND 0x1
#define SIB_CHANGE_IND 0x2
#define T305_EXPIRY_IND 0x4
#define CU_INITIATE_REQ 0x8
#define CRLC_STATUS_IND 0x10

typedef struct
{
  rlc_lc_id_type lc_id;
}rrccu_bufferred_reset_ind_type;

/* Value of greater than the maximum value of T302 (8s)*/
#define RRC_CU_T302_RECOVERY_TMR 10000
uint8 rrccu_buffered_cmd_mask = 0;
rrc_initiate_cu_req_type rrccu_buffered_cu_initiate_req = {0};
rrccu_bufferred_reset_ind_type rrccu_buffered_reset_ind = {0};

#define IS_CU_TRIGGERED_WITH_RE_ENTER_SERVICE_AREA_VALID\
               ((cmd_ptr->cmd.initiate_cell_update.cause == RRC_REENTERED_SERVICE_AREA) &&\
                ((cmd_ptr->cmd.initiate_cell_update.procedure == RRC_PROCEDURE_CSP)||\
                  (cmd_ptr->cmd.initiate_cell_update.procedure == RRC_PROCEDURE_SIB) ||\
                  (cmd_ptr->cmd.initiate_cell_update.procedure == RRC_PROCEDURE_RBRC) ||\
                  (cmd_ptr->cmd.initiate_cell_update.procedure == RRC_PROCEDURE_TCR) ||\
                  (cmd_ptr->cmd.initiate_cell_update.procedure == RRC_PROCEDURE_PCR) ||\
                  (cmd_ptr->cmd.initiate_cell_update.procedure == RRC_PROCEDURE_RBR))) 
  
#ifdef FEATURE_QSH_EVENT_METRIC
extern rrc_qsh_ul_failure_ota_param_s failure_ota;
extern rrc_qsh_metric_db_type rrc_qsh_metric_db[WRRC_QSH_METRIC_MAX+1];
extern boolean rrc_qsh_dl_committed;
#endif

uint8 rrc_qsh_establishment_cause = 0xFF;

uint8 rrc_qsh_security_revert_status = 0xFF;

uint8 rrc_qsh_reconfig_status_ind = 0xFF;
/* -----------------------------------------------------------------------
** Local Object Definitions
** ----------------------------------------------------------------------- */

/* -----------------------------------------------------------------------
** Forward Declarations
** ----------------------------------------------------------------------- */


/*===========================================================================
** -----------------------------------------------------------------------------------
**-- ----------NON-Demand paging section Srart--------------------------------------------
** -----------------------------------------------------------------------------------
  This section will have code section that will not be demand paged. Function which should be in this section are
  -RRC functions that are called by L1/L2 which are higher priority then RRC
  -RRC functions that are called in ISR context or RTOS timer call back
  -RRC functions that indirectly gets called by L1/L2 /ISR/timer call back   
  For example: Fun1() gets called by L1. Fun2() is called by Fun1(). Now both  Fun1() & Fun2() should be NON demand paged, 
  so both should be added in this section  
  Usage of pragma 
  __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED__
  void foo(void)
  {
    function body here
  }
        __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED_END__
  If you have another function to be added in the same section then again it needs to be wrapped with these pragma 
  for example:- function bar() is just below function foo() then function bar() needs to be written like this …. 
  __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED__
  void bar(void)
  {
    function body here
  }
  __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED_END__
** ----------------------------------------------------------------------- */

#ifdef FEATURE_WCDMA_HS_FACH
/*===========================================================================

FUNCTION rrccu_update_hrnti_from_ota

DESCRIPTION
  Updates HRNTI from OTA's like CU-CNF, URA-CNF
  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/


uecomdef_status_e_type rrccu_update_hrnti_from_ota
(
  ASN1BitStr32  *new_hrnti_ptr,          /* Pointer to external HRNTI type */
  ordered_config_type  *config_ptr    /* Pointer to internal HRNTI type */
);

/*===========================================================================

FUNCTION rrccu_update_rnti_from_cu_cnf

DESCRIPTION 
This function updates RNTIs
DEPENDENCIES
    None.

RETURN VALUE
    None.

===========================================================================*/

static void rrccu_update_rnti_from_cu_cnf
(
boolean new_H_RNTIPresent,
boolean newPrimary_E_RNTIPresent,
rrc_H_RNTI *new_H_RNTI,
rrc_E_RNTI *newPrimary_E_RNTI,
rrcrb_directed_cell_info_type *directed_cell_info
);


/*===========================================================================

FUNCTION rrccu_update_chan_config_rb_r7_for_efach

DESCRIPTION
 
  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/

static uint32 
rrccu_update_chan_config_rb_r7_for_efach
(
  uint32 no_of_RBs,
  rrc_rb_config_type * rb_info
);
/*===========================================================================

FUNCTION rrccu_check_rnti_for_resending_cu

DESCRIPTION 
This function checks rntis for resending CU
DEPENDENCIES
    None.

RETURN VALUE
    None.

===========================================================================*/

boolean rrccu_check_rnti_for_resending_cu
(
boolean new_H_RNTI_present, 
boolean newPrimary_E_RNTI,
rrc_msg_ver_enum_type msg_version,
rrccu_resp_msg_e_type resp
);

#endif
/*===========================================================================

FUNCTION RRCCU_GET_CELL_UPDATE_STARTED_STATUS

DESCRIPTION

  This function checks whether Cell Update procedure is started or not.
  
DEPENDENCIES


RETURN VALUE

  A value of rrccu_cell_update_status_e_type indicating the status of the
  function.

SIDE EFFECTS

  None

===========================================================================*/
/***/ __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED__ /***/

rrccu_cell_update_started_status_e_type rrccu_get_cell_update_started_status
(    
  void
)
{
  if(rrccu_substate != RRCCU_INITIAL)  
  {
    return( RRCCU_STARTED );
  }
  else
  {
    return(RRCCU_NOT_STARTED);
  }
} /* rrccu_get_cell_update_started_status */
/***/ __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED_END__ /***/

/*===========================================================================

FUNCTION rrccu_send_cell_update_initiate_req

DESCRIPTION
  This function posts a cell update request to rrccu itself
  in internal command queue. This function is used to avoid the race conditions. 

DEPENDENCIES
  None.

RETURN VALUE
  None.

===========================================================================*/
/***/ __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED__ /***/
void rrccu_send_cell_update_initiate_req
(
 rrc_cell_update_cause_e_type cause
)
{
  rrc_cmd_type *int_cmd_ptr;

  int_cmd_ptr =  rrc_get_int_cmd_buf();
  /* Fill in the command parameters for RRC_CELL_UPDATE_INITIATE_REQ */
  int_cmd_ptr->cmd_hdr.cmd_id = RRC_CELL_UPDATE_INITIATE_REQ;
  int_cmd_ptr->cmd.initiate_cell_update.cause = cause;
  int_cmd_ptr->cmd.initiate_cell_update.cu_complete_cnf_required = FALSE;
  int_cmd_ptr->cmd.initiate_cell_update.procedure = RRC_PROCEDURE_CU;
  MSG_HIGH("post self cu init req cause:%d, cu_st:%d, curr_cause:%d",
           cause,
           rrccu_substate,
           cause
           );
  rrc_put_int_cmd(int_cmd_ptr);             
}/*rrccu_send_cell_update_initiate_req*/
/***/ __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED_END__ /***/

/*===========================================================================

FUNCTION RRCCU_IS_CMD_BUFFERING_REQUIRED

DESCRIPTION
  This function returns true if any mode is standby or if CSP has not yet sent any channel config to resume channels.
  
DEPENDENCIES
  None

RETURN VALUE
  Boolean
  
SIDE EFFECTS

  None
===========================================================================*/

static boolean rrccu_is_cmd_buffering_required()
{
  if((rrcmcm_get_rrc_mode() == RRC_MODE_STANDBY) || ((rrcmcm_get_rrc_mode() == RRC_MODE_ACTIVE) && 
     ((rrc_get_csp_substate() == RRCCSP_WT_RESUME_MODE_CHANGE_CNF) ||
      (rrc_get_csp_substate() == RRCCSP_WT_RESUME_MODE_CHANGE_CNF_PENDING)|| 
      (rrc_get_csp_substate() == RRCCSP_WT_FOR_CHAN_CFG_CNF)||
      (rrc_get_csp_substate() == RRCCSP_WT_FOR_CHAN_CFG_CNF_PENDING))))
  {
    return TRUE;
  }
  return FALSE;
}

#ifdef FEATURE_WCDMA_FREE_FLOATING_TASK
/*===========================================================================

FUNCTION rrccu_rlc_ul_data_ind

DESCRIPTION
  This function is used as call back function from rlc when uplink data 
  presence has to be indicated in cell_pch or ura_pch state.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
/***/ __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED__ /***/
#ifdef FEATURE_DSM_WM_CB
void rrccu_rlc_ul_data_ind (struct dsm_watermark_type_s *dsm_ptr, void *ptr)
#else /*FEATURE_DSM_WM_CB*/
void rrccu_rlc_ul_data_ind (void)
#endif /*FEATURE_DSM_WM_CB*/
{
  /* Local varible to store state */
#ifdef FEATURE_WCDMA_HS_RACH
 /* For delay CU case, before any DOWNLINK SDU IND can be receieved, 
    we want to initiate CU, so that when DOWNLINK SDU IND is receieved, a failure 
    response will be transmitted after CU is completed */
if((rrc_get_state() == RRC_STATE_CELL_FACH) && (rrccu_get_hsrach_sib_change() == TRUE))
{
    /*Buffer the UL data indication if rrc is in standby mode*/
    if(RRC_MODE_STANDBY == rrcmcm_get_rrc_mode())
    {
      rrccu_buffered_cmd_mask |= UL_DATA_IND; 
      WRRC_MSG0_HIGH("RRC_RLC_UL_DATA_IND got triggered in STANDBY mode");
      return;
    }
  
  /*
       This change to move the handling of UL data indication earlier is needed because
        L2 first calls rrccu_rlc_ul_data_ind to post UL data command and then posts DL SDU Indication
        Now RRC_RLC_UL_DATA_IND is handled in rrccu_handle_rlc_ul_data_ind and initiates
        cell update initiate request. Still the CU substate is initial so when OTA is processed
        reconfiguration message is processed directly without waiting for CU to be completed.
        so rather than adding code in all procedures to handle delay CU case, 
        we moved the handling of UL data by 1 command.

      If the UE is in CELL_FACH state or CELL_PCH state and the value of the variable READY_FOR_COMMON_EDCH has changed due to a system information modification, the UE shall:
     	1>	when the UE has uplink RLC data PDU or uplink RLC control PDU on RB1 or upwards to transmit:
     	2>	clear the variable C_RNTI, variable H_RNTI and variable E_RNTI;
     	2>	if the UE is in CELL_FACH state:
     	3>	initiate the cell update procedure with cell update cause "cell reselection" as specified in subclause 8.3.1.2.
      */
 rlc_ul_reg_data_ind_in_fach(RLC_UNREG_DATA_IND_IN_FACH);
 rrccu_send_cell_update_initiate_req(RRC_CELL_RESELECTION);
 MSG_HIGH("SIB5_Delay: Triggering the delayed Cell Update",0,0,0);
}
else	
#endif
{
  rrc_cmd_type *rlc_ul_data_ind_cmd_ptr;

  rlc_ul_data_ind_cmd_ptr = rrc_get_int_cmd_buf();
  rlc_ul_data_ind_cmd_ptr->cmd_hdr.cmd_id = RRC_RLC_UL_DATA_IND;
   WRRC_MSG0_HIGH("Post RRC_RLC_UL_DATA_IND");
  rrc_put_int_cmd(rlc_ul_data_ind_cmd_ptr);
 }

}
/***/ __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED_END__ /***/

/*===========================================================================

FUNCTION rrccu_handle_rlc_ul_data_ind

DESCRIPTION
  This function will process the uplink data indication and update 
  CU database

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
/***/ __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED__ /***/
void rrccu_handle_rlc_ul_data_ind (void)
{
  rrc_state_e_type state ;                    /* Local varible to store state */
  state =  rrc_get_state();
  MSG_HIGH("UL data ind, cu_st %d rrc_st:%d cu_cause: %d",rrccu_substate,state,rrccu_cell_update_cause);

  if( (state == RRC_STATE_CELL_PCH) || (state == RRC_STATE_URA_PCH) )
  {

    /*Buffer the UL data indication if rrc is in standby mode*/
    if(TRUE == rrccu_is_cmd_buffering_required())
    {
      rrccu_buffered_cmd_mask |= UL_DATA_IND;;

      rrccu_cell_update_cause = rrc_CellUpdateCause_uplinkDataTransmission;
      
      WRRC_MSG0_HIGH("RRC_RLC_UL_DATA_IND got triggered in STANDBY mode");
      return;
    }
  
    switch (rrccu_substate)
    {
      case  RRCCU_INITIAL:
      /*This allows UL DATA IND to be triggered even though CU is waiting for SIB7*/
#ifdef FEATURE_UPDATE_SIB7_FOR_PCH_TO_FACH
      case  RRCCU_WAIT_FOR_SIB7_CURRENT:
#endif /*FEATURE_UPDATE_SIB7_FOR_PCH_TO_FACH*/
        if(rrctmr_get_remaining_time(RRCTMR_T_320_TIMER))
        {
          if(rrcdt_is_dt_initiated_cu())
          {
            rrctmr_stop_timer(RRCTMR_T_320_TIMER);
          }
          else
          {
            rrccu_int_data.cu_cause_for_wait_timer = RRC_UL_DATA_TRANSMISSION;
            return;
          }
        }
#ifdef FEATURE_WCDMA_HS_RACH
        /*While coming out of PCH state if ready_for_common_edch or hspa_rnti_stored_cell_pch
          is true then send a measurement report instead of cell update*/
        if(TRUE == rrcllc_get_hspa_rnti_stored_cell_pch(current_config_ptr))
        {
          /*initiate a cell update post an internal command to avoid any race conditions */
          WRRC_MSG0_HIGH("RRCHSRACH :Ready to send MR while coming out of PCH");
          rrccu_send_cell_update_initiate_req (RRC_PCH_TO_FACH_TRANSITION_REQ); 
        }
        else
#endif
        /*initiate a cell update post an internal command to avoid any race conditions */
        rrccu_send_cell_update_initiate_req (RRC_UL_DATA_TRANSMISSION);
        break;

      case  RRCCU_WAIT_FOR_UE_TO_CAMP_ON:
      case  RRCCU_WAIT_FOR_RB0_EST_CNF:
      case  RRCCU_WAIT_FOR_BPLMN_SUSPEND_CNF:
        /*some other process has initiated cell updte 
        look at the cell update cause if the cause is same as 
        uplink data transmission then ignore this data indication
        otherwise post the command in internal queue*/
        if (rrccu_cell_update_started == TRUE)
        {
          /* get the appropriate cell update caus. Uplink data transmission
                     has highest priority over any other cause */
          rrccu_cell_update_cause = rrc_CellUpdateCause_uplinkDataTransmission;
          /* continue in the same substate */
        }
        else if (rrccu_ura_update_started == TRUE)
        {
          /*cell update was must have been initialized with cause
          other than cell reselection or periodical cell update. In such
          case cell update procedure takes the priority over the ura update
          change the procedure and cause accordingly */
          rrccu_ura_update_started = FALSE;
          rrccu_cell_update_started = TRUE;
          /* Update Cell Update cause. Uplink data transmission
          has highest priority over any other cause*/
          rrccu_cell_update_cause = rrc_CellUpdateCause_uplinkDataTransmission;
          /* continue in the same substate */
        }
        break;

      default:
        MSG_HIGH("state %d cu_st%d, cu_cause:%d Ignoring UL data ind", 
                 state,rrccu_substate,rrccu_cell_update_cause);
        break;

    }
  }
  else
  {
    WRRC_MSG2_ERROR("state %d cu_st%d, UL data ind in invalid rrc state", 
             state,rrccu_substate);
  }
}
/***/ __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED_END__ /***/
#else
/*===========================================================================

FUNCTION rrccu_rlc_ul_data_ind

DESCRIPTION

  This function is used as call back function from rlc when uplink data 
  presence has to be indicated in cell_pch or ura_pch state.
  
DEPENDENCIES


RETURN VALUE
           viod


SIDE EFFECTS

  None

===========================================================================*/
/***/ __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED__ /***/
#ifdef FEATURE_DSM_WM_CB
void rrccu_rlc_ul_data_ind (struct dsm_watermark_type_s *dsm_ptr, void *ptr)
#else /*FEATURE_DSM_WM_CB*/
void rrccu_rlc_ul_data_ind (void)
#endif /*FEATURE_DSM_WM_CB*/
{
  rrc_state_e_type state ;                    /* Local varible to store state */
  state =  rrc_get_state();
  MSG_4(MSG_SSID_DFLT, MSG_LEGACY_HIGH,"UL data ind, cu_substate %d rrc_st:%d, rrc_mode: %d, cu_cause: %d",rrccu_substate,state, rrcmcm_get_rrc_mode(), rrccu_cell_update_cause);

  if( (state == RRC_STATE_CELL_PCH) || (state == RRC_STATE_URA_PCH) )
  {
    /*Buffer the UL data indication if rrc is in standby mode*/
    if(TRUE == rrccu_is_cmd_buffering_required())
    {
      rrccu_buffered_cmd_mask |= UL_DATA_IND;

      rrccu_cell_update_cause = rrc_CellUpdateCause_uplinkDataTransmission;
      return;
    }

    switch (rrccu_substate)
    {
      case  RRCCU_INITIAL:
      /*This allows UL DATA IND to be triggered even though CU is waiting for SIB7*/
#ifdef FEATURE_UPDATE_SIB7_FOR_PCH_TO_FACH
      case  RRCCU_WAIT_FOR_SIB7_CURRENT:
#endif /*FEATURE_UPDATE_SIB7_FOR_PCH_TO_FACH*/
        if(rrctmr_get_remaining_time(RRCTMR_T_320_TIMER))
        {
          if(rrcdt_is_dt_initiated_cu())
          {
            rrctmr_stop_timer(RRCTMR_T_320_TIMER);
          }
          else
          {
            rrccu_int_data.cu_cause_for_wait_timer = RRC_UL_DATA_TRANSMISSION;
            return;
          }
        }
        /*Code to update CU cause is already present while handling cell 
        initiation in PCH state*/
        /*initiate a cell update post an internal command to avoid any race conditions */
        rrccu_send_cell_update_initiate_req (RRC_UL_DATA_TRANSMISSION);
        break;

      case  RRCCU_WAIT_FOR_UE_TO_CAMP_ON:
      case  RRCCU_WAIT_FOR_RB0_EST_CNF:
      case RRCCU_WAIT_FOR_BPLMN_SUSPEND_CNF:
        /*some other process has initiated cell updte 
        look at the cell update cause if the cause is same as 
        uplink data transmission then ignore this data indication
        otherwise post the command in internal queue*/
        if (rrccu_cell_update_started == TRUE)
        {
          {
            /* get the appropriate cell update caus. Uplink data transmission
               has highest priority over any other cause */
            rrccu_cell_update_cause = rrc_CellUpdateCause_uplinkDataTransmission;
            /* continue in the same substate */
          }
        }
        else if (rrccu_ura_update_started == TRUE)
        {
          /*cell update was must have been initialized with cause
          other than cell reselection or periodical cell update. In such
          case cell update procedure takes the priority over the ura update
          change the procedure and cause accordingly */
          rrccu_ura_update_started = FALSE;
          rrccu_cell_update_started = TRUE;
          /* Update Cell Update cause. Uplink data transmission
          has highest priority over any other cause*/
          rrccu_cell_update_cause = rrc_CellUpdateCause_uplinkDataTransmission;
          /* continue in the same substate */
        }
        break;

      default:
        MSG_HIGH("state %d cu_st%d, cu_cause:%d Ignoring UL data ind", 
                 state,rrccu_substate,rrccu_cell_update_cause);
        break;

    }
  }
 else if((state == RRC_STATE_CELL_FACH) &&
           (rrccu_get_hsrach_sib_change() == TRUE))
  {

    /*Buffer the UL data indication if rrc is in standby mode*/
    if(TRUE == rrccu_is_cmd_buffering_required())
    {
      rrccu_buffered_cmd_mask |= UL_DATA_IND; 
      WRRC_MSG0_HIGH("RRC_RLC_UL_DATA_IND got triggered in STANDBY mode");
      return;
    }
    /*
        If the UE is in CELL_FACH state or CELL_PCH state and the value of the variable READY_FOR_COMMON_EDCH has changed due to a system information modification, the UE shall:
        1>  when the UE has uplink RLC data PDU or uplink RLC control PDU on RB1 or upwards to transmit:
        2>  clear the variable C_RNTI, variable H_RNTI and variable E_RNTI;
        2>  if the UE is in CELL_FACH state:
        3>  initiate the cell update procedure with cell update cause "cell reselection" as specified in subclause 8.3.1.2.
      */
    rlc_ul_reg_data_ind_in_fach(RLC_UNREG_DATA_IND_IN_FACH);
    rrccu_send_cell_update_initiate_req(RRC_CELL_RESELECTION);
    WRRC_MSG0_HIGH("SIB5_Delay: Triggering the delayed Cell Update");

  }
  else
  {
    WRRC_MSG2_ERROR("state %d cu_st%d, UL data ind in invalid rrc state", 
             state,rrccu_substate);
  }
}
/***/ __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED_END__ /***/
#endif
/* =======================================================================
**                            Function Definitions
** ======================================================================= */

/*===========================================================================
FUNCTION rrccu_get_cu_cause_for_wait_timer

DESCRIPTION
  Returns the cause for which CU was requested when the wait timer was running. Basically it is the pending CU cause.
  
DEPENDENCIES
  None

RETURN VALUE

SIDE EFFECTS
  None
===========================================================================*/
rrc_cell_update_cause_e_type rrccu_get_cu_cause_for_wait_timer
(
  void
)
{
  return rrccu_int_data.cu_cause_for_wait_timer;
}

/*===========================================================================
FUNCTION rrccu_reset_cu_cause_for_wait_timer

DESCRIPTION
  Resets cu cause for wait timer stored in CU internal DB.

DEPENDENCIES
  None

RETURN VALUE

SIDE EFFECTS
  None
===========================================================================*/
void rrccu_reset_cu_cause_for_wait_timer
(
  void
)
{
  rrccu_int_data.cu_cause_for_wait_timer = RRC_CU_CAUSE_NONE;
}

/*===========================================================================
FUNCTION rrccu_get_cu_wait_timer_value

DESCRIPTION
  Returns the value of the wait timer that was given by N\W in PCH state.
  
DEPENDENCIES
  None

RETURN VALUE

SIDE EFFECTS
  None
===========================================================================*/
uint8 rrccu_get_cu_wait_timer_value
(
  void
)
{
  return rrccu_int_data.wait_time_in_pch;
}

/*===========================================================================
FUNCTION rrccu_reset_cu_wait_timer_value

DESCRIPTION
  Resets wait timer value in CU internal DB.
  
DEPENDENCIES
  None

RETURN VALUE

SIDE EFFECTS
  None
===========================================================================*/
void rrccu_reset_cu_wait_timer_value
(
  void
)
{
  rrccu_int_data.wait_time_in_pch = RRC_T320_INVALID_VALUE;
}
extern boolean mm_waiting_for_nw_command(void);

#ifdef FEATURE_DUAL_SIM
extern boolean mm_per_subs_waiting_for_nw_command(sys_modem_as_id_e_type as_id);
#endif
extern rrc_proc_e_type rrc_wait_for_l2ack_for_reconfig;



/*===========================================================================

FUNCTION rrccu_check_if_cell_selection_in_progress

DESCRIPTION
   Checks if Cell Selection was triggerred to due to the directed cell info present 
   in CU Cnf msg.
   This is used by CCM to to send NEW_CELL_IND to CU in  this scenario
DEPENDENCIES
  None

RETURN VALUE
  TRUE : If the CELL Selection was triggered due to directed cell info in CU CNF
  else
  FALSE
SIDE EFFECTS
  None
===========================================================================*/

boolean rrccu_check_if_cell_selection_in_progress()
{
  return rrccu_int_data.rrccu_cell_selection_trans_from_fach;
}
/*===========================================================================      
      FUNCTION rrccu_post_sib_change_ind    
      DESCRIPTION       
      This function will post RRC_SIB_CHANGE_IND if it was buffered when 
      UE was in standby mode when sib previously triggered sib_change_ind     
      DEPENDENCIES
        None     
      RETURN VALUE
        None       
      SIDE EFFECTS

        None     
===========================================================================*/
static void rrccu_post_sib_change_ind(void)
{
  rrc_cmd_type *rrc_sib_change_ind_cmd_ptr;
  rrc_sib_change_ind_cmd_ptr = rrc_get_int_cmd_buf();
  rrc_sib_change_ind_cmd_ptr->cmd_hdr.cmd_id = RRC_SIB_CHANGE_IND;
  rrc_sib_change_ind_cmd_ptr->cmd.sib_change_ind.procedure = RRC_PROCEDURE_CU;
  WRRC_MSG0_HIGH("Post RRC_SIB_CHANGE_IND");
  rrc_put_int_cmd(rrc_sib_change_ind_cmd_ptr);  
}
/*===========================================================================     
      FUNCTION rrccu_post_cu_initiate_req    
      DESCRIPTION       
      This function will post RRC_CELL_UPDATE_INITIATE_REQ if it was buffered when 
      UE was in standby mode 
      DEPENDENCIES
        None     
      RETURN VALUE
        None       
      SIDE EFFECTS

        None     
===========================================================================*/
static void rrccu_post_cu_initiate_req(void)
{
  rrc_cmd_type *rrc_cu_initiate_req_cmd_ptr;
  rrc_cu_initiate_req_cmd_ptr = rrc_get_int_cmd_buf();
  rrc_cu_initiate_req_cmd_ptr->cmd_hdr.cmd_id = RRC_CELL_UPDATE_INITIATE_REQ;
  rrc_cu_initiate_req_cmd_ptr->cmd.initiate_cell_update.cause = rrccu_buffered_cu_initiate_req.cause;
  rrc_cu_initiate_req_cmd_ptr->cmd.initiate_cell_update.cu_complete_cnf_required = rrccu_buffered_cu_initiate_req.cu_complete_cnf_required;
  rrc_cu_initiate_req_cmd_ptr->cmd.initiate_cell_update.procedure = rrccu_buffered_cu_initiate_req.procedure;
      
  WRRC_MSG2_HIGH("Posting the Buffered CU Initiate request with cause %d  procedure %d ",
    rrccu_buffered_cu_initiate_req.cause,
    rrccu_buffered_cu_initiate_req.procedure );
        
  rrc_put_int_cmd(rrc_cu_initiate_req_cmd_ptr);  
}
/*===========================================================================     
      FUNCTION rrccu_post_t305_expiry_ind
      
      DESCRIPTION        
      This function will post RRC_T305_EXPIRED_IND if it was buffered when 
      UE was in standby mode and t305 expired

      DEPENDENCIES
        None     
      RETURN VALUE
        None        
      SIDE EFFECTS      
        None      
===========================================================================*/
static void rrccu_post_t305_expiry_ind(void)
{
  rrc_cmd_type *rrc_t305_exp_ind_ptr;
  rrc_t305_exp_ind_ptr = rrc_get_int_cmd_buf();
  rrc_t305_exp_ind_ptr->cmd_hdr.cmd_id = RRC_T305_EXPIRED_IND;
   WRRC_MSG0_HIGH("Post RRC_T305_EXP_IND");
  rrc_put_int_cmd(rrc_t305_exp_ind_ptr); 
}
/*===========================================================================

FUNCTION rrccu_intiate_cell_selection_within_fach_cu_cnf

DESCRIPTION 
  Sends a Initate Cell Selection for FACH->FACH.
  Also takes a backup of the ota contents which are 
  required for configuring the lower layers once the cell selection 
  is complete. 

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/

static void rrccu_intiate_cell_selection_within_fach_cu_cnf(   rrc_cmd_type *cmd_ptr  )
{
  uint8 idx;
  /* Backup the channel config req contents */
  rrccu_chan_config_info.num_rbs = cmd_ptr->cmd.chan_config_req.num_rb_to_config;
  rrccu_chan_config_reqd = TRUE;
  
  rrccu_int_data.rrccu_cell_selection_last_response_msg =   rrccu_resp_msg;
  rrccu_int_data.rrccu_cell_selection_last_trans_id = rrccu_trans_id;
  
  rrccu_int_data.rrccu_last_cucnf_for_srns_relocation= rrccu_cucnf_for_srns_relocation ;
  rrccu_int_data.rrccu_last_cucnf_cipher_update_required =rrccu_cipher_update_required  ;
  WRRC_MSG2_HIGH("Initiate Cell selection, response present to CU saved %d tran id %d",rrccu_resp_msg,rrccu_trans_id);
  for(idx =0;idx < cmd_ptr->cmd.chan_config_req.num_rb_to_config;idx++)
  {
    rrccu_chan_config_info.rb_info[idx].rb_id = cmd_ptr->cmd.chan_config_req.rb[idx].rb_id;
    rrccu_chan_config_info.rb_info[idx].rb_config = cmd_ptr->cmd.chan_config_req.rb[idx].rb_config;
    
  }
  /* Now copy OC to TOC */

  rrcllcoc_update_toc_with_oc_from_fach();
  
    /*Initiate the cell selection*/
  rrcrb_send_initiate_cell_selection_req( RRC_PROCEDURE_CU,
                                         RRC_TRANSITION_FROM_FACH,
                                        RRC_STATE_CELL_FACH );
  
  
  rrccu_substate = RRCCU_WAIT_FOR_UE_TO_CAMP_ON;
   
  rrccu_int_data.rrccu_cell_selection_trans_from_fach = TRUE;
  /*Not using the command for channel config right now so free it. */
  rrc_free_cmd_buf(cmd_ptr);

}

/*===========================================================================

FUNCTION rrccu_intiate_cell_selection_fach_pch_cu_cnf

DESCRIPTION
  Sends a Initate Cell Selection for FACH->PCH
DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/

static void rrccu_intiate_cell_selection_fach_pch_cu_cnf(  void  )
{
  
  
  /* Now copy OC to TOC */
  rrcllcoc_update_toc_with_oc_from_fach();

  if(rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH )
  {
   rrcrb_send_initiate_cell_selection_req(RRC_PROCEDURE_CU,
                                    RRC_TRANSITION_FROM_FACH,
                                    RRC_STATE_CELL_PCH);
  }
  else
  {
   rrcrb_send_initiate_cell_selection_req(RRC_PROCEDURE_CU,
                                    RRC_TRANSITION_FROM_FACH,
                                    RRC_STATE_URA_PCH);
  }   
  
  rrccu_substate = RRCCU_WAIT_FOR_UE_TO_CAMP_ON;
}


/*===========================================================================

FUNCTION       rrccu_check_and_send_response_to_previous_cell_upd_cnf

DESCRIPTION
   IF the Response to previous Cell Update Cnf is still pending, then it sends that response now.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/

static void  rrccu_check_and_send_response_to_previous_cell_upd_cnf(void )
{
   /*   In the case where UE receives CU Cnf(for say CU 1) with Freq re-direction info to FACH, 
     * and having an response to send. CU will remember the Response details for CU 1, 
     * then intiate a cell selection.  If UE doesnt camp on directed cell, then it
     * configure Lower layers with OTA contents and then initate cell update (say cu 2)
     * with cause cell reselection. On receving CU CNF for CU 2, CU will send response
     * for CU 2, and then also send response for CU 1.
     * For this case CU needs to rember the response to be sent for 1 st CU .
     */
  if(rrccu_int_data.rrccu_cell_selection_last_response_msg != RRCCU_NO_RESP_MSG)
  {
     rrccu_resp_msg = rrccu_int_data.rrccu_cell_selection_last_response_msg ;
     rrccu_int_data.rrccu_cell_selection_last_response_msg = RRCCU_NO_RESP_MSG;
     rrccu_trans_id = rrccu_int_data.rrccu_cell_selection_last_trans_id ;
     rrccu_cucnf_for_srns_relocation = rrccu_int_data.rrccu_last_cucnf_for_srns_relocation;
     rrccu_cipher_update_required = rrccu_int_data.rrccu_last_cucnf_cipher_update_required;
     rrccu_send_response_msg();
  }
}
/*===========================================================================

FUNCTION       rrccu_init_last_cu_cnf_info

DESCRIPTION
   Initialises all the variables, which was required to send a response to the previous CU Cnf 
DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
void rrccu_init_last_cu_cnf_info(void )
{
  WRRC_MSG0_HIGH("Initialised data for last CU response");
  rrccu_int_data.rrccu_cell_selection_last_response_msg = RRCCU_NO_RESP_MSG;
  rrccu_int_data.rrccu_cell_selection_last_trans_id = 0xff;
  rrccu_int_data.rrccu_last_cucnf_for_srns_relocation = FALSE;
  rrccu_int_data.rrccu_last_cucnf_cipher_update_required = FALSE;
}

/*===========================================================================

FUNCTION rrccu_start_t_305_timer

DESCRIPTION
  This function is called during transition from CELL_DCH to CELL_FACH/
  CELL_PCH/URA_PCH to start the periodic cell update timer T_305
DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
void  rrccu_start_t_305_timer(void)
{
  unsigned long timer_value;

  timer_value = rrc_convert_t305_to_ms(RRC_GET_T305());
  if(timer_value != RRCTMR_INFINITY_VAL )
  {
    rrctmr_start_timer(RRCTMR_T_305_TIMER, 
                     timer_value); 
  }
}
/*===========================================================================

FUNCTION rrccu_check_if_rabs_need_to_be_released

DESCRIPTION
  This function returns the value of rrccu_rl_failure_info.t314_info.need_to_release_rabs
DEPENDENCIES
  None

RETURN VALUE
  boolean

SIDE EFFECTS
  None
===========================================================================*/
boolean  rrccu_get_rabs_need_to_be_released_T314(void)
{
  if(rrccu_rl_failure_info.t314_info.need_to_release_rabs )
  {
    WRRC_MSG1_HIGH("T314 rrccu_rl_failure_info.t314_info.need_to_release_rabs %d ",
		rrccu_rl_failure_info.t314_info.need_to_release_rabs);
    return TRUE;		
  }
  return FALSE;
}
/*===========================================================================

FUNCTION rrccu_check_if_rabs_need_to_be_released

DESCRIPTION
  This function returns the value of rrccu_rl_failure_info.t314_info.need_to_release_rabs
DEPENDENCIES
  None

RETURN VALUE
  boolean

SIDE EFFECTS
  None
===========================================================================*/
boolean  rrccu_get_rabs_need_to_be_released_T315(void)
{
  if(rrccu_rl_failure_info.t315_info.need_to_release_rabs )
  {
    WRRC_MSG1_HIGH("T315 rrccu_rl_failure_info.t315_info.need_to_release_rabs %d ",
		rrccu_rl_failure_info.t315_info.need_to_release_rabs);
    return TRUE;		
  }
  return FALSE;
}
/*===========================================================================

FUNCTION rrccu_fill_est_cause

DESCRIPTION
  This function will fill the establish cause in cell update.
  
DEPENDENCIES
  None

RETURN VALUE
  boolean
  TRUE  : OK to proceed with oc reset 
  FALSE :  Not OK to proceed with oc reset

SIDE EFFECTS
  None
===========================================================================*/


static void  rrccu_fill_est_cause(rrc_UL_CCCH_Message *loc_msg_ptr)
{

  rrc_establish_cause_e_type  est_cause;
  rrc_EstablishmentCause trans_cause; /* translated to ASN format */
  rrc_call_type_in_est_req_e_type call_type;

  if(rrcidt_check_if_est_cause_available(RRC_PROCEDURE_CU,&est_cause
                   ,&call_type
                              ) == TRUE)
  {
    WRRC_MSG2_HIGH("Establishment cause : %d Call Type : %d " ,est_cause,call_type);
  
    RRC_MSG_COMMON_SET_BITMASK_IE(loc_msg_ptr->message.u.cellUpdate,rrc_CellUpdate,
		laterNonCriticalExtensions);
  
    RRC_RESET_MSG_IE_PRESENT(loc_msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions);
  
    loc_msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.m.
     v590NonCriticalExtensionsPresent =1;
  
    //change_here  reset bit_mask to 0
    RRC_RESET_MSG_IE_PRESENT(loc_msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.
      v590NonCriticalExtensions);
  
    RRC_RESET_MSG_IE_PRESENT(loc_msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.
        cellUpdate_v590ext);
  
   RRC_MSG_COMMON_SET_BITMASK_IE_TYPE2(loc_msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.
        cellUpdate_v590ext,establishmentCause);
    rrc_translate_establishment_cause(est_cause, &trans_cause);
    loc_msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.
         cellUpdate_v590ext.establishmentCause = trans_cause;
	rrc_qsh_establishment_cause = trans_cause;
    rrcidt_set_sent_by_cu(RRC_PROCEDURE_CU);
      
    if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL7)
    {
      if(rrcidt_is_cs_call_initiate() ==TRUE)
      {
        if(est_cause == RRC_EST_ORIG_CONV_CALL ||
            est_cause == RRC_EST_EMERGENCY_CALL)
        {
          loc_msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.m.
           v690NonCriticalExtensionsPresent =1;
  
          RRC_RESET_MSG_IE_PRESENT(loc_msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions);
          
          loc_msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.
            m.v6b0NonCriticalExtensionsPresent =1;
  
          RRC_RESET_MSG_IE_PRESENT(loc_msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.
            v6b0NonCriticalExtensions);
        
          loc_msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.
            v6b0NonCriticalExtensions.m.v770NonCriticalExtensionsPresent =1;
  
          RRC_RESET_MSG_IE_PRESENT(loc_msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.
            v6b0NonCriticalExtensions.v770NonCriticalExtensions);
  
          RRC_RESET_MSG_IE_PRESENT(loc_msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.
            v6b0NonCriticalExtensions.v770NonCriticalExtensions.cellUpdate_v770ext);
  
         RRC_MSG_COMMON_SET_BITMASK_IE(loc_msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.
            v6b0NonCriticalExtensions.v770NonCriticalExtensions.cellUpdate_v770ext,
              rrc_CellUpdate_v770ext_IEs,csCallType);
      
          switch(call_type)
          {
            case RRC_CALL_TYPE_SPEECH:
              loc_msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.
                                   v690NonCriticalExtensions.v6b0NonCriticalExtensions.v770NonCriticalExtensions.
                                   cellUpdate_v770ext.csCallType = rrc_CellUpdate_v770ext_IEs_csCallType_speech;
              break;
            case RRC_CALL_TYPE_VIDEO:
              loc_msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.
                                   v690NonCriticalExtensions.v6b0NonCriticalExtensions.v770NonCriticalExtensions.
                                   cellUpdate_v770ext.csCallType = rrc_CellUpdate_v770ext_IEs_csCallType_video;
              break;
            case RRC_CALL_TYPE_OTHERS:
              loc_msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.
                                   v690NonCriticalExtensions.v6b0NonCriticalExtensions.v770NonCriticalExtensions.
                                   cellUpdate_v770ext.csCallType = rrc_CellUpdate_v770ext_IEs_csCallType_other;
              break;
            default:
              loc_msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.
                                   v690NonCriticalExtensions.v6b0NonCriticalExtensions.v770NonCriticalExtensions.
                                   cellUpdate_v770ext.csCallType = rrc_CellUpdate_v770ext_IEs_csCallType_other;
              break;
          }
        }
  #ifdef FEATURE_WCDMA_REL7_SPECRS
        /*If COUEC procedure is active and RNC supports Change of UE Capability during RRC Connection,
            send "capabilityChangeIndicator" IE in Cell Update OTA.*/
        if(rrccouec_is_proc_active() && rrc_rnc_cap_change_support)
        {
          RRC_MSG_COMMON_SET_BITMASK_IE_TYPE2(loc_msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.
                                   v690NonCriticalExtensions.v6b0NonCriticalExtensions.v770NonCriticalExtensions.
            cellUpdate_v770ext,capabilityChangeIndicator);
  
          loc_msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.
            v690NonCriticalExtensions.v6b0NonCriticalExtensions.v770NonCriticalExtensions.cellUpdate_v770ext.
            capabilityChangeIndicator = rrc_CellUpdate_v770ext_IEs_capabilityChangeIndicator_true;
        }
  #endif/* FEATURE_WCDMA_REL7_SPECRS*/
      }
  
    }
  }
}
/*===========================================================================

FUNCTION   RRCCU_IS_SRNS_IN_PROGRESS()

DESCRIPTION
 This function returns if SRNS is in progress with current reconfig procedure


        
DEPENDENCIES

  None.
 
RETURN VALUE

  TRUE or FALSE

SIDE EFFECTS

  None.

===========================================================================*/
boolean rrccu_is_srns_in_progress
(
  void
)
{
  return rrccu_cucnf_for_srns_relocation;
}
/*===========================================================================

FUNCTION RRCCU_CHECK_PROC_WAITING_FOR_L2_ACK

DESCRIPTION
  This function will check the status of the procedure that has set the
  oc  

DEPENDENCIES
  None

RETURN VALUE
  boolean
  TRUE  : OK to proceed with oc reset 
  FALSE :  Not OK to proceed with oc reset

SIDE EFFECTS
  None
===========================================================================*/

static boolean rrccu_check_proc_waiting_for_l2_ack (rrc_proc_e_type proc_id)
{
  boolean status = FALSE;
  /*rrcrb_substate_e_type sub_st = RRCRB_MAX_SUBSTATES; */
  switch (proc_id)
  {
    case  RRC_PROCEDURE_RBE:
    case  RRC_PROCEDURE_RBR:
    case  RRC_PROCEDURE_RBRC:
    case  RRC_PROCEDURE_TCR:
    case  RRC_PROCEDURE_PCR:
      if (RRCRB_WAIT_FOR_L2_ACK == rrcrb_get_proc_sub_state(proc_id))
      {
        status = TRUE;
      } 
      else
      {
        status = FALSE;
      }
    break;
    case RRC_PROCEDURE_ASU:
      status = TRUE;
    break;
    default:
      status = FALSE;
    break;
  }
  WRRC_MSG2_HIGH("Procedure %d, waiting for L2 ACK ? : rrc_proc_e_type%d", proc_id, status);
  return status;
}  /* rrccu_check_proc_waiting_for_l2_ack */

/*===========================================================================

FUNCTION RRCCU_CHECK_PROC_WAITING_FOR_CHAN_CONFIG_CNF

DESCRIPTION
  This function will check the status of the procedure that has set the
  oc  

DEPENDENCIES
  None

RETURN VALUE
  boolean
  TRUE  :  procedure waiting for ch config cnf 
  FALSE :  procedure in some other state. 

SIDE EFFECTS
  None
===========================================================================*/

static boolean rrccu_check_proc_waiting_for_chan_config_cnf (rrc_proc_e_type proc_id)
{
  /*rrcrb_substate_e_type sub_st = RRCRB_MAX_SUBSTATES; */
  switch (proc_id)
  {
    case  RRC_PROCEDURE_RBE:
    case  RRC_PROCEDURE_RBR:
    case  RRC_PROCEDURE_RBRC:
    case  RRC_PROCEDURE_TCR:
    case  RRC_PROCEDURE_PCR:
      if (RRCRB_WAIT_FOR_CHAN_CFG_CNF == rrcrb_get_proc_sub_state(proc_id))
      {
        return TRUE;
      } 
      else
      {
        return FALSE;
      }
    case RRC_PROCEDURE_ASU:
      return TRUE;

    default:
      WRRC_MSG1_HIGH("OC set by proc:rrc_proc_e_type_value%d",proc_id);
      return FALSE;
  }
}  /* rrccu_check_proc_waiting_for_chan_config_cnf */

/*===========================================================================

FUNCTION RRCCU_CLEAR_PROCEDURE

DESCRIPTION
  This function will clear the global variables.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
void rrccu_clear_procedure
(    
  void  
)
{
  rrccu_failure_state                   = RRC_STATE_WILDCARD;
  rrccu_chan_config_reqd                = FALSE;
  rrccu_oc_set_by_cu                    = FALSE;
  rrccu_rb_release_info.rrccu_rb_release_in_cucnf = FALSE;
  rrccu_cell_update_cause               = rrc_CellUpdateCause_cellUpdateCause_ext;
  rrccu_ura_update_cause                = rrc_URA_UpdateCause_spare1;
  rrccu_cell_update_started             = FALSE;
  rrccu_ura_update_started              = FALSE;
  rrccu_ura_update_required             = FALSE;
  rrccu_physical_channel_failure        = FALSE;
  
  rrccu_rl_failure_info.t314_info.timer_status         = RE_EST_TIMER_NOT_STARTED;
  rrccu_rl_failure_info.t314_info.need_to_release_rabs = FALSE;
  rrccu_rl_failure_info.t314_info.need_rab_release_ind = FALSE;
  rrccu_rl_failure_info.t315_info.timer_status         = RE_EST_TIMER_NOT_STARTED;
  rrccu_rl_failure_info.t315_info.need_to_release_rabs = FALSE;
  rrccu_rl_failure_info.t315_info.need_rab_release_ind = FALSE;
  rrccu_rlc_error_info.error_on_srb = FALSE;
  rrccu_rlc_error_info.error_on_urb = FALSE;

  rrccu_cu_initiate_reqd.cu_reqd = FALSE;
 

  /*clear the global variables stored */
  rrccu_cucnf_for_srns_relocation = FALSE;
  rrccu_new_urnti_valid = FALSE;
  rrccu_new_crnti_valid = FALSE;
  rrccu_reestablish_srb = FALSE;
  rrccu_reestablish_srb = FALSE;
  rrccu_reestablish_rab = FALSE;
  rrccu_reestablish_rab = FALSE;
  rrccu_utran_drx_coef  = 0; 
 
  rrccu_phy_chan_failure_from_rb = FALSE;

  rrccu_cipher_update_required = FALSE;
  pending_config_proc_id = RRC_PROCEDURE_NONE;
  rb_id_unrec_error = RRC_INVALID_RB_ID; 
  rrccu_int_data.rrccu_cell_selection_trans_from_fach =FALSE;
  rrccu_chan_config_info.num_rbs = 0;

  /*Reset the variable once CU procedure ends*/
  rrcllc_reset_toc_usage_change_oos_to_dch();

  rrccu_is_bplmn_suspend_retried = FALSE;
  rrccu_revert_back_to_old_config = FALSE;
  last_active_cell_capability = RRC_CELL_CAP_INACTIVE;

#ifdef FEATURE_WCDMA_HS_RACH
  if(rrccu_get_hsrach_sib_change() == TRUE)
  {
    rrccu_set_hsrach_sib_change(FALSE);
    rlc_ul_reg_data_ind_in_fach(RLC_UNREG_DATA_IND_IN_FACH);
  }
#endif
 rrc_check_and_init_rrc_reestab_entity(RRC_PROCEDURE_CU); 

  rrc_cu_uu_log_event_started = FALSE;
  rrc_cu_uu_log_event_failure_cause = RRC_CU_UU_FAILURE_CAUSE_NONE;
  /* Reset buffered commands mask*/
  rrccu_buffered_cmd_mask = 0;
  memset(&rrccu_buffered_cu_initiate_req,0,sizeof(rrc_initiate_cu_req_type));
  memset(&rrccu_buffered_reset_ind,0,sizeof(rrccu_bufferred_reset_ind_type));
  rrccu_do_not_acpt_nw_conf_in_cuc = FALSE;
  need_to_incl_failure_cause_in_next_cu = FALSE;

} /* rrccu_clear_procedure */

/*===========================================================================

FUNCTION rrccu_check_rb_in_estab_rab

DESCRIPTION
  This function will check whether the rb is in established rabs, if so it returns
  true, else it returns false and clears cu state

DEPENDENCIES
  None

RETURN VALUE
  boolean
  TRUE  : rb is in established rabs
  FALSE : rb is not in established rabs 

SIDE EFFECTS
  None
===========================================================================*/

boolean rrccu_check_rb_in_estab_rab
(
 void
)
{
  rrc_RB_Identity rb_id =   rb_id_unrec_error;
  rlc_lc_id_type ul_rlc_lc_id = RRCLCM_RLC_LC_ID_NOT_FOUND;

  if(RRC_RB_PRESENT == rrc_find_rb_in_est_rabs(rb_id))
  {
    return TRUE;
  }
  else if (rb_id == DCCH_DT_LOW_PRI_RADIO_BEARER_ID)
  {
    /* check whether RB4 is present or not */
    ul_rlc_lc_id = rrclcm_check_ul_rlc_lc_id(UE_LOGCHAN_DCCH, 
                       DCCH_DT_LOW_PRI_RADIO_BEARER_ID,
                       UE_MODE_ACKNOWLEDGED_DATA);

    if(ul_rlc_lc_id != RRCLCM_RLC_LC_ID_NOT_FOUND)
    {
      return TRUE;
    }
  }
  /* If we get here, we never found that RB id */
  WRRC_MSG1_HIGH("rb %d not found in established rabs", rb_id);
  rrccu_substate = RRCCU_INITIAL;
  rrccu_clear_procedure();
  return FALSE;  
}
/*===========================================================================

FUNCTION RRCCU_CHECK_AND_CLEAR_OC_RESTRICTION

DESCRIPTION
  This function will check whether OC is set. If set then checks whether
  it is OK to reset the OC and if it is OK to reset it will call llc function 
  to clear the oc 

DEPENDENCIES
  None

RETURN VALUE
  boolean
  TRUE  : there is OC restriction 
  FALSE : there is no OC restriction 

SIDE EFFECTS
  None
===========================================================================*/
static rrccu_status_e_type rrccu_check_and_clear_oc_restrictions
(
  rrc_cmd_type *cmd_ptr,
  rrc_CellUpdateCause cell_update_cause
)
{
  rrc_proc_e_type proc_id;
  rrcllc_oc_process_state_e_type  process_state;  
  rrcllc_oc_set_status_e_type     oc_status;
  
  rrc_CellUpdateCause       cu_cause;
  rrccu_re_est_timers_status_e_type cu_tmr_status =  rrccu_check_re_est_timers();
  rrc_cmd_type *llc_cmd_ptr = NULL;  
  

  oc_status = rrcllc_get_ordered_config_state_and_proc(&proc_id, &process_state);
  pending_config_proc_id = proc_id;

  if (oc_status != OC_NOT_SET)
  {
    /* check if the OC is set by CU itself and still it is waiting
    for UE to camp on. Inthis case it is OK procede with cell update */
    if ((proc_id == RRC_PROCEDURE_CU) && 
        (rrccu_substate == RRCCU_WAIT_FOR_UE_TO_CAMP_ON))
    {
      return RRCCU_SUCCESS;
    }
    else
    {
      if (process_state == LL_CONFIG_WITH_OC)
      {
        return RRCCU_FAILURE_MAJOR;
      }
      else
      {
        /*If OC is set by ASU then no error handling is done. Simply tear down the RRC Connection.*/
        /*Checking for CU cause is extraneous because currently no other CU cause will happen in this 
        condition but adding them for future use*/
        if((rrc_get_state() == RRC_STATE_CELL_DCH) && (proc_id == RRC_PROCEDURE_ASU)
          && ((cell_update_cause == rrc_CellUpdateCause_rlc_unrecoverableError)||(cell_update_cause == rrc_CellUpdateCause_radiolinkFailure)))
        {
            return RRCCU_FAILURE_MAJOR;
        }
        /*lower layers are not configured with oc. get the proc and
        check its status. If it is waiting for L2ack then reset the oc */
        if (TRUE==rrccu_check_proc_waiting_for_l2_ack(proc_id))
        {
          /* If we are driven to Cell_PCH/URA_PCH from Cell_FACH
             we register to cell update to complete routine.
             As OC is going to be reset by CU, reconfig procedures
             would send a failure later */
          if(rrc_get_state() == RRC_STATE_CELL_FACH &&
             (proc_id         == RRC_PROCEDURE_RBE ||
              proc_id         == RRC_PROCEDURE_RBR || 
              proc_id         == RRC_PROCEDURE_RBRC ||
              proc_id         == RRC_PROCEDURE_TCR ||
              proc_id         == RRC_PROCEDURE_PCR)
            )
          {
            if((RRCCU_STARTED == rrccu_get_cell_update_started_status_with_cause(&cu_cause) &&
              (cu_cause == rrc_CellUpdateCause_re_enteredServiceArea || cu_cause == rrc_CellUpdateCause_rlc_unrecoverableError ||
               cu_cause == rrc_CellUpdateCause_radiolinkFailure)) || (cell_update_cause == rrc_CellUpdateCause_rlc_unrecoverableError))
            {
              (void)rrccu_register_for_cell_update_to_complete(proc_id);
            }
          }
            (void)rrcllc_reset_ordered_config(RRC_PROCEDURE_CU ,TRUE);

            /*Update reconfig procedure failure status to  RRCRB_CELL_UPDATE_OCCURED*/
            rrccu_update_reconfig_proc_failure_status(proc_id);
            return RRCCU_SUCCESS;
          }
        else
        {
          /* procedure is waiting for channel config confirm */
          if (((cell_update_cause != rrc_CellUpdateCause_radiolinkFailure) && (cell_update_cause != rrc_CellUpdateCause_rlc_unrecoverableError)) ||
              !((rrc_get_state() == RRC_STATE_CELL_DCH) && ((oc_status == OC_SET_FOR_CELL_DCH) || (oc_status == OC_SET_FOR_DCH_FACH_TRANS))) ||
              !(rrccu_check_proc_waiting_for_chan_config_cnf(proc_id) ||(oc_status == OC_SET_FOR_DCH_FACH_TRANS)) )
          {
            return RRCCU_FAILURE_MAJOR;
          }
          rrccu_cell_update_cause =  cell_update_cause;
          WRRC_MSG1_HIGH("Updated CU cause %d",rrccu_cell_update_cause);
          
          if(oc_status == OC_SET_FOR_DCH_FACH_TRANS && (cell_update_cause == rrc_CellUpdateCause_rlc_unrecoverableError || 
              (cell_update_cause == rrc_CellUpdateCause_radiolinkFailure)))
          {
            if(cell_update_cause == rrc_CellUpdateCause_rlc_unrecoverableError)
            {
               rb_id_unrec_error = rrclcm_get_ul_rb_id (cmd_ptr->cmd.crlc_status_ind.lc_id);
               WRRC_MSG1_HIGH("rlc error on RB id %d and pending cfg not cancld", rb_id_unrec_error);
               if ((rb_id_unrec_error >= DCCH_AM_RADIO_BEARER_ID) && 
                 (rb_id_unrec_error <= DCCH_DT_LOW_PRI_RADIO_BEARER_ID))
               {
                 rrccu_rlc_error_info.error_on_srb = TRUE;
               }
               else
               {
                 rrccu_rlc_error_info.error_on_urb = TRUE;
               }
            }
          }
          else
          {
            if((cell_update_cause == rrc_CellUpdateCause_radiolinkFailure) || ((cell_update_cause == rrc_CellUpdateCause_rlc_unrecoverableError)
              && ((rb_id_unrec_error = rrclcm_get_ul_rb_id (cmd_ptr->cmd.crlc_status_ind.lc_id)) == DCCH_AM_RADIO_BEARER_ID)))
            { 
              if (cell_update_cause == rrc_CellUpdateCause_rlc_unrecoverableError)
              {
                WRRC_MSG1_HIGH("rlc error on RB id %d", rb_id_unrec_error);
                if ((rb_id_unrec_error >= DCCH_AM_RADIO_BEARER_ID) && 
                  (rb_id_unrec_error <= DCCH_DT_LOW_PRI_RADIO_BEARER_ID))
                {
                  rrccu_rlc_error_info.error_on_srb = TRUE;
                }
                else
                {
                  rrccu_rlc_error_info.error_on_urb = TRUE;
                }
              }
  
              /* Before sending cancel req to L1, check these conditions:
               * LLC substate is waiting for CPHY_SETUP_CNF, and not going to old config
               * and T314 and T315 are non-zero with associated RBs
               */
              if((LLC_WAIT_CPHY_SETUP_CNF == rrcllc_return_current_substate()) && 
                 (rrcllc_get_current_chan_conf_under_process_procedure() == proc_id) &&
                !(rrcllc_check_going_to_old_config()) && 
                (rrcllc_check_sufficient_act_time()) &&
                ((cu_tmr_status == RRCCU_T314_T315_NON_ZERO) ||
                (cu_tmr_status == RRCCU_T315_ZERO) || 
                ((cu_tmr_status == RRCCU_T314_ZERO &&
                 rrc_check_rbs_associated_with_re_est_timer(rrc_Re_EstablishmentTimer_useT315)))))
              
              {
  
                WRRC_MSG0_HIGH("Cancel pending L1 config ");
                llc_cmd_ptr = rrc_get_int_cmd_buf();
                llc_cmd_ptr->cmd.rrc_llc_req.l1_req = (l1_req_cmd *)rrc_malloc(sizeof(l1_req_cmd)); 
                  /* Initialize the LLC command header first */
                  llc_cmd_ptr->cmd_hdr.cmd_id= RRC_LLC_CMD_REQ;
                  llc_cmd_ptr->cmd.rrc_llc_req.procedure = RRC_PROCEDURE_CU;
                  llc_cmd_ptr->cmd.rrc_llc_req.cmd_dest = LAYER1_PHY;
                  llc_cmd_ptr->cmd.rrc_llc_req.l1_cmd.act_time_type = L1_ACTIVATION_TIME_NONE;
                  llc_cmd_ptr->cmd.rrc_llc_req.l1_cmd.cmd_id = CPHY_ACT_TIME_CANCEL_REQ;
                  rrc_put_int_cmd(llc_cmd_ptr); 
                }
                else
                {
                  /* We will come to this condition only if OC is set by procedure
                     and channel config is yet to be processed by LLC */
                  /* This condition is very rare. (receiving RL failure just after a DL SDU */
                  /* This scenario is seen only in DUAL SIM cases where CSP would initiate 
                     CU with cause RL failure for a call on other SUB */
                  /* Returning failure here will cause a TX to IDLE */
                  return RRCCU_FAILURE_MAJOR;
                }
            }
            else
            {
              /* unrecoverable error on other rbs */
              WRRC_MSG1_HIGH("rlc error on RB id %d and pending cfg not cancld", rb_id_unrec_error);
              if ((rb_id_unrec_error >= DCCH_AM_RADIO_BEARER_ID) && 
                  (rb_id_unrec_error <= DCCH_DT_LOW_PRI_RADIO_BEARER_ID))
              {
                rrccu_rlc_error_info.error_on_srb = TRUE;
              }
              else
              {
                rrccu_rlc_error_info.error_on_urb = TRUE;
              }
              
              if((RRCCU_T314_T315_ZERO == rrccu_check_re_est_timers()) ||  
                 (RRCCU_T314_ZERO == rrccu_check_re_est_timers() &&
                  !rrc_check_rbs_associated_with_re_est_timer(rrc_Re_EstablishmentTimer_useT315)))
              {
                WRRC_MSG0_HIGH("Going to idle do to T314 and T315 setting ");
                return RRCCU_FAILURE_MAJOR;
              }
            }
          }

          WRRC_MSG0_HIGH("move CU to wait for pending config sub state ");
          rrccu_substate = RRCCU_WAIT_FOR_PENDING_CONFIG;
          rrccu_cell_update_started = TRUE;
          return RRCCU_PENDING_CONFIG;
        }
      }
    }
  } /* oc is set */
#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  else if(rrcdata_check_if_ota_is_buffered())
  {
    /*Post buffer ind so that message will be rejected as CU sub state will be chnaged by the time of processing message*/
    rrcdata_post_buffer_ota_after_activation_time_expiry();
    rrctmr_stop_timer(RRCTMR_OTA_BUFFER_ACTIVATION_TIMER);
    return RRCCU_SUCCESS;
  }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
  else
  {
    return RRCCU_SUCCESS;
  }
}  /* rrccu_check_and_clear_oc_restrictions */


/*===========================================================================

FUNCTION RRCCU_INIT_PROCEDURE

DESCRIPTION
  This function will initialize the Cell Update procedure substate to 
  RRCCU_INITIAL Substate. This will called in the RRCTASK modules 
  along with other Init Procedures.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/

void rrccu_init_procedure
(    
  void  
)
{
  uint32 i;
  /* Resets the CU state machine */
  rrccu_substate            = RRCCU_INITIAL; 
  rrccu_cell_update_started = FALSE;
  rrccu_ura_update_started  = FALSE;

  rrccu_failure_state                   = RRC_STATE_WILDCARD;
  rrccu_chan_config_reqd                = FALSE;
  rrccu_oc_set_by_cu                    = FALSE;
  rrccu_cell_update_cause               = rrc_CellUpdateCause_cellUpdateCause_ext;
  rrccu_ura_update_cause                = rrc_URA_UpdateCause_spare1;
  rrccu_ura_update_required             = FALSE;
  rrccu_rb_release_info.rrccu_rb_release_in_cucnf = FALSE;

  rrccu_rl_failure_info.t314_info.timer_status         = RE_EST_TIMER_NOT_STARTED;
  rrccu_rl_failure_info.t314_info.need_to_release_rabs = FALSE;
  rrccu_rl_failure_info.t314_info.need_rab_release_ind = FALSE;
  rrccu_rl_failure_info.t315_info.timer_status         = RE_EST_TIMER_NOT_STARTED;
  rrccu_rl_failure_info.t315_info.need_to_release_rabs = FALSE;
  rrccu_rl_failure_info.t315_info.need_rab_release_ind = FALSE;
  rrccu_rlc_error_info.error_on_srb = FALSE;
  rrccu_rlc_error_info.error_on_urb = FALSE;

  /*clear the global variables stored */
  rrccu_cucnf_for_srns_relocation = FALSE;
  rrccu_new_urnti_valid = FALSE;
  rrccu_new_crnti_valid = FALSE;
  rrccu_reestablish_srb = FALSE;
  rrccu_reestablish_srb = FALSE;
  rrccu_reestablish_rab = FALSE;
  rrccu_reestablish_rab = FALSE;

  rrccu_cu_initiate_reqd.cu_reqd = FALSE;
  rrccu_utran_drx_coef  = 0; 
 
 
  rrccu_phy_chan_failure_from_rb = FALSE;
  rrccu_int_data.rrccu_cell_selection_trans_from_fach =FALSE;
  rrccu_int_data.rrccu_cell_selection_last_response_msg = RRCCU_NO_RESP_MSG;
  rrccu_int_data.rrccu_cell_selection_last_trans_id = 0xff;
  rrccu_int_data.rrccu_last_cucnf_for_srns_relocation= FALSE;
  rrccu_int_data.rrccu_last_cucnf_cipher_update_required = FALSE;
  rrccu_chan_config_info.num_rbs = 0;

  /* Set no of registered procedures to zero */
  rrccu_reg_info.no_of_reg_procs = 0;
  pending_config_proc_id = RRC_PROCEDURE_NONE;
  rb_id_unrec_error = RRC_INVALID_RB_ID; 

  rrccu_revert_back_to_old_config = FALSE;

  rrccu_int_data.wait_time_in_pch = RRC_T320_INVALID_VALUE;
  rrccu_int_data.cu_cause_for_wait_timer = RRC_CU_CAUSE_NONE;

  rrccu_hsrach_delay_cu_sib_change = FALSE;

  /* Initialize all procedures to NULL proecdures */
  for (i = 0; i < (uint32)MAX_NUM_OF_PROCEDURES; i++)
  {
    rrccu_reg_info.rrc_proc[i] = RRC_PROCEDURE_NONE;
  }
  

  rrccu_is_bplmn_suspend_retried = FALSE;

    
  rrcscmgr_register_for_scn(RRC_PROCEDURE_CU,
                            RRC_STATE_WILDCARD,
                            RRC_STATE_DISCONNECTED);

  rrcscmgr_register_for_scn(RRC_PROCEDURE_CU,
                            RRC_STATE_CELL_DCH,
                            RRC_STATE_CELL_FACH);

  /* DCH->CELL_PCH state change notification is reqd:
  to start timer t305 */
  rrcscmgr_register_for_scn(RRC_PROCEDURE_CU,
                            RRC_STATE_CELL_DCH,
                            RRC_STATE_CELL_PCH);

  /* DCH->URA_PCH state change notification is reqd:
  to start timer t305
  to Check URA reselection */
  rrcscmgr_register_for_scn(RRC_PROCEDURE_CU,
                            RRC_STATE_CELL_DCH,
                            RRC_STATE_URA_PCH);
  /* FACH->URA_PCH state change notification is reqd:
  to check URA reselection */

  rrcscmgr_register_for_scn(RRC_PROCEDURE_CU,
                            RRC_STATE_CELL_FACH,
                            RRC_STATE_URA_PCH);
  
  /* FACH->CELL_PCH state change notification is reqd:
   */
  rrcscmgr_register_for_scn(RRC_PROCEDURE_CU,
                            RRC_STATE_CELL_FACH,
                            RRC_STATE_CELL_PCH);

  /*register for SIB2 modification notification from SIB proc */
  rrcsib_register_for_sib_change_notification ( RRC_PROCEDURE_CU,
                                                rrc_SIB2
                                              );
  rrc_cu_uu_log_event_started = FALSE;
  rrc_cu_uu_log_event_failure_cause = RRC_CU_UU_FAILURE_CAUSE_NONE;
  need_to_incl_failure_cause_in_next_cu = FALSE;
} /* rrccu_init_procedure */


/*===========================================================================

FUNCTION RRCCU_RESET_REGISTRATION_INFO

DESCRIPTION
  This function will reset the registration information.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/

void rrccu_reset_registration_info
(    
  void  
)
{
  uint32 i;
 
  /* Set no of registered procedures to zero */
  rrccu_reg_info.no_of_reg_procs = 0;

  /* Initialize all procedures to NULL proecdures */
  for (i = 0; i < (uint32)MAX_NUM_OF_PROCEDURES; i++)
  {
    rrccu_reg_info.rrc_proc[i] = RRC_PROCEDURE_NONE;
  }
 } /* rrccu_reset_registration_info */

/*===========================================================================

FUNCTION RRCCU_RESET_REGISTRATION_INFO_FOR_PROCEDURE

DESCRIPTION
  This function will reset the registration information.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/

void rrccu_reset_registration_info_for_procedure
(
  rrc_proc_e_type proc_id
)
{
  uint32 i;
 
  /* Initialize all procedures to NULL proecdures */
  for (i = 0; i <  rrccu_reg_info.no_of_reg_procs; i++)
  {
    if(proc_id == rrccu_reg_info.rrc_proc[i])
    {
       rrccu_reg_info.rrc_proc[i] = 
           rrccu_reg_info.rrc_proc[rrccu_reg_info.no_of_reg_procs-1];

       rrccu_reg_info.rrc_proc[rrccu_reg_info.no_of_reg_procs-1] 
          = RRC_PROCEDURE_NONE;
       rrccu_reg_info.no_of_reg_procs--;
       break;
     }
   }
 } /* rrccu_reset_registration_info */

/*===========================================================================

FUNCTION rrccu_status_for_reselection

DESCRIPTION
  This function will check whether CU is in a state where reselection
  can be continued. This API is to prevent situations such as reselection
  when oc is set and lower layers are being configured. 

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/

boolean rrccu_status_for_reselection
(    
  void  
)
{
  boolean status = TRUE;
  switch (rrccu_substate)
  {
    case  RRCCU_WAIT_FOR_RB_EST_CNF:
      /* no need to check next state 
      lower layers are being configured
      block reselection*/
      status = FALSE;
      break;

    case  RRCCU_WAIT_FOR_SRB2_RE_EST_CNF:
      /* Involves SRNS relocation and 
      lower layers are being configured
      block reselection*/
      status = FALSE;
      break;

    case  RRCCU_WAIT_FOR_L2_ACK:
      /* cu in in this substate because either the
      message involves SRNS relocation or next state
      is CELL_PCH/URA_PCH. Block reselection only if 
      CU is in this state due to SRNS relocation and
      OC is set by cu */
      if ((rrccu_oc_set_by_cu == TRUE) && 
          (rrccu_cucnf_for_srns_relocation))
      {
        /* Involves SRNS relocation and 
        lower layers are being configured
        block reselection*/
        status = FALSE;
      }
      break;

    case  RRCCU_WAIT_FOR_RNTI_UPDATE_CNF:
      if ((rrccu_cucnf_for_srns_relocation) ||
          ((rrccu_oc_set_by_cu == TRUE) &&
          (rrccu_state_indicator != rrc_RRC_StateIndicator_cell_PCH) &&
          (rrccu_state_indicator != rrc_RRC_StateIndicator_ura_PCH)))
      {
        /* Block reselection when either SRNS reloc is 
        involved and response has not been
        sent yet or lower layers are being configured*/
        status = FALSE;
      }
      break;

    default:
      break;
  }
  MSG_HIGH("cu_st:%d,oc:%d,resel:%d",
           rrccu_substate, rrccu_oc_set_by_cu, status);
  return status; 
} /* rrccu_status_for_reselection */



 /*===========================================================================

FUNCTION RRCCU_MAP_CU_INITIATION_CAUSE

DESCRIPTION
  This function returns the cellupdate cause defined in rrc asn.1 corresponding to the
  cause received in cell update initiate request from various procedures.


DEPENDENCIES
  None

RETURN VALUE
  rrc_CellUpdateCause cause

SIDE EFFECTS
  None
===========================================================================*/
static rrc_CellUpdateCause rrccu_map_cu_initiation_cause
(
  rrc_cell_update_cause_e_type cause             
)
{
  rrc_CellUpdateCause rrc_cause = rrc_CellUpdateCause_cellUpdateCause_ext;
  switch (cause)
  {
    case RRC_CELL_RESELECTION:
      rrc_cause = rrc_CellUpdateCause_cellReselection;
      break;

    case RRC_PERIODIC_CELL_UPDATE:
      rrc_cause = rrc_CellUpdateCause_periodicalCellUpdate;
      break;

    case RRC_UL_DATA_TRANSMISSION:
#ifdef FEATURE_WCDMA_HS_RACH
    case RRC_PCH_TO_FACH_TRANSITION_REQ:
#endif
      rrc_cause = rrc_CellUpdateCause_uplinkDataTransmission;
      break;

    case RRC_PAGING_RESPONSE:
      rrc_cause = rrc_CellUpdateCause_utran_pagingResponse;
      break;

    case RRC_RADIO_LINK_FAILURE:
      rrc_cause = rrc_CellUpdateCause_radiolinkFailure;
      break;

    case RRC_REENTERED_SERVICE_AREA:
      rrc_cause = rrc_CellUpdateCause_re_enteredServiceArea;
      break;

    case RRC_UNRECOVERABLE_ERROR:
      rrc_cause = rrc_CellUpdateCause_rlc_unrecoverableError;
      break;


#ifdef FEATURE_BPLMN_SEARCH_320MS
    case RRC_LOSSY_PAGE_RECEPTION:
      rrc_cause = rrc_CellUpdateCause_re_enteredServiceArea;
      break;
#endif /*FEATURE_BPLMN_SEARCH_320MS*/

    default:
      WRRC_MSG1_ERROR("No CU ASN1 cause correspondig to %d", cause); 
      break;
  }
  return rrc_cause;

}
 /*===========================================================================

FUNCTION RRCCU_MAP_UU_INITIATION_CAUSE

DESCRIPTION
  This function returns the uraupdate cause defined in rrc asn.1 corresponding to the
  cause received in ura update initiate request from various procedures.


DEPENDENCIES
  None

RETURN VALUE
  rrc_URA_UpdateCause cause

SIDE EFFECTS
  None
===========================================================================*/
static rrc_URA_UpdateCause rrccu_map_uu_initiation_cause
(
  rrc_ura_update_cause_e_type cause             
)
{
  rrc_URA_UpdateCause rrc_cause = rrc_URA_UpdateCause_spare1;
  switch (cause)
  {
    case RRC_URA_RESELECTION:
      rrc_cause = rrc_URA_UpdateCause_changeOfURA;
      break;

    case RRC_PERIODIC_URA_UPDATE:
      rrc_cause = rrc_URA_UpdateCause_periodicURAUpdate;
      break;

    default:
      WRRC_MSG1_ERROR("No UU ASN1 cause correspondig to %d", cause); 
      rrc_cause = rrc_URA_UpdateCause_spare1;
      break;
  }
  return rrc_cause;
}  /* rrccu_map_uu_initiation_cause */

/*===========================================================================

FUNCTION rrccu_send_ura_update_initiate_req

DESCRIPTION
  This function sends the ura update initiate request 

DEPENDENCIES
  None.

RETURN VALUE
  None.

===========================================================================*/
static void rrccu_send_ura_update_initiate_req
(
rrc_ura_update_cause_e_type  cause,
boolean                      cnf_reqd
)
{
  rrc_cmd_type *int_cmd_ptr;

  int_cmd_ptr =  rrc_get_int_cmd_buf();

  /* Fill in the command parameters for RRC_CELL_UPDATE_INITIATE_REQ */
  int_cmd_ptr->cmd_hdr.cmd_id                                   = RRC_URA_UPDATE_INITIATE_REQ;
  int_cmd_ptr->cmd.initiate_ura_update.cause                    = cause;
  int_cmd_ptr->cmd.initiate_ura_update.uu_complete_cnf_required = cnf_reqd;
  int_cmd_ptr->cmd.initiate_ura_update.procedure                = RRC_PROCEDURE_CU;
  WRRC_MSG2_HIGH("URA_UPDATE_INITIATE  Cause:%d, cnf_reqd:%d", 
             cause, cnf_reqd);
  rrc_put_int_cmd(int_cmd_ptr);             

}/*rrccu_send_ura_update_initiate_req*/

/*===========================================================================

FUNCTION RRCCU_CONVERT_T307_TO_MS

DESCRIPTION
  This function converts the rrc_T_307 enums to milliseconds

DEPENDENCIES
  None

RETURN VALUE
  uint32

SIDE EFFECTS
  None
===========================================================================*/
uint32 rrccu_convert_t307_to_ms
(
  rrc_T_307 rrccu_t_307                    /* enum for Timer T307 */
)
{
  uint32 timer_value;                         /* Timer Value in milli seconds */

  switch (rrccu_t_307)
  {
    case rrc_T_307_s5:
      timer_value = 5000;
      break;
    case rrc_T_307_s10:
      timer_value = 10000;
      break;      
    case rrc_T_307_s15:
      timer_value = 15000;
      break;
    case rrc_T_307_s20:
      timer_value = 20000;
      break;
    case rrc_T_307_s30:
      timer_value = 30000;
      break;
    case rrc_T_307_s40:
      timer_value = 40000;
      break; 
    case rrc_T_307_s50:
      timer_value = 50000;
      break;
    default:
      WRRC_MSG0_HIGH("Unknown Timer value received ");
      timer_value = 0;                  /* Set lowest timer value as a default */
      break;
  }
  return (timer_value);
} /* rrccu_convert_t307_to_ms*/
/*===========================================================================

FUNCTION RRCCU_CONVERT_T302_TO_MS

DESCRIPTION
  This function converts the rrc_T_302 enums to milliseconds

DEPENDENCIES
  None

RETURN VALUE
  uint32

SIDE EFFECTS
  None
===========================================================================*/
uint32 rrccu_convert_t302_to_ms
(
  rrc_T_302 rrccu_t_302                    /* enum for Timer T302 */
)
{
  uint32 timer_value;                      /* Timer Value in milli seconds */

  switch (rrccu_t_302)
  {
    case rrc_T_302_ms100:
      timer_value = 100;
      break;
    case rrc_T_302_ms200:
      timer_value = 200;
      break;      
    case rrc_T_302_ms400:
      timer_value = 400;
      break;
    case rrc_T_302_ms600:
      timer_value = 600;
      break;
    case rrc_T_302_ms800:
      timer_value = 800;
      break;
    case rrc_T_302_ms1000:
      timer_value = 1000;
      break; 
    case rrc_T_302_ms1200:
      timer_value = 1200;
      break;
    case rrc_T_302_ms1400:
      timer_value = 1400;
      break;      
    case rrc_T_302_ms1600:
      timer_value = 1600;
      break;
    case rrc_T_302_ms1800:
      timer_value = 1800;
      break;
    case rrc_T_302_ms2000:
      timer_value = 2000;
      break;
    case rrc_T_302_ms3000:
      timer_value = 3000;
      break; 
    case rrc_T_302_ms4000:
      timer_value = 4000;
      break;
    case rrc_T_302_ms6000:
      timer_value = 6000;
      break; 
    case rrc_T_302_ms8000:
      timer_value = 8000;
      break;

    default:
      WRRC_MSG0_HIGH("Unknown Timer value received ");
      timer_value = 200;                  /* Set lowest timer value as a default */
      break;
  }
  return (timer_value);
} /* rrccu_convert_t302_to_ms*/
/*===========================================================================

FUNCTION RRCCU_CONVERT_T316_TO_MS

DESCRIPTION
  This function converts the rrc_T_316 enums to milliseconds

DEPENDENCIES
  None

RETURN VALUE
  uint32

SIDE EFFECTS
  None
===========================================================================*/
uint32 rrccu_convert_t316_to_ms
(
  rrc_T_316 rrccu_t_316                    /* enum for Timer T316 */
)
{
  uint32 timer_value;                      /* Timer Value in milli seconds */

  switch (rrccu_t_316)
  {
    case rrc_T_316_s0:
      timer_value = 0;
      break;
    case rrc_T_316_s10:
      timer_value = 10000;
      break;      
    case rrc_T_316_s20:
      timer_value = 20000;
      break;
    case rrc_T_316_s30:
      timer_value = 30000;
      break;
    case rrc_T_316_s40:
      timer_value = 40000;
      break;
    case rrc_T_316_s50:
      timer_value = 50000;
      break; 
    case rrc_T_316_s_inf:                      /* Set very large value for infinity */
      timer_value = RRCTMR_INFINITY_VAL;
      break;

    default:
      WRRC_MSG0_HIGH("Unknown Timer value received ");
      timer_value = 0;                  /* Set lowest timer value as a default */
      break;
  }
  return (timer_value);
} /* rrccu_convert_t316_to_ms*/

/*===========================================================================

FUNCTION RRCCU_CONVERT_T314_TO_MS

DESCRIPTION
  This function converts the rrc_T_314 enums to milliseconds

DEPENDENCIES
  None

RETURN VALUE
  uint32

SIDE EFFECTS
  None
===========================================================================*/
uint32 rrccu_convert_t314_to_ms
(
  rrc_T_314 rrccu_t_314                    /* enum for Timer T314 */
)
{
  uint32 timer_value;                      /* Timer Value in milli seconds */

  switch (rrccu_t_314)
  {
    case rrc_T_314_s0:
     timer_value = 0;
      break;
    case rrc_T_314_s2:
      timer_value = 2000;
      break;      
    case rrc_T_314_s4:
      timer_value = 4000;
      break;
    case rrc_T_314_s6:
      timer_value = 6000;
      break;
    case rrc_T_314_s8:
      timer_value = 8000;
      break;
    case rrc_T_314_s12:
      timer_value = 12000;
      break; 
    case rrc_T_314_s16:
      timer_value = 16000;
      break;
    case rrc_T_314_s20:
      timer_value = 20000;
      break;
    default:
      WRRC_MSG0_HIGH("Unknown Timer value received");
      timer_value = 0;                     /* Set lowest timer value as a default */
      break;
  }
  return (timer_value);
} /* rrccu_convert_t314_to_ms*/
/*===========================================================================

FUNCTION RRCCU_CONVERT_T315_TO_MS

DESCRIPTION
  This function converts the rrc_T_315 enums to milliseconds

DEPENDENCIES
  None

RETURN VALUE
  int

SIDE EFFECTS
  None
===========================================================================*/
uint32 rrccu_convert_t315_to_ms
(
  rrc_T_315 rrccu_t_315                    /* enum for Timer T315 */
)
{
  uint32 timer_value;                       /* Timer Value in milli seconds */

  switch (rrccu_t_315)
  {
    case rrc_T_315_s0:
     timer_value = 0;
      break;
    case rrc_T_315_s10:
      timer_value = 10000;
      break;      
    case rrc_T_315_s30:
      timer_value = 30000;
      break;
    case rrc_T_315_s60:
      timer_value = 60000;
      break;
    case rrc_T_315_s180:
      timer_value = 180000;
      break;
    case rrc_T_315_s600:
      timer_value = 600000;
      break; 
    case rrc_T_315_s1200:
      timer_value = 1200000;
      break;
    case rrc_T_315_s1800:
      timer_value = 1800000;
      break;
    default:
      WRRC_MSG0_HIGH("Unknown Timer value received");
      timer_value = 0;               /* Set lowest timer value as a default */
      break;
  }
  return (timer_value);
} /* rrccu_convert_t315_to_ms*/
/*===========================================================================

FUNCTION RRCCU_STOP_CU_TIMERS

DESCRIPTION
  This function stops all Cell Update procedure related timers. This
  function will be used when CU procedure non-gracefully terminates and
  RRC transitions to Disconnected State.


DEPENDENCIES
  None

RETURN VALUE
  int

SIDE EFFECTS
  None
===========================================================================*/
void rrccu_stop_cu_timers
(
  void              
)
{
  /* There ins no harm if one stops the timer that had already stopped.*/

  /* Stop timer T305 */
  rrctmr_stop_timer(RRCTMR_T_305_TIMER);
  /* Stop timer T302 */
  rrctmr_stop_timer(RRCTMR_T_302_TIMER);
    /* Stop timer T307 */
  rrctmr_stop_timer(RRCTMR_T_307_TIMER);
  /* Stop timer T317 */
  rrctmr_stop_timer(RRCTMR_T_317_TIMER);
  /* Stop timer T316 */
  rrctmr_stop_timer(RRCTMR_T_316_TIMER);
  /* Stop timer T315 */
  rrctmr_stop_timer(RRCTMR_T_315_TIMER);
  /* Stop timer T314 */
  rrctmr_stop_timer(RRCTMR_T_314_TIMER);

} /* rrccu_stop_cu_timers*/


  /*===========================================================================

FUNCTION rrccu_send_rnti_update_req

DESCRIPTION
  This function builds rnti update command and uses globally populated
  rnti and rlc-restablishment info 

DEPENDENCIES
  None.

RETURN VALUE
  None.

===========================================================================*/
static void rrccu_send_rnti_update_req
(
 boolean cnf_req
)
{
  rrc_cmd_type *int_cmd_ptr;

  /* send RNTI update request now before sending the response message*/
  /* Allocates the buffer to RRC Internal command */
  if( (int_cmd_ptr =  rrc_get_int_cmd_buf()) != NULL)
  { 
    int_cmd_ptr->cmd_hdr.cmd_id = RRC_RNTI_UPDATE_REQ;

    /* Fill parameters for RRC_RNTI_UPDATE_REQ command */
    int_cmd_ptr->cmd.rnti_update_req.procedure = RRC_PROCEDURE_CU;

    if(rrccu_new_crnti_valid)
    {
      int_cmd_ptr->cmd.rnti_update_req.crnti_action = RRC_RNTI_UPDATE;
      int_cmd_ptr->cmd.rnti_update_req.crnti = rrccu_new_crnti;
    }
    else
    {
      int_cmd_ptr->cmd.rnti_update_req.crnti_action = RRC_RNTI_NOCHANGE;
    }

    if(rrccu_new_urnti_valid)
    {
      int_cmd_ptr->cmd.rnti_update_req.urnti_action = RRC_RNTI_UPDATE;
      int_cmd_ptr->cmd.rnti_update_req.urnti= rrccu_new_urnti;
    }
    else
    {
      int_cmd_ptr->cmd.rnti_update_req.urnti_action = RRC_RNTI_NOCHANGE;
    }
    /* Indicate to LLC if RLC for SRBs needs to be re-established */
    if(rrccu_reestablish_srb == TRUE)
    {
      int_cmd_ptr->cmd.rnti_update_req.rlc_re_establish_srb = TRUE;
    }
    else
    {
      int_cmd_ptr->cmd.rnti_update_req.rlc_re_establish_srb = FALSE;
    }
    /* Indicate to LLC if RLC for User plane RBs needs to be re-established */
    if( rrccu_reestablish_rab == TRUE)
    {
      int_cmd_ptr->cmd.rnti_update_req.rlc_re_establish_rab = TRUE;
    }
    else
    {
      int_cmd_ptr->cmd.rnti_update_req.rlc_re_establish_rab = FALSE;
    }

    int_cmd_ptr->cmd.rnti_update_req.cnf_required = cnf_req;

    MSG_HIGH("RNTI update req, crnti:%d, urnti:%d, re_est:%d",
             rrccu_new_crnti_valid, 
             rrccu_new_urnti_valid,
             rrccu_reestablish_rab
             );
    rrc_put_int_cmd(int_cmd_ptr);       /* sends the command to RRC  LLC. */
  }
 }/*rrccu_send_rnti_update_req*/

 /*===========================================================================

FUNCTION rrccu_remove_rbs_from_est_rabs

DESCRIPTION
  This function removes the RBs from established_rabs variable.
  If all the RBs of a RAB are removed then it will send an indication to
  upper layer.

DEPENDENCIES
  None.

RETURN VALUE
  None.
===========================================================================*/
static void rrccu_remove_rbs_from_est_rabs
(
 void
)
{
  mm_cmd_type               *mm_ptr;   /* To send the MM_SYNC_IND command */
  rabm_cmd_type             *rabm_ptr; /* To send the RABMAS_RAB_RELEASE_IND  command */
  rrc_rb_remove_result_type rab_result; /* To hold result */
  uint32                     rb_index;
#ifdef FEATURE_DUAL_SIM
  boolean rab_removed = FALSE;
#endif
  /*set the flag to false here */
  rrccu_rb_release_info.rrccu_rb_release_in_cucnf = FALSE;

  for (rb_index=0; rb_index<rrccu_rb_release_info.num_rbs; rb_index++)
  {
    /* Call the function to remove each RB */
    rrc_remove_rb_from_established_rabs( rrccu_rb_release_info.rb_id[rb_index],
                                         &(rab_result));
    /* Now check if a RAB was removed because of this RB */
    if ( rab_result.result == RRC_RB_AND_RAB_REMOVED )
    {
      /* Since a RAB was removed, we should send the
      indication to the appropriate NAS entity. For CS
      RABs send the command to MM layer and for PS RABs
      send it to RABM layer. */
        
#ifdef FEATURE_DUAL_SIM
      rab_removed = TRUE;
#endif
      if ( rab_result.cn_domain == RRC_CS_DOMAIN_CN_ID )
      {
        mm_ptr = mm_rrc_get_cmd_buf(RRC_SYNC_IND);

        if ( rab_result.cn_domain == RRC_CS_DOMAIN_CN_ID )
        {
          mm_ptr->cmd.rrc_sync_ind.cn_domain_id = RRC_CS_DOMAIN_CN_ID;
        }
        else
        {
          mm_ptr->cmd.rrc_sync_ind.cn_domain_id = RRC_PS_DOMAIN_CN_ID;
        }
        mm_ptr->cmd.rrc_sync_ind.cause = RRC_RAB_ESTABLISHED;
        mm_ptr->cmd.rrc_sync_ind.rab_id_present = TRUE;
        mm_ptr->cmd.rrc_sync_ind.rab_info.action = RAB_RELEASED;
        mm_ptr->cmd.rrc_sync_ind.rab_info.rab_id = rab_result.rab_id;
#ifdef FEATURE_UMTS_VOICE_CIPHERING_IND
        #error code not present
#endif /*FEATURE_UMTS_VOICE_CIPHERING_IND*/


        if(rab_result.rab_type == RRCRB_CS_VOICE_RAB)
        {
          mm_ptr->cmd.rrc_sync_ind.rab_info.cs_rab_type = RRCMN_CS_VOICE_CALL;
        }
        else if(rab_result.rab_type == RRCRB_CS_DATA_RAB)
        {
          mm_ptr->cmd.rrc_sync_ind.rab_info.cs_rab_type = RRCMN_CS_DATA_CALL;
        }
        else
        {
          WRRC_MSG1_ERROR("Something wrong with RAB Type for RAB-id %d",
              mm_ptr->cmd.rrc_sync_ind.rab_info.rab_id);
          mm_ptr->cmd.rrc_sync_ind.rab_info.cs_rab_type = RRCMN_INVALID_RAB_ID;
        }

#ifdef FEATURE_DUAL_SIM
        mm_ptr->cmd.rrc_sync_ind.as_id = rrc_get_as_id();
#endif

        /* Put the command on MM queue */
        WRRC_MSG2_HIGH("Dispatching out MM cmd / Sending RRC_SYNC_IND to MM for RAB type %d RAB-id %d", 
                mm_ptr->cmd.rrc_sync_ind.rab_info.cs_rab_type, 
                mm_ptr->cmd.rrc_sync_ind.rab_info.rab_id);
        rrc_send_rrc_message_to_mm(mm_ptr);
      }/* end if cs domain */
      else if ( rab_result.cn_domain == RRC_PS_DOMAIN_CN_ID )
      {
        if ((rabm_ptr = rabm_get_cmd_buf()) == NULL)
        {
          ERR_FATAL("Can't send RABM cmd - out of memory!", 0, 0, 0);
        }
        rabm_ptr->header.cmd_id = RABMAS_RAB_RELEASE_IND;
        rabm_ptr->header.message_set = MS_RABM_RRC;
        rabm_ptr->cmd.rrc_release_ind.rabid = 
        (rabid_T)(rab_result.rab_id);
#ifdef FEATURE_DUAL_SIM
        rabm_ptr->cmd.rrc_release_ind.as_id = rrc_get_as_id();
#endif
        /* Put the command on RABM queue */
        WRRC_MSG0_HIGH("Sending RABMAS_RAB_RELEASE_IND to RABM");
        rabm_put_cmd(rabm_ptr);
      }/* end if ps domain */
    }/* end if RB_AND_RAB_REMOVED */
  } /* for rb_index */
#ifdef FEATURE_DUAL_SIM
  if(rab_removed == TRUE)
  {
    rrc_check_send_change_priority();
  }
#endif


}/*rrccu_remove_rbs_from_est_rabs*/

/*===========================================================================

FUNCTION RRCCU_GET_CELL_UPDATE_STARTED_STATUS_WITH_CAUSE

DESCRIPTION

  This function checks whether Cell Update procedure is started or not.
  
DEPENDENCIES


RETURN VALUE

  A value of rrccu_cell_update_status_e_type indicating the status of the
  function.

SIDE EFFECTS

  None

===========================================================================*/
#ifdef FEATURE_QSH_DUMP
__attribute__((section(".uncompressible.text")))
#endif
rrccu_cell_update_started_status_e_type rrccu_get_cell_update_started_status_with_cause
(    
  rrc_CellUpdateCause       *cu_cause_ptr
)
{
  *cu_cause_ptr = rrccu_cell_update_cause;
  if(rrccu_substate != RRCCU_INITIAL)  
  {
    return( RRCCU_STARTED );
  }
  else
  {
    return(RRCCU_NOT_STARTED);
  }
} /* rrccu_get_cell_update_started_status_with_cause */

/*===========================================================================

FUNCTION rrccu_get_cu_cause

DESCRIPTION

  Returns cell update cause
  
DEPENDENCIES


RETURN VALUE

  Returns cell update cause

SIDE EFFECTS

  None

===========================================================================*/

rrc_CellUpdateCause rrccu_get_cu_cause(void)
{
  WRRC_MSG1_HIGH("Cell update cause is  : %d",rrccu_cell_update_cause);
  return rrccu_cell_update_cause;
}

/*===========================================================================

FUNCTION RRCCU_GET_CELL_UPDATE_COMPLETE_STATUS

DESCRIPTION

  This function checks whether Cell Update procedure is active or not and 
  returns the status to the procedure.
  
DEPENDENCIES


RETURN VALUE

  A value of rrccu_cell_update_complete_status_e_type indicating the status of the
  function.

SIDE EFFECTS

  None

===========================================================================*/
rrccu_cell_update_complete_status_e_type rrccu_get_cell_update_complete_status
(    
  rrc_proc_e_type rrc_proc
)
{
  rrccu_cell_update_complete_status_e_type status;

  if( RRCCU_NOT_STARTED == rrccu_get_cell_update_started_status() )
  {
    status = RRCCU_COMPLETED;
  }
  else
  {
    /*If CU is waiting for SIB7, and if DT procs query for CU status,
    return COMPLETED and register */
#ifdef FEATURE_UPDATE_SIB7_FOR_PCH_TO_FACH
    if((rrccu_substate == RRCCU_WAIT_FOR_SIB7_CURRENT) && 
      ((rrc_proc == RRC_PROCEDURE_IDT) || (rrc_proc == RRC_PROCEDURE_UDT) ||
       (rrc_proc == RRC_PROCEDURE_SCRR) || 
       (rrc_proc == RRC_PROCEDURE_DORMANCY)
      ))
    {
      (void)rrccu_register_for_cell_update_to_complete(rrc_proc);
      return RRCCU_COMPLETED;
    }  
#endif /*FEATURE_UPDATE_SIB7_FOR_PCH_TO_FACH*/
    switch( rrccu_cell_update_cause )
    {
      case rrc_CellUpdateCause_cellReselection:
      case rrc_CellUpdateCause_radiolinkFailure:
      case rrc_CellUpdateCause_uplinkDataTransmission:
      case rrc_CellUpdateCause_utran_pagingResponse:
        /* Update the registration if Cell Update is not completed */
        (void)rrccu_register_for_cell_update_to_complete(rrc_proc);
        status = RRCCU_NOT_COMPLETED;
        break;

      case rrc_CellUpdateCause_rlc_unrecoverableError:
      case rrc_CellUpdateCause_periodicalCellUpdate:
      case rrc_CellUpdateCause_cellUpdateCause_ext:
          case rrc_CellUpdateCause_re_enteredServiceArea:
        if (C_RNTI_NOT_VALID == rrcllc_get_current_crnti_status() )
        {
          /* Update the registration if Cell Update is not completed */
          (void)rrccu_register_for_cell_update_to_complete(rrc_proc);
          status = RRCCU_NOT_COMPLETED;
        }
        else
        {
          status = RRCCU_COMPLETED;
        }
        break;

      default:
        status = RRCCU_COMPLETED;
        WRRC_MSG0_ERROR(" Unknown Cell Update cause");
        break;
    }
  }
  return (status);
} /* rrccu_get_cell_update_complete_status */
/*===========================================================================

FUNCTION RRCCU_REGISTER_FOR_CELL_UPDATE_TO_COMPLETE

DESCRIPTION

  This function registers RRC proceudre to inform when Cell Update is
  completed.
  
DEPENDENCIES


RETURN VALUE

  A value of uecomdef_status_e_type indicating success or failure of 
  registration..

SIDE EFFECTS

  None

===========================================================================*/
uecomdef_status_e_type rrccu_register_for_cell_update_to_complete
(    
  rrc_proc_e_type rrc_proc
)
{
  uecomdef_status_e_type status = FAILURE;
  int32 counter;
  boolean match_found = FALSE;
  
  

  if( rrccu_reg_info.no_of_reg_procs >= (uint32)MAX_NUM_OF_PROCEDURES )
  {
    WRRC_MSG0_ERROR("Failed to Register RRC Procedure");
  }
  else
  {
    if (rrccu_reg_info.no_of_reg_procs > 0)
    {
      /* Check for duplication registers */
      for(counter = (int32) rrccu_reg_info.no_of_reg_procs-1; counter >= 0; counter--)
      {
        if(rrccu_reg_info.rrc_proc[counter] == rrc_proc)
        {
          match_found = TRUE;
          MSG_MED("Duplicate registration: %d", rrc_proc,0,0);
          break;
        }
      }
    }
    /* No Duplication, Add to the list */
    if(!match_found)
    {
      /* Update the registration  */
      rrccu_reg_info.rrc_proc[rrccu_reg_info.no_of_reg_procs] = rrc_proc; 
      rrccu_reg_info.no_of_reg_procs++;
    }
    status = SUCCESS;
  }
  return (status);
} /* rrccu_register_for_cell_update_to_complete */


/*===========================================================================

FUNCTION rrccu_process_successful_completion

DESCRIPTION
 This function handles the successful completion of CU CNF or URA Update CNF.

DEPENDENCIES
  None.

RETURN VALUE
  uint32.

===========================================================================*/
void rrccu_process_successful_completion
( 
  void 
)
{
#ifdef FEATURE_WCDMA_REL7_SPECRS 
  rrc_save_rnc_cap_change_support();
#endif /*FEATURE_WCDMA_REL7_SPECRS*/
  rrccu_log_cu_status(RRC_CU_UU_STATUS_SUCCESS, TRUE);
  return;
}


/*===========================================================================

FUNCTION RRCCU_INFORM_CELL_UPDATE_COMPLETED

DESCRIPTION

  This function checks the database and sends RRC_CELL_UPDATE_COMPLETE_CNF
  command to all RRC procedures that waiting for Cell Update completetion.
  
DEPENDENCIES


RETURN VALUE

  None

SIDE EFFECTS

  None

===========================================================================*/
void rrccu_inform_cell_update_completed
(    
  void
)
{
  
  rrc_cmd_type *cmd_ptr = NULL;              /* Pointer to the RRC Command */
  uint32 count = 0;                          /* Local variable to store the
                                                count */

  while( count < rrccu_reg_info.no_of_reg_procs)
  {
    /* Allocates the buffer to RRC Internal command */
    cmd_ptr =  rrc_get_int_cmd_buf();
    /* Fill in the command parameters for RRC_CELL_UPDATE_COMPLETE_CNF */
    cmd_ptr->cmd_hdr.cmd_id = RRC_CELL_UPDATE_COMPLETE_CNF;
    cmd_ptr->cmd.cu_complete_cnf.procedure = rrccu_reg_info.rrc_proc[count];
    MSG_MED("RRC_CELL_UPDATE_COMPLETE_CNF is sent to Proc rrc_proc_e_type_value%d ",
             rrccu_reg_info.rrc_proc[count],0,0);
    rrc_put_int_cmd(cmd_ptr);                 /* sends the command to RRC
                                                   LLC. */
    count++;
    cmd_ptr = NULL;
  }
   /* Initialize procedures to NULL proecdures */
  for (count = 0; count < rrccu_reg_info.no_of_reg_procs; count++)
  {
    rrccu_reg_info.rrc_proc[count] = RRC_PROCEDURE_NONE;
  }
   /* Set no of registered procedures to zero */
  rrccu_reg_info.no_of_reg_procs = 0;


} /* rrccu_inform_cell_update_completed */

/*===========================================================================

FUNCTION RRCCU_PURGE_RLC_WM

DESCRIPTION

  This function requests RLC to purge RLC UL  watermark
  
DEPENDENCIES


RETURN VALUE

  None

SIDE EFFECTS

  None

===========================================================================*/
static void rrccu_purge_rlc_wm
(    
boolean purge_rb0, boolean purge_srb1_2  
)
{
   uint32 count=0;
  
   rrc_cmd_type *llc_cmd_ptr;                     /* Pointer to the RRC Command */

   l2_ul_req_cmd * llc_cmd_l2_ptr = NULL;
    /*send CRLC DATA IND REQ to RLC via rrcllc */
    llc_cmd_ptr = rrc_get_int_cmd_buf();
    RRC_GET_POINTER_L2_REQ_VALUE(llc_cmd_ptr->cmd.rrc_llc_req.l2_ul_req,llc_cmd_l2_ptr);
    /* Initialize the LLC command header first */
    llc_cmd_ptr->cmd_hdr.cmd_id= RRC_LLC_CMD_REQ;
    llc_cmd_ptr->cmd.rrc_llc_req.procedure = RRC_PROCEDURE_CU;
    llc_cmd_ptr->cmd.rrc_llc_req.cmd_dest = LAYER2_RLC_UL;
    /* Now fill the L2 cmd header */
    llc_cmd_ptr->cmd.rrc_llc_req.l2_ul_cmd.cmd_id = RLC_UL_PURGE_WM_REQ;
    /*Include the lc_ids for signalling RBs with RLC AM mode. Eventhough RRC can monitor
    the UL data in the uplink on signalling RBs this is required to suspend the periodic status
    timer at RLC */
    if (purge_rb0)
    {
      llc_cmd_l2_ptr->ul_purge_wm_ind.lc_id[count] =
        rrclcm_get_ul_rlc_lc_id(CCCH_RADIO_BEARER_ID);
      llc_cmd_l2_ptr->ul_purge_wm_ind.num_sdus[count++] = MAX_RB0_SDUS_TOBE_PURGED;
    }
    if (purge_srb1_2)
    {
      llc_cmd_l2_ptr->ul_purge_wm_ind.lc_id[count] =
        rrclcm_get_ul_rlc_lc_id(DCCH_UM_RADIO_BEARER_ID);
      llc_cmd_l2_ptr->ul_purge_wm_ind.num_sdus[count++] = MAX_SRB1_SDUS_TOBE_PURGED;
      llc_cmd_l2_ptr->ul_purge_wm_ind.lc_id[count] =
        rrclcm_get_ul_rlc_lc_id(DCCH_AM_RADIO_BEARER_ID);
      llc_cmd_l2_ptr->ul_purge_wm_ind.num_sdus[count++] = MAX_SRB2_SDUS_TOBE_PURGED;
    }
    llc_cmd_l2_ptr->ul_purge_wm_ind.num_lc_id= (uint8)count;
    WRRC_MSG2_HIGH("purging RLC RB0:%d, SRB:%d", purge_rb0,purge_srb1_2);
    rrc_put_int_cmd(llc_cmd_ptr); 
} /* rrccu_purge_rlc_wm */


/*===========================================================================

FUNCTION RRCCU_PURGE_RLC_WM_RB3_RB4

DESCRIPTION

  This function requests RLC to purge RLC UL  watermark for RB3 and RB4
  
DEPENDENCIES


RETURN VALUE

  None

SIDE EFFECTS

  None

===========================================================================*/
static void rrccu_purge_rlc_wm_rb3_rb4
(    
   boolean purge_srb3, boolean purge_srb4  
)
{
   uint32 count=0;
  
   rrc_cmd_type *llc_cmd_ptr;  /* Pointer to the RRC Command */

   l2_ul_req_cmd * llc_cmd_l2_ptr = NULL;
   if (rrcdt_is_idt_waitingfor_l2ack() != TRUE)
   {
      return;
   }
   /*send CRLC DATA IND REQ to RLC via rrcllc */
      llc_cmd_ptr = rrc_get_int_cmd_buf();
      RRC_GET_POINTER_L2_REQ_VALUE(llc_cmd_ptr->cmd.rrc_llc_req.l2_ul_req,llc_cmd_l2_ptr);

      /* Initialize the LLC command header first */
      llc_cmd_ptr->cmd_hdr.cmd_id= RRC_LLC_CMD_REQ;
      llc_cmd_ptr->cmd.rrc_llc_req.procedure = RRC_PROCEDURE_CU;
      llc_cmd_ptr->cmd.rrc_llc_req.cmd_dest = LAYER2_RLC_UL;

      /* Now fill the L2 cmd header */
      llc_cmd_ptr->cmd.rrc_llc_req.l2_ul_cmd.cmd_id = RLC_UL_PURGE_WM_REQ;

      /*Include the lc_ids for signalling RBs with RLC AM mode. */
      /* Eventhough RRC can monitor the UL data in the uplink on */
      /* signalling RBs this is required to suspend the periodic status
      timer at RLC */
      if (purge_srb3)
      {
        
         llc_cmd_l2_ptr->ul_purge_wm_ind.lc_id[count] =
             rrclcm_get_ul_rlc_lc_id(DCCH_DT_HIGH_PRI_RADIO_BEARER_ID);
         llc_cmd_l2_ptr->
              ul_purge_wm_ind.num_sdus[count++] = MAX_SRB2_SDUS_TOBE_PURGED;
        
      }
      if (purge_srb4)
      {
       
          llc_cmd_l2_ptr->ul_purge_wm_ind.lc_id[count] =
            rrclcm_get_ul_rlc_lc_id(DCCH_DT_LOW_PRI_RADIO_BEARER_ID);
          llc_cmd_l2_ptr->
            ul_purge_wm_ind.num_sdus[count++] = MAX_SRB2_SDUS_TOBE_PURGED;
        
      }
      
      llc_cmd_l2_ptr->ul_purge_wm_ind.num_lc_id= (uint8)count;
      WRRC_MSG2_HIGH("purging RLC SRB3:%d, SRB4:%d", purge_srb3,purge_srb4);
      rrc_put_int_cmd(llc_cmd_ptr); 
} /* rrccu_purge_rlc_wm_rb3_rb4 */




/*===========================================================================

FUNCTION RRCCU_INFORM_URA_UPDATE_COMPLETED

DESCRIPTION

  This function checks the database and sends RRC_URA_UPDATE_COMPLETE_CNF
  command to all RRC procedures that waiting for Cell Update completetion.
  
DEPENDENCIES


RETURN VALUE

  None

SIDE EFFECTS

  None

===========================================================================*/
static void rrccu_inform_ura_update_completed
(    
  void
)
{
  rrccu_inform_cell_update_completed();
}


/*===========================================================================

FUNCTION RRCCU_REGISTER_WITH_RLC_FOR_UL_DATA_INDICATION

DESCRIPTION

  This function sends the registration request to rlc for UL data indication
  
DEPENDENCIES


RETURN VALUE

  None

SIDE EFFECTS

  None

===========================================================================*/
static void rrccu_register_with_rlc_for_ul_data_indication
(    
void  
)
{
   uint32 count=0;
   uint32 rab_count;
   uint32 rb_count;

   l2_ul_req_cmd *llc_cmd_l2_ptr = NULL;
   rlc_lc_id_type ul_rlc_lc_id = RRCLCM_RLC_LC_ID_NOT_FOUND;
  
   rrc_cmd_type *llc_cmd_ptr;                     /* Pointer to the RRC Command */

    /*send CRLC DATA IND REQ to RLC via rrcllc */
      llc_cmd_ptr = rrc_get_int_cmd_buf();
      RRC_GET_POINTER_L2_REQ_VALUE(llc_cmd_ptr->cmd.rrc_llc_req.l2_ul_req,llc_cmd_l2_ptr);

      /* Initialize the LLC command header first */
      llc_cmd_ptr->cmd_hdr.cmd_id= RRC_LLC_CMD_REQ;
      llc_cmd_ptr->cmd.rrc_llc_req.procedure = RRC_PROCEDURE_CU;
      llc_cmd_ptr->cmd.rrc_llc_req.cmd_dest = LAYER2_RLC_UL;

      /* Now fill the L2 cmd header */
      llc_cmd_ptr->cmd.rrc_llc_req.l2_ul_cmd.cmd_id = CRLC_UL_REG_FOR_DATA_IND_REQ;
      llc_cmd_l2_ptr->ul_reg_data_ind.block_status_timer=TRUE;

      /*Include the lc_ids for signalling RBs with RLC AM mode. Eventhough RRC can monitor
      the UL data in the uplink on signalling RBs this is required to suspend the periodic status
      timer at RLC */
      llc_cmd_l2_ptr->ul_reg_data_ind.lc_id[count++] =
        rrclcm_get_ul_rlc_lc_id(DCCH_AM_RADIO_BEARER_ID);
      llc_cmd_l2_ptr->ul_reg_data_ind.lc_id[count++] =
         rrclcm_get_ul_rlc_lc_id(DCCH_DT_HIGH_PRI_RADIO_BEARER_ID);
      ul_rlc_lc_id = rrclcm_check_ul_rlc_lc_id(UE_LOGCHAN_DCCH, 
                                               DCCH_DT_LOW_PRI_RADIO_BEARER_ID,
                                               UE_MODE_ACKNOWLEDGED_DATA);
      
      if(ul_rlc_lc_id != RRCLCM_RLC_LC_ID_NOT_FOUND)
      {
        llc_cmd_l2_ptr->ul_reg_data_ind.lc_id[count++] =
          rrclcm_get_ul_rlc_lc_id(DCCH_DT_LOW_PRI_RADIO_BEARER_ID);
      }
     
      /* get the lc_ids for user plane RBs */
      for (rab_count=0; rab_count<MAX_RAB_TO_SETUP; rab_count++)
      {
        if ((rrc_est_rabs.rabs[rab_count].cn_domain == RRC_CS_DOMAIN_CN_ID) 
            &&
            (rrc_est_rabs.rabs[rab_count].num_rbs_for_rab > 0)
           )
        {
          WRRC_MSG2_ERROR("No reg for CS domain,rabid:%d,rbs:%d",
               rrc_est_rabs.rabs[rab_count].rab_id,
               rrc_est_rabs.rabs[rab_count].num_rbs_for_rab
              );

        }
        else if ((rrc_est_rabs.rabs[rab_count].cn_domain == RRC_PS_DOMAIN_CN_ID)
                &&
                (rrc_est_rabs.rabs[rab_count].num_rbs_for_rab > 0)
                )
        {
          /*it is a valid established rab, now compare each rb-id in this established rab with 
          the rb-id received in the message */
          for (rb_count=0; rb_count<rrc_est_rabs.rabs[rab_count].num_rbs_for_rab; rb_count++)
          {
            llc_cmd_l2_ptr->ul_reg_data_ind.lc_id[count++] =
               rrclcm_get_ul_rlc_lc_id(rrc_est_rabs.rabs[rab_count].rb_for_rab[rb_count].rb_id);
          }
        } /*end of if*/
      }/* rab_count loop */
      llc_cmd_l2_ptr->ul_reg_data_ind.num_lc= (uint16)count;
      WRRC_MSG1_HIGH("registering with RLC for %d RBs", count);
      rrc_put_int_cmd(llc_cmd_ptr); 
} /* rrccu_register_with_rlc_for_ul_data_indication */
/*===========================================================================

FUNCTION RRCCU_UNREGISTER_WITH_RLC_FOR_UL_DATA_INDICATION

DESCRIPTION

  This function sends the unregistration request to rlc for UL data indication
  
DEPENDENCIES


RETURN VALUE

  None

SIDE EFFECTS

  None

===========================================================================*/
static void rrccu_unregister_with_rlc_for_ul_data_indication
(    
void  
)
{
   uint32 count=0;
   uint32 rab_count;
   uint32 rb_count;
   l2_ul_req_cmd * llc_cmd_l2_ptr = NULL;
   rlc_lc_id_type ul_rlc_lc_id = RRCLCM_RLC_LC_ID_NOT_FOUND; 
   rrc_cmd_type *llc_cmd_ptr;                     /* Pointer to the RRC Command */

    /*send CRLC DATA IND REQ to RLC via rrcllc */
    llc_cmd_ptr = rrc_get_int_cmd_buf();
      RRC_GET_POINTER_L2_REQ_VALUE(llc_cmd_ptr->cmd.rrc_llc_req.l2_ul_req,llc_cmd_l2_ptr);

      /* Initialize the LLC command header first */
      llc_cmd_ptr->cmd_hdr.cmd_id= RRC_LLC_CMD_REQ;
      llc_cmd_ptr->cmd.rrc_llc_req.procedure = RRC_PROCEDURE_CU;
      llc_cmd_ptr->cmd.rrc_llc_req.cmd_dest = LAYER2_RLC_UL;

      /* Now fill the L2 cmd header */
      llc_cmd_ptr->cmd.rrc_llc_req.l2_ul_cmd.cmd_id = CRLC_UL_UNREG_FOR_DATA_IND_REQ;
      llc_cmd_l2_ptr->ul_unreg_data_ind.resume_status_timer=TRUE;

      /*Include the lc_ids for signalling RBs with RLC AM mode. Eventhough RRC can monitor
      the UL data in the uplink on signalling RBs this is required to suspend the periodic status
      timer at RLC */
      llc_cmd_l2_ptr->ul_unreg_data_ind.lc_id[count++] =
        rrclcm_get_ul_rlc_lc_id(DCCH_AM_RADIO_BEARER_ID);
      llc_cmd_l2_ptr->ul_unreg_data_ind.lc_id[count++] =
        rrclcm_get_ul_rlc_lc_id(DCCH_DT_HIGH_PRI_RADIO_BEARER_ID);
      ul_rlc_lc_id = rrclcm_check_ul_rlc_lc_id(UE_LOGCHAN_DCCH, 
                                               DCCH_DT_LOW_PRI_RADIO_BEARER_ID,
                                               UE_MODE_ACKNOWLEDGED_DATA);
     
      if(ul_rlc_lc_id != RRCLCM_RLC_LC_ID_NOT_FOUND)
      {
        llc_cmd_l2_ptr->ul_reg_data_ind.lc_id[count++] =
          rrclcm_get_ul_rlc_lc_id(DCCH_DT_LOW_PRI_RADIO_BEARER_ID);
      }
      
      /* get the lc_ids for user plane RBs */
      for (rab_count=0; rab_count<MAX_RAB_TO_SETUP; rab_count++)
      {
        if ((rrc_est_rabs.rabs[rab_count].cn_domain == RRC_PS_DOMAIN_CN_ID)
            &&
            (rrc_est_rabs.rabs[rab_count].num_rbs_for_rab > 0)
           )
        {
          /*it is a valid established rab, now compare each rb-id in this established rab with 
          the rb-id received in the message */
          for (rb_count=0; rb_count<rrc_est_rabs.rabs[rab_count].num_rbs_for_rab; rb_count++)
          {
            llc_cmd_l2_ptr->ul_unreg_data_ind.lc_id[count++] =
               rrclcm_get_ul_rlc_lc_id(rrc_est_rabs.rabs[rab_count].rb_for_rab[rb_count].rb_id);
          }
        } /*end of if*/
      }/* rab_count loop */
      llc_cmd_l2_ptr->ul_unreg_data_ind.num_lc= (uint16)count;
      WRRC_MSG1_HIGH("unregistering with RLC for %d RBs", count);
      rrc_put_int_cmd(llc_cmd_ptr); 
} /* rrccu_unregister_with_rlc_for_ul_data_indication */

/*===========================================================================

FUNCTION          RRCCU_SEND_L1_DRX_REQ

DESCRIPTION       This function is responsible for sending CPHY_DRX_REQ
                  to L1.

DEPENDENCIES
                  

RETURN VALUE
                  Void
SIDE EFFECTS      None.
===========================================================================*/
static void rrccu_send_l1_drx_req(void)
{

  rrc_cmd_type *cmd_ptr;
  uint32 drx_len;

  l1_req_cmd * llc_cmd_l1_req = NULL;

  /* Send DRX command to L1, no confirm to wait for */

  cmd_ptr = rrc_get_int_cmd_buf();

    RRC_GET_POINTER_L1_REQ_VALUE(cmd_ptr->cmd.rrc_llc_req.l1_req,llc_cmd_l1_req);
    
    /* Initialize the LLC command header first */
    cmd_ptr->cmd_hdr.cmd_id = RRC_LLC_CMD_REQ;
    cmd_ptr->cmd.rrc_llc_req.procedure = RRC_PROCEDURE_CU;
    cmd_ptr->cmd.rrc_llc_req.cmd_dest = LAYER1_PHY;
  
    /* Now fill the L1 cmd header */
    cmd_ptr->cmd.rrc_llc_req.l1_cmd.cmd_id = CPHY_DRX_REQ;
    cmd_ptr->cmd.rrc_llc_req.l1_cmd.act_time_type = L1_ACTIVATION_TIME_NONE;

    /* Populate the cmd data */
    drx_len = rrcllc_get_drx_info();

    llc_cmd_l1_req->drx.drx_cycle_len =  rrc_csp_set_drx_length(drx_len);
    
    /* Send the Internal RRC command - LLC should directly handle it */
    rrc_put_int_cmd(cmd_ptr);
    WRRC_MSG1_HIGH("Sending DRX_REQ to L1 cycle:%d",
             llc_cmd_l1_req->drx.drx_cycle_len);
} /*rrcu_send_l1_drx_req */

/*===========================================================================

FUNCTION RRCCU_ESTABLISH_PCCH_RB

DESCRIPTION

  This function checks the database and sends RRC_CELL_UPDATE_COMPLETE_CNF
  command to all RRC procedures that waiting for Cell Update completetion.
  
DEPENDENCIES


RETURN VALUE

  None

SIDE EFFECTS

  None

===========================================================================*/
static void rrccu_establish_pcch_rb
(    
 rrc_state_e_type dest_state  
)
{
  
   rrc_cmd_type *cmd_ptr;                     /* Pointer to the RRC Command */
   uint32 rb_count;
   uint32 rb_index = 0;

  /* Allocates the buffer to RRC Internal command */
  cmd_ptr =  rrc_get_int_cmd_buf();
    /* Fill in the command parameters for RRC_CHANNEL_CONFIG_REQ */
    cmd_ptr->cmd_hdr.cmd_id = RRC_CHANNEL_CONFIG_REQ;
    cmd_ptr->cmd.chan_config_req.procedure = RRC_PROCEDURE_CU;

    /* Fill in parameters for RRC_CHANNEL_CONFIG_REQ command */
    cmd_ptr->cmd.chan_config_req.rrc_state_change_required = TRUE;
    cmd_ptr->cmd.chan_config_req.next_state = dest_state;
    cmd_ptr->cmd.chan_config_req.rb[rb_index].rb_id = CCCH_RADIO_BEARER_ID;
    cmd_ptr->cmd.chan_config_req.rb[rb_index++].rb_config = RELEASE_RB;
    cmd_ptr->cmd.chan_config_req.rb[rb_index].rb_id = PCCH_RADIO_BEARER_ID;
    cmd_ptr->cmd.chan_config_req.rb[rb_index++].rb_config = ESTABLISH_RB;
    cmd_ptr->cmd.chan_config_req.rrc_channel_config_cnf_required = 
      TRUE;
    cmd_ptr->cmd.chan_config_req.chan_config_reason = RRCLLC_CHAN_CFG_REASON_NONE;
    /*check whether any chan config is pending due to rb/tc info from cucnf message */
    if (rrccu_chan_config_reqd)
    {
      for (rb_count=0; rb_count<rrccu_chan_config_info.num_rbs; rb_count++)
      {
        cmd_ptr->cmd.chan_config_req.rb[rb_index].rb_id = 
            rrccu_chan_config_info.rb_info[rb_count].rb_id;

        cmd_ptr->cmd.chan_config_req.rb[rb_index++].rb_config = 
          rrccu_chan_config_info.rb_info[rb_count].rb_config;
      }
    }
    cmd_ptr->cmd.chan_config_req.num_rb_to_config = (int)rb_index;
  
    WRRC_MSG1_HIGH("RRC_CHANNEL_CONFIG_REQ is sent to establish PCCH RBs:%d",
            rb_index);
    rrc_put_int_cmd(cmd_ptr);                 /* sends the command to RRC
                                                 LLC. */
} /* rrccu_inform_cell_update_completed */

/*===========================================================================

FUNCTION rrccu_validate_rrc_status_for_failure_handling

DESCRIPTION

  This function validates RRC_CELL_UPDATE_INITIATE_REQ command and stores
  initiates procedure if it needs confirmation after Cell Update procedure
  successfully completed.
  
DEPENDENCIES


RETURN VALUE

  rrccu_status_e_type: returns RRCCU_SUCCESS if it successfully validates
  RRC_CELL_UPDATE_INITIATE_REQ. Otherwise it returns
  RRCCU_FAILURE_MINOR.

SIDE EFFECTS

  None

===========================================================================*/
static rrccu_status_e_type rrccu_validate_rrc_status_for_failure_handling
(    
  rrc_cmd_type *cmd_ptr,
  rrc_CellUpdateCause cu_cause
)
{
  rrccu_status_e_type status = RRCCU_FAILURE_MAJOR;

  /*chech the security reconfiguration status. If IP reconfig
  or ciphering reconfig is active then return failure */
  if (!rrcsmc_is_security_reconfig_active())
  {
    /* check rrcrcr status */
    if (!rrcrcr_is_proc_active())
    {                           
      /* check oc status */
      status = rrccu_check_and_clear_oc_restrictions(cmd_ptr, cu_cause);
    }
  }
  else
  {
    WRRC_MSG0_HIGH("Security is active");
  }
  return status;
} /*  rrccu_validate_rrc_status_for_failure_handling */



/*===========================================================================

FUNCTION rrccu_validate_rrc_status_for_oos_handling

DESCRIPTION

  This function validates CPHY_OUT_OF_SERVICE_AREA_IND command and stores
  initiates procedure if it needs confirmation after Cell Update procedure
  successfully compelted.
  
DEPENDENCIES


RETURN VALUE

  rrccu_status_e_type: returns RRCCU_SUCCESS if it successfully validates
  CPHY_OUT_OF_SERVICE_AREA_IND. Otherwise it returns
  RRCCU_FAILURE_MINOR.

SIDE EFFECTS

  None

===========================================================================*/
static rrccu_status_e_type rrccu_validate_rrc_status_for_oos_handling
(    
  void
)
{
  rrccu_status_e_type status = RRCCU_FAILURE_MAJOR;
  
  rrc_proc_e_type                 proc_id;
  rrcllc_oc_process_state_e_type  process_state;  
  rrcllc_oc_set_status_e_type     oc_status;

  /*chech the security reconfiguration status. If IP reconfig
  or ciphering reconfig is active then return failure */
  if (!rrcsmc_is_security_reconfig_active())
  {
    /*Make sure that if both re-establishment timers have expired and cu_substate is
      RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM, then take UE to idle */
    if (!((rrccu_substate == RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM) && 
           ( ((rrccu_rl_failure_info.t314_info.timer_status == RE_EST_TIMER_EXPIRED) &&
              (rrccu_rl_failure_info.t315_info.timer_status == RE_EST_TIMER_EXPIRED)) ||
             ((rrccu_rl_failure_info.t314_info.timer_status == RE_EST_TIMER_EXPIRED) &&
              (rrccu_rl_failure_info.t315_info.timer_status == RE_EST_TIMER_NOT_STARTED)) ||
             ((rrccu_rl_failure_info.t314_info.timer_status == RE_EST_TIMER_NOT_STARTED) &&
              (rrccu_rl_failure_info.t315_info.timer_status == RE_EST_TIMER_EXPIRED)) )
           ))
    {
      /* check rrcrcr status */
      if (!(rrcrcr_is_proc_active()))
      {                           
        oc_status = rrcllc_get_ordered_config_state_and_proc(&proc_id, &process_state);
	MSG_HIGH ("OOS in OC status: %d, procedure_substate: %d, cu_substate: %d", oc_status, rrcrb_get_proc_sub_state(proc_id), rrccu_substate);
        /* check oc status.  Return a failure if oc is set by another proc */
        if (oc_status == OC_NOT_SET)
        {
          status = RRCCU_SUCCESS;
        }
        else if (oc_status != OC_NOT_SET && proc_id == RRC_PROCEDURE_CU)
        {
          if ((rrccu_substate == RRCCU_WAIT_FOR_L2_ACK) ||
              (rrccu_substate == RRCCU_WAIT_FOR_RNTI_UPDATE_CNF))
          {
            if ((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH) ||
                (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH))
            {
              
              oc_status = rrcllc_reset_ordered_config(RRC_PROCEDURE_CU
                                                      ,TRUE
                                                      );
              if (oc_status ==  OC_NOT_SET)
              {
                status = RRCCU_SUCCESS;
              }
            }
          }
          else if(rrccu_substate == RRCCU_WAIT_FOR_RB1_RB4_EST_CNF)
          {
            /* When RL failure happens, OC is set by CU. At this point,
             If CU is initiated due to DL_WEAK_IND, OC should be reset. 
             Else we will transition to idle which is wrong */
            /* rrccu_oc_set_by_cu flag is set to FALSE to prevent the
             extra swap of CC to OC */
            rrccu_oc_set_by_cu = FALSE;
            oc_status = rrcllc_reset_ordered_config(RRC_PROCEDURE_CU
                                                    ,TRUE
                                                    );
            if (oc_status ==  OC_NOT_SET)
            {
              status = RRCCU_SUCCESS;
            }
          }
        }
        else 
        {
          
          if ((proc_id == RRC_PROCEDURE_RBE || proc_id == RRC_PROCEDURE_RBRC || 
               proc_id == RRC_PROCEDURE_TCR || proc_id == RRC_PROCEDURE_PCR ||
               proc_id == RRC_PROCEDURE_RBR) &&
              rrcrb_get_proc_sub_state(proc_id) == RRCRB_WAIT_FOR_L2_ACK )
          {
            if (SUCCESS == rrccu_register_for_cell_update_to_complete(proc_id))
            {
              WRRC_MSG0_HIGH("OOS while RB proc waiting for L2 ack");
              oc_status = rrcllc_reset_ordered_config(RRC_PROCEDURE_CU
                                                      ,TRUE
                                                      );
              if (oc_status ==  OC_NOT_SET)
              {
                /*Update reconfig procedure failure status to  RRCRB_CELL_UPDATE_OCCURED*/
                rrccu_update_reconfig_proc_failure_status(proc_id);
                status = RRCCU_SUCCESS;
              }
            }
          }
          /* Reset the OC and set TOC for FACH->FACh and FACH->PCH OOS case*/
          else if ((proc_id == RRC_PROCEDURE_RBE || proc_id == RRC_PROCEDURE_RBRC || 
                      proc_id == RRC_PROCEDURE_TCR || proc_id == RRC_PROCEDURE_PCR ||
                     proc_id == RRC_PROCEDURE_RBR) &&
                      ( rrcrb_get_proc_sub_state(proc_id) == RRCRB_WAIT_FOR_CELL_SELECTION_CNF )
                 &&
                 ((oc_status ==   OC_SET_FOR_CELL_FACH) ||
                   (oc_status ==   OC_SET_FOR_FACH_CELL_PCH_TRANS) ||
                   (oc_status ==   OC_SET_FOR_FACH_URA_PCH_TRANS)
                    ))
          {
            if (SUCCESS == rrccu_register_for_cell_update_to_complete(proc_id))
            {
              WRRC_MSG0_HIGH("OOS while RB proc performing cell selection as directed by N/W");
              oc_status = rrcllc_reset_ordered_config(RRC_PROCEDURE_CU
                                                      ,FALSE
                                                      );
              if (oc_status ==  OC_NOT_SET)
              {
                status = RRCCU_SUCCESS;
              }
            }
          }

        }
      }
    }
    else
    {
      WRRC_MSG0_HIGH("re-establish timers have expired.");
    }
  }
  else
  {
    WRRC_MSG0_HIGH("Security reconfiguration is active");
  }
  return status;
} /*  rrccu_validate_rrc_status_for_failure_handling */




/*===========================================================================
FUNCTION RRCCU_VALIDATE_CELL_UPDATE_INITIATE_REQ

DESCRIPTION
  This function validates RRC_CELL_UPDATE_INITIATE_REQ command and stores
  initiates procedure if it needs confirmation after Cell Update procedure
  successfully completed.
  
DEPENDENCIES


RETURN VALUE
  rrccu_status_e_type: returns RRCCU_SUCCESS if it successfully validates
  RRC_CELL_UPDATE_INITIATE_REQ. Otherwise it returns
  RRCCU_FAILURE_MINOR.

SIDE EFFECTS
  None
===========================================================================*/
rrccu_status_e_type rrccu_validate_cell_update_initiate_req
(    
  rrc_cmd_type *cmd_ptr
)
{
  rrccu_status_e_type status = RRCCU_FAILURE_MINOR;
  
  rrc_state_e_type curr_state = RRC_STATE_WILDCARD; /* Local variable to store
                                                       current RRC state */
  curr_state = rrc_get_state();
  MSG_HIGH("RRC_CELL_UPDATE_INITIATE_REQ with cause:%d rrc state:rrc_state_e_type_value %d, proc:rrc_proc_e_type_value %d",
  cmd_ptr->cmd.initiate_cell_update.cause,
  curr_state,
  cmd_ptr->cmd.initiate_cell_update.procedure
  );

  if (cmd_ptr->cmd_hdr.cmd_id == RRC_CELL_UPDATE_INITIATE_REQ)
  {
    /* Check for Cell Update cause */
    switch(cmd_ptr->cmd.initiate_cell_update.cause)
    {
      
      case RRC_PHY_CHAN_FAILURE:
        if (curr_state == RRC_STATE_CELL_FACH)
        {
          status = RRCCU_SUCCESS;
        }
        break;

      case RRC_RADIO_LINK_FAILURE:
       /* The procedure Id needs to be stored if Cell Update
          completion needs to be informed */ 
        if(curr_state == RRC_STATE_CELL_DCH)
        {
          status = RRCCU_SUCCESS;
        }
        if(curr_state == RRC_STATE_CELL_FACH)
        {
          /*smc and ueci procedures can initiate cell update with cause
          RL failure in CELL_FACH state also */
          if (cmd_ptr->cmd.initiate_cell_update.procedure == RRC_PROCEDURE_SMC ||
              cmd_ptr->cmd.initiate_cell_update.procedure == RRC_PROCEDURE_UECI)
          {
            status = RRCCU_SUCCESS;
          }
        }
        break;

      case RRC_PERIODIC_CELL_UPDATE:
      case RRC_UL_DATA_TRANSMISSION:
      case RRC_PAGING_RESPONSE:
        if( (curr_state == RRC_STATE_CELL_FACH) ||
            (curr_state == RRC_STATE_CELL_PCH) ||
            (curr_state == RRC_STATE_URA_PCH ) )
        {
          status = RRCCU_SUCCESS;
        }
        (void)rrcdormancy_check_n_reset_v316(cmd_ptr->cmd.initiate_cell_update.procedure);
        break;

      case RRC_REENTERED_SERVICE_AREA:
        if( (curr_state != RRC_STATE_DISCONNECTED) &&
            (curr_state != RRC_STATE_CONNECTING))
        {
          status = RRCCU_SUCCESS;
        }
        break;
      case RRC_CELL_RESELECTION:
        if( (curr_state == RRC_STATE_CELL_FACH) ||
            (curr_state == RRC_STATE_CELL_PCH ) )
        {
          status = RRCCU_SUCCESS;
        }
        break;
      case RRC_UNRECOVERABLE_ERROR:
        if(( curr_state == RRC_STATE_CELL_DCH) ||
          (curr_state == RRC_STATE_CELL_FACH ))
        {
          status = RRCCU_SUCCESS;
        }
        break;

#ifdef FEATURE_BPLMN_SEARCH_320MS
      case RRC_LOSSY_PAGE_RECEPTION:
        if((rrccu_substate == RRCCU_INITIAL) && ((curr_state == RRC_STATE_CELL_PCH)||
            (curr_state == RRC_STATE_URA_PCH)))
        {
          status = RRCCU_SUCCESS;
        }
        break;
#endif /*FEATURE_BPLMN_SEARCH_320MS*/

#ifdef FEATURE_WCDMA_HS_RACH
        case RRC_PCH_TO_FACH_TRANSITION_REQ:
         status = RRCCU_SUCCESS;
         WRRC_MSG1_HIGH("EPCH:CU int for epCH->eFACH<%d>",cmd_ptr->cmd_hdr.cmd_id);
        break;
#endif

      default:
        WRRC_MSG1_ERROR("Unknown CU cause: %d",
             cmd_ptr->cmd.initiate_cell_update.cause);
        break;
    }
    /* Update the registration if RRC proc needs confirmation of Cell Update
       completion */
    if( (status == RRCCU_SUCCESS) && 
        (cmd_ptr->cmd.initiate_cell_update.cu_complete_cnf_required == TRUE) ) 
    {
      (void)rrccu_register_for_cell_update_to_complete(cmd_ptr->cmd.initiate_cell_update.procedure);
    }
  }
  if(status != RRCCU_SUCCESS)
  {
    WRRC_MSG2_HIGH("RRC_CELL_UPDATE_INITIATE_REQ Cmd Invalid cause: %d ",
    cmd_ptr->cmd.initiate_cell_update.cause, rrc_get_state());
  }     
  return( status );
} /* rrccu_validate_cell_update_initiate_req */

/*===========================================================================
FUNCTION RRCCU_MAP_CU_CAUSE_BASED_ON_PRIORITY

DESCRIPTION
  This function determines the new cell upddate cause based upon
  the priority of the new cause and old cause.
  
DEPENDENCIES
         rrc_CellUpdateCause new cause;
RETURN VALUE

SIDE EFFECTS
  None
===========================================================================*/
static rrc_CellUpdateCause rrccu_map_cu_cause_based_on_priority
(    
  rrc_cell_update_cause_e_type cause
)
{    
  rrc_CellUpdateCause old_cu_cause;
  rrc_CellUpdateCause new_cu_cause;

  old_cu_cause = rrccu_cell_update_cause;
  new_cu_cause = rrccu_cell_update_cause;

  /* Check for Cell Update cause */
  switch (cause)
  {
    case RRC_UL_DATA_TRANSMISSION:
      /* UL DATA TRANSMISSION is the highest priority as per 8.3.1.2 */
      new_cu_cause = rrccu_map_cu_initiation_cause(RRC_UL_DATA_TRANSMISSION);
      break;

    case RRC_PAGING_RESPONSE:
      /* Paging response has the second highest priority as per 8.3.1.2*/
      switch (rrccu_cell_update_cause)
      {
        case  rrc_CellUpdateCause_uplinkDataTransmission:
        case  rrc_CellUpdateCause_utran_pagingResponse:
          /* retain the previous cell update cause */
          new_cu_cause = rrccu_cell_update_cause;
          break;
        default:
          /* since the new cause has higher priority
          overwrite the old cause with the new one */
          new_cu_cause =  rrccu_map_cu_initiation_cause(RRC_PAGING_RESPONSE);
          break;
       }
       break;

    case RRC_RADIO_LINK_FAILURE:
    /* Paging response has the third highest priority as per 8.3.1.2*/
      switch (rrccu_cell_update_cause)
      {
        case  rrc_CellUpdateCause_uplinkDataTransmission:
        case  rrc_CellUpdateCause_utran_pagingResponse:
        case  rrc_CellUpdateCause_radiolinkFailure:
          /* retain the previous cell update cause */
          new_cu_cause = rrccu_cell_update_cause;
          break;

        default:
          /* since the new cause has higher priority
          overwrite the old cause with the new one */
          new_cu_cause =  rrccu_map_cu_initiation_cause(RRC_RADIO_LINK_FAILURE);
          break;
      }
      break;

    case RRC_REENTERED_SERVICE_AREA:
      switch (rrccu_cell_update_cause)
      {
        case  rrc_CellUpdateCause_uplinkDataTransmission:
        case  rrc_CellUpdateCause_utran_pagingResponse:
        case  rrc_CellUpdateCause_radiolinkFailure:
        case  rrc_CellUpdateCause_re_enteredServiceArea:
          /* retain the previous cell update cause */
          new_cu_cause = rrccu_cell_update_cause;
          break;
        default:
          /* since the new cause has higher priority
          overwrite the old cause with the new one */
          new_cu_cause =  rrccu_map_cu_initiation_cause(RRC_REENTERED_SERVICE_AREA);
          break;
      }
      break;
      
      case RRC_UNRECOVERABLE_ERROR:
        switch (rrccu_cell_update_cause)
        {
          case  rrc_CellUpdateCause_uplinkDataTransmission:
          case  rrc_CellUpdateCause_utran_pagingResponse:
          case  rrc_CellUpdateCause_radiolinkFailure:
          case  rrc_CellUpdateCause_re_enteredServiceArea:
          case  rrc_CellUpdateCause_rlc_unrecoverableError:
            /* retain the previous cell update cause */
            new_cu_cause = rrccu_cell_update_cause;
            break;
          default:
            /* since the new cause has higher priority
            overwrite the old cause with the new one */
            new_cu_cause =  rrccu_map_cu_initiation_cause(RRC_UNRECOVERABLE_ERROR);
            break;

         }
         break;


    case RRC_CELL_RESELECTION:
      switch (rrccu_cell_update_cause)
      {
        case  rrc_CellUpdateCause_uplinkDataTransmission:
        case  rrc_CellUpdateCause_utran_pagingResponse:
        case  rrc_CellUpdateCause_radiolinkFailure:
        case  rrc_CellUpdateCause_re_enteredServiceArea:
        case  rrc_CellUpdateCause_rlc_unrecoverableError:
        case  rrc_CellUpdateCause_cellReselection:
          /* retain the previous cell update cause */
          new_cu_cause = rrccu_cell_update_cause;
          break;

        default:
          /* since the new cause has higher priority
          overwrite the old cause with the new one */
          new_cu_cause =  rrccu_map_cu_initiation_cause(RRC_CELL_RESELECTION);
          break;
      }
      break;



    case RRC_PERIODIC_CELL_UPDATE:
      switch (rrccu_cell_update_cause)
      {
        case  rrc_CellUpdateCause_uplinkDataTransmission:
        case  rrc_CellUpdateCause_utran_pagingResponse:
        case  rrc_CellUpdateCause_radiolinkFailure:
        case  rrc_CellUpdateCause_re_enteredServiceArea:
        case  rrc_CellUpdateCause_rlc_unrecoverableError:
        case  rrc_CellUpdateCause_cellReselection:
        case rrc_CellUpdateCause_periodicalCellUpdate:
          /* retain the previous cell update cause */
          new_cu_cause = rrccu_cell_update_cause;
          break;
        default:
          /* since the new cause has higher priority
          overwrite the old cause with the new one */
          new_cu_cause =  rrccu_map_cu_initiation_cause(RRC_PERIODIC_CELL_UPDATE);
          break;
      }
      break;
    default:
      WRRC_MSG1_ERROR("unknown CU cause:%d", cause);
      break;
  }

  
  MSG_HIGH("curr_cause:%d new_cause:%d,result_cause:%d",
           old_cu_cause, 
           cause, 
           new_cu_cause
           );
  return(new_cu_cause);
} /* rrccu_map_cu_cause_based_on_priority */
/*===========================================================================

FUNCTION rrccu_is_change_of_cu_cause_reqd

DESCRIPTION

  This function determines the new cell upddate cause based upon
  the priority of the new cause and old cause.
  
DEPENDENCIES

         rrc_CellUpdateCause new cause;
RETURN VALUE


SIDE EFFECTS

  None

===========================================================================*/
static boolean rrccu_is_change_of_cu_cause_reqd
(    
  rrc_cell_update_cause_e_type cause
)
{    
  boolean change_reqd = FALSE;

  if (!rrccu_cell_update_started) 
  {
    change_reqd = TRUE;
  } 
  else
  {

    /* Check for Cell Update cause */
    switch (cause)
    {
      case RRC_UL_DATA_TRANSMISSION:
        switch (rrccu_cell_update_cause)
        {
          case  rrc_CellUpdateCause_uplinkDataTransmission:
            /* retain the previous cell update cause */
            change_reqd = FALSE;
            break;
          case  rrc_CellUpdateCause_utran_pagingResponse:
          case  rrc_CellUpdateCause_radiolinkFailure:
          case  rrc_CellUpdateCause_re_enteredServiceArea:
          case  rrc_CellUpdateCause_rlc_unrecoverableError:
          case  rrc_CellUpdateCause_cellReselection:
          case  rrc_CellUpdateCause_periodicalCellUpdate:
            /* since the new cause has higher priority
            overwrite the old cause with the new one */
            change_reqd = TRUE;
            break;
          default:
            WRRC_MSG1_ERROR("unknown CU cause:%d", rrccu_cell_update_cause);
            break;
         }
         break;

      case RRC_PAGING_RESPONSE:
        switch (rrccu_cell_update_cause)
        {
          case  rrc_CellUpdateCause_uplinkDataTransmission:
          case  rrc_CellUpdateCause_utran_pagingResponse:
            /* retain the previous cell update cause */
            change_reqd = FALSE;
            break;

          case  rrc_CellUpdateCause_radiolinkFailure:
          case  rrc_CellUpdateCause_re_enteredServiceArea:
          case  rrc_CellUpdateCause_rlc_unrecoverableError:
          case  rrc_CellUpdateCause_cellReselection:
          case  rrc_CellUpdateCause_periodicalCellUpdate:
            /* since the new cause has higher priority
            overwrite the old cause with the new one */
            change_reqd = TRUE;
            break;
          default:
            WRRC_MSG1_ERROR("unknown CU cause:%d", rrccu_cell_update_cause);
            break;
         }
         break;

      case RRC_RADIO_LINK_FAILURE:
        switch (rrccu_cell_update_cause)
        {
          case  rrc_CellUpdateCause_uplinkDataTransmission:
          case  rrc_CellUpdateCause_utran_pagingResponse:
          case  rrc_CellUpdateCause_radiolinkFailure:
            change_reqd = FALSE;
            break;

          case  rrc_CellUpdateCause_re_enteredServiceArea:
          case  rrc_CellUpdateCause_rlc_unrecoverableError:
          case  rrc_CellUpdateCause_cellReselection:
          case  rrc_CellUpdateCause_periodicalCellUpdate:
            /* since the new cause has higher priority
            overwrite the old cause with the new one */
            change_reqd = TRUE;
            break;
          default:
            WRRC_MSG1_ERROR("unknown CU cause:%d", rrccu_cell_update_cause);
            break;
        }
        break;
    case RRC_REENTERED_SERVICE_AREA:
      switch (rrccu_cell_update_cause)
      {
        case  rrc_CellUpdateCause_uplinkDataTransmission:
        case  rrc_CellUpdateCause_utran_pagingResponse:
        case  rrc_CellUpdateCause_radiolinkFailure:
        case  rrc_CellUpdateCause_re_enteredServiceArea:
          /* retain the previous cell update cause */
          change_reqd = FALSE;
          break;
        case  rrc_CellUpdateCause_cellReselection:
        case  rrc_CellUpdateCause_periodicalCellUpdate:
          /* since the new cause has higher priority
          overwrite the old cause with the new one */
          change_reqd = TRUE;
          break;
        default:
          WRRC_MSG1_ERROR("unknown CU cause:%d", rrccu_cell_update_cause);
          break;
       }
       break;


    case RRC_UNRECOVERABLE_ERROR:
      switch (rrccu_cell_update_cause)
      {
        case  rrc_CellUpdateCause_uplinkDataTransmission:
        case  rrc_CellUpdateCause_utran_pagingResponse:
        case  rrc_CellUpdateCause_radiolinkFailure:
        case  rrc_CellUpdateCause_re_enteredServiceArea:
        case  rrc_CellUpdateCause_rlc_unrecoverableError:
          /* retain the previous cell update cause */
          change_reqd = FALSE;
          break;
        case  rrc_CellUpdateCause_cellReselection:
        case  rrc_CellUpdateCause_periodicalCellUpdate:
          /* since the new cause has higher priority
          overwrite the old cause with the new one */
          change_reqd = TRUE;
          break;
        default:
          WRRC_MSG1_ERROR("unknown CU cause:%d", rrccu_cell_update_cause);
          break;
       }
       break;

      case RRC_CELL_RESELECTION:
        switch (rrccu_cell_update_cause)
        {
          case  rrc_CellUpdateCause_uplinkDataTransmission:
          case  rrc_CellUpdateCause_utran_pagingResponse:
          case  rrc_CellUpdateCause_radiolinkFailure:
          case  rrc_CellUpdateCause_re_enteredServiceArea:
          case  rrc_CellUpdateCause_rlc_unrecoverableError:
          case  rrc_CellUpdateCause_cellReselection:
            /* retain the previous cell update cause */
            change_reqd = FALSE;
            break;
          case  rrc_CellUpdateCause_periodicalCellUpdate:
            /* since the new cause has higher priority
            overwrite the old cause with the new one */
            change_reqd = TRUE;
            break;
          default:
            WRRC_MSG1_ERROR("unknown CU cause:%d", rrccu_cell_update_cause);
            break;
        }
        break;


    case RRC_PERIODIC_CELL_UPDATE:
      switch (rrccu_cell_update_cause)
      {
        case  rrc_CellUpdateCause_uplinkDataTransmission:
        case  rrc_CellUpdateCause_utran_pagingResponse:
        case  rrc_CellUpdateCause_radiolinkFailure:
        case  rrc_CellUpdateCause_re_enteredServiceArea:
        case  rrc_CellUpdateCause_rlc_unrecoverableError:
        case  rrc_CellUpdateCause_cellReselection:
        case  rrc_CellUpdateCause_periodicalCellUpdate:
          /* retain the previous cell update cause */
          change_reqd = FALSE;
          break;
          default:
          WRRC_MSG1_ERROR("unknown CU cause:%d", rrccu_cell_update_cause);
          break;
      }
      break;
        default:
        WRRC_MSG1_ERROR("unknown CU cause:%d", cause);
        break;
    }

  }

  MSG_4(MSG_SSID_DFLT, MSG_LEGACY_HIGH,"rrccu_cell_update_started: %d change reqd:%d, curr_cause:%d, new_cause:%d",
  	rrccu_cell_update_started, change_reqd, rrccu_cell_update_cause, cause);

  return(change_reqd);
} /* rrccu_is_change_of_cu_cause_reqd */

/*===========================================================================

FUNCTION RRCCU_VALIDATE_URA_UPDATE_INITIATE_REQ

DESCRIPTION

  This function validates RRC_URA_UPDATE_INITIATE_REQ command and stores
  initiates procedure if it needs confirmation after Cell Update procedure
  successfully compelted.
  
DEPENDENCIES


RETURN VALUE

  rrccu_status_e_type: returns RRCCU_SUCCESS if it successfully validates
  RRC_URA_UPDATE_INITIATE_REQ. Otherwise it returns
  RRCCU_FAILURE_MINOR.

SIDE EFFECTS

  None

===========================================================================*/
static rrccu_status_e_type rrccu_validate_ura_update_initiate_req
(    
  rrc_cmd_type *cmd_ptr
)
{
  rrccu_status_e_type status = RRCCU_FAILURE_MINOR;
  
  rrc_state_e_type curr_state = RRC_STATE_WILDCARD; /* Local variable to store
                                                       current RRC state */
                   

  curr_state = rrc_get_state();
  WRRC_MSG2_HIGH("UU initiated with cause:%d by Proc:%d",
  cmd_ptr->cmd.initiate_ura_update.cause,
  cmd_ptr->cmd.initiate_ura_update.procedure);

  if (cmd_ptr->cmd_hdr.cmd_id == RRC_URA_UPDATE_INITIATE_REQ)
  {
    /* Check for Cell Update cause */
    switch(cmd_ptr->cmd.initiate_ura_update.cause)
    {
      case RRC_URA_RESELECTION:
        if (curr_state == RRC_STATE_URA_PCH )
        {
          status = RRCCU_SUCCESS;
        }
        break;

      default:
        WRRC_MSG1_ERROR("Unknown CU cause: %d",
             cmd_ptr->cmd.initiate_ura_update.cause);
        break;
    }
    /* Update the registration if RRC proc needs confirmation of Cell Update
       completion */
    if( (status == RRCCU_SUCCESS) && 
        (cmd_ptr->cmd.initiate_ura_update.uu_complete_cnf_required == TRUE) ) 
    {
      rrccu_reg_info.rrc_proc[rrccu_reg_info.no_of_reg_procs] = 
        cmd_ptr->cmd.initiate_ura_update.procedure; 
      rrccu_reg_info.no_of_reg_procs++;
    }
  }

  if(status != RRCCU_SUCCESS)
  {
    WRRC_MSG2_HIGH("Invalid cause: %d RRC_URA_UPDATE_INITIATE_REQ Cmd",
    cmd_ptr->cmd.initiate_ura_update.cause, curr_state);
  }     
  return( status );
} /* rrccu_validate_ura_update_initiate_req */


/*===========================================================================
      
      FUNCTION RRCCU_VALIDATE_URA_UPDATE_INITIATE_REQ
      
      DESCRIPTION
        
      This function will
      1. Check if the current URA_ID is present in the list of URA identities 
      specified in SIB2 database.
      2. Checks if SIB2 is empty
      3. Checks if SIB2 can't be found.
      
      If any of the above condition is true then it will initiate a URA update request
      with cause "ura_reselection"
        
      DEPENDENCIES
        None
      
      RETURN VALUE
        None
        
      SIDE EFFECTS
      
        None
      
===========================================================================*/

boolean rrccu_check_for_ura_reselection(void)
{
  rrc_SysInfoType2          *rrc_sib2_ptr = NULL; /* Ptr to sib2 type structure*/
  rrc_URA_IdentityList    *ura_id_node_ptr;     /* Ptr to the start of the ura identity list */
  boolean                   ura_reselection_occurred = TRUE;
  rrc_int_ura_id_type       int_ura_id;
  uint32 idx=0;
  /* Get the SIB2 pointer for the serving cell */
  rrc_sib2_ptr = (rrc_SysInfoType2 *) 
  rrc_sibdb_return_sib_for_srv_cell(rrc_SIB2);

  /* This MACRO would check the boolean to see if it is set to TRUE when any message 
  that is received has the URA_ID field set to a value which is the URA_IDENTITY */
  if (rrccu_current_ura_id != RRC_INVALID_URA_ID) 
  {
    if (rrc_sib2_ptr != NULL)
    {
      /* Get the pointer to the start of the ura_identity list */
      ura_id_node_ptr = &rrc_sib2_ptr->ura_IdentityList;
      /* If the list is not empty */
      while (ura_id_node_ptr->n > idx)
      {
        /*Convert the OSSBITSTRING to uint32. rrccu_Current_URA_ID*/
        rrc_translate_ura_id(&ura_id_node_ptr->elem[idx], &int_ura_id);
        MSG_HIGH("URA_ID in SIB 0x%x, current URA_ID 0x%x, URA_IDs match status %d",int_ura_id,rrccu_current_ura_id,(rrccu_current_ura_id == int_ura_id));

        /* Check if this URA_IDENTITY is present in the SIB2 list */
        if (rrccu_current_ura_id == int_ura_id)
        {
          /* If the ura id is present in the list of ura-id's */
          ura_reselection_occurred = FALSE;
          break;
        }
        /* Move to the next element */
        idx++;
      } /* end while */
    }/* sib2 != NULL */
    else
    {
    // Already taken care of since the flag ura-reselection_occurred is set to TRUE;
      WRRC_MSG0_HIGH("URA reselection occurred No SIB2");
    }
  }
  /* If the URA_ID is not included in the received message */
  else
  {
    if (rrc_sib2_ptr != NULL) 
    {
      /* Get the pointer to the start of the ura_identity list */
      ura_id_node_ptr = &rrc_sib2_ptr->ura_IdentityList;
      /* If the list has only one entry then store the URA_ID of the 
      first entry in the variable URA_IDENTITY */
      if (ura_id_node_ptr->n == 1)
      {
       /*Convert the OSSBITSTRING to uint32. rrccu_Current_URA_ID*/
        rrc_translate_ura_id(&ura_id_node_ptr->elem[idx], &rrccu_current_ura_id);

        WRRC_MSG1_HIGH("Only one URA_ID 0x%x in SIB2",rrccu_current_ura_id);
        /* A Macro which sets the URA_IDENTITY field */
        ura_reselection_occurred = FALSE;
      }
      else
      {
        // Already taken care of since ura_selection_occurred = TRUE
        // in the beginning.
        WRRC_MSG0_HIGH("More than one URA_IDs in SIB2");
      }
    }
  }

  /* TO_DO check if an URA_UPDATE procedure is ongoing if yes then do another
  ura update */
  return ura_reselection_occurred;

} /* rrccu_check_for_ura_reselection */

/*===========================================================================
      
      FUNCTION RRCCU_CLEAR_URA_ID
      
      DESCRIPTION
        
      This function will clear the URA_ID field. Would set it to 0xffff
        
      DEPENDENCIES
        None
      
      RETURN VALUE
        None
        
      SIDE EFFECTS
      
        None
      
===========================================================================*/

void rrccu_clear_ura_id()
{
  rrccu_current_ura_id = RRC_INVALID_URA_ID;
  /* check for ura reselection here if the current state is CELL_FACH
  and set the flag accordingly */
  if (RRC_STATE_CELL_FACH == rrc_get_state())
  {
    rrccu_ura_update_required = rrccu_check_for_ura_reselection();
    WRRC_MSG1_HIGH("URA Reselection flag set to %d", rrccu_ura_update_required);
  }
}

/*===========================================================================
      
FUNCTION RRCCU_IS_URA_UPDATE_REQD

DESCRIPTION
  
This function will return TRUE if the URA update is required 
else it will return FALSE.
  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/


boolean rrccu_is_ura_update_reqd()
{
 return (rrccu_ura_update_required); 
}


/*===========================================================================
      
      FUNCTION RRCCU_UPDATE_URA_ID
      
      DESCRIPTION
        
      This function will convert the oss_bitstring to the unit32 value
    and then stores the value of in the URA_ID field.
        
      DEPENDENCIES
        None
      
      RETURN VALUE
        None
        
      SIDE EFFECTS
      
        None
      
===========================================================================*/

void rrccu_update_ura_id
(
  ASN1BitStr32 *ura_id
)
{
  /* Translate the OSS bit string and update the URA-ID */
  rrc_translate_ura_id(ura_id, &rrccu_current_ura_id);
  /* check for ura reselection here if the current state is CELL_FACH
  and set the flag accordingly */
  if (RRC_STATE_CELL_FACH == rrc_get_state())
  {
    rrccu_ura_update_required = rrccu_check_for_ura_reselection();
    WRRC_MSG1_HIGH("URA Reselection flag set to %d", rrccu_ura_update_required);
  }
}

/*===========================================================================

FUNCTION RRCCU_CHECK_RE_EST_TIMERS

DESCRIPTION

  This function reads the values of Timers T314 and T315 from the SIB DB and
  returns details of the counters.
  
DEPENDENCIES


RETURN VALUE

  rrccu_re_est_timers_status_e_type: returns RRCCU_T314_T315_ZERO if both T314 and 
  T315 are zero. Returns RRCCU_T314_ZERO if T314 is zero and T315 is a non-zero.
  Returns RRCCU_T315_ZERO if T315 is non-zero and T315 is a zero and returns
  RRCCU_T314_T315_NON_ZERO if both T314 and T315 are non-zero.

SIDE EFFECTS

  None

===========================================================================*/
rrccu_re_est_timers_status_e_type rrccu_check_re_est_timers
(    
  void
)
{

  rrccu_re_est_timers_status_e_type status; 
                              /* Local variable to store timers status */


  if( (RRC_GET_T314() == rrc_T_314_s0) && (RRC_GET_T315() != rrc_T_315_s0) )
  {
    status = RRCCU_T314_ZERO;
  }    
  else if ( (RRC_GET_T314() != rrc_T_314_s0) && (RRC_GET_T315() == rrc_T_315_s0) )  
  {
    status = RRCCU_T315_ZERO;
  }
  else if ( (RRC_GET_T314() != rrc_T_314_s0) && (RRC_GET_T315() != rrc_T_315_s0) ) 
  {
    status = RRCCU_T314_T315_NON_ZERO;
  }
  else
  {
    status = RRCCU_T314_T315_ZERO;
  }
  WRRC_MSG2_HIGH("T314=%d, T315=%d", RRC_GET_T314(), RRC_GET_T315());
  /* In the current release, the re-establishment is not supported */
  return( status );
} /* rrccu_check_re_est_timers */
/*===========================================================================

FUNCTION RRCCU_ESTABLISH_RB0

DESCRIPTION
  This function sends RRC_CHANNEL_CONFIG_REQ to RRC LLC to establish RB0
  
DEPENDENCIES


RETURN VALUE
  rrccu_status_e_type: returns RRCCU_SUCCESS if it successfully sends
  RRC_CHANNEL_CONFIG_REQ to the RRC LLC. Otherwise it returns
  RRCCU_FAILURE_MAJOR.


SIDE EFFECTS

  None

===========================================================================*/
void rrccu_establish_rb0
(    
  rrc_rb_cfg_e_type action,                   /* Type of action RB 0 */
  rrc_state_e_type dest_state,                /* Next state to transition is
                                                 expected to take place */
  boolean confirm_required                    /* This indicates whether
                                                 RRC_CHANNEL_CONFIG_CNF is 
                                                 required or not */  
)
{
  rrc_cmd_type *cmd_ptr;                     /* Pointer to the RRC Command */

  /* Allocates the buffer to RRC Internal command */
  cmd_ptr =  rrc_get_int_cmd_buf();
  /* Fill in the command parameters for RRC_CHANNEL_CONFIG_REQ */
  cmd_ptr->cmd_hdr.cmd_id = RRC_CHANNEL_CONFIG_REQ;
  cmd_ptr->cmd.chan_config_req.procedure = RRC_PROCEDURE_CU;
  /* Fill in parameters for RRC_CHANNEL_CONFIG_REQ command */
  cmd_ptr->cmd.chan_config_req.rrc_state_change_required = TRUE;
  cmd_ptr->cmd.chan_config_req.next_state = dest_state;
  cmd_ptr->cmd.chan_config_req.num_rb_to_config = 1;
  cmd_ptr->cmd.chan_config_req.rb[0].rb_id = CCCH_RADIO_BEARER_ID;
  cmd_ptr->cmd.chan_config_req.rb[0].rb_config = action;
  cmd_ptr->cmd.chan_config_req.rrc_channel_config_cnf_required = 
    confirm_required;
  
  MSG_MED("RRC_CHANNEL_CONFIG_REQ is sent to establish RB0",0,0,0);
  rrc_put_int_cmd(cmd_ptr);                 /* sends the command to RRC
                                                 LLC. */
} /* rrccu_establish_rb0 */
/*===========================================================================

FUNCTION rrccu_send_rab_rel_ind_to_nas

DESCRIPTION
  This function is used to send the RAB release indicatio to NAS 
  
DEPENDENCIES


RETURN VALUE

None


SIDE EFFECTS

  None

===========================================================================*/

static void rrccu_send_rab_rel_ind_to_nas (rrc_cn_domain_identity_e_type domain_id, uint32 rab_id  )
{
  mm_cmd_type *mm_ptr;   /* To send the MM_SYNC_IND command */
  rabm_cmd_type *rabm_ptr; /* To send the RABMAS_RAB_RELEASE_IND  command */
  uint8 rab_index = MAX_RAB_TO_SETUP;

  /* Send the indication to MM or RABM based on the CN domain ID */
  if ( domain_id == RRC_CS_DOMAIN_CN_ID )
  {
    mm_ptr = mm_rrc_get_cmd_buf(RRC_SYNC_IND);    
    mm_ptr->cmd.rrc_sync_ind.cn_domain_id = RRC_CS_DOMAIN_CN_ID;
    mm_ptr->cmd.rrc_sync_ind.cause = RRC_RAB_ESTABLISHED;
    mm_ptr->cmd.rrc_sync_ind.rab_id_present = TRUE;
    mm_ptr->cmd.rrc_sync_ind.rab_info.action = RAB_RELEASED;
    mm_ptr->cmd.rrc_sync_ind.rab_info.rab_id = rab_id;
    if((rab_index = rrc_get_idx_in_rrc_est_rabs_for_rab_id(rab_id)) < MAX_RAB_TO_SETUP)
    {
      if(rrc_est_rabs.rabs[rab_index].rab_type == RRCRB_CS_VOICE_RAB) 
      {
        mm_ptr->cmd.rrc_sync_ind.rab_info.cs_rab_type = RRCMN_CS_VOICE_CALL;
      }
      else if(rrc_est_rabs.rabs[rab_index].rab_type == RRCRB_CS_DATA_RAB)
      {
        mm_ptr->cmd.rrc_sync_ind.rab_info.cs_rab_type = RRCMN_CS_DATA_CALL;
      }
      else
      {
        WRRC_MSG1_ERROR("Something wrong with RAB Type for RAB-id %d",
            mm_ptr->cmd.rrc_sync_ind.rab_info.rab_id);
        mm_ptr->cmd.rrc_sync_ind.rab_info.cs_rab_type = RRCMN_INVALID_RAB_ID;
      }
    }
#ifdef FEATURE_UMTS_VOICE_CIPHERING_IND
    #error code not present
#endif  /*FEATURE_UMTS_VOICE_CIPHERING_IND*/

#ifdef FEATURE_DUAL_SIM
    mm_ptr->cmd.rrc_sync_ind.as_id = rrc_get_as_id();
#endif

    /* Put the command on MM queue */
    MSG_HIGH("Dispatching out MM cmd / Sending RRC_SYNC_IND to MM for RAB type %d RAB-id %d, action: %d", 
            mm_ptr->cmd.rrc_sync_ind.rab_info.cs_rab_type, 
            mm_ptr->cmd.rrc_sync_ind.rab_info.rab_id,mm_ptr->cmd.rrc_sync_ind.rab_info.action);
    rrc_send_rrc_message_to_mm(mm_ptr);
  }/* end if cs domain */
  else if ( domain_id == RRC_PS_DOMAIN_CN_ID )
  {
    if ((rabm_ptr = rabm_get_cmd_buf()) == NULL)
    {
      ERR_FATAL("Can't send RABM cmd - out of memory!", 0, 0, 0);
    }
    rabm_ptr->header.cmd_id = RABMAS_RAB_RELEASE_IND;
    rabm_ptr->header.message_set = MS_RABM_RRC;
    rabm_ptr->cmd.rrc_release_ind.rabid = 
    (rabid_T)(rab_id);
#ifdef FEATURE_DUAL_SIM
    rabm_ptr->cmd.rrc_release_ind.as_id = rrc_get_as_id();
#endif
    /* Put the command on RABM queue */
    WRRC_MSG1_HIGH("Sending RABMAS_RAB_RELEASE_IND to RABM rabid %d", rab_id);
    rabm_put_cmd(rabm_ptr);
  }/* end if ps domain */
}/* rrccu_send_rab_rel_ind_to_nas */

/*===========================================================================

FUNCTION rrccu_is_need_to_release_signalling_connection

DESCRIPTION
  This function checks whether all RABs related to a CN domain
  I.D are being released
DEPENDENCIES
  None

RETURN VALUE
  TRUE :If all RABs related to a re-estblishment
        timer belong to a single CN comain.
  FALSE:Otherwise

SIDE EFFECTS
  None
===========================================================================*/
static boolean rrccu_is_need_to_release_signalling_connection
(
  rrc_Re_EstablishmentTimer re_est_timer,
  rrc_cn_domain_identity_e_type cn_domain_id
)
{
  uint32 rab_count;
  
  /*Get the Cn domain associated with first RAB which uses re_est_timer*/

  for(rab_count=0; rab_count<MAX_RAB_TO_SETUP; rab_count++)
  {
    if((rrc_est_rabs.rabs[rab_count].num_rbs_for_rab > 0) && 
       (rrc_est_rabs.rabs[rab_count].cn_domain == cn_domain_id))
    {
      if(rrc_est_rabs.rabs[rab_count].re_est_timer != re_est_timer)
      {
        MSG_4(MSG_SSID_DFLT, MSG_LEGACY_HIGH,"Do not Release CN Domain %d as RAB-Id %d is accociated with Re_est Timer %d, RAB rxd re_est_timer=%d",
                  cn_domain_id,rab_count,rrc_est_rabs.rabs[rab_count].re_est_timer,re_est_timer);
        return FALSE;
      }
    }
  }
  /*Below consition will be true when
       1. Only PS domain is up and RAB is accociated with T314
       2. Both domains are up and no RAB's have yet been established

       When either of the above is satisfied, dont return TRUE since we need to send RRC_REL_IND
   */
   
  MSG_4(MSG_SSID_DFLT, MSG_LEGACY_HIGH," RAB rxd re_est_timer: %d[0-T314, 1-T315], CN domain: %d, is_cs_up: %d, is_ps_up: %d", re_est_timer, cn_domain_id, rrcdt_is_cs_domain_open(), rrcdt_is_ps_domain_open());
  if((cn_domain_id ==  RRC_PS_DOMAIN_CN_ID) && (rrcdt_is_cs_domain_open() == FALSE))
  {
    return FALSE;
  }
  else if((cn_domain_id ==  RRC_CS_DOMAIN_CN_ID) && (rrcdt_is_ps_domain_open() == FALSE))
  {
    return FALSE;
  }
  return TRUE;
}

/*===========================================================================

FUNCTION rrccu_send_rab_release_for_rbs_associated_with_re_est_timer

DESCRIPTION
  This function sends RABMAS_RAB_RELEASE_IND or RRC_SYNC_IND to NAS for Rbs that whose
  timer has expired and are about to be released.
  
DEPENDENCIES


RETURN VALUE
  rrccu_status_e_type: returns RRCCU_SUCCESS if it successfully sends
  RRC_CHANNEL_CONFIG_REQ to the RRC LLC. Otherwise it returns
  RRCCU_FAILURE_MAJOR.


SIDE EFFECTS

  None

===========================================================================*/

static void rrccu_send_rab_rel_ind_for_rbs_associated_with_re_est_timer
(    
   rrc_Re_EstablishmentTimer re_est_timer
)
{
  uint32 rab_count = 0;
  uint8 i;

  /*get the RBs that are associated with the re-est timer */
  for (rab_count=0; rab_count < MAX_RAB_TO_SETUP; rab_count++)
  {
    if (
        (rrc_est_rabs.rabs[rab_count].re_est_timer == re_est_timer) &&
        (rrc_est_rabs.rabs[rab_count].num_rbs_for_rab > 0)
        )
    {
      /*since all RBs associated with the RAB are going to be released
        inform about the RAB release to upper layer */
      rrccu_send_rab_rel_ind_to_nas(rrc_est_rabs.rabs[rab_count].cn_domain,
                                    rrc_est_rabs.rabs[rab_count].rab_id);
    } /*end of if*/
  }/* rab_count loop */  

  /*If all radio access bearers associated with a CN domain are released,
     Locally release the signalling connection for this CN domain*/
  for(i=0;i<RRC_MAX_CN_DOMAINS;i++)
  {
    if((rrc_cn_domain_identity_e_type)i == RRC_CS_DOMAIN_CN_ID)
    {
      if(rrccu_is_need_to_release_signalling_connection(re_est_timer,RRC_CS_DOMAIN_CN_ID) == TRUE)
      {
        (void)rrcscr_local_release_of_signalling_connection(RRC_CS_DOMAIN_CN_ID, RRC_SESSION_CLOSE_RL_FAILURE);
      }
    }
    if((rrc_cn_domain_identity_e_type)i == RRC_PS_DOMAIN_CN_ID)
    {
      if(rrccu_is_need_to_release_signalling_connection(re_est_timer,RRC_PS_DOMAIN_CN_ID) == TRUE)
      {
        (void)rrcscr_local_release_of_signalling_connection(RRC_PS_DOMAIN_CN_ID, RRC_SESSION_CLOSE_RL_FAILURE);
      }
    }
  }


} /* rrccu_send_rab_rel_ind_for_rbs_associated_with_re_est_timer */


/*===========================================================================

FUNCTION rrccu_release_rbs_associated_with_re_est_timer

DESCRIPTION
  This function sends RRC_CHANNEL_CONFIG_REQ to RRC LLC to establish RB1_RB4
  
DEPENDENCIES


RETURN VALUE
  rrccu_status_e_type: returns RRCCU_SUCCESS if it successfully sends
  RRC_CHANNEL_CONFIG_REQ to the RRC LLC. Otherwise it returns
  RRCCU_FAILURE_MAJOR.


SIDE EFFECTS

  None

===========================================================================*/
static void rrccu_release_rabs_associated_with_re_est_timer
(    
   rrc_Re_EstablishmentTimer re_est_timer
)
{
  rrc_cmd_type *cmd_ptr;                     /* Pointer to the RRC Command */
  uint32 count=0;
  uint32 nrab=0;
  uint32 rab_count;
  uint32 rb_count;

  /* Allocates the buffer to RRC Internal command */
    cmd_ptr =  rrc_get_int_cmd_buf();
    /* Fill in the command parameters for RRC_CHANNEL_CONFIG_REQ */
    cmd_ptr->cmd_hdr.cmd_id = RRC_CHANNEL_CONFIG_REQ;
    cmd_ptr->cmd.chan_config_req.procedure = RRC_PROCEDURE_CU;

    /* Fill in parameters for RRC_CHANNEL_CONFIG_REQ command */
    cmd_ptr->cmd.chan_config_req.rrc_state_change_required = FALSE;
    cmd_ptr->cmd.chan_config_req.chan_config_reason = RRCLLC_CHAN_CFG_REASON_RLC_CONFIG_ONLY;

    /*get the RBs that are associated with the re-est timer */
    for (rab_count=0; rab_count<MAX_RAB_TO_SETUP; rab_count++)
    {
      if (
           (rrc_est_rabs.rabs[rab_count].re_est_timer == re_est_timer) &&
            (rrc_est_rabs.rabs[rab_count].num_rbs_for_rab > 0)
          )
      {
        nrab++;
        /*it is a valid established rab, now compare each rb-id in this established rab with 
        the rb-id received in the message */
        for (rb_count=0; ((rb_count<rrc_est_rabs.rabs[rab_count].num_rbs_for_rab) && 
          (rb_count < MAX_RB_PER_RAB) && (count<MAX_RB)); rb_count++)
        {
          cmd_ptr->cmd.chan_config_req.rb[count].rb_id = 
            rrc_est_rabs.rabs[rab_count].rb_for_rab[rb_count].rb_id;
          cmd_ptr->cmd.chan_config_req.rb[count++].rb_config = RELEASE_RB;
        }
        /*since all RBs associated with the RAB are going to be released
        inform about the RAB release to upper layer */
        //rrccu_send_rab_rel_ind_to_nas(rrc_est_rabs.rabs[rab_count].cn_domain,
        //                               rrc_est_rabs.rabs[rab_count].rab_id);
        /*clear the RAB from established_rab variable. */
        rrc_remove_rab_from_established_rabs (rrc_est_rabs.rabs[rab_count].rab_id);
      } /*end of if*/
    }/* rab_count loop */
    cmd_ptr->cmd.chan_config_req.num_rb_to_config = (uint16)count;
    /* confirmation is not required */
    cmd_ptr->cmd.chan_config_req.rrc_channel_config_cnf_required = FALSE;
  
    MSG_HIGH("RRC_CHANNEL_CONFIG_REQ sent to release %dRBs,RABs:%d,cu_st:%d",
             count,nrab,rrccu_substate);
    rrc_put_int_cmd(cmd_ptr);                 /* sends the command to RRC
                                                 LLC. */
} /* rrccu_release_rabs_associated_with_re_est_timer */

/*===========================================================================

FUNCTION rrccu_check_re_est_timer_status

DESCRIPTION
 This function will check re-est timer status and takes appropriate action
DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/

static void rrccu_check_re_est_timer_status
(    
  void  
)
{
  /*check whether any RAB release is required because of 
  re-establishment timer expiry. If so send channel config request
  If both timers are expired or not started then enter idle */
  if(rrccu_rl_failure_info.t314_info.need_rab_release_ind == TRUE)
  {
    rrccu_send_rab_rel_ind_for_rbs_associated_with_re_est_timer(rrc_Re_EstablishmentTimer_useT314);
    rrccu_rl_failure_info.t314_info.need_rab_release_ind = FALSE;
  }
  if(rrccu_rl_failure_info.t314_info.need_to_release_rabs == TRUE)
  {
    rrccu_release_rabs_associated_with_re_est_timer (rrc_Re_EstablishmentTimer_useT314);
    rrccu_rl_failure_info.t314_info.need_to_release_rabs = FALSE;
  }

  if(rrccu_rl_failure_info.t315_info.need_rab_release_ind == TRUE)
  {
    rrccu_send_rab_rel_ind_for_rbs_associated_with_re_est_timer(rrc_Re_EstablishmentTimer_useT315);
    rrccu_rl_failure_info.t315_info.need_rab_release_ind = FALSE;
  }
  if(rrccu_rl_failure_info.t315_info.need_to_release_rabs == TRUE)
  {
    rrccu_release_rabs_associated_with_re_est_timer (rrc_Re_EstablishmentTimer_useT315);
    rrccu_rl_failure_info.t315_info.need_to_release_rabs = FALSE;
  }
} /*   rrccu_check_re_est_timer_status */

#ifdef FEATURE_WCDMA_HS_FACH
/*===========================================================================

FUNCTION rrcllc_establish_srb_rab_in_efach

DESCRIPTION
  This function sends RRC_CHANNEL_CONFIG_REQ to RRC LLC to establish RB0
  and RB1 to RB4 if the RB mapping info of these signalling RBs on FACH
  is available. rrcllc will decide whether to setup RB1 to RB4 along with RB0
  
DEPENDENCIES


RETURN VALUE
  rrccu_status_e_type: returns RRCCU_SUCCESS if it successfully sends
  RRC_CHANNEL_CONFIG_REQ to the RRC LLC. Otherwise it returns
  RRCCU_FAILURE_MAJOR.


SIDE EFFECTS

  None

===========================================================================*/
void rrcllc_establish_srb_rab_in_efach
( 
  rrc_e_fach_operation_mode_e_type efach_mode,
  rrc_proc_e_type       procedure,
  boolean is_oc_set
)
{
  rrc_cmd_type *cmd_ptr;                     /* Pointer to the RRC Command */
  uint32 count=0;
  uint32 urb_count=0;
  uint32 rab_count;
  uint32 rb_count;
  rlc_lc_id_type ul_rlc_lc_id = RRCLCM_RLC_LC_ID_NOT_FOUND;
  rrc_RB_Identity srb5_rb_id;

  /* Allocates the buffer to RRC Internal command */
  cmd_ptr =  rrc_get_int_cmd_buf();
  /* Fill in the command parameters for RRC_CHANNEL_CONFIG_REQ */
  cmd_ptr->cmd_hdr.cmd_id = RRC_CHANNEL_CONFIG_REQ;
  cmd_ptr->cmd.chan_config_req.procedure = procedure;
  cmd_ptr->cmd.chan_config_req.next_state = RRC_STATE_CELL_FACH;
  cmd_ptr->cmd.chan_config_req.rrc_channel_config_cnf_required = FALSE;
  cmd_ptr->cmd.chan_config_req.is_oc_set= is_oc_set;

  if(efach_mode == RRC_E_FACH_DEDICATED)
  {
    cmd_ptr->cmd.chan_config_req.chan_config_reason = 
           RRCLLC_CHAN_CFG_REASON_HS_FACH_DEDICATED_OPS;
    /*reconfig signalling RBs */
    cmd_ptr->cmd.chan_config_req.rb[count].rb_id = DCCH_UM_RADIO_BEARER_ID;
    cmd_ptr->cmd.chan_config_req.rb[count++].rb_config = RECONFIG_RB;
    cmd_ptr->cmd.chan_config_req.rb[count].rb_id = DCCH_AM_RADIO_BEARER_ID;
    cmd_ptr->cmd.chan_config_req.rb[count++].rb_config = RECONFIG_RB;
    cmd_ptr->cmd.chan_config_req.rb[count].rb_id = DCCH_DT_HIGH_PRI_RADIO_BEARER_ID;
    cmd_ptr->cmd.chan_config_req.rb[count++].rb_config = RECONFIG_RB;
    /* check whether RB4 was present or not */
    ul_rlc_lc_id = rrclcm_check_ul_rlc_lc_id(UE_LOGCHAN_DCCH, 
                                 DCCH_DT_LOW_PRI_RADIO_BEARER_ID,
                                 UE_MODE_ACKNOWLEDGED_DATA);

    if(ul_rlc_lc_id != RRCLCM_RLC_LC_ID_NOT_FOUND)
    {
      cmd_ptr->cmd.chan_config_req.rb[count].rb_id = DCCH_DT_LOW_PRI_RADIO_BEARER_ID;
      cmd_ptr->cmd.chan_config_req.rb[count++].rb_config = RECONFIG_RB;
    }

    if(rrclcm_get_rb_id_if_dl_lc_type_exists(UE_LOGCHAN_TM_DCCH_DL, &srb5_rb_id) == RRCLCM_SUCCESS)
    {
      cmd_ptr->cmd.chan_config_req.rb[count].rb_id       = (rb_id_type)srb5_rb_id;
      cmd_ptr->cmd.chan_config_req.rb[count++].rb_config = RECONFIG_RB;
    }
    
    /*setup the user plane RBs also at this time. Do not have to worry about the
    ul transmission as it will not happen until we get a valid C-RNTI in the 
    cell update confirm message */
    for (rab_count=0; rab_count<MAX_RAB_TO_SETUP; rab_count++)
    {
      if (rrc_est_rabs.rabs[rab_count].num_rbs_for_rab > 0)
      {
        /*it is a valid established rab, now compare each rb-id in this established rab with 
        the rb-id received in the message */
        for (rb_count=0; ((rb_count<rrc_est_rabs.rabs[rab_count].num_rbs_for_rab) && 
          (rb_count < MAX_RB_PER_RAB) && (count<MAX_RB)); rb_count++)    
        {
          cmd_ptr->cmd.chan_config_req.rb[count].rb_id = (uint16)
            rrc_est_rabs.rabs[rab_count].rb_for_rab[rb_count].rb_id;
          cmd_ptr->cmd.chan_config_req.rb[count++].rb_config = RECONFIG_RB;
          urb_count++;
        }
      } /*end of if*/
    }/* rab_count loop */
  }
  else
  {
    cmd_ptr->cmd.chan_config_req.chan_config_reason = 
                RRCLLC_CHAN_CFG_REASON_HS_FACH_COMMON_OPS;
    cmd_ptr->cmd.chan_config_req.rrc_channel_config_cnf_required = TRUE;
    cmd_ptr->cmd.chan_config_req.rb[count].rb_id = CCCH_RADIO_BEARER_ID;
    cmd_ptr->cmd.chan_config_req.rb[count++].rb_config = RECONFIG_RB;
    cmd_ptr->cmd.chan_config_req.rb[count].rb_id = DCCH_UM_RADIO_BEARER_ID;
    cmd_ptr->cmd.chan_config_req.rb[count++].rb_config = RECONFIG_RB;
  }

  /* set both rab release flags to false as the "TRUE" case is 
  taken care in the above loop */
  cmd_ptr->cmd.chan_config_req.num_rb_to_config        = (uint16)count;

  MSG_HIGH("RRC_CHANNEL_CONFIG_REQ sent to establish %d RBs, uplane RBs:%d, efach_mode: %d",
           count,urb_count, efach_mode);
  rrc_put_int_cmd(cmd_ptr);                 /* sends the command to RRC
                                               LLC. */
} /* rrccu_establish_srb */
#endif

/*===========================================================================

FUNCTION RRCCU_ESTABLISH_SRB

DESCRIPTION
  This function sends RRC_CHANNEL_CONFIG_REQ to RRC LLC to establish RB0
  and RB1 to RB4 if the RB mapping info of these signalling RBs on FACH
  is available. rrcllc will decide whether to setup RB1 to RB4 along with RB0
  
DEPENDENCIES


RETURN VALUE
  rrccu_status_e_type: returns RRCCU_SUCCESS if it successfully sends
  RRC_CHANNEL_CONFIG_REQ to the RRC LLC. Otherwise it returns
  RRCCU_FAILURE_MAJOR.


SIDE EFFECTS

  None

===========================================================================*/
static void rrccu_establish_srb
(    
  boolean pch_to_fach_transition,
  rrc_state_e_type dest_state,                /* Next state to transition is
                                                 expected to take place */
  boolean confirm_required                    /* This indicates whether
                                                 RRC_CHANNEL_CONFIG_CNF is 
                                                 required or not */  
)
{
  rrc_cmd_type *cmd_ptr;                     /* Pointer to the RRC Command */
  uint32 count=0;
  uint32 urb_count=0;
  uint32 rab_count;
  uint32 rb_count;
  rlc_lc_id_type ul_rlc_lc_id = RRCLCM_RLC_LC_ID_NOT_FOUND;
  rrc_RB_Identity srb5_rb_id;


  /* Allocates the buffer to RRC Internal command */
    cmd_ptr =  rrc_get_int_cmd_buf();
    /* Fill in the command parameters for RRC_CHANNEL_CONFIG_REQ */
    cmd_ptr->cmd_hdr.cmd_id = RRC_CHANNEL_CONFIG_REQ;
    cmd_ptr->cmd.chan_config_req.procedure = RRC_PROCEDURE_CU;
    cmd_ptr->cmd.chan_config_req.next_state = dest_state;
    cmd_ptr->cmd.chan_config_req.rrc_channel_config_cnf_required = 
      confirm_required;

    /* Fill in parameters for RRC_CHANNEL_CONFIG_REQ command */
    /* if Pch->fach transition then state change is required and also
    need to release pcch and add ccch */
    if (pch_to_fach_transition)
    {
      cmd_ptr->cmd.chan_config_req.rrc_state_change_required = TRUE;
      cmd_ptr->cmd.chan_config_req.rb[count].rb_id = PCCH_RADIO_BEARER_ID;
      cmd_ptr->cmd.chan_config_req.rb[count++].rb_config = RELEASE_RB;
      cmd_ptr->cmd.chan_config_req.rb[count].rb_id = CCCH_RADIO_BEARER_ID;
      cmd_ptr->cmd.chan_config_req.rb[count++].rb_config = RECONFIG_RB;
      cmd_ptr->cmd.chan_config_req.chan_config_reason = RRCLLC_CHAN_CFG_REASON_PCH_TO_FACH; 
    }
    else
    {
      cmd_ptr->cmd.chan_config_req.rrc_state_change_required = FALSE;
      cmd_ptr->cmd.chan_config_req.chan_config_reason = RRCLLC_CHAN_CFG_REASON_RL_FAILURE;
    }
    /*reconfig signalling RBs */
    cmd_ptr->cmd.chan_config_req.rb[count].rb_id = DCCH_UM_RADIO_BEARER_ID;
    cmd_ptr->cmd.chan_config_req.rb[count++].rb_config = RECONFIG_RB;
    cmd_ptr->cmd.chan_config_req.rb[count].rb_id = DCCH_AM_RADIO_BEARER_ID;
    cmd_ptr->cmd.chan_config_req.rb[count++].rb_config = RECONFIG_RB;
    cmd_ptr->cmd.chan_config_req.rb[count].rb_id = DCCH_DT_HIGH_PRI_RADIO_BEARER_ID;
    cmd_ptr->cmd.chan_config_req.rb[count++].rb_config = RECONFIG_RB;
    /* check whether RB4 was present or not */
    ul_rlc_lc_id = rrclcm_check_ul_rlc_lc_id(UE_LOGCHAN_DCCH, 
                                 DCCH_DT_LOW_PRI_RADIO_BEARER_ID,
                                 UE_MODE_ACKNOWLEDGED_DATA);

    if(ul_rlc_lc_id != RRCLCM_RLC_LC_ID_NOT_FOUND)
    {
      cmd_ptr->cmd.chan_config_req.rb[count].rb_id = DCCH_DT_LOW_PRI_RADIO_BEARER_ID;
      cmd_ptr->cmd.chan_config_req.rb[count++].rb_config = RECONFIG_RB;
    }

    if(rrclcm_get_rb_id_if_dl_lc_type_exists(UE_LOGCHAN_TM_DCCH_DL, &srb5_rb_id) == RRCLCM_SUCCESS)
    {
      cmd_ptr->cmd.chan_config_req.rb[count].rb_id       = srb5_rb_id;
      cmd_ptr->cmd.chan_config_req.rb[count++].rb_config = RECONFIG_RB;
    }
    
    /*setup the user plane RBs also at this time. Do not have to worry about the
    ul transmission as it will not happen until we get a valid C-RNTI in the 
    cell update confirm message */
    for (rab_count=0; rab_count<MAX_RAB_TO_SETUP; rab_count++)
    {
      if (
           ((rrc_est_rabs.rabs[rab_count].cn_domain == RRC_CS_DOMAIN_CN_ID)|| 
             (rrc_est_rabs.rabs[rab_count].cn_domain == RRC_PS_DOMAIN_CN_ID))
            &&
            (rrc_est_rabs.rabs[rab_count].num_rbs_for_rab > 0)
          )
      {
        /*it is a valid established rab, now compare each rb-id in this established rab with 
        the rb-id received in the message */
        for (rb_count=0; ((rb_count<rrc_est_rabs.rabs[rab_count].num_rbs_for_rab) && 
          (rb_count < MAX_RB_PER_RAB) && (count<MAX_RB)); rb_count++)    
        {
          cmd_ptr->cmd.chan_config_req.rb[count].rb_id = 
            rrc_est_rabs.rabs[rab_count].rb_for_rab[rb_count].rb_id;
          cmd_ptr->cmd.chan_config_req.rb[count++].rb_config = RECONFIG_RB;
          urb_count++;
        }
      } /*end of if*/
    }/* rab_count loop */
    /* set both rab release flags to false as the "TRUE" case is 
    taken care in the above loop */
    cmd_ptr->cmd.chan_config_req.num_rb_to_config        = (uint16)count;
    /* if we don't find the HSRACH mappings then don't send the MR*/	

    WRRC_MSG2_HIGH("RRC_CHANNEL_CONFIG_REQ sent to establish %dRBs, uplane RBs:%d",
count,urb_count);
    rrc_put_int_cmd(cmd_ptr);                 /* sends the command to RRC
                                                 LLC. */
} /* rrccu_establish_srb */
/*===========================================================================

FUNCTION rrccu_populate_security_revert_status_in_cu

DESCRIPTION
  This function updates the CELL UPDATE message with security revert status ind

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/

static void rrccu_populate_security_revert_status_in_cu
(
  rrc_UL_CCCH_Message * msg_ptr
)
{
  
  /* The following bitmask may already be set earlier */
  if(!(msg_ptr->message.u.cellUpdate.m.laterNonCriticalExtensionsPresent))
  {
    RRC_MSG_COMMON_SET_BITMASK_IE_TYPE2(msg_ptr->message.u.cellUpdate, laterNonCriticalExtensions);
    
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions);
  }
  
   /* The following bitmask may already be set earlier */
  if(!(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.m.v590NonCriticalExtensionsPresent))
  {
    RRC_MSG_COMMON_SET_BITMASK_IE_TYPE2(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions, v590NonCriticalExtensions);
    
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.
      v590NonCriticalExtensions);
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.cellUpdate_v590ext);
  }
  
  if(!(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.m.v690NonCriticalExtensionsPresent))
  {
     RRC_MSG_COMMON_SET_BITMASK_IE_TYPE2(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.
      v590NonCriticalExtensions, v690NonCriticalExtensions);
    
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.
      v690NonCriticalExtensions);
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.
    v690NonCriticalExtensions.cellUpdate_v690ext);
  }


  if(!(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.m.
       v6b0NonCriticalExtensionsPresent))
  {
    RRC_MSG_COMMON_SET_BITMASK_IE_TYPE2(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.
      v690NonCriticalExtensions, v6b0NonCriticalExtensions);
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.
      v6b0NonCriticalExtensions);
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.
      v690NonCriticalExtensions.v6b0NonCriticalExtensions.cellUpdate_v6b0ext);
  }

  if(!(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.v6b0NonCriticalExtensions.
       m.v770NonCriticalExtensionsPresent))
  {
    RRC_MSG_COMMON_SET_BITMASK_IE_TYPE2(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.
      v6b0NonCriticalExtensions, v770NonCriticalExtensions);
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.
      v6b0NonCriticalExtensions.v770NonCriticalExtensions);
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.
      v690NonCriticalExtensions.v6b0NonCriticalExtensions.v770NonCriticalExtensions.cellUpdate_v770ext);
  }

  if(!(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.v6b0NonCriticalExtensions.v770NonCriticalExtensions.m.v860NonCriticalExtensionsPresent))
  {
    RRC_MSG_COMMON_SET_BITMASK_IE_TYPE2(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.v6b0NonCriticalExtensions.v770NonCriticalExtensions, v860NonCriticalExtensions);
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.v6b0NonCriticalExtensions.v770NonCriticalExtensions.v860NonCriticalExtensions);
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.v6b0NonCriticalExtensions.v770NonCriticalExtensions.v860NonCriticalExtensions.cellUpdate_v860ext);
  }


  if(!(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.v6b0NonCriticalExtensions.v770NonCriticalExtensions.v860NonCriticalExtensions.m.va40NonCriticalExtensionsPresent))
  {
    RRC_MSG_COMMON_SET_BITMASK_IE_TYPE2(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.v6b0NonCriticalExtensions.v770NonCriticalExtensions.v860NonCriticalExtensions, va40NonCriticalExtensions);
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.v6b0NonCriticalExtensions.v770NonCriticalExtensions.v860NonCriticalExtensions.va40NonCriticalExtensions);
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.v6b0NonCriticalExtensions.v770NonCriticalExtensions.v860NonCriticalExtensions.va40NonCriticalExtensions.cellUpdate_va40ext);
  }



  RRC_MSG_COMMON_SET_BITMASK_IE_TYPE2(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.v6b0NonCriticalExtensions.v770NonCriticalExtensions.v860NonCriticalExtensions.va40NonCriticalExtensions.cellUpdate_va40ext, securityRevertStatusIndicator);     
  if(rrccu_revert_back_to_old_config == TRUE)
  {
    msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.v6b0NonCriticalExtensions.v770NonCriticalExtensions.v860NonCriticalExtensions.va40NonCriticalExtensions.cellUpdate_va40ext.securityRevertStatusIndicator = rrc_CellUpdate_va40ext_IEs_securityRevertStatusIndicator_revertedBack;
  }
  else
  {
    msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.v6b0NonCriticalExtensions.v770NonCriticalExtensions.v860NonCriticalExtensions.va40NonCriticalExtensions.cellUpdate_va40ext.securityRevertStatusIndicator = rrc_CellUpdate_va40ext_IEs_securityRevertStatusIndicator_normalOperation;
  }
  rrc_qsh_security_revert_status = msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.v6b0NonCriticalExtensions.v770NonCriticalExtensions.v860NonCriticalExtensions.va40NonCriticalExtensions.cellUpdate_va40ext.securityRevertStatusIndicator;

}
#ifdef FEATURE_WCDMA_HS_FACH
/*===========================================================================

FUNCTION rrccu_populate_enh_state_info_in_cu

DESCRIPTION
  This function builds the CELL UPDATE message with all required
  parameters.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/

static void rrccu_populate_enh_state_info_in_cu
(
  rrc_UL_CCCH_Message * msg_ptr
)
{
  
  /* The following bitmask may already be set earlier */
  if(!(msg_ptr->message.u.cellUpdate.m.laterNonCriticalExtensionsPresent))
  {
    RRC_MSG_COMMON_SET_BITMASK_IE_TYPE2(msg_ptr->message.u.cellUpdate, laterNonCriticalExtensions);
    
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions);
  }
  
   /* The following bitmask may already be set earlier */
  if(!(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.m.v590NonCriticalExtensionsPresent))
  {
    RRC_MSG_COMMON_SET_BITMASK_IE_TYPE2(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions, v590NonCriticalExtensions);
    
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.
      v590NonCriticalExtensions);
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.cellUpdate_v590ext);
  }
  
  if(!(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.m.v690NonCriticalExtensionsPresent))
  {
     RRC_MSG_COMMON_SET_BITMASK_IE_TYPE2(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.
      v590NonCriticalExtensions, v690NonCriticalExtensions);
    
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.
      v690NonCriticalExtensions);
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.
    v690NonCriticalExtensions.cellUpdate_v690ext);
  }


  if(!(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.m.
       v6b0NonCriticalExtensionsPresent))
  {
    RRC_MSG_COMMON_SET_BITMASK_IE_TYPE2(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.
      v690NonCriticalExtensions, v6b0NonCriticalExtensions);
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.
      v6b0NonCriticalExtensions);
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.
      v690NonCriticalExtensions.v6b0NonCriticalExtensions.cellUpdate_v6b0ext);
  }

  if(!(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.v6b0NonCriticalExtensions.
       m.v770NonCriticalExtensionsPresent))
  {
    RRC_MSG_COMMON_SET_BITMASK_IE_TYPE2(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.
      v6b0NonCriticalExtensions, v770NonCriticalExtensions);
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.
      v6b0NonCriticalExtensions.v770NonCriticalExtensions);
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.
      v690NonCriticalExtensions.v6b0NonCriticalExtensions.v770NonCriticalExtensions.cellUpdate_v770ext);
  }

  RRC_MSG_COMMON_SET_BITMASK_IE_TYPE2(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.
      v6b0NonCriticalExtensions.v770NonCriticalExtensions.cellUpdate_v770ext, hspdschReception_CellFach);     

  msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.
      v6b0NonCriticalExtensions.v770NonCriticalExtensions.cellUpdate_v770ext.hspdschReception_CellFach = rrc_CellUpdate_v770ext_IEs_hspdschReception_CellFach_true;
#ifdef FEATURE_WCDMA_HS_FACH_DRX
  if (rrcenhstate_nv_supports_e_fach_drx())
  {
    msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.
        v6b0NonCriticalExtensions.v770NonCriticalExtensions.m.v860NonCriticalExtensionsPresent = 1;
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.
          v6b0NonCriticalExtensions.v770NonCriticalExtensions.v860NonCriticalExtensions.cellUpdate_v860ext);
    msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.
        v6b0NonCriticalExtensions.v770NonCriticalExtensions.v860NonCriticalExtensions.cellUpdate_v860ext.m.
        supportOfHS_DSCHDRXOperationPresent = 1;
    msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.
        v6b0NonCriticalExtensions.v770NonCriticalExtensions.v860NonCriticalExtensions.cellUpdate_v860ext.
         supportOfHS_DSCHDRXOperation = rrc_CellUpdate_v860ext_IEs_supportOfHS_DSCHDRXOperation_true;
  }

#endif

}
#endif /*FEATURE_WCDMA_HS_FACH*/

#ifdef FEATURE_WCDMA_REL7_SPECRS
/*===========================================================================

FUNCTION rrccu_populate_mobility_info_in_cu

DESCRIPTION
  This function builds the CELL UPDATE message with all required
  parameters.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/

static void rrccu_populate_mobility_info_in_cu
(
  rrc_UL_CCCH_Message * msg_ptr
)
{
  
  if(!(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.m.
       v6b0NonCriticalExtensionsPresent))
  {
    RRC_MSG_COMMON_SET_BITMASK_IE_TYPE2(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.
      v690NonCriticalExtensions, v6b0NonCriticalExtensions);
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.
      v6b0NonCriticalExtensions);
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.
      v690NonCriticalExtensions.v6b0NonCriticalExtensions.cellUpdate_v6b0ext);
  }

  if(!(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.v6b0NonCriticalExtensions.m.
       v770NonCriticalExtensionsPresent))
  {
    RRC_MSG_COMMON_SET_BITMASK_IE_TYPE2(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.
      v6b0NonCriticalExtensions, v770NonCriticalExtensions);
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.
      v6b0NonCriticalExtensions.v770NonCriticalExtensions);
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.
      v690NonCriticalExtensions.v6b0NonCriticalExtensions.v770NonCriticalExtensions.cellUpdate_v770ext);
  }
  RRC_MSG_COMMON_SET_BITMASK_IE_TYPE2(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.
      v6b0NonCriticalExtensions.v770NonCriticalExtensions.cellUpdate_v770ext, ueMobilityStateIndicator);     
  msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.
      v6b0NonCriticalExtensions.v770NonCriticalExtensions.cellUpdate_v770ext.ueMobilityStateIndicator = rrc_High_MobilityDetected_high_MobilityDetected;			  
}
#endif
#ifdef FEATURE_MAC_I
/*===========================================================================

FUNCTION rrccu_populate_maci_info_in_cu

DESCRIPTION
  This function populates the CELL UPDATE message with mac-i 
  support.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/

static void rrccu_populate_maci_info_in_cu
(
  rrc_UL_CCCH_Message * msg_ptr
)
{
  
  /* The following bitmask may already be set earlier */
  if(!(msg_ptr->message.u.cellUpdate.m.laterNonCriticalExtensionsPresent))
  {
    RRC_MSG_COMMON_SET_BITMASK_IE_TYPE2(msg_ptr->message.u.cellUpdate, laterNonCriticalExtensions);
    
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions);
  }
	
  /* The following bitmask may already be set earlier */
  if(!(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.m.v590NonCriticalExtensionsPresent))
  {
    RRC_MSG_COMMON_SET_BITMASK_IE_TYPE2(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions, v590NonCriticalExtensions);
    
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.
      v590NonCriticalExtensions);
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.cellUpdate_v590ext);
  }

  if(!(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.m.v690NonCriticalExtensionsPresent))
  {
     RRC_MSG_COMMON_SET_BITMASK_IE_TYPE2(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.
      v590NonCriticalExtensions, v690NonCriticalExtensions);
    
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.
      v690NonCriticalExtensions);
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.
    v690NonCriticalExtensions.cellUpdate_v690ext);
  }


  if(!(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.m.
       v6b0NonCriticalExtensionsPresent))
  {
    RRC_MSG_COMMON_SET_BITMASK_IE_TYPE2(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.
      v690NonCriticalExtensions, v6b0NonCriticalExtensions);
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.
      v6b0NonCriticalExtensions);
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.
      v690NonCriticalExtensions.v6b0NonCriticalExtensions.cellUpdate_v6b0ext);
  }

  if(!(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.v6b0NonCriticalExtensions.
       m.v770NonCriticalExtensionsPresent))
  {
    RRC_MSG_COMMON_SET_BITMASK_IE_TYPE2(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.
      v6b0NonCriticalExtensions, v770NonCriticalExtensions);
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.
      v6b0NonCriticalExtensions.v770NonCriticalExtensions);
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.
      v690NonCriticalExtensions.v6b0NonCriticalExtensions.v770NonCriticalExtensions.cellUpdate_v770ext);
  }

if(!(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.
        v6b0NonCriticalExtensions.v770NonCriticalExtensions.m.v860NonCriticalExtensionsPresent))
  {
    msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.
        v6b0NonCriticalExtensions.v770NonCriticalExtensions.m.v860NonCriticalExtensionsPresent = 1;
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.
          v6b0NonCriticalExtensions.v770NonCriticalExtensions.v860NonCriticalExtensions.cellUpdate_v860ext);
  }
    msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.
        v6b0NonCriticalExtensions.v770NonCriticalExtensions.v860NonCriticalExtensions.cellUpdate_v860ext.m.
        supportOfMACiisPresent = 1;
    msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.
        v6b0NonCriticalExtensions.v770NonCriticalExtensions.v860NonCriticalExtensions.cellUpdate_v860ext.
         supportOfMACiis = rrc_CellUpdate_v860ext_IEs_supportOfMACiis_true;

}
#endif /* FEATURE_MAC_I */
#ifdef FEATURE_WCDMA_HS_RACH
/*===========================================================================

FUNCTION rrccu_populate_hsrach_info_in_cu

DESCRIPTION
  This function populates the the CELL UPDATE message with hs-rach info 
  support.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/

static void rrccu_populate_hsrach_info_in_cu
(
  rrc_UL_CCCH_Message * msg_ptr
)
{

  /* All the bitmasks should be  already set earlier by maci*/	
    msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.
        v6b0NonCriticalExtensions.v770NonCriticalExtensions.v860NonCriticalExtensions.cellUpdate_v860ext.m.
        supportOfCommonEDCHPresent = 1;
    msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.
        v6b0NonCriticalExtensions.v770NonCriticalExtensions.v860NonCriticalExtensions.cellUpdate_v860ext.
         supportOfCommonEDCH = rrc_CellUpdate_v860ext_IEs_supportOfCommonEDCH_true;

}
#endif /* FEATURE_WCDMA_HS_FACH */
/*===========================================================================

FUNCTION rrccu_should_rsi_be_included

DESCRIPTION
  This function decides if RSI needs to be included in CU message also sets a flag
  to track if new config in CUC can be accepted usi

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
static boolean rrccu_should_rsi_be_included(void)
{
  rrc_proc_e_type                 proc_id;
  rrcllc_oc_process_state_e_type  process_state;  
  rrcllc_oc_set_status_e_type     oc_status;
  uint8                           proc_idx;
  boolean procedure_waiting_for_l2ack = FALSE;
  boolean any_procedure_waiting_for_l2ack = rrc_check_any_proc_waiting_for_l2_ack();
  oc_status = rrcllc_get_ordered_config_state_and_proc(&proc_id, &process_state);

  rrccu_do_not_acpt_nw_conf_in_cuc = FALSE;

  for(proc_idx=0;proc_idx<rrccu_reg_info.no_of_reg_procs;proc_idx++)
  {
    if(rrccu_check_proc_waiting_for_l2_ack(rrccu_reg_info.rrc_proc[proc_idx]))
    {
      WRRC_MSG2_HIGH("Proc rrc_proc_e_type_value%d is waiting for L2 ACK and CU cause is %d ",rrccu_reg_info.rrc_proc[proc_idx],rrccu_cell_update_cause);
      procedure_waiting_for_l2ack = TRUE;
      break;
    }
  }
/* Added the condition for rlc unrecoverable cause for the following scenario
   during a reconfiguration if UE needs to trigger a cell update for cell reselection due to
   absence of target cell info in OTA and rlc reset happens during reconfiguration processing
    As per 8.3.1.3
    1> if the variable ORDERED_RECONFIGURATION is set to TRUE:
    2> include the IE "Reconfiguration Status Indicator" and set it to TRUE.*/
  if((oc_status != OC_NOT_SET && ((rrccu_cell_update_cause==rrc_CellUpdateCause_cellReselection) ||
        (rrccu_cell_update_cause == rrc_CellUpdateCause_rlc_unrecoverableError))&&
      ((proc_id == RRC_PROCEDURE_RBE) ||
        (proc_id == RRC_PROCEDURE_RBR) || 
        (proc_id == RRC_PROCEDURE_RBRC) ||
        (proc_id == RRC_PROCEDURE_TCR) ||
        (proc_id == RRC_PROCEDURE_PCR))
      )
      /* Reconfig status indicator is added if OOS happenes when RRC state is DCH and TOC usage is reset to TOC_FOR_DCH*/
      /*
         OC is cleared for all Out of service cases. So following TOC checks are made to include RSI for OOS cases.
         DCH to FACH timer expiry case - rrcllc_get_toc_usage_change_oos_to_dch() == TRUE)&&(rrcllc_get_toc_usage()==TOC_FOR_DCH)
         OOS while Reconfiguring to FACH - TOC status will be either TOC_FOR_OOS/TOC_FOR_OOS_WITHOUT_DCH_INFO/TOC_FOR_OOS_WITH_DCH_INFO
      */
      ||((rrccu_cell_update_cause == rrc_CellUpdateCause_re_enteredServiceArea)&&((rrcllc_get_toc_usage()==TOC_FOR_OOS )
      || ((rrcllc_get_toc_usage_change_oos_to_dch() == TRUE)&&(rrcllc_get_toc_usage()==TOC_FOR_DCH ))))
      ||((rrccu_cell_update_cause == rrc_CellUpdateCause_re_enteredServiceArea)&&(rrcllc_get_toc_usage()==TOC_FOR_OOS_WITHOUT_DCH_INFO ||
          rrcllc_get_toc_usage()==TOC_FOR_OOS_WITH_DCH_INFO))
      )
  {
    /* Do not accept new configuration in Cell update confirm as Lower layers are yet to be configured with previous reconfiguation OTA contents */
    rrccu_do_not_acpt_nw_conf_in_cuc = TRUE;
    WRRC_MSG0_HIGH("Do not accept new configuration in CUC");
    return TRUE;
  }
  /* 8.3.1.3
     1>if the IE "Cell update cause" is set to "radio link failure" or "RLC Unrecoverable error" and the UE has
     submitted a reconfiguration response message to RLC and the UE has not received the RLC acknowledgement
     for the response message
     2> include the IE "Reconfiguration Status Indicator" and set it to TRUE.
  */
  /*
      For the above case, OC is already cleared and lower layers are configured with Reconfiguration OTA content. So we can accept the new CUC configuraiton.
      Note: "procedure_waiting_for_l2ack" will be true if any reconfig procedure registered with CUC is in wait for L2 ack substate.
            "any_procedure_waiting_for_l2ack" will be true if L2 ack is yet to be received for Reconfiguration complete message. 
  */
  if( ((rrccu_cell_update_cause == rrc_CellUpdateCause_re_enteredServiceArea) && (procedure_waiting_for_l2ack))
      ||((rrccu_cell_update_cause == rrc_CellUpdateCause_radiolinkFailure) && (any_procedure_waiting_for_l2ack))
      ||((rrccu_cell_update_cause == rrc_CellUpdateCause_rlc_unrecoverableError) && (any_procedure_waiting_for_l2ack)))
  {
    return TRUE;
  }
  return FALSE;
}

/*===========================================================================

FUNCTION RRCCU_BUILD_CELL_UPDATE_MSG

DESCRIPTION
  This function builds the CELL UPDATE message with all required
  parameters.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
rrccu_status_e_type rrccu_build_cell_update_msg
(
  rrc_UL_CCCH_Message *msg_ptr,             /* Pointer to uplink CCCH message*/
  rrccu_failure_status_e_type status        /* Indicates whether to include
                                               failure cause or not */
)
{
  uint32 urnti;                             /* Local variable to store U-RNTI */

  rrccu_re_est_timers_status_e_type est_timer_status = rrccu_check_re_est_timers();
  
  rrc_proc_e_type                 proc_id;
  rrcllc_oc_process_state_e_type  process_state;  
  rrcllc_oc_set_status_e_type     oc_status;
  byte start_value[RRC_MAX_START_LENGTH] = {0};


  if(U_RNTI_NOT_PRESENT == rrcllc_get_current_urnti(&urnti) )
  {
    return RRCCU_FAILURE_MINOR;
  }


  if(rrctmr_get_remaining_time(RRCTMR_T_320_TIMER))
  {
    rrctmr_stop_timer(RRCTMR_T_320_TIMER);

    if(rrccu_int_data.cu_cause_for_wait_timer == RRC_UL_DATA_TRANSMISSION)
    {
      /*Though Uplink Data Transfer is highest priority yet calling the mapping function
	  makes code uniform*/
      rrccu_cell_update_cause = rrccu_map_cu_cause_based_on_priority(
            rrccu_map_cu_cause(rrc_CellUpdateCause_uplinkDataTransmission ));
    }
  }

  /*Whether T320 is running or not, we need to reset cu cause for wait timer.
    Once Cell Update is sent, there's no use of remembering cu cause for wait timer.*/
  rrccu_reset_cu_cause_for_wait_timer();


  /* Select the message as CELL UPDATE message */
  msg_ptr->message.t = T_rrc_UL_CCCH_MessageType_cellUpdate;

  /* Initializes the URNTI */
  msg_ptr->message.u.cellUpdate.u_RNTI.srnc_Identity.numbits =  12;

  *(msg_ptr->message.u.cellUpdate.u_RNTI.srnc_Identity.data) = 
    (unsigned char ) ((urnti & 0xFF000000) >> 24); 

  *(msg_ptr->message.u.cellUpdate.u_RNTI.srnc_Identity.data + 1) = 
    (unsigned char ) ((urnti & 0x00F00000) >> 16);

  msg_ptr->message.u.cellUpdate.u_RNTI.s_RNTI.numbits = 20;
  
  *(msg_ptr->message.u.cellUpdate.u_RNTI.s_RNTI.data ) = 
    (unsigned char ) ((urnti & 0x000FF000) >> 12);

  *(msg_ptr->message.u.cellUpdate.u_RNTI.s_RNTI.data + 1) = 
    (unsigned char ) ((urnti & 0x00000FF0) >> 4);

  *(msg_ptr->message.u.cellUpdate.u_RNTI.s_RNTI.data + 2) = 
    (unsigned char ) ((urnti & 0x0000000F) << 4);

  /* Initialize the bit mask not to include the optional fields */
  RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate);

  

  oc_status = rrcllc_get_ordered_config_state_and_proc(&proc_id, &process_state);
  /* Appends START list to the CELL UPDATE message */
  if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL6)
  {
    #ifdef FEATURE_SMC_APPEND_ACTIVE_CN_DOMAIN_START_IN_CU
    (void)rrcsmc_append_start_list_per_active_domain(
        &msg_ptr->message.u.cellUpdate.startList,
        RRCSMC_EXTRACT_AND_APPEND_START
    );
    #else
    if((TRUE == rrcllc_reconfig_in_progress()) &&
       (oc_status != OC_NOT_SET) &&
       (proc_id == RRC_PROCEDURE_RBE) &&
       (RRCRB_WAIT_FOR_CELL_UPDATE_CNF == rrcrbe_get_current_sub_state()) &&
       (TRUE == rrcsmc_get_start_value_to_transmit_flag_status()))
    {
      if(TRUE == rrcsmc_get_calc_start_value(start_value))
      {
        (void) rrcsmc_append_start_list_with_already_computed_start(
            msg_ptr->message.u.cellUpdate.startList,
            start_value, 
            RRCSMC_EXTRACT_AND_APPEND_START);
      }
      else
      {
        (void) rrcsmc_append_start_list(
            msg_ptr->message.u.cellUpdate.startList,
            RRCSMC_EXTRACT_AND_APPEND_START);
      }
    }
    else
    {
      (void) rrcsmc_append_start_list(
          msg_ptr->message.u.cellUpdate.startList,
          RRCSMC_EXTRACT_AND_APPEND_START);
    }
    #endif
  }
  else
  {
    if((TRUE == rrcllc_reconfig_in_progress()) &&
       (oc_status != OC_NOT_SET) &&
       (proc_id == RRC_PROCEDURE_RBE) &&
       (RRCRB_WAIT_FOR_CELL_UPDATE_CNF == rrcrbe_get_current_sub_state()) &&
       (TRUE == rrcsmc_get_start_value_to_transmit_flag_status()))
    {
      if(TRUE == rrcsmc_get_calc_start_value(start_value))
      {
        (void) rrcsmc_append_start_list_with_already_computed_start(
            &msg_ptr->message.u.cellUpdate.startList,
            start_value, 
            RRCSMC_EXTRACT_AND_APPEND_START);
      }
      else
      {
        (void) rrcsmc_append_start_list(
            &msg_ptr->message.u.cellUpdate.startList,
            RRCSMC_EXTRACT_AND_APPEND_START);
      }
    }
    else
    {
      (void) rrcsmc_append_start_list(
            &msg_ptr->message.u.cellUpdate.startList,
            RRCSMC_EXTRACT_AND_APPEND_START);
    }
  }

  /* update the cause */
  msg_ptr->message.u.cellUpdate.cellUpdateCause = rrccu_cell_update_cause;

  if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5)
  {
    rrccu_fill_est_cause(msg_ptr);
  }

#ifdef FEATURE_QCHAT
  if(qchatupk_wcdma_icup_enabled()) /* dynamic flag to check if qchat is loaded and active on the handset */
  {
    //below function will also do the entire qchat processing for estab cause
    qchatupk_rrccu_process_est_cause(msg_ptr);
  }
#endif

  /* Initializde RLC Error Indications */

  msg_ptr->message.u.cellUpdate.am_RLC_ErrorIndicationRb2_3or4 = 
    rrccu_rlc_error_info.error_on_srb;
  msg_ptr->message.u.cellUpdate.am_RLC_ErrorIndicationRb5orAbove =
  rrccu_rlc_error_info.error_on_urb;

  /* Initialize RB Timer Indicators */
  if ( ((rrccu_failure_state == RRC_STATE_CELL_DCH) &&
        (rrccu_rl_failure_info.t314_info.timer_status == RE_EST_TIMER_EXPIRED)) ||
        ((rrctmr_get_remaining_time(RRCTMR_T_314_TIMER) == 0) &&
          (est_timer_status == RRCCU_T314_ZERO || est_timer_status == RRCCU_T314_T315_ZERO)
        )
     )
  {
    msg_ptr->message.u.cellUpdate.rb_timer_indicator.t314_expired = TRUE;
  }
  else
  {
    msg_ptr->message.u.cellUpdate.rb_timer_indicator.t314_expired = FALSE;
  }
  if ( ((rrccu_failure_state == RRC_STATE_CELL_DCH) &&
        (rrccu_rl_failure_info.t315_info.timer_status == RE_EST_TIMER_EXPIRED)) ||
        ((rrctmr_get_remaining_time(RRCTMR_T_315_TIMER) == 0) &&
          (est_timer_status == RRCCU_T315_ZERO || est_timer_status == RRCCU_T314_T315_ZERO)
        )
    )
  {
    msg_ptr->message.u.cellUpdate.rb_timer_indicator.t315_expired = TRUE;
  }
  else
  {
    msg_ptr->message.u.cellUpdate.rb_timer_indicator.t315_expired = FALSE;
  }

  /* Function call to Measurement Control & Report procedure. */
  if(RRCMEAS_RACH_SUCCESSFUL == rrcmeas_append_meas_rpt_on_rach(
    &msg_ptr->message.u.cellUpdate.measuredResultsOnRACH, RRC_PROCEDURE_CU, FALSE))
  {
    /* if Measurement Control & Reportprocedure returns RRC_MEAS_RACH_SUCCESFUL,
     * then enable the  bit_mask field */
    RRC_MSG_COMMON_SET_BITMASK_IE(msg_ptr->message.u.cellUpdate,
    rrc_CellUpdate,measuredResultsOnRACH);
   
  }
  else
  {
    /*"Measured Results on RACH" IE is optional, if Measurement Control & Report
    procedure returns other than RRC_MEAS_RACH_SUCCESFUL, then disable the
    bit_mask field */
    WRRC_MSG0_HIGH("Measured Results on RACH is not appended");
  } 

  if((rrccu_cell_update_cause == rrc_CellUpdateCause_uplinkDataTransmission)&&(rrctvm_is_traffic_volume_indicator_to_be_set_in_cu()))
  {
    rrccu_set_tvm_ind_in_cu(msg_ptr);
  }

#ifdef FEATURE_WCDMA_INTER_FREQ_RACH_REPORTING
#error code not present
#endif /*FEATURE_WCDMA_INTER_FREQ_RACH_REPORTING*/

  if(rrccu_should_rsi_be_included() == TRUE)
  {
   /* The following bitmask may already be set earlier */
   if(!(RRC_MSG_COMMON_BITMASK_IE(msg_ptr->message.u.cellUpdate,
         rrc_CellUpdate,laterNonCriticalExtensions)))
   {
     RRC_MSG_COMMON_SET_BITMASK_IE(msg_ptr->message.u.cellUpdate,
       rrc_CellUpdate,laterNonCriticalExtensions);
     
     RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions);
   }
  
    /* The following bitmask may already be set earlier */
   if(!(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.m.
   	 v590NonCriticalExtensionsPresent))
   {
     msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.m.v590NonCriticalExtensionsPresent =1;
     
     RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.
       v590NonCriticalExtensions);
     RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.cellUpdate_v590ext);
   }
  
   if(!(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.m.
   	v690NonCriticalExtensionsPresent))
   {
      msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.
       v590NonCriticalExtensions.m.v690NonCriticalExtensionsPresent =1;
     
     RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.
       v690NonCriticalExtensions);
     RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.
     v690NonCriticalExtensions.cellUpdate_v690ext);
   
   }
   RRC_MSG_COMMON_SET_BITMASK_IE_TYPE2(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.
     v690NonCriticalExtensions.cellUpdate_v690ext, reconfigurationStatusIndicator);
   
   msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.
     v690NonCriticalExtensions.cellUpdate_v690ext.reconfigurationStatusIndicator = 
     rrc_CellUpdate_v690ext_IEs_reconfigurationStatusIndicator_true;
   rrc_qsh_reconfig_status_ind = 1;
  }
 

  {
    boolean process_non_critcal_ext =FALSE;
    if( (l1_get_mobility_info()) &&
        (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL7))
    {
      process_non_critcal_ext = TRUE;
    }
    if(process_non_critcal_ext)
    {
      if (!(RRC_MSG_COMMON_BITMASK_IE(msg_ptr->message.u.cellUpdate,
            rrc_CellUpdate,laterNonCriticalExtensions))) 
      {
        RRC_MSG_COMMON_SET_BITMASK_IE(msg_ptr->message.u.cellUpdate,
          rrc_CellUpdate,laterNonCriticalExtensions);
        RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions);
      }
   
      if(!(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.m.
           v590NonCriticalExtensionsPresent))
      {
        msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.m.v590NonCriticalExtensionsPresent =1;

		RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions);
        RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.cellUpdate_v590ext);
      }
  
      if(!(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.m.
	  	v690NonCriticalExtensionsPresent))
      {
        msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.
          m.v690NonCriticalExtensionsPresent = 1;
        RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.
          v690NonCriticalExtensions);
        RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.
          v690NonCriticalExtensions.cellUpdate_v690ext);
      }
    }
  }

  if( rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL7)
  {
    /* The following bitmask may already be set earlier */
    if(!(RRC_MSG_COMMON_BITMASK_IE(msg_ptr->message.u.cellUpdate,
     	     rrc_CellUpdate,laterNonCriticalExtensions)))
    {
       RRC_MSG_COMMON_SET_BITMASK_IE(msg_ptr->message.u.cellUpdate, 
        rrc_CellUpdate,laterNonCriticalExtensions);
    
      RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions);
    }

    if(!(RRC_MSG_COMMON_BITMASK_IE_TYPE2(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions,
        cellUpdate_r3_add_ext
        )))
    {
      RRC_MSG_COMMON_SET_BITMASK_IE_TYPE2(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions,
        cellUpdate_r3_add_ext);
    }
  
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.cellUpdate_r3_add_ext);
    msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.
     cellUpdate_r3_add_ext.cellUpdate_v7e0ext.m.supportForTwoDRXSchemesInPCHPresent = 1;
  
    msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.
     	cellUpdate_r3_add_ext.cellUpdate_v7e0ext.supportForTwoDRXSchemesInPCH = 
     	rrc_CellUpdate_v7e0ext_IEs_supportForTwoDRXSchemesInPCH_true;

    if((l1_get_mobility_info())&&
      (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL7))
    {
#ifdef FEATURE_WCDMA_REL7_SPECRS  
      rrccu_populate_mobility_info_in_cu(msg_ptr);
#else  /*FEATURE_WCDMA_REL7_SPECRS*/
      WRRC_MSG0_ERROR("High Mobility Ind from L1 not supported.");
#endif /*FEATURE_WCDMA_REL7_SPECRS*/
    }
    else
    {
      WRRC_MSG0_HIGH("High Mobility not Detected from L1 hence not indicated in CU");
    }

#ifdef FEATURE_WCDMA_HS_FACH
  if(rrcenhstate_nv_supports_e_fach() == TRUE)
  {
    rrccu_populate_enh_state_info_in_cu(msg_ptr);
  }
#endif /*FEATURE_WCDMA_HS_FACH*/

  }
  if( rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL8)
  {
#ifdef FEATURE_MAC_I
    if(rrcueci_nv_supports_mac_i() == TRUE)
    {
      rrccu_populate_maci_info_in_cu(msg_ptr);
    }
#endif /* FEATURE_MAC_I */
#ifdef FEATURE_WCDMA_HS_RACH
  if(rrchsrach_nv_supports_hs_rach() == TRUE)
  {
    rrccu_populate_hsrach_info_in_cu(msg_ptr);
  }
#endif /* FEATURE_WCDMA_HS_RACH */
  }

  /* This spec CR is early implementable for REl9*/
  if( rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL9)
  {
    rrccu_populate_security_revert_status_in_cu(msg_ptr);
  }
  if( status == RRCCU_INCLUDE_FAILURE_CAUSE)
  {
    RRC_MSG_COMMON_SET_BITMASK_IE_TYPE2(msg_ptr->message.u.cellUpdate, failureCause);
    msg_ptr->message.u.cellUpdate.failureCause = rrccu_failure_cause;

	/*log error*/
      rrc_log_protocol_error( (uint8) (rrc_get_state()),
                              (uint8)RRC_PROCEDURE_CU,
                              (uint8) rrccu_failure_cause.failureCause.t,
                              (uint8) ((rrccu_failure_cause.failureCause.t == T_rrc_FailureCauseWithProtErr_protocolError) 
                              ? rrccu_failure_cause.failureCause.u.protocolError->diagnosticsType.u.type1->protocolErrorCause
                              : RRCLOG_PROTOCOL_ERROR_NA)
                            );

    /* NULL dangling pointers inside rrccu_failure_cause */
    if(rrccu_failure_cause.failureCause.t == T_rrc_FailureCauseWithProtErr_protocolError)
    {
      // IS IT A MEMORY LEAK????
      rrccu_failure_cause.failureCause.u.protocolError = NULL;
    }
  }                                  

#ifdef FEATURE_QSH_EVENT_METRIC
  /*    uint8 cell_update_cause;
    uint8 est_cause;
    uint8 rsi;
    uint8 rue_on_srb; 
    uint8 rue_on_drb; 
    uint8 security_revert_status;
    uint8 failure_cause;
    uint8 t314_expired:1;
    uint8 t315_expired:1;
  
  */
  if(rrc_qsh_dl_committed == FALSE)
  {
    failure_ota.ul_ota_type = RRC_OTA_CU;
    failure_ota.msg_id = WRRC_UL_CCCH_MESSAGETYPE_CELLUPDATE;
    failure_ota.ul_fail_ota.cu_params.cell_update_cause =msg_ptr->message.u.cellUpdate.cellUpdateCause;
    failure_ota.ul_fail_ota.cu_params.failure_cause = msg_ptr->message.u.cellUpdate.failureCause.failureCause.t;
    failure_ota.ul_fail_ota.cu_params.rue_on_srb= msg_ptr->message.u.cellUpdate.am_RLC_ErrorIndicationRb2_3or4;
    failure_ota.ul_fail_ota.cu_params.rue_on_drb= msg_ptr->message.u.cellUpdate.am_RLC_ErrorIndicationRb5orAbove;
    failure_ota.ul_fail_ota.cu_params.t314_expired = msg_ptr->message.u.cellUpdate.rb_timer_indicator.t314_expired;
    failure_ota.ul_fail_ota.cu_params.t315_expired = msg_ptr->message.u.cellUpdate.rb_timer_indicator.t315_expired;
    failure_ota.ul_fail_ota.cu_params.est_cause= rrc_qsh_establishment_cause;
    failure_ota.ul_fail_ota.cu_params.rsi= rrc_qsh_reconfig_status_ind;
    failure_ota.ul_fail_ota.cu_params.security_revert_status= rrc_qsh_security_revert_status;
  }
  else if(rrc_qsh_metric_db[WRRC_QSH_METRIC_OTA].data_ptr != NULL)
  {
    ((wrrc_qsh_metric_ota_s*)rrc_qsh_metric_db[WRRC_QSH_METRIC_OTA].data_ptr)->ota_info.cu_params.failure_cause = 0;
    ((wrrc_qsh_metric_ota_s*)rrc_qsh_metric_db[WRRC_QSH_METRIC_OTA].data_ptr)->ota_info.cu_params.cell_update_cause= msg_ptr->message.u.cellUpdate.cellUpdateCause;
    ((wrrc_qsh_metric_ota_s*)rrc_qsh_metric_db[WRRC_QSH_METRIC_OTA].data_ptr)->ota_info.cu_params.rue_on_srb= msg_ptr->message.u.cellUpdate.am_RLC_ErrorIndicationRb2_3or4;
    ((wrrc_qsh_metric_ota_s*)rrc_qsh_metric_db[WRRC_QSH_METRIC_OTA].data_ptr)->ota_info.cu_params.rue_on_drb= msg_ptr->message.u.cellUpdate.am_RLC_ErrorIndicationRb5orAbove;  
    ((wrrc_qsh_metric_ota_s*)rrc_qsh_metric_db[WRRC_QSH_METRIC_OTA].data_ptr)->ota_info.cu_params.t314_expired = msg_ptr->message.u.cellUpdate.rb_timer_indicator.t314_expired;
    ((wrrc_qsh_metric_ota_s*)rrc_qsh_metric_db[WRRC_QSH_METRIC_OTA].data_ptr)->ota_info.cu_params.t315_expired = msg_ptr->message.u.cellUpdate.rb_timer_indicator.t315_expired;
    ((wrrc_qsh_metric_ota_s*)rrc_qsh_metric_db[WRRC_QSH_METRIC_OTA].data_ptr)->ota_info.cu_params.est_cause= rrc_qsh_establishment_cause;
    ((wrrc_qsh_metric_ota_s*)rrc_qsh_metric_db[WRRC_QSH_METRIC_OTA].data_ptr)->ota_info.cu_params.rsi= rrc_qsh_reconfig_status_ind;
    ((wrrc_qsh_metric_ota_s*)rrc_qsh_metric_db[WRRC_QSH_METRIC_OTA].data_ptr)->ota_info.cu_params.security_revert_status= rrc_qsh_security_revert_status;
  }
#endif
  rrc_qsh_establishment_cause = 0xFF;
  rrc_qsh_reconfig_status_ind = 0xFF;
  rrc_qsh_security_revert_status = 0xFF;
    
  return RRCCU_SUCCESS;
} /* rrccu_build_cell_update_msg  */

/*===========================================================================

FUNCTION rrccu_send_cell_update_msg

DESCRIPTION

  This function builds the CELL UPDATE message and enqueues the same in the 
  Uplink queue. Also starts the timer T302.
  
DEPENDENCIES


RETURN VALUE
  rrccu_status_e_type: returns RRCCU_SUCCESS if it successfully enqueues
  CELL UPDATE message in the Uplink queue. Otherwise it returns
  RRCCU_FAILURE_MAJOR

SIDE EFFECTS

  None

===========================================================================*/
rrccu_status_e_type rrccu_send_cell_update_msg
(    
  rlc_lc_id_type ul_lc_id,                 /* Logical Channel Id */
  rrccu_failure_status_e_type status       /* Indicates whether to include
                                              failure cause or not */
)
{
  rrccu_status_e_type local_status = RRCCU_FAILURE_MAJOR; 
                                            /* Status is initialized to
                                               Failure */
  rrc_UL_CCCH_Message *msg_ptr;             /* Pointer to uplink CCCH message*/

#ifdef FEATURE_QCHAT
  if (qchatupk_wcdma_imo_enabled())
  {
    qchatupk_send_cell_update_status qchat_scu_status; // For lint fix.

    qchat_scu_status = qchatupk_process_send_cell_update_msg();
	WRRC_MSG1_HIGH("QCHAT send CU status: %d [DEFER, ABORT, SEND]", qchat_scu_status);
    switch(qchat_scu_status)
    {
      case QCHATUPK_DEFER_CU:
      {
        return RRCCU_SUCCESS;
      }
      case QCHATUPK_ABORT_CU:
      {
        return RRCCU_FAILURE_MAJOR;
      }
      case QCHATUPK_SEND_CU:
      {
        break;
      }
      default:
        // fall through
        break;
    }
  }
#endif /*FEATURE_QCHAT*/

  /* Allocate a buffer for an uplink CCCH Message. This buffer should be 
     released by rrcsend_send_ul_sdu() function */

  msg_ptr = (rrc_UL_CCCH_Message *) rrc_malloc ( 
                                    sizeof(struct rrc_UL_CCCH_Message));

    if (RRCCU_FAILURE_MINOR == rrccu_build_cell_update_msg(msg_ptr, status))
    {
      rrc_free(msg_ptr);
      return local_status;
    }
    /* This places SDU into RLC watermark queue */
    if(RRCSEND_SUCCESS == 
       rrcsend_send_ul_sdu(RRC_PROCEDURE_CU,msg_ptr,ul_lc_id,
       RRCSEND_L2ACK_NOT_REQUIRED) )
    {

      rrccu_log_cu_status(RRC_CU_UU_STATUS_START|RRC_CU_UU_STATUS_RESEND, TRUE);

      MSG_HIGH("Cell Update sent,Cause %d, V302 %d, N302 %d", 
               rrccu_cell_update_cause, rrc_v_302, RRC_GET_N302());
      /* start the timer T302 with 10s so that this will be a recovery if lower layers 
         are stuck*/
      /* this is equivalent to stopping T302 if already running */
      rrctmr_start_timer(RRCTMR_T_302_TIMER, RRC_CU_T302_RECOVERY_TMR);    
      /* Increment re-transmission counter */
      rrc_v_302++;

      /*clear Transaction Id */
      rrccu_trans_id = RRCCU_INVALID_TRANSACTION_ID;
  
      local_status = RRCCU_SUCCESS;
      /* Reset buffered commands mask*/
      rrccu_buffered_cmd_mask = 0;
      memset(&rrccu_buffered_cu_initiate_req,0,sizeof(rrc_initiate_cu_req_type));

  }     

  /* If due some race conditions, RB is not released because of T314/T315 expiry, it will be released when sending CU */
  /* Race conditions: After RL failure, when waiting for CUC, OOS/reselection or CU is triggered due to any other cause and T314/T315 expired */
  rrccu_check_re_est_timer_status();

  if(local_status != RRCCU_SUCCESS)
  {
    WRRC_MSG0_ERROR("Failed to xmit Cell Update Msg");
  }

  return (local_status);            

} /* rrccu_send_cell_update_msg */

/*===========================================================================
FUNCTION rrccu_log_cu_status

DESCRIPTION   This function logs the CU status for START, RESEND, SUCCESS and FAILURE cases each
              with appropriate CU cause and failure caus.

DEPENDENCIES  None

RETURN VALUE  None

SIDE EFFECTS  None
===========================================================================*/
void rrccu_log_cu_status(rrc_cu_uu_status_e_type cu_status, boolean is_cu)
{

  rrc_cu_uu_status_event_type cu_status_event;

  if(cu_status == RRC_CU_UU_STATUS_SUCCESS)
  {
    cu_status_event.status = RRC_CU_UU_STATUS_SUCCESS;
    cu_status_event.cu_cause = RRC_CU_UU_CAUSE_NONE;
    cu_status_event.failure_cause = RRC_CU_UU_FAILURE_CAUSE_NONE;
  }
  else if(cu_status == RRC_CU_UU_STATUS_FAILURE)
  {
    cu_status_event.status = RRC_CU_UU_STATUS_FAILURE;
    cu_status_event.cu_cause = RRC_CU_UU_CAUSE_NONE;
    cu_status_event.failure_cause = RRC_CU_UU_TX_TO_IDLE;
  }/* RESEND or START depends on 'rrc_cu_uu_event_started' */
  else if(rrc_cu_uu_log_event_started == FALSE)
  {
    cu_status_event.status = RRC_CU_UU_STATUS_START;
    cu_status_event.cu_cause = rrccu_map_cu_uu_cause_for_event_logging(is_cu);
    cu_status_event.failure_cause = RRC_CU_UU_FAILURE_CAUSE_NONE;
    rrc_cu_uu_log_event_started = TRUE;
  }
  else
  {
    cu_status_event.status = RRC_CU_UU_STATUS_RESEND;
    cu_status_event.cu_cause = rrccu_map_cu_uu_cause_for_event_logging(is_cu);
    cu_status_event.failure_cause = rrccu_get_cu_uu_failure_cause_for_event_logging(is_cu);
  }
  if(rrc_cu_uu_log_event_started == TRUE)
  {
    event_report_payload(EVENT_WCDMA_RRC_CU_STATUS, sizeof(cu_status_event),(void *)&cu_status_event);
  }
  if((cu_status == RRC_CU_UU_STATUS_SUCCESS) || (cu_status == RRC_CU_UU_STATUS_FAILURE))
  {
    rrc_cu_uu_log_event_started = FALSE;
    rrc_cu_uu_log_event_failure_cause = RRC_CU_UU_FAILURE_CAUSE_NONE;
  }
}
/*===========================================================================
FUNCTION   rrccu_map_cu_uu_cause_for_event_logging

DESCRIPTION   This function maps the CU and UU legacy causes to rrc_cu_uu_cause_e_type type for event logging

DEPENDENCIES  None

RETURN VALUE  rrc_cu_uu_cause_e_type

SIDE EFFECTS  None
===========================================================================*/
rrc_cu_uu_cause_e_type rrccu_map_cu_uu_cause_for_event_logging(boolean is_cu)
{

  rrc_cu_uu_cause_e_type event_cu_uu_cause = RRC_CU_UU_CAUSE_NONE;

  if(TRUE == is_cu)
  {
    if(rrccu_cell_update_cause == rrc_CellUpdateCause_cellReselection)
    {
      event_cu_uu_cause = RRC_CU_CELL_RESELECTION;
    }
    else if(rrccu_cell_update_cause == rrc_CellUpdateCause_periodicalCellUpdate)
    {
      event_cu_uu_cause = RRC_CU_PERIODIC_CELL_UPDATE;
    }
    else if(rrccu_cell_update_cause == rrc_CellUpdateCause_uplinkDataTransmission)
    {
      event_cu_uu_cause = RRC_CU_UL_DATA_TRANSMISSION;
    }
    else if(rrccu_cell_update_cause == rrc_CellUpdateCause_utran_pagingResponse)
    {
      event_cu_uu_cause = RRC_CU_PAGING_RESPONSE;
    }
    else if(rrccu_cell_update_cause == rrc_CellUpdateCause_re_enteredServiceArea)
    {
      event_cu_uu_cause = RRC_CU_REENTERED_SERVICE_AREA;
    }
    else if(rrccu_cell_update_cause == rrc_CellUpdateCause_radiolinkFailure)
    {
      event_cu_uu_cause = RRC_CU_RADIO_LINK_FAILURE;
    }
    else if(rrccu_cell_update_cause == rrc_CellUpdateCause_rlc_unrecoverableError)
    {
      event_cu_uu_cause = RRC_CU_UNRECOVERABLE_ERROR;
    }
  }
  else
  {
    if(rrccu_ura_update_cause == rrc_URA_UpdateCause_changeOfURA)
    {    
      event_cu_uu_cause = RRC_UU_URA_RESELECTION;
    }
    else if(rrccu_ura_update_cause == rrc_URA_UpdateCause_periodicURAUpdate)
    {
      event_cu_uu_cause = RRC_UU_PERIODIC_URA_UPDATE;
    }
  }
	return event_cu_uu_cause;
}
/*===========================================================================
FUNCTION   rrccu_get_cu_uu_failure_cause_for_event_logging

DESCRIPTION   This function maps the CU and UU legacy failure causes to rrc_cu_uu_failure_cause_e_type type for event logging

DEPENDENCIES  None

RETURN VALUE  rrc_cu_uu_failure_cause_e_type

SIDE EFFECTS  None
===========================================================================*/
rrc_cu_uu_failure_cause_e_type rrccu_get_cu_uu_failure_cause_for_event_logging(boolean is_cu)
{
  rrc_cu_uu_failure_cause_e_type event_cu_uu_failure_cause = RRC_CU_UU_FAILURE_CAUSE_NONE;
  if(is_cu == TRUE)
  {
    if(rrccu_failure_cause.failureCause.t == T_rrc_FailureCauseWithProtErr_configurationUnsupported)
    {
      event_cu_uu_failure_cause = RRC_CU_UU_UNSUPPORTED_CONFIG;
    }
    else if(rrccu_failure_cause.failureCause.t == T_rrc_FailureCauseWithProtErr_invalidConfiguration)
    {
      event_cu_uu_failure_cause = RRC_CU_UU_INVALID_CONFIG;
    }
    else if(rrccu_failure_cause.failureCause.t == T_rrc_FailureCauseWithProtErr_incompatibleSimultaneousReconfiguration)
    {
      event_cu_uu_failure_cause = RRC_CU_UU_INCOMPATIBLE_SIMULTANEOUS_RECFG;
    }
    else if(rrccu_failure_cause.failureCause.t == T_rrc_FailureCauseWithProtErr_protocolError)
    {
      event_cu_uu_failure_cause = RRC_CU_UU_PROTOCOL_ERROR;
    }
  }
  else if(rrccu_uu_failure_cause.t == T_rrc_ProtocolErrorIndicatorWithMoreInfo_errorOccurred)
  {
    event_cu_uu_failure_cause = RRC_CU_UU_PROTOCOL_ERROR;
  }
  if(event_cu_uu_failure_cause == RRC_CU_UU_FAILURE_CAUSE_NONE)
  {
    if((rrc_cu_uu_log_event_failure_cause == RRC_CU_UU_T302_EXPIRED) || (rrc_cu_uu_log_event_failure_cause == RRC_CU_UU_INVALID_CONFIG))
    {
      event_cu_uu_failure_cause = rrc_cu_uu_log_event_failure_cause;
    } 				
    else
    {
      event_cu_uu_failure_cause = RRC_CU_UU_ANOTHER_CU_INITIATED;
    }
  }
  rrc_cu_uu_log_event_failure_cause = RRC_CU_UU_FAILURE_CAUSE_NONE;
  return event_cu_uu_failure_cause;
}


/*===========================================================================

FUNCTION RRCCU_BUILD_URA_UPDATE_MSG

DESCRIPTION
  This function builds the URA UPDATE message with all required
  parameters.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
static void rrccu_build_ura_update_msg
(
rrc_UL_CCCH_Message *msg_ptr,             /* Pointer to uplink CCCH message*/
rrccu_failure_status_e_type status        /* Indicates whether to include
                                             failure cause or not */
)
{
  uint32 urnti;                             /* Local variable to store U-RNTI */

  /* Select the message as URA UPDATE message */
  msg_ptr->message.t = T_rrc_UL_CCCH_MessageType_uraUpdate;  

  /* Initializes the URNTI */
  msg_ptr->message.u.uraUpdate.u_RNTI.srnc_Identity.numbits = 12;

  if (U_RNTI_NOT_PRESENT == rrcllc_get_current_urnti(&urnti) )
  {
    ERR_FATAL("URNTI is not present",0,0,0);
  }

  *(msg_ptr->message.u.uraUpdate.u_RNTI.srnc_Identity.data) = 
  (unsigned char ) ((urnti & 0xFF000000) >> 24); 

  *(msg_ptr->message.u.uraUpdate.u_RNTI.srnc_Identity.data + 1) = 
  (unsigned char ) ((urnti & 0x00F00000) >> 16);

  msg_ptr->message.u.uraUpdate.u_RNTI.s_RNTI.numbits = 20;

  *(msg_ptr->message.u.uraUpdate.u_RNTI.s_RNTI.data ) = 
  (unsigned char ) ((urnti & 0x000FF000) >> 12);

  *(msg_ptr->message.u.uraUpdate.u_RNTI.s_RNTI.data + 1) = 
  (unsigned char ) ((urnti & 0x00000FF0) >> 4);

  *(msg_ptr->message.u.uraUpdate.u_RNTI.s_RNTI.data + 2) = 
  (unsigned char ) ((urnti & 0x0000000F) << 4);

  /* Initialize the bit mask not to include the optional fields */
  RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.uraUpdate);

  /* Initialize ura update cause */
  msg_ptr->message.u.uraUpdate.ura_UpdateCause = rrccu_ura_update_cause;

  if ( status == RRCCU_INCLUDE_FAILURE_CAUSE)
  {
    msg_ptr->message.u.uraUpdate.protocolErrorIndicator = rrccu_uu_failure_cause;
  }
  else
  {
    msg_ptr->message.u.uraUpdate.protocolErrorIndicator.t = T_rrc_ProtocolErrorIndicatorWithMoreInfo_noError;
  }

  if( rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL7)
  {
   /* The following bitmask may already be set earlier */
   if(!(RRC_MSG_COMMON_BITMASK_IE(msg_ptr->message.u.uraUpdate,
         rrc_URAUpdate,laterNonCriticalExtensions)))
   {
     RRC_MSG_COMMON_SET_BITMASK_IE(msg_ptr->message.u.uraUpdate,
       rrc_URAUpdate,laterNonCriticalExtensions);
     
     RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.uraUpdate.laterNonCriticalExtensions);
   }

   if(!(RRC_MSG_COMMON_BITMASK_IE_TYPE2(msg_ptr->message.u.uraUpdate.laterNonCriticalExtensions,
       uraUpdate_r3_add_ext)))
   {
     RRC_MSG_COMMON_SET_BITMASK_IE_TYPE2(msg_ptr->message.u.uraUpdate.laterNonCriticalExtensions,
       uraUpdate_r3_add_ext);
   }   

   RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.uraUpdate.laterNonCriticalExtensions.
     uraUpdate_r3_add_ext);
      
   RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.uraUpdate.laterNonCriticalExtensions.
    uraUpdate_r3_add_ext.uraUpdate_v7e0ext);

   msg_ptr->message.u.uraUpdate.laterNonCriticalExtensions.
    uraUpdate_r3_add_ext.uraUpdate_v7e0ext.m.supportForTwoDRXSchemesInPCHPresent = 1;
  
   msg_ptr->message.u.uraUpdate.laterNonCriticalExtensions.uraUpdate_r3_add_ext.uraUpdate_v7e0ext.
    supportForTwoDRXSchemesInPCH = rrc_URAUpdate_v7e0ext_IEs_supportForTwoDRXSchemesInPCH_true;

  }

#ifdef FEATURE_WCDMA_HS_FACH
  if(rrcenhstate_nv_supports_e_fach() == TRUE)
  {
    RRC_MSG_COMMON_SET_BITMASK_IE_TYPE2(msg_ptr->message.u.uraUpdate, laterNonCriticalExtensions);
    RRC_MSG_COMMON_SET_BITMASK_IE_TYPE2(msg_ptr->message.u.uraUpdate.laterNonCriticalExtensions, v770NonCriticalExtensions);
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.uraUpdate.laterNonCriticalExtensions.v770NonCriticalExtensions);
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.uraUpdate.laterNonCriticalExtensions.v770NonCriticalExtensions.uraUpdate_v770ext);
  
    RRC_MSG_COMMON_SET_BITMASK_IE_TYPE2(msg_ptr->message.u.uraUpdate.laterNonCriticalExtensions.v770NonCriticalExtensions.uraUpdate_v770ext, 
      support_hsdschReception_CellFach);
    msg_ptr->message.u.uraUpdate.laterNonCriticalExtensions.v770NonCriticalExtensions.uraUpdate_v770ext.support_hsdschReception_CellFach = 
       rrc_UraUpdate_v770ext_IEs_support_hsdschReception_CellFach_true;
  
#ifdef FEATURE_WCDMA_HS_FACH_DRX
      if (rrcenhstate_nv_supports_e_fach_drx())
      {
        msg_ptr->message.u.uraUpdate.laterNonCriticalExtensions.v770NonCriticalExtensions.m.v860NonCriticalExtensionsPresent = 1;

        RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.uraUpdate.laterNonCriticalExtensions.v770NonCriticalExtensions.
        v860NonCriticalExtensions.uraUpdate_v860ext);
        
        msg_ptr->message.u.uraUpdate.laterNonCriticalExtensions.v770NonCriticalExtensions.
          v860NonCriticalExtensions.uraUpdate_v860ext.m.supportOfHS_DSCHDRXOperationPresent = 1;
        
        msg_ptr->message.u.uraUpdate.laterNonCriticalExtensions.v770NonCriticalExtensions.
          v860NonCriticalExtensions.uraUpdate_v860ext.supportOfHS_DSCHDRXOperation = rrc_URAUpdate_v860ext_IEs_supportOfHS_DSCHDRXOperation_true;

      }
      
#endif
    }
#endif /*FEATURE_WCDMA_HS_FACH*/
  /*URAUpdate-v860ext has the following IEs in R8.6
  1. supportOfHS-DSCHDRXOperation
  2. supportOfCommonEDCH
  3. supportOfMACiis*/
  /*REL8: URAUpdate-v860ext isn't supported yet*/
  if( rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL8)
  {
#ifdef FEATURE_MAC_I
    if(rrcueci_nv_supports_mac_i() == TRUE)
    {
    if(!(msg_ptr->message.u.uraUpdate.laterNonCriticalExtensions.v770NonCriticalExtensions.m.v860NonCriticalExtensionsPresent))
    {
  
      msg_ptr->message.u.uraUpdate.laterNonCriticalExtensions.v770NonCriticalExtensions.m.v860NonCriticalExtensionsPresent = 1;

      RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.uraUpdate.laterNonCriticalExtensions.v770NonCriticalExtensions.
      v860NonCriticalExtensions.uraUpdate_v860ext);
    }
    
    msg_ptr->message.u.uraUpdate.laterNonCriticalExtensions.v770NonCriticalExtensions.
      v860NonCriticalExtensions.uraUpdate_v860ext.m.supportOfMACiisPresent = 1;
    
    msg_ptr->message.u.uraUpdate.laterNonCriticalExtensions.v770NonCriticalExtensions.
      v860NonCriticalExtensions.uraUpdate_v860ext.supportOfMACiis = rrc_URAUpdate_v860ext_IEs_supportOfMACiis_true;

    }
		
#endif /* FEATURE_MAC_I */
#ifdef FEATURE_WCDMA_HS_RACH
  if(rrchsrach_nv_supports_hs_rach() == TRUE)
    {
      msg_ptr->message.u.uraUpdate.laterNonCriticalExtensions.v770NonCriticalExtensions.
        v860NonCriticalExtensions.uraUpdate_v860ext.m.supportOfCommonEDCHPresent = 1;
      
      msg_ptr->message.u.uraUpdate.laterNonCriticalExtensions.v770NonCriticalExtensions.
        v860NonCriticalExtensions.uraUpdate_v860ext.supportOfCommonEDCH = rrc_URAUpdate_v860ext_IEs_supportOfCommonEDCH_true;
      
    }
#endif /* FEATURE_WCDMA_HS_RACH */
  }
  
} /*rrccu_build_ura_update_msg*/

/*===========================================================================

FUNCTION rrccu_send_ura_update_msg

DESCRIPTION

  This function builds the URA UPDATE message and enqueues the same in the 
  Uplink queue. Also starts the timer T302.
  
DEPENDENCIES


RETURN VALUE
  rrccu_status_e_type: returns RRCCU_SUCCESS if it successfully enqueues
  URA UPDATE message in the Uplink queue. Otherwise it returns
  RRCCU_FAILURE_MAJOR

SIDE EFFECTS

  None

===========================================================================*/
static rrccu_status_e_type rrccu_send_ura_update_msg
(
rlc_lc_id_type ul_lc_id,                 /* Logical Channel Id */
rrccu_failure_status_e_type status       /* Indicates whether to include
                                            failure cause or not */
)
{
  rrccu_status_e_type local_status = RRCCU_FAILURE_MINOR; 
  /* Status is initialized to
     Failure */
  rrc_UL_CCCH_Message *msg_ptr;             /* Pointer to uplink CCCH message*/

  /* Allocate a buffer for an uplink CCCH Message. This buffer should be 
     released by rrcsend_send_ul_sdu() function */

  msg_ptr = (rrc_UL_CCCH_Message *) rrc_malloc (sizeof(struct rrc_UL_CCCH_Message));

    // Build URA update message
    rrccu_build_ura_update_msg(msg_ptr, status); 

    /* This places SDU into RLC watermark queue */
    if (RRCSEND_SUCCESS == rrcsend_send_ul_sdu(RRC_PROCEDURE_UU,msg_ptr,ul_lc_id,
    RRCSEND_L2ACK_NOT_REQUIRED) )
    {
      rrccu_log_cu_status(RRC_CU_UU_STATUS_START | RRC_CU_UU_STATUS_RESEND, FALSE);
      MSG_HIGH("URA Update sent,Cause %d, V302 %d, N302 %d", 
               rrccu_ura_update_cause, rrc_v_302, RRC_GET_N302());
      /* start the timer T302 with 10s so that this will be a recovery if lower layers 
         are stuck*/
      rrctmr_start_timer(RRCTMR_T_302_TIMER,RRC_CU_T302_RECOVERY_TMR);    
      /* Increment re-transmission counter */
      rrc_v_302++;
      /*clear Transaction Id */
      rrccu_trans_id = RRCCU_INVALID_TRANSACTION_ID;
      local_status = RRCCU_SUCCESS;
    }
  if(local_status != RRCCU_SUCCESS)
  {
    WRRC_MSG1_ERROR("local_status: %d, Failed to xmit URA Update Msg",local_status);
  }
  return(local_status);            

} /* rrccu_send_ura_update_msg */


/*===========================================================================

FUNCTION rrccu_send_rrc_initiate_cell_selection_ind

DESCRIPTION
  This function builds RRC_INITIATE_CELL_SELECTION_IND command to post to
  CSP procedure with the cause specified.
DEPENDENCIES
  None

RETURN VALUE
  rrccu_status_e_type: It returns RRCCU_SUCCESS if it successfully sends 
  RRC_INITIATE_CELL_SELECTION_IND command to CSP. Otherwise it returns 
  RRCCU_FAILURE_MAJOR.

SIDE EFFECTS
  None
===========================================================================*/
void  rrccu_send_rrc_initiate_cell_selection_ind
(
  rrc_cell_sel_cause_e_type cause,           /* Cause to trigger Cell
                                                selection */
  rrc_state_e_type destination_state         /* Destination RRC state */
)
{
  rrc_cmd_type *cmd_ptr;                    /* Pointer to the RRC Command */

  if((cause == RRC_OUT_OF_SERVICE_AREA_IND ) && 
     ((destination_state == RRC_STATE_CELL_FACH ) 
        ||(destination_state == RRC_STATE_CELL_PCH )
        ||(destination_state == RRC_STATE_CELL_DCH )
        ||(destination_state == RRC_STATE_URA_PCH ))
        && (rrcdt_check_if_emergency_call_initiated()==TRUE))
  {
  
    /* could not clear OC. go to idle */
      rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                           RRC_TX_TO_DISCON_EM_CALL);
      /* Update the release cause */
      rrc_release_cause = RRC_REL_DEEP_FADE;
      rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
    return;
  }
  /* Allocate memory for RRC_INITIATE_CELL_SELECTION_IND command */
    cmd_ptr =  rrc_get_int_cmd_buf();
    cmd_ptr->cmd_hdr.cmd_id = RRC_INITIATE_CELL_SELECTION_IND;

    /* Fill in parameters for RRC_INITIATE_CELL_SELECTION_IND command */
    cmd_ptr->cmd.initiate_cell_sel_ind.cause = cause;
    cmd_ptr->cmd.initiate_cell_sel_ind.proc  = RRC_PROCEDURE_CU;

    cmd_ptr->cmd.initiate_cell_sel_ind.dest_state = destination_state;
    cmd_ptr->cmd.initiate_cell_sel_ind.dest_freq_present = FALSE;
    cmd_ptr->cmd.initiate_cell_sel_ind.dest_psc_present = FALSE;

    WRRC_MSG2_HIGH("INITIATE_CELL_SELECTION cause:%d, dest_st:%d",
             cause, destination_state);

    rrc_put_int_cmd(cmd_ptr);          /* Sends the command to CSP */

}/*rrccu_send_rrc_initiate_cell_selection_ind */

/*===========================================================================

FUNCTION rrccu_process_rl_failure_for_nonzero_re_est_timers

DESCRIPTION
  This function takes necessary action to handle RL failure scenario when 
  there is non zero re-establishment timer 
DEPENDENCIES
  None

RETURN VALUE
 None

SIDE EFFECTS
  None
===========================================================================*/
static void  rrccu_process_rl_failure_for_nonzero_re_est_timers
(
  void
)
{
  rrcllc_oc_status_e_type                oc_status;/* To hold ordered_config status          */
   /* set the OC here. This should take care race condition due to 
    any reconfig message queued in the command queue */ 
   oc_status = rrcllc_set_ordered_config_for_rl_failure(RRC_PROCEDURE_CU);
   if (oc_status == ORDERED_CONFIG_SET)
   {
     rrccu_oc_set_by_cu = TRUE;
     /* treat this cell selection as if it is normal cell selection going from 
     Cell_DCH to Cell_FACH state*/

     rrccu_send_rrc_initiate_cell_selection_ind(
                                        RRC_TRANSITION_FROM_DCH,
                                        RRC_STATE_CELL_FACH);
     rrccu_substate = RRCCU_WAIT_FOR_UE_TO_CAMP_ON; 

   }
   else
   {
#ifdef FEATURE_WCDMA_HANDLE_MDSP_HALT      
     if(rrccu_mdsp_recov_active)
     {
       return;
     }
#endif    
     /*OC could not be set for some reason. Go to Idle */
     WRRC_MSG1_HIGH("Can not set OC oc_status: rrcllc_oc_set_status_e_type_value%d",oc_status);
     rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU, 
                                          RRC_TX_TO_DISCON_OTHER);
       /* Update the release cause */
       rrc_release_cause = RRC_REL_DEEP_FADE;

       rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
     }
}         /* rrccu_process_rl_failure_for_nonzero_re_est_timer */

/*===========================================================================

FUNCTION rrccu_process_re_est_timers

DESCRIPTION
  This function checks the timers T314 and T315 and releases the RBs
  accordingly and starts Cell Selection to camp-on a suitable cell and 
  transition to CELL_FACH state.
DEPENDENCIES
  None

RETURN VALUE
  None.

SIDE EFFECTS
  None
===========================================================================*/
/*Spec CR 2910 - [UE behaviour in RRC Connection Re-establishment scenarios]
Basically, the intention of this Spec CR is not to release RRC Conn earlier than 
expected. And therefore, it gives more tolerance for error handling of PS RABs.*/
void rrccu_process_re_est_timers
(
  boolean release_connection
)
{
  rrccu_re_est_timers_status_e_type est_timer_status;
  boolean re_est_timer_started = FALSE;
  est_timer_status = rrccu_check_re_est_timers();
  
  if(release_connection == TRUE)
  {
    est_timer_status = RRCCU_T314_T315_ZERO;
    WRRC_MSG0_HIGH("Releasing RRC connection as TA duration is more than re-establishment timer");
  }
  
  switch( est_timer_status )
  {
    case RRCCU_T314_T315_ZERO:
        WRRC_MSG0_HIGH("RRC Conn Released since T314=0 & T315=0");
      break;
    
    case RRCCU_T314_ZERO:  /* t314=0 and t315!=0 */
       /*To comply with Spec CR 2910, if there's no RAB associated with T315 and "only" 
         CS domain is open, the UE goes to Idle mode*/
      if((FALSE == rrc_check_rbs_associated_with_re_est_timer(rrc_Re_EstablishmentTimer_useT315)) && 
           (rrcdt_is_cs_domain_open()) && (!rrcdt_is_ps_domain_open()))
      {
        WRRC_MSG0_HIGH("T314=0, No RABs with T315");
      }
      else
      {
        /* there are RBs associated with T315 which needs to be started. 
         release any RABs associated with T314 */
        rrccu_rl_failure_info.t314_info.timer_status = RE_EST_TIMER_EXPIRED;
        rrccu_rl_failure_info.t314_info.need_to_release_rabs = FALSE;
        if(TRUE == rrc_check_rbs_associated_with_re_est_timer(rrc_Re_EstablishmentTimer_useT314) )
        {
          rrccu_rl_failure_info.t314_info.need_to_release_rabs = TRUE;
        }

        /*To comply with Spec CR 2910, added check whether any RAB associated with T315 or PS 
         domain is open*/
        if(rrc_check_rbs_associated_with_re_est_timer(rrc_Re_EstablishmentTimer_useT315) || 
              rrcdt_is_ps_domain_open())
        {
          WRRC_MSG1_HIGH("T315 started %dms",rrccu_convert_t315_to_ms( RRC_GET_T315() ));
          /* start the re-est timer */
          rrctmr_start_timer(RRCTMR_T_315_TIMER, 
                     rrccu_convert_t315_to_ms( RRC_GET_T315() ) );
          rrccu_rl_failure_info.t315_info.timer_status         = RE_EST_TIMER_STARTED;
          rrccu_rl_failure_info.t315_info.need_to_release_rabs = FALSE;
          re_est_timer_started = TRUE;
        }
      }
      break;

    case RRCCU_T315_ZERO: /* case where T315=0 but T314!=0 */
      rrccu_rl_failure_info.t315_info.timer_status         = RE_EST_TIMER_EXPIRED;
      rrccu_rl_failure_info.t315_info.need_to_release_rabs = FALSE;
      if(TRUE == rrc_check_rbs_associated_with_re_est_timer(rrc_Re_EstablishmentTimer_useT315) )
      {
        rrccu_rl_failure_info.t315_info.need_to_release_rabs = TRUE;
      }

      /*To comply with Spec CR 2910, added check whether any RAB associated with T314 or CS
       domain is open without any RAB associated with T315 */
      if((TRUE == rrc_check_rbs_associated_with_re_est_timer(rrc_Re_EstablishmentTimer_useT314)) ||
        (!rrc_check_rbs_associated_with_re_est_timer(rrc_Re_EstablishmentTimer_useT315) && rrcdt_is_cs_domain_open()))
      {
        WRRC_MSG1_HIGH("T314 started %dms",rrccu_convert_t314_to_ms( RRC_GET_T314() ));
        /* start the re-est timer */
        rrctmr_start_timer(RRCTMR_T_314_TIMER, 
                   rrccu_convert_t314_to_ms( RRC_GET_T314() ) );
        rrccu_rl_failure_info.t314_info.timer_status         = RE_EST_TIMER_STARTED;
        rrccu_rl_failure_info.t314_info.need_to_release_rabs = FALSE;
        re_est_timer_started = TRUE;        
      }
      break;

    case RRCCU_T314_T315_NON_ZERO: /*case where both T314!=0 and T315!=0 */
      /*To comply with Spec CR 2910, added check whether any RAB associated with T315 or 
      PS domain is open */
      
      if( rrc_check_rbs_associated_with_re_est_timer(rrc_Re_EstablishmentTimer_useT315) || rrcdt_is_ps_domain_open())
      {
        rrccu_rl_failure_info.t315_info.timer_status         = RE_EST_TIMER_STARTED;
        rrccu_rl_failure_info.t315_info.need_to_release_rabs = FALSE;
        WRRC_MSG1_HIGH("T315 started %dms",rrccu_convert_t315_to_ms( RRC_GET_T315() ));
        rrctmr_start_timer(RRCTMR_T_315_TIMER, 
                   rrccu_convert_t315_to_ms( RRC_GET_T315() ) );
        re_est_timer_started = TRUE;
      }
      /* check whether any RABs associated with t314 */
      if (TRUE == rrc_check_rbs_associated_with_re_est_timer(rrc_Re_EstablishmentTimer_useT314)) 
      {
        rrccu_rl_failure_info.t314_info.timer_status = RE_EST_TIMER_STARTED;
        rrccu_rl_failure_info.t314_info.need_to_release_rabs = FALSE;
        WRRC_MSG1_HIGH("T314 started %d",rrccu_convert_t314_to_ms( RRC_GET_T314() ));
        rrctmr_start_timer(RRCTMR_T_314_TIMER, 
                   rrccu_convert_t314_to_ms( RRC_GET_T314() ) );
        re_est_timer_started = TRUE;
      }
      /*To comply with Spec CR 2910, added check whether CS domain is open without 
      any RAB associated with T315 */
      else if (( FALSE == rrc_check_rbs_associated_with_re_est_timer(rrc_Re_EstablishmentTimer_useT315)) && 
                rrcdt_is_cs_domain_open())
      {
        rrccu_rl_failure_info.t314_info.timer_status = RE_EST_TIMER_STARTED;
        rrccu_rl_failure_info.t314_info.need_to_release_rabs = FALSE;
        WRRC_MSG1_HIGH("No RABs with T314 or T315, T314 started %dms",
                 rrccu_convert_t314_to_ms( RRC_GET_T314() ));
        rrctmr_start_timer(RRCTMR_T_314_TIMER, 
                   rrccu_convert_t314_to_ms( RRC_GET_T314() ) );
        re_est_timer_started = TRUE;
      }
      break;

    default:
      break;
  }           
  
  /*Process RL failure for Non zero re_est_timers only if any timer is started*/
  if(re_est_timer_started == TRUE)    
  {
    /* CR751026: In the case when T314 or T315 is configured to zero, RAB_RELEASE_IND is sent to RABM only if T315 or T314 timer has started.
    Otherwise the Release indication is sent twice as RCE procedure also sends the release indication after RRC releases the PS RABs when transitioning to disconnected state */

    if(rrccu_rl_failure_info.t314_info.need_to_release_rabs == TRUE) 
    {
	/* Send Rab_rel_ind for rabs assosiated with t314 */
        rrccu_send_rab_rel_ind_for_rbs_associated_with_re_est_timer(rrc_Re_EstablishmentTimer_useT314);   
    }
    else if(rrccu_rl_failure_info.t315_info.need_to_release_rabs == TRUE)
    {
       /* Send Rab_rel_ind for rabs assosiated with t315 */
       rrccu_send_rab_rel_ind_for_rbs_associated_with_re_est_timer(rrc_Re_EstablishmentTimer_useT315);
    }
    /*call the function to process rl failure for non zero re-establishment timer */
    rrccu_process_rl_failure_for_nonzero_re_est_timers();
  }
  else
  {
#ifdef FEATURE_WCDMA_HANDLE_MDSP_HALT      
    if(rrccu_mdsp_recov_active)
    {
      return;
    }
#endif  
    /*Since none of the Timers T314 and T315 were started, UE goes in Idle mode*/
    rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU, 
                                         RRC_TX_TO_DISCON_RL_FAILURE_T314_T315_0);
      /* Update the release cause */
      rrc_release_cause = RRC_REL_DEEP_FADE;
      rrccu_substate    = RRCCU_WAIT_FOR_RB_REL_CNF;
  }
}
/*rrccu_process_re_est_timers */

/*===========================================================================

FUNCTION rrccu_start_t305_or_oos_timer

DESCRIPTION This function starts T305 or OOS timer accordingly
  
DEPENDENCIES
  None

RETURN VALUE
  None.

SIDE EFFECTS
  None
===========================================================================*/
static void rrccu_start_t305_or_oos_timer
(
  void
)
{
  uint32 t_305_timer_in_ms = 0;
  t_305_timer_in_ms = rrc_convert_t305_to_ms(RRC_GET_T305());
  WRRC_MSG0_HIGH("Start T305 or OOS called");
  /* Start min(T305, Toos) */
  /* If remaining T305 is 0, T305 has been stopped or expired */
  if((rrctmr_get_remaining_time(RRCTMR_T_305_TIMER) == 0) && 
                (t_305_timer_in_ms != RRCTMR_INFINITY_VAL ))
  {
   
    if ( t_305_timer_in_ms <= RRCTMR_T_OOS_TIMER_IN_MS) 
    {
         rrccu_start_t_305_timer();   
    }
    else
    {
            rrctmr_start_timer(RRCTMR_T_OOS_TIMER, RRCTMR_T_OOS_TIMER_IN_MS);
    }
  }
  /* If T305 is running, then get the min between the remaing ticks and Toos */
  else if((rrctmr_get_remaining_time(RRCTMR_T_305_TIMER) > RRCTMR_T_OOS_TIMER_IN_MS)
    || (t_305_timer_in_ms == RRCTMR_INFINITY_VAL ))
  {
          rrctmr_start_timer(RRCTMR_T_OOS_TIMER, RRCTMR_T_OOS_TIMER_IN_MS);
  }
}

/*===========================================================================

FUNCTION rrccu_process_oos_area_handling

DESCRIPTION
  This function is called when Cell update is initiated with cause 
  RRC_REENTERED_SERVICE_AREA by CSP.  It triggers out of service area handling.
  
DEPENDENCIES
  None

RETURN VALUE
  None.

SIDE EFFECTS
  None
===========================================================================*/
void rrccu_process_oos_area_handling(void)
{
  rrc_state_e_type curr_state = rrc_get_state();

  uint32 t_316_timer_in_ms = 0;
  rrc_proc_e_type                 proc_id;
  rrcllc_oc_process_state_e_type  process_state;  
  rrcllc_oc_set_status_e_type     oc_status;
  WRRC_MSG2_HIGH("OOS Ind Rcvd in st:%d cu_st:%d",
           curr_state,rrccu_substate);
  event_report(EVENT_WCDMA_OUT_OF_SERVICE);
  
  switch(rrccu_substate)
  {
    case RRCCU_INITIAL:
    /*Handle normal OOS flow for SIB7 waiting substate also.*/
#ifdef FEATURE_UPDATE_SIB7_FOR_PCH_TO_FACH
    case RRCCU_WAIT_FOR_SIB7_CURRENT:
#endif /*FEATURE_UPDATE_SIB7_FOR_PCH_TO_FACH*/
      if (curr_state != RRC_STATE_CELL_DCH) 
      {
        oc_status = rrcllc_get_ordered_config_state_and_proc(&proc_id, &process_state);

        /* Force set the curr rrc state to the destination state from the reconfiguration message.
         * This is so that the right timers are started.
         */

        if (oc_status == OC_SET_FOR_CELL_FACH) 
        {
          curr_state = RRC_STATE_CELL_FACH;
        }
        else if (oc_status == OC_SET_FOR_FACH_CELL_PCH_TRANS) 
        {
          curr_state = RRC_STATE_CELL_PCH;
        }
        else if (oc_status == OC_SET_FOR_FACH_URA_PCH_TRANS) 
        {
          curr_state = RRC_STATE_URA_PCH;
        }
        else
        {
          WRRC_MSG0_HIGH("Not any freq dirsction case ");
        }
        if (RRCCU_SUCCESS != rrccu_validate_rrc_status_for_oos_handling())
        {
          rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU, 
                                               RRC_TX_TO_DISCON_OTHER);
            /* Update the release cause */
            rrc_release_cause = RRC_REL_DEEP_FADE;
            rrccu_substate    = RRCCU_WAIT_FOR_RB_REL_CNF;
          return;
        }
      }
      else
      {
        /* This is OOS case during DCH->FACH\PCH transition
         * First get the active procedure and register it for 
         * cell update complete notification.  Then reset OC, 
         * and start relevant timers.
         */
        
        oc_status = rrcllc_get_ordered_config_state_and_proc(&proc_id, &process_state);

        /* Force set the curr rrc state to the destination state from the reconfiguration message.
         * This is so that the right timers are started.
         */
        if (oc_status == OC_SET_FOR_DCH_FACH_TRANS) 
        {
          curr_state = RRC_STATE_CELL_FACH;
        }
        else if (oc_status == OC_SET_FOR_DCH_CELL_PCH_TRANS) 
        {
          curr_state = RRC_STATE_CELL_PCH;
        }
        else if (oc_status == OC_SET_FOR_DCH_URA_PCH_TRANS) 
        {
          curr_state = RRC_STATE_URA_PCH;
        }
        else
        {
          WRRC_MSG0_ERROR("Transition to invalid state.  Should not occur");
        }

        /* Register the reconfig message for cell update complete indication so it can 
         * proceed processing the ota reconfig msg
         */
        (void)rrccu_register_for_cell_update_to_complete(proc_id);

        /* Reset OC but Set TOC for OOS. TOC will be used once re-entering
           service*/
        (void)rrcllc_reset_ordered_config(RRC_PROCEDURE_CU,FALSE);
        
      }

      /* Update Cell Update cause */
      rrccu_cell_update_cause = 
        rrccu_map_cu_cause_based_on_priority(RRC_REENTERED_SERVICE_AREA);
      
      break;
      
    case RRCCU_WAIT_FOR_UE_TO_CAMP_ON:
      /* remap the cu cause based on the priority */
      WRRC_MSG2_HIGH("OOS Area is ignored in state:%d, cu_state:%d",
               rrc_get_state(),rrccu_substate);
      rrccu_cell_update_cause = 
        rrccu_map_cu_cause_based_on_priority(RRC_REENTERED_SERVICE_AREA);
      return;

    case RRCCU_WAIT_FOR_RB0_EST_CNF:
     /* unregister with RLC for ul data indication   
      It might be too early but we will revisit this */
      if (curr_state == RRC_STATE_CELL_FACH)
      {
        rrccu_unregister_with_rlc_for_ul_data_indication();
      }
      if (rrccu_ura_update_started == TRUE)
      {
        rrccu_ura_update_started = FALSE;
        rrccu_cell_update_started = TRUE;
        /* Update Cell Update cause */
        rrccu_cell_update_cause = rrc_CellUpdateCause_re_enteredServiceArea;
      }
      else
      {
        /* Get the appropriate cell update cause based on priority*/
        rrccu_cell_update_cause = 
          rrccu_map_cu_cause_based_on_priority(RRC_REENTERED_SERVICE_AREA);
      }
      
      break;
      
    case RRCCU_WAIT_FOR_RB1_RB4_EST_CNF:
        /* This is added to make sure OC is reset */
        if (RRCCU_SUCCESS != rrccu_validate_rrc_status_for_oos_handling())
        {
          rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU, 
                                               RRC_TX_TO_DISCON_OTHER);
          /* Update the release cause */
          rrc_release_cause = RRC_REL_DEEP_FADE;
          rrccu_substate    = RRCCU_WAIT_FOR_RB_REL_CNF;
          return;
        }
      rrccu_cell_update_cause = 
        rrccu_map_cu_cause_based_on_priority(RRC_REENTERED_SERVICE_AREA);
      break;
      
    case RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM:
    case RRCCU_WAIT_FOR_URA_UPDATE_CONFIRM:  
      oc_status = rrcllc_get_ordered_config_state_and_proc(&proc_id, &process_state);

      /* If this OOS is during transition from DCH, the set TOC for OOS and handle the
       * OOS. If OOS happens after DCH to FACH timer expires then OC would already have 
         been reset by timer expiry so the below condition is added to set the TOC for OOS.
       */
      if ((oc_status == OC_SET_FOR_DCH_FACH_TRANS) ||
          (oc_status == OC_SET_FOR_DCH_CELL_PCH_TRANS) ||
          (oc_status == OC_SET_FOR_DCH_URA_PCH_TRANS) ||
          ((rrcllc_get_toc_usage_change_oos_to_dch() == TRUE)&&(rrcllc_get_toc_usage()==TOC_FOR_DCH ))) 
      {
        /* Register the reconfig message for cell update complete indication so it can 
         * proceed processing the ota reconfig msg
         */
        (void)rrccu_register_for_cell_update_to_complete(proc_id);

        /* Reset OC but Set TOC for OOS. TOC will be used once re-entering
           service*/
       (void)rrcllc_reset_ordered_config(RRC_PROCEDURE_CU,FALSE);

      }
      else  
      {
        if (RRCCU_SUCCESS != rrccu_validate_rrc_status_for_oos_handling())
        {
          rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU, 
                                               RRC_TX_TO_DISCON_OTHER);
            /* Update the release cause */
          rrc_release_cause = RRC_REL_DEEP_FADE;
          rrccu_substate    = RRCCU_WAIT_FOR_RB_REL_CNF;
          return;
        }
      }

      /*Check if any RABs need to be released due to T314 or T315 expiry*/
      rrccu_check_re_est_timer_status();

        
      rrccu_cell_update_cause = 
        rrccu_map_cu_cause_based_on_priority(RRC_REENTERED_SERVICE_AREA);
      /* purge RLC wm if cu was initiated as a result of OOS */
      rrccu_purge_rlc_wm(TRUE, FALSE);
      /* Stop Timer T302 */
      rrctmr_stop_timer(RRCTMR_T_302_TIMER); 
      /*  ura_update cause must be set to false and cell_update_cause to true */
      rrccu_ura_update_started = FALSE;

      /* If cell update cause is RL failure or RLC reset, we don't want to start OOS timers.
       * Let T314 and T315 take their course. 
       */
      if (rrccu_cell_update_cause == rrc_CellUpdateCause_radiolinkFailure || 
          rrccu_cell_update_cause == rrc_CellUpdateCause_rlc_unrecoverableError) 
      {
        rrccu_send_rrc_initiate_cell_selection_ind(RRC_OUT_OF_SERVICE_AREA_IND,curr_state);        
        rrccu_substate = RRCCU_WAIT_FOR_UE_TO_CAMP_ON;
        return;
      }
      break;

    case RRCCU_WAIT_FOR_RNTI_UPDATE_CNF:

      if (rrccu_cucnf_for_srns_relocation)
      {
        rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                             RRC_TX_TO_DISCON_OTHER);
          /* Update the release cause */
        rrc_release_cause = RRC_REL_DEEP_FADE;  
        rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
        WRRC_MSG0_HIGH("OOS during srns-reloc");
        return;
      }
      else  /* not for srns relocation */
      {
        oc_status = rrcllc_get_ordered_config_state_and_proc(&proc_id, &process_state);
  
        /* If this OOS is during transition from DCH, the set TOC for OOS and handle the
         * OOS.If OOS happens after DCH to FACH timer expires then OC would already have 
         been reset by timer expiry so the below condition is added to set the TOC for OOS.
         */
        if ((oc_status == OC_SET_FOR_DCH_FACH_TRANS) ||
            (oc_status == OC_SET_FOR_DCH_CELL_PCH_TRANS) ||
            (oc_status == OC_SET_FOR_DCH_URA_PCH_TRANS)
            ||(oc_status == OC_SET_FOR_CELL_FACH) ||
              (oc_status == OC_SET_FOR_FACH_CELL_PCH_TRANS) ||
              (oc_status == OC_SET_FOR_FACH_URA_PCH_TRANS) 
            || ((rrcllc_get_toc_usage_change_oos_to_dch() == TRUE)&&(rrcllc_get_toc_usage()==TOC_FOR_DCH ))
            ) 
        {
          /* Register the reconfig message for cell update complete indication so it can 
           * proceed processing the ota reconfig msg
           */
          (void)rrccu_register_for_cell_update_to_complete(proc_id);
          /* Reset OC but Set TOC for OOS. TOC will be used once re-entering
             service*/
          (void)rrcllc_reset_ordered_config(RRC_PROCEDURE_CU,FALSE);
          
        }


        if (rrccu_ura_update_started == TRUE)
        {
          rrccu_ura_update_started = FALSE;
          rrccu_cell_update_started = TRUE;
          /* Update Cell Update cause */
          rrccu_cell_update_cause = rrc_CellUpdateCause_re_enteredServiceArea;
        }
        else
        {
          /* remap the cu cause based on the priority */
          rrccu_cell_update_cause = 
            rrccu_map_cu_cause_based_on_priority(RRC_REENTERED_SERVICE_AREA);
        }
        if ((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH) ||
            (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH))
        {
          if (rrccu_oc_set_by_cu == TRUE) 
          {
            /*reset oc */
            (void)rrcllc_reset_ordered_config(RRC_PROCEDURE_CU,TRUE);
              /* clear stored channel config info */
              rrccu_chan_config_info.num_rbs = 0;
          } /* if oc_set_by_cu == TRUE */
        }/* if next state is cell_PCH or URA_PCH */
      }
      break;
      
    case RRCCU_WAIT_FOR_RB_EST_CNF:
    
       /* if next state is cell_DCH then ignore this oos indication
      otherwise it is too late. Take the UE to idle */
      if (rrccu_state_indicator != rrc_RRC_StateIndicator_cell_DCH)
      {
        rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                             RRC_TX_TO_DISCON_OTHER);
          rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
          
          WRRC_MSG1_HIGH("OOS not handled in cu_subst:%d",
                   rrccu_substate);
        }
        else
        {
        WRRC_MSG2_HIGH("OOS Area is ignored in state:%d, cu_state:%d",
                 rrc_get_state(),rrccu_substate);
      }
      return;
    
    case RRCCU_WAIT_FOR_PCCH_RB_EST_CNF:
    /*clear the ordered config if it is set from rrccu procedure */
      if (rrccu_oc_set_by_cu == TRUE)
      {
        rrcllc_clear_ordered_config();
      }
      if (rrccu_ura_update_started == TRUE)
      {
        rrccu_ura_update_started = FALSE;
        rrccu_cell_update_started = TRUE;
        /* Update Cell Update cause */
      }
      rrccu_cell_update_cause = rrc_CellUpdateCause_re_enteredServiceArea;
      
      break;

    case RRCCU_WAIT_FOR_L2_ACK:
      if ((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH) ||
          (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH) ||
          ((rrccu_cucnf_for_srns_relocation) && (!rrccu_oc_set_by_cu)))
      {
        if (rrccu_oc_set_by_cu == TRUE) 
        {
          /* clear stored channel config info */
          rrccu_chan_config_info.num_rbs = 0;
          /*reset oc */
          (void)rrcllc_reset_ordered_config(RRC_PROCEDURE_CU,TRUE);
          rrccu_oc_set_by_cu = FALSE;
        }
        /*If UE is waiting for L2 Ack during SRNS relocation and OC is set by any procedure
        and then OOS happens go to disconnected state*/
        else if (rrccu_cucnf_for_srns_relocation)
        {
          oc_status = rrcllc_get_ordered_config_state_and_proc(&proc_id, &process_state);
    
          if(oc_status!= OC_NOT_SET)
          {
    	                /*reset oc */
            (void)rrcllc_reset_ordered_config(RRC_PROCEDURE_CU,TRUE);
                
            WRRC_MSG1_HIGH("OOS while waiting for L2 Ack of SRNS relocation. Reset OC and Tx to Disconn", 
                         0);

            rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                                 RRC_TX_TO_DISCON_OTHER);
              rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
            return;
          }
        }
        rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;
        rrccu_failure_cause.failureCause.t = 
                T_rrc_FailureCauseWithProtErr_incompatibleSimultaneousReconfiguration;
        need_to_incl_failure_cause_in_next_cu = TRUE;
		
        /* check whether cu or uu procedure is active */
        if (rrccu_ura_update_started)
        {
          rrccu_ura_update_started = FALSE;
          rrccu_cell_update_started = TRUE;
          /* Update Cell Update cause */
          rrccu_cell_update_cause = rrc_CellUpdateCause_re_enteredServiceArea;
        }
        else
        {
          /* remap the cu cause based on the priority */
          rrccu_cell_update_cause = 
            rrccu_map_cu_cause_based_on_priority(RRC_REENTERED_SERVICE_AREA);
        }
      }
      else 
      { 
        /* this would be the case when SRNS relocation is involved and OC is
        set and lower layers are already configured */
        rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                             RRC_TX_TO_DISCON_OTHER);
          rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
          WRRC_MSG1_HIGH("SRNS reloc & OC set cu_subst:%d",rrccu_substate);
        return;
      }
      
      break;
      
    case RRCCU_WAIT_FOR_SRB2_RE_EST_CNF:
      /* check whether this procedure has set oc  in that
      case it is too late to go back to old state so enter
      idle*/
      if (rrccu_oc_set_by_cu == TRUE) 
      {
        /* could not clear OC. go to idle */
        rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                             RRC_TX_TO_DISCON_OTHER);
          rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
          WRRC_MSG1_HIGH("OOS during srns reloc cu_subst:%d", 
                   rrccu_substate);
        return;
      }
      else
      {
        oc_status = rrcllc_get_ordered_config_state_and_proc(&proc_id, &process_state);
  
        /* If this OOS is during transition from DCH, the set TOC for OOS and handle the
         * OOS. If OOS happens after DCH to FACH timer expires then OC would already have 
         been reset by timer expiry so the below condition is added to set the TOC for OOS.
         */
        if ((oc_status == OC_SET_FOR_DCH_FACH_TRANS) ||
            (oc_status == OC_SET_FOR_DCH_CELL_PCH_TRANS) ||
            (oc_status == OC_SET_FOR_DCH_URA_PCH_TRANS)
            ||(oc_status == OC_SET_FOR_CELL_FACH) ||
              (oc_status == OC_SET_FOR_FACH_CELL_PCH_TRANS) ||
              (oc_status == OC_SET_FOR_FACH_URA_PCH_TRANS) 
            || ((rrcllc_get_toc_usage_change_oos_to_dch() == TRUE)&&(rrcllc_get_toc_usage()==TOC_FOR_DCH ))
            ) 
        {
          /* Register the reconfig message for cell update complete indication so it can 
           * proceed processing the ota reconfig msg
           */
          (void)rrccu_register_for_cell_update_to_complete(proc_id);
          
          /* Reset OC but Set TOC for OOS. TOC will be used once re-entering
             service*/
          (void)rrcllc_reset_ordered_config(RRC_PROCEDURE_CU,FALSE);
          
        }

        /* oc is not set so go ahead and start cell selection */
        /* check whether ura update was in progress. In that case
        stop it and set cell_update_started=TRUE. set the cu cause */
        if (rrccu_ura_update_started == TRUE)
        {
          rrccu_ura_update_started = FALSE;
          rrccu_cell_update_started = TRUE;
          /* Update Cell Update cause */
          rrccu_cell_update_cause = rrc_CellUpdateCause_re_enteredServiceArea;
        }
        else
        {
          /* remap the cu cause based on the priority */
          rrccu_cell_update_cause = 
            rrccu_map_cu_cause_based_on_priority (RRC_REENTERED_SERVICE_AREA);
        }
      }
      
      break;

  case RRCCU_WAIT_FOR_BPLMN_SUSPEND_CNF:
    WRRC_MSG1_HIGH("Handling OOS in CU state %d",rrccu_substate);
    rrccu_cell_update_cause = 
       rrccu_map_cu_cause_based_on_priority(RRC_REENTERED_SERVICE_AREA);
    break;

  default:
    WRRC_MSG1_ERROR("sub-state unhandled: CU st %d", rrccu_substate);
    return;
    
  } /* switch (rrccu_substate) */
  
  
  rrccu_cell_update_started = TRUE;
  /* store the current rrc state when failure was indicated */
  rrccu_failure_state = rrc_get_state();

  /* Start the OOS Timer */


  /* If UE is in PCH state and cu_substate is RRCCU_INTITIAL, then start T316.  Else
   * Start the min of T305 or Toos 
   */

  if ((curr_state == RRC_STATE_CELL_PCH || curr_state == RRC_STATE_URA_PCH) && 
      ((rrccu_substate == RRCCU_INITIAL)
#ifdef FEATURE_UPDATE_SIB7_FOR_PCH_TO_FACH
      || (rrccu_substate == RRCCU_WAIT_FOR_SIB7_CURRENT)
#endif /*FEATURE_UPDATE_SIB7_FOR_PCH_TO_FACH*/
      ))
  {
    /* IF CU substate is initial then start T316 timer */
    /* 
       T316 will be started during fach to pch state transition
       But this will be harmless, T316 will be stopped as soon as 
       UE camps back and NEW_CELL_IND is received. UE will trigger a
       cell update after camping back
   */
    t_316_timer_in_ms = rrccu_convert_t316_to_ms( RRC_GET_T316() );
    if (t_316_timer_in_ms > 0 && t_316_timer_in_ms != RRCTMR_INFINITY_VAL) 
    {
      WRRC_MSG1_HIGH("OOS: Starting timer T316 %d ms", t_316_timer_in_ms);
      /* start the timer T316 */
      rrctmr_start_timer(RRCTMR_T_316_TIMER, t_316_timer_in_ms);
    }
    else
    {
      rrccu_start_t305_or_oos_timer();
    }
  }
  /* If T305 is running, then get the min between the remaing ticks and Toos */
  else 
  {
    rrccu_start_t305_or_oos_timer();
  }

  rrccu_send_rrc_initiate_cell_selection_ind(RRC_OUT_OF_SERVICE_AREA_IND,curr_state);  
  
  rrccu_substate = RRCCU_WAIT_FOR_UE_TO_CAMP_ON; 
  
} 

#ifdef FEATURE_QSH_EVENT_METRIC
/*===========================================================================

FUNCTION rrccu_qsh_log_rlf_params

DESCRIPTION
  This function reports rlf parameters to qsh
  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/

void rrccu_qsh_log_rlf_params(sys_rlf_weak_signal_e_type cause)
{
  wrrc_call_end_data_log_type call_end_data;
  call_end_data.type = WRRC_CALL_END_TYPE_RLF;
  call_end_data.cause.rlf_cause = cause;
  wrrc_qsh_log_conn_end_info(WRRC_METRIC_LOG, &call_end_data);
}
#endif
/*===========================================================================

FUNCTION RRCCU_PROCESS_CU_INITIAL

DESCRIPTION
  This function processes all events that are dispatched to Cell Update 
  procedure in RRCCU_INITIAL substate.

  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
void rrccu_process_cu_initial
(    
  rrc_cmd_type *cmd_ptr
)
{
  rrc_rl_failure_cause_e_type  rl_cause;

  rlc_lc_id_type ul_rlc_lc_id = RRCLCM_RLC_LC_ID_NOT_FOUND;
                                /* Local varible for Uplink RLC LC Id. */
  rrc_state_e_type current_rrc_state;
  rrccu_status_e_type status;
  uint32 t_316_timer_in_ms = 0;
  uint8 count = 0;

  current_rrc_state = rrc_get_state();
 
  rrc_v_302 = 0;                /* Initialize Cell Update re-transmission
                                   counter to zero */

  if ((RRC_STATE_CELL_DCH == current_rrc_state) || 
      (RRC_STATE_CELL_FACH == current_rrc_state))
  {
    /* All the commands in CELL_DCH and CELL_FACH will result in cell update.
       Hence, check whether any security configuration is active or not. If yes,
       then abort the on-going security configuration before cell update is 
       triggered.The following are the exceptions(where CU is not triggered)
       
       1. RRC_STATE_CHANGE_IND
       2. RRC_SIB_CHANGE_IND
       3. RRC_CRLC_STATUS_IND with error_type = RLC_RESET (Not an unrecoverable error
          or direction = FALSE (Uplink)
    */   
    if(!((cmd_ptr->cmd_hdr.cmd_id == RRC_STATE_CHANGE_IND) ||
         (cmd_ptr->cmd_hdr.cmd_id == RRC_SIB_CHANGE_IND) || 
         ((cmd_ptr->cmd_hdr.cmd_id == RRC_CRLC_STATUS_IND) &&
          ((cmd_ptr->cmd.crlc_status_ind.error_type == RLC_RESET) ||
           (cmd_ptr->cmd.crlc_status_ind.direction == FALSE)))||
         (cmd_ptr->cmd_hdr.cmd_id == RRC_SIB7_UPDATE_STATUS_IND) 
        )
       )
    {
      rrccu_revert_back_to_old_config = rrcsmc_check_and_abort_ongoing_security_configuration();
      WRRC_MSG1_HIGH("rrccu_revert_back_to_old_config is %d",rrccu_revert_back_to_old_config);
    }
  }

  switch(current_rrc_state)
  {
    case RRC_STATE_DISCONNECTED:
    case RRC_STATE_CONNECTING:
      if(cmd_ptr->cmd_hdr.cmd_id == RRC_CPHY_OUT_OF_SERVICE_AREA_IND)
      {
        WRRC_MSG1_ERROR("OOS indication in state:%d should be routed to RCE",current_rrc_state);
        rrccu_substate = RRCCU_INITIAL; 
        /*call the procedure to clear the global variabls */
        rrccu_clear_procedure();

        event_report(EVENT_WCDMA_OUT_OF_SERVICE);
      }
      else if(cmd_ptr->cmd_hdr.cmd_id == RRC_STATE_CHANGE_IND)
      { 
        /* Reset the registration info */
        rrccu_reset_registration_info();
      }
      else
      {
        WRRC_MSG2_ERROR("Unknown command: 0x%x, CU st %d", cmd_ptr->cmd_hdr.cmd_id,rrccu_substate);
      }
      break; 
    
    case RRC_STATE_CELL_DCH:
      switch(cmd_ptr->cmd_hdr.cmd_id)
      { 
        case RRC_CELL_UPDATE_INITIATE_REQ:
          if((RRCCU_SUCCESS == 
              rrccu_validate_cell_update_initiate_req(cmd_ptr)) &&
             (cmd_ptr->cmd.initiate_cell_update.cause == 
              RRC_RADIO_LINK_FAILURE ) )
          {
#ifdef FEATURE_QSH_EVENT_METRIC
            rrccu_qsh_log_rlf_params(SYS_RLF_WEAK_SIGNAL_OTHER);
#endif
            /* Reset the OC if RB procedure initiated Cell Update with RL failure in the case of a 
               physical channel failure in DCH */
            if (cmd_ptr->cmd.initiate_cell_update.procedure == RRC_PROCEDURE_RBE || 
                cmd_ptr->cmd.initiate_cell_update.procedure == RRC_PROCEDURE_RBR || 
                cmd_ptr->cmd.initiate_cell_update.procedure == RRC_PROCEDURE_RBRC|| 
                cmd_ptr->cmd.initiate_cell_update.procedure == RRC_PROCEDURE_PCR || 
                cmd_ptr->cmd.initiate_cell_update.procedure == RRC_PROCEDURE_TCR )
            {
              (void)rrcllc_reset_ordered_config(RRC_PROCEDURE_CU,TRUE);
            }
            /*check whether it is OK to proceed with rl failure handling. if not 
            take Ue to idle */
            status = rrccu_validate_rrc_status_for_failure_handling(cmd_ptr, rrc_CellUpdateCause_radiolinkFailure);
            if (status != RRCCU_SUCCESS)
            {
              if(status == RRCCU_PENDING_CONFIG)
              {
                /* All process done in cu_wait_for_pending_config substate.  Just return */
                return;
              }
              else /* RRCCU_FAILURE_MAJOR case */
              {
                rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                                     RRC_TX_TO_DISCON_OTHER);
                  /* Update the release cause */
                  rrc_release_cause = RRC_REL_DEEP_FADE;
                  rrccu_substate    = RRCCU_WAIT_FOR_RB_REL_CNF;
                }
            }
            else
            {
              /* Update Cell Update cause */
              rrccu_cell_update_started = TRUE;
              rrccu_cell_update_cause   = rrc_CellUpdateCause_radiolinkFailure;
              rl_cause                  = RL_FAILURE_DUE_TO_RRC;
              /* store the current rrc state when failure was indicated */
              rrccu_failure_state       = current_rrc_state;

              event_report_payload(EVENT_WCDMA_RL_FAILURE, sizeof(rrc_rl_failure_cause_e_type), 
                                (void *)&rl_cause);
              /* Check if timers T314 and T315 for RRC Connection Establishment.*/  
              rrccu_process_re_est_timers(FALSE);
            }
          }
          /* UE has detected OOS area during DCH->FACH or DCH->PCH transition.  
           * Initiate cell selection with cause OOS
           */
          else if ((cmd_ptr->cmd.initiate_cell_update.cause == 
                    RRC_REENTERED_SERVICE_AREA) && 
                   (cmd_ptr->cmd.initiate_cell_update.procedure == 
                    RRC_PROCEDURE_CSP)) 
          {
            WRRC_MSG2_HIGH("OOS detected on dch->fach_pch trans. OOS area in UE st %d cu_st %d",
                     rrc_get_state(),rrccu_substate);
            rrccu_process_oos_area_handling();
          }
          else
          {
            WRRC_MSG2_HIGH("Invalid cause: %d RRC_CELL_UPDATE_INITIATE_REQ Cmd",
            cmd_ptr->cmd.initiate_cell_update.cause, current_rrc_state);
          }
          break;

        case RRC_CPHY_RL_FAILURE_IND:
          WRRC_MSG1_HIGH("Rcvd RRC_CPHY_RL_FAILURE_IND cu_st:%d",rrccu_substate);
#ifdef FEATURE_QSH_EVENT_METRIC
          rrccu_qsh_log_rlf_params(SYS_RLF_WEAK_SIGNAL_RLF_TIMER_EXP);
#endif
#ifdef FEATURE_DUAL_SIM
          if(rrccsp_get_curr_scan() == RRC_CSP_UNLOCK_BY_SCAN)
          {
            WRRC_MSG0_HIGH("DSIM_TUNEAWAY: Ignore RRC_CPHY_RL_FAILURE_IND  for now. Any way during resume, cphy setup fails");
            return;
          }
#endif
            
          /* In case Of Radio Link Failure, abort the Reading of SIB
           * in DCH mode
           */
          if(rrc_sib_is_current_event_sib_read_in_dch())
          {
            WRRC_MSG0_HIGH("RRCGPS: Force Init GPS ");
            rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_SIB_READ_IN_DCH);
          }
          rl_cause = RL_FAILURE_DUE_TO_L1;
          event_report_payload(EVENT_WCDMA_RL_FAILURE, sizeof(rrc_rl_failure_cause_e_type), 
                               (void *)&rl_cause);
          {
            boolean mm_waiting_for_nw_cmd = FALSE;
#ifdef FEATURE_DUAL_SIM
            mm_waiting_for_nw_cmd = mm_per_subs_waiting_for_nw_command(rrc_get_as_id());
#else
            mm_waiting_for_nw_cmd = mm_waiting_for_nw_command();
#endif
          /* Here, we query nas function to see if CC has received a release complete.  In the case where RL failure 
          is caused because RCR msg is sent from NW only once and is lost, if CC has received a release complete, 
          we just take UE to idle if PS signalling is not up.  Else, we follow the regular path for RL failure. */
            if (mm_waiting_for_nw_cmd) 
            {
              WRRC_MSG0_HIGH("Nas waiting for Connection Release.");
              if (!rrcscr_get_signalling_connection_status(RRC_PS_DOMAIN_CN_ID))
              {
                WRRC_MSG0_HIGH("PS Signalling is not up.  Taking UE to Idle");
                rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                                     RRC_TX_TO_DISCON_OTHER);
                /* Update the release cause */
                rrc_release_cause = RRC_REL_DEEP_FADE;
                rrccu_substate    = RRCCU_WAIT_FOR_RB_REL_CNF;
                return;
              }
              else
              {
                /* PS signalling is up.  Continue with RL failure*/
                WRRC_MSG0_HIGH("PS Signalling is UP.");    
              }
            }
          }


          /*Update the global release_cause variable here */
          rrc_release_cause = RRC_REL_DEEP_FADE;
          /* Update Cell Update cause */
          rrccu_cell_update_cause = rrc_CellUpdateCause_radiolinkFailure;
          /* set Cell_update_started flag here */
          rrccu_cell_update_started = TRUE;
          /*check whether it is OK to proceed with rl failure handling. if not 
          take Ue to idle */
          status = rrccu_validate_rrc_status_for_failure_handling(cmd_ptr, rrc_CellUpdateCause_radiolinkFailure);
          if (status != RRCCU_SUCCESS) 
          {
            /* all s*/
            if(status == RRCCU_PENDING_CONFIG)
            {
                /* all process done in cu_Wait_pending_config_substate. just return */
                return;
            }
            else /* RRCCU_FAILURE_MAJOR case */
            {
              rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                                   RRC_TX_TO_DISCON_OTHER);
              /* Update the release cause */
              rrc_release_cause = RRC_REL_DEEP_FADE;
              rrccu_substate    = RRCCU_WAIT_FOR_RB_REL_CNF;
              
            }
          }
          else
          {
            /* store the current rrc state when failure was indicated */
            rrccu_failure_state = current_rrc_state;
            /* Check if timers T314 and T315 for RRC Connection Establishment.
            process the RABs associated with re-est timers.*/  
            rrccu_process_re_est_timers(FALSE);
          }

          break;

        case RRC_CRLC_STATUS_IND:
          /* Call the function to process RLC status indication in initial state */
          rrccu_process_rlc_status_ind(cmd_ptr);
          break;

        default:
          WRRC_MSG2_ERROR("Unknown command: 0x%x, CU st %d", cmd_ptr->cmd_hdr.cmd_id,rrccu_substate);
          break;
      }
      break;

    case RRC_STATE_CELL_FACH:
      switch(cmd_ptr->cmd_hdr.cmd_id)
      { 
        case RRC_CPHY_OUT_OF_SERVICE_AREA_IND:
          WRRC_MSG2_HIGH("OOS Ind Rcvd in st:%d cu_st:%d",
                    current_rrc_state, rrccu_substate);

          event_report(EVENT_WCDMA_OUT_OF_SERVICE);
          /* Delete C-RNTI */
         // rrccu_delete_crnti();

            if (RRCCU_SUCCESS != rrccu_validate_rrc_status_for_oos_handling())
            {
              rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                                   RRC_TX_TO_DISCON_OTHER);
              /* Update the release cause */
              rrc_release_cause = RRC_REL_DEEP_FADE;
              rrccu_substate    = RRCCU_WAIT_FOR_RB_REL_CNF;
            }
            else
            {
            uint32 t_305_timer_in_ms = 0;
            t_305_timer_in_ms = rrc_convert_t305_to_ms(RRC_GET_T305());
       
            /* store the current rrc state when failure was indicated */
            rrccu_failure_state = current_rrc_state;
            rrccu_cell_update_started = TRUE;
            /* Start the OOS Timer */
            /* Start min(T305, Toos) */
            /* If remaining ticks of T305 is 0, then T305 just expired.
            * Start T307 in this case
            */
            if ((rrctmr_get_remaining_time(RRCTMR_T_305_TIMER) == 0)&&
                (t_305_timer_in_ms != RRCTMR_INFINITY_VAL ))
            {
              rrctmr_start_timer(RRCTMR_T_307_TIMER, 
                                 rrccu_convert_t307_to_ms( RRC_GET_T307() ) );
            }
            /* If T305 is running, then get the min between the remaining ticks and Toos */
            else if((rrctmr_get_remaining_time(RRCTMR_T_305_TIMER) > RRCTMR_T_OOS_TIMER_IN_MS)
                ||(t_305_timer_in_ms == RRCTMR_INFINITY_VAL ))
            {
              WRRC_MSG1_HIGH("OOS: Starting timer %d ", RRCTMR_T_OOS_TIMER_IN_MS);
              rrctmr_start_timer(RRCTMR_T_OOS_TIMER, RRCTMR_T_OOS_TIMER_IN_MS);
            }

            /*Initiate Cell Selection */
            rrccu_send_rrc_initiate_cell_selection_ind(
                                          RRC_OUT_OF_SERVICE_AREA_IND,
                                          RRC_STATE_CELL_FACH);
          }
          
          /* Update Cell Update cause */
          rrccu_cell_update_cause = rrc_CellUpdateCause_re_enteredServiceArea;

          rrccu_substate = RRCCU_WAIT_FOR_UE_TO_CAMP_ON; 
          break;


        case RRC_CELL_UPDATE_INITIATE_REQ:

          if(RRCCU_SUCCESS == 
              rrccu_validate_cell_update_initiate_req(cmd_ptr))
          {
            /* set Cell_update_started flag here */
            rrccu_cell_update_started = TRUE;
            
            /*  CU initiate req with PHY_CHAN_FAILURE, Start T_OOS with 10 sec,
            and initiate cell selection with cause OOS area */
            if (cmd_ptr->cmd.initiate_cell_update.cause ==  RRC_PHY_CHAN_FAILURE)
            {
              WRRC_MSG0_HIGH("CU with cause RRC_PHY_CHAN_FAILURE rcvd. Init cell sel"); 
              (void)rrcllc_reset_ordered_config(RRC_PROCEDURE_CU
                                                          ,TRUE);
              /* store the current rrc state when failure was indicated */
              rrccu_failure_state = current_rrc_state;
              rrccu_cell_update_started = TRUE;
              /* Set flag to true to indicate that CU is initiated by RB procedure
              with cause phy_chan_failure */
              rrccu_phy_chan_failure_from_rb = TRUE;
              /* Start the OOS Timer */
              rrctmr_start_timer(RRCTMR_T_OOS_TIMER, RRCTMR_CPHYCHANFAIL_TIMER_IN_MS);
              /*Initiate Cell Selection */
              rrccu_send_rrc_initiate_cell_selection_ind(
                                          RRC_OUT_OF_SERVICE_AREA_IND,
                                          RRC_STATE_CELL_FACH);     
       
              rrccu_cell_update_cause = rrc_CellUpdateCause_cellReselection;
              rrccu_substate = RRCCU_WAIT_FOR_UE_TO_CAMP_ON;
              return;
            } 

            else if(cmd_ptr->cmd.initiate_cell_update.cause == 
              RRC_UNRECOVERABLE_ERROR ) 
            { /* Update Cell Update cause */
              rrccu_cell_update_cause = rrc_CellUpdateCause_rlc_unrecoverableError;
              rrccu_rlc_error_info.error_on_srb = TRUE;
              status = rrccu_validate_rrc_status_for_failure_handling(cmd_ptr, rrc_CellUpdateCause_rlc_unrecoverableError);
              /* check for any restrictions to proceed with rl failure handling */
              if (status != RRCCU_SUCCESS)
              {
                /* all process done in cu_wait_for_pending_config.  just return */
                if(status == RRCCU_PENDING_CONFIG)
                {
                  return;
                }
                else /* RRCCU_FAILURE_MAJOR case */
                {
                  rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                                       RRC_TX_TO_DISCON_OTHER);
                  /* Update the release cause */
                  rrc_release_cause = RRC_REL_DEEP_FADE;
                  rrccu_substate    = RRCCU_WAIT_FOR_RB_REL_CNF;
                  
                }
              }
            }
            else if (cmd_ptr->cmd.initiate_cell_update.cause == 
                     RRC_CELL_RESELECTION ) 
            {
              rrccu_cell_update_cause = rrc_CellUpdateCause_cellReselection;
            }
            else if (cmd_ptr->cmd.initiate_cell_update.cause == 
                     RRC_RADIO_LINK_FAILURE ) 
            {
              status = rrccu_validate_rrc_status_for_failure_handling(cmd_ptr, rrc_CellUpdateCause_radiolinkFailure);
              if (status != RRCCU_SUCCESS) 
              {
                /* all process done in cu_wait_for_pending_config.  Just return */
                if(status == RRCCU_PENDING_CONFIG)
                {
                  return;
                }
                else /* RRCCU_FAILURE_MAJOR case */
                {
                  rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                                       RRC_TX_TO_DISCON_OTHER);
                  /* Update the release cause */
                  rrc_release_cause = RRC_REL_DEEP_FADE;
                  rrccu_substate    = RRCCU_WAIT_FOR_RB_REL_CNF;
                }
              }
              rrccu_cell_update_cause = rrc_CellUpdateCause_radiolinkFailure;
            }
            else if( IS_CU_TRIGGERED_WITH_RE_ENTER_SERVICE_AREA_VALID ) 
            {
              rrccu_process_oos_area_handling();
              return;
            }

            else
            {
              WRRC_MSG1_ERROR("Invalid cell update cause: %d",
                   cmd_ptr->cmd.initiate_cell_update.cause);
            }
            /* Check whether RB0 is already established */
            ul_rlc_lc_id = rrclcm_check_ul_rlc_lc_id(UE_LOGCHAN_CCCH, 
                                         CCCH_RADIO_BEARER_ID,
                                         UE_MODE_TRANSPARENT);
             if((ul_rlc_lc_id == RRCLCM_RLC_LC_ID_NOT_FOUND)
#ifdef FEATURE_WCDMA_HS_FACH
               && (rrcenhstate_camped_cell_supports_e_fach() == FALSE) 
#endif
               )
            {
              WRRC_MSG0_ERROR("No RB0 in CELL_FACH");
            }
            else
            {
              /* Stop timer T305 */
              rrctmr_stop_timer(RRCTMR_T_305_TIMER);

#ifdef FEATURE_WCDMA_HS_FACH
               /*Since CU was initiated, configure lower layers with common H-RNTI, if the cell supports E-FACH*/
               if(rrcenhstate_camped_cell_supports_e_fach() == TRUE)
               {
                 WRRC_MSG0_HIGH("EFACH:CU Initiated , send CHAN_CONFIG_REQ for cHrnti");
                 rrcllc_establish_srb_rab_in_efach(RRC_E_FACH_COMMON,RRC_PROCEDURE_CU,FALSE);
                 rrccu_substate = RRCCU_WAIT_FOR_RB0_EST_CNF;
                 break;
               }
#endif


              /* Enqueue Cell Update Message in the Uplink Queue.
                 This function also starts T302 timer */
              rrccu_purge_rlc_wm_rb3_rb4(TRUE,FALSE);
              if (RRCCU_SUCCESS == rrccu_send_cell_update_msg(ul_rlc_lc_id, 
                                   RRCCU_NOT_INCLUDE_FAILURE_CAUSE) )
              {      
                rrccu_substate = RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM; 
              }
              else
              {
                /* Reset Cell Update State machine */
                rrccu_substate = RRCCU_INITIAL;
                /*call the procedure to clear the global variabls */
                rrccu_clear_procedure();
                rrccu_init_last_cu_cnf_info();
                /*If sending of CU is failed move to disconnected state*/
                rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                                     RRC_TX_TO_DISCON_OTHER);
                rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
              }
            }
          }
          break;
            
        case RRC_NEW_CELL_IND:
          WRRC_MSG2_HIGH("Cell reselection in state:%d, cu_state:%d",
                   current_rrc_state, rrccu_substate);
          /* set Cell_update_started flag here */
          rrccu_cell_update_started = TRUE;
          /* Update Cell Update cause If UL DATA IND is buffered, set the cause as UL data IND as 
             this is higher priority cause. This can happen if resume fails and UL data is buffered in standby state*/
          rrccu_cell_update_cause = (rrccu_buffered_cmd_mask & UL_DATA_IND)?rrc_CellUpdateCause_uplinkDataTransmission:rrc_CellUpdateCause_cellReselection;

          /* Check whether RB0 is already established */
          ul_rlc_lc_id = rrclcm_check_ul_rlc_lc_id(UE_LOGCHAN_CCCH, 
                                       CCCH_RADIO_BEARER_ID,
                                       UE_MODE_TRANSPARENT);

          if(ul_rlc_lc_id == RRCLCM_RLC_LC_ID_NOT_FOUND)
          {
            WRRC_MSG0_ERROR("No RB0 in CELL_FACH");
          }
          else
          {
            /* Stop timer T305 */
            rrctmr_stop_timer(RRCTMR_T_305_TIMER);

           /* Enqueue Cell Update Message in the Uplink Queue.
              This Function also starts T302 timer */
            rrccu_purge_rlc_wm_rb3_rb4(TRUE,FALSE);
            if (RRCCU_SUCCESS == rrccu_send_cell_update_msg(ul_rlc_lc_id,
                                 RRCCU_NOT_INCLUDE_FAILURE_CAUSE) )
            {        
              rrccu_substate = RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM; 
            }
            else
            {
              /* Reset Cell Update State machine */
              rrccu_substate = RRCCU_INITIAL;
              /*call the procedure to clear the global variabls */
              rrccu_clear_procedure();
            }
          }
          break;

        case RRC_T305_EXPIRED_IND:
          WRRC_MSG2_HIGH("Timer T305 expired in state: %d, cu_subst: %d", current_rrc_state, rrccu_substate);

          /*Checking for whether Cell_FACH->Cell_DCH is in progress */
          if(ordered_config.set_status != OC_SET_FOR_CELL_DCH)
          {
            /* set Cell_update_started flag here */
            rrccu_cell_update_started = TRUE;
            /* Update Cell Update cause */
            rrccu_cell_update_cause = rrc_CellUpdateCause_periodicalCellUpdate;
  
          /*In case peridic cell Update timer expires when DELAY CU is active, update the cause to 
            UL data indication if expiry is in PCH state and Cell reselection in FACH state.
            NW may not provide RNTI set if cause is set to periodic cell update*/
            if(rrccu_get_hsrach_sib_change())
            {
              rrccu_cell_update_cause = rrc_CellUpdateCause_cellReselection;
            }
            /* Check whether RB0 is already established */
            ul_rlc_lc_id = rrclcm_check_ul_rlc_lc_id(UE_LOGCHAN_CCCH, 
                                         CCCH_RADIO_BEARER_ID,
                                         UE_MODE_TRANSPARENT);
  
            if(ul_rlc_lc_id != RRCLCM_RLC_LC_ID_NOT_FOUND)
            { /* Enqueue Cell Update Message in the Uplink Queue.
               This function also starts T302 timer */
              if (RRCCU_SUCCESS == rrccu_send_cell_update_msg(ul_rlc_lc_id,
                                   RRCCU_NOT_INCLUDE_FAILURE_CAUSE) )
              {        
                rrccu_substate = RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM; 
              }
              else
              {
                /* Reset Cell Update State machine */
                rrccu_substate = RRCCU_INITIAL;
                /*call the procedure to clear the global variabls */
                rrccu_clear_procedure();
  
                if(rrc_convert_t305_to_ms(RRC_GET_T305()) == RRCTMR_INFINITY_VAL )
                {
                  WRRC_MSG0_HIGH("T305 value infinity, dont start this timer");
                }
                else
                {
  
                  rrccu_start_t_305_timer();
                }
              } 
            }
            else
            {
              WRRC_MSG0_ERROR("Can't find RLC ID for UL RB 0");
            }
          }
          else
          {
            WRRC_MSG0_HIGH("Next state is Cell_DCH. So ignoring RRC_T305_EXPIRED_IND");
          }
          break;

        case RRC_CRLC_STATUS_IND:
          /* call function to process rlc status indication */
          rrccu_process_rlc_status_ind(cmd_ptr);
          break;

        case RRC_STATE_CHANGE_IND:

          /* Ue is entering CELL_FACH start
           * no need to start the timer here since T_305 
           * would have been started when cell selection is initiated
           * when transitioning out of DCH
           */
          WRRC_MSG2_HIGH("State change ind received.  in rrc_state: %d, cu_substate: %d", current_rrc_state, rrccu_substate);
          if ((rrctmr_get_remaining_time(RRCTMR_T_305_TIMER) == 0) && 
             (rrc_convert_t305_to_ms(RRC_GET_T305()) != RRCTMR_INFINITY_VAL ))
          {
            if (rrctmr_get_remaining_time(RRCTMR_T_307_TIMER) == 0) 
            {
              /* It shouldn't happen that both T_305 and T_307 are 0
                 at this point 
               */
              WRRC_MSG0_ERROR("Something wrong - Restarting T305");
              rrccu_start_t_305_timer();
            }
          }
          break;

        default:
          WRRC_MSG2_ERROR("Unknown command: 0x%x, CU st %d", cmd_ptr->cmd_hdr.cmd_id,rrccu_substate);
          break;
      }
      break;

    case RRC_STATE_CELL_PCH:
    case RRC_STATE_URA_PCH:
      switch(cmd_ptr->cmd_hdr.cmd_id)
      { 
        case RRC_SIB_CHANGE_IND:
          WRRC_MSG2_HIGH("RRC_SIB_CHANGE_IND in state:%d, cu_state:%d",
                   current_rrc_state, rrccu_substate);
          if (RRC_STATE_URA_PCH == current_rrc_state)
          {
            /* This function would check if a URA reselection occurred */
            if (rrccu_check_for_ura_reselection())
            {
              /* set Cell_update_started flag here */
              rrccu_ura_update_started = TRUE;
              /* Stop timer T305 */
              rrctmr_stop_timer(RRCTMR_T_305_TIMER);
              /* Update URA Update cause */
              rrccu_ura_update_cause = rrc_URA_UpdateCause_changeOfURA;
              
              /* Check if BPLMN is in progress.  If so abort*/
              if (rrc_csp_bplmn_srch_in_progress() != WTOW_SEARCH_STOP ) 
              {
                WRRC_MSG0_HIGH("BPLMN search in progess. Abort before sending CU");
                /* Important:  Always set CU substate before calling func send bplmn suspend
                 * req 
                 */
                rrccu_substate = RRCCU_WAIT_FOR_BPLMN_SUSPEND_CNF;
                rrc_csp_send_bplmn_suspend_req(RRC_PROCEDURE_CU, BPLMN_SUSPEND_REASON_OTHER); 
              }
              else
              {
#ifdef FEATURE_DUAL_SIM
                if(rrc_acquire_lock_for_pch_to_fach() == SUCCESS)
#endif /*FEATURE_DUAL_SIM*/
                {
                rrccu_establish_srb(TRUE, RRC_STATE_CELL_FACH, TRUE);
                rrccu_substate = RRCCU_WAIT_FOR_RB0_EST_CNF;
              } 
#ifdef FEATURE_DUAL_SIM
                else
                {
                  rrccu_process_oos_area_handling();
                }
#endif /*FEATURE_DUAL_SIM*/
              } 
            }
          }
          break;
       case RRC_STATE_CHANGE_IND:
		 MSG_HIGH("RRC_STATE_CHANGE_IND received. prev_state: %d, new_state: %d, cu_substate: %d",cmd_ptr->cmd.state_change_ind.previous_state,
		 	cmd_ptr->cmd.state_change_ind.new_state, rrccu_substate);
         if (cmd_ptr->cmd.state_change_ind.previous_state == RRC_STATE_CELL_DCH)
         {
          /* Ue is entering CELL_PCH/URA_PCH state/
           * no need to start the timer here since T_305 
           * would have been started when cell selection is initiated
           * when transitioning out of DCH
           */
           if ((rrctmr_get_remaining_time(RRCTMR_T_305_TIMER) == 0)&& 
            (rrc_convert_t305_to_ms(RRC_GET_T305()) != RRCTMR_INFINITY_VAL ))
           {
             if (rrctmr_get_remaining_time(RRCTMR_T_307_TIMER) == 0) 
             {
               /* It shouldn't happen that both T_305 and T_307 are 0
                 at this point 
               */
               WRRC_MSG0_ERROR("Something wrong - Restarting T305");
               rrccu_start_t_305_timer();
             }
           }

         }
         if (cmd_ptr->cmd.state_change_ind.previous_state == RRC_STATE_CELL_FACH)
         {
           /* start the periodic timer if state transition is dch->pch*/
           rrccu_start_t_305_timer();
         }
         if (cmd_ptr->cmd.state_change_ind.new_state == RRC_STATE_URA_PCH)
         {
           /* This function would check the contents of the SIB2 and will set ura_update_reqd flag
           to TRUE if the URA update procedure is required else will set it to FALSE.This flag later
           is used by rb procedures to initiate ura update procedure if ura reselection
           has happened */
           rrccu_ura_update_required = rrccu_check_for_ura_reselection();
           WRRC_MSG1_HIGH("URA Reselection flag set to %d", rrccu_ura_update_required);
         }
         /* If state changed to PCH, check if any module has registered for CU and initiate CU accordingle */
         /* Currently handling is added only for SCRR. This can be extended to any other procedure */
         if((cmd_ptr->cmd.state_change_ind.new_state == RRC_STATE_URA_PCH) ||
         (cmd_ptr->cmd.state_change_ind.new_state == RRC_STATE_CELL_PCH))
         {
           while( count < rrccu_reg_info.no_of_reg_procs)
           {
             if(rrccu_reg_info.rrc_proc[count] == RRC_PROCEDURE_SCRR)
             {
               /* If CUC moving UE to PCH received a wait time, we will start T320 */
               /* We shouldnt send CU till the timer expires, hence initiate CU only if timer is not running */
               if(!rrctmr_get_remaining_time(RRCTMR_T_320_TIMER))
               {
                 rrcrb_send_cell_update_initiate_req(RRC_PROCEDURE_SCRR,RRC_UL_DATA_TRANSMISSION, FALSE);
               }
               else
               {
                 /* Updating the cause here to make sure that CU is initiated at T320 expiry */
                 rrccu_set_cu_cause_for_wait_timer(RRC_UL_DATA_TRANSMISSION);
               }
               break;
             }
             count++;
           }
         }
         break;

       case RRC_CPHY_OUT_OF_SERVICE_AREA_IND:
         WRRC_MSG2_HIGH("OOS Ind Rcvd in st:%d cu_st:%d",
                   current_rrc_state, rrccu_substate);

         event_report(EVENT_WCDMA_OUT_OF_SERVICE);

          rrccu_cell_update_started = TRUE;
          /* start the OOS timer */

         /* If UE is in PCH state and cu_substate is RRCCU_INTITIAL, then start T316.  If 
          * T316 is infinity or 0, the UE shall start the min between T305 and T00s. 
          */

          t_316_timer_in_ms = rrccu_convert_t316_to_ms( RRC_GET_T316() );
          if (t_316_timer_in_ms > 0 && t_316_timer_in_ms != RRCTMR_INFINITY_VAL) 
          {
            WRRC_MSG1_HIGH("OOS: Starting timer T316 %d ms", t_316_timer_in_ms);
            /* start the timer T316 */
            rrctmr_start_timer(RRCTMR_T_316_TIMER, t_316_timer_in_ms);
          }
          else
          {
            /* Start min(T305, Toos) */
            /* If the remaining T305 is 0, then T305 has expired and it's in the Queue.  
             * Start T307 in this case
             */
            if ((rrctmr_get_remaining_time(RRCTMR_T_305_TIMER) == 0)
                && (rrc_convert_t305_to_ms(RRC_GET_T305()) != RRCTMR_INFINITY_VAL ))
            {
              WRRC_MSG1_HIGH("Start T307 %d ms",rrccu_convert_t307_to_ms( RRC_GET_T307()));
              rrctmr_start_timer(RRCTMR_T_307_TIMER, 
                                 rrccu_convert_t307_to_ms( RRC_GET_T307() ) );
            }
            else if((rrctmr_get_remaining_time(RRCTMR_T_305_TIMER) > RRCTMR_T_OOS_TIMER_IN_MS)
                || (rrc_convert_t305_to_ms(RRC_GET_T305()) == RRCTMR_INFINITY_VAL ))
            {
              WRRC_MSG1_HIGH("OOS: Starting timer %d ", RRCTMR_T_OOS_TIMER_IN_MS);
              rrctmr_start_timer(RRCTMR_T_OOS_TIMER, RRCTMR_T_OOS_TIMER_IN_MS);
            }
          }
          /* Initiate Cell Selection */
          rrccu_send_rrc_initiate_cell_selection_ind(
                                          RRC_OUT_OF_SERVICE_AREA_IND,
                                          current_rrc_state);               

          /* Update cell update cause */
          rrccu_cell_update_cause = rrc_CellUpdateCause_re_enteredServiceArea;

          /* Wait for UE to camp on */
          rrccu_substate = RRCCU_WAIT_FOR_UE_TO_CAMP_ON;



         break;

       case RRC_CELL_UPDATE_INITIATE_REQ:
         if((rrccu_buffered_cmd_mask != 0) && (rrcmcm_get_rrc_mode() == RRC_MODE_ACTIVE)&& (cmd_ptr->cmd.initiate_cell_update.cause == RRC_REENTERED_SERVICE_AREA)&&
            (cmd_ptr->cmd.initiate_cell_update.procedure == RRC_PROCEDURE_CSP))
         {
           WRRC_MSG0_HIGH("Resume failed and we have buffered comamnds. Post the buffered commands now");
           if(rrccu_buffered_cmd_mask & UL_DATA_IND)
           {
               rrccu_cell_update_cause = 
             rrccu_map_cu_initiation_cause(RRC_UL_DATA_TRANSMISSION);
               /* Need not send SIB-change/t305 expiry if UL data ind is sent even if it is buffered*/
           }
           else if(rrccu_buffered_cmd_mask & CU_INITIATE_REQ)
           {
               rrccu_cell_update_cause = 
             rrccu_map_cu_initiation_cause(rrccu_buffered_cu_initiate_req.cause);
           }
           /*Ignore T305 expiry or SIB change indication */
           rrccu_buffered_cmd_mask = 0;
         }
#ifdef FEATURE_WCDMA_HS_RACH
        /*While coming out of PCH state if ready_for_common_edch or hspa_rnti_stored_cell_pch
          is true then send a measurement report instead of cell update*/
        if(TRUE == rrcllc_get_hspa_rnti_stored_cell_pch(current_config_ptr))
        {
           /*initiate a cell update post an internal command to avoid any race conditions */
           cmd_ptr->cmd.initiate_cell_update.cause = RRC_PCH_TO_FACH_TRANSITION_REQ; 
           WRRC_MSG1_HIGH("RRCHSRACH: Change CU cause to %d",
                     cmd_ptr->cmd.initiate_cell_update.cause);
        }
#endif
        if(RRCCU_SUCCESS == 
             rrccu_validate_cell_update_initiate_req(cmd_ptr)) 
        {
           if( (cmd_ptr->cmd.initiate_cell_update.cause == RRC_REENTERED_SERVICE_AREA) &&
               ((cmd_ptr->cmd.initiate_cell_update.procedure == RRC_PROCEDURE_CSP)||
                (cmd_ptr->cmd.initiate_cell_update.procedure == RRC_PROCEDURE_SIB)) 
             )
           {
             rrccu_process_oos_area_handling();
             return;
           }

           /* set Cell_update_started flag here */
           rrccu_cell_update_started = TRUE;

#ifndef FEATURE_UPDATE_SIB7_FOR_PCH_TO_FACH
           /* Stop timer T305 */
           rrctmr_stop_timer(RRCTMR_T_305_TIMER);
#endif /*FEATURE_UPDATE_SIB7_FOR_PCH_TO_FACH*/

           /* Update Cell Update cause */
           rrccu_cell_update_cause = 
             rrccu_map_cu_initiation_cause(cmd_ptr->cmd.initiate_cell_update.cause);
           
           /* Check if BPLMN is in progress.  If so abort*/
           if (rrc_csp_bplmn_srch_in_progress() != WTOW_SEARCH_STOP ) 
           {
#ifdef FEATURE_UPDATE_SIB7_FOR_PCH_TO_FACH
             /* Stop timer T305 */
             rrctmr_stop_timer(RRCTMR_T_305_TIMER);
#endif /*FEATURE_UPDATE_SIB7_FOR_PCH_TO_FACH*/           
             WRRC_MSG0_HIGH("BPLMN search in progess. Abort before sending CU");
             /* Important:  Always set CU substate before calling func send bplmn suspend
              * req 
              */
             rrccu_substate = RRCCU_WAIT_FOR_BPLMN_SUSPEND_CNF;
             rrc_csp_send_bplmn_suspend_req(RRC_PROCEDURE_CU, BPLMN_SUSPEND_REASON_OTHER); 
           }
           else
           {
#ifdef  FEATURE_UPDATE_SIB7_FOR_PCH_TO_FACH
             if(FALSE == rrcsib_check_and_update_sib7_validity(RRC_PROCEDURE_CU))
             {
               /*Note that T305 isn't running now and CU/UU cause has been updated with CU/UU started status*/
               WRRC_MSG0_HIGH("CU procedure waiting for SIB7");
#ifdef FEATURE_DUAL_SIM
               if(rrc_acquire_lock_for_pch_to_fach() == SUCCESS)
#endif /*FEATURE_DUAL_SIM*/
               {
               rrccu_substate = RRCCU_WAIT_FOR_SIB7_CURRENT;
             }
#ifdef FEATURE_DUAL_SIM
               else
               {
                 rrccu_process_oos_area_handling();
               }
#endif /*FEATURE_DUAL_SIM*/		
             }
             else
#endif /*FEATURE_UPDATE_SIB7_FOR_PCH_TO_FACH*/
             {           
#ifdef  FEATURE_UPDATE_SIB7_FOR_PCH_TO_FACH
               /* Stop timer T305 */
               rrctmr_stop_timer(RRCTMR_T_305_TIMER);             
#endif /*FEATURE_UPDATE_SIB7_FOR_PCH_TO_FACH*/
#ifdef FEATURE_DUAL_SIM
               if(rrc_acquire_lock_for_pch_to_fach() == SUCCESS)
#endif /*FEATURE_DUAL_SIM*/
               {
               rrccu_establish_srb(TRUE, RRC_STATE_CELL_FACH, TRUE);
               rrccu_substate = RRCCU_WAIT_FOR_RB0_EST_CNF;
             }
#ifdef FEATURE_DUAL_SIM
               else
               {
                 rrccu_process_oos_area_handling();
               }
#endif /*FEATURE_DUAL_SIM*/
             }
           }
           
         }
         break;

       case RRC_URA_UPDATE_INITIATE_REQ:
         if(RRCCU_SUCCESS == 
            rrccu_validate_ura_update_initiate_req(cmd_ptr)) 
         {
           if (rrccu_ura_update_required)
           {
             rrccu_ura_update_required = FALSE;
           }
           else if (cmd_ptr->cmd.initiate_ura_update.procedure != RRC_PROCEDURE_CU)
           {
             /* in case of rrccu procedure originated ura update this flag will be cleared
             by this time because of clear procedure is called after initiating ura update 
             So it is ok if flag is set to zero */
             WRRC_MSG0_ERROR("URA update flag is not set");
           }
           /* set Cell_update_started flag here */
           rrccu_ura_update_started = TRUE;
#ifndef FEATURE_UPDATE_SIB7_FOR_PCH_TO_FACH   
           /* Stop timer T305 */
           rrctmr_stop_timer(RRCTMR_T_305_TIMER);
#endif /*FEATURE_UPDATE_SIB7_FOR_PCH_TO_FACH*/
           /* Update ura Update cause */
           rrccu_ura_update_cause = 
             rrccu_map_uu_initiation_cause(cmd_ptr->cmd.initiate_ura_update.cause);

           /* Check if BPLMN is in progress.  If so abort*/
           if (rrc_csp_bplmn_srch_in_progress() != WTOW_SEARCH_STOP ) 
           {
#ifdef FEATURE_UPDATE_SIB7_FOR_PCH_TO_FACH   
           /* Stop timer T305 */
           rrctmr_stop_timer(RRCTMR_T_305_TIMER);
#endif /*FEATURE_UPDATE_SIB7_FOR_PCH_TO_FACH*/           
             WRRC_MSG0_HIGH("BPLMN search in progess.  Abort before sending CU");
             /* Important:  Always set CU substate before calling func send bplmn suspend
              * req 
              */
             rrccu_substate = RRCCU_WAIT_FOR_BPLMN_SUSPEND_CNF;
             rrc_csp_send_bplmn_suspend_req(RRC_PROCEDURE_CU, BPLMN_SUSPEND_REASON_OTHER); 
           }
           else
           {
#ifdef FEATURE_UPDATE_SIB7_FOR_PCH_TO_FACH           
             if(FALSE == rrcsib_check_and_update_sib7_validity(RRC_PROCEDURE_CU))
             {
               /*Note that T305 isn't running now and CU/UU cause has been updated with CU/UU started status*/
               WRRC_MSG0_HIGH("CU procedure waiting for SIB7");
#ifdef FEATURE_DUAL_SIM
               if(rrc_acquire_lock_for_pch_to_fach() == SUCCESS)
#endif /*FEATURE_DUAL_SIM*/
               {
               rrccu_substate = RRCCU_WAIT_FOR_SIB7_CURRENT;
             }
#ifdef FEATURE_DUAL_SIM
               else
               {
                 rrccu_process_oos_area_handling();
               }
#endif /*FEATURE_DUAL_SIM*/
             }
             else
#endif /*FEATURE_UPDATE_SIB7_FOR_PCH_TO_FACH*/
             {           
#ifdef FEATURE_UPDATE_SIB7_FOR_PCH_TO_FACH                
               /* Stop timer T305 */
               rrctmr_stop_timer(RRCTMR_T_305_TIMER);             
#endif /*FEATURE_UPDATE_SIB7_FOR_PCH_TO_FACH*/

               /* Send RRC_CHANNEL_CONFIG_REQ to RRC LLC to establish SRB */
#ifdef FEATURE_DUAL_SIM
               if(rrc_acquire_lock_for_pch_to_fach() == SUCCESS)
#endif /*FEATURE_DUAL_SIM*/
               {
               rrccu_establish_srb(TRUE, RRC_STATE_CELL_FACH, TRUE);
               rrccu_substate = RRCCU_WAIT_FOR_RB0_EST_CNF; 
             }
#ifdef FEATURE_DUAL_SIM
               else
               {
                 rrccu_process_oos_area_handling();
               }
#endif /*FEATURE_DUAL_SIM*/
             }
           }
         }
         break;

       case RRC_NEW_CELL_IND:
         WRRC_MSG2_HIGH("Cell reselection in state:%d, cu_state:%d", current_rrc_state, rrccu_substate);
         if (RRC_STATE_CELL_PCH == current_rrc_state)
         {
           /* set Cell_update_started flag here */
           rrccu_cell_update_started = TRUE;

           /* Stop timer T305 */
           rrctmr_stop_timer(RRCTMR_T_305_TIMER);
           /* Update Cell Update cause */
           rrccu_cell_update_cause = rrc_CellUpdateCause_cellReselection;
           /* Check if BPLMN is in progress.  If so abort*/
           if (rrc_csp_bplmn_srch_in_progress() != WTOW_SEARCH_STOP ) 
           {
             WRRC_MSG0_HIGH("BPLMN search in progess.  Abort before sending CU");
             /* Important:  Always set CU substate before calling func send bplmn suspend
              * req 
              */
             rrccu_substate = RRCCU_WAIT_FOR_BPLMN_SUSPEND_CNF;
             rrc_csp_send_bplmn_suspend_req(RRC_PROCEDURE_CU, BPLMN_SUSPEND_REASON_OTHER); 
           }
           else
           {
#ifdef FEATURE_DUAL_SIM
             if(rrc_acquire_lock_for_pch_to_fach() == SUCCESS)
#endif /*FEATURE_DUAL_SIM*/
             {
             rrccu_establish_srb (TRUE, RRC_STATE_CELL_FACH, TRUE);
             rrccu_substate = RRCCU_WAIT_FOR_RB0_EST_CNF; 
           }
#ifdef FEATURE_DUAL_SIM
             else
             {
               rrccu_process_oos_area_handling();
             }
#endif /*FEATURE_DUAL_SIM*/
           }
         }
         else /* current state is URA_PCH */
         {
            /* This function would check if a URA reselection occurred */
           if (rrccu_check_for_ura_reselection())
           {
             /* set Cell_update_started flag here */
             rrccu_ura_update_started = TRUE;
             /* Stop timer T305 */
             rrctmr_stop_timer(RRCTMR_T_305_TIMER);
             /* Update URA Update cause */
             rrccu_ura_update_cause = rrc_URA_UpdateCause_changeOfURA;

             /* Check if BPLMN is in progress.  If so abort*/
             if (rrc_csp_bplmn_srch_in_progress() != WTOW_SEARCH_STOP ) 
             {
               WRRC_MSG0_HIGH("BPLMN search in progess.  Abort before sending CU");
               /* Important:  Always set CU substate before calling func send bplmn suspend
                * req 
                */
               rrccu_substate = RRCCU_WAIT_FOR_BPLMN_SUSPEND_CNF;
               rrc_csp_send_bplmn_suspend_req(RRC_PROCEDURE_CU, BPLMN_SUSPEND_REASON_OTHER); 
             }
             else
             {
               /*------------------------------------------------------------
               Initiate a state transition to CELL_FACH state. The URA update
               message can be sent only in CELL_FACH state
               -------------------------------------------------------------*/
#ifdef FEATURE_DUAL_SIM
               if(rrc_acquire_lock_for_pch_to_fach() == SUCCESS)
#endif /*FEATURE_DUAL_SIM*/
               {
               rrccu_establish_srb(TRUE, RRC_STATE_CELL_FACH, TRUE);
               rrccu_substate = RRCCU_WAIT_FOR_RB0_EST_CNF; 
             }
#ifdef FEATURE_DUAL_SIM
               else
               {
                 rrccu_process_oos_area_handling();
               }
#endif /*FEATURE_DUAL_SIM*/
             }
           }
         }
         break;
       case RRC_T305_EXPIRED_IND:
         WRRC_MSG2_HIGH("Timer T305 expired in state: %d, cu_substate: %d", current_rrc_state, rrccu_substate);
         if (RRC_STATE_CELL_PCH == current_rrc_state)
         {
           /* set Cell_update_started flag here */
           rrccu_cell_update_started = TRUE;
           /* Update Cell Update cause */
           rrccu_cell_update_cause = rrc_CellUpdateCause_periodicalCellUpdate;
         }
         else /* current state is URA_PCH */
         {
           /* set ura_update_started flag here */
           rrccu_ura_update_started = TRUE;
           /* Update URA Update cause */
           rrccu_ura_update_cause = rrc_URA_UpdateCause_periodicURAUpdate;
         }
         /*In case peridic cell Update timer expires when DELAY CU is active, update the cause to 
           UL data indication if expiry is in PCH state and Cell reselection in FACH state.
           NW may not provide RNTI set if cause is set to periodic cell update*/
         if(rrccu_get_hsrach_sib_change())
         {
           rrccu_cell_update_cause = rrc_CellUpdateCause_uplinkDataTransmission;
         }
         rrctmr_stop_timer(RRCTMR_T_305_TIMER);
         /* Check if BPLMN is in progress.  If so abort*/
         if (rrc_csp_bplmn_srch_in_progress() != WTOW_SEARCH_STOP ) 
         {
           WRRC_MSG1_HIGH("BPLMN search in progess.  Abort before sending CU and Start T307 %d",rrccu_convert_t307_to_ms(RRC_GET_T307()));
           /* start the timer T307  and remain in the same substate */
           rrctmr_start_timer(RRCTMR_T_307_TIMER, 
                              rrccu_convert_t307_to_ms( RRC_GET_T307() ) );
           /* Important:  Always set CU substate before calling func send bplmn suspend
            * req 
            */
           rrccu_substate = RRCCU_WAIT_FOR_BPLMN_SUSPEND_CNF;
           rrc_csp_send_bplmn_suspend_req(RRC_PROCEDURE_CU, BPLMN_SUSPEND_REASON_OTHER); 
         }
         else
         {
#ifdef FEATURE_UPDATE_SIB7_FOR_PCH_TO_FACH         
           if(FALSE == rrcsib_check_and_update_sib7_validity(RRC_PROCEDURE_CU))
           {
             /*Note that T305 isn't running now and CU/UU cause has been updated with CU/UU started status*/
             WRRC_MSG0_HIGH("CU procedure waiting for SIB7");
#ifdef FEATURE_DUAL_SIM
             if(rrc_acquire_lock_for_pch_to_fach() == SUCCESS)
#endif /*FEATURE_DUAL_SIM*/
             {
               /* Send RRC_CHANNEL_CONFIG_REQ to RRC LLC to establish SRB */
             rrccu_substate = RRCCU_WAIT_FOR_SIB7_CURRENT;
           }
#ifdef FEATURE_DUAL_SIM
             else
             {
               rrccu_process_oos_area_handling();
             }
#endif /*FEATURE_DUAL_SIM*/			 
           }
           else
#endif /*FEATURE_UPDATE_SIB7_FOR_PCH_TO_FACH*/
           {
#ifdef FEATURE_DUAL_SIM
             if(rrc_acquire_lock_for_pch_to_fach() == SUCCESS)
#endif /*FEATURE_DUAL_SIM*/
             {
             /* Send RRC_CHANNEL_CONFIG_REQ to RRC LLC to establish SRB */
             rrccu_establish_srb(TRUE, RRC_STATE_CELL_FACH, TRUE);
             rrccu_substate = RRCCU_WAIT_FOR_RB0_EST_CNF; 
           } 
#ifdef FEATURE_DUAL_SIM
             else
             {
               rrccu_process_oos_area_handling();
             }
#endif /*FEATURE_DUAL_SIM*/
           }
         }
         break;

        default:
          WRRC_MSG2_ERROR("Unknown command: 0x%x, CU st %d", cmd_ptr->cmd_hdr.cmd_id,rrccu_substate);
          break;
      }
      break;

    default:
      WRRC_MSG2_HIGH("Invalid Event: %d in the substate: %d", 
                cmd_ptr->cmd_hdr.cmd_id, rrccu_substate);
      break;
  }
} /* rrccu_process_cu_initial */


/*===========================================================================

FUNCTION rrcu_process_timer_t315_expired

DESCRIPTION
  This function processes RRC_T315_EXPIRED_IND event. It checks whether T314
  is already expired. If T314 expired, then it will bring down RRC Connection
  and waits for RRC_CHANNEL_CONFIG_CNF from the RRC LLC. Otherwise it releases
  the RBs associated with T315 and remain in the same CU substate.
  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
void rrcu_process_timer_t315_expired
(    
  void
)
{

  MSG_HIGH("Timer T315 expired,T314 status: %d[NOT_STARTED, STARTED, EXPIERD], cu_subst:%d, RRC_state:%d",
           rrccu_rl_failure_info.t314_info.timer_status, rrccu_substate,rrc_get_state());
  if (rrccu_rl_failure_info.t314_info.timer_status == RE_EST_TIMER_STARTED)
  {
    /* do not want to send the channel config here *
    store the expiry info so that the corresponding RBs are
    released after UE goes to a stable state */
    rrccu_rl_failure_info.t315_info.timer_status         = RE_EST_TIMER_EXPIRED;
    rrccu_rl_failure_info.t315_info.need_to_release_rabs = TRUE;

    if (rrccu_substate == RRCCU_WAIT_FOR_UE_TO_CAMP_ON) 
    {
      /* Send Rab_rel_ind for rabs assosiated with t315 */
      rrccu_send_rab_rel_ind_for_rbs_associated_with_re_est_timer(rrc_Re_EstablishmentTimer_useT315);
    }
    else
    {
      rrccu_rl_failure_info.t315_info.need_rab_release_ind = TRUE;
    }
  }
  else
  {
    /* Since both T314 and T315 are expired, bring down RRC Connection */
  rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                       RRC_TX_TO_DISCON_OTHER);
    /* Update the release cause */
    rrc_release_cause = RRC_REL_DEEP_FADE;
    rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
  }
} /* rrcu_process_timer_t315_expired */
/*===========================================================================

FUNCTION rrcu_process_timer_t314_expired

DESCRIPTION
  This function processes RRC_T314_EXPIRED_IND event. It checks whether T315
  is already expired. If T315 expired, then it will bring down RRC Connection
  and waits for RRC_CHANNEL_CONFIG_CNF from RRC LLC. Otherwise it releases
  the RBs associated with T314 and remain in the same CU substate.
  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
void rrcu_process_timer_t314_expired
(    
  void
)
{
  MSG_HIGH("Timer T314 expired,T315 status: %d[NOT_STARTED, STARTED, EXPIERD], cu_subst:%d, RRC_state:%d",
           rrccu_rl_failure_info.t315_info.timer_status, rrccu_substate,rrc_get_state());
  if (rrccu_rl_failure_info.t315_info.timer_status == RE_EST_TIMER_STARTED)
  {
    /* do not want to send the channel config here *
    store the expiry info so that the corresponding RBs are
    released after UE goes to a stable state */
    rrccu_rl_failure_info.t314_info.timer_status         = RE_EST_TIMER_EXPIRED;
    rrccu_rl_failure_info.t314_info.need_to_release_rabs = TRUE;
    if (rrccu_substate == RRCCU_WAIT_FOR_UE_TO_CAMP_ON) 
    {
      /* Send Rab_rel_ind for rabs assosiated with t314 */
      rrccu_send_rab_rel_ind_for_rbs_associated_with_re_est_timer(rrc_Re_EstablishmentTimer_useT314);
    }
    else
    {
      rrccu_rl_failure_info.t314_info.need_rab_release_ind = TRUE;
    }
  }
  else
  {
    /* Since both T314 and T315 are expired, bring down RRC Connection */
    rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                         RRC_TX_TO_DISCON_OTHER);
      /* Update the release cause */
      rrc_release_cause = RRC_REL_DEEP_FADE;
      rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
    }
} /* rrcu_process_timer_t314_expired */


/*===========================================================================

FUNCTION RRCCU_PROCESS_CU_WAIT_FOR_RB_PROC_COMPL_IND

DESCRIPTION
  This function processes all events that are dispatched to Cell Update 
  procedure in RRCCU_WAIT_FOR_RB_PROC_COMPL_IND substate.

  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
void rrccu_process_cu_wait_for_rb_proc_compl_ind
(    
  rrc_cmd_type *cmd_ptr
)
{
  rrc_state_e_type current_rrc_state = rrc_get_state();
  rlc_lc_id_type ul_rlc_lc_id = RRCLCM_RLC_LC_ID_NOT_FOUND;

    switch(current_rrc_state)
    {
      case RRC_STATE_CELL_FACH:
        switch(cmd_ptr->cmd_hdr.cmd_id)
        {
          case RRC_RB_PROC_COMPL_IND:
            WRRC_MSG0_HIGH("Rcvd RRC_RB_PROC_COMPL_IND.  Est SRBs");
            /* Stop timer T305 */
            rrctmr_stop_timer(RRCTMR_T_305_TIMER);
            /* Stop timer T307 */
            rrctmr_stop_timer(RRCTMR_T_307_TIMER);

            /* Check whether RB0 is already established */
            ul_rlc_lc_id = rrclcm_check_ul_rlc_lc_id(UE_LOGCHAN_CCCH, 
                                                     CCCH_RADIO_BEARER_ID,
                                                     UE_MODE_TRANSPARENT);

            if(ul_rlc_lc_id == RRCLCM_RLC_LC_ID_NOT_FOUND)
            {
              /* Send RRC_CHANNEL_CONFIG_REQ to RRC LLC to establish RB0 */
              rrccu_establish_rb0(ESTABLISH_RB,RRC_STATE_CELL_FACH, TRUE);

              rrccu_substate = RRCCU_WAIT_FOR_RB0_EST_CNF; 
            }
            else
            {
              /* Stop timer T305 */
              rrctmr_stop_timer(RRCTMR_T_305_TIMER);

              /* Enqueue Cell Update Message in the Uplink Queue.
               This function also starts T302 timer */
              if (RRCCU_SUCCESS == rrccu_send_cell_update_msg(ul_rlc_lc_id,
                                                              RRCCU_NOT_INCLUDE_FAILURE_CAUSE) )
              {        
                rrccu_substate = RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM; 
              }
              else
              {
                /* unable to send CU...  Take UE to idle */
                rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                                     RRC_TX_TO_DISCON_OTHER);
                /* Update the release cause */
                rrc_release_cause = RRC_REL_DEEP_FADE;
                rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
              }
            }

            break;

          case RRC_T305_EXPIRED_IND:
            WRRC_MSG2_HIGH("Timer T305 Expired in state: %d, Start T307 %d",rrc_get_state(),rrccu_convert_t307_to_ms(RRC_GET_T307()));
            /* start the timer T307  and remain in the same substate */
            rrctmr_start_timer(RRCTMR_T_307_TIMER, 
                               rrccu_convert_t307_to_ms( RRC_GET_T307() ) );
            break;

          case RRC_T307_EXPIRED_IND:
            WRRC_MSG1_HIGH("Timer T307 Expired in state: %d", rrc_get_state());
            /* stop the oos timer */
            rrctmr_stop_timer(RRCTMR_T_OOS_TIMER);
            /* Since Timer T307 expired after T305 are expired, 
            bring down the RRC Connection */
            rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                                 RRC_TX_TO_DISCON_OTHER);
              /* Update the release cause */
            rrc_release_cause = RRC_REL_DEEP_FADE;
            rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
            break;

          case RRC_CPHY_OUT_OF_SERVICE_AREA_IND:  /* NEED to re-visit */
            event_report(EVENT_WCDMA_OUT_OF_SERVICE);
            rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                                 RRC_TX_TO_DISCON_OTHER);
              /* Update the release cause */
              rrc_release_cause = RRC_REL_DEEP_FADE;
              rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;

            break;

          case RRC_CELL_UPDATE_INITIATE_REQ:
            /* Same hanldine as OOS from L1 */
            if(cmd_ptr->cmd.initiate_cell_update.cause == RRC_REENTERED_SERVICE_AREA)
            {
              rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,RRC_TX_TO_DISCON_OTHER);
              /* Update the release cause */
              rrc_release_cause = RRC_REL_DEEP_FADE;
              rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
              break;
            }
            if(RRCCU_SUCCESS == 
               rrccu_validate_cell_update_initiate_req(cmd_ptr))
            {

            /* if CU is in this substate to do a URA update, it needs to change to cell update  */
              if (!rrccu_cell_update_started)
              {
                rrccu_cell_update_started = TRUE;
                rrccu_ura_update_started = FALSE;
              }
              
              rrccu_cell_update_cause = 
                rrccu_map_cu_cause_based_on_priority(cmd_ptr->cmd.initiate_cell_update.cause);

              if((cmd_ptr->cmd.initiate_cell_update.procedure == RRC_PROCEDURE_RBE) ||
                 (cmd_ptr->cmd.initiate_cell_update.procedure == RRC_PROCEDURE_RBRC) ||
                 (cmd_ptr->cmd.initiate_cell_update.procedure == RRC_PROCEDURE_RBR) ||
                 (cmd_ptr->cmd.initiate_cell_update.procedure == RRC_PROCEDURE_PCR) ||
                 (cmd_ptr->cmd.initiate_cell_update.procedure == RRC_PROCEDURE_TCR))
              {
                WRRC_MSG0_HIGH("Rcvd CU in RRCCU_WAIT_FOR_RB_PROC_COMPL_IND.  Initiate CU");
                /* Stop timer T305 */
                rrctmr_stop_timer(RRCTMR_T_305_TIMER);
                /* Stop timer T307 */
                rrctmr_stop_timer(RRCTMR_T_307_TIMER);

                /* Check whether RB0 is already established */
                ul_rlc_lc_id = rrclcm_check_ul_rlc_lc_id(UE_LOGCHAN_CCCH, 
                                                         CCCH_RADIO_BEARER_ID,
                                                         UE_MODE_TRANSPARENT);
                
#ifdef FEATURE_WCDMA_HS_FACH
                if(rrcenhstate_camped_cell_supports_e_fach() == TRUE)
                {
                  rrcllc_establish_srb_rab_in_efach(RRC_E_FACH_COMMON,RRC_PROCEDURE_CU,FALSE);
                  rrccu_substate = RRCCU_WAIT_FOR_RB0_EST_CNF;
                }
                else
#endif
                if(ul_rlc_lc_id == RRCLCM_RLC_LC_ID_NOT_FOUND)
                {
                  /* Send RRC_CHANNEL_CONFIG_REQ to RRC LLC to establish RB0 */
                  rrccu_establish_rb0(ESTABLISH_RB,RRC_STATE_CELL_FACH, TRUE);
                  
                  rrccu_substate = RRCCU_WAIT_FOR_RB0_EST_CNF; 
                }
                else
                {
                  /* Stop timer T305 */
                  rrctmr_stop_timer(RRCTMR_T_305_TIMER);
                  
                /*  Enqueue Cell Update Message in the Uplink Queue.
                   This function also starts T302 timer */
                  if (RRCCU_SUCCESS == rrccu_send_cell_update_msg(ul_rlc_lc_id,
                                                                  RRCCU_NOT_INCLUDE_FAILURE_CAUSE) )
                  {        
                    rrccu_substate = RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM; 
                  }
                  else
                  {
                    /* unable to send CU...  Take UE to idle */
                    rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                                         RRC_TX_TO_DISCON_OTHER);
                    /* Update the release cause */
                    rrc_release_cause = RRC_REL_DEEP_FADE;
                    rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
                }
              }
            }
            }
            break;

          case RRC_NEW_CELL_IND:
            WRRC_MSG1_HIGH("NEW CELL IND in cu_state:%d . Remap cause",rrccu_substate);
            if (rrccu_cell_update_started) 
            {
              rrccu_cell_update_cause = 
                rrccu_map_cu_cause_based_on_priority(RRC_CELL_RESELECTION);
            }

            break;

          default:
            WRRC_MSG1_ERROR("Unexpected UE state and cmd %d ",cmd_ptr->cmd_hdr.cmd_id);
            break;
        }
        break;

      case RRC_STATE_CELL_PCH:
      case RRC_STATE_URA_PCH:
        switch(cmd_ptr->cmd_hdr.cmd_id)
        {
          case RRC_RB_PROC_COMPL_IND:
            /* Stop timer T305 */
            rrctmr_stop_timer(RRCTMR_T_305_TIMER);
            /* Stop timer T307 */
            rrctmr_stop_timer(RRCTMR_T_307_TIMER);
              
#ifdef FEATURE_DUAL_SIM
            if(rrc_acquire_lock_for_pch_to_fach() == SUCCESS)
#endif /*FEATURE_DUAL_SIM*/
            {
            rrccu_establish_srb(TRUE, RRC_STATE_CELL_FACH, TRUE);
            rrccu_substate = RRCCU_WAIT_FOR_RB0_EST_CNF; 
            }
#ifdef FEATURE_DUAL_SIM
            else
            {
              ERR_FATAL("LOCK isn't acquired in CU substate %d",rrccu_substate,0,0);
            }
#endif /*FEATURE_DUAL_SIM*/
            break;

          case RRC_T305_EXPIRED_IND:
            /* start the timer T307  and remain in the same substate */
            rrctmr_start_timer(RRCTMR_T_307_TIMER, 
                               rrccu_convert_t307_to_ms( RRC_GET_T307() ) );
            break;

          case RRC_T307_EXPIRED_IND:
            /* stop the oos timer */
            rrctmr_stop_timer(RRCTMR_T_OOS_TIMER);
            /* Since Timer T307 expired after T305 are expired, 
            bring down the RRC Connection */
            rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                                 RRC_TX_TO_DISCON_OTHER);
              /* Update the release cause */
            rrc_release_cause = RRC_REL_DEEP_FADE;
            rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
            break;

          case RRC_CPHY_OUT_OF_SERVICE_AREA_IND:  /* NEED to re-visit */
            event_report(EVENT_WCDMA_OUT_OF_SERVICE);
            rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                                 RRC_TX_TO_DISCON_OTHER);
              /* Update the release cause */
            rrc_release_cause = RRC_REL_DEEP_FADE;
            rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
            break;

          case RRC_CELL_UPDATE_INITIATE_REQ:
            if(RRCCU_SUCCESS == 
               rrccu_validate_cell_update_initiate_req(cmd_ptr)) 
            {
              if( (cmd_ptr->cmd.initiate_cell_update.cause == RRC_REENTERED_SERVICE_AREA) &&
                  ((cmd_ptr->cmd.initiate_cell_update.procedure == RRC_PROCEDURE_CSP)||
                   (cmd_ptr->cmd.initiate_cell_update.procedure == RRC_PROCEDURE_SIB)) 
                  )
              {
                rrccu_process_oos_area_handling();
                return;
              }

              /* set Cell_update_started flag here */
              rrccu_cell_update_started = TRUE;
              rrccu_ura_update_started = FALSE;
              /* Stop timer T305 */
              rrctmr_stop_timer(RRCTMR_T_305_TIMER);

              /* Update Cell Update cause */
              rrccu_cell_update_cause = 
                rrccu_map_cu_initiation_cause(cmd_ptr->cmd.initiate_cell_update.cause);
           
              /* Check if BPLMN is in progress.  If so abort*/
              if (rrc_csp_bplmn_srch_in_progress() != WTOW_SEARCH_STOP ) 
              {
                WRRC_MSG0_HIGH("BPLMN search in progess. Abort before sending CU");
                /* Important:  Always set CU substate before calling func send bplmn suspend
                 * req 
                 */
                rrccu_substate = RRCCU_WAIT_FOR_BPLMN_SUSPEND_CNF;
                rrc_csp_send_bplmn_suspend_req(RRC_PROCEDURE_CU, BPLMN_SUSPEND_REASON_OTHER); 
              }
              else
              {
#ifdef FEATURE_DUAL_SIM
                if(rrc_acquire_lock_for_pch_to_fach() == SUCCESS)
#endif /*FEATURE_DUAL_SIM*/
                {
                rrccu_establish_srb(TRUE, RRC_STATE_CELL_FACH, TRUE);
                rrccu_substate = RRCCU_WAIT_FOR_RB0_EST_CNF;
              }                    
#ifdef FEATURE_DUAL_SIM
                else
                {
                  ERR_FATAL("LOCK isn't acquired in CU substate %d",rrccu_substate,0,0);
                }
#endif /*FEATURE_DUAL_SIM*/
              }                    
            }
            break;

          case RRC_NEW_CELL_IND:
            WRRC_MSG1_HIGH("NEW CELL IND in cu_state:%d . Remap cause",rrccu_substate);
            if (rrccu_cell_update_started) 
            {
              rrccu_cell_update_cause = 
                rrccu_map_cu_cause_based_on_priority(RRC_CELL_RESELECTION);
            }
            else
            {
              if (rrccu_check_for_ura_reselection())
              {
                /* set Cell_update_started flag here */
                rrccu_ura_update_cause = rrc_URA_UpdateCause_changeOfURA;
              }
            }
            break;

          case RRC_SIB_CHANGE_IND:
            WRRC_MSG2_HIGH("SIB modification state:%d, cu_state:%d",
                     current_rrc_state, rrccu_substate);
            if (rrccu_ura_update_started)
            {              
              if (RRC_STATE_URA_PCH == current_rrc_state)
              {
                /* This function would check if a URA reselection occurred */
                if (rrccu_check_for_ura_reselection())
                {
                  /* Update URA Update cause */
                  rrccu_ura_update_cause = rrc_URA_UpdateCause_changeOfURA;      
                }
              }
            }
            break;

          default:
            WRRC_MSG1_ERROR("Unexpected UE state and cmd %d ",cmd_ptr->cmd_hdr.cmd_id);
            break;
        }
        break;
      default:
        WRRC_MSG1_ERROR("Unexpected UE state and cmd %d",cmd_ptr->cmd_hdr.cmd_id);
        break;
    }
}
/*===========================================================================

FUNCTION RRCU_PROCESS_CU_WAIT_FOR_UE_TO_CAMP_ON

DESCRIPTION
  This function processes all events that are dispatched to Cell Update 
  procedure in RRCCU_WAIT_FOR_UE_TO_CAMP_ON substate.
  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
static void rrccu_process_cu_wait_for_ue_to_camp_on
(    
  rrc_cmd_type *cmd_ptr
)
{
  rlc_lc_id_type ul_rlc_lc_id = RRCLCM_RLC_LC_ID_NOT_FOUND;
                                /* Local varible for Uplink RLC LC Id. */

  switch(rrc_get_state())
  {
    case RRC_STATE_CELL_DCH:
      switch(cmd_ptr->cmd_hdr.cmd_id)
      {
        case RRC_T314_EXPIRED_IND:
          /* This function brings down RRC Connection and waits for
             RRC_CHANNEL_CONFIG_CNF from RRC LLC if both T314 and T315 are
             expired. Otherwise releases the RBs associated T314 */
          rrcu_process_timer_t314_expired();
          break;

        case RRC_T315_EXPIRED_IND:
          /* This function brings down RRC Connection and waits for
             RRC_CHANNEL_CONFIG_CNF from RRC LLC if both T314 and T315 are
             expired. Otherwise releases the RBs associtaed with T315 */
          rrcu_process_timer_t315_expired();
          break;

        case RRC_CELL_UPDATE_INITIATE_REQ:
          if((RRCCU_SUCCESS == 
              rrccu_validate_cell_update_initiate_req(cmd_ptr)) &&
             (cmd_ptr->cmd.initiate_cell_update.cause == 
              RRC_RADIO_LINK_FAILURE ) )
          {
            /* Since CU with Radio Link Failure is active, Ignore the
               subsequent CUs */
            /* get the appropriate cell update cause */
            rrccu_cell_update_cause = 
              rrccu_map_cu_cause_based_on_priority (RRC_RADIO_LINK_FAILURE);
          }
          break;

        case RRC_CRLC_STATUS_IND:
          /* Call the function to process rlc status indication 
          in non initial custate */ 
          rrccu_process_rlc_status_ind_in_non_initial_sub_states(cmd_ptr);
          break;

        case RRC_T316_EXPIRED_IND:
          /* After T316 expiry UE should start the min between T305 [or continue if 
           * it's already ticking] and Toos
           */
          /* Start min(T305, Toos) */
          rrccu_start_t305_or_oos_timer();
          
          /* CU shall remain in the same substate. */
          break;

        case RRC_T305_EXPIRED_IND:
          /* start the timer T307  and remain in the same substate */
          rrctmr_start_timer(RRCTMR_T_307_TIMER, 
                     rrccu_convert_t307_to_ms( RRC_GET_T307() ) );
          break;

        case RRC_T307_EXPIRED_IND:
          /* Since Timer T307 expired after T305 are expired, 
            bring down the RRC Connection */
          /* stop the oos timer */
          rrctmr_stop_timer(RRCTMR_T_OOS_TIMER);
          rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                               RRC_TX_TO_DISCON_OTHER);
            /* Update the release cause */
          rrc_release_cause = RRC_REL_DEEP_FADE;
          rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
          break;

        case RRC_OOS_TIMER_EXPIRED_IND:
          /* Since Timer OOS_TIMER expired, bring down the RRC Connection */
          rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                               RRC_TX_TO_DISCON_OTHER);
            /* Update the realease cause */
          rrc_release_cause = RRC_REL_DEEP_FADE;
          rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
          break;

        default:
          WRRC_MSG2_ERROR("Unknown command: 0x%x, CU st %d", cmd_ptr->cmd_hdr.cmd_id,rrccu_substate);
          break;
      }
      break;

    case RRC_STATE_CELL_FACH:
      switch(cmd_ptr->cmd_hdr.cmd_id)
      { 
        case RRC_T305_EXPIRED_IND:

          /* start the timer T307  and remain in the same substate */
          rrctmr_start_timer(RRCTMR_T_307_TIMER, 
                     rrccu_convert_t307_to_ms( RRC_GET_T307() ) );

          break;

        case RRC_T317_EXPIRED_IND:
          /* Since Timer T317 expired, bring down the RRC Connection */
          rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                               RRC_TX_TO_DISCON_OTHER);
            /* Update the release cause */
          rrc_release_cause = RRC_REL_CAUSE_OOS;
          rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
          break;

        case RRC_T307_EXPIRED_IND:
           /* Since Timer T307 expired after T305 are expired, 
              bring down the RRC Connection */
          /* stop the oos timer */
          rrctmr_stop_timer(RRCTMR_T_OOS_TIMER);
          rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                               RRC_TX_TO_DISCON_OTHER);
            /* Update the release cause */
          rrc_release_cause = RRC_REL_CAUSE_OOS;
          rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
          break;

        case RRC_OOS_TIMER_EXPIRED_IND:
          /* Since Timer OOS_TIMER expired, bring down the RRC Connection */
          rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                               RRC_TX_TO_DISCON_OTHER);
            /* Update the realease cause */
          rrc_release_cause = RRC_REL_CAUSE_OOS;
          rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
          break;


        case RRC_NEW_CELL_IND:
          WRRC_MSG2_HIGH("NEW_CELL_IND in state:%d, cu_state:%d",
                   rrc_get_state(),rrccu_substate);
          /*In case of Fre-redirection received in CU Cnf to FACH, Cell Selection is 
            * triggered. After going to new cell, the NEW_CELL_IND is received
            * so configure Lower layer with OTA contntents
            */
          if((rrccu_int_data.rrccu_cell_selection_trans_from_fach)&&
             (rrccu_oc_set_by_cu == TRUE))
          {
            rrc_cmd_type *chan_cmd_ptr;                     /* Pointer to the RRC Command */
                        
            rrccu_int_data.rrccu_cell_selection_trans_from_fach = FALSE;
            /* If the UE has camped on directed cell then do not send a cell update,
              * else send a CELL update with cause "cell Re-selection 
              "*/
            if(rrccsp_is_selected_cell_utran_directed() == FALSE)    
            {
              rrccu_cu_initiate_reqd.cu_reqd = TRUE;
              rrccu_cu_initiate_reqd.cu_cause = rrc_CellUpdateCause_cellReselection;
            }
               
#ifdef FEATURE_WCDMA_HS_FACH
 /* If H-RNTI is not given in OTA then initiate cell update*/
            if(rrcenhstate_set_hrnti_status_for_transitions())
            {
              rrccu_cu_initiate_reqd.cu_reqd = TRUE;
              rrccu_cu_initiate_reqd.cu_cause = rrc_CellUpdateCause_cellReselection;
            }
#endif

#ifdef FEATURE_WCDMA_HS_RACH
            /* Check if E-RNTI is not given in OTA then initiate cell update*/
            if(rrchsrach_check_ernti_status())
            {
              rrccu_cu_initiate_reqd.cu_reqd = TRUE;
              rrccu_cu_initiate_reqd.cu_cause = rrc_CellUpdateCause_cellReselection;
            }
#endif


            /*Send Channel config req */
 
            if(rrccu_chan_config_reqd)
            {
              uint8 idx;
              rrccu_chan_config_reqd = FALSE;
              /* Allocates the buffer to RRC Internal command */
              chan_cmd_ptr =  rrc_get_int_cmd_buf();
              /* Fill in the command parameters for RRC_CHANNEL_CONFIG_REQ */
              chan_cmd_ptr->cmd_hdr.cmd_id = RRC_CHANNEL_CONFIG_REQ;
              chan_cmd_ptr->cmd.chan_config_req.procedure = RRC_PROCEDURE_CU;
              /* Fill in parameters for RRC_CHANNEL_CONFIG_REQ command */
              chan_cmd_ptr->cmd.chan_config_req.rrc_state_change_required = FALSE;
              chan_cmd_ptr->cmd.chan_config_req.next_state = RRC_STATE_CELL_FACH;
              chan_cmd_ptr->cmd.chan_config_req.num_rb_to_config =  rrccu_chan_config_info.num_rbs;
              for(idx=0;idx < rrccu_chan_config_info.num_rbs;idx++)
              {
                chan_cmd_ptr->cmd.chan_config_req.rb[idx].rb_id = rrccu_chan_config_info.rb_info[idx].rb_id;
                chan_cmd_ptr->cmd.chan_config_req.rb[idx].rb_config=rrccu_chan_config_info.rb_info[idx].rb_config;
              }
              chan_cmd_ptr->cmd.chan_config_req.rrc_channel_config_cnf_required = 
                TRUE;
              chan_cmd_ptr->cmd.chan_config_req.chan_config_reason = RRCLLC_CHAN_CFG_REASON_NONE;
              WRRC_MSG0_HIGH("RRC_CHANNEL_CONFIG_REQ is sent to establish RB0");
              rrc_put_int_cmd(chan_cmd_ptr);                 /* sends the command to RRC
                                                             LLC. */
              rrccu_chan_config_info.num_rbs = 0;
              /* Change the substate since we're waiting for the
                  confirmation from LLC for the channel configs */
              rrccu_substate = RRCCU_WAIT_FOR_RB_EST_CNF;
            }
          }
          else
          {
            /* stop the oos timer */
            rrctmr_stop_timer(RRCTMR_T_OOS_TIMER);
            
            /*Timer T316 got started in the scenario when cell reselection fails 
            when UE is waiting for L2 ack for FACH to PCH transition.
            This timer stopping got missed because RRC never moved to PCH state
            and CU never received NEW_CELL_IND in PCH state*/
            if(rrctmr_get_remaining_time(RRCTMR_T_316_TIMER) > 0)
            {
              rrctmr_stop_timer(RRCTMR_T_316_TIMER);
            }
                        
            /* Check if Cell update message is initiate by a procedure other than CU.
            If so, send a cell update only if the cell is different than the last cell UE 
            camped on.  If it's the same cell, then a cell update is unnecessary */
            if (rrccu_phy_chan_failure_from_rb && TRUE == rrc_ccm_cell_change_to_same_cell()) 
            {
              WRRC_MSG0_HIGH("Camped on same cell.  Sending a cell update complete");
              rrccu_start_t_305_timer();
              /* Inform all registered RRC procedures that Cell
              Update is completed */
              rrccu_inform_cell_update_completed();


              rrccu_process_successful_completion();
              
              /* Reset Cell Update State machine */
              rrccu_substate = RRCCU_INITIAL;
              /*call the procedure to clear the global variabls */
              rrccu_clear_procedure();
            }
            /* Check for re-transmission counter threshold */
            else if (rrc_v_302 <= RRC_GET_N302() )
            {
              WRRC_MSG0_HIGH("Sending cell update msg");
              /* Stop timer T307 */
              rrctmr_stop_timer(RRCTMR_T_307_TIMER);
              /* Check whether RB0 is already established */
              ul_rlc_lc_id = rrclcm_check_ul_rlc_lc_id(UE_LOGCHAN_CCCH, 
                                           CCCH_RADIO_BEARER_ID,
                                           UE_MODE_TRANSPARENT);
  
              if(ul_rlc_lc_id == RRCLCM_RLC_LC_ID_NOT_FOUND)
              {
                /* Send RRC_CHANNEL_CONFIG_REQ to RRC LLC to establish RB0 */
                rrccu_establish_rb0(ESTABLISH_RB,RRC_STATE_CELL_FACH, TRUE);
  
                rrccu_substate = RRCCU_WAIT_FOR_RB0_EST_CNF; 
              }
              else
              {
                rrccu_failure_status_e_type status = RRCCU_NOT_INCLUDE_FAILURE_CAUSE;
                /* Stop timer T305 */
                rrctmr_stop_timer(RRCTMR_T_305_TIMER);
                /* If, for the RLF reason, failure cause must be sent in message CU, set status accordingly
                 * This is as per 25.331 Section 8.3.1.7a	Physical channel failure
                 */
                if(rrccu_physical_channel_failure == TRUE)
                {
                  if (rrccu_cell_update_cause == rrc_CellUpdateCause_radiolinkFailure)
                  {
                    status = RRCCU_INCLUDE_FAILURE_CAUSE;
                  }
                }
  
                if(need_to_incl_failure_cause_in_next_cu == TRUE)
                {
                  status = RRCCU_INCLUDE_FAILURE_CAUSE;
                }
  
                /* Enqueue Cell Update Message in the Uplink Queue.
                   This function also starts T302 timer */
                if (RRCCU_SUCCESS == rrccu_send_cell_update_msg(ul_rlc_lc_id,
                                     status) )
                {        
                  rrccu_substate = RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM; 
                }
                else
                {
                  /* Reset Cell Update State machine */
                  rrccu_substate = RRCCU_INITIAL;
                  /*call the procedure to clear the global variabls */
                  rrccu_clear_procedure();
                  rrccu_init_last_cu_cnf_info();

                } 
              }
            }
            else
            {
              /* Max re-transmissions are tried */
                rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                                     RRC_TX_TO_DISCON_OTHER);
                /* Update the release cause */
                rrc_release_cause = RRC_REL_DEEP_FADE;
                rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
                WRRC_MSG2_HIGH("Max re-tries are tried, v302: %d, N302: %d ", rrc_v_302, RRC_GET_N302());
              }
          }
          break;

        case RRC_CPHY_OUT_OF_SERVICE_AREA_IND:
          event_report(EVENT_WCDMA_OUT_OF_SERVICE);        
          break;

        case RRC_STATE_CHANGE_IND:
          /* entering cell_FACH. No need to start timer T305 now
          because while sending cell updadate we are going to 
          stop this timer any way. */
          if ((cmd_ptr->cmd.state_change_ind.new_state == RRC_STATE_CELL_FACH) &&
                   (cmd_ptr->cmd.state_change_ind.previous_state == RRC_STATE_CELL_DCH))
          {
            /*make sure that cell update should be sent with cause "rl failure" */
            if ((rrccu_cell_update_cause == rrc_CellUpdateCause_radiolinkFailure)||
              (rrccu_cell_update_cause == rrc_CellUpdateCause_rlc_unrecoverableError))
            {
              /*purge RLC watermark for SRB 1 and 2 before proceding with RL failure handling */
               rrccu_purge_rlc_wm(FALSE, TRUE);

              /*establish RB1 to RB4 if their mapping on FACH is present */
              rrccu_establish_srb (FALSE, RRC_STATE_CELL_FACH, TRUE);
              rrccu_substate = RRCCU_WAIT_FOR_RB1_RB4_EST_CNF; 
            }
            else if ((rrccu_cell_update_cause == rrc_CellUpdateCause_re_enteredServiceArea) && 
                     (rrcllc_get_toc_usage() == TOC_FOR_OOS))
            {

              /* stop the oos timer */
              rrctmr_stop_timer(RRCTMR_T_OOS_TIMER);

              WRRC_MSG0_HIGH("Need to send CU msg.  Wait for RB procedure to complete.");
            
              rrccu_substate = RRCCU_WAIT_FOR_RB_PROC_COMPL_IND; 

            }
          }
          break;

        case RRC_T314_EXPIRED_IND:
          /* This function brings down RRC Connection and waits for
             RRC_CHANNEL_CONFIG_CNF from RRC LLC if both T314 and T315
             are expired. Otherwise it releases the RBs associated with T314 */
          rrcu_process_timer_t314_expired();
          break;

        case RRC_T315_EXPIRED_IND:
          /* This function brings down RRC Connection and waits for
             RRC_CHANNEL_CONFIG_CNF from RRC LLC  if both T314 and T315
             are expired. Otherwise it releases the RBs associated with T315 */
          rrcu_process_timer_t315_expired();
          break;

        case RRC_CRLC_STATUS_IND:
          /* Call the function to process rlc status indication 
          in non initial custate */ 
          rrccu_process_rlc_status_ind_in_non_initial_sub_states(cmd_ptr);
          break;

        case RRC_CELL_UPDATE_INITIATE_REQ:
          if(RRCCU_SUCCESS == rrccu_validate_cell_update_initiate_req(cmd_ptr)) 
          {
            if( (cmd_ptr->cmd.initiate_cell_update.cause == RRC_REENTERED_SERVICE_AREA) &&
                (cmd_ptr->cmd.initiate_cell_update.procedure == RRC_PROCEDURE_CSP))
              
            {
              /*In the case of OOS when CU Cnf trigerred Cell Selection
               * due to Directed info for FACH->FACH or FACH->PCH,
               * clear all the CU variables, and trigger OOS
               */
              if((rrccu_int_data.rrccu_cell_selection_trans_from_fach)&&
                 (rrccu_oc_set_by_cu == TRUE))
              {

                rrcllc_clear_ordered_config();
                  /*clear TOC */
                WRRC_MSG1_HIGH("TOC Status %d ",transition_config.toc_usage);
                if(transition_config.toc_usage == TOC_FOR_FACH_AND_PCH)
                {
                  transition_config.toc_usage = TOC_INVALID;
                }
                else if (transition_config.toc_usage == TOC_FOR_FACH_AND_PCH_WITH_DCH_INFO)
                {
                  transition_config.toc_usage = TOC_FOR_DCH;
                }
   
                rrccu_int_data.rrccu_cell_selection_trans_from_fach = FALSE;
                rrccu_init_last_cu_cnf_info();
              }

              /* remap the cu cause based on the priority */
              rrccu_cell_update_cause = 
                rrccu_map_cu_cause_based_on_priority(RRC_REENTERED_SERVICE_AREA);
              rrccu_cell_update_started = TRUE;

              /* If T305 is running, then get the min between the remaing ticks and Toos */
              rrccu_start_t305_or_oos_timer();
              rrccu_send_rrc_initiate_cell_selection_ind(RRC_OUT_OF_SERVICE_AREA_IND, rrc_get_state());  
              /* Remain in same state */
            }
            else if((cmd_ptr->cmd.initiate_cell_update.procedure == RRC_PROCEDURE_UECI)&& (cmd_ptr->cmd.initiate_cell_update.cause == RRC_RADIO_LINK_FAILURE))
            {
              rrccu_cell_update_cause = rrccu_map_cu_cause_based_on_priority(RRC_RADIO_LINK_FAILURE);
            }
            else
            {
              WRRC_MSG1_ERROR("CU initiated. This should never happen in substate %d, RRC Conn Release since T316 & T317 expired", rrccu_substate);
              /* rrccu_process_oos_area_handling();*/
              /* Taking UE to Idle*/
              rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                                   RRC_TX_TO_DISCON_OTHER);
                /* Update the release cause */
              rrc_release_cause = RRC_REL_CAUSE_OOS;
              rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
            }
          }
          break;
        case RRC_T316_EXPIRED_IND:
          /* After T316 expiry UE should start the min between T305 [or continue if 
           * it's already ticking] and Toos
           */
          rrccu_start_t305_or_oos_timer();
          /* CU shall remain in the same substate. */
          break;

        default:
          WRRC_MSG2_ERROR("Unknown command: 0x%x, CU st %d", cmd_ptr->cmd_hdr.cmd_id,rrccu_substate);
          break;
      }
      break;  

    case RRC_STATE_CELL_PCH:
    case RRC_STATE_URA_PCH:
      switch(cmd_ptr->cmd_hdr.cmd_id)
      {
        case RRC_T305_EXPIRED_IND:
          /* start the timer T307  and remain in the same substate */
          rrctmr_start_timer(RRCTMR_T_307_TIMER, 
                     rrccu_convert_t307_to_ms( RRC_GET_T307() ) );
          break;

        case RRC_T316_EXPIRED_IND:
          /* After T316 expiry UE should start the min between T305 [or continue if 
           * it's already ticking] and Toos
           */
          rrccu_start_t305_or_oos_timer();
          /* CU shall remain in the same substate. */

          break;

        case RRC_NEW_CELL_IND:
          WRRC_MSG2_HIGH("NEW_CELL_IND in state:%d, cu_state:%d",
                   rrc_get_state(),rrccu_substate);
          /* stop the oos timer */
          rrctmr_stop_timer(RRCTMR_T_OOS_TIMER);
          /* If tT316 is running and UE camped on the same cell before T316 expiry.
           * If t307 is started or CU cause has changed, the UE need to do a cell
           * update.  Else UE can remain in PCH without doing a Cell Update.
           */
          if ((RRC_GET_T316() == rrc_T_316_s_inf) || 
              (rrctmr_get_remaining_time(RRCTMR_T_316_TIMER) > 0)) 
          {
            /* Stop timer T316 */
            rrctmr_stop_timer(RRCTMR_T_316_TIMER);
            if (rrc_get_state() == RRC_STATE_CELL_PCH) 
            {
              if (TRUE == rrc_ccm_cell_change_to_same_cell() && rrctmr_get_remaining_time(RRCTMR_T_307_TIMER) == 0
                  && rrccu_cell_update_cause == rrc_CellUpdateCause_re_enteredServiceArea) 
              {
                WRRC_MSG0_HIGH("UE detected in service on same cell. No CU necessary");              

                /* Reset Cell Update State machine */
                rrccu_substate = RRCCU_INITIAL;
                /* Inform all registered RRC procedures that Cell
                   Update is completed */
                rrccu_inform_cell_update_completed();


                rrccu_process_successful_completion();

                /*call the procedure to clear the global variabls */
                rrccu_clear_procedure();
                break;
              }
              else if (rrctmr_get_remaining_time(RRCTMR_T_307_TIMER) == 0) 
              {
                if(rrccu_cell_update_cause == rrc_CellUpdateCause_re_enteredServiceArea)
                {
                /* Update the cause to re-selection as the Cell upate cause should
                   indicate re-selection and not re-entered service area since T_316 hasn't
                   expired and T_307 is not started
                   Spec Reference:25.331
                   	8.5.5.2.1 Actions following Re-entry into "in service area" in URA_PCH or CELL_PCH state
                          If the UE re-enters "in service area" before T316 expiry the UE shall perform the following actions. The UE shall:
                          1>  if the UE is in CELL_PCH state and the UE is camped on a cell different from the one where service was lost:
                            2>  for FDD and 1.28 Mcps TDD:
                              3>  clear the variables C_RNTI, H_RNTI and E_RNTI;
                              3>  stop using that C-RNTI, H-RNTI and E_RNTI just cleared from variables C_RNTI, H_RNTI and E_RNTI in MAC.
                            2>  initiate the cell update procedure using the cause "cell-reselection" as specified in subclause 8.3.1.

                 */

                  rrccu_cell_update_cause = rrc_CellUpdateCause_cellReselection;
                }
                else 
                {
                  /* Update cause based on priority if cause is other than re-entered service area */
                  rrccu_cell_update_cause = rrccu_map_cu_cause_based_on_priority(RRC_CELL_RESELECTION);
                }
              }
            }
            /* Check if Cell Update has been triggered with higher priority cause than Re-entered service area 
               If there is high priority cause other than re-entered service area trigger CU. Otherwise 
               trigger URA update if there is a change in URA */
            else if((rrccu_cell_update_cause != rrc_CellUpdateCause_utran_pagingResponse)&&
                    (rrccu_cell_update_cause != rrc_CellUpdateCause_uplinkDataTransmission))
            {
              /* If UE is in URA_PCH, check in URA_ID of the cell has changed.  If so, do a URA_UPDATE
                 with cause ura reselection
               */
              /* This function would check if a URA reselection occurred */
              if (rrccu_check_for_ura_reselection())
              {
                /* set Cell_update_started flag here */
                rrccu_ura_update_started = TRUE;
                rrccu_cell_update_started = FALSE;
                /* Update URA Update cause */
                rrccu_ura_update_cause = rrc_URA_UpdateCause_changeOfURA;
              }
              else if(rrctmr_get_remaining_time(RRCTMR_T_307_TIMER) == 0)
              {
                WRRC_MSG0_HIGH("UE detected in service on same URA. No URAU necessary");              
                /* Reset Cell Update State machine */
                rrccu_substate = RRCCU_INITIAL;
                /* Inform all registered RRC procedures that Cell
                   Update is completed */
                rrccu_inform_cell_update_completed();


                rrccu_process_successful_completion();
                
                /*call the procedure to clear the global variabls */
                rrccu_clear_procedure();
                break;                
              }
              else
              {
                WRRC_MSG0_HIGH("UE detected in service on same URA,T307 is Running, Trigger Periodic URA Update");
                /* set URA_update_started flag here */
                rrccu_ura_update_started = TRUE;
                rrccu_cell_update_started = FALSE;
                /* Update URA Update cause */
                rrccu_ura_update_cause = rrc_URA_UpdateCause_periodicURAUpdate;
              }
            }
          }
          /* Stop timer T305 */
          rrctmr_stop_timer(RRCTMR_T_305_TIMER);
          /* Stop timer T307 */
          rrctmr_stop_timer(RRCTMR_T_307_TIMER);
          /*Since SIB7 would have been read already. No need to wait for SIB7 here.*/      
#ifdef FEATURE_DUAL_SIM
          if(rrc_acquire_lock_for_pch_to_fach() == SUCCESS)
#endif /*FEATURE_DUAL_SIM*/
          {
          /* Send RRC_CHANNEL_CONFIG_REQ to RRC LLC to establish SRB */
          rrccu_establish_srb(TRUE, RRC_STATE_CELL_FACH, TRUE);
          rrccu_substate = RRCCU_WAIT_FOR_RB0_EST_CNF; 
          }
#ifdef FEATURE_DUAL_SIM
          else
          {
            ERR_FATAL("LOCK isn't acquired in CU substate %d",rrccu_substate,0,0);
          }
#endif /*FEATURE_DUAL_SIM*/

          break;

        case RRC_STATE_CHANGE_IND:       
          /* Make sure to handling this only in the case where UE went
             out of service area while in transition from DCH->PCH
           */
          if (rrccu_cell_update_cause == rrc_CellUpdateCause_re_enteredServiceArea &&
              ((rrcllc_get_toc_usage() == TOC_FOR_OOS)
              || (rrcllc_get_toc_usage() == TOC_FOR_OOS_WITHOUT_DCH_INFO)
              || (rrcllc_get_toc_usage() == TOC_FOR_OOS_WITH_DCH_INFO)
          ))
          {
            rrccu_cell_update_started = TRUE;
            /* stop the oos timer */
            rrctmr_stop_timer(RRCTMR_T_OOS_TIMER);
            /* stopping of T_305 and T_307 will be done if and only if CU or URAU is 
             * to be done
             */
            /* If tT316 is running and UE camped on the same cell before T316 expiry.
             * If t307 is started or CU cause has changed, the UE need to do a cell
             * update.  Else UE can remain in PCH without doing a Cell Update.
             */
            if ((RRC_GET_T316() == rrc_T_316_s_inf) || 
                (rrctmr_get_remaining_time(RRCTMR_T_316_TIMER) > 0)) 
            {
              /* Stop timer T316 */
              rrctmr_stop_timer(RRCTMR_T_316_TIMER);
              if (rrc_get_state() == RRC_STATE_CELL_PCH) 
              {
                if (((TRUE == rrccsp_is_selected_cell_utran_directed())) && 
                    (rrctmr_get_remaining_time(RRCTMR_T_307_TIMER) == 0)) 
                {
                  WRRC_MSG0_HIGH("UE detected in service on directed cell. No CU necessary");              
                  /* Reset Cell Update State machine */
                  rrccu_substate = RRCCU_INITIAL;
                  /* Inform all registered RRC procedures that Cell
                     Update is completed */
                  rrccu_inform_cell_update_completed();


                  rrccu_process_successful_completion();
                  
                  /*call the procedure to clear the global variabls */
                  rrccu_clear_procedure();
                  break;
                }
                else if (rrctmr_get_remaining_time(RRCTMR_T_307_TIMER) == 0) 
                {
                  /* Update the cause to re-selection as the Cell upate cause should
                     indicate re-selection and not re-entered service area since T_316 hasn't
                     expired and T_307 is not started
                   */
                  rrccu_cell_update_cause = rrc_CellUpdateCause_cellReselection;
                }
              }
              else
              {
                /* If UE is in URA_PCH, check in URA_ID of the cell has changed.  If so, do a URA_UPDATE
                   with cause ura reselection
                 */
                /* This function would check if a URA reselection occurred */
                if (rrccu_check_for_ura_reselection())
                {
                  /* set Cell_update_started flag here */
                  rrccu_ura_update_started = TRUE;
                  rrccu_cell_update_started = FALSE;
                  /* Update URA Update cause */
                  rrccu_ura_update_cause = rrc_URA_UpdateCause_changeOfURA;
                }
                else
                {
                  WRRC_MSG0_HIGH("UE detected in service on same URA. No URAU necessary");              
                  /* Reset Cell Update State machine */
                  rrccu_substate = RRCCU_INITIAL;
                  /* Inform all registered RRC procedures that Cell
                     Update is completed */
                  rrccu_inform_cell_update_completed();


                  rrccu_process_successful_completion();

                  /*call the procedure to clear the global variabls */
                  rrccu_clear_procedure();
                  rrccu_init_last_cu_cnf_info();

                  break;                
                }
              }
            }
            
            WRRC_MSG0_HIGH("Need to send CU or URAU msg.  Wait for RB procedure to complete.");
            
            rrccu_substate = RRCCU_WAIT_FOR_RB_PROC_COMPL_IND; 
          }

          /*In case of Fre-redirection received in CU Cnf to PCH/URA PCH,
            *  Cell Selection is  triggered. After going to new cell, the 
            * STATE_CHANGE_IND is received so configure Lower layer
            * with OTA contntents, so that the TOC is also restored in LLC 
            */
          else if((rrccu_int_data.rrccu_cell_selection_trans_from_fach)
            &&(rrccu_oc_set_by_cu == TRUE))
          {
            rrccu_int_data.rrccu_cell_selection_trans_from_fach = FALSE;
            
            if(rrccsp_is_selected_cell_utran_directed() == FALSE )    
            {
              rrccu_cu_initiate_reqd.cu_reqd = TRUE;
              rrccu_cu_initiate_reqd.cu_cause = rrc_CellUpdateCause_cellReselection;
            }
     
            rrccu_start_t_305_timer();


            /*send  ul data registration request to rlc */
            rrccu_register_with_rlc_for_ul_data_indication();
           
             
            /* start the periodic timer */
            /* if the next state is cell_pch or ura_pch then setup pcch */

            rrcllc_set_utran_drx_info (rrccu_utran_drx_coef); 
            /*send channel config to release ccch and setup pcch 
            This function will also take care of the channel configuration
            of RBs due to received cell update confirm message*/
            rrccu_establish_pcch_rb (
            rrc_translate_state_indicator_to_state(rrccu_state_indicator));
            rrccu_substate = RRCCU_WAIT_FOR_PCCH_RB_EST_CNF;
             
          }
            
          
     
          break;

        case RRC_CPHY_OUT_OF_SERVICE_AREA_IND:
          event_report(EVENT_WCDMA_OUT_OF_SERVICE);

            /*We ingnore the command and remain in the same substate
              when out of service area is being handled */

          break;

        case RRC_T317_EXPIRED_IND:
          /* Since Timer T317 and T316 are expired, bring down the RRC 
             Connection */
          rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                               RRC_TX_TO_DISCON_OTHER);
            /* Update the release cause */
          rrc_release_cause = RRC_REL_CAUSE_OOS;
          rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;

          break;

        case RRC_T307_EXPIRED_IND:
          /* stop the oos timer */
          rrctmr_stop_timer(RRCTMR_T_OOS_TIMER);
           /* Since Timer T307 expired after T305 are expired, 
              bring down the RRC Connection */
          rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                               RRC_TX_TO_DISCON_OTHER);
            /* Update the release cause */
          rrc_release_cause = RRC_REL_CAUSE_OOS;
          rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
          break;

        case RRC_OOS_TIMER_EXPIRED_IND:
            /* Since Timer OOS_TIMER expired, bring down the RRC Connection */
            rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                                 RRC_TX_TO_DISCON_OTHER);
              /* Update the realease cause */
              rrc_release_cause = RRC_REL_CAUSE_OOS;
              rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
          break;



        case RRC_CELL_UPDATE_INITIATE_REQ:
          if(RRCCU_SUCCESS == rrccu_validate_cell_update_initiate_req(cmd_ptr)) 
          {
            if( (cmd_ptr->cmd.initiate_cell_update.cause == RRC_REENTERED_SERVICE_AREA) &&
                ((cmd_ptr->cmd.initiate_cell_update.procedure == RRC_PROCEDURE_CSP)||
                 (cmd_ptr->cmd.initiate_cell_update.procedure == RRC_PROCEDURE_SIB)) 
              )
            {
              rrccu_process_oos_area_handling();   
            }
          }
          break;

        default:
          WRRC_MSG2_ERROR("Unknown command: 0x%x, CU st %d", cmd_ptr->cmd_hdr.cmd_id,rrccu_substate);
          break;
      }
      break;

    default:
      WRRC_MSG2_HIGH("Invalid Event: %d in the substate: %d", 
                cmd_ptr->cmd_hdr.cmd_id, rrccu_substate);
      break;
  }
} /* rrcu_process_cu_wait_for_ue_to_camp_on */

#ifdef FEATURE_WCDMA_HS_RACH
#ifdef FEATURE_QCHAT
/*===========================================================================

FUNCTION rrccu_append_rb_id_rlc_payload_to_meas_rpt

DESCRIPTION
  This function compares V302 with N302 and trasmits CELL UPDATE if 
  V302 <= N302. Otherwise it brings down RRC Connection.

  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
static void rrccu_append_rb_id_rlc_payload_to_meas_rpt
(
  rrc_UL_DCCH_Message* msg_ptr
)
{
  uint8 count,i;
  /*local var to store logical channel ID and radio bearer ID*/
  uint32 local_rb_id;
  //add this under Qchat feature flag
  rrc_rb_id_info_type rb_list;
  uint32 num_bytes = 0;
  struct rrc_TrafficVolumeMeasuredResultsList *meas_report_ptr = NULL;

//init num_rbs here
  rb_list.num_rbs = 0;

  if(rb_list.num_rbs < MAX_RB)
  {
    if((num_bytes = rlc_rrc_get_wm_info_req(rrclcm_get_ul_rlc_lc_id(CCCH_RADIO_BEARER_ID))) != 0)
    {
      //Add RB.ID 0
      rb_list.rb_id_list[rb_list.num_rbs].rb_id = CCCH_RADIO_BEARER_ID;
      rb_list.rb_id_list[rb_list.num_rbs].raw_rlc_payload = num_bytes;
      WRRC_MSG2_HIGH("EPCH: rb_id=%d, num_bytes=%d ",rb_list.rb_id_list[rb_list.num_rbs].rb_id,
            num_bytes);
      rb_list.num_rbs++;
    }
  }

  if(rb_list.num_rbs < MAX_RB)
  {
    if((num_bytes = rlc_rrc_get_wm_info_req(rrclcm_get_ul_rlc_lc_id(DCCH_UM_RADIO_BEARER_ID))) != 0)
    {
      //Add RB.ID 1
      rb_list.rb_id_list[rb_list.num_rbs].rb_id = DCCH_UM_RADIO_BEARER_ID;
      rb_list.rb_id_list[rb_list.num_rbs].raw_rlc_payload = num_bytes;
      WRRC_MSG2_HIGH("EPCH: rb_id=%d, num_bytes=%d ",rb_list.rb_id_list[rb_list.num_rbs].rb_id,
            num_bytes);
      rb_list.num_rbs++;
    }
  }

  if(rb_list.num_rbs < MAX_RB)
  {
    if((num_bytes = rlc_rrc_get_wm_info_req(rrclcm_get_ul_rlc_lc_id(DCCH_AM_RADIO_BEARER_ID))) != 0)
    {
      //Add RB.ID 2
      rb_list.rb_id_list[rb_list.num_rbs].rb_id = DCCH_AM_RADIO_BEARER_ID;
      rb_list.rb_id_list[rb_list.num_rbs].raw_rlc_payload = num_bytes;
      WRRC_MSG2_HIGH("EPCH: rb_id=%d, num_bytes=%d ",rb_list.rb_id_list[rb_list.num_rbs].rb_id,
            num_bytes);
      rb_list.num_rbs++;
    }
  }

  if(rb_list.num_rbs < MAX_RB)
  {
    if((num_bytes = rlc_rrc_get_wm_info_req(rrclcm_get_ul_rlc_lc_id(DCCH_DT_HIGH_PRI_RADIO_BEARER_ID))) != 0)
    {
      //Add RB.ID 3
      rb_list.rb_id_list[rb_list.num_rbs].rb_id = DCCH_DT_HIGH_PRI_RADIO_BEARER_ID;
      rb_list.rb_id_list[rb_list.num_rbs].raw_rlc_payload = num_bytes;
      WRRC_MSG2_HIGH("EPCH: rb_id=%d, num_bytes=%d ",rb_list.rb_id_list[rb_list.num_rbs].rb_id,
            num_bytes);
      rb_list.num_rbs++;
    }
  }

  if(rb_list.num_rbs < MAX_RB)
  {
    if((num_bytes = rlc_rrc_get_wm_info_req(rrclcm_get_ul_rlc_lc_id(DCCH_DT_LOW_PRI_RADIO_BEARER_ID))) != 0)
    {
      //Add RB.ID 4
      rb_list.rb_id_list[rb_list.num_rbs].rb_id = DCCH_DT_LOW_PRI_RADIO_BEARER_ID;
      rb_list.rb_id_list[rb_list.num_rbs].raw_rlc_payload = num_bytes;
      WRRC_MSG2_HIGH("EPCH: rb_id =%d, num_bytes=%d ",rb_list.rb_id_list[rb_list.num_rbs].rb_id,
            num_bytes);
      rb_list.num_rbs++;
    }
  }

  //loop through rrc_est_rabs & add uRb's which have data
  for ( count=0; count<MAX_RAB_TO_SETUP; count++ )
  {
    if ((rrc_est_rabs.rabs[count].rab_id != RRC_INVALID_RAB_ID) && 
          (rrc_est_rabs.rabs[count].cn_domain == RRC_PS_DOMAIN_CN_ID) &&
          (rrc_est_rabs.rabs[count].num_rbs_for_rab > 0))
    {
      for (i=0; i< rrc_est_rabs.rabs[count].num_rbs_for_rab; i++)
      {
        /*copy to local vars to avoid multiple indirections in each loop and
              generally lengthy variable names and confusion */
        local_rb_id = rrc_est_rabs.rabs[count].rb_for_rab[i].rb_id;
        if(rb_list.num_rbs < MAX_RB)
        {
          if((num_bytes = rlc_rrc_get_wm_info_req(rrclcm_get_ul_rlc_lc_id(local_rb_id))) != 0)
          {
            //Add uRB.
            rb_list.rb_id_list[rb_list.num_rbs].rb_id = local_rb_id;
            rb_list.rb_id_list[rb_list.num_rbs].raw_rlc_payload = num_bytes;
            WRRC_MSG2_HIGH("EPCH: rb_id=%d, num_bytes=%d ",rb_list.rb_id_list[rb_list.num_rbs].rb_id,
              num_bytes);
            rb_list.num_rbs++;
          }
        }
      }
    }
  }

  WRRC_MSG1_HIGH("EPCH:num_rbs %d which has UL data",rb_list.num_rbs);

  if(rb_list.num_rbs > 0)
  {
    if(!(msg_ptr->message.u.measurementReport.m.measuredResultsPresent))
    {
      //need to add rrc_MeasurementReport_measuredResults_present
      WRRC_MSG0_HIGH("EPCH:measuredResults I.E for MR");
      msg_ptr->message.u.measurementReport.m.measuredResultsPresent = 1;
      msg_ptr->message.u.measurementReport.measuredResults.t = 
        T_rrc_MeasuredResults_trafficVolumeMeasuredResultsList;

      meas_report_ptr = rtxMemAllocTypeZ(&enc_ctxt,rrc_TrafficVolumeMeasuredResultsList);
      
      msg_ptr->message.u.measurementReport.measuredResults.u.trafficVolumeMeasuredResultsList =
        meas_report_ptr;

      meas_report_ptr->n = rb_list.num_rbs;
      if(meas_report_ptr->n >= (MAX_RB -1))
      {
        meas_report_ptr->n = MAX_RB -1 ;
      }
      ALLOC_ASN1ARRAY2(&enc_ctxt,meas_report_ptr,rrc_TrafficVolumeMeasuredResults);

      for (count=0; count < meas_report_ptr->n; count++)
      {
        /* Get radio bearer Id */
        meas_report_ptr->elem[count].rb_Identity = 
          rb_list.rb_id_list[count].rb_id;
        
        meas_report_ptr->elem[count].m.rlc_BuffersPayloadPresent = 1 ;

        /* Convert the size */
        meas_report_ptr->elem[count].rlc_BuffersPayload =  
          TVM_RET_RLC_BUFFER_PAYLOAD(rb_list.rb_id_list[count].raw_rlc_payload);
        
        MSG_HIGH("EPCH:Adding RB = %d, Raw RLC payload sent = %d,raw_rlc_payload=%d to MR",
             rb_list.rb_id_list[count].rb_id,
             rb_list.rb_id_list[count].raw_rlc_payload,
             TVM_RET_RLC_BUFFER_PAYLOAD(rb_list.rb_id_list[count].raw_rlc_payload));
      }
    }
  }
}
#endif
/*===========================================================================

FUNCTION rrccu_send_meas_rpt_epch_to_efach_trans

DESCRIPTION
  This function compares V302 with N302 and trasmits CELL UPDATE if 
  V302 <= N302. Otherwise it brings down RRC Connection.

  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
void rrccu_send_meas_rpt_epch_to_efach_trans
(
  void
)
{
  rlc_lc_id_type ul_rlc_lc_id = RRCLCM_RLC_LC_ID_NOT_FOUND;
                                /* Local varible for Uplink RLC LC Id. */
                                /* Stores meas report */
  rrc_UL_DCCH_Message* msg_ptr = NULL;
                                /* Logical Channel Id */

  /* Tells if send chain is successful in sending msg */
  rrcsend_status_e_type status;

  /* Stop timer T305 */
  rrctmr_stop_timer(RRCTMR_T_305_TIMER);
  /* Enqueue measurment report Message in the Uplink Queue.*/

  /* start the periodic timer */
  rrccu_start_t_305_timer();

  ul_rlc_lc_id = rrclcm_check_ul_rlc_lc_id ( UE_LOGCHAN_DCCH, DCCH_AM_RADIO_BEARER_ID,
        UE_MODE_ACKNOWLEDGED_DATA);
    
  if ( ul_rlc_lc_id == RRCLCM_RLC_LC_ID_NOT_FOUND )
  {
    WRRC_MSG0_ERROR("RLC Logical channel not found");
    return;
  }
    
  /* Allocate a buffer for an uplink DCCH Message. This buffer
    * should be released by SEND_CHAIN using OSS compiler functions */
    
  msg_ptr = (rrc_UL_DCCH_Message *) rrc_malloc (sizeof(struct rrc_UL_DCCH_Message));
    
  /* Store meas report chosen */
  msg_ptr->message.t = T_rrc_UL_DCCH_MessageType_measurementReport;
    
  /* First store the meas id */
  msg_ptr->message.u.measurementReport.measurementIdentity = 16;

  RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.measurementReport);

  /* Function call to Measurement Control & Report procedure. */
  if(RRCMEAS_RACH_SUCCESSFUL == rrcmeas_append_meas_rpt_on_rach(
      &msg_ptr->message.u.measurementReport.measuredResultsOnRACH, RRC_PROCEDURE_MCMR, FALSE))
  {
    /* if Measurement Control & Reportprocedure returns RRC_MEAS_RACH_SUCCESFUL,
        then enable the  bit_mask field */
    msg_ptr->message.u.measurementReport.m.measuredResultsOnRACHPresent = 1;
  }
  else
  {
    /*"Measured Results on RACH" IE is optional, if Measurement Control & Report
       procedure returns other than RRC_MEAS_RACH_SUCCESFUL, then disable the
       bit_mask field */
    MSG_MED("Measured Results on RACH is not appended",0,0,0);
  } 

  if((rrctvm_is_traffic_volume_indicator_to_be_set_in_cu()))
  {
    /* Set event results present */
    msg_ptr->message.u.measurementReport.m.eventResultsPresent = 1; 
        
    /* Set traffic vol event results */
    msg_ptr->message.u.measurementReport.eventResults.t =
          T_rrc_EventResults_trafficVolumeEventResults;
        
    msg_ptr->message.u.measurementReport.eventResults.u.
        trafficVolumeEventResults =
        rtxMemAllocTypeZ (&enc_ctxt, rrc_TrafficVolumeEventResults);
    /* Set event name */
    WRRC_MSG0_HIGH("TVM:EVENT 4A Reported");

    /*spec Ref: 25.331$14.4.2
    4> set the IE "Uplink transport channel type causing the event" to the value "DCH";
    4> include the IE "UL Transport Channel identity" and set it to any value */


    msg_ptr->message.u.measurementReport.eventResults.u.
          trafficVolumeEventResults->trafficVolumeEventIdentity = rrc_TrafficVolumeEventType_e4a;
    /* Set transport channel on which event happens */
    msg_ptr->message.u.measurementReport.eventResults.u.
         trafficVolumeEventResults->ul_transportChannelCausingEvent.t
         = T_rrc_UL_TrCH_Identity_dch;
    
    msg_ptr->message.u.measurementReport.eventResults.u.
         trafficVolumeEventResults->ul_transportChannelCausingEvent.u.dch = UE_MAX_NUM_TRCH_32;
    
  }

#ifdef FEATURE_QCHAT
  if(qchatupk_wcdma_icup_enabled()) /* dynamic flag to check if qchat is loaded and active on the handset */
  {
    //below function will  process & append rb id list in MR(measurement request message)
    rrccu_append_rb_id_rlc_payload_to_meas_rpt (msg_ptr);
  }
#endif

  /* This places SDU into RLC watermark queue */
  status =  rrcsend_send_ul_sdu(RRC_PROCEDURE_MCMR, (void *) msg_ptr,
  ul_rlc_lc_id, RRCSEND_L2ACK_NOT_REQUIRED);
    
  if ( status != RRCSEND_SUCCESS )
  {
    WRRC_MSG0_ERROR("Failed to send Measurement report Msg");
  }
  else
  {
    WRRC_MSG0_HIGH("Meas Control report message sent from RRC to RLC");
  }

  /*clear the ordered config if it is set from rrccu procedure */
  if (rrccu_oc_set_by_cu == TRUE)
  {
    rrcllc_clear_ordered_config();
  }
  /* Inform all registered RRC procedures that Cell
           Update is completed */
  rrccu_inform_cell_update_completed();

  rrccu_process_successful_completion();
                
  /* check whether any cell update initiate req needs to be 
      posted to itself due to reselections in certain substates*/
  if (rrccu_cu_initiate_reqd.cu_reqd)
  {
    /* do not delete CRNTI here respnse message might
        get stuck in RLC */
    rrccu_cu_initiate_reqd.cu_reqd = FALSE;
    rrccu_send_cell_update_initiate_req (RRC_CELL_RESELECTION);
  }
  
  /* The procedures ends */
  rrccu_substate = RRCCU_INITIAL;
  /*call the procedure to clear the global variabls */
  rrccu_clear_procedure();
} /* rrccu_resend_cell_update_msg */
#endif 
/*===========================================================================

FUNCTION rrccu_resend_cell_update_msg

DESCRIPTION
  This function compares V302 with N302 and trasmits CELL UPDATE if 
  V302 <= N302. Otherwise it brings down RRC Connection.

  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
void rrccu_resend_cell_update_msg
(    
  rrccu_failure_status_e_type status         /* Indicates whether to include
                                                failure cause or not */
)
{
  rlc_lc_id_type ul_rlc_lc_id = RRCLCM_RLC_LC_ID_NOT_FOUND;
                                /* Local varible for Uplink RLC LC Id. */

#ifdef FEATURE_DUAL_SIM
  boolean tune_away_state;
#endif

  /* If, for the RLF reason, failure cause must be sent in message CU, set status accordingly
   * This is as per 25.331 Section 8.3.1.7a	Physical channel failure
   */
  if(rrccu_physical_channel_failure == TRUE)
  { 
    if (rrccu_cell_update_cause == rrc_CellUpdateCause_radiolinkFailure)
    {
      status = RRCCU_INCLUDE_FAILURE_CAUSE;
    }
  }
  /* If step 1 HHO is done and RL failure/RLC reset happens, we need to revert to old cipher DB */
  rrcsmc_revert_to_old_config_for_failure_message(FALSE);
                                
  /* Check for re-transmission counter threshold */
#ifdef FEATURE_DUAL_SIM
  /* This will fix the issue where G sub is not able to get the lock when W performs
     cell update for resumption after a pre-emption, and n/w does not respond to CU.
     So W keeps waiting for CU cnf from n/w for 10 to 12s and G is denied lock for
     this duration. */
  tune_away_state = rrc_ok_for_tune_away();
  if((!tune_away_state && (rrc_v_302 <= RRC_GET_N302())) || 
      (tune_away_state && (rrc_v_302 <= (RRC_GET_N302()/2))))
#else
  if (rrc_v_302 <= RRC_GET_N302() )
#endif
  {
    /* clear some global variables */
    rrccu_chan_config_reqd                = FALSE;
    rrccu_oc_set_by_cu                    = FALSE;
    rrccu_rb_release_info.rrccu_rb_release_in_cucnf = FALSE;
    /*clear SRNS reloc info */
    rrccu_cucnf_for_srns_relocation = FALSE;
    rrccu_new_urnti_valid = FALSE;
    rrccu_new_crnti_valid = FALSE;
    rrccu_reestablish_srb = FALSE;
    rrccu_reestablish_srb = FALSE;
    rrccu_reestablish_rab = FALSE;
    rrccu_reestablish_rab = FALSE;

    /* check re-est timers status if cell update was active due to 
    rl failure or rlc unrecoverable error in CELL_DCH state */
    if(((rrccu_cell_update_cause == rrc_CellUpdateCause_radiolinkFailure)||
        (rrccu_cell_update_cause == rrc_CellUpdateCause_rlc_unrecoverableError)) &&
        (rrccu_failure_state == RRC_STATE_CELL_DCH)
      )
    {
      /*check whether any RAB release is required because of 
      re-establishment timer expiry. If so send channel config request
      If both timers are not started then enter idle*/
      if((rrccu_rl_failure_info.t314_info.timer_status != RE_EST_TIMER_STARTED) &&
         (rrccu_rl_failure_info.t315_info.timer_status != RE_EST_TIMER_STARTED))
      {
        rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                             RRC_TX_TO_DISCON_OTHER);
          /* Update the release cause */
        rrc_release_cause = RRC_REL_DEEP_FADE;
        rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
        WRRC_MSG0_HIGH("re-est timers expired during re-establishment ");
        /*return from here */
        return;
      }
    }
    /* Check whether RB0 is already established */
    ul_rlc_lc_id = rrclcm_check_ul_rlc_lc_id(UE_LOGCHAN_CCCH, 
                                 CCCH_RADIO_BEARER_ID,
                                 UE_MODE_TRANSPARENT);

    if(ul_rlc_lc_id == RRCLCM_RLC_LC_ID_NOT_FOUND)
    {
      WRRC_MSG0_ERROR("Cann't find RLC LC Id for RB0");
    }
    else
    {
      /* Stop timer T305 */
      rrctmr_stop_timer(RRCTMR_T_305_TIMER);
      /* Enqueue Cell Update Message in the Uplink Queue.
         This function also starts T302 timer */
      rrccu_purge_rlc_wm_rb3_rb4(TRUE,FALSE);
      if (RRCCU_SUCCESS == rrccu_send_cell_update_msg(ul_rlc_lc_id, status) )
      {        
        rrccu_substate = RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM; 
      }
      else
      {
        /*lint -e793*/
        /*lint +e793*/
        /* Reset Cell Update State machine */
        rrccu_substate = RRCCU_INITIAL;
        /*call the procedure to clear the global variabls */
        rrccu_clear_procedure();
        rrccu_init_last_cu_cnf_info();

      } 
    }
  }
  else 
  {
    /* Max re-transmissions are tried */
      rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                           RRC_TX_TO_DISCON_OTHER);
      /* Update the release cause */              
      rrc_release_cause = RRC_REL_DEEP_FADE;
      rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
      WRRC_MSG1_HIGH("Max retries:%d are tried" , RRC_GET_N302());
    }
} /* rrccu_resend_cell_update_msg */

/*===========================================================================

FUNCTION rrccu_resend_ura_update_msg

DESCRIPTION
  This function compares V302 with N302 and trasmits URA UPDATE if 
  V302 <= N302. Otherwise it brings down RRC Connection.

  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
static void rrccu_resend_ura_update_msg
(    
  rrccu_failure_status_e_type status         /* Indicates whether to include
                                                failure cause or not */
)
{
  rlc_lc_id_type ul_rlc_lc_id = RRCLCM_RLC_LC_ID_NOT_FOUND;
                                /* Local varible for Uplink RLC LC Id. */
  /* Check for re-transmission counter threshold */
  if (rrc_v_302 <= RRC_GET_N302() )
  {
    /* Check whether RB0 is already established */
    ul_rlc_lc_id = rrclcm_check_ul_rlc_lc_id(UE_LOGCHAN_CCCH, 
                                 CCCH_RADIO_BEARER_ID,
                                 UE_MODE_TRANSPARENT);

    if(ul_rlc_lc_id == RRCLCM_RLC_LC_ID_NOT_FOUND)
    {
      WRRC_MSG0_ERROR("Cann't find RLC LC Id for RB0");
    }
    else
    {
      /* Stop timer T305 */
      rrctmr_stop_timer(RRCTMR_T_305_TIMER);

      /* Enqueue ura Update Message in the Uplink Queue.
         This function also starts T302 timer */
      if (RRCCU_SUCCESS == rrccu_send_ura_update_msg(ul_rlc_lc_id, status) )
      {        
        rrccu_substate = RRCCU_WAIT_FOR_URA_UPDATE_CONFIRM; 
      }
      else
      {
        /*lint -e793*/
        /*lint +e793*/
        /* Reset URA Update State machine */
        rrccu_substate = RRCCU_INITIAL;
        /*call the procedure to clear the global variabls */
        rrccu_clear_procedure();
      } 
    }
  }
  else 
  {
    /* Max re-transmissions are tried */
      rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                           RRC_TX_TO_DISCON_OTHER);
      /* Update the release cause */
      rrc_release_cause = RRC_REL_DEEP_FADE;
      rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
      WRRC_MSG0_HIGH("Max retries are tried" );
    }
} /* rrccu_resend_ura_update_msg */

/*===========================================================================

FUNCTION rrccu_process_cu_wait_for_rb1_rb4_est_cnf

DESCRIPTION
  This function processes all events that are dispatched to Cell Update 
  procedure in RRCCU_WAIT_FOR_RB1_RB4_EST_CNF substate.

  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
static void rrccu_process_cu_wait_for_rb1_rb4_est_cnf
(    
  rrc_cmd_type *cmd_ptr
)
{
  rlc_lc_id_type ul_rlc_lc_id = RRCLCM_RLC_LC_ID_NOT_FOUND;

  switch(rrc_get_state())
  {
    case RRC_STATE_CELL_FACH:
      switch(cmd_ptr->cmd_hdr.cmd_id)
      {
        case RRC_CHANNEL_CONFIG_CNF:
          rrcllcpcie_initialise_sync_a_post_veri_info();

          if(cmd_ptr->cmd.chan_config_cnf.chan_cfg_status != RRCLLC_CHAN_CFG_SUCCESS)
          {
            WRRC_MSG0_HIGH("Chan Config not successful for rb1-rb4");
#ifndef FEATURE_WCDMA_HS_FACH
            /* Channel config failure, so initialise the ordered RB-Mapping database*/
            rrcllc_init_ordered_hanging_rb_mapping_info();
#else
            rrcllc_copy_current_hanging_rb_mapping_to_ordered();
#endif
          }
        
          /* clear the oc here */
          rrcllc_clear_ordered_config();
          rrccu_oc_set_by_cu = FALSE;
          /* send channel config to release RBs associated with 
          the re-establishment timers that were either set to zero or expired
          during cell selection */
          rrccu_check_re_est_timer_status();
         
          /*Even if the previous channel configuration is failed 
          send cell update message because RB0 is available */
          ul_rlc_lc_id = rrclcm_check_ul_rlc_lc_id(UE_LOGCHAN_CCCH, 
                                       CCCH_RADIO_BEARER_ID,
                                       UE_MODE_TRANSPARENT);

          if(ul_rlc_lc_id == RRCLCM_RLC_LC_ID_NOT_FOUND)
          {
            WRRC_MSG0_ERROR("No RB0 in CELL_FACH");
          }
          else
          {
            /* Stop timer T305 */
            rrctmr_stop_timer(RRCTMR_T_305_TIMER);

            /* Enqueue Cell Update Message in the Uplink Queue.
               This function also starts T302 timer */
            rrccu_purge_rlc_wm_rb3_rb4(TRUE,FALSE);
            if (RRCCU_SUCCESS == rrccu_send_cell_update_msg(ul_rlc_lc_id, 
                                 RRCCU_NOT_INCLUDE_FAILURE_CAUSE) )
            {      
              rrccu_substate = RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM; 
            }
            else
            {
              /* Reset Cell Update State machine */
              rrccu_substate = RRCCU_INITIAL;
              /*call the procedure to clear the global variabls */
              rrccu_clear_procedure();
              rrccu_init_last_cu_cnf_info();

            }
          }
          break;

        case RRC_T314_EXPIRED_IND:

          /* This function brings down RRC Connection and waits for
             RRC_CHANNEL_CONFIG_CNF from RRC LLC if both T314 and T315
             are expired. Otherwise it releases the RBs associated with T314 */
          rrcu_process_timer_t314_expired();
          break;

        case RRC_T315_EXPIRED_IND:
          /* This function brings down RRC Connection and waits for
             RRC_CHANNEL_CONFIG_CNF from RRC LLC  if both T314 and T315
             are expired. Otherwise it updates rl_failure info to relese rab
             and the rab will be released later when we get the confirmation */
          rrcu_process_timer_t315_expired();
          break;

        case RRC_CPHY_OUT_OF_SERVICE_AREA_IND:
          event_report(EVENT_WCDMA_OUT_OF_SERVICE);


          /* this part needs tobe revisited 
          We are quit waiting for channel_config_cnf and oc is still
          in set state. It is good to enter idle after sending first
          cell update message in such corner cases*/
          /* Start the OOS timer */
          /* if cell update cause was radio link failure or rlc reset in DCH state, then 
           * T305 was never started.  Start min(T305, Toos)
           */
          rrccu_start_t305_or_oos_timer();

          /* Initiate Cell Selection */
          rrccu_send_rrc_initiate_cell_selection_ind(
                                        RRC_OUT_OF_SERVICE_AREA_IND,
                                        rrc_get_state());     

          WRRC_MSG2_HIGH("OC status rrcllc_oc_set_status_e_type_value%d and TOC status %d",rrcllc_get_ordered_config_status_wo_f3(),
              transition_config.toc_usage);

          if((rrcllc_get_ordered_config_status_wo_f3() == OC_SET_FOR_DCH_FACH_TRANS)&&
            (transition_config.toc_usage != TOC_INVALID))
          {
            rrcllc_update_cc_in_fach_with_toc_for_oos_ind();
            (void)rrcllc_reset_ordered_config(RRC_PROCEDURE_CU
                                        ,TRUE
                                        );
          }

          /* Get the appropriate cell update cause based on priority*/
          rrccu_cell_update_cause = 
            rrccu_map_cu_cause_based_on_priority (RRC_REENTERED_SERVICE_AREA);

          rrccu_substate = RRCCU_WAIT_FOR_UE_TO_CAMP_ON;
          break;

        case RRC_NEW_CELL_IND:
          WRRC_MSG2_HIGH("Cell reselection ignored in state:%d, cu_state:%d",
                   rrc_get_state(),rrccu_substate);
          /* No need to Update Cell Update cause as cell reselection
          cause has lower priority than rl failure, rlc unrecoverable error
          Continue in the same substate */
          /*TBD do we need to re-send channel config to establish rb1-4? */
          break;

        case RRC_CELL_UPDATE_INITIATE_REQ:
          if(RRCCU_SUCCESS == rrccu_validate_cell_update_initiate_req(cmd_ptr)) 
          {
            if( (cmd_ptr->cmd.initiate_cell_update.cause == RRC_REENTERED_SERVICE_AREA) &&
                ((cmd_ptr->cmd.initiate_cell_update.procedure == RRC_PROCEDURE_CSP)||
                 (cmd_ptr->cmd.initiate_cell_update.procedure == RRC_PROCEDURE_SIB)) 
              )
            {
              rrccu_process_oos_area_handling();   
            }
          }

          break;

        default:
          MSG_HIGH("Ignoring unexpected cmd 0x%x in cu_state: %d rrc state %d", 
                   cmd_ptr->cmd_hdr.cmd_id,rrccu_substate,rrc_get_state());
          break;
        } /* switch command id */
      break;
    default:
      MSG_HIGH("Ignoring unexpected cmd 0x%x in cu_state: %d rrc state %d", 
               cmd_ptr->cmd_hdr.cmd_id,rrccu_substate,rrc_get_state());
    break;
  } /* switch rrc state */
} /* rrccu_process_cu_wait_for_rb1_rb4_est_cnf */

/*===========================================================================

FUNCTION rrccu_process_cu_wait_for_rb0_est_cnf

DESCRIPTION
  This function processes all events that are dispatched to Cell Update 
  procedure in RRCCU_WAIT_FOR_RB0_EST_CNF substate.

  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
void rrccu_process_cu_wait_for_rb0_est_cnf
(    
  rrc_cmd_type *cmd_ptr
)
{
  uint32 t_305_timer_in_ms = 0;
#ifdef FEATURE_WCDMA_HS_RACH
  ordered_config_type *hsrach_config_ptr = rrcllc_get_config_ptr_in_use();
#endif

  switch(rrc_get_state())
  {
    case RRC_STATE_CELL_FACH:
      switch(cmd_ptr->cmd_hdr.cmd_id)
      {
        case RRC_CPHY_OUT_OF_SERVICE_AREA_IND:
          WRRC_MSG2_HIGH("OOS Ind Rcvd in st:%d cu_st:%d",
                    rrc_get_state(),rrccu_substate);
          event_report(EVENT_WCDMA_OUT_OF_SERVICE);

            /* unregister with RLC for ul data indication 
            It might be too early but we will revisit this */
            //rrccu_unregister_with_rlc_for_ul_data_indication();


          if (rrccu_ura_update_started == TRUE)
          {
            rrccu_ura_update_started = FALSE;
            rrccu_cell_update_started = TRUE;
            /* Update Cell Update cause */
            rrccu_cell_update_cause = rrc_CellUpdateCause_re_enteredServiceArea;
          }
          else
          {
            /* Get the appropriate cell update cause based on priority*/
            rrccu_cell_update_cause = 
              rrccu_map_cu_cause_based_on_priority (RRC_REENTERED_SERVICE_AREA);
          }
          
          /* Start the OOS timer */

          t_305_timer_in_ms = rrc_convert_t305_to_ms(RRC_GET_T305());
          if ( t_305_timer_in_ms <= RRCTMR_T_OOS_TIMER_IN_MS) 
          {
            rrccu_start_t_305_timer();
          }
          else
          {
            rrctmr_start_timer(RRCTMR_T_OOS_TIMER, RRCTMR_T_OOS_TIMER_IN_MS);
          }

          /* Initiate Cell Selection */
          rrccu_send_rrc_initiate_cell_selection_ind( RRC_OUT_OF_SERVICE_AREA_IND,
                                                         rrc_get_state());


          rrccu_substate = RRCCU_WAIT_FOR_UE_TO_CAMP_ON;
          break;

        case RRC_T314_EXPIRED_IND:
          /* This function brings down RRC Connection and waits for
             RRC_CHANNEL_CONFIG_CNF from RRC LLC  if both T314 and T315
             are expired.Otherwise it releases the RBs associated with T314 */
          rrcu_process_timer_t314_expired();
          break;

        case RRC_T315_EXPIRED_IND:
          /* This function brings down RRC Connection and waits for
             RRC_CHANNEL_CONFIG_CNF from RRC LLC if both T314 and T315
             are expired.Otherwise it releases the RBs associated with T315 */
          rrcu_process_timer_t315_expired();
          break;

        case RRC_CHANNEL_CONFIG_CNF:
          rrcllcpcie_initialise_sync_a_post_veri_info();

          if(cmd_ptr->cmd.chan_config_cnf.chan_cfg_status == RRCLLC_CHAN_CFG_SUCCESS)
          {
#ifdef FEATURE_WCDMA_HS_RACH
            if(hsrach_config_ptr->efach_hrnti_status == DEDICATED_HRNTI)
            {
              rrccu_send_meas_rpt_epch_to_efach_trans();
            }
            else
#endif
            {
              rrccu_resend_cell_update_msg(RRCCU_NOT_INCLUDE_FAILURE_CAUSE);
            }
          }
          else
          { 
#ifndef FEATURE_WCDMA_HS_FACH
              /* Channel config failure, so initialise the ordered RB-Mapping database*/
            rrcllc_init_ordered_hanging_rb_mapping_info();
#else
            rrcllc_copy_current_hanging_rb_mapping_to_ordered();
#endif


            /* Failure status is received.*/
            /* Initiate Cell Selection and reset the CU state machine */
            rrccu_send_rrc_initiate_cell_selection_ind(
                                             RRC_CELL_SEL_RB0_SETUP_FAILURE,
                                             RRC_STATE_DISCONNECTED);

            rrccu_substate = RRCCU_INITIAL;
            /*call the procedure to clear the global variabls */
            rrccu_clear_procedure();
            rrccu_init_last_cu_cnf_info();

          }
          break;

        case RRC_NEW_CELL_IND:
          WRRC_MSG2_HIGH("Cell reselection in state:%d, cu_state:%d",
                   rrc_get_state(),rrccu_substate);
          /* Update Cell Update cause only if current cause is 
          periodical cell update */
          if (rrccu_cell_update_cause == rrc_CellUpdateCause_periodicalCellUpdate)
          {
            rrccu_cell_update_cause = rrc_CellUpdateCause_cellReselection;
          }
          /*continue in the same substate */
          break;

        case RRC_T305_EXPIRED_IND:
          /* Continue with the same cause as periodical cell update cause has
          lowest priority */
          /*continue in the same substate */
          break;

        case RRC_STATE_CHANGE_IND:
          if((cmd_ptr->cmd.state_change_ind.new_state == 
              RRC_STATE_DISCONNECTED) &&
             ( rrc_get_state() == RRC_STATE_DISCONNECTED))
          {
             /* Reset CU Procedure and  Procedure ends */
             rrccu_substate = RRCCU_INITIAL; 
             /*call the procedure to clear the global variabls */
             rrccu_clear_procedure();
             rrccu_init_last_cu_cnf_info();

          }
          else
          {
            WRRC_MSG2_ERROR("state change ind %d in state %d ignored",
            cmd_ptr->cmd.state_change_ind.new_state,rrc_get_state());
          }
          break;

        case RRC_CELL_UPDATE_INITIATE_REQ:
          if(RRCCU_SUCCESS == rrccu_validate_cell_update_initiate_req(cmd_ptr)) 
          {
            if( IS_CU_TRIGGERED_WITH_RE_ENTER_SERVICE_AREA_VALID )
            {
              rrccu_process_oos_area_handling();   
            }
          }
          break;

        default:
          /*lint -e793*/
          WRRC_MSG2_ERROR("Unknown command: 0x%x, CU st %d", cmd_ptr->cmd_hdr.cmd_id,
               rrccu_substate);
          /*lint +e793*/
          break;
      }
      break;

    case RRC_STATE_CELL_PCH:
    case RRC_STATE_URA_PCH:
      switch(cmd_ptr->cmd_hdr.cmd_id)
      {
        case RRC_CELL_UPDATE_INITIATE_REQ:
          if(RRCCU_SUCCESS == 
              rrccu_validate_cell_update_initiate_req(cmd_ptr)) 
          {
            if( (cmd_ptr->cmd.initiate_cell_update.cause == RRC_REENTERED_SERVICE_AREA) &&
                ((cmd_ptr->cmd.initiate_cell_update.procedure == RRC_PROCEDURE_CSP)||
                 (cmd_ptr->cmd.initiate_cell_update.procedure == RRC_PROCEDURE_SIB)) 
              )
            {
              rrccu_process_oos_area_handling();
              return;
            }
            if (rrccu_cell_update_started == TRUE)
            {
              /* get the appropriate cell update cause */
              rrccu_cell_update_cause = 
                rrccu_map_cu_cause_based_on_priority (
                  cmd_ptr->cmd.initiate_cell_update.cause);
              /* continue in the same substate */
            }
            else if (rrccu_ura_update_started == TRUE)
            {
              /*cell update was must have been initialized with cause
              other than cell reselection or periodical cell update. In such
              case cell update procedure takes the priority over the ura update
              change the procedure and cause accordingly */
              rrccu_ura_update_started = FALSE;
              rrccu_cell_update_started = TRUE;
              /* Update Cell Update cause */
              rrccu_cell_update_cause = 
                rrccu_map_cu_initiation_cause(cmd_ptr->cmd.initiate_cell_update.cause);
              /* continue in the same substate */
            }
          }
          else
          {
            MSG_HIGH("Invalid cause:%d rrc_st:%d cu_st:%d ",
            cmd_ptr->cmd.initiate_cell_update.cause,rrc_get_state(),rrccu_substate);
          }
          break;
        case RRC_CHANNEL_CONFIG_CNF:
          rrcllcpcie_initialise_sync_a_post_veri_info();

          /* unregister with RLC for ul data indication    */ 
          {
            rrccu_unregister_with_rlc_for_ul_data_indication();
          }
                        
          if(cmd_ptr->cmd.chan_config_cnf.chan_cfg_status == RRCLLC_CHAN_CFG_SUCCESS)
          {
            if (rrccu_cell_update_started)
            {
#ifdef FEATURE_WCDMA_HS_RACH
              if(hsrach_config_ptr->efach_hrnti_status == DEDICATED_HRNTI)
              {
                rrccu_send_meas_rpt_epch_to_efach_trans();
              }
              else
#endif
              {
               /*send cellupdate message with appropriate cause */
                rrccu_resend_cell_update_msg(RRCCU_NOT_INCLUDE_FAILURE_CAUSE);
              }
            }
            else if (rrccu_ura_update_started)
            {
             /*send uraupdate message with appropriate cause */
              rrccu_resend_ura_update_msg(RRCCU_NOT_INCLUDE_FAILURE_CAUSE);
            }
            else
            {
              WRRC_MSG2_ERROR("Unknown command: 0x%x, CU st %d", cmd_ptr->cmd_hdr.cmd_id,
                                          rrccu_substate);
            }
          }
          else
          {
             
            WRRC_MSG1_HIGH("Chan Config fail %d",cmd_ptr->cmd.chan_config_cnf.chan_cfg_status);
#ifndef FEATURE_WCDMA_HS_FACH
              /* Channel config failure, so initialise the ordered RB-Mapping database*/
            rrcllc_init_ordered_hanging_rb_mapping_info();
#else
            rrcllc_copy_current_hanging_rb_mapping_to_ordered();
#endif


            if (cmd_ptr->cmd.chan_config_cnf.chan_cfg_status == RRCLLC_CHAN_CFG_FAILURE_PHY_CHL)
            {
              //initiate cell selection with oos as cause.

              if (rrccu_ura_update_started == TRUE)
              {
               /*Cell update was must have been initialized with cause
                other than cell reselection or periodical cell update. In such
                case cell update procedure takes the priority over the ura update
                change the procedure and cause accordingly */
                rrccu_ura_update_started = FALSE;
                                
                /* continue in the same substate */
              }  
              rrccu_cell_update_started = TRUE;
              /* start the OOS timer */

             /* No need to start T316 here */
              t_305_timer_in_ms = rrc_convert_t305_to_ms(RRC_GET_T305());
              if ( t_305_timer_in_ms <= RRCTMR_T_OOS_TIMER_IN_MS) 
              {
                rrccu_start_t_305_timer();
              }
              else
              {
                rrctmr_start_timer(RRCTMR_T_OOS_TIMER, RRCTMR_T_OOS_TIMER_IN_MS);
              }

              /* Initiate Cell Selection */
              rrccu_send_rrc_initiate_cell_selection_ind(
                                          RRC_OUT_OF_SERVICE_AREA_IND,
                                          rrc_get_state());               

              /* Update cell update cause */
              rrccu_cell_update_cause = 
                  rrccu_map_cu_cause_based_on_priority(RRC_REENTERED_SERVICE_AREA);

              /* Wait for UE to camp on */
              rrccu_substate = RRCCU_WAIT_FOR_UE_TO_CAMP_ON;

            }
            else if (cmd_ptr->cmd.chan_config_cnf.chan_cfg_status == RRCLLC_CHAN_CFG_FAILURE_OTHER )
            {
              /* Failure status is received.*/
              /* Initiate Cell Selection and reset the CU state machine */
              rrccu_send_rrc_initiate_cell_selection_ind(
                                            RRC_CELL_SEL_RB0_SETUP_FAILURE,
                                            RRC_STATE_DISCONNECTED);

              rrccu_substate = RRCCU_INITIAL;
              /*call the procedure to clear the global variabls */
              rrccu_clear_procedure();
            }
            else if (cmd_ptr->cmd.chan_config_cnf.chan_cfg_status == RRCLLC_CHAN_CFG_FAILURE_INCOMPATIBLE_STATE )
            {
              // config rejected due to cell reselection.  Resend channel_config_re
              //continue in the same sub state
#ifdef FEATURE_DUAL_SIM
              if(rrc_acquire_lock_for_pch_to_fach() == SUCCESS)
#endif /*FEATURE_DUAL_SIM*/
              {
                /* Send RRC_CHANNEL_CONFIG_REQ to RRC LLC to establish SRB */                
                rrccu_establish_srb(TRUE, RRC_STATE_CELL_FACH, TRUE);
              }
#ifdef FEATURE_DUAL_SIM
              else
              {
                ERR_FATAL("LOCK isn't acquired in CU substate %d",rrccu_substate,0,0);
              }
#endif /*FEATURE_DUAL_SIM*/                 
            }
          }
          break;

        case RRC_NEW_CELL_IND:
          WRRC_MSG2_HIGH("Cell reselection in state:%d, cu_state:%d",
                   rrc_get_state(),rrccu_substate);
          if (RRC_STATE_CELL_PCH == rrc_get_state())
          {
            if (rrccu_cell_update_started)
            {
              /* get the appropriate cell update cause */
              rrccu_cell_update_cause = 
                rrccu_map_cu_cause_based_on_priority (RRC_CELL_RESELECTION);
            }
            /*continue waiting for SRB establishment */
          } /* current state is CELL_PCH */
          else /* current state is URA_PCH */
          {
            if (rrccu_cell_update_started)
            {
              /* if cell update has been initiated in URA_PCH state
              then it takes the priority over any URA update procedures
              So do not do anything here and let the SRB establishment
              complete. No need to remap the cause because CU can not be active
              in URA_PCH state for cause cell reselection or periodical cellupdate
              so any cu cause will be of higher priority that CELL_RESEL */
              WRRC_MSG2_HIGH("CU active in URA_PCH cause:%d cu_st:%d",rrccu_cell_update_cause,
                       rrccu_substate);
            }
            else  if (rrccu_ura_update_started)
            {
              /*cell reselection when URA update was initiated */
              if (rrccu_check_for_ura_reselection())
              {
                /* Update URA Update cause */
                rrccu_ura_update_cause = rrc_URA_UpdateCause_changeOfURA;
              }
            }
          } /*current state is URA_PCH */
          break;
        case RRC_SIB_CHANGE_IND:
          WRRC_MSG2_HIGH("SIB modification state:%d, cu_state:%d",
                   rrc_get_state(),rrccu_substate);
          if (RRC_STATE_URA_PCH == rrc_get_state())
          {
             /* This function would check if a URA reselection occurred */
            if (rrccu_check_for_ura_reselection())
            {
              /* Update URA Update cause */
              rrccu_ura_update_cause = rrc_URA_UpdateCause_changeOfURA;
            }
          } /*current state is URA_PCH */
          break;
        case RRC_CPHY_OUT_OF_SERVICE_AREA_IND:
          WRRC_MSG2_HIGH("OOS Ind Rcvd in st:%d cu_st:%d",
                    rrc_get_state(),rrccu_substate);
          event_report(EVENT_WCDMA_OUT_OF_SERVICE);

            /* unregister with RLC for ul data indication 
            It might be too early but we will revisit this */
            //rrccu_unregister_with_rlc_for_ul_data_indication();

          
          if (rrccu_ura_update_started == TRUE)
          {
            rrccu_ura_update_started = FALSE;
            rrccu_cell_update_started = TRUE;
            /* Update Cell Update cause */
            rrccu_cell_update_cause = rrc_CellUpdateCause_re_enteredServiceArea;
          }
          else
          {
            /* Get the appropriate cell update cause based on priority*/
            rrccu_cell_update_cause = 
              rrccu_map_cu_cause_based_on_priority (RRC_REENTERED_SERVICE_AREA);
          }
          
          /* Start the OOS timer */
          /* No need to start 316 here */
          t_305_timer_in_ms = rrc_convert_t305_to_ms(RRC_GET_T305());
          if ( t_305_timer_in_ms <= RRCTMR_T_OOS_TIMER_IN_MS) 
          {
            rrccu_start_t_305_timer();
          }
          else
          {
            rrctmr_start_timer(RRCTMR_T_OOS_TIMER, RRCTMR_T_OOS_TIMER_IN_MS);
          }

          /* Initiate Cell Selection */
          rrccu_send_rrc_initiate_cell_selection_ind( RRC_OUT_OF_SERVICE_AREA_IND,
                                                         rrc_get_state());


          rrccu_substate = RRCCU_WAIT_FOR_UE_TO_CAMP_ON;
          break;

        case RRC_STATE_CHANGE_IND:
          if((cmd_ptr->cmd.state_change_ind.new_state == 
              RRC_STATE_DISCONNECTED) &&
             ( rrc_get_state() == RRC_STATE_DISCONNECTED))
          {
             /* Reset CU Procedure and  Procedure ends */
             rrccu_substate = RRCCU_INITIAL; 
             /*call the procedure to clear the global variabls */
             rrccu_clear_procedure();
          }
          else
          {
            WRRC_MSG2_ERROR("state change ind %d in state %d ignored",
            cmd_ptr->cmd.state_change_ind.new_state,rrc_get_state());
          }
          break;

        default:
          WRRC_MSG2_ERROR("Unknown command: 0x%x, CU st %d", cmd_ptr->cmd_hdr.cmd_id,rrccu_substate);
          break;
      }
      break;

    default:
      WRRC_MSG2_HIGH("Invalid Event: %d in the substate: %d", 
                cmd_ptr->cmd_hdr.cmd_id, rrccu_substate);
      break;
  }
} /* rrccu_process_cu_wait_for_rb0_est_cnf */
/*===========================================================================

FUNCTION RRCCU_PROCESS_CU_WAIT_FOR_RB_REL_CNF

DESCRIPTION
  This function processes all events that are dispatched to Cell Update 
  procedure in RRCCU_WAIT_FOR_RB_REL_CNF substate.

  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
void rrccu_process_cu_wait_for_rb_rel_cnf
(    
  rrc_cmd_type *cmd_ptr
)
{
  switch(rrc_get_state())
  {
    case RRC_STATE_CELL_FACH:
    case RRC_STATE_CELL_DCH:
    case RRC_STATE_CELL_PCH:
    case RRC_STATE_URA_PCH:
    case RRC_STATE_DISCONNECTED:
      switch(cmd_ptr->cmd_hdr.cmd_id)
      {
        case RRC_CHANNEL_CONFIG_CNF:     
          rrcllcpcie_initialise_sync_a_post_veri_info();

          /* Stop timer T305 */
          rrctmr_stop_timer(RRCTMR_T_305_TIMER);  
          /* stop timer t302 if cu proc is waiting for cucnf.*/
          if (rrccu_substate == RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM || 
              rrccu_substate == RRCCU_WAIT_FOR_URA_UPDATE_CONFIRM)
          {
            rrctmr_stop_timer(RRCTMR_T_302_TIMER);
          }

          /*stop T314 and T315 timers if they are started */
          if (rrccu_substate != RRCCU_INITIAL)  
          {
            switch (rrccu_cell_update_cause)
            {
              case  rrc_CellUpdateCause_radiolinkFailure:
              case  rrc_CellUpdateCause_re_enteredServiceArea:
                rrctmr_stop_timer(RRCTMR_T_307_TIMER);
                rrctmr_stop_timer(RRCTMR_T_317_TIMER);
                /* stop the oos timer */
                rrctmr_stop_timer(RRCTMR_T_OOS_TIMER);
                /* do not break, fall through */

              case  rrc_CellUpdateCause_rlc_unrecoverableError:
                if (rrccu_failure_state == RRC_STATE_CELL_DCH)
                {
                  WRRC_MSG0_HIGH("Stop re-est timers");
                  rrctmr_stop_timer(RRCTMR_T_314_TIMER);
                  rrctmr_stop_timer(RRCTMR_T_315_TIMER);
                }
                break;

              default:
                break;
            }
          }
          /* Reset CU Procedure and  Procedure ends */
          rrccu_substate = RRCCU_INITIAL; 
          /*call the procedure to clear the global variabls */
          rrccu_clear_procedure();
          break;
 
        case RRC_STATE_CHANGE_IND:
          if((cmd_ptr->cmd.state_change_ind.new_state == 
              RRC_STATE_DISCONNECTED) &&
             ( rrc_get_state() == RRC_STATE_DISCONNECTED))
          {
             /* Stop timer T305 */
             rrctmr_stop_timer(RRCTMR_T_305_TIMER);
             rrctmr_stop_timer(RRCTMR_RRCCU_TRANS_TO_DISCON_TIMER);
             rrccu_tran_to_discon_counter =0;
             /* Reset CU Procedure and  Procedure ends */
             rrccu_substate = RRCCU_INITIAL; 
             /*call the procedure to clear the global variabls */
             rrccu_clear_procedure();
             rrccu_init_last_cu_cnf_info();


          }
          else
          {
            WRRC_MSG2_ERROR("state change ind %d in state %d ignored",
            cmd_ptr->cmd.state_change_ind.new_state,rrc_get_state());
          }
          break;

        case RRC_CRLC_STATUS_IND:
          MSG_MED("Unexpected event:%d in substate:%d",
            cmd_ptr->cmd_hdr.cmd_id, rrccu_substate,0);
          break;

        default:
          WRRC_MSG2_ERROR("Unknown command: 0x%x, CU st %d", cmd_ptr->cmd_hdr.cmd_id,rrccu_substate);
          break;
      }
      break;

    default:
      WRRC_MSG2_HIGH("Invalid Event: %d in the substate: %d", 
                cmd_ptr->cmd_hdr.cmd_id, rrccu_substate);
      break;
  }
} /* rrccu_process_cu_wait_for_rb_rel_cnf */

 /*===========================================================================

FUNCTION RRCCU_FIND_RESPONSE_TO_URA_UPDATE_CONFIRM

DESCRIPTION
  This function processes URA UPDATE CONFIRM message received in response to
  URA Update message.
  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
static rrccu_resp_msg_e_type rrccu_find_response_to_ura_update_confirm
(
void *msg_ptr,                             /* Pointer to Downlink Msg */
uint32 dl_sdu_type                         /* Downlink SDU type */
)
{
  rrccu_resp_msg_e_type       resp_msg =  RRCCU_NO_RESP_MSG;
  rrc_URAUpdateConfirm       *ura_update_confirm = NULL;
  rrc_URAUpdateConfirm_CCCH  *ura_update_cnf_ccch = NULL;

  rrc_DL_CCCH_Message *ccch_msg_ptr;          /* Pointer to Downlink CCCH Msg */
  rrc_DL_DCCH_Message *dcch_msg_ptr;          /* Pointer to Downlink DCCH Msg */

  boolean cn_info_present = FALSE;
  boolean ciphering_mode_info_present = FALSE;
  boolean ip_mode_info_present = FALSE;
  boolean new_urnti_present = FALSE;
  boolean new_crnti_present = FALSE;

  if ( dl_sdu_type == rrc_DL_CCCH_Message_PDU)
  {
    ccch_msg_ptr = (rrc_DL_CCCH_Message *) msg_ptr;
    ura_update_cnf_ccch = &ccch_msg_ptr->message.u.uraUpdateConfirm;

    if(ura_update_cnf_ccch->t == T_rrc_URAUpdateConfirm_CCCH_r3)
    {
      if(RRC_MSG_COMMON_BITMASK_IE(ura_update_cnf_ccch->u.r3.uraUpdateConfirm_CCCH_r3.uraUpdateConfirm,
         rrc_URAUpdateConfirm_r3_IEs,integrityProtectionModeInfo))
      {
        ip_mode_info_present = TRUE;
      }

      if(RRC_MSG_COMMON_BITMASK_IE(ura_update_cnf_ccch->u.r3.uraUpdateConfirm_CCCH_r3.uraUpdateConfirm,
         rrc_URAUpdateConfirm_r3_IEs,cipheringModeInfo))
      {
        ciphering_mode_info_present = TRUE;
      }

      if(RRC_MSG_COMMON_BITMASK_IE(ura_update_cnf_ccch->u.r3.uraUpdateConfirm_CCCH_r3.uraUpdateConfirm, 
         rrc_URAUpdateConfirm_r3_IEs,new_C_RNTI))
      {
        new_crnti_present = TRUE;
      }

      if(RRC_MSG_COMMON_BITMASK_IE(ura_update_cnf_ccch->u.r3.uraUpdateConfirm_CCCH_r3.uraUpdateConfirm,
         rrc_URAUpdateConfirm_r3_IEs,new_U_RNTI))
      {
        new_urnti_present = TRUE;
      }

      if(RRC_MSG_COMMON_BITMASK_IE(ura_update_cnf_ccch->u.r3.uraUpdateConfirm_CCCH_r3.uraUpdateConfirm,
         rrc_URAUpdateConfirm_r3_IEs,cn_InformationInfo))
      {
        cn_info_present = TRUE;
      }
    }
    else
    {
      WRRC_MSG0_ERROR("Later than r3 extensions for CCCH not supported");
    }
  }
  else if ( dl_sdu_type == rrc_DL_DCCH_Message_PDU)
  {
    dcch_msg_ptr = (rrc_DL_DCCH_Message *)msg_ptr; 
    ura_update_confirm = &dcch_msg_ptr->message.u.uraUpdateConfirm;

    if(ura_update_confirm->t == T_rrc_URAUpdateConfirm_later_than_r3)
    {
      if(ura_update_confirm->u.later_than_r3.criticalExtensions.t == 
        T_rrc_URAUpdateConfirm_criticalExtensions_2_r5)
      {
        if(RRC_MSG_COMMON_BITMASK_IE(ura_update_confirm->u.later_than_r3.criticalExtensions.u.r5.uraUpdateConfirm_r5,
           rrc_URAUpdateConfirm_r5_IEs,cn_InformationInfo))
        { 
          cn_info_present = TRUE;
        } 

        if(RRC_MSG_COMMON_BITMASK_IE(ura_update_confirm->u.later_than_r3.criticalExtensions.u.r5.uraUpdateConfirm_r5, 
          rrc_URAUpdateConfirm_r5_IEs,cipheringModeInfo))
        { 
          ciphering_mode_info_present = TRUE;
        } 
       
        if(RRC_MSG_COMMON_BITMASK_IE(ura_update_confirm->u.later_than_r3.criticalExtensions.u.r5.uraUpdateConfirm_r5, 
          rrc_URAUpdateConfirm_r5_IEs,integrityProtectionModeInfo))
        { 
          ip_mode_info_present = TRUE;
        } 

        if(RRC_MSG_COMMON_BITMASK_IE(ura_update_confirm->u.later_than_r3.criticalExtensions.u.r5.uraUpdateConfirm_r5, 
          rrc_URAUpdateConfirm_r5_IEs,new_U_RNTI))
        { 
          new_urnti_present = TRUE;
        } 

        if(RRC_MSG_COMMON_BITMASK_IE(ura_update_confirm->u.later_than_r3.criticalExtensions.u.r5.uraUpdateConfirm_r5, 
           rrc_URAUpdateConfirm_r5_IEs,new_C_RNTI))
        { 
          new_crnti_present = TRUE;
        } 
      }


      else if(ura_update_confirm->u.later_than_r3.criticalExtensions.t == 
                 T_rrc_URAUpdateConfirm_criticalExtensions_2_criticalExtensions)
      {
        if(ura_update_confirm->u.later_than_r3.criticalExtensions.u.criticalExtensions.t == 
                   T_rrc_URAUpdateConfirm_criticalExtensions_1_r7)
        {
          if( ura_update_confirm->u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r7.uraUpdateConfirm_r7.m.cn_InformationInfoPresent)
          { 
            cn_info_present = TRUE;
          } 

          if(ura_update_confirm->u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r7.uraUpdateConfirm_r7.m.cipheringModeInfoPresent)
          { 
            ciphering_mode_info_present = TRUE;
          } 
         
          if(ura_update_confirm->u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r7.uraUpdateConfirm_r7.m.integrityProtectionModeInfoPresent)
          { 
            ip_mode_info_present = TRUE;
          } 

          if(ura_update_confirm->u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r7.uraUpdateConfirm_r7.m.new_U_RNTIPresent )
          { 
            new_urnti_present = TRUE;
          } 

          if(ura_update_confirm->u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r7.uraUpdateConfirm_r7.m.new_C_RNTIPresent)
          { 
            new_crnti_present = TRUE;
          } 
        }
        else
        {
          WRRC_MSG0_ERROR("Critical extensions for non-Rel7 in DCCH are not supported");
        }
      }
      else
      {
        WRRC_MSG0_ERROR("Critical extensions for non-R99 & non-Rel5 in DCCH are not supported");
      }
    } 
    else
    {
      if(RRC_MSG_COMMON_BITMASK_IE(ura_update_confirm->u.r3.uraUpdateConfirm_r3, 
          rrc_URAUpdateConfirm_r3_IEs,cn_InformationInfo))
      {
        cn_info_present = TRUE;
      }

      if(RRC_MSG_COMMON_BITMASK_IE(ura_update_confirm->u.r3.uraUpdateConfirm_r3,
          rrc_URAUpdateConfirm_r3_IEs,cipheringModeInfo))
      {
        ciphering_mode_info_present = TRUE;
      }
       
      if(RRC_MSG_COMMON_BITMASK_IE(ura_update_confirm->u.r3.uraUpdateConfirm_r3, 
          rrc_URAUpdateConfirm_r3_IEs,integrityProtectionModeInfo))
      {
        ip_mode_info_present = TRUE;
      }

      if(RRC_MSG_COMMON_BITMASK_IE(ura_update_confirm->u.r3.uraUpdateConfirm_r3,
          rrc_URAUpdateConfirm_r3_IEs,new_U_RNTI))
      {
        new_urnti_present = TRUE;
      }

      if(RRC_MSG_COMMON_BITMASK_IE(ura_update_confirm->u.r3.uraUpdateConfirm_r3,
          rrc_URAUpdateConfirm_r3_IEs,new_C_RNTI))
      {
        new_crnti_present = TRUE;
      }
    }
  }
  else
  {
    ERR_FATAL("Invalid SDU type",0,0,0);
  }

  if ((cn_info_present == TRUE) ||
      (new_crnti_present == TRUE ) ||
      (new_urnti_present == TRUE)||
      (ip_mode_info_present == TRUE) ||
      (ciphering_mode_info_present == TRUE ))
  {
    resp_msg = RRCCU_UMIC_COMPLETE_RESP_MSG;
  }
  else if ((new_crnti_present != TRUE ) &&
           (new_urnti_present != TRUE) &&
           (ip_mode_info_present != TRUE) &&
           (ciphering_mode_info_present != TRUE ))
  {
    resp_msg = RRCCU_NO_RESP_MSG;
  }
  else
  {
    WRRC_MSG0_ERROR("Unknown Response message");
  }
  return resp_msg;
}  /*  rrccu_find_response_to_ura_update_confirm */
/*===========================================================================

FUNCTION   rrccu_urauc_check_and_get_primary_plmn_id

DESCRIPTION

  This function will check whether primary plmn id is present 
  in r3,r5 path of URA update comfirmation message DCCH/CCCH. If present 
  then it will return primary plmn id.
        
DEPENDENCIES
  None.

RETURN VALUE
TRUE : IF Primary PLMN I.D is present in URA update comfirmation message in r3,r5 path
FFALSE: Otherwise

SIDE EFFECTS

  None.

===========================================================================*/
static boolean rrccu_urauc_check_and_get_primary_plmn_id
(
  /* Pointer to the URA update comfirmation message DCCH message */
  rrc_URAUpdateConfirm *dcch_msg_ptr,
  /* Pointer to the URA update comfirmation message CCCH message */
  rrc_URAUpdateConfirm_CCCH *ccch_msg_ptr,
  /*This will copy primary plmn i.d if present in OTA msg*/
  rrc_PLMN_Identity *primary_plmn_Identity,
  /* Downlink SDU type */
  uint32 dl_sdu_type,
  /*This will indicate OTA msg version*/
  rrc_msg_ver_enum_type msg_version
)
{
  
  boolean primary_plmn_Id_present = FALSE;

  if ( dl_sdu_type == rrc_DL_CCCH_Message_PDU)
  {
    if(ccch_msg_ptr == NULL)
    {
      /*msg ptr is NULL so return from here*/
      return FALSE;
    }
    switch(msg_version)
    {
      case MSG_REL99:
        /*Check to see if primary PLMN I.D is present in URA update comfirmation CCCH 
         *message ext URA update comfirmation-v690ext which is present in 
         * v690NonCriticalExtensions in r99 path
         */
        if((ccch_msg_ptr->u.r3.m.laterNonCriticalExtensionsPresent)&&
           (ccch_msg_ptr->u.r3.laterNonCriticalExtensions.m.v690NonCriticalExtensionsPresent)&&
           (ccch_msg_ptr->u.r3.laterNonCriticalExtensions.v690NonCriticalExtensions.uraUpdateConfirm_v690ext.m.
            primary_plmn_IdentityPresent)
          )
        {
          WRRC_MSG0_HIGH("NWS:urauc_ccch msg contains primary_plmn_Id in r99 path");
          primary_plmn_Id_present = TRUE;
          *primary_plmn_Identity = ccch_msg_ptr->u.r3.laterNonCriticalExtensions.
              v690NonCriticalExtensions.uraUpdateConfirm_v690ext.primary_plmn_Identity;
        }
        break;
   
      default:
        WRRC_MSG1_ERROR("NWS: Msg version = %d, Not supported",msg_version);
        break;
    }
  }
  else if( dl_sdu_type == rrc_DL_DCCH_Message_PDU)
  {
    if(dcch_msg_ptr == NULL)
    {
      /*msg ptr is NULL so return from here*/
      return FALSE;
    }
    switch(msg_version)
    {
      case MSG_REL99:
        /*Check to see if primary PLMN I.D is present in URA update comfirmation DCCH 
         *message ext URA update comfirmation-v690ext which is present in 
         * v690NonCriticalExtensions in r99 path
         */
        if((dcch_msg_ptr->u.r3.m.laterNonCriticalExtensionsPresent)&&
            (dcch_msg_ptr->u.r3.laterNonCriticalExtensions.m.v690NonCriticalExtensionsPresent)&&
            (dcch_msg_ptr->u.r3.laterNonCriticalExtensions.v690NonCriticalExtensions.
            uraUpdateConfirm_v690ext.m.primary_plmn_IdentityPresent)
          )
        {
          WRRC_MSG0_HIGH("NWS:urauc_dcch msg contains primary_plmn_Id in r99 path");
          primary_plmn_Id_present = TRUE;
          *primary_plmn_Identity = dcch_msg_ptr->u.r3.laterNonCriticalExtensions.
            v690NonCriticalExtensions.uraUpdateConfirm_v690ext.primary_plmn_Identity;
        }
        break;
  
      case MSG_REL5:
        /*Check to see if primary PLMN I.D is present in URA update comfirmation DCCH 
         *message ext URA update comfirmation-v690ext which is present in 
         * v690NonCriticalExtensions in r5 path
         */
        if((dcch_msg_ptr->u.later_than_r3.criticalExtensions.u.r5.m.v690NonCriticalExtensionsPresent)&&
           (dcch_msg_ptr->u.later_than_r3.criticalExtensions.u.r5.v690NonCriticalExtensions.
            uraUpdateConfirm_v690ext.m.primary_plmn_IdentityPresent)
          )
        {
          WRRC_MSG0_HIGH("NWS:urauc_dcch msg contains primary_plmn_Id in r5 path");
          primary_plmn_Id_present = TRUE;
          *primary_plmn_Identity = dcch_msg_ptr->u.later_than_r3.criticalExtensions.u.r5.
           v690NonCriticalExtensions.uraUpdateConfirm_v690ext.primary_plmn_Identity;
        }
        break;
       case MSG_REL7:
         /*Check to see if primary PLMN I.D is present in URA update comfirmation DCCH 
         message, present in r7 path*/
         if((dcch_msg_ptr->u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r7.m.uraUpdateConfirm_r7_add_extPresent )
             && (dcch_msg_ptr->u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r7.uraUpdateConfirm_r7.m.primary_plmn_IdentityPresent))
         {
           WRRC_MSG0_HIGH("NWS:urauc_dcch msg contains primary_plmn_Id in r7 path");
           primary_plmn_Id_present = TRUE;
           *primary_plmn_Identity = dcch_msg_ptr->u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r7.
            uraUpdateConfirm_r7.primary_plmn_Identity ;
         }
         break;
   
      default:
        WRRC_MSG1_ERROR("NWS: Msg version = %d, Not supported",msg_version);
        break;
    }
  }
  else
  {
    WRRC_MSG1_ERROR("NWS: Wrong SDU type = %d, Not supported",dl_sdu_type);
  }
  return primary_plmn_Id_present;
}
/*===========================================================================

FUNCTION RRCCU_PROCESS_URA_UPDATE_CONFIRM

DESCRIPTION
  This function processes URA UPDATE CONFIRM message received in response to
  URA Update message.
  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
static void rrccu_process_ura_update_confirm
(
void *msg_ptr,                             /* Pointer to Downlink Msg */
uint32 dl_sdu_type                         /* Downlink SDU type */
)
{
  rrc_cmd_type *cmd_ptr;                      /* Pointer to the RRC Command */
  boolean msg_not_valid = FALSE;
  rrc_state_e_type state ;                    /* Local varible to store state */
  rrc_cmd_type *int_cmd_ptr;                  /* Pointer to the RRC Command */
  rrc_int_c_rnti_type crnti;                  /* Local variable for C-RNTI */
  rrc_int_u_rnti_type urnti;                  /* Local variable for U-RNTI */
  rrc_URAUpdateConfirm *ura_update_confirm = NULL;
  rrc_URAUpdateConfirm_CCCH  *ura_update_cnf_ccch = NULL;

  rrc_DL_CCCH_Message *ccch_msg_ptr;          /* Pointer to Downlink CCCH Msg */
  rrc_DL_DCCH_Message *dcch_msg_ptr;          /* Pointer to Downlink DCCH Msg */

  boolean drx_present                  = FALSE;
  boolean ip_mode_info_present         = FALSE;
  boolean ciphering_mode_info_present  = FALSE;
  uint32  ura_id_length                = 0;

  rrc_U_RNTI      *new_urnti_ptr       = NULL;
  ASN1BitStr32    *new_crnti_ptr       = NULL;
  rrc_CN_InformationInfo  *cn_info_ptr = NULL; 
  ASN1BitStr32            *ura_id_ptr  = NULL;
  /*This will indicate OTA msg version*/
  rrc_msg_ver_enum_type msg_version = MSG_REL99;
   /*Boolean used to indicate primary plmn i.d is present in OTA msg*/
  boolean primary_plmn_Id_present = FALSE;
   /*Variable to hold primary plmn i.d if present in OTA msg*/
  rrc_PLMN_Identity primary_plmn_Identity;

#ifdef FEATURE_WCDMA_HS_FACH
  ASN1BitStr32    *new_hrnti_ptr       = NULL;
  boolean chan_confg_reqd = FALSE;
  boolean new_HRNTI_present = FALSE;
#ifdef FEATURE_WCDMA_HS_RACH
  ASN1BitStr32    *new_ernti_ptr       = NULL;
  boolean new_ERNTI_present = FALSE;
#endif
#endif

  if ( dl_sdu_type == rrc_DL_CCCH_Message_PDU)
  {
    ccch_msg_ptr = (rrc_DL_CCCH_Message *) msg_ptr;
    if(ccch_msg_ptr->message.u.uraUpdateConfirm.t ==
       T_rrc_URAUpdateConfirm_CCCH_later_than_r3 )
    {
      WRRC_MSG0_ERROR("Critical Extensions are not supported");
      /* Update the failure cause */
      rrccu_uu_failure_cause.t =  T_rrc_ProtocolErrorIndicatorWithMoreInfo_errorOccurred;
      rrccu_uu_failure_cause.u.errorOccurred = 
        rtxMemAllocTypeZ (&enc_ctxt, rrc_ProtocolErrorIndicatorWithMoreInfo_errorOccurred);

      rrccu_uu_failure_cause.u.errorOccurred->rrc_TransactionIdentifier = 
        ccch_msg_ptr->message.u.uraUpdateConfirm.u.later_than_r3.rrc_TransactionIdentifier;
      
      rrccu_uu_failure_cause.u.errorOccurred->protocolErrorInformation.
        diagnosticsType.t = T_rrc_ProtocolErrorInformation_diagnosticsType_type1;

      rrccu_uu_failure_cause.u.errorOccurred->protocolErrorInformation.diagnosticsType.u.type1 = 
        rtxMemAllocTypeZ (&enc_ctxt, rrc_ProtocolErrorInformation_type1);

      rrccu_uu_failure_cause.u.errorOccurred->protocolErrorInformation.diagnosticsType.u.type1->
        protocolErrorCause = rrc_ProtocolErrorCause_messageExtensionNotComprehended;

      /* Resend the CELL UPDATE with Failure cause */
      rrccu_resend_ura_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
      return;
    } 
    msg_version = MSG_REL99;
    ura_update_cnf_ccch = &ccch_msg_ptr->message.u.uraUpdateConfirm;

#ifndef FEATURE_WCDMA_HS_FACH
    if((ura_update_cnf_ccch->u.r3.m.laterNonCriticalExtensionsPresent) &&
      (ura_update_cnf_ccch->u.r3.laterNonCriticalExtensions.m.v690NonCriticalExtensionsPresent) &&
      (ura_update_cnf_ccch->u.r3.laterNonCriticalExtensions.v690NonCriticalExtensions.m.v860NonCriticalExtensionsPresent))
    {
      WRRC_MSG0_ERROR("REL8: v860NonCriticalExtensions not supported yet");
    }
#endif

    /* Update transaction identifier */
    rrccu_trans_id = 
       ura_update_cnf_ccch->u.r3.uraUpdateConfirm_CCCH_r3.uraUpdateConfirm.rrc_TransactionIdentifier;

    if(RRC_MSG_COMMON_BITMASK_IE(ura_update_cnf_ccch->u.r3.uraUpdateConfirm_CCCH_r3.uraUpdateConfirm, 
        rrc_URAUpdateConfirm_r3_IEs,new_C_RNTI))
    {
      new_crnti_ptr = &ura_update_cnf_ccch->u.r3.uraUpdateConfirm_CCCH_r3.uraUpdateConfirm.new_C_RNTI;
    }

    if(RRC_MSG_COMMON_BITMASK_IE(ura_update_cnf_ccch->u.r3.uraUpdateConfirm_CCCH_r3.uraUpdateConfirm,
         rrc_URAUpdateConfirm_r3_IEs,new_U_RNTI))
    {
      new_urnti_ptr = &ura_update_cnf_ccch->u.r3.uraUpdateConfirm_CCCH_r3.uraUpdateConfirm.new_U_RNTI;
    }

    if(RRC_MSG_COMMON_BITMASK_IE(ura_update_cnf_ccch->u.r3.uraUpdateConfirm_CCCH_r3.uraUpdateConfirm, 
       rrc_URAUpdateConfirm_r3_IEs,utran_DRX_CycleLengthCoeff))
    {
      drx_present = TRUE;
      rrccu_utran_drx_coef = ura_update_cnf_ccch->u.r3.uraUpdateConfirm_CCCH_r3.uraUpdateConfirm.utran_DRX_CycleLengthCoeff;
    }

    if(RRC_MSG_COMMON_BITMASK_IE(ura_update_cnf_ccch->u.r3.uraUpdateConfirm_CCCH_r3.uraUpdateConfirm, 
          rrc_URAUpdateConfirm_r3_IEs,ura_Identity))
    {
      ura_id_length = ura_update_cnf_ccch->u.r3.uraUpdateConfirm_CCCH_r3.uraUpdateConfirm.ura_Identity.numbits;
      ura_id_ptr    = &ura_update_cnf_ccch->u.r3.uraUpdateConfirm_CCCH_r3.uraUpdateConfirm.ura_Identity;
    }

    if(RRC_MSG_COMMON_BITMASK_IE(ura_update_cnf_ccch->u.r3.uraUpdateConfirm_CCCH_r3.uraUpdateConfirm, 
          rrc_URAUpdateConfirm_r3_IEs,integrityProtectionModeInfo))
    {
      ip_mode_info_present = TRUE;
    }

    if(RRC_MSG_COMMON_BITMASK_IE(ura_update_cnf_ccch->u.r3.uraUpdateConfirm_CCCH_r3.uraUpdateConfirm, 
        rrc_URAUpdateConfirm_r3_IEs,cipheringModeInfo))
    {
      ciphering_mode_info_present = TRUE;
    }

    if(RRC_MSG_COMMON_BITMASK_IE(ura_update_cnf_ccch->u.r3.uraUpdateConfirm_CCCH_r3.uraUpdateConfirm, 
       rrc_URAUpdateConfirm_r3_IEs,cn_InformationInfo))
    {
      cn_info_ptr = &ura_update_cnf_ccch->u.r3.uraUpdateConfirm_CCCH_r3.uraUpdateConfirm.cn_InformationInfo;
    }

    rrccu_state_indicator = ura_update_cnf_ccch->u.r3.uraUpdateConfirm_CCCH_r3.uraUpdateConfirm.rrc_StateIndicator;

#ifdef FEATURE_WCDMA_HS_FACH
    if((ura_update_cnf_ccch->u.r3.m.laterNonCriticalExtensionsPresent) &&
      (ura_update_cnf_ccch->u.r3.laterNonCriticalExtensions.m.v690NonCriticalExtensionsPresent) &&
      (ura_update_cnf_ccch->u.r3.laterNonCriticalExtensions.v690NonCriticalExtensions.m.v860NonCriticalExtensionsPresent))
      {
        if(ura_update_cnf_ccch->u.r3.laterNonCriticalExtensions.v690NonCriticalExtensions.v860NonCriticalExtensions.uraUpdateConfirm_v860ext.m.new_H_RNTIPresent)
        {
          new_hrnti_ptr = &ura_update_cnf_ccch->u.r3.laterNonCriticalExtensions.v690NonCriticalExtensions.v860NonCriticalExtensions.uraUpdateConfirm_v860ext.new_H_RNTI;
          new_HRNTI_present = TRUE;
        }
#ifdef FEATURE_WCDMA_HS_RACH
        if(ura_update_cnf_ccch->u.r3.laterNonCriticalExtensions.v690NonCriticalExtensions.v860NonCriticalExtensions.uraUpdateConfirm_v860ext.m.newPrimary_E_RNTIPresent)
        {
          new_ernti_ptr = &ura_update_cnf_ccch->u.r3.laterNonCriticalExtensions.v690NonCriticalExtensions.v860NonCriticalExtensions.uraUpdateConfirm_v860ext.newPrimary_E_RNTI;
          new_ERNTI_present = TRUE;
        }
#endif
        
      }
#endif
    
  }
  else if ( dl_sdu_type == rrc_DL_DCCH_Message_PDU)
  {    
    dcch_msg_ptr = (rrc_DL_DCCH_Message *) msg_ptr;

    ura_update_confirm = &(dcch_msg_ptr->message.u.uraUpdateConfirm);

    if(dcch_msg_ptr->message.u.uraUpdateConfirm.t ==
       T_rrc_URAUpdateConfirm_later_than_r3 )
    {
      if((rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) &&
         (ura_update_confirm->u.later_than_r3.criticalExtensions.t == 
          T_rrc_URAUpdateConfirm_criticalExtensions_2_r5))
      {
        msg_version = MSG_REL5;
        /* Update state Indicator */   
        rrccu_state_indicator = ura_update_confirm->u.later_than_r3.
              criticalExtensions.u.r5.uraUpdateConfirm_r5.rrc_StateIndicator;

        /* Update Transaction id */
        rrccu_trans_id = ura_update_confirm->u.later_than_r3.rrc_TransactionIdentifier;

        if(RRC_MSG_COMMON_BITMASK_IE(ura_update_confirm->u.later_than_r3.
              criticalExtensions.u.r5.uraUpdateConfirm_r5, 
           rrc_URAUpdateConfirm_r5_IEs,new_C_RNTI))
        { 
          new_crnti_ptr = &ura_update_confirm->u.later_than_r3.
               criticalExtensions.u.r5.uraUpdateConfirm_r5.new_C_RNTI;
        } 

        if(RRC_MSG_COMMON_BITMASK_IE(ura_update_confirm->u.later_than_r3.
           criticalExtensions.u.r5.uraUpdateConfirm_r5,
           rrc_URAUpdateConfirm_r5_IEs,new_U_RNTI))
        { 
          new_urnti_ptr = &ura_update_confirm->u.later_than_r3.
            criticalExtensions.u.r5.uraUpdateConfirm_r5.new_U_RNTI;
        } 

        if(RRC_MSG_COMMON_BITMASK_IE(ura_update_confirm->u.later_than_r3.
           criticalExtensions.u.r5.uraUpdateConfirm_r5, 
           rrc_URAUpdateConfirm_r5_IEs,utran_DRX_CycleLengthCoeff))
        { 
          drx_present = TRUE;
          rrccu_utran_drx_coef = ura_update_confirm->u.later_than_r3.
              criticalExtensions.u.r5.uraUpdateConfirm_r5.utran_DRX_CycleLengthCoeff;
        } 

        if(RRC_MSG_COMMON_BITMASK_IE(ura_update_confirm->u.later_than_r3.
              criticalExtensions.u.r5.uraUpdateConfirm_r5, 
            rrc_URAUpdateConfirm_r5_IEs,ura_Identity))
        { 
          ura_id_length = ura_update_confirm->u.later_than_r3.
              criticalExtensions.u.r5.uraUpdateConfirm_r5.ura_Identity.numbits;
          ura_id_ptr        = &ura_update_confirm->u.later_than_r3.
              criticalExtensions.u.r5.uraUpdateConfirm_r5.ura_Identity;
        } 

        if(RRC_MSG_COMMON_BITMASK_IE(ura_update_confirm->u.later_than_r3.
           criticalExtensions.u.r5.uraUpdateConfirm_r5, 
           rrc_URAUpdateConfirm_r5_IEs,integrityProtectionModeInfo))
        { 
          ip_mode_info_present = TRUE;
        } 

        if(RRC_MSG_COMMON_BITMASK_IE(ura_update_confirm->u.later_than_r3.
              criticalExtensions.u.r5.uraUpdateConfirm_r5, 
              rrc_URAUpdateConfirm_r5_IEs,cipheringModeInfo))
        { 
          ciphering_mode_info_present = TRUE;
        } 

        if(RRC_MSG_COMMON_BITMASK_IE(ura_update_confirm->u.later_than_r3.
           criticalExtensions.u.r5.uraUpdateConfirm_r5, 
           rrc_URAUpdateConfirm_r5_IEs,cn_InformationInfo))
        { 
          cn_info_ptr = &ura_update_confirm->u.later_than_r3.
              criticalExtensions.u.r5.uraUpdateConfirm_r5.cn_InformationInfo;
        } 
      }
      else if((rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL7) &&
         (ura_update_confirm->u.later_than_r3.criticalExtensions.t == 
          T_rrc_URAUpdateConfirm_criticalExtensions_2_criticalExtensions)
          &&(ura_update_confirm->u.later_than_r3.criticalExtensions.u.criticalExtensions.t  == 
          T_rrc_URAUpdateConfirm_criticalExtensions_1_r7))
      {
        rrc_URAUpdateConfirm_r7_IEs * ura_update_cnf_msg_ptr_r7;
        msg_version = MSG_REL7;
        ura_update_cnf_msg_ptr_r7 = &ura_update_confirm->u.later_than_r3.
              criticalExtensions.u.criticalExtensions.u.r7.uraUpdateConfirm_r7;
        /* Update state Indicator */   
        rrccu_state_indicator = ura_update_cnf_msg_ptr_r7->rrc_StateIndicator;

        /* Update Transaction id */
        rrccu_trans_id = ura_update_confirm->u.later_than_r3.rrc_TransactionIdentifier;

        if(RRC_MSG_COMMON_BITMASK_IE_PTR(ura_update_cnf_msg_ptr_r7,
           rrc_URAUpdateConfirm_r7_IEs,new_C_RNTI) )
        { 
          new_crnti_ptr = &ura_update_cnf_msg_ptr_r7->new_C_RNTI;
        } 

        if(RRC_MSG_COMMON_BITMASK_IE_PTR(ura_update_cnf_msg_ptr_r7,
           rrc_URAUpdateConfirm_r7_IEs,new_U_RNTI))
        { 
          new_urnti_ptr = &ura_update_cnf_msg_ptr_r7->new_U_RNTI;
        } 

        if(RRC_MSG_COMMON_BITMASK_IE_PTR(ura_update_cnf_msg_ptr_r7,
           rrc_URAUpdateConfirm_r7_IEs,utran_DRX_CycleLengthCoeff))
        { 
          drx_present = TRUE;
          /* store it in a variable */
          if(rrcllc_update_utran_drx_cycle_length_coeff_in_oc_r7(TRUE,&ura_update_cnf_msg_ptr_r7->utran_DRX_CycleLengthCoeff)
             == SUCCESS)
          {
            if((RRC_MSG_COMMON_BITMASK_IE_TYPE2(ura_update_cnf_msg_ptr_r7->utran_DRX_CycleLengthCoeff,drx_CycleLengthCoefficient2))
               && (RRC_MSG_COMMON_BITMASK_IE_TYPE2(ura_update_cnf_msg_ptr_r7->utran_DRX_CycleLengthCoeff,timeForDRXCycle2)))
              
            {
              rrccu_utran_drx_coef = ura_update_cnf_msg_ptr_r7->utran_DRX_CycleLengthCoeff.drx_CycleLengthCoefficient2;
            }
            else
            {
              rrccu_utran_drx_coef = ura_update_cnf_msg_ptr_r7->utran_DRX_CycleLengthCoeff.drx_CycleLengthCoefficient;
            }
          }
          else
          {
            rrccu_utran_drx_coef = ura_update_cnf_msg_ptr_r7->utran_DRX_CycleLengthCoeff.drx_CycleLengthCoefficient;
          }
          if((RRC_MSG_COMMON_BITMASK_IE_TYPE2(ura_update_cnf_msg_ptr_r7->utran_DRX_CycleLengthCoeff,drx_CycleLengthCoefficient2))
            ||(RRC_MSG_COMMON_BITMASK_IE_TYPE2(ura_update_cnf_msg_ptr_r7->utran_DRX_CycleLengthCoeff,timeForDRXCycle2)))
          {
            WRRC_MSG0_ERROR("drx_CycleLengthCoefficient2_present  or  timeForDRXCycle2_present not supported ");
          }
        } 

        if(RRC_MSG_COMMON_BITMASK_IE_PTR(ura_update_cnf_msg_ptr_r7,
            rrc_URAUpdateConfirm_r7_IEs,ura_Identity))
        { 
          ura_id_length = ura_update_cnf_msg_ptr_r7->ura_Identity.numbits;
          ura_id_ptr        = &ura_update_cnf_msg_ptr_r7->ura_Identity;
        } 

#ifdef FEATURE_WCDMA_REL7_SPECRS         
        
        /*If URA Update Cnf OTA provides "supportForChangeOfUE_Capability" IE, we need to store it in
            "rrc_ordered_rnc_cap_change_support" so that later once the procedure is over successfully, global
            "rrc_rnc_cap_change_support" can be updated accordingly. */
        if(RRC_MSG_COMMON_BITMASK_IE_PTR(ura_update_cnf_msg_ptr_r7,rrc_URAUpdateConfirm_r7_IEs,supportForChangeOfUE_Capability))
        {
          if(ura_update_cnf_msg_ptr_r7->supportForChangeOfUE_Capability == TRUE)
          {
            rrc_ordered_rnc_cap_change_support = RNC_CAP_CHANGE_SUPPORTED;
          }
          else
          {
            rrc_ordered_rnc_cap_change_support = RNC_CAP_CHANGE_UNSUPPORTED;
          }
        }
        else
        {
          rrc_ordered_rnc_cap_change_support = RNC_CAP_CHANGE_NONE;
        }
#endif

#ifndef FEATURE_WCDMA_HS_FACH
        if(ura_update_confirm->u.later_than_r3.criticalExtensions.
			u.criticalExtensions.u.r7.m.v860NonCriticalExtensionsPresent)
        {
          WRRC_MSG0_ERROR("REL8: v860NonCriticalExtensions not supported.");
        }
#endif

        if(RRC_MSG_COMMON_BITMASK_IE_PTR(ura_update_cnf_msg_ptr_r7, 
           rrc_URAUpdateConfirm_r7_IEs,integrityProtectionModeInfo))
        { 
          ip_mode_info_present = TRUE;
        } 

        if(RRC_MSG_COMMON_BITMASK_IE_PTR(ura_update_cnf_msg_ptr_r7,
              rrc_URAUpdateConfirm_r7_IEs,cipheringModeInfo))
        { 
          ciphering_mode_info_present = TRUE;
        } 

        if(RRC_MSG_COMMON_BITMASK_IE_PTR(ura_update_cnf_msg_ptr_r7,
           rrc_URAUpdateConfirm_r7_IEs,cn_InformationInfo))
        { 
          cn_info_ptr = &ura_update_cnf_msg_ptr_r7->cn_InformationInfo;
        } 

#ifdef FEATURE_WCDMA_HS_FACH
        if(ura_update_confirm->u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r7.m.v860NonCriticalExtensionsPresent)
          {
            if(ura_update_confirm->u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r7.v860NonCriticalExtensions.uraUpdateConfirm_v860ext.m.new_H_RNTIPresent)
            {
              new_hrnti_ptr = &ura_update_confirm->u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r7.v860NonCriticalExtensions.uraUpdateConfirm_v860ext.new_H_RNTI;
              new_HRNTI_present = TRUE;
            }
#ifdef FEATURE_WCDMA_HS_RACH
            if(ura_update_confirm->u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r7.v860NonCriticalExtensions.uraUpdateConfirm_v860ext.m.newPrimary_E_RNTIPresent)
            {
              new_ernti_ptr = &ura_update_confirm->u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r7.v860NonCriticalExtensions.uraUpdateConfirm_v860ext.newPrimary_E_RNTI;
              new_ERNTI_present = TRUE;
            }
#endif
          }
#endif
        
      }
      else
      {
        WRRC_MSG0_ERROR("Critical Extensions are not supported");
        /* Update the failure cause */
        rrccu_uu_failure_cause.t =  T_rrc_ProtocolErrorIndicatorWithMoreInfo_errorOccurred;
		 rrccu_uu_failure_cause.u.errorOccurred = 
         rtxMemAllocTypeZ (&enc_ctxt, rrc_ProtocolErrorIndicatorWithMoreInfo_errorOccurred);
  
        rrccu_uu_failure_cause.u.errorOccurred->rrc_TransactionIdentifier = 
        dcch_msg_ptr->message.u.uraUpdateConfirm.u.later_than_r3.rrc_TransactionIdentifier;
        rrccu_uu_failure_cause.u.errorOccurred->protocolErrorInformation.
        diagnosticsType.t = T_rrc_ProtocolErrorInformation_diagnosticsType_type1;

		rrccu_uu_failure_cause.u.errorOccurred->protocolErrorInformation.diagnosticsType.u.type1 = 
        rtxMemAllocTypeZ (&enc_ctxt, rrc_ProtocolErrorInformation_type1);

        rrccu_uu_failure_cause.u.errorOccurred->protocolErrorInformation.
        diagnosticsType.u.type1->protocolErrorCause = 
        rrc_ProtocolErrorCause_messageExtensionNotComprehended;

        /* Resend the URA UPDATE with Failure cause */
        rrccu_resend_ura_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
        return;
      }
    }
    else
    {
      msg_version = MSG_REL99;
      /* Update state Indicator */
      rrccu_state_indicator = ura_update_confirm->u.r3.uraUpdateConfirm_r3.rrc_StateIndicator;
      /* Update Transaction id */
      rrccu_trans_id = ura_update_confirm->u.r3.uraUpdateConfirm_r3.rrc_TransactionIdentifier;

      if(RRC_MSG_COMMON_BITMASK_IE(ura_update_confirm->u.r3.uraUpdateConfirm_r3, 
         rrc_URAUpdateConfirm_r3_IEs,new_C_RNTI) )
      {
        new_crnti_ptr = &ura_update_confirm->u.r3.uraUpdateConfirm_r3.new_C_RNTI;
      }

      if(RRC_MSG_COMMON_BITMASK_IE(ura_update_confirm->u.r3.uraUpdateConfirm_r3,
         rrc_URAUpdateConfirm_r3_IEs,new_U_RNTI))
      {
        new_urnti_ptr = &ura_update_confirm->u.r3.uraUpdateConfirm_r3.new_U_RNTI;
      }

      if(RRC_MSG_COMMON_BITMASK_IE(ura_update_confirm->u.r3.uraUpdateConfirm_r3, 
          rrc_URAUpdateConfirm_r3_IEs,utran_DRX_CycleLengthCoeff))
      {
        drx_present = TRUE;
        rrccu_utran_drx_coef = ura_update_confirm->u.r3.uraUpdateConfirm_r3.utran_DRX_CycleLengthCoeff;
      }

      if(RRC_MSG_COMMON_BITMASK_IE(ura_update_confirm->u.r3.uraUpdateConfirm_r3, 
            rrc_URAUpdateConfirm_r3_IEs,ura_Identity))
      {
        ura_id_length = ura_update_confirm->u.r3.uraUpdateConfirm_r3.ura_Identity.numbits;
        ura_id_ptr    = &ura_update_confirm->u.r3.uraUpdateConfirm_r3.ura_Identity;
      }

      if(RRC_MSG_COMMON_BITMASK_IE(ura_update_confirm->u.r3.uraUpdateConfirm_r3, 
            rrc_URAUpdateConfirm_r3_IEs,integrityProtectionModeInfo))
      {
        ip_mode_info_present = TRUE;
      }

      if(RRC_MSG_COMMON_BITMASK_IE(ura_update_confirm->u.r3.uraUpdateConfirm_r3, 
         rrc_URAUpdateConfirm_r3_IEs,cipheringModeInfo))
      {
        ciphering_mode_info_present = TRUE;
      }

      if(RRC_MSG_COMMON_BITMASK_IE(ura_update_confirm->u.r3.uraUpdateConfirm_r3, 
         rrc_URAUpdateConfirm_r3_IEs,cn_InformationInfo))
      {
        cn_info_ptr = &ura_update_confirm->u.r3.uraUpdateConfirm_r3.cn_InformationInfo;
      }
    }
  }
  else
  {
    ERR_FATAL("Invalid SDU type",0,0,0);
  }

      /*Check to see if primary PLMN I.D is present in URA update comfirmation CCCH message ext
       * URA update comfirmation CCCH/DCCH-v690ext which is present in 
       * v690NonCriticalExtensions
       */
  primary_plmn_Id_present = rrccu_urauc_check_and_get_primary_plmn_id(ura_update_confirm,
                                                                          ura_update_cnf_ccch,
                                                                          &primary_plmn_Identity,
                                                                          dl_sdu_type,
                                                                          msg_version);

  state = rrc_translate_state_indicator_to_state(rrccu_state_indicator);

  /* check whether new CRNTI is present in the message or not when there is
  no valid C-RNTI is existing and next state indicated by the message is 
  CELL_FACH */
  if ((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_FACH) ||
     (((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH) || (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH)) &&
     (RRCCU_NO_RESP_MSG != rrccu_find_response_to_ura_update_confirm (msg_ptr, dl_sdu_type))))
  {
    if ((C_RNTI_NOT_VALID == rrcllc_get_current_crnti_status()) && 
        (new_crnti_ptr == NULL ))
    {
      if(((rrcllc_get_toc_usage() == TOC_FOR_OOS)
              || (rrcllc_get_toc_usage() == TOC_FOR_OOS_WITHOUT_DCH_INFO)
              || (rrcllc_get_toc_usage() == TOC_FOR_OOS_WITH_DCH_INFO)

        ) && 
         (rrcrb_get_new_crnti_valid() && rrccsp_is_selected_cell_utran_directed()))
      {
        WRRC_MSG0_HIGH("Crnti present in reconfig msg");
      }
      else
      {
        WRRC_MSG1_ERROR("No CRNTI for next_st:%d", rrccu_state_indicator);
        /* set the invalid msg flag */
        msg_not_valid = TRUE;
      }
    }
  }

#ifdef FEATURE_WCDMA_HS_FACH
  /*RNTI validation for HS-FACH and HS-RACH*/
  if(rrccu_check_rnti_for_resending_cu(new_HRNTI_present,new_ERNTI_present,msg_version,
                                       rrccu_find_response_to_ura_update_confirm (msg_ptr,
                                                                                  dl_sdu_type)) == TRUE)
  {
    rrccu_substate = RRCCU_WAIT_FOR_URA_UPDATE_CONFIRM;
    rrccu_resend_ura_update_msg(RRCCU_NOT_INCLUDE_FAILURE_CAUSE);
    return;
  }
#endif

  if ((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH) ||
      (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH))
  {
    if (drx_present == FALSE)
    {
      WRRC_MSG0_ERROR("UTRAN DRX is not present");
      
      /* set the invalid msg flag */
      msg_not_valid = TRUE;
    }

       /*resend the cell update message if there is any invalid config*/
    if  (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH)
    {
      if (ura_id_ptr == NULL)
      {
        WRRC_MSG0_HIGH("URA-id is not present");
        rrccu_clear_ura_id();
      }
      /* update rrccu procedure with new URA-id */
      else
      {
        /*URA ID present in the message set ura_identity variable with this value */
        if (ura_id_length == 16)
        {
          /*rrccu_translate_ura_id (&(msg_ptr->u.r3.radioBearerReconfiguration_r3.ura_Identity));*/
          rrccu_update_ura_id (ura_id_ptr);
        }
        else
        {
          WRRC_MSG1_ERROR("Invalid URA ID length%d",
              ura_id_length);
          /* set the invalid msg flag */
          msg_not_valid = TRUE;
        }
      }
      /* check whether URA update is required and set the flag
      accordingly */
      rrccu_ura_update_required = rrccu_check_for_ura_reselection();
    }
  }

#ifdef FEATURE_WCDMA_HS_FACH
  if ((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_FACH)|| 
      (rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH) || 
      (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH))
  {
    if((rrcenhstate_camped_cell_supports_e_fach() == TRUE) &&
        (new_hrnti_ptr != NULL))
    {
      WRRC_MSG0_HIGH("EFACH:Updated HRNTI from URA-CNF");
      rrccu_update_hrnti_from_ota(new_hrnti_ptr, transition_config.toc_ptr);
      chan_confg_reqd = TRUE;
    }
#ifdef FEATURE_WCDMA_HS_RACH
    if((rrchsrach_camped_cell_supports_hsrach() == TRUE)&&
        (new_ernti_ptr!=NULL))
    {
      /*store the ernti*/
      ordered_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = TRUE;
      (void)rrc_translate_ernti(new_ernti_ptr, &ordered_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti);
      transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = TRUE;
      transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti = ordered_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti;
      chan_confg_reqd = TRUE;
    }
#endif
    if(chan_confg_reqd == TRUE)
    {
      rrcllc_establish_srb_rab_in_efach(RRC_E_FACH_DEDICATED,RRC_PROCEDURE_CU,FALSE);
    }
  }
#endif

  if (msg_not_valid)
  {
    /* Set the Transaction Id */
    /* Update the failure cause */
    rrccu_uu_failure_cause.t =  T_rrc_ProtocolErrorIndicatorWithMoreInfo_errorOccurred;
	 rrccu_uu_failure_cause.u.errorOccurred = 
       rtxMemAllocTypeZ (&enc_ctxt, rrc_ProtocolErrorIndicatorWithMoreInfo_errorOccurred);

    rrccu_uu_failure_cause.u.errorOccurred->rrc_TransactionIdentifier = rrccu_trans_id;
    rrccu_uu_failure_cause.u.errorOccurred->protocolErrorInformation.
      diagnosticsType.t = T_rrc_ProtocolErrorInformation_diagnosticsType_type1;
	 rrccu_uu_failure_cause.u.errorOccurred->protocolErrorInformation.diagnosticsType.u.type1 = 
        rtxMemAllocTypeZ (&enc_ctxt, rrc_ProtocolErrorInformation_type1);

    rrccu_uu_failure_cause.u.errorOccurred->protocolErrorInformation.
      diagnosticsType.u.type1->protocolErrorCause = 
      rrc_ProtocolErrorCause_informationElementMissing;
    rrccu_resend_ura_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
    /* continue with rrccu state  RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM */
    return;
  }
  rrccu_resp_msg = rrccu_find_response_to_ura_update_confirm(msg_ptr, dl_sdu_type);

  if (rrccu_resp_msg == RRCCU_UMIC_COMPLETE_RESP_MSG)
  {
    if ((rrccu_cucnf_for_srns_relocation == TRUE) && 
        ((ip_mode_info_present == TRUE)||(ciphering_mode_info_present == TRUE)))
    {
      WRRC_MSG0_HIGH("Processing SRNS for URA Update Confirm");

      /* procedure involves SRNS relocation so store the C-RNTI
             and send rlc_reestablishment request to SMC . RNTI update 
             will be done after RLC re-establishment*/
      if (new_crnti_ptr != NULL) 
      {
        rrccu_new_crnti_valid = TRUE;
        rrc_translate_crnti(new_crnti_ptr, &rrccu_new_crnti);

#ifdef FEATURE_WCDMA_HS_RACH
        if(rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH)
        {
          rrchsrach_set_hspa_rnti_stored_cell_pch(ordered_config_ptr,TRUE);
        }
#endif
      }
      if(new_urnti_ptr != NULL)
      {
        rrccu_new_urnti_valid = TRUE;
        rrc_translate_urnti(new_urnti_ptr, &rrccu_new_urnti);
      }
      /* store the rlc re-establishment indications */
      rrccu_reestablish_srb = FALSE;
      rrccu_reestablish_rab = FALSE;

      //commit fresh values for srns relocation
      rrcsmc_commit_fresh_for_srns_relocation();

      /* Send the rlc re-establishment request to SMC to re-establish SRB2 */
      /* Get the command buffer */
      int_cmd_ptr = rrc_get_int_cmd_buf();
        /* Fill in the command id  */
        int_cmd_ptr->cmd_hdr.cmd_id = RRC_RE_EST_RLC_FOR_SRNS_REQ;
        int_cmd_ptr->cmd.rrc_re_est_srns_req.rrc_proc = RRC_PROCEDURE_CU;
        int_cmd_ptr->cmd.rrc_re_est_srns_req.rb_type  = RRC_RE_EST_RB_2;
        int_cmd_ptr->cmd.rrc_re_est_srns_req.cnf_reqd = TRUE;
      WRRC_MSG1_HIGH(" URA confirm doing SRNS relocation, RLC Reestablish req for %d ", 
                 RRC_RE_EST_RB_2); 

        rrc_put_int_cmd(int_cmd_ptr);             
        rrccu_substate = RRCCU_WAIT_FOR_SRB2_RE_EST_CNF;         
      }
    else if ((new_crnti_ptr != NULL)||(new_urnti_ptr != NULL))
    {
      /* Allocates the buffer to RRC Internal command */
      cmd_ptr =  rrc_get_int_cmd_buf();
      {
        cmd_ptr->cmd_hdr.cmd_id = RRC_RNTI_UPDATE_REQ;

        /* Fill parameters for RRC_RNTI_UPDATE_REQ command */
        cmd_ptr->cmd.rnti_update_req.procedure = RRC_PROCEDURE_CU;

        if (new_crnti_ptr != NULL)
        {
          rrc_translate_crnti(new_crnti_ptr,&crnti);
          cmd_ptr->cmd.rnti_update_req.crnti = crnti;
          cmd_ptr->cmd.rnti_update_req.crnti_action = RRC_RNTI_UPDATE;

#ifdef FEATURE_WCDMA_HS_RACH
          if(rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH)
          {
            rrchsrach_set_hspa_rnti_stored_cell_pch(ordered_config_ptr,TRUE);
          }
#endif

        }
        else
        {
          cmd_ptr->cmd.rnti_update_req.crnti_action = RRC_RNTI_NOCHANGE;
        }

        if (new_urnti_ptr != NULL)
        {
          rrc_translate_urnti(new_urnti_ptr, &urnti);
          cmd_ptr->cmd.rnti_update_req.urnti= urnti;
          cmd_ptr->cmd.rnti_update_req.urnti_action = RRC_RNTI_UPDATE;
        }
        else
        {
          cmd_ptr->cmd.rnti_update_req.urnti_action = RRC_RNTI_NOCHANGE;
        }
        cmd_ptr->cmd.rnti_update_req.cnf_required = TRUE;
        cmd_ptr->cmd.rnti_update_req.rlc_re_establish_srb = FALSE;
        cmd_ptr->cmd.rnti_update_req.rlc_re_establish_rab = FALSE;
        WRRC_MSG2_HIGH("RNTI update req crnti:%d, urnti:%d",
                   cmd_ptr->cmd.rnti_update_req.crnti_action,
                   cmd_ptr->cmd.rnti_update_req.urnti_action);
        rrc_put_int_cmd(cmd_ptr);       /* sends the command to RRC  LLC. */
        rrccu_substate = RRCCU_WAIT_FOR_RNTI_UPDATE_CNF;
      }
    }
    else 
    {
      WRRC_MSG0_HIGH("C-RNTI & U-RNTI both are not present");
      rrccu_send_response_msg();
    }
    
    if (cn_info_ptr != NULL)
    {
      (void) rrc_ccm_send_nas_cn_info(
                     cn_info_ptr
                     ,primary_plmn_Id_present
                     ,&primary_plmn_Identity
           );
    }
  }
  else if ( rrccu_resp_msg == RRCCU_NO_RESP_MSG)
  {
    /* if the next state is cell_pch or ura_pch then setup pcch */
    if ((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH) ||
         (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH))
    {
      if (cn_info_ptr != NULL)
      {
        (void) rrc_ccm_send_nas_cn_info(
                     cn_info_ptr
                     ,primary_plmn_Id_present
                     ,&primary_plmn_Identity
               );
      }
     /*set the UTRAN DRX coef in rrcllc */
      rrcllc_set_utran_drx_info (rrccu_utran_drx_coef); 
      rrccu_establish_pcch_rb (state);
      rrccu_substate = RRCCU_WAIT_FOR_PCCH_RB_EST_CNF;
    }
    else 
    {
      /* Reset the state machine and the procedure ends */
      rrccu_substate = RRCCU_INITIAL;
      /* Start timer T305 */
      rrccu_start_t_305_timer();

      if (cn_info_ptr != NULL)
      {
        (void) rrc_ccm_send_nas_cn_info(
                      cn_info_ptr
                     ,primary_plmn_Id_present
                     ,&primary_plmn_Identity
              );
      }
     /* Inform all registered RRC procedures that Cell
       Update is completed */
      rrccu_inform_ura_update_completed();

   
      rrccu_process_successful_completion();

      /*call the procedure to clear the global variabls */
      rrccu_clear_procedure();
    }
  }
} /* rrccu_process_ura_update_confirm*/

/*===========================================================================

FUNCTION RRCCU_RESPONSE_TO_CELL_UPDATE_CONFIRM

DESCRIPTION
  This function evaluates CELL UPDATE CONFIRM message and decides what
  response message has to be sent
  Cell Update message.
  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
static rrccu_resp_msg_e_type rrccu_find_response_to_cell_update_confirm
(    
  void *msg_ptr,                              /* Pointer to Downlink Msg */
  uint32 dl_sdu_type                          /* Downlink SDU type */
)
{

  rrc_DL_CCCH_Message *ccch_msg_ptr;          /* Pointer to Downlink CCCH Msg */
  rrc_DL_DCCH_Message *dcch_msg_ptr;          /* Pointer to Downlink DCCH Msg */
  rrc_CellUpdateConfirm_r3_IEs *cell_update_confirm = NULL;
  rrccu_resp_msg_e_type resp_msg= RRCCU_NO_RESP_MSG;

  if( dl_sdu_type == rrc_DL_CCCH_Message_PDU)
  {
    ccch_msg_ptr = (rrc_DL_CCCH_Message *) msg_ptr;
    cell_update_confirm = &ccch_msg_ptr->message.u.cellUpdateConfirm.u.
                           r3.cellUpdateConfirm_r3;
  }
  else if( dl_sdu_type == rrc_DL_DCCH_Message_PDU)
  {
    dcch_msg_ptr = (rrc_DL_DCCH_Message *) msg_ptr;
                  
    cell_update_confirm = &dcch_msg_ptr->message.u.cellUpdateConfirm.u.
                          r3.cellUpdateConfirm_r3;
  }
  else
  {
    ERR_FATAL("Invalid SDU type",0,0,0);
  }
  /*if(cell_update_confirm == NULL)
  {
    ERR_FATAL("Null Pointer passed",0,0,0);
    return resp_msg;
  }*/
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, rrc_CellUpdateConfirm_r3_IEs,rb_InformationReleaseList))
  {
    resp_msg = RRCCU_RBR_COMPLETE_RESP_MSG;
  }
  else if(!(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, rrc_CellUpdateConfirm_r3_IEs,rb_InformationReleaseList)) &&
          ( (RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, rrc_CellUpdateConfirm_r3_IEs,rb_InformationReconfigList)) ||
            (RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, rrc_CellUpdateConfirm_r3_IEs,rb_InformationAffectedList)) )
          )
  {
    resp_msg = RRCCU_RBRC_COMPLETE_RESP_MSG;
  }
  else if (!(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, rrc_CellUpdateConfirm_r3_IEs,rb_InformationReleaseList)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, rrc_CellUpdateConfirm_r3_IEs,rb_InformationReconfigList)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
            rrc_CellUpdateConfirm_r3_IEs,rb_InformationAffectedList)) &&
           ( (RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
             rrc_CellUpdateConfirm_r3_IEs,ul_CommonTransChInfo)) ||
             (RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
             rrc_CellUpdateConfirm_r3_IEs,ul_deletedTransChInfoList)) ||
             (RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
             rrc_CellUpdateConfirm_r3_IEs,ul_AddReconfTransChInfoList)) ||
             (RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm,            
             rrc_CellUpdateConfirm_r3_IEs,dl_CommonTransChInfo))||
             (RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm,       
             rrc_CellUpdateConfirm_r3_IEs,dl_DeletedTransChInfoList)) ||
             (RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm,   
             rrc_CellUpdateConfirm_r3_IEs,dl_AddReconfTransChInfoList)) )
          )
  {
    resp_msg = RRCCU_TCR_COMPLETE_RESP_MSG;
  }
  else if (!(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, rrc_CellUpdateConfirm_r3_IEs,rb_InformationReleaseList)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, rrc_CellUpdateConfirm_r3_IEs,rb_InformationReconfigList)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
            rrc_CellUpdateConfirm_r3_IEs,rb_InformationAffectedList)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
             rrc_CellUpdateConfirm_r3_IEs,ul_CommonTransChInfo)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
             rrc_CellUpdateConfirm_r3_IEs,ul_deletedTransChInfoList)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
             rrc_CellUpdateConfirm_r3_IEs,ul_AddReconfTransChInfoList)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm,            
             rrc_CellUpdateConfirm_r3_IEs,dl_CommonTransChInfo))&&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm,       
             rrc_CellUpdateConfirm_r3_IEs,dl_DeletedTransChInfoList)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm,   
             rrc_CellUpdateConfirm_r3_IEs,dl_AddReconfTransChInfoList)) &&
           ( (RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
             rrc_CellUpdateConfirm_r3_IEs,ul_ChannelRequirement)) ||
             (RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm,
             rrc_CellUpdateConfirm_r3_IEs,dl_CommonInformation)) ||
             (RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm,
             rrc_CellUpdateConfirm_r3_IEs,dl_InformationPerRL_List)) ||
             (RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm,
             rrc_CellUpdateConfirm_r3_IEs,frequencyInfo)) || 
             (RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm,
             rrc_CellUpdateConfirm_r3_IEs,maxAllowedUL_TX_Power)))
          )
  {
    resp_msg = RRCCU_PCR_COMPLETE_RESP_MSG;
  }
  else if (!(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, rrc_CellUpdateConfirm_r3_IEs,rb_InformationReleaseList)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, rrc_CellUpdateConfirm_r3_IEs,rb_InformationReconfigList)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
            rrc_CellUpdateConfirm_r3_IEs,rb_InformationAffectedList)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
             rrc_CellUpdateConfirm_r3_IEs,ul_CommonTransChInfo)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
             rrc_CellUpdateConfirm_r3_IEs,ul_deletedTransChInfoList)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
             rrc_CellUpdateConfirm_r3_IEs,ul_AddReconfTransChInfoList)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm,            
             rrc_CellUpdateConfirm_r3_IEs,dl_CommonTransChInfo))&&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm,       
             rrc_CellUpdateConfirm_r3_IEs,dl_DeletedTransChInfoList)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm,   
             rrc_CellUpdateConfirm_r3_IEs,dl_AddReconfTransChInfoList)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
             rrc_CellUpdateConfirm_r3_IEs,ul_ChannelRequirement)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm,
             rrc_CellUpdateConfirm_r3_IEs,dl_CommonInformation)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm,
             rrc_CellUpdateConfirm_r3_IEs,dl_InformationPerRL_List)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm,
             rrc_CellUpdateConfirm_r3_IEs,frequencyInfo))&&
           ( (RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm,
             rrc_CellUpdateConfirm_r3_IEs,cn_InformationInfo)) ||
             (RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm,
             rrc_CellUpdateConfirm_r3_IEs,cipheringModeInfo)) ||
             (RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm,
             rrc_CellUpdateConfirm_r3_IEs,integrityProtectionModeInfo))||
             (RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
             rrc_CellUpdateConfirm_r3_IEs,new_U_RNTI)) ||
             (RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
             rrc_CellUpdateConfirm_r3_IEs,new_C_RNTI)) )
          )
  {
    resp_msg = RRCCU_UMIC_COMPLETE_RESP_MSG;
  }
  else if (!(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, rrc_CellUpdateConfirm_r3_IEs,rb_InformationReleaseList)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, rrc_CellUpdateConfirm_r3_IEs,rb_InformationReconfigList)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
            rrc_CellUpdateConfirm_r3_IEs,rb_InformationAffectedList)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
             rrc_CellUpdateConfirm_r3_IEs,ul_CommonTransChInfo)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
             rrc_CellUpdateConfirm_r3_IEs,ul_deletedTransChInfoList)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
             rrc_CellUpdateConfirm_r3_IEs,ul_AddReconfTransChInfoList)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm,            
             rrc_CellUpdateConfirm_r3_IEs,dl_CommonTransChInfo))&&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm,       
             rrc_CellUpdateConfirm_r3_IEs,dl_DeletedTransChInfoList)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm,   
             rrc_CellUpdateConfirm_r3_IEs,dl_AddReconfTransChInfoList)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
             rrc_CellUpdateConfirm_r3_IEs,ul_ChannelRequirement)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm,
             rrc_CellUpdateConfirm_r3_IEs,dl_CommonInformation)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm,
             rrc_CellUpdateConfirm_r3_IEs,dl_InformationPerRL_List)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm,
             rrc_CellUpdateConfirm_r3_IEs,frequencyInfo))&&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm,
             rrc_CellUpdateConfirm_r3_IEs,cn_InformationInfo)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm,
             rrc_CellUpdateConfirm_r3_IEs,cipheringModeInfo)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm,
             rrc_CellUpdateConfirm_r3_IEs,integrityProtectionModeInfo)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
             rrc_CellUpdateConfirm_r3_IEs,new_U_RNTI)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
             rrc_CellUpdateConfirm_r3_IEs,new_C_RNTI))
          )
  {
    resp_msg = RRCCU_NO_RESP_MSG;
  }

  return resp_msg;

} /*  rrccu_find_response_to_cell_update_confirm */


/*===========================================================================

FUNCTION RRCCU_RESPONSE_TO_CELL_UPDATE_CONFIRM_R5

DESCRIPTION
  This function evaluates CELL UPDATE CONFIRM message and decides what
  response message has to be sent
  Cell Update message.
  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
static rrccu_resp_msg_e_type rrccu_find_response_to_cell_update_confirm_r5
(    
  void *msg_ptr,                              /* Pointer to Downlink Msg */
  uint32 dl_sdu_type                          /* Downlink SDU type */
)
{

  rrc_DL_CCCH_Message *ccch_msg_ptr;          /* Pointer to Downlink CCCH Msg */
  rrc_DL_DCCH_Message *dcch_msg_ptr;          /* Pointer to Downlink DCCH Msg */
  rrc_CellUpdateConfirm_r5_IEs *cucnf_ptr = NULL;
  rrccu_resp_msg_e_type resp_msg= RRCCU_NO_RESP_MSG;

  if( dl_sdu_type == rrc_DL_CCCH_Message_PDU)
  {
    ccch_msg_ptr = (rrc_DL_CCCH_Message *) msg_ptr;
    cucnf_ptr = &ccch_msg_ptr->message.u.cellUpdateConfirm.u.
      later_than_r3.criticalExtensions.u.criticalExtensions.u.r5.cellUpdateConfirm_r5;
  }
  else if( dl_sdu_type == rrc_DL_DCCH_Message_PDU)
  {
    dcch_msg_ptr = (rrc_DL_DCCH_Message *) msg_ptr;
                  
    cucnf_ptr = &dcch_msg_ptr->message.u.cellUpdateConfirm.u.
      later_than_r3.criticalExtensions.u.criticalExtensions.u.r5.cellUpdateConfirm_r5;
  }
  else
  {
    ERR_FATAL("Invalid SDU type",0,0,0);
  }
  
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r5_IEs,rb_InformationReleaseList))
  {
    resp_msg = RRCCU_RBR_COMPLETE_RESP_MSG;
  }
  else if(!(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr,
            rrc_CellUpdateConfirm_r5_IEs,rb_InformationReleaseList)) &&
          ( (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, 
            rrc_CellUpdateConfirm_r5_IEs,rb_InformationReconfigList)) ||
            (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, 
             rrc_CellUpdateConfirm_r5_IEs,rb_InformationAffectedList)) )
          )
  {
    resp_msg = RRCCU_RBRC_COMPLETE_RESP_MSG;
  }
  else if (!(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr,
            rrc_CellUpdateConfirm_r5_IEs,rb_InformationReleaseList)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, 
            rrc_CellUpdateConfirm_r5_IEs,rb_InformationReconfigList)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, 
            rrc_CellUpdateConfirm_r5_IEs,rb_InformationAffectedList)) &&
           ( (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, 
             rrc_CellUpdateConfirm_r5_IEs,ul_CommonTransChInfo)) ||
             (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, 
             rrc_CellUpdateConfirm_r5_IEs,ul_deletedTransChInfoList)) ||
             (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, 
             rrc_CellUpdateConfirm_r5_IEs,ul_AddReconfTransChInfoList)) ||
             (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr,            
             rrc_CellUpdateConfirm_r5_IEs,dl_CommonTransChInfo))||
             (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr,       
             rrc_CellUpdateConfirm_r5_IEs,dl_DeletedTransChInfoList)) ||
             (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr,   
             rrc_CellUpdateConfirm_r5_IEs,dl_AddReconfTransChInfoList)) )
          )
  {
    resp_msg = RRCCU_TCR_COMPLETE_RESP_MSG;
  }
  else if (!(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr,
            rrc_CellUpdateConfirm_r5_IEs,rb_InformationReleaseList)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, 
            rrc_CellUpdateConfirm_r5_IEs,rb_InformationReconfigList)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, 
            rrc_CellUpdateConfirm_r5_IEs,rb_InformationAffectedList)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, 
             rrc_CellUpdateConfirm_r5_IEs,ul_CommonTransChInfo)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, 
             rrc_CellUpdateConfirm_r5_IEs,ul_deletedTransChInfoList)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, 
             rrc_CellUpdateConfirm_r5_IEs,ul_AddReconfTransChInfoList)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr,            
             rrc_CellUpdateConfirm_r5_IEs,dl_CommonTransChInfo))&&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr,       
             rrc_CellUpdateConfirm_r5_IEs,dl_DeletedTransChInfoList)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr,   
             rrc_CellUpdateConfirm_r5_IEs,dl_AddReconfTransChInfoList)) &&
           ( (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, 
             rrc_CellUpdateConfirm_r5_IEs,ul_ChannelRequirement)) ||
             (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr,
             rrc_CellUpdateConfirm_r5_IEs,dl_CommonInformation)) ||
             (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr,
             rrc_CellUpdateConfirm_r5_IEs,dl_InformationPerRL_List)) ||
             (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr,
             rrc_CellUpdateConfirm_r5_IEs,frequencyInfo)) ||
             (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr,
             rrc_CellUpdateConfirm_r5_IEs,maxAllowedUL_TX_Power)))
          )
  {
    resp_msg = RRCCU_PCR_COMPLETE_RESP_MSG;
  }
  else if (!(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr,
            rrc_CellUpdateConfirm_r5_IEs,rb_InformationReleaseList)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, 
            rrc_CellUpdateConfirm_r5_IEs,rb_InformationReconfigList)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, 
            rrc_CellUpdateConfirm_r5_IEs,rb_InformationAffectedList)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, 
             rrc_CellUpdateConfirm_r5_IEs,ul_CommonTransChInfo)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, 
             rrc_CellUpdateConfirm_r5_IEs,ul_deletedTransChInfoList)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, 
             rrc_CellUpdateConfirm_r5_IEs,ul_AddReconfTransChInfoList)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr,            
             rrc_CellUpdateConfirm_r5_IEs,dl_CommonTransChInfo))&&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr,       
             rrc_CellUpdateConfirm_r5_IEs,dl_DeletedTransChInfoList)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr,   
             rrc_CellUpdateConfirm_r5_IEs,dl_AddReconfTransChInfoList)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, 
             rrc_CellUpdateConfirm_r5_IEs,ul_ChannelRequirement)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr,
             rrc_CellUpdateConfirm_r5_IEs,dl_CommonInformation)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr,
             rrc_CellUpdateConfirm_r5_IEs,dl_InformationPerRL_List)) &&
           !  (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr,
             rrc_CellUpdateConfirm_r5_IEs,frequencyInfo)) &&
           ( (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr,
             rrc_CellUpdateConfirm_r5_IEs,cn_InformationInfo)) ||
             (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr,
             rrc_CellUpdateConfirm_r5_IEs,cipheringModeInfo)) ||
             (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr,
             rrc_CellUpdateConfirm_r5_IEs,integrityProtectionModeInfo))||
             (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, 
             rrc_CellUpdateConfirm_r5_IEs,new_U_RNTI)) ||
             (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, 
             rrc_CellUpdateConfirm_r5_IEs,new_C_RNTI)) )
          )
  {
    resp_msg = RRCCU_UMIC_COMPLETE_RESP_MSG;
  }
  else if (!(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr,
            rrc_CellUpdateConfirm_r5_IEs,rb_InformationReleaseList)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, 
            rrc_CellUpdateConfirm_r5_IEs,rb_InformationReconfigList)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, 
            rrc_CellUpdateConfirm_r5_IEs,rb_InformationAffectedList)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, 
             rrc_CellUpdateConfirm_r5_IEs,ul_CommonTransChInfo)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, 
             rrc_CellUpdateConfirm_r5_IEs,ul_deletedTransChInfoList)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, 
             rrc_CellUpdateConfirm_r5_IEs,ul_AddReconfTransChInfoList)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr,            
             rrc_CellUpdateConfirm_r5_IEs,dl_CommonTransChInfo))&&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr,       
             rrc_CellUpdateConfirm_r5_IEs,dl_DeletedTransChInfoList)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr,   
             rrc_CellUpdateConfirm_r5_IEs,dl_AddReconfTransChInfoList)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, 
             rrc_CellUpdateConfirm_r5_IEs,ul_ChannelRequirement)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr,
             rrc_CellUpdateConfirm_r5_IEs,dl_CommonInformation)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr,
             rrc_CellUpdateConfirm_r5_IEs,dl_InformationPerRL_List)) &&
           !  (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr,
             rrc_CellUpdateConfirm_r5_IEs,frequencyInfo)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr,
             rrc_CellUpdateConfirm_r5_IEs,cn_InformationInfo)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr,
             rrc_CellUpdateConfirm_r5_IEs,cipheringModeInfo)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr,
             rrc_CellUpdateConfirm_r5_IEs,integrityProtectionModeInfo)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, 
             rrc_CellUpdateConfirm_r5_IEs,new_U_RNTI)) &&
           !(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, 
             rrc_CellUpdateConfirm_r5_IEs,new_C_RNTI))
          )
  {
    resp_msg = RRCCU_NO_RESP_MSG;
  }

  return resp_msg;

} /*  rrccu_find_response_to_cell_update_confirm_r5 */




/*===========================================================================

FUNCTION RRCCU_RESPONSE_TO_CELL_UPDATE_CONFIRM_R6

DESCRIPTION
  This function evaluates CELL UPDATE CONFIRM message and decides what
  response message has to be sent
  Cell Update message.
  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
static rrccu_resp_msg_e_type rrccu_find_response_to_cell_update_confirm_r6
(
  rrc_CellUpdateConfirm_r6_IEs *cucnf_ptr
)
{
  rrccu_resp_msg_e_type resp_msg= RRCCU_NO_RESP_MSG;

  if(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,rb_InformationReleaseList))
  {
    resp_msg = RRCCU_RBR_COMPLETE_RESP_MSG;
  }
  else if (!(RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr,
             rrc_CellUpdateConfirm_r6_IEs,rb_InformationReleaseList)) &&
          ((RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, 
           rrc_CellUpdateConfirm_r6_IEs,rb_InformationReconfigList)) ||
            (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr,rrc_CellUpdateConfirm_r6_IEs,rb_InformationAffectedList)
           )
          
         ))
  {
    resp_msg = RRCCU_RBRC_COMPLETE_RESP_MSG;
  }
  else if (!((RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr,
            rrc_CellUpdateConfirm_r6_IEs,rb_InformationReleaseList)) ||
            ((RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr,rrc_CellUpdateConfirm_r6_IEs,rb_InformationReconfigList)) ||
            ((RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr,rrc_CellUpdateConfirm_r6_IEs,rb_InformationAffectedList))))) &&
          ( (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, 
             rrc_CellUpdateConfirm_r6_IEs,ul_CommonTransChInfo)) ||
              (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,ul_deletedTransChInfoList)) ||
              (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,ul_AddReconfTransChInfoList)) ||
              (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,dl_CommonTransChInfo)) ||
              (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,dl_DeletedTransChInfoList)) ||
              (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,dl_AddReconfTransChInfoList)))
          )
  {
    resp_msg = RRCCU_TCR_COMPLETE_RESP_MSG;
  }
  else if (!((RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr,
            rrc_CellUpdateConfirm_r6_IEs,rb_InformationReleaseList)) ||
             (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,rb_InformationReconfigList)) ||
             (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,rb_InformationAffectedList)) ||
              (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,ul_CommonTransChInfo)) ||
              (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,ul_deletedTransChInfoList)) ||
              (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,ul_AddReconfTransChInfoList)) ||
              (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,dl_CommonTransChInfo)) ||
              (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,dl_DeletedTransChInfoList)) ||
              (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,dl_AddReconfTransChInfoList))) &&
           ((RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, 
             rrc_CellUpdateConfirm_r6_IEs,ul_DPCH_Info)) ||
               (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,dl_CommonInformation)) ||
               (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,dl_InformationPerRL_List)) ||
               (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,frequencyInfo)) ||
               (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,ul_EDCH_Information)) ||
               (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,dl_HSPDSCH_Information))||
               (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,maxAllowedUL_TX_Power)))
          )
  {
    resp_msg = RRCCU_PCR_COMPLETE_RESP_MSG;
  }
  else if (!((RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr,
            rrc_CellUpdateConfirm_r6_IEs,rb_InformationReleaseList)) ||
             (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,rb_InformationReconfigList)) ||
             (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,rb_InformationAffectedList)) ||
              (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,ul_CommonTransChInfo)) ||
              (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,ul_deletedTransChInfoList)) ||
              (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,ul_AddReconfTransChInfoList)) ||
              (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,dl_CommonTransChInfo)) ||
              (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,dl_DeletedTransChInfoList)) ||
              (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,dl_AddReconfTransChInfoList)) ||
              (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,ul_DPCH_Info)) ||
              (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,dl_CommonInformation)) ||
              (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,dl_InformationPerRL_List)) ||
              (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,frequencyInfo)) ||
               (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,ul_EDCH_Information)) ||
               (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,dl_HSPDSCH_Information))) &&
            ((RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr,
             rrc_CellUpdateConfirm_r6_IEs,cn_InformationInfo)) ||
              (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,cipheringModeInfo)) ||
              (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,integrityProtectionModeInfo)) ||
              (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,new_U_RNTI)) ||
              (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,new_C_RNTI)))
          )
  {
    resp_msg = RRCCU_UMIC_COMPLETE_RESP_MSG;
  }
  else if (!((RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr,
           rrc_CellUpdateConfirm_r6_IEs,rb_InformationReleaseList)) ||
             (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,rb_InformationReconfigList)) ||
             (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,rb_InformationAffectedList)) ||
              (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,ul_CommonTransChInfo)) ||
              (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,ul_deletedTransChInfoList)) ||
              (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,ul_AddReconfTransChInfoList)) ||
              (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,dl_CommonTransChInfo)) ||
              (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,dl_DeletedTransChInfoList)) ||
              (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,dl_AddReconfTransChInfoList)) ||
              (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,ul_DPCH_Info)) ||
              (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,dl_CommonInformation)) ||
              (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,dl_InformationPerRL_List)) ||
              (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,frequencyInfo)) ||
              (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,ul_EDCH_Information)) ||
              (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,dl_HSPDSCH_Information)) ||
              (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,cn_InformationInfo)) ||
              (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,cipheringModeInfo)) ||
              (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,integrityProtectionModeInfo)) ||
              (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,new_U_RNTI)) ||
              (RRC_MSG_COMMON_BITMASK_IE_PTR(cucnf_ptr, rrc_CellUpdateConfirm_r6_IEs,new_C_RNTI)))
          )
  {
    resp_msg = RRCCU_NO_RESP_MSG;
  }

  return resp_msg;
} /*  rrccu_find_response_to_cell_update_confirm_r6 */

/*===========================================================================

FUNCTION   rrccu_check_and_get_primary_plmn_id

DESCRIPTION

  This function will check whether primary plmn id is present 
  in r3,r5 path of CU comfirmation message CCCH/DCCH. If present 
  then it will return primary plmn id.
        
DEPENDENCIES
  None.

RETURN VALUE
TRUE : IF Primary PLMN I.D is present in CU comfirmation message in r3,r5 path
FFALSE: Otherwise

SIDE EFFECTS

  None.

===========================================================================*/
static boolean rrccu_check_and_get_primary_plmn_id
(
  /* Pointer to the CU comfirmation message DCCH message */
  rrc_CellUpdateConfirm *dcch_msg_ptr,
  /* Pointer to the CU comfirmation message CCCH message */
  rrc_CellUpdateConfirm_CCCH *ccch_msg_ptr,
  /*This will copy primary plmn i.d if present in OTA msg*/
  rrc_PLMN_Identity *primary_plmn_Identity,
  /* Downlink SDU type */
  uint32 dl_sdu_type,
  /*This will indicate OTA msg version*/
  rrc_msg_ver_enum_type msg_version
)
{
  boolean primary_plmn_Id_present = FALSE;

  if ( dl_sdu_type == rrc_DL_CCCH_Message_PDU)
  {
    if(ccch_msg_ptr == NULL)
    {
      /*msg ptr is NULL so return from here*/
      return FALSE;
    }
    switch(msg_version)
    {
      case MSG_REL99:
        /*Check to see if primary PLMN I.D is present in CU comfirmation CCCH 
         *message ext CU comfirmation-v690ext which is present in 
         * v690NonCriticalExtensions in r99 path
         */
        if((ccch_msg_ptr->u.r3.m.laterNonCriticalExtensionsPresent)&&
           (ccch_msg_ptr->u.r3.laterNonCriticalExtensions.m.v4b0NonCriticalExtensionsPresent)&&
           (ccch_msg_ptr->u.r3.laterNonCriticalExtensions.v4b0NonCriticalExtensions.m.v590NonCriticalExtensionsPresent)&&
           (ccch_msg_ptr->u.r3.laterNonCriticalExtensions.v4b0NonCriticalExtensions.v590NonCriticalExtensions.m.
           v5d0NonCriticalExtenstionsPresent)&&
           (ccch_msg_ptr->u.r3.laterNonCriticalExtensions.v4b0NonCriticalExtensions.v590NonCriticalExtensions.
           v5d0NonCriticalExtenstions.m.v690NonCriticalExtensionsPresent)&&
           (ccch_msg_ptr->u.r3.laterNonCriticalExtensions.v4b0NonCriticalExtensions.v590NonCriticalExtensions.
            v5d0NonCriticalExtenstions.v690NonCriticalExtensions.cellUpdateConfirm_v690ext.m.primary_plmn_IdentityPresent)
          )
        {
          WRRC_MSG0_HIGH("NWS:cuc_ccch msg contains primary_plmn_Id in r99 path");
          primary_plmn_Id_present = TRUE;
                *primary_plmn_Identity = ccch_msg_ptr->u.r3.laterNonCriticalExtensions.v4b0NonCriticalExtensions.
              v590NonCriticalExtensions.v5d0NonCriticalExtenstions.v690NonCriticalExtensions.
              cellUpdateConfirm_v690ext.primary_plmn_Identity;
        }
        break;
        
      case MSG_REL5:
        /*Check to see if primary PLMN I.D is present in CU comfirmation message CCCH
         *ext CU comfirmation-v690ext which is present in 
         * v690NonCriticalExtensions in r5 path
         */
       if((ccch_msg_ptr->u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r5.m.v5d0NonCriticalExtenstionsPresent)&&
            (ccch_msg_ptr->u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r5.
            v5d0NonCriticalExtenstions.m.v690NonCriticalExtensionsPresent)&&
            (ccch_msg_ptr->u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r5.v5d0NonCriticalExtenstions.
              v690NonCriticalExtensions.cellUpdateConfirm_v690ext.m.primary_plmn_IdentityPresent)
          )
        {
          WRRC_MSG0_HIGH("NWS:CUC_ccch msg contains primary_plmn_Id in r5 path");
          primary_plmn_Id_present = TRUE;
          *primary_plmn_Identity = ccch_msg_ptr->u.later_than_r3.criticalExtensions.u.
                      criticalExtensions.u.r5.v5d0NonCriticalExtenstions.v690NonCriticalExtensions.
                      cellUpdateConfirm_v690ext.primary_plmn_Identity;
        }
        break;
  
      default:
        WRRC_MSG1_ERROR("NWS: Msg version = %d, Not supported",msg_version);
        break;
    }
  }
  else if( dl_sdu_type == rrc_DL_DCCH_Message_PDU)
  {
    if(dcch_msg_ptr == NULL)
    {
      /*msg ptr is NULL so return from here*/
      return FALSE;
    }
    switch(msg_version)
    {
      case MSG_REL99:
      /*Check to see if primary PLMN I.D is present in CU update comfirmation DCCH 
       *message ext CU comfirmation-v690ext which is present in 
       * v690NonCriticalExtensions in r99 path
       */
        if((dcch_msg_ptr->u.r3.m.v3a0NonCriticalExtensionsPresent)&&
            (dcch_msg_ptr->u.r3.v3a0NonCriticalExtensions.m.laterNonCriticalExtensionsPresent)&&
            (dcch_msg_ptr->u.r3.v3a0NonCriticalExtensions.laterNonCriticalExtensions.m.v4b0NonCriticalExtensionsPresent)&&
            (dcch_msg_ptr->u.r3.v3a0NonCriticalExtensions.laterNonCriticalExtensions.
            v4b0NonCriticalExtensions.m.v590NonCriticalExtenstionsPresent)&&
            (dcch_msg_ptr->u.r3.v3a0NonCriticalExtensions.laterNonCriticalExtensions.
            v4b0NonCriticalExtensions.v590NonCriticalExtenstions.m.v5d0NonCriticalExtenstionsPresent)&&
            (dcch_msg_ptr->u.r3.v3a0NonCriticalExtensions.laterNonCriticalExtensions.
            v4b0NonCriticalExtensions.v590NonCriticalExtenstions.v5d0NonCriticalExtenstions.m.
            v690NonCriticalExtensionsPresent)&&
            (dcch_msg_ptr->u.r3.v3a0NonCriticalExtensions.laterNonCriticalExtensions.
            v4b0NonCriticalExtensions.v590NonCriticalExtenstions.v5d0NonCriticalExtenstions.
            v690NonCriticalExtensions.cellUpdateConfirm_v690ext.m.primary_plmn_IdentityPresent)
          )
        {
          WRRC_MSG0_HIGH("NWS:CUC_dcch msg contains primary_plmn_Id in r99 path");
          primary_plmn_Id_present = TRUE;
                *primary_plmn_Identity = dcch_msg_ptr->u.r3.v3a0NonCriticalExtensions.laterNonCriticalExtensions.
              v4b0NonCriticalExtensions.v590NonCriticalExtenstions.v5d0NonCriticalExtenstions.
              v690NonCriticalExtensions.cellUpdateConfirm_v690ext.primary_plmn_Identity;
        }
        break;
        
      case MSG_REL5:
        /*Check to see if primary PLMN I.D is present in CU comfirmation DCCH 
         *message ext CU comfirmation-v690ext which is present in 
         * v690NonCriticalExtensions in r5 path
         */
        if((dcch_msg_ptr->u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r5.m.v5d0NonCriticalExtenstionsPresent)&&
           (dcch_msg_ptr->u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r5.v5d0NonCriticalExtenstions.m.
           v690NonCriticalExtensionsPresent)&&
           (dcch_msg_ptr->u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r5.v5d0NonCriticalExtenstions.
             v690NonCriticalExtensions.cellUpdateConfirm_v690ext.m.primary_plmn_IdentityPresent)
          )
        {
          WRRC_MSG0_HIGH("NWS:CUC_dcch msg contains primary_plmn_Id in r5 path");
          primary_plmn_Id_present = TRUE;
          *primary_plmn_Identity = dcch_msg_ptr->u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r5.v5d0NonCriticalExtenstions.
             v690NonCriticalExtensions.cellUpdateConfirm_v690ext.primary_plmn_Identity;
        }
        break;
   
      default:
        WRRC_MSG1_ERROR("NWS: Msg version = %d, Not supported",msg_version);
        break;
    }
  }
  else
  {
    WRRC_MSG1_ERROR("NWS: Wrong SDU type = %d, Not supported",dl_sdu_type);
  }
  
  return primary_plmn_Id_present;
}
/*===========================================================================

FUNCTION rrccu_validate_rel_rb_exist_in_reconfig_list

DESCRIPTION
  This function checks if the Cu Cnf has the same RB ID in the RB Release list
   and also in RB Reconfig/RB Affected List
  
DEPENDENCIES
  None

RETURN VALUE
  True, if same RB ID is present in RB Release list and also in RB Reconfig/RB Affected List
  else
  FALSE
  
SIDE EFFECTS

  None

===========================================================================*/
static boolean rrccu_validate_rel_rb_exist_in_reconfig_list
(
  rrc_CellUpdateConfirm_r3_IEs * cell_update_confirm
)
{
  rrc_RB_Identity released_rb_id= 0xFF;
  rrc_RB_InformationReleaseList *rrc_rb_information_release_list;
                                            /* Local pointer to preserve the
                                               head of linked list */  
  rrc_RB_InformationReconfig *rrc_rb_information_reconfig_ptr; 
  
  rrc_RB_InformationAffected *rrc_rb_information_affected_ptr; 
  uint32 idx=0,idy=0;
  /* Save the linked list head pointer */ 
  rrc_rb_information_release_list = 
    &cell_update_confirm->rb_InformationReleaseList;
  
  while(rrc_rb_information_release_list->n > idx)
  { 
  
    released_rb_id =rrc_rb_information_release_list->elem[idx];
    if(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm,
             rrc_CellUpdateConfirm_r3_IEs,rb_InformationReconfigList))
    {
      idy=0;
      do
      { 
       
        /* Save the linked list head pointer */
        rrc_rb_information_reconfig_ptr = 
          &cell_update_confirm->rb_InformationReconfigList.elem[idy];
          /* Check whether rb id in rb reconfig list is in the established rabs list.  If not set msg_not_valid variable
             to true to resend cell update msg with failure cause  */
        if (rrc_rb_information_reconfig_ptr->rb_Identity == released_rb_id  )
        {
          /* RB Message was invalid. */
          WRRC_MSG1_ERROR(" RB id:%d in rb_InformationReconfigList  and RB Release list of CUCnf Msg",
             rrc_rb_information_reconfig_ptr->rb_Identity );
          return TRUE;
        }
                 
        /* Advance the Linked List pointer */
        idy++;
      }while(cell_update_confirm->rb_InformationReconfigList.n > idy);
    }
  
    if( RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm,
        rrc_CellUpdateConfirm_r3_IEs,rb_InformationAffectedList))
    {
      idy=0;

      do
      { 
            /* Save the head pointer of linked list */
        rrc_rb_information_affected_ptr = 
         &cell_update_confirm->rb_InformationAffectedList.elem[idy];
        /* Check whether rb id in rb affected list is in the established rabs list.  If not set msg_not_valid variable
               to true to resend cell update msg with failure cause  */
        if (rrc_rb_information_affected_ptr->rb_Identity == released_rb_id )
        {
          /* RB Message was invalid. */
          WRRC_MSG1_ERROR(" RB id:%d in rb_InformationAffectedList  and RB Release list of CUCnf Msg",
             rrc_rb_information_affected_ptr->rb_Identity );
          return TRUE;
        }
        /* Advance the Linked List pointer */
        idy++;
        
      }while(cell_update_confirm->rb_InformationAffectedList.n > idy);
    }
        
    idx++;
  } 

  return FALSE;
}

/*==========================================================
FUNCTION  : rrccu_check_if_rbid_present_in_rrccu_rb_release_info

DESCRIPTION : This function checks if the RB-Id specified 
              is already present in rrccu_rb_release_info within the index specified.

DEPENDENCIES: None.

RETURN VALUE: 
uint8:   It returns the index at which 
         the RB-Id is present in rrccu_rb_release_info else returns 
         MAX_RB.

SIDE EFFECTS: None
============================================================*/
static uint8 rrccu_check_if_rbid_present_in_rrccu_rb_release_info
(
  rrc_RB_Identity rb_id,
  uint8 count
)
{
  uint8 j;
   
  for(j=0;j<count;j++)
  {
    if(rrccu_rb_release_info.rb_id[j] == rb_id )
    {
      WRRC_MSG2_ERROR( "rb_id %d found in rrccu_rb_release_info at index %d",rb_id,j);
      return j;
    }
  }
  return MAX_RB;
}
/*===========================================================================

FUNCTION RRCCU_PROCESS_CELL_UPDATE_CONFIRM

DESCRIPTION
  This function processes CELL UPDATE CONFIRM message received in response to
  Cell Update message.
  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
void rrccu_process_cell_update_confirm
(    
  void *msg_ptr,                              /* Pointer to Downlink Msg */
  uint32 dl_sdu_type                          /* Downlink SDU type */
)
{
  rrc_cmd_type *cmd_ptr;                      /* Pointer to the RRC Command */
  rrc_cmd_type *int_cmd_ptr;                      /* Pointer to the RRC Command */
  uint32 no_of_RBs;                           /* Local variable to store no
                                                of RBs */
  boolean msg_not_valid      = FALSE;         /* boolean to indicate msg validity */
  rrc_int_c_rnti_type crnti;                  /* Local variable for C-RNTI */
  rrc_int_u_rnti_type urnti;                  /* Local variable for U-RNTI */
  rrc_CellUpdateConfirm_r3_IEs *cell_update_confirm = NULL;
   
  rrc_DL_CCCH_Message *ccch_msg_ptr;          /* Pointer to Downlink CCCH Msg */
  rrc_DL_DCCH_Message *dcch_msg_ptr;          /* Pointer to Downlink DCCH Msg */
 
  rrc_state_e_type state ;                    /* Local varible to store state */

  rrcllc_oc_status_e_type status;             /* Local var to store Ordered Config
                                                 status */
  rrc_RB_InformationReleaseList *rrc_rb_information_release_list;
                                              /* Local pointer to preserve the
                                                 head of linked list */  
  rrc_RB_InformationReconfig *rrc_rb_information_reconfig_ptr;
  uint32 rb_idx =0;											   

  rrc_RB_InformationAffectedList *rrc_rb_information_affected_list; 
  rlc_lc_id_type                          lc_id;
  uecomdef_logch_mode_e_type              lc_mode;
  rrcrb_directed_cell_info_type          directed_cell_info; /* directed cell info struct */
#ifdef FEATURE_UMTS_PDCP
  rrc_HeaderCompressionInfoList *pdcpHeaderCompressionInfoList = NULL;  
#endif /* FEATURE_UMTS_PDCP*/

   /*Boolean used to indicate primary plmn i.d is present in OTA msg*/
  boolean primary_plmn_Id_present = FALSE;
   /*Variable to hold primary plmn i.d if present in OTA msg*/
  rrc_PLMN_Identity primary_plmn_Identity;
   /*ptr for CUC OTA msg*/
  rrc_CellUpdateConfirm_CCCH *cuc_ccch_msg_ptr = NULL;
  rrc_CellUpdateConfirm *cuc_dcch_msg_ptr = NULL;

  if( dl_sdu_type == rrc_DL_CCCH_Message_PDU)
  {
    ccch_msg_ptr = (rrc_DL_CCCH_Message *) msg_ptr;
    if(ccch_msg_ptr->message.u.cellUpdateConfirm.t ==
       T_rrc_CellUpdateConfirm_CCCH_later_than_r3 )
    {
      WRRC_MSG0_ERROR("Critical Extensions are not supported");
      /* Update the failure cause */
      rrccu_failure_cause.rrc_TransactionIdentifier = 
        ccch_msg_ptr->message.u.cellUpdateConfirm.u.later_than_r3.rrc_TransactionIdentifier;
      rrccu_failure_cause.failureCause.t = T_rrc_FailureCauseWithProtErr_protocolError;
      rrccu_failure_cause.failureCause.u.protocolError = rtxMemAllocTypeZ (&enc_ctxt, rrc_ProtocolErrorInformation);
      
      rrccu_failure_cause.failureCause.u.protocolError->diagnosticsType.t = 
        T_rrc_ProtocolErrorInformation_diagnosticsType_type1;
      rrccu_failure_cause.failureCause.u.protocolError->diagnosticsType.u.type1 = 
        rtxMemAllocTypeZ (&enc_ctxt, rrc_ProtocolErrorInformation_type1);

      rrccu_failure_cause.failureCause.u.protocolError->
        diagnosticsType.u.type1->protocolErrorCause = 
        rrc_ProtocolErrorCause_messageExtensionNotComprehended;
      
      /* Resend the CELL UPDATE with Failure cause */
      rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
      return;
    }
    cell_update_confirm = &ccch_msg_ptr->message.u.cellUpdateConfirm.u.
                           r3.cellUpdateConfirm_r3;
    cuc_ccch_msg_ptr = &ccch_msg_ptr->message.u.cellUpdateConfirm;
  }
  else if( dl_sdu_type == rrc_DL_DCCH_Message_PDU)
  {
    dcch_msg_ptr = (rrc_DL_DCCH_Message *) msg_ptr;
    if(dcch_msg_ptr->message.u.cellUpdateConfirm.t ==
       T_rrc_CellUpdateConfirm_later_than_r3 )
    {
      WRRC_MSG0_ERROR("Critical Extensions are not supported");
      /* Update the failure cause */
      rrccu_failure_cause.rrc_TransactionIdentifier = 
        dcch_msg_ptr->message.u.cellUpdateConfirm.u.later_than_r3.rrc_TransactionIdentifier;
      rrccu_failure_cause.failureCause.t = T_rrc_FailureCauseWithProtErr_protocolError;
      rrccu_failure_cause.failureCause.u.protocolError = rtxMemAllocTypeZ (&enc_ctxt, rrc_ProtocolErrorInformation);
      
      rrccu_failure_cause.failureCause.u.protocolError->diagnosticsType.t = 
        T_rrc_ProtocolErrorInformation_diagnosticsType_type1;
      rrccu_failure_cause.failureCause.u.protocolError->diagnosticsType.u.type1 = 
        rtxMemAllocTypeZ (&enc_ctxt, rrc_ProtocolErrorInformation_type1);

      rrccu_failure_cause.failureCause.u.protocolError->
        diagnosticsType.u.type1->protocolErrorCause = 
        rrc_ProtocolErrorCause_messageExtensionNotComprehended;

      /* Resend the CELL UPDATE with Failure cause */
      rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
      return;
    }
                  
    cell_update_confirm = &dcch_msg_ptr->message.u.cellUpdateConfirm.u.
                          r3.cellUpdateConfirm_r3;

     cuc_dcch_msg_ptr = &dcch_msg_ptr->message.u.cellUpdateConfirm;

  }
  else
  {
    ERR_FATAL("Invalid SDU type",0,0,0);
  }
  /*if(cell_update_confirm == NULL)
  {
    ERR_FATAL("Null Pointer passed",0,0,0);
    return;
  }*/
  
  /*If this is a CU confirm DCCH/CCCH msg then check to see if primary 
    PLMN I.D is present from DCCH/CCCH msg ptr*/
  primary_plmn_Id_present = rrccu_check_and_get_primary_plmn_id(cuc_dcch_msg_ptr,
                                                                cuc_ccch_msg_ptr,
                                                                &primary_plmn_Identity,
                                                                dl_sdu_type,
                                                                MSG_REL99);
  
  /*phase-1 rl failure limitations */
  /* enter idle if both timers are marked as expired */
  if ((rrccu_rl_failure_info.t314_info.timer_status == RE_EST_TIMER_EXPIRED) &&
      (rrccu_rl_failure_info.t315_info.timer_status == RE_EST_TIMER_EXPIRED))
  {
    /* Since both T314 and T315 are expired, bring down RRC Connection */
      rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                           RRC_TX_TO_DISCON_OTHER);
      /* Update the release cause */
      rrc_release_cause = RRC_REL_DEEP_FADE;
      rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
      WRRC_MSG0_HIGH("RRC Conn Released since T314=0 & T315=0");
    return;
  }

  /* Update state Indicator */   
  rrccu_state_indicator = cell_update_confirm->rrc_StateIndicator;

  /* Update Transaction id */
  rrccu_trans_id = cell_update_confirm->rrc_TransactionIdentifier;

  /* check whether new CRNTI is present in the message or not when there is
  no valid C-RNTI is existing and next state indicated by the message is 
  CELL_FACH */
/*If cell supports HS-RACH then configure the E-RNTI and H-RNTI not given in CUCNF initiate the CU again*/

  if ((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_FACH) ||
     (((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH) || (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH)) &&
     (RRCCU_NO_RESP_MSG != rrccu_find_response_to_cell_update_confirm (msg_ptr, dl_sdu_type))))
  {
    if ((C_RNTI_NOT_VALID == rrcllc_get_current_crnti_status()) &&
        ((RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, rrc_CellUpdateConfirm_r3_IEs,new_C_RNTI)) == 0))
    {
      if(((rrcllc_get_toc_usage() == TOC_FOR_OOS)
              || (rrcllc_get_toc_usage() == TOC_FOR_OOS_WITHOUT_DCH_INFO)
              || (rrcllc_get_toc_usage() == TOC_FOR_OOS_WITH_DCH_INFO)

      ) && 
         (rrcrb_get_new_crnti_valid() && rrccsp_is_selected_cell_utran_directed()))
      {
        WRRC_MSG0_HIGH("Crnti present in reconfig msg");
      }
      else
      {

        WRRC_MSG1_ERROR("No CRNTI for next_st:%d", rrccu_state_indicator);
        /* Update the cause to re-selection as the Cell upate cause should
              indicate re-selection in case of No CRNTI
              */
        rrccu_cell_update_cause = rrc_CellUpdateCause_cellReselection;		
        rrc_cu_uu_log_event_failure_cause = RRC_CU_UU_INVALID_CONFIG;
        rrccu_resend_cell_update_msg(RRCCU_NOT_INCLUDE_FAILURE_CAUSE);
        /* continue with rrccu state  RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM */
        return;
      }
    }
  }

#ifdef FEATURE_WCDMA_HS_FACH
  /*RNTI validation for HS-FACH and HS-RACH*/
  if(TRUE == rrccu_check_rnti_for_resending_cu(FALSE, FALSE, MSG_REL99, 
  rrccu_find_response_to_cell_update_confirm(cell_update_confirm,dl_sdu_type)))
  {
    rrccu_cell_update_cause = rrc_CellUpdateCause_cellReselection;
    rrc_cu_uu_log_event_failure_cause = RRC_CU_UU_INVALID_CONFIG;
    rrccu_resend_cell_update_msg(RRCCU_NOT_INCLUDE_FAILURE_CAUSE);
    return;
  }
#endif

  if ((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH) ||
      (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH))
  {
    if (!(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
          rrc_CellUpdateConfirm_r3_IEs,utran_DRX_CycleLengthCoeff)))
    {
      WRRC_MSG0_ERROR("UTRAN DRX is not present");
      
      /* set the invalid msg flag */
      msg_not_valid = TRUE;

    }
    else
    {
      /* store it in a variable */
      rrccu_utran_drx_coef = cell_update_confirm->utran_DRX_CycleLengthCoeff;
    }
       /*resend the cell update message if there is any invalid config*/
    if  (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH)
    {
      if (!(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
            rrc_CellUpdateConfirm_r3_IEs,ura_Identity)))
      {
        WRRC_MSG0_HIGH("URA-id is not present");
        rrccu_clear_ura_id();
      }
      /* update rrccu procedure with new URA-id */
      else
      {
        /*URA ID present in the message set ura_identity variable with this value */
        if (cell_update_confirm->ura_Identity.numbits == 16)
        {
          /*rrccu_translate_ura_id (&(msg_ptr->u.r3.radioBearerReconfiguration_r3.ura_Identity));*/
          rrccu_update_ura_id (&(cell_update_confirm->ura_Identity));
        }
        else
        {
          WRRC_MSG1_ERROR("Invalid URA ID length%d",
              cell_update_confirm->ura_Identity.numbits);
          /* set the invalid msg flag */
          msg_not_valid = TRUE;
        }
      }
        
    }
  }

  /*  If next state is DCH, check if DCH info is present.  Else resend cell update
      and remap CU cause to RRC_RADIO_LINK_FAILURE */
  if (rrccu_state_indicator == rrc_RRC_StateIndicator_cell_DCH)
  {
    
    if (!(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
          rrc_CellUpdateConfirm_r3_IEs,dl_CommonInformation)))
    {
      WRRC_MSG0_ERROR("DL Common Info is not present");
      /* remap the cu cause based on the priority */
      rrccu_cell_update_cause = 
        rrccu_map_cu_cause_based_on_priority (RRC_RADIO_LINK_FAILURE);
      rrc_cu_uu_log_event_failure_cause = RRC_CU_UU_INVALID_CONFIG;
      rrccu_resend_cell_update_msg(RRCCU_NOT_INCLUDE_FAILURE_CAUSE);
      return;
    }
    if (!(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
               rrc_CellUpdateConfirm_r3_IEs,dl_InformationPerRL_List)))
    {
      WRRC_MSG0_ERROR("DL info per RL List is not present");
      /* remap the cu cause based on the priority */
      rrccu_cell_update_cause = 
        rrccu_map_cu_cause_based_on_priority (RRC_RADIO_LINK_FAILURE);
      rrc_cu_uu_log_event_failure_cause = RRC_CU_UU_INVALID_CONFIG;
      rrccu_resend_cell_update_msg(RRCCU_NOT_INCLUDE_FAILURE_CAUSE);      
      return;
    }
  }

    
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, rrc_CellUpdateConfirm_r3_IEs,rb_InformationReconfigList))
  {
    rb_idx=0;
    do
    { 
         /* Save the linked list head pointer */
      rrc_rb_information_reconfig_ptr = 
      &cell_update_confirm->rb_InformationReconfigList.elem[rb_idx];
      /* Check whether rb id in rb reconfig list is in the established rabs list.  If not set msg_not_valid variable
         to true to resend cell update msg with failure cause  */
      if (RRC_RB_NOT_PRESENT == validate_rb_id_in_reconfig_list(rrc_rb_information_reconfig_ptr->rb_Identity))
      {
        /* RB Message was invalid. */
        WRRC_MSG1_HIGH("Invalid RB id:%d in rb_InformationReconfigList of CUCnf Msg",rrc_rb_information_reconfig_ptr->rb_Identity );
        msg_not_valid = TRUE;
        break;
      }

      if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_rb_information_reconfig_ptr, rrc_RB_InformationReconfig,rb_StopContinue))
      {
        if (rrc_rb_information_reconfig_ptr->rb_Identity <= 2)
        {
          msg_not_valid = TRUE;
          break;
        }
        
        lc_id = rrclcm_get_ul_rlc_lc_id(rrc_rb_information_reconfig_ptr->rb_Identity);
        
        if (lc_id == RRCLCM_RLC_LC_ID_NOT_FOUND)
        {
          msg_not_valid = TRUE;
          WRRC_MSG1_ERROR("No corresponding LC id for the RB %d",rrc_rb_information_reconfig_ptr->rb_Identity);
          break;
        }
        else if (rrclcm_get_ul_rlc_mode(lc_id, &lc_mode) == RRCLCM_FAILURE)
        {
          msg_not_valid = TRUE;
          WRRC_MSG1_ERROR("Invalid lc_mode for RB %d",rrc_rb_information_reconfig_ptr->rb_Identity);
          break;
        }
        else if (lc_mode == UE_MODE_TRANSPARENT)
        {
          msg_not_valid = TRUE;
          WRRC_MSG2_ERROR("Transparent mode RB %d lc_id %d can't be stopped/contd",(uint16)(rrc_rb_information_reconfig_ptr->rb_Identity),lc_id);
          break;
        }
      }
#ifdef FEATURE_UMTS_PDCP
      if (rrc_pdcp_enabled)  
      { 
        if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_rb_information_reconfig_ptr, rrc_RB_InformationReconfig,pdcp_Info)) 
        {
          if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_rb_information_reconfig_ptr, rrc_RB_InformationReconfig,pdcp_SN_Info)) 
          {
            msg_not_valid = TRUE;
            WRRC_MSG0_ERROR("Invalid: PDCP SN info shouldn't be in CU CNF");
            break;
          }
          
          /* Validate PDCP info */
          if (rrc_get_rab_type_for_given_rb_id(rrc_rb_information_reconfig_ptr->rb_Identity) !=
              RRCRB_PS_DATA_RAB)
          {
            WRRC_MSG1_HIGH("NW incld PDCP info for non-ps rb id %d: Invalid",
                     rrc_rb_information_reconfig_ptr->rb_Identity);
            msg_not_valid = TRUE;
            break;
          }
          
          if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_rb_information_reconfig_ptr, rrc_RB_InformationReconfig,pdcp_Info))
          {
            /* check whether lossless SRNS relocation flag is set or   
             * and header compression algo is present in the message 
             */
            if ((RRC_MSG_COMMON_BITMASK_IE(rrc_rb_information_reconfig_ptr->pdcp_Info.pdcp_Info,
                 rrc_PDCP_Info,losslessSRNS_RelocSupport)) && 
                (RRC_CHECK_COMMON_MSG_TYPE(rrc_rb_information_reconfig_ptr->pdcp_Info.pdcp_Info.losslessSRNS_RelocSupport,
                 rrc_LosslessSRNS_RelocSupport_supported)))
            {
              if (rrc_rb_information_reconfig_ptr->pdcp_Info.pdcp_Info.pdcp_PDU_Header == rrc_PDCP_PDU_Header_absent)
              {
                WRRC_MSG0_HIGH("PDCP pdu header is absent.  Invalid config");
                msg_not_valid = TRUE;
                break;
              }
              
            } /* if  rrc_PDCP_Info_losslessSRNS_RelocSupport_present*/
          }

          if (rrc_rb_information_reconfig_ptr->pdcp_Info.pdcp_Info.pdcp_PDU_Header == rrc_PDCP_PDU_Header_present) 
          {
            if ((RRC_MSG_COMMON_BITMASK_IE(rrc_rb_information_reconfig_ptr->pdcp_Info.pdcp_Info,
                 rrc_PDCP_Info_r4,losslessSRNS_RelocSupport)) && 
                (RRC_CHECK_COMMON_MSG_TYPE(rrc_rb_information_reconfig_ptr->pdcp_Info.pdcp_Info.losslessSRNS_RelocSupport,
                 rrc_LosslessSRNS_RelocSupport_notSupported)))
            {
              if (!(RRC_MSG_COMMON_BITMASK_IE(rrc_rb_information_reconfig_ptr->pdcp_Info.pdcp_Info,
                  rrc_PDCP_Info,headerCompressionInfoList)) )
              {
                WRRC_MSG0_HIGH("PDCP header compress info list not present");
                msg_not_valid = TRUE;
                break;
              }
            }
          }
          
          if (RRC_MSG_COMMON_BITMASK_IE(rrc_rb_information_reconfig_ptr->pdcp_Info.pdcp_Info,
              rrc_PDCP_Info,headerCompressionInfoList)) 
          {
            uint32 local_idx=0;
            pdcpHeaderCompressionInfoList = &rrc_rb_information_reconfig_ptr->pdcp_Info.pdcp_Info.headerCompressionInfoList;
            while (pdcpHeaderCompressionInfoList->n > local_idx) 
            {
              if (pdcpHeaderCompressionInfoList->elem[local_idx].algorithmSpecificInfo.t == 
                  T_rrc_AlgorithmSpecificInfo_rfc2507_Info)
              {
                        /* if the UE capability "Maximum header compression context space", is exceeded with this configuration send
                         * failure with cause "Invalid Config"
                 */
                if ((pdcpHeaderCompressionInfoList->elem[local_idx].algorithmSpecificInfo.u.rfc2507_Info->max_HEADER > IPHC_MAX_HC_CONTEXT_SPACE))
                {
                  WRRC_MSG1_HIGH("Max header comprss context space exceeded : %d",
                           pdcpHeaderCompressionInfoList->elem[local_idx].algorithmSpecificInfo.u.rfc2507_Info->max_HEADER);
                  msg_not_valid = TRUE;
                  break;
                }
              }
              local_idx++;
            } /*  while (pdcpHeaderCompressionInfoList) */
          } /*  if (rb_list_ptr->value.pdcp_Info.pdcp_Info.bit_mask & rrc_PDCP_Info_r4_headerCompressionInfoList)) */        
        }
      }
#endif /* FEATURE_UMTS_PDCP */

      /* Advance the Linked List pointer */
      rb_idx++;
    } while(cell_update_confirm->rb_InformationReconfigList.n > rb_idx) ;
  }
  
  
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, rrc_CellUpdateConfirm_r3_IEs,rb_InformationReleaseList))
  {
    /* Save the linked list head pointer */ 
    rrc_rb_information_release_list = 
      &cell_update_confirm->rb_InformationReleaseList;
    rb_idx=0;
    do
    { 
      /* Check whether rb id in rb release list is in the established rabs list.  If not set msg_not_valid variable
         to true to resend cell update msg with failure cause  */
      if (RRC_RB_NOT_PRESENT == validate_rb_id_in_release_list(rrc_rb_information_release_list->elem[rb_idx]))
      {
        /* RB Message was invalid. */
        WRRC_MSG1_HIGH("Invalid RB id:%d in rb_InformationReleaseList of CUCnf Msg",rrc_rb_information_release_list->elem[rb_idx] );
        msg_not_valid = TRUE;
        break;
      }      
      rb_idx++;
    } while(rrc_rb_information_release_list->n > rb_idx);
    
    
  }
  
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm,
     rrc_CellUpdateConfirm_r3_IEs,rb_InformationAffectedList))
  {
    /* Save the head pointer of linked list */
    rrc_rb_information_affected_list = 
      &cell_update_confirm->rb_InformationAffectedList;
	rb_idx=0;
    do
    { 
      /* Check whether rb id in rb affected list is in the established rabs list.  If not set msg_not_valid variable
      to true to resend cell update msg with failure cause  */
      if (RRC_RB_NOT_PRESENT == validate_rb_id_in_reconfig_list(rrc_rb_information_affected_list->elem[rb_idx].rb_Identity))
      {
        /* RB Message was invalid. */
        WRRC_MSG1_HIGH("Invalid RB id:%d in rb_InformationAffectedList of CUCnf Msg",rrc_rb_information_affected_list->elem[rb_idx].rb_Identity );
        msg_not_valid = TRUE;
        break;
      }
      /* Advance the Linked List pointer */
      rb_idx++;
      
    } while(rrc_rb_information_affected_list->n > rb_idx);
  }
  
  if((msg_not_valid == FALSE) && (RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm,
       rrc_CellUpdateConfirm_r3_IEs,rb_InformationReleaseList))
       && ((RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm,
                 rrc_CellUpdateConfirm_r3_IEs,rb_InformationReconfigList)) ||
           (RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm,
       rrc_CellUpdateConfirm_r3_IEs,rb_InformationAffectedList))   ))
  {
    msg_not_valid = rrccu_validate_rel_rb_exist_in_reconfig_list(cell_update_confirm);
  }
  
  if (msg_not_valid)
  {
    WRRC_MSG0_HIGH("Invalid Configurartion in CUCnf Msg.  Resending Cell Update");
    /* Set the Transaction Id */
    rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;

    /* Set Failure cause */
    rrccu_failure_cause.failureCause.t = 
      T_rrc_FailureCauseWithProtErr_invalidConfiguration;
    /* dummy value for Null type */
   
    rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
    /* continue with rrccu state  RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM */
    return;
  }
  /* Populate the local variables to indicate if Re-direction info is present */
  directed_cell_info.freq_info_present = FALSE;
  directed_cell_info.pscr_present = FALSE;
  if(   (rrccu_state_indicator ==rrc_RRC_StateIndicator_cell_FACH)
        || (rrccu_state_indicator==rrc_RRC_StateIndicator_cell_PCH)
        || (rrccu_state_indicator==rrc_RRC_StateIndicator_ura_PCH))
  {
    if((RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
        rrc_CellUpdateConfirm_r3_IEs,frequencyInfo)) &&
       (RRC_CHECK_COMMON_MSG_TYPE(cell_update_confirm->frequencyInfo.modeSpecificInfo,
       rrc_FrequencyInfo_modeSpecificInfo_fdd)))
    {
      directed_cell_info.freq_info_present = TRUE;
      directed_cell_info.uarfcn_dl         = cell_update_confirm->frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_DL;
    }
    
    if((RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, rrc_CellUpdateConfirm_r3_IEs,dl_InformationPerRL_List))
        && (cell_update_confirm->dl_InformationPerRL_List.elem[0].modeSpecificInfo.t ==
         T_rrc_DL_InformationPerRL_modeSpecificInfo_fdd))
    {
      WRRC_MSG1_HIGH("Primary SCR in CU Cnf  message %d",
           cell_update_confirm->dl_InformationPerRL_List.elem[0].modeSpecificInfo.
           u.fdd->primaryCPICH_Info.primaryScramblingCode);
      directed_cell_info.pscr_present = TRUE;
      directed_cell_info.pscr = cell_update_confirm->dl_InformationPerRL_List.elem[0].modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode;
    }
  }

  /*call the function that evaluates the directed cell info and set the flags accordingly */
  if ((rrc_RRC_StateIndicator_cell_FACH == rrccu_state_indicator) &&
     (rrcrb_validate_directed_cell_info (directed_cell_info) == FALSE))
  {
    /* If UE still has to send a response to the previous Cu Cnf with directed info
     * and it receives another Cu Cnf with directed info, then send failure
     * If the previous Cu Cnf had directed info, then atleast a PCRC Complete
     * has to be pending as a response.
     */
    if( rrccu_int_data.rrccu_cell_selection_last_response_msg != RRCCU_NO_RESP_MSG )
    {
       WRRC_MSG0_ERROR(" Previous Cu Cnf sent a directed info, cannot accept another Cu Cnd with directed info");
       /* Set the Transaction Id */
       rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;
       /* Set Failure cause */
   
       rrccu_failure_cause.failureCause.t = 
         T_rrc_FailureCauseWithProtErr_incompatibleSimultaneousReconfiguration;
        
       rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
       return;
    }
  }


  if (RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
      rrc_CellUpdateConfirm_r3_IEs,dl_CounterSynchronisationInfo)) 
  {
    /*check whether PDCP info is present in the dl counter sync info */
    if (RRC_MSG_COMMON_BITMASK_IE(cell_update_confirm->dl_CounterSynchronisationInfo,
         rrc_DL_CounterSynchronisationInfo,rB_WithPDCP_InfoList))
    {
      /* this involves lossless SRNS relocation so re-send cell update 
         message */
      WRRC_MSG0_ERROR("PDCP info not supported");

      /* Set the Transaction Id */
      rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;

      /* Set Failure cause */
      rrccu_failure_cause.failureCause.t = 
       T_rrc_FailureCauseWithProtErr_configurationUnsupported;

      rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
      /* continue with rrccu state  RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM */
      return;
    }
    /*UE actions, in case IE "Downlink counter synchronisation info" is included and 
         *either IE "RLC reestablish indicator (RB2, RB3 and RB4)" or IE "RLC re-establish 
         *indicator (RB5 and upwards)" are set to TRUE, are not defined.refer to R2-041019,spec cr-2328
         */
    if((cell_update_confirm->rlc_Re_establishIndicatorRb2_3or4 == TRUE) ||
      (cell_update_confirm->rlc_Re_establishIndicatorRb5orAbove == TRUE))
    {
      /* Set the Transaction Id */
      rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;
    
      /* Set Failure cause */
      rrccu_failure_cause.failureCause.t = T_rrc_FailureCauseWithProtErr_configurationUnsupported;
    

    
      WRRC_MSG0_ERROR("UE doesn't support simultaneous RLC Re_est & S-RNS<R2-041019,spec cr-2328>");
      rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
      /* continue with rrccu state  RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM */
      return;
    }

    /* This is lossy SRNS relocation */
    rrccu_cucnf_for_srns_relocation  = TRUE;
    /* store the new URNTI value if present */
    if (RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, rrc_CellUpdateConfirm_r3_IEs,new_U_RNTI))
    {
      rrccu_new_urnti_valid = TRUE;
      rrc_translate_urnti (&(cell_update_confirm->new_U_RNTI),
                            &rrccu_new_urnti);
    }
  }
  /* check whether rlc-re establishment was require but not indicated in cell update
  confirm message. In such case discard the cucnf and resend cell update message.
  This should also take care of multiple cell updates initiated due to change in cause.
  for ex. periodicall...rlc unrecoverabel error, reselection...rlc unrecoverable error
  rl failure..rlc unrecoverable error */
  if (((rrccu_rlc_error_info.error_on_srb == TRUE) && 
      (cell_update_confirm->rlc_Re_establishIndicatorRb2_3or4 == FALSE)) ||
       ((rrccu_rlc_error_info.error_on_urb == TRUE) && 
      (cell_update_confirm->rlc_Re_establishIndicatorRb5orAbove == FALSE)))
  {
    if (RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
        rrc_CellUpdateConfirm_r3_IEs,dl_CounterSynchronisationInfo)) 
    {
      WRRC_MSG0_HIGH("S-RNS relocation is Implicit rlc_Re_establish");
    }
    else
    {
      rrc_cu_uu_log_event_failure_cause = RRC_CU_UU_INVALID_CONFIG;
      rrccu_resend_cell_update_msg(RRCCU_NOT_INCLUDE_FAILURE_CAUSE);
      /* continue with rrccu state  RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM */
      return;
    }
  }

  rrccu_resp_msg = rrccu_find_response_to_cell_update_confirm (msg_ptr, dl_sdu_type);
  /* If CUC doesnt set OC, validate if the existing ehs queues are holding a proper window size */
  /* Calling 'rrcllc_validate_hs_ehs_window_size_for_sec' directly without checking for 
     num of carriers. As CUC doesnt set OC, num sec carriers is anyways 0. We can reject CUC
     if window size is > 32 */
 /*  Note: directed_cell_info.freq_info_present and directed_cell_info.pscr_present will always be FALSE 
     for NO RSP and UMIC response. Added those conditions to just maintain the code consistency. 
     These conditions doesnt impact the logics. If these conditions are redundant, we can remove
     such condition everywhere  */
  if(((RRCCU_NO_RESP_MSG == rrccu_resp_msg)||(RRCCU_UMIC_COMPLETE_RESP_MSG == rrccu_resp_msg)) &&
    (((directed_cell_info.freq_info_present == FALSE )&& (directed_cell_info.pscr_present == FALSE ))
    ||(rrccu_state_indicator ==rrc_RRC_StateIndicator_cell_DCH)))
  {
    if(FALSE == rrcllc_validate_hs_ehs_window_size_for_sec(rrccu_state_indicator))
    {
      rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;
      rrccu_failure_cause.failureCause.t = T_rrc_FailureCauseWithProtErr_invalidConfiguration;
      rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
	  return;
    }
  }
  /* check whether reconfiguration is involved and OC is already set by some other 
  procedure */ 
  if ((rrccu_resp_msg != RRCCU_NO_RESP_MSG) && 
      (rrccu_resp_msg != RRCCU_UMIC_COMPLETE_RESP_MSG) &&
      ((rrcllc_get_ordered_config_status_wo_f3() != OC_NOT_SET) || (rrccu_do_not_acpt_nw_conf_in_cuc == TRUE)))
  {
    /* Set the Transaction Id */
    rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;
    /* Set Failure cause */

    rrccu_failure_cause.failureCause.t = 
      T_rrc_FailureCauseWithProtErr_incompatibleSimultaneousReconfiguration;


    rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
  }
  else
  {

    rrc_update_reconfig_waiting_for_l2ack_dch(MAX_NUM_OF_PROCEDURES);


    /* if this cell update was due to RL faiure then stop any re-est timer
    that is running */
    if(((rrccu_cell_update_cause == rrc_CellUpdateCause_radiolinkFailure)||  
        (rrccu_cell_update_cause == rrc_CellUpdateCause_re_enteredServiceArea)||
      (rrccu_cell_update_cause == rrc_CellUpdateCause_rlc_unrecoverableError)) &&
      (rrccu_failure_state == RRC_STATE_CELL_DCH))
    {
      if (rrccu_rl_failure_info.t314_info.timer_status == RE_EST_TIMER_STARTED)
      {
        WRRC_MSG0_HIGH("Stopping T314");
        rrctmr_stop_timer(RRCTMR_T_314_TIMER); 
      }
      if (rrccu_rl_failure_info.t315_info.timer_status == RE_EST_TIMER_STARTED)
      {
        WRRC_MSG0_HIGH("Stopping T315");
        rrctmr_stop_timer(RRCTMR_T_315_TIMER); 
      }
    }
    state = rrc_translate_state_indicator_to_state(rrccu_state_indicator);
   /* In case of Fre-redirection info from FACh->FACH or FACH->PCH the OC 
     * needs to be set force the OC to be set
     */


    if((rrccu_resp_msg == RRCCU_UMIC_COMPLETE_RESP_MSG)
        &&(((directed_cell_info.freq_info_present == FALSE )&& (directed_cell_info.pscr_present == FALSE ))||
     (  rrccu_state_indicator == rrc_RRC_StateIndicator_cell_DCH))
    )
    {
      if (rrc_get_rlc_size_change_status_for_procedure_id(RRC_PROCEDURE_CU))
      {
        rrcsmc_update_hfn_for_rlc_rb(rlc_size_change_in_progress.rb_id, 
                                     rlc_size_change_in_progress.direction);
      }
      if (! rrccu_cucnf_for_srns_relocation)
      {
        /* procedure does not involve SRNS relocation */

        /* need to send RNTI update request if any of the RNTIs is present
        in the message */
        if ((RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
              rrc_CellUpdateConfirm_r3_IEs,new_C_RNTI)) ||
            (RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm,
             rrc_CellUpdateConfirm_r3_IEs,new_U_RNTI)))
        {
          /* Allocates the buffer to RRC Internal command */
          cmd_ptr =  rrc_get_int_cmd_buf();
          /* Fill parameters for RRC_RNTI_UPDATE_REQ command */
          cmd_ptr->cmd.rnti_update_req.procedure = RRC_PROCEDURE_CU;
          cmd_ptr->cmd_hdr.cmd_id = RRC_RNTI_UPDATE_REQ;

          if (RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
                rrc_CellUpdateConfirm_r3_IEs,new_C_RNTI)) 
          {
            rrc_translate_crnti(&cell_update_confirm->new_C_RNTI,&crnti);
            cmd_ptr->cmd.rnti_update_req.crnti_action = RRC_RNTI_UPDATE;
            cmd_ptr->cmd.rnti_update_req.crnti = crnti;
#ifdef FEATURE_WCDMA_HS_RACH
            if(rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH)
            {
              rrchsrach_set_hspa_rnti_stored_cell_pch(ordered_config_ptr,TRUE);
            }
#endif
          }
          else
          {
            cmd_ptr->cmd.rnti_update_req.crnti_action = RRC_RNTI_NOCHANGE;
          }

          if(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
             rrc_CellUpdateConfirm_r3_IEs,new_U_RNTI))
          {
            rrc_translate_urnti(&cell_update_confirm->new_U_RNTI, &urnti);
            cmd_ptr->cmd.rnti_update_req.urnti_action = RRC_RNTI_UPDATE;
            cmd_ptr->cmd.rnti_update_req.urnti= urnti;
          }
          else
          {
            cmd_ptr->cmd.rnti_update_req.urnti_action = RRC_RNTI_NOCHANGE;
          }

          /* Indicate to LLC if RLC for SRBs needs to be re-established */
          if(cell_update_confirm->rlc_Re_establishIndicatorRb2_3or4 == TRUE)
          {
            cmd_ptr->cmd.rnti_update_req.rlc_re_establish_srb = TRUE;
          }
          else
          {
            cmd_ptr->cmd.rnti_update_req.rlc_re_establish_srb = FALSE;
          }

          /* Indicate to LLC if RLC for User plane RBs needs to be re-established */
          if(cell_update_confirm->rlc_Re_establishIndicatorRb5orAbove == TRUE)
          {
            cmd_ptr->cmd.rnti_update_req.rlc_re_establish_rab = TRUE;
          }
          else
          {
            cmd_ptr->cmd.rnti_update_req.rlc_re_establish_rab = FALSE;
          }

          cmd_ptr->cmd.rnti_update_req.cnf_required = TRUE;
          WRRC_MSG2_HIGH("Sending RNTI update req CRNTI_stat:%d, URNTI_stat:%d", 
                    cmd_ptr->cmd.rnti_update_req.crnti_action,
                    cmd_ptr->cmd.rnti_update_req.urnti_action);

          rrc_put_int_cmd(cmd_ptr);       /* sends the command to RRC  LLC. */

          rrccu_substate = RRCCU_WAIT_FOR_RNTI_UPDATE_CNF;         
        }
        else
        {
          if (C_RNTI_NOT_VALID == rrcllc_get_current_crnti_status())
          {
            /* should not come here as this condition is already taken care in downlink
            sdu processing */
            WRRC_MSG1_ERROR("RNTI absent for UMIC message, next state %d", 
                    rrc_get_state());
            /* Set the Transaction Id */
            rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;

            /* Set Failure cause */
            rrccu_failure_cause.failureCause.t = 
              T_rrc_FailureCauseWithProtErr_invalidConfiguration;
 

            rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
            /* continue with rrccu state  RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM */
            return;
          }
          rrccu_send_response_msg();
        }
        if( RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
            rrc_CellUpdateConfirm_r3_IEs,cn_InformationInfo))
        {
          (void) rrc_ccm_send_nas_cn_info(
                        &(cell_update_confirm->cn_InformationInfo)
                        ,primary_plmn_Id_present
                        ,&primary_plmn_Identity
             );
        } 
      }
      else
      {
        /* procedure involves SRNS relocation so store the C-RNTI
        and send rlc_reestablishment request to SMC . RNTI update 
        will be done after RLC re-establishment*/
        if (RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
              rrc_CellUpdateConfirm_r3_IEs,new_C_RNTI)) 
        {
          rrccu_new_crnti_valid = TRUE;
          rrc_translate_crnti(&cell_update_confirm->new_C_RNTI,&rrccu_new_crnti);
#ifdef FEATURE_WCDMA_HS_RACH
          if(rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH)
          {
            rrchsrach_set_hspa_rnti_stored_cell_pch(ordered_config_ptr,TRUE);
          }
#endif

        }
        if(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
           rrc_CellUpdateConfirm_r3_IEs,new_U_RNTI))
        {
          rrccu_new_urnti_valid = TRUE;
          rrc_translate_urnti(&cell_update_confirm->new_U_RNTI,&rrccu_new_urnti);
        }
        /* store the rlc re-establishment indications */
        rrccu_reestablish_srb = cell_update_confirm->rlc_Re_establishIndicatorRb2_3or4;
        rrccu_reestablish_rab = cell_update_confirm->rlc_Re_establishIndicatorRb5orAbove;

        //commit fresh values for srns relocation
        rrcsmc_commit_fresh_for_srns_relocation();

        /*send the rlc re-establishment request to SMC to re-establish SRB2 */
        /* Get the command buffer */
          int_cmd_ptr = rrc_get_int_cmd_buf();
          /* Fill in the command id  */
          int_cmd_ptr->cmd_hdr.cmd_id = RRC_RE_EST_RLC_FOR_SRNS_REQ;
          int_cmd_ptr->cmd.rrc_re_est_srns_req.rrc_proc = RRC_PROCEDURE_CU;
          int_cmd_ptr->cmd.rrc_re_est_srns_req.rb_type  = RRC_RE_EST_RB_2;
          int_cmd_ptr->cmd.rrc_re_est_srns_req.cnf_reqd = TRUE;
          WRRC_MSG1_HIGH("RLC Reestablish req for %d ", 
                   RRC_RE_EST_RB_2); 

          rrc_put_int_cmd(int_cmd_ptr);             

          rrccu_substate = RRCCU_WAIT_FOR_SRB2_RE_EST_CNF;         
          if( RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
              rrc_CellUpdateConfirm_r3_IEs,cn_InformationInfo))
          {
            (void) rrc_ccm_send_nas_cn_info(
                        &(cell_update_confirm->cn_InformationInfo)
                        ,primary_plmn_Id_present
                        ,&primary_plmn_Identity
                 );
          } 
        }
    }
   /* In case of Fre-redirection info from FACh->FACH or FACH->PCH the OC 
     * needs to be set force the OC to be set
     */
    else if( (rrccu_resp_msg == RRCCU_NO_RESP_MSG)
            &&(((directed_cell_info.freq_info_present == FALSE )&& 
                  (directed_cell_info.pscr_present == FALSE ))||
            (  rrccu_state_indicator ==rrc_RRC_StateIndicator_cell_DCH))
        ) 
    {
      rrccu_check_and_send_response_to_previous_cell_upd_cnf();

      /* if the next state is cell_pch or ura_pch then setup pcch */
      if ((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH) ||
          (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH))
      {
        if (cell_update_confirm->rlc_Re_establishIndicatorRb2_3or4 == TRUE || 
            cell_update_confirm->rlc_Re_establishIndicatorRb5orAbove == TRUE)
        {
          cmd_ptr =  rrc_get_int_cmd_buf();
          /* Fill parameters for RRC_RNTI_UPDATE_REQ command */
          cmd_ptr->cmd.rnti_update_req.procedure = RRC_PROCEDURE_CU;
          cmd_ptr->cmd_hdr.cmd_id = RRC_RNTI_UPDATE_REQ;
          cmd_ptr->cmd.rnti_update_req.crnti_action = RRC_RNTI_NOCHANGE;            
          cmd_ptr->cmd.rnti_update_req.urnti_action = RRC_RNTI_NOCHANGE;
        
          /* Indicate to LLC if RLC for SRBs needs to be re-established */
          if(cell_update_confirm->rlc_Re_establishIndicatorRb2_3or4 == TRUE)
          {
            cmd_ptr->cmd.rnti_update_req.rlc_re_establish_srb = TRUE;
          }
          else
          {
            cmd_ptr->cmd.rnti_update_req.rlc_re_establish_srb = FALSE;
          }
          
          /* Indicate to LLC if RLC for User plane RBs needs to be re-established */
          if(cell_update_confirm->rlc_Re_establishIndicatorRb5orAbove == TRUE)
          {
            cmd_ptr->cmd.rnti_update_req.rlc_re_establish_rab = TRUE;
          }
          else
          {
            cmd_ptr->cmd.rnti_update_req.rlc_re_establish_rab = FALSE;
          }

          rrc_put_int_cmd(cmd_ptr);       /* sends the command to RRC  LLC. */
        }

        if( RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
            rrc_CellUpdateConfirm_r3_IEs,cn_InformationInfo))
        {
          (void) rrc_ccm_send_nas_cn_info(
                         &(cell_update_confirm->cn_InformationInfo)
                        ,primary_plmn_Id_present
                        ,&primary_plmn_Identity
               );
        } 
       /*set the UTRAN DRX coef in rrcllc */
        rrcllc_set_utran_drx_info (rrccu_utran_drx_coef); 
        rrccu_establish_pcch_rb (state);
        rrccu_substate = RRCCU_WAIT_FOR_PCCH_RB_EST_CNF;
      }
      else 
      {

        if (cell_update_confirm->rlc_Re_establishIndicatorRb2_3or4 == TRUE || 
            cell_update_confirm->rlc_Re_establishIndicatorRb5orAbove == TRUE)
        {
          cmd_ptr =  rrc_get_int_cmd_buf();

          /* Fill parameters for RRC_RNTI_UPDATE_REQ command */
          cmd_ptr->cmd.rnti_update_req.procedure = RRC_PROCEDURE_CU;
          cmd_ptr->cmd_hdr.cmd_id = RRC_RNTI_UPDATE_REQ;
          cmd_ptr->cmd.rnti_update_req.crnti_action = RRC_RNTI_NOCHANGE;            
          cmd_ptr->cmd.rnti_update_req.urnti_action = RRC_RNTI_NOCHANGE;

          /* Indicate to LLC if RLC for SRBs needs to be re-established */
          if(cell_update_confirm->rlc_Re_establishIndicatorRb2_3or4 == TRUE)
          {
            cmd_ptr->cmd.rnti_update_req.rlc_re_establish_srb = TRUE;
          }
          else
          {
            cmd_ptr->cmd.rnti_update_req.rlc_re_establish_srb = FALSE;
          }
          
          /* Indicate to LLC if RLC for User plane RBs needs to be re-established */
          if(cell_update_confirm->rlc_Re_establishIndicatorRb5orAbove == TRUE)
          {
            cmd_ptr->cmd.rnti_update_req.rlc_re_establish_rab = TRUE;
          }
          else
          {
            cmd_ptr->cmd.rnti_update_req.rlc_re_establish_rab = FALSE;
          }

          rrc_put_int_cmd(cmd_ptr);       /* sends the command to RRC  LLC. */
        }
       
        /* Reset the state machine and the procedure ends */
        rrccu_substate = RRCCU_INITIAL;
        
        /* Start timer T305 */
        rrccu_start_t_305_timer();
        if( RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
            rrc_CellUpdateConfirm_r3_IEs,cn_InformationInfo))
        {
          (void) rrc_ccm_send_nas_cn_info(
                        &(cell_update_confirm->cn_InformationInfo)
                        ,primary_plmn_Id_present
                        ,&primary_plmn_Identity
              );
        } 
       /* Inform all registered RRC procedures that Cell
         Update is completed */
        rrccu_inform_cell_update_completed();
       
   
        rrccu_process_successful_completion();

        /*call the procedure to clear the global variabls */
        rrccu_clear_procedure();
        rrccu_init_last_cu_cnf_info();

      }
    }
    else
    {
      status = rrcllc_set_ordered_config(RRC_PROCEDURE_CU, state, dl_sdu_type, msg_ptr) ;
      switch( status  )
      {
        case ORDERED_CONFIG_SET:
          /* set the flag.Later it will be used while clearing the OC */
          rrccu_oc_set_by_cu = TRUE;

          if ((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH)||
              (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH))
          {
     
       
            /*call the function that evaluates the directed cell info and set the flags accordingly */
            if (rrcrb_validate_directed_cell_info (directed_cell_info) == FALSE)
            {
              if(rrccsp_check_initiate_cell_selection_handling(&directed_cell_info) == FALSE)
              {
                rrccu_cu_initiate_reqd.cu_reqd = TRUE;
                rrccu_cu_initiate_reqd.cu_cause = rrc_CellUpdateCause_cellReselection;
              }
              else
              {
                rrccu_int_data.rrccu_cell_selection_trans_from_fach = TRUE;
              }
            }
 
            if (rrccu_resp_msg == RRCCU_UMIC_COMPLETE_RESP_MSG)
            {
              if (rrc_get_rlc_size_change_status_for_procedure_id(RRC_PROCEDURE_CU))
              {
                WRRC_MSG0_HIGH("RLC Size change detecting.  calling smc func");
                rrcsmc_update_hfn_for_rlc_rb(rlc_size_change_in_progress.rb_id, 
                                             rlc_size_change_in_progress.direction);
              }
              else
              {
                WRRC_MSG0_HIGH("NO RLC size change detected.");
              }
            }

            /* copy the channel config info in to a local buffer
            we should configure the channels after the response message
            is sent */
            /* Initialize the no of RBs */
            no_of_RBs = 0;
            /* Fill in the command parameters for RRC_CHANNEL_CONFIG_REQ */

            /* Fill in parameters for RRC_CHANNEL_CONFIG_REQ command */
              /* Change the state if it is not CELL_PCH or URA_PCH */

            if(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, rrc_CellUpdateConfirm_r3_IEs,rb_InformationReleaseList))
            {
              /* set to flag to indicate that rb release information is present
              in the message. This information will be used after channel configu
              ration to release the rbs from established_rab and also to indicate
              to the upper layers about RAB release if necessary */
              rrccu_rb_release_info.rrccu_rb_release_in_cucnf = TRUE;
              /* Save the linked list head pointer */ 
              rrc_rb_information_release_list = 
                &cell_update_confirm->rb_InformationReleaseList;
              rb_idx=0;
              while(rrc_rb_information_release_list->n > rb_idx)
              { 
                if( rrc_rb_information_release_list->elem[rb_idx] == DCCH_DT_LOW_PRI_RADIO_BEARER_ID)
                {
                  if(RRCLCM_RLC_LC_ID_NOT_FOUND == rrclcm_check_dl_rlc_lc_id(
                                                   UE_LOGCHAN_DCCH,
                                                   DCCH_DT_LOW_PRI_RADIO_BEARER_ID,
                                                   UE_MODE_ACKNOWLEDGED_DATA))
                  {
                    WRRC_MSG1_HIGH("Ignore Non-exitent rb_id =%d in cucnf",rrc_rb_information_release_list->elem[rb_idx]);
                    rb_idx++;
                    continue;
                  }
                }
                else if(! rrc_find_rb_in_est_rabs(rrc_rb_information_release_list->elem[rb_idx])) 
                {
                  WRRC_MSG1_HIGH("Ignore Non-exitent rb_id =%d in cucnf",rrc_rb_information_release_list->elem[rb_idx]);
                  rb_idx++;
                  continue;
                }
                else if (MAX_RB != rrccu_check_if_rbid_present_in_rrccu_rb_release_info(rrc_rb_information_release_list->elem[rb_idx],no_of_RBs))
                {
                  WRRC_MSG1_ERROR(" Ignoring Duplicate RB ID % d in CU ",rrc_rb_information_release_list->elem[rb_idx]);
                  rb_idx++;
                  continue;
                }

                WRRC_MSG1_HIGH("Release RB id=%d",rrc_rb_information_release_list->elem[rb_idx]);

                rrccu_chan_config_info.rb_info[no_of_RBs].rb_id = 
                rrc_rb_information_release_list->elem[rb_idx];

                rrccu_chan_config_info.rb_info[no_of_RBs].rb_config = RELEASE_RB;

                /* store the rb info to release list in local buffer which will
                be used later to release it from established_rab variable */
                rrccu_rb_release_info.rb_id[no_of_RBs]=rrc_rb_information_release_list->elem[rb_idx];

                /* Advance the Linked List pointer */
                rb_idx++;
                no_of_RBs++;
              }

              rrccu_rb_release_info.num_rbs = no_of_RBs;

              rrcrb_update_mac_rab_status(RRC_PROCEDURE_CU, RRC_CS_DOMAIN_CN_ID,
                                          &cell_update_confirm->rb_InformationReleaseList,
                                          FALSE);

            }
            if(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, rrc_CellUpdateConfirm_r3_IEs,rb_InformationReconfigList))
            {
              rb_idx=0;
              do
              { 
                 /* Save the linked list head pointer */
                rrc_rb_information_reconfig_ptr = 
                 &cell_update_confirm->rb_InformationReconfigList.elem[rb_idx];
                rrccu_chan_config_info.rb_info[no_of_RBs].rb_id = 
                        rrc_rb_information_reconfig_ptr->rb_Identity;

                rrccu_chan_config_info.rb_info[no_of_RBs].rb_config = RECONFIG_RB;
                rrccu_chan_config_info.rb_info[no_of_RBs].rb_config = RECONFIG_RB_OTA;
                rrccu_chan_config_info.rb_info[no_of_RBs].ul_cfg_mask = 0;
                rrccu_chan_config_info.rb_info[no_of_RBs].dl_cfg_mask = 0;
                if((RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_rb_information_reconfig_ptr, rrc_RB_InformationReconfig,rlc_Info))
                    &&(RRC_MSG_COMMON_BITMASK_IE(rrc_rb_information_reconfig_ptr->rlc_Info,rrc_RLC_Info,ul_RLC_Mode)))
                {
                  rrccu_chan_config_info.rb_info[no_of_RBs].ul_cfg_mask |= MODIFY_RB_CFG;
                }
                if((RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_rb_information_reconfig_ptr, rrc_RB_InformationReconfig,rlc_Info))
                    &&(RRC_MSG_COMMON_BITMASK_IE(rrc_rb_information_reconfig_ptr->rlc_Info,rrc_RLC_Info,dl_RLC_Mode)))
                {
                  rrccu_chan_config_info.rb_info[no_of_RBs].dl_cfg_mask |= MODIFY_RB_CFG;
                }
                if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_rb_information_reconfig_ptr, rrc_RB_InformationReconfig,rb_StopContinue))
                {
                  if (rrc_rb_information_reconfig_ptr->rb_StopContinue == rrc_RB_StopContinue_stopRB)
                  {
                    rrccu_chan_config_info.rb_info[no_of_RBs].ul_cfg_mask |= STOP_RB_CFG; 
                    rrccu_chan_config_info.rb_info[no_of_RBs].dl_cfg_mask |= STOP_RB_CFG;

                    WRRC_MSG1_HIGH("Stop recvd for RB %d", (rrc_rb_information_reconfig_ptr->rb_Identity));
                  }
                  else if (rrc_rb_information_reconfig_ptr->rb_StopContinue == rrc_RB_StopContinue_continueRB)
                  {
                    rrccu_chan_config_info.rb_info[no_of_RBs].ul_cfg_mask |= CONTINUE_RB_CFG; 
                    rrccu_chan_config_info.rb_info[no_of_RBs].dl_cfg_mask |= CONTINUE_RB_CFG;
                    WRRC_MSG1_HIGH("Continue recvd for RB %d", (rrc_rb_information_reconfig_ptr->rb_Identity));
                  }
                }
                /* Advance the Linked List pointer */
                rb_idx++;
                no_of_RBs++;
                 
              } while(cell_update_confirm->rb_InformationReconfigList.n > rb_idx) ;
            }
            if(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm,
               rrc_CellUpdateConfirm_r3_IEs,rb_InformationAffectedList))
            {
              rb_idx =0;
              /* Save the head pointer of linked list */
              rrc_rb_information_affected_list = 
                &cell_update_confirm->rb_InformationAffectedList;

              rrccu_chan_config_info.rb_info[no_of_RBs].rb_id = 
                cell_update_confirm->rb_InformationAffectedList.elem[rb_idx].rb_Identity;

              rrccu_chan_config_info.rb_info[no_of_RBs].rb_config = RECONFIG_RB;
              /*NOT NEEDED*/
              rrccu_chan_config_info.rb_info[no_of_RBs].rb_config = RECONFIG_RB_OTA;
              rrccu_chan_config_info.rb_info[no_of_RBs].ul_cfg_mask = rrccu_chan_config_info.rb_info[no_of_RBs].dl_cfg_mask = MODIFY_RB_CFG;
              do
              { 
                rrccu_chan_config_info.rb_info[no_of_RBs].rb_id = 
                    rrc_rb_information_affected_list->elem[rb_idx].rb_Identity;

                rrccu_chan_config_info.rb_info[no_of_RBs].rb_config = RECONFIG_RB;
                rrccu_chan_config_info.rb_info[no_of_RBs].rb_config = RECONFIG_RB_OTA;
                rrccu_chan_config_info.rb_info[no_of_RBs].ul_cfg_mask = rrccu_chan_config_info.rb_info[no_of_RBs].dl_cfg_mask = MODIFY_RB_CFG;
                /* Advance the Linked List pointer */
                rb_idx++;

                no_of_RBs++;

              } while(rrc_rb_information_affected_list->n > rb_idx);
            }

            rrccu_chan_config_info.num_rbs = no_of_RBs;
            rrccu_chan_config_reqd = TRUE;
            if (! rrccu_cucnf_for_srns_relocation)
            {
              /* procedure does not involve SRNS relocation */

              /* CRNTI always must be present to send the 
              response message */
              /* if cucnf message has new C-RNTI  then we need to update
              the C-RNTI in mac first and send the response and then start
              the channel configuration */
              if (RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
                    rrc_CellUpdateConfirm_r3_IEs,new_C_RNTI))
              {
                /* Allocates the buffer to RRC Internal command */
                cmd_ptr =  rrc_get_int_cmd_buf();
                /* Fill parameters for RRC_RNTI_UPDATE_REQ command */
                cmd_ptr->cmd.rnti_update_req.procedure = RRC_PROCEDURE_CU;
                cmd_ptr->cmd_hdr.cmd_id = RRC_RNTI_UPDATE_REQ;

                rrc_translate_crnti(&cell_update_confirm->new_C_RNTI,&crnti);
                cmd_ptr->cmd.rnti_update_req.crnti_action = RRC_RNTI_UPDATE;
                cmd_ptr->cmd.rnti_update_req.crnti = crnti;

                if(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
                   rrc_CellUpdateConfirm_r3_IEs,new_U_RNTI))
                {
                  rrc_translate_urnti(&cell_update_confirm->new_U_RNTI, &urnti);
                  cmd_ptr->cmd.rnti_update_req.urnti_action = RRC_RNTI_UPDATE;
                  cmd_ptr->cmd.rnti_update_req.urnti= urnti;
                }
                else
                {
                  cmd_ptr->cmd.rnti_update_req.urnti_action = RRC_RNTI_NOCHANGE;
                }
                /* Indicate to LLC if RLC for SRBs needs to be re-established */
                if(cell_update_confirm->rlc_Re_establishIndicatorRb2_3or4 == TRUE)
                {
                  cmd_ptr->cmd.rnti_update_req.rlc_re_establish_srb = TRUE;
                }
                else
                {
                  cmd_ptr->cmd.rnti_update_req.rlc_re_establish_srb = FALSE;
                }
                /* Indicate to LLC if RLC for User plane RBs needs to be re-established */
                if(cell_update_confirm->rlc_Re_establishIndicatorRb5orAbove == TRUE)
                {
                  cmd_ptr->cmd.rnti_update_req.rlc_re_establish_rab = TRUE;
                }
                else
                {
                  cmd_ptr->cmd.rnti_update_req.rlc_re_establish_rab = FALSE;
                }
                cmd_ptr->cmd.rnti_update_req.cnf_required = TRUE;

                WRRC_MSG2_HIGH("Sending RNTI update req CRNTI_stat:%d, URNTI_stat:%d", 
                          cmd_ptr->cmd.rnti_update_req.crnti_action,
                          cmd_ptr->cmd.rnti_update_req.urnti_action);

                rrc_put_int_cmd(cmd_ptr);       /* sends the command to RRC  LLC. */

                rrccu_substate = RRCCU_WAIT_FOR_RNTI_UPDATE_CNF;         
                if( RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
                    rrc_CellUpdateConfirm_r3_IEs,cn_InformationInfo))
                {
                  (void) rrc_ccm_send_nas_cn_info(
                        &(cell_update_confirm->cn_InformationInfo)
                        ,primary_plmn_Id_present
                        ,&primary_plmn_Identity
                   );
                } 
              }
              else
              {
                /* We will be in Cell_FACH state at this time and going to send the
                response message in Cell_FACH state.*/
                WRRC_MSG1_HIGH("RNTI absent for RB resp message, next state%d", 
                        rrc_get_state());
                if( RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
                    rrc_CellUpdateConfirm_r3_IEs,cn_InformationInfo))
                {
                  (void) rrc_ccm_send_nas_cn_info(
                         &(cell_update_confirm->cn_InformationInfo)
                        ,primary_plmn_Id_present
                        ,&primary_plmn_Identity
                   );
                } 

                /* In case of FACH->PCH if no response has to be sent then initate
                 *  cell selection if directed info is present.
                 */
                if ((rrccu_int_data.rrccu_cell_selection_trans_from_fach) &&
                    (rrccu_resp_msg == RRCCU_NO_RESP_MSG))
                {   
                  rrccu_intiate_cell_selection_fach_pch_cu_cnf(); 
                }
                else
                {
                  /* send the response message on the old configuration */
                  rrccu_send_response_msg();
                }
              }
            }
            else
            {
              /* procedure involves SRNS relocation so store the C-RNTI
              and send rlc_reestablishment request to SMC . RNTI update 
              will be done after RLC re-establishment*/
              if (RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
                    rrc_CellUpdateConfirm_r3_IEs,new_C_RNTI)) 
              {
                rrccu_new_crnti_valid = TRUE;
                rrc_translate_crnti(&cell_update_confirm->new_C_RNTI,&rrccu_new_crnti);
              }
              if(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
                 rrc_CellUpdateConfirm_r3_IEs,new_U_RNTI))
              {
                rrccu_new_urnti_valid = TRUE;
                rrc_translate_urnti(&cell_update_confirm->new_U_RNTI,&rrccu_new_urnti);
              }
              /* store the rlc re-establishment indications */
              rrccu_reestablish_srb = cell_update_confirm->rlc_Re_establishIndicatorRb2_3or4;
              rrccu_reestablish_rab = cell_update_confirm->rlc_Re_establishIndicatorRb5orAbove;

              //commit fresh values for srns relocation
              rrcsmc_commit_fresh_for_srns_relocation();

              /*send the rlc re-establishment request to SMC to re-establish SRB2 */
              /* Get the command buffer */
                int_cmd_ptr = rrc_get_int_cmd_buf();
                /* Fill in the command id  */
                int_cmd_ptr->cmd_hdr.cmd_id = RRC_RE_EST_RLC_FOR_SRNS_REQ;
                int_cmd_ptr->cmd.rrc_re_est_srns_req.rrc_proc = RRC_PROCEDURE_CU;
                int_cmd_ptr->cmd.rrc_re_est_srns_req.rb_type  = RRC_RE_EST_RB_2;
                int_cmd_ptr->cmd.rrc_re_est_srns_req.cnf_reqd = TRUE;
                WRRC_MSG1_HIGH("RLC Reestablish req for %d ", 
                         RRC_RE_EST_RB_2); 

                rrc_put_int_cmd(int_cmd_ptr);             

                rrccu_substate = RRCCU_WAIT_FOR_SRB2_RE_EST_CNF;         
                if( RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
                    rrc_CellUpdateConfirm_r3_IEs,cn_InformationInfo))
                {
                  (void) rrc_ccm_send_nas_cn_info(
                        &(cell_update_confirm->cn_InformationInfo)
                        ,primary_plmn_Id_present
                        ,&primary_plmn_Identity
                      );
                } 
              }
          }
          else /*normal fach-fach or fach-dch configuration */
          {
            /* if any rlc entity has to be re-established then re-establish it 
            before configuring channels. */
            if((cell_update_confirm->rlc_Re_establishIndicatorRb2_3or4 == TRUE) ||
                (cell_update_confirm->rlc_Re_establishIndicatorRb5orAbove == TRUE))
            {
              /* store the rlc re-establishment indications */
              rrccu_reestablish_srb = cell_update_confirm->rlc_Re_establishIndicatorRb2_3or4;
              rrccu_reestablish_rab = cell_update_confirm->rlc_Re_establishIndicatorRb5orAbove;
              rrccu_new_crnti_valid = FALSE;
              rrccu_new_urnti_valid = FALSE;
              rrccu_send_rnti_update_req(FALSE);
              ps_rb_re_establish_indicator = cell_update_confirm->rlc_Re_establishIndicatorRb5orAbove;
              WRRC_MSG1_HIGH("CU: RB5 or higher re-establish indicator %d",
                       cell_update_confirm->rlc_Re_establishIndicatorRb5orAbove);
            }

            if((rrccu_resp_msg == RRCCU_UMIC_COMPLETE_RESP_MSG)
                && (rrccu_state_indicator == rrc_RRC_StateIndicator_cell_FACH ))
            {
              if (rrc_get_rlc_size_change_status_for_procedure_id(RRC_PROCEDURE_CU))
              {
                rrcsmc_update_hfn_for_rlc_rb(rlc_size_change_in_progress.rb_id, 
                                             rlc_size_change_in_progress.direction);
              }
            }


            rrccu_reestablish_srb = FALSE;
            rrccu_reestablish_rab = FALSE;
            /* store the C-RNTI
            and send rlc_reestablishment request to SMC . RNTI update 
            will be done after Channel configuration*/
            if (RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
                  rrc_CellUpdateConfirm_r3_IEs,new_C_RNTI) 
                  && (rrccu_state_indicator != rrc_RRC_StateIndicator_cell_DCH) ) 
            {
              rrccu_new_crnti_valid = TRUE;
              rrc_translate_crnti(&cell_update_confirm->new_C_RNTI,&rrccu_new_crnti);
            }
            if(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
               rrc_CellUpdateConfirm_r3_IEs,new_U_RNTI))
            {
              rrccu_new_urnti_valid = TRUE;
              rrc_translate_urnti(&cell_update_confirm->new_U_RNTI,&rrccu_new_urnti);
            }

            /*check whether this procedure involves SRNS reloc */
            if (rrccu_cucnf_for_srns_relocation)
            {
              /*commit fresh values for srns relocation */
              rrcsmc_commit_fresh_for_srns_relocation();
            }
            /* Allocates the buffer to RRC Internal command */
              cmd_ptr =  rrc_get_int_cmd_buf();
              rrccu_cipher_update_required = FALSE;

              /* Initialize the no of RBs */
              no_of_RBs = 0;
              /* Fill in the command parameters for RRC_CHANNEL_CONFIG_REQ */
              cmd_ptr->cmd_hdr.cmd_id = RRC_CHANNEL_CONFIG_REQ;
              cmd_ptr->cmd.chan_config_req.procedure = RRC_PROCEDURE_CU;

              /* Fill in parameters for RRC_CHANNEL_CONFIG_REQ command */
              if (rrccu_state_indicator == rrc_RRC_StateIndicator_cell_DCH  )
              {
                //if we r going to dch, then dl-common-info-for-all-rl will be present..
                //check if ciphering is active in mac for cs domain, if it is then,
                //start 2 tiered HHO procedure STEP_1 and STEP_2 for rl-re-establishment
                if(rrcsmc_tm_ciph_active() == TRUE)
                {
                  WRRC_MSG0_HIGH("RL-cipher present in TM-rb's");
                  if(SUCCESS == 
                   rrcsmc_process_cipher_config_for_hho(RRCSMC_INVALID_HFN_VALUE)) 
                  {
                    rrccu_cipher_update_required = TRUE;
                  }
                }
                else
                {
                  WRRC_MSG0_HIGH("RL-cipher not-present in TM");
                }

                /* Change the state if it is not CELL_PCH or URA_PCH */
                cmd_ptr->cmd.chan_config_req.rrc_state_change_required = TRUE;
                cmd_ptr->cmd.chan_config_req.next_state = state;
              }
              else
              {
                cmd_ptr->cmd.chan_config_req.rrc_state_change_required = FALSE;
              }
              cmd_ptr->cmd.chan_config_req.rrc_channel_config_cnf_required = TRUE;

              if(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, rrc_CellUpdateConfirm_r3_IEs,rb_InformationReleaseList))
              {
                /* set to flag to indicate that rb release information is present
                in the message. This information will be used after channel configu
                ration to release the rbs from established_rab and also to indicate
                to the upper layers about RAB release if necessary */
                rrccu_rb_release_info.rrccu_rb_release_in_cucnf = TRUE;

                /* Save the linked list head pointer */ 
                rrc_rb_information_release_list = 
                  &cell_update_confirm->rb_InformationReleaseList;

                /* If voice RAB still exist, then indicate layer 1 that next configuration is going to
                   include AMR configuration.
                   This check is not required if state change indication is either cell_PCH, URA_PCH or
                   CELL_FACH, because if voice is configured then next state has to be CELL_DCH.
                */
                if ((rrc_RRC_StateIndicator_cell_DCH == rrccu_state_indicator) && (FALSE == 
                    rrc_is_given_rb_rel_list_releases_all_rb_for_voice_rab(
                                      rrc_rb_information_release_list)))
                {
                  rrc_indicate_layer1_next_config_is_for_voice();
                }
                rb_idx=0;
                while(rrc_rb_information_release_list->n > rb_idx)
                { 
                  if( rrc_rb_information_release_list->elem[rb_idx] == DCCH_DT_LOW_PRI_RADIO_BEARER_ID)
                  {
                  if(RRCLCM_RLC_LC_ID_NOT_FOUND == rrclcm_check_dl_rlc_lc_id(
                                                   UE_LOGCHAN_DCCH,
                                                   DCCH_DT_LOW_PRI_RADIO_BEARER_ID,
                                                   UE_MODE_ACKNOWLEDGED_DATA))
                    {
                      WRRC_MSG1_HIGH("Ignore Non-exitent rb_id = %d in cucnf",rrc_rb_information_release_list->elem[rb_idx]);
                      rb_idx++;
                      continue;
                    }
                  }
                  else if(! rrc_find_rb_in_est_rabs(rrc_rb_information_release_list->elem[rb_idx])) 
                  {
                    WRRC_MSG1_HIGH("Ignore Non-exitent rb_id =%d in cucnf",rrc_rb_information_release_list->elem[rb_idx]);
                    rb_idx++;
                    continue;
                  }
                  else if (MAX_RB != rrccu_check_if_rbid_present_in_rrccu_rb_release_info(rrc_rb_information_release_list->elem[rb_idx],no_of_RBs))
                  {
                    WRRC_MSG1_ERROR(" Ignoring Duplicate RB ID % d in CU ",rrc_rb_information_release_list->elem[rb_idx]);
                    rb_idx++;
                    continue;
                  }

                  WRRC_MSG1_HIGH("Release rb_id =%d in cucnf",rrc_rb_information_release_list->elem[rb_idx]);
                  cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].rb_id = 
                  rrc_rb_information_release_list->elem[rb_idx];

                  cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].rb_config = RELEASE_RB;

                  /* store the rb info to release list in local buffer which will
                  be used later to release it from established_rab variable */
                  rrccu_rb_release_info.rb_id[no_of_RBs]=rrc_rb_information_release_list->elem[rb_idx];

                  /* Advance the Linked List pointer */
                  rb_idx++;

                  no_of_RBs++;

                }

                rrccu_rb_release_info.num_rbs = no_of_RBs;

                rrcrb_update_mac_rab_status(RRC_PROCEDURE_CU, RRC_CS_DOMAIN_CN_ID,
                                            &cell_update_confirm->rb_InformationReleaseList,
                                            FALSE);
              }
              else
              {
                /* It means CU Confirm doesnt include information to release any RB. 
                   check if AMR RAB was established earlier. If yes then indicate layer 1 that
                   next configuration will be for AMR.
                   This check is not required if state change indication is either cell_PCH, URA_PCH or
                   CELL_FACH, because if voice is configured then next state has to be CELL_DCH.                   
                */
                if ((rrc_RRC_StateIndicator_cell_DCH == rrccu_state_indicator) && 
                                          (TRUE == rrc_is_voice_rab_present()))
                {
                  rrc_indicate_layer1_next_config_is_for_voice();
                }
              }
              if(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, rrc_CellUpdateConfirm_r3_IEs,rb_InformationReconfigList))
              {
                rb_idx =0;
                

                do
                { 
                  /* Save the linked list head pointer */
                  rrc_rb_information_reconfig_ptr = 
                  &cell_update_confirm->rb_InformationReconfigList.elem[rb_idx];
                  cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].rb_id = 
                  rrc_rb_information_reconfig_ptr->rb_Identity;

                  cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].rb_config = RECONFIG_RB;
                  cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].rb_config = RECONFIG_RB_OTA;
                  cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].ul_cfg_mask = 0;
                  cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].dl_cfg_mask = 0;
                  if((RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_rb_information_reconfig_ptr, 
				  	rrc_RB_InformationReconfig,rlc_Info))
                      &&(RRC_MSG_COMMON_BITMASK_IE(rrc_rb_information_reconfig_ptr->rlc_Info,
                      rrc_RLC_Info,ul_RLC_Mode)))
                  {
                    cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].ul_cfg_mask = MODIFY_RB_CFG;
                  }
                  if((RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_rb_information_reconfig_ptr, rrc_RB_InformationReconfig,rlc_Info))
                      &&(RRC_MSG_COMMON_BITMASK_IE(
                      rrc_rb_information_reconfig_ptr->rlc_Info,rrc_RLC_Info,dl_RLC_Mode)))
                  {
                    cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].dl_cfg_mask = MODIFY_RB_CFG;
                  }
                  if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_rb_information_reconfig_ptr,rrc_RB_InformationReconfig,
				  	rb_StopContinue))
                  {
                    if (rrc_rb_information_reconfig_ptr->rb_StopContinue == rrc_RB_StopContinue_stopRB)
                    {
                      cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].ul_cfg_mask |= STOP_RB_CFG;
                      cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].dl_cfg_mask |= STOP_RB_CFG;
                      WRRC_MSG1_HIGH("Stop recvd for RB %d", rrc_rb_information_reconfig_ptr->rb_Identity);
                    }
                    else if (rrc_rb_information_reconfig_ptr->rb_StopContinue == rrc_RB_StopContinue_continueRB)
                    {
                      cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].ul_cfg_mask |= CONTINUE_RB_CFG;
                      cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].dl_cfg_mask |= CONTINUE_RB_CFG;

                      WRRC_MSG1_HIGH("Continue recvd for RB %d", rrc_rb_information_reconfig_ptr->rb_Identity);
                    }
                  }
                  /* Advance the Linked List pointer */
                  rb_idx++;

                  no_of_RBs++;

                } while(cell_update_confirm->rb_InformationReconfigList.n > rb_idx);
              }
              if(RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm,
                 rrc_CellUpdateConfirm_r3_IEs,rb_InformationAffectedList))
              {
                /* Save the head pointer of linked list */
                rrc_rb_information_affected_list = 
                  &cell_update_confirm->rb_InformationAffectedList;
                rb_idx=0;
                do
                { 
                  cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].rb_id = 
                  rrc_rb_information_affected_list->elem[rb_idx].rb_Identity;

                  cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].rb_config = RECONFIG_RB;
                  cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].rb_config = RECONFIG_RB_OTA;
                  cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].ul_cfg_mask = cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].dl_cfg_mask = MODIFY_RB_CFG;
                  /* Advance the Linked List pointer */
                  rb_idx++;

                  no_of_RBs++;

                }while(rrc_rb_information_affected_list->n > rb_idx);
              }

              cmd_ptr->cmd.chan_config_req.num_rb_to_config =(int) no_of_RBs;
              rrc_fill_rb_id_chan_req_from_standalone_db(&no_of_RBs, &cmd_ptr->cmd.chan_config_req);

              if(rrccu_state_indicator == rrc_RRC_StateIndicator_cell_DCH)
              {
                /* Fill those RBs in chan_config_req for which RLC PDU size has changed and 
                that are already not present in chan_config_req*/
                rrc_fill_rb_id_chan_req_from_rb_list_mapped_to_dch(&no_of_RBs, 
                              &cmd_ptr->cmd.chan_config_req);
              }
              /*If state transition is Cell_FACH->Cell_DCH, add all the existing AM  
              PS RBs in chan_config_req*/
              if((rrc_get_state() == RRC_STATE_CELL_FACH) && 
                            (rrccu_state_indicator == rrc_RRC_StateIndicator_cell_DCH))
              {
                rrc_fill_rb_id_chan_req_from_est_rabs(&no_of_RBs, 
                              &cmd_ptr->cmd.chan_config_req);
                rrc_fill_srb_in_chan_config_req(&no_of_RBs,&cmd_ptr->cmd.chan_config_req);
              }

              cmd_ptr->cmd.chan_config_req.chan_config_reason = RRCLLC_CHAN_CFG_REASON_NONE;


              /*call the function that evaluates the directed cell info and set the flags accordingly */
              if ((rrc_RRC_StateIndicator_cell_FACH == rrccu_state_indicator) &&
                  (rrcrb_validate_directed_cell_info (directed_cell_info) == FALSE))
              {
                if(rrccsp_check_initiate_cell_selection_handling(NULL) == FALSE)
                {
                  rrccu_cu_initiate_reqd.cu_reqd = TRUE;
                  rrccu_cu_initiate_reqd.cu_cause = rrc_CellUpdateCause_cellReselection;
                  WRRC_MSG1_HIGH("CHANNEL_CONFIG_REQ for %dRBs",no_of_RBs);
                  rrc_put_int_cmd(cmd_ptr);                 /* sends the command to RRC
                                                             LLC. */
                  rrccu_substate = RRCCU_WAIT_FOR_RB_EST_CNF;         
                }
                else
                {
                  rrccu_intiate_cell_selection_within_fach_cu_cnf(cmd_ptr);
                  cmd_ptr = NULL;
                }
              }
              else
              {
                WRRC_MSG1_HIGH("CHANNEL_CONFIG_REQ for %dRBs",no_of_RBs);
                rrc_put_int_cmd(cmd_ptr);                 /* sends the command to RRC
                                                             LLC. */
                rrccu_substate = RRCCU_WAIT_FOR_RB_EST_CNF;         
              }

            if( RRC_MSG_COMMON_BITMASK_IE_PTR(cell_update_confirm, 
                rrc_CellUpdateConfirm_r3_IEs,cn_InformationInfo))
            {
              (void) rrc_ccm_send_nas_cn_info(
                         &(cell_update_confirm->cn_InformationInfo)
                        ,primary_plmn_Id_present
                        ,&primary_plmn_Identity
                 );
            } 
          }
          break;

        case ORDERED_CONFIG_INCOMPATABLE_SIMULTANEOUS_RECONFIG:
         /* Set the Transaction Id */
          rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;

          /* Set Failure cause */
          rrccu_failure_cause.failureCause.t = 
            T_rrc_FailureCauseWithProtErr_incompatibleSimultaneousReconfiguration;
 

          rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
          break;

        case ORDERED_CONFIG_CONFIGURATION_NOT_SUPPORTED:
          /* Set the Transaction Id */
          rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;

          /* Set Failure cause */
          rrccu_failure_cause.failureCause.t = 
            T_rrc_FailureCauseWithProtErr_configurationUnsupported;
    

          rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
          break;

        case ORDERED_CONFIG_NOT_SET_OTHER:
          /* For Cell Update Confirm message RRC LLC should never
             set Ordered Config */
          WRRC_MSG0_ERROR("Ordered Config Should not return this status");
          break;

        case ORDERED_CONFIG_CONFIGURATION_INVALID:
          /* Set the Transaction Id */
          rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;

          /* Set Failure cause */
          rrccu_failure_cause.failureCause.t = 
            T_rrc_FailureCauseWithProtErr_invalidConfiguration;
 

          rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
          break;

        default:
          WRRC_MSG0_ERROR("Invalid status from ORDERED_CONFIG");
          break;
      } 
    }  
  }
} /* rrccu_process_cell_update_confirm*/

/*===========================================================================

FUNCTION rrccu_validate_rel_rb_exist_in_reconfig_list_r5

DESCRIPTION
  This function checks if the Cu Cnf has the same RB ID in the RB Release list
   and also in RB Reconfig/RB Affected List
  
DEPENDENCIES
  None

RETURN VALUE
  True, if same RB ID is present in RB Release list and also in RB Reconfig/RB Affected List
  else
  FALSE
  
SIDE EFFECTS

  None

===========================================================================*/
static boolean rrccu_validate_rel_rb_exist_in_reconfig_list_r5
(
  rrc_CellUpdateConfirm_r5_IEs * cu_confirm_ptr
)
{
  rrc_RB_Identity released_rb_id= 0xFF;
  rrc_RB_InformationReleaseList *rrc_rb_information_release_list;
                                            /* Local pointer to preserve the
                                               head of linked list */  
  rrc_RB_InformationReconfig_r5 *rrc_rb_information_reconfig_ptr; 
  
  rrc_RB_InformationAffectedList_r5 *rrc_rb_information_affected_list; 
  uint32 idx=0,idy=0;
    /* Save the linked list head pointer */ 
  rrc_rb_information_release_list = 
      &cu_confirm_ptr->rb_InformationReleaseList;
  
  while(rrc_rb_information_release_list->n > idx)
  { 
  
    released_rb_id =rrc_rb_information_release_list->elem[idx];
    if(RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr,
             rrc_CellUpdateConfirm_r5_IEs,rb_InformationReconfigList))
    {
      idy=0;
 
      do
      { 
           /* Save the linked list head pointer */
        rrc_rb_information_reconfig_ptr = 
          &cu_confirm_ptr->rb_InformationReconfigList.elem[idy];
        /* Check whether rb id in rb reconfig list is in the established rabs list.  If not set msg_not_valid variable
             to true to resend cell update msg with failure cause  */
        if (rrc_rb_information_reconfig_ptr->rb_Identity == released_rb_id  )
        {
          /* RB Message was invalid. */
          WRRC_MSG1_ERROR(" RB id:%d in rb_InformationReconfigList  and RB Release list of CUCnf Msg",
             rrc_rb_information_reconfig_ptr->rb_Identity );
          return TRUE;
        }
                 
        /* Advance the Linked List pointer */
        idy++;
      }while(cu_confirm_ptr->rb_InformationReconfigList.n > idy);
    }
  
    if(RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr,
        rrc_CellUpdateConfirm_r5_IEs,rb_InformationAffectedList))
    {
      /* Save the head pointer of linked list */
      rrc_rb_information_affected_list = 
       &cu_confirm_ptr->rb_InformationAffectedList;
	  idy=0;
      do
      { 
        /* Check whether rb id in rb affected list is in the established rabs list.  If not set msg_not_valid variable
        to true to resend cell update msg with failure cause  */
        if (rrc_rb_information_affected_list->elem[idy].rb_Identity == released_rb_id )
        {
          /* RB Message was invalid. */
          WRRC_MSG1_ERROR(" RB id:%d in rb_InformationAffectedList  and RB Release list of CUCnf Msg",
             rrc_rb_information_affected_list->elem[idy].rb_Identity );
          return TRUE;
        }
        /* Advance the Linked List pointer */
        idy++;
        
      } while(cu_confirm_ptr->rb_InformationAffectedList.n > idy);
    }
     
    idx++;
  } 
  
  return FALSE;
}
/*===========================================================================

FUNCTION RRCCU_PROCESS_CELL_UPDATE_CONFIRM_R5

DESCRIPTION
  This function processes the REl 5 CELL UPDATE CONFIRM message received in response to
  Cell Update message.
  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
static void rrccu_process_cell_update_confirm_r5
(    
  void *msg_ptr,                              /* Pointer to Downlink Msg */
  uint32 dl_sdu_type                          /* Downlink SDU type */
)
{
  rrc_cmd_type *cmd_ptr;                      /* Pointer to the RRC Command */
  rrc_cmd_type *int_cmd_ptr;                      /* Pointer to the RRC Command */
  uint32 no_of_RBs;                           /* Local variable to store no
                                                of RBs */
  boolean msg_not_valid      = FALSE;         /* boolean to indicate msg validity */
  rrc_int_c_rnti_type crnti;                  /* Local variable for C-RNTI */
  rrc_int_u_rnti_type urnti;                  /* Local variable for U-RNTI */
  rrc_CellUpdateConfirm_r5_IEs *cu_confirm_ptr = NULL;
   
  rrc_DL_CCCH_Message *ccch_msg_ptr = NULL;          /* Pointer to Downlink CCCH Msg */
  rrc_DL_DCCH_Message *dcch_msg_ptr = NULL;          /* Pointer to Downlink DCCH Msg */
 
  rrc_state_e_type state ;                    /* Local varible to store state */

  rrcllc_oc_status_e_type status;             /* Local var to store Ordered Config
                                                 status */
  rrc_RB_InformationReleaseList *rrc_rb_information_release_list;
                                              /* Local pointer to preserve the
                                                 head of linked list */  
  rrc_RB_InformationReconfig_r5 *rrc_rb_information_reconfig_ptr; 

  rrc_RB_InformationAffectedList_r5 *rrc_rb_information_affected_list; 

#ifdef FEATURE_UMTS_PDCP
  rrc_HeaderCompressionInfo_r4 *pdcpHeaderCompressionInfoptr = NULL;  
#endif /* FEATURE_UMTS_PDCP*/

  rlc_lc_id_type                          lc_id;
  uecomdef_logch_mode_e_type              lc_mode;
  uint32 rb_idx=0;

   /*Boolean used to indicate primary plmn i.d is present in OTA msg*/
  boolean primary_plmn_Id_present = FALSE;
   /*Variable to hold primary plmn i.d if present in OTA msg*/
  rrc_PLMN_Identity primary_plmn_Identity;
   /*ptr for CUC OTA msg*/
  rrc_CellUpdateConfirm_CCCH *cuc_ccch_msg_ptr = NULL;
  rrc_CellUpdateConfirm *cuc_dcch_msg_ptr = NULL;

  uecomdef_status_e_type hs_valid_status = SUCCESS;
  rrcrb_directed_cell_info_type          directed_cell_info; /* directed cell info struct */

  if( dl_sdu_type == rrc_DL_CCCH_Message_PDU)
  {
    ccch_msg_ptr = (rrc_DL_CCCH_Message *) msg_ptr;
    cu_confirm_ptr = &ccch_msg_ptr->message.u.cellUpdateConfirm.u.later_than_r3.
      criticalExtensions.u.criticalExtensions.u.r5.cellUpdateConfirm_r5;

    cuc_ccch_msg_ptr = &ccch_msg_ptr->message.u.cellUpdateConfirm;
   
    /* Update Transaction id */
    rrccu_trans_id = ccch_msg_ptr->message.u.cellUpdateConfirm.u.later_than_r3.rrc_TransactionIdentifier;
  }
  else if( dl_sdu_type == rrc_DL_DCCH_Message_PDU)
  {
    dcch_msg_ptr = (rrc_DL_DCCH_Message *) msg_ptr;
    cu_confirm_ptr = &dcch_msg_ptr->message.u.cellUpdateConfirm.u.later_than_r3.
      criticalExtensions.u.criticalExtensions.u.r5.cellUpdateConfirm_r5;

    cuc_dcch_msg_ptr = &dcch_msg_ptr->message.u.cellUpdateConfirm;
   
    /* Update Transaction id */
    rrccu_trans_id = dcch_msg_ptr->message.u.cellUpdateConfirm.u.later_than_r3.rrc_TransactionIdentifier;
  }
  else
  {
    ERR_FATAL("Invalid DL_SDU_TYPE %d", dl_sdu_type,0,0);
  }
    
  /*If this is a CU confirm DCCH/CCCH msg then check to see if primary 
    PLMN I.D is present from DCCH/CCCH msg ptr*/
  primary_plmn_Id_present = rrccu_check_and_get_primary_plmn_id(cuc_dcch_msg_ptr,
                                                                cuc_ccch_msg_ptr,
                                                                &primary_plmn_Identity,
                                                                dl_sdu_type,
                                                                MSG_REL5);
  
  /* enter idle if both timers are marked as expired */
  if ((rrccu_rl_failure_info.t314_info.timer_status == RE_EST_TIMER_EXPIRED) &&
      (rrccu_rl_failure_info.t315_info.timer_status == RE_EST_TIMER_EXPIRED))
  {
    /* Since both T314 and T315 are expired, bring down RRC Connection */
      rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                           RRC_TX_TO_DISCON_OTHER);
      /* Update the release cause */
      rrc_release_cause = RRC_REL_DEEP_FADE;
      rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
      WRRC_MSG0_HIGH("RRC Conn Released since T314=0 & T315=0");
    return;
  }

  /* Update state Indicator */   
  rrccu_state_indicator = cu_confirm_ptr->rrc_StateIndicator;


  /* check whether new CRNTI is present in the message or not when there is
  no valid C-RNTI is existing and next state indicated by the message is 
  CELL_FACH */
  if ((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_FACH) ||
     (((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH) || (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH)) &&
     (RRCCU_NO_RESP_MSG != rrccu_find_response_to_cell_update_confirm_r5(msg_ptr, dl_sdu_type))))
  {
    if ((C_RNTI_NOT_VALID == rrcllc_get_current_crnti_status()) &&
        ((RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, rrc_CellUpdateConfirm_r5_IEs,new_C_RNTI)) == 0 ))
    {
      if(((rrcllc_get_toc_usage() == TOC_FOR_OOS)
              || (rrcllc_get_toc_usage() == TOC_FOR_OOS_WITHOUT_DCH_INFO)
              || (rrcllc_get_toc_usage() == TOC_FOR_OOS_WITH_DCH_INFO)

      ) && 
         (rrcrb_get_new_crnti_valid() && rrccsp_is_selected_cell_utran_directed()))
      {
        WRRC_MSG0_HIGH("Crnti present in reconfig msg");
      }
      else
      {

        WRRC_MSG1_ERROR("No CRNTI for next_st:%d", rrccu_state_indicator);
        /* Update the cause to re-selection as the Cell upate cause should
              indicate re-selection in case of No CRNTI
              */
        rrccu_cell_update_cause = rrc_CellUpdateCause_cellReselection;		
        rrc_cu_uu_log_event_failure_cause = RRC_CU_UU_INVALID_CONFIG;
        rrccu_resend_cell_update_msg(RRCCU_NOT_INCLUDE_FAILURE_CAUSE);
        /* continue with rrccu state  RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM */
        return;
      }
    }
  }

#ifdef FEATURE_WCDMA_HS_FACH
  /*RNTI validation for HS-FACH and HS-RACH*/
  if(TRUE == rrccu_check_rnti_for_resending_cu(
               RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, rrc_CellUpdateConfirm_r5_IEs,new_H_RNTI),
               FALSE, MSG_REL5,
               rrccu_find_response_to_cell_update_confirm_r5(cu_confirm_ptr,dl_sdu_type)))
  {
    rrccu_cell_update_cause = rrc_CellUpdateCause_cellReselection;
    rrc_cu_uu_log_event_failure_cause = RRC_CU_UU_INVALID_CONFIG;
    rrccu_resend_cell_update_msg(RRCCU_NOT_INCLUDE_FAILURE_CAUSE);
    return;
  }
#endif

  if ((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH) ||
      (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH))
  {
    if (!(RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
          rrc_CellUpdateConfirm_r5_IEs,utran_DRX_CycleLengthCoeff)))
    {
      WRRC_MSG0_ERROR("UTRAN DRX is not present");
      
      /* set the invalid msg flag */
      msg_not_valid = TRUE;

    }
    else
    {
      /* store it in a variable */
      rrccu_utran_drx_coef = cu_confirm_ptr->utran_DRX_CycleLengthCoeff;
    }
       /*resend the cell update message if there is any invalid config*/
    if  (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH)
    {
      if (!(RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
            rrc_CellUpdateConfirm_r5_IEs,ura_Identity)))
      {
        WRRC_MSG0_HIGH("URA-id is not present");
        rrccu_clear_ura_id();
      }
      /* update rrccu procedure with new URA-id */
      else
      {
        /*URA ID present in the message set ura_identity variable with this value */
        if (cu_confirm_ptr->ura_Identity.numbits == 16)
        {
          /*rrccu_translate_ura_id (&(msg_ptr->u.r3.radioBearerReconfiguration_r3.ura_Identity));*/
          rrccu_update_ura_id (&(cu_confirm_ptr->ura_Identity));
        }
        else
        {
          WRRC_MSG1_ERROR("Invalid URA ID length%d",
              cu_confirm_ptr->ura_Identity.numbits);
          /* set the invalid msg flag */
          msg_not_valid = TRUE;
        }
      }
        
    }
  }
  
#ifdef FEATURE_WCDMA_HS_FACH
  if(cu_confirm_ptr->m.new_H_RNTIPresent)
  {
    if(rrccu_update_hrnti_from_ota(&cu_confirm_ptr->new_H_RNTI,transition_config.toc_ptr) == FAILURE)
    {
      WRRC_MSG0_ERROR("HRNTI invalid");
      msg_not_valid = TRUE;
    }
  }
  
#endif



  if(RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr,
               rrc_CellUpdateConfirm_r5_IEs,rb_InformationReconfigList))
  {
    do
    { 
        /* Save the linked list head pointer */
      rrc_rb_information_reconfig_ptr = 
      &cu_confirm_ptr->rb_InformationReconfigList.elem[rb_idx];
      /* Check whether rb id in rb reconfig list is in the established rabs list.  If not set msg_not_valid variable
         to true to resend cell update msg with failure cause  */
      if (RRC_RB_NOT_PRESENT == validate_rb_id_in_reconfig_list(rrc_rb_information_reconfig_ptr->rb_Identity))
      {
        /* RB Message was invalid. */
        WRRC_MSG1_HIGH("Invalid RB id:%d in rb_InformationReconfigList of CUCnf Msg",rrc_rb_information_reconfig_ptr->rb_Identity );
        msg_not_valid = TRUE;
        break;
      }

      if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_rb_information_reconfig_ptr, 
          rrc_RB_InformationReconfig_r5,rb_StopContinue))
      {
        if ((rrc_rb_information_reconfig_ptr->rb_Identity) <= 2)
        {
          msg_not_valid = TRUE;
          break;
        }
        
        lc_id = rrclcm_get_ul_rlc_lc_id(rrc_rb_information_reconfig_ptr->rb_Identity);
        
        if (lc_id == RRCLCM_RLC_LC_ID_NOT_FOUND)
        {
          msg_not_valid = TRUE;
          WRRC_MSG1_ERROR("No corresponding LC id for the RB %d",(rrc_rb_information_reconfig_ptr->rb_Identity));
          break;
        }
        else if (rrclcm_get_ul_rlc_mode(lc_id, &lc_mode) == RRCLCM_FAILURE)
        {
          msg_not_valid = TRUE;
          WRRC_MSG1_ERROR("Invalid lc_mode for RB %d",rrc_rb_information_reconfig_ptr->rb_Identity);
          break;
        }
        else if (lc_mode == UE_MODE_TRANSPARENT)
        {
          msg_not_valid = TRUE;
          WRRC_MSG2_ERROR("Transparent mode RB %d lc_id %d can't be stopped/contd",(uint16)(rrc_rb_information_reconfig_ptr->rb_Identity),lc_id);
          break;
        }
      }

#ifdef FEATURE_UMTS_PDCP
      if (rrc_pdcp_enabled)  
      { 
        if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_rb_information_reconfig_ptr, rrc_RB_InformationReconfig_r5,pdcp_SN_Info)) 
        {
          msg_not_valid = TRUE;
          WRRC_MSG0_HIGH("Invalid: PDCP SN info not supported CU CNF");
          break;
        }
        
        if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_rb_information_reconfig_ptr, rrc_RB_InformationReconfig_r5,pdcp_Info)) 
        {
          /* Validate PDCP info */
          if (rrc_get_rab_type_for_given_rb_id(rrc_rb_information_reconfig_ptr->rb_Identity) !=
              RRCRB_PS_DATA_RAB)
          {
            WRRC_MSG1_HIGH("NW incld PDCP info for non-ps rb id %d: Invalid",
                     rrc_rb_information_reconfig_ptr->rb_Identity);
            msg_not_valid = TRUE;
            break;
          }
          
          if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_rb_information_reconfig_ptr, rrc_RB_InformationReconfig_r5,pdcp_Info))
          {
            /* check whether lossless SRNS relocation flag is set or   
             * and header compression algo is present in the message 
             */
            if ((RRC_MSG_COMMON_BITMASK_IE(rrc_rb_information_reconfig_ptr->pdcp_Info.pdcp_Info,
                 rrc_PDCP_Info_r4,losslessSRNS_RelocSupport)) && 
                (RRC_CHECK_COMMON_MSG_TYPE(rrc_rb_information_reconfig_ptr->pdcp_Info.pdcp_Info.losslessSRNS_RelocSupport,
                 rrc_LosslessSRNS_RelocSupport_supported)))
            {
              if (rrc_rb_information_reconfig_ptr->pdcp_Info.pdcp_Info.pdcp_PDU_Header == rrc_PDCP_PDU_Header_absent)
              {
                WRRC_MSG0_HIGH("PDCP pdu header is absent.  Invalid config");
                msg_not_valid = TRUE;
                break;
              }
           
            } /* if rrc_PDCP_Info_r4_losslessSRNS_RelocSupport_present */
          }

          if (rrc_rb_information_reconfig_ptr->pdcp_Info.pdcp_Info.pdcp_PDU_Header == rrc_PDCP_PDU_Header_present)
          {
            if ((RRC_MSG_COMMON_BITMASK_IE(rrc_rb_information_reconfig_ptr->pdcp_Info.pdcp_Info,
                 rrc_PDCP_Info_r4,losslessSRNS_RelocSupport)) && 
                (RRC_CHECK_COMMON_MSG_TYPE(rrc_rb_information_reconfig_ptr->pdcp_Info.pdcp_Info.losslessSRNS_RelocSupport,
                 rrc_LosslessSRNS_RelocSupport_notSupported)))
            {
              if (!(RRC_MSG_COMMON_BITMASK_IE(rrc_rb_information_reconfig_ptr->pdcp_Info.pdcp_Info,
                  rrc_PDCP_Info_r4,headerCompressionInfoList)) )
              {
                WRRC_MSG0_HIGH("PDCP header compress info list not present");
                msg_not_valid = TRUE;
                break;
              }
            }
          }
          
          if (RRC_MSG_COMMON_BITMASK_IE(rrc_rb_information_reconfig_ptr->pdcp_Info.pdcp_Info,
		  	rrc_PDCP_Info_r4,headerCompressionInfoList)) 
          {
            uint32 local_idx =0;
            while (rrc_rb_information_reconfig_ptr->pdcp_Info.pdcp_Info.headerCompressionInfoList.n > local_idx) 
            {
              pdcpHeaderCompressionInfoptr = &rrc_rb_information_reconfig_ptr->pdcp_Info.pdcp_Info.headerCompressionInfoList.elem[local_idx];
              if (RRC_CHECK_COMMON_MSG_TYPE(pdcpHeaderCompressionInfoptr->algorithmSpecificInfo,
                  rrc_AlgorithmSpecificInfo_r4_rfc2507_Info))
              {
                /* if the UE capability "Maximum header compression context space", is exceeded with this configuration send
                 * failure with cause "Invalid Config"
                 */
                if ( (pdcpHeaderCompressionInfoptr->algorithmSpecificInfo.u.rfc2507_Info->max_HEADER > IPHC_MAX_HC_CONTEXT_SPACE))
                {
                  WRRC_MSG1_HIGH("Max header comprss context space exceeded : %d",
                           pdcpHeaderCompressionInfoptr->algorithmSpecificInfo.u.rfc2507_Info->max_HEADER);
                  msg_not_valid = TRUE;
                  break;
                }
              }
              else if (pdcpHeaderCompressionInfoptr->algorithmSpecificInfo.t == 
                       T_rrc_AlgorithmSpecificInfo_r4_rfc3095_Info)
              {
                /*  the chosen MAX_CID shall not be greater than the value "Maximum number of ROHC context sessions" as 
                 *  indicated in the IE "PDCP Capability"
                 */
                if (pdcpHeaderCompressionInfoptr->algorithmSpecificInfo.u.rfc3095_Info->m.ul_RFC3095Present)
                {
                  if (pdcpHeaderCompressionInfoptr->algorithmSpecificInfo.u.rfc3095_Info->ul_RFC3095.max_CID > ROHC_MAX_CONTEXT_SESSIONS)
                  {
                    WRRC_MSG1_HIGH("Invalid config.  MAX_CID %d is invalid",
                             pdcpHeaderCompressionInfoptr->algorithmSpecificInfo.u.rfc3095_Info->ul_RFC3095.max_CID);
                    msg_not_valid = TRUE;
                    break;
                  }
                }
                
                if (pdcpHeaderCompressionInfoptr->algorithmSpecificInfo.u.rfc3095_Info->m.dl_RFC3095Present)
                {
                  if (pdcpHeaderCompressionInfoptr->algorithmSpecificInfo.u.rfc3095_Info->dl_RFC3095.max_CID > ROHC_MAX_CONTEXT_SESSIONS)
                  {
                    WRRC_MSG1_HIGH("Invalid config.  MAX_CID %d is invalid",
                             pdcpHeaderCompressionInfoptr->algorithmSpecificInfo.u.rfc3095_Info->dl_RFC3095.max_CID);
                    msg_not_valid = TRUE;
                    break;
                  }
                }

              }/* else if (pdcpHeaderCompressionInfoptr->algorithmSpecificInfo.t == rrc_rfc3095_Info)*/

              local_idx++;
            } /*  while (pdcpHeaderCompressionInfoList) */
          } /*  if (rb_list_ptr->value.pdcp_Info.pdcp_Info.bit_mask & rrc_PDCP_Info_r4_headerCompressionInfoList)) */         
        }
      }
#endif /* FEATURE_UMTS_PDCP */

      /* Advance the Linked List pointer */
      rb_idx++;
    } while(cu_confirm_ptr->rb_InformationReconfigList.n > rb_idx) ;
  }
  
  
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr,
     rrc_CellUpdateConfirm_r5_IEs,rb_InformationReleaseList))
  {
    /* Save the linked list head pointer */ 
    rrc_rb_information_release_list = 
      &cu_confirm_ptr->rb_InformationReleaseList;
    rb_idx=0;
    do
    { 
      /* Check whether rb id in rb release list is in the established rabs list.  If not set msg_not_valid variable
         to true to resend cell update msg with failure cause  */
      if (RRC_RB_NOT_PRESENT == validate_rb_id_in_release_list(rrc_rb_information_release_list->elem[rb_idx]))
      {
        /* RB Message was invalid. */
        WRRC_MSG1_HIGH("Invalid RB id:%d in rb_InformationReleaseList of CUCnf Msg",rrc_rb_information_release_list->elem[rb_idx] );
        msg_not_valid = TRUE;
        break;
      }      
      rb_idx++;
    } while(rrc_rb_information_release_list->n > rb_idx);
    
    
  }
  
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr,
     rrc_CellUpdateConfirm_r5_IEs,rb_InformationAffectedList))
  {
    /* Save the head pointer of linked list */
    rrc_rb_information_affected_list = 
      &cu_confirm_ptr->rb_InformationAffectedList;
	rb_idx=0;
    do
    { 
      /* Check whether rb id in rb affected list is in the established rabs list.  If not set msg_not_valid variable
      to true to resend cell update msg with failure cause  */
      if (RRC_RB_NOT_PRESENT == validate_rb_id_in_reconfig_list(rrc_rb_information_affected_list->elem[rb_idx].rb_Identity))
      {
        /* RB Message was invalid. */
        WRRC_MSG1_HIGH("Invalid RB id:%d in rb_InformationAffectedList of CUCnf Msg",rrc_rb_information_affected_list->elem[rb_idx].rb_Identity );
        msg_not_valid = TRUE;
        break;
      }
      /* Advance the Linked List pointer */
      rb_idx++;
      
    } while(rrc_rb_information_affected_list->n > rb_idx);
  }

  if((msg_not_valid == FALSE) && (RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr,
     rrc_CellUpdateConfirm_r5_IEs,rb_InformationReleaseList))
     && ((RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr,
               rrc_CellUpdateConfirm_r5_IEs,rb_InformationReconfigList)) ||
       (RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr,
     rrc_CellUpdateConfirm_r5_IEs,rb_InformationAffectedList))   ))
  {
    msg_not_valid = rrccu_validate_rel_rb_exist_in_reconfig_list_r5(cu_confirm_ptr);
  }
    
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, rrc_CellUpdateConfirm_r5_IEs,dl_HSPDSCH_Information))
  {
    WRRC_MSG0_HIGH("RRCHS:HSPDSCH Info present");
    
    /* Check if network does not try to initiate HSDPA with invalid state */
    hs_valid_status = rrc_hsdpa_initial_validation(cu_confirm_ptr->rrc_StateIndicator,
    				(RRC_CHECK_MSG_TYPE(cu_confirm_ptr->dl_HSPDSCH_Information.modeSpecificInfo,
                      T_rrc_DL_HSPDSCH_Information_modeSpecificInfo_tdd))
      					);
    if (hs_valid_status == FAILURE)
    {
      WRRC_MSG0_ERROR("Invalid HSDPA Info specified");
      msg_not_valid = TRUE;
    }
  }

  if (msg_not_valid)
  {
    WRRC_MSG0_HIGH("Invalid Configurartion in CUCnf Msg.  Resending Cell Update");
    /* Set the Transaction Id */
    rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;

    /* Set Failure cause */
    rrccu_failure_cause.failureCause.t = 
      T_rrc_FailureCauseWithProtErr_invalidConfiguration;

    rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
    /* continue with rrccu state  RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM */
    return;
  }
  /* Populate the local variables to indicate if Re-direction info is present */
  directed_cell_info.freq_info_present = FALSE;
  directed_cell_info.pscr_present = FALSE;
  if(   (rrccu_state_indicator ==rrc_RRC_StateIndicator_cell_FACH)
         || (rrccu_state_indicator==rrc_RRC_StateIndicator_cell_PCH)
         || (rrccu_state_indicator==rrc_RRC_StateIndicator_ura_PCH))
  {
    if((RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
        rrc_CellUpdateConfirm_r5_IEs,frequencyInfo)) &&
       (RRC_CHECK_COMMON_MSG_TYPE(cu_confirm_ptr->frequencyInfo.modeSpecificInfo,
       rrc_FrequencyInfo_modeSpecificInfo_fdd)))
    {
      directed_cell_info.freq_info_present = TRUE;
      directed_cell_info.uarfcn_dl         = cu_confirm_ptr->frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_DL;
    }
    
    if ((RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, rrc_CellUpdateConfirm_r5_IEs,dl_InformationPerRL_List))
        &&(cu_confirm_ptr->dl_InformationPerRL_List.elem[0].modeSpecificInfo.t ==
         T_rrc_DL_InformationPerRL_r5_modeSpecificInfo_fdd))
    {
      WRRC_MSG1_HIGH("Primary SCR in CU Cnf  r5 message %d",
           cu_confirm_ptr->dl_InformationPerRL_List.elem[0].modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode);
      directed_cell_info.pscr_present = TRUE;
      directed_cell_info.pscr = cu_confirm_ptr->dl_InformationPerRL_List.elem[0].modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode;
    } 
  }

  /*call the function that evaluates the directed cell info and set the flags accordingly */
  if ((rrc_RRC_StateIndicator_cell_FACH == rrccu_state_indicator) &&
     (rrcrb_validate_directed_cell_info (directed_cell_info) == FALSE))
  {
    /* If UE still has to send a response to the previous Cu Cnf with directed info
     * and it receives another Cu Cnf with directed info, then send failure
     * If the previous Cu Cnf had directed info, then atleast a PCRC Complete
     * has to be pending as a response.
     */
    if( rrccu_int_data.rrccu_cell_selection_last_response_msg != RRCCU_NO_RESP_MSG )
    {
       WRRC_MSG0_ERROR(" Previous Cu Cnf sent a directed info, cannot accept another Cu Cnd with directed info");
       /* Set the Transaction Id */
       rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;
       /* Set Failure cause */
   
       rrccu_failure_cause.failureCause.t = 
         T_rrc_FailureCauseWithProtErr_incompatibleSimultaneousReconfiguration;

   
       rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
       return;
    }
  }
   

  if (RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
      rrc_CellUpdateConfirm_r5_IEs,dl_CounterSynchronisationInfo)) 
  {
    /*check whether PDCP info is present in the dl counter sync info */
    if ((RRC_MSG_COMMON_BITMASK_IE_TYPE2(cu_confirm_ptr->dl_CounterSynchronisationInfo,
        rb_WithPDCP_InfoList)) ||
        (RRC_MSG_COMMON_BITMASK_IE(cu_confirm_ptr->dl_CounterSynchronisationInfo,
         rrc_DL_CounterSynchronisationInfo_r5,rb_PDCPContextRelocationList)))
    {
      /* this involves lossless SRNS relocation so re-send cell update 
       message */
      WRRC_MSG0_ERROR("PDCP info not supported");
  
      /* Set the Transaction Id */
      rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;
  
      /* Set Failure cause */
      rrccu_failure_cause.failureCause.t = 
        T_rrc_FailureCauseWithProtErr_configurationUnsupported;
     
  
      rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
      /* continue with rrccu state  RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM */
      return;
    }
    /*UE actions, in case IE "Downlink counter synchronisation info" is included and 
         *either IE "RLC reestablish indicator (RB2, RB3 and RB4)" or IE "RLC re-establish 
         *indicator (RB5 and upwards)" are set to TRUE, are not defined.refer to R2-041019,spec cr-2328
         */
    if((cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4 == TRUE) ||
      (cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove == TRUE))
    {
      /* Set the Transaction Id */
      rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;
    
      /* Set Failure cause */
      rrccu_failure_cause.failureCause.t = T_rrc_FailureCauseWithProtErr_configurationUnsupported;

    
      WRRC_MSG0_ERROR("UE doesn't support simultaneous RLC Re_est & S-RNS<R2-041019,spec cr-2328>");
      rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
      /* continue with rrccu state  RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM */
      return;
    }

    /* This is lossy SRNS relocation */
    rrccu_cucnf_for_srns_relocation  = TRUE;
    /* store the new URNTI value if present */
    if (RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, rrc_CellUpdateConfirm_r5_IEs,new_U_RNTI))
    {
      rrccu_new_urnti_valid = TRUE;
      rrc_translate_urnti (&(cu_confirm_ptr->new_U_RNTI),
                            &rrccu_new_urnti);
    }
  }
  /* check whether rlc-re establishment was require but not indicated in cell update
  confirm message. In such case discard the cucnf and resend cell update message.
  This should also take care of multiple cell updates initiated due to change in cause.
  for ex. periodicall...rlc unrecoverabel error, reselection...rlc unrecoverable error
  rl failure..rlc unrecoverable error */
  if (((rrccu_rlc_error_info.error_on_srb == TRUE) && 
      (cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4 == FALSE)) ||
       ((rrccu_rlc_error_info.error_on_urb == TRUE) && 
      (cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove == FALSE)))
  {
    if (RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
        rrc_CellUpdateConfirm_r5_IEs,dl_CounterSynchronisationInfo)) 
    {
      WRRC_MSG0_HIGH("S-RNS relocation is Implicit rlc_Re_establish");
    }
    else
    {
      rrc_cu_uu_log_event_failure_cause = RRC_CU_UU_INVALID_CONFIG;
      rrccu_resend_cell_update_msg(RRCCU_NOT_INCLUDE_FAILURE_CAUSE);
      /* continue with rrccu state  RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM */
      return;
    }
  }

  rrccu_resp_msg = rrccu_find_response_to_cell_update_confirm_r5(msg_ptr, dl_sdu_type);
  /* If CUC doesnt set OC, validate if the existing ehs queues are holding a proper window size */
  /* Calling 'rrcllc_validate_hs_ehs_window_size_for_sec' directly without checking for 
     num of carriers. As CUC doesnt set OC, num sec carriers is anyways 0. We can reject CUC
     if window size is > 32 */
 /*  Note: directed_cell_info.freq_info_present and directed_cell_info.pscr_present will always be FALSE 
     for NO RSP and UMIC response. Added those conditions to just maintain the code consistency. 
     These conditions doesnt impact the logics. If these conditions are redundant, we can remove
     such condition everywhere  */
  if(((RRCCU_NO_RESP_MSG == rrccu_resp_msg)||(RRCCU_UMIC_COMPLETE_RESP_MSG == rrccu_resp_msg)) &&
  	(((directed_cell_info.freq_info_present == FALSE )&& (directed_cell_info.pscr_present == FALSE ))
    ||(rrccu_state_indicator ==rrc_RRC_StateIndicator_cell_DCH)))
  {
    if(FALSE == rrcllc_validate_hs_ehs_window_size_for_sec(rrccu_state_indicator))
    {
      rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;
      rrccu_failure_cause.failureCause.t = T_rrc_FailureCauseWithProtErr_invalidConfiguration;
      rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
	  return;
    }
  }

  if(((rrccu_resp_msg != RRCCU_NO_RESP_MSG) && 
      (rrccu_resp_msg != RRCCU_UMIC_COMPLETE_RESP_MSG)) &&
      (rrcllc_get_ordered_config_status_wo_f3() != OC_NOT_SET))
  {
    rrcllc_clear_ordered_config();
  }
  rrc_update_reconfig_waiting_for_l2ack_dch(MAX_NUM_OF_PROCEDURES);


  /* if this cell update was due to RL faiure then stop any re-est timer
  that is running */
  if(((rrccu_cell_update_cause == rrc_CellUpdateCause_radiolinkFailure)||  
      (rrccu_cell_update_cause == rrc_CellUpdateCause_re_enteredServiceArea)||
    (rrccu_cell_update_cause == rrc_CellUpdateCause_rlc_unrecoverableError)) &&
    (rrccu_failure_state == RRC_STATE_CELL_DCH))
  {
    if (rrccu_rl_failure_info.t314_info.timer_status == RE_EST_TIMER_STARTED)
    {
      WRRC_MSG0_HIGH("Stopping T314");
      rrctmr_stop_timer(RRCTMR_T_314_TIMER); 
    }
    if (rrccu_rl_failure_info.t315_info.timer_status == RE_EST_TIMER_STARTED)
    {
      WRRC_MSG0_HIGH("Stopping T315");
      rrctmr_stop_timer(RRCTMR_T_315_TIMER); 
    }
  }
  state = rrc_translate_state_indicator_to_state(rrccu_state_indicator);

#ifdef FEATURE_WCDMA_HS_FACH
    if (rrcenhstate_camped_cell_supports_e_fach()&&
        ((rrccu_state_indicator ==rrc_RRC_StateIndicator_cell_FACH)|| 
         (rrccu_state_indicator ==rrc_RRC_StateIndicator_cell_PCH) || 
         (rrccu_state_indicator ==rrc_RRC_StateIndicator_ura_PCH))
       )
    {
      if(RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr,rrc_CellUpdateConfirm_r5_IEs,new_H_RNTI))
      {
        if(((rrccu_resp_msg == RRCCU_UMIC_COMPLETE_RESP_MSG) || (rrccu_resp_msg == RRCCU_NO_RESP_MSG))
        &&((directed_cell_info.freq_info_present == FALSE )&& (directed_cell_info.pscr_present == FALSE )))
        {
          rrcllc_establish_srb_rab_in_efach(RRC_E_FACH_DEDICATED,RRC_PROCEDURE_CU,FALSE);
        }
      }
     }
#endif
  /* In case of Fre-redirection info from FACh->FACH or FACH->PCH the OC 
   * needs to be set force the OC to be set
   */
  if((rrccu_resp_msg == RRCCU_UMIC_COMPLETE_RESP_MSG)
       &&(((directed_cell_info.freq_info_present == FALSE )&&
              (directed_cell_info.pscr_present == FALSE ))
          ||(  rrccu_state_indicator ==rrc_RRC_StateIndicator_cell_DCH))
      )
  {
    if (rrc_get_rlc_size_change_status_for_procedure_id(RRC_PROCEDURE_CU))
    {
      rrcsmc_update_hfn_for_rlc_rb(rlc_size_change_in_progress.rb_id, 
                                   rlc_size_change_in_progress.direction);
    }
    if (! rrccu_cucnf_for_srns_relocation)
    {
      /* procedure does not involve SRNS relocation */

      /* need to send RNTI update request if any of the RNTIs is present
      in the message */
      if ((RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
            rrc_CellUpdateConfirm_r5_IEs,new_C_RNTI)) ||
          (RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr,
           rrc_CellUpdateConfirm_r5_IEs,new_U_RNTI)))
      {
        /* Allocates the buffer to RRC Internal command */
        cmd_ptr =  rrc_get_int_cmd_buf();
        /* Fill parameters for RRC_RNTI_UPDATE_REQ command */
        cmd_ptr->cmd.rnti_update_req.procedure = RRC_PROCEDURE_CU;
        cmd_ptr->cmd_hdr.cmd_id = RRC_RNTI_UPDATE_REQ;

        if (RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
              rrc_CellUpdateConfirm_r5_IEs,new_C_RNTI)) 
        {
          rrc_translate_crnti(&cu_confirm_ptr->new_C_RNTI,&crnti);
          cmd_ptr->cmd.rnti_update_req.crnti_action = RRC_RNTI_UPDATE;
          cmd_ptr->cmd.rnti_update_req.crnti = crnti;
#ifdef FEATURE_WCDMA_HS_RACH
          if(rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH)
          {
            rrchsrach_set_hspa_rnti_stored_cell_pch(ordered_config_ptr,TRUE);
          }
#endif
        }
        else
        {
          cmd_ptr->cmd.rnti_update_req.crnti_action = RRC_RNTI_NOCHANGE;
        }

        if(RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
           rrc_CellUpdateConfirm_r5_IEs,new_U_RNTI))
        {
          rrc_translate_urnti(&cu_confirm_ptr->new_U_RNTI, &urnti);
          cmd_ptr->cmd.rnti_update_req.urnti_action = RRC_RNTI_UPDATE;
          cmd_ptr->cmd.rnti_update_req.urnti= urnti;
        }
        else
        {
          cmd_ptr->cmd.rnti_update_req.urnti_action = RRC_RNTI_NOCHANGE;
        }

        /* Indicate to LLC if RLC for SRBs needs to be re-established */
        if(cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4 == TRUE)
        {
          cmd_ptr->cmd.rnti_update_req.rlc_re_establish_srb = TRUE;
        }
        else
        {
          cmd_ptr->cmd.rnti_update_req.rlc_re_establish_srb = FALSE;
        }

        /* Indicate to LLC if RLC for User plane RBs needs to be re-established */
        if(cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove == TRUE)
        {
          cmd_ptr->cmd.rnti_update_req.rlc_re_establish_rab = TRUE;
        }
        else
        {
          cmd_ptr->cmd.rnti_update_req.rlc_re_establish_rab = FALSE;
        }

        cmd_ptr->cmd.rnti_update_req.cnf_required = TRUE;
        WRRC_MSG2_HIGH("Sending RNTI update req CRNTI_stat:%d, URNTI_stat:%d", 
                  cmd_ptr->cmd.rnti_update_req.crnti_action,
                  cmd_ptr->cmd.rnti_update_req.urnti_action);

        rrc_put_int_cmd(cmd_ptr);       /* sends the command to RRC  LLC. */

        rrccu_substate = RRCCU_WAIT_FOR_RNTI_UPDATE_CNF;         
      }
      else
      {
        if (C_RNTI_NOT_VALID == rrcllc_get_current_crnti_status())
        {
          /* should not come here as this condition is already taken care in downlink
          sdu processing */
          WRRC_MSG1_ERROR("RNTI absent for UMIC message, next state %d", 
                  rrc_get_state());
          /* Set the Transaction Id */
          rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;

          /* Set Failure cause */
          rrccu_failure_cause.failureCause.t = 
            T_rrc_FailureCauseWithProtErr_invalidConfiguration;


          rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
          /* continue with rrccu state  RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM */
          return;
        }
        rrccu_send_response_msg();
      }
      if( RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
          rrc_CellUpdateConfirm_r5_IEs,cn_InformationInfo))
      {
        (void) rrc_ccm_send_nas_cn_info(
                      &(cu_confirm_ptr->cn_InformationInfo)
                      ,primary_plmn_Id_present
                      ,&primary_plmn_Identity
                      );
      } 
    }
    else
    {
      /* procedure involves SRNS relocation so store the C-RNTI
      and send rlc_reestablishment request to SMC . RNTI update 
      will be done after RLC re-establishment*/
      if (RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
            rrc_CellUpdateConfirm_r5_IEs,new_C_RNTI)) 
      {
        rrccu_new_crnti_valid = TRUE;
        rrc_translate_crnti(&cu_confirm_ptr->new_C_RNTI,&rrccu_new_crnti);
#ifdef FEATURE_WCDMA_HS_RACH
        if(rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH)
        {
          rrchsrach_set_hspa_rnti_stored_cell_pch(ordered_config_ptr,TRUE);
        }
#endif
      }
      if(RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
         rrc_CellUpdateConfirm_r5_IEs,new_U_RNTI))
      {
        rrccu_new_urnti_valid = TRUE;
        rrc_translate_urnti(&cu_confirm_ptr->new_U_RNTI,&rrccu_new_urnti);
      }
      /* store the rlc re-establishment indications */
      rrccu_reestablish_srb = cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4;
      rrccu_reestablish_rab = cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove;

      //commit fresh values for srns relocation
      rrcsmc_commit_fresh_for_srns_relocation();

      /*send the rlc re-establishment request to SMC to re-establish SRB2 */
      /* Get the command buffer */
        int_cmd_ptr = rrc_get_int_cmd_buf();
        /* Fill in the command id  */
        int_cmd_ptr->cmd_hdr.cmd_id = RRC_RE_EST_RLC_FOR_SRNS_REQ;
        int_cmd_ptr->cmd.rrc_re_est_srns_req.rrc_proc = RRC_PROCEDURE_CU;
        int_cmd_ptr->cmd.rrc_re_est_srns_req.rb_type  = RRC_RE_EST_RB_2;
        int_cmd_ptr->cmd.rrc_re_est_srns_req.cnf_reqd = TRUE;
        WRRC_MSG1_HIGH("RLC Reestablish req for %d ", 
                 RRC_RE_EST_RB_2); 

        rrc_put_int_cmd(int_cmd_ptr);             

        rrccu_substate = RRCCU_WAIT_FOR_SRB2_RE_EST_CNF;         
        if( RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
            rrc_CellUpdateConfirm_r5_IEs,cn_InformationInfo))
        {
          (void) rrc_ccm_send_nas_cn_info(
                       &(cu_confirm_ptr->cn_InformationInfo)
                      ,primary_plmn_Id_present
                      ,&primary_plmn_Identity
                     );
        } 
      }
  }
  /* In case of Fre-redirection info from FACh->FACH or FACH->PCH the OC 
   * needs to be set force the OC to be set
   */
  else if(( rrccu_resp_msg == RRCCU_NO_RESP_MSG)
           &&(((directed_cell_info.freq_info_present == FALSE )&& 
                  (directed_cell_info.pscr_present == FALSE ))
                || ( rrccu_state_indicator == rrc_RRC_StateIndicator_cell_DCH))
      ) 
  {
    rrccu_check_and_send_response_to_previous_cell_upd_cnf();
    if (cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4 == TRUE || 
        cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove == TRUE)
    {
      cmd_ptr =  rrc_get_int_cmd_buf();

      /* Fill parameters for RRC_RNTI_UPDATE_REQ command */
      cmd_ptr->cmd.rnti_update_req.procedure = RRC_PROCEDURE_CU;
      cmd_ptr->cmd_hdr.cmd_id = RRC_RNTI_UPDATE_REQ;
      cmd_ptr->cmd.rnti_update_req.crnti_action = RRC_RNTI_NOCHANGE;            
      cmd_ptr->cmd.rnti_update_req.urnti_action = RRC_RNTI_NOCHANGE;

      /* Indicate to LLC if RLC for SRBs needs to be re-established */
      if(cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4 == TRUE)
      {
        cmd_ptr->cmd.rnti_update_req.rlc_re_establish_srb = TRUE;
      }
      else
      {
        cmd_ptr->cmd.rnti_update_req.rlc_re_establish_srb = FALSE;
      }
      
      /* Indicate to LLC if RLC for User plane RBs needs to be re-established */
      if(cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove == TRUE)
      {
        cmd_ptr->cmd.rnti_update_req.rlc_re_establish_rab = TRUE;
      }
      else
      {
        cmd_ptr->cmd.rnti_update_req.rlc_re_establish_rab = FALSE;
      }
      
      rrc_put_int_cmd(cmd_ptr);       /* sends the command to RRC  LLC. */
    }
    
    /* if the next state is cell_pch or ura_pch then setup pcch */
    if ((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH) ||
         (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH))
    {
      if( RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
          rrc_CellUpdateConfirm_r5_IEs,cn_InformationInfo))
      {
        (void) rrc_ccm_send_nas_cn_info(
                   &(cu_confirm_ptr->cn_InformationInfo)
                      ,primary_plmn_Id_present
                      ,&primary_plmn_Identity
                 );
      } 
     /*set the UTRAN DRX coef in rrcllc */
      rrcllc_set_utran_drx_info (rrccu_utran_drx_coef); 
      rrccu_establish_pcch_rb (state);
      rrccu_substate = RRCCU_WAIT_FOR_PCCH_RB_EST_CNF;
    }
    else 
    {
      /* Reset the state machine and the procedure ends */
      rrccu_substate = RRCCU_INITIAL;
      /* Start timer T305 */
      rrccu_start_t_305_timer();
      if( RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
          rrc_CellUpdateConfirm_r5_IEs,cn_InformationInfo))
      {
        (void) rrc_ccm_send_nas_cn_info(
                       &(cu_confirm_ptr->cn_InformationInfo)
                      ,primary_plmn_Id_present
                      ,&primary_plmn_Identity
               );
      } 
     /* Inform all registered RRC procedures that Cell
       Update is completed */
      rrccu_inform_cell_update_completed();

      rrccu_process_successful_completion();
     
      /*call the procedure to clear the global variabls */
      rrccu_clear_procedure();
      rrccu_init_last_cu_cnf_info();

    }
  }
  else
  {
    status = rrcllc_set_ordered_config(RRC_PROCEDURE_CU, state, dl_sdu_type, msg_ptr) ;
    switch( status  )
    {
      case ORDERED_CONFIG_SET:
        /* set the flag.Later it will be used while clearing the OC */
        rrccu_oc_set_by_cu = TRUE;

        if ((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH)||
            (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH))
        {

          /*call the function that evaluates the directed cell info and set the flags accordingly */
          if (rrcrb_validate_directed_cell_info (directed_cell_info) == FALSE)
          {
            if(rrccsp_check_initiate_cell_selection_handling(&directed_cell_info) == FALSE)
            {
              rrccu_cu_initiate_reqd.cu_reqd = TRUE;
              rrccu_cu_initiate_reqd.cu_cause = rrc_CellUpdateCause_cellReselection;
            }
            else
            {
              rrccu_int_data.rrccu_cell_selection_trans_from_fach = TRUE;
            }
          }



          if (rrccu_resp_msg == RRCCU_UMIC_COMPLETE_RESP_MSG)
          {
            if (rrc_get_rlc_size_change_status_for_procedure_id(RRC_PROCEDURE_CU))
            {
              rrcsmc_update_hfn_for_rlc_rb(rlc_size_change_in_progress.rb_id, 
                                           rlc_size_change_in_progress.direction);
            }
          }

#ifdef FEATURE_WCDMA_HS_FACH
          
          if((rrcenhstate_camped_cell_supports_e_fach() == TRUE) &&
                        (rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH || rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH))
          {
            if(ordered_config_ptr->efach_hrnti_status == DEDICATED_HRNTI)
            {
              rrcllc_establish_srb_rab_in_efach(RRC_E_FACH_DEDICATED,RRC_PROCEDURE_CU,FALSE);
              
            }
          }
#endif


          /* copy the channel config info in to a local buffer
          we should configure the channels after the response message
          is sent */
          /* Initialize the no of RBs */
          no_of_RBs = 0;
          /* Fill in the command parameters for RRC_CHANNEL_CONFIG_REQ */

          /* Fill in parameters for RRC_CHANNEL_CONFIG_REQ command */
            /* Change the state if it is not CELL_PCH or URA_PCH */

          if(RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr,
             rrc_CellUpdateConfirm_r5_IEs,rb_InformationReleaseList))
          {
            /* set to flag to indicate that rb release information is present
            in the message. This information will be used after channel configu
            ration to release the rbs from established_rab and also to indicate
            to the upper layers about RAB release if necessary */
            rrccu_rb_release_info.rrccu_rb_release_in_cucnf = TRUE;
            /* Save the linked list head pointer */ 
            rrc_rb_information_release_list = 
              &cu_confirm_ptr->rb_InformationReleaseList;
            rb_idx=0;
            while(rrc_rb_information_release_list->n > rb_idx)
            { 
              if( rrc_rb_information_release_list->elem[rb_idx] == DCCH_DT_LOW_PRI_RADIO_BEARER_ID)
              {
                if(RRCLCM_RLC_LC_ID_NOT_FOUND == rrclcm_check_dl_rlc_lc_id(
                                                 UE_LOGCHAN_DCCH,
                                                 DCCH_DT_LOW_PRI_RADIO_BEARER_ID,
                                                 UE_MODE_ACKNOWLEDGED_DATA))
                {
                  WRRC_MSG1_HIGH("Ignore Non-exitent rb_id =%d in cucnf",rrc_rb_information_release_list->elem[rb_idx]);
                  rb_idx++;
                  continue;
                }
              }
              else if(! rrc_find_rb_in_est_rabs((rrc_rb_information_release_list->elem[rb_idx]))) 
              {
                WRRC_MSG1_HIGH("Ignore Non-exitent rb_id =%d in cucnf",rrc_rb_information_release_list->elem[rb_idx]);
                rb_idx++;
                continue;
              }
              else if (MAX_RB != rrccu_check_if_rbid_present_in_rrccu_rb_release_info(rrc_rb_information_release_list->elem[rb_idx],no_of_RBs))
              {
                WRRC_MSG1_ERROR(" Ignoring Duplicate RB ID % d in CU ",rrc_rb_information_release_list->elem[rb_idx]);
                rb_idx++;
                continue;
              }

              WRRC_MSG1_HIGH("Release RB i.d=%d",rrc_rb_information_release_list->elem[rb_idx]);

              rrccu_chan_config_info.rb_info[no_of_RBs].rb_id = 
              rrc_rb_information_release_list->elem[rb_idx];

              rrccu_chan_config_info.rb_info[no_of_RBs].rb_config = RELEASE_RB;

              /* store the rb info to release list in local buffer which will
              be used later to release it from established_rab variable */
              rrccu_rb_release_info.rb_id[no_of_RBs]=rrc_rb_information_release_list->elem[rb_idx];

              /* Advance the Linked List pointer */
              rb_idx++;
              no_of_RBs++;
            }

            rrccu_rb_release_info.num_rbs = no_of_RBs;

            rrcrb_update_mac_rab_status(RRC_PROCEDURE_CU, RRC_CS_DOMAIN_CN_ID,
                                        &cu_confirm_ptr->rb_InformationReleaseList,
                                        FALSE);
          }
          if(RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr,
             rrc_CellUpdateConfirm_r5_IEs,rb_InformationReconfigList))
          {
            rb_idx=0;
            /* Save the linked list head pointer */
            do
            { 
              rrc_rb_information_reconfig_ptr = 
              &cu_confirm_ptr->rb_InformationReconfigList.elem[rb_idx];
            
              rrccu_chan_config_info.rb_info[no_of_RBs].rb_id = 
                      rrc_rb_information_reconfig_ptr->rb_Identity;

              rrccu_chan_config_info.rb_info[no_of_RBs].rb_config = RECONFIG_RB;
              rrccu_chan_config_info.rb_info[no_of_RBs].rb_config = RECONFIG_RB_OTA;
              rrccu_chan_config_info.rb_info[no_of_RBs].ul_cfg_mask = 0;
              rrccu_chan_config_info.rb_info[no_of_RBs].dl_cfg_mask = 0;
              if((RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_rb_information_reconfig_ptr, rrc_RB_InformationReconfig_r5,rlc_Info))
                  &&(RRC_MSG_COMMON_BITMASK_IE(rrc_rb_information_reconfig_ptr->rlc_Info,
                  rrc_RLC_Info_r5,ul_RLC_Mode)))
              {
                rrccu_chan_config_info.rb_info[no_of_RBs].ul_cfg_mask = MODIFY_RB_CFG;
              }
              if((RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_rb_information_reconfig_ptr, rrc_RB_InformationReconfig_r5,rlc_Info))
                  &&(RRC_MSG_COMMON_BITMASK_IE(rrc_rb_information_reconfig_ptr->rlc_Info,
                  rrc_RLC_Info_r5,dl_RLC_Mode)))
              {
                rrccu_chan_config_info.rb_info[no_of_RBs].dl_cfg_mask = MODIFY_RB_CFG;
              }
              if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_rb_information_reconfig_ptr, 
                  rrc_RB_InformationReconfig_r5,rb_StopContinue))
              {
                if (rrc_rb_information_reconfig_ptr->rb_StopContinue == rrc_RB_StopContinue_stopRB)
                {
                  rrccu_chan_config_info.rb_info[no_of_RBs].ul_cfg_mask |= STOP_RB_CFG; 
                  rrccu_chan_config_info.rb_info[no_of_RBs].dl_cfg_mask |= STOP_RB_CFG;
                  WRRC_MSG1_HIGH("Stop recvd for RB %d", (uint16)(rrc_rb_information_reconfig_ptr->rb_Identity));
                }
                else if (rrc_rb_information_reconfig_ptr->rb_StopContinue == rrc_RB_StopContinue_continueRB)
                {
                  rrccu_chan_config_info.rb_info[no_of_RBs].ul_cfg_mask |= CONTINUE_RB_CFG; 
                  rrccu_chan_config_info.rb_info[no_of_RBs].dl_cfg_mask |= CONTINUE_RB_CFG;
                  WRRC_MSG1_HIGH("Continue recvd for RB %d", (uint16)(rrc_rb_information_reconfig_ptr->rb_Identity));
                }
              }
              /* Advance the Linked List pointer */
              rb_idx++;
              no_of_RBs++;
               
            } while(cu_confirm_ptr->rb_InformationReconfigList.n > rb_idx) ;
          }
          if(RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr,
             rrc_CellUpdateConfirm_r5_IEs,rb_InformationAffectedList))
          {
            /* Save the head pointer of linked list */
            rrc_rb_information_affected_list = 
              &cu_confirm_ptr->rb_InformationAffectedList;
            rb_idx=0;
            rrccu_chan_config_info.rb_info[no_of_RBs].rb_id = 
              cu_confirm_ptr->rb_InformationAffectedList.elem[rb_idx].rb_Identity;

            rrccu_chan_config_info.rb_info[no_of_RBs].rb_config = RECONFIG_RB;
            /*NOT NEEDED*/
            rrccu_chan_config_info.rb_info[no_of_RBs].rb_config = RECONFIG_RB_OTA;
            rrccu_chan_config_info.rb_info[no_of_RBs].ul_cfg_mask = rrccu_chan_config_info.rb_info[no_of_RBs].dl_cfg_mask = MODIFY_RB_CFG;
            do
            { 
              rrccu_chan_config_info.rb_info[no_of_RBs].rb_id = 
                  rrc_rb_information_affected_list->elem[rb_idx].rb_Identity;

              rrccu_chan_config_info.rb_info[no_of_RBs].rb_config = RECONFIG_RB;
              rrccu_chan_config_info.rb_info[no_of_RBs].rb_config = RECONFIG_RB_OTA;
              rrccu_chan_config_info.rb_info[no_of_RBs].ul_cfg_mask = rrccu_chan_config_info.rb_info[no_of_RBs].dl_cfg_mask = MODIFY_RB_CFG;
              /* Advance the Linked List pointer */
              rb_idx++;

              no_of_RBs++;

            } while(rrc_rb_information_affected_list->n > rb_idx);
          }

          rrccu_chan_config_info.num_rbs = no_of_RBs;
          rrccu_chan_config_reqd = TRUE;
          if (! rrccu_cucnf_for_srns_relocation)
          {
            /* procedure does not involve SRNS relocation */

            /* CRNTI always must be present to send the 
            response message */
            /* if cucnf message has new C-RNTI  then we need to update
            the C-RNTI in mac first and send the response and then start
            the channel configuration */
            if (RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
                  rrc_CellUpdateConfirm_r5_IEs,new_C_RNTI))
            {
              /* Allocates the buffer to RRC Internal command */
              cmd_ptr =  rrc_get_int_cmd_buf();
              /* Fill parameters for RRC_RNTI_UPDATE_REQ command */
              cmd_ptr->cmd.rnti_update_req.procedure = RRC_PROCEDURE_CU;
              cmd_ptr->cmd_hdr.cmd_id = RRC_RNTI_UPDATE_REQ;

              rrc_translate_crnti(&cu_confirm_ptr->new_C_RNTI,&crnti);
              cmd_ptr->cmd.rnti_update_req.crnti_action = RRC_RNTI_UPDATE;
              cmd_ptr->cmd.rnti_update_req.crnti = crnti;

              if(RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
                 rrc_CellUpdateConfirm_r5_IEs,new_U_RNTI))
              {
                rrc_translate_urnti(&cu_confirm_ptr->new_U_RNTI, &urnti);
                cmd_ptr->cmd.rnti_update_req.urnti_action = RRC_RNTI_UPDATE;
                cmd_ptr->cmd.rnti_update_req.urnti= urnti;
              }
              else
              {
                cmd_ptr->cmd.rnti_update_req.urnti_action = RRC_RNTI_NOCHANGE;
              }
              /* Indicate to LLC if RLC for SRBs needs to be re-established */
              if(cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4 == TRUE)
              {
                cmd_ptr->cmd.rnti_update_req.rlc_re_establish_srb = TRUE;
              }
              else
              {
                cmd_ptr->cmd.rnti_update_req.rlc_re_establish_srb = FALSE;
              }
              /* Indicate to LLC if RLC for User plane RBs needs to be re-established */
              if(cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove == TRUE)
              {
                cmd_ptr->cmd.rnti_update_req.rlc_re_establish_rab = TRUE;
              }
              else
              {
                cmd_ptr->cmd.rnti_update_req.rlc_re_establish_rab = FALSE;
              }
              cmd_ptr->cmd.rnti_update_req.cnf_required = TRUE;

              WRRC_MSG2_HIGH("Sending RNTI update req CRNTI_stat:%d, URNTI_stat:%d", 
                        cmd_ptr->cmd.rnti_update_req.crnti_action,
                        cmd_ptr->cmd.rnti_update_req.urnti_action);

              rrc_put_int_cmd(cmd_ptr);       /* sends the command to RRC  LLC. */

              rrccu_substate = RRCCU_WAIT_FOR_RNTI_UPDATE_CNF;         
              if( RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
                  rrc_CellUpdateConfirm_r5_IEs,cn_InformationInfo))
              {
                (void) rrc_ccm_send_nas_cn_info(
                        &(cu_confirm_ptr->cn_InformationInfo)
                      ,primary_plmn_Id_present
                      ,&primary_plmn_Identity
                                   );
              } 
            }
            else
            {
              /* We will be in Cell_FACH state at this time and going to send the
              response message in Cell_FACH state.*/
              WRRC_MSG1_HIGH("RNTI absent for RB resp message, next state%d", 
                      rrc_get_state());
              if( RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
                  rrc_CellUpdateConfirm_r5_IEs,cn_InformationInfo))
              {
                (void) rrc_ccm_send_nas_cn_info(
                          &(cu_confirm_ptr->cn_InformationInfo)
                         ,primary_plmn_Id_present
                         ,&primary_plmn_Identity
                      );
              } 
              if ((rrccu_int_data.rrccu_cell_selection_trans_from_fach) &&
                  (rrccu_resp_msg == RRCCU_NO_RESP_MSG))
              { 
                rrccu_intiate_cell_selection_fach_pch_cu_cnf(); 
              }
              else
              {
                /* send the response message on the old configuration */
                rrccu_send_response_msg();
              }
            }
          }
          else
          {
            /* procedure involves SRNS relocation so store the C-RNTI
            and send rlc_reestablishment request to SMC . RNTI update 
            will be done after RLC re-establishment*/
            if (RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
                  rrc_CellUpdateConfirm_r5_IEs,new_C_RNTI)) 
            {
              rrccu_new_crnti_valid = TRUE;
              rrc_translate_crnti(&cu_confirm_ptr->new_C_RNTI,&rrccu_new_crnti);
            }
            if(RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
               rrc_CellUpdateConfirm_r5_IEs,new_U_RNTI))
            {
              rrccu_new_urnti_valid = TRUE;
              rrc_translate_urnti(&cu_confirm_ptr->new_U_RNTI,&rrccu_new_urnti);
            }
            /* store the rlc re-establishment indications */
            rrccu_reestablish_srb = cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4;
            rrccu_reestablish_rab = cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove;

            //commit fresh values for srns relocation
            rrcsmc_commit_fresh_for_srns_relocation();

            /*send the rlc re-establishment request to SMC to re-establish SRB2 */
            /* Get the command buffer */
              int_cmd_ptr = rrc_get_int_cmd_buf();
              /* Fill in the command id  */
              int_cmd_ptr->cmd_hdr.cmd_id = RRC_RE_EST_RLC_FOR_SRNS_REQ;
              int_cmd_ptr->cmd.rrc_re_est_srns_req.rrc_proc = RRC_PROCEDURE_CU;
              int_cmd_ptr->cmd.rrc_re_est_srns_req.rb_type  = RRC_RE_EST_RB_2;
              int_cmd_ptr->cmd.rrc_re_est_srns_req.cnf_reqd = TRUE;
              WRRC_MSG1_HIGH("RLC Reestablish req for %d ", 
                       RRC_RE_EST_RB_2); 

              rrc_put_int_cmd(int_cmd_ptr);             

              rrccu_substate = RRCCU_WAIT_FOR_SRB2_RE_EST_CNF;         
              if( RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
                  rrc_CellUpdateConfirm_r5_IEs,cn_InformationInfo))
              {
                (void) rrc_ccm_send_nas_cn_info(
                         &(cu_confirm_ptr->cn_InformationInfo)
                         ,primary_plmn_Id_present
                         ,&primary_plmn_Identity
                      );
              } 
            }
        }
        else /*normal fach-fach or fach-dch configuration */
        {
          /* if any rlc entity has to be re-established then re-establish it 
          before configuring channels. */
          if((cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4 == TRUE) ||
              (cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove == TRUE))
          {
            /* store the rlc re-establishment indications */
            rrccu_reestablish_srb = cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4;
            rrccu_reestablish_rab = cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove;
            rrccu_new_crnti_valid = FALSE;
            rrccu_new_urnti_valid = FALSE;
            rrccu_send_rnti_update_req(FALSE);
            ps_rb_re_establish_indicator = cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove;
            WRRC_MSG1_HIGH("CU: RB5 or higher re-establish indicator %d",ps_rb_re_establish_indicator);

          }
          rrccu_reestablish_srb = FALSE;
          rrccu_reestablish_rab = FALSE;

          if((rrccu_resp_msg == RRCCU_UMIC_COMPLETE_RESP_MSG) &&
             (rrccu_state_indicator == rrc_RRC_StateIndicator_cell_FACH ))
          {
            if (rrc_get_rlc_size_change_status_for_procedure_id(RRC_PROCEDURE_CU))
            {
              rrcsmc_update_hfn_for_rlc_rb(rlc_size_change_in_progress.rb_id, 
                                          rlc_size_change_in_progress.direction);
            }
          }
          /* store the C-RNTI
          and send rlc_reestablishment request to SMC . RNTI update 
          will be done after Channel configuration*/
          if (RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
                rrc_CellUpdateConfirm_r5_IEs,new_C_RNTI) 
                && (rrccu_state_indicator != rrc_RRC_StateIndicator_cell_DCH) ) 
          {
            rrccu_new_crnti_valid = TRUE;
            rrc_translate_crnti(&cu_confirm_ptr->new_C_RNTI,&rrccu_new_crnti);
          }
          if(RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
             rrc_CellUpdateConfirm_r5_IEs,new_U_RNTI))
          {
            rrccu_new_urnti_valid = TRUE;
            rrc_translate_urnti(&cu_confirm_ptr->new_U_RNTI,&rrccu_new_urnti);
          }

          /*check whether this procedure involves SRNS reloc */
          if (rrccu_cucnf_for_srns_relocation)
          {
            /*commit fresh values for srns relocation */
            rrcsmc_commit_fresh_for_srns_relocation();
          }
          /* Allocates the buffer to RRC Internal command */
            cmd_ptr =  rrc_get_int_cmd_buf();
            rrccu_cipher_update_required = FALSE;

            /* Initialize the no of RBs */
            no_of_RBs = 0;
            /* Fill in the command parameters for RRC_CHANNEL_CONFIG_REQ */
            cmd_ptr->cmd_hdr.cmd_id = RRC_CHANNEL_CONFIG_REQ;
            cmd_ptr->cmd.chan_config_req.procedure = RRC_PROCEDURE_CU;

            /* Fill in parameters for RRC_CHANNEL_CONFIG_REQ command */
            if (rrccu_state_indicator == rrc_RRC_StateIndicator_cell_DCH  )
            {
              //if we r going to dch, then dl-common-info-for-all-rl will be present..
              //check if ciphering is active in mac for cs domain, if it is then,
              //start 2 tiered HHO procedure STEP_1 and STEP_2 for rl-re-establishment
              if(rrcsmc_tm_ciph_active() == TRUE)
              {
                uint32 mac_d_hfn_l=RRCSMC_INVALID_HFN_VALUE;
                WRRC_MSG0_HIGH("RL-cipher present in TM-rb's");
                mac_d_hfn_l = get_mac_d_hfn_cucnf(cu_confirm_ptr);              
                if(SUCCESS == rrcsmc_process_cipher_config_for_hho(mac_d_hfn_l)) 
                {
                  rrccu_cipher_update_required = TRUE;
                }
              }
              else
              {
                WRRC_MSG0_HIGH("RL-cipher not-present in TM");
              }

              /* Change the state if it is not CELL_PCH or URA_PCH */
              cmd_ptr->cmd.chan_config_req.rrc_state_change_required = TRUE;
              cmd_ptr->cmd.chan_config_req.next_state = state;
            }
            else
            {
              cmd_ptr->cmd.chan_config_req.rrc_state_change_required = FALSE;
            }
            cmd_ptr->cmd.chan_config_req.rrc_channel_config_cnf_required = TRUE;

            if(RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr,
               rrc_CellUpdateConfirm_r5_IEs,rb_InformationReleaseList))
            {
              /* set to flag to indicate that rb release information is present
              in the message. This information will be used after channel configu
              ration to release the rbs from established_rab and also to indicate
              to the upper layers about RAB release if necessary */
              rrccu_rb_release_info.rrccu_rb_release_in_cucnf = TRUE;

              /* Save the linked list head pointer */ 
              rrc_rb_information_release_list = 
                &cu_confirm_ptr->rb_InformationReleaseList;
              rb_idx=0;
              /* If voice RAB still exist, then indicate layer 1 that next configuration is going to
                 include AMR configuration.
                 This check is not required if state change indication is either cell_PCH, URA_PCH or
                 CELL_FACH, because if voice is configured then next state has to be CELL_DCH.
              */
              if ((rrc_RRC_StateIndicator_cell_DCH == rrccu_state_indicator) && (FALSE == 
                  rrc_is_given_rb_rel_list_releases_all_rb_for_voice_rab(
                                    rrc_rb_information_release_list)))
              {
                rrc_indicate_layer1_next_config_is_for_voice();
              }

              while(rrc_rb_information_release_list->n > rb_idx)
              {
                if( rrc_rb_information_release_list->elem[rb_idx] == DCCH_DT_LOW_PRI_RADIO_BEARER_ID)
                {
                if(RRCLCM_RLC_LC_ID_NOT_FOUND == rrclcm_check_dl_rlc_lc_id(
                                                 UE_LOGCHAN_DCCH,
                                                 DCCH_DT_LOW_PRI_RADIO_BEARER_ID,
                                                 UE_MODE_ACKNOWLEDGED_DATA))
                  {
                    WRRC_MSG1_HIGH("Ignore Non-exitent rb_id =%d in cucnf",rrc_rb_information_release_list->elem[rb_idx]);
                    rb_idx++;
                    continue;
                  }
                }
                else if(! rrc_find_rb_in_est_rabs((rrc_rb_information_release_list->elem[rb_idx]))) 
                {
                  WRRC_MSG1_HIGH("Ignore Non-exitent rb_id = %d in cucnf",rrc_rb_information_release_list->elem[rb_idx]);
                  rb_idx++;
                  continue;
                }
                else if (MAX_RB != rrccu_check_if_rbid_present_in_rrccu_rb_release_info(rrc_rb_information_release_list->elem[rb_idx],no_of_RBs))
                {
                  WRRC_MSG1_ERROR(" Ignoring Duplicate RB ID % d in CU ",rrc_rb_information_release_list->elem[rb_idx]);
                  rb_idx++;
                  continue;
                }

                WRRC_MSG1_HIGH("Release RB i.d=%d",rrc_rb_information_release_list->elem[rb_idx]);

                cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].rb_id = 
                rrc_rb_information_release_list->elem[rb_idx];

                cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].rb_config = RELEASE_RB;

                /* store the rb info to release list in local buffer which will
                be used later to release it from established_rab variable */
                rrccu_rb_release_info.rb_id[no_of_RBs]=rrc_rb_information_release_list->elem[rb_idx];

                /* Advance the Linked List pointer */
                rb_idx++;

                no_of_RBs++;

              }

              rrccu_rb_release_info.num_rbs = no_of_RBs;

              rrcrb_update_mac_rab_status(RRC_PROCEDURE_CU, RRC_CS_DOMAIN_CN_ID,
                                          &cu_confirm_ptr->rb_InformationReleaseList,
                                          FALSE);
            }
            else
            {
              /* It means CU Confirm doesnt include information to release any RB. 
                 check if AMR RAB was established earlier. If yes then indicate layer 1 that
                 next configuration will be for AMR.
                 This check is not required if state change indication is either cell_PCH, URA_PCH or
                 CELL_FACH, because if voice is configured then next state has to be CELL_DCH.                   
              */
              if ((rrc_RRC_StateIndicator_cell_DCH == rrccu_state_indicator) && 
                                        (TRUE == rrc_is_voice_rab_present()))
              {
                rrc_indicate_layer1_next_config_is_for_voice();
              }
            }
            if(RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr,
               rrc_CellUpdateConfirm_r5_IEs,rb_InformationReconfigList))
            {

              rb_idx=0;

              do
              { 
                              /* Save the linked list head pointer */
                rrc_rb_information_reconfig_ptr = 
                  &cu_confirm_ptr->rb_InformationReconfigList.elem[rb_idx];
                cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].rb_id = 
                rrc_rb_information_reconfig_ptr->rb_Identity;

                cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].rb_config = RECONFIG_RB;
                cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].rb_config = RECONFIG_RB_OTA;
                cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].ul_cfg_mask = 0;
                cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].dl_cfg_mask = 0;
                if((RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_rb_information_reconfig_ptr, rrc_RB_InformationReconfig_r5,rlc_Info))
                    &&(RRC_MSG_COMMON_BITMASK_IE(rrc_rb_information_reconfig_ptr->rlc_Info,
                    rrc_RLC_Info_r5,ul_RLC_Mode)))
                {
                  cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].ul_cfg_mask = MODIFY_RB_CFG;
                }
                if((RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_rb_information_reconfig_ptr, rrc_RB_InformationReconfig_r5,rlc_Info))
                    &&(RRC_MSG_COMMON_BITMASK_IE(rrc_rb_information_reconfig_ptr->rlc_Info,
                    rrc_RLC_Info_r5,dl_RLC_Mode)))
                {
                  cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].dl_cfg_mask = MODIFY_RB_CFG;
                }
                if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_rb_information_reconfig_ptr, 
                    rrc_RB_InformationReconfig_r5,rb_StopContinue))
                {
                  if (rrc_rb_information_reconfig_ptr->rb_StopContinue == rrc_RB_StopContinue_stopRB)
                  {
                    cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].ul_cfg_mask |= STOP_RB_CFG;
                    cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].dl_cfg_mask |= STOP_RB_CFG;
                    WRRC_MSG1_HIGH("Stop recvd for RB %d", (uint16)(rrc_rb_information_reconfig_ptr->rb_Identity));
                  }
                  else if (rrc_rb_information_reconfig_ptr->rb_StopContinue == rrc_RB_StopContinue_continueRB)
                  {
                    cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].ul_cfg_mask |= CONTINUE_RB_CFG;
                    cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].dl_cfg_mask |= CONTINUE_RB_CFG;
                    WRRC_MSG1_HIGH("Continue recvd for RB %d", (uint16)(rrc_rb_information_reconfig_ptr->rb_Identity));
                  }
                }
                /* Advance the Linked List pointer */
                rb_idx++;

                no_of_RBs++;

              } while(cu_confirm_ptr->rb_InformationReconfigList.n > rb_idx );
            }
            if(RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr,
               rrc_CellUpdateConfirm_r5_IEs,rb_InformationAffectedList))
            {
              /* Save the head pointer of linked list */
              rrc_rb_information_affected_list = 
                &cu_confirm_ptr->rb_InformationAffectedList;
              rb_idx=0;
              do
              { 
                cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].rb_id = 
                rrc_rb_information_affected_list->elem[rb_idx].rb_Identity;

                cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].rb_config = RECONFIG_RB;
                cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].rb_config = RECONFIG_RB_OTA;
                cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].ul_cfg_mask = cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].dl_cfg_mask = MODIFY_RB_CFG;
                /* Advance the Linked List pointer */
                rb_idx++;

                no_of_RBs++;

              }while(rrc_rb_information_affected_list->n > rb_idx);
            }
#ifdef FEATURE_WCDMA_HS_FACH
            if (rrcenhstate_camped_cell_supports_e_fach()&&
               (rrccu_state_indicator ==rrc_RRC_StateIndicator_cell_FACH))
            {
              no_of_RBs = rrccu_update_chan_config_rb_r7_for_efach(no_of_RBs,cmd_ptr->cmd.chan_config_req.rb);
            }
#endif


            cmd_ptr->cmd.chan_config_req.num_rb_to_config =(int) no_of_RBs;
            rrc_fill_rb_id_chan_req_from_standalone_db(&no_of_RBs, &cmd_ptr->cmd.chan_config_req);

            if(rrccu_state_indicator == rrc_RRC_StateIndicator_cell_DCH)
            {
              /* Fill those RBs in chan_config_req for which RLC PDU size has changed and 
              that are already not present in chan_config_req*/
              rrc_fill_rb_id_chan_req_from_rb_list_mapped_to_dch(&no_of_RBs, 
                            &cmd_ptr->cmd.chan_config_req);
            }
            /*If state transition is Cell_FACH->Cell_DCH, add all the existing AM 
            PS RBs in chan_config_req*/
            if((rrc_get_state() == RRC_STATE_CELL_FACH) && 
                          (rrccu_state_indicator == rrc_RRC_StateIndicator_cell_DCH))
            {
              rrc_fill_rb_id_chan_req_from_est_rabs(&no_of_RBs, 
                            &cmd_ptr->cmd.chan_config_req);
              rrc_fill_srb_in_chan_config_req(&no_of_RBs,&cmd_ptr->cmd.chan_config_req);
            }

            cmd_ptr->cmd.chan_config_req.chan_config_reason = RRCLLC_CHAN_CFG_REASON_NONE;
   
     
            /*call the function that evaluates the directed cell info and set the flags accordingly */
            if ((rrc_RRC_StateIndicator_cell_FACH == rrccu_state_indicator) &&
                (rrcrb_validate_directed_cell_info (directed_cell_info) == FALSE))
            {
              if(rrccsp_check_initiate_cell_selection_handling(NULL) == FALSE)
              {
                rrccu_cu_initiate_reqd.cu_reqd = TRUE;
                rrccu_cu_initiate_reqd.cu_cause = rrc_CellUpdateCause_cellReselection;
                WRRC_MSG1_HIGH("CHANNEL_CONFIG_REQ for %dRBs",no_of_RBs);
                rrc_put_int_cmd(cmd_ptr);                 /* sends the command to RRC
                                                           LLC. */
                rrccu_substate = RRCCU_WAIT_FOR_RB_EST_CNF;         
              }
              else
              {
                rrccu_intiate_cell_selection_within_fach_cu_cnf(cmd_ptr);
                cmd_ptr = NULL;
              }
            }
            else
            {
              WRRC_MSG1_HIGH("CHANNEL_CONFIG_REQ for %dRBs",no_of_RBs);
              rrc_put_int_cmd(cmd_ptr);                 /* sends the command to RRC
                                                           LLC. */
              rrccu_substate = RRCCU_WAIT_FOR_RB_EST_CNF;         
            }

          if( RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
              rrc_CellUpdateConfirm_r5_IEs,cn_InformationInfo))
          {
            (void) rrc_ccm_send_nas_cn_info(
                         &(cu_confirm_ptr->cn_InformationInfo)
                         ,primary_plmn_Id_present
                         ,&primary_plmn_Identity
                     );
          } 
        }
        break;

      case ORDERED_CONFIG_INCOMPATABLE_SIMULTANEOUS_RECONFIG:
        /* This should not occur for CELL UPDATE CONFIRM */
       /* Set the Transaction Id */
        rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;

        /* Set Failure cause */
        rrccu_failure_cause.failureCause.t = 
          T_rrc_FailureCauseWithProtErr_incompatibleSimultaneousReconfiguration;
 

        rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
        break;

      case ORDERED_CONFIG_CONFIGURATION_NOT_SUPPORTED:
        /* Set the Transaction Id */
        rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;

        /* Set Failure cause */
        rrccu_failure_cause.failureCause.t = 
          T_rrc_FailureCauseWithProtErr_configurationUnsupported;

        rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
        break;

      case ORDERED_CONFIG_NOT_SET_OTHER:
        /* For Cell Update Confirm message RRC LLC should never
           set Ordered Config */
        WRRC_MSG0_ERROR("Ordered Config Should not return this status");
        break;

      case ORDERED_CONFIG_CONFIGURATION_INVALID:
        /* Set the Transaction Id */
        rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;

        /* Set Failure cause */
        rrccu_failure_cause.failureCause.t = 
          T_rrc_FailureCauseWithProtErr_invalidConfiguration;

        rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
        break;

      default:
        WRRC_MSG0_ERROR("Invalid status from ORDERED_CONFIG");
        break;
    } 
  }  
} /* rrccu_process_cell_update_confirm_r5*/


/*===========================================================================

FUNCTION rrccu_validate_rel_rb_exist_in_reconfig_list_r6

DESCRIPTION
  This function checks if the Cu Cnf has the same RB ID in the RB Release list
   and also in RB Reconfig/RB Affected List
  
DEPENDENCIES
  None

RETURN VALUE
  True, if same RB ID is present in RB Release list and also in RB Reconfig/RB Affected List
  else
  FALSE
  
SIDE EFFECTS

  None

===========================================================================*/
static boolean rrccu_validate_rel_rb_exist_in_reconfig_list_r6
(
  rrc_CellUpdateConfirm_r6_IEs * cu_confirm_ptr
)
{
  rrc_RB_Identity released_rb_id= 0xFF;
  rrc_RB_InformationReleaseList *rrc_rb_information_release_list;
                                            /* Local pointer to preserve the
                                               head of linked list */  
  rrc_RB_InformationReconfig_r6 *rrc_rb_information_reconfig_ptr; 
  
  rrc_RB_InformationAffectedList_r6 *rrc_rb_information_affected_list; 
  uint32 idx=0,idy=0;
  /* Save the linked list head pointer */ 
  rrc_rb_information_release_list = 
    &cu_confirm_ptr->rb_InformationReleaseList;
  
  while(rrc_rb_information_release_list->n > idx)
  { 
  
    released_rb_id =rrc_rb_information_release_list->elem[idx];
    if(RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr,
             rrc_CellUpdateConfirm_r6_IEs,rb_InformationReconfigList))
    {
      idy=0;

      do
      { 
            /* Save the linked list head pointer */
        rrc_rb_information_reconfig_ptr = 
         &cu_confirm_ptr->rb_InformationReconfigList.elem[idy];
        /* Check whether rb id in rb reconfig list is in the established rabs list.  If not set msg_not_valid variable
           to true to resend cell update msg with failure cause  */
        if (rrc_rb_information_reconfig_ptr->rb_Identity == released_rb_id  )
        {
          /* RB Message was invalid. */
          WRRC_MSG1_ERROR(" RB id:%d in rb_InformationReconfigList  and RB Release list of CUCnf Msg",
             rrc_rb_information_reconfig_ptr->rb_Identity );
          return TRUE;
        }
                 
        /* Advance the Linked List pointer */
        idy++;
      }while(cu_confirm_ptr->rb_InformationReconfigList.n > idy);
    }
  
    if(RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr,
        rrc_CellUpdateConfirm_r6_IEs,rb_InformationAffectedList))
    {
      /* Save the head pointer of linked list */
      rrc_rb_information_affected_list = 
       &cu_confirm_ptr->rb_InformationAffectedList;
	  idy=0;
      do
      { 
        /* Check whether rb id in rb affected list is in the established rabs list.  If not set msg_not_valid variable
        to true to resend cell update msg with failure cause  */
        if (rrc_rb_information_affected_list->elem[idy].rb_Identity == released_rb_id )
        {
          /* RB Message was invalid. */
          WRRC_MSG1_ERROR(" RB id:%d in rb_InformationAffectedList  and RB Release list of CUCnf Msg",
             rrc_rb_information_affected_list->elem[idy].rb_Identity );
          return TRUE;
        }
        /* Advance the Linked List pointer */
        idy++;
        
      } while(rrc_rb_information_affected_list->n > idy);
    }
  
    idx++;
  }
  return FALSE;
}

/*===========================================================================

FUNCTION RRCCU_PROCESS_CELL_UPDATE_CONFIRM_R6

DESCRIPTION
  This function processes the REl 6 CELL UPDATE CONFIRM message received in response to
  Cell Update message.
  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
static void rrccu_process_cell_update_confirm_r6
(    
  void *msg_ptr,                           /* Pointer to Downlink Msg */
  rrc_RRC_TransactionIdentifier rcvd_transaction_id,
  rrc_CellUpdateConfirm_r6_IEs *cu_confirm_ptr,
  uint32 dl_sdu_type                       /* Downlink SDU type */
)
{
  rrc_cmd_type *cmd_ptr;                      /* Pointer to the RRC Command */
  rrc_cmd_type *int_cmd_ptr;                      /* Pointer to the RRC Command */
  uint32 no_of_RBs;                           /* Local variable to store no
                                                of RBs */
  boolean msg_not_valid      = FALSE;         /* boolean to indicate msg validity */
  rrc_int_c_rnti_type crnti;                  /* Local variable for C-RNTI */
  rrc_int_u_rnti_type urnti;                  /* Local variable for U-RNTI */
 
  rrc_state_e_type state ;                    /* Local varible to store state */

  rrcllc_oc_status_e_type status;             /* Local var to store Ordered Config
                                                 status */
  rrc_RB_InformationReleaseList *rrc_rb_information_release_list;
                                              /* Local pointer to preserve the
                                                 head of linked list */  
  rrc_RB_InformationReconfig_r6 *rrc_rb_information_reconfig_ptr; 

  rrc_RB_InformationAffectedList_r6 *rrc_rb_information_affected_list; 

  uecomdef_status_e_type hs_valid_status = SUCCESS;
  rrcrb_directed_cell_info_type          directed_cell_info; /* directed cell info struct */
 uint32 rb_idx=0;

  /* Update Transaction id */
  rrccu_trans_id = rcvd_transaction_id;
    
  /* enter idle if both timers are marked as expired */
  if ((rrccu_rl_failure_info.t314_info.timer_status == RE_EST_TIMER_EXPIRED) &&
      (rrccu_rl_failure_info.t315_info.timer_status == RE_EST_TIMER_EXPIRED))
  {
    /* Since both T314 and T315 are expired, bring down RRC Connection */
      rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                           RRC_TX_TO_DISCON_OTHER);
      /* Update the release cause */
      rrc_release_cause = RRC_REL_DEEP_FADE;
      rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
      WRRC_MSG0_HIGH("RRC Conn Released since T314=0 & T315=0");

    return;
  }

  /* Update state Indicator */   
  rrccu_state_indicator = cu_confirm_ptr->rrc_StateIndicator;


  /* check whether new CRNTI is present in the message or not when there is
  no valid C-RNTI is existing and next state indicated by the message is 
  CELL_FACH */
  if ((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_FACH) ||
     (((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH) || (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH)) &&
     (RRCCU_NO_RESP_MSG != rrccu_find_response_to_cell_update_confirm_r6(cu_confirm_ptr))))
  {
    if ((C_RNTI_NOT_VALID == rrcllc_get_current_crnti_status()) &&
        ((RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, rrc_CellUpdateConfirm_r6_IEs,new_C_RNTI)) == 0 ))
    {
      if(((rrcllc_get_toc_usage() == TOC_FOR_OOS)
          || (rrcllc_get_toc_usage() == TOC_FOR_OOS_WITHOUT_DCH_INFO)
          || (rrcllc_get_toc_usage() == TOC_FOR_OOS_WITH_DCH_INFO)
      ) && 
         (rrcrb_get_new_crnti_valid() && rrccsp_is_selected_cell_utran_directed()))
      {
        WRRC_MSG0_HIGH("Crnti present in reconfig msg");
      }
      else
      {

        WRRC_MSG1_ERROR("No CRNTI for next_st:%d", rrccu_state_indicator);
        /* Update the cause to re-selection as the Cell upate cause should
              indicate re-selection in case of No CRNTI
              */
        rrccu_cell_update_cause = rrc_CellUpdateCause_cellReselection;		
        rrc_cu_uu_log_event_failure_cause = RRC_CU_UU_INVALID_CONFIG;
        rrccu_resend_cell_update_msg(RRCCU_NOT_INCLUDE_FAILURE_CAUSE);
        /* continue with rrccu state  RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM */
        return;
      }
    }
  }

#ifdef FEATURE_WCDMA_HS_FACH
  /*RNTI validation for HS-FACH and HS-RACH*/
    if(TRUE == rrccu_check_rnti_for_resending_cu(
                 RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, rrc_CellUpdateConfirm_r6_IEs,new_H_RNTI), 
                 RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, rrc_CellUpdateConfirm_r6_IEs,newPrimary_E_RNTI),
                 MSG_REL6, 
	         rrccu_find_response_to_cell_update_confirm_r6(cu_confirm_ptr)))
    {
      rrccu_cell_update_cause = rrc_CellUpdateCause_cellReselection;
      rrc_cu_uu_log_event_failure_cause = RRC_CU_UU_INVALID_CONFIG;
      rrccu_resend_cell_update_msg(RRCCU_NOT_INCLUDE_FAILURE_CAUSE);
      return;
    }
#endif
  if ((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH) ||
      (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH))
  {
    if (!(RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
          rrc_CellUpdateConfirm_r6_IEs,utran_DRX_CycleLengthCoeff)))
    {
      WRRC_MSG0_ERROR("UTRAN DRX is not present");
      
      /* set the invalid msg flag */
      msg_not_valid = TRUE;

    }
    else
    {
      /* store it in a variable */
      rrccu_utran_drx_coef = cu_confirm_ptr->utran_DRX_CycleLengthCoeff;
    }
       /*resend the cell update message if there is any invalid config*/
    if  (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH)
    {
      if (!(RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
            rrc_CellUpdateConfirm_r6_IEs,ura_Identity)))
      {
        WRRC_MSG0_HIGH("URA-id is not present");
        rrccu_clear_ura_id();
      }
      /* update rrccu procedure with new URA-id */
      else
      {
        /*URA ID present in the message set ura_identity variable with this value */
        if (cu_confirm_ptr->ura_Identity.numbits == 16)
        {
          /*rrccu_translate_ura_id (&(msg_ptr->u.r3.radioBearerReconfiguration_r3.ura_Identity));*/
          rrccu_update_ura_id (&(cu_confirm_ptr->ura_Identity));
        }
        else
        {
          WRRC_MSG1_ERROR("Invalid URA ID length%d",
              cu_confirm_ptr->ura_Identity.numbits);
          /* set the invalid msg flag */
          msg_not_valid = TRUE;
        }
      }
        
    }
  }

  if(RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr,
               rrc_CellUpdateConfirm_r6_IEs,rb_InformationReconfigList))
  {
    /* Save the linked list head pointer */
    if (FAILURE == rrcllc_validate_rb_info_reconfig_list_r6(
        &cu_confirm_ptr->rb_InformationReconfigList))
    {
      msg_not_valid = TRUE;
    }
  }
  
  
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr,
     rrc_CellUpdateConfirm_r6_IEs,rb_InformationReleaseList))
  {
    /* Save the linked list head pointer */ 
    rrc_rb_information_release_list = 
      &cu_confirm_ptr->rb_InformationReleaseList;
    rb_idx=0;
    while(rrc_rb_information_release_list->n > rb_idx)
    { 
      /* Check whether rb id in rb release list is in the established rabs list.  If not set msg_not_valid variable
         to true to resend cell update msg with failure cause  */
      if (RRC_RB_NOT_PRESENT == validate_rb_id_in_release_list(
                            (rrc_rb_information_release_list->elem[rb_idx])))
      {
        /* RB Message was invalid. */
        WRRC_MSG1_HIGH("Invalid RB id:%d in rb_InformationReleaseList of CUCnf Msg",
          rrc_rb_information_release_list->elem[rb_idx] );
        msg_not_valid = TRUE;
        break;
      }      
      rb_idx++;
    } 
  }
  
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr,
     rrc_CellUpdateConfirm_r6_IEs,rb_InformationAffectedList))
  {
    /* Save the head pointer of linked list */
    rrc_rb_information_affected_list = 
      &cu_confirm_ptr->rb_InformationAffectedList;
    do
    { 
      /* Check whether rb id in rb affected list is in the established rabs list.  If not set msg_not_valid variable
      to true to resend cell update msg with failure cause  */
      if (RRC_RB_NOT_PRESENT == validate_rb_id_in_reconfig_list(
          (rrc_rb_information_affected_list->elem[rb_idx].rb_Identity)))
      {
        /* RB Message was invalid. */
        WRRC_MSG1_HIGH("Invalid RB id:%d in rb_InformationAffectedList of CUCnf Msg",
          rrc_rb_information_affected_list->elem[rb_idx].rb_Identity );
        msg_not_valid = TRUE;
        break;
      }
      /* Advance the Linked List pointer */
      rb_idx++;
      
    } while(rrc_rb_information_affected_list->n > rb_idx);
  }

  if((msg_not_valid == FALSE) && (RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr,
     rrc_CellUpdateConfirm_r6_IEs,rb_InformationReleaseList))
     && ((RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr,
               rrc_CellUpdateConfirm_r6_IEs,rb_InformationReconfigList)) ||
      (RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr,
     rrc_CellUpdateConfirm_r6_IEs,rb_InformationAffectedList))   ))
  {
    msg_not_valid = rrccu_validate_rel_rb_exist_in_reconfig_list_r6(cu_confirm_ptr);
  }
  
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
      rrc_CellUpdateConfirm_r6_IEs,dl_HSPDSCH_Information))
  {
    /* Check if network does not try to initiate HSDPA with invalid state */
    hs_valid_status = rrc_hsdpa_initial_validation_r6(cu_confirm_ptr->rrc_StateIndicator, 
      &cu_confirm_ptr->dl_HSPDSCH_Information);
    
    if (hs_valid_status == FAILURE)
    {
      WRRC_MSG0_ERROR("Invalid HSDPA Info specified");
      msg_not_valid = TRUE;
    }
  }
  

  if (msg_not_valid)
  {
    WRRC_MSG0_HIGH("Invalid Configurartion in CUCnf Msg.  Resending Cell Update");
    /* Set the Transaction Id */
    rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;

    /* Set Failure cause */
    rrccu_failure_cause.failureCause.t = 
      T_rrc_FailureCauseWithProtErr_invalidConfiguration;


    rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
    /* continue with rrccu state  RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM */
    return;
  }
  /* Populate the local variables to indicate if Re-direction info is present */
  directed_cell_info.freq_info_present = FALSE;
  directed_cell_info.pscr_present = FALSE;
  if(  (rrccu_state_indicator ==rrc_RRC_StateIndicator_cell_FACH)
        ||( rrccu_state_indicator==rrc_RRC_StateIndicator_cell_PCH)
        || (rrccu_state_indicator==rrc_RRC_StateIndicator_ura_PCH))
  {
    if((RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
        rrc_CellUpdateConfirm_r6_IEs,frequencyInfo)) &&
       (cu_confirm_ptr->frequencyInfo.modeSpecificInfo.t == 
       T_rrc_FrequencyInfo_modeSpecificInfo_fdd))
    {
      directed_cell_info.freq_info_present = TRUE;
      directed_cell_info.uarfcn_dl         = cu_confirm_ptr->frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_DL;
    }
    
    if ((RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, rrc_CellUpdateConfirm_r6_IEs,dl_InformationPerRL_List))
        &&(cu_confirm_ptr->dl_InformationPerRL_List.elem[0].modeSpecificInfo.t ==
         T_rrc_DL_InformationPerRL_r6_modeSpecificInfo_fdd))
    {
        WRRC_MSG1_HIGH("Primary SCR in CU Cnf  r5 message %d",
           cu_confirm_ptr->dl_InformationPerRL_List.elem[0].modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode);
      directed_cell_info.pscr_present = TRUE;
      directed_cell_info.pscr = cu_confirm_ptr->dl_InformationPerRL_List.elem[0].modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode;
    }
  }

  if ((rrc_RRC_StateIndicator_cell_FACH == rrccu_state_indicator) &&
       (rrcrb_validate_directed_cell_info (directed_cell_info) == FALSE))
   {
     /* If UE still has to send a response to the previous Cu Cnf with directed info
      * and it receives another Cu Cnf with directed info, then send failure
      * If the previous Cu Cnf had directed info, then atleast a PCRC Complete
      * has to be pending as a response.
      */
     if( rrccu_int_data.rrccu_cell_selection_last_response_msg != RRCCU_NO_RESP_MSG )
     {
        WRRC_MSG0_ERROR(" Previous Cu Cnf sent a directed info, cannot accept another Cu Cnd with directed info");
        /* Set the Transaction Id */
        rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;
        /* Set Failure cause */
    
        rrccu_failure_cause.failureCause.t = 
          T_rrc_FailureCauseWithProtErr_incompatibleSimultaneousReconfiguration;
 
    
        rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
        return;
     }
   }

  if (RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
      rrc_CellUpdateConfirm_r6_IEs,dl_CounterSynchronisationInfo)) 
  {
    /*check whether PDCP info is present in the dl counter sync info */
    if ((RRC_MSG_COMMON_BITMASK_IE_TYPE2(cu_confirm_ptr->dl_CounterSynchronisationInfo,
        rb_WithPDCP_InfoList)) ||
           (RRC_MSG_COMMON_BITMASK_IE(cu_confirm_ptr->dl_CounterSynchronisationInfo,
            rrc_DL_CounterSynchronisationInfo_r5,rb_PDCPContextRelocationList)))
    {
      /* this involves lossless SRNS relocation so re-send cell update 
         message */
      WRRC_MSG0_ERROR("PDCP info not supported");

      /* Set the Transaction Id */
      rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;

      /* Set Failure cause */
      rrccu_failure_cause.failureCause.t = 
        T_rrc_FailureCauseWithProtErr_configurationUnsupported;


      rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
      /* continue with rrccu state  RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM */
      return;
    }
    /*UE actions, in case IE "Downlink counter synchronisation info" is included and 
         *either IE "RLC reestablish indicator (RB2, RB3 and RB4)" or IE "RLC re-establish 
         *indicator (RB5 and upwards)" are set to TRUE, are not defined.refer to R2-041019,spec cr-2328
         */
    if((cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4 == TRUE) ||
     (cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove == TRUE))
    {
      /* Set the Transaction Id */
      rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;
    
      /* Set Failure cause */
      rrccu_failure_cause.failureCause.t = T_rrc_FailureCauseWithProtErr_configurationUnsupported;
    

    
      WRRC_MSG0_ERROR("UE doesn't support simultaneous RLC Re_est & S-RNS<R2-041019,spec cr-2328>");
      rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
      /* continue with rrccu state  RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM */
      return;
    }
    /* This is lossy SRNS relocation */
    rrccu_cucnf_for_srns_relocation  = TRUE;
    /* store the new URNTI value if present */
    if(RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, rrc_CellUpdateConfirm_r6_IEs,new_U_RNTI))
    {
      rrccu_new_urnti_valid = TRUE;
      rrc_translate_urnti (&(cu_confirm_ptr->new_U_RNTI),
                            &rrccu_new_urnti);
    }
  }

  /* check whether rlc-re establishment was require but not indicated in cell update
  confirm message. In such case discard the cucnf and resend cell update message.
  This should also take care of multiple cell updates initiated due to change in cause.
  for ex. periodicall...rlc unrecoverabel error, reselection...rlc unrecoverable error
  rl failure..rlc unrecoverable error */
  if (((rrccu_rlc_error_info.error_on_srb == TRUE) && 
      (cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4 == FALSE)) ||
       ((rrccu_rlc_error_info.error_on_urb == TRUE) && 
      (cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove == FALSE)))
  {
    if (RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
        rrc_CellUpdateConfirm_r6_IEs,dl_CounterSynchronisationInfo)) 
    {
      WRRC_MSG0_HIGH("S-RNS relocation is Implicit rlc_Re_establish");
    }
    else
    {
      rrc_cu_uu_log_event_failure_cause = RRC_CU_UU_INVALID_CONFIG;
      rrccu_resend_cell_update_msg(RRCCU_NOT_INCLUDE_FAILURE_CAUSE);
      /* continue with rrccu state  RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM */
      return;
    }
  }

#ifdef FEATURE_WCDMA_HS_FACH
  if(cu_confirm_ptr->m.new_H_RNTIPresent)
  {
    if(rrccu_update_hrnti_from_ota(&cu_confirm_ptr->new_H_RNTI,transition_config.toc_ptr) == FAILURE)
    {
      WRRC_MSG0_ERROR("HRNTI invalid");
      msg_not_valid = TRUE;
    }
  }
#endif

  rrccu_resp_msg = rrccu_find_response_to_cell_update_confirm_r6(cu_confirm_ptr);
  /* If CUC doesnt set OC, validate if the existing ehs queues are holding a proper window size */
  /* Calling 'rrcllc_validate_hs_ehs_window_size_for_sec' directly without checking for 
     num of carriers. As CUC doesnt set OC, num sec carriers is anyways 0. We can reject CUC
     if window size is > 32 */
 /*  Note: directed_cell_info.freq_info_present and directed_cell_info.pscr_present will always be FALSE 
     for NO RSP and UMIC response. Added those conditions to just maintain the code consistency. 
     These conditions doesnt impact the logics. If these conditions are redundant, we can remove
     such condition everywhere  */
  if(((RRCCU_NO_RESP_MSG == rrccu_resp_msg)||(RRCCU_UMIC_COMPLETE_RESP_MSG == rrccu_resp_msg)) &&
    (((directed_cell_info.freq_info_present == FALSE )&& (directed_cell_info.pscr_present == FALSE ))
    ||(rrccu_state_indicator ==rrc_RRC_StateIndicator_cell_DCH)))
  {
    if(FALSE == rrcllc_validate_hs_ehs_window_size_for_sec(rrccu_state_indicator))
    {
      rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;
      rrccu_failure_cause.failureCause.t = T_rrc_FailureCauseWithProtErr_invalidConfiguration;
      rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
	  return;
    }
  }

  /* check whether reconfiguration is involved and OC is already set by some other 
  procedure */ 
  if ((rrccu_resp_msg != RRCCU_NO_RESP_MSG) && 
      (rrccu_resp_msg != RRCCU_UMIC_COMPLETE_RESP_MSG) &&
      ((rrcllc_get_ordered_config_status_wo_f3() != OC_NOT_SET) || (rrccu_do_not_acpt_nw_conf_in_cuc == TRUE)))
  {
    /* Set the Transaction Id */
    rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;
    /* Set Failure cause */

    rrccu_failure_cause.failureCause.t = 
      T_rrc_FailureCauseWithProtErr_incompatibleSimultaneousReconfiguration;

    rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
  }
  else
  {

    rrc_update_reconfig_waiting_for_l2ack_dch(MAX_NUM_OF_PROCEDURES);

    /* if this cell update was due to RL faiure then stop any re-est timer
    that is running */
    if(((rrccu_cell_update_cause == rrc_CellUpdateCause_radiolinkFailure)||  
        (rrccu_cell_update_cause == rrc_CellUpdateCause_re_enteredServiceArea)||
      (rrccu_cell_update_cause == rrc_CellUpdateCause_rlc_unrecoverableError)) &&
      (rrccu_failure_state == RRC_STATE_CELL_DCH))
    {
      if (rrccu_rl_failure_info.t314_info.timer_status == RE_EST_TIMER_STARTED)
      {
        WRRC_MSG0_HIGH("Stopping T314");
        rrctmr_stop_timer(RRCTMR_T_314_TIMER); 
      }
      if (rrccu_rl_failure_info.t315_info.timer_status == RE_EST_TIMER_STARTED)
      {
        WRRC_MSG0_HIGH("Stopping T315");
        rrctmr_stop_timer(RRCTMR_T_315_TIMER); 
      }
    }
    state = rrc_translate_state_indicator_to_state(rrccu_state_indicator);

    /* In case of Fre-redirection info from FACh->FACH or FACH->PCH the OC 
     * needs to be set force the OC to be set
     */
#ifdef FEATURE_WCDMA_HS_FACH
  rrccu_update_rnti_from_cu_cnf(cu_confirm_ptr->m.new_H_RNTIPresent,
                                cu_confirm_ptr->m.newPrimary_E_RNTIPresent,
                                &cu_confirm_ptr->new_H_RNTI, 
                                &cu_confirm_ptr->newPrimary_E_RNTI,
                                &directed_cell_info);
#endif
    if((rrccu_resp_msg == RRCCU_UMIC_COMPLETE_RESP_MSG)
       &&(((directed_cell_info.freq_info_present == FALSE )&& 
              (directed_cell_info.pscr_present == FALSE ))
            ||(  rrccu_state_indicator ==rrc_RRC_StateIndicator_cell_DCH))
        )
    {
      if (rrc_get_rlc_size_change_status_for_procedure_id(RRC_PROCEDURE_CU))
      {
        WRRC_MSG0_HIGH("RLC Size change detecting.  calling smc func");
        rrcsmc_update_hfn_for_rlc_rb(rlc_size_change_in_progress.rb_id, 
                                     rlc_size_change_in_progress.direction);
      }
      else
      {
        WRRC_MSG0_HIGH("NO RLC size change detected.");
      }

     if (!rrccu_cucnf_for_srns_relocation)
     {
        /* procedure does not involve SRNS relocation */

        /* need to send RNTI update request if any of the RNTIs is present
              in the message */
       if ((RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
             rrc_CellUpdateConfirm_r6_IEs,new_C_RNTI)) ||
           (RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr,
            rrc_CellUpdateConfirm_r6_IEs,new_U_RNTI)))
       {
          /* Allocates the buffer to RRC Internal command */
          cmd_ptr =  rrc_get_int_cmd_buf();
          /* Fill parameters for RRC_RNTI_UPDATE_REQ command */
          cmd_ptr->cmd.rnti_update_req.procedure = RRC_PROCEDURE_CU;
          cmd_ptr->cmd_hdr.cmd_id = RRC_RNTI_UPDATE_REQ;

          if (RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
               rrc_CellUpdateConfirm_r6_IEs,new_C_RNTI)) 
          {
            rrc_translate_crnti(&cu_confirm_ptr->new_C_RNTI,&crnti);
            cmd_ptr->cmd.rnti_update_req.crnti_action = RRC_RNTI_UPDATE;
            cmd_ptr->cmd.rnti_update_req.crnti = crnti;
#ifdef FEATURE_WCDMA_HS_RACH
            if(rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH)
            {
              rrchsrach_set_hspa_rnti_stored_cell_pch(ordered_config_ptr,TRUE);
            }
#endif
          }
          else
          {
            cmd_ptr->cmd.rnti_update_req.crnti_action = RRC_RNTI_NOCHANGE;
          }

          if(RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
             rrc_CellUpdateConfirm_r6_IEs,new_U_RNTI))
          {
            rrc_translate_urnti(&cu_confirm_ptr->new_U_RNTI, &urnti);
            cmd_ptr->cmd.rnti_update_req.urnti_action = RRC_RNTI_UPDATE;
            cmd_ptr->cmd.rnti_update_req.urnti= urnti;
          }
          else
          {
            cmd_ptr->cmd.rnti_update_req.urnti_action = RRC_RNTI_NOCHANGE;
          }

          /* Indicate to LLC if RLC for SRBs needs to be re-established */
          if(cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4 == TRUE)
          {
            cmd_ptr->cmd.rnti_update_req.rlc_re_establish_srb = TRUE;
          }
          else
          {
            cmd_ptr->cmd.rnti_update_req.rlc_re_establish_srb = FALSE;
          }

          /* Indicate to LLC if RLC for User plane RBs needs to be re-established */
          if(cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove == TRUE)
          {
            cmd_ptr->cmd.rnti_update_req.rlc_re_establish_rab = TRUE;
          }
          else
          {
            cmd_ptr->cmd.rnti_update_req.rlc_re_establish_rab = FALSE;
          }

          cmd_ptr->cmd.rnti_update_req.cnf_required = TRUE;
          WRRC_MSG2_HIGH("Sending RNTI update req CRNTI_stat:%d, URNTI_stat:%d", 
                    cmd_ptr->cmd.rnti_update_req.crnti_action,
                    cmd_ptr->cmd.rnti_update_req.urnti_action);

          rrc_put_int_cmd(cmd_ptr);       /* sends the command to RRC  LLC. */

          rrccu_substate = RRCCU_WAIT_FOR_RNTI_UPDATE_CNF;         
        }
        else
        {
          if (C_RNTI_NOT_VALID == rrcllc_get_current_crnti_status())
          {
            /* should not come here as this condition is already taken care in downlink
            sdu processing */
            WRRC_MSG1_ERROR("RNTI absent for UMIC message, next state %d", 
                    rrc_get_state());
            /* Set the Transaction Id */
            rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;

            /* Set Failure cause */
            rrccu_failure_cause.failureCause.t = 
              T_rrc_FailureCauseWithProtErr_invalidConfiguration;
       

            rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
            /* continue with rrccu state  RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM */
            return;
          }
          rrccu_send_response_msg();
        }
        if( RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
            rrc_CellUpdateConfirm_r6_IEs,cn_InformationInfo))
        {
          (void) rrc_ccm_send_nas_cn_info_r6(&(cu_confirm_ptr->cn_InformationInfo));
        } 
      }
      else
      {
        /* procedure involves SRNS relocation so store the C-RNTI
        and send rlc_reestablishment request to SMC . RNTI update 
        will be done after RLC re-establishment*/
        if (RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
              rrc_CellUpdateConfirm_r6_IEs,new_C_RNTI)) 
        {
          rrccu_new_crnti_valid = TRUE;
          rrc_translate_crnti(&cu_confirm_ptr->new_C_RNTI,&rrccu_new_crnti);
#ifdef FEATURE_WCDMA_HS_RACH
          if(rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH)
          {
            rrchsrach_set_hspa_rnti_stored_cell_pch(ordered_config_ptr,TRUE);
          }
#endif
        }
        if(RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
           rrc_CellUpdateConfirm_r6_IEs,new_U_RNTI))
        {
          rrccu_new_urnti_valid = TRUE;
          rrc_translate_urnti(&cu_confirm_ptr->new_U_RNTI,&rrccu_new_urnti);
        }
        /* store the rlc re-establishment indications */
        rrccu_reestablish_srb = cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4;
        rrccu_reestablish_rab = cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove;

        //commit fresh values for srns relocation
        rrcsmc_commit_fresh_for_srns_relocation();

        /*send the rlc re-establishment request to SMC to re-establish SRB2 */
        /* Get the command buffer */
        int_cmd_ptr = rrc_get_int_cmd_buf();
          /* Fill in the command id  */
          int_cmd_ptr->cmd_hdr.cmd_id = RRC_RE_EST_RLC_FOR_SRNS_REQ;
          int_cmd_ptr->cmd.rrc_re_est_srns_req.rrc_proc = RRC_PROCEDURE_CU;
          int_cmd_ptr->cmd.rrc_re_est_srns_req.rb_type  = RRC_RE_EST_RB_2;
          int_cmd_ptr->cmd.rrc_re_est_srns_req.cnf_reqd = TRUE;
          WRRC_MSG1_HIGH("RLC Reestablish req for %d ", 
                   RRC_RE_EST_RB_2); 

          rrc_put_int_cmd(int_cmd_ptr);             

          rrccu_substate = RRCCU_WAIT_FOR_SRB2_RE_EST_CNF;         
          if( RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
              rrc_CellUpdateConfirm_r6_IEs,cn_InformationInfo))
          {
            (void) rrc_ccm_send_nas_cn_info_r6(&(cu_confirm_ptr->cn_InformationInfo));
          } 
        }
    }
    /* In case of Fre-redirection info from FACh->FACH or FACH->PCH the OC 
     * needs to be set force the OC to be set
     */
    else if( (rrccu_resp_msg == RRCCU_NO_RESP_MSG)
  &&(((directed_cell_info.freq_info_present == FALSE )&&
         (directed_cell_info.pscr_present == FALSE ))
        ||(  rrccu_state_indicator ==rrc_RRC_StateIndicator_cell_DCH))
        ) 
    {
      rrccu_check_and_send_response_to_previous_cell_upd_cnf();

        /* if any rlc entity has to be re-established then re-establish it before configuring channels. */
        if((cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4 == TRUE) ||
            (cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove == TRUE))
        {
          /* store the rlc re-establishment indications */
          rrccu_reestablish_srb = cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4;
          rrccu_reestablish_rab = cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove;
          rrccu_new_crnti_valid = FALSE;
          rrccu_new_urnti_valid = FALSE;
          rrccu_send_rnti_update_req(FALSE);
          WRRC_MSG2_HIGH("CU Confirm R6: RNTI_UPDATE_REQ  to reestablish SRBs(%d)  DataRB (%d)",
                       rrccu_reestablish_srb,rrccu_reestablish_rab);
        }
        rrccu_reestablish_srb = FALSE;
        rrccu_reestablish_rab = FALSE;

    /* if the next state is cell_pch or ura_pch then setup pcch */
      if ((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH) ||
           (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH))
      {
        if( RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
            rrc_CellUpdateConfirm_r6_IEs,cn_InformationInfo))
        {
          (void) rrc_ccm_send_nas_cn_info_r6(&(cu_confirm_ptr->cn_InformationInfo));
        } 
       /*set the UTRAN DRX coef in rrcllc */
        rrcllc_set_utran_drx_info (rrccu_utran_drx_coef); 
        rrccu_establish_pcch_rb (state);
        rrccu_substate = RRCCU_WAIT_FOR_PCCH_RB_EST_CNF;
      }
      else 
      {
        /* Reset the state machine and the procedure ends */
        rrccu_substate = RRCCU_INITIAL;
        /* Start timer T305 */
        rrccu_start_t_305_timer();
        if( RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
            rrc_CellUpdateConfirm_r6_IEs,cn_InformationInfo))
        {
          (void) rrc_ccm_send_nas_cn_info_r6(&(cu_confirm_ptr->cn_InformationInfo));
        } 
       /* Inform all registered RRC procedures that Cell
         Update is completed */
        rrccu_inform_cell_update_completed();

     
        rrccu_process_successful_completion();
       
        /*call the procedure to clear the global variabls */
        rrccu_clear_procedure();
        rrccu_init_last_cu_cnf_info();

      }
    }
    else
    {
      status = rrcllc_set_ordered_config(RRC_PROCEDURE_CU, state, dl_sdu_type, msg_ptr) ;
      switch( status  )
      {
        case ORDERED_CONFIG_SET:
          /* set the flag.Later it will be used while clearing the OC */
          rrccu_oc_set_by_cu = TRUE;

          if ((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH)||
              (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH))
          {
            /*call the function that evaluates the directed cell info and set the flags accordingly */
            if (rrcrb_validate_directed_cell_info (directed_cell_info) == FALSE)
            {
              if(rrccsp_check_initiate_cell_selection_handling(&directed_cell_info) == FALSE)
              {
                rrccu_cu_initiate_reqd.cu_reqd = TRUE;
                rrccu_cu_initiate_reqd.cu_cause = rrc_CellUpdateCause_cellReselection;
              }
              else
              {
                rrccu_int_data.rrccu_cell_selection_trans_from_fach = TRUE;
              }
            }

            if (rrccu_resp_msg == RRCCU_UMIC_COMPLETE_RESP_MSG)
            {
              if (rrc_get_rlc_size_change_status_for_procedure_id(RRC_PROCEDURE_CU))
              {
                rrcsmc_update_hfn_for_rlc_rb(rlc_size_change_in_progress.rb_id, 
                                             rlc_size_change_in_progress.direction);
              }
            }
#ifdef FEATURE_WCDMA_HS_FACH
            if((rrcenhstate_camped_cell_supports_e_fach() == TRUE) &&
               ((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH) || 
                (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH)))
            {
              if((cu_confirm_ptr->m.new_H_RNTIPresent)
#ifdef FEATURE_WCDMA_HS_RACH
                || (cu_confirm_ptr->m.newPrimary_E_RNTIPresent)
#endif
                )
            {
#ifdef FEATURE_WCDMA_HS_RACH
                if((rrchsrach_camped_cell_supports_hsrach() == TRUE) && cu_confirm_ptr->m.newPrimary_E_RNTIPresent)
                {
                  current_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = TRUE;
                  (void)rrc_translate_ernti(&cu_confirm_ptr->newPrimary_E_RNTI, &current_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti);
                }
#endif
                rrcllc_establish_srb_rab_in_efach(RRC_E_FACH_DEDICATED,RRC_PROCEDURE_CU,TRUE);
                  
              }
            }
#endif

            /* copy the channel config info in to a local buffer
            we should configure the channels after the response message
            is sent */
            /* Initialize the no of RBs */
            no_of_RBs = 0;
            /* Fill in the command parameters for RRC_CHANNEL_CONFIG_REQ */

            /* Fill in parameters for RRC_CHANNEL_CONFIG_REQ command */
              /* Change the state if it is not CELL_PCH or URA_PCH */

            if(RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr,
               rrc_CellUpdateConfirm_r6_IEs,rb_InformationReleaseList))
            {
              /* set to flag to indicate that rb release information is present
              in the message. This information will be used after channel configu
              ration to release the rbs from established_rab and also to indicate
              to the upper layers about RAB release if necessary */
              rrccu_rb_release_info.rrccu_rb_release_in_cucnf = TRUE;
              /* Save the linked list head pointer */ 
              rrc_rb_information_release_list = 
                &cu_confirm_ptr->rb_InformationReleaseList;
              rb_idx=0;
              while(rrc_rb_information_release_list->n > rb_idx)
              { 
                if( rrc_rb_information_release_list->elem[rb_idx] == DCCH_DT_LOW_PRI_RADIO_BEARER_ID)
                {
                  if(RRCLCM_RLC_LC_ID_NOT_FOUND == rrclcm_check_dl_rlc_lc_id(
                                                   UE_LOGCHAN_DCCH,
                                                   DCCH_DT_LOW_PRI_RADIO_BEARER_ID,
                                                   UE_MODE_ACKNOWLEDGED_DATA))
                  {
                    WRRC_MSG1_HIGH("Ignore Non-exitent rb_id =%d in cucnf",rrc_rb_information_release_list->elem[rb_idx]);
                    rb_idx++;
                    continue;
                  }
                }
                else if(! rrc_find_rb_in_est_rabs(rrc_rb_information_release_list->elem[rb_idx])) 
                {
                  WRRC_MSG1_HIGH("Ignore Non-exitent rb_id =%d in cucnf",rrc_rb_information_release_list->elem[rb_idx]);
                  rb_idx++;
                  continue;
                }
                else if (MAX_RB != rrccu_check_if_rbid_present_in_rrccu_rb_release_info(rrc_rb_information_release_list->elem[rb_idx],no_of_RBs))
                {
                  WRRC_MSG1_ERROR(" Ignoring Duplicate RB ID % d in CU ",rrc_rb_information_release_list->elem[rb_idx]);
                  rb_idx++;
                  continue;
                }

                WRRC_MSG1_HIGH("Release RB i.d=%d",rrc_rb_information_release_list->elem[rb_idx]);

                rrccu_chan_config_info.rb_info[no_of_RBs].rb_id = 
                rrc_rb_information_release_list->elem[rb_idx];

                rrccu_chan_config_info.rb_info[no_of_RBs].rb_config = RELEASE_RB;

                /* store the rb info to release list in local buffer which will
                be used later to release it from established_rab variable */
                rrccu_rb_release_info.rb_id[no_of_RBs]=rrc_rb_information_release_list->elem[rb_idx];

                /* Advance the Linked List pointer */
                rb_idx++;
                no_of_RBs++;
              } 

              rrccu_rb_release_info.num_rbs = no_of_RBs;

              rrcrb_update_mac_rab_status(RRC_PROCEDURE_CU, RRC_CS_DOMAIN_CN_ID,
                                          &cu_confirm_ptr->rb_InformationReleaseList,
                                          FALSE);
            }
            if(RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr,
               rrc_CellUpdateConfirm_r6_IEs,rb_InformationReconfigList))
            {
              rb_idx =0;
              
              do
              { 
                /* Save the linked list head pointer */
                rrc_rb_information_reconfig_ptr = 
                &cu_confirm_ptr->rb_InformationReconfigList.elem[rb_idx];
                rrccu_chan_config_info.rb_info[no_of_RBs].rb_id = 
                        rrc_rb_information_reconfig_ptr->rb_Identity;

                rrccu_chan_config_info.rb_info[no_of_RBs].rb_config = RECONFIG_RB;
                rrccu_chan_config_info.rb_info[no_of_RBs].rb_config = RECONFIG_RB_OTA;
                rrccu_chan_config_info.rb_info[no_of_RBs].ul_cfg_mask = 0;
                rrccu_chan_config_info.rb_info[no_of_RBs].dl_cfg_mask = 0;
                if((RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_rb_information_reconfig_ptr,
					rrc_RB_InformationReconfig_r6,rlc_Info))
                    &&(RRC_MSG_COMMON_BITMASK_IE(rrc_rb_information_reconfig_ptr->rlc_Info,
                    rrc_RLC_Info_r6,ul_RLC_Mode)))
                {
                  rrccu_chan_config_info.rb_info[no_of_RBs].ul_cfg_mask = MODIFY_RB_CFG;
                }
                if((RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_rb_information_reconfig_ptr, rrc_RB_InformationReconfig_r6,rlc_Info))
                    &&(RRC_MSG_COMMON_BITMASK_IE(rrc_rb_information_reconfig_ptr->rlc_Info,
                    rrc_RLC_Info_r6,dl_RLC_Mode)))
                {
                  rrccu_chan_config_info.rb_info[no_of_RBs].dl_cfg_mask = MODIFY_RB_CFG;
                }
                if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_rb_information_reconfig_ptr, 
                    rrc_RB_InformationReconfig_r6,rb_StopContinue))
                {
                  if (rrc_rb_information_reconfig_ptr->rb_StopContinue == rrc_RB_StopContinue_stopRB)
                  {
                    rrccu_chan_config_info.rb_info[no_of_RBs].ul_cfg_mask |= STOP_RB_CFG; 
                    rrccu_chan_config_info.rb_info[no_of_RBs].dl_cfg_mask |= STOP_RB_CFG;
                    WRRC_MSG1_HIGH("Stop recvd for RB %d", (rrc_rb_information_reconfig_ptr->rb_Identity));
                  }
                  else if (rrc_rb_information_reconfig_ptr->rb_StopContinue == rrc_RB_StopContinue_continueRB)
                  {
                    rrccu_chan_config_info.rb_info[no_of_RBs].ul_cfg_mask |= CONTINUE_RB_CFG; 
                    rrccu_chan_config_info.rb_info[no_of_RBs].dl_cfg_mask |= CONTINUE_RB_CFG;
                    WRRC_MSG1_HIGH("Continue recvd for RB %d", (rrc_rb_information_reconfig_ptr->rb_Identity));
                  }
                }
                /* Advance the Linked List pointer */
                rb_idx++;
                no_of_RBs++;
                 
              } while(cu_confirm_ptr->rb_InformationReconfigList.n > rb_idx) ;
            }
            if(RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr,
               rrc_CellUpdateConfirm_r6_IEs,rb_InformationAffectedList))
            {
              /* Save the head pointer of linked list */
              rrc_rb_information_affected_list = 
                &cu_confirm_ptr->rb_InformationAffectedList;
			  rb_idx=0;

              rrccu_chan_config_info.rb_info[no_of_RBs].rb_id = 
                cu_confirm_ptr->rb_InformationAffectedList.elem[rb_idx].rb_Identity;

              rrccu_chan_config_info.rb_info[no_of_RBs].rb_config = RECONFIG_RB;
              rrccu_chan_config_info.rb_info[no_of_RBs].rb_config = RECONFIG_RB_OTA;
              rrccu_chan_config_info.rb_info[no_of_RBs].ul_cfg_mask = rrccu_chan_config_info.rb_info[no_of_RBs].dl_cfg_mask = MODIFY_RB_CFG;
              do
              { 
                rrccu_chan_config_info.rb_info[no_of_RBs].rb_id = 
                    rrc_rb_information_affected_list->elem[rb_idx].rb_Identity;

                rrccu_chan_config_info.rb_info[no_of_RBs].rb_config = RECONFIG_RB;
                rrccu_chan_config_info.rb_info[no_of_RBs].rb_config = RECONFIG_RB_OTA;
                rrccu_chan_config_info.rb_info[no_of_RBs].ul_cfg_mask = rrccu_chan_config_info.rb_info[no_of_RBs].dl_cfg_mask = MODIFY_RB_CFG;
                /* Advance the Linked List pointer */
                rb_idx++;

                no_of_RBs++;

              } while(rrc_rb_information_affected_list->n > rb_idx);
            }

            rrccu_chan_config_info.num_rbs = no_of_RBs;
            rrccu_chan_config_reqd = TRUE;
            if (! rrccu_cucnf_for_srns_relocation)
            {
              /* procedure does not involve SRNS relocation */

              /* CRNTI always must be present to send the 
              response message */
              /* if cucnf message has new C-RNTI  then we need to update
              the C-RNTI in mac first and send the response and then start
              the channel configuration */
              if (RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
                    rrc_CellUpdateConfirm_r6_IEs,new_C_RNTI))
              {
                /* Allocates the buffer to RRC Internal command */
                cmd_ptr =  rrc_get_int_cmd_buf();

                /* Fill parameters for RRC_RNTI_UPDATE_REQ command */
                cmd_ptr->cmd.rnti_update_req.procedure = RRC_PROCEDURE_CU;
                cmd_ptr->cmd_hdr.cmd_id = RRC_RNTI_UPDATE_REQ;

                rrc_translate_crnti(&cu_confirm_ptr->new_C_RNTI,&crnti);
                cmd_ptr->cmd.rnti_update_req.crnti_action = RRC_RNTI_UPDATE;
                cmd_ptr->cmd.rnti_update_req.crnti = crnti;

                if(RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
                   rrc_CellUpdateConfirm_r6_IEs,new_U_RNTI))
                {
                  rrc_translate_urnti(&cu_confirm_ptr->new_U_RNTI, &urnti);
                  cmd_ptr->cmd.rnti_update_req.urnti_action = RRC_RNTI_UPDATE;
                  cmd_ptr->cmd.rnti_update_req.urnti= urnti;
                }
                else
                {
                  cmd_ptr->cmd.rnti_update_req.urnti_action = RRC_RNTI_NOCHANGE;
                }
                /* Indicate to LLC if RLC for SRBs needs to be re-established */
                if(cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4 == TRUE)
                {
                  cmd_ptr->cmd.rnti_update_req.rlc_re_establish_srb = TRUE;
                }
                else
                {
                  cmd_ptr->cmd.rnti_update_req.rlc_re_establish_srb = FALSE;
                }
                /* Indicate to LLC if RLC for User plane RBs needs to be re-established */
                if(cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove == TRUE)
                {
                  cmd_ptr->cmd.rnti_update_req.rlc_re_establish_rab = TRUE;
                }
                else
                {
                  cmd_ptr->cmd.rnti_update_req.rlc_re_establish_rab = FALSE;
                }
                cmd_ptr->cmd.rnti_update_req.cnf_required = TRUE;

                WRRC_MSG2_HIGH("Sending RNTI update req CRNTI_stat:%d, URNTI_stat:%d", 
                          cmd_ptr->cmd.rnti_update_req.crnti_action,
                          cmd_ptr->cmd.rnti_update_req.urnti_action);

                rrc_put_int_cmd(cmd_ptr);       /* sends the command to RRC  LLC. */

                rrccu_substate = RRCCU_WAIT_FOR_RNTI_UPDATE_CNF;         
                if( RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
                    rrc_CellUpdateConfirm_r6_IEs,cn_InformationInfo))
                {
                  (void) rrc_ccm_send_nas_cn_info_r6(&(cu_confirm_ptr->cn_InformationInfo));
                } 
              }
              else
              {
                /* We will be in Cell_FACH state at this time and going to send the
                response message in Cell_FACH state.*/
                WRRC_MSG1_HIGH("RNTI absent for RB resp message, next state%d", 
                        rrc_get_state());
                if( RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
                    rrc_CellUpdateConfirm_r6_IEs,cn_InformationInfo))
                {
                  (void) rrc_ccm_send_nas_cn_info_r6(&(cu_confirm_ptr->cn_InformationInfo));
                } 

                if ((rrccu_int_data.rrccu_cell_selection_trans_from_fach) &&
                    (rrccu_resp_msg == RRCCU_NO_RESP_MSG))
                {
                  rrccu_intiate_cell_selection_fach_pch_cu_cnf(); 
                }
                else
                {
                  /* send the response message on the old configuration */
                  rrccu_send_response_msg();
                }
              }
            }
            else
            {
              /* procedure involves SRNS relocation so store the C-RNTI
              and send rlc_reestablishment request to SMC . RNTI update 
              will be done after RLC re-establishment*/
              if (RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
                    rrc_CellUpdateConfirm_r6_IEs,new_C_RNTI)) 
              {
                rrccu_new_crnti_valid = TRUE;
                rrc_translate_crnti(&cu_confirm_ptr->new_C_RNTI,&rrccu_new_crnti);
              }
              if(RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
                 rrc_CellUpdateConfirm_r6_IEs,new_U_RNTI))
              {
                rrccu_new_urnti_valid = TRUE;
                rrc_translate_urnti(&cu_confirm_ptr->new_U_RNTI,&rrccu_new_urnti);
              }
              /* store the rlc re-establishment indications */
              rrccu_reestablish_srb = cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4;
              rrccu_reestablish_rab = cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove;

              //commit fresh values for srns relocation
              rrcsmc_commit_fresh_for_srns_relocation();

              /*send the rlc re-establishment request to SMC to re-establish SRB2 */
              /* Get the command buffer */
              int_cmd_ptr = rrc_get_int_cmd_buf();
                /* Fill in the command id  */
                int_cmd_ptr->cmd_hdr.cmd_id = RRC_RE_EST_RLC_FOR_SRNS_REQ;
                int_cmd_ptr->cmd.rrc_re_est_srns_req.rrc_proc = RRC_PROCEDURE_CU;
                int_cmd_ptr->cmd.rrc_re_est_srns_req.rb_type  = RRC_RE_EST_RB_2;
                int_cmd_ptr->cmd.rrc_re_est_srns_req.cnf_reqd = TRUE;
                WRRC_MSG1_HIGH("RLC Reestablish req for %d ", 
                         RRC_RE_EST_RB_2); 

                rrc_put_int_cmd(int_cmd_ptr);             

                rrccu_substate = RRCCU_WAIT_FOR_SRB2_RE_EST_CNF;         
                if( RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
                    rrc_CellUpdateConfirm_r6_IEs,cn_InformationInfo))
                {
                  (void) rrc_ccm_send_nas_cn_info_r6(&(cu_confirm_ptr->cn_InformationInfo));
                } 
              }
          }
          else /*normal fach-fach or fach-dch configuration */
          {
            /* if any rlc entity has to be re-established then re-establish it 
            before configuring channels. */

            if((rrccu_resp_msg == RRCCU_UMIC_COMPLETE_RESP_MSG) &&
               (rrccu_state_indicator == rrc_RRC_StateIndicator_cell_FACH ))
            {
              if (rrc_get_rlc_size_change_status_for_procedure_id(RRC_PROCEDURE_CU))
              {
                WRRC_MSG0_HIGH("RLC Size change detecting.  calling smc func");
                rrcsmc_update_hfn_for_rlc_rb(rlc_size_change_in_progress.rb_id, 
                                             rlc_size_change_in_progress.direction);
              }
              else
              {
                WRRC_MSG0_HIGH("NO RLC size change detected.");
              }
            }


            if((cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4 == TRUE) ||
                (cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove == TRUE))
            {
              /* store the rlc re-establishment indications */
              rrccu_reestablish_srb = cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4;
              rrccu_reestablish_rab = cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove;
              rrccu_new_crnti_valid = FALSE;
              rrccu_new_urnti_valid = FALSE;
              rrccu_send_rnti_update_req(FALSE);
              ps_rb_re_establish_indicator = cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove;
              WRRC_MSG1_HIGH("CU: RB5 or higher re-establish indicator %d",
                       cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove);
            }
            rrccu_reestablish_srb = FALSE;
            rrccu_reestablish_rab = FALSE;
            /* store the C-RNTI
            and send rlc_reestablishment request to SMC . RNTI update 
            will be done after Channel configuration*/
            if (RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
                  rrc_CellUpdateConfirm_r6_IEs,new_C_RNTI) 
                  && (rrccu_state_indicator != rrc_RRC_StateIndicator_cell_DCH) ) 
            {
              rrccu_new_crnti_valid = TRUE;
              rrc_translate_crnti(&cu_confirm_ptr->new_C_RNTI,&rrccu_new_crnti);
            }
            if(RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
               rrc_CellUpdateConfirm_r6_IEs,new_U_RNTI))
            {
              rrccu_new_urnti_valid = TRUE;
              rrc_translate_urnti(&cu_confirm_ptr->new_U_RNTI,&rrccu_new_urnti);
            }

            /*check whether this procedure involves SRNS reloc */
            if (rrccu_cucnf_for_srns_relocation)
            {
              /*commit fresh values for srns relocation */
              rrcsmc_commit_fresh_for_srns_relocation();
            }
            /* Allocates the buffer to RRC Internal command */
              cmd_ptr =  rrc_get_int_cmd_buf();
              rrccu_cipher_update_required = FALSE;

              /* Initialize the no of RBs */
              no_of_RBs = 0;
              /* Fill in the command parameters for RRC_CHANNEL_CONFIG_REQ */
              cmd_ptr->cmd_hdr.cmd_id = RRC_CHANNEL_CONFIG_REQ;
              cmd_ptr->cmd.chan_config_req.procedure = RRC_PROCEDURE_CU;

              /* Fill in parameters for RRC_CHANNEL_CONFIG_REQ command */
              if (rrccu_state_indicator == rrc_RRC_StateIndicator_cell_DCH  )
              {
                //if we r going to dch, then dl-common-info-for-all-rl will be present..
                //check if ciphering is active in mac for cs domain, if it is then,
                //start 2 tiered HHO procedure STEP_1 and STEP_2 for rl-re-establishment
                if(rrcsmc_tm_ciph_active() == TRUE)
                {
                  uint32 mac_d_hfn_l=RRCSMC_INVALID_HFN_VALUE;

                  WRRC_MSG0_HIGH("RL-cipher present in TM-rb's");

                  if (RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
                      rrc_CellUpdateConfirm_r6_IEs,dl_CommonInformation))
                  {
                    if(RRC_MSG_COMMON_BITMASK_IE(cu_confirm_ptr->dl_CommonInformation,
                        rrc_DL_CommonInformation_r6,dl_dpchInfoCommon))
                    {
                      (void) rrcrb_get_mac_d_hfn(
                       (RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr->dl_CommonInformation.dl_dpchInfoCommon.u.
                         dl_DPCH_InfoCommon,rrc_DL_DPCH_InfoCommon_r6,mac_d_HFN_initial_value)),
                        &cu_confirm_ptr->dl_CommonInformation.dl_dpchInfoCommon.u.
                         dl_DPCH_InfoCommon->mac_d_HFN_initial_value,
                        &mac_d_hfn_l);
                    }
                  }

                  if(SUCCESS == rrcsmc_process_cipher_config_for_hho(mac_d_hfn_l)) 
                  {
                    rrccu_cipher_update_required = TRUE;
                  }
                }
                else
                {
                  WRRC_MSG0_HIGH("RL-cipher not-present in TM");
                }

                /* Change the state if it is not CELL_PCH or URA_PCH */
                cmd_ptr->cmd.chan_config_req.rrc_state_change_required = TRUE;
                cmd_ptr->cmd.chan_config_req.next_state = state;
              }
              else
              {
                cmd_ptr->cmd.chan_config_req.rrc_state_change_required = FALSE;
              }
              cmd_ptr->cmd.chan_config_req.rrc_channel_config_cnf_required = TRUE;

              if(RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr,
                 rrc_CellUpdateConfirm_r6_IEs,rb_InformationReleaseList))
              {
                /* set to flag to indicate that rb release information is present
                            in the message. This information will be used after channel configu
                           ration to release the rbs from established_rab and also to indicate
                            to the upper layers about RAB release if necessary */
                rrccu_rb_release_info.rrccu_rb_release_in_cucnf = TRUE;

                /* Save the linked list head pointer */ 
                rrc_rb_information_release_list = 
                  &cu_confirm_ptr->rb_InformationReleaseList;

                /* If voice RAB still exist, then indicate layer 1 that next configuration is going to
                            include AMR configuration.
                            This check is not required if state change indication is either cell_PCH, URA_PCH or
                            CELL_FACH, because if voice is configured then next state has to be CELL_DCH.
                            */
                if ((rrc_RRC_StateIndicator_cell_DCH == rrccu_state_indicator) && (FALSE == 
                    rrc_is_given_rb_rel_list_releases_all_rb_for_voice_rab(
                                      rrc_rb_information_release_list)))
                {
                  rrc_indicate_layer1_next_config_is_for_voice();
                }
                rb_idx=0;

                while(rrc_rb_information_release_list->n > rb_idx)
                { 
                  if( rrc_rb_information_release_list->elem[rb_idx] == DCCH_DT_LOW_PRI_RADIO_BEARER_ID)
                  {
                  if(RRCLCM_RLC_LC_ID_NOT_FOUND == rrclcm_check_dl_rlc_lc_id(
                                                   UE_LOGCHAN_DCCH,
                                                   DCCH_DT_LOW_PRI_RADIO_BEARER_ID,
                                                   UE_MODE_ACKNOWLEDGED_DATA))
                    {
                      WRRC_MSG1_HIGH("Ignore Non-exitent rb_id =%d in cucnf",rrc_rb_information_release_list->elem[rb_idx]);
                      rb_idx++;
                      continue;
                    }
                  }
                  else if(! rrc_find_rb_in_est_rabs(rrc_rb_information_release_list->elem[rb_idx]))
                  {
                    WRRC_MSG1_HIGH("Ignore Non-exitent rb_id = %d in cucnf",rrc_rb_information_release_list->elem[rb_idx]);
                    rb_idx++;
                    continue;
                  }
                  else if (MAX_RB != rrccu_check_if_rbid_present_in_rrccu_rb_release_info(rrc_rb_information_release_list->elem[rb_idx],no_of_RBs))
                  {
                    WRRC_MSG1_ERROR(" Ignoring Duplicate RB ID % d in CU ",rrc_rb_information_release_list->elem[rb_idx]);
                    rb_idx++;
                    continue;
                  }

                  WRRC_MSG1_HIGH("Release RB i.d=%d",rrc_rb_information_release_list->elem[rb_idx]);

                  cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].rb_id = 
                  rrc_rb_information_release_list->elem[rb_idx];

                  cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].rb_config = RELEASE_RB;

                  /* store the rb info to release list in local buffer which will
                  be used later to release it from established_rab variable */
                  rrccu_rb_release_info.rb_id[no_of_RBs]=rrc_rb_information_release_list->elem[rb_idx];

                  /* Advance the Linked List pointer */
                  rb_idx++;

                  no_of_RBs++;

                }

                rrccu_rb_release_info.num_rbs = no_of_RBs;

                rrcrb_update_mac_rab_status(RRC_PROCEDURE_CU, RRC_CS_DOMAIN_CN_ID,
                                            &cu_confirm_ptr->rb_InformationReleaseList,
                                            FALSE);
              }
              else
              {
                /* It means CU Confirm doesnt include information to release any RB. 
                   check if AMR RAB was established earlier. If yes then indicate layer 1 that
                   next configuration will be for AMR.
                   This check is not required if state change indication is either cell_PCH, URA_PCH or
                   CELL_FACH, because if voice is configured then next state has to be CELL_DCH.                   
                */
                if ((rrc_RRC_StateIndicator_cell_DCH == rrccu_state_indicator) && 
                                          (TRUE == rrc_is_voice_rab_present()))
                {
                  rrc_indicate_layer1_next_config_is_for_voice();
                }
              }
              if(RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr,
                 rrc_CellUpdateConfirm_r6_IEs,rb_InformationReconfigList))
              {
                rb_idx=0;
                

                do
                { 
                  /* Save the linked list head pointer */
                  rrc_rb_information_reconfig_ptr = 
                  &cu_confirm_ptr->rb_InformationReconfigList.elem[rb_idx];
                  cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].rb_id = 
                  rrc_rb_information_reconfig_ptr->rb_Identity;

                  cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].rb_config = RECONFIG_RB;
                  cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].rb_config = RECONFIG_RB_OTA;
                  cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].ul_cfg_mask = 0;
                  cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].dl_cfg_mask = 0;
                  if((RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_rb_information_reconfig_ptr, rrc_RB_InformationReconfig_r6,rlc_Info))
                      &&(RRC_MSG_COMMON_BITMASK_IE(rrc_rb_information_reconfig_ptr->rlc_Info,rrc_RLC_Info_r6,ul_RLC_Mode)))
                  {
                    cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].ul_cfg_mask = MODIFY_RB_CFG;
                  }
                  if((RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_rb_information_reconfig_ptr, rrc_RB_InformationReconfig_r6,rlc_Info))
                      &&(RRC_MSG_COMMON_BITMASK_IE(rrc_rb_information_reconfig_ptr->rlc_Info,rrc_RLC_Info_r6,dl_RLC_Mode)))
                  {
                    cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].dl_cfg_mask = MODIFY_RB_CFG;
                  }
                  if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_rb_information_reconfig_ptr, 
                      rrc_RB_InformationReconfig_r6,rb_StopContinue))
                  {
                    if (rrc_rb_information_reconfig_ptr->rb_StopContinue == rrc_RB_StopContinue_stopRB)
                    {
                      cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].ul_cfg_mask |= STOP_RB_CFG;
                      cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].dl_cfg_mask |= STOP_RB_CFG;

                      WRRC_MSG1_HIGH("Stop recvd for RB %d", rrc_rb_information_reconfig_ptr->rb_Identity);
                    }
                    else if (rrc_rb_information_reconfig_ptr->rb_StopContinue == rrc_RB_StopContinue_continueRB)
                    {
                      cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].ul_cfg_mask |= CONTINUE_RB_CFG;
                      cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].dl_cfg_mask |= CONTINUE_RB_CFG;
                      WRRC_MSG1_HIGH("Continue recvd for RB %d", rrc_rb_information_reconfig_ptr->rb_Identity);
                    }
                  }
                  /* Advance the Linked List pointer */
                  rb_idx++;

                  no_of_RBs++;

                } while(cu_confirm_ptr->rb_InformationReconfigList.n > rb_idx);
              }
              if(RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr,
                 rrc_CellUpdateConfirm_r6_IEs,rb_InformationAffectedList))
              {
                /* Save the head pointer of linked list */
                rrc_rb_information_affected_list = 
                  &cu_confirm_ptr->rb_InformationAffectedList;
				rb_idx=0;

                do
                { 
                  cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].rb_id = 
                  rrc_rb_information_affected_list->elem[rb_idx].rb_Identity;

                  cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].rb_config = RECONFIG_RB;
                  cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].rb_config = RECONFIG_RB_OTA;
                  cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].ul_cfg_mask = cmd_ptr->cmd.chan_config_req.rb[no_of_RBs].dl_cfg_mask = MODIFY_RB_CFG;
                  /* Advance the Linked List pointer */
                  rb_idx++;

                  no_of_RBs++;

                }while(rrc_rb_information_affected_list->n > rb_idx);
              }
#ifdef FEATURE_WCDMA_HS_FACH
              if (rrcenhstate_camped_cell_supports_e_fach()&&
                     (rrccu_state_indicator ==rrc_RRC_StateIndicator_cell_FACH))
              {
                WRRC_MSG0_HIGH("EFACH:reconfig SRB's/urb's is not");
                no_of_RBs = rrccu_update_chan_config_rb_r7_for_efach(no_of_RBs,cmd_ptr->cmd.chan_config_req.rb);
              }
#endif

              cmd_ptr->cmd.chan_config_req.num_rb_to_config =(int) no_of_RBs;

              rrc_fill_rb_id_chan_req_from_standalone_db(&no_of_RBs, &cmd_ptr->cmd.chan_config_req);

              if(rrccu_state_indicator == rrc_RRC_StateIndicator_cell_DCH)
              {
                /*Fill those RBs in chan_config_req for which RLC PDU size has changed and 
                that are already not present in chan_config_req*/
                rrc_fill_rb_id_chan_req_from_rb_list_mapped_to_dch(&no_of_RBs, 
                              &cmd_ptr->cmd.chan_config_req);
              }

              /*If state transition is Cell_FACH->Cell_DCH, add all the existing AM 
              PS RBs in chan_config_req*/
              if((rrc_get_state() == RRC_STATE_CELL_FACH) && 
                            (rrccu_state_indicator == rrc_RRC_StateIndicator_cell_DCH))
              {
                rrc_fill_rb_id_chan_req_from_est_rabs(&no_of_RBs, 
                              &cmd_ptr->cmd.chan_config_req);
                rrc_fill_srb_in_chan_config_req(&no_of_RBs,&cmd_ptr->cmd.chan_config_req);
              }

              cmd_ptr->cmd.chan_config_req.chan_config_reason = RRCLLC_CHAN_CFG_REASON_NONE;
     
       
              /*call the function that evaluates the directed cell info and set the flags accordingly */
              if ((rrc_RRC_StateIndicator_cell_FACH == rrccu_state_indicator) &&
                  (rrcrb_validate_directed_cell_info (directed_cell_info) == FALSE))
              {
                if(rrccsp_check_initiate_cell_selection_handling(NULL) == FALSE)
                {
                  rrccu_cu_initiate_reqd.cu_reqd = TRUE;
                  rrccu_cu_initiate_reqd.cu_cause = rrc_CellUpdateCause_cellReselection;
                  WRRC_MSG1_HIGH("CHANNEL_CONFIG_REQ for %dRBs",no_of_RBs);
                  rrc_put_int_cmd(cmd_ptr);                 /* sends the command to RRC
                                                             LLC. */
                  rrccu_substate = RRCCU_WAIT_FOR_RB_EST_CNF;         
                }
                else
                {
                  rrccu_intiate_cell_selection_within_fach_cu_cnf(cmd_ptr);
                  cmd_ptr = NULL;
                }
              }
              else
              {
                WRRC_MSG1_HIGH("CHANNEL_CONFIG_REQ for %dRBs", no_of_RBs);
                rrc_put_int_cmd(cmd_ptr); /* sends the command to RRC LLC. */
                rrccu_substate = RRCCU_WAIT_FOR_RB_EST_CNF;         
              }

            if( RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, 
                rrc_CellUpdateConfirm_r6_IEs,cn_InformationInfo))
            {
              (void) rrc_ccm_send_nas_cn_info_r6(&(cu_confirm_ptr->cn_InformationInfo));
            } 
          }
          break;

        case ORDERED_CONFIG_INCOMPATABLE_SIMULTANEOUS_RECONFIG:
          /* Set the Transaction Id */
          rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;

          /* Set Failure cause */
          rrccu_failure_cause.failureCause.t = 
            T_rrc_FailureCauseWithProtErr_incompatibleSimultaneousReconfiguration;


          rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
          break;

        case ORDERED_CONFIG_CONFIGURATION_NOT_SUPPORTED:
          /* Set the Transaction Id */
          rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;

          /* Set Failure cause */
          rrccu_failure_cause.failureCause.t = 
            T_rrc_FailureCauseWithProtErr_configurationUnsupported;
  

          rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
          break;

        case ORDERED_CONFIG_NOT_SET_OTHER:
          /* For Cell Update Confirm message RRC LLC should never
             set Ordered Config */
          WRRC_MSG0_ERROR("Ordered Config Should not return this status");
          break;

        case ORDERED_CONFIG_CONFIGURATION_INVALID:
          /* Set the Transaction Id */
          rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;

          /* Set Failure cause */
          rrccu_failure_cause.failureCause.t = 
            T_rrc_FailureCauseWithProtErr_invalidConfiguration;

          rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
          break;

        default:
          WRRC_MSG0_ERROR("Invalid status from ORDERED_CONFIG");
          break;
      } 
    }  
  }
} /* rrccu_process_cell_update_confirm_r5*/

#ifdef FEATURE_WCDMA_HS_FACH
/*===========================================================================

FUNCTION rrccu_update_chan_config_rb_r7_for_efach

DESCRIPTION
 
  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/

static uint32 
rrccu_update_chan_config_rb_r7_for_efach
(
  uint32 no_of_RBs,
 rrc_rb_config_type * rb_info
)
{
  rlc_lc_id_type     ul_rlc_lc_id;
  uint32 local_no_of_RBs = no_of_RBs;
  uint32 i=0;
  uint8 rab_count;
  uint8 rb_count;
  boolean found_rb = FALSE;

  WRRC_MSG0_HIGH("EFACH:reconfig SRB's/urb's ");


  /*Find if SRB1 presnt for reconfig, if not then add it for reconfig*/
  for(i = 0;i < MIN(MAX_RB, no_of_RBs);i++)
  {
    if(rb_info[i].rb_id == DCCH_UM_RADIO_BEARER_ID)
    {
      found_rb = TRUE;
      break;
    }
  }
  if(found_rb == FALSE)
  {
   /*reconfig signalling RBs */
   rb_info[local_no_of_RBs].rb_id = DCCH_UM_RADIO_BEARER_ID;
   
   rb_info[local_no_of_RBs].rb_config = RECONFIG_RB;
   local_no_of_RBs++;
  }


  /*Find if SRB2 presnt for reconfig, if not then add it for reconfig*/
  for(i = 0,found_rb = FALSE;i < no_of_RBs;i++)
  {
    if(rb_info[i].rb_id == DCCH_AM_RADIO_BEARER_ID)
    {
      found_rb = TRUE;
      break;
    }
  }
  if(found_rb == FALSE)
  {
    /*reconfig signalling RBs */
    rb_info[local_no_of_RBs].rb_id = DCCH_AM_RADIO_BEARER_ID;
     
    rb_info[local_no_of_RBs].rb_config = RECONFIG_RB;
    local_no_of_RBs++;
  }

  /*Find if SRB3 presnt for reconfig, if not then add it for reconfig*/
  for(i = 0,found_rb = FALSE;i < no_of_RBs;i++)
  {
    if(rb_info[i].rb_id == DCCH_DT_HIGH_PRI_RADIO_BEARER_ID)
    {
      found_rb = TRUE;
      break;
    }
  }
  if(found_rb == FALSE)
  {
    /*reconfig signalling RBs */
    rb_info[local_no_of_RBs].rb_id = DCCH_DT_HIGH_PRI_RADIO_BEARER_ID;
     
    rb_info[local_no_of_RBs].rb_config = RECONFIG_RB;
    local_no_of_RBs++;
  }

//ToDO:check for RB release

  /* check whether RB4 was present or not */
  ul_rlc_lc_id = rrclcm_check_ul_rlc_lc_id(UE_LOGCHAN_DCCH, 
                                DCCH_DT_LOW_PRI_RADIO_BEARER_ID,
                                UE_MODE_ACKNOWLEDGED_DATA);
  
  if(ul_rlc_lc_id == RRCLCM_RLC_LC_ID_NOT_FOUND)
  {
    WRRC_MSG0_HIGH("No RB4 in CELL_FACH");
  }
  else 
  {
    /*Find if SRB4 presnt for reconfig, if not then add it for reconfig*/
    for(i = 0,found_rb = FALSE;i < no_of_RBs;i++)
    {
      if(rb_info[i].rb_id == DCCH_DT_LOW_PRI_RADIO_BEARER_ID)
      {
        found_rb = TRUE;
        break;
      }
    }
    if(found_rb == FALSE)
    {
      /*reconfig signalling RBs */
      rb_info[local_no_of_RBs].rb_id = DCCH_DT_LOW_PRI_RADIO_BEARER_ID;
          
      rb_info[local_no_of_RBs].rb_config = RECONFIG_RB;
      local_no_of_RBs++;
    }
  }
  
  /*setup the user plane RBs also at this time. Do not have to worry about the
      ul transmission as it will not happen until we get a valid C-RNTI in the 
      cell update confirm message */
  for (rab_count=0; rab_count<MAX_RAB_TO_SETUP; rab_count++)
  {
    if (
        ((rrc_est_rabs.rabs[rab_count].cn_domain == RRC_CS_DOMAIN_CN_ID)|| 
         (rrc_est_rabs.rabs[rab_count].cn_domain == RRC_PS_DOMAIN_CN_ID)) &&
         (rrc_est_rabs.rabs[rab_count].num_rbs_for_rab > 0)
        )
    {
      /*it is a valid established rab, now compare each rb-id in this established rab with 
              the rb-id received in the message */
      for (rb_count=0; ((rb_count<rrc_est_rabs.rabs[rab_count].num_rbs_for_rab) && 
           (rb_count < MAX_RB_PER_RAB)); rb_count++)    
      {
        /*Find if SRB4 presnt for reconfig, if not then add it for reconfig*/
        for(i = 0,found_rb = FALSE;i < no_of_RBs;i++)
        {
          if(rb_info[i].rb_id == rrc_est_rabs.rabs[rab_count].rb_for_rab[rb_count].rb_id)
          {
            found_rb = TRUE;
            break;
          }
        }
        if(found_rb == FALSE)
        {
          WRRC_MSG1_HIGH("EFACH:Reconfig urb =%d",
          rrc_est_rabs.rabs[rab_count].rb_for_rab[rb_count].rb_id);
          /*reconfig signalling RBs */
          rb_info[local_no_of_RBs].rb_id = rrc_est_rabs.rabs[rab_count].rb_for_rab[rb_count].rb_id;
              
          rb_info[local_no_of_RBs].rb_config = RECONFIG_RB;
          local_no_of_RBs++;
        }
      }
    } /*end of if*/
  }/* rab_count loop */
  
   /* set both rab release flags to false as the "TRUE" case is 
     taken care in the above loop */
  return local_no_of_RBs;
  }

/*===========================================================================

FUNCTION rrccu_get_phy_chan_fail_indication

DESCRIPTION

DEPENDENCIES
  None

RETURN VALUE

SIDE EFFECTS

  None

===========================================================================*/

boolean rrccu_get_phy_chan_fail_indication
(
  void
)
{
  return rrccu_phy_chan_failure_from_rb;
}
#endif

/*===========================================================================

FUNCTION rrccu_update_chan_config_rb_r7

DESCRIPTION
 
  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/

static uint32 
rrccu_update_chan_config_rb_r7
(
 rrc_CellUpdateConfirm_r7_IEs * cu_confirm_ptr,
 rrc_rb_config_type * rb_info)
{
  uint8   no_of_RBs = 0;
  /* Local var to store Ordered Config
                                       status */
  rrc_RB_InformationReleaseList *rrc_rb_information_release_list;
                                    /* Local pointer to preserve the
                                       head of linked list */  
  rrc_RB_InformationReconfig_r7 *rrc_rb_information_reconfig_ptr; 
  
  rrc_RB_InformationAffectedList_r7 *rrc_rb_information_affected_list; 
          /* Pointer to the RRC Command */
  uint32 rb_idx=0;
  
  
  if(RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,rb_InformationReleaseList))
  {
    /* set to flag to indicate that rb release information is present
    in the message. This information will be used after channel configu
    ration to release the rbs from established_rab and also to indicate
    to the upper layers about RAB release if necessary */
    rrccu_rb_release_info.rrccu_rb_release_in_cucnf = TRUE;
    /* Save the linked list head pointer */ 
    rrc_rb_information_release_list = 
      &cu_confirm_ptr->rb_InformationReleaseList;
  
      /* If voice RAB still exist, then indicate layer 1 that next configuration is going to
         include AMR configuration.
         This check is not required if state change indication is either cell_PCH, URA_PCH or
         CELL_FACH, because if voice is configured then next state has to be CELL_DCH.
      */
      if ((rrc_RRC_StateIndicator_cell_DCH == rrccu_state_indicator) && (FALSE == 
          rrc_is_given_rb_rel_list_releases_all_rb_for_voice_rab(
                            rrc_rb_information_release_list)))
      {
        rrc_indicate_layer1_next_config_is_for_voice();
      }
    rb_idx=0;
    while(rrc_rb_information_release_list->n > rb_idx )
    { 
      if( rrc_rb_information_release_list->elem[rb_idx] == DCCH_DT_LOW_PRI_RADIO_BEARER_ID)
      {
        if(RRCLCM_RLC_LC_ID_NOT_FOUND == rrclcm_check_dl_rlc_lc_id(
                                            UE_LOGCHAN_DCCH,
                                            DCCH_DT_LOW_PRI_RADIO_BEARER_ID,
                                            UE_MODE_ACKNOWLEDGED_DATA))
        {
          WRRC_MSG1_HIGH("Ignore Non-exitent rb_id =%d in cucnf",rrc_rb_information_release_list->elem[rb_idx]);
          rb_idx++;
          continue;
        }
      }
      else if(! rrc_find_rb_in_est_rabs((rrc_rb_information_release_list->elem[rb_idx]))) 
      {
        WRRC_MSG1_HIGH("Ignore Non-exitent rb_id = %d in cucnf",rrc_rb_information_release_list->elem[rb_idx]);
        rb_idx++;
        continue;
      }
      else if (MAX_RB != rrccu_check_if_rbid_present_in_rrccu_rb_release_info(rrc_rb_information_release_list->elem[rb_idx],no_of_RBs))
      {
        WRRC_MSG1_ERROR(" Ignoring Duplicate RB ID % d in CU ",rrc_rb_information_release_list->elem[rb_idx]);
        rb_idx++;
        continue;
      }
      
      rb_info[no_of_RBs].rb_id = 
      rrc_rb_information_release_list->elem[rb_idx];
  
      rb_info[no_of_RBs].rb_config = RELEASE_RB;
  
      /* store the rb info to release list in local buffer which will
      be used later to release it from established_rab variable */
      if(no_of_RBs < MAX_RB)
      {
        rrccu_rb_release_info.rb_id[no_of_RBs]=rrc_rb_information_release_list->elem[rb_idx];
      }
  
      /* Advance the Linked List pointer */
      rb_idx++;
      no_of_RBs++;
    } 
  
    rrccu_rb_release_info.num_rbs = no_of_RBs;
  
    rrcrb_update_mac_rab_status(RRC_PROCEDURE_CU, RRC_CS_DOMAIN_CN_ID,
                                &cu_confirm_ptr->rb_InformationReleaseList,
                                FALSE);
  }
  else
  {
      /* It means CU Confirm doesnt include information to release any RB. 
         check if AMR RAB was established earlier. If yes then indicate layer 1 that
         next configuration will be for AMR.
         This check is not required if state change indication is either cell_PCH, URA_PCH or
         CELL_FACH, because if voice is configured then next state has to be CELL_DCH.                   
      */
      if ((rrc_RRC_StateIndicator_cell_DCH == rrccu_state_indicator) && 
                                (TRUE == rrc_is_voice_rab_present()))
      {
        rrc_indicate_layer1_next_config_is_for_voice();
      }
    }
  
  if( RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,rb_InformationReconfigList))
  {
    rb_idx=0;
   
    do
    { 
       /* Save the linked list head pointer */
      rrc_rb_information_reconfig_ptr = 
        &cu_confirm_ptr->rb_InformationReconfigList.elem[rb_idx];
      rb_info[no_of_RBs].rb_id = 
              rrc_rb_information_reconfig_ptr->rb_Identity;
  
      rb_info[no_of_RBs].rb_config = RECONFIG_RB;
      rb_info[no_of_RBs].rb_config = RECONFIG_RB_OTA;
      rb_info[no_of_RBs].ul_cfg_mask = 0;
      rb_info[no_of_RBs].dl_cfg_mask = 0;
      if((RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_rb_information_reconfig_ptr, rrc_RB_InformationReconfig_r7,rlc_Info))
          &&(RRC_MSG_COMMON_BITMASK_IE(rrc_rb_information_reconfig_ptr->rlc_Info,rrc_RLC_Info_r7,ul_RLC_Mode)))
      {
        rb_info[no_of_RBs].ul_cfg_mask = MODIFY_RB_CFG;
      }
      if((RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_rb_information_reconfig_ptr, rrc_RB_InformationReconfig_r7,rlc_Info))
          &&(RRC_MSG_COMMON_BITMASK_IE(rrc_rb_information_reconfig_ptr->rlc_Info,rrc_RLC_Info_r7,dl_RLC_Mode)))
      {
        rb_info[no_of_RBs].dl_cfg_mask = MODIFY_RB_CFG;
      }

      if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_rb_information_reconfig_ptr, 
          rrc_RB_InformationReconfig_r7,rb_StopContinue))
      {
        if (rrc_rb_information_reconfig_ptr->rb_StopContinue == rrc_RB_StopContinue_stopRB)
        {
          rb_info[no_of_RBs].ul_cfg_mask |= STOP_RB_CFG;
          rb_info[no_of_RBs].dl_cfg_mask |= STOP_RB_CFG;
          WRRC_MSG1_HIGH("Stop recvd for RB %d", (rrc_rb_information_reconfig_ptr->rb_Identity));
        }
        else if (rrc_rb_information_reconfig_ptr->rb_StopContinue == rrc_RB_StopContinue_continueRB)
        {
          rb_info[no_of_RBs].ul_cfg_mask |= CONTINUE_RB_CFG;
          rb_info[no_of_RBs].dl_cfg_mask |= CONTINUE_RB_CFG;
          WRRC_MSG1_HIGH("Continue recvd for RB %d", (rrc_rb_information_reconfig_ptr->rb_Identity));
        }
      }
      /* Advance the Linked List pointer */
      rb_idx++;
      no_of_RBs++;
       
    } while(cu_confirm_ptr->rb_InformationReconfigList.n > rb_idx) ;
  }
  if(RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,rb_InformationAffectedList))
  {
    /* Save the head pointer of linked list */
    rrc_rb_information_affected_list = 
      &cu_confirm_ptr->rb_InformationAffectedList;
    rb_idx=0;
    do
    { 
      rb_info[no_of_RBs].rb_id = 
          rrc_rb_information_affected_list->elem[rb_idx].rb_Identity;
  
      rb_info[no_of_RBs].rb_config = RECONFIG_RB;
      rb_info[no_of_RBs].rb_config = RECONFIG_RB_OTA;
      rb_info[no_of_RBs].ul_cfg_mask = rb_info[no_of_RBs].dl_cfg_mask = MODIFY_RB_CFG;

      /* Advance the Linked List pointer */
      rb_idx++;
  
      no_of_RBs++;
  
    } while(rrc_rb_information_affected_list->n > rb_idx);
  }


  return no_of_RBs;
  
  }

/*===========================================================================

FUNCTION rrccu_send_re_est_rlc_for_srns_req

DESCRIPTION
 
  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/

static void rrccu_send_re_est_rlc_for_srns_req 
(
    rrc_rlc_re_est_for_srns_rb_e_type rb_type,   /* rb type to re_est rb2 or others*/
  boolean                           cnf_reqd  /* to indicate if cnf is reqd     */
 )
{
     rrc_cmd_type *int_cmd_ptr;                      /* Pointer to the RRC Command */
     
/*send the rlc re-establishment request to SMC to re-establish SRB2 */
          /* Get the command buffer */
    int_cmd_ptr = rrc_get_int_cmd_buf();
    /* Fill in the command id  */
    int_cmd_ptr->cmd_hdr.cmd_id = RRC_RE_EST_RLC_FOR_SRNS_REQ;
    int_cmd_ptr->cmd.rrc_re_est_srns_req.rrc_proc = RRC_PROCEDURE_CU;
    int_cmd_ptr->cmd.rrc_re_est_srns_req.rb_type  = rb_type;
    int_cmd_ptr->cmd.rrc_re_est_srns_req.cnf_reqd = cnf_reqd;
    WRRC_MSG1_HIGH("RLC Reestablish req for %d ", 
             RRC_RE_EST_RB_2); 

    rrc_put_int_cmd(int_cmd_ptr);             
    rrccu_substate = RRCCU_WAIT_FOR_SRB2_RE_EST_CNF;        
}

/*===========================================================================

FUNCTION rrccu_validate_rel_rb_exist_in_reconfig_list_r7

DESCRIPTION
  This function checks if the Cu Cnf has the same RB ID in the RB Release list
   and also in RB Reconfig/RB Affected List
  
DEPENDENCIES
  None

RETURN VALUE
  True, if same RB ID is present in RB Release list and also in RB Reconfig/RB Affected List
  else
  FALSE
  
SIDE EFFECTS

  None

===========================================================================*/
static boolean rrccu_validate_rel_rb_exist_in_reconfig_list_r7
(
  rrc_CellUpdateConfirm_r7_IEs * cu_confirm_ptr
)
{
  rrc_RB_Identity released_rb_id= 0xFF;
  rrc_RB_InformationReleaseList *rrc_rb_information_release_list;
                                            /* Local pointer to preserve the
                                               head of linked list */  
  rrc_RB_InformationReconfig_r7 *rrc_rb_information_reconfig_ptr; 
  
  rrc_RB_InformationAffectedList_r7 *rrc_rb_information_affected_list; 
  uint32 idx =0,idy=0;
    /* Save the linked list head pointer */ 
  rrc_rb_information_release_list = 
      &cu_confirm_ptr->rb_InformationReleaseList;

    
  while(rrc_rb_information_release_list->n > idx)
  { 
  
    released_rb_id =rrc_rb_information_release_list->elem[idx];
    if( RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,rb_InformationReconfigList))
    {
      idy=0;
      do
      { 
        /* Save the linked list head pointer */
        rrc_rb_information_reconfig_ptr = 
          &cu_confirm_ptr->rb_InformationReconfigList.elem[idy];
        /* Check whether rb id in rb reconfig list is in the established rabs list.  If not set msg_not_valid variable
              to true to resend cell update msg with failure cause  */
        if (rrc_rb_information_reconfig_ptr->rb_Identity == released_rb_id  )
        {
          /* RB Message was invalid. */
          WRRC_MSG1_ERROR(" RB id:%d in rb_InformationReconfigList  and RB Release list of CUCnf Msg",
             rrc_rb_information_reconfig_ptr->rb_Identity );
          return TRUE;
        }
                 
        /* Advance the Linked List pointer */
        idy++;
      }while(cu_confirm_ptr->rb_InformationReconfigList.n > idy);
    }
  
    if(RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,rb_InformationAffectedList))
    {
      /* Save the head pointer of linked list */
      rrc_rb_information_affected_list = 
       &cu_confirm_ptr->rb_InformationAffectedList;
      idy=0;
      do
      { 
        /* Check whether rb id in rb affected list is in the established rabs list.  If not set msg_not_valid variable
        to true to resend cell update msg with failure cause  */
        if (rrc_rb_information_affected_list->elem[idy].rb_Identity == released_rb_id )
        {
          /* RB Message was invalid. */
          WRRC_MSG1_ERROR(" RB id:%d in rb_InformationAffectedList  and RB Release list of CUCnf Msg",
             rrc_rb_information_affected_list->elem[idy].rb_Identity );
          return TRUE;
        }
        /* Advance the Linked List pointer */
        idy++;
        
      } while(rrc_rb_information_affected_list->n > idy);
    }
     
    idx++;
  } 
  
  return FALSE;
}
/*===========================================================================

FUNCTION rrccu_validate_rb_info_r7

DESCRIPTION
  This function validates the Rb related IEs in Cu Cnf
  Cell Update message.
  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
static boolean rrccu_validate_rb_info_r7
(
   rrc_CellUpdateConfirm_r7_IEs * cu_confirm_ptr
)
{

  rrc_RB_InformationReleaseList *rrc_rb_information_release_list;
                                              /* Local pointer to preserve the
                                                 head of linked list */  
  rrc_RB_InformationAffectedList_r7 *rrc_rb_information_affected_list; 
  uint32 rb_idx=0;
                                              
  if( RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,rb_InformationReconfigList))
  {
    /* Save the linked list head pointer */
    if (FAILURE == rrcllc_validate_rb_info_reconfig_list_r7(
        &cu_confirm_ptr->rb_InformationReconfigList))
    {
      return FALSE;
    }
  }
  
  
  if(RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,rb_InformationReleaseList))
  {
    /* Save the linked list head pointer */ 
    rrc_rb_information_release_list = 
      &cu_confirm_ptr->rb_InformationReleaseList;
    rb_idx=0;
    while(rrc_rb_information_release_list->n > rb_idx)
    { 
      /* Check whether rb id in rb release list is in the established rabs list.  If not set msg_not_valid variable
         to true to resend cell update msg with failure cause  */
      if (RRC_RB_NOT_PRESENT == validate_rb_id_in_release_list(
                            (rrc_rb_information_release_list->elem[rb_idx])))
      {
        /* RB Message was invalid. */
        WRRC_MSG1_ERROR("Invalid RB id:%d in rb_InformationReleaseList of CUCnf Msg",
          rrc_rb_information_release_list->elem[rb_idx] );
        return FALSE;
      }      
      rb_idx++;
    } 
  }
  
  if( RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,rb_InformationAffectedList))
  {
    /* Save the head pointer of linked list */
    rrc_rb_information_affected_list = 
      &cu_confirm_ptr->rb_InformationAffectedList;
    do
    { 
      /* Check whether rb id in rb affected list is in the established rabs list.  If not set msg_not_valid variable
      to true to resend cell update msg with failure cause  */
      if (RRC_RB_NOT_PRESENT == validate_rb_id_in_reconfig_list(
          (rrc_rb_information_affected_list->elem[rb_idx].rb_Identity)))
      {
        /* RB Message was invalid. */
        WRRC_MSG1_ERROR("Invalid RB id:%d in rb_InformationAffectedList of CUCnf Msg",
          rrc_rb_information_affected_list->elem[rb_idx].rb_Identity );
        return FALSE;
      }
      /* Advance the Linked List pointer */
      rb_idx++;
      
    } while(rrc_rb_information_affected_list->n > rb_idx);
  }

  if((RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,rb_InformationReleaseList))
     && (( RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,rb_InformationReconfigList)) ||
       ( RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,rb_InformationAffectedList)))  )
  {
    if(rrccu_validate_rel_rb_exist_in_reconfig_list_r7(cu_confirm_ptr) == TRUE)
    {
        return FALSE;
    }
  }
  return TRUE;
}
/*===========================================================================

FUNCTION RRCCU_RESPONSE_TO_CELL_UPDATE_CONFIRM_R7

DESCRIPTION
  This function evaluates CELL UPDATE CONFIRM message and decides what
  response message has to be sent
  Cell Update message.
  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
static rrccu_resp_msg_e_type rrccu_find_response_to_cell_update_confirm_r7
(
  rrc_CellUpdateConfirm_r7_IEs *cucnf_ptr
)
{
  rrccu_resp_msg_e_type resp_msg= RRCCU_NO_RESP_MSG;


  /* In RB Release present send RB Release complete */
  
  if(RRCRBR_R7_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r7_IEs,rb_InformationReleaseList))
  {
    resp_msg = RRCCU_RBR_COMPLETE_RESP_MSG;
  }
    /* else if rb reconfig present send Reconfig complete*/
  else if ((RRCRBR_R7_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r7_IEs,rb_InformationReconfigList))
                || (RRCRBR_R7_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r7_IEs,rb_InformationAffectedList)))
  {
    resp_msg = RRCCU_RBRC_COMPLETE_RESP_MSG;
  }
  /* else if Trch info is  present send Transport reconfig  complete*/
  else if ((RRCRBR_R7_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r7_IEs,ul_CommonTransChInfo))
                || (RRCRBR_R7_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r7_IEs,ul_deletedTransChInfoList))
                ||(RRCRBR_R7_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r7_IEs,ul_AddReconfTransChInfoList))
                || (RRCRBR_R7_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r7_IEs,dl_CommonTransChInfo))
                ||(RRCRBR_R7_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r7_IEs,dl_DeletedTransChInfoList))
                || (RRCRBR_R7_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r7_IEs,dl_AddReconfTransChInfoList))) 
  {
    resp_msg = RRCCU_TCR_COMPLETE_RESP_MSG;
  }
   /* else if Physical channel info  is  present send Physical Channel reconfig  complete*/
  else if ((RRCRBR_R7_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r7_IEs,ul_DPCH_Info))
                || (RRCRBR_R7_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r7_IEs,dl_CommonInformation))
                ||(RRCRBR_R7_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r7_IEs,dl_InformationPerRL_List))
                ||(RRCRBR_R7_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r7_IEs,ul_EDCH_Information))
                || (RRCRBR_R7_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r7_IEs,dl_HSPDSCH_Information))
                || (RRCRBR_R7_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r7_IEs,frequencyInfo))
                || (RRCRBR_R7_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r7_IEs,maxAllowedUL_TX_Power))
                ||(RRCRBR_R7_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r7_IEs,dtx_drx_TimingInfo))
                ||(RRCRBR_R7_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r7_IEs,dtx_drx_Info))
                )
  {
    resp_msg = RRCCU_PCR_COMPLETE_RESP_MSG;
  }
   /* else if Utran Mobility info  is  present, send  Utran Mobility info  complete*/
  else if ((RRCRBR_R7_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r7_IEs,cn_InformationInfo))
                || (RRCRBR_R7_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r7_IEs,cipheringModeInfo))
                ||(RRCRBR_R7_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r7_IEs,integrityProtectionModeInfo))
                ||(RRCRBR_R7_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r7_IEs,new_U_RNTI))
                || (RRCRBR_R7_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r7_IEs,new_C_RNTI)))                
  {
    resp_msg = RRCCU_UMIC_COMPLETE_RESP_MSG;
  }
  else if (!((RRCRBR_R7_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r7_IEs,rb_InformationReleaseList))
                || (RRCRBR_R7_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r7_IEs,rb_InformationReconfigList))
                || (RRCRBR_R7_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r7_IEs,rb_InformationAffectedList))
                ||(RRCRBR_R7_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r7_IEs,ul_CommonTransChInfo))
                || (RRCRBR_R7_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r7_IEs,ul_deletedTransChInfoList))
                ||(RRCRBR_R7_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r7_IEs,ul_AddReconfTransChInfoList))
                || (RRCRBR_R7_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r7_IEs,dl_CommonTransChInfo))
                ||(RRCRBR_R7_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r7_IEs,dl_DeletedTransChInfoList))
                || (RRCRBR_R7_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r7_IEs,dl_AddReconfTransChInfoList))
                ||(RRCRBR_R7_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r7_IEs,ul_DPCH_Info))
                || (RRCRBR_R7_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r7_IEs,dl_CommonInformation))
                ||(RRCRBR_R7_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r7_IEs,dl_InformationPerRL_List))
                ||(RRCRBR_R7_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r7_IEs,ul_EDCH_Information))
                || (RRCRBR_R7_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r7_IEs,dl_HSPDSCH_Information))
                ||(RRCRBR_R7_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r7_IEs,cn_InformationInfo))
                || (RRCRBR_R7_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r7_IEs,cipheringModeInfo))
                ||(RRCRBR_R7_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r7_IEs,integrityProtectionModeInfo))
                ||(RRCRBR_R7_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r7_IEs,new_U_RNTI))
                || (RRCRBR_R7_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r7_IEs,new_C_RNTI))
                ||(RRCRBR_R7_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r7_IEs,frequencyInfo)))
              )
  {
    resp_msg = RRCCU_NO_RESP_MSG;
  }

  return resp_msg;
}
/*===========================================================================

FUNCTION RRCCU_PROCESS_CELL_UPDATE_CONFIRM_R7

DESCRIPTION
  This function processes the REl 6 CELL UPDATE CONFIRM message received in response to
  Cell Update message.
  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
static void rrccu_process_cell_update_confirm_r7
(    
  void *msg_ptr,                           /* Pointer to Downlink Msg */
  rrc_RRC_TransactionIdentifier rcvd_transaction_id,
  rrc_CellUpdateConfirm_r7_IEs *cu_confirm_ptr,
  uint32 dl_sdu_type                       /* Downlink SDU type */
)
{
  rrc_cmd_type *cmd_ptr;                      /* Pointer to the RRC Command */
  uint32 no_of_RBs;                           /* Local variable to store no
                                                of RBs */
  boolean msg_not_valid      = FALSE;         /* boolean to indicate msg validity */
  rrc_int_c_rnti_type crnti;                  /* Local variable for C-RNTI */
  rrc_int_u_rnti_type urnti;                  /* Local variable for U-RNTI */
 
  rrc_state_e_type state ;                    /* Local varible to store state */

  rrcllc_oc_status_e_type status;             /* Local var to store Ordered Config
                                                 status */

  uecomdef_status_e_type hs_valid_status = SUCCESS;
  rrcrb_directed_cell_info_type          directed_cell_info; /* directed cell info struct */

  /* Update Transaction id */
  rrccu_trans_id = rcvd_transaction_id;
    
  /* enter idle if both timers are marked as expired */
  if ((rrccu_rl_failure_info.t314_info.timer_status == RE_EST_TIMER_EXPIRED) &&
      (rrccu_rl_failure_info.t315_info.timer_status == RE_EST_TIMER_EXPIRED))
  {
    /* Since both T314 and T315 are expired, bring down RRC Connection */
      rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                           RRC_TX_TO_DISCON_OTHER);
      /* Update the release cause */
      rrc_release_cause = RRC_REL_DEEP_FADE;
      rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
      WRRC_MSG0_HIGH("RRC Conn Released since T314=0 & T315=0");
    return;
  }

  /* Update state Indicator */   
  rrccu_state_indicator = cu_confirm_ptr->rrc_StateIndicator;

  /*If wait timer IE is valid, we need to store it. We need this value if R7 CU CNF OTA
    is taking the UE to Cell_PCH or URA_PCH state. In this case, we need to start wait timer
    T320 with this IE.*/

  if(((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH) || (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH)) &&
    (RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,waitTime)) &&
    (cu_confirm_ptr->waitTime))
  {
    rrccu_int_data.wait_time_in_pch = cu_confirm_ptr->waitTime;

    /*If current CU cause is Uplink Data Transmission or MBMS P2P Rb Request, we need to store it 
       so that when T320 expires, we can initiate CU with this cause.*/
    if(rrccu_cell_update_cause == rrc_CellUpdateCause_uplinkDataTransmission)
    {
      rrccu_int_data.cu_cause_for_wait_timer = rrccu_map_cu_cause(rrccu_cell_update_cause);
    }
  }  

  /* check whether new CRNTI is present in the message or not when there is
  no valid C-RNTI is existing and next state indicated by the message is 
  CELL_FACH */
  if ((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_FACH) ||
      (  ((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH) || 
          (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH)) &&
     (RRCCU_NO_RESP_MSG != rrccu_find_response_to_cell_update_confirm_r7(cu_confirm_ptr))))
  {
    if ((C_RNTI_NOT_VALID == rrcllc_get_current_crnti_status()) &&
        ((RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,new_C_RNTI)) == 0 ))
    {
      if(((rrcllc_get_toc_usage() == TOC_FOR_OOS) 
          || (rrcllc_get_toc_usage() == TOC_FOR_OOS_WITHOUT_DCH_INFO)
          || (rrcllc_get_toc_usage() == TOC_FOR_OOS_WITH_DCH_INFO)
       ) &&   (rrcrb_get_new_crnti_valid() && rrccsp_is_selected_cell_utran_directed()))
      {
        WRRC_MSG0_HIGH("CRNTI present in Cell Update Confirm ");
      }
      else
      {

        WRRC_MSG1_ERROR("No CRNTI for next_st:%d", rrccu_state_indicator);
        /* Update the cause to re-selection as the Cell upate cause should
              indicate re-selection in case of No CRNTI
              */
        rrccu_cell_update_cause = rrc_CellUpdateCause_cellReselection;		
        rrc_cu_uu_log_event_failure_cause = RRC_CU_UU_INVALID_CONFIG;
        rrccu_resend_cell_update_msg(RRCCU_NOT_INCLUDE_FAILURE_CAUSE);
        /* continue with rrccu state  RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM */
        return;
      }
    }
  }
  
#ifdef FEATURE_WCDMA_HS_FACH
  /*RNTI validation for HS-FACH and HS-RACH*/
  if(TRUE == rrccu_check_rnti_for_resending_cu(
               RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr, rrc_CellUpdateConfirm_r7_IEs,new_H_RNTI), 
               RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr, rrc_CellUpdateConfirm_r7_IEs,newPrimary_E_RNTI),
               MSG_REL7, 
               rrccu_find_response_to_cell_update_confirm_r7(cu_confirm_ptr)))
  {
    rrccu_cell_update_cause = rrc_CellUpdateCause_cellReselection;
    rrc_cu_uu_log_event_failure_cause = RRC_CU_UU_INVALID_CONFIG;
    rrccu_resend_cell_update_msg(RRCCU_NOT_INCLUDE_FAILURE_CAUSE);
    return;
  }
#endif

  if ((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH) ||
      (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH))
  {
    if (!(RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,utran_DRX_CycleLengthCoeff)))
    {
      WRRC_MSG0_ERROR("UTRAN DRX is not present");
      
      /* set the invalid msg flag */
      msg_not_valid = TRUE;

    }
    else
    {
      /* store it in a variable */
      if(rrcllc_update_utran_drx_cycle_length_coeff_in_oc_r7(TRUE,&cu_confirm_ptr->utran_DRX_CycleLengthCoeff)
         == SUCCESS)
      {        
        if((RRC_MSG_COMMON_BITMASK_IE_TYPE2(cu_confirm_ptr->utran_DRX_CycleLengthCoeff,drx_CycleLengthCoefficient2))&&
           (RRC_MSG_COMMON_BITMASK_IE_TYPE2(cu_confirm_ptr->utran_DRX_CycleLengthCoeff,timeForDRXCycle2)))
        {
          rrccu_utran_drx_coef = cu_confirm_ptr->utran_DRX_CycleLengthCoeff.drx_CycleLengthCoefficient2;
        }
        else
        {
          rrccu_utran_drx_coef = cu_confirm_ptr->utran_DRX_CycleLengthCoeff.drx_CycleLengthCoefficient;
        }
      }
      else
      {
        rrccu_utran_drx_coef = cu_confirm_ptr->utran_DRX_CycleLengthCoeff.drx_CycleLengthCoefficient;
      }
    }
       /*resend the cell update message if there is any invalid config*/
    if  (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH)
    {
      if (!(RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,ura_Identity)))
      {
        WRRC_MSG0_HIGH("URA-id is not present");
        rrccu_clear_ura_id();
      }
      /* update rrccu procedure with new URA-id */
      else
      {
        /*URA ID present in the message set ura_identity variable with this value */
        if (cu_confirm_ptr->ura_Identity.numbits == 16)
        {
          /*rrccu_translate_ura_id (&(msg_ptr->u.r3.radioBearerReconfiguration_r3.ura_Identity));*/
          rrccu_update_ura_id (&(cu_confirm_ptr->ura_Identity));
        }
        else
        {
          WRRC_MSG1_ERROR("Invalid URA ID length%d",
              cu_confirm_ptr->ura_Identity.numbits);
          /* set the invalid msg flag */
          msg_not_valid = TRUE;
        }
      }
        
    }
  }

#ifdef FEATURE_WCDMA_REL7_SPECRS   

   /*If CU Confirm OTA provides "supportForChangeOfUE_Capability" IE, we need to store it in
        "rrc_ordered_rnc_cap_change_support" so that later once the procedure is over successfully, global
        "rrc_rnc_cap_change_support" can be updated accordingly. */  
  if(RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,
      supportForChangeOfUE_Capability))
  {
    if(cu_confirm_ptr->supportForChangeOfUE_Capability == TRUE)
    {
      rrc_ordered_rnc_cap_change_support = RNC_CAP_CHANGE_SUPPORTED;
    }
    else
    {
      rrc_ordered_rnc_cap_change_support = RNC_CAP_CHANGE_UNSUPPORTED;
    }
  }
  else
  {
    rrc_ordered_rnc_cap_change_support = RNC_CAP_CHANGE_NONE;
  }
  #endif
  
  if(msg_not_valid == FALSE)
    { 
   if( rrccu_validate_rb_info_r7(cu_confirm_ptr) == FALSE)
      {
        msg_not_valid = TRUE;
    } 
  }

  if (RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,dl_HSPDSCH_Information))
  {
    /* Check if network does not try to initiate HSDPA with invalid state */
    hs_valid_status = rrc_hsdpa_initial_validation(cu_confirm_ptr->rrc_StateIndicator, 
     RRC_CHECK_COMMON_MSG_TYPE(cu_confirm_ptr->dl_HSPDSCH_Information.modeSpecificInfo,
     rrc_DL_HSPDSCH_Information_modeSpecificInfo_tdd));
    
    if (hs_valid_status == FAILURE)
    {
      WRRC_MSG0_ERROR("Invalid HSDPA Info specified");
      msg_not_valid = TRUE;
    }
  }
  

  if (msg_not_valid)
  {
    WRRC_MSG0_HIGH("Invalid Configurartion in CUCnf Msg.  Resending Cell Update");
    /* Set the Transaction Id */
    rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;

    /* Set Failure cause */
    rrccu_failure_cause.failureCause.t = 
      T_rrc_FailureCauseWithProtErr_invalidConfiguration;


    rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
    /* continue with rrccu state  RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM */
    return;
  }
  /* Populate the local variables to indicate if Re-direction info is present */
  directed_cell_info.freq_info_present = FALSE;
  directed_cell_info.pscr_present = FALSE;
  if(  (rrccu_state_indicator ==rrc_RRC_StateIndicator_cell_FACH)
        ||( rrccu_state_indicator==rrc_RRC_StateIndicator_cell_PCH)
        || (rrccu_state_indicator==rrc_RRC_StateIndicator_ura_PCH))
  {
    if((RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,frequencyInfo))
         && (RRC_CHECK_COMMON_MSG_TYPE(cu_confirm_ptr->frequencyInfo.modeSpecificInfo,
       rrc_FrequencyInfo_modeSpecificInfo_fdd)))
    {
      directed_cell_info.freq_info_present = TRUE;
      directed_cell_info.uarfcn_dl         = cu_confirm_ptr->frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_DL;
    }
    
    if (((RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,dl_InformationPerRL_List)))
        &&(cu_confirm_ptr->dl_InformationPerRL_List.elem[0].modeSpecificInfo.t ==
         T_rrc_DL_InformationPerRL_r7_modeSpecificInfo_fdd))
    {
        WRRC_MSG1_HIGH("Primary SCR in CU Cnf R7 message %d",
           cu_confirm_ptr->dl_InformationPerRL_List.elem[0].modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode);
      directed_cell_info.pscr_present = TRUE;
      directed_cell_info.pscr = cu_confirm_ptr->dl_InformationPerRL_List.elem[0].modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode;
    }
  }

  if ((rrc_RRC_StateIndicator_cell_FACH == rrccu_state_indicator) &&
       (rrcrb_validate_directed_cell_info (directed_cell_info) == FALSE))
  {
    /* If UE still has to send a response to the previous Cu Cnf with directed info
     * and it receives another Cu Cnf with directed info, then send failure
     * If the previous Cu Cnf had directed info, then atleast a PCRC Complete
     * has to be pending as a response.
     */
    if( rrccu_int_data.rrccu_cell_selection_last_response_msg != RRCCU_NO_RESP_MSG )
    {
       WRRC_MSG0_ERROR(" Previous Cu Cnf sent a directed info, cannot accept another Cu Cnd with directed info");
       /* Set the Transaction Id */
       rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;
       /* Set Failure cause */
   
       rrccu_failure_cause.failureCause.t = 
         T_rrc_FailureCauseWithProtErr_incompatibleSimultaneousReconfiguration;

   
       rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
       return;
    }
  }
    

  if (RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,dl_CounterSynchronisationInfo))
  {
    /*check whether PDCP info is present in the dl counter sync info */
    if ((RRC_MSG_COMMON_BITMASK_IE_TYPE2(cu_confirm_ptr->dl_CounterSynchronisationInfo,
         rb_WithPDCP_InfoList)) ||
           (RRC_MSG_COMMON_BITMASK_IE(cu_confirm_ptr->dl_CounterSynchronisationInfo,
            rrc_DL_CounterSynchronisationInfo_r5,rb_PDCPContextRelocationList)))
    {
      /* this involves lossless SRNS relocation so re-send cell update 
         message */
      WRRC_MSG0_ERROR("PDCP info not supported");

      /* Set the Transaction Id */
      rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;

      /* Set Failure cause */
      rrccu_failure_cause.failureCause.t = 
         T_rrc_FailureCauseWithProtErr_configurationUnsupported;


      rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
      /* continue with rrccu state  RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM */
      return;
    }

    /*UE actions, in case IE "Downlink counter synchronisation info" is included and 
      *either IE "RLC reestablish indicator (RB2, RB3 and RB4)" or IE "RLC re-establish 
      *indicator (RB5 and upwards)" are set to TRUE, are not defined.refer to R2-041019,spec cr-2328
      */
    if((cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4 == TRUE) ||
      (cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove == TRUE))
    {
      /* Set the Transaction Id */
      rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;
    
      /* Set Failure cause */
      rrccu_failure_cause.failureCause.t = T_rrc_FailureCauseWithProtErr_configurationUnsupported;
    

    
      WRRC_MSG0_ERROR("UE doesn't support simultaneous RLC Re_est & S-RNS<R2-041019,spec cr-2328>");
      rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
      /* continue with rrccu state  RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM */
      return;
    }

    /* This is lossy SRNS relocation */
    rrccu_cucnf_for_srns_relocation  = TRUE;
    /* store the new URNTI value if present */
    if (RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,new_U_RNTI))
    {
      rrccu_new_urnti_valid = TRUE;
      rrc_translate_urnti (&(cu_confirm_ptr->new_U_RNTI),
                               &rrccu_new_urnti);
    }
  }

#ifdef FEATURE_WCDMA_HS_FACH
  if(cu_confirm_ptr->m.new_H_RNTIPresent)
  {
    if(rrccu_update_hrnti_from_ota(&cu_confirm_ptr->new_H_RNTI, transition_config.toc_ptr) == FAILURE)
    {
      WRRC_MSG0_ERROR("HRNTI invalid");
      msg_not_valid = TRUE;
    }
  }
#endif

  /* check whether rlc-re establishment was require but not indicated in cell update
  confirm message. In such case discard the cucnf and resend cell update message.
  This should also take care of multiple cell updates initiated due to change in cause.
  for ex. periodicall...rlc unrecoverabel error, reselection...rlc unrecoverable error
  rl failure..rlc unrecoverable error */
  if (((rrccu_rlc_error_info.error_on_srb == TRUE) && 
      (cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4 == FALSE)) ||
       ((rrccu_rlc_error_info.error_on_urb == TRUE) && 
      (cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove == FALSE)))
  {
    if(RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,dl_CounterSynchronisationInfo)) 
    {
      WRRC_MSG0_HIGH("S-RNS relocation is Implicit rlc_Re_establish");
    }
    else
    {
      rrc_cu_uu_log_event_failure_cause = RRC_CU_UU_INVALID_CONFIG;
      rrccu_resend_cell_update_msg(RRCCU_NOT_INCLUDE_FAILURE_CAUSE);
      /* continue with rrccu state  RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM */
      return;
    }
  }

  rrccu_resp_msg = rrccu_find_response_to_cell_update_confirm_r7(cu_confirm_ptr);
  /* If CUC doesnt set OC, validate if the existing ehs queues are holding a proper window size */
  /* Calling 'rrcllc_validate_hs_ehs_window_size_for_sec' directly without checking for 
     num of carriers. As CUC doesnt set OC, num sec carriers is anyways 0. We can reject CUC
     if window size is > 32 */
 /*  Note: directed_cell_info.freq_info_present and directed_cell_info.pscr_present will always be FALSE 
     for NO RSP and UMIC response. Added those conditions to just maintain the code consistency. 
     These conditions doesnt impact the logics. If these conditions are redundant, we can remove
     such condition everywhere  */
  if(((RRCCU_NO_RESP_MSG == rrccu_resp_msg)||(RRCCU_UMIC_COMPLETE_RESP_MSG == rrccu_resp_msg)) &&
    (((directed_cell_info.freq_info_present == FALSE )&& (directed_cell_info.pscr_present == FALSE ))
    ||(rrccu_state_indicator ==rrc_RRC_StateIndicator_cell_DCH)))
  {
    if(FALSE == rrcllc_validate_hs_ehs_window_size_for_sec(rrccu_state_indicator))
    {
      rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;
      rrccu_failure_cause.failureCause.t = T_rrc_FailureCauseWithProtErr_invalidConfiguration;
      rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
	  return;
    }
  }
  /* check whether reconfiguration is involved and OC is already set by some other 
  procedure */ 
  if ((rrccu_resp_msg != RRCCU_NO_RESP_MSG) && 
      (rrccu_resp_msg != RRCCU_UMIC_COMPLETE_RESP_MSG) &&
      ((rrcllc_get_ordered_config_status_wo_f3() != OC_NOT_SET) || (rrccu_do_not_acpt_nw_conf_in_cuc == TRUE)))
  {
    /* Set the Transaction Id */
    rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;
    /* Set Failure cause */

    rrccu_failure_cause.failureCause.t = 
      T_rrc_FailureCauseWithProtErr_incompatibleSimultaneousReconfiguration;


    rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
  }
  else
  {

    rrc_update_reconfig_waiting_for_l2ack_dch(MAX_NUM_OF_PROCEDURES);


    /* if this cell update was due to RL faiure then stop any re-est timer
    that is running */
    if(((rrccu_cell_update_cause == rrc_CellUpdateCause_radiolinkFailure)||  
        (rrccu_cell_update_cause == rrc_CellUpdateCause_re_enteredServiceArea)||
      (rrccu_cell_update_cause == rrc_CellUpdateCause_rlc_unrecoverableError)) &&
      (rrccu_failure_state == RRC_STATE_CELL_DCH))
    {
      if (rrccu_rl_failure_info.t314_info.timer_status == RE_EST_TIMER_STARTED)
      {
        WRRC_MSG0_HIGH("Stopping T314");
        rrctmr_stop_timer(RRCTMR_T_314_TIMER); 
      }
      if (rrccu_rl_failure_info.t315_info.timer_status == RE_EST_TIMER_STARTED)
      {
        WRRC_MSG0_HIGH("Stopping T315");
        rrctmr_stop_timer(RRCTMR_T_315_TIMER); 
      }
    }
    state = rrc_translate_state_indicator_to_state(rrccu_state_indicator);

#ifdef FEATURE_WCDMA_HS_FACH
  rrccu_update_rnti_from_cu_cnf(
    RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs ,new_H_RNTI),
    RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs ,newPrimary_E_RNTI),
    &cu_confirm_ptr->new_H_RNTI,
    &cu_confirm_ptr->newPrimary_E_RNTI,
    &directed_cell_info);
#endif
    if((rrccu_resp_msg == RRCCU_UMIC_COMPLETE_RESP_MSG)
       &&(((directed_cell_info.freq_info_present == FALSE )&& 
              (directed_cell_info.pscr_present == FALSE ))
            ||(  rrccu_state_indicator ==rrc_RRC_StateIndicator_cell_DCH))
        )
    {
      if (rrc_get_rlc_size_change_status_for_procedure_id(RRC_PROCEDURE_CU))
      {
        rrcsmc_update_hfn_for_rlc_rb(rlc_size_change_in_progress.rb_id, 
                                     rlc_size_change_in_progress.direction);
      }
      if (!rrccu_cucnf_for_srns_relocation)
      {
        /* procedure does not involve SRNS relocation */

        /* need to send RNTI update request if any of the RNTIs is present
        in the message */
        if ((RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,new_C_RNTI)) ||
            (RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,new_U_RNTI)))
        {
          /* Allocates the buffer to RRC Internal command */
          cmd_ptr =  rrc_get_int_cmd_buf();

          /* Fill parameters for RRC_RNTI_UPDATE_REQ command */
          cmd_ptr->cmd.rnti_update_req.procedure = RRC_PROCEDURE_CU;
          cmd_ptr->cmd_hdr.cmd_id = RRC_RNTI_UPDATE_REQ;

          if (RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,new_C_RNTI)) 
          {
            rrc_translate_crnti(&cu_confirm_ptr->new_C_RNTI,&crnti);
            cmd_ptr->cmd.rnti_update_req.crnti_action = RRC_RNTI_UPDATE;
            cmd_ptr->cmd.rnti_update_req.crnti = crnti;

#ifdef FEATURE_WCDMA_HS_RACH
            if(rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH)
            {
              rrchsrach_set_hspa_rnti_stored_cell_pch(ordered_config_ptr,TRUE);
            }
#endif
          }
          else
          {
            cmd_ptr->cmd.rnti_update_req.crnti_action = RRC_RNTI_NOCHANGE;
          }

          if(RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,new_U_RNTI))
          {
            rrc_translate_urnti(&cu_confirm_ptr->new_U_RNTI, &urnti);
            cmd_ptr->cmd.rnti_update_req.urnti_action = RRC_RNTI_UPDATE;
            cmd_ptr->cmd.rnti_update_req.urnti= urnti;
          }
          else
          {
            cmd_ptr->cmd.rnti_update_req.urnti_action = RRC_RNTI_NOCHANGE;
          }

          /* Indicate to LLC if RLC for SRBs needs to be re-established */
          if(cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4 == TRUE)
          {
            cmd_ptr->cmd.rnti_update_req.rlc_re_establish_srb = TRUE;
          }
          else
          {
            cmd_ptr->cmd.rnti_update_req.rlc_re_establish_srb = FALSE;
          }

          /* Indicate to LLC if RLC for User plane RBs needs to be re-established */
          if(cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove == TRUE)
          {
            cmd_ptr->cmd.rnti_update_req.rlc_re_establish_rab = TRUE;
          }
          else
          {
            cmd_ptr->cmd.rnti_update_req.rlc_re_establish_rab = FALSE;
          }

          cmd_ptr->cmd.rnti_update_req.cnf_required = TRUE;
          WRRC_MSG2_HIGH("Sending RNTI update req CRNTI_stat:%d, URNTI_stat:%d", 
                    cmd_ptr->cmd.rnti_update_req.crnti_action,
                    cmd_ptr->cmd.rnti_update_req.urnti_action);

          rrc_put_int_cmd(cmd_ptr);       /* sends the command to RRC  LLC. */

          rrccu_substate = RRCCU_WAIT_FOR_RNTI_UPDATE_CNF;         
        }
        else
        {
          if (C_RNTI_NOT_VALID == rrcllc_get_current_crnti_status())
          {
            /* should not come here as this condition is already taken care in downlink
            sdu processing */
            WRRC_MSG1_ERROR("RNTI absent for UMIC message, next state %d",
                    rrc_get_state());
            /* Set the Transaction Id */
            rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;

            /* Set Failure cause */
            rrccu_failure_cause.failureCause.t = 
              T_rrc_FailureCauseWithProtErr_invalidConfiguration;
   
            rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
            /* continue with rrccu state  RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM */
            return;
          }
          rrccu_send_response_msg();
        }
        if( RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,cn_InformationInfo))
        {
          (void) rrc_ccm_send_nas_cn_info_r6(&(cu_confirm_ptr->cn_InformationInfo));
        } 
      }
      else
      {
        /* procedure involves SRNS relocation so store the C-RNTI
        and send rlc_reestablishment request to SMC . RNTI update 
        will be done after RLC re-establishment*/
        if (RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,new_C_RNTI))
        {
          rrccu_new_crnti_valid = TRUE;
          rrc_translate_crnti(&cu_confirm_ptr->new_C_RNTI,&rrccu_new_crnti);
#ifdef FEATURE_WCDMA_HS_RACH
          if(rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH)
          {
            rrchsrach_set_hspa_rnti_stored_cell_pch(ordered_config_ptr,TRUE);
          }
#endif
        }
        if(RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,new_U_RNTI))
        {
          rrccu_new_urnti_valid = TRUE;
          rrc_translate_urnti(&cu_confirm_ptr->new_U_RNTI,&rrccu_new_urnti);
        }
        /* store the rlc re-establishment indications */
        rrccu_reestablish_srb = cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4;
        rrccu_reestablish_rab = cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove;

        //commit fresh values for srns relocation
        rrcsmc_commit_fresh_for_srns_relocation();

        rrccu_send_re_est_rlc_for_srns_req (RRC_RE_EST_RB_2, TRUE);
          
          if(RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,cn_InformationInfo))
          {
            (void) rrc_ccm_send_nas_cn_info_r6(&(cu_confirm_ptr->cn_InformationInfo));
          } 
       
      }
    }
    else if(( rrccu_resp_msg == RRCCU_NO_RESP_MSG)
       &&(((directed_cell_info.freq_info_present == FALSE )&& 
              (directed_cell_info.pscr_present == FALSE ))
            ||(  rrccu_state_indicator ==rrc_RRC_StateIndicator_cell_DCH))
    ) 
    {
      rrccu_check_and_send_response_to_previous_cell_upd_cnf();

        /* if any rlc entity has to be re-established then re-establish it before configuring channels. */
        if((cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4 == TRUE) ||
            (cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove == TRUE))
        {
          /* store the rlc re-establishment indications */
          rrccu_reestablish_srb = cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4;
          rrccu_reestablish_rab = cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove;
          rrccu_new_crnti_valid = FALSE;
          rrccu_new_urnti_valid = FALSE;
          rrccu_send_rnti_update_req(FALSE);
          WRRC_MSG2_HIGH("CU Confirm R7: RNTI_UPDATE_REQ  to reestablish SRBs(%d)  DataRB (%d)",
                       rrccu_reestablish_srb,rrccu_reestablish_rab);
        }
        rrccu_reestablish_srb = FALSE;
        rrccu_reestablish_rab = FALSE;
    /* if the next state is cell_pch or ura_pch then setup pcch */
      if ((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH) ||
           (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH))
      {
        if(  RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,cn_InformationInfo))
        {
          (void) rrc_ccm_send_nas_cn_info_r6(&(cu_confirm_ptr->cn_InformationInfo));
        } 
       /*set the UTRAN DRX coef in rrcllc */
        rrcllc_set_utran_drx_info (rrccu_utran_drx_coef); 
        rrccu_establish_pcch_rb (state);
        rrccu_substate = RRCCU_WAIT_FOR_PCCH_RB_EST_CNF;
      }
      else 
      {
        /* Reset the state machine and the procedure ends */
        rrccu_substate = RRCCU_INITIAL;
        /* Start timer T305 */
        rrccu_start_t_305_timer();
        if( RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,cn_InformationInfo))
        {
          (void) rrc_ccm_send_nas_cn_info_r6(&(cu_confirm_ptr->cn_InformationInfo));
        } 
       /* Inform all registered RRC procedures that Cell
         Update is completed */
        rrccu_inform_cell_update_completed();

     
        rrccu_process_successful_completion();
       
        /*call the procedure to clear the global variabls */
        rrccu_clear_procedure();
        rrccu_init_last_cu_cnf_info();

      }
    }
    else
    {
      status = rrcllc_set_ordered_config(RRC_PROCEDURE_CU, state, dl_sdu_type, msg_ptr) ;

      switch( status  )
      {
        case ORDERED_CONFIG_SET:
          /* set the flag.Later it will be used while clearing the OC */
          rrccu_oc_set_by_cu = TRUE;

          if ((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH)||
              (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH))
          {
     
       
            /*call the function that evaluates the directed cell info and set the flags accordingly */
            if (rrcrb_validate_directed_cell_info (directed_cell_info) == FALSE)
            {
              if(rrccsp_check_initiate_cell_selection_handling(&directed_cell_info) == FALSE)
              {
                rrccu_cu_initiate_reqd.cu_reqd = TRUE;
                rrccu_cu_initiate_reqd.cu_cause = rrc_CellUpdateCause_cellReselection;
              }
              else
              {
                rrccu_int_data.rrccu_cell_selection_trans_from_fach = TRUE;
              }
            }

            if (rrccu_resp_msg == RRCCU_UMIC_COMPLETE_RESP_MSG)
            {
              if (rrc_get_rlc_size_change_status_for_procedure_id(RRC_PROCEDURE_CU))
              {
                rrcsmc_update_hfn_for_rlc_rb(rlc_size_change_in_progress.rb_id, 
                                             rlc_size_change_in_progress.direction);
              }
            }

            /* copy the channel config info in to a local buffer
            we should configure the channels after the response message
            is sent */

            /* Fill in the command parameters for RRC_CHANNEL_CONFIG_REQ */

            /* Fill in parameters for RRC_CHANNEL_CONFIG_REQ command */
              /* Change the state if it is not CELL_PCH or URA_PCH */
            rrccu_chan_config_info.num_rbs = 
                  rrccu_update_chan_config_rb_r7(
                    cu_confirm_ptr,rrccu_chan_config_info.rb_info);
            
#ifdef FEATURE_WCDMA_HS_FACH
            if((rrcenhstate_camped_cell_supports_e_fach() == TRUE) &&
                        (rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH || rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH))
            {
              if((RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,new_H_RNTI))
#ifdef FEATURE_WCDMA_HS_RACH
                || (RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs ,newPrimary_E_RNTI))
#endif
                )
              {
#ifdef FEATURE_WCDMA_HS_RACH
                if((rrchsrach_camped_cell_supports_hsrach() == TRUE) && RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs ,newPrimary_E_RNTI))
                {
                  current_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = TRUE;
                  (void)rrc_translate_ernti(&cu_confirm_ptr->newPrimary_E_RNTI, &current_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti);
                }
#endif
                  rrcllc_establish_srb_rab_in_efach(RRC_E_FACH_DEDICATED,RRC_PROCEDURE_CU,TRUE);
                
              }
            }
#endif
           
            rrccu_chan_config_reqd = TRUE;
            if (! rrccu_cucnf_for_srns_relocation)
            {
              /* procedure does not involve SRNS relocation */

              /* CRNTI always must be present to send the 
              response message */
              /* if cucnf message has new C-RNTI  then we need to update
              the C-RNTI in mac first and send the response and then start
              the channel configuration */
              if (RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,new_C_RNTI))
              {
                /* Allocates the buffer to RRC Internal command */
                cmd_ptr =  rrc_get_int_cmd_buf();
                /* Fill parameters for RRC_RNTI_UPDATE_REQ command */
                cmd_ptr->cmd.rnti_update_req.procedure = RRC_PROCEDURE_CU;
                cmd_ptr->cmd_hdr.cmd_id = RRC_RNTI_UPDATE_REQ;

                rrc_translate_crnti(&cu_confirm_ptr->new_C_RNTI,&crnti);
                cmd_ptr->cmd.rnti_update_req.crnti_action = RRC_RNTI_UPDATE;
                cmd_ptr->cmd.rnti_update_req.crnti = crnti;

                if(RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,new_U_RNTI))
                {
                  rrc_translate_urnti(&cu_confirm_ptr->new_U_RNTI, &urnti);
                  cmd_ptr->cmd.rnti_update_req.urnti_action = RRC_RNTI_UPDATE;
                  cmd_ptr->cmd.rnti_update_req.urnti= urnti;
                }
                else
                {
                  cmd_ptr->cmd.rnti_update_req.urnti_action = RRC_RNTI_NOCHANGE;
                }
                /* Indicate to LLC if RLC for SRBs needs to be re-established */
                if(cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4 == TRUE)
                {
                  cmd_ptr->cmd.rnti_update_req.rlc_re_establish_srb = TRUE;
                }
                else
                {
                  cmd_ptr->cmd.rnti_update_req.rlc_re_establish_srb = FALSE;
                }
                /* Indicate to LLC if RLC for User plane RBs needs to be re-established */
                if(cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove == TRUE)
                {
                  cmd_ptr->cmd.rnti_update_req.rlc_re_establish_rab = TRUE;
                }
                else
                {
                  cmd_ptr->cmd.rnti_update_req.rlc_re_establish_rab = FALSE;
                }
                cmd_ptr->cmd.rnti_update_req.cnf_required = TRUE;

                WRRC_MSG2_HIGH("Sending RNTI update req CRNTI_stat:%d, URNTI_stat:%d", 
                          cmd_ptr->cmd.rnti_update_req.crnti_action,
                          cmd_ptr->cmd.rnti_update_req.urnti_action);

                rrc_put_int_cmd(cmd_ptr);       /* sends the command to RRC  LLC. */

                rrccu_substate = RRCCU_WAIT_FOR_RNTI_UPDATE_CNF;         
                if( RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,cn_InformationInfo))
                {
                  (void) rrc_ccm_send_nas_cn_info_r6(&(cu_confirm_ptr->cn_InformationInfo));
                } 
              }
              else
              {
                /* We will be in Cell_FACH state at this time and going to send the
                response message in Cell_FACH state.*/
                WRRC_MSG1_HIGH("RNTI absent for RB resp message, next state%d", 
                        rrc_get_state());
                if( RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,cn_InformationInfo))
                {
                  (void) rrc_ccm_send_nas_cn_info_r6(&(cu_confirm_ptr->cn_InformationInfo));
                } 
                if ((rrccu_int_data.rrccu_cell_selection_trans_from_fach) &&
                    (rrccu_resp_msg == RRCCU_NO_RESP_MSG))
                {
                  rrccu_intiate_cell_selection_fach_pch_cu_cnf(); 
                }
                else
                {
                  /* send the response message on the old configuration */
                  rrccu_send_response_msg();
                }
              }
            }
            else
            {
              /* procedure involves SRNS relocation so store the C-RNTI
              and send rlc_reestablishment request to SMC . RNTI update 
              will be done after RLC re-establishment*/
              if (RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,new_C_RNTI))
              {
                rrccu_new_crnti_valid = TRUE;
                rrc_translate_crnti(&cu_confirm_ptr->new_C_RNTI,&rrccu_new_crnti);
              }
              if(RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,new_U_RNTI))
              {
                rrccu_new_urnti_valid = TRUE;
                rrc_translate_urnti(&cu_confirm_ptr->new_U_RNTI,&rrccu_new_urnti);
              }
              /* store the rlc re-establishment indications */
              rrccu_reestablish_srb = cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4;
              rrccu_reestablish_rab = cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove;

              //commit fresh values for srns relocation
              rrcsmc_commit_fresh_for_srns_relocation();

              rrccu_send_re_est_rlc_for_srns_req(RRC_RE_EST_RB_2, TRUE);
                   
     
                if( RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,cn_InformationInfo))
                {
                  (void) rrc_ccm_send_nas_cn_info_r6(&(cu_confirm_ptr->cn_InformationInfo));
                } 
             
            }
          }
          else /*normal fach-fach or fach-dch configuration */
          {
            /* if any rlc entity has to be re-established then re-establish it 
            before configuring channels. */
            if((cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4 == TRUE) ||
                (cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove == TRUE))
            {
              /* store the rlc re-establishment indications */
              rrccu_reestablish_srb = cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4;
              rrccu_reestablish_rab = cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove;
              rrccu_new_crnti_valid = FALSE;
              rrccu_new_urnti_valid = FALSE;
              rrccu_send_rnti_update_req(FALSE);
              ps_rb_re_establish_indicator = cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove;
              WRRC_MSG1_HIGH("CU: RB5 or higher re-establish indicator %d",
                       cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove);
            }
            rrccu_reestablish_srb = FALSE;
            rrccu_reestablish_rab = FALSE;
            /* store the C-RNTI
            and send rlc_reestablishment request to SMC . RNTI update 
            will be done after Channel configuration*/
            if (RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,new_C_RNTI) 
                 && (rrccu_state_indicator != rrc_RRC_StateIndicator_cell_DCH) ) 
            {
              rrccu_new_crnti_valid = TRUE;
              rrc_translate_crnti(&cu_confirm_ptr->new_C_RNTI,&rrccu_new_crnti);
            }
            if(RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,new_U_RNTI))
            {
              rrccu_new_urnti_valid = TRUE;
              rrc_translate_urnti(&cu_confirm_ptr->new_U_RNTI,&rrccu_new_urnti);
            }

            /*check whether this procedure involves SRNS reloc */
            if (rrccu_cucnf_for_srns_relocation)
            {
              /*commit fresh values for srns relocation */
              rrcsmc_commit_fresh_for_srns_relocation();
            }
            /* Allocates the buffer to RRC Internal command */
              cmd_ptr =  rrc_get_int_cmd_buf();
              rrccu_cipher_update_required = FALSE;

              /* Initialize the no of RBs */
              no_of_RBs = 0;
              /* Fill in the command parameters for RRC_CHANNEL_CONFIG_REQ */
              cmd_ptr->cmd_hdr.cmd_id = RRC_CHANNEL_CONFIG_REQ;
              cmd_ptr->cmd.chan_config_req.procedure = RRC_PROCEDURE_CU;

              /* Fill in parameters for RRC_CHANNEL_CONFIG_REQ command */
              if (rrccu_state_indicator == rrc_RRC_StateIndicator_cell_DCH  )
              {
                //if we r going to dch, then dl-common-info-for-all-rl will be present..
                //check if ciphering is active in mac for cs domain, if it is then,
                //start 2 tiered HHO procedure STEP_1 and STEP_2 for rl-re-establishment
                if(rrcsmc_tm_ciph_active() == TRUE)
                {
                  uint32 mac_d_hfn_l=RRCSMC_INVALID_HFN_VALUE;

                  WRRC_MSG0_HIGH("RL-cipher present in TM-rb's");

                  if (RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,dl_CommonInformation))
                  {
                    if(RRC_MSG_COMMON_BITMASK_IE(cu_confirm_ptr->dl_CommonInformation,
                        rrc_DL_CommonInformation_r7,dl_dpchInfoCommon))
                    {
                      (void) rrcrb_get_mac_d_hfn(
                       (
                        RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr->dl_CommonInformation.dl_dpchInfoCommon.u.
                         dl_DPCH_InfoCommon,rrc_DL_DPCH_InfoCommon_r6,mac_d_HFN_initial_value)),
                        &cu_confirm_ptr->dl_CommonInformation.dl_dpchInfoCommon.u.
                         dl_DPCH_InfoCommon->mac_d_HFN_initial_value,
                        &mac_d_hfn_l);
                    }
                  }

                  if(SUCCESS == rrcsmc_process_cipher_config_for_hho(mac_d_hfn_l)) 
                  {
                    rrccu_cipher_update_required = TRUE;
                  }
                }
                else
                {
                  WRRC_MSG0_HIGH("RL-cipher not-present in TM");
                }

                /* Change the state if it is not CELL_PCH or URA_PCH */
                cmd_ptr->cmd.chan_config_req.rrc_state_change_required = TRUE;
                cmd_ptr->cmd.chan_config_req.next_state = state;
              }
              else
              {
                cmd_ptr->cmd.chan_config_req.rrc_state_change_required = FALSE;
              }
              cmd_ptr->cmd.chan_config_req.rrc_channel_config_cnf_required = TRUE;

               no_of_RBs =
                rrccu_update_chan_config_rb_r7(cu_confirm_ptr, cmd_ptr->cmd.chan_config_req.rb);
              
#ifdef FEATURE_WCDMA_HS_FACH
              if (rrcenhstate_camped_cell_supports_e_fach()&&
                     (rrccu_state_indicator ==rrc_RRC_StateIndicator_cell_FACH))
              {
                no_of_RBs = rrccu_update_chan_config_rb_r7_for_efach(no_of_RBs,cmd_ptr->cmd.chan_config_req.rb);
              }
#endif
              cmd_ptr->cmd.chan_config_req.num_rb_to_config =(int) no_of_RBs;

              rrc_fill_rb_id_chan_req_from_standalone_db(&no_of_RBs, &cmd_ptr->cmd.chan_config_req);

              if(rrccu_state_indicator == rrc_RRC_StateIndicator_cell_DCH)
              {
                /*Fill those RBs in chan_config_req for which RLC PDU size has changed and 
                that are already not present in chan_config_req*/
                rrc_fill_rb_id_chan_req_from_rb_list_mapped_to_dch(&no_of_RBs, 
                              &cmd_ptr->cmd.chan_config_req);
              }

              /*If state transition is Cell_FACH->Cell_DCH, add all the existing AM SRBs and 
              PS RBs in chan_config_req*/
              if((rrc_get_state() == RRC_STATE_CELL_FACH) && 
                            (rrccu_state_indicator == rrc_RRC_StateIndicator_cell_DCH))
              {
                rrc_fill_rb_id_chan_req_from_est_rabs(&no_of_RBs, 
                              &cmd_ptr->cmd.chan_config_req);
                rrc_fill_srb_in_chan_config_req(&no_of_RBs,&cmd_ptr->cmd.chan_config_req);

              }
              cmd_ptr->cmd.chan_config_req.chan_config_reason = RRCLLC_CHAN_CFG_REASON_NONE;
     
       
              /*call the function that evaluates the directed cell info and set the flags accordingly */
              if ((rrc_RRC_StateIndicator_cell_FACH == rrccu_state_indicator) &&
                  (rrcrb_validate_directed_cell_info (directed_cell_info) == FALSE))
              {
                if(rrccsp_check_initiate_cell_selection_handling(NULL) == FALSE)
                {
                  rrccu_cu_initiate_reqd.cu_reqd = TRUE;
                  rrccu_cu_initiate_reqd.cu_cause = rrc_CellUpdateCause_cellReselection;
                  WRRC_MSG1_HIGH("CHANNEL_CONFIG_REQ for %dRBs",no_of_RBs);
                  rrc_put_int_cmd(cmd_ptr);                 /* sends the command to RRC
                                                             LLC. */
                  rrccu_substate = RRCCU_WAIT_FOR_RB_EST_CNF;         
                }
                else
                {
                  rrccu_intiate_cell_selection_within_fach_cu_cnf(cmd_ptr);
                  cmd_ptr = NULL;
                }
              }
              else
              {
                WRRC_MSG1_HIGH("CHANNEL_CONFIG_REQ for %dRBs", no_of_RBs);
                rrc_put_int_cmd(cmd_ptr); /* sends the command to RRC LLC. */
                rrccu_substate = RRCCU_WAIT_FOR_RB_EST_CNF;         
              }

            if(RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,cn_InformationInfo))
            {
              (void) rrc_ccm_send_nas_cn_info_r6(&(cu_confirm_ptr->cn_InformationInfo));
            } 
          }
          break;

        case ORDERED_CONFIG_INCOMPATABLE_SIMULTANEOUS_RECONFIG:
          /* This should not occur for CELL UPDATE CONFIRM */
          /* Set the Transaction Id */
          rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;

          /* Set Failure cause */
          rrccu_failure_cause.failureCause.t = 
            T_rrc_FailureCauseWithProtErr_incompatibleSimultaneousReconfiguration;


          rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
          break;

        case ORDERED_CONFIG_CONFIGURATION_NOT_SUPPORTED:
          /* Set the Transaction Id */
          rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;

          /* Set Failure cause */
          rrccu_failure_cause.failureCause.t = 
            T_rrc_FailureCauseWithProtErr_configurationUnsupported;
   

          rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
          break;

        case ORDERED_CONFIG_NOT_SET_OTHER:
          /* For Cell Update Confirm message RRC LLC should never
             set Ordered Config */
          WRRC_MSG0_ERROR("Ordered Config Should not return this status");
          break;

        case ORDERED_CONFIG_CONFIGURATION_INVALID:
          /* Set the Transaction Id */
          rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;

          /* Set Failure cause */
          rrccu_failure_cause.failureCause.t = 
            T_rrc_FailureCauseWithProtErr_invalidConfiguration;
  

          rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
          break;

        default:
          WRRC_MSG0_ERROR("Invalid status from ORDERED_CONFIG");
          break;
      } 
    }  
  }
} /* rrccu_process_cell_update_confirm_r5*/


/*===========================================================================
FUNCTION   rrccu_map_cu_cause

DESCRIPTION
  This function maps the OTA format CU cause type to RRC internal format CU cause.
        
DEPENDENCIES
  None.
 
RETURN VALUE
  None.

SIDE EFFECTS
  None.
===========================================================================*/
rrc_cell_update_cause_e_type rrccu_map_cu_cause
(
  rrc_CellUpdateCause cu_cell_update_cause
)
{
  if(cu_cell_update_cause == rrc_CellUpdateCause_cellReselection)
  {
    return RRC_CELL_RESELECTION;
  }
  else if(cu_cell_update_cause == rrc_CellUpdateCause_periodicalCellUpdate)
  {
    return RRC_PERIODIC_CELL_UPDATE;
  }
  else if(cu_cell_update_cause == rrc_CellUpdateCause_uplinkDataTransmission)
  {
    return RRC_UL_DATA_TRANSMISSION;
  }  
  else if(cu_cell_update_cause == rrc_CellUpdateCause_utran_pagingResponse)
  {
    return RRC_PAGING_RESPONSE;
  }   
  else if(cu_cell_update_cause == rrc_CellUpdateCause_re_enteredServiceArea)
  {
    return RRC_REENTERED_SERVICE_AREA;
  }  
  else if(cu_cell_update_cause == rrc_CellUpdateCause_radiolinkFailure)
  {
    return RRC_RADIO_LINK_FAILURE;
  }   
  else if(cu_cell_update_cause == rrc_CellUpdateCause_rlc_unrecoverableError)
  {
    return RRC_UNRECOVERABLE_ERROR;
  }
  else if(cu_cell_update_cause == rrc_CellUpdateCause_cellUpdateCause_ext)
  {
      WRRC_MSG1_ERROR("Cell Update cause %d is invalid.",cu_cell_update_cause);      
    }
  else
  {
    WRRC_MSG1_ERROR("Cell Update cause %d is invalid.",cu_cell_update_cause);
  }
  return RRC_CU_CAUSE_NONE;
}

/*===========================================================================

FUNCTION   rrccu_send_cu_failure_unsupported_config

DESCRIPTION

  This function re-sends the cell update message with failure cause unsupported
  configuration because UE dont support the extension provided by the network.
        
DEPENDENCIES

  None.
 
RETURN VALUE

  None.

SIDE EFFECTS

  None.

===========================================================================*/
static void rrccu_send_cu_failure_unsupported_config
(
  /* transaction id of RB Reconfig message */
  rrc_RRC_TransactionIdentifier transaction_id  
)
{
  rrccu_failure_cause.rrc_TransactionIdentifier = transaction_id;

  rrccu_failure_cause.failureCause.t = 
   T_rrc_FailureCauseWithProtErr_protocolError;
  
  rrccu_failure_cause.failureCause.u.protocolError = 
    rtxMemAllocTypeZ (&enc_ctxt, rrc_ProtocolErrorInformation);
  
  rrccu_failure_cause.failureCause.u.protocolError->diagnosticsType.t = 
   T_rrc_ProtocolErrorInformation_diagnosticsType_type1;
  rrccu_failure_cause.failureCause.u.protocolError->diagnosticsType.u.type1 = 
    rtxMemAllocTypeZ (&enc_ctxt, rrc_ProtocolErrorInformation_type1);
  
  rrccu_failure_cause.failureCause.u.protocolError->
   diagnosticsType.u.type1->protocolErrorCause = rrc_ProtocolErrorCause_messageExtensionNotComprehended;

  /* Resend the CELL UPDATE with Failure cause */
  rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);

  return;
}

/*===========================================================================

FUNCTION   rrccu_compare_received_urnti

DESCRIPTION

  This function compares the received urnti with the stored value.
  If it matches then it returns SUCCESS else returns FAILURE.
          
DEPENDENCIES

  None.

REUSABILITY: R99/R5/R6, and ccch/dcch

RETURN VALUE

  SUCCESS or FAILURE

SIDE EFFECTS

  None.

===========================================================================*/
static uecomdef_status_e_type rrccu_compare_received_urnti
(
  struct rrc_U_RNTI  *ext_urnti     /* Pointer to external U-RNTI type */
)
{
  rrc_int_u_rnti_type                 u_rnti_rcvd;              /* Local varibale to store U-RNTI */
  rrc_int_u_rnti_type                 u_rnti_stored;        /* Local varibale to store U-RNTI */

  /* Translate the U-RNTI */
  rrc_translate_urnti(ext_urnti, &u_rnti_rcvd);

  if(U_RNTI_NOT_PRESENT == rrcllc_get_current_urnti(&u_rnti_stored) )
  {
    WRRC_MSG0_HIGH("URNTI is not present");
    return(FAILURE);
  }

  if(u_rnti_stored == u_rnti_rcvd)
  {
    return(SUCCESS);
  }
  else
  {
    WRRC_MSG0_HIGH("U-RNTI Mismatch. Ignore");
    return(FAILURE);
  }
} /* rrccu_compare_received_urnti */

/*===========================================================================

FUNCTION   rrccu_validate_and_check_integrity_for_srns_relocoation

DESCRIPTION

  This function validates whether received cell update msg is due to SRNS relocation,
  if yes, then it performs the integrity check on the received message because
  integrity check was skipped for message which triggers SRNS relocation.
          
DEPENDENCIES

  None.

REUSABILITY: R99/R5/R6, and ccch/dcch

RETURN VALUE

  SUCCESS or FAILURE

SIDE EFFECTS

  None.

===========================================================================*/
static uecomdef_status_e_type rrccu_validate_and_check_integrity_for_srns_relocoation
(
  rrc_cmd_type *cmd_ptr,
  /* Pointer to the PC Reconfig message        */
 OSS_UINT32 dl_counter_sync_info_present,
 rrc_RRC_TransactionIdentifier transaction_id,  
 rrc_msg_ver_enum_type msg_version
)
{
  rrcsmc_srns_ip_check_status_e_type  ip_check_status = 
                                         RRCSMC_SRNS_INTEGRITY_CHECK_SUCCESS;

  /*check whether SRNS relocation info is present or not
  if present  then the integrity check has to be done with the new
  integrity protection info in the message */
  if (dl_counter_sync_info_present)
  {
    /*SRNS Relocation is involved with this message 
    Call the SMC api to do integrity check with new integrity info */

    ip_check_status = 
        rrcsmc_check_integrity_for_srns_relocation(
          cmd_ptr
          , msg_version
        );

    switch (ip_check_status)
    {
      case RRCSMC_SRNS_INTEGRITY_CHECK_SUCCESS:
        break;

      case RRCSMC_SRNS_INTEGRITY_CHECK_FAILURE:
        /*Discard the message and continue with ongoing procedure as if this
        message was not received */
        WRRC_MSG0_ERROR("IP check failed. Discarding CUCNF msg");
        break;

      case RRCSMC_SRNS_SECURITY_INFO_INVALID:
      case RRCSMC_INCOMPATIBLE_SECURITY_RECONFIGURATION:
        /* Update the failure cause */
        rrccu_failure_cause.rrc_TransactionIdentifier = transaction_id;
        /* populate the appropriate failure cause */
        if (ip_check_status == RRCSMC_SRNS_SECURITY_INFO_INVALID)
        {
          rrccu_failure_cause.failureCause.t = 
            T_rrc_FailureCauseWithProtErr_invalidConfiguration;
        }
        else
        {
          rrccu_failure_cause.failureCause.t = 
            T_rrc_FailureCauseWithProtErr_incompatibleSimultaneousReconfiguration;
        }
        /* Resend the CELL UPDATE with Failure cause */
        rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
        break;

      default:
        /*should not come here */
        break;
    }
  }

  if (RRCSMC_SRNS_INTEGRITY_CHECK_SUCCESS == ip_check_status)
  {
    return(SUCCESS);
  }
  else
  {
    return(FAILURE);
  }
}/* rrccu_validate_and_check_integrity_for_srns_relocoation */

/*===========================================================================

FUNCTION RRCCU_SEND_RESPONSE_MSG

DESCRIPTION
  This function transmits response message to CELL UPDATE CONFIRM message if
  required.
  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
void rrccu_send_response_msg
(    
  void
)
{
  rrc_utran_mob_info_cnf_type umi_cnf_info;
  rrc_UL_DCCH_Message *msg_ptr;          /* Pointer to Uplink DCCH Msg */
  rrcsend_l2ack_status_e_type l2_ack_status =RRCSEND_L2ACK_REQUIRED;

  rlc_lc_id_type ul_rlc_lc_id = RRCLCM_RLC_LC_ID_NOT_FOUND;
                                      /* Local varible for Uplink RLC LC Id. */
  uint16 l2_ack_timer_val = 0;

#ifdef FEATURE_WCDMA_HS_FACH_DRX
  ordered_config_type *config_ptr = rrcllc_get_config_ptr_in_use();
#endif

  switch(rrccu_resp_msg)
  {
    case RRCCU_NO_RESP_MSG:
      /* No Response is required. Hence reset the CU state machine */
      rrccu_substate = RRCCU_INITIAL;
      /*call the procedure to clear the global variabls */
      rrccu_clear_procedure();
      break;

    case RRCCU_UMIC_COMPLETE_RESP_MSG:
    case RRCCU_RBR_COMPLETE_RESP_MSG:
    case RRCCU_RBRC_COMPLETE_RESP_MSG:
    case RRCCU_TCR_COMPLETE_RESP_MSG:
    case RRCCU_PCR_COMPLETE_RESP_MSG: 
      /* Build UTRAN MOBILITY INFO CONFIRM Message */
      umi_cnf_info.transaction_id = rrccu_trans_id;
     
      /* Check whether RB2 is already established */
      ul_rlc_lc_id = rrclcm_check_ul_rlc_lc_id(UE_LOGCHAN_DCCH, 
                                   DCCH_AM_RADIO_BEARER_ID,
                                   UE_MODE_ACKNOWLEDGED_DATA);

      if(ul_rlc_lc_id == RRCLCM_RLC_LC_ID_NOT_FOUND)
      {
        WRRC_MSG0_ERROR("Cann't find RLC LC Id for RB 2");
      }
      else
      {
        msg_ptr = (rrc_UL_DCCH_Message *) rrc_malloc ( 
                                    sizeof(struct rrc_UL_DCCH_Message));

          if(rrccu_resp_msg == RRCCU_UMIC_COMPLETE_RESP_MSG)
          { /* Build UTRAN MOBILITY INFO CONFIRM Message */
            umi_cnf_info.transaction_id = rrccu_trans_id;
     
            rrcumi_build_utran_mobility_info_confirm_msg(&umi_cnf_info,msg_ptr);
          if (rrccu_cucnf_for_srns_relocation == TRUE)
          {
            /*start list is included in ul_counter_synchronization_info. So enable this IE in the
            bitmask */
           RRC_MSG_COMMON_SET_BITMASK_IE(msg_ptr->message.u.utranMobilityInformationConfirm,
              rrc_UTRANMobilityInformationConfirm,ul_CounterSynchronisationInfo);
           RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.utranMobilityInformationConfirm.ul_CounterSynchronisationInfo);

           
             /* call SMC API to append the start list */
            (void)rrcsmc_append_start_list(&msg_ptr->message.u.utranMobilityInformationConfirm.ul_CounterSynchronisationInfo.startList,RRCSMC_EXTRACT_AND_APPEND_START);
          }
          }
          else if(rrccu_resp_msg == RRCCU_RBR_COMPLETE_RESP_MSG)
          {/* Build Radio Bearer RElease Complete Message */
           rrcrbr_build_rbr_complete_message(rrccu_trans_id,msg_ptr, 
                                             rrccu_cucnf_for_srns_relocation,
                                             rrccu_cipher_update_required);
          }
          else if(rrccu_resp_msg == RRCCU_RBRC_COMPLETE_RESP_MSG)
          {/* Build Radio Bearer Reconfiguration Complete Message */

            rrcrbrc_build_rbrc_complete_message(rrccu_trans_id,msg_ptr, 
                                                rrccu_cucnf_for_srns_relocation,
                                                rrccu_cipher_update_required);
          }
          else if(rrccu_resp_msg == RRCCU_TCR_COMPLETE_RESP_MSG)
          {/* Build Transport Channel Reconfiguration Complete Message */
            rrctcr_build_tcr_complete_message(rrccu_trans_id,msg_ptr, 
                                              rrccu_cucnf_for_srns_relocation,
                                              rrccu_cipher_update_required);
     
          }
          else if(rrccu_resp_msg == RRCCU_PCR_COMPLETE_RESP_MSG)
          {/* Build Physical Channel Reconfiguration Complete Message */
     
            rrcpcr_build_pcr_complete_message(rrccu_trans_id,msg_ptr, 
                                              rrccu_cucnf_for_srns_relocation,
                                              rrccu_cipher_update_required);
          }
          else
          {
            ERR_FATAL(" THis should never happen",0,0,0);
          }

          if ((rrccu_cucnf_for_srns_relocation) ||
              (rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH) ||
              (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH)) 
          {
            l2_ack_status =RRCSEND_L2ACK_REQUIRED;
          }
          else
          {
            l2_ack_status =RRCSEND_L2ACK_NOT_REQUIRED;
          }
          /* Need to wait for L2 ack for all states because RRC needs to trigger include reconfig status indicator
          if RLC acknowledgement is not yet received.
          As per 8.3.1.3
          1> if the IE "Cell update cause" is set to "radio link failure" and the UE has submitted a reconfiguration response
          message to RLC and the UE has not received the RLC acknowledgement for the response message:
          2> include the IE "Reconfiguration Status Indicator" and set it to TRUE.*/
            rrc_update_reconfig_waiting_for_l2ack_dch(RRC_PROCEDURE_CU);
            l2_ack_status = RRCSEND_L2ACK_REQUIRED;
#ifdef FEATURE_QSH_EVENT_METRIC
  
          if(rrc_qsh_dl_committed == FALSE)
          {
            failure_ota.ul_ota_type = RRC_OTA_UL_CPLT;			
            if(rrccu_resp_msg == RRCCU_UMIC_COMPLETE_RESP_MSG)
            {
              failure_ota.msg_id = WRRC_UL_DCCH_MESSAGETYPE_UTRANMOBILITYINFORMATIONCONFIRM;
            }
            else if(rrccu_resp_msg == RRCCU_RBR_COMPLETE_RESP_MSG)
            {
              failure_ota.msg_id = WRRC_UL_DCCH_MESSAGETYPE_RADIOBEARERRELEASECOMPLETE;
            }
            else if(rrccu_resp_msg == RRCCU_RBRC_COMPLETE_RESP_MSG)
            {
              failure_ota.msg_id = WRRC_UL_DCCH_MESSAGETYPE_RADIOBEARERRECONFIGURATIONCOMPLETE;
            }
            else if(rrccu_resp_msg == RRCCU_TCR_COMPLETE_RESP_MSG)
            {
              failure_ota.msg_id = WRRC_UL_DCCH_MESSAGETYPE_TRANSPORTCHANNELRECONFIGURATIONCOMPLETE;
            }
            else if(rrccu_resp_msg == RRCCU_PCR_COMPLETE_RESP_MSG)
            {
              failure_ota.msg_id = WRRC_UL_DCCH_MESSAGETYPE_PHYSICALCHANNELRECONFIGURATIONCOMPLETE;
            }
            if(RRCSMC_IP_STARTED == rrcsmc_check_integrity_status())
            {
              failure_ota.ul_fail_ota.ul_ota_parms.ul_integrity_info_present = 1;
            }
            /* Commit data should happen after dl SDU is committed */
          }
#endif
          /* This places SDU into RLC watermark queue */
          if(RRCSEND_SUCCESS == 
             rrcsend_send_ul_sdu(RRC_PROCEDURE_CU,msg_ptr,ul_rlc_lc_id,
             l2_ack_status) )
          {
             
            WRRC_MSG1_HIGH("CUCnf resp:%d is sent",rrccu_resp_msg);
            /* check whether this channel config included some 
            RBs to be released. In that case release the RBs from
            established_RABs variable. Also indicate to the upper layers if 
            all the RBs associated with a RAB are released */

            if (rrccu_rb_release_info.rrccu_rb_release_in_cucnf == TRUE)
            {
              rrccu_remove_rbs_from_est_rabs();
            }
            if ((rrccu_cucnf_for_srns_relocation) ||
                (rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH) ||
                (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH)) 
            {
              rrccu_substate = RRCCU_WAIT_FOR_L2_ACK; 
              if((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH) ||
                (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH))
              {
 #ifdef FEATURE_WCDMA_HS_FACH_DRX
                if(TRUE == rrcenhstate_get_e_fach_drx_status(&(config_ptr->l1_hsdpa_info)))
                {
                  /* Set timer value as 850 ms for EDRX*/
                  l2_ack_timer_val = RRC_WAIT_TIME_FOR_L2_ACK_FOR_PCH_TRANSITION_FOR_EDRX;
                }
                else
 #endif
                {
                   l2_ack_timer_val = RRC_WAIT_TIME_FOR_L2_ACK_FOR_PCH_TRANSITION;
                }
                rrctmr_start_timer(RRCTMR_WAIT_FOR_L2_ACK_FOR_PCH_TRANSITION_TIMER, l2_ack_timer_val);
              }
            }
            else
            {
              if (rrccu_state_indicator == rrc_RRC_StateIndicator_cell_FACH)
              {
                /* start the periodic timer */
                rrccu_start_t_305_timer();
              }
              /*clear the ordered config if it is set from rrccu procedure */
              if (rrccu_oc_set_by_cu == TRUE)
              {
                rrcllc_clear_ordered_config();
              }
              /* Inform all registered RRC procedures that Cell
                 Update is completed */
              rrccu_inform_cell_update_completed();

    
              rrccu_process_successful_completion();
              
              /* check whether any cell update initiate req needs to be 
              posted to itself due to reselections in certain substates*/
              if (rrccu_cu_initiate_reqd.cu_reqd)
              {
                /* do not delete CRNTI here respnse message might
                get stuck in RLC */
                rrccu_cu_initiate_reqd.cu_reqd = FALSE;
                rrccu_send_cell_update_initiate_req (RRC_CELL_RESELECTION);
              }

              /* The procedures ends */
              rrccu_substate = RRCCU_INITIAL;
              /*call the procedure to clear the global variabls */
              rrccu_clear_procedure();
            }

          }
          else
          {
            /* Reset Cell Update State machine */
            rrccu_substate = RRCCU_INITIAL;
            /*call the procedure to clear the global variabls */
            rrccu_clear_procedure();
            rrccu_init_last_cu_cnf_info();

          } 
        }
      break;      
    
    default:
      WRRC_MSG1_HIGH("Invalid resp Msg Type: %d ",rrccu_resp_msg);
      break;
  }
  if (rrccu_resp_msg == RRCCU_RBR_COMPLETE_RESP_MSG ||
      rrccu_resp_msg == RRCCU_RBRC_COMPLETE_RESP_MSG ||
      rrccu_resp_msg == RRCCU_TCR_COMPLETE_RESP_MSG) 
  {
    rrc_send_rb_rate_info_packet();
  }

  rrccu_check_and_send_response_to_previous_cell_upd_cnf();

} /* rrccu_send_response_msg*/
/*===========================================================================

FUNCTION RRCCU_PROCESS_CU_WAIT_FOR_CELL_UPDATE_CONFIRM

DESCRIPTION
  This function processes all events that are dispatched to Cell Update 
  procedure in RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM substate.

  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
void rrccu_process_cu_wait_for_cell_update_confirm
(    
  rrc_cmd_type *cmd_ptr
)
{

  switch(rrc_get_state())
  {
    case RRC_STATE_CELL_FACH:
      switch(cmd_ptr->cmd_hdr.cmd_id)
      {

        case RRC_CMAC_STATUS_IND:
          rrctmr_start_timer(RRCTMR_T_302_TIMER, rrccu_convert_t302_to_ms(RRC_GET_T302()));   
	  break;
		  
        case RRC_T314_EXPIRED_IND:
          WRRC_MSG2_HIGH("Timer T314 expired cu_st:%d, rrc_st:%d",
                   rrccu_substate,rrc_get_state());
           /* do not send the channel config here because T302 is running
           store the expiry info so that the corresponding RBs are
           released after UE goes to a stable state */
           rrccu_rl_failure_info.t314_info.timer_status         = RE_EST_TIMER_EXPIRED;
           /*release all radio bearers, associated with any radio access 
             bearers for which in the variable ESTABLISHED_RABS the value of the 
             IE "Re-establishment timer" is set to "useT314*/
           rrccu_rl_failure_info.t314_info.need_to_release_rabs = TRUE;
           /*indicate release of those radio access bearers to upper layers*/
           rrccu_rl_failure_info.t314_info.need_rab_release_ind = TRUE;
           if (rrccu_rl_failure_info.t315_info.timer_status == RE_EST_TIMER_STARTED)
           {
             WRRC_MSG0_HIGH("T315 is running");
           }

          break;

        case RRC_T315_EXPIRED_IND:
          WRRC_MSG2_HIGH("Timer T315 expired cu_st:%d, rrc_st:%d",
                   rrccu_substate,rrc_get_state());
           /* do not send the channel config here because T302 is running
           store the expiry info so that the corresponding RBs are
           released after UE goes to a stable state */
           rrccu_rl_failure_info.t315_info.timer_status         = RE_EST_TIMER_EXPIRED;
           /*release all radio bearers, associated with any radio access 
             bearers for which in the variable ESTABLISHED_RABS the value of the 
             IE "Re-establishment timer" is set to "useT315*/
           rrccu_rl_failure_info.t315_info.need_to_release_rabs = TRUE;
           /*indicate release of those radio access bearers to upper layers*/
           rrccu_rl_failure_info.t315_info.need_rab_release_ind = TRUE;
           if (rrccu_rl_failure_info.t314_info.timer_status == RE_EST_TIMER_STARTED)
           {
             WRRC_MSG0_HIGH("T314 is running");
           }
          break;

        case RRC_T302_EXPIRED_IND:
          WRRC_MSG1_HIGH("Timer T302 Expired in state: %d",rrc_get_state());  
          if (rrctmr_get_remaining_time(RRCTMR_T_302_TIMER) == 0) 
          {
            rrc_cu_uu_log_event_failure_cause = RRC_CU_UU_T302_EXPIRED;
            rrccu_resend_cell_update_msg(RRCCU_NOT_INCLUDE_FAILURE_CAUSE);
          }
          else
          {
            /* Else, T302 must have been started again between the time T302 expiry was
            posted onto internal queue and the time CU procedure got the indication.  So
            just ignore here */
            WRRC_MSG0_HIGH("Ignoring T302 expiry");
          }
          break;

        case RRC_NEW_CELL_IND:
          WRRC_MSG2_HIGH("Cell reselection in state:%d, cu_state:%d",
                   rrc_get_state(),rrccu_substate);
          if((rrccu_cell_update_cause == rrc_CellUpdateCause_radiolinkFailure) || 
             (rrccu_cell_update_cause == rrc_CellUpdateCause_rlc_unrecoverableError)) 
          {
            WRRC_MSG0_HIGH("Cell resel ind after RL Failure");
          }
          /* keep the same cause as before unless
          the cause is periodicall cell update otherwise
          change the cause*/
          if (rrccu_cell_update_cause == rrc_CellUpdateCause_periodicalCellUpdate)
          {            
            rrccu_cell_update_cause = rrc_CellUpdateCause_cellReselection;
          }
          rrccu_resend_cell_update_msg(RRCCU_NOT_INCLUDE_FAILURE_CAUSE);
          break;

        case RRC_CELL_UPDATE_INITIATE_REQ:
          if( IS_CU_TRIGGERED_WITH_RE_ENTER_SERVICE_AREA_VALID )
          {
            rrccu_process_oos_area_handling();
            return;
          }
          /* check whether cell update cause need to be changed 
          resend the cell update only if cause need to be changed*/ 
          if (TRUE == 
              rrccu_is_change_of_cu_cause_reqd(cmd_ptr->cmd.initiate_cell_update.cause))
          {
            /* determine the new cu cause based upon the priority */
            rrccu_cell_update_cause = 
              rrccu_map_cu_cause_based_on_priority (cmd_ptr->cmd.initiate_cell_update.cause);
            /*resend cell update message */
            rrccu_resend_cell_update_msg(RRCCU_NOT_INCLUDE_FAILURE_CAUSE);
          }

          break;

        case RRC_DOWNLINK_SDU_IND:
          /* Assert the receieved message is of type rrc_DL_CCCH_Message */
          if(cmd_ptr->cmd.downlink_sdu_ind.dl_sdu_type == rrc_DL_CCCH_Message_PDU)
          {
            rrccu_process_dl_sdu_ind_on_ccch(cmd_ptr);
          }
          else if(cmd_ptr->cmd.downlink_sdu_ind.dl_sdu_type == rrc_DL_DCCH_Message_PDU)
          {
            rrccu_process_dl_sdu_ind_on_dcch(cmd_ptr);
          }
          else
          /* Received other than rrc_DL_CCCH_Message type  and rrc_DL_DCCH_Message*/
          {
            WRRC_MSG1_HIGH("Rcvd an invalid message type:%d",
                      cmd_ptr->cmd.downlink_sdu_ind.dl_sdu_type);
          }
          break; 

        case RRC_CPHY_OUT_OF_SERVICE_AREA_IND:
          rrccu_process_oos_area_handling();
          break;
          
        case RRC_CRLC_STATUS_IND:
          /* compare this cause with previous cell update cause
          if new cause is going to be rlc unrecoverable error
          then call the function to process it. else continuou in 
          the same substate but update the rlc error info */

          rrccu_process_rlc_status_ind_in_non_initial_sub_states(cmd_ptr);
          break;

        default:
          WRRC_MSG2_ERROR("Unknown command: 0x%x, CU st %d", cmd_ptr->cmd_hdr.cmd_id,rrccu_substate);
          break;
      }
      break;

    case RRC_STATE_CELL_PCH:
    case RRC_STATE_URA_PCH: 
      switch(cmd_ptr->cmd_hdr.cmd_id)
      {
        case RRC_STATE_CHANGE_IND:
          WRRC_MSG1_ERROR("Unexpected state change ind in CU st %d", rrccu_substate);
          rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                               RRC_TX_TO_DISCON_OTHER);
          /* Update the release cause */
          rrc_release_cause = RRC_REL_DEEP_FADE;
          rrccu_substate    = RRCCU_WAIT_FOR_RB_REL_CNF;
          break;

        default:
          WRRC_MSG2_ERROR("Unknown command: 0x%x, CU st %d", cmd_ptr->cmd_hdr.cmd_id,rrccu_substate);            
          break;
      } 
      break;

    default:
      WRRC_MSG2_HIGH("Invalid Event: %d in the substate: %d", 
                cmd_ptr->cmd_hdr.cmd_id, rrccu_substate);
      break;
  } 

} /* rrccu_process_cu_wait_for_cell_update_confirm */

/*===========================================================================
FUNCTION rrccu_process_dl_sdu_ind_on_ccch

DESCRIPTION
  This function processes DL SDU IND command if it has come over CCCH.

  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS
  None
===========================================================================*/
void rrccu_process_dl_sdu_ind_on_ccch
(
  rrc_cmd_type *cmd_ptr
)
{
  uint8   message_choice;       /* Local variable to store message t */
  rrc_DL_CCCH_Message                *ccch_msg_ptr = NULL; /* Pointer to  downlink CCCH message */   

  message_choice = rrc_get_dl_ccch_message_type(cmd_ptr->cmd.downlink_sdu_ind.dl_sdu,
                    cmd_ptr->cmd.downlink_sdu_ind.dl_sdu_length);

  if(message_choice == T_rrc_DL_CCCH_MessageType_cellUpdateConfirm)
  {
    WRRC_MSG1_HIGH("Cell Update Confirm rcvd on CCCH for CU cause = %d",
      rrccu_cell_update_cause);
  }

  if(cmd_ptr->cmd.downlink_sdu_ind.decoded_msg != NULL)
  {
    /* Get the OTA message pointer */
    ccch_msg_ptr = (rrc_DL_CCCH_Message *) cmd_ptr->cmd.downlink_sdu_ind.decoded_msg;

    if(ccch_msg_ptr->message.t == T_rrc_DL_CCCH_MessageType_cellUpdateConfirm )
    {
      if(rrc_v_302 != RRC_RACH_TX_STATS_ONE_TIME_RACH)
      {
        /*RACH tx Success full for UE message sent in UL, 
                *so update RACH tx parameters count here*/
        RRC_DEBUG_INCREMENT_STATS(RACH_SUCCFUL_RRC_RETRY);
      }
   
      if (ccch_msg_ptr->message.u.cellUpdateConfirm.t == 
                T_rrc_CellUpdateConfirm_CCCH_r3)
      {
        /* check whether this cell update is for our UE or not */
        if(SUCCESS == rrccu_compare_received_urnti(
             &ccch_msg_ptr->message.u.cellUpdateConfirm.u.r3.u_RNTI))
        {
          if(rrcllc_is_rab_release_in_progress() == TRUE)
          {
            rrc_v_302 --;
            WRRC_MSG0_HIGH("LLC is processing RAB-release, ignore CU-CNF");
            return;
          }
          if (rrccsp_ignore_cu_due_to_resel_cell_change_in_progress() == TRUE )
          {
            WRRC_MSG0_HIGH("Ignore cell update confirm as reselection is  in progress");
            rrc_v_302--;
            return;
          }
          /*check whether SRNS relocation info is present or not
                   if present  then the integrity check has to be done with the new
                   integrity protection info in the message */
          if (SUCCESS == rrccu_validate_and_check_integrity_for_srns_relocoation(
                            cmd_ptr,
                            (RRC_MSG_COMMON_BITMASK_IE(ccch_msg_ptr->message.u.cellUpdateConfirm.u.r3.cellUpdateConfirm_r3,
                              rrc_CellUpdateConfirm_r3_IEs,dl_CounterSynchronisationInfo)),
                            ccch_msg_ptr->message.u.cellUpdateConfirm.u.r3.cellUpdateConfirm_r3.rrc_TransactionIdentifier,
                            MSG_REL99))
          {
            /*continue further processing with the message */
            /* Stop Timer T302 */
            rrctmr_stop_timer(RRCTMR_T_302_TIMER); 
             /* Save the CCCH commands here. All the DCCH commands will be added in Dispatcher  */
            rrc_crash_debug_save_ota(cmd_ptr->cmd.downlink_sdu_ind.dl_sdu, cmd_ptr->cmd.downlink_sdu_ind.dl_sdu_length,RRC_CCCH_DL_SDU, 
                                     rrc_get_dl_ccch_message_type(cmd_ptr->cmd.downlink_sdu_ind.dl_sdu,cmd_ptr->cmd.downlink_sdu_ind.dl_sdu_length),RRC_PROCEDURE_CU);
            rrccu_process_cell_update_confirm( (void *) ccch_msg_ptr,
                                                       rrc_DL_CCCH_Message_PDU);
          }
        }
      }
      else if ((rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) &&
                         (ccch_msg_ptr->message.u.cellUpdateConfirm.t == 
                          T_rrc_CellUpdateConfirm_CCCH_later_than_r3) &&
                         (ccch_msg_ptr->message.u.cellUpdateConfirm.u.
                          later_than_r3.criticalExtensions.t == 
                          T_rrc_CellUpdateConfirm_CCCH_criticalExtensions_5_criticalExtensions))
      {
        if (ccch_msg_ptr->message.u.cellUpdateConfirm.u.
                      later_than_r3.criticalExtensions.u.criticalExtensions.t ==
                      T_rrc_CellUpdateConfirm_CCCH_criticalExtensions_4_r5)
        {
          WRRC_MSG0_HIGH("RRCHS:cellupdateconfirmrel5 rcvd");
          /* check whether this cell update is for our UE or not */
          if(SUCCESS == rrccu_compare_received_urnti(
                &ccch_msg_ptr->message.u.cellUpdateConfirm.u.later_than_r3.u_RNTI))
          {
            if(rrcllc_is_rab_release_in_progress() == TRUE)
            {
              rrc_v_302 --;
              WRRC_MSG0_HIGH("LLC is processing RAB-release, ignore CU-CNF");
              return;
            }
            if (rrccsp_ignore_cu_due_to_resel_cell_change_in_progress() == TRUE)
            {
              WRRC_MSG0_HIGH("Ignore cell update confirm as reselection is  in progress");
              rrc_v_302--;
              return;
            }
            /*check whether SRNS relocation info is present or not
                      if present  then the integrity check has to be done with the new
                      integrity protection info in the message */
            if (SUCCESS == rrccu_validate_and_check_integrity_for_srns_relocoation(
                            cmd_ptr,
                            RRC_MSG_COMMON_BITMASK_IE(ccch_msg_ptr->message.u.cellUpdateConfirm.u.later_than_r3.
                            criticalExtensions.u.criticalExtensions.u.r5.cellUpdateConfirm_r5,
                            rrc_CellUpdateConfirm_r5_IEs,dl_CounterSynchronisationInfo),
                            ccch_msg_ptr->message.u.cellUpdateConfirm.u.later_than_r3.rrc_TransactionIdentifier,
                            MSG_REL5))
            {
              /*continue further processing with the message */
              /* Stop Timer T302 */
              rrctmr_stop_timer(RRCTMR_T_302_TIMER);
              /* Save the CCCH commands here. All the DCCH commands will be added in Dispatcher  */
              rrc_crash_debug_save_ota(cmd_ptr->cmd.downlink_sdu_ind.dl_sdu, cmd_ptr->cmd.downlink_sdu_ind.dl_sdu_length,RRC_CCCH_DL_SDU,
                                      rrc_get_dl_ccch_message_type(cmd_ptr->cmd.downlink_sdu_ind.dl_sdu,cmd_ptr->cmd.downlink_sdu_ind.dl_sdu_length), RRC_PROCEDURE_CU);

              rrccu_process_cell_update_confirm_r5( (void *) ccch_msg_ptr,
                                                       rrc_DL_CCCH_Message_PDU);
            }  
          }
        }
        else /* rrc_CellUpdateConfirm_CCCH_later_than_r3_criticalExtensions_criticalExtensions_criticalExtensions */
        if ((rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL6) &&
                      (ccch_msg_ptr->message.u.cellUpdateConfirm.u.
                       later_than_r3.criticalExtensions.u.criticalExtensions.u.criticalExtensions.t ==
                       T_rrc_CellUpdateConfirm_CCCH_criticalExtensions_3_r6))
        {
                    /* check whether this cell update is for our UE or not */
          if(SUCCESS == rrccu_compare_received_urnti(
                      &ccch_msg_ptr->message.u.cellUpdateConfirm.u.later_than_r3.u_RNTI))
          {                  
            if(rrcllc_is_rab_release_in_progress() == TRUE)
            {
              rrc_v_302 --;
              WRRC_MSG0_HIGH("LLC is processing RAB-release, ignore CU-CNF");
              return;
            }
            if (rrccsp_ignore_cu_due_to_resel_cell_change_in_progress() == TRUE)
            {
              WRRC_MSG0_HIGH("Ignore cell update confirm as reselection is  in progress");
              rrc_v_302--;
              return;
            }
              /*continue further processing with the message */
              /* Stop Timer T302 */
            rrctmr_stop_timer(RRCTMR_T_302_TIMER);

              /* check whether SRNS relocation info is present or not
                        * if present  then the integrity check has to be done with the new
                        * integrity protection info in the message */
            if (SUCCESS == rrccu_validate_and_check_integrity_for_srns_relocoation(
                      cmd_ptr,
                      RRC_MSG_COMMON_BITMASK_IE(ccch_msg_ptr->message.u.cellUpdateConfirm.u.later_than_r3.
                      criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.r6.
                      cellUpdateConfirm_r6,
                      rrc_CellUpdateConfirm_r6_IEs,dl_CounterSynchronisationInfo),
                      ccch_msg_ptr->message.u.cellUpdateConfirm.u.later_than_r3.rrc_TransactionIdentifier,
                      MSG_REL6))
            {
              /* Save the CCCH commands here. All the DCCH commands will be added in Dispatcher  */
              rrc_crash_debug_save_ota(cmd_ptr->cmd.downlink_sdu_ind.dl_sdu, cmd_ptr->cmd.downlink_sdu_ind.dl_sdu_length,RRC_CCCH_DL_SDU,
                                       rrc_get_dl_ccch_message_type(cmd_ptr->cmd.downlink_sdu_ind.dl_sdu,cmd_ptr->cmd.downlink_sdu_ind.dl_sdu_length),RRC_PROCEDURE_CU);
              rrccu_process_cell_update_confirm_r6(
                           (void *) ccch_msg_ptr,
                           ccch_msg_ptr->message.u.cellUpdateConfirm.u.
                           later_than_r3.rrc_TransactionIdentifier,
                           &ccch_msg_ptr->message.u.cellUpdateConfirm.u.later_than_r3.
                           criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.r6.
                           cellUpdateConfirm_r6,
                           rrc_DL_CCCH_Message_PDU);
            }
          }
        }
        else
        if ((rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL7) &&
                      (ccch_msg_ptr->message.u.cellUpdateConfirm.u.
                       later_than_r3.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.t ==
                       T_rrc_CellUpdateConfirm_CCCH_criticalExtensions_2_r7))
        {
          WRRC_MSG0_HIGH("RRCHSPA+:cell update confirm rel7 rcvd");
          /* check whether this cell update is for our UE or not */
          if(SUCCESS == rrccu_compare_received_urnti(
                      &ccch_msg_ptr->message.u.cellUpdateConfirm.u.later_than_r3.u_RNTI))
          {             
            rrc_CellUpdateConfirm_r7_IEs *cu_confirm_ptr;
            if(rrcllc_is_rab_release_in_progress() == TRUE)
            {
              rrc_v_302 --;
              WRRC_MSG0_HIGH("LLC is processing RAB-release, ignore CU-CNF");
              return;
            }
            if (rrccsp_ignore_cu_due_to_resel_cell_change_in_progress() == TRUE)
            {
              WRRC_MSG0_HIGH("Ignore cell update confirm as reselection is  in progress");
              rrc_v_302--;
              return;
            }

           cu_confirm_ptr = &ccch_msg_ptr->message.u.cellUpdateConfirm.u.later_than_r3.
                criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.r7.cellUpdateConfirm_r7;
            /*continue further processing with the message */
            /* Stop Timer T302 */
            rrctmr_stop_timer(RRCTMR_T_302_TIMER);

            /* check whether SRNS relocation info is present or not
                       * if present  then the integrity check has to be done with the new
                       * integrity protection info in the message */
            if (SUCCESS == rrccu_validate_and_check_integrity_for_srns_relocoation(
                       cmd_ptr,
                      (RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,dl_CounterSynchronisationInfo)),
                      ccch_msg_ptr->message.u.cellUpdateConfirm.u.later_than_r3.rrc_TransactionIdentifier,
                      MSG_REL7))
            {
              /* Save the CCCH commands here. All the DCCH commands will be added in Dispatcher  */
              rrc_crash_debug_save_ota(cmd_ptr->cmd.downlink_sdu_ind.dl_sdu, cmd_ptr->cmd.downlink_sdu_ind.dl_sdu_length,RRC_CCCH_DL_SDU,
                                        rrc_get_dl_ccch_message_type(cmd_ptr->cmd.downlink_sdu_ind.dl_sdu,cmd_ptr->cmd.downlink_sdu_ind.dl_sdu_length),RRC_PROCEDURE_CU);

              rrccu_process_cell_update_confirm_r7(
                            (void *) ccch_msg_ptr,
                            ccch_msg_ptr->message.u.cellUpdateConfirm.u.
                            later_than_r3.rrc_TransactionIdentifier,
                            &ccch_msg_ptr->message.u.cellUpdateConfirm.u.later_than_r3.
                            criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.r7.
                            cellUpdateConfirm_r7,
                            rrc_DL_CCCH_Message_PDU);
            }
          }
        }
        else
        if ((rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL8) &&
            (RRCRB_R8_CU_CRITICAL_EXT_PRESENT_PTR(ccch_msg_ptr,rrc_CellUpdateConfirm_CCCH)))
        {
          WRRC_MSG0_HIGH("REL8: Cell Update Confirm on CCCH rcvd");
  
          /* check whether this cell update is for our UE or not */
          if(SUCCESS == rrccu_compare_received_urnti(&ccch_msg_ptr->message.u.cellUpdateConfirm.u.later_than_r3.u_RNTI))
          {             
            rrc_CellUpdateConfirm_r8_IEs *cu_confirm_ptr;
            if(rrcllc_is_rab_release_in_progress() == TRUE)
            {
              rrc_v_302 --;
              WRRC_MSG0_HIGH("LLC is processing RAB-release, ignore CU-CNF");
              return;
            }
            if (rrccsp_ignore_cu_due_to_resel_cell_change_in_progress() == TRUE)
            {
              WRRC_MSG0_HIGH("Ignore cell update confirm as reselection is  in progress");
              rrc_v_302--;
              return;
            }

           cu_confirm_ptr = &ccch_msg_ptr->message.u.cellUpdateConfirm.u.later_than_r3.
                criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.r8.cellUpdateConfirm_r8;

            /*continue further processing with the message and Stop Timer T302 */
            rrctmr_stop_timer(RRCTMR_T_302_TIMER);
  
            /* check whether SRNS relocation info is present or not if present  then the integrity check has to 
            be done with the new integrity protection info in the message */
            if (SUCCESS == rrccu_validate_and_check_integrity_for_srns_relocoation(cmd_ptr,
              (RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,dl_CounterSynchronisationInfo)),
              ccch_msg_ptr->message.u.cellUpdateConfirm.u.later_than_r3.rrc_TransactionIdentifier, MSG_REL8))
            {
              /* Save the CCCH commands here. All the DCCH commands will be added in Dispatcher  */
              rrc_crash_debug_save_ota(cmd_ptr->cmd.downlink_sdu_ind.dl_sdu, cmd_ptr->cmd.downlink_sdu_ind.dl_sdu_length,RRC_CCCH_DL_SDU,
                                       rrc_get_dl_ccch_message_type(cmd_ptr->cmd.downlink_sdu_ind.dl_sdu,cmd_ptr->cmd.downlink_sdu_ind.dl_sdu_length),RRC_PROCEDURE_CU);
              rrccu_process_cell_update_confirm_r8((void *) ccch_msg_ptr, ccch_msg_ptr->message.u.
                cellUpdateConfirm.u.later_than_r3.rrc_TransactionIdentifier, &ccch_msg_ptr->message.u.cellUpdateConfirm.
                u.later_than_r3.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.r8.
                cellUpdateConfirm_r8, rrc_DL_CCCH_Message_PDU);
            }
          }
        }
        else
#ifdef FEATURE_WCDMA_REL9
        if ((rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL9) &&
            (RRCRB_R9_CU_CRITICAL_EXT_PRESENT_PTR(ccch_msg_ptr,rrc_CellUpdateConfirm_CCCH)))
        {
          WRRC_MSG0_HIGH("REL9: Cell Update Confirm on CCCH rcvd");
        
          /* check whether this cell update is for our UE or not */
          if(SUCCESS == rrccu_compare_received_urnti(&ccch_msg_ptr->message.u.cellUpdateConfirm.u.later_than_r3.u_RNTI))
          {
            rrc_CellUpdateConfirm_r9_IEs *cu_confirm_ptr;
            if(rrcllc_is_rab_release_in_progress() == TRUE)
            {
             rrc_v_302 --;
             WRRC_MSG0_HIGH("LLC is processing RAB-release, ignore CU-CNF");
             return;
            }
            if (rrccsp_ignore_cu_due_to_resel_cell_change_in_progress() == TRUE)
            {
              WRRC_MSG0_HIGH("Ignore cell update confirm as reselection is  in progress");
              rrc_v_302--;
              return;
            }
         cu_confirm_ptr = &ccch_msg_ptr->message.u.cellUpdateConfirm.u.later_than_r3.
                criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.later_r8_criticalExtensions.u.r9.cellUpdateConfirm_r9;
            /*continue further processing with the message and Stop Timer T302 */
            rrctmr_stop_timer(RRCTMR_T_302_TIMER);
        
            /* check whether SRNS relocation info is present or not if present  then the integrity check has to 
            be done with the new integrity protection info in the message */
            if (SUCCESS == rrccu_validate_and_check_integrity_for_srns_relocoation(cmd_ptr,
              (RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,dl_CounterSynchronisationInfo)),
              ccch_msg_ptr->message.u.cellUpdateConfirm.u.later_than_r3.rrc_TransactionIdentifier, MSG_REL9))
            {
              /* Save the CCCH commands here. All the DCCH commands will be added in Dispatcher  */
              rrc_crash_debug_save_ota(cmd_ptr->cmd.downlink_sdu_ind.dl_sdu, cmd_ptr->cmd.downlink_sdu_ind.dl_sdu_length, RRC_CCCH_DL_SDU,
                                        rrc_get_dl_ccch_message_type(cmd_ptr->cmd.downlink_sdu_ind.dl_sdu,cmd_ptr->cmd.downlink_sdu_ind.dl_sdu_length),RRC_PROCEDURE_CU);
              rrccu_process_cell_update_confirm_r9((void *) ccch_msg_ptr, ccch_msg_ptr->message.u.
                cellUpdateConfirm.u.later_than_r3.rrc_TransactionIdentifier, &ccch_msg_ptr->message.u.cellUpdateConfirm.
                u.later_than_r3.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.later_r8_criticalExtensions.u.r9.cellUpdateConfirm_r9, rrc_DL_CCCH_Message_PDU);
            }
          }
        }
        else
#endif /* FEATURE_WCDMA_REL9 */

#ifdef FEATURE_WCDMA_REL10
        #error code not present
#endif /* FEATURE_WCDMA_REL10 */
        {
          rrc_print_supported_asn1_rel_version();
          rrccu_send_cu_failure_unsupported_config(
                      ccch_msg_ptr->message.u.cellUpdateConfirm.u.later_than_r3
                        .rrc_TransactionIdentifier);
        }
      }/* End of if of cell update cnf rel 5 */
      else
      {
        rrccu_send_cu_failure_unsupported_config(
                   ccch_msg_ptr->message.u.cellUpdateConfirm.u.later_than_r3
                      .rrc_TransactionIdentifier);
      }
    }
    else
    {
      WRRC_MSG0_HIGH("Peeking into OTA Msg mismatch");
    }
  }
  else /* ASN1 decoding failed */
  {
    /* ASN.1 decode failed. Ignore the message since it is received on
       ccch and let T302 expire before re-transmitting cell update message */
    WRRC_MSG0_HIGH("ASN.1 decode fail. Ignoring CCCH msg");
  } 
  return;
}

/*===========================================================================
FUNCTION rrccu_process_dl_sdu_ind_on_dcch

DESCRIPTION
  This function processes DL SDU IND command if it has come over DCCH.
  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS
  None
===========================================================================*/
void rrccu_process_dl_sdu_ind_on_dcch
(
  rrc_cmd_type * cmd_ptr
)
          {
  uint8   message_choice;       /* Local variable to store message t */
  rrc_DL_DCCH_Message                *dcch_msg_ptr = NULL; /* Pointer to  downlink DCCH message */ 
 
            message_choice = 
              rrc_get_dl_dcch_message_type(cmd_ptr->cmd.downlink_sdu_ind.dl_sdu,
                    cmd_ptr->cmd.downlink_sdu_ind.dl_sdu_length);

            if(message_choice == T_rrc_DL_DCCH_MessageType_cellUpdateConfirm )
            {
              WRRC_MSG1_HIGH("Cell Update Confirm rcvd on DCCH for CU cause = %d",
                   rrccu_cell_update_cause);
            }
            else
			{				
                WRRC_MSG1_ERROR("Ignoring %d when waiting for CU-cnf", message_choice);
                return;
            }

            if(cmd_ptr->cmd.downlink_sdu_ind.decoded_msg != NULL)
            {
               /* Get the OTA message pointer */
              dcch_msg_ptr = (rrc_DL_DCCH_Message *) cmd_ptr->cmd.downlink_sdu_ind.decoded_msg;

              if(dcch_msg_ptr->message.t ==
                 T_rrc_DL_DCCH_MessageType_cellUpdateConfirm )
              {

                if (rrccsp_ignore_cu_due_to_resel_cell_change_in_progress() == TRUE)
                {
                  WRRC_MSG0_HIGH("Ignore cell update confirm as reselection is in progress");
                  rrc_v_302--;
                  return;
                }
                if(rrcllc_is_rab_release_in_progress() == TRUE)
                {
                  rrc_v_302 --;
                  WRRC_MSG0_HIGH("LLC is processing RAB-release, ignore CU-CNF");
                  return;
                }

                if(rrc_v_302 != RRC_RACH_TX_STATS_ONE_TIME_RACH)
                {
                  /*RACH tx Success full for UE message sent in UL, 
                   *so update RACH tx parameters count here*/
                  RRC_DEBUG_INCREMENT_STATS(RACH_SUCCFUL_RRC_RETRY);
                }
              }
              if (dcch_msg_ptr->message.u.cellUpdateConfirm.t == 
                  T_rrc_CellUpdateConfirm_r3)
              {
                /*check whether SRNS relocation info is present or not
                if present  then the integrity check has to be done with the new
                integrity protection info in the message */
                if (SUCCESS == rrccu_validate_and_check_integrity_for_srns_relocoation(
                        cmd_ptr,
                        (RRC_MSG_COMMON_BITMASK_IE(dcch_msg_ptr->message.u.cellUpdateConfirm.u.r3.cellUpdateConfirm_r3,
                    rrc_CellUpdateConfirm_r3_IEs,dl_CounterSynchronisationInfo)),
                        dcch_msg_ptr->message.u.cellUpdateConfirm.u.r3.cellUpdateConfirm_r3.rrc_TransactionIdentifier,
                        MSG_REL99))
                {
                  /*continue further processing with the message */
                  /* Stop Timer T302 */
                  rrctmr_stop_timer(RRCTMR_T_302_TIMER); 
                  rrccu_process_cell_update_confirm( (void *) dcch_msg_ptr,
                                                 rrc_DL_DCCH_Message_PDU);
                }
              }
              else if ((rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) &&
                       (dcch_msg_ptr->message.u.cellUpdateConfirm.t == 
                        T_rrc_CellUpdateConfirm_later_than_r3) &&
                       (dcch_msg_ptr->message.u.cellUpdateConfirm.u.
                        later_than_r3.criticalExtensions.t == 
                        T_rrc_CellUpdateConfirm_criticalExtensions_5_criticalExtensions))
              {
                if (dcch_msg_ptr->message.u.cellUpdateConfirm.u.
                        later_than_r3.criticalExtensions.u.criticalExtensions.t ==
                        T_rrc_CellUpdateConfirm_criticalExtensions_4_r5)
                {

                  /*check whether SRNS relocation info is present or not
                    if present  then the integrity check has to be done with the new
                    integrity protection info in the message */
                  if (SUCCESS == rrccu_validate_and_check_integrity_for_srns_relocoation(
                    cmd_ptr,
                    RRC_MSG_COMMON_BITMASK_IE(dcch_msg_ptr->message.u.cellUpdateConfirm.u.
                    later_than_r3.criticalExtensions.u.criticalExtensions.u.r5.
                    cellUpdateConfirm_r5, 
                    rrc_CellUpdateConfirm_r5_IEs,dl_CounterSynchronisationInfo),
                    dcch_msg_ptr->message.u.cellUpdateConfirm.u.later_than_r3.rrc_TransactionIdentifier,
                    MSG_REL5))
                  {
                    /*continue further processing with the message */
                    /* Stop Timer T302 */
                    rrctmr_stop_timer(RRCTMR_T_302_TIMER); 
                    
                    rrccu_process_cell_update_confirm_r5( (void *) dcch_msg_ptr,
                                                          rrc_DL_DCCH_Message_PDU);
                  }  

                }
                else /* rrc_CellUpdateConfirm_CCCH_later_than_r3_criticalExtensions_criticalExtensions_criticalExtensions */
                if ((rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL6) &&
                    (dcch_msg_ptr->message.u.cellUpdateConfirm.u.
                     later_than_r3.criticalExtensions.u.criticalExtensions.u.criticalExtensions.t ==
                     T_rrc_CellUpdateConfirm_criticalExtensions_3_r6))
                {

                  /* check whether SRNS relocation info is present or not
                   * if present  then the integrity check has to be done with the new
                   * integrity protection info in the message */
                  if (SUCCESS == rrccu_validate_and_check_integrity_for_srns_relocoation(
                    cmd_ptr,
                    RRC_MSG_COMMON_BITMASK_IE(dcch_msg_ptr->message.u.cellUpdateConfirm.u.later_than_r3.
                    criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.r6.
                    cellUpdateConfirm_r6,
                    rrc_CellUpdateConfirm_r6_IEs,dl_CounterSynchronisationInfo),
                    dcch_msg_ptr->message.u.cellUpdateConfirm.u.later_than_r3.rrc_TransactionIdentifier,
                    MSG_REL6))
                  {
                    /*continue further processing with the message */
                    /* Stop Timer T302 */
                    rrctmr_stop_timer(RRCTMR_T_302_TIMER); 
                    
                    rrccu_process_cell_update_confirm_r6(
                      (void *) dcch_msg_ptr,
                      dcch_msg_ptr->message.u.cellUpdateConfirm.u.
                      later_than_r3.rrc_TransactionIdentifier,
                      &dcch_msg_ptr->message.u.cellUpdateConfirm.u.later_than_r3.
                      criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.r6.
                      cellUpdateConfirm_r6,
                      rrc_DL_DCCH_Message_PDU);
                  }  
                }
                else
                if ((rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL7) &&
                    (dcch_msg_ptr->message.u.cellUpdateConfirm.u.
                     later_than_r3.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.t ==
                     T_rrc_CellUpdateConfirm_criticalExtensions_2_r7))
                {
                  rrc_CellUpdateConfirm_r7_IEs *cu_confirm_ptr = &dcch_msg_ptr->message.u.cellUpdateConfirm.u.later_than_r3.
                    criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.r7.cellUpdateConfirm_r7;

                  /* check whether SRNS relocation info is present or not
                               * if present  then the integrity check has to be done with the new
                               * integrity protection info in the message */
                  if (SUCCESS == rrccu_validate_and_check_integrity_for_srns_relocoation(
                      cmd_ptr,
                      (RRCRBR_R7_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r7_IEs,dl_CounterSynchronisationInfo)),
                      dcch_msg_ptr->message.u.cellUpdateConfirm.u.later_than_r3.rrc_TransactionIdentifier,
                      MSG_REL7) )
                  {
                    /*continue further processing with the message */
                    /* Stop Timer T302 */
                    rrctmr_stop_timer(RRCTMR_T_302_TIMER); 
                    
                    rrccu_process_cell_update_confirm_r7(
                      (void *) dcch_msg_ptr,
                      dcch_msg_ptr->message.u.cellUpdateConfirm.u.
                      later_than_r3.rrc_TransactionIdentifier,
                      &dcch_msg_ptr->message.u.cellUpdateConfirm.u.later_than_r3.
                      criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.r7.
                      cellUpdateConfirm_r7,
                      rrc_DL_DCCH_Message_PDU);
                  }  
                }
                else
                if((rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL8) &&
                  (RRCRB_R8_CU_CRITICAL_EXT_PRESENT_PTR(dcch_msg_ptr,rrc_CellUpdateConfirm)))
                {
                  rrc_CellUpdateConfirm_r8_IEs *cu_confirm_ptr = &dcch_msg_ptr->message.u.cellUpdateConfirm.u.later_than_r3.
                    criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.r8.cellUpdateConfirm_r8;
          
                  /* check whether SRNS relocation info is present or not if present  then the integrity check has to be done 
                                with the new integrity protection info in the message */
                  if(SUCCESS == rrccu_validate_and_check_integrity_for_srns_relocoation(cmd_ptr,
                      (RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,dl_CounterSynchronisationInfo)),
                      dcch_msg_ptr->message.u.cellUpdateConfirm.u.later_than_r3.rrc_TransactionIdentifier,
                      MSG_REL8) )
                  {
                    /*continue further processing with the message and Stop Timer T302 */
                    rrctmr_stop_timer(RRCTMR_T_302_TIMER); 
              
                    rrccu_process_cell_update_confirm_r8((void *)dcch_msg_ptr,
                      dcch_msg_ptr->message.u.cellUpdateConfirm.u.later_than_r3.rrc_TransactionIdentifier,
                      &dcch_msg_ptr->message.u.cellUpdateConfirm.u.later_than_r3.
                      criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.r8.
                      cellUpdateConfirm_r8, rrc_DL_DCCH_Message_PDU);
                  }  
                }
                else
                  
#ifdef FEATURE_WCDMA_REL9
                if((rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL9) &&
                  (RRCRB_R9_CU_CRITICAL_EXT_PRESENT_PTR(dcch_msg_ptr,rrc_CellUpdateConfirm)))
                {
                  rrc_CellUpdateConfirm_r9_IEs *cu_confirm_ptr = &dcch_msg_ptr->message.u.cellUpdateConfirm.u.later_than_r3.
                    criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.later_r8_criticalExtensions.u.r9.cellUpdateConfirm_r9;


                  /* check whether SRNS relocation info is present or not if present  then the integrity check has to be done 
                                with the new integrity protection info in the message */
                  if(SUCCESS == rrccu_validate_and_check_integrity_for_srns_relocoation(cmd_ptr,
                      (RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,dl_CounterSynchronisationInfo)),
                      dcch_msg_ptr->message.u.cellUpdateConfirm.u.later_than_r3.rrc_TransactionIdentifier,
                      MSG_REL9) )
                  {
                    /*continue further processing with the message and Stop Timer T302 */
                    rrctmr_stop_timer(RRCTMR_T_302_TIMER); 

                    rrccu_process_cell_update_confirm_r9((void *)dcch_msg_ptr,
                      dcch_msg_ptr->message.u.cellUpdateConfirm.u.later_than_r3.rrc_TransactionIdentifier,
                      &dcch_msg_ptr->message.u.cellUpdateConfirm.u.later_than_r3.
                      criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.
                      later_r8_criticalExtensions.u.r9.cellUpdateConfirm_r9, rrc_DL_DCCH_Message_PDU);
                  }  
                }
                else
                  

#endif /* FEATURE_WCDMA_REL9 */
#ifdef FEATURE_WCDMA_REL10
                 #error code not present
#endif /* FEATURE_WCDMA_REL10 */



                {
                  rrc_print_supported_asn1_rel_version();
                  rrccu_send_cu_failure_unsupported_config(
                    dcch_msg_ptr->message.u.cellUpdateConfirm.u.later_than_r3
                      .rrc_TransactionIdentifier);
                }
              }/* End of if of cell update cnf rel 5 */
              else
              {
                rrccu_send_cu_failure_unsupported_config(
                  dcch_msg_ptr->message.u.cellUpdateConfirm.u.later_than_r3
                    .rrc_TransactionIdentifier);
              }
            } 
            else /* ASN1 decoding failed */
            {
              /* Update the failure cause */
              rrccu_failure_cause.rrc_TransactionIdentifier = 0;
              rrccu_failure_cause.failureCause.t =  T_rrc_FailureCauseWithProtErr_protocolError;
              rrccu_failure_cause.failureCause.u.protocolError = 
                rtxMemAllocTypeZ (&enc_ctxt, rrc_ProtocolErrorInformation);

              rrccu_failure_cause.failureCause.u.protocolError->diagnosticsType.t = 
                T_rrc_ProtocolErrorInformation_diagnosticsType_type1;
              
              rrccu_failure_cause.failureCause.u.protocolError->diagnosticsType.u.type1 = 
                rtxMemAllocTypeZ (&enc_ctxt, rrc_ProtocolErrorInformation_type1);
              
              rrccu_failure_cause.failureCause.u.protocolError->
                diagnosticsType.u.type1->protocolErrorCause = 
                rrc_ProtocolErrorCause_asn1_ViolationOrEncodingError;

              /* Resend the CELL UPDATE with Failure cause */
              rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
            } 
  return;
          }
/*===========================================================================

FUNCTION RRCCU_PROCESS_CU_WAIT_FOR_URA_UPDATE_CONFIRM

DESCRIPTION
  This function processes all events that are dispatched to URA Update 
  procedure in RRCCU_WAIT_FOR_URA_UPDATE_CONFIRM substate.

  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
static void rrccu_process_cu_wait_for_ura_update_confirm
(    
  rrc_cmd_type *cmd_ptr
)
{
  uint8                              message_choice;       /* Local variable to store message t */
  rrc_DL_CCCH_Message                *ccch_msg_ptr = NULL; /* Pointer to  downlink CCCH message */ 
  rrc_DL_DCCH_Message                *dcch_msg_ptr = NULL; /* Pointer to  downlink DCCH message */ 
  rrc_int_u_rnti_type                 u_rnti;              /* Local varibale to store U-RNTI */
  rrc_int_u_rnti_type                 u_rnti_local;        /* Local varibale to store U-RNTI */ 
  rrcsmc_srns_ip_check_status_e_type  ip_check_status;
  uint32 t_305_timer_in_ms = 0;

  switch(rrc_get_state())
  {
    case RRC_STATE_CELL_FACH:
      switch(cmd_ptr->cmd_hdr.cmd_id)
      {

        case RRC_CMAC_STATUS_IND:
          rrctmr_start_timer(RRCTMR_T_302_TIMER, rrccu_convert_t302_to_ms(RRC_GET_T302()));   
	  break;

        case RRC_T302_EXPIRED_IND:
          WRRC_MSG1_HIGH("Timer T302 Expired in state: %d",rrc_get_state());  
          if (rrctmr_get_remaining_time(RRCTMR_T_302_TIMER) == 0) 
          {
            rrc_cu_uu_log_event_failure_cause = RRC_CU_UU_T302_EXPIRED;
            rrccu_resend_ura_update_msg(RRCCU_NOT_INCLUDE_FAILURE_CAUSE);
          }
          else
          {
            /* Else, T302 must have been started again between the time T302 expiry was
            posted onto internal queue and the time CU procedure got the indication.  So
            just ignore here */
            WRRC_MSG0_HIGH("Ignoring T302 expiry");
          }
          break;

        case RRC_NEW_CELL_IND:
          WRRC_MSG2_HIGH("Cell reselection in state:%d, cu_state:%d",
                   rrc_get_state(),rrccu_substate);

          if (rrccu_check_for_ura_reselection())
          {
            WRRC_MSG0_HIGH("URA reselection occured");
            /* Update URA Update cause */
            rrccu_ura_update_cause = rrc_URA_UpdateCause_changeOfURA;
          }
          rrccu_resend_ura_update_msg(RRCCU_NOT_INCLUDE_FAILURE_CAUSE);
          break;

        case RRC_DOWNLINK_SDU_IND:
          /* Assert the receieved message is of type rrc_DL_CCCH_Message */
          if(cmd_ptr->cmd.downlink_sdu_ind.dl_sdu_type == rrc_DL_CCCH_Message_PDU)
          {
            message_choice = 
              rrc_get_dl_ccch_message_type(cmd_ptr->cmd.downlink_sdu_ind.dl_sdu,
                    cmd_ptr->cmd.downlink_sdu_ind.dl_sdu_length);

            if(message_choice == T_rrc_DL_CCCH_MessageType_uraUpdateConfirm )
            {
              WRRC_MSG0_HIGH("URA Update Confirm rcvd on CCCH");
            }
            if(cmd_ptr->cmd.downlink_sdu_ind.decoded_msg != NULL)
            {
               /* Get the OTA message pointer */
              ccch_msg_ptr = (rrc_DL_CCCH_Message *) 
                cmd_ptr->cmd.downlink_sdu_ind.decoded_msg;

              if(ccch_msg_ptr->message.t ==
                 T_rrc_DL_CCCH_MessageType_uraUpdateConfirm )
              {
                if(rrc_v_302 != RRC_RACH_TX_STATS_ONE_TIME_RACH)
                {
                  /*RACH tx Success full for UE message sent in UL, 
                   *so update RACH tx parameters count here*/
                  RRC_DEBUG_INCREMENT_STATS(RACH_SUCCFUL_RRC_RETRY);
                }
   
                /* Translate the U-RNTI */
                rrc_translate_urnti(&ccch_msg_ptr->message.u.
                                     uraUpdateConfirm.u.r3.uraUpdateConfirm_CCCH_r3.u_RNTI,
                                     &u_rnti);
                rrcllc_get_current_urnti(&u_rnti_local);
                if(u_rnti_local == u_rnti)
                {
                  /* Stop Timer T302 */
                  rrctmr_stop_timer(RRCTMR_T_302_TIMER); 
              /* Save the CCCH commands here. All the DCCH commands will be added in Dispatcher  */
                  rrc_crash_debug_save_ota(cmd_ptr->cmd.downlink_sdu_ind.dl_sdu, cmd_ptr->cmd.downlink_sdu_ind.dl_sdu_length,RRC_CCCH_DL_SDU,
                                            rrc_get_dl_ccch_message_type(cmd_ptr->cmd.downlink_sdu_ind.dl_sdu,cmd_ptr->cmd.downlink_sdu_ind.dl_sdu_length),RRC_PROCEDURE_CU);
                  rrccu_process_ura_update_confirm( (void *) ccch_msg_ptr,
                                               rrc_DL_CCCH_Message_PDU);
                }
                else
                {
                  WRRC_MSG0_HIGH("U-RNTI Mismatch. Ignore");
                }
              }
              else
              {
                WRRC_MSG0_HIGH("Peeking into OTA Msg mismatch");
              }
            }
            else /* ASN1 decoding failed */
            {
              /* ASN.1 decode failed. Ignore the message since it is received on
              ccch and let T302 expire before re-transmitting ura update message */
              WRRC_MSG0_HIGH("ASN.1 decode fail. Ignoring CCCH msg");
            } 
          }
          else if(cmd_ptr->cmd.downlink_sdu_ind.dl_sdu_type == rrc_DL_DCCH_Message_PDU)
          {
            message_choice = 
              rrc_get_dl_dcch_message_type(cmd_ptr->cmd.downlink_sdu_ind.dl_sdu,
                    cmd_ptr->cmd.downlink_sdu_ind.dl_sdu_length);

            if(message_choice == 
               T_rrc_DL_DCCH_MessageType_uraUpdateConfirm )
            {
              WRRC_MSG0_HIGH("URA Update Confirm rcvd on DCCH");
            }
            if(cmd_ptr->cmd.downlink_sdu_ind.decoded_msg != NULL)
            {
               /* Get the OTA message pointer */
              dcch_msg_ptr = (rrc_DL_DCCH_Message *) cmd_ptr->cmd.downlink_sdu_ind.
                decoded_msg;
              if(dcch_msg_ptr->message.t ==
                 T_rrc_DL_DCCH_MessageType_uraUpdateConfirm )
              {
                boolean dl_sync_info_present = FALSE;
                rrc_msg_ver_enum_type rcvd_msg_version = MSG_REL99;
                if(rrc_v_302 != RRC_RACH_TX_STATS_ONE_TIME_RACH)
                {
                  /*RACH tx Success full for UE message sent in UL, 
                   *so update RACH tx parameters count here*/
                  RRC_DEBUG_INCREMENT_STATS(RACH_SUCCFUL_RRC_RETRY);
                }
   
                /*check whether SRNS relocation info is present or not
                if present  then the integrity check has to be done with the new
                integrity protection info in the message */

                if(dcch_msg_ptr->message.u.uraUpdateConfirm.t !=
                   T_rrc_URAUpdateConfirm_later_than_r3)
                {
                  if(RRC_MSG_COMMON_BITMASK_IE(dcch_msg_ptr->message.u.uraUpdateConfirm.u.r3.uraUpdateConfirm_r3,
                     rrc_URAUpdateConfirm_r3_IEs,dl_CounterSynchronisationInfo))
                  {
                    dl_sync_info_present = TRUE;
                  }
                }
                else
                {
                  if(dcch_msg_ptr->message.u.uraUpdateConfirm.u.later_than_r3.
                      criticalExtensions.t == T_rrc_URAUpdateConfirm_criticalExtensions_2_r5)
                  {
                    rcvd_msg_version = MSG_REL5;
                    if(RRC_MSG_COMMON_BITMASK_IE(dcch_msg_ptr->message.u.uraUpdateConfirm.u.later_than_r3.
                      criticalExtensions.u.r5.uraUpdateConfirm_r5,
                     rrc_URAUpdateConfirm_r5_IEs,dl_CounterSynchronisationInfo))
                    { 
                      dl_sync_info_present = TRUE;
                    }
                  }
                  else if(dcch_msg_ptr->message.u.uraUpdateConfirm.u.later_than_r3.
                      criticalExtensions.u.criticalExtensions.t == 
                      T_rrc_URAUpdateConfirm_criticalExtensions_1_r7)
                  {
                    rcvd_msg_version = MSG_REL7;
                    if(RRC_MSG_COMMON_BITMASK_IE(dcch_msg_ptr->message.u.uraUpdateConfirm.u.later_than_r3.
                      criticalExtensions.u.criticalExtensions.u.r7.uraUpdateConfirm_r7,
                     rrc_URAUpdateConfirm_r7_IEs,dl_CounterSynchronisationInfo))
                    { 
                      dl_sync_info_present = TRUE;
                    }
                  }
                  else
                  {
                    /* Update the failure cause */
                    rrccu_uu_failure_cause.t =  T_rrc_ProtocolErrorIndicatorWithMoreInfo_errorOccurred;
                   
                      rrccu_uu_failure_cause.u.errorOccurred = 
                    rtxMemAllocTypeZ (&enc_ctxt, rrc_ProtocolErrorIndicatorWithMoreInfo_errorOccurred);
             
                    rrccu_uu_failure_cause.u.errorOccurred->rrc_TransactionIdentifier = 
                    dcch_msg_ptr->message.u.uraUpdateConfirm.u.later_than_r3.rrc_TransactionIdentifier;
                    rrccu_uu_failure_cause.u.errorOccurred->protocolErrorInformation.
                    diagnosticsType.t = T_rrc_ProtocolErrorInformation_diagnosticsType_type1;
             
                    rrccu_uu_failure_cause.u.errorOccurred->protocolErrorInformation.diagnosticsType.u.type1 = 
                      rtxMemAllocTypeZ (&enc_ctxt, rrc_ProtocolErrorInformation_type1);
             
                    rrccu_uu_failure_cause.u.errorOccurred->protocolErrorInformation.
                    diagnosticsType.u.type1->protocolErrorCause = 
                                            rrc_ProtocolErrorCause_messageExtensionNotComprehended;

                    /* Resend the URA UPDATE with Failure cause */
                    rrccu_resend_ura_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
                    return;
                  }
                }

                if (dl_sync_info_present == TRUE)
                {
                  /*SRNS Relocation is involved with this message 
                   * Call the SMC api to do integrity check with new integrity info */
                  rrccu_cucnf_for_srns_relocation  = TRUE;
                  ip_check_status = rrcsmc_check_integrity_for_srns_relocation(cmd_ptr, rcvd_msg_version);

                  switch (ip_check_status)
                  {
                    case RRCSMC_SRNS_INTEGRITY_CHECK_SUCCESS:
                      /* Stop Timer T302 */
                      rrctmr_stop_timer(RRCTMR_T_302_TIMER); 

                      rrccu_process_ura_update_confirm( (void *) dcch_msg_ptr,
                                                   rrc_DL_DCCH_Message_PDU);
                      break;

                    case RRCSMC_SRNS_INTEGRITY_CHECK_FAILURE:
                      /*Discard the message and continue with ongoing procedure as if this
                      message was not received */
                      WRRC_MSG0_ERROR("IP check failed. Discarding CUCNF msg");
                      break;

                    case RRCSMC_SRNS_SECURITY_INFO_INVALID:
                    case RRCSMC_INCOMPATIBLE_SECURITY_RECONFIGURATION:
                      /* Update the failure cause */
                      rrccu_uu_failure_cause.t =  T_rrc_ProtocolErrorIndicatorWithMoreInfo_errorOccurred;
					     rrccu_uu_failure_cause.u.errorOccurred = 
				       rtxMemAllocTypeZ (&enc_ctxt, rrc_ProtocolErrorIndicatorWithMoreInfo_errorOccurred);

                      rrccu_uu_failure_cause.u.errorOccurred->rrc_TransactionIdentifier = 0;
                      rrccu_uu_failure_cause.u.errorOccurred->protocolErrorInformation.
                        diagnosticsType.t = T_rrc_ProtocolErrorInformation_diagnosticsType_type1;

					   rrccu_uu_failure_cause.u.errorOccurred->protocolErrorInformation.diagnosticsType.u.type1 = 
				        rtxMemAllocTypeZ (&enc_ctxt, rrc_ProtocolErrorInformation_type1);

                      /* populate the appropriate failure cause */
                      if (ip_check_status == RRCSMC_SRNS_SECURITY_INFO_INVALID)
                      {
                        rrccu_uu_failure_cause.u.errorOccurred->protocolErrorInformation.
                          diagnosticsType.u.type1->protocolErrorCause = 
                          rrc_ProtocolErrorCause_asn1_ViolationOrEncodingError;
                      }
                      else
                      {
                        rrccu_uu_failure_cause.u.errorOccurred->protocolErrorInformation.
                          diagnosticsType.u.type1->protocolErrorCause = 
                          rrc_ProtocolErrorCause_asn1_ViolationOrEncodingError;
                      }
                      /* Resend the CELL UPDATE with Failure cause */
                      rrccu_resend_ura_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
                      break;

                    default:
                      /*should not come here */
                      break;
                  }
                }
                else /*regular message, does not  involve SRNS relocation */
                {
                  /* Stop Timer T302 */
                  rrctmr_stop_timer(RRCTMR_T_302_TIMER); 

                  rrccu_process_ura_update_confirm( (void *) dcch_msg_ptr,
                                                 rrc_DL_DCCH_Message_PDU);
                }
              }
              else
              {
                WRRC_MSG0_HIGH("Peeking into OTA Msg mismatch");
              }
            } 
            else /* ASN1 decoding failed */
            {
              /* Update the failure cause */
              rrccu_uu_failure_cause.t =  T_rrc_ProtocolErrorIndicatorWithMoreInfo_errorOccurred;
			  
			  rrccu_uu_failure_cause.u.errorOccurred = 
	  			rtxMemAllocTypeZ (&enc_ctxt, rrc_ProtocolErrorIndicatorWithMoreInfo_errorOccurred);
	  
              rrccu_uu_failure_cause.u.errorOccurred->rrc_TransactionIdentifier = 0;
              rrccu_uu_failure_cause.u.errorOccurred->protocolErrorInformation.
                diagnosticsType.t = T_rrc_ProtocolErrorInformation_diagnosticsType_type1;
	  
	  			rrccu_uu_failure_cause.u.errorOccurred->protocolErrorInformation.diagnosticsType.u.type1 = 
	  			 rtxMemAllocTypeZ (&enc_ctxt, rrc_ProtocolErrorInformation_type1);
	  
              rrccu_uu_failure_cause.u.errorOccurred->protocolErrorInformation.
                diagnosticsType.u.type1->protocolErrorCause = 
                rrc_ProtocolErrorCause_asn1_ViolationOrEncodingError;
              /* Resend the CELL UPDATE with Failure cause */
              rrccu_resend_ura_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
            } 
          }
          else
          /* Received other than rrc_DL_CCCH_Message type  and rrc_DL_DCCH_Message*/
          {
            WRRC_MSG1_HIGH("Rcvd an invalid message type:%d",
                      cmd_ptr->cmd.downlink_sdu_ind.dl_sdu_type);
          }
          break; 

        case RRC_CPHY_OUT_OF_SERVICE_AREA_IND:
          WRRC_MSG2_HIGH("OOS Ind Rcvd in st:%d cu_st:%d",
                    rrc_get_state(),rrccu_substate);
          event_report(EVENT_WCDMA_OUT_OF_SERVICE);
          /* Delete C-RNTI */
         // rrccu_delete_crnti();


          if (RRCCU_SUCCESS != rrccu_validate_rrc_status_for_oos_handling())
          {
              rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                                   RRC_TX_TO_DISCON_OTHER);
              /* Update the release cause */
              rrc_release_cause = RRC_REL_DEEP_FADE;
              rrccu_substate    = RRCCU_WAIT_FOR_RB_REL_CNF;
            }
            else
            {
            /* store the current rrc state when failure was indicated */
            /* Stop Timer T302 */
            rrctmr_stop_timer(RRCTMR_T_302_TIMER); 
            /* Start the OOS Timer */
            t_305_timer_in_ms = rrc_convert_t305_to_ms(RRC_GET_T305());
            if ( t_305_timer_in_ms <= RRCTMR_T_OOS_TIMER_IN_MS) 
            {
              rrccu_start_t_305_timer();
            }
            else
            {
              rrctmr_start_timer(RRCTMR_T_OOS_TIMER, RRCTMR_T_OOS_TIMER_IN_MS);
            }

            /*  ura_update cause must be set to false and cell_update_cause to true */
            rrccu_ura_update_started = FALSE;
            rrccu_cell_update_started = TRUE;
            /*Initiate Cell Selection */
            rrccu_send_rrc_initiate_cell_selection_ind(
                                          RRC_OUT_OF_SERVICE_AREA_IND,
                                          RRC_STATE_CELL_FACH);     
          }


          /* Update Cell Update cause */
          rrccu_cell_update_cause = rrc_CellUpdateCause_re_enteredServiceArea;

          rrccu_substate = RRCCU_WAIT_FOR_UE_TO_CAMP_ON;
          break;

        case RRC_CELL_UPDATE_INITIATE_REQ:
          if(RRCCU_SUCCESS == rrccu_validate_cell_update_initiate_req(cmd_ptr)) 
          {
            if( IS_CU_TRIGGERED_WITH_RE_ENTER_SERVICE_AREA_VALID )
            {
              rrccu_process_oos_area_handling();   
            }
          }
          break;
          
        default:
          WRRC_MSG2_ERROR("Unknown command: 0x%x, CU st %d", cmd_ptr->cmd_hdr.cmd_id,rrccu_substate);
          break;
      }
      break;

    case RRC_STATE_CELL_PCH:
    case RRC_STATE_URA_PCH: 
      switch(cmd_ptr->cmd_hdr.cmd_id)
      {
        case RRC_STATE_CHANGE_IND:
          WRRC_MSG1_ERROR("Unexpected state change ind in CU st %d", rrccu_substate);
          rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                               RRC_TX_TO_DISCON_OTHER);
          /* Update the release cause */
          rrc_release_cause = RRC_REL_DEEP_FADE;
          rrccu_substate    = RRCCU_WAIT_FOR_RB_REL_CNF;

          break;

        default:
          WRRC_MSG2_ERROR("Unknown command: 0x%x, CU st %d", cmd_ptr->cmd_hdr.cmd_id,rrccu_substate);            
          break;
      } 
      break;

    default:
      WRRC_MSG2_HIGH("Invalid Event: %d in the substate: %d", 
                cmd_ptr->cmd_hdr.cmd_id, rrccu_substate);
      break;
  }

} /* rrccu_process_cu_wait_for_ura_update_confirm */



/*===========================================================================
FUNCTION RRCCU_PROCESS_CU_WAIT_FOR_PCCH_RB_EST_CNF

DESCRIPTION
  This function processes all events that are dispatched to Cell Update 
  procedure in RRCCU_WAIT_FOR_PCCH_RB_EST_CNF substate.

  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
static void rrccu_process_cu_wait_for_pcch_rb_est_cnf
(    
  rrc_cmd_type *cmd_ptr
)
{
  uint32 t_305_timer_in_ms = 0;

  switch(rrc_get_state())
  {
    case RRC_STATE_CELL_FACH:
      switch(cmd_ptr->cmd_hdr.cmd_id)
      { 
        case RRC_NEW_CELL_IND:
          WRRC_MSG1_HIGH("Cell reselection in state:%d",rrc_get_state());
          /* set the flag for another cell update so that cellupdate
          can be initiated once pcch is established and this procedure is
          complete */
          if (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH)
          {
            /* read sib2 and set ura_update_reqd flag accordingly */
            rrccu_ura_update_required = rrccu_check_for_ura_reselection();
          }
          else
          {
            rrccu_cu_initiate_reqd.cu_reqd  = TRUE;
            rrccu_cu_initiate_reqd.cu_cause = rrc_CellUpdateCause_cellReselection;
            /* continue in the same substate */
          }
          break;

        case RRC_DOWNLINK_SDU_IND:
          /* Cell Update Confirm Msg may be received in this
              Substate because of cell-reselections. */
          WRRC_MSG0_HIGH("Simultanous transactions not supported");
          break;

        case RRC_CPHY_OUT_OF_SERVICE_AREA_IND:
          WRRC_MSG2_HIGH("OOS Ind Rcvd in st:%d cu_st:%d",
                    rrc_get_state(),rrccu_substate);
          event_report(EVENT_WCDMA_OUT_OF_SERVICE);


          /*clear the ordered config if it is set from rrccu procedure */
          if (rrccu_oc_set_by_cu == TRUE)
          {
            rrcllc_clear_ordered_config();
          }
          if (rrccu_ura_update_started == TRUE)
          {
            rrccu_ura_update_started = FALSE;
            rrccu_cell_update_started = TRUE;
            /* Update Cell Update cause */
          }
          /* Initiate Cell Selection */
          rrccu_send_rrc_initiate_cell_selection_ind(
                                          RRC_OUT_OF_SERVICE_AREA_IND,
                                          RRC_STATE_CELL_FACH);
          /* Start the OOS timer */

          t_305_timer_in_ms = rrc_convert_t305_to_ms(RRC_GET_T305());
          if ( t_305_timer_in_ms <= RRCTMR_T_OOS_TIMER_IN_MS) 
          {
            rrccu_start_t_305_timer();          
          }
          else
          {
            rrctmr_start_timer(RRCTMR_T_OOS_TIMER, RRCTMR_T_OOS_TIMER_IN_MS);
          }

          rrccu_cell_update_cause = rrc_CellUpdateCause_re_enteredServiceArea;
          rrccu_substate = RRCCU_WAIT_FOR_UE_TO_CAMP_ON;
          break;

        case RRC_CHANNEL_CONFIG_CNF:
          rrcllcpcie_initialise_sync_a_post_veri_info();

          if(cmd_ptr->cmd.chan_config_cnf.chan_cfg_status == RRCLLC_CHAN_CFG_SUCCESS)
          {
            /*clear the ordered config if it is set from rrccu procedure */
            if (rrccu_oc_set_by_cu == TRUE)
            {
              rrcllc_clear_ordered_config();
              /* Copy the Ordered RB Mapping into the current RB-Mapping database*/
              rrcllc_copy_ordered_hanging_rb_mapping_to_current();
            }
            /*send DRX command to L1 via rrcllc */
            rrccu_send_l1_drx_req();
            /* Reset the state machine and the procedure ends */
            rrccu_substate = RRCCU_INITIAL;
            rrccu_start_t_305_timer();
            if (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH)
            {
              /* check whether URA update is required */
              if ( rrccu_is_ura_update_reqd() == TRUE)
              {
                rrccu_send_ura_update_initiate_req( RRC_URA_RESELECTION,
                                                    FALSE);
              }
            }
            else if (rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH)
            {
              /* check whether any cell update initiate req needs to be 
              posted to itself due to reselections in certain substates*/
              if (rrccu_cu_initiate_reqd.cu_reqd)
              {
                /* delete CRNTI */
                rrccu_delete_crnti();
                rrccu_cu_initiate_reqd.cu_reqd = FALSE;
                rrccu_send_cell_update_initiate_req (RRC_CELL_RESELECTION);
              }
            }
            /*send  ul data registration request to rlc */
            rrccu_register_with_rlc_for_ul_data_indication();
           /* Inform all registered RRC procedures that Cell
             Update is completed */
            rrccu_inform_cell_update_completed();

   
            rrccu_process_successful_completion();
           
            /*call the procedure to clear the global variabls */
            rrccu_clear_procedure();
          }
          else
          {
            /* TBD */
#ifndef FEATURE_WCDMA_HS_FACH
            /* Channel config failure, so initialise the ordered RB-Mapping database*/
            rrcllc_init_ordered_hanging_rb_mapping_info();
#else
            rrcllc_copy_current_hanging_rb_mapping_to_ordered();
#endif


           /* Channel config failed Enter idle */
            rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                                 RRC_TX_TO_DISCON_OTHER);
            rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
            WRRC_MSG1_HIGH("Chan_config failed cu_subst:%d", 
                     rrccu_substate);
            }
          break;  

        case RRC_CELL_UPDATE_INITIATE_REQ:
          if(RRCCU_SUCCESS == rrccu_validate_cell_update_initiate_req(cmd_ptr)) 
          {
            if( (cmd_ptr->cmd.initiate_cell_update.cause == RRC_REENTERED_SERVICE_AREA) &&
                ((cmd_ptr->cmd.initiate_cell_update.procedure == RRC_PROCEDURE_CSP)||
                 (cmd_ptr->cmd.initiate_cell_update.procedure == RRC_PROCEDURE_SIB)) 
              )
            {
              rrccu_process_oos_area_handling();   
            }
          }
          break;

        default:
          WRRC_MSG2_ERROR("Unknown command: 0x%x, CU st %d", cmd_ptr->cmd_hdr.cmd_id,rrccu_substate);
          break;
      }
      break;
    /* In case of freq -re-direction for FACH->PCH in CU Cnf, after cell selection 
      * Cu will reconfigure PCCH in PCH state with OTA contents, so
      * that TOC is cleared. So handle RRC_CHANNEL_CONFIG_CNF in this substate
      * for PCH/URA PCh state 
      */
    case RRC_STATE_URA_PCH:
    case RRC_STATE_CELL_PCH:
      if(cmd_ptr->cmd_hdr.cmd_id == RRC_CHANNEL_CONFIG_CNF )
      {
        rrcllcpcie_initialise_sync_a_post_veri_info();
     
        if(cmd_ptr->cmd.chan_config_cnf.chan_cfg_status == RRCLLC_CHAN_CFG_SUCCESS)
        {
          /*clear the ordered config if it is set from rrccu procedure */
          
          if (rrccu_oc_set_by_cu == TRUE)
          {
            rrcllc_clear_ordered_config();
          }
          /* Copy the Ordered RB Mapping into the current RB-Mapping database*/
          rrcllc_copy_ordered_hanging_rb_mapping_to_current();
     
          /*send DRX command to L1 via rrcllc */
          rrccu_send_l1_drx_req();
          /* Reset the state machine and the procedure ends */
          rrccu_substate = RRCCU_INITIAL;
         
          if (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH)
          {
            /* check whether URA update is required */
            if ( rrccu_is_ura_update_reqd() == TRUE)
            {
              rrccu_send_ura_update_initiate_req( RRC_URA_RESELECTION,
                                                  FALSE);
            }
          }
          else if (rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH)
          {
            /* check whether any cell update initiate req needs to be 
            posted to itself due to reselections in certain substates*/
            if (rrccu_cu_initiate_reqd.cu_reqd)
            {
              /* delete CRNTI */
              rrccu_delete_crnti();
              rrccu_cu_initiate_reqd.cu_reqd = FALSE;
             
              rrccu_send_cell_update_initiate_req (RRC_CELL_RESELECTION);
            }
          }
          /*send  ul data registration request to rlc */
          rrccu_register_with_rlc_for_ul_data_indication();
          /* Inform all registered RRC procedures that Cell
           Update is completed */
          rrccu_inform_cell_update_completed();

 
          rrccu_process_successful_completion();
          
          /*call the procedure to clear the global variabls */
          rrccu_clear_procedure();
     
        }
      }
    break;
    default:
      WRRC_MSG2_HIGH("Invalid Event: %x in the substate: %d", 
                cmd_ptr->cmd_hdr.cmd_id, rrccu_substate);
      break;
  }
} /* rrccu_process_cu_wait_for_pcch_rb_est_cnf **/


/*===========================================================================

FUNCTION RRCCU_PROCESS_CU_WAIT_FOR_RNTI_UPDATE_CNF

DESCRIPTION
  This function processes all events that are dispatched to Cell Update 
  procedure in RRCCU_WAIT_FOR_RNTI_UPDATE_CNF substate.

  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
static void rrccu_process_cu_wait_for_rnti_update_cnf
(    
  rrc_cmd_type *cmd_ptr
)
{
  rrc_rl_failure_cause_e_type  rl_cause;

  switch(rrc_get_state())
  {
    case RRC_STATE_CELL_FACH:
      switch(cmd_ptr->cmd_hdr.cmd_id)
      { 
        case RRC_NEW_CELL_IND:
          WRRC_MSG2_HIGH("Cell reselection in state:%d, cu_state:%d",
                   rrc_get_state(),rrccu_substate);
          if (rrccu_oc_set_by_cu != TRUE) 
          {
            rrccu_delete_crnti();
            /* Remap the cell update cause */
            rrccu_cell_update_cause = 
              rrccu_map_cu_cause_based_on_priority(RRC_CELL_RESELECTION);
            rrccu_resend_cell_update_msg(RRCCU_NOT_INCLUDE_FAILURE_CAUSE);
          }
          else
          {
            if (rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH)
            {
              /* lower layers are not configured yet. clear
              oc. and re-send the cell update message */

              /* delete CRNTI */
              rrccu_delete_crnti();
              /* clear stored channel config info */
              rrccu_chan_config_info.num_rbs = 0;
              /*reset oc */
              (void)rrcllc_reset_ordered_config(RRC_PROCEDURE_CU,TRUE);
                /* keep the same cause as before unless
                the cause is periodicall cell update otherwise
                change the cause*/
                if (rrccu_cell_update_cause == rrc_CellUpdateCause_periodicalCellUpdate)
                {            
                  rrccu_cell_update_cause = rrc_CellUpdateCause_cellReselection;
                }
                rrccu_resend_cell_update_msg(RRCCU_NOT_INCLUDE_FAILURE_CAUSE);
              }
            else if (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH)
            {
              /* read sib2 and set ura_update_reqd flag accordingly */
              rrccu_ura_update_required = rrccu_check_for_ura_reselection();
            }
            else
            {
              /*channel is already being configured */
              /* new cell indication at this stage should
              be blocked by csp itself? */
              WRRC_MSG2_ERROR("OC set cu_subst:%d,next_st:%d",
                     rrccu_substate, rrccu_state_indicator);
              rrccu_cu_initiate_reqd.cu_reqd  = TRUE;
              rrccu_cu_initiate_reqd.cu_cause = rrc_CellUpdateCause_cellReselection;
              /* continue in the same substate */
            }
          }
          break;

        case RRC_DOWNLINK_SDU_IND:
          /* Cell Update Confirm Msg may be received in this
              Substate because of cell-reselections. */
          WRRC_MSG0_HIGH("Simultanous transactions not supported");
          break;

        case RRC_CPHY_OUT_OF_SERVICE_AREA_IND:
          /*Delete C-RNTI */
          //rrccu_delete_crnti();

          rrccu_process_oos_area_handling();


          break;

        case RRC_RNTI_UPDATE_CNF:
          if(cmd_ptr->cmd.rnti_update_cnf.status == SUCCESS)
          {
            /* In case of RNTI req in the CU Cnf for FACH->PCH which
              * has Directed cell info, initiate cell selction now
              */
            if (rrccu_int_data.rrccu_cell_selection_trans_from_fach)
            {
              rrccu_intiate_cell_selection_fach_pch_cu_cnf();
            }
            /* In case of FACH->FACH freq redirection, after rnti update
             * is complete in new cell, if camped on non directed cell
             * post a Cu with cause cell reselction 
             */
            else if ((rrccu_cu_initiate_reqd.cu_reqd) && (!rrccu_cucnf_for_srns_relocation))
            {
              if (rrccu_oc_set_by_cu == TRUE)
              {
                rrcllc_clear_ordered_config();
                rrccu_chan_config_info.num_rbs = 0;
              }
              /* delete CRNTI */
              rrccu_delete_crnti();
              rrccu_cu_initiate_reqd.cu_reqd = FALSE;
              rrccu_send_cell_update_initiate_req (RRC_CELL_RESELECTION);
              rrccu_substate = RRCCU_INITIAL;
              rrccu_clear_procedure();
            }
            else
            {
              rrccu_send_response_msg();
            }
          }
          else
          {
            rrccu_int_data.rrccu_cell_selection_trans_from_fach = FALSE;
            if (rrccu_oc_set_by_cu == TRUE)
            {
              rrcllc_clear_ordered_config();
            }
            WRRC_MSG0_HIGH("RNTI_UPDATE Failed.  Re-send cell update");
            rrccu_resend_cell_update_msg(RRCCU_NOT_INCLUDE_FAILURE_CAUSE);
          }
          break;  

        case RRC_CRLC_STATUS_IND:
          rrccu_process_rlc_status_ind_in_non_initial_sub_states(cmd_ptr);
          break;

        case RRC_CELL_UPDATE_INITIATE_REQ:
          if(RRCCU_SUCCESS == rrccu_validate_cell_update_initiate_req(cmd_ptr)) 
          {
            if( IS_CU_TRIGGERED_WITH_RE_ENTER_SERVICE_AREA_VALID )
            {
              rrccu_process_oos_area_handling();   
            }
          }
          break;

        default:
          WRRC_MSG2_ERROR("Unknown command: 0x%x, CU st %d", cmd_ptr->cmd_hdr.cmd_id,rrccu_substate);
          break;
      }
      break;
    case RRC_STATE_CELL_DCH:
      switch(cmd_ptr->cmd_hdr.cmd_id)
      { 
        case RRC_DOWNLINK_SDU_IND:
          /* Cell Update Confirm Msg may be received in this
              Substate because of cell-reselections. */
          WRRC_MSG0_HIGH("Simultanous transactions not supported");
          break;
        case RRC_RNTI_UPDATE_CNF:
          if(cmd_ptr->cmd.rnti_update_cnf.status == SUCCESS)
          {
            rrccu_send_response_msg();
          }
          else
          {
            if (rrccu_oc_set_by_cu == TRUE)
            {
              rrcllc_clear_ordered_config();
            }
            WRRC_MSG0_HIGH("RNTI update failed.  Re-send Cell update");
            rrccu_resend_cell_update_msg(RRCCU_NOT_INCLUDE_FAILURE_CAUSE);
          }
          break;  

        case RRC_CRLC_STATUS_IND:
          rrccu_process_rlc_status_ind_in_non_initial_sub_states(cmd_ptr);
          break;

        case RRC_CPHY_RL_FAILURE_IND:
          rl_cause = RL_FAILURE_DUE_TO_L1;
          /*Update the global release_cause variable here */
          rrc_release_cause = RRC_REL_DEEP_FADE;
          event_report_payload(EVENT_WCDMA_RL_FAILURE, sizeof(rrc_rl_failure_cause_e_type), 
                              (void *)&rl_cause);
          WRRC_MSG1_HIGH("Rcvd RRC_CPHY_RL_FAILURE_IND cu_st:%d, Etering idle",rrccu_substate);
          /* this is too late for any recovery because
          failure happened during the reconfiguration and response has
          not been sent Since going back to old config is not supported
          enter idle*/
          rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                               RRC_TX_TO_DISCON_OTHER);
          rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
          break;

        default:
          WRRC_MSG2_ERROR("Unknown command: 0x%x, CU st %d", cmd_ptr->cmd_hdr.cmd_id,rrccu_substate);
          break;
      }
      break;

    default:
      MSG_HIGH("Invalid Event: 0x%x cu_st:%d rrc_st:%d", 
                cmd_ptr->cmd_hdr.cmd_id, rrccu_substate, rrc_get_state());
      break;
  }
} /* rrccu_process_cu_wait_for_rnti_update_cnf */


/*===========================================================================

FUNCTION RRCCU_PROCESS_CU_WAIT_FOR_RB_EST_CNF

DESCRIPTION
  This function processes all events that are dispatched to Cell Update 
  procedure in RRCCU_WAIT_FOR_RB_EST_CNF substate.

  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
void rrccu_process_cu_wait_for_rb_est_cnf
(    
  rrc_cmd_type *cmd_ptr
)
{
  rrc_cmd_type              *int_cmd_ptr;

  switch(rrc_get_state())
  {
    case RRC_STATE_CELL_FACH:
      switch(cmd_ptr->cmd_hdr.cmd_id)
      { 
        case RRC_NEW_CELL_IND:
          /*TBD neet to revisit this. We can not just send cellupdate here
          because ordered config is set and channelconfig is also requested
          should we go back to old config? or delay the reconfig? */
          WRRC_MSG2_HIGH("Cell reselection in state:%d, cu_state:%d",
                   rrc_get_state(),rrccu_substate);
          /* if next state is cell_DCH then ignore this oos indication
          otherwise it is too late. Take the UE to idle */
          if (rrccu_state_indicator != rrc_RRC_StateIndicator_cell_DCH)
          {
            rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                                 RRC_TX_TO_DISCON_OTHER);
            rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
            WRRC_MSG1_HIGH("OOS not handled ini cu_subst:%d",
                     rrccu_substate);
            }
          break;

        case RRC_DOWNLINK_SDU_IND:
          /* Cell Update Confirm Msg may be received in this
              Substate because of cell-reselections. */
          WRRC_MSG0_HIGH("Simultanous transactions not supported");
          break;

        case RRC_CPHY_OUT_OF_SERVICE_AREA_IND:
          WRRC_MSG2_HIGH("OOS Ind Rcvd in st:%d cu_st:%d",
                    rrc_get_state(),rrccu_substate);
          event_report(EVENT_WCDMA_OUT_OF_SERVICE);
          /* if next state is cell_DCH then ignore this oos indication
          otherwise it is too late. Take the UE to idle */
          if (rrccu_state_indicator != rrc_RRC_StateIndicator_cell_DCH)
          {
            rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                                 RRC_TX_TO_DISCON_OTHER);

              rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
          }
          break;

        case RRC_CHANNEL_CONFIG_CNF:
          rrcllcpcie_initialise_sync_a_post_veri_info();

          if(cmd_ptr->cmd.chan_config_cnf.chan_cfg_status == RRCLLC_CHAN_CFG_SUCCESS)
          {
            /*
              Since channel config confirm has been received with a success, hence update the value of maximum 
              Count C in the permanent variable from the temporary one
            */
            rrcsmc_update_count_c_released_rbs();
            
            /* Copy the Ordered RB Mapping into the current RB-Mapping database*/
            rrcllc_copy_ordered_hanging_rb_mapping_to_current();

            if(rrccu_state_indicator == rrc_RRC_StateIndicator_cell_DCH)
            {
              {            
#ifdef FEATURE_VOC_AMR_WB
                WRRC_MSG1_HIGH("Configuring Vocoder and current active codec is %d",rrc_active_codec);
                rrcrb_update_amr_cctrch_id_for_reconfig(rrc_active_codec);
#else/*FEATURE_VOC_AMR_WB*/
                rrcrb_update_amr_cctrch_id_for_reconfig();
#endif/*FEATURE_VOC_AMR_WB*/
              }
              /*Notify the Cell_Id to registered entities*/
              rrc_notify_cell_id_in_dch();
            }

            if (! rrccu_cucnf_for_srns_relocation)
            {
              /*send RNTI update req if any one of the RNTIs has been received
              in cell update confirm message */
              if (rrccu_new_crnti_valid || rrccu_new_urnti_valid || 
                  rrccu_reestablish_srb || rrccu_reestablish_rab)
              {
                rrccu_send_rnti_update_req(TRUE);
                /*clear the global variables */
                rrccu_reestablish_srb = FALSE;
                rrccu_reestablish_rab = FALSE;
                rrccu_new_crnti_valid = FALSE;
                rrccu_new_urnti_valid = FALSE;

                rrccu_substate = RRCCU_WAIT_FOR_RNTI_UPDATE_CNF;         
              }
              else
              {
                /* In case of FACH->FACH freq redirection, after configuring
                 * Lower layer in new cell, if camped on non directed cell
                 * post a Cu with cause cell reselction 
                 */
                if (rrccu_cu_initiate_reqd.cu_reqd)
                {
                  if (rrccu_oc_set_by_cu == TRUE)
                  {
                    rrcllc_clear_ordered_config();
                    rrccu_chan_config_info.num_rbs = 0;
                  }
                               /* delete CRNTI */
                  rrccu_delete_crnti();
  
                  rrccu_cu_initiate_reqd.cu_reqd = FALSE;
                  rrccu_send_cell_update_initiate_req (RRC_CELL_RESELECTION);
                  
                  rrccu_substate = RRCCU_INITIAL;
                  rrccu_clear_procedure();
                }
                else
                {
                  /* send response*/
                  rrccu_send_response_msg();
                  /* check if a cell update confirm was received in previous cell and the response msg still needs to be sent*/
  
                }

              }
            }
            else
            {
              /* message involves SRNS relocation
              send the rlc re-establishment request to SMC to re-establish SRB2 */
              /* Get the command buffer */
                int_cmd_ptr = rrc_get_int_cmd_buf();
                /* Fill in the command id  */
                int_cmd_ptr->cmd_hdr.cmd_id = RRC_RE_EST_RLC_FOR_SRNS_REQ;
                int_cmd_ptr->cmd.rrc_re_est_srns_req.rrc_proc = RRC_PROCEDURE_CU;
                int_cmd_ptr->cmd.rrc_re_est_srns_req.rb_type  = RRC_RE_EST_RB_2;
                int_cmd_ptr->cmd.rrc_re_est_srns_req.cnf_reqd = TRUE;
                WRRC_MSG1_HIGH("RLC Reestablish req for %d ", 
                         RRC_RE_EST_RB_2); 

                rrc_put_int_cmd(int_cmd_ptr);             

                rrccu_substate = RRCCU_WAIT_FOR_SRB2_RE_EST_CNF;         
              }
          }
          else
          {
            /*
               Since channel config comfirm came with a failure, hence revert the max count c value
               in the temporary variable to the original value
            */
            rrcsmc_revert_max_count_c();
            
#ifndef FEATURE_WCDMA_HS_FACH
              /* Channel config failure, so initialise the ordered RB-Mapping database*/
            rrcllc_init_ordered_hanging_rb_mapping_info();
#else
            rrcllc_copy_current_hanging_rb_mapping_to_ordered();
#endif


            WRRC_MSG1_HIGH("Chan config failed,cu_subst:%d",
                       rrccu_substate);
            if (rrccu_state_indicator == rrc_RRC_StateIndicator_cell_DCH)
            {
              if (rrc_v_302 <= RRC_GET_N302())
              {
                (void)rrcllc_reset_ordered_config(RRC_PROCEDURE_CU,TRUE);
                  if (rrccu_oc_set_by_cu == TRUE)
                  {
                    /* For the RLF reason, failure cause must be sent in message CU, set it accordingly
                     * This is as per 25.331 Section 8.3.1.7a	Physical channel failure
                     */	   
                    rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;	
                    rrccu_failure_cause.failureCause.t = T_rrc_FailureCauseWithProtErr_physicalChannelFailure;
                    rrccu_physical_channel_failure = TRUE;
                    rrccu_oc_set_by_cu = FALSE;
                  }
                  /* store the current rrc state when failure was indicated */
                  rrccu_failure_state = rrc_get_state();
                  /* update mac_rab_status*/
                  rrcrb_update_mac_rab_status(RRC_PROCEDURE_CU, RRC_CS_DOMAIN_CN_ID,
                                              NULL,
                                              TRUE);
                  /* Start the OOS Timer */
                  rrctmr_start_timer(RRCTMR_T_OOS_TIMER, RRCTMR_CPHYCHANFAIL_TIMER_IN_MS);
                  /*Initiate Cell Selection */
                  rrccu_send_rrc_initiate_cell_selection_ind(
                    RRC_OUT_OF_SERVICE_AREA_IND,
                    RRC_STATE_CELL_FACH); 
                
                  /* Update Cell Update cause */
                  rrccu_cell_update_cause = rrc_CellUpdateCause_radiolinkFailure;
                  rrccu_substate = RRCCU_WAIT_FOR_UE_TO_CAMP_ON;
                }
              else 
              {
                /* Max re-transmissions are tried */
                rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                                     RRC_TX_TO_DISCON_OTHER);
                  /* Update the release cause */              
                rrc_release_cause = RRC_REL_DEEP_FADE;
                rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
                WRRC_MSG1_HIGH("Max retries:%d are tried" , RRC_GET_N302());
              }
            }
            else
            {
              /* channel config was not successful. too late to 
              take any action to recover. Enter idle state */
                rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                                     RRC_TX_TO_DISCON_OTHER);
                rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
              }
          }
          break;  

        case RRC_CRLC_STATUS_IND:
          rrccu_process_rlc_status_ind_in_non_initial_sub_states(cmd_ptr);
          break;

        case RRC_CELL_UPDATE_INITIATE_REQ:
          if(RRCCU_SUCCESS == rrccu_validate_cell_update_initiate_req(cmd_ptr)) 
          {
            if( IS_CU_TRIGGERED_WITH_RE_ENTER_SERVICE_AREA_VALID )
            {
              rrccu_process_oos_area_handling();   
            }
          }
          break;

        default:
          WRRC_MSG2_ERROR("Unknown command: 0x%x, CU st %d", cmd_ptr->cmd_hdr.cmd_id,rrccu_substate);
          break;
      }
      break;
    case RRC_STATE_CELL_DCH:
      switch(cmd_ptr->cmd_hdr.cmd_id)
      { 
        case RRC_DOWNLINK_SDU_IND:
          /* Cell Update Confirm Msg may be received in this
              Substate because of cell-reselections. */
          WRRC_MSG0_HIGH("Simultanous transactions not supported");
          break;

        case RRC_CHANNEL_CONFIG_CNF:
          rrcllcpcie_initialise_sync_a_post_veri_info();

          if(cmd_ptr->cmd.chan_config_cnf.chan_cfg_status == RRCLLC_CHAN_CFG_SUCCESS)
          {
            /*
               Since channel config confirm has been received with a success, hence update the value of maximum 
               Count C in the permanent variable from the temporary one
            */
            rrcsmc_update_count_c_released_rbs();
            
            /* Copy the Ordered RB Mapping into the current RB-Mapping database*/
            rrcllc_copy_ordered_hanging_rb_mapping_to_current();

            if(rrccu_state_indicator == rrc_RRC_StateIndicator_cell_DCH)
            {
              {           
#ifdef FEATURE_VOC_AMR_WB
                WRRC_MSG1_HIGH("Configuring Vocoder and current active codec is %d",rrc_active_codec);
                rrcrb_update_amr_cctrch_id_for_reconfig(rrc_active_codec);
#else/*FEATURE_VOC_AMR_WB*/
                rrcrb_update_amr_cctrch_id_for_reconfig();
#endif/*FEATURE_VOC_AMR_WB*/
              }
            }

            if (! rrccu_cucnf_for_srns_relocation)
            {
              /*send RNTI update req if any one of the RNTIs has been received
              in cell update confirm message or rlc-reestablishment was indicated */
              if (rrccu_new_crnti_valid || rrccu_new_urnti_valid || 
                    rrccu_reestablish_srb || rrccu_reestablish_rab)
              {
                rrccu_send_rnti_update_req(TRUE);
                /*clear the global variables */
                rrccu_reestablish_srb = FALSE;
                rrccu_reestablish_rab = FALSE;
                rrccu_new_crnti_valid = FALSE;
                rrccu_new_urnti_valid = FALSE;

                rrccu_substate = RRCCU_WAIT_FOR_RNTI_UPDATE_CNF;         
              }
              else
              {
                rrccu_send_response_msg();
              }
            }
            else
            {
              /* message involves SRNS relocation
              send the rlc re-establishment request to SMC to re-establish SRB2 */
              /* Get the command buffer */
                int_cmd_ptr = rrc_get_int_cmd_buf();
                /* Fill in the command id  */
                int_cmd_ptr->cmd_hdr.cmd_id = RRC_RE_EST_RLC_FOR_SRNS_REQ;
                int_cmd_ptr->cmd.rrc_re_est_srns_req.rrc_proc = RRC_PROCEDURE_CU;
                int_cmd_ptr->cmd.rrc_re_est_srns_req.rb_type  = RRC_RE_EST_RB_2;
                int_cmd_ptr->cmd.rrc_re_est_srns_req.cnf_reqd = TRUE;
                WRRC_MSG1_HIGH("RLC Reestablish req for %d ", 
                         RRC_RE_EST_RB_2); 

                rrc_put_int_cmd(int_cmd_ptr);             

                rrccu_substate = RRCCU_WAIT_FOR_SRB2_RE_EST_CNF;         
              }
          }
          else
          {
           /* channel config was not successful. too late to 
           take any action to recover. Enter idle state */

            /*
               Since channel config comfirm came with a failure, hence revert the max count c value
               in the temporary variable to the original value
            */
            rrcsmc_revert_max_count_c();
           
#ifndef FEATURE_WCDMA_HS_FACH
              /* Channel config failure, so initialise the ordered RB-Mapping database*/
            rrcllc_init_ordered_hanging_rb_mapping_info();
#else
           rrcllc_copy_current_hanging_rb_mapping_to_ordered();
#endif

            rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                                 RRC_TX_TO_DISCON_OTHER);
              rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
              WRRC_MSG2_HIGH("l2ack failed SRNSReloc:%d,cu_subst:%d",
                       rrccu_cucnf_for_srns_relocation,
                       rrccu_state_indicator);
            }
          break;  

        case RRC_CRLC_STATUS_IND:
          rrccu_process_rlc_status_ind_in_non_initial_sub_states(cmd_ptr);
          break;

        default:
          WRRC_MSG2_ERROR("Unknown command: 0x%x, CU st %d", cmd_ptr->cmd_hdr.cmd_id,rrccu_substate);
          break;
      }
      break;

    default:
      WRRC_MSG2_HIGH("Invalid Event: %d in the substate: %d", 
                cmd_ptr->cmd_hdr.cmd_id, rrccu_substate);
      break;
  }
} /* rrccu_process_cu_wait_for_rb_est_cnf */

/*===========================================================================

FUNCTION RRCCU_PROCESS_CU_WAIT_FOR_SRB2_RE_EST_CNF

DESCRIPTION
  This function processes all events that are dispatched to Cell Update 
  procedure in RRCCU_WAIT_FOR_SRB2_RE_EST_CNF substate.

  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
static void rrccu_process_cu_wait_for_srb2_re_est_cnf
(    
  rrc_cmd_type *cmd_ptr
)
{
  switch(rrc_get_state())
  {
    case RRC_STATE_CELL_FACH:
      switch(cmd_ptr->cmd_hdr.cmd_id)
      { 
        case RRC_NEW_CELL_IND:
          WRRC_MSG2_HIGH("Cell reselection in state:%d, cu_state:%d",
                   rrc_get_state(),rrccu_substate);
          if (rrccu_oc_set_by_cu == TRUE) 
          {
           /* could not clear OC. go to idle */
              rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                                   RRC_TX_TO_DISCON_OTHER);
              rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
              WRRC_MSG1_HIGH("OOS during srns reloc cu_subst:%d", 
                       rrccu_substate);
            }
            else
            {
            /* Remap the cell update cause */
            rrccu_cell_update_cause = 
              rrccu_map_cu_cause_based_on_priority(RRC_CELL_RESELECTION);
            rrccu_resend_cell_update_msg(RRCCU_NOT_INCLUDE_FAILURE_CAUSE);
          }
          break;

        case RRC_DOWNLINK_SDU_IND:
          /* Cell Update Confirm Msg may be received in this
              Substate because of cell-reselections. */
          WRRC_MSG0_HIGH("Simultanous transactions not supported");
          break;

        case RRC_CPHY_OUT_OF_SERVICE_AREA_IND:
          rrccu_process_oos_area_handling();
          break;

        case RRC_RE_EST_RLC_FOR_SRNS_CNF:
          /*send RNTI update req if any one of the RNTIs has been received
          in cell update confirm message */
          if (rrccu_new_crnti_valid || rrccu_new_urnti_valid || 
                 rrccu_reestablish_srb || rrccu_reestablish_rab)
          {
            rrccu_send_rnti_update_req(TRUE);
            /*clear the global variables */
            rrccu_reestablish_srb = FALSE;
            rrccu_reestablish_rab = FALSE;
            rrccu_new_crnti_valid = FALSE;
            rrccu_new_urnti_valid = FALSE;

            rrccu_substate = RRCCU_WAIT_FOR_RNTI_UPDATE_CNF;         
          }
          /*send the response message */
          else
          {
              /*call the function that evaluates the directed cell info and set the flags accordingly */
           /* In case of FACH->PCH freq redirection, after srns 
             * re-establishment,if directed info is present trigger
             * cell selection
             */
            if (rrccu_int_data.rrccu_cell_selection_trans_from_fach)
            {
              rrccu_intiate_cell_selection_fach_pch_cu_cnf();
            }
            else
            {
               /* In case of FACH->FACH freq redirection, after srns 
                 * re-establishment,  if camped on non directed cell
                 * post a Cu with cause cell reselction 
                 */
              if ((rrccu_cu_initiate_reqd.cu_reqd) && (rrccu_substate == RRCCU_INITIAL ))
              {
                if (rrccu_oc_set_by_cu == TRUE)
                {
                  rrcllc_clear_ordered_config();
                  rrccu_chan_config_info.num_rbs = 0;
                }
                             /* delete CRNTI */
                rrccu_delete_crnti();

                rrccu_cu_initiate_reqd.cu_reqd = FALSE;
                rrccu_send_cell_update_initiate_req (RRC_CELL_RESELECTION);
                                             rrccu_substate = RRCCU_INITIAL;
                rrccu_clear_procedure();
              }
              else
              {
                rrccu_send_response_msg();
              }
            }

          }
          break;  

        case RRC_CRLC_STATUS_IND:
          rrccu_process_rlc_status_ind_in_non_initial_sub_states(cmd_ptr);
          break;

        case RRC_CELL_UPDATE_INITIATE_REQ:
          if(RRCCU_SUCCESS == rrccu_validate_cell_update_initiate_req(cmd_ptr)) 
          {
            if( IS_CU_TRIGGERED_WITH_RE_ENTER_SERVICE_AREA_VALID )
            {
              rrccu_process_oos_area_handling();   
            }
          }
          break;

        default:
          WRRC_MSG2_ERROR("Unknown command: 0x%x, CU st %d", cmd_ptr->cmd_hdr.cmd_id,rrccu_substate);
          break;
      }
      break;
    case RRC_STATE_CELL_DCH:
      switch(cmd_ptr->cmd_hdr.cmd_id)
      { 
        case RRC_DOWNLINK_SDU_IND:
          /* Cell Update Confirm Msg may be received in this
              Substate because of cell-reselections. */
          WRRC_MSG0_HIGH("Simultanous transactions not supported");
          break;

        case RRC_RE_EST_RLC_FOR_SRNS_CNF:
          /*send RNTI update req if any one of the RNTIs has been received
          in cell update confirm message */
          if (rrccu_new_crnti_valid || rrccu_new_urnti_valid || 
                 rrccu_reestablish_srb || rrccu_reestablish_rab)
          {
            /* send RNTI update request now before sending the response message*/
            /*we are sending this to make sure that if any rlc re-establishment is 
            indicated in the cucnf then it will be processed */
            /* Allocates the buffer to RRC Internal command */
            rrccu_send_rnti_update_req(TRUE);
            /*clear the global variables */
            rrccu_reestablish_srb = FALSE;
            rrccu_reestablish_rab = FALSE;
            rrccu_new_crnti_valid = FALSE;
            rrccu_new_urnti_valid = FALSE;

            rrccu_substate = RRCCU_WAIT_FOR_RNTI_UPDATE_CNF;         
          }
          /*send the response message */
          else
          {
            rrccu_send_response_msg();
          }
          break;  

        case RRC_CRLC_STATUS_IND:
          rrccu_process_rlc_status_ind_in_non_initial_sub_states(cmd_ptr);
          break;

        default:
          WRRC_MSG2_ERROR("Unknown command: 0x%x, CU st %d", cmd_ptr->cmd_hdr.cmd_id,rrccu_substate);
          break;
      }
      break;

    default:
      WRRC_MSG2_HIGH("Invalid Event: %d in the substate: %d", 
                cmd_ptr->cmd_hdr.cmd_id, rrccu_substate);
      break;
  }
} /* rrccu_process_cu_wait_for_srb2_re_est_cnf */

/*===========================================================================

FUNCTION RRCCU_DELETE_CRNTI

DESCRIPTION
  This function sends RRC_RNTI_UPDATE_REQ to RRC LLC to delete the C-RNTI
  
DEPENDENCIES


RETURN VALUE
  rrccu_status_e_type: returns RRCCU_SUCCESS if it successfully sends
  RRC_CHANNEL_CONFIG_REQ to the RRC LLC. Otherwise it returns
  RRCCU_FAILURE_MAJOR.


SIDE EFFECTS

  None

===========================================================================*/
void rrccu_delete_crnti
(  
  void
)
{
  rrc_cmd_type *cmd_ptr;                     /* Pointer to the RRC Command */

  /* Allocates the buffer to RRC Internal command */
    cmd_ptr =  rrc_get_int_cmd_buf();
    /* Fill in the command parameters for RRC_CHANNEL_CONFIG_REQ */
    cmd_ptr->cmd_hdr.cmd_id = RRC_RNTI_UPDATE_REQ;
    cmd_ptr->cmd.rnti_update_req.procedure = RRC_PROCEDURE_CU;

    /* Fill in parameters for RRC_RNTI_UPDATE_REQ command */
    cmd_ptr->cmd.rnti_update_req.crnti_action = RRC_RNTI_DELETE;

    cmd_ptr->cmd.rnti_update_req.urnti_action = RRC_RNTI_NOCHANGE;
    cmd_ptr->cmd.rnti_update_req.cnf_required = FALSE;
   
    cmd_ptr->cmd.rnti_update_req.rlc_re_establish_rab = FALSE;
    cmd_ptr->cmd.rnti_update_req.rlc_re_establish_srb = FALSE;

    cmd_ptr->cmd.chan_config_req.rrc_channel_config_cnf_required = FALSE;
  
    rrc_put_int_cmd(cmd_ptr);                 /* sends the command to RRC
                                                 LLC. */
} /* rrccu_delete_crnti */

/*===========================================================================

FUNCTION RRCCU_RETURN_CU_SUBSTATE

DESCRIPTION
  This function returns the cu subtate

  
DEPENDENCIES
  None

RETURN VALUE
  cu substate
  
SIDE EFFECTS

  None

===========================================================================*/
#ifdef FEATURE_QSH_DUMP
__attribute__((section(".uncompressible.text")))
#endif
rrccu_substate_e_type rrccu_return_cu_substate(void)
{

   return rrccu_substate;
}

/*===========================================================================
FUNCTION RRCCU_SET_CU_SUBSTATE

DESCRIPTION
  This function sets the cu subtate

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
void rrccu_set_cu_substate
(
  rrccu_substate_e_type state
)
{
  MSG_HIGH("Set CU substate from %d to %d in RRC state %d",rrccu_substate,state,rrc_get_state());
  rrccu_substate = state;
  return;
}

/*===========================================================================
FUNCTION rrccu_get_rb_id_unrec_error()

DESCRIPTION
  This function return the RB id on which RLC unrecoverable error has occured.
  
DEPENDENCIES
  None

RETURN VALUE
  RB Id.
  
SIDE EFFECTS
  None
===========================================================================*/
rrc_RB_Identity rrccu_get_rb_id_unrec_error
(
  void
)
{
   return rb_id_unrec_error;
}

/*===========================================================================

FUNCTION RRCCU_PROCESS_CU_PENDING_CONFIG

DESCRIPTION
  This function processes all events that are dispatched to Cell Update 
  procedure in RRCCU_WAIT_FOR_PENDING_CONFIG substate

  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
static void rrccu_process_cu_pending_config
 (
   rrc_cmd_type *cmd_ptr
 )
{  
  rrccu_status_e_type status;
  rrc_state_e_type current_rrc_state = rrc_get_state();
  rrc_RB_Identity ul_rb_id = RRC_INVALID_RB_ID;
  rlc_lc_id_type ul_rlc_lc_id;

  MSG_HIGH("rrccu_process_cu_pending_config cmd_id: %d, in cu_substate: %d, in rrc_state: %d",cmd_ptr->cmd_hdr.cmd_id, rrccu_substate, current_rrc_state); 
  switch(cmd_ptr->cmd_hdr.cmd_id)
  { 

    case RRC_LLC_CMD_CNF:
      
      if((cmd_ptr->cmd_hdr.cmd_id == RRC_LLC_CMD_CNF) ||
         (RRCRB_WAIT_FOR_CELL_UPDATE_CNF == rrcrb_get_proc_sub_state(pending_config_proc_id)))
      {
        (void)rrccu_register_for_cell_update_to_complete(pending_config_proc_id);
      }
      if(cmd_ptr->cmd.rrc_llc_cnf.cnf.act_cancel_cnf.status == TRUE)
      {
        WRRC_MSG0_HIGH("received ACT CANC SUCCESS");
      }
      else
      {
        WRRC_MSG0_HIGH("received ACT CANC fail take ue to idle");
          rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                               RRC_TX_TO_DISCON_OTHER);
          rrc_release_cause = RRC_REL_DEEP_FADE;
          break;
        }

      (void)rrcllc_reset_ordered_config(RRC_PROCEDURE_CU,TRUE);

      rrccu_process_re_est_timers(FALSE);
      break;

    
    case RRC_CELL_UPDATE_INITIATE_REQ:

      if(pending_config_proc_id != cmd_ptr->cmd.initiate_cell_update.procedure)
      {
        WRRC_MSG0_HIGH("proc id not of proc that set OC.Initiate to disconnect state");
        rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                             RRC_TX_TO_DISCON_OTHER);
          /* Update the release cause */
          rrc_release_cause = RRC_REL_DEEP_FADE;
        return;
      }
      
      if(RRCRB_WAIT_FOR_CELL_UPDATE_CNF == rrcrb_get_proc_sub_state(pending_config_proc_id))
      {
        (void)rrccu_register_for_cell_update_to_complete(pending_config_proc_id);
      }

      rrccu_cell_update_cause = 
        rrccu_map_cu_cause_based_on_priority(cmd_ptr->cmd.initiate_cell_update.cause);
        
      if((RRCCU_T314_T315_ZERO == rrccu_check_re_est_timers()) ||  
           (RRCCU_T314_ZERO == rrccu_check_re_est_timers() &&
            !rrc_check_rbs_associated_with_re_est_timer(rrc_Re_EstablishmentTimer_useT315)))
      {

        /* confirm with rajeev: Procedure sent Initiate cell selecion for dch->fach doe they handle Tran to disconnected */
          rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                               RRC_TX_TO_DISCON_OTHER);
          /* Update the release cause */
          rrc_release_cause = RRC_REL_DEEP_FADE;
        }
      else if(rrc_get_state() == RRC_STATE_CELL_FACH)
      {
        WRRC_MSG1_HIGH("OC status in Cell_FACH = rrcllc_oc_set_status_e_type_value%d.",rrcllc_get_ordered_config_status_wo_f3());

        /* Check whether RB0 is already established */
        ul_rlc_lc_id = rrclcm_check_ul_rlc_lc_id(UE_LOGCHAN_CCCH, 
                                       CCCH_RADIO_BEARER_ID,
                                       UE_MODE_TRANSPARENT);

        if(ul_rlc_lc_id == RRCLCM_RLC_LC_ID_NOT_FOUND)
        {
          WRRC_MSG0_ERROR("No RB0 in CELL_FACH");
 #ifdef FEATURE_WCDMA_HS_FACH
          /*Configure common mode configuaiton for cell update procedure*/
          if(rrcenhstate_camped_cell_supports_e_fach() == TRUE)
          {
            WRRC_MSG0_HIGH("EFACH:CU Initiated , send CHAN_CONFIG_REQ for cHrnti");
            rrcllc_establish_srb_rab_in_efach(RRC_E_FACH_COMMON,RRC_PROCEDURE_CU,FALSE);
            rrccu_substate = RRCCU_WAIT_FOR_RB0_EST_CNF;
            break;
          }
 #endif
        }

        /* Stop timer T305 */
        rrctmr_stop_timer(RRCTMR_T_305_TIMER);

        /*Is there any need to purge SRB3 and SRB4. Or may be SRB1 or SRB2*/

        if (RRCCU_SUCCESS == rrccu_send_cell_update_msg(ul_rlc_lc_id,
                             RRCCU_NOT_INCLUDE_FAILURE_CAUSE) )
        {        
          rrccu_substate = RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM; 
        }
        else
        {
          /* Reset Cell Update State machine */
          rrccu_substate = RRCCU_INITIAL;
          /*call the procedure to clear the global variabls */
          rrccu_clear_procedure();
          rrccu_init_last_cu_cnf_info();

        }        
      }
      else
      {
        (void)rrcllc_reset_ordered_config(RRC_PROCEDURE_CU,TRUE);
      
        /* Check if timers T314 and T315 for RRC Connection Establishment.
         * process the RABs associated with re-est timers.*/  
        rrccu_process_re_est_timers(FALSE);
      }
      break;

    case RRC_CPHY_RL_FAILURE_IND:

	  
      WRRC_MSG1_HIGH("RL failure rcvd in RRCCU_PENDING_CONFIG. rrccu_cell_update_cause: %d ",rrccu_cell_update_cause);
      if (rrccu_cell_update_cause == rrc_CellUpdateCause_radiolinkFailure) 
      {
        /* CU cause is already RL failure. Ignore this RL failure */
      }
      else if (rrccu_cell_update_cause == rrc_CellUpdateCause_rlc_unrecoverableError &&
               rb_id_unrec_error == DCCH_AM_RADIO_BEARER_ID ) 
      {
        rrccu_cell_update_cause = 
          rrccu_map_cu_cause_based_on_priority(RRC_UNRECOVERABLE_ERROR);
      }
      else
      {
        /* UE hit RL failure while waiting to handle RLC unrec error on 
         * non-srb2.  Try to cancel the ongoing configuration
        */
        rrccu_cell_update_cause = 
          rrccu_map_cu_cause_based_on_priority(RRC_RADIO_LINK_FAILURE);
        status = rrccu_validate_rrc_status_for_failure_handling(cmd_ptr, rrc_CellUpdateCause_radiolinkFailure);
        if (status != RRCCU_SUCCESS) 
        {
          if(status == RRCCU_PENDING_CONFIG)
          {
            WRRC_MSG1_HIGH("Remain in the same substate: %d", rrccu_substate);
          }
          else /* RRCCU_FAILURE_MAJOR case */
          {
              rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                                   RRC_TX_TO_DISCON_OTHER);
              /* Update the release cause */
              rrc_release_cause = RRC_REL_DEEP_FADE;
              rrccu_substate    = RRCCU_WAIT_FOR_RB_REL_CNF;
            }
        }
        else /* status == RRCCU_SUCCESS*/
        {
          WRRC_MSG0_HIGH("This should not happen");
          /* store the current rrc state when failure was indicated */
          rrccu_failure_state = current_rrc_state;
          /* Check if timers T314 and T315 for RRC Connection Establishment.
          process the RABs associated with re-est timers.*/  
          rrccu_process_re_est_timers(FALSE);
        }
      }
      
      break;
    case RRC_CRLC_STATUS_IND:
      
      MSG_HIGH("RLC RESET type:%d,LC_id:%d,dir:%d", 
               cmd_ptr->cmd.crlc_status_ind.error_type,
               cmd_ptr->cmd.crlc_status_ind.lc_id,
               cmd_ptr->cmd.crlc_status_ind.direction);

      
      if (rrccu_cell_update_cause == rrc_CellUpdateCause_radiolinkFailure)
      {
        if ((cmd_ptr->cmd.crlc_status_ind.error_type == RLC_RESET_FAIL) &&
            (cmd_ptr->cmd.crlc_status_ind.direction == TRUE))
        {
          /* get the RBid mapped to the logical channel id on which
          RLC unrecoverable error was reported */
          ul_rb_id = rrclcm_get_ul_rb_id (cmd_ptr->cmd.crlc_status_ind.lc_id);
          if ((ul_rb_id >= DCCH_AM_RADIO_BEARER_ID) && 
              (ul_rb_id <= DCCH_DT_LOW_PRI_RADIO_BEARER_ID))
          {
            rrccu_rlc_error_info.error_on_srb = TRUE;
          }
          else
          {
            rrccu_rlc_error_info.error_on_urb = TRUE;
          }
        }
      }
      else if (rrccu_cell_update_cause == rrc_CellUpdateCause_rlc_unrecoverableError)
      {
        /* If we get unrecoverable on SRB 2 when processing unrecovrable error on non-srb2, 
         * try to cancel the ongoing configuration and remain in the same substate.
         */
        if (rrclcm_get_ul_rb_id (cmd_ptr->cmd.crlc_status_ind.lc_id) == DCCH_AM_RADIO_BEARER_ID &&
            rb_id_unrec_error != DCCH_AM_RADIO_BEARER_ID) 
        {
          status = rrccu_validate_rrc_status_for_failure_handling(cmd_ptr, rrc_CellUpdateCause_radiolinkFailure);
          if (status != RRCCU_SUCCESS) 
          {
            if(status == RRCCU_PENDING_CONFIG)
            {
              WRRC_MSG1_HIGH("Remain in the same substate: %d", rrccu_substate);
            }
            else /* RRCCU_FAILURE_MAJOR case */
            {
              rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                                   RRC_TX_TO_DISCON_OTHER);
                /* Update the release cause */
                rrc_release_cause = RRC_REL_DEEP_FADE;
                rrccu_substate    = RRCCU_WAIT_FOR_RB_REL_CNF;
              }
          }
          else /* status == RRCCU_SUCCESS*/
          {
            WRRC_MSG0_HIGH("This should not happen");
            /* store the current rrc state when failure was indicated */
            rrccu_failure_state = current_rrc_state;
           /* Check if timers T314 and T315 for RRC Connection Establishment.
              process the RABs associated with re-est timers.*/  
            rrccu_process_re_est_timers(FALSE);
          }
        }
        else
        {
          /* get the RBid mapped to the logical channel id on which
          RLC unrecoverable error was reported */
          ul_rb_id = rrclcm_get_ul_rb_id (cmd_ptr->cmd.crlc_status_ind.lc_id);
          if ((ul_rb_id >= DCCH_AM_RADIO_BEARER_ID) && 
              (ul_rb_id <= DCCH_DT_LOW_PRI_RADIO_BEARER_ID))
          {
            rrccu_rlc_error_info.error_on_srb = TRUE;
          }
          else
          {
            rrccu_rlc_error_info.error_on_urb = TRUE;
          }


        }
      }
      break;
    case RRC_T305_EXPIRED_IND:
    case RRC_T307_EXPIRED_IND:
    case RRC_CPHY_OUT_OF_SERVICE_AREA_IND:
    case RRC_NEW_CELL_IND:
    case RRC_SIB_CHANGE_IND:
    case RRC_STATE_CHANGE_IND:
          break;

    default:
      break;
  }
}

/*===========================================================================

FUNCTION RRCCU_PROCESS_CU_WAIT_FOR_L2_ACK

DESCRIPTION
  This function processes all events that are dispatched to Cell Update 
  procedure in RRCCU_WAIT_FOR_L2_ACK substate.

  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
void rrccu_process_cu_wait_for_l2_ack
(    
  rrc_cmd_type *cmd_ptr
)
{
  rrc_rl_failure_cause_e_type  rl_cause;
  rrc_cmd_type *int_cmd_ptr;

  switch(rrc_get_state())
  {
    case RRC_STATE_CELL_FACH:
      switch(cmd_ptr->cmd_hdr.cmd_id)
      { 
        case RRC_NEW_CELL_IND:
          WRRC_MSG2_HIGH("Cell reselection in state:%d, cu_state:%d",
                   rrc_get_state(),rrccu_substate);
          if ((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH) ||
              (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH) )
          {
            rrccu_failure_status_e_type status = RRCCU_NOT_INCLUDE_FAILURE_CAUSE;
            if (rrccu_oc_set_by_cu == TRUE) 
            {
              /* clear stored channel config info */
              rrccu_chan_config_info.num_rbs = 0;
              /*reset oc */
              (void)rrcllc_reset_ordered_config(RRC_PROCEDURE_CU,TRUE);
              rrccu_oc_set_by_cu = FALSE;
              rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;
              rrccu_failure_cause.failureCause.t = 
                    T_rrc_FailureCauseWithProtErr_incompatibleSimultaneousReconfiguration;
              status = RRCCU_INCLUDE_FAILURE_CAUSE;            }
            rrccu_delete_crnti();
            if (rrccu_ura_update_started)
            {
              /*cell reselection when URA update was initiated */
              if (rrccu_check_for_ura_reselection())
              {
                /* Update URA Update cause */
                rrccu_ura_update_cause = rrc_URA_UpdateCause_changeOfURA;
              }
              rrccu_resend_ura_update_msg(status);
            }
            else
            {
              /* Remap the cell update cause */
              rrccu_cell_update_cause = 
                rrccu_map_cu_cause_based_on_priority(RRC_CELL_RESELECTION);
              rrccu_resend_cell_update_msg(status);
            }
          }
          else if (rrccu_cucnf_for_srns_relocation) 
          { 
            /* this would be the case when SRNS relocation is involved and OC is
            set and lower layers are already configured */
            rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                                 RRC_TX_TO_DISCON_OTHER);
              rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
              WRRC_MSG1_HIGH("SRNS reloc & OC set cu_subst:%d", 
                       rrccu_substate);
            }
          break;

        case RRC_DOWNLINK_SDU_IND:
          /* Cell Update Confirm Msg may be received in this
              Substate because of cell-reselections. */
          WRRC_MSG0_HIGH("Simultanous transactions not supported");
          break;

        case RRC_CPHY_OUT_OF_SERVICE_AREA_IND:
          rrccu_process_oos_area_handling();
          break;

        case RRC_DOWNLINK_L2ACK_IND:
          if(cmd_ptr->cmd.downlink_l2ack_ind.status == SUCCESS)
          {
            WRRC_MSG0_HIGH("L2 ACK recvd for Rsp Msg");

     
            /*In FACH->PCH if direction info present intiate cell
              * selection, after l2 ack is received for response msg*/
            if (rrccu_int_data.rrccu_cell_selection_trans_from_fach)
            {
              rrccu_intiate_cell_selection_fach_pch_cu_cnf();
            }
    

            if (rrccu_cucnf_for_srns_relocation)
            {
              /*send the rlc re-establishment request to SMC to re-establish 
              remaining RBs other than SRB2 */
              /* Get the command buffer */
                int_cmd_ptr = rrc_get_int_cmd_buf();
                /* Fill in the command id  */
                int_cmd_ptr->cmd_hdr.cmd_id = RRC_RE_EST_RLC_FOR_SRNS_REQ;
                int_cmd_ptr->cmd.rrc_re_est_srns_req.rrc_proc = RRC_PROCEDURE_CU;
                int_cmd_ptr->cmd.rrc_re_est_srns_req.rb_type  = RRC_RE_EST_NON_RB_2_UM_AM;
                int_cmd_ptr->cmd.rrc_re_est_srns_req.cnf_reqd = FALSE;
                WRRC_MSG1_HIGH("RLC Reestablish req for %d ", 
                         RRC_RE_EST_NON_RB_2_UM_AM); 

                rrc_put_int_cmd(int_cmd_ptr);             
              /*clear the global variables stored */
              rrccu_cucnf_for_srns_relocation = FALSE;
              rrccu_new_urnti_valid = FALSE;
              rrccu_new_crnti_valid = FALSE;
              /* Abort Dormancy if CU_CNF with SRNS proceed to successful processing. */
              rrcdormancy_update_dormancy_for_srns_hho_cco(RRC_PROCEDURE_CU);
            }
            /* start the periodic timer */
          /* if the next state is cell_pch or ura_pch then setup pcch */
            if ((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH) ||
            (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH))
            {
              rrcllc_set_utran_drx_info (rrccu_utran_drx_coef); 
              /*send channel config to release ccch and setup pcch 
              This function will also take care of the channel configuration
              of RBs due to received cell update confirm message*/
              rrccu_establish_pcch_rb (
              rrc_translate_state_indicator_to_state(rrccu_state_indicator));
              rrccu_substate = RRCCU_WAIT_FOR_PCCH_RB_EST_CNF;
                /* do not start T305 here. It will be started after PCCH is established */
            }
            else 
            {
              /*clear the ordered config if it is set from rrccu procedure */
              if (rrccu_oc_set_by_cu == TRUE)
              {
                rrcllc_clear_ordered_config();
              }
              /* Start timer T305 */
              rrccu_start_t_305_timer();
             /* Inform all registered RRC procedures that Cell
               Update is completed */
              rrccu_inform_cell_update_completed();
             
    
              rrccu_process_successful_completion();
             
              /* check whether any cell update initiate req needs to be 
              posted to itself due to reselections in certain substates*/
              if (rrccu_cu_initiate_reqd.cu_reqd)
              {
                /* delete CRNTI */
                rrccu_delete_crnti();
                rrccu_cu_initiate_reqd.cu_reqd = FALSE;

                rrccu_send_cell_update_initiate_req (RRC_CELL_RESELECTION);
              }
              /*call the procedure to clear the global variabls */
              rrccu_clear_procedure();
              /* Reset the state machine and the procedure ends */
              rrccu_substate = RRCCU_INITIAL;
            }
          }
          else /*failed to receive l2ack */
          {
            WRRC_MSG0_ERROR("Failed to get L2ack");
            /*go to idle only if SRNS relocation was involved in this procedure 
            otherwise ignore the failure */
            if ((rrccu_cucnf_for_srns_relocation) ||
                (rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH) ||
                (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH))
            {
                rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                                     RRC_TX_TO_DISCON_OTHER);
                rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
                WRRC_MSG2_HIGH("l2ack failed SRNSReloc:%d,cu_subst:%d",
                         rrccu_cucnf_for_srns_relocation,
                         rrccu_state_indicator);
              }
            else /*Failed to get L2ack and SRNS relocation is not involved */
            {
            /* if the next state is cell_pch or ura_pch then setup pcch */
              if ((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH) ||
              (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH))
              {
                rrcllc_set_utran_drx_info (rrccu_utran_drx_coef); 
                rrccu_establish_pcch_rb (
                  rrc_translate_state_indicator_to_state(rrccu_state_indicator));
                rrccu_substate = RRCCU_WAIT_FOR_PCCH_RB_EST_CNF;
                /* do not start T305 here. It will be started after PCCH is established */
              }
              else 
              {
                /*clear the ordered config if it is set from rrccu procedure */
                if (rrccu_oc_set_by_cu == TRUE)
                {
                  rrcllc_clear_ordered_config();
                }
                /* Reset the state machine and the procedure ends */
                rrccu_substate = RRCCU_INITIAL;
                /* Start timer T305 */
                rrccu_start_t_305_timer();
               /* Inform all registered RRC procedures that Cell
                 Update is completed */
                rrccu_inform_cell_update_completed();

  
                rrccu_process_successful_completion();
               
                /*call the procedure to clear the global variabls */
                rrccu_clear_procedure();
              }
            }
          }
          break;
  
        case RRC_CRLC_STATUS_IND:
          rrccu_process_rlc_status_ind_in_non_initial_sub_states(cmd_ptr);
          break;

        case RRC_CELL_UPDATE_INITIATE_REQ:
          if(RRCCU_SUCCESS == rrccu_validate_cell_update_initiate_req(cmd_ptr)) 
          {
            if( IS_CU_TRIGGERED_WITH_RE_ENTER_SERVICE_AREA_VALID )
            {
              rrccu_process_oos_area_handling();   
            }
          }
          break;

        default:
          WRRC_MSG2_ERROR("Unknown command: 0x%x, CU st %d", cmd_ptr->cmd_hdr.cmd_id,rrccu_substate);
          break;
      }
      break;

    case RRC_STATE_CELL_DCH:
      switch(cmd_ptr->cmd_hdr.cmd_id)
      { 
        case RRC_DOWNLINK_L2ACK_IND:
          if(cmd_ptr->cmd.downlink_l2ack_ind.status == SUCCESS)
          {
            WRRC_MSG0_HIGH("L2 ACK recvd for Rsp Msg");
            if (rrccu_cucnf_for_srns_relocation)
            {
              /*send the rlc re-establishment request to SMC to re-establish 
              remaining RBs other than SRB2 */
              /* Get the command buffer */
              int_cmd_ptr = rrc_get_int_cmd_buf();
              /* Fill in the command id  */
              int_cmd_ptr->cmd_hdr.cmd_id = RRC_RE_EST_RLC_FOR_SRNS_REQ;
              int_cmd_ptr->cmd.rrc_re_est_srns_req.rrc_proc = RRC_PROCEDURE_CU;
              int_cmd_ptr->cmd.rrc_re_est_srns_req.rb_type  = RRC_RE_EST_NON_RB_2_UM_AM;
              int_cmd_ptr->cmd.rrc_re_est_srns_req.cnf_reqd = FALSE;
              WRRC_MSG1_HIGH("RLC Reestablish req for %d ", 
                       RRC_RE_EST_NON_RB_2_UM_AM); 
              rrc_put_int_cmd(int_cmd_ptr);             
              /*clear the global variables stored */
              rrccu_cucnf_for_srns_relocation = FALSE;
              rrccu_new_urnti_valid = FALSE;
              rrccu_new_crnti_valid = FALSE;
              /* Abort Dormancy if CU_CNF with SRNS proceed to successful processing. */
              rrcdormancy_update_dormancy_for_srns_hho_cco(RRC_PROCEDURE_CU);
            }
            /* start the periodic timer */

            /*clear the ordered config if it is set from rrccu procedure */
            if (rrccu_oc_set_by_cu == TRUE)
            {
              rrcllc_clear_ordered_config();
            }
             /* Inform all registered RRC procedures that Cell
               Update is completed */
              rrccu_inform_cell_update_completed();
              rrccu_process_successful_completion();
            rrccu_substate = RRCCU_INITIAL;
            /*call the procedure to clear the global variabls */
            rrccu_clear_procedure();
          }
          else
          {
            WRRC_MSG0_ERROR("Failed to get L2ack");
            /*go to idle only if SRNS relocation was involved in this procedure 
            otherwise ignore the failure */
            if (rrccu_cucnf_for_srns_relocation)
            {
              rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                                   RRC_TX_TO_DISCON_OTHER);
                rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
                WRRC_MSG0_HIGH("l2ack failed during SRNS reloc");
              break;
            }
            else
            {
              /*clear the ordered config if it is set from rrccu procedure */
              if (rrccu_oc_set_by_cu == TRUE)
              {
                rrcllc_clear_ordered_config();
              }
               /* Inform all registered RRC procedures that Cell
               Update is completed */
              rrccu_inform_cell_update_completed();
              rrccu_process_successful_completion();
              rrccu_substate = RRCCU_INITIAL;
              /*call the procedure to clear the global variabls */
              rrccu_clear_procedure();
            }
          }
          break;  

        case RRC_CRLC_STATUS_IND:
          rrccu_process_rlc_status_ind_in_non_initial_sub_states(cmd_ptr);
          break;

        case RRC_CPHY_RL_FAILURE_IND:
          rl_cause = RL_FAILURE_DUE_TO_L1;
          /*Update the global release_cause variable here */
          rrc_release_cause = RRC_REL_DEEP_FADE;
          event_report_payload(EVENT_WCDMA_RL_FAILURE, sizeof(rrc_rl_failure_cause_e_type), 
                              (void *)&rl_cause);
          /* this is too late for any recovery because
          failure happened during the reconfiguration and response has
          not been sent Since going back to old config is not supported
          enter idle*/
          rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                               RRC_TX_TO_DISCON_OTHER);
          rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
          break;


        default:
          WRRC_MSG2_ERROR("Unknown command: 0x%x, CU st %d", cmd_ptr->cmd_hdr.cmd_id,rrccu_substate);
          break;
      }
      break;

    default:
      WRRC_MSG2_HIGH("Invalid Event: %d in the substate: %d", 
                cmd_ptr->cmd_hdr.cmd_id, rrccu_substate);
      break;
  }
} /* rrccu_process_cu_wait_for_l2_ack */

/*===========================================================================

FUNCTION RRCCU_PROCESS_CU_WAIT_FOR_BPLMN_SUSPEND_CNF

DESCRIPTION
  This function processes all events that are dispatched to Cell Update 
  procedure in RRCCU_WAIT_FOR_BPLMN_SUSPEND_CNF substate.

  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
void rrccu_process_cu_wait_for_bplmn_suspend_cnf
(    
  rrc_cmd_type *cmd_ptr
)
{
  rrc_state_e_type current_rrc_state = rrc_get_state();

    switch(current_rrc_state)
    {
      case RRC_STATE_CELL_PCH:
      case RRC_STATE_URA_PCH:
        switch(cmd_ptr->cmd_hdr.cmd_id)
        {
          case RRC_BPLMN_SUSPEND_CNF:
            
            if(cmd_ptr->cmd.rrc_csp_bplmn_suspend_cnf.status == SUCCESS)
            {
              /* If cu cause is re-entered service area, initiate cell selection */
              if (rrccu_cell_update_cause == rrc_CellUpdateCause_re_enteredServiceArea ) 
              {
                /* Initiate Cell Selection */
                rrccu_send_rrc_initiate_cell_selection_ind(
                  RRC_OUT_OF_SERVICE_AREA_IND,
                  current_rrc_state);               

                /* Wait for UE to camp on */
                rrccu_substate = RRCCU_WAIT_FOR_UE_TO_CAMP_ON;
              }
              else
              {
#ifdef FEATURE_UPDATE_SIB7_FOR_PCH_TO_FACH              
                if(FALSE == rrcsib_check_and_update_sib7_validity(RRC_PROCEDURE_CU))
                {
                  /*Note that T305 isn't running now and CU cause has been updated with CU started status*/
                  WRRC_MSG0_HIGH("CU procedure waiting for SIB7.");
#ifdef FEATURE_DUAL_SIM
                  if(rrc_acquire_lock_for_pch_to_fach() == SUCCESS)
#endif /*FEATURE_DUAL_SIM*/
                  {
                    /* Send RRC_CHANNEL_CONFIG_REQ to RRC LLC to establish SRB */                
                  rrccu_substate = RRCCU_WAIT_FOR_SIB7_CURRENT;
                }
#ifdef FEATURE_DUAL_SIM
                  else
                  {
                    rrccu_process_oos_area_handling();
                  }
#endif /*FEATURE_DUAL_SIM*/   
                }
                else
#endif /*FEATURE_UPDATE_SIB7_FOR_PCH_TO_FACH*/
                {              
                  rrctmr_stop_timer(RRCTMR_T_307_TIMER);
#ifdef FEATURE_DUAL_SIM
                  if(rrc_acquire_lock_for_pch_to_fach() == SUCCESS)
#endif /*FEATURE_DUAL_SIM*/
                  {
                    /* Send RRC_CHANNEL_CONFIG_REQ to RRC LLC to establish SRB */                
                  rrccu_establish_srb(TRUE, RRC_STATE_CELL_FACH, TRUE);
                  rrccu_substate = RRCCU_WAIT_FOR_RB0_EST_CNF;
                }
#ifdef FEATURE_DUAL_SIM
                  else
                  {
                    rrccu_process_oos_area_handling();
                  }
#endif /*FEATURE_DUAL_SIM*/   
                }
              }
             rrccu_is_bplmn_suspend_retried = FALSE;
            }
            /* Check if BPLMN suspend is retried already. If not retry BPLMN suspend
            Scenario : IN PCH state, Due to BPLMN, if CSP is waiting for ACQ Confirm, Now if UL data gets trigered
            CU tries to suspend BPLMN. Simultaneously CS call gets triggered and then DT tries to suspend BPLMN.
            In this scenario CU gets a BPLMN Suspend failure and DT suspend request gets stored by CSP.
            In such cases if CU can retry BPLMN instead of error fatal.            
           */
            else if ((!rrccu_is_bplmn_suspend_retried) && (rrc_csp_bplmn_srch_in_progress() != WTOW_SEARCH_STOP ))
           {
#ifdef FEATURE_UPDATE_SIB7_FOR_PCH_TO_FACH
             /* Stop timer T305 */
             rrctmr_stop_timer(RRCTMR_T_305_TIMER);
#endif /*FEATURE_UPDATE_SIB7_FOR_PCH_TO_FACH*/           
             WRRC_MSG0_HIGH("BPLMN search in progess. Abort before sending CU");
             /* Important:  Always set CU substate before calling func send bplmn suspend
              * req 
              */
             rrccu_substate = RRCCU_WAIT_FOR_BPLMN_SUSPEND_CNF;
             rrc_csp_send_bplmn_suspend_req(RRC_PROCEDURE_CU, BPLMN_SUSPEND_REASON_OTHER); 
             
             rrccu_is_bplmn_suspend_retried = TRUE;
            }
            else
            {
              ERR_FATAL("ERR CSP sent SUSPEND_CNF with status FAILURE", 0, 0, 0);
            }
            break;

          case RRC_T305_EXPIRED_IND:
            /* start the timer T307  and remain in the same substate */
            rrctmr_start_timer(RRCTMR_T_307_TIMER, 
                               rrccu_convert_t307_to_ms( RRC_GET_T307() ) );
            break;

          case RRC_T307_EXPIRED_IND:
            /* stop the oos timer */
            rrctmr_stop_timer(RRCTMR_T_OOS_TIMER);
            /* Since Timer T307 expired after T305 are expired, 
            bring down the RRC Connection */
            rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                                 RRC_TX_TO_DISCON_OTHER);
            /* Update the release cause */
            rrc_release_cause = RRC_REL_DEEP_FADE;
            rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
            WRRC_MSG0_HIGH("RRC Conn Released since T307 & T305 expired.");
            break;

          case RRC_CPHY_OUT_OF_SERVICE_AREA_IND:
            event_report(EVENT_WCDMA_OUT_OF_SERVICE);
            /* Just remap the cause here... Don't start T316*/
            rrccu_ura_update_started = FALSE;
            rrccu_cell_update_started = TRUE;

            rrccu_cell_update_cause = 
              rrccu_map_cu_cause_based_on_priority(RRC_REENTERED_SERVICE_AREA);

            break;

          case RRC_CELL_UPDATE_INITIATE_REQ:
            break;

          case RRC_NEW_CELL_IND:
            if (rrccu_cell_update_started) 
            {
              rrccu_cell_update_cause = 
                rrccu_map_cu_cause_based_on_priority(RRC_CELL_RESELECTION);
            }
            else
            {
              if (rrccu_check_for_ura_reselection())
              {
                /* set Cell_update_started flag here */
                rrccu_ura_update_cause = rrc_URA_UpdateCause_changeOfURA;
              }
            }
            break;

          case RRC_SIB_CHANGE_IND:
            WRRC_MSG2_HIGH("SIB modification state:%d, cu_state:%d",
                     current_rrc_state, rrccu_substate);
            if (rrccu_ura_update_started)
            {              
              if (RRC_STATE_URA_PCH == current_rrc_state)
              {
                /* This function would check if a URA reselection occurred */
                if (rrccu_check_for_ura_reselection())
                {
                  /* Update URA Update cause */
                  rrccu_ura_update_cause = rrc_URA_UpdateCause_changeOfURA;      
                }
              }
            }
            break;

          default:
            WRRC_MSG1_ERROR("Unexpected UE state and cmd %d ",cmd_ptr->cmd_hdr.cmd_id);
            break;
        }
        break;
      default:
        WRRC_MSG1_ERROR("Unexpected UE state and cmd %d",cmd_ptr->cmd_hdr.cmd_id);
        break;
    }
}

/*===========================================================================

FUNCTION RRCCU_PROCESS_RLC_STATUS_IND

DESCRIPTION
  This function processes RRC_CRLC_STATUS_IND command received from RLC
  when RLC reset is occured.

  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
void rrccu_process_rlc_status_ind
(    
  rrc_cmd_type *cmd_ptr
)
{
   rrc_state_e_type rrc_state;
   rrc_RB_Identity ul_rb_id;
   rrccu_status_e_type status;

   MSG_HIGH("RLC RESET type:%d,LC_id:%d,dir:%d", 
        cmd_ptr->cmd.crlc_status_ind.error_type,
        cmd_ptr->cmd.crlc_status_ind.lc_id,
        cmd_ptr->cmd.crlc_status_ind.direction);

   if ((cmd_ptr->cmd.crlc_status_ind.error_type == RLC_RESET_FAIL) &&
      (cmd_ptr->cmd.crlc_status_ind.direction == TRUE))
   {

         /* In case Of RLC Unrecoverable error , abort the Reading of SIB
          * in DCH mode
          */
     if((rrc_get_state() == RRC_STATE_CELL_DCH ) && (rrc_sib_is_current_event_sib_read_in_dch()))      
     {
       WRRC_MSG0_HIGH("RRCGPS: Force Init GPS ");
       rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_SIB_READ_IN_DCH);
     }
     status = rrccu_validate_rrc_status_for_failure_handling(cmd_ptr, rrc_CellUpdateCause_rlc_unrecoverableError);
     
     /* check whether due to any restrictions we need to enter idle */
     if (status != RRCCU_SUCCESS)
     {
       if(status == RRCCU_PENDING_CONFIG)
       {
         return; 
       }
       else
       {
         rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                              RRC_TX_TO_DISCON_OTHER);
         /* Update the release cause */
         rrc_release_cause = RRC_REL_DEEP_FADE;
         rrccu_substate    = RRCCU_WAIT_FOR_RB_REL_CNF;
         }
     }
     /* no restrictions so go ahead with cell update initiation */
     else
     {
       /* set Cell_update_started flag here */
       rrccu_cell_update_started = TRUE;
       rrccu_cell_update_cause   = rrc_CellUpdateCause_rlc_unrecoverableError;
       /* store the current rrc state when failure was indicated */
       rrccu_failure_state       = rrc_get_state();

       /* get the RB id corresponding to the logical channel id and 
       store in in the rlc error info which will be later used to 
       populate cell update message */
       ul_rb_id = rrclcm_get_ul_rb_id (cmd_ptr->cmd.crlc_status_ind.lc_id);
       WRRC_MSG1_HIGH("rlc error on RB id %d", ul_rb_id);
       if ((ul_rb_id >= DCCH_AM_RADIO_BEARER_ID) && 
           (ul_rb_id <= DCCH_DT_LOW_PRI_RADIO_BEARER_ID))
       {
         rrccu_rlc_error_info.error_on_srb = TRUE;
       }
       else
       {
         rrccu_rlc_error_info.error_on_urb = TRUE;
       }
       rrc_state = rrc_get_state();
       if (rrc_state == RRC_STATE_CELL_DCH)
       {
         /*process re-establishment timers and act accordingly */
         rrccu_process_re_est_timers(FALSE);
       }
       else
       {
         /* If RLC reset is happening, and cell transition req is 
          * Q-ed onto LLC queue, dequeue cmd from llc queue so to 
          * take care of re-selection, then wait for New cell ind
          * before sending CELL UPDATE msg to NW.
          */
         if (rrcccm_waiting_for_reselection_cnf()) 
         {
           WRRC_MSG0_HIGH("CCM waiting for reselection cnf.  D-q from LLC q");
           rrcllc_dequeue_cmd();
           rrccu_substate = RRCCU_WAIT_FOR_UE_TO_CAMP_ON;
           return;
         }
#ifdef FEATURE_WCDMA_HS_FACH
         if(rrcenhstate_camped_cell_supports_e_fach() == TRUE)
         {
           rrcllc_establish_srb_rab_in_efach(RRC_E_FACH_COMMON,RRC_PROCEDURE_CU,FALSE);
           rrccu_substate = RRCCU_WAIT_FOR_RB0_EST_CNF;
         }
         else
#endif
         {
           /* call the function that takes care of both sending the cellupdate
           and starting T302 */
           rrccu_resend_cell_update_msg(RRCCU_NOT_INCLUDE_FAILURE_CAUSE);
         }
       }
     }
#ifdef FEATURE_QSH_EVENT_METRIC
     rrccu_qsh_log_rlf_params(SYS_RLF_WEAK_SIGNAL_L2_FAILURE);
#endif  
   }
} /* rrccu_process_rlc_status_ind */

/*===========================================================================

FUNCTION rrccu_process_rlc_status_ind_in_non_initial_sub_states

DESCRIPTION
  This function processes RRC_CRLC_STATUS_IND command received from RLC
  when RLC reset is occured.

  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
void rrccu_process_rlc_status_ind_in_non_initial_sub_states
(    
  rrc_cmd_type *cmd_ptr
)
{
   rrc_RB_Identity ul_rb_id;
   /* In the current release, rrc does not support cell update with
      RLC unrecoverable error cause. Hence bring down  RRC Connection */
   rrccu_status_e_type status;
   MSG_5(MSG_SSID_DFLT, MSG_LEGACY_HIGH,"RLC RESET type:%d,LC_id:%d,dir:%d, rrc_state: %d, cu_substate: %d",
        cmd_ptr->cmd.crlc_status_ind.error_type,
        cmd_ptr->cmd.crlc_status_ind.lc_id,
        cmd_ptr->cmd.crlc_status_ind.direction, rrc_get_state(), rrccu_substate);

   if ((cmd_ptr->cmd.crlc_status_ind.error_type == RLC_RESET_FAIL) &&
      (cmd_ptr->cmd.crlc_status_ind.direction == TRUE))
   {
     if ((rrccu_substate == RRCCU_WAIT_FOR_RB_EST_CNF) ||
         (rrccu_substate == RRCCU_WAIT_FOR_SRB2_RE_EST_CNF)||
         (rrccu_substate == RRCCU_WAIT_FOR_RNTI_UPDATE_CNF))
     {
       /* enter idle */
       rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                            RRC_TX_TO_DISCON_OTHER);
         /* Update the release cause */
         rrc_release_cause = RRC_REL_DEEP_FADE;
         rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
       return;
     }
     /* get the RBid mapped to the logical channel id on which
     RLC unrecoverable error was reported */
     ul_rb_id = rrclcm_get_ul_rb_id (cmd_ptr->cmd.crlc_status_ind.lc_id);
     if ((ul_rb_id >= DCCH_AM_RADIO_BEARER_ID) && 
         (ul_rb_id <= DCCH_DT_LOW_PRI_RADIO_BEARER_ID))
     {
       rrccu_rlc_error_info.error_on_srb = TRUE;
     }
     else
     {
       rrccu_rlc_error_info.error_on_urb = TRUE;
     }
     /* check whether the cell update is active due to cause
     RLC unrecoverable error or rl failure or re-entering service area
     in that case just update the RLC failure info and continue in the
     same substate*/
     /* check whether due to any restrictions we need to enter idle */
     if ((rrccu_cell_update_cause == rrc_CellUpdateCause_radiolinkFailure) ||
         (rrccu_cell_update_cause == rrc_CellUpdateCause_re_enteredServiceArea) ||
         (rrccu_cell_update_cause == rrc_CellUpdateCause_rlc_unrecoverableError)) 
     {
       WRRC_MSG2_HIGH("Continue with old cause:%d, cu_st:%d", 
                rrccu_cell_update_cause,rrccu_substate);
       switch (rrccu_substate)
       {
         case  RRCCU_WAIT_FOR_UE_TO_CAMP_ON:
         case  RRCCU_WAIT_FOR_RB1_RB4_EST_CNF:
           /* continue in the same substate */
           break;
         default:
           rrccu_resend_cell_update_msg(RRCCU_NOT_INCLUDE_FAILURE_CAUSE);
           break;
       }
     }
     /* cell update was active due to some low priority cause 
     override the cause with rlc unrecoverable error */
     else
     {
       /* check whether any restrictions for this cause */
       /* if there are any restrictions continue with the current
       cell update proc */
       status = rrccu_validate_rrc_status_for_failure_handling(cmd_ptr, rrc_CellUpdateCause_rlc_unrecoverableError);
       if (status == RRCCU_SUCCESS)
       {
         rrccu_cell_update_cause = rrc_CellUpdateCause_rlc_unrecoverableError;
         switch (rrccu_substate)
         {
           case  RRCCU_WAIT_FOR_UE_TO_CAMP_ON:
           case  RRCCU_WAIT_FOR_RB1_RB4_EST_CNF:
             /* continue in the same substate */
             break;

           case  RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM:
             rrccu_resend_cell_update_msg(RRCCU_NOT_INCLUDE_FAILURE_CAUSE);
             break;

           case  RRCCU_WAIT_FOR_URA_UPDATE_CONFIRM:
           case  RRCCU_WAIT_FOR_L2_ACK:
             if (rrccu_ura_update_started == TRUE)
             {
               /* Need override ura-update procedure */
               rrccu_ura_update_started  = FALSE;
               rrccu_cell_update_started = TRUE;
             }
             rrccu_resend_cell_update_msg(RRCCU_NOT_INCLUDE_FAILURE_CAUSE);
             break;

           default:
             WRRC_MSG2_ERROR("RLC reset not handled in cu_st:%d rrc_st:%d",
                 rrccu_substate, rrc_get_state());
             break;
         }
       }
       else
       {
         /* Transition to Idle if security is active*/
         WRRC_MSG2_ERROR("Transition to disconnected RLC reset received when security is active, CU substate %d rrc_state %d",
           rrccu_substate, rrc_get_state());
         /* enter idle */
         rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                            RRC_TX_TO_DISCON_OTHER);
         /* Update the release cause */
         rrc_release_cause = RRC_REL_DEEP_FADE;
         rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
         return;         
       }  
     }
   }
} /* rrccu_process_rlc_status_ind_in_non_initial_sub_states */

#ifdef FEATURE_UPDATE_SIB7_FOR_PCH_TO_FACH
/*===========================================================================
FUNCTION rrccu_process_cu_wait_for_sib7_current

DESCRIPTION
  This function processes commands for CU procedure when CU is in substate
  RRCCU_WAIT_FOR_SIB7_CURRENT.
  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS
  None
===========================================================================*/
static void rrccu_process_cu_wait_for_sib7_current
(
  rrc_cmd_type *cmd_ptr
)
{
  rrc_state_e_type current_rrc_state = rrc_get_state();

  switch(current_rrc_state)
  {
    case RRC_STATE_CELL_PCH:
    case RRC_STATE_URA_PCH:
      switch(cmd_ptr->cmd_hdr.cmd_id)
      {
        case RRC_SIB7_UPDATE_STATUS_IND:
          /*Right now we are not interested in the status of SIB7 Indication.
          Because SIB proc would have prioritized the SIB7 update request from CU 
          and would have sent UPDATE_STATUS_IND anyway.*/
          WRRC_MSG0_HIGH("SIB7 updated for PCH->FACH transition");

          if(rrccu_cell_update_started || rrccu_ura_update_started)
          {
            rrccu_establish_srb(TRUE, RRC_STATE_CELL_FACH, TRUE);
            rrccu_substate = RRCCU_WAIT_FOR_RB0_EST_CNF;     
          }
          else
          {
            WRRC_MSG0_ERROR("We should not encounter this!Reset CU proc.");
            rrccu_substate = RRCCU_INITIAL;
            rrccu_clear_procedure();
          }
          break;

        case RRC_CELL_UPDATE_INITIATE_REQ:
          if(RRCCU_SUCCESS == rrccu_validate_cell_update_initiate_req(cmd_ptr)) 
          {
            if((cmd_ptr->cmd.initiate_cell_update.cause == RRC_REENTERED_SERVICE_AREA) &&
              ((cmd_ptr->cmd.initiate_cell_update.procedure == RRC_PROCEDURE_CSP)||
              (cmd_ptr->cmd.initiate_cell_update.procedure == RRC_PROCEDURE_SIB)))
            {
              rrccu_process_oos_area_handling();
              return;
            }
  
            /* set Cell_update_started flag here */
            rrccu_cell_update_started = TRUE;
  
            rrccu_cell_update_cause = 
              rrccu_map_cu_cause_based_on_priority(cmd_ptr->cmd.initiate_cell_update.cause);
  
            /*If CU proc is waiting for SIB7, BPLMN shouldn't be active. if so abort BPLMN search.*/
            if(rrc_csp_bplmn_srch_in_progress() != WTOW_SEARCH_STOP) 
            {
              /* Stop timer T305 */
              rrctmr_stop_timer(RRCTMR_T_305_TIMER);
  
              WRRC_MSG0_HIGH("BPLMN search in progess. Abort before sending CU");
              rrccu_substate = RRCCU_WAIT_FOR_BPLMN_SUSPEND_CNF;
              rrc_csp_send_bplmn_suspend_req(RRC_PROCEDURE_CU, BPLMN_SUSPEND_REASON_OTHER); 
            }
            else
            {
              WRRC_MSG0_HIGH("Updated CU cause and wait for SIB7 to be current.");
#ifdef FEATURE_DUAL_SIM
                  if(rrc_acquire_lock_for_pch_to_fach() == SUCCESS)
#endif /*FEATURE_DUAL_SIM*/
                  {
                    /* Send RRC_CHANNEL_CONFIG_REQ to RRC LLC to establish SRB */                
              rrccu_substate = RRCCU_WAIT_FOR_SIB7_CURRENT;            
            }
#ifdef FEATURE_DUAL_SIM
                  else
                  {
                    rrccu_process_oos_area_handling();
                  }
#endif /*FEATURE_DUAL_SIM*/   			  
            }
          }
          break;

        case RRC_URA_UPDATE_INITIATE_REQ:
          /*Think of the case when CU in in this substate becuse of doing INITIATE_CELL_UPDATE_REQ
          and while CU is waiting here, CU gets INITIATE_URA_UPDATE_REQ. In that case,
          we are doing the second one i.e. URA_UPDATE. The other way can also happen*/
          if(RRCCU_SUCCESS == rrccu_validate_ura_update_initiate_req(cmd_ptr)) 
          {
            if (rrccu_ura_update_required)
            {
              rrccu_ura_update_required = FALSE;
            }
            else if (cmd_ptr->cmd.initiate_ura_update.procedure != RRC_PROCEDURE_CU)
            {
              /* in case of rrccu procedure originated ura update this flag will be cleared
              by this time because of clear procedure is called after initiating ura update 
              So it is ok if flag is set to zero */
              WRRC_MSG0_ERROR("URA update flag is not set");
            }
  
            /* set Cell_update_started flag here */
            rrccu_ura_update_started = TRUE;
  
            /* Stop timer T305 */
            rrctmr_stop_timer(RRCTMR_T_305_TIMER);
  
            /* Update ura Update cause */
            rrccu_ura_update_cause = 
              rrccu_map_uu_initiation_cause(cmd_ptr->cmd.initiate_ura_update.cause);
  
            /*If CU proc is waiting for SIB7, BPLMN shouldn't be active. if so abort BPLMN search.*/
            if(rrc_csp_bplmn_srch_in_progress() != WTOW_SEARCH_STOP) 
            {
              WRRC_MSG0_HIGH("BPLMN search in progess.  Abort before sending CU");
              rrccu_substate = RRCCU_WAIT_FOR_BPLMN_SUSPEND_CNF;
              rrc_csp_send_bplmn_suspend_req(RRC_PROCEDURE_CU, BPLMN_SUSPEND_REASON_OTHER); 
            }
            else
            {
              {
              /* Send RRC_CHANNEL_CONFIG_REQ to RRC LLC to establish SRB */
              rrccu_establish_srb(TRUE, RRC_STATE_CELL_FACH, TRUE);
              rrccu_substate = RRCCU_WAIT_FOR_RB0_EST_CNF; 
              }
            }
          }
          break;

        case RRC_NEW_CELL_IND:
          if (RRC_STATE_CELL_PCH == current_rrc_state)
          {
            /* set Cell_update_started flag here */
            rrccu_cell_update_started = TRUE;
            WRRC_MSG2_HIGH("Cell reselection in state:%d, cu_state:%d", current_rrc_state, rrccu_substate);

            /* Stop timer T305 */
            rrctmr_stop_timer(RRCTMR_T_305_TIMER);

            /* Update Cell Update cause */
            rrccu_cell_update_cause = rrccu_map_cu_cause_based_on_priority(RRC_CELL_RESELECTION);

            /* Check if BPLMN is in progress.  If so abort*/
            if (rrc_csp_bplmn_srch_in_progress() != WTOW_SEARCH_STOP ) 
            {
              WRRC_MSG0_HIGH("BPLMN search in progess.  Abort before sending CU");
              rrccu_substate = RRCCU_WAIT_FOR_BPLMN_SUSPEND_CNF;
              rrc_csp_send_bplmn_suspend_req(RRC_PROCEDURE_CU, BPLMN_SUSPEND_REASON_OTHER); 
            }
            else
            {
               {
              /* Send RRC_CHANNEL_CONFIG_REQ to RRC LLC to establish SRB */
              rrccu_establish_srb (TRUE, RRC_STATE_CELL_FACH, TRUE);
              rrccu_substate = RRCCU_WAIT_FOR_RB0_EST_CNF; 
              }
            }
          }
          else /* current state is URA_PCH */
          {
            /* This function would check if a URA reselection occurred */
            if (rrccu_check_for_ura_reselection())
            {
              /* set Cell_update_started flag here */
              rrccu_ura_update_started = TRUE;
              /* Stop timer T305 */
              rrctmr_stop_timer(RRCTMR_T_305_TIMER);
              /* Update URA Update cause */
              rrccu_ura_update_cause = rrc_URA_UpdateCause_changeOfURA;

              /* Check if BPLMN is in progress.  If so abort*/
              if (rrc_csp_bplmn_srch_in_progress() != WTOW_SEARCH_STOP ) 
              {
                WRRC_MSG0_HIGH("BPLMN search in progess.  Abort before sending CU");
                rrccu_substate = RRCCU_WAIT_FOR_BPLMN_SUSPEND_CNF;
                rrc_csp_send_bplmn_suspend_req(RRC_PROCEDURE_CU, BPLMN_SUSPEND_REASON_OTHER); 
              }
              else
              {
                 {
                /* Send RRC_CHANNEL_CONFIG_REQ to RRC LLC to establish SRB */
                rrccu_establish_srb(TRUE, RRC_STATE_CELL_FACH, TRUE);
                rrccu_substate = RRCCU_WAIT_FOR_RB0_EST_CNF; 
                }
              }
            }
          }
          break;

        case RRC_SIB_CHANGE_IND:
          WRRC_MSG2_HIGH("SIB modification state:%d, cu_state:%d",
                   current_rrc_state, rrccu_substate);
          if (RRC_STATE_URA_PCH == current_rrc_state)
          {
            /* This function would check if a URA reselection occurred */
            if (rrccu_check_for_ura_reselection())
            {
              /* set Cell_update_started flag here */
              rrccu_ura_update_started = TRUE;
              /* Stop timer T305 */
              rrctmr_stop_timer(RRCTMR_T_305_TIMER);
              /* Update URA Update cause */
              rrccu_ura_update_cause = rrc_URA_UpdateCause_changeOfURA;
              
              /* Check if BPLMN is in progress.  If so abort*/
              if (rrc_csp_bplmn_srch_in_progress() != WTOW_SEARCH_STOP ) 
              {
                WRRC_MSG0_HIGH("BPLMN search in progess. Abort before sending CU");
                /* Important:  Always set CU substate before calling func send bplmn suspend
                 * req 
                 */
                rrccu_substate = RRCCU_WAIT_FOR_BPLMN_SUSPEND_CNF;
                rrc_csp_send_bplmn_suspend_req(RRC_PROCEDURE_CU, BPLMN_SUSPEND_REASON_OTHER); 
              }
              else
              {
                 {
                     /* Send RRC_CHANNEL_CONFIG_REQ to RRC LLC to establish SRB */
                rrccu_establish_srb(TRUE, RRC_STATE_CELL_FACH, TRUE);
                rrccu_substate = RRCCU_WAIT_FOR_RB0_EST_CNF;
                } 
             } 
            }
            else
            {
              /*We might come here - periodic UU needs to be done and then SIB CHANGE IND needed.*/
              WRRC_MSG0_ERROR("UU isn't needed yet CU is here. something wrong");
            }
          }
          else
          {
            /*The fact we are waiting in this sub-state, it means that we need to do cell update*/
            /* set Cell_update_started flag here */
            rrccu_ura_update_started = TRUE;
            /* Stop timer T305 */
            rrctmr_stop_timer(RRCTMR_T_305_TIMER);
                
            rrccu_establish_srb(TRUE, RRC_STATE_CELL_FACH, TRUE);
            rrccu_substate = RRCCU_WAIT_FOR_RB0_EST_CNF;
             }
          break;

        case RRC_CPHY_OUT_OF_SERVICE_AREA_IND:
          rrccu_process_oos_area_handling();
          break;

        case RRC_T305_EXPIRED_IND:
          if (RRC_STATE_CELL_PCH == current_rrc_state)
          {
            /* set Cell_update_started flag here */
            rrccu_cell_update_started = TRUE;
            /* Update Cell Update cause */
            rrccu_cell_update_cause = rrccu_map_cu_cause_based_on_priority(RRC_PERIODIC_CELL_UPDATE);
          }
          else /* current state is URA_PCH */
          {
            /* set ura_update_started flag here */
            rrccu_ura_update_started = TRUE;
            /* Update URA Update cause */
            rrccu_ura_update_cause = rrc_URA_UpdateCause_periodicURAUpdate;
          }
          /* Stop timer T305 */
          rrctmr_stop_timer(RRCTMR_T_305_TIMER);
          /* Check if BPLMN is in progress.  If so abort*/
          if (rrc_csp_bplmn_srch_in_progress() != WTOW_SEARCH_STOP ) 
          {
            WRRC_MSG1_HIGH("BPLMN search in progess.  Abort before sending CU, Start T307 %d",rrccu_convert_t307_to_ms(RRC_GET_T307()));
            /* start the timer T307  and remain in the same substate */
            rrctmr_start_timer(RRCTMR_T_307_TIMER, 
                              rrccu_convert_t307_to_ms( RRC_GET_T307() ) );
            rrccu_substate = RRCCU_WAIT_FOR_BPLMN_SUSPEND_CNF;
            rrc_csp_send_bplmn_suspend_req(RRC_PROCEDURE_CU, BPLMN_SUSPEND_REASON_OTHER); 
          }
          else
          {
             {
            /* Send RRC_CHANNEL_CONFIG_REQ to RRC LLC to establish SRB */
            rrccu_establish_srb(TRUE, RRC_STATE_CELL_FACH, TRUE);
            rrccu_substate = RRCCU_WAIT_FOR_RB0_EST_CNF; 
             }
          }
          break;

        default:
          WRRC_MSG1_ERROR("Cmd %d not handled in PCH state",cmd_ptr->cmd_hdr.cmd_id);
      }
      break;

    default:
      /*Basically the idea is not to handle any command if CU is in this substate. Beacuse UE is already
      out of Cell_PCH/URA_PCH. And there's no point in waiting for SIB7. But SIB proc should have given
      RRC_SIB7_UPDATE_STATUS_IND by now.*/

      /*Later we need to consider the following scenarios in Cell_FACH state:
      1. In Cell_FACH state, setting up of SRB0 and CU is not initiated bcoz we reset the CU state machine here.
      2. Commands like OOS Ind etc are ignored while UE in Cell_FACH state and CU is in this substate
      But ignoring commands in other RRC states such as Cell_DCH may be fine.*/
      WRRC_MSG2_ERROR("Invalid Cmd %d in RRC state %d! Reset CU proc.",cmd_ptr->cmd_hdr.cmd_id,rrc_get_state());
      rrccu_substate = RRCCU_INITIAL;
      rrccu_clear_procedure();
  }
  return;
}
#endif /*FEATURE_UPDATE_SIB7_FOR_PCH_TO_FACH*/

/*===========================================================================

FUNCTION rrccu_get_max_timer_t314_t315

DESCRIPTION
  This procedure returns the max timer value between t-314 and t-315.  

DEPENDENCIES
  None.

RETURN VALUE
  uint32.  Returns 0 if neither timers are started.

===========================================================================*/
uint32 rrccu_get_max_timer_t314_t315( void )
{
  uint32 timer_314 = rrccu_convert_t314_to_ms(RRC_GET_T314());
  uint32 timer_315 = rrccu_convert_t315_to_ms(RRC_GET_T315());

  if ((rrccu_rl_failure_info.t314_info.timer_status == RE_EST_TIMER_STARTED) &&
      (rrccu_rl_failure_info.t315_info.timer_status == RE_EST_TIMER_STARTED))
  {
    if (timer_314 >= timer_315)
    {
      return timer_314;
    }
    else 
    {
      return timer_315;
    }                 
  }
  else if (rrccu_rl_failure_info.t314_info.timer_status == RE_EST_TIMER_STARTED)
  {
    return timer_314;
  }
  else if (rrccu_rl_failure_info.t315_info.timer_status == RE_EST_TIMER_STARTED)
  {
    return timer_315;
  }
    
  return 0;
}   
/*===========================================================================

FUNCTION rrccu_map_cu_cause_on_priority_in_buffered_cu_init_req

DESCRIPTION
  This function maps the CU cause based on priority in rrccu_buffered_cu_initiate_req
  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/

static boolean rrccu_map_cu_cause_on_priority_in_buffered_cu_init_req(rrc_cell_update_cause_e_type cause)
{
  rrc_cell_update_cause_e_type new_cu_cause = RRC_CU_CAUSE_NONE;

  /* Check for Cell Update cause */
  switch (cause)
  {
    case RRC_UL_DATA_TRANSMISSION:
      /* UL DATA TRANSMISSION is the highest priority as per 8.3.1.2 */
      new_cu_cause = RRC_UL_DATA_TRANSMISSION;
      break;

    case RRC_PAGING_RESPONSE:
      /* Paging response has the second highest priority as per 8.3.1.2*/
      switch (rrccu_buffered_cu_initiate_req.cause)
      {
        case  RRC_UL_DATA_TRANSMISSION:
          new_cu_cause = rrccu_buffered_cu_initiate_req.cause;
          break;
        default:
          /* since the new cause has higher priority
          overwrite the old cause with the new one */
          new_cu_cause =  cause;
          break;
       }
       break;

    case RRC_RADIO_LINK_FAILURE:
    /* Paging response has the third highest priority as per 8.3.1.2*/
      switch (rrccu_buffered_cu_initiate_req.cause)
      {
        case  RRC_UL_DATA_TRANSMISSION:
        case  RRC_PAGING_RESPONSE:
          /* retain the previous cell update cause */
          new_cu_cause = rrccu_buffered_cu_initiate_req.cause;
          break;

        default:
          /* since the new cause has higher priority
          overwrite the old cause with the new one */
          new_cu_cause = cause;
          break;
      }
      break;

    case RRC_REENTERED_SERVICE_AREA:
      switch (rrccu_buffered_cu_initiate_req.cause)
      {
        case  RRC_UL_DATA_TRANSMISSION:
        case  RRC_PAGING_RESPONSE:
        case  RRC_RADIO_LINK_FAILURE:
          /* retain the previous cell update cause */
          new_cu_cause = rrccu_buffered_cu_initiate_req.cause;
          break;
        default:
          /* since the new cause has higher priority
          overwrite the old cause with the new one */
          new_cu_cause =  cause;
          break;
      }
      break;
      
      case RRC_UNRECOVERABLE_ERROR:
        switch (rrccu_buffered_cu_initiate_req.cause)
        {
          case  RRC_UL_DATA_TRANSMISSION:
          case  RRC_PAGING_RESPONSE:
          case  RRC_RADIO_LINK_FAILURE:
          case  RRC_REENTERED_SERVICE_AREA:
            /* retain the previous cell update cause */
            new_cu_cause = rrccu_buffered_cu_initiate_req.cause;
            break;
          default:
            /* since the new cause has higher priority
            overwrite the old cause with the new one */
            new_cu_cause =  cause;
            break;

         }
         break;


    case RRC_CELL_RESELECTION:
      switch (rrccu_buffered_cu_initiate_req.cause)
        {
          case  RRC_UL_DATA_TRANSMISSION:
          case  RRC_PAGING_RESPONSE:
          case  RRC_RADIO_LINK_FAILURE:
          case  RRC_REENTERED_SERVICE_AREA:
          case  RRC_UNRECOVERABLE_ERROR:
          new_cu_cause = rrccu_buffered_cu_initiate_req.cause;
          break;

        default:
          /* since the new cause has higher priority
          overwrite the old cause with the new one */
          new_cu_cause =  cause;
          break;
      }
      break;



    case RRC_PERIODIC_CELL_UPDATE:
      switch (rrccu_buffered_cu_initiate_req.cause)
        {
          case  RRC_UL_DATA_TRANSMISSION:
          case  RRC_PAGING_RESPONSE:
          case  RRC_RADIO_LINK_FAILURE:
          case  RRC_REENTERED_SERVICE_AREA:
          case  RRC_UNRECOVERABLE_ERROR:
          case  RRC_CELL_RESELECTION:
          /* retain the previous cell update cause */
          new_cu_cause = rrccu_buffered_cu_initiate_req.cause;
          break;
        default:
          /* since the new cause has higher priority
          overwrite the old cause with the new one */
          new_cu_cause =  cause;
          break;
      }
      break;
    default:
      ERR("unknown CU cause:%d", cause,0,0);
      break;
  }
  
  rrccu_buffered_cu_initiate_req.cause = new_cu_cause;

  MSG_HIGH("New CU cause:%d",new_cu_cause,0,0);

  if(rrccu_buffered_cu_initiate_req.cause != new_cu_cause && 
     (new_cu_cause != RRC_CU_CAUSE_NONE))
  {
    rrccu_buffered_cu_initiate_req.cause = new_cu_cause;
    /*Cause is overwritten*/
    return TRUE;
  }
  else
  {
    /*Old cause is retained*/
    return FALSE;
  }

}
  
/*===========================================================================

FUNCTION rrccu_buffer_commands_in_stand_by_mode

DESCRIPTION
  This function buffers the commands if RRC mode is stand by
  
DEPENDENCIES
  None

RETURN VALUE
  Returns true if command is buffered, returns false otherwise
  
SIDE EFFECTS

  None

===========================================================================*/
static boolean rrccu_buffer_commands_in_stand_by_mode
(
  rrc_cmd_type *cmd_ptr
)
{
  boolean status = FALSE;

  if(rrccu_is_cmd_buffering_required() == TRUE)
  {
    /*If RRC is in Stanby mode, buffer the commands now and repost after resuming WCDMA mode */
    WRRC_MSG1_HIGH("RRC mode is standby.command rcvd:rrc_cmd_e_type_value_0x%x",cmd_ptr->cmd_hdr.cmd_id);
    switch(cmd_ptr->cmd_hdr.cmd_id)
    {
      case RRC_CELL_UPDATE_INITIATE_REQ:
          if((rrccu_buffered_cmd_mask & CU_INITIATE_REQ) == 0)
          {
            rrccu_buffered_cmd_mask |= CU_INITIATE_REQ;
            rrccu_buffered_cu_initiate_req.procedure = cmd_ptr->cmd.initiate_cell_update.procedure;
            rrccu_buffered_cu_initiate_req.cause = cmd_ptr->cmd.initiate_cell_update.cause;
          }
          
          /*If there are multiple CU init requests in stand by state map the CU cause based on priority */
          else if(TRUE == rrccu_map_cu_cause_on_priority_in_buffered_cu_init_req(cmd_ptr->cmd.initiate_cell_update.cause))
          {
            /* Retain the procedure that initiated CU with high priority cause */
            rrccu_buffered_cu_initiate_req.procedure = cmd_ptr->cmd.initiate_cell_update.procedure;
          }
  
          /* Register the procedure for cell update complete confirm notification */
          if(cmd_ptr->cmd.initiate_cell_update.cu_complete_cnf_required)
          {
            (void)rrccu_register_for_cell_update_to_complete(cmd_ptr->cmd.initiate_cell_update.procedure);
          }
  
          MSG_HIGH("Buffered CU Initiate request with cause %d cnf requried %d procedure %d",
            rrccu_buffered_cu_initiate_req.cause,
            cmd_ptr->cmd.initiate_cell_update.cu_complete_cnf_required, 
            rrccu_buffered_cu_initiate_req.procedure );
  
          status = TRUE;
        break;
        
      case RRC_CRLC_STATUS_IND:
         if((cmd_ptr->cmd.crlc_status_ind.direction == TRUE) 
            && 
            (cmd_ptr->cmd.crlc_status_ind.error_type == RLC_RESET_FAIL))
        {
          rrccu_buffered_cmd_mask |= CRLC_STATUS_IND;
          rrccu_buffered_reset_ind.lc_id = cmd_ptr->cmd.crlc_status_ind.lc_id;
          status = TRUE;
        }
        break;
        
      case RRC_SIB_CHANGE_IND:
        rrccu_buffered_cmd_mask |= SIB_CHANGE_IND;
        status = TRUE;
        break;
        
      case RRC_T305_EXPIRED_IND:
        rrccu_buffered_cmd_mask |= T305_EXPIRY_IND;
        status = TRUE;
        break;

      default:
        break;

    }
  }
  return status;
}

/*===========================================================================

FUNCTION RRCCU_PROCESS_CELL_DCH_STATE

DESCRIPTION
  This function processes all events that are dispatched to Cell Update 
  procedure in CELL_DCH state of Connected  mode.

  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
void rrccu_process_cell_dch_state
(    
  rrc_cmd_type *cmd_ptr
)
{
  if ((cmd_ptr->cmd_hdr.cmd_id == RRC_DOWNLINK_L2ACK_IND) &&
      (rrccu_substate != RRCCU_WAIT_FOR_L2_ACK))
  {
    /* We could get L2ack for a previously sent message while we are already
    processing the next message. So l2ack could be received any any of the following
    substates. If rbrc substate does not indicate that we are not waiting for l2ack
    then just print the status */
    MSG_4(MSG_SSID_DFLT, MSG_LEGACY_HIGH,"L2ack status %d [0-SUCCESS, 1-FAILURE] for MUI:%d, Lc_Id:%d, cu_subst:%d",
         cmd_ptr->cmd.downlink_l2ack_ind.status,cmd_ptr->cmd.downlink_l2ack_ind.mui, 
         cmd_ptr->cmd.downlink_l2ack_ind.lc_id, rrccu_substate);

    /* return from here so that procedure can continue with existing process */
    return;
  }
  /* 
     Limit the buffering mechanism only to CRLC_STATUS_IND for now
     If required we can extend to other commands. Current logic can buffer 
     only one CRLC_STATUS_IND in stand by mode. 
     Logic should be updated to accomodate multiple CRLC_STATUS_IND
     during stand by state. 
  */
  if((cmd_ptr->cmd_hdr.cmd_id == RRC_CRLC_STATUS_IND) &&
     (rrccu_buffer_commands_in_stand_by_mode(cmd_ptr) == TRUE))
  {
    return;
  }

  if(cmd_ptr->cmd_hdr.cmd_id == RRC_CELL_UPDATE_INITIATE_REQ ||
      cmd_ptr->cmd_hdr.cmd_id == RRC_URA_UPDATE_INITIATE_REQ)
  {
    if(rrctmr_get_remaining_time(RRCTMR_T_319_TIMER) > 0)
    {
      rrctmr_stop_timer(RRCTMR_T_319_TIMER);
      rrcllc_update_drx_coef_length();
    }
    else
    {
      WRRC_MSG0_HIGH("Timer T319 not running");
    }
  }
    
  switch (rrccu_substate)
  {      
    case RRCCU_INITIAL:
      rrccu_process_cu_initial(cmd_ptr);
      break;
    case RRCCU_WAIT_FOR_UE_TO_CAMP_ON:
      rrccu_process_cu_wait_for_ue_to_camp_on(cmd_ptr);
      break;
    case RRCCU_WAIT_FOR_RNTI_UPDATE_CNF:
      rrccu_process_cu_wait_for_rnti_update_cnf(cmd_ptr);
      break;
    case RRCCU_WAIT_FOR_RB_EST_CNF:
      rrccu_process_cu_wait_for_rb_est_cnf(cmd_ptr);
      break;
    case RRCCU_WAIT_FOR_RB_REL_CNF:
      rrccu_process_cu_wait_for_rb_rel_cnf(cmd_ptr);
      break;
    case RRCCU_WAIT_FOR_L2_ACK:
      rrccu_process_cu_wait_for_l2_ack(cmd_ptr);
      break;
    case RRCCU_WAIT_FOR_PENDING_CONFIG:
      rrccu_process_cu_pending_config(cmd_ptr);
      break;
	  
    case RRCCU_WAIT_FOR_SRB2_RE_EST_CNF:
      rrccu_process_cu_wait_for_srb2_re_est_cnf(cmd_ptr);
      break;	
    default:
      WRRC_MSG2_ERROR("Invalid CU st %d for Cell_DCH for cmd %d",rrccu_substate,cmd_ptr->cmd_hdr.cmd_id);
      break; 
  }
} /* rrccu_process_cell_dch_state */
/*===========================================================================

FUNCTION RRCCU_PROCESS_CELL_FACH_STATE

DESCRIPTION
  This function processes all events that are dispatched to Cell Update 
  procedure in CELL_FACH state of Connected  mode.

  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
void rrccu_process_cell_fach_state
(  
  rrc_cmd_type *cmd_ptr
)
{
  if(cmd_ptr->cmd_hdr.cmd_id == RRC_CELL_UPDATE_INITIATE_REQ ||
      cmd_ptr->cmd_hdr.cmd_id == RRC_URA_UPDATE_INITIATE_REQ)
  {
    if(rrctmr_get_remaining_time(RRCTMR_T_319_TIMER) > 0)
    {
      rrctmr_stop_timer(RRCTMR_T_319_TIMER);
      rrcllc_update_drx_coef_length();
    }
  }
  if ((cmd_ptr->cmd_hdr.cmd_id == RRC_DOWNLINK_L2ACK_IND) &&
      (rrccu_substate != RRCCU_WAIT_FOR_L2_ACK))
  {
    /* We could get L2ack for a previously sent message while we are already
    processing the next message. So l2ack could be received any any of the following
    substates. If rbrc substate does not indicate that we are not waiting for l2ack
    then just print the status */

    MSG_4(MSG_SSID_DFLT, MSG_LEGACY_HIGH,"L2ack status %d [0-SUCCESS, 1-FAILURE] for MUI:%d, Lc_Id:%d, cu_subst:%d",
          cmd_ptr->cmd.downlink_l2ack_ind.status,cmd_ptr->cmd.downlink_l2ack_ind.mui, 
          cmd_ptr->cmd.downlink_l2ack_ind.lc_id, rrccu_substate);
    /* return from here so that procedure can continue with existing process */
    return;
  }

  if(rrccu_get_hsrach_sib_change() == TRUE &&
     /*Ensure that Cell Update has been started before re-setting the delay CU status.
       All commands posted to CU may not initiate CU, ex: CRLC_STATUS_IND with success 
       Also note that there will be a slight overlap where SIB5 delay is active and cell update 
       has been started( as delay cell update flag is not reset immediately when substate 
       changes but at the next command posted to CU). Having this overlap will allow a more
       robust handling when reconfiguration OTA's are in race with UL data indication due to
       L2 acks.
      */
     rrccu_get_cell_update_started_status() == RRCCU_STARTED )
  {
    rrccu_set_hsrach_sib_change(FALSE);
    rlc_ul_reg_data_ind_in_fach(RLC_UNREG_DATA_IND_IN_FACH);
  }

  switch (rrccu_substate)
  {      
    case RRCCU_INITIAL:
      rrccu_process_cu_initial(cmd_ptr);
      break;
    case RRCCU_WAIT_FOR_UE_TO_CAMP_ON:
      rrccu_process_cu_wait_for_ue_to_camp_on(cmd_ptr);
      break;
    case RRCCU_WAIT_FOR_RB0_EST_CNF:
      rrccu_process_cu_wait_for_rb0_est_cnf(cmd_ptr);
      break;
    case RRCCU_WAIT_FOR_RB1_RB4_EST_CNF:
      rrccu_process_cu_wait_for_rb1_rb4_est_cnf(cmd_ptr);
      break;
    case RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM:
      rrccu_process_cu_wait_for_cell_update_confirm(cmd_ptr);
      break;
    case RRCCU_WAIT_FOR_RNTI_UPDATE_CNF:
      rrccu_process_cu_wait_for_rnti_update_cnf(cmd_ptr);
      break;
    case RRCCU_WAIT_FOR_RB_EST_CNF:
      rrccu_process_cu_wait_for_rb_est_cnf(cmd_ptr);
      break;
    case RRCCU_WAIT_FOR_RB_REL_CNF:
      rrccu_process_cu_wait_for_rb_rel_cnf(cmd_ptr);
      break;
    case RRCCU_WAIT_FOR_L2_ACK:
      rrccu_process_cu_wait_for_l2_ack(cmd_ptr);
      break;
    case RRCCU_WAIT_FOR_SRB2_RE_EST_CNF:
      rrccu_process_cu_wait_for_srb2_re_est_cnf(cmd_ptr);
      break;
    case RRCCU_WAIT_FOR_URA_UPDATE_CONFIRM:
      rrccu_process_cu_wait_for_ura_update_confirm(cmd_ptr);
      break;
    case RRCCU_WAIT_FOR_PCCH_RB_EST_CNF:
      rrccu_process_cu_wait_for_pcch_rb_est_cnf(cmd_ptr);
      break;
    case RRCCU_WAIT_FOR_PENDING_CONFIG:
      rrccu_process_cu_pending_config(cmd_ptr);
      break;

    case RRCCU_WAIT_FOR_RB_PROC_COMPL_IND:
      rrccu_process_cu_wait_for_rb_proc_compl_ind(cmd_ptr);
      break;

#ifdef FEATURE_UPDATE_SIB7_FOR_PCH_TO_FACH
    case RRCCU_WAIT_FOR_SIB7_CURRENT:
      rrccu_process_cu_wait_for_sib7_current(cmd_ptr);
      break;
#endif /*FEATURE_UPDATE_SIB7_FOR_PCH_TO_FACH*/  

    default:
      WRRC_MSG2_ERROR("Invalid CU st %d for CELL_FACH for cmd %d",rrccu_substate,cmd_ptr->cmd_hdr.cmd_id);
      break; 
  }
} /* rrccu_process_cell_fach_state */
/*===========================================================================

FUNCTION RRCCU_PROCESS_DISCONNECTED_STATE

DESCRIPTION
  This function processes all events that are dispatched to Cell Update 
  procedure in DISCONNECTED state of Idle  mode.

  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
void rrccu_process_disconnected_state
(  
  rrc_cmd_type *cmd_ptr
)
{   

  if(cmd_ptr->cmd_hdr.cmd_id == RRC_STATE_CHANGE_IND)
  {
    /* On a change of state to Disconnected, clear the
     * Cell Update substate upfront, irrespective of 
     * current Cell Update substate. This is to 
     * rule out any possibility of a "hung" Cell Update.
     */
    if(cmd_ptr->cmd.state_change_ind.new_state ==
        RRC_STATE_DISCONNECTED)
    {
      rrctmr_stop_timer(RRCTMR_T_305_TIMER);

      rrctmr_stop_timer(RRCTMR_T_302_TIMER);

      /*Stop T316 while entering disconnected for protection*/
      if(rrctmr_get_remaining_time(RRCTMR_T_316_TIMER) > 0)
      {
        rrctmr_stop_timer(RRCTMR_T_316_TIMER);
      }

      /*stop T314 and T315 timers if they are started */
      if (rrccu_substate != RRCCU_INITIAL)  
      {
        switch (rrccu_cell_update_cause)
        {
          case  rrc_CellUpdateCause_radiolinkFailure:
          case  rrc_CellUpdateCause_rlc_unrecoverableError:
          case  rrc_CellUpdateCause_re_enteredServiceArea:
            if (rrccu_failure_state == RRC_STATE_CELL_DCH)
            {
              WRRC_MSG0_HIGH("Stop re-est timers");
              rrctmr_stop_timer(RRCTMR_T_314_TIMER);
              rrctmr_stop_timer(RRCTMR_T_315_TIMER);
            }
            /* UE must have gone out of service area during
            RL failure handling */
            if ((rrccu_substate == RRCCU_WAIT_FOR_UE_TO_CAMP_ON) ||
                (rrccu_substate == RRCCU_WAIT_FOR_RB_REL_CNF))
            {
              WRRC_MSG0_HIGH("Stop OOS timers");
              rrctmr_stop_timer(RRCTMR_T_307_TIMER);
              rrctmr_stop_timer(RRCTMR_T_317_TIMER);
              /* stop the oos timer */
              rrctmr_stop_timer(RRCTMR_T_OOS_TIMER);
            }
            break;

          default:
            break;
        }
      }
      rrccu_substate = RRCCU_INITIAL;            
      /*call the procedure to clear the global variabls */
      rrccu_clear_procedure();
      rrccu_init_last_cu_cnf_info();
      rrccu_reset_registration_info();
      rrccu_tran_to_discon_counter = 0;
      rrctmr_stop_timer(RRCTMR_RRCCU_TRANS_TO_DISCON_TIMER);
      return;
    }
  }


  switch (rrccu_substate)
  {      
    case RRCCU_INITIAL:
      rrccu_process_cu_initial(cmd_ptr);
      break;
    case RRCCU_WAIT_FOR_UE_TO_CAMP_ON:
      rrccu_process_cu_wait_for_ue_to_camp_on(cmd_ptr);
      break;
    case RRCCU_WAIT_FOR_RB0_EST_CNF:
      rrccu_process_cu_wait_for_rb0_est_cnf(cmd_ptr);
      break;
    case RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM:
      rrccu_process_cu_wait_for_cell_update_confirm(cmd_ptr);
      break;
    case RRCCU_WAIT_FOR_RB_EST_CNF:
      rrccu_process_cu_wait_for_rb_est_cnf(cmd_ptr);
      break;
    case RRCCU_WAIT_FOR_RB_REL_CNF:
      rrccu_process_cu_wait_for_rb_rel_cnf(cmd_ptr);
      break;
    case RRCCU_WAIT_FOR_L2_ACK:
      rrccu_process_cu_wait_for_l2_ack(cmd_ptr);
      break;
    default:
      WRRC_MSG2_ERROR("Invalid CU st %d for DISCONN for cmd %d",rrccu_substate,cmd_ptr->cmd_hdr.cmd_id);
      break; 
  }
} 
/* rrccu_process_disconnected_state */
/*===========================================================================

FUNCTION RRCCU_PROCESS_CONNECTING_STATE

DESCRIPTION
  This function processes all events that are dispatched to Cell Update 
  procedure in CONNECTING state of Idle  mode.

  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
void rrccu_process_connecting_state
(  
  rrc_cmd_type *cmd_ptr
)
{
  switch (rrccu_substate)
  {      
    case RRCCU_INITIAL:
      rrccu_process_cu_initial(cmd_ptr);
      break;
    
    default:
      WRRC_MSG2_ERROR("Invalid CU st %d for CONNECTING for cmd %d",rrccu_substate,cmd_ptr->cmd_hdr.cmd_id);
      break; 
  }
} 

/* rrccu_process_connecting_state */
/*===========================================================================

FUNCTION RRCCU_PROCESS_CELL_PCH_URA_PCH_STATE

DESCRIPTION
  This function processes all events that are dispatched to Cell Update 
  procedure in CELL_PCH and URA_PCH states of Connected  mode.

  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
void rrccu_process_cell_pch_ura_pch_state
(  
  rrc_cmd_type *cmd_ptr
)
{
  if(rrccu_buffer_commands_in_stand_by_mode(cmd_ptr) == TRUE)
  {
    return;
  }

  if(cmd_ptr->cmd_hdr.cmd_id == RRC_CELL_UPDATE_INITIATE_REQ ||
      cmd_ptr->cmd_hdr.cmd_id == RRC_URA_UPDATE_INITIATE_REQ)
  {
    if(rrctmr_get_remaining_time(RRCTMR_T_319_TIMER) > 0)
    {
      rrctmr_stop_timer(RRCTMR_T_319_TIMER);
      rrcllc_update_drx_coef_length();
    }
  }

  switch (rrccu_substate)
  {      
    case RRCCU_INITIAL:
      rrccu_process_cu_initial(cmd_ptr);
      break;
    case RRCCU_WAIT_FOR_UE_TO_CAMP_ON:
      rrccu_process_cu_wait_for_ue_to_camp_on(cmd_ptr);
      break;
    case RRCCU_WAIT_FOR_RB0_EST_CNF:
      rrccu_process_cu_wait_for_rb0_est_cnf(cmd_ptr);
      break;
    case RRCCU_WAIT_FOR_RB_REL_CNF:
      rrccu_process_cu_wait_for_rb_rel_cnf(cmd_ptr);
      break;
    case RRCCU_WAIT_FOR_BPLMN_SUSPEND_CNF:
      rrccu_process_cu_wait_for_bplmn_suspend_cnf(cmd_ptr);
      break;
    case RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM:
      rrccu_process_cu_wait_for_cell_update_confirm(cmd_ptr);
      break;
    case RRCCU_WAIT_FOR_RB_PROC_COMPL_IND:
      rrccu_process_cu_wait_for_rb_proc_compl_ind(cmd_ptr);
      break;

    case RRCCU_WAIT_FOR_PCCH_RB_EST_CNF:
      rrccu_process_cu_wait_for_pcch_rb_est_cnf(cmd_ptr);
      break;

#ifdef FEATURE_UPDATE_SIB7_FOR_PCH_TO_FACH
    case RRCCU_WAIT_FOR_SIB7_CURRENT:
      rrccu_process_cu_wait_for_sib7_current(cmd_ptr);
      break;
#endif /*FEATURE_UPDATE_SIB7_FOR_PCH_TO_FACH*/

    default:
      MSG_ERROR("Invalid CU st %d for RRC st %d for cmd %d",rrccu_substate,rrc_get_state(),cmd_ptr->cmd_hdr.cmd_id);
      break; 
  }
} /* rrccu_process_cell_pch_ura_pch_state */

/*===========================================================================

FUNCTION rrccu_procedure_event_handler

DESCRIPTION
  This procedure is the event handler for the Cell Update procedure.


DEPENDENCIES
  None.

RETURN VALUE
  None.

===========================================================================*/

void rrccu_procedure_event_handler
(
  rrc_cmd_type *cmd_ptr
)
{
  
  rrc_state_e_type rrc_state = rrc_get_state();
  rrc_crash_debug_save_proc_substates(RRC_PROCEDURE_CU,rrccu_substate,cmd_ptr->cmd_hdr.cmd_id);

  MSG_HIGH("function rrccu_procedure_event_handler is called. Cmd_id: rrc_cmd_e_type%x received [0x01000025 - CU_INITIATE_REQ, 0x02000014 - OOS,  0x0200000E - RL_FAILURE, 0x0100001F - NEW_CELL_IND, 0x04000001 - RLC_RESET] in rrc_state = rrc_state_e_type_value%d, and rrccu_substate = rrccu_substate_e_type_value%d", cmd_ptr->cmd_hdr.cmd_id, rrc_state, rrccu_substate);

  /*  When W is suspended, ignore RL failure from L1 */
  /* This is to avoid setting conn_oos_flag to TRUE in standby  */
  if((rrcmcm_get_rrc_mode() == RRC_MODE_STANDBY) && (cmd_ptr->cmd_hdr.cmd_id == RRC_CPHY_RL_FAILURE_IND))
  {
    WRRC_MSG1_HIGH("Ignoring RL FAILURE at CU in  cu_state %d in W STANDBY mode", rrccu_substate);
    return;
  }

#ifdef FEATURE_WCDMA_HS_RACH  

/* if T305 expires and common_edch_transmission is TRUE then re-start it.
Section 8.3.1.2 Initiation
1> Periodical cell update:
2> if the timer T305 expires; and
  4> if the variable COMMON_E_DCH_TRANSMISSION is set to FALSE:
5> perform cell update using the cause "periodical cell update".
4> else:
5> restart the timer T305;
5> and end the procedure.
*/

  if(RRC_T305_EXPIRED_IND == cmd_ptr->cmd_hdr.cmd_id)
  {
	if(TRUE == l1_rrc_is_common_edch_resrc_active())
	{
          WRRC_MSG2_HIGH("RRCHSRACH Re-Starting T305 cu_state %d config ptr in use ", rrccu_substate, config_ptr_in_use);
          rrccu_start_t_305_timer();   
          return;
	}
  }
#endif

#ifdef FEATURE_WCDMA_FREE_FLOATING_TASK
  if(cmd_ptr->cmd_hdr.cmd_id == RRC_RLC_UL_DATA_IND)
  {
    rrccu_handle_rlc_ul_data_ind();
    return;
  }
#endif

  switch (rrc_state)
  {

    case RRC_STATE_CELL_DCH:  
      rrccu_process_cell_dch_state(cmd_ptr);     
      break;
    
    case RRC_STATE_DISCONNECTED:
      rrccu_process_disconnected_state(cmd_ptr);
      break;
    
    case RRC_STATE_CONNECTING:
      rrccu_process_connecting_state(cmd_ptr);
      break;

    case RRC_STATE_CELL_FACH:   
      rrccu_process_cell_fach_state(cmd_ptr);
      break;
 
    case RRC_STATE_URA_PCH:
    case RRC_STATE_CELL_PCH:
      rrccu_process_cell_pch_ura_pch_state(cmd_ptr); 
      break;

    default: 
      /* This should never happen */
      ERR_FATAL("This is an invalid state: %d",rrc_state,0,0);
      break;
   }  
} /* rrccu_procedure_event_handler */

/*===========================================================================

FUNCTION rrccu_trim_cu_msg_ul_tm_tb_size

DESCRIPTION
  This procedure is the event handler for the Cell Update procedure.


DEPENDENCIES
  None.

RETURN VALUE
  None.

===========================================================================*/

boolean rrccu_trim_cu_msg_ul_tm_tb_size
(
  rrc_UL_CCCH_Message *msg_ptr,
  uint32 pdu_length
)
{
  boolean status = FALSE;
  WRRC_MSG1_HIGH("CU trimming bit Mask val =%x",trim_cu_msg_status);
  /*These If conditions should be in sequence, below is the spec section which indicates that
    *8.5.23 Measured results on RACH
    *1>for messages transmitted on CCCH, take care that the maximum allowed message size
    *    is not exceeded when forming the IE "Measured results on RACH", i.e. limit the number 
    *    of included neighbour cells or if required omit the IE "Measured results on RACH" altogether. 
    *   When limiting the number of included neighbouring cells, 
    *   the number of inter-frequency cells should be limited first i.e. inter-frequency cells should
    *   be omitted before limiting  the number of intra- frequency cells.
    *
    ******************************************************************
    *  Update from rel10 CR RP-130235 are below. This CR is early implementable
    *****************************************************************
    *
    *  UE may omit the IE "Support for Two DRX schemes in URA_PCH and CELL_PCH" (i.e. omit the cellUpdate-r3-add-ext), 
    *  and the UE may omit IE "MBMS Selected Services" (i.e. omit the mbmsSelectedServices) to be able to include the 
    *  Rel-10 non-critical extensions (i.e. include the cellUpdate-va40ext), or to be able to include IE "Measured results on RACH". 
    *  The UE should first omit the IEs before applying the prioritization rules in section 8.5.23 to include the IE "Measured results on RACH".
    */
  
  /*
    Trim security revert status indicator first if UE is not rel-10 capable.
  */
#ifdef FEATURE_WCDMA_REL10
  #error code not present
#endif
  if ((trim_cu_msg_status & RRCCU_REMOVED_SUPPORT_FOR_TWO_DRX_SCHEMES_IN_PCH) 
                   == RRCCU_TRIM_REQ_BIT_MASK_NOT_SET)
  {
    if(RRC_MSG_COMMON_BITMASK_IE(msg_ptr->message.u.cellUpdate,
                                  rrc_CellUpdate,laterNonCriticalExtensions))
    {
      if (msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.
         cellUpdate_r3_add_ext.cellUpdate_v7e0ext.m.supportForTwoDRXSchemesInPCHPresent)
      {
          msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.m.cellUpdate_r3_add_extPresent=0;
          WRRC_MSG0_HIGH("Removed rel7 supportForTwoDRXSchemesInPCH/cellUpdate_r3_add_ext "); 
      }
    }
    trim_cu_msg_status |= RRCCU_REMOVED_SUPPORT_FOR_TWO_DRX_SCHEMES_IN_PCH;
        status = TRUE;
  }
  
#ifdef FEATURE_WCDMA_INTER_FREQ_RACH_REPORTING
  #error code not present
#endif
  else if((trim_cu_msg_status & RRCCU_REMOVED_MONITORED_CELL_FROM_MEAS_RPT_ON_RACH) 
                       == RRCCU_TRIM_REQ_BIT_MASK_NOT_SET)
  {    
    if(RRC_MSG_COMMON_BITMASK_IE(msg_ptr->message.u.cellUpdate,rrc_CellUpdate,measuredResultsOnRACH))
    {
      WRRC_MSG0_HIGH("rrc_CellUpdate_measuredResultsOnRACH_present bit mask set");      

      if(RRC_MSG_COMMON_BITMASK_IE(msg_ptr->message.u.cellUpdate.measuredResultsOnRACH, rrc_MeasuredResultsOnRACH, monitoredCells))
      {
        /*Exclude monitored cell results in meas rpt on rach*/
        WRRC_MSG1_HIGH("rrc_monitoredCells_present bit mask set and the Number of monitored cell = %d",msg_ptr->message.u.cellUpdate.measuredResultsOnRACH.monitoredCells.n);
          
        msg_ptr->message.u.cellUpdate.measuredResultsOnRACH.m.monitoredCellsPresent = 0;        
		msg_ptr->message.u.cellUpdate.measuredResultsOnRACH.monitoredCells.n = 0;
      	rtxMemFreePtr(&enc_ctxt,msg_ptr->message.u.cellUpdate.measuredResultsOnRACH.monitoredCells.elem);
      }
    }
    /*Set REMOVE_MONITORED_CELL_FROM_MEAS_RPT_ON_RACH in trim_cu_msg_status*/
    trim_cu_msg_status |= RRCCU_REMOVED_MONITORED_CELL_FROM_MEAS_RPT_ON_RACH;
    status = TRUE;
  }
  else if((trim_cu_msg_status & RRCCU_REMOVED_ENTIRE_MEAS_RPT_ON_RACH) 
                       == RRCCU_TRIM_REQ_BIT_MASK_NOT_SET)
  {
    if(RRC_MSG_COMMON_BITMASK_IE(msg_ptr->message.u.cellUpdate,
		rrc_CellUpdate,measuredResultsOnRACH))
    {
      /*Disable bit mask*/
      msg_ptr->message.u.cellUpdate.m.measuredResultsOnRACHPresent =0;
    }
    WRRC_MSG0_HIGH("Removed measuredResultsOnRACH I.E from CU, bit mask ");
    trim_cu_msg_status |= RRCCU_REMOVED_ENTIRE_MEAS_RPT_ON_RACH;
    status = TRUE;
  }
  else
       /*This fix is added to trim the CU size based on whether establishment cause is present or not.
          Establishment cause will be filled in CU only if either of CS or PS session establishment is ongoing.         
          1) In PCH state if the CS call is triggered then establishment cause will indicate CS session
          2) While in CS call if PS session establishment is triggered and before sucessfull Ps session if RLF happens
              CU will be triggered with PS session establishment cause*/
#ifdef FEATURE_WCDMA_HS_FACH_DRX
  if((rrcenhstate_nv_supports_e_fach_drx())&&
    ((trim_cu_msg_status & RRCCU_REMOVED_REL8_CAP_IND_IF_CS_OR_PS_SESS_PEND) 
                         == RRCCU_TRIM_REQ_BIT_MASK_NOT_SET))     
      {
      if(RRC_MSG_COMMON_BITMASK_IE(msg_ptr->message.u.cellUpdate,
                                rrc_CellUpdate,laterNonCriticalExtensions))
          {
        if((RRC_MSG_COMMON_BITMASK_IE(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions,
          rrc_CellUpdate_laterNonCriticalExtensions,v590NonCriticalExtensions)) &&
          (RRC_MSG_COMMON_BITMASK_IE(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.
          v590NonCriticalExtensions.cellUpdate_v590ext,rrc_CellUpdate_v590ext,establishmentCause)))
        {
     
            /*This is a work around to trim CU size to fit in CCCH message. v860NonCriticalExtensions can contain 
                   supportOfCommonEDCHPresent : 1;
                   supportOfHS_DSCHDRXOperationPresent : 1;
                   supportOfMACiisPresent : 1;
                   supportOfSPSOperationPresent : 1;
                   supportOfControlChannelDRXOperationPresent : 1;
  
                   Among these fields now only HS_DSCHDRX is supported. As we are nullifying 860NonCriticalExtensions above all rel8 features will not be indicated
                   in CU     */
            msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.
            v6b0NonCriticalExtensions.v770NonCriticalExtensions.m.v860NonCriticalExtensionsPresent=0;
            WRRC_MSG0_HIGH("Removed rel8 capability indication bitmask "); 
        }
          }
      trim_cu_msg_status |= RRCCU_REMOVED_REL8_CAP_IND_IF_CS_OR_PS_SESS_PEND;
          status = TRUE;
      }
    else
#ifdef FEATURE_WCDMA_REL10
      #error code not present
#endif
#endif
  {
      WRRC_MSG0_ERROR("MAX possible trim on CU done, lets discard this msg");
    status = FALSE;
  }
  return status;
}
/*===========================================================================

FUNCTION rrccu_reset_trim_bit_mask

DESCRIPTION
  This procedure Reset Cell Update Trim bit mask.


DEPENDENCIES
  None.

RETURN VALUE
  None.

===========================================================================*/

void rrccu_reset_trim_bit_mask
(
void
)
{
  /*Reset Cell Update Trim bit mask*/
  WRRC_MSG0_HIGH("CU reset Trim bit mask ");
  trim_cu_msg_status = trim_cu_msg_status & RRCCU_TRIM_REQ_BIT_MASK_NOT_SET;
}

/*===========================================================================

FUNCTION rrccu_set_tvm_ind_in_cu

DESCRIPTION
  This function will set the traffic volume indicator in cell update message. 

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
void rrccu_set_tvm_ind_in_cu
(
  rrc_UL_CCCH_Message *msg_ptr
)
{
  /* The following bitmask may already be set earlier */
  if(!(RRC_MSG_COMMON_BITMASK_IE(msg_ptr->message.u.cellUpdate,
        rrc_CellUpdate,laterNonCriticalExtensions)))
  {
   RRC_MSG_COMMON_SET_BITMASK_IE(msg_ptr->message.u.cellUpdate,
      rrc_CellUpdate,laterNonCriticalExtensions);
    
   RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions);
  }
  
  /* The following bitmask may already be set earlier */
  if(!(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.m.v590NonCriticalExtensionsPresent))
  {
    msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.m.v590NonCriticalExtensionsPresent =1;
    
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.
      v590NonCriticalExtensions);
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.cellUpdate_v590ext);
  }
  
  if(!(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.m.
  	v690NonCriticalExtensionsPresent))
  {
     msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.
      v590NonCriticalExtensions.m.v690NonCriticalExtensionsPresent =1;
    
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.
      v690NonCriticalExtensions);
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.
    v690NonCriticalExtensions.cellUpdate_v690ext);
  
  }
  msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.
    v690NonCriticalExtensions.cellUpdate_v690ext.m.trafficVolumeIndicatorPresent =1;
  
  msg_ptr->message.u.cellUpdate.laterNonCriticalExtensions.v590NonCriticalExtensions.
    v690NonCriticalExtensions.cellUpdate_v690ext.trafficVolumeIndicator = rrc_CellUpdate_v690ext_IEs_trafficVolumeIndicator_true;
}

/*===========================================================================
FUNCTION RRCCU_PROCESS_CELL_UPDATE_CONFIRM_R8

DESCRIPTION
  This function processes the REl 8 CELL UPDATE CONFIRM message received in response to
  Cell Update message.
  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS
  None

===========================================================================*/
void rrccu_process_cell_update_confirm_r8
(    
  void *msg_ptr,                           /* Pointer to Downlink Msg */
  rrc_RRC_TransactionIdentifier rcvd_transaction_id,
  rrc_CellUpdateConfirm_r8_IEs *cu_confirm_ptr,
  uint32 dl_sdu_type                       /* Downlink SDU type */
)
{
  boolean msg_not_valid      = FALSE;         /* boolean to indicate msg validity */

  rrcrb_directed_cell_info_type          directed_cell_info; /* directed cell info struct */

  /* Update Transaction id */
  rrccu_trans_id = rcvd_transaction_id;
    
  /* enter idle if both timers are marked as expired */
  if ((rrccu_rl_failure_info.t314_info.timer_status == RE_EST_TIMER_EXPIRED) &&
      (rrccu_rl_failure_info.t315_info.timer_status == RE_EST_TIMER_EXPIRED))
  {
    /* Since both T314 and T315 are expired, bring down RRC Connection */
    rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                         RRC_TX_TO_DISCON_OTHER);
      /* Update the release cause */
    rrc_release_cause = RRC_REL_DEEP_FADE;
    rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
    WRRC_MSG0_HIGH("RRC Conn Released since T314=0 & T315=0");
    return;
  }

  /* Update state Indicator */   
  rrccu_state_indicator = cu_confirm_ptr->rrc_StateIndicator;

  /*If wait timer IE is valid, we need to store it. We need this value if R7 CU CNF OTA
    is taking the UE to Cell_PCH or URA_PCH state. In this case, we need to start wait timer
    T320 with this IE.*/

  if(((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH) || (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH)) &&
    (RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr, rrc_CellUpdateConfirm_r8_IEs, waitTime)) &&
    (cu_confirm_ptr->waitTime))
  {
    rrccu_int_data.wait_time_in_pch = cu_confirm_ptr->waitTime;

    /*If current CU cause is Uplink Data Transmission or MBMS P2P Rb Request, we need to store it 
       so that when T320 expires, we can initiate CU with this cause.*/
    if(rrccu_cell_update_cause == rrc_CellUpdateCause_uplinkDataTransmission)
    {
      rrccu_int_data.cu_cause_for_wait_timer = rrccu_map_cu_cause(rrccu_cell_update_cause);
    }
  }  

  /* check whether new CRNTI is present in the message or not when there is
  no valid C-RNTI is existing and next state indicated by the message is 
  CELL_FACH */
  if ((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_FACH) ||
     (((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH) || (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH)) &&
     (RRCCU_NO_RESP_MSG != rrccu_find_response_to_cell_update_confirm_r8(cu_confirm_ptr))))
  {
    if ((C_RNTI_NOT_VALID == rrcllc_get_current_crnti_status()) &&
        ((RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,new_C_RNTI)) == 0 ))
    {
      if(((rrcllc_get_toc_usage() == TOC_FOR_OOS) 
          || (rrcllc_get_toc_usage() == TOC_FOR_OOS_WITHOUT_DCH_INFO)
          || (rrcllc_get_toc_usage() == TOC_FOR_OOS_WITH_DCH_INFO)
       ) &&   (rrcrb_get_new_crnti_valid() && rrccsp_is_selected_cell_utran_directed()))
      {
        WRRC_MSG0_HIGH("Crnti present in reconfig msg");
      }
      else
      {

        WRRC_MSG1_ERROR("No CRNTI for next_st:%d", rrccu_state_indicator);
        /* Update the cause to re-selection as the Cell upate cause should
              indicate re-selection in case of No CRNTI
              */
        rrccu_cell_update_cause = rrc_CellUpdateCause_cellReselection;		
        rrccu_resend_cell_update_msg(RRCCU_NOT_INCLUDE_FAILURE_CAUSE);
        /* continue with rrccu state  RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM */
        return;
      }
    }
  }

#ifdef FEATURE_WCDMA_HS_FACH
/*RNTI validation for HS-FACH and HS-RACH*/
  if(TRUE == rrccu_check_rnti_for_resending_cu(
               RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr, rrc_CellUpdateConfirm_r8_IEs,new_H_RNTI), 
               RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr, rrc_CellUpdateConfirm_r6_IEs,newPrimary_E_RNTI),
               MSG_REL8,
	       rrccu_find_response_to_cell_update_confirm_r8(cu_confirm_ptr)))
  {
    rrccu_cell_update_cause = rrc_CellUpdateCause_cellReselection;
    rrccu_resend_cell_update_msg(RRCCU_NOT_INCLUDE_FAILURE_CAUSE);
    return;
  }
#endif

  if ((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH) ||
      (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH))
  {
    if (!(RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,utran_DRX_CycleLengthCoeff)))
    {
      WRRC_MSG0_ERROR("UTRAN DRX is not present");
      
      /* set the invalid msg flag */
      msg_not_valid = TRUE;
    }
    else
    {
      /* store it in a variable */
      if(rrcllc_update_utran_drx_cycle_length_coeff_in_oc_r7(TRUE,&cu_confirm_ptr->utran_DRX_CycleLengthCoeff)
         == SUCCESS)
      {        
        if((RRC_MSG_COMMON_BITMASK_IE_TYPE2(cu_confirm_ptr->utran_DRX_CycleLengthCoeff,drx_CycleLengthCoefficient2))&&
           (RRC_MSG_COMMON_BITMASK_IE_TYPE2(cu_confirm_ptr->utran_DRX_CycleLengthCoeff,timeForDRXCycle2)))
        {
          rrccu_utran_drx_coef = cu_confirm_ptr->utran_DRX_CycleLengthCoeff.drx_CycleLengthCoefficient2;
        }
        else
        {
      rrccu_utran_drx_coef = cu_confirm_ptr->utran_DRX_CycleLengthCoeff.drx_CycleLengthCoefficient;
    }
      }
      else
      {
        rrccu_utran_drx_coef = cu_confirm_ptr->utran_DRX_CycleLengthCoeff.drx_CycleLengthCoefficient;
      }
    }
       /*resend the cell update message if there is any invalid config*/
    if(rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH)
    {
      if (!(RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,ura_Identity)))
      {
        WRRC_MSG0_HIGH("URA-id is not present");
        rrccu_clear_ura_id();
      }
      /* update rrccu procedure with new URA-id */
      else
      {
        /*URA ID present in the message set ura_identity variable with this value */
        if (cu_confirm_ptr->ura_Identity.numbits == 16)
        {
          /*rrccu_translate_ura_id (&(msg_ptr->u.r3.radioBearerReconfiguration_r3.ura_Identity));*/
          rrccu_update_ura_id (&(cu_confirm_ptr->ura_Identity));
        }
        else
        {
          WRRC_MSG1_ERROR("Invalid URA ID length%d",
              cu_confirm_ptr->ura_Identity.numbits);
          /* set the invalid msg flag */
          msg_not_valid = TRUE;
        }
      }
        
    }
  }

#ifdef FEATURE_WCDMA_HS_FACH
  if(cu_confirm_ptr->m.new_H_RNTIPresent)
  {
    rrccu_update_hrnti_from_ota(&cu_confirm_ptr->new_H_RNTI, transition_config.toc_ptr);
  }
#endif


#ifdef FEATURE_WCDMA_REL7_SPECRS   
   /*If CU Confirm OTA provides "supportForChangeOfUE_Capability" IE, we need to store it in
        "rrc_ordered_rnc_cap_change_support" so that later once the procedure is over successfully, global
        "rrc_rnc_cap_change_support" can be updated accordingly. */  
  if(RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,supportForChangeOfUE_Capability))
  {
    if(cu_confirm_ptr->supportForChangeOfUE_Capability == TRUE)
    {
      rrc_ordered_rnc_cap_change_support = RNC_CAP_CHANGE_SUPPORTED;
    }
    else
    {
      rrc_ordered_rnc_cap_change_support = RNC_CAP_CHANGE_UNSUPPORTED;
    }
  }
  else
  {
    rrc_ordered_rnc_cap_change_support = RNC_CAP_CHANGE_NONE;
  }
#endif /*FEATURE_WCDMA_REL7_SPECRS*/
    
  if(msg_not_valid == FALSE)
  { 
    if(rrccu_validate_rb_info_r8(cu_confirm_ptr) == FALSE)
      {
        msg_not_valid = TRUE;
    } 
  }

  /*RRC_GKG: See whether adding HSDPA check for TDD adds any value.*/

  if (msg_not_valid)
  {
    WRRC_MSG0_HIGH("Invalid Configurartion in CUCnf Msg.  Resending Cell Update");
    /* Set the Transaction Id */
    rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;

    /* Set Failure cause */
    rrccu_failure_cause.failureCause.t = 
      T_rrc_FailureCauseWithProtErr_invalidConfiguration;


    rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
    /* continue with rrccu state  RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM */
    return;
  }

  if(rrccu_process_freq_redirection_info_r8(cu_confirm_ptr, &directed_cell_info) == FALSE)
  {
    return;
  }

  if (RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,dl_CounterSynchronisationInfo))
  {

  /*check whether PDCP info is present in the dl counter sync info */
    if((RRC_MSG_COMMON_BITMASK_IE_TYPE2(cu_confirm_ptr->dl_CounterSynchronisationInfo,
		rb_WithPDCP_InfoList)) ||
      (RRC_MSG_COMMON_BITMASK_IE(cu_confirm_ptr->dl_CounterSynchronisationInfo,
      rrc_DL_CounterSynchronisationInfo_r5,rb_PDCPContextRelocationList)))
    {
      /* this involves lossless SRNS relocation so re-send cell update message */
      WRRC_MSG0_ERROR("REL8: PDCP info not supported");

      /* Set the Transaction Id */
      rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;

      /* Set Failure cause */
      rrccu_failure_cause.failureCause.t = T_rrc_FailureCauseWithProtErr_configurationUnsupported;

    

      rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
      /* continue with rrccu state  RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM */
      return;
    }
    /*UE actions, in case IE "Downlink counter synchronisation info" is included and 
    *either IE "RLC reestablish indicator (RB2, RB3 and RB4)" or IE "RLC re-establish 
    *indicator (RB5 and upwards)" are set to TRUE, are not defined.refer to R2-041019,spec cr-2328
    */
    if((cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4 == TRUE) ||
      (cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove == TRUE))
    {
      /* Set the Transaction Id */
      rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;

      /* Set Failure cause */
      rrccu_failure_cause.failureCause.t = T_rrc_FailureCauseWithProtErr_configurationUnsupported;

   

      WRRC_MSG0_ERROR("UE doesn't support simultaneous RLC Re_est & S-RNS<R2-041019,spec cr-2328>");
      rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
      /* continue with rrccu state  RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM */
      return;
    }

    /* This is lossy SRNS relocation */
    rrccu_cucnf_for_srns_relocation  = TRUE;

    /* store the new URNTI value if present */
    if (RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,new_U_RNTI))
    {
      rrccu_new_urnti_valid = TRUE;
      rrc_translate_urnti (&(cu_confirm_ptr->new_U_RNTI), &rrccu_new_urnti);
    }
  }

  /* check whether rlc-re establishment was require but not indicated in cell update
  confirm message. In such case discard the cucnf and resend cell update message.
  This should also take care of multiple cell updates initiated due to change in cause.
  for ex. periodicall...rlc unrecoverabel error, reselection...rlc unrecoverable error
  rl failure..rlc unrecoverable error */
  if (((rrccu_rlc_error_info.error_on_srb == TRUE) && 
      (cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4 == FALSE)) ||
       ((rrccu_rlc_error_info.error_on_urb == TRUE) && 
      (cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove == FALSE)))
  {
    if(RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,dl_CounterSynchronisationInfo)) 
    {
      WRRC_MSG0_HIGH("S-RNS relocation is Implicit rlc_Re_establish");
    }
    else
    {
      rrccu_resend_cell_update_msg(RRCCU_NOT_INCLUDE_FAILURE_CAUSE);
      /* continue with rrccu state  RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM */
      return;
    }
  }

  rrccu_resp_msg = rrccu_find_response_to_cell_update_confirm_r8(cu_confirm_ptr);
  /* If CUC doesnt set OC, validate if the existing ehs queues are holding a proper window size */
  /* Calling 'rrcllc_validate_hs_ehs_window_size_for_sec' directly without checking for 
     num of carriers. As CUC doesnt set OC, num sec carriers is anyways 0. We can reject CUC
     if window size is > 32 */
 /*  Note: directed_cell_info.freq_info_present and directed_cell_info.pscr_present will always be FALSE 
     for NO RSP and UMIC response. Added those conditions to just maintain the code consistency. 
     These conditions doesnt impact the logics. If these conditions are redundant, we can remove
     such condition everywhere  */
  if(((RRCCU_NO_RESP_MSG == rrccu_resp_msg)||(RRCCU_UMIC_COMPLETE_RESP_MSG == rrccu_resp_msg)) &&
  (((directed_cell_info.freq_info_present == FALSE )&& (directed_cell_info.pscr_present == FALSE ))
    ||(rrccu_state_indicator ==rrc_RRC_StateIndicator_cell_DCH)))
  {
    if(FALSE == rrcllc_validate_hs_ehs_window_size_for_sec(rrccu_state_indicator))
    {
      rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;
      rrccu_failure_cause.failureCause.t = T_rrc_FailureCauseWithProtErr_invalidConfiguration;
      rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
	  return;
    }
  }

  /* check whether reconfiguration is involved and OC is already set by some other procedure */ 
  if ((rrccu_resp_msg != RRCCU_NO_RESP_MSG) && 
      (rrccu_resp_msg != RRCCU_UMIC_COMPLETE_RESP_MSG) &&
      ((rrcllc_get_ordered_config_status_wo_f3() != OC_NOT_SET) || (rrccu_do_not_acpt_nw_conf_in_cuc == TRUE)))
  {
    /* Set the Transaction Id */
    rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;

    /* Set Failure cause */
    rrccu_failure_cause.failureCause.t = T_rrc_FailureCauseWithProtErr_incompatibleSimultaneousReconfiguration;
    rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
  }
  else
  {
    rrcu_process_cu_cnf_after_validation_r8(msg_ptr,cu_confirm_ptr,dl_sdu_type
                                                                        ,directed_cell_info
                                                                        );
  }
  return;
} 

/*===========================================================================
FUNCTION rrcu_process_cu_cnf_after_validation_r8

DESCRIPTION
  This function processes the REl 8 CELL UPDATE CONFIRM message after doing the initial validation
  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS
  None
===========================================================================*/
void rrcu_process_cu_cnf_after_validation_r8
(
  void *msg_ptr,                           /* Pointer to Downlink Msg */
  rrc_CellUpdateConfirm_r8_IEs *cu_confirm_ptr,
  uint32 dl_sdu_type                       /* Downlink SDU type */  
  ,rrcrb_directed_cell_info_type          directed_cell_info
)
{
  rrc_state_e_type state ;                    /* Local varible to store state */
  rrc_cmd_type *cmd_ptr;                      /* Pointer to the RRC Command */  
  rrc_int_c_rnti_type crnti;                  /* Local variable for C-RNTI */
  rrc_int_u_rnti_type urnti;                  /* Local variable for U-RNTI */  
  rrcllc_oc_status_e_type status;             /* Local var to store Ordered Config  status */

  rrc_update_reconfig_waiting_for_l2ack_dch(MAX_NUM_OF_PROCEDURES);

  /* if this cell update was due to RL faiure then stop any re-est timer that is running */
  if(((rrccu_cell_update_cause == rrc_CellUpdateCause_radiolinkFailure)||(rrccu_cell_update_cause == rrc_CellUpdateCause_re_enteredServiceArea)||
  (rrccu_cell_update_cause == rrc_CellUpdateCause_rlc_unrecoverableError)) && (rrccu_failure_state == RRC_STATE_CELL_DCH))
  {
    if (rrccu_rl_failure_info.t314_info.timer_status == RE_EST_TIMER_STARTED)
    {
      WRRC_MSG0_HIGH("Stopping T314");
      rrctmr_stop_timer(RRCTMR_T_314_TIMER); 
    }
    if (rrccu_rl_failure_info.t315_info.timer_status == RE_EST_TIMER_STARTED)
    {
      WRRC_MSG0_HIGH("Stopping T315");
      rrctmr_stop_timer(RRCTMR_T_315_TIMER); 
    }
  }

  state = rrc_translate_state_indicator_to_state(rrccu_state_indicator);

#ifdef FEATURE_WCDMA_HS_FACH
  rrccu_update_rnti_from_cu_cnf(
    RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,new_H_RNTI),
    RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,newPrimary_E_RNTI), 
    &cu_confirm_ptr->new_H_RNTI,
    &cu_confirm_ptr->newPrimary_E_RNTI,
    &directed_cell_info);
#endif

  if((rrccu_resp_msg == RRCCU_UMIC_COMPLETE_RESP_MSG)
    &&(((directed_cell_info.freq_info_present == FALSE )&& (directed_cell_info.pscr_present == FALSE ))
    ||(rrccu_state_indicator ==rrc_RRC_StateIndicator_cell_DCH))
    )
  {
    if (rrc_get_rlc_size_change_status_for_procedure_id(RRC_PROCEDURE_CU))
    {
      rrcsmc_update_hfn_for_rlc_rb(rlc_size_change_in_progress.rb_id, 
                                 rlc_size_change_in_progress.direction);
    }

    if (!rrccu_cucnf_for_srns_relocation)
    {
      /* procedure does not involve SRNS relocation */
  
      /* need to send RNTI update request if any of the RNTIs is present
      in the message */
      if ((RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,new_C_RNTI)) ||
          (RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,new_U_RNTI)))
      {
        /* Allocates the buffer to RRC Internal command */
        cmd_ptr =  rrc_get_int_cmd_buf();
        /* Fill parameters for RRC_RNTI_UPDATE_REQ command */
        cmd_ptr->cmd.rnti_update_req.procedure = RRC_PROCEDURE_CU;
        cmd_ptr->cmd_hdr.cmd_id = RRC_RNTI_UPDATE_REQ;
  
        if (RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,new_C_RNTI)) 
        {
          rrc_translate_crnti(&cu_confirm_ptr->new_C_RNTI,&crnti);
          cmd_ptr->cmd.rnti_update_req.crnti_action = RRC_RNTI_UPDATE;
          cmd_ptr->cmd.rnti_update_req.crnti = crnti;
#ifdef FEATURE_WCDMA_HS_RACH
          if(rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH)
          {
            rrchsrach_set_hspa_rnti_stored_cell_pch(ordered_config_ptr,TRUE);
          }
#endif
        }
        else
        {
          cmd_ptr->cmd.rnti_update_req.crnti_action = RRC_RNTI_NOCHANGE;
        }
  
        if(RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,new_U_RNTI))
        {
          rrc_translate_urnti(&cu_confirm_ptr->new_U_RNTI, &urnti);
          cmd_ptr->cmd.rnti_update_req.urnti_action = RRC_RNTI_UPDATE;
          cmd_ptr->cmd.rnti_update_req.urnti= urnti;
        }
        else
        {
          cmd_ptr->cmd.rnti_update_req.urnti_action = RRC_RNTI_NOCHANGE;
        }
  
        /* Indicate to LLC if RLC for SRBs needs to be re-established */
        if(cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4 == TRUE)
        {
          cmd_ptr->cmd.rnti_update_req.rlc_re_establish_srb = TRUE;
        }
        else
        {
          cmd_ptr->cmd.rnti_update_req.rlc_re_establish_srb = FALSE;
        }
  
        /* Indicate to LLC if RLC for User plane RBs needs to be re-established */
        if(cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove == TRUE)
        {
          cmd_ptr->cmd.rnti_update_req.rlc_re_establish_rab = TRUE;
        }
        else
        {
          cmd_ptr->cmd.rnti_update_req.rlc_re_establish_rab = FALSE;
        }
  
        cmd_ptr->cmd.rnti_update_req.cnf_required = TRUE;
  
        WRRC_MSG2_HIGH("REL8: Sending RNTI update req CRNTI_stat:%d, URNTI_stat:%d", 
                  cmd_ptr->cmd.rnti_update_req.crnti_action,
                  cmd_ptr->cmd.rnti_update_req.urnti_action);
  
        rrc_put_int_cmd(cmd_ptr);       /* sends the command to RRC  LLC. */
  
        rrccu_substate = RRCCU_WAIT_FOR_RNTI_UPDATE_CNF;         
      }
      else
      {
        if (C_RNTI_NOT_VALID == rrcllc_get_current_crnti_status())
        {
          /* should not come here as this condition is already taken care in downlink
          sdu processing */
          WRRC_MSG1_ERROR("RNTI absent for UMIC message, next state %d", 
                  rrc_get_state());
          /* Set the Transaction Id */
          rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;
  
          /* Set Failure cause */
          rrccu_failure_cause.failureCause.t = 
            T_rrc_FailureCauseWithProtErr_invalidConfiguration;

          rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
          /* continue with rrccu state  RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM */
          return;
        }
        rrccu_send_response_msg();
      }
      if( RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,cn_InformationInfo))
      {
        (void) rrc_ccm_send_nas_cn_info_r6(&(cu_confirm_ptr->cn_InformationInfo));
      } 
    }
    else
    {
      /* procedure involves SRNS relocation so store the C-RNTI
      and send rlc_reestablishment request to SMC . RNTI update 
      will be done after RLC re-establishment*/
      if (RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,new_C_RNTI)) 
      {
        rrccu_new_crnti_valid = TRUE;
        rrc_translate_crnti(&cu_confirm_ptr->new_C_RNTI,&rrccu_new_crnti);
#ifdef FEATURE_WCDMA_HS_RACH
        if(rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH)
        {
          rrchsrach_set_hspa_rnti_stored_cell_pch(ordered_config_ptr,TRUE);
        }
#endif
      }
      if(RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,new_U_RNTI))
      {
        rrccu_new_urnti_valid = TRUE;
        rrc_translate_urnti(&cu_confirm_ptr->new_U_RNTI,&rrccu_new_urnti);
      }
      /* store the rlc re-establishment indications */
      rrccu_reestablish_srb = cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4;
      rrccu_reestablish_rab = cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove;
  
      //commit fresh values for srns relocation
      rrcsmc_commit_fresh_for_srns_relocation();
  
      rrccu_send_re_est_rlc_for_srns_req (RRC_RE_EST_RB_2, TRUE);
        
      if(RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,cn_InformationInfo))
      {
        (void) rrc_ccm_send_nas_cn_info_r6(&(cu_confirm_ptr->cn_InformationInfo));
      } 
    }
  }

  else if(( rrccu_resp_msg == RRCCU_NO_RESP_MSG)
    &&(((directed_cell_info.freq_info_present == FALSE ) && (directed_cell_info.pscr_present == FALSE ))
    ||(  rrccu_state_indicator ==rrc_RRC_StateIndicator_cell_DCH))
    ) 
  {
    rrccu_check_and_send_response_to_previous_cell_upd_cnf();
  
        /* if any rlc entity has to be re-established then re-establish it before configuring channels. */
        if((cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4 == TRUE) ||
            (cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove == TRUE))
        {
          /* store the rlc re-establishment indications */
          rrccu_reestablish_srb = cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4;
          rrccu_reestablish_rab = cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove;
          rrccu_new_crnti_valid = FALSE;
          rrccu_new_urnti_valid = FALSE;
          rrccu_send_rnti_update_req(FALSE);
          WRRC_MSG2_HIGH("CU Confirm R8: RNTI_UPDATE_REQ  to reestablish SRBs(%d)  DataRB (%d)",
                       rrccu_reestablish_srb,rrccu_reestablish_rab);
        }
        rrccu_reestablish_srb = FALSE;
        rrccu_reestablish_rab = FALSE;
    /* if the next state is cell_pch or ura_pch then setup pcch */
    if((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH) ||(rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH))
    {
      if(  RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,cn_InformationInfo))
      {
        (void) rrc_ccm_send_nas_cn_info_r6(&(cu_confirm_ptr->cn_InformationInfo));
      } 
      /*set the UTRAN DRX coef in rrcllc */
      rrcllc_set_utran_drx_info (rrccu_utran_drx_coef); 
      rrccu_establish_pcch_rb (state);
      rrccu_substate = RRCCU_WAIT_FOR_PCCH_RB_EST_CNF;
    }
    else 
    {
      /* Reset the state machine and the procedure ends */
      rrccu_substate = RRCCU_INITIAL;
      /* Start timer T305 */

      rrctmr_start_timer(RRCTMR_T_305_TIMER, rrc_convert_t305_to_ms(RRC_GET_T305()));

      if( RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,cn_InformationInfo))
      {
        (void) rrc_ccm_send_nas_cn_info_r6(&(cu_confirm_ptr->cn_InformationInfo));
      } 
      /* Inform all registered RRC procedures that Cell Update is completed */
      rrccu_inform_cell_update_completed();
   
      rrccu_process_successful_completion();
     
      /*call the procedure to clear the global variabls */
      rrccu_clear_procedure();
      rrccu_init_last_cu_cnf_info();
    }
  }
  else
  {
    status = rrcllc_set_ordered_config(RRC_PROCEDURE_CU, state, dl_sdu_type, msg_ptr) ;
    switch( status  )
    {
      case ORDERED_CONFIG_SET:
        rrccu_process_after_oc_config_set_r8(cu_confirm_ptr,directed_cell_info
                                                                        );
        break;
  
      case ORDERED_CONFIG_INCOMPATABLE_SIMULTANEOUS_RECONFIG:
        /* This should not occur for CELL UPDATE CONFIRM */
        /* Set the Transaction Id */
        rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;
  
        /* Set Failure cause */
        rrccu_failure_cause.failureCause.t = 
          T_rrc_FailureCauseWithProtErr_incompatibleSimultaneousReconfiguration;
 
        rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
        break;
  
      case ORDERED_CONFIG_CONFIGURATION_NOT_SUPPORTED:
        /* Set the Transaction Id */
        rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;
  
        /* Set Failure cause */
        rrccu_failure_cause.failureCause.t = 
          T_rrc_FailureCauseWithProtErr_configurationUnsupported;

  
        rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
        break;
  
      case ORDERED_CONFIG_NOT_SET_OTHER:
        /* For Cell Update Confirm message RRC LLC should never set Ordered Config */
        WRRC_MSG0_ERROR("Ordered Config Should not return this status");
        break;
  
      case ORDERED_CONFIG_CONFIGURATION_INVALID:
        /* Set the Transaction Id */
        rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;
  
        /* Set Failure cause */
        rrccu_failure_cause.failureCause.t = 
          T_rrc_FailureCauseWithProtErr_invalidConfiguration;
    
  
        rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
        break;
  
      default:
        WRRC_MSG0_ERROR("Invalid status from ORDERED_CONFIG");
        break;
    } 
  }  
  return;
}

/*===========================================================================
FUNCTION rrccu_process_after_oc_config_set_r8

DESCRIPTION
  This function processes the REl 8 CELL UPDATE CONFIRM after OC is set by CU CNF.
  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS
  None
===========================================================================*/
void rrccu_process_after_oc_config_set_r8
(
  rrc_CellUpdateConfirm_r8_IEs *cu_confirm_ptr
  ,rrcrb_directed_cell_info_type          directed_cell_info
)
{
  rrc_cmd_type *cmd_ptr;                      /* Pointer to the RRC Command */ 
  rrc_int_c_rnti_type crnti;                  /* Local variable for C-RNTI */
  rrc_int_u_rnti_type urnti;                  /* Local variable for U-RNTI */  
  uint32 no_of_RBs;                           /* Local variable to store no of RBs */
  rrc_state_e_type state ;                    /* Local varible to store state */

  /* set the flag.Later it will be used while clearing the OC */
  rrccu_oc_set_by_cu = TRUE;
  
  state = rrc_translate_state_indicator_to_state(rrccu_state_indicator);

  /*Cell_FACH -> Cell_PCH or Cell_FACH -> URA_PCH*/
  if((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH)||(rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH))
  {
    /*call the function that evaluates the directed cell info and set the flags accordingly */
    if (rrcrb_validate_directed_cell_info (directed_cell_info) == FALSE)
    {
      if(rrccsp_check_initiate_cell_selection_handling(&directed_cell_info) == FALSE)
      {
        rrccu_cu_initiate_reqd.cu_reqd = TRUE;
        rrccu_cu_initiate_reqd.cu_cause = rrc_CellUpdateCause_cellReselection;
      }
      else
      {
        rrccu_int_data.rrccu_cell_selection_trans_from_fach = TRUE;
      }
    }

    if(rrccu_resp_msg == RRCCU_UMIC_COMPLETE_RESP_MSG)
    {
      if(rrc_get_rlc_size_change_status_for_procedure_id(RRC_PROCEDURE_CU))
      {
        rrcsmc_update_hfn_for_rlc_rb(rlc_size_change_in_progress.rb_id, 
                                   rlc_size_change_in_progress.direction);
      }
    }
#ifdef FEATURE_WCDMA_HS_FACH
    if((rrcenhstate_camped_cell_supports_e_fach() == TRUE) &&
                  (rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH || rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH))
    {
      if(((RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,new_H_RNTI)))
#ifdef FEATURE_WCDMA_HS_RACH
          || (RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,newPrimary_E_RNTI))
#endif
        )
      {
#ifdef FEATURE_WCDMA_HS_RACH
        if((rrchsrach_camped_cell_supports_hsrach() == TRUE) && RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,newPrimary_E_RNTI))
        {
          current_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = TRUE;
          (void)rrc_translate_ernti(&cu_confirm_ptr->newPrimary_E_RNTI, &current_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti);
        }
#endif
        
        rrcllc_establish_srb_rab_in_efach(RRC_E_FACH_DEDICATED,RRC_PROCEDURE_CU,TRUE);
        
      }
    }
#endif

    /* copy the channel config info in to a local buffer we should configure the channels 
    after the response message is sent */
    rrccu_chan_config_info.num_rbs = rrccu_update_chan_config_rb_r8(cu_confirm_ptr,
                                                           rrccu_chan_config_info.rb_info);
    rrccu_chan_config_reqd = TRUE;

    if (! rrccu_cucnf_for_srns_relocation)
    {
      /* procedure does not involve SRNS relocation */
  
      /* CRNTI always must be present to send the response message */
      /* if cucnf message has new C-RNTI  then we need to update the C-RNTI in mac first and 
      send the response and then start the channel configuration */
      if (RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,new_C_RNTI))
      {
        /* Allocates the buffer to RRC Internal command */
        cmd_ptr =  rrc_get_int_cmd_buf();
        /* Fill parameters for RRC_RNTI_UPDATE_REQ command */
        cmd_ptr->cmd.rnti_update_req.procedure = RRC_PROCEDURE_CU;
        cmd_ptr->cmd_hdr.cmd_id = RRC_RNTI_UPDATE_REQ;
  
        rrc_translate_crnti(&cu_confirm_ptr->new_C_RNTI,&crnti);
        cmd_ptr->cmd.rnti_update_req.crnti_action = RRC_RNTI_UPDATE;
        cmd_ptr->cmd.rnti_update_req.crnti = crnti;
  
        if(RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,new_U_RNTI))
        {
          rrc_translate_urnti(&cu_confirm_ptr->new_U_RNTI, &urnti);
          cmd_ptr->cmd.rnti_update_req.urnti_action = RRC_RNTI_UPDATE;
          cmd_ptr->cmd.rnti_update_req.urnti= urnti;
        }
        else
        {
          cmd_ptr->cmd.rnti_update_req.urnti_action = RRC_RNTI_NOCHANGE;
        }
        /* Indicate to LLC if RLC for SRBs needs to be re-established */
        if(cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4 == TRUE)
        {
          cmd_ptr->cmd.rnti_update_req.rlc_re_establish_srb = TRUE;
        }
        else
        {
          cmd_ptr->cmd.rnti_update_req.rlc_re_establish_srb = FALSE;
        }
        /* Indicate to LLC if RLC for User plane RBs needs to be re-established */
        if(cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove == TRUE)
        {
          cmd_ptr->cmd.rnti_update_req.rlc_re_establish_rab = TRUE;
        }
        else
        {
          cmd_ptr->cmd.rnti_update_req.rlc_re_establish_rab = FALSE;
        }
        cmd_ptr->cmd.rnti_update_req.cnf_required = TRUE;
  
        WRRC_MSG2_HIGH("Sending RNTI update req CRNTI_stat:%d, URNTI_stat:%d", 
                  cmd_ptr->cmd.rnti_update_req.crnti_action,
                  cmd_ptr->cmd.rnti_update_req.urnti_action);
  
        rrc_put_int_cmd(cmd_ptr);       /* sends the command to RRC  LLC. */
  
        rrccu_substate = RRCCU_WAIT_FOR_RNTI_UPDATE_CNF;         
        if( RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,cn_InformationInfo))
        {
          (void) rrc_ccm_send_nas_cn_info_r6(&(cu_confirm_ptr->cn_InformationInfo));
        } 
      }
      else
      {
        /* We will be in Cell_FACH state at this time and going to send the response message in Cell_FACH state.*/
        WRRC_MSG1_HIGH("RNTI absent for RB resp message, next state%d", rrc_get_state());
        if( RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,cn_InformationInfo))
        {
          (void) rrc_ccm_send_nas_cn_info_r6(&(cu_confirm_ptr->cn_InformationInfo));
        } 
        if ((rrccu_int_data.rrccu_cell_selection_trans_from_fach) && (rrccu_resp_msg == RRCCU_NO_RESP_MSG))
        {
          rrccu_intiate_cell_selection_fach_pch_cu_cnf(); 
        }
        else
        {
          /* send the response message on the old configuration */
          rrccu_send_response_msg();
        }
      }
    }
    else
    {
      /* procedure involves SRNS relocation so store the C-RNTI
      and send rlc_reestablishment request to SMC . RNTI update 
      will be done after RLC re-establishment*/
      if (RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,new_C_RNTI)) 
      {
        rrccu_new_crnti_valid = TRUE;
        rrc_translate_crnti(&cu_confirm_ptr->new_C_RNTI,&rrccu_new_crnti);
      }
      if(RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,new_U_RNTI))
      {
        rrccu_new_urnti_valid = TRUE;
        rrc_translate_urnti(&cu_confirm_ptr->new_U_RNTI,&rrccu_new_urnti);
      }
      /* store the rlc re-establishment indications */
      rrccu_reestablish_srb = cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4;
      rrccu_reestablish_rab = cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove;
 
      //commit fresh values for srns relocation
      rrcsmc_commit_fresh_for_srns_relocation();
      rrccu_send_re_est_rlc_for_srns_req(RRC_RE_EST_RB_2, TRUE);
 
      if( RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,cn_InformationInfo))
      {
        (void) rrc_ccm_send_nas_cn_info_r6(&(cu_confirm_ptr->cn_InformationInfo));
      } 
    }
  }
  else /*Cell_FACH->Cell_FACH or Cell_FACH to Cell_DCH*/
  {
    /* If any RLC entity has to be re-established then re-establish it before configuring channels. */
    if((cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4 == TRUE) ||
      (cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove == TRUE))
    {
      /* store the rlc re-establishment indications */
      rrccu_reestablish_srb = cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4;
      rrccu_reestablish_rab = cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove;
      rrccu_new_crnti_valid = FALSE;
      rrccu_new_urnti_valid = FALSE;
      rrccu_send_rnti_update_req(FALSE);
      ps_rb_re_establish_indicator = cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove;
      WRRC_MSG1_HIGH("CU: RB5 or higher re-establish indicator %d", ps_rb_re_establish_indicator);
    }

    rrccu_reestablish_srb = FALSE;
    rrccu_reestablish_rab = FALSE;

    /* store the C-RNTI and send rlc_reestablishment request to SMC. RNTI update 
    will be done after Channel configuration*/
    if (RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,new_C_RNTI)
         && (rrccu_state_indicator != rrc_RRC_StateIndicator_cell_DCH)) 
    {
      rrccu_new_crnti_valid = TRUE;
      rrc_translate_crnti(&cu_confirm_ptr->new_C_RNTI,&rrccu_new_crnti);
    }
    if(RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,new_U_RNTI))
    {
      rrccu_new_urnti_valid = TRUE;
      rrc_translate_urnti(&cu_confirm_ptr->new_U_RNTI,&rrccu_new_urnti);
    }

    /*check whether this procedure involves SRNS reloc */
    if (rrccu_cucnf_for_srns_relocation)
    {
      /*commit fresh values for srns relocation */
      rrcsmc_commit_fresh_for_srns_relocation();
    }
    /* Allocates the buffer to RRC Internal command */
      cmd_ptr =  rrc_get_int_cmd_buf();
      rrccu_cipher_update_required = FALSE;
      
      no_of_RBs = 0; /* Initialize the no of RBs */

      /* Fill in the command parameters for RRC_CHANNEL_CONFIG_REQ */
      cmd_ptr->cmd_hdr.cmd_id = RRC_CHANNEL_CONFIG_REQ;
      cmd_ptr->cmd.chan_config_req.procedure = RRC_PROCEDURE_CU;
  
      /* Fill in parameters for RRC_CHANNEL_CONFIG_REQ command */
      if (rrccu_state_indicator == rrc_RRC_StateIndicator_cell_DCH)
      {
        //if we r going to dch, then dl-common-info-for-all-rl will be present..
        //check if ciphering is active in mac for cs domain, if it is then,
        //start 2 tiered HHO procedure STEP_1 and STEP_2 for rl-re-establishment
        if(rrcsmc_tm_ciph_active() == TRUE)
        {
          uint32 mac_d_hfn_l=RRCSMC_INVALID_HFN_VALUE;
  
          WRRC_MSG0_HIGH("REL8: RL-cipher present in TM-rb's");
  
          if (RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,dl_CommonInformation))
          {
            if(RRC_MSG_COMMON_BITMASK_IE(cu_confirm_ptr->dl_CommonInformation,rrc_DL_CommonInformation_r8,dl_dpchInfoCommon))
            {
              (void) rrcrb_get_mac_d_hfn(( 
                RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr->dl_CommonInformation.dl_dpchInfoCommon.u.
                dl_DPCH_InfoCommon,
                rrc_DL_DPCH_InfoCommon_r6,mac_d_HFN_initial_value)), 
                &cu_confirm_ptr->dl_CommonInformation.dl_dpchInfoCommon.u.
                dl_DPCH_InfoCommon->mac_d_HFN_initial_value, &mac_d_hfn_l);
            }
          }
  
          if(SUCCESS == rrcsmc_process_cipher_config_for_hho(mac_d_hfn_l)) 
          {
            rrccu_cipher_update_required = TRUE;
          }
        }
        else
        {
          WRRC_MSG0_HIGH("REL8: RL-cipher not-present in TM");
        }
  
        /* Change the state if it is not CELL_PCH or URA_PCH */
        cmd_ptr->cmd.chan_config_req.rrc_state_change_required = TRUE;
        cmd_ptr->cmd.chan_config_req.next_state = state;
      }/* next state id DCH*/
      else /*next state is FACH*/
      {
        cmd_ptr->cmd.chan_config_req.rrc_state_change_required = FALSE;
      }

      cmd_ptr->cmd.chan_config_req.rrc_channel_config_cnf_required = TRUE;
  
      no_of_RBs = rrccu_update_chan_config_rb_r8(cu_confirm_ptr, cmd_ptr->cmd.chan_config_req.rb);
  
#ifdef FEATURE_WCDMA_HS_FACH
      if (rrcenhstate_camped_cell_supports_e_fach()&&
             (rrccu_state_indicator ==rrc_RRC_StateIndicator_cell_FACH))
      {
        no_of_RBs = rrccu_update_chan_config_rb_r7_for_efach(no_of_RBs,cmd_ptr->cmd.chan_config_req.rb);
      }
#endif

      cmd_ptr->cmd.chan_config_req.num_rb_to_config =(int) no_of_RBs;
  
      rrc_fill_rb_id_chan_req_from_standalone_db(&no_of_RBs, &cmd_ptr->cmd.chan_config_req);
  
      if(rrccu_state_indicator == rrc_RRC_StateIndicator_cell_DCH)
      {
        /*Fill those RBs in chan_config_req for which RLC PDU size has changed and 
        that are already not present in chan_config_req*/
        rrc_fill_rb_id_chan_req_from_rb_list_mapped_to_dch(&no_of_RBs, 
                      &cmd_ptr->cmd.chan_config_req);
      }
  
      /*If state transition is Cell_FACH->Cell_DCH, add all the existing AM SRBs and 
      PS RBs in chan_config_req*/
      if((rrc_get_state() == RRC_STATE_CELL_FACH) && 
                    (rrccu_state_indicator == rrc_RRC_StateIndicator_cell_DCH))
      {
        rrc_fill_rb_id_chan_req_from_est_rabs(&no_of_RBs, 
                      &cmd_ptr->cmd.chan_config_req);
        rrc_fill_srb_in_chan_config_req(&no_of_RBs,&cmd_ptr->cmd.chan_config_req);
      }
      cmd_ptr->cmd.chan_config_req.chan_config_reason = RRCLLC_CHAN_CFG_REASON_NONE;

      /*call the function that evaluates the directed cell info and set the flags accordingly */
      if ((rrc_RRC_StateIndicator_cell_FACH == rrccu_state_indicator) &&
          (rrcrb_validate_directed_cell_info (directed_cell_info) == FALSE))
      {
        if(rrccsp_check_initiate_cell_selection_handling(NULL) == FALSE)
        {
          rrccu_cu_initiate_reqd.cu_reqd = TRUE;
          rrccu_cu_initiate_reqd.cu_cause = rrc_CellUpdateCause_cellReselection;
          WRRC_MSG1_HIGH("CHANNEL_CONFIG_REQ for %dRBs",no_of_RBs);
          rrc_put_int_cmd(cmd_ptr);  /* sends the command to RRC LLC. */
          rrccu_substate = RRCCU_WAIT_FOR_RB_EST_CNF;         
        }
        else
        {
          rrccu_intiate_cell_selection_within_fach_cu_cnf(cmd_ptr);
          cmd_ptr = NULL;
        }
      }
      else
      {
        WRRC_MSG1_HIGH("CHANNEL_CONFIG_REQ for %dRBs", no_of_RBs);
  
        rrc_put_int_cmd(cmd_ptr); /* sends the command to RRC LLC. */
        rrccu_substate = RRCCU_WAIT_FOR_RB_EST_CNF;         
      }
    if(RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,cn_InformationInfo))
    {
      (void) rrc_ccm_send_nas_cn_info_r6(&(cu_confirm_ptr->cn_InformationInfo));
    } 
  }
  return;
}

/*===========================================================================
FUNCTION rrccu_process_freq_redirection_info_r8

DESCRIPTION
  This function processes the REl 8 CELL UPDATE CONFIRM message for Freq Redirection.
  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS
  None
===========================================================================*/
boolean rrccu_process_freq_redirection_info_r8
(
  rrc_CellUpdateConfirm_r8_IEs * cu_confirm_ptr,
  rrcrb_directed_cell_info_type * directed_cell_info_ptr
)
{
  rrcrb_directed_cell_info_type          directed_cell_info; /* directed cell info struct */

  memset(&directed_cell_info, 0, sizeof(rrcrb_directed_cell_info_type));

  /* Populate the local variables to indicate if Re-direction info is present */
  directed_cell_info.freq_info_present = FALSE;
  directed_cell_info.pscr_present = FALSE;

  if((rrccu_state_indicator ==rrc_RRC_StateIndicator_cell_FACH) ||( rrccu_state_indicator==rrc_RRC_StateIndicator_cell_PCH) 
      ||(rrccu_state_indicator==rrc_RRC_StateIndicator_ura_PCH))
  {
    if((RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,frequencyInfo))
         && (cu_confirm_ptr->frequencyInfo.modeSpecificInfo.t == 
       T_rrc_FrequencyInfo_modeSpecificInfo_fdd))
    {
      directed_cell_info.freq_info_present = TRUE;
      directed_cell_info.uarfcn_dl = cu_confirm_ptr->frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_DL;
    }
  
    if((RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,dl_InformationPerRL_List))
        &&(cu_confirm_ptr->dl_InformationPerRL_List.elem[0].modeSpecificInfo.t ==
         T_rrc_DL_InformationPerRL_r8_modeSpecificInfo_fdd))
    {
        WRRC_MSG1_HIGH("REL8: Primary SCR in CU Cnf message %d",
           cu_confirm_ptr->dl_InformationPerRL_List.elem[0].modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode);
        directed_cell_info.pscr_present = TRUE;
        directed_cell_info.pscr = cu_confirm_ptr->dl_InformationPerRL_List.elem[0].modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode;
    }
  }

  if ((rrc_RRC_StateIndicator_cell_FACH == rrccu_state_indicator) && (rrcrb_validate_directed_cell_info (directed_cell_info) == FALSE))
  {
    /* If UE still has to send a response to the previous Cu Cnf with directed info
     * and it receives another Cu Cnf with directed info, then send failure
     * If the previous Cu Cnf had directed info, then atleast a PCRC Complete
     * has to be pending as a response.
     */
    if( rrccu_int_data.rrccu_cell_selection_last_response_msg != RRCCU_NO_RESP_MSG )
    {
       WRRC_MSG0_ERROR("Previous Cu Cnf sent a directed info, cannot accept another Cu Cnd with directed info");
       /* Set the Transaction Id */
       rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;
       /* Set Failure cause */
    
       rrccu_failure_cause.failureCause.t = 
         T_rrc_FailureCauseWithProtErr_incompatibleSimultaneousReconfiguration;

    
       rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
       return FALSE;
    }
  }

  directed_cell_info_ptr->freq_info_present = directed_cell_info.freq_info_present;
  directed_cell_info_ptr->uarfcn_dl = directed_cell_info.uarfcn_dl;
  directed_cell_info_ptr->pscr_present = directed_cell_info.pscr_present;
  directed_cell_info_ptr->pscr = directed_cell_info.pscr;

  return TRUE;
}

/*===========================================================================

FUNCTION RRCCU_RESPONSE_TO_CELL_UPDATE_CONFIRM_R8

DESCRIPTION
  This function evaluates CELL UPDATE CONFIRM message and decides what
  response message has to be sent
  Cell Update message.
  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
rrccu_resp_msg_e_type rrccu_find_response_to_cell_update_confirm_r8
(
  rrc_CellUpdateConfirm_r8_IEs *cucnf_ptr
)
{
  rrccu_resp_msg_e_type resp_msg= RRCCU_NO_RESP_MSG;


  /* In RB Release present send RB Release complete */
  
  if(RRCRB_R8_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r8_IEs,rb_InformationReleaseList))
  {
    resp_msg = RRCCU_RBR_COMPLETE_RESP_MSG;
  }
    /* else if rb reconfig present send Reconfig complete*/
  else if ((RRCRB_R8_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r8_IEs,rb_InformationReconfigList))
                || (RRCRB_R8_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r8_IEs,rb_InformationAffectedList)))
  {
    resp_msg = RRCCU_RBRC_COMPLETE_RESP_MSG;
  }
  /* else if Trch info is  present send Transport reconfig  complete*/
  else if ((RRCRB_R8_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r8_IEs,ul_CommonTransChInfo))
                || (RRCRB_R8_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r8_IEs,ul_deletedTransChInfoList))
                ||(RRCRB_R8_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r8_IEs,ul_AddReconfTransChInfoList))
                || (RRCRB_R8_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r8_IEs,dl_CommonTransChInfo))
                ||(RRCRB_R8_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r8_IEs,dl_DeletedTransChInfoList))
                || (RRCRB_R8_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r8_IEs,dl_AddReconfTransChInfoList)) )
  {
    resp_msg = RRCCU_TCR_COMPLETE_RESP_MSG;
  }
   /* else if Physical channel info  is  present send Physical Channel reconfig  complete*/
  else if ((RRCRB_R8_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r8_IEs,ul_DPCH_Info))
                || (RRCRB_R8_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r8_IEs,dl_CommonInformation))
                ||(RRCRB_R8_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r8_IEs,dl_InformationPerRL_List))
                ||(RRCRB_R8_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r8_IEs,ul_EDCH_Information ))
                || (RRCRB_R8_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r8_IEs,dl_HSPDSCH_Information))
                || (RRCRB_R8_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r8_IEs,frequencyInfo))
                ||(RRCRB_R8_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r8_IEs,maxAllowedUL_TX_Power))
                ||(RRCRB_R8_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r8_IEs,dtx_drx_TimingInfo))
                ||(RRCRB_R8_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r8_IEs,dtx_drx_Info))
#ifdef FEATURE_WCDMA_DC_HSDPA
                ||(RRCRB_R8_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r8_IEs,dl_SecondaryCellInfoFDD))
#endif
  )
  {
    resp_msg = RRCCU_PCR_COMPLETE_RESP_MSG;
  }
   /* else if Utran Mobility info  is  present, send  Utran Mobility info  complete*/
  else if ((RRCRB_R8_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r8_IEs,cn_InformationInfo))
                || (RRCRB_R8_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r8_IEs,cipheringModeInfo))
                ||(RRCRB_R8_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r8_IEs,integrityProtectionModeInfo))
                ||(RRCRB_R8_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r8_IEs,new_U_RNTI))
                || (RRCRB_R8_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r8_IEs,new_C_RNTI)))                
  {
    resp_msg = RRCCU_UMIC_COMPLETE_RESP_MSG;
  }
  else if (!((RRCRB_R8_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r8_IEs,rb_InformationReleaseList))
                || (RRCRB_R8_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r8_IEs,rb_InformationReconfigList))
                || (RRCRB_R8_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r8_IEs,rb_InformationAffectedList))
                ||(RRCRB_R8_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r8_IEs,ul_CommonTransChInfo))
                || (RRCRB_R8_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r8_IEs,ul_deletedTransChInfoList))
                ||(RRCRB_R8_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r8_IEs,ul_AddReconfTransChInfoList))
                || (RRCRB_R8_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r8_IEs,dl_CommonTransChInfo))
                ||(RRCRB_R8_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r8_IEs,dl_DeletedTransChInfoList ))
                || (RRCRB_R8_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r8_IEs,dl_AddReconfTransChInfoList))
                ||(RRCRB_R8_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r8_IEs,ul_DPCH_Info))
                || (RRCRB_R8_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r8_IEs,dl_CommonInformation))
                ||(RRCRB_R8_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r8_IEs,dl_InformationPerRL_List))
                ||(RRCRB_R8_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r8_IEs,ul_EDCH_Information ))
                || (RRCRB_R8_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r8_IEs,dl_HSPDSCH_Information))
                ||(RRCRB_R8_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r8_IEs,cn_InformationInfo))
                || (RRCRB_R8_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r8_IEs,cipheringModeInfo))
                ||(RRCRB_R8_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r8_IEs,integrityProtectionModeInfo))
                ||(RRCRB_R8_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r8_IEs,new_U_RNTI ))
                || (RRCRB_R8_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r8_IEs,new_C_RNTI))
                ||(RRCRB_R8_MSG_IE_PRESENT(cucnf_ptr,rrc_CellUpdateConfirm_r8_IEs,frequencyInfo)))
              )
  {
    resp_msg = RRCCU_NO_RESP_MSG;
  }

  return resp_msg;
}

/*===========================================================================

FUNCTION rrccu_validate_rb_info_r8

DESCRIPTION
  This function validates the Rb related IEs in Cu Cnf
  Cell Update message.
  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
boolean rrccu_validate_rb_info_r8
(
   rrc_CellUpdateConfirm_r8_IEs * cu_confirm_ptr
)
{

  rrc_RB_InformationReleaseList *rrc_rb_information_release_list;
                                              /* Local pointer to preserve the
                                                 head of linked list */  
  rrc_RB_InformationAffectedList_r8 *rrc_rb_information_affected_list; 
  uint32 rb_idx=0;
                                              
  if( RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,rb_InformationReconfigList))
  {
    /* Save the linked list head pointer */
    if (FAILURE == rrcllc_validate_rb_info_reconfig_list_r8(
        &cu_confirm_ptr->rb_InformationReconfigList))
    {
      return FALSE;
    }
  }
  
  
  if(RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,rb_InformationReleaseList))
  {
    /* Save the linked list head pointer */ 
    rrc_rb_information_release_list = 
      &cu_confirm_ptr->rb_InformationReleaseList;
    
    while(rrc_rb_information_release_list->n > rb_idx)
    { 
      /* Check whether rb id in rb release list is in the established rabs list.  If not set msg_not_valid variable
         to true to resend cell update msg with failure cause  */
      if (RRC_RB_NOT_PRESENT == validate_rb_id_in_release_list(
                            (rrc_rb_information_release_list->elem[rb_idx])))
      {
        /* RB Message was invalid. */
        WRRC_MSG1_ERROR("Invalid RB id:%d in rb_InformationReleaseList of CUCnf Msg",
          rrc_rb_information_release_list->elem[rb_idx] );
        return FALSE;
      }      
      rb_idx++;
    } 
  }
  
  if( RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,rb_InformationAffectedList))
  {
    rb_idx =0;
    /* Save the head pointer of linked list */
    rrc_rb_information_affected_list = 
      &cu_confirm_ptr->rb_InformationAffectedList;
    do
    { 
      /* Check whether rb id in rb affected list is in the established rabs list.  If not set msg_not_valid variable
      to true to resend cell update msg with failure cause  */
      if (RRC_RB_NOT_PRESENT == validate_rb_id_in_reconfig_list(
          (rrc_rb_information_affected_list->elem[rb_idx].rb_Identity)))
      {
        /* RB Message was invalid. */
        WRRC_MSG1_ERROR("Invalid RB id:%d in rb_InformationAffectedList of CUCnf Msg",
          rrc_rb_information_affected_list->elem[rb_idx].rb_Identity );
        return FALSE;
      }
      /* Advance the Linked List pointer */
      rb_idx++;
      
    } while(rrc_rb_information_affected_list->n > rb_idx);
  }

  if((RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,rb_InformationReleaseList))
     && (( RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,rb_InformationReconfigList)) ||
       ( RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,rb_InformationAffectedList))   ))
  {
    if(rrccu_validate_rel_rb_exist_in_reconfig_list_r8(cu_confirm_ptr) == TRUE)
    {
        return FALSE;
    }
  }
  return TRUE;
}


/*===========================================================================
FUNCTION rrccu_update_chan_config_rb_r8

DESCRIPTION
 
  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
uint32 rrccu_update_chan_config_rb_r8
(
 rrc_CellUpdateConfirm_r8_IEs * cu_confirm_ptr,
 rrc_rb_config_type * rb_info
)
{
  uint32   no_of_RBs = 0;
  /* Local var to store Ordered Config
                                       status */
   rrc_RB_InformationReleaseList *rrc_rb_information_release_list;
                                    /* Local pointer to preserve the
                                       head of linked list */  
   rrc_RB_InformationReconfig_r8 *rrc_rb_information_reconfig_ptr; 
  
   rrc_RB_InformationAffectedList_r8 *rrc_rb_information_affected_list; 
          /* Pointer to the RRC Command */
   uint32 rb_idx=0;
  
  
  if(RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,rb_InformationReleaseList))
  {
    /* set to flag to indicate that rb release information is present
    in the message. This information will be used after channel configu
    ration to release the rbs from established_rab and also to indicate
    to the upper layers about RAB release if necessary */
    rrccu_rb_release_info.rrccu_rb_release_in_cucnf = TRUE;
    /* Save the linked list head pointer */ 
    rrc_rb_information_release_list = 
      &cu_confirm_ptr->rb_InformationReleaseList;
  
      /* If voice RAB still exist, then indicate layer 1 that next configuration is going to
         include AMR configuration.
         This check is not required if state change indication is either cell_PCH, URA_PCH or
         CELL_FACH, because if voice is configured then next state has to be CELL_DCH.
      */
      if ((rrc_RRC_StateIndicator_cell_DCH == rrccu_state_indicator) && (FALSE == 
          rrc_is_given_rb_rel_list_releases_all_rb_for_voice_rab(
                            rrc_rb_information_release_list)))
      {
        rrc_indicate_layer1_next_config_is_for_voice();
      }
    rb_idx =0;
    while(rrc_rb_information_release_list->n > rb_idx)
    { 
      if( rrc_rb_information_release_list->elem[rb_idx] == DCCH_DT_LOW_PRI_RADIO_BEARER_ID)
      {
        if(RRCLCM_RLC_LC_ID_NOT_FOUND == rrclcm_check_dl_rlc_lc_id(
                                            UE_LOGCHAN_DCCH,
                                            DCCH_DT_LOW_PRI_RADIO_BEARER_ID,
                                            UE_MODE_ACKNOWLEDGED_DATA))
        {
          WRRC_MSG1_HIGH("Ignore Non-exitent rb_id =%d in cucnf",rrc_rb_information_release_list->elem[rb_idx]);
          rb_idx++;
          continue;
        }
      }
      else if(! rrc_find_rb_in_est_rabs(rrc_rb_information_release_list->elem[rb_idx])) 
      {
        WRRC_MSG1_HIGH("Ignore Non-exitent rb_id = %d in cucnf",rrc_rb_information_release_list->elem[rb_idx]);
        rb_idx++;
        continue;
      }
      else if (MAX_RB != rrccu_check_if_rbid_present_in_rrccu_rb_release_info(rrc_rb_information_release_list->elem[rb_idx],no_of_RBs))
      {
        WRRC_MSG1_ERROR(" Ignoring Duplicate RB ID % d in CU ",rrc_rb_information_release_list->elem[rb_idx]);
        rb_idx++;
        continue;
      }

      WRRC_MSG1_HIGH("Release RB i.d = %d",rrc_rb_information_release_list->elem[rb_idx]);
      rb_info[no_of_RBs].rb_id = 
      rrc_rb_information_release_list->elem[rb_idx];
  
      rb_info[no_of_RBs].rb_config = RELEASE_RB;
  
      if(no_of_RBs < MAX_RB)
      {
        /* store the rb info to release list in local buffer which will
             be used later to release it from established_rab variable */
        rrccu_rb_release_info.rb_id[no_of_RBs]=rrc_rb_information_release_list->elem[rb_idx];
      }
      else
      {
        WRRC_MSG1_ERROR("No. of RBs reached the MAX %d",MAX_RB);
      }
      /* Advance the Linked List pointer */
      rb_idx++;
      no_of_RBs++;
    } 
  
    rrccu_rb_release_info.num_rbs = no_of_RBs;
  
    rrcrb_update_mac_rab_status(RRC_PROCEDURE_CU, RRC_CS_DOMAIN_CN_ID,
                                &cu_confirm_ptr->rb_InformationReleaseList,
                                FALSE);
  }
  else
  {
      /* It means CU Confirm doesnt include information to release any RB. 
         check if AMR RAB was established earlier. If yes then indicate layer 1 that
         next configuration will be for AMR.
         This check is not required if state change indication is either cell_PCH, URA_PCH or
         CELL_FACH, because if voice is configured then next state has to be CELL_DCH.                   
      */
      if ((rrc_RRC_StateIndicator_cell_DCH == rrccu_state_indicator) && 
                                (TRUE == rrc_is_voice_rab_present()))
      {
        rrc_indicate_layer1_next_config_is_for_voice();
      }
    }
  
  if( RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,rb_InformationReconfigList))
  {
    rb_idx=0;
    do
    { 
      /* Save the linked list head pointer */
      rrc_rb_information_reconfig_ptr = 
      &cu_confirm_ptr->rb_InformationReconfigList.elem[rb_idx];
      rb_info[no_of_RBs].rb_id = 
              rrc_rb_information_reconfig_ptr->rb_Identity;
  
      rb_info[no_of_RBs].rb_config = RECONFIG_RB;
      rb_info[no_of_RBs].rb_config = RECONFIG_RB_OTA;
      rb_info[no_of_RBs].ul_cfg_mask = 0;
      rb_info[no_of_RBs].dl_cfg_mask = 0;
      if((RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_rb_information_reconfig_ptr, rrc_RB_InformationReconfig_r8,rlc_Info))
          &&(RRC_MSG_COMMON_BITMASK_IE(rrc_rb_information_reconfig_ptr->rlc_Info,rrc_RLC_Info_r7,ul_RLC_Mode)))
      {
        rb_info[no_of_RBs].ul_cfg_mask = MODIFY_RB_CFG;
      }
      if((RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_rb_information_reconfig_ptr, rrc_RB_InformationReconfig_r8,rlc_Info))
          &&(RRC_MSG_COMMON_BITMASK_IE(rrc_rb_information_reconfig_ptr->rlc_Info,rrc_RLC_Info_r7,dl_RLC_Mode)))
      {
        rb_info[no_of_RBs].dl_cfg_mask = MODIFY_RB_CFG;
      }

      if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_rb_information_reconfig_ptr, 
          rrc_RB_InformationReconfig_r8,rb_StopContinue))
      {
        if (rrc_rb_information_reconfig_ptr->rb_StopContinue == rrc_RB_StopContinue_stopRB)
        {
          rb_info[no_of_RBs].ul_cfg_mask |= STOP_RB_CFG;
          rb_info[no_of_RBs].dl_cfg_mask |= STOP_RB_CFG;
          WRRC_MSG1_HIGH("Stop recvd for RB %d", (rrc_rb_information_reconfig_ptr->rb_Identity));
        }
        else if (rrc_rb_information_reconfig_ptr->rb_StopContinue == rrc_RB_StopContinue_continueRB)
        {
          rb_info[no_of_RBs].ul_cfg_mask |= CONTINUE_RB_CFG;
          rb_info[no_of_RBs].dl_cfg_mask |= CONTINUE_RB_CFG;
          WRRC_MSG1_HIGH("Continue recvd for RB %d", (uint16)(rrc_rb_information_reconfig_ptr->rb_Identity));
        }
      }
      /* Advance the Linked List pointer */
      rb_idx++;
      no_of_RBs++;
       
    } while(cu_confirm_ptr->rb_InformationReconfigList.n > rb_idx) ;
  }
  if(RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,rb_InformationAffectedList))
  {
    /* Save the head pointer of linked list */
    rrc_rb_information_affected_list = 
      &cu_confirm_ptr->rb_InformationAffectedList;
  
    do
    { 
      rb_info[no_of_RBs].rb_id = 
          rrc_rb_information_affected_list->elem[rb_idx].rb_Identity;
  
      rb_info[no_of_RBs].rb_config = RECONFIG_RB;
      rb_info[no_of_RBs].rb_config = RECONFIG_RB_OTA;
      rb_info[no_of_RBs].ul_cfg_mask = rb_info[no_of_RBs].dl_cfg_mask = MODIFY_RB_CFG;

      /* Advance the Linked List pointer */
      rb_idx++;
  
      no_of_RBs++;
  
    } while(rrc_rb_information_affected_list->n > rb_idx);
  }
  
  return no_of_RBs;
  
  }


/*===========================================================================
FUNCTION rrccu_validate_rel_rb_exist_in_reconfig_list_r8

DESCRIPTION
  This function checks if the Cu Cnf has the same RB ID in the RB Release list
   and also in RB Reconfig/RB Affected List
  
DEPENDENCIES
  None

RETURN VALUE
  True, if same RB ID is present in RB Release list and also in RB Reconfig/RB Affected List
  else
  FALSE
  
SIDE EFFECTS

  None

===========================================================================*/
boolean rrccu_validate_rel_rb_exist_in_reconfig_list_r8
(
  rrc_CellUpdateConfirm_r8_IEs * cu_confirm_ptr
)
{
  rrc_RB_Identity released_rb_id= 0xFF;
  rrc_RB_InformationReleaseList *rrc_rb_information_release_list;
                                            /* Local pointer to preserve the
                                               head of linked list */  
  rrc_RB_InformationReconfig_r8 *rrc_rb_information_reconfig_ptr; 
  
  rrc_RB_InformationAffectedList_r8 *rrc_rb_information_affected_list; 
  uint32 idx=0,idy=0;
    /* Save the linked list head pointer */ 
  rrc_rb_information_release_list = 
      &cu_confirm_ptr->rb_InformationReleaseList;
    
  while(rrc_rb_information_release_list->n > idx)
  { 
  
    released_rb_id =rrc_rb_information_release_list->elem[idx];
    if( RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,rb_InformationReconfigList))
    {
      /* Save the linked list head pointer */
      idy=0;
      do
      {
        rrc_rb_information_reconfig_ptr = 
        &cu_confirm_ptr->rb_InformationReconfigList.elem[idy];
      
        /* Check whether rb id in rb reconfig list is in the established rabs list.  If not set msg_not_valid variable
           to true to resend cell update msg with failure cause  */
        if (rrc_rb_information_reconfig_ptr->rb_Identity == released_rb_id  )
        {
          /* RB Message was invalid. */
          WRRC_MSG1_ERROR(" RB id:%d in rb_InformationReconfigList  and RB Release list of CUCnf Msg",
             rrc_rb_information_reconfig_ptr->rb_Identity );
          return TRUE;
        }
                 
        /* Advance the Linked List pointer */
        idy++;;
      }while(cu_confirm_ptr->rb_InformationReconfigList.n > idy);
    }
  
    if(RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,rb_InformationAffectedList))
    {
      /* Save the head pointer of linked list */
      rrc_rb_information_affected_list = 
       &cu_confirm_ptr->rb_InformationAffectedList;
      idy=0;
      do
      { 
        /* Check whether rb id in rb affected list is in the established rabs list.  If not set msg_not_valid variable
        to true to resend cell update msg with failure cause  */
        if (rrc_rb_information_affected_list->elem[idy].rb_Identity == released_rb_id )
        {
          /* RB Message was invalid. */
          WRRC_MSG1_ERROR(" RB id:%d in rb_InformationAffectedList  and RB Release list of CUCnf Msg",
             rrc_rb_information_affected_list->elem[idy].rb_Identity );
          return TRUE;
        }
        /* Advance the Linked List pointer */
        idy++;
        
      } while(rrc_rb_information_affected_list->n > idy);
    }
     
    idx++;
  } 
  
  return FALSE;
}



/*===========================================================================
      
      FUNCTION RRCCU_GET_URA_ID
      
      DESCRIPTION
        
      This function will populate the URA_ID in the arguments passed
        
      DEPENDENCIES
        None
      
      RETURN VALUE
        None
        
      SIDE EFFECTS
      
        None
      
===========================================================================*/

void rrccu_get_ura_id
(
  uint32 *ura_id
)
{
  *ura_id = rrccu_current_ura_id;
}



#ifdef FEATURE_WCDMA_HS_RACH
/*===========================================================================
      
      FUNCTION rrccu_get_cu_initiate_reqd
      
      DESCRIPTION
        
      This function will return the rrccu_cu_initiate_reqd.cu_reqd flag
        
      DEPENDENCIES
        None
      
      RETURN VALUE
        None
        
      SIDE EFFECTS
      
        None
      
===========================================================================*/

boolean rrccu_get_cu_initiate_reqd(void)
{
  return(rrccu_cu_initiate_reqd.cu_reqd);
}
#endif
#ifdef FEATURE_WCDMA_REL9


/*===========================================================================
FUNCTION rrcu_process_cu_cnf_after_validation_r9

DESCRIPTION
  This function processes the REl 9 CELL UPDATE CONFIRM message after doing the initial validation
  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS
  None
===========================================================================*/
void rrcu_process_cu_cnf_after_validation_r9
(
  void *msg_ptr,                           /* Pointer to Downlink Msg */
  rrc_CellUpdateConfirm_r9_IEs *cu_confirm_ptr,
  uint32 dl_sdu_type                       /* Downlink SDU type */  
  ,rrcrb_directed_cell_info_type          directed_cell_info
)
{
  rrc_state_e_type state ;                    /* Local varible to store state */
  rrc_cmd_type *cmd_ptr;                      /* Pointer to the RRC Command */  
  rrc_int_c_rnti_type crnti;                  /* Local variable for C-RNTI */
  rrc_int_u_rnti_type urnti;                  /* Local variable for U-RNTI */  
  rrcllc_oc_status_e_type status;             /* Local var to store Ordered Config  status */

  rrc_update_reconfig_waiting_for_l2ack_dch(MAX_NUM_OF_PROCEDURES);

  /* if this cell update was due to RL faiure then stop any re-est timer that is running */
  if(((rrccu_cell_update_cause == rrc_CellUpdateCause_radiolinkFailure)||(rrccu_cell_update_cause == rrc_CellUpdateCause_re_enteredServiceArea)||
  (rrccu_cell_update_cause == rrc_CellUpdateCause_rlc_unrecoverableError)) && (rrccu_failure_state == RRC_STATE_CELL_DCH))
  {
    if (rrccu_rl_failure_info.t314_info.timer_status == RE_EST_TIMER_STARTED)
    {
      WRRC_MSG0_HIGH("Stopping T314");
      rrctmr_stop_timer(RRCTMR_T_314_TIMER); 
    }
    if (rrccu_rl_failure_info.t315_info.timer_status == RE_EST_TIMER_STARTED)
    {
      WRRC_MSG0_HIGH("Stopping T315");
      rrctmr_stop_timer(RRCTMR_T_315_TIMER); 
    }
  }

  state = rrc_translate_state_indicator_to_state(rrccu_state_indicator);

#ifdef FEATURE_WCDMA_HS_RACH
        /*If cell supports HS-RACH or HS-FACH then configure the E-RNTI and H-RNTI given in CUCNF*/
    if ((rrchsrach_camped_cell_supports_hsrach() == TRUE)&&
       ((rrccu_state_indicator ==rrc_RRC_StateIndicator_cell_FACH) ||
       (rrccu_state_indicator ==rrc_RRC_StateIndicator_cell_PCH) ||
       (rrccu_state_indicator ==rrc_RRC_StateIndicator_ura_PCH)))
    {
      if((RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,new_H_RNTI)) &&
        (RRCRB_R8_MSG_IE_PRESENT(cu_confirm_ptr,rrc_CellUpdateConfirm_r8_IEs,newPrimary_E_RNTI)))
      {
        /*store the hrnti*/
        (void)rrc_translate_hrnti(&cu_confirm_ptr->new_H_RNTI, &ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.h_rnti);
        rrc_set_hrnti_status(ordered_config_ptr, HRNTI_VALID);
        (void)rrc_translate_hrnti(&cu_confirm_ptr->new_H_RNTI, &transition_config.toc_ptr->l1_hsdpa_info.hs_dsch_info.h_rnti);
        rrc_set_hrnti_status(transition_config.toc_ptr, HRNTI_VALID);

        /*store the ernti*/
        ordered_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = TRUE;
        (void)rrc_translate_ernti(&cu_confirm_ptr->newPrimary_E_RNTI, &ordered_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti);

        transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = TRUE;
        transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti = ordered_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti;
        
        if(((rrccu_resp_msg == RRCCU_UMIC_COMPLETE_RESP_MSG) || (rrccu_resp_msg == RRCCU_NO_RESP_MSG))
        &&((directed_cell_info.freq_info_present == FALSE )&& (directed_cell_info.pscr_present == FALSE )))
        {
          rrcllc_establish_srb_rab_in_efach(RRC_E_FACH_DEDICATED,RRC_PROCEDURE_CU,FALSE);
        }
      }
    }
    else
#endif
#ifdef FEATURE_WCDMA_HS_FACH
    if (rrcenhstate_camped_cell_supports_e_fach()&&
        ((rrccu_state_indicator ==rrc_RRC_StateIndicator_cell_FACH)|| 
         (rrccu_state_indicator ==rrc_RRC_StateIndicator_cell_PCH) || 
         (rrccu_state_indicator ==rrc_RRC_StateIndicator_ura_PCH))
        )
    {
      if((RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,new_H_RNTI)))
      {
        if(((rrccu_resp_msg == RRCCU_UMIC_COMPLETE_RESP_MSG) || (rrccu_resp_msg == RRCCU_NO_RESP_MSG))
        &&((directed_cell_info.freq_info_present == FALSE )&& (directed_cell_info.pscr_present == FALSE )))
        {
          rrcllc_establish_srb_rab_in_efach(RRC_E_FACH_DEDICATED,RRC_PROCEDURE_CU,FALSE);
        }
      }
    }
#endif
  if((rrccu_resp_msg == RRCCU_UMIC_COMPLETE_RESP_MSG)
    &&(((directed_cell_info.freq_info_present == FALSE )&& (directed_cell_info.pscr_present == FALSE ))
    ||(rrccu_state_indicator ==rrc_RRC_StateIndicator_cell_DCH))
    )
  {
    if (rrc_get_rlc_size_change_status_for_procedure_id(RRC_PROCEDURE_CU))
    {
      rrcsmc_update_hfn_for_rlc_rb(rlc_size_change_in_progress.rb_id, 
                                 rlc_size_change_in_progress.direction);
    }

    if (!rrccu_cucnf_for_srns_relocation)
    {
      /* procedure does not involve SRNS relocation */
  
      /* need to send RNTI update request if any of the RNTIs is present
      in the message */
      if ((RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,new_C_RNTI)) ||
          (RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,new_U_RNTI)))
      {
        /* Allocates the buffer to RRC Internal command */
        cmd_ptr =  rrc_get_int_cmd_buf();
        /* Fill parameters for RRC_RNTI_UPDATE_REQ command */
        cmd_ptr->cmd.rnti_update_req.procedure = RRC_PROCEDURE_CU;
        cmd_ptr->cmd_hdr.cmd_id = RRC_RNTI_UPDATE_REQ;
  
        if (RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,new_C_RNTI)) 
        {
          rrc_translate_crnti(&cu_confirm_ptr->new_C_RNTI,&crnti);
          cmd_ptr->cmd.rnti_update_req.crnti_action = RRC_RNTI_UPDATE;
          cmd_ptr->cmd.rnti_update_req.crnti = crnti;

#ifdef FEATURE_WCDMA_HS_RACH
          if(rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH)
          {
            rrchsrach_set_hspa_rnti_stored_cell_pch(ordered_config_ptr,TRUE);
          }
#endif

        }
        else
        {
          cmd_ptr->cmd.rnti_update_req.crnti_action = RRC_RNTI_NOCHANGE;
        }
  
        if(RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,new_U_RNTI))
        {
          rrc_translate_urnti(&cu_confirm_ptr->new_U_RNTI, &urnti);
          cmd_ptr->cmd.rnti_update_req.urnti_action = RRC_RNTI_UPDATE;
          cmd_ptr->cmd.rnti_update_req.urnti= urnti;
        }
        else
        {
          cmd_ptr->cmd.rnti_update_req.urnti_action = RRC_RNTI_NOCHANGE;
        }
  
        /* Indicate to LLC if RLC for SRBs needs to be re-established */
        if(cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4 == TRUE)
        {
          cmd_ptr->cmd.rnti_update_req.rlc_re_establish_srb = TRUE;
        }
        else
        {
          cmd_ptr->cmd.rnti_update_req.rlc_re_establish_srb = FALSE;
        }
  
        /* Indicate to LLC if RLC for User plane RBs needs to be re-established */
        if(cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove == TRUE)
        {
          cmd_ptr->cmd.rnti_update_req.rlc_re_establish_rab = TRUE;
        }
        else
        {
          cmd_ptr->cmd.rnti_update_req.rlc_re_establish_rab = FALSE;
        }
  
        cmd_ptr->cmd.rnti_update_req.cnf_required = TRUE;
  
        WRRC_MSG2_HIGH("REL9: Sending RNTI update req CRNTI_stat:%d, URNTI_stat:%d", 
                  cmd_ptr->cmd.rnti_update_req.crnti_action,
                  cmd_ptr->cmd.rnti_update_req.urnti_action);
  
        rrc_put_int_cmd(cmd_ptr);       /* sends the command to RRC  LLC. */
  
        rrccu_substate = RRCCU_WAIT_FOR_RNTI_UPDATE_CNF;         
      }
      else
      {
        if (C_RNTI_NOT_VALID == rrcllc_get_current_crnti_status())
        {
          /* should not come here as this condition is already taken care in downlink
          sdu processing */
          WRRC_MSG1_ERROR("RNTI absent for UMIC message, next state %d",
                  rrc_get_state());
          /* Set the Transaction Id */
          rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;
  
          /* Set Failure cause */
          rrccu_failure_cause.failureCause.t = 
            T_rrc_FailureCauseWithProtErr_invalidConfiguration;

          rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
          /* continue with rrccu state  RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM */
          return;
        }
        rrccu_send_response_msg();
      }
      if( RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,cn_InformationInfo))
      {
        (void) rrc_ccm_send_nas_cn_info_r6(&(cu_confirm_ptr->cn_InformationInfo));
      } 
    }
    else
    {
      /* procedure involves SRNS relocation so store the C-RNTI
      and send rlc_reestablishment request to SMC . RNTI update 
      will be done after RLC re-establishment*/
      if (RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,new_C_RNTI)) 
      {
        rrccu_new_crnti_valid = TRUE;
        rrc_translate_crnti(&cu_confirm_ptr->new_C_RNTI,&rrccu_new_crnti);

#ifdef FEATURE_WCDMA_HS_RACH
        if(rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH)
        {
          rrchsrach_set_hspa_rnti_stored_cell_pch(ordered_config_ptr,TRUE);
        }
#endif

      }
      if(RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,new_U_RNTI))
      {
        rrccu_new_urnti_valid = TRUE;
        rrc_translate_urnti(&cu_confirm_ptr->new_U_RNTI,&rrccu_new_urnti);
      }
      /* store the rlc re-establishment indications */
      rrccu_reestablish_srb = cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4;
      rrccu_reestablish_rab = cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove;
  
      //commit fresh values for srns relocation
      rrcsmc_commit_fresh_for_srns_relocation();
  
      rrccu_send_re_est_rlc_for_srns_req (RRC_RE_EST_RB_2, TRUE);
        
      if(RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,cn_InformationInfo))
      {
        (void) rrc_ccm_send_nas_cn_info_r6(&(cu_confirm_ptr->cn_InformationInfo));
      } 
    }
  }

  else if(( rrccu_resp_msg == RRCCU_NO_RESP_MSG)
    &&(((directed_cell_info.freq_info_present == FALSE ) && (directed_cell_info.pscr_present == FALSE ))
    ||(  rrccu_state_indicator ==rrc_RRC_StateIndicator_cell_DCH))
    ) 
  {
    rrccu_check_and_send_response_to_previous_cell_upd_cnf();
  
        /* if any rlc entity has to be re-established then re-establish it before configuring channels. */
        if((cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4 == TRUE) ||
            (cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove == TRUE))
        {
          /* store the rlc re-establishment indications */
          rrccu_reestablish_srb = cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4;
          rrccu_reestablish_rab = cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove;
          rrccu_new_crnti_valid = FALSE;
          rrccu_new_urnti_valid = FALSE;
          rrccu_send_rnti_update_req(FALSE);
          WRRC_MSG2_HIGH("CU Confirm R9: RNTI_UPDATE_REQ  to reestablish SRBs(%d)  DataRB (%d)",
                       rrccu_reestablish_srb,rrccu_reestablish_rab);
        }
        rrccu_reestablish_srb = FALSE;
        rrccu_reestablish_rab = FALSE;
    /* if the next state is cell_pch or ura_pch then setup pcch */
    if((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH) ||(rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH))
    {
      if(  RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,cn_InformationInfo))
      {
        (void) rrc_ccm_send_nas_cn_info_r6(&(cu_confirm_ptr->cn_InformationInfo));
      } 
      /*set the UTRAN DRX coef in rrcllc */
      rrcllc_set_utran_drx_info (rrccu_utran_drx_coef); 
      rrccu_establish_pcch_rb (state);
      rrccu_substate = RRCCU_WAIT_FOR_PCCH_RB_EST_CNF;
    }
    else 
    {
      /* Reset the state machine and the procedure ends */
      rrccu_substate = RRCCU_INITIAL;
      /* Start timer T305 */
      rrctmr_start_timer(RRCTMR_T_305_TIMER, rrc_convert_t305_to_ms(RRC_GET_T305()));

      if( RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,cn_InformationInfo))
      {
        (void) rrc_ccm_send_nas_cn_info_r6(&(cu_confirm_ptr->cn_InformationInfo));
      } 
      /* Inform all registered RRC procedures that Cell Update is completed */
      rrccu_inform_cell_update_completed();
   
      rrccu_process_successful_completion();
     
      /*call the procedure to clear the global variabls */
      rrccu_clear_procedure();
      rrccu_init_last_cu_cnf_info();
    }
  }
  else
  {
    status = rrcllc_set_ordered_config(RRC_PROCEDURE_CU, state, dl_sdu_type, msg_ptr) ;
    switch( status  )
    {
      case ORDERED_CONFIG_SET:
        rrccu_process_after_oc_config_set_r9(cu_confirm_ptr
                                                                        ,directed_cell_info
                                                                        );
        break;
  
      case ORDERED_CONFIG_INCOMPATABLE_SIMULTANEOUS_RECONFIG:
        /* This should not occur for CELL UPDATE CONFIRM */
        /* Set the Transaction Id */
        rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;
  
        /* Set Failure cause */
        rrccu_failure_cause.failureCause.t = 
          T_rrc_FailureCauseWithProtErr_incompatibleSimultaneousReconfiguration;
 
        rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
        break;
  
      case ORDERED_CONFIG_CONFIGURATION_NOT_SUPPORTED:
        /* Set the Transaction Id */
        rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;
  
        /* Set Failure cause */
        rrccu_failure_cause.failureCause.t = 
          T_rrc_FailureCauseWithProtErr_configurationUnsupported;

  
        rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
        break;
  
      case ORDERED_CONFIG_NOT_SET_OTHER:
        /* For Cell Update Confirm message RRC LLC should never set Ordered Config */
        WRRC_MSG0_ERROR("Ordered Config Should not return this status");
        break;
  
      case ORDERED_CONFIG_CONFIGURATION_INVALID:
        /* Set the Transaction Id */
        rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;
  
        /* Set Failure cause */
        rrccu_failure_cause.failureCause.t = 
          T_rrc_FailureCauseWithProtErr_invalidConfiguration;
    
  
        rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
        break;
  
      default:
        WRRC_MSG0_ERROR("Invalid status from ORDERED_CONFIG");
        break;
    } 
  }  
  return;
}



/*===========================================================================
FUNCTION rrccu_process_after_oc_config_set_r9

DESCRIPTION
  This function processes the REl 9 CELL UPDATE CONFIRM after OC is set by CU CNF.
  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS
  None
===========================================================================*/
void rrccu_process_after_oc_config_set_r9
(
  rrc_CellUpdateConfirm_r9_IEs *cu_confirm_ptr
  ,rrcrb_directed_cell_info_type          directed_cell_info
)
{
  rrc_cmd_type *cmd_ptr;                      /* Pointer to the RRC Command */ 
  rrc_int_c_rnti_type crnti;                  /* Local variable for C-RNTI */
  rrc_int_u_rnti_type urnti;                  /* Local variable for U-RNTI */  
  uint32 no_of_RBs;                           /* Local variable to store no of RBs */
  rrc_state_e_type state ;                    /* Local varible to store state */

  /* set the flag.Later it will be used while clearing the OC */
  rrccu_oc_set_by_cu = TRUE;
  
  state = rrc_translate_state_indicator_to_state(rrccu_state_indicator);

  /*Cell_FACH -> Cell_PCH or Cell_FACH -> URA_PCH*/
  if((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH)||(rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH))
  {
    /*call the function that evaluates the directed cell info and set the flags accordingly */
    if (rrcrb_validate_directed_cell_info (directed_cell_info) == FALSE)
    {
      if(rrccsp_check_initiate_cell_selection_handling(&directed_cell_info) == FALSE)
      {
        rrccu_cu_initiate_reqd.cu_reqd = TRUE;
        rrccu_cu_initiate_reqd.cu_cause = rrc_CellUpdateCause_cellReselection;
      }
      else
      {
        rrccu_int_data.rrccu_cell_selection_trans_from_fach = TRUE;
      }
    }

    if(rrccu_resp_msg == RRCCU_UMIC_COMPLETE_RESP_MSG)
    {
      if(rrc_get_rlc_size_change_status_for_procedure_id(RRC_PROCEDURE_CU))
      {
        rrcsmc_update_hfn_for_rlc_rb(rlc_size_change_in_progress.rb_id, 
                                   rlc_size_change_in_progress.direction);
      }
    }
#ifdef FEATURE_WCDMA_HS_FACH
    if((rrcenhstate_camped_cell_supports_e_fach() == TRUE) &&
                  (rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH || rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH))
    {
      if(((RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,new_H_RNTI)))
#ifdef FEATURE_WCDMA_HS_RACH
          || (RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,newPrimary_E_RNTI))
#endif
        )
      {
#ifdef FEATURE_WCDMA_HS_RACH
        if((rrchsrach_camped_cell_supports_hsrach() == TRUE) && RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,newPrimary_E_RNTI))
        {
          current_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = TRUE;
          (void)rrc_translate_ernti(&cu_confirm_ptr->newPrimary_E_RNTI, &current_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti);
        }
#endif
          rrcllc_establish_srb_rab_in_efach(RRC_E_FACH_DEDICATED,RRC_PROCEDURE_CU,TRUE);
      }
    }
#endif

    /* copy the channel config info in to a local buffer we should configure the channels 
    after the response message is sent */
    rrccu_chan_config_info.num_rbs = rrccu_update_chan_config_rb_r9(cu_confirm_ptr,
                                                           rrccu_chan_config_info.rb_info);
    rrccu_chan_config_reqd = TRUE;

    if (! rrccu_cucnf_for_srns_relocation)
    {
      /* procedure does not involve SRNS relocation */
  
      /* CRNTI always must be present to send the response message */
      /* if cucnf message has new C-RNTI  then we need to update the C-RNTI in mac first and 
      send the response and then start the channel configuration */
      if (RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,new_C_RNTI))
      {
        /* Allocates the buffer to RRC Internal command */
        cmd_ptr =  rrc_get_int_cmd_buf();
        /* Fill parameters for RRC_RNTI_UPDATE_REQ command */
        cmd_ptr->cmd.rnti_update_req.procedure = RRC_PROCEDURE_CU;
        cmd_ptr->cmd_hdr.cmd_id = RRC_RNTI_UPDATE_REQ;
  
        rrc_translate_crnti(&cu_confirm_ptr->new_C_RNTI,&crnti);
        cmd_ptr->cmd.rnti_update_req.crnti_action = RRC_RNTI_UPDATE;
        cmd_ptr->cmd.rnti_update_req.crnti = crnti;
  
        if(RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,new_U_RNTI))
        {
          rrc_translate_urnti(&cu_confirm_ptr->new_U_RNTI, &urnti);
          cmd_ptr->cmd.rnti_update_req.urnti_action = RRC_RNTI_UPDATE;
          cmd_ptr->cmd.rnti_update_req.urnti= urnti;
        }
        else
        {
          cmd_ptr->cmd.rnti_update_req.urnti_action = RRC_RNTI_NOCHANGE;
        }
        /* Indicate to LLC if RLC for SRBs needs to be re-established */
        if(cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4 == TRUE)
        {
          cmd_ptr->cmd.rnti_update_req.rlc_re_establish_srb = TRUE;
        }
        else
        {
          cmd_ptr->cmd.rnti_update_req.rlc_re_establish_srb = FALSE;
        }
        /* Indicate to LLC if RLC for User plane RBs needs to be re-established */
        if(cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove == TRUE)
        {
          cmd_ptr->cmd.rnti_update_req.rlc_re_establish_rab = TRUE;
        }
        else
        {
          cmd_ptr->cmd.rnti_update_req.rlc_re_establish_rab = FALSE;
        }
        cmd_ptr->cmd.rnti_update_req.cnf_required = TRUE;
  
        WRRC_MSG2_HIGH("Sending RNTI update req CRNTI_stat:%d, URNTI_stat:%d", 
                  cmd_ptr->cmd.rnti_update_req.crnti_action,
                  cmd_ptr->cmd.rnti_update_req.urnti_action);
  
        rrc_put_int_cmd(cmd_ptr);       /* sends the command to RRC  LLC. */
  
        rrccu_substate = RRCCU_WAIT_FOR_RNTI_UPDATE_CNF;         
        if( RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,cn_InformationInfo))
        {
          (void) rrc_ccm_send_nas_cn_info_r6(&(cu_confirm_ptr->cn_InformationInfo));
        } 
      }
      else
      {
        /* We will be in Cell_FACH state at this time and going to send the response message in Cell_FACH state.*/
        WRRC_MSG1_HIGH("RNTI absent for RB resp message, next state%d", rrc_get_state());
        if( RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,cn_InformationInfo))
        {
          (void) rrc_ccm_send_nas_cn_info_r6(&(cu_confirm_ptr->cn_InformationInfo));
        } 
        if ((rrccu_int_data.rrccu_cell_selection_trans_from_fach) && (rrccu_resp_msg == RRCCU_NO_RESP_MSG))
        {
          rrccu_intiate_cell_selection_fach_pch_cu_cnf(); 
        }
        else
        {
          /* send the response message on the old configuration */
          rrccu_send_response_msg();
        }
      }
    }
    else
    {
      /* procedure involves SRNS relocation so store the C-RNTI
      and send rlc_reestablishment request to SMC . RNTI update 
      will be done after RLC re-establishment*/
      if (RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,new_C_RNTI)) 
      {
        rrccu_new_crnti_valid = TRUE;
        rrc_translate_crnti(&cu_confirm_ptr->new_C_RNTI,&rrccu_new_crnti);
      }
      if(RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,new_U_RNTI))
      {
        rrccu_new_urnti_valid = TRUE;
        rrc_translate_urnti(&cu_confirm_ptr->new_U_RNTI,&rrccu_new_urnti);
      }
      /* store the rlc re-establishment indications */
      rrccu_reestablish_srb = cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4;
      rrccu_reestablish_rab = cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove;
 
      //commit fresh values for srns relocation
      rrcsmc_commit_fresh_for_srns_relocation();
      rrccu_send_re_est_rlc_for_srns_req(RRC_RE_EST_RB_2, TRUE);
 
      if( RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,cn_InformationInfo))
      {
        (void) rrc_ccm_send_nas_cn_info_r6(&(cu_confirm_ptr->cn_InformationInfo));
      } 
    }
  }
  else /*Cell_FACH->Cell_FACH or Cell_FACH to Cell_DCH*/
  {
    /* If any RLC entity has to be re-established then re-establish it before configuring channels. */
    if((cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4 == TRUE) ||
      (cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove == TRUE))
    {
      /* store the rlc re-establishment indications */
      rrccu_reestablish_srb = cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4;
      rrccu_reestablish_rab = cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove;
      rrccu_new_crnti_valid = FALSE;
      rrccu_new_urnti_valid = FALSE;
      rrccu_send_rnti_update_req(FALSE);
      ps_rb_re_establish_indicator = cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove;
      WRRC_MSG1_HIGH("CU: RB5 or higher re-establish indicator %d", ps_rb_re_establish_indicator);
    }

    rrccu_reestablish_srb = FALSE;
    rrccu_reestablish_rab = FALSE;

    /* store the C-RNTI and send rlc_reestablishment request to SMC. RNTI update 
    will be done after Channel configuration*/
    if (RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,new_C_RNTI)
         && (rrccu_state_indicator != rrc_RRC_StateIndicator_cell_DCH)) 
    {
      rrccu_new_crnti_valid = TRUE;
      rrc_translate_crnti(&cu_confirm_ptr->new_C_RNTI,&rrccu_new_crnti);
    }
    if(RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,new_U_RNTI))
    {
      rrccu_new_urnti_valid = TRUE;
      rrc_translate_urnti(&cu_confirm_ptr->new_U_RNTI,&rrccu_new_urnti);
    }

    /*check whether this procedure involves SRNS reloc */
    if (rrccu_cucnf_for_srns_relocation)
    {
      /*commit fresh values for srns relocation */
      rrcsmc_commit_fresh_for_srns_relocation();
    }
    /* Allocates the buffer to RRC Internal command */
      cmd_ptr =  rrc_get_int_cmd_buf();
      rrccu_cipher_update_required = FALSE;
      
      no_of_RBs = 0; /* Initialize the no of RBs */

      /* Fill in the command parameters for RRC_CHANNEL_CONFIG_REQ */
      cmd_ptr->cmd_hdr.cmd_id = RRC_CHANNEL_CONFIG_REQ;
      cmd_ptr->cmd.chan_config_req.procedure = RRC_PROCEDURE_CU;
  
      /* Fill in parameters for RRC_CHANNEL_CONFIG_REQ command */
      if (rrccu_state_indicator == rrc_RRC_StateIndicator_cell_DCH)
      {
        //if we r going to dch, then dl-common-info-for-all-rl will be present..
        //check if ciphering is active in mac for cs domain, if it is then,
        //start 2 tiered HHO procedure STEP_1 and STEP_2 for rl-re-establishment
        if(rrcsmc_tm_ciph_active() == TRUE)
        {
          uint32 mac_d_hfn_l=RRCSMC_INVALID_HFN_VALUE;
  
          WRRC_MSG0_HIGH("REL9: RL-cipher present in TM-rb's");
  
          if (RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,dl_CommonInformation))
          {
            if(RRC_MSG_COMMON_BITMASK_IE(cu_confirm_ptr->dl_CommonInformation,rrc_DL_CommonInformation_r8,dl_dpchInfoCommon))
            {
              (void) rrcrb_get_mac_d_hfn(( 
                RRC_MSG_COMMON_BITMASK_IE_PTR(cu_confirm_ptr->dl_CommonInformation.dl_dpchInfoCommon.u.
                dl_DPCH_InfoCommon,
                rrc_DL_DPCH_InfoCommon_r6,mac_d_HFN_initial_value)), 
                &cu_confirm_ptr->dl_CommonInformation.dl_dpchInfoCommon.u.
                dl_DPCH_InfoCommon->mac_d_HFN_initial_value, &mac_d_hfn_l);
            }
          }
  
          if(SUCCESS == rrcsmc_process_cipher_config_for_hho(mac_d_hfn_l)) 
          {
            rrccu_cipher_update_required = TRUE;
          }
        }
        else
        {
          WRRC_MSG0_HIGH("REL9: RL-cipher not-present in TM");
        }
  
        /* Change the state if it is not CELL_PCH or URA_PCH */
        cmd_ptr->cmd.chan_config_req.rrc_state_change_required = TRUE;
        cmd_ptr->cmd.chan_config_req.next_state = state;
      }/* next state id DCH*/
      else /*next state is FACH*/
      {
        cmd_ptr->cmd.chan_config_req.rrc_state_change_required = FALSE;
      }

      cmd_ptr->cmd.chan_config_req.rrc_channel_config_cnf_required = TRUE;
  
      no_of_RBs = rrccu_update_chan_config_rb_r9(cu_confirm_ptr, cmd_ptr->cmd.chan_config_req.rb);
  
#ifdef FEATURE_WCDMA_HS_FACH
      if (rrcenhstate_camped_cell_supports_e_fach()&&
             (rrccu_state_indicator ==rrc_RRC_StateIndicator_cell_FACH))
      {
        WRRC_MSG0_HIGH("EFACH:reconfig SRB's/urb's is not");
        no_of_RBs = rrccu_update_chan_config_rb_r7_for_efach(no_of_RBs,cmd_ptr->cmd.chan_config_req.rb);
      }
#endif

      cmd_ptr->cmd.chan_config_req.num_rb_to_config =(int) no_of_RBs;
  
      rrc_fill_rb_id_chan_req_from_standalone_db(&no_of_RBs, &cmd_ptr->cmd.chan_config_req);
  
      if(rrccu_state_indicator == rrc_RRC_StateIndicator_cell_DCH)
      {
        /*Fill those RBs in chan_config_req for which RLC PDU size has changed and 
        that are already not present in chan_config_req*/
        rrc_fill_rb_id_chan_req_from_rb_list_mapped_to_dch(&no_of_RBs, 
                      &cmd_ptr->cmd.chan_config_req);
      }
  
      /*If state transition is Cell_FACH->Cell_DCH, add all the existing AM SRBs and 
      PS RBs in chan_config_req*/
      if((rrc_get_state() == RRC_STATE_CELL_FACH) && 
                    (rrccu_state_indicator == rrc_RRC_StateIndicator_cell_DCH))
      {
        rrc_fill_rb_id_chan_req_from_est_rabs(&no_of_RBs, 
                      &cmd_ptr->cmd.chan_config_req);
        rrc_fill_srb_in_chan_config_req(&no_of_RBs,&cmd_ptr->cmd.chan_config_req);
      }
      cmd_ptr->cmd.chan_config_req.chan_config_reason = RRCLLC_CHAN_CFG_REASON_NONE;

      /*call the function that evaluates the directed cell info and set the flags accordingly */
      if ((rrc_RRC_StateIndicator_cell_FACH == rrccu_state_indicator) &&
          (rrcrb_validate_directed_cell_info (directed_cell_info) == FALSE))
      {
        if(rrccsp_check_initiate_cell_selection_handling(NULL) == FALSE)
        {
          rrccu_cu_initiate_reqd.cu_reqd = TRUE;
          rrccu_cu_initiate_reqd.cu_cause = rrc_CellUpdateCause_cellReselection;
          WRRC_MSG1_HIGH("CHANNEL_CONFIG_REQ for %dRBs",no_of_RBs);
          rrc_put_int_cmd(cmd_ptr);  /* sends the command to RRC LLC. */
          rrccu_substate = RRCCU_WAIT_FOR_RB_EST_CNF;         
        }
        else
        {
          rrccu_intiate_cell_selection_within_fach_cu_cnf(cmd_ptr);
          cmd_ptr = NULL;
        }
      }
      else
      {
        WRRC_MSG1_HIGH("CHANNEL_CONFIG_REQ for %dRBs", no_of_RBs);
        rrc_put_int_cmd(cmd_ptr); /* sends the command to RRC LLC. */
        rrccu_substate = RRCCU_WAIT_FOR_RB_EST_CNF;         
      }   
    if(RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,cn_InformationInfo))
    {
      (void) rrc_ccm_send_nas_cn_info_r6(&(cu_confirm_ptr->cn_InformationInfo));
    } 
  }
  return;
}


/*===========================================================================
FUNCTION rrccu_process_freq_redirection_info_r9

DESCRIPTION
  This function processes the REl 9 CELL UPDATE CONFIRM message for Freq Redirection.
  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS
  None
===========================================================================*/
boolean rrccu_process_freq_redirection_info_r9
(
  rrc_CellUpdateConfirm_r9_IEs * cu_confirm_ptr,
  rrcrb_directed_cell_info_type * directed_cell_info_ptr
)
{
  rrcrb_directed_cell_info_type          directed_cell_info; /* directed cell info struct */

  memset(&directed_cell_info, 0, sizeof(rrcrb_directed_cell_info_type));

  /* Populate the local variables to indicate if Re-direction info is present */
  directed_cell_info.freq_info_present = FALSE;
  directed_cell_info.pscr_present = FALSE;

  if((rrccu_state_indicator ==rrc_RRC_StateIndicator_cell_FACH) ||( rrccu_state_indicator==rrc_RRC_StateIndicator_cell_PCH) 
      ||(rrccu_state_indicator==rrc_RRC_StateIndicator_ura_PCH))
  {
    if((RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,frequencyInfo))
         && (cu_confirm_ptr->frequencyInfo.modeSpecificInfo.t == 
       T_rrc_FrequencyInfo_modeSpecificInfo_fdd))
    {
      directed_cell_info.freq_info_present = TRUE;
      directed_cell_info.uarfcn_dl = cu_confirm_ptr->frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_DL;
    }
  
    if((RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,dl_InformationPerRL_List))
        &&(cu_confirm_ptr->dl_InformationPerRL_List.elem[0].modeSpecificInfo.t ==
         T_rrc_DL_InformationPerRL_r8_modeSpecificInfo_fdd))
    {
        WRRC_MSG1_HIGH("REL8: Primary SCR in CU Cnf message %d",
           cu_confirm_ptr->dl_InformationPerRL_List.elem[0].modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode);
        directed_cell_info.pscr_present = TRUE;
        directed_cell_info.pscr = cu_confirm_ptr->dl_InformationPerRL_List.elem[0].modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode;
    }
  }

  if ((rrc_RRC_StateIndicator_cell_FACH == rrccu_state_indicator) && (rrcrb_validate_directed_cell_info (directed_cell_info) == FALSE))
  {
    /* If UE still has to send a response to the previous Cu Cnf with directed info
     * and it receives another Cu Cnf with directed info, then send failure
     * If the previous Cu Cnf had directed info, then atleast a PCRC Complete
     * has to be pending as a response.
     */
    if( rrccu_int_data.rrccu_cell_selection_last_response_msg != RRCCU_NO_RESP_MSG )
    {
       WRRC_MSG0_ERROR("Previous Cu Cnf sent a directed info, cannot accept another Cu Cnd with directed info");
       /* Set the Transaction Id */
       rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;
       /* Set Failure cause */
    
       rrccu_failure_cause.failureCause.t = 
         T_rrc_FailureCauseWithProtErr_incompatibleSimultaneousReconfiguration;

    
       rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
       return FALSE;
    }
  }

  directed_cell_info_ptr->freq_info_present = directed_cell_info.freq_info_present;
  directed_cell_info_ptr->uarfcn_dl = directed_cell_info.uarfcn_dl;
  directed_cell_info_ptr->pscr_present = directed_cell_info.pscr_present;
  directed_cell_info_ptr->pscr = directed_cell_info.pscr;

  return TRUE;
}


/*===========================================================================

FUNCTION rrccu_validate_rb_info_r9

DESCRIPTION
  This function validates the Rb related IEs in Cu Cnf
  Cell Update message.
  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
boolean rrccu_validate_rb_info_r9
(
   rrc_CellUpdateConfirm_r9_IEs * cu_confirm_ptr
)
{

  rrc_RB_InformationReleaseList *rrc_rb_information_release_list;
                                              /* Local pointer to preserve the
                                                 head of linked list */  
  rrc_RB_InformationAffectedList_r8 *rrc_rb_information_affected_list; 
  uint32 rb_idx=0;
                                              
  if( RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,rb_InformationReconfigList))
  {
    /* Save the linked list head pointer */
    if (FAILURE == rrcllc_validate_rb_info_reconfig_list_r8(
        &cu_confirm_ptr->rb_InformationReconfigList))
    {
      return FALSE;
    }
  }
  
  
  if(RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,rb_InformationReleaseList))
  {
    /* Save the linked list head pointer */ 
    rrc_rb_information_release_list = 
      &cu_confirm_ptr->rb_InformationReleaseList;
    
    while(rrc_rb_information_release_list->n > rb_idx)
    { 
      /* Check whether rb id in rb release list is in the established rabs list.  If not set msg_not_valid variable
         to true to resend cell update msg with failure cause  */
      if (RRC_RB_NOT_PRESENT == validate_rb_id_in_release_list(
                            (rrc_rb_information_release_list->elem[rb_idx])))
      {
        /* RB Message was invalid. */
        WRRC_MSG1_ERROR("Invalid RB id:%d in rb_InformationReleaseList of CUCnf Msg",
          rrc_rb_information_release_list->elem[rb_idx] );
        return FALSE;
      }      
      rb_idx++;
    } 
  }
  
  if( RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,rb_InformationAffectedList))
  {
    rb_idx =0;
    /* Save the head pointer of linked list */
    rrc_rb_information_affected_list = 
      &cu_confirm_ptr->rb_InformationAffectedList;
    do
    { 
      /* Check whether rb id in rb affected list is in the established rabs list.  If not set msg_not_valid variable
      to true to resend cell update msg with failure cause  */
      if (RRC_RB_NOT_PRESENT == validate_rb_id_in_reconfig_list(
          (rrc_rb_information_affected_list->elem[rb_idx].rb_Identity)))
      {
        /* RB Message was invalid. */
        WRRC_MSG1_ERROR("Invalid RB id:%d in rb_InformationAffectedList of CUCnf Msg",
          rrc_rb_information_affected_list->elem[rb_idx].rb_Identity );
        return FALSE;
      }
      /* Advance the Linked List pointer */
      rb_idx++;
      
    } while(rrc_rb_information_affected_list->n > rb_idx);
  }

  if((RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,rb_InformationReleaseList))
     && (( RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,rb_InformationReconfigList)) ||
       ( RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,rb_InformationAffectedList))   ))
  {
    if(rrccu_validate_rel_rb_exist_in_reconfig_list_r9(cu_confirm_ptr) == TRUE)
    {
        return FALSE;
    }
  }
  return TRUE;
}

/*===========================================================================
FUNCTION rrccu_update_chan_config_rb_r9

DESCRIPTION
 
  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
uint32 rrccu_update_chan_config_rb_r9
(
 rrc_CellUpdateConfirm_r9_IEs * cu_confirm_ptr,
 rrc_rb_config_type * rb_info
)
{
  uint8   no_of_RBs = 0;
  /* Local var to store Ordered Config
                                       status */
   rrc_RB_InformationReleaseList *rrc_rb_information_release_list;
                                    /* Local pointer to preserve the
                                       head of linked list */  
   rrc_RB_InformationReconfig_r8 *rrc_rb_information_reconfig_ptr; 
  
   rrc_RB_InformationAffectedList_r8 *rrc_rb_information_affected_list; 
          /* Pointer to the RRC Command */
   uint32 rb_idx=0;
  
  
  if(RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,rb_InformationReleaseList))
  {
    /* set to flag to indicate that rb release information is present
    in the message. This information will be used after channel configu
    ration to release the rbs from established_rab and also to indicate
    to the upper layers about RAB release if necessary */
    rrccu_rb_release_info.rrccu_rb_release_in_cucnf = TRUE;
    /* Save the linked list head pointer */ 
    rrc_rb_information_release_list = 
      &cu_confirm_ptr->rb_InformationReleaseList;
  
      /* If voice RAB still exist, then indicate layer 1 that next configuration is going to
         include AMR configuration.
         This check is not required if state change indication is either cell_PCH, URA_PCH or
         CELL_FACH, because if voice is configured then next state has to be CELL_DCH.
      */
      if ((rrc_RRC_StateIndicator_cell_DCH == rrccu_state_indicator) && (FALSE == 
          rrc_is_given_rb_rel_list_releases_all_rb_for_voice_rab(
                            rrc_rb_information_release_list)))
      {
        rrc_indicate_layer1_next_config_is_for_voice();
      }
    rb_idx =0;
    while(rrc_rb_information_release_list->n > rb_idx)
    { 
      if( rrc_rb_information_release_list->elem[rb_idx] == DCCH_DT_LOW_PRI_RADIO_BEARER_ID)
      {
        if(RRCLCM_RLC_LC_ID_NOT_FOUND == rrclcm_check_dl_rlc_lc_id(
                                            UE_LOGCHAN_DCCH,
                                            DCCH_DT_LOW_PRI_RADIO_BEARER_ID,
                                            UE_MODE_ACKNOWLEDGED_DATA))
        {
          WRRC_MSG1_HIGH("Ignore Non-exitent rb_id =%d in cucnf",rrc_rb_information_release_list->elem[rb_idx]);
          rb_idx++;
          continue;
        }
      }
      else if(! rrc_find_rb_in_est_rabs(rrc_rb_information_release_list->elem[rb_idx])) 
      {
        WRRC_MSG1_HIGH("Ignore Non-exitent rb_id = %d in cucnf",rrc_rb_information_release_list->elem[rb_idx]);
        rb_idx++;
        continue;
      }
      else if (MAX_RB != rrccu_check_if_rbid_present_in_rrccu_rb_release_info(rrc_rb_information_release_list->elem[rb_idx],no_of_RBs))
      {
        WRRC_MSG1_ERROR(" Ignoring Duplicate RB ID % d in CU ",rrc_rb_information_release_list->elem[rb_idx]);
        rb_idx++;
        continue;
      }

      WRRC_MSG1_HIGH("Release RB i.d = %d",rrc_rb_information_release_list->elem[rb_idx]);
      rb_info[no_of_RBs].rb_id = 
      rrc_rb_information_release_list->elem[rb_idx];
  
      rb_info[no_of_RBs].rb_config = RELEASE_RB;
  
      if(no_of_RBs < MAX_RB)
      {
        /* store the rb info to release list in local buffer which will
             be used later to release it from established_rab variable */
        rrccu_rb_release_info.rb_id[no_of_RBs]=rrc_rb_information_release_list->elem[rb_idx];
      }
      else
      {
        WRRC_MSG1_ERROR("No. of RBs reached the MAX %d",MAX_RB);
      }
      /* Advance the Linked List pointer */
      rb_idx++;
      no_of_RBs++;
    } 
  
    rrccu_rb_release_info.num_rbs = no_of_RBs;
  
    rrcrb_update_mac_rab_status(RRC_PROCEDURE_CU, RRC_CS_DOMAIN_CN_ID,
                                &cu_confirm_ptr->rb_InformationReleaseList,
                                FALSE);
  }
  else
  {
      /* It means CU Confirm doesnt include information to release any RB. 
         check if AMR RAB was established earlier. If yes then indicate layer 1 that
         next configuration will be for AMR.
         This check is not required if state change indication is either cell_PCH, URA_PCH or
         CELL_FACH, because if voice is configured then next state has to be CELL_DCH.                   
      */
      if ((rrc_RRC_StateIndicator_cell_DCH == rrccu_state_indicator) && 
                                (TRUE == rrc_is_voice_rab_present()))
      {
        rrc_indicate_layer1_next_config_is_for_voice();
      }
    }
  
  if( RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,rb_InformationReconfigList))
  {
    rb_idx=0;
    do
    { 
      /* Save the linked list head pointer */
      rrc_rb_information_reconfig_ptr = 
      &cu_confirm_ptr->rb_InformationReconfigList.elem[rb_idx];
      rb_info[no_of_RBs].rb_id = 
              rrc_rb_information_reconfig_ptr->rb_Identity;
  
      rb_info[no_of_RBs].rb_config = RECONFIG_RB;
      rb_info[no_of_RBs].rb_config = RECONFIG_RB_OTA;
      rb_info[no_of_RBs].ul_cfg_mask = 0;
      rb_info[no_of_RBs].dl_cfg_mask = 0;
      if((RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_rb_information_reconfig_ptr, rrc_RB_InformationReconfig_r8,rlc_Info))
          &&(RRC_MSG_COMMON_BITMASK_IE(rrc_rb_information_reconfig_ptr->rlc_Info,rrc_RLC_Info_r7,ul_RLC_Mode)))
      {
        rb_info[no_of_RBs].ul_cfg_mask = MODIFY_RB_CFG;
      }
      if((RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_rb_information_reconfig_ptr, rrc_RB_InformationReconfig_r8,rlc_Info))
          &&(RRC_MSG_COMMON_BITMASK_IE(rrc_rb_information_reconfig_ptr->rlc_Info,rrc_RLC_Info_r7,dl_RLC_Mode)))
      {
        rb_info[no_of_RBs].dl_cfg_mask = MODIFY_RB_CFG;
      }

      if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_rb_information_reconfig_ptr, 
          rrc_RB_InformationReconfig_r8,rb_StopContinue))
      {
        if (rrc_rb_information_reconfig_ptr->rb_StopContinue == rrc_RB_StopContinue_stopRB)
        {
          rb_info[no_of_RBs].ul_cfg_mask |= STOP_RB_CFG;
          rb_info[no_of_RBs].dl_cfg_mask |= STOP_RB_CFG;
          WRRC_MSG1_HIGH("Stop recvd for RB %d", (rrc_rb_information_reconfig_ptr->rb_Identity));
        }
        else if (rrc_rb_information_reconfig_ptr->rb_StopContinue == rrc_RB_StopContinue_continueRB)
        {
          rb_info[no_of_RBs].ul_cfg_mask |= CONTINUE_RB_CFG;
          rb_info[no_of_RBs].dl_cfg_mask |= CONTINUE_RB_CFG;
          WRRC_MSG1_HIGH("Continue recvd for RB %d", (uint16)(rrc_rb_information_reconfig_ptr->rb_Identity));
        }
      }
      /* Advance the Linked List pointer */
      rb_idx++;
      no_of_RBs++;
       
    } while(cu_confirm_ptr->rb_InformationReconfigList.n > rb_idx) ;
  }
  if(RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,rb_InformationAffectedList))
  {
    /* Save the head pointer of linked list */
    rrc_rb_information_affected_list = 
      &cu_confirm_ptr->rb_InformationAffectedList;
  
    do
    { 
      rb_info[no_of_RBs].rb_id = 
          rrc_rb_information_affected_list->elem[rb_idx].rb_Identity;
  
      rb_info[no_of_RBs].rb_config = RECONFIG_RB;
      rb_info[no_of_RBs].rb_config = RECONFIG_RB_OTA;
      rb_info[no_of_RBs].ul_cfg_mask = rb_info[no_of_RBs].dl_cfg_mask = MODIFY_RB_CFG;

      /* Advance the Linked List pointer */
      rb_idx++;
  
      no_of_RBs++;
  
    } while(rrc_rb_information_affected_list->n > rb_idx);
  }
  
  return no_of_RBs;
  
  }


/*===========================================================================
FUNCTION rrccu_validate_rel_rb_exist_in_reconfig_list_r9

DESCRIPTION
  This function checks if the Cu Cnf has the same RB ID in the RB Release list
   and also in RB Reconfig/RB Affected List
  
DEPENDENCIES
  None

RETURN VALUE
  True, if same RB ID is present in RB Release list and also in RB Reconfig/RB Affected List
  else
  FALSE
  
SIDE EFFECTS

  None

===========================================================================*/
boolean rrccu_validate_rel_rb_exist_in_reconfig_list_r9
(
  rrc_CellUpdateConfirm_r9_IEs * cu_confirm_ptr
)
{
  rrc_RB_Identity released_rb_id= 0xFF;
  rrc_RB_InformationReleaseList *rrc_rb_information_release_list;
                                            /* Local pointer to preserve the
                                               head of linked list */  
  rrc_RB_InformationReconfig_r8 *rrc_rb_information_reconfig_ptr; 
  
  rrc_RB_InformationAffectedList_r8 *rrc_rb_information_affected_list; 
  uint32 idx=0,idy=0;
    /* Save the linked list head pointer */ 
  rrc_rb_information_release_list = 
      &cu_confirm_ptr->rb_InformationReleaseList;
    
  while(rrc_rb_information_release_list->n > idx)
  { 
  
    released_rb_id =rrc_rb_information_release_list->elem[idx];
    if( RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,rb_InformationReconfigList))
    {
      /* Save the linked list head pointer */
      idy=0;
      do
      {
        rrc_rb_information_reconfig_ptr = 
        &cu_confirm_ptr->rb_InformationReconfigList.elem[idy];
      
        /* Check whether rb id in rb reconfig list is in the established rabs list.  If not set msg_not_valid variable
           to true to resend cell update msg with failure cause  */
        if (rrc_rb_information_reconfig_ptr->rb_Identity == released_rb_id  )
        {
          /* RB Message was invalid. */
          WRRC_MSG1_ERROR(" RB id:%d in rb_InformationReconfigList  and RB Release list of CUCnf Msg",
             rrc_rb_information_reconfig_ptr->rb_Identity );
          return TRUE;
        }
                 
        /* Advance the Linked List pointer */
        idy++;;
      }while(cu_confirm_ptr->rb_InformationReconfigList.n > idy);
    }
  
    if(RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,rb_InformationAffectedList))
    {
      /* Save the head pointer of linked list */
      rrc_rb_information_affected_list = 
       &cu_confirm_ptr->rb_InformationAffectedList;
      idy=0;
      do
      { 
        /* Check whether rb id in rb affected list is in the established rabs list.  If not set msg_not_valid variable
        to true to resend cell update msg with failure cause  */
        if (rrc_rb_information_affected_list->elem[idy].rb_Identity == released_rb_id )
        {
          /* RB Message was invalid. */
          WRRC_MSG1_ERROR(" RB id:%d in rb_InformationAffectedList  and RB Release list of CUCnf Msg",
             rrc_rb_information_affected_list->elem[idy].rb_Identity );
          return TRUE;
        }
        /* Advance the Linked List pointer */
        idy++;
        
      } while(rrc_rb_information_affected_list->n > idy);
    }
     
    idx++;
  } 
  
  return FALSE;
}


/*===========================================================================

FUNCTION RRCCU_RESPONSE_TO_CELL_UPDATE_CONFIRM_R9

DESCRIPTION
  This function evaluates CELL UPDATE CONFIRM message and decides what
  response message has to be sent
  Cell Update message.
  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/
rrccu_resp_msg_e_type rrccu_find_response_to_cell_update_confirm_r9
(
  rrc_CellUpdateConfirm_r9_IEs *cucnf_ptr
)
{
  rrccu_resp_msg_e_type resp_msg= RRCCU_NO_RESP_MSG;


  /* In RB Release present send RB Release complete */
  
  if(RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,rb_InformationReleaseList))
  {
    resp_msg = RRCCU_RBR_COMPLETE_RESP_MSG;
  }
    /* else if rb reconfig present send Reconfig complete*/
  else if ((RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,rb_InformationReconfigList))
                || (RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,rb_InformationAffectedList)))
  {
    resp_msg = RRCCU_RBRC_COMPLETE_RESP_MSG;
  }
  /* else if Trch info is  present send Transport reconfig  complete*/
  else if ((RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,ul_CommonTransChInfo))
                || (RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,ul_deletedTransChInfoList))
                ||(RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,ul_AddReconfTransChInfoList))
                || (RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,dl_CommonTransChInfo))
                ||(RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,dl_DeletedTransChInfoList))
                || (RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,dl_AddReconfTransChInfoList)) )
  {
    resp_msg = RRCCU_TCR_COMPLETE_RESP_MSG;
  }
   /* else if Physical channel info  is  present send Physical Channel reconfig  complete*/
  else if ((RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,ul_DPCH_Info))
                || (RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,dl_CommonInformation))
                ||(RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,dl_InformationPerRL_List))
                ||(RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,ul_EDCH_Information ))
                || (RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,dl_HSPDSCH_Information))
                || (RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,frequencyInfo))
                ||(RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,maxAllowedUL_TX_Power))
                ||(RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,dtx_drx_TimingInfo))
                ||(RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,dtx_drx_Info))
#ifdef FEATURE_WCDMA_DC_HSDPA
                ||(RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,dl_SecondaryCellInfoFDD))
#endif
#ifdef FEATURE_WCDMA_DC_HSUPA
                || (RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,ul_SecondaryCellInfoFDD))
#endif /* FEATURE_WCDMA_DC_HSUPA */

           )
  {
    resp_msg = RRCCU_PCR_COMPLETE_RESP_MSG;
  }
   /* else if Utran Mobility info  is  present, send  Utran Mobility info  complete*/
  else if ((RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,cn_InformationInfo))
                || (RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,cipheringModeInfo))
                ||(RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,integrityProtectionModeInfo))
                ||(RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,new_U_RNTI))
                || (RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,new_C_RNTI)))                
  {
    resp_msg = RRCCU_UMIC_COMPLETE_RESP_MSG;
  }
  else if (!((RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,rb_InformationReleaseList))
                || (RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,rb_InformationReconfigList))
                || (RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,rb_InformationAffectedList))
                ||(RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,ul_CommonTransChInfo))
                || (RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,ul_deletedTransChInfoList))
                ||(RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,ul_AddReconfTransChInfoList))
                || (RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,dl_CommonTransChInfo))
                ||(RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,dl_DeletedTransChInfoList ))
                || (RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,dl_AddReconfTransChInfoList))
                ||(RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,ul_DPCH_Info))
                || (RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,dl_CommonInformation))
                ||(RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,dl_InformationPerRL_List))
                ||(RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,ul_EDCH_Information ))
                || (RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,dl_HSPDSCH_Information))
                ||(RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,cn_InformationInfo))
                || (RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,cipheringModeInfo))
                ||(RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,integrityProtectionModeInfo))
                ||(RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,new_U_RNTI ))
                || (RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,new_C_RNTI))
                ||(RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,frequencyInfo))
#ifdef FEATURE_WCDMA_DC_HSUPA
                || (RRCRB_R9_MSG_IE_PRESENT(cucnf_ptr,ul_SecondaryCellInfoFDD))
#endif /* FEATURE_WCDMA_DC_HSUPA */
              ))
  {
    resp_msg = RRCCU_NO_RESP_MSG;
  }

  return resp_msg;
}




/*===========================================================================
FUNCTION RRCCU_PROCESS_CELL_UPDATE_CONFIRM_R9

DESCRIPTION
  This function processes the REl 9 CELL UPDATE CONFIRM message received in response to
  Cell Update message.
  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS
  None

===========================================================================*/
void rrccu_process_cell_update_confirm_r9
(    
  void *msg_ptr,                           /* Pointer to Downlink Msg */
  rrc_RRC_TransactionIdentifier rcvd_transaction_id,
  rrc_CellUpdateConfirm_r9_IEs *cu_confirm_ptr,
  uint32 dl_sdu_type                       /* Downlink SDU type */
)

{
  boolean msg_not_valid      = FALSE;         /* boolean to indicate msg validity */

  rrcrb_directed_cell_info_type          directed_cell_info; /* directed cell info struct */

#ifdef FEATURE_WCDMA_HS_FACH
  boolean rnti_required_for_hsfach_hsrach = FALSE;
#endif

  /* Update Transaction id */
  rrccu_trans_id = rcvd_transaction_id;
    
  /* enter idle if both timers are marked as expired */
  if ((rrccu_rl_failure_info.t314_info.timer_status == RE_EST_TIMER_EXPIRED) &&
      (rrccu_rl_failure_info.t315_info.timer_status == RE_EST_TIMER_EXPIRED))
  {
    /* Since both T314 and T315 are expired, bring down RRC Connection */
    rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                                    RRC_TX_TO_DISCON_OTHER);
    /* Update the release cause */
    rrc_release_cause = RRC_REL_DEEP_FADE;
    rrccu_substate = RRCCU_WAIT_FOR_RB_REL_CNF;
    WRRC_MSG0_HIGH("RRC Conn Released since T314=0 & T315=0");
    return;
  }

  /* Update state Indicator */   
  rrccu_state_indicator = cu_confirm_ptr->rrc_StateIndicator;

  /*If wait timer IE is valid, we need to store it. We need this value if R7 CU CNF OTA
    is taking the UE to Cell_PCH or URA_PCH state. In this case, we need to start wait timer
    T320 with this IE.*/

  if(((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH) || (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH)) &&
    (RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,waitTime)) &&
    (cu_confirm_ptr->waitTime))
  {
    rrccu_int_data.wait_time_in_pch = cu_confirm_ptr->waitTime;

    /*If current CU cause is Uplink Data Transmission or MBMS P2P Rb Request, we need to store it 
       so that when T320 expires, we can initiate CU with this cause.*/
    if(rrccu_cell_update_cause == rrc_CellUpdateCause_uplinkDataTransmission)
    {
      rrccu_int_data.cu_cause_for_wait_timer = rrccu_map_cu_cause(rrccu_cell_update_cause);
    }
  }  

  /* check whether new CRNTI is present in the message or not when there is
  no valid C-RNTI is existing and next state indicated by the message is 
  CELL_FACH */
  if ((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_FACH) ||
     (((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH) || (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH)) &&
     (RRCCU_NO_RESP_MSG != rrccu_find_response_to_cell_update_confirm_r9(cu_confirm_ptr))))
  {
    if ((C_RNTI_NOT_VALID == rrcllc_get_current_crnti_status()) &&
        ((RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,new_C_RNTI)) == 0 ))
    {
      if(((rrcllc_get_toc_usage() == TOC_FOR_OOS) 
          || (rrcllc_get_toc_usage() == TOC_FOR_OOS_WITHOUT_DCH_INFO)
          || (rrcllc_get_toc_usage() == TOC_FOR_OOS_WITH_DCH_INFO)
       ) &&   (rrcrb_get_new_crnti_valid() && rrccsp_is_selected_cell_utran_directed()))
      {
        WRRC_MSG0_HIGH("Crnti present in reconfig msg");
      }
      else
      {

        WRRC_MSG1_ERROR("No CRNTI for next_st:%d", rrccu_state_indicator);
        /* Update the cause to re-selection as the Cell upate cause should
              indicate re-selection in case of No CRNTI
              */
        rrccu_cell_update_cause = rrc_CellUpdateCause_cellReselection;
        rrc_cu_uu_log_event_failure_cause = RRC_CU_UU_INVALID_CONFIG;
        rrccu_resend_cell_update_msg(RRCCU_NOT_INCLUDE_FAILURE_CAUSE);
        /* continue with rrccu state  RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM */
        return;
      }
    }
  }

/*RNTI validation for HS-FACH and HS-RACH*/
#ifdef FEATURE_WCDMA_HS_FACH
  if(rrcenhstate_camped_cell_supports_e_fach() == TRUE)
  {
    switch(rrccu_state_indicator)
    {
      case rrc_RRC_StateIndicator_cell_PCH:
      case rrc_RRC_StateIndicator_ura_PCH:
        if(RRCCU_NO_RESP_MSG != rrccu_find_response_to_cell_update_confirm_r9(cu_confirm_ptr))
        {
          if(!RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,new_H_RNTI))
          {
            WRRC_MSG0_ERROR("EFACH:HRNTI not given in Cell Update Confirm, retry CU");
            rnti_required_for_hsfach_hsrach = TRUE;
          }
#ifdef FEATURE_WCDMA_HS_RACH
          if((rrchsrach_camped_cell_supports_hsrach() == TRUE)&&
                  (!RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,newPrimary_E_RNTI)))
          {
            WRRC_MSG0_ERROR("HSRACH:ERNTI not given in Cell Update Confirm, retry CU");
            rnti_required_for_hsfach_hsrach = TRUE;
          }
#endif
        }
        break;
      case rrc_RRC_StateIndicator_cell_FACH:
        if(rrccu_cell_update_cause == rrc_CellUpdateCause_periodicalCellUpdate)
          break;
          if(!RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,new_H_RNTI))
          {
            WRRC_MSG0_ERROR("EFACH:HRNTI not given in Cell Update Confirm, retry CU");
            rnti_required_for_hsfach_hsrach = TRUE;
          }
#ifdef FEATURE_WCDMA_HS_RACH
          if((rrchsrach_camped_cell_supports_hsrach() == TRUE)&&
                  (!RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,newPrimary_E_RNTI)))
          {
            WRRC_MSG0_ERROR("HSRACH:ERNTI not given in Cell Update Confirm, retry CU");
            rnti_required_for_hsfach_hsrach = TRUE;
          }
#endif
        break;
    }
  }
  if(rnti_required_for_hsfach_hsrach == TRUE)
  {
    rrccu_cell_update_cause = rrc_CellUpdateCause_cellReselection;
    rrc_cu_uu_log_event_failure_cause = RRC_CU_UU_INVALID_CONFIG;
    rrccu_resend_cell_update_msg(RRCCU_NOT_INCLUDE_FAILURE_CAUSE);
    return;
  }
#endif


  if ((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH) ||
      (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH))
  {
    if (!(RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,utran_DRX_CycleLengthCoeff)))
    {
      WRRC_MSG0_ERROR("UTRAN DRX is not present");
      
      /* set the invalid msg flag */
      msg_not_valid = TRUE;
    }
    else
    {
      /* store it in a variable */
      if(rrcllc_update_utran_drx_cycle_length_coeff_in_oc_r7(TRUE,&cu_confirm_ptr->utran_DRX_CycleLengthCoeff)
         == SUCCESS)
      {        
        if((RRC_MSG_COMMON_BITMASK_IE_TYPE2(cu_confirm_ptr->utran_DRX_CycleLengthCoeff,drx_CycleLengthCoefficient2))&&
           (RRC_MSG_COMMON_BITMASK_IE_TYPE2(cu_confirm_ptr->utran_DRX_CycleLengthCoeff,timeForDRXCycle2)))
        {
          rrccu_utran_drx_coef = cu_confirm_ptr->utran_DRX_CycleLengthCoeff.drx_CycleLengthCoefficient2;
        }
        else
        {
      rrccu_utran_drx_coef = cu_confirm_ptr->utran_DRX_CycleLengthCoeff.drx_CycleLengthCoefficient;
    }
      }
      else
      {
        rrccu_utran_drx_coef = cu_confirm_ptr->utran_DRX_CycleLengthCoeff.drx_CycleLengthCoefficient;
      }
    }
       /*resend the cell update message if there is any invalid config*/
    if(rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH)
    {
      if (!(RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,ura_Identity)))
      {
        WRRC_MSG0_HIGH("URA-id is not present");
        rrccu_clear_ura_id();
      }
      /* update rrccu procedure with new URA-id */
      else
      {
        /*URA ID present in the message set ura_identity variable with this value */
        if (cu_confirm_ptr->ura_Identity.numbits == 16)
        {
          /*rrccu_translate_ura_id (&(msg_ptr->u.r3.radioBearerReconfiguration_r3.ura_Identity));*/
          rrccu_update_ura_id (&(cu_confirm_ptr->ura_Identity));
        }
        else
        {
          WRRC_MSG1_ERROR("Invalid URA ID length%d",
              cu_confirm_ptr->ura_Identity.numbits);
          /* set the invalid msg flag */
          msg_not_valid = TRUE;
        }
      }
        
    }
  }

#ifdef FEATURE_WCDMA_HS_FACH
  if(cu_confirm_ptr->m.new_H_RNTIPresent)
  {
    if(rrccu_update_hrnti_from_ota(&cu_confirm_ptr->new_H_RNTI, transition_config.toc_ptr) == FAILURE)
    {
      WRRC_MSG0_ERROR("HRNTI invalid");
      msg_not_valid = TRUE;
    }
  }
#endif


#ifdef FEATURE_WCDMA_REL7_SPECRS   
   /*If CU Confirm OTA provides "supportForChangeOfUE_Capability" IE, we need to store it in
        "rrc_ordered_rnc_cap_change_support" so that later once the procedure is over successfully, global
        "rrc_rnc_cap_change_support" can be updated accordingly. */  
  if(RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,supportForChangeOfUE_Capability))
  {
    if(cu_confirm_ptr->supportForChangeOfUE_Capability == TRUE)
    {
      rrc_ordered_rnc_cap_change_support = RNC_CAP_CHANGE_SUPPORTED;
    }
    else
    {
      rrc_ordered_rnc_cap_change_support = RNC_CAP_CHANGE_UNSUPPORTED;
    }
  }
  else
  {
    rrc_ordered_rnc_cap_change_support = RNC_CAP_CHANGE_NONE;
  }
#endif /*FEATURE_WCDMA_REL7_SPECRS*/
    
  if(msg_not_valid == FALSE)
  { 
    if(rrccu_validate_rb_info_r9(cu_confirm_ptr) == FALSE)
      {
        msg_not_valid = TRUE;
    } 
  }

  /*RRC_GKG: See whether adding HSDPA check for TDD adds any value.*/

  if (msg_not_valid)
  {
    WRRC_MSG0_HIGH("Invalid Configurartion in CUCnf Msg.  Resending Cell Update");
    /* Set the Transaction Id */
    rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;

    /* Set Failure cause */
    rrccu_failure_cause.failureCause.t = 
      T_rrc_FailureCauseWithProtErr_invalidConfiguration;


    rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
    /* continue with rrccu state  RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM */
    return;
  }

  if(rrccu_process_freq_redirection_info_r9(cu_confirm_ptr, &directed_cell_info) == FALSE)
  {
    return;
  }

  if (RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,dl_CounterSynchronisationInfo))
  {
    WRRC_MSG0_HIGH("REL9: DL Counter Sync info present");

  /*check whether PDCP info is present in the dl counter sync info */
    if((RRC_MSG_COMMON_BITMASK_IE_TYPE2(cu_confirm_ptr->dl_CounterSynchronisationInfo,
		rb_WithPDCP_InfoList)) ||
      (RRC_MSG_COMMON_BITMASK_IE(cu_confirm_ptr->dl_CounterSynchronisationInfo,
      rrc_DL_CounterSynchronisationInfo_r5,rb_PDCPContextRelocationList)))
    {
      /* this involves lossless SRNS relocation so re-send cell update message */
      WRRC_MSG0_ERROR("REL9: PDCP info not supported");

      /* Set the Transaction Id */
      rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;

      /* Set Failure cause */
      rrccu_failure_cause.failureCause.t = T_rrc_FailureCauseWithProtErr_configurationUnsupported;

    

      rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
      /* continue with rrccu state  RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM */
      return;
    }
    /*UE actions, in case IE "Downlink counter synchronisation info" is included and 
    *either IE "RLC reestablish indicator (RB2, RB3 and RB4)" or IE "RLC re-establish 
    *indicator (RB5 and upwards)" are set to TRUE, are not defined.refer to R2-041019,spec cr-2328
    */
    if((cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4 == TRUE) ||
      (cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove == TRUE))
    {
      /* Set the Transaction Id */
      rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;

      /* Set Failure cause */
      rrccu_failure_cause.failureCause.t = T_rrc_FailureCauseWithProtErr_configurationUnsupported;

   

      WRRC_MSG0_ERROR("UE doesn't support simultaneous RLC Re_est & S-RNS<R2-041019,spec cr-2328>");
      rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
      /* continue with rrccu state  RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM */
      return;
    }

    /* This is lossy SRNS relocation */
    rrccu_cucnf_for_srns_relocation  = TRUE;

    /* store the new URNTI value if present */
    if (RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,new_U_RNTI))
    {
      rrccu_new_urnti_valid = TRUE;
      rrc_translate_urnti (&(cu_confirm_ptr->new_U_RNTI), &rrccu_new_urnti);
    }
  }

  /* check whether rlc-re establishment was require but not indicated in cell update
  confirm message. In such case discard the cucnf and resend cell update message.
  This should also take care of multiple cell updates initiated due to change in cause.
  for ex. periodicall...rlc unrecoverabel error, reselection...rlc unrecoverable error
  rl failure..rlc unrecoverable error */
  if (((rrccu_rlc_error_info.error_on_srb == TRUE) && 
      (cu_confirm_ptr->rlc_Re_establishIndicatorRb2_3or4 == FALSE)) ||
       ((rrccu_rlc_error_info.error_on_urb == TRUE) && 
      (cu_confirm_ptr->rlc_Re_establishIndicatorRb5orAbove == FALSE)))
  {
    if(RRCRB_R9_MSG_IE_PRESENT(cu_confirm_ptr,dl_CounterSynchronisationInfo)) 
    {
      WRRC_MSG0_HIGH("S-RNS relocation is Implicit rlc_Re_establish");
    }
    else
    {
      rrc_cu_uu_log_event_failure_cause = RRC_CU_UU_INVALID_CONFIG;
      rrccu_resend_cell_update_msg(RRCCU_NOT_INCLUDE_FAILURE_CAUSE);
      /* continue with rrccu state  RRCCU_WAIT_FOR_CELL_UPDATE_CONFIRM */
      return;
    }
  }

  rrccu_resp_msg = rrccu_find_response_to_cell_update_confirm_r9(cu_confirm_ptr);
  /* If CUC doesnt set OC, validate if the existing ehs queues are holding a proper window size */
  /* Calling 'rrcllc_validate_hs_ehs_window_size_for_sec' directly without checking for 
     num of carriers. As CUC doesnt set OC, num sec carriers is anyways 0. We can reject CUC
     if window size is > 32 */
 /*  Note: directed_cell_info.freq_info_present and directed_cell_info.pscr_present will always be FALSE 
     for NO RSP and UMIC response. Added those conditions to just maintain the code consistency. 
     These conditions doesnt impact the logics. If these conditions are redundant, we can remove
     such condition everywhere  */
  if(((RRCCU_NO_RESP_MSG == rrccu_resp_msg)||(RRCCU_UMIC_COMPLETE_RESP_MSG == rrccu_resp_msg)) &&
  (((directed_cell_info.freq_info_present == FALSE )&& (directed_cell_info.pscr_present == FALSE ))
    ||(rrccu_state_indicator ==rrc_RRC_StateIndicator_cell_DCH)))
  {
    if(FALSE == rrcllc_validate_hs_ehs_window_size_for_sec(rrccu_state_indicator))
    {
      rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;
      rrccu_failure_cause.failureCause.t = T_rrc_FailureCauseWithProtErr_invalidConfiguration;
      rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
	  return;
    }
  }

  /* check whether reconfiguration is involved and OC is already set by some other procedure */ 
  if ((rrccu_resp_msg != RRCCU_NO_RESP_MSG) && 
      (rrccu_resp_msg != RRCCU_UMIC_COMPLETE_RESP_MSG) &&
      ((rrcllc_get_ordered_config_status_wo_f3() != OC_NOT_SET) || (rrccu_do_not_acpt_nw_conf_in_cuc == TRUE)))
  {
    /* Set the Transaction Id */
    rrccu_failure_cause.rrc_TransactionIdentifier = rrccu_trans_id;

    /* Set Failure cause */
    rrccu_failure_cause.failureCause.t = T_rrc_FailureCauseWithProtErr_incompatibleSimultaneousReconfiguration;
    rrccu_resend_cell_update_msg(RRCCU_INCLUDE_FAILURE_CAUSE);
  }
  else
  {
    rrcu_process_cu_cnf_after_validation_r9(msg_ptr,cu_confirm_ptr,dl_sdu_type
                                                                        ,directed_cell_info
                                                                        );
  }
  return;
} 


#endif /* FEATURE_WCDMA_REL9 */

#ifdef FEATURE_WCDMA_REL10
#error code not present
#endif /* FEATURE_WCDMA_REL10 */

#ifdef FEATURE_WCDMA_HANDLE_MDSP_HALT
/*===========================================================================

FUNCTION rrccu_handle_mdsp_halt_recov_in_dch

DESCRIPTION 

DEPENDENCIES
    None.

RETURN VALUE
    None.

===========================================================================*/
boolean rrccu_handle_mdsp_halt_recov_in_dch()
{
  rrc_state_e_type current_rrc_state;
  current_rrc_state = rrc_get_state();

  rrccu_mdsp_recov_active = TRUE;
  /* In case Of Radio Link Failure, abort the Reading of SIB
   * in DCH mode
   */
  if(rrc_sib_is_current_event_sib_read_in_dch())
  {
    WRRC_MSG0_HIGH( "RRCGPS: Force Init GPS ");
    rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_SIB_READ_IN_DCH);
  }

  WRRC_MSG1_HIGH( "Rcvd MDSP HALT RECOV req cu_st:%d",rrccu_substate);
#ifdef FEATURE_RRC_RELEASE_OPT
  {
    boolean mm_waiting_for_nw_cmd = FALSE;
#ifdef FEATURE_DUAL_SIM
    mm_waiting_for_nw_cmd = mm_per_subs_waiting_for_nw_command(rrc_get_as_id());
#else
    mm_waiting_for_nw_cmd = mm_waiting_for_nw_command();
#endif
    /* Here, we query nas function to see if CC has received a release complete.  In the case where RL failure 
    is caused because RCR msg is sent from NW only once and is lost, if CC has received a release complete, 
    we just take UE to idle if PS signalling is not up.  Else, we follow the regular path for RL failure. */
    if (mm_waiting_for_nw_cmd) 
    {
      WRRC_MSG0_HIGH( "Nas waiting for Connection Release.");
      if (!rrcscr_get_signalling_connection_status(RRC_PS_DOMAIN_CN_ID))
      {
        WRRC_MSG0_HIGH( "PS is not up.can not handel MDSP halt recovery in CU");
        rrccu_mdsp_recov_active = FALSE;
        return FALSE;
      }
      else
      {
        /* PS signalling is up.  Continue with RL failure*/
        WRRC_MSG0_HIGH( "PS Signalling is UP."); 
      }
    }
  }
#endif /* FEATURE_RRC_RELEASE_OPT */


  if (rrcsmc_is_security_reconfig_active() || rrcrcr_is_proc_active() )
  {
    WRRC_MSG0_HIGH("security or rcr active.can not handel MDSP halt recovery in CU ");
    rrccu_mdsp_recov_active = FALSE;
    return FALSE;
  }
  else
  {
    /*Update the global release_cause variable here */
    rrc_release_cause = RRC_REL_DEEP_FADE;
    /* Update Cell Update cause */
    rrccu_cell_update_cause = rrc_radiolinkFailure;
    /* set Cell_update_started flag here */
    rrccu_cell_update_started = TRUE;
  
    /* store the current rrc state when failure was indicated */
    rrccu_failure_state = current_rrc_state;
    /* Check if timers T314 and T315 for RRC Connection Establishment.
    process the RABs associated with re-est timers.*/  
    rrccu_process_re_est_timers(FALSE);
    if(rrccu_substate == RRCCU_WAIT_FOR_UE_TO_CAMP_ON)
    {
      WRRC_MSG0_HIGH("mdsp halt recovered in CU");
      rrccu_mdsp_recov_active = FALSE;
      return TRUE;
    }
    else
    {
      WRRC_MSG0_HIGH("can not handel MDSP halt recovery in CU");
      rrccu_mdsp_recov_active = FALSE;
      return FALSE;
    }
  }

}
#endif

/*===========================================================================

FUNCTION rrccu_tran_to_disconn_debug_handler

DESCRIPTION 
    This function is the handler when transition to disconnected timer eby CU xpires 
DEPENDENCIES
    None.

RETURN VALUE
    None.

===========================================================================*/
void rrccu_tran_to_disconn_debug_handler
(
  rrc_cmd_type *cmd_ptr
)
{
  WRRC_MSG2_HIGH("function rrccu_tran_to_disconn_debug_handler is called in rrccu_substate = rrccu_substate_e_type_value%d and RRC_DEBUG: rrccu_tran_to_discon_counter %d", rrccu_substate, rrccu_tran_to_discon_counter);

  if((rrccu_substate != RRCCU_WAIT_FOR_RB_REL_CNF)|| (rrc_get_state() == RRC_STATE_DISCONNECTED))
  {
    rrccu_tran_to_discon_counter = 0;
    return;
  }
  
  if(rrccu_tran_to_discon_counter == RRCCU_TRANS_TO_DISCON_MAX_TRY)
  {
    ERR_FATAL("CSP stuck, ignored transition to disconnected command for %d times ",RRCCU_TRANS_TO_DISCON_MAX_TRY,0,0);
  }

  rrc_transition_to_disconnected_state(RRC_PROCEDURE_CU,
                                       RRC_TX_TO_DISCON_OTHER);
    
  rrccu_tran_to_discon_counter ++;
  
}

#ifdef FEATURE_WCDMA_HS_RACH
/*===========================================================================

FUNCTION rrccu_set_hsrach_sib_change

DESCRIPTION
  Sets the flag .  

DEPENDENCIES
  None.

RETURN VALUE
  NONE

===========================================================================*/
void rrccu_set_hsrach_sib_change
(
  boolean status
)
{
  WRRC_MSG1_HIGH("Setting rrccu_hsrach_delay_cu_sib_change to %d ",status);
  rrccu_hsrach_delay_cu_sib_change = status;
  return;
}

/*===========================================================================

FUNCTION rrccu_set_hsrach_sib_change

DESCRIPTION
  Gets the flag

DEPENDENCIES
  None.

RETURN VALUE
  Boolean

===========================================================================*/
boolean rrccu_get_hsrach_sib_change
(
void 
)
{
  return rrccu_hsrach_delay_cu_sib_change;
}
#endif
#ifdef FEATURE_WCDMA_HS_FACH
/*===========================================================================

FUNCTION rrccu_update_hrnti_from_ota

DESCRIPTION
  Updates HRNTI from OTA's like CU-CNF, URA-CNF
  
DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS

  None

===========================================================================*/


uecomdef_status_e_type rrccu_update_hrnti_from_ota
(
  ASN1BitStr32  *new_hrnti_ptr,          /* Pointer to external HRNTI type */
  ordered_config_type  *config_ptr    /* Pointer to internal HRNTI type */
)
{

  if(new_hrnti_ptr == NULL)
  {
    return SUCCESS;
  }

  rrc_translate_hrnti(new_hrnti_ptr,&config_ptr->efach_hrnti);

  config_ptr->efach_hrnti_status = DEDICATED_HRNTI;
  WRRC_MSG1_HIGH("EFACH: Updated HRNTI into TOC from CU-Confirm %d",config_ptr->efach_hrnti);
#ifdef TEST_FRAMEWORK
  #error code not present
#endif

 return SUCCESS;
}


/*===========================================================================

FUNCTION rrccu_check_if_registered_reconfig_proc_is_successful

DESCRIPTION 
  Checks if any reconfiguration procs hacve registered with Cell Update 
procedure and 
  if the procedure is succesful(if yes, procedure will take care of swapping 
OC and CC ,
  else CU will have to take care

DEPENDENCIES
    None.

RETURN VALUE
    TRUE only if there is a procedure registered and that procedure is 
successful.

===========================================================================*/

boolean rrccu_check_if_registered_reconfig_proc_is_successful
(
  void 
)
{
  uint8 i=0;
  for(;i<rrccu_reg_info.no_of_reg_procs;i++)
  {
    switch(rrccu_reg_info.rrc_proc[i])
    {
      case RRC_PROCEDURE_RBE:
        return rrcrbe_is_proc_successful();
      case RRC_PROCEDURE_RBR:
        return rrcrbr_is_proc_successful();
      case RRC_PROCEDURE_RBRC:
         return rrcrbrc_is_proc_successful();
      case RRC_PROCEDURE_TCR:
        return rrctcrc_is_proc_successful();
      case RRC_PROCEDURE_PCR:
        return rrcpcrc_is_proc_successful();
      default:
        break;
    }
  }
  WRRC_MSG0_HIGH("Either no registered procs or registered procedures are going to fail");
  return FALSE;
}

/*===========================================================================

FUNCTION rrccu_check_rnti_for_resending_cu

DESCRIPTION 
This function checks rntis for resending CU
DEPENDENCIES
    None.

RETURN VALUE
    None.

===========================================================================*/

boolean rrccu_check_rnti_for_resending_cu
(
boolean new_H_RNTI_present, 
boolean newPrimary_E_RNTI,
rrc_msg_ver_enum_type msg_version,
rrccu_resp_msg_e_type resp
)
{
  boolean rnti_required_for_hsfach_hsrach = FALSE;
  
  if(rrcenhstate_camped_cell_supports_e_fach() == TRUE)
  {
    if (msg_version == MSG_REL99)
    {
      switch(rrccu_state_indicator)
      {
        case rrc_RRC_StateIndicator_cell_PCH:
        case rrc_RRC_StateIndicator_ura_PCH:
          if(RRCCU_NO_RESP_MSG != resp)
          {
            rnti_required_for_hsfach_hsrach = TRUE;
          }
          break;
        case rrc_RRC_StateIndicator_cell_FACH:
          if(rrccu_cell_update_cause == rrc_CellUpdateCause_periodicalCellUpdate)
            break;
          rnti_required_for_hsfach_hsrach = TRUE;
          break;
      }
    }
  
    else if (msg_version == MSG_REL5)
    {
      switch(rrccu_state_indicator)
      {
        case rrc_RRC_StateIndicator_cell_PCH:
        case rrc_RRC_StateIndicator_ura_PCH:
          if(RRCCU_NO_RESP_MSG != resp)
          {
            if(!new_H_RNTI_present)
            {
              rnti_required_for_hsfach_hsrach = TRUE;
            }
#ifdef FEATURE_WCDMA_HS_RACH
            if(rrchsrach_camped_cell_supports_hsrach() == TRUE)
            {
              rnti_required_for_hsfach_hsrach = TRUE;
            }
#endif
          }
          break;
        case rrc_RRC_StateIndicator_cell_FACH:
          if(rrccu_cell_update_cause == rrc_CellUpdateCause_periodicalCellUpdate)
            break;
          if(!new_H_RNTI_present)
          {
            rnti_required_for_hsfach_hsrach = TRUE;
          }
#ifdef FEATURE_WCDMA_HS_RACH
          if(rrchsrach_camped_cell_supports_hsrach() == TRUE)
          {
            rnti_required_for_hsfach_hsrach = TRUE;
          }
#endif
          break;
      }
    }
    
    else
    {
      switch(rrccu_state_indicator)
      {
        case rrc_RRC_StateIndicator_cell_PCH:
        case rrc_RRC_StateIndicator_ura_PCH:
          if(RRCCU_NO_RESP_MSG != resp)
          {
            if(!new_H_RNTI_present)
            {
              rnti_required_for_hsfach_hsrach = TRUE;
            }
#ifdef FEATURE_WCDMA_HS_RACH
            if((rrchsrach_camped_cell_supports_hsrach() == TRUE) && (!newPrimary_E_RNTI))
            {
              rnti_required_for_hsfach_hsrach = TRUE;
            }
#endif
          }
          break;
         case rrc_RRC_StateIndicator_cell_FACH:
           if(rrccu_cell_update_cause == rrc_CellUpdateCause_periodicalCellUpdate)
             break;
           if(!new_H_RNTI_present)
           {
             rnti_required_for_hsfach_hsrach = TRUE;
           }
#ifdef FEATURE_WCDMA_HS_RACH
           if((rrchsrach_camped_cell_supports_hsrach() == TRUE) && (!newPrimary_E_RNTI))
           {
             rnti_required_for_hsfach_hsrach = TRUE;
           }
#endif
           break;
      }
    }
  }
  MSG_6(MSG_SSID_DFLT, MSG_LEGACY_HIGH,"HRNTI_present: %d, ERNTI_present: %d, msg_version: %d, resp: %d, rrccu_state_indicator: %d, rnti_required_for_hsfach_hsrach: %d", 
  	new_H_RNTI_present, newPrimary_E_RNTI, msg_version, resp, rrccu_state_indicator, rnti_required_for_hsfach_hsrach);
  if(rnti_required_for_hsfach_hsrach == TRUE)
  {
    return TRUE;
  }
  return FALSE;
}

/*===========================================================================

FUNCTION rrccu_update_rnti_from_cu_cnf

DESCRIPTION 
This function updates RNTIs
DEPENDENCIES
    None.

RETURN VALUE
    None.

===========================================================================*/

static void rrccu_update_rnti_from_cu_cnf
(
boolean new_H_RNTIPresent,
boolean newPrimary_E_RNTIPresent,
rrc_H_RNTI *new_H_RNTI,
rrc_E_RNTI *newPrimary_E_RNTI,
rrcrb_directed_cell_info_type *directed_cell_info
)
{
#ifdef FEATURE_WCDMA_HS_RACH
  /*If cell supports HS-RACH then configure the E-RNTI and H-RNTI given in CUCNF*/
  if ((rrchsrach_camped_cell_supports_hsrach() == TRUE)&&
  ((rrccu_state_indicator ==rrc_RRC_StateIndicator_cell_FACH) ||
  (rrccu_state_indicator ==rrc_RRC_StateIndicator_cell_PCH)||
  (rrccu_state_indicator ==rrc_RRC_StateIndicator_ura_PCH))
  )
  {
    if(new_H_RNTIPresent && newPrimary_E_RNTIPresent)
    {
      /*store the hrnti*/
      (void)rrc_translate_hrnti(new_H_RNTI, &ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.h_rnti);
      rrc_set_hrnti_status(ordered_config_ptr, HRNTI_VALID);
      (void)rrc_translate_hrnti(new_H_RNTI, &transition_config.toc_ptr->l1_hsdpa_info.hs_dsch_info.h_rnti);
      rrc_set_hrnti_status(transition_config.toc_ptr, HRNTI_VALID);
      
      /*store the ernti*/
      ordered_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = TRUE;
      (void)rrc_translate_ernti(newPrimary_E_RNTI, &ordered_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti);
      
      transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = TRUE;
      transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti = ordered_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti;
      
      if(((rrccu_resp_msg == RRCCU_UMIC_COMPLETE_RESP_MSG) || (rrccu_resp_msg == RRCCU_NO_RESP_MSG))
      &&((directed_cell_info->freq_info_present == FALSE )&& (directed_cell_info->pscr_present == FALSE )))
      {
        rrcllc_establish_srb_rab_in_efach(RRC_E_FACH_DEDICATED,RRC_PROCEDURE_CU,FALSE);
      }
    }
  }
  else
#endif
  {
    if (rrcenhstate_camped_cell_supports_e_fach()&&
    ((rrccu_state_indicator ==rrc_RRC_StateIndicator_cell_FACH)|| 
    (rrccu_state_indicator ==rrc_RRC_StateIndicator_cell_PCH) || 
    (rrccu_state_indicator ==rrc_RRC_StateIndicator_ura_PCH))
    )
    {
      if(new_H_RNTIPresent)
      {
        if(((rrccu_resp_msg == RRCCU_UMIC_COMPLETE_RESP_MSG) || (rrccu_resp_msg == RRCCU_NO_RESP_MSG))
        &&((directed_cell_info->freq_info_present == FALSE )&& (directed_cell_info->pscr_present == FALSE )))
        {
          rrcllc_establish_srb_rab_in_efach(RRC_E_FACH_DEDICATED,RRC_PROCEDURE_CU,FALSE);
        }
      }
    }
  }
}
#endif
/*===========================================================================

FUNCTION rrccu_update_reconfig_proc_failure_status

DESCRIPTION 
  Updates reconfig procedures failure status so that LLC can swap after chan config by CU is done

DEPENDENCIES
    None.

RETURN VALUE
   NONE
successful.

===========================================================================*/

void rrccu_update_reconfig_proc_failure_status
(
  rrc_proc_e_type  proc_id
)
{
  switch(proc_id)
  {
    case RRC_PROCEDURE_RBE:
      return rrcrbe_update_failure_status(RRCRB_CELL_UPDATE_OCCURED);
    case RRC_PROCEDURE_RBR:
      return rrcrbr_update_failure_status(RRCRB_CELL_UPDATE_OCCURED);
    case RRC_PROCEDURE_RBRC:
       return rrcrbrc_update_failure_status(RRCRB_CELL_UPDATE_OCCURED);
    case RRC_PROCEDURE_TCR:
      return rrctcrc_update_failure_status(RRCTC_CELL_UPDATE_OCCURED);
    case RRC_PROCEDURE_PCR:
      return rrcpcrc_update_failure_status(RRCPC_CELL_UPDATE_OCCURED);
    default:
      break;
  }
  return;
}
/*===========================================================================   
      FUNCTION rrccu_post_crlc_status_ind
      
      DESCRIPTION
        
      This function will post RLC reset if buffered before moving to stand by 
      State.
        
      DEPENDENCIES
        None
      
      RETURN VALUE
        None
        
      SIDE EFFECTS
      
        None
      
===========================================================================*/
static void rrccu_post_crlc_status_ind(void)
{
  rrc_cmd_type *rrc_cu_rlc_reset_cmd_ptr;
  rrc_cu_rlc_reset_cmd_ptr = rrc_get_rlc_cmd_buf();
  rrc_cu_rlc_reset_cmd_ptr->cmd_hdr.cmd_id = RRC_CRLC_STATUS_IND;
  rrc_cu_rlc_reset_cmd_ptr->cmd.crlc_status_ind.direction = TRUE;
  rrc_cu_rlc_reset_cmd_ptr->cmd.crlc_status_ind.error_type = RLC_RESET_FAIL;
  rrc_cu_rlc_reset_cmd_ptr->cmd.crlc_status_ind.lc_id = rrccu_buffered_reset_ind.lc_id;
      
  WRRC_MSG1_HIGH("Posting the Buffered RLC reset indication LC ID %d ",
    rrc_cu_rlc_reset_cmd_ptr->cmd.crlc_status_ind.lc_id );
        
  rrc_put_rlc_cmd(rrc_cu_rlc_reset_cmd_ptr);
}
/*===========================================================================   
      FUNCTION rrccu_post_buffered_commands
      
      DESCRIPTION
        
      This function will post commands buffered when UE was in standby state.
        
      DEPENDENCIES
        None
      
      RETURN VALUE
        None
        
      SIDE EFFECTS
      
        None
      
===========================================================================*/

void rrccu_post_buffered_commands(void)
{ 
  if(rrccu_buffered_cmd_mask != 0)
  {
    WRRC_MSG1_HIGH("Post %d from buffered indication",rrccu_buffered_cmd_mask);
  }
  if(rrccu_buffered_cmd_mask & UL_DATA_IND)
  {
      rrccu_rlc_ul_data_ind(NULL,NULL);
      /* Need not send SIB-change/t305 expiry if UL data ind is sent even if it is buffered*/
  }  
  else if(rrccu_buffered_cmd_mask & CRLC_STATUS_IND)
  {
    rrccu_post_crlc_status_ind();
  } 
  else if(rrccu_buffered_cmd_mask & CU_INITIATE_REQ)
  {
      rrccu_post_cu_initiate_req();
  }
  else if(rrccu_buffered_cmd_mask & T305_EXPIRY_IND)
  {
      rrccu_post_t305_expiry_ind();
      /*Need not send sib change ind if t305 expiry is sent even if it is buffered 
        Prioritize t305 expiry because this will always trigger CU, where as sib change ind 
        triggers CU only if there is a URA change 
       */
  }  
  else if(rrccu_buffered_cmd_mask & SIB_CHANGE_IND)
  {
      rrccu_post_sib_change_ind();
  }
  /* Reset the mask */
  rrccu_buffered_cmd_mask = 0;  
  memset(&rrccu_buffered_cu_initiate_req,0,sizeof(rrc_initiate_cu_req_type));
  memset(&rrccu_buffered_reset_ind,0,sizeof(rrccu_bufferred_reset_ind_type));
}
/*===========================================================================

FUNCTION rrccu_get_dest_state

DESCRIPTION 
  This function returns the destination state

DEPENDENCIES
   None.

RETURN VALUE
   rrc_state_e_type

SIDE EFFECTS
      
    None
===========================================================================*/

  rrc_state_e_type rrccu_get_dest_state(void)
{
  return rrc_translate_state_indicator_to_state(rrccu_state_indicator);  
}
/*===========================================================================

FUNCTION rrc_check_cu_started_with_cause_rlfailure_or_rlc_unrecoverable_error

DESCRIPTION 
  This function returns true if cu is sent with cause RL failure or RRC unrecoverable error

DEPENDENCIES
    None.

RETURN VALUE
   boolean
successful.

===========================================================================*/
boolean rrc_check_cu_started_with_cause_rlfailure_rlc_unrecoverable_error()
{
  rrc_CellUpdateCause cu_cause;
  if((rrccu_get_cell_update_started_status_with_cause(&cu_cause) == RRCCU_STARTED) && 
      ((cu_cause == rrc_CellUpdateCause_radiolinkFailure) || 
       (rrccu_rlc_error_info.error_on_srb == TRUE) || 
       (rrccu_rlc_error_info.error_on_urb)))
  {
    return TRUE;
  }
  return FALSE;
}

/*===========================================================================

FUNCTION rrccu_check_cu_active_before_lock_rel

DESCRIPTION 
  This procedure is used to query if CU is active for UL Data Transmission,
  Periodic Cell Update, Paging Response 

DEPENDENCIES
    None.

RETURN VALUE
   NONE
successful.

===========================================================================*/

boolean rrccu_check_cu_active_before_lock_rel(void)
{
  boolean status=FALSE;  

  if((rrccu_get_cell_update_started_status()== RRCCU_STARTED) 
   &&((rrccu_cell_update_cause == rrc_CellUpdateCause_uplinkDataTransmission)||
      (rrccu_cell_update_cause == rrc_CellUpdateCause_utran_pagingResponse)||
      (rrccu_cell_update_cause == rrc_CellUpdateCause_periodicalCellUpdate)||
      (rrccu_ura_update_cause == rrc_URA_UpdateCause_periodicURAUpdate)))
  {

   /* When CU cause is rrc_CellUpdateCause_cellReselection & rrc_CellUpdateCause_re_enteredServiceArea,
      CU module will decide if lock acquiring is needed after it receives NEW_CELL_IND. 
      Thus CSP releases the lock as its uncertain whether CU will be triggered.
    */ 
    status=TRUE;
  }
  return status;  
}
/*===========================================================================

FUNCTION rrccu_set_cu_cause_for_wait_timer

DESCRIPTION 
  This function sets the variable cu_cause_for_wait_timer with an appropriate CU cause

DEPENDENCIES
    None.

RETURN VALUE
None

===========================================================================*/

void rrccu_set_cu_cause_for_wait_timer(rrc_cell_update_cause_e_type cu_cause)
{
  rrccu_int_data.cu_cause_for_wait_timer = cu_cause;
}
/*===========================================================================

FUNCTION rrccu_set_cu_cause_to_ul_data_indication

DESCRIPTION 
  This function sets cell update cause to UL data indication. 
  UL data inidication can be directly updated as CU cause as it has highest priority.
  This function should be used only if current state is PCH

DEPENDENCIES
    None.

RETURN VALUE
None

===========================================================================*/
void rrccu_set_cu_cause_to_ul_data_indication()
{
  rrccu_cell_update_cause = rrc_CellUpdateCause_uplinkDataTransmission;
}
/*===========================================================================

FUNCTION rrccu_return_ordered_state

DESCRIPTION 
   This function returns the ordered state give by NW in Cell update confirmation

DEPENDENCIES
    None.

RETURN VALUE
    Ordered RRC state

===========================================================================*/

rrc_RRC_StateIndicator rrccu_return_ordered_state(void)
{
  return(rrccu_state_indicator);
}/*===========================================================================
      
      FUNCTION rrccu_check_if_crnti_valid
      
      DESCRIPTION
        
      This function returns rrccu_new_crnti_valid
        
      DEPENDENCIES
        None
      
      RETURN VALUE
        boolean
        
      SIDE EFFECTS
      
        None
      
===========================================================================*/

boolean rrccu_check_if_crnti_valid(void)
{
  MSG_HIGH("CRNTI Valid %d",rrccu_new_crnti_valid,0,0);
  return (rrccu_new_crnti_valid);
}/*===========================================================================

FUNCTION rrccu_check_if_cu_ordered_state_is_pch_and_oc_is_not_set

DESCRIPTION 
   This function checks if we are transitioning to PCH and if OC is not set

DEPENDENCIES
    None.

RETURN VALUE
    None

===========================================================================*/

boolean rrccu_check_if_cu_ordered_state_is_pch_and_oc_is_not_set(void)
{
  if((rrcllc_get_ordered_config_status() == OC_NOT_SET)
     &&
     (rrccu_substate != RRCCU_INITIAL)
     &&
     ((rrccu_state_indicator == rrc_RRC_StateIndicator_cell_PCH)
     ||
     (rrccu_state_indicator == rrc_RRC_StateIndicator_ura_PCH))
     &&
     (rrccu_oc_set_by_cu == FALSE))
  {
    return TRUE;
  }
  return FALSE;
}

/*===========================================================================

FUNCTION rrccu_is_channel_config_in_process

DESCRIPTION 
   This function indicates whether lower layer configuration is in progress

DEPENDENCIES
    None.

RETURN VALUE
    boolean

===========================================================================*/
boolean rrccu_is_channel_config_in_process()
{
  if((ordered_config.set_by_proc == RRC_PROCEDURE_CU) && 
    ((rrccu_return_cu_substate() == RRCCU_WAIT_FOR_RB_EST_CNF) || (rrccu_return_cu_substate() == RRCCU_WAIT_FOR_RNTI_UPDATE_CNF)))
  {
    return TRUE;
  }
  return FALSE;
}
#ifdef FEATURE_QSH_DUMP
/*===========================================================================
FUNCTION wrrc_qsh_dump_cu_debug

DESCRIPTION
  This function dumps cu globals

DEPENDENCIES
  None


RETURN VALUE
None


SIDE EFFECTS
  None

===========================================================================*/
__attribute__((section(".uncompressible.text")))
size_t wrrc_qsh_dump_cu_debug(uint8* dump_addr, size_t size)
{
  wrrc_qsh_dump_tag_cu cu_globals;  
  rrc_CellUpdateCause cu_cause;
  qsh_client_dump_tag_hdr_init((qsh_dump_tag_hdr_s *)dump_addr,WRRC_QSH_DUMP_TAG_CU_DEBUG,
                                   (sizeof(wrrc_qsh_dump_tag_cu)));
  WCDMA_MEMCPY(&cu_globals,sizeof(wrrc_qsh_dump_tag_cu),(wrrc_qsh_dump_tag_cu*)dump_addr, sizeof(wrrc_qsh_dump_tag_cu));

  cu_globals.rrccu_substate = rrccu_return_cu_substate();
  rrccu_get_cell_update_started_status_with_cause(&(cu_cause));
  cu_globals.rrccu_cell_update_cause = (uint8)cu_cause;
  cu_globals.rrccu_ura_update_cause = rrccu_ura_update_cause;
  cu_globals.rrccu_state_indicator = rrccu_state_indicator;
  /* URA update state indicator */
  cu_globals.rrccu_resp_msg = rrccu_resp_msg;
  cu_globals.rrccu_tran_to_discon_counter = rrccu_tran_to_discon_counter;
  cu_globals.rrccu_buffered_cmd_mask = rrccu_buffered_cmd_mask;
  cu_globals.rrccu_reestablish_srb = rrccu_reestablish_srb & 0x01;
  cu_globals.rrccu_reestablish_rab = rrccu_reestablish_rab & 0x01; 

  if(sizeof(cu_globals) >= size)
  {
    WCDMA_MEMCPY((wrrc_qsh_dump_tag_cu*)dump_addr, size, &cu_globals, size);
    return ((size_t)size);
  }
  else
  {
    WCDMA_MEMCPY((wrrc_qsh_dump_tag_cu*)dump_addr,sizeof(cu_globals), &cu_globals, sizeof(cu_globals));
    return ((size_t)(sizeof(cu_globals)));
  }
}     
#endif 
#ifdef FEATURE_QSH_EVENT_METRIC

/*===========================================================================
FUNCTION rrcqsh_log_cuc_ota_params

DESCRIPTION

DEPENDENCIES
  None

RETURN VALUE
None

SIDE EFFECTS
  None

===========================================================================*/

void rrcqsh_log_cuc_ota_params()
{
  ((wrrc_qsh_metric_ota_s*)rrc_qsh_metric_db[WRRC_QSH_METRIC_OTA].data_ptr)->ota_info.cuc_params.srb_re_est_ind = rrccu_reestablish_srb;
  ((wrrc_qsh_metric_ota_s*)rrc_qsh_metric_db[WRRC_QSH_METRIC_OTA].data_ptr)->ota_info.cuc_params.drb_re_est_ind = rrccu_reestablish_rab;
  ((wrrc_qsh_metric_ota_s*)rrc_qsh_metric_db[WRRC_QSH_METRIC_OTA].data_ptr)->ota_info.cuc_params.new_crnti_present = rrccu_new_crnti;
  ((wrrc_qsh_metric_ota_s*)rrc_qsh_metric_db[WRRC_QSH_METRIC_OTA].data_ptr)->ota_info.cuc_params.new_urnti_present = rrccu_new_urnti;
}

/*===========================================================================
FUNCTION rrccu_get_num_rb_rel

DESCRIPTION

DEPENDENCIES
  None

RETURN VALUE
None

SIDE EFFECTS
  None

===========================================================================*/

uint8 rrccu_get_num_rb_rel()
{
  return rrccu_rb_release_info.num_rbs;
}

/*===========================================================================
FUNCTION rrccu_get_num_rb_rel

DESCRIPTION

DEPENDENCIES
  None

RETURN VALUE
None

SIDE EFFECTS
  None

===========================================================================*/

boolean rrccu_get_cuc_for_srns_relocation()
{
  return  rrccu_cucnf_for_srns_relocation;
}
#endif