/*===========================================================================

                    L3 - RRC Lower Layer Controller Interface

DESCRIPTION
  This file implements the Lower layer Controller functionality. The
  functionality includes -
    * Processing of RRC internal commands like RRC_CHANNEL_CONFIG_REQ that
      results in sending of multiple lower layer commands and processing their
      confirms till RLC, MAC and L1 is configured with the new channels. The
      processing of RRC_CHANNEL_CONFIG_REQ also involves implicit channel
      setups/releases on an RRC state change.
    * Funneling all commands to lower layers from RRC procedures.
    * Processing Confirmations and Indications from lower layers. Those
      that are as a response to funneled command are sent to the RRC procedure
      that was the sender of the funneled command. Others are processed in LLC.

  The LLC depends on Ordered Config data structures to fill up L1, MAC and RLC
  config data. Some fields in Ordered Config data structures (logical channel
  IDs, CCTrCH IDs etc) are to be filled in by LLC while processing
  RRC_CHANNEL_CONFIG_REQ.


  EXTERNALIZED FUNCTIONS

  rrcllc_init(void)

    This function initializes all RRCLLC data including CCTrCH ID database,
    Command under process data, LLC internal queue and the ORDERED_CONFIG
    databases. This calls a number of other initialization functions. At present
    it also initializes some ordered config MAC and RLC data.
    This function should only be called when RRC is being initialized,
    i.e. after a power up reset, or during an RRC reset.

  rrcllc_process_cmd(rrc_cmd_type *cmd_ptr)

    This function is the main entry point for LLC. It is called by RRC
    dispatcher for all commands that are meant to be for LLC. These include
    RRC internal commands and confirms/indications from MAC, RLC and L1.
    This function depending on the existing LLC state, calls the
    corresponding LLC state handler. If the next LLC state as returned from
    LLC state handler is LLC_IDLE, the LLC command queue is dequeued and the
    new command processed till there are no more commands in LLC command queue.


Copyright (c) 2000-2009 Qualcomm Technologies, Inc.  All Rights Reserved.
QUALCOMM Proprietary.  Export of this technology or software is regulated
by the U.S. Government. Diversion contrary to U.S. law prohibited.
===========================================================================*/



/*===========================================================================
                      EDIT HISTORY FOR FILE

This section contains comments describing changes made to this file.
Notice that changes are listed in reverse chronological order.

$PVCSPath:  L:/src/asw/MSM5200/RRC/vcs/rrcllc.c_v   1.110   12 Jul 2002 10:39:58   vnagpal  $
$Header: //commercial/MPSS.JO.2.0.c1.4/Main/modem_proc/wcdma/rrc/src/rrcllc.c#1 $ $DateTime: 2016/12/13 08:00:12 $ $Author: mplcsds1 $

when       who      what, where, why
--------   ---      -------------------------------------------------------- 
06/20/16   sp      Made changes to reduce F3s
06/06/16   sp      Made changes to fix QSH Active set metric, UL OTA parameters metrics 
06/06/16   sp      Made changes to add call end metrics - FR#30856
06/06/16   sp      Made changes for Mav debug snapshot
05/30/16   as      Made changes to drop SCCPCH1(CTCH) before after entering HSFACH
05/12/16   sp      Made changes to reset sib-5 in progress flag if channel config for sib-5 change failure happens
05/09/16   nr      Made changes to remove F3 in rrcllc_get_ordered_config_state_and_proc_wo_f3 
01/27/16   sp      Made changes to swap OC/CC as needed if ping pong reselections from
                   legacy/hsfach/hsrach cells if DCH_FACH timer expiry happens.01/19/16   sp      Made changes to stop EUL if it is active at MAC
11/27/15   as      Made changes to trigger cphy act cancel only if cphy setup is in progress for procedure which set OC
11/27/15   nr      Made changes to clear CCTrCH ID for HSFACH when W to G HO fails in connecting state
10/16/15   as      Added code to support LTA durting activation time
08/21/15   sg      Made changes to send NOT HHO CFG when going back to old config after a forced SYNC A failure.
06/26/15   sg      Made changes to reset mac_hs_restore_tsns once restore is indicated to mac
06/26/15   sg      Made changes to send channel config cnf to IHO procedure before processing the next LLC cmds in queue
06/25/15   sp      Made changes not to report physical channel establish ind fail event on cphy setup failure
06/03/15   ad      Made changes to take UE to idle if SIB5 capability changes from non-hsfach
                   to hsfach (vice versa) and there is a cell update being initiated
06/12/15   sp      Fixed KW errors
03/04/15   aa      Made changes to provide RB Id and one-sided reestablishment flag status in RLC config procedures
05/26/15   sp      Made changes to avoid configuring Data RB to lower layers for when OOS is received during fach to fach redirection cases
04/20/15   ad      Changes are done to initialize the LLC substate when L1 sends a DRX error indication.
04/14/15   sp      Made changes to indicate Multi rab status to L1
03/04/15   ad      Made changes to reset common edch transmission variable when cphy setup fails
                   on connecting  to dch channel config
02/12/15   sa      Made changes for QTF with JO CRM
02/10/15   aa      Made changes to reset llc_stored_cmd_ptr to NULL in wait for cphy_setup_handler.
02/06/15   aa       Made changes to trash cell_transition_req at RRC after Neighbor BCCH drop fails at L1 with reason as no lock available
01/21/15   sa      Made changes for QTF with CRM
01/07/15   sp      Made changes to block IDLE_REQ when RRC mode is inactive
12/01/14   sp      Made changes to reduce activation time for dch/fach transition
11/27/14   sp      Made changes to send TVM command to MAC after common transport channels are configured during DCH/FACH transition
11/27/14   sr      NV control for FR23776
11/24/14   sg      Made changes to take backup of old size if re-establishment happens through RNTI update
                   and re-est indicator for RAB is TRUE.
11/19/14   aa      Made changes to the config mask in case of reestablishment
11/17/14   sp      Made changes to store URNTI in TOC during RNTI update.
11/10/14   sp      Made changes to save procedure substates in crash debug info
10/22/14   sp      Made changes to reset ordered_config process state after FACH to PCH state transition
10/17/14   sr      CSFB call optimization changes
10/13/14   sg      Made changes to init TSN extn in TOC during release
                   transport channel phy channel
10/09/14   as      Made changes to not configure AGCH for non serving RLs after resume
10/09/14   sp      Made changes to call config_dcch_dtch when HSPA RNTI flag is set to true during fach to PCH state transition
10/07/14   sp      Made changes to check the HS-FACH status in the config-pointer-in-use while populating call type mask
10/06/14   sg      Made changes to clear allocated lc ids if update cmd under process
                   fails during reselection
09/24/14   sp      Made changes to set EFACH action as start only if cell capability upgrades from legacy to EFACH.
09/11/14   sg      Made changes to handle IRAT reselection failure when
                   OC is set for FACH to PCH state transition
09/05/14   sp      Made changes to detect UL size change for fach to pch transition before sending 
                   RB complete to facilitate inclusion of start value
09/05/13   sg      Made changes to log events for inter freq HHO status
09/02/14   sp      Made changes to start L1 deadlock timer for CPHY_CELL_SELECTION_REQ
09/02/14   sp      Made changes to log CRLC AM
09/02/14   as      Made changes to send DL TM chan request for dch to fach transition optimizaion
08/26/14   ad      Made changes not to configure C/ERNTI during the channel configuration from CU and 
                   reconfigure MAC later when RNTI update happens.
08/24/14   sp      Made changes not to set RLC am config mask if there is no UL size change in RNTI update code
08/18/14   vr      Cleanup code for HSRACH 'conventional' seamless recfg.
08/11/14   sg      Made changes to clear ERNTI at MAC if CU is to be
                   triggered
08/08/14   sp      Made changes to set PDCP action as release if RB is released due to re-establish timer expiry
08/06/14   sp      Made changes to update hspa rnti stored in cell pch before calling config dcch dtch 
08/04/14   sp      Made changes to fix compilation errors
07/31/14   sp      Made changes to update dedicated params to oc for delay cu case
07/28/14   sg      Made changes to include code review comments 
                   for delay CU code
07/24/14   sp      Made changes to replace memcpy with safer macro WCDMA_MEMCPY
07/24/14   sp      Made changes to update re-establihment redesign F3s.
07/24/14   as      Made changes to check DC-HSUPA status at L2 while stopping DC
07/21/14   as      Made changes to check-in F3 reduction chnages
07/21/14   sp      Made changes to set hsfach req mask in cphy setup when sib-5 change happens waiting for CU confirm
07/18/14   sp      Made changes to use dest frequency present flag instead of is_hho flag to trigger HHO on moving back to old configuration.
09/13/13   db      Made changes to detect PCCPCH mismatch between L1 and RRC
06/30/14   db      Made changes to clear ERNTI when HSPA_RNTI_STPRED_CELL_PCH is evaluated to false
06/27/14   db      Made changes to trigger OOS when validation fails for 2nd cphy setup during FACH to DCH and
                   to clear UL TM logical channel when channel config fails
06/26/14   sn      WRRC changes for FR20484
06/19/14   sg      Made changes to revert the cipher config db if cipher config type is
                   updated to step1 but later message validation failed.
06/24/14   sp      Made changes to set HSPA_RNTI_STORED_CELL_PCH to true upon OOS and recovery on same cell
06/20/14   db      Mainlined FEATURE_WCDMA_HS_RACH_DELAY_CU and introduced NV control
06/23/14   sp      Made changes to set the HSRACH req mask correctly when CSP sends channel config for channel resetup after resume.
06/23/14   sp      Made changes to reset ERNTI is OC/CC if OOS occurs in cell_FACH state.
06/20/14   sa      Made changes to update the UL 16QAM
06/09/14   db      RRC Logging Changes for CMAC and CRLC
06/17/14   rmn     Made changes to indicate resel fail cause in CPHY_CELL_TRANSITION_REQ
06/17/14   sp      Made changes to mainline DCH-FACH transition optimization changes
06/17/14   sp      Made changes to mainline RLC-restablihment redesign changes
06/04/14   as      Made changes for DCH-FACH transition time optimization
06/02/14   sp      Made changes for FR19997 - UL rlc re-establishment redesign
05/30/14   sa      Made changes to support 64x64 single PS RAB detection
05/26/14   db      Made changes to include the correct diverstiy value when the optiona IE 
                   'Primary PCCPCH info'is omitted
05/23/14   sg      Made changes to configure SRB1 properly for reselection within fach
05/23/14   db      Made changes to stop HSRACH when cell transition fails from HSRACH to legacy cell
05/23/14   db      Made changes to update config database when reselection is triggered during DCH to FACH transition
04/15/14   sa      Made change to allow MAC that config has been changed even thru ASU for to stop DCHSUPA
05/20/14   sp      Set maximum limit on the number of commands in LLC command queue
05/16/14   vi      Made changes to support MOB framework
05/16/14   sp       Made changes to update proper data base when getting serving rl idx for DCHSUPA
05/15/14   sp      Made changes to avoid accessing null pointer while accessing hsdpa_l1_info.
05/14/14   ymu     Feature name FEATURE_WCDMA_DC_HSUPA_FRAME replacement with FEATURE_WCDMA_DC_HSUPA 
05/06/14   geg     Use safer versions of memcpy() and memmove()
04/10/14   db      Made changes to detect UL size change during FACH to FACH redirection
04/10/14   sp      Made changes to avoid initializing re-establish entity if OC is set and reselection happens on a EFACH/HSRACH cell
04/10/14   sp      Made changes to avoid initializing re-establish entity when OC is set and cell reselection happens
04/04/14   db      Made changes to set HSPA_RNTI_STORED_CELL_PCH to true upon OOS and recovery on same cell
04/02/14   vg      Made changes to Systematically log all the internal and external primitive handled in RRC and corresponding top level action.
04/01/14   sp      Fixed KW errors
03/25/14   db      Made changes to include secondary carrier frequency for DCHSUPA upon WtoL failure
02/11/14   sg      Made changes to include revert to old config flag in cphy setup req.
02/04/14   sg      Made code changes for 3C for latest interface
03/13/14   db      Made changes to configure HSRACH mask for FACH to PCH redirection case
03/13/14   sp      Removed code under FEATURE_WCDMA_HS_PCH feature flag
08/13/13   sg      Made changes to include pccpch tx div ind in cell transition req
02/13/14   ad      Made changes to remove redundant F3s
03/08/14   vg      Made changes to reduce the stack size usage of some RRC functions which has the usage more than 500 bytes.
02/03/14   as      Made changes to backup internal/external cmds for crash debugging
01/28/14   db      Made changes to not set wait for L1 signal to MAC when reselection is triggered during FACH to PCH transition
01/20/14   sg      Made changes not to include ASET bitmask and 
                   include DROP bitmask if DCHSUPA is stopped through ASU
01/09/14   sp      Removed code under FEATURE_CS_VOICE_OVER_HSPA features
07/01/14   vi      Modified code to configure MAC with TVM when 
                   new cell indication is posted to meas and rrccu_substate is wait for CU confirm
06/01/14   sp      Made changes to reset hspa_rnti_stored_cell_pch flag on resume failure
02/01/14   sg      Made changes to set DC HS status based on config_ptr_in_use
02/01/14   rmn     Reduction of unwanted F3's
24/12/13   sp      Made changes to use reselection pointer to set wait for L1 signal for HSRACH
12/19/13   db      Made changes to configure lower layers properly and detect size re-establishment for SIB5 change
11/08/13   ad      Made changes to indicate ho_type as part of codec info to CM
12/13/13   db      Made changes to delay Cell Update when HSRACH Capability changes until Uplink Data Arrives 
12/11/13   db      Revert CR 566377 and reverted allocation of bcch-fach lc-id during copy sib to oc for efach
12/03/13   sg      MAde changes to update review comments for 3C
11/22/13   vg      Made changes to ensure CC does not have RLC size from OTA when transitioning from DCH to FACH and "same_as_before" not used for AM RBs.
11/20/13   db      Made changes to delay PCCPCH drop upon HSRACH to DCH transition
11/19/13   sp      Made changes to trigger transition to disconnect if SIB5 change is triggered when OC set
10/24/13   sn      Changes to handle channel config in standby mode for FRLTE cases
11/13/13   db      Made changes to reset hs action if channel config cnf is not needed
                   for specific channel config reason
11/12/13   as      Made changes to not increament the num of sec hs carriers while going back to old config
11/11/13   sp      Made changes to configure dedicated mode only when fach to dch physical chanel failure
                   happens and ue camps back on same cell
10/30/13   as      Made changes to add feature code for FEATURE_WCDMA_3C_HSDPA
10/24/13   ad      Made changes to drop BCCH-FACH channel on going to DCH state,
                   and adding while going to connecting state
10/17/13   ad      Changes for DC HSDPA feature with 3C interface
09/29/13   sp      Made changes to correct the hsrach action for fach to dch transitions
09/20/13   sp      Made changes to correct overwriting of mac hsdpa action in OC by directly copying the L2 hsdpa action to the L2 buffer.
09/03/13   sa      Made changes to handle the sysinfochange ind while waiting for CU-Cnf
08/07/13   sp      Made changes revert the code for unconditional reset of HS if channel config cnf is not needed
08/02/13   db      Made changes correctly update semi permanent and cctrch id database
                   when a NBCH setup fails
07/31/13   vi      Replace l1_get_best_psc_in_aset to new api l1_get_hs_psc_sib_read
07/30/13   sp      Made changes to send channel config cnf with correct transaction id while processing the pending 
                   commands on receiving new cell indication during reselection
07/29/13   ad      Made Changes to reset hs req mask if channel config cnf is not required.
                   Changes to reset the hs req mask before sending cell transition req
07/27/13   sp       Made Changes to fix URNTI typecast error
07/24/13   ad      Made changes to reconfigure L1/MAC for loopback mode when HSRACH is ON
07/23/13   db      Made changes to ignore flow-ID check for SRB's and user RB when cell update is triggered
07/19/13   db      Made changes to Swap OC and CC after channel config by CU when
                   a procedure is registered and it fails
07/11/13   ad       Made changes to ignore add and drop of bcch
                    in standby state
07/08/13   db       Made changes to check if BCCH and dedicated HRNTI matches for HSFACH
07/08/13   ad      Made changes to remove redundant F3s
06/28/13   sg       Made changes to set rlc_action as suspend in mac config during reselection
06/27/13   sa      Added changes to support call type mask for AMR with PS0x0 config
06/26/13   as       Made changes to allocate CCTrch-ID only aftere restoring the mappings
06/12/13   ad       Made changes to configure from OC when cell update confirm takes to 
                    PCH state and OC is set.This will remove the use of 
                    RRCLLC_CHAN_CFG_EPCH_HRNTI_ONLY cause.
06/05/13   db       Made changes to restore EDCH_EHS mappings when camped cell supports HSRACH
06/04/13   db       Made changes to update sccpch flag properly for reselection cases
05/30/13   db      Made changes to ignore Cu-Cnf when RAB release is in progress
05/27/13   db       Made changes to transition to FACH state in race condition between deferred SIBs,
                     paging and cell reselection
05/22/13   sa      Added code changes to support FEATURE_WCDMA_DC_HSUPA
05/20/13   as       Made changes to clear CCTrch-Id for HS-FACH when WCDMA to GSM HO fails
05/20/13   db       Made changes to update sccpch flag in semi perm data upon reselections
05/16/13   db       Made changes to configure lower layers properly upon SIB5 change in HSRACH cell
05/10/13   sg      Made changes to fix the compilation errors
05/08/13   db      Multiple mapping support for EFACH
04/22/13   ad      Made changes to set hspa_rnti_stored_cell_pch to TRUE when cell update/ura update
                   confirm’s response is UMIC
04/24/13   ad       Made changes to configure hsrach dedicated mode during reselection.
                    Made changes not to reset hsrach actions in OC if OC is set when RRCLLC_CHAN_CFG_EPCH_HRNTI_ONLY
                    cause is used.
04/18/13   db       Made changes to restore the rb mappings after rececovering from OOS in PCH state
04/16/13   db       Made changes to set sttd indicator to FALSE when IE is not included in SIB5
04/15/13   mp       Made changes to include HSDPCCH req mask 
                    in hsrach configuration when 2 cphy_setup reqs are sent to L1
04/08/13   db       Made changes to configure lower layers properly when CU Cnf response is 
                    other than UMIC
03/27/13   mp       Made changes to set the dummy cphy setup req mask to zero
                    for DCH to FACH transition
03/26/13   db       Changes for unification of Cell Transition and CPHY setup handling.
03/22/13   mp       Removed tmc.h include file
03/07/13   mp       Made changes to not reconfig RACH when CU response is UMIC
03/06/13   ad       Added prints to print CRNTI on PCH->FACH and FACH->PCH transition
02/11/13   ad       Made changes to reset the hsrach action when channel configuration is from CCM and
                    next state is fach or connecting. Made changes not to determine
                    hsrach action when configuration of dedicated mode fails.
02/06/13   ad       Made changes to repost the channel config request to internal command while setting 
                    up serving bcch for reading cell id in dch and oc is set
02/01/12   md       Made changes to skip RLC size change detection for SRBs
02/04/13   ad      Changes to check if num_trch is greater than zero before printing
02/01/13   db       Made changes to clear HRNTI for HSFACH to DCH(non-HS) case
01/25/13   db      Made changes to not configure BCCH FACH in connecting state
01/25/13   sa      Made changes for TM loop back mode under FEATURE_TM_LB
01/23/13   mp      Fixing KW errors
01/17/13   sa      Made changes trash the queued commands till first useful command
01/03/13   ad      Made changes to reduce the redundant F3s
01/03/13   db       Made changes to not Swap OC and CC  when DCH_FACH timer expires to an EFACH cell
12/31/12   sn       Changes to handle channel config request to release all
                    channels when RRC went to standby mode due to fast return to LTE
12/18/12   sn       Changes to honor channel config request in wait new cell
                    indication substate triggerred due to fast return to LTE
12/11/12   mp       Made changes to reconfig HS to MAC if redirection to different RAT fails
12/10/12   sa       Made the changs to update copy sib to oc for hsrach for connecting to fach state
12/07/12   sn       CSG feature changes
12/04/12   ad       Made changes to send start of SRVCC indication to CM 
11/28/12   db       Made changes to determine the hspa_rnti_stored_cell_pch flag based 
                    on if CRNTI is provided in the OTA message or not
11/27/12   gv       Fixed compiler warnings when DSDS is enabled
11/22/12   sa       Made changes to update the call type mask for CS data 
11/16/12   mp       Made changes to configure hs action properly depends on the MAC hs status 
                    when cphy setup fails
11/16/12   mp       Made changes to not configure sccpch if efach is active during RNTI update req processing
11/12/12   gv       Fixed compiler warning
11/07/12   db       Made changes to backup and restore drx co-efficient
11/08/12   as       Made changes to drop pccpch in 2nd cphy setup reqeust for efach to pch transition
10/29/12   pm       Made changes to handle CRLC_UL_UNREG_FOR_DATA_IND_REQ in 
                    rrcllc_handle_commands_on_new_cell_ind substate
10/26/12   gv       Corrected the changes under FEATURE_WCDMA_DIME_SW
10/26/12   db       EFACH Redesign changes
10/23/12   pm       Made changes to assign pointer to NULL after de-allocation
10/22/12   pm       Made changes to correctly increment DL TM channels in OC
10/19/12   sa       Made the changes to update the call type mask for cs voice and cs data
10/18/12   gv       Replace FEATURE_DUAL_SIM_WCDMA_TUNEAWAY with FEATURE_DUAL_SIM
10/04/12   md       Made changes to detect RLC size change during state transitions via CELL PCH state.
10/04/12   pm       Removed unnecessary comments
10/03/12   pm       Made changes to backup hrnti while going to PCH state and 
                    retrieving it while evaluating hspa_rnti_stored_cell_pch
                    and ready_for_common_edch variables.
10/03/12   pm       Made changes to configure hs-rach after recovered from rl failure and
                    to not reset the hs-fach status in OC when channel config fails
10/03/12   pm       Made changes to validate only legacy fach/rach mapping while 
                    processing RNTI update request from CU
10/03/12   pm       Made changes to backup ernti without checking for hsrach support.
10/03/12   pm       Made changes to set hspa_rnti_stored_cell_pch to false when 
                    re-entering service in fach state, removed the determination of
                    hsrach action twice when cu sends dedicated mode config,changes
                    to determine rlc-reestablishment during reselection from hsrach
                    to non-hsrach cell and cucnf sets OC.
10/03/12   pm       Made changes to allow only a few procedures to reset the hsrach actions
10/01/12   rd       Changes were made to trash DRX_REQ from internal cmd queue if CTCH setup is ignored.
10/01/12   pm       Made changes to stop hs-rach for the special case, when we receive HRNTI and 
                    transition to PCH, first channel config is update HRNTI at L1/MAC.
10/01/12   pm       Made changes to send RLC_SUSPEND/RLC_RESUME based on RLC action Modify only in CMAC_UL_CONFIG
09/28/12   db       Made changes to reset the rlc reestablish entity during cell reselections in FACH and PCH
09/28/12   db       Made changes to incorporate the review comments of CRs 377231,389499
09/28/12   ad       Made changes to send reconfiguration complete if cell update confirm
                    takes us to PCH and complete message is yet to be sent to network.
                    Made changes to stop HSDPA when CU is taking from FACH to PCH and
                    OC is not set by CU
09/27/12   db       Made changes to access reselection ptr when allocated
09/27/12   pm       Made the changes to update the HRNTI for UMIC
09/24/12   ad       Made changes to reset common_edch_transmission when UE moves
                    from HSRACH to non HSRACH cell in connecting state.
09/22/12   ad       Corrected featurization for RRCLLC_CHAN_CFG_EPCH_HRNTI_ONLY cause
09/07/12   ad       Made changes to fill the LC IDs in RLC database in modify case also
                    in rrcllc_process_config_dcch_dtch for AM channels
07/27/12   ad       Fixed compiler warning
08/29/12   db       Made changes to DROP BCH after UE re-enters in HSRACH cell
08/14/12   db       Made changes to set the correct HSRACH actions to L1 and MAC
                    in CCO fails and resume scenario.
08/14/12   db       Made changes to set transition_to_dch for connecting to DCH state.
08/12/12   db       Added NULL pointer check for reselection_config_ptr
08/14/12   db       Made changes to determine hsrach action on fach to dch transition
08/14/12   db       Made changes reconfig ccch during reselection to efach cell in connecting state
08/14/12   as       Made changes to restore rlc size list for rach
07/20/12   ad       Made changes to do rlc-reestablishment during reselections.
17/07/12   ad       Changes for handling RRCLLC_CHAN_CFG_REASON_RL_FAILURE
                    reason from CU
13/07/12   ad       Changes for handling SIB5 modification
07/24/12   geg      Upmerge WCDMA.MPSS.1.0 to WCDMA.MPSS.2.0
07/11/12   ad       Changes for including the hsdpcch bitmask in 
                    cell_transition_req for a hsrach cell.Made changes 
                    to handle ERNTI correctly. Changes to avoid starting MAC
                    for a HSRACH to HSRACH SIB5 change.Increased the handing rb size.
11/07/12   ad       Made changes to handle ERNTI correctly. Changes to avoid starting MAC
                    for a HSRACH to HSRACH SIB5 change.Increased the handing rb size.
07/03/12   sa       Made the latest HS_RACH changes to to check in on 4.0 branch
07/02/12   sr       Made changes to pick aset always from L1 for CELL_ID_IN_DCH request
06/29/12   ad       Made changes for triggering CU if E-RNTI is not given.
                    Skipped the de-registration of WMs if HS-RACH is ON and RRC is 
                    triggering MR while coming out of PCH. Fixed bug to updated E-RNTI
                    in OC correctly. Added code to trigger CU if R99 or R5 CUCNF is received. 
                    Added code to keep L1 and MAC in sync wrt HS-RACH actions.
18/06/12   ad       Changes for configuring HS-RACH when RLC reset happens
04/06/12   ad       Changes for HS-RACH feature
06/05/12   db       Made changes to ensure hanging databases are in sync
05/31/12   md       Merged MAC_I fixes.
05/24/12   db       Made changes to restore HRNTI and mapping info on fach to dch phy chn failure
19/05/12   md       Made changes to discard the OC while sending channel config confirm failure only if 
                    the OC was set by the procedure which has triggered the current channel config request
05/10/12   md       Added code changes to support FEATURE_MAC_I
05/01/12   md       Fixed the coding bug introduced due to CR-342551 fix
04/25/12   db       Added code to set hs-status in efach to HSDPA_NOOP during EFACH to non-EFACH cell
04/12/12   as       Added code to support feature NB/WB handover support
04/12/12   as       Corrected the featurization for HS-FACH
04/06/12   as       Made changes to restore the legacy cell fach mappings even if
                    HS-PCH is disabled
03/15/12   db       Fixed Compilation Warnings
03/13/12   md       Made changes to trash Channel config req from CU while WCDMA STOP MODE REQ handling is in 
                    progress.
03/12/12   rl       Made changes to fix the FEATURE_WCDMA_NEW_L2_INTERFACE porting issue.
02/17/12   db       Fixed Compiler errors and warnings
12/26/11   ad       Added changes to handle UL RLC size change from DCH to EDCH
12/20/11   mn       Made changes to config NO_OP to MAC when hand over fails with HS
12/20/11   mn       Made changes to clear pending ordered config after SIB config
12/15/11   sks      Made changes to release all channels before triggering inter-RAT redirection.
12/13/11   mn       Made changes to ignore meas failure form L1
12/12/11   ad       Made changes not to add bcch-fach while re-entering in connecting state
12/08/11   db       Made changes to handle EFACH/EPCH support change in SIB5
12/08/11   db       Made changes to stop MAC when cell supports efach and mac is active
12/08/11   db       Made changes to resotre rb mapping after reenter in pch
12/08/11   db       Made changes to not invalidate hrnti status during dch to fach transtion
11/30/11   sa       fixed the compilation error 
11/23/11   mn       Made changes to free meas_ptr when ignoring CPHY_MEAS_REQ at LLC.
11/20/11   db       Added code to include the reconfig_status indicator in a 
                    corner scenario where TOC is reset from TOC_FOR_OOS to TOC_FOR_DCH
11/18/11   mn       Made changes to disable reselection to LTE after attach reject from network
                    with cause 14.
11/16/11   ad       Changed the macro for FEATURE_WCDMA_PAUSE_MTPL_BACKOFF_VOICE_CALL
10/28/11   as       Made changes to restore cc trchid dch info only if num_dchs is greater then zero
09/14/11   ad       Added code for FEATURE CPC DTX HS SCCH REVERT HHO RECOVERY feature
09/09/11   rl       Fixed KW errors
09/08/11   as       Added E-DRX changes for R8
08/30/11   rl       Merged with VU_MODEM_WCDMA_RRC.01.105.00
08/25/11   as       Made changes to add NULL pointer access chceck for reselection ptr
08/29/11   as       Made changes to ignore cell param req and drx req
08/26/11   rl       Fixed the KW error
08/16/11   rl       Merged with VU_MODEM_WCDMA_RRC.01.104.00
08/02/11   as       Made changes to restore HRNTI after DCH to FACH transition
08/02/11   rl       Made changes to initialize DL Sig and UL Sig during cell transition
08/02/11   rl       Merged with VU_MODEM_WCDMA_RRC.01.103.00
07/29/11   ad       Added code for FEATURE_WCDMA_PAUSE_MTPL_BACKOFF_VOICE_CALL feature
07/27/11   kp       Added code to check if config_ptr->pdcp_parms.pdcp_config_req[i].
                    pdcp_cfg_req has proper values if not then we need to fill in 
                    rrcllc_cpdcp_release_all_non_mbms_req which will make sure PDCP gets 
                    proper LC’s in release cmd
07/04/11   rl      Added code to send chan_config_cnf failuer for S-BCCH setup 
                   in case of CID_DCH if SIB event is not active. 
06/21/11   rl       Merged with VU_MODEM_WCDMA_RRC.01.100.50
06/17/11   ad       Fixed bug to update HSDPA action to NOOP if MAC HS is 
                    already stopped in MAC
06/17/11   ad       Fixed bug to update HSDPA status if MDSP halt happens 
06/17/11   su       Added code to swap OC and CC on complettion of chan_config_req
                    when DSIM tuneaway is in progress,in order to avoid CC nbch 
                    hitting max value.
06/07/11   rl       Merged with VU_MODEM_WCDMA_RRC.01.99.50
05/25/11   ad       Fixed bug to send resel fail when cell reselection is triggered while 
                    waiting for L2 ack when FACH to PCH transition is triggered by CU
05/24/11   rl       Merged with VU_MODEM_WCDMA_RRC.01.98.50
05/13/11   kp       Bug fix in re-post cmd to internal in rrcllc_idle_handler
05/10/11   rl       Merged with VU_MODEM_WCDMA_RRC.01.97.50
05/06/11   vg       fixed compilation error.
05/03/11   as       Made changes to display CRNTI and URNTI events
05/03/11   rl       Fixed the lint error
04/26/11   rl       Merged with VU_MODEM_WCDMA_RRC.01.96.50
04/20/11   vg       added support for mdsp halt recovery
04/20/11   as       Made changes to restore rb mapping after reslection to 
                    non-efach cell from efach because of RL fialure
04/20/11   as       Made changes to handle cell update confirm with dhrnti and epch state
04/18/11   as       Added code to support feature EFACH-DRX 
04/12/11   ad       Made changes to deallocate the LC IDs which are being 
                    established when rrcllc_process_config_dcch_dtch returns failure
04/13/11   sk       Fix Memory corruption when Re-Post of cell selection request.
04/07/11   rl       Merged with VU_MODEM_WCDMA_RRC.01.94.52
04/06/11   kp       Made changes to copy CC to OC for Chan_config_req from CU CNF for 
                    HS-FACH to update dH-RNTI.
03/30/11   as       Made changes to update rb mapping info for re-enter in epch cell
03/29/11   rl       Merged with VU_MODEM_WCDMA_RRC.01.94.50
03/28/11   sks      Made changes to trash DRX_REQ in case CTCH setup fails or if
                    suspend_req is to be handled after CTCH setup.
03/23/11   ad       Made changes to start the loop from correct index in 
                    rrcllc_rearrange_pdcp_info function
03/18/11   kp       moved print L1 validable function before put cmd in l1 q
03/18/11   kp       Added code to configure HSDPA in chan_config_discon_to_dch for IHO
03/16/11   as       Made changes to update rlc ul um re-est request properly
03/15/11   as       Made changes to reset hs action after successful cell change for E-FACH
03/28/11   rl       Merged the HS-FACH/PCH changes from mainline
03/14/11   rl       Merged with VU_MODEM_WCDMA_RRC.01.93.50
03/09/11   ssg      MAC-ehs support on Apollo.
03/11/11   ad       Made changes to clear the holes and rearrange the PDCP Info
                    after the RBs are released
03/08/11   ad       Added code changes to set MAC action as STOP when MACHS is active
03/04/11   kp       Added code to set proper mimo & DC-HS action in case of going 
                    back to old config.
02/23/11   kp       Added to swap_oc_and_cc for Chan_config-req with reason for eFACH
03/02/11   rl       Merged with VU_MODEM_WCDMA_RRC.01.92.50
02/23/11   kp       Added changes init hs_pcch_info_valid in CC,TOC at pch2fach trasn
02/18/11   ad       Added changes for one sided UL RLC reestablishment 
02/15/11   kp       Added code to restore eFACH mapping for CU CNF OOS case.
02/14/11   as       Fixed compilation warning
02/15/11   rl       Merged with VU_MODEM_WCDMA_RRC.01.91.50
02/14/11   ad       Made changes to set the L1 MIMO and DC-HSDPA action to START
                    incase of IRAT failure to G  
02/14/11   ad       Made changes for trashing CPHY_DRX_REQ and CPHY_CELL_PARM_REQ
                    in DCH state and CPHY_CELL_PARM_REQ in FACH state                      
02/11/11   ad       Made changes to fix the issue introduced due to e-fach.
                    Copy the TOC into OC and CC when UE comes back to service.  
02/04/11   as       Made changes to skip setting pch if cell supports epch
02/01/11   ad       Made changes to set the correct CPC DTX and DRX action incase
                    of HHO failure at L1
02/07/11   rl       Merged with VU_MODEM_WCDMA_RRC.01.90.50
01/27/11   as       Made changes to delete cctrch id of neighbour cell during
                    cell reselection irrespective of cell is E-Fach enabled or not
01/28/11   rl       Merged with VU_MODEM_WCDMA_RRC.01.89.57
01/18/11   as       Made changes to fix the issue with cphy failure
                    recovery mechanism when eFDPCH is enabled
01/17/11   ad       Made changes in RRC related to L2 SW Decoupling
01/12/11   ad       Added changes for RRC SW decoupling
1/11/11    prk      Added missing changes for new WCDMA-L2 interface.
01/08/11   prk      Fixed merge issue.
01/07/11   prk      Skip checking for SCCPCH in enh-FACH state.
01/06/11   as       Made changes to delete commonn queue info while moving
                    to non EFACH cell or DCH state
01/03/11   prk      Made changes to avoid 2nd HS stop to MAC if cphy channel 
                    establishment failed during e-fach to R99 DCH.
01/04/11   rl       Merged with VU_MODEM_WCDMA_RRC.01.87.50
12/20/10   prk      Removed the code to init hsdpa action during handling of 
                    channel config cnf. And moved the init part to rrcllc_reset_mac_and_l1_for_hsdpa
12/20/10   prk      Made changes to fix issues in OOS handling in Enh PCH state.
12/15/10   kp       Added code to reconfig PCCH in ePCH to legacy resel 
                    & some bug fix.
12/13/10   kp       Added code to reset hs_pcch_info_valid  in all cases except BD.
12/08/10   prk      Restore mappipngs from hanging RB after redirection.
12/10/10   rm       Ignore funneled L1 cmds when waiting for IDLE CNF from L1,
                    if preemtion is in progress
12/08/10   kp       Added code for CCO/I-RAT re sel fail recovery code for EFACH
12/07/10   prk      Made changes to send Cphy setup req to L1 after DCH to 
                    enh-PCH transition.
12/31/10   rl       Merged with VU_MODEM_WCDMA_RRC.01.86.50
12/06/10   prk      Set sccpch_is_up to TRUE in LLC semi permanent data, when
                    SCCPCH is added during Cell reselection.
11/22/10   prk      Reconfigure PCCH on HS during cell reselection in enh-pch state.
11/22/10   prk      Skip checking for SCCPCH present in enh-pch state.
12/17/10   rl       Fixed the compiler error
11/29/10   rl       Merged with VU_MODEM_WCDMA_RRC.01.85.50
11/22/10   sks      Added support for handling EM call during WRLF.
11/19/10   prk      Setup HS channel for Loop back mode in e-fach state.
11/19/10   ssg      Added changes for new WCDMA-L2 interface.
11/09/10   prk      Setup HS channel after re-entering in service in e-pch state.
11/03/10   rl       Fixed compiler warnings
10/30/10   rl       Objective systems migration changes check in 
                    on code base VU_MODEM_WCDMA_RRC.01.80.00
09/13/10   as       Added code to support FEATURE_DUAL_SIM
09/02/10   sk       Fixed compiler warning.
09/01/10   prk      Fixed compiler warnings. 
08/30/10   ss       Added code changes to send RLC re-establishment ciphering configuration of UM user RB's.
08/27/10   kp       Added code to clean up the EUL flags in CURRENT CONFIG PTR in case going 
                    back to old config fail as we use CC to update bit masks for going back to old config. 
08/27/10   kp       Added code to Send a Failure for Cell_PCH/URA_PCH --> Cell_DCH transition.
06/07/10   ss       Added code to get and apply latest start_value_to_transmit that still 
                    has not been udpated to security database.
08/24/10   kp       Added code to set correct MIMO/DC-HS action in case of going back to old config.
07/02/10   sks      Added code to support FEATURE_WRLF_SYSTEM_SEL for connected mode OOS.
06/29/10   rm       Added code to support LTE<->WCDMA Inter RAT
06/29/10   as       Removed feature flag WCDMA_UNIT_TEST for rrc stub code
06/10/10   prk      LLC ignores CPHY_DRX_REQ command from other procedures 
                    if RRC is not in PCH or disconnected state. 
06/09/10   dm       Made changes for swappping the order of sending two Cphy setup reqs if it 
                    results in 2 BTFD CCTrChs being present at L1.
06/08/10   dm       Fixed compiler error when FEATURE UMTS BMC  and 
                    FEATURE_WCDMA_SUSPEND_BMC_DURING_BPLMN are not defined.
06/07/10   rm       Added code to notify CSP after processing CTCH drop request from CSP
06/07/10   ss       Added code to reset SVTHHO in case of failure message
05/24/10   kp       Added code for feature CPC-DRX under feature flag FEATURE_WCDMA_CPC_DRX
05/20/10   gkg      Made changes to log RRC state in SMEM area.
05/21/10   kp       Added code to indicate DTX START action to L1 during 
                    IRAT Cell Change Order Failure recovery on the old cell
                    where DTX was active.
05/13/10   ss       Fixed compiler warnings.
05/07/10   prk      Fixed compiler warnings.
05/03/10   dm       Made changes for trashing Meas req command when Phy channel setup fails 
                    after W2G CCO failure and UE resumes in W.
04/30/10   sks      Made changes to not send CPHY_CELL_BAR_REQ, incase resume fails with
                    cause WL1_FAILED_NO_WRM_LOCK.
04/23/10   dm       Made changes for trashing Cell Parm Req when received during FACH to 
                    DCH transition.
03/21/10   dm       Made changes for trashing DRX req in FACH/Connecting when posted 
                    due to SIB5 change in PCH/Disconnected state.
03/12/10   rm      Added code to support FEATURE_DUAL_SIM
02/22/10   ss       Modified debug prints for Cipher Algo
02/10/10   as      Added feature falg WCDMA_UNIT_TEST for rrc stub code
02/08/10   rmsd     Fixed Lint Indentation error.
02/08/10   dm       Made changes to not clear config db if it is NULL.
03/02/10   dm       Made changes to abort N-BCCH setup if reselection info for the cell is 
                    cleared.
12/10/09   gkg      Made changes so that PDCP Config is reset in LLC if Channel Config
                    Request fails and LLC takes back to Old Config.
02/01/10   ss       Added handling of RRC_LLC_RE_EST_RLC_REQ in rrcllc_wait_cphy_setup_cnf_handler
01/22/10   gkg      Made changes to reset MAC action to NOOP after CMAC_DL_CONFIG_REQ is sent to
                    MAC if it's part of LLC_RELEASE_TR_PHY_CHAN_ENGINE.
01/22/10   rm       Modified the usage of qchatupk_wcdma.h with rrc_qchatupk.h
                    (at the request of QCHAT team)
01/22/10   ss       Added code to take backup of MAX HFN for CS RB's before HHO Step-1 
                    and later use that backup to calculate START_VALUE_TO_TRANSMIT for CS domain.
12/21/09   gkg      Made changes for CSoHSPA under feature FEATURE_CS_VOICE_OVER_HSPA.
12/07/09   ss       Changes to add Stub code under feature flag TEST_FRAMEWORK
11/27/09   gkg      RRC changes required to integrate QChat Porting Kit Optimizations 
                    into AMSS. The changes are under feature FEATURE_QCHAT.
11/26/09   dm       Added function to check whether S-BCCH is up.
11/16/09   gkg      Made changes to set the MIMO and/or DC-HSDPA action as START if CCO
                    fails and MIMO and/or DC-HSDPA was up before CCO.
11/16/09   dm       Changes for ignoring S-BCCH drop if not setup when the same Chan config
                    req also sets up N-BCCH.
11/04/09   sks      Added code to support inter-RAT redirection via connection reject
                    and both inter-RAT and inter-freq redirection via connection release.
10/30/09   dm       Changes for handling CCCH Reconfig and PCCH Reconfig posted during
                    FACH->PCH and PCH->FACH transitions respectively.
10/30/09   dm       Fixed compilation errors associated with not defining FEATURE HSDPA.
10/05/09   gkg      When both MBMS and PDCP features are enabled and RRC Conn is taking down
                    beacuse of error scenarios (e.g. RLF/RLC unrecoverable errors etc), send
                    command to release PDCP entities. 
10/05/09   ps       Fixed Klockwork warnings
10/12/09   kp       If N/W is providing AGCH info for non EUL serving RL then don’t 
                    indicate add/reconfig action to L1, since AGCH makes sense 
                    only for serving RL.
10/07/09   gkg/kp   Changes for REL8 under FEATURE_WCDMA_REL8 and CPC -DTX
10/08/09   gkg      Made changes so that HSDPA vars INACTIVE_TO_ACTIVE and 
                    ACTIVE_TO_INACTIVE are reset while going back to old config
                    due to CPHY_SETUP_CNF failure and HSDPA isn't active.
09/24/09   ps       Made changes to update HS status after MAC is configured 
                    with HS action even in case of HHO failure. 
                    So that RRC and MAC are in sync
09/11/09   ps       Made changes for reducing the internal RRC command size 
                    under FEATURE_RRC_REDUCE_CMD_SIZE
08/21/09   dm       Fixed lint warning.
08/17/09   dm       Made changes to not tear down S-BCCH after reading SIB7 
                    when going from PCH to FACH, if FEATURE_UPDATE_SIB7_IN_fACH 
                    is on.
08/11/09   dm       Made changes to send resel cnf failure if Cel Reselec Req is received
                    while waiting for L2 ack during FACH to PCH transition.
08/07/09   dm       Made changes to trash meas req command and handle chan config req 
                    command when LLC fails to go back to old config in DCH state.
07/20/09   rm       Modified the call to funtion rrcrce_force_initialize
07/17/09   dm       Made changes to queue commands from CSP while LLC is 
                    waiting for WCDMA stop mode cnf.
07/01/09   dm       Fixed lint issue.
06/23/09   ps       Made changes to ignore L2 ack for CRLC REL all req
06/18/09   av       Fix compilation error due to not defining rrc_state 
06/18/09   dm       Made changes to not send CTCH add/drop for BPLMN, if RRC State is not PCH 
                    or Disconnected.
06/04/09   gkg      Fixed KW error for 'Array Out of Bound'.
06/03/09   rm       Deleted fucntion rrcllc_get_substate, Added code to call 
                    rrc_csp_cell_trans_cnf_rcvd_at_llc on reception of Cell transition cnf
                    from L1 for funneled transition req to L1
05/29/09   kp      Added support for new SNOW3g security Algo & single cipher algo usage across 
                   access stratum layers.
05/22/09   ps       Made changes to suspend BMC if BPLMN is ongoing
05/22/09   ps       Suppressing lint warning when BMCfeature is not defined
05/18/09   ps       Made changes to enqueue the Resel cmd to internal Q 
                    instead of LLC cmd Q if no cmd is already present in LLC cmd 
                    Q, so that LLC doesnt get stuck in a never ending loop
05/14/09  sks       Made changes to suppress compilation errors for RRC UTF.
05/14/09  kp        Added support to not drop S-BCCH during FACH to PCH transition only if 
                    event active is UPDATE_SIB’s in all other cases if S-BCCH is up during 
                    the transition then Drop. 
05/11/09  kp        Fixed Lint issue.
05/11/09  ps        Feature to dynamically allocate OC, CC and TOC ptr 
05/11/09   rm       Added rrcllc_get_substate to return LLC substate
05/08/09   ps       Made changes to not call force sib init when CPHY-Est ind
                    for rrc connection setup fails
05/10/09   kp       Added support for demand paging RRC code using pragma.
05/08/09   ss       Updated Copyright Information
04/29/09   ss       Made changes to compiler warnings on gcc compilers.
04/22/09   ps       Made changes to send a request to RLC to release all RBS
                    when RESUME CNF fails in DISCONNECTED state
04/14/09   ps       Made changes to init the CTCH enabled flag in L1 DB while
                    going out of PCH/IDLE state.
04/06/09   gkg      For PDCP, made the changes so that PDCP parameters can be 
                    changed through Reconfig OTA when FEATURE MULTIPLE RLC OPERATIONS 
                    is enabled.
03/24/09   ps       Made changes that once OTA provides RLC size, then it
                    can be changed only through OTA, only in case of R3 OTA
                    RLC size will be calculated from the TF of the Trch
03/16/09   kp       Added code to handle RRC_CIPHER_CONFIG_REQ in new cell handler 
                    code which will send a dummy RRC_CIPHER_CONFIG_CNF to smc for 
                    resuming suspended RLC LC's.
03/09/09   ps       Cleanup of the feature flags
                    FEATURE TFC RLC SIZE
                    FEATURE_DCH_FACH_STATE_TRANSITIONS
                    FEATURE_DCH_IE_IN_CELL_FACH
                    FEATURE_TFCSUBSET
                    FEATURE_ADJUST_TB_SIZE_WHEN_TRCH_INFO_NOT_PRESENT
03/06/09   gkg      Corrected compilation issue (if HSUPA isn't defined) in function.
                    rrcllc_send_rrc_channel_config_cnf()
03/06/09   gkg      Made changes for resetting MAC-HS action in Config DB when 
                    LLC sends Channel Config Confirm to procedures. Also reset hs_
                    req_mask for L1.
01/30/09   ps       Added a MSG_HIGH to print the HSDPA bitmask sent to L1
01/22/09   ps       Removing NULL pointer access code when action is HSDPA_NOOP
                    Also reverted the changes to process MAC HS action if transition
                    type is invalid
01/19/09   ps       Made changes to process MAC_EHS actions even if Transition type
                    is invalid
01/13/09   rm       Added code to process funneled SUSPEND L1 req as first useful cmd
                    in rrcllc_trash_cmds_till_first_useful
12/18/08   ps       Made changes to send an add and drop for DPCH , if the tau DPCH
                    changes by 1 under FEATURE_WCDMA_REL7_HACK_CHG_TAU_DPCH
12/08/08   ps       Made changes to call mvssup_set_voc_timing() for Inter-Freq
                    HHO/Timing Initialised HHO and Forced SYNCA
12/05/08   ps       Made changes to not reset the HSDPA action if the Chan Config
                    is initiated by CSP.
12/05/08   ps       Made changes to send a Channel Config CNf failure to CCO/IHO
                    if Chan config sent by these procedures fail after resume
11/21/08   ps       Made changes to restore the CRNTI if the cell reselction 
                    fails.
11/21/08   gkg      Merged the changes that are needed for disabling HS on LCU build.
11/20/08   ps       Added check to act on Chan_config_req in Standby mode, 
                    only if L1 is not already in Suspend state   
11/10/08   ps       Made changes to set bitmask for MIMO for FACH->HS transition 
                    if MIMO is active
11/10/08   ps       Made to call rrcllc_init_cmd_under_process_data before 
                    processing Chan config req an Reset L1 Req in Standby mode 
11/04/08   rm       Added support for rove-in to GAN in RRC Connected mode.
                    Code changes are under FEATURE_GAN_3G_ROVE_IN_CONNECTED_STATE.
10/10/08   gkg      Added code for updating UM RBs in OC first and then making them 
                    available to LLC to configure RLC while doing Channel Config Req. 
                    Also added code for Alt E Bit that is used for UM RBs.
10/22/08   ps       Made changes to restore the URNTI value to OC from TOC
                    for FACH->FACH Freq redirection
10/20/08   ps       Made changes to init the SRb5 info in TOC for SRB5 release
                    during DCH->FACH
10/13/08   ps       Made changes to proceed with trash command in LLC queue 
                    after processing MAC commands in 
                    rrcllc_trash_cmds_till_first_useful()
10/10/08   ps       Fixed compiler warnings when HSUPA is not defined
09/23/08   ps       Made changes to always send the EUl pointer to L1, if EUL
                    is active. Even if the action is NOOP
09/19/08   ps       Corrected merge issue due to R7 code to send the correct MAC 
                    Action for HSDPA on going back to old config
09/12/08   ps       Added code for REl7 under FEATURE_WCDMA_REL7
09/15/08   ns       Made changes to calculate the activation time using the CFN of the
                    new cell, and thereby ensure that the activation time sent is at least 200
                    frames ahead of CFN. 
08/22/08   ps       Made changes to convert some of the ERR msges to MSG_ERROR
08/29/08   kp       Add support for indicating TSN revert while going back to old config if  
                    mac_e_reset_ind was set in previous cphy.
08/01/08   rm       Made changes to process L1 reset request, Release transport and physical channels
                    when RRC mode is Standby
07/21/08   rm       Made changes to process S-BCH/N-BCH drop requests when RRC mode
                    is standby
07/14/08   gkg      Made changes so that MAC DL is directed to restore TSNs by setting
                    mac_hs_restore_tsns as TRUE in case of failure recovery from HS->DCH
                    trasition. It should be noted that in case of failure recovery, now 
                    restoring of TSNs is done irrespective of the presence of MAC HS RESET 
                    Indicator in Reconfig OTA.
06/30/08   ps       Made changes to call rrc_initialize_rlc_size_per_rb() even
                    if FEATURE HSDPA is not defined.
06/24/08   gkg      Made Changes for the case when the RLC entity of a RB (mapped to HSDPA in DL) 
                    is reconfigured but RB level IEs are not given in OTA, there is no need to  
                    change RLC size in DL.
06/23/08   ps       Made changes to not send CMAC_DL_CONFIG_REQ to MAC, incase
                    of SUSPEND for Inter-rat scenarios
06/16/08   ps       Corrected featurisation issues for FEATURE HSDPA
06/13/08   gkg      Made changes so that if RLC PDU size changes for RBs through
                    Transport Channel IEs of in OTA messages, those RBs are reconfigured
                    and therefore their RLC entity is notified for new RLC PDU size.
05/27/08   ps       Made changes to indicate mac_hs_reset_indicator to MAC 
                    only if the OTA msg indicates a MAC HS RESET
06/04/08   ns       Made changes to take care of unnecessary re-establishment of 
                    UM RBs during second SRNS relocation
05/26/08   ps       Made changes to incate to PDCP, if an RB for a
                    Unicast Call or a Multi-Cast Call                    
05/07/08   ps       Made changes to not release CCRTCH id internally for CPHY_SETUP 
                    validation failure, for ASU
                    Also changes have been made to update it DB for releasing CCTRCH 
                    ID for SCCPCH 1 incase CTCH and PCH are not configured on same SCCPCH 
05/02/08   da       Added change to inform lower layers if loopback is in progress
                    during reconfigurations.
04/30/08   rm       Fixed compilation errors when FEATURE UMTS BMC is not defined and 
                    FEATURE_UPDATE_SIB7_IN_FACH  is defined
04/25/08   ps       Made changes to pass num_trch and num_tfci as 0 to L1
                    when num_dpdch in UL is 0
04/23/08   ps       Added error print when the num of AM chan is zero in CC, 
                    while coping to TOC
04/18/08   gkg      Fixed Klockwork errors.
04/10/08   rm       Made changes to bypass channel config request for S-BCCH drop from CSP if
                    S-BCCH is not up in Disconnected and PCH states
04/01/08   da       Fixed compilation issue.
03/19/08   rm       Added function rrcllc_check_if_chan_config_in_progress_for_sib5_change
                    that checks if lower layers are being configured for SIB5 Change
03/14/08   ps       Made changes to check pccpch_is_up in rrcllc_semi_permanent_data
                    to release S-BCCH for FCH->PCH transition.Also added code change 
                    to release S-BCCH in case of current event is SIB7 or no sib event.
10/03/08   gkg      Made changes so that RRC correctly calculates number of UL 
                    TM channels in FACH->FACH redirection.
03/06/08   da       Added MBMS phase 2C changes.  MBMS support in CELL_DCH.  
                    Includes mobility and dynamic resource management.
03/06/08   da       Changed FEATURE_MBMS to FEATURE_MODEM_MBMS
03/03/08   vk       While sending CMAC_DL_CONFIG_REQ, set restore MAC-hs TSN
                    variable to TRUE only if the internal HSDPA structrure has
                    the same variable set to TRUE. While going back to old configuration,
                    set the MAC-hs restore TSN variable in hsdpa_msg_params for
                    various scenarios for physical channel setup as well as
                    physical channel establishment case. Changes have been featurized
                    under FEATURE HSDPA MAC HS DL RESTORE TSN
02/29/08   ps       Made modifications to enqueue RRC_CONN_MODE_DEEP_SLEEP_WAKEUP_REQ
                    in LLC queue, if received when LLC is in LLC_WAIT_RLC_TM_DL_CNF,
                    LLC_WAIT_CPHY_SETUP_CNF or LLC_WAIT_CPHY_IDLE_CNF state
02/18/07   ps       Made modification to update CC also from TOC, when 
                    UE recoveres from OOS during DCH->FACH.
02/14/08   da       Made change to populate current cell scrambling code on PCCPCH setup as new 
                    DL code relies on this info from rrc.
02/08/08   rm       Made changes to discard the mesurement requests to L1 rather than queueing in
                    LLC queue when LLC config engine is Release all engine
02/06/08   rm       Made changes to not bring up S-BCCH if N-BCCH is up when transitioning
                    from connecting to FACH state as well as from PCH to FACH
01/28/08   vr       Changed feature definition of Inter SIB Sleep from FEATURE_INTER_SIB_SLEEP
                    to (defined(FEATURE_INTER_SIB_SLEEP) || defined(FEATURE_WCDMA_DRX_MANAGER))
                    since the new DL code in L1 uses FEATURE_WCDMA_DRX_MANAGER instead of
                    FEATURE_INTER_SIB_SLEEP
01/22/08   ps       Made modification to init the MAC & l1 variables in OC
                    only after receiving IDLE_CNF
01/18/07   ps       Made modification to update RLC LC ID for RACH in DCH State,
                    when no DCH is present for that RB.
12/21/07   da       Support for FEATURE_MBMS
12/05/07   rm       Made changes to set new_tfcs_list_present in ordered config when 
                    physical channel fails in DCH and going back to old config
11/28/07   rm       Added support for handling multiple RLC operations on a
                    single RB under FEATURE MULTIPLE RLC OPERATIONS
11/14/07   rm       Made changes to Set/Reset new_tfcs_list_present when configuring
                    UL MAC
11/12/07   rm       LLC will not call rrcsib_force_sib_event_init when physical
                    channel setup fails in case of moving from connecting to DCH
                    as it is taken care by CSP
11/08/07   vm       Added fix to handle wakeup req when LLC is in wait stop cnf substate
11/07/07   vk       In fn rrcllc_chan_config_connecting_to_dch(), added code
                    to start HSDPA. In fn rrcllc_chan_config_fach_to_dch(),
                    add check if DL RLC Channel Id exists for signalling channels. 
                    Changes have been featurized under FEATURE_WCDMA_FDPCH
11/02/07   rm       Calling the srchmeas_set_inter_freq_measdb_status_during_state_transition
                    for clearing the inter frequency measurements if CSP current scan is not 
                    leaving connected mode scan and current channel config engine is 
                    Release all channels engine
10/30/07   rm       Made changes to clean CTCH LCM variables when a physical channel setup
                    for CTCH fails
10/08/07   da       Featurized code that disallows UL TFCS based on WL1 max limitations.
                    This is now going to be done at WL1\MAC under feature flag
                    FEATURE LIMIT TFCS TO ERAM SIZE. 
10/03/07   ps       Added support for filling in the tx diversity indicator from SIB5/6 
                    while updating S-PCCPCH parameters during state transitions.
09/21/07   da       Added change to queue cmd RRC_CONN_MODE_DEEP_SLEEP_REQ
                    in LLC_WAIT_CPHY_SETUP_CNF, LLC_WAIT_RLC_TM_DL_CNF and
                    LLC_WAIT_CPHY_IDLE_CNF substates.
09/18/07   rm       Initialized the CM info while leaving the coneected mode
                    and when the procedure is initialized
09/14/07   rm       Initilized the MAC HS operation to NOOP when Setting/Tearing 
                    S-BCCH in DCH for FEATURE_WCDMA_GPS_CELL_ID_READING
09/13/07   vk       In fn rrcllc_check_if_hsdpa_can_be_started_reconfigured(),allow
                    HSDPA Setup/Reconfiguration to proceed if SRBs are mapped on
										HS-DSCH for F-DPCH channel only under FEATURE_WCDMA_FDPCH
09/10/07   da       Removed Proc ASU from rrcllc_phy_chan_failure_handling_restrictions 
                    as WL1 will be able to handle this failure. 
09/10/07   rm       Added support for Frequency redirection received in 
                    FACH->FACH and FACH->PCH cases under feature flag
                    FEATURE_RRC_FREQ_REDIRECTION_THRU_RB_AND_CU
08/31/07   ps       rrcgps.h file is removed and code is move to rrcmeasi.h. So 
                    adding rrcmeasi.h in header instead of rrcgps.h
08/31/07   rm       Calling the srchmeas_set_inter_freq_measdb_status_during_state_transition
                    for clearing the inter frequency and intra frequency measurements 
                    on transition to Idle
08/28/07   kp       Added support for capturing RACH transmission Statistic.
08/27/07   da       Added CHO to list of procedures check before setting and cleaning
                    up EUL masks.
08/15/07   vk       In fn rrcllc_cphy_setup_req(), indicate L1 to send sync to MAC
                    when ASU Repointing with MAC-hs reset is involved. In fn 
                    rrcllc_cmac_dl_config_req(), indicate MAC to wait for L1 sync
                    if it is ASU Repointing with MAC-hs Reset. Changes have been
										featurized under FEATURE_HSDPA_ASU_REPOINTING
08/08/07   rm       Added support for feature cell id reading in DCH state, 
                    under feature flag FEATURE_WCDMA_GPS_CELL_ID_READING.
08/06/07   da       Added IHO to list of procedures check before setting and cleaning
                    up EUL masks.
08/06/07   da       Made changes to copy EUL actions from OC to cmd under process
                    only when procedure is capable of EUL action, and OC EUL action
                    is not no-op.  
07/27/07   da       Put code changes for HSPA call status ind under feature 
                    flag FEATURE_HSPA_CALL_STATUS_IND
07/24/07   pk       If BPLMN search is in progress, get PCCPCH channel parameters from
                    CSP into Ordered Config.  
07/20/07   sm       Made changes to set e_req_mask in l1_cmd ir-respective of whether its
                    NOOP or not from EUL config point of view
07/16/07   rm       Made Changes to SETUP or DROP CTCH (Based on SIB contents for CTCH)
                    when PCCH is reconfigured in Cell PCH/URA PCH State.
07/13/07   da       Added support for HSPA call status indication.
07/09/07   da       Added defensive checks to make sure config_ptr->mac_dl_parms.num_bchs
                    does not exceed 1.
07/05/07   da       Change to notify RLC UL TM when loopback mode 2 is configured.
                    Changes are under flag FEATURE_TM_LB
06/25/07   da       Sending chan_config_cnf back with failure back to procedure 
                    before initiating cell selection to idle due to unhandled 
                    cphy_setup_cnf failures.
06/11/07   vm       Fixed compilation error
06/08/07   da       Made change under FEATURE_RRC_ERROR_DETECT to ERROR FATAL if 
                    CPHY_ERROR_IND is rcvd from WL1.
06/04/07   kp       Added a function which will return status of N-BCCH setup.
                    It looks at semi permanent data & LCM status.          
05/22/07   rm       Added Fix for preventing URNTI Invalidation in OOS Scenarios
                    in OC
05/21/07   ps       Made changes to send a FAILURE to ASu, when 
                    CHANNEL_CONFIG_REQ is received for ASU in Standby State.
05/17/07   rm       Added Support for handling the DEACT REQ in LLC_WAIT_CPHY_RESUME_WCDMA_MODE_CNF and we
                    receive Resume Wcdma Mode Cnf Success
05/16/07   rm       Added support to handle cleaning up of LCM parameters during CPHY_SETUP
                    and Transition failures
05/14/07   vm       Fixed compilation error.
05/10/07   da       Bug fix for clearing EUL bitmasks on sending channel_config_cnf
                    back to procedures.  The bitmasks should be reset only when procedures
                    that can start, reconfig or stop EUL requested for the channel 
                    configuration.  
05/10/07   da       Made change to handled reconfiguration of CCCH in 
                    chan_config_within_connecting as it can happen due to SIB5 change.
                    Also fixed bug when handling CPHY_SETUP_CNF failure during PCH->FACH.
04/19/07   ps       Made modifications to use a array of static blocks for the
                    allocation of internal commands
04/03/07   da       Fix for SYNC-A + EUL.  RRC needs to drop and add EUL channels
                    as well as set the e-dl masks to ADD.
03/23/07   da       Added more checks before sending fake cphy_setup_req for 
                    DCH->FACH transition.
03/16/07   da       Added change to handle race condition between FACH->DCH transition
                    and W-G resumption.  This is addressing CR 97613.
03/06/07   ps       Made correction to recalcualte DL RLC size for RLC_MODIFY
                    case only when no valid DL RLC size is already present
03/05/07   da       Checking pccpch_is_up flag in semi permanent date before
                    doing a drop of BCCH.  Only do a drop if this flag is set
                    to true.  If set to false, it means pccpch is not up so no
                    need for drop.
03/04/07   vm       Added support for FEATURE_UMTS_UNIFORM_OOS_HANDLING_P2.
03/02/07   ps       Made changes for handling reconfig of SRB5 in channel req.
02/28/07   sgk      Added FDPCH support under FEATURE_WCDMA_FDPCH. 
02/26/07   rm       Added the support to ignore the channel config request
                    sent by SIB, if PCCPCH is already up in Within FACH State.
                    And just sending SUCCESS to SIB. Changes are made under the 
                    feature flag FEATURE_UPDATE_SIB7_IN_FACH.
02/09/07   kp       Removed extra hop of command interface between SMC & LLC, 
                    for resuming uplink RB’s & updating uplink ciphering keys. 
                    Now SMC directly places these request to L2 task & L1 respectively 
                    bypassing LLC.
02/09/07   ps       Made changes to re-initializes Re-establish entity either
                    only in OC, or in CC only or both 
02/07/07   da       Corrected check in cphy_Setup_cnf failure cases to continue
                    with IDLE req if proc is CSP and engine is PHY and TrCH release 
                    engine.
02/07/07   ps       Made changes to handle Standalone Rb-Mappings
02/02/07   da       Added change to send "fake" cphy_setup_req before sending
                    cphy_idle_req, during DCH->FACH transition,
                    if the reconfig message contains some activation time.
01/29/07   rm       Moved the commnon code to a fn for sib7 cell fach
01/19/07   rm       Added support for SIB7 update in Cell FACH state.
                    The code is under feature flag FEATURE_UPDATE_SIB7_IN_FACH.
                    S-BCCH will be kept open for the duration UE stays in cell FACH state.
01/04/07   kp       Added support for updating UL Ciphering keys to L1. 
12/28/06   sm       Set mac_e_reset_ind and tsn action appropriately whenever EUL is stopped
12/11/06   da       Put BMC specific code under FEATURE UMTS BMC
12/11/06   ps       To allocate 10 blocks of internal cmd buffer statically and
                    if not not available there, then only go the the heap.Changes have been made 
                    under the feature flag FEATURE_RRC_STATIC_BUFFER_ALLOC
11/28/06   sgk      Set the mdsp image default to WCDMA GSM in the start mode req. 
11/28/06   da       Changed cfg_req to pdcp_cfg_req due to name change of struct
                    used for sending commands to PDCP
11/23/06   kp       SMC suspend request & confirmation will be through call back function 
                    with RLC, Cleaning up code for command interface.
11/20/06   da       Don't save into TOC in func rrcllc_chan_config_for_oos_within_fach()
                    and rrcllc_chan_config_for_oos_within_pch() when toc_usage is
                    set for TOC_FOR_OOS since TOC is already updated with right info.
11/15/06   sm       Added EUL HHO and reverting back to old config support
10/18/06   sgk      Fixed lint errors. 
10/16/06   vk       Implemented function rrcllc_init_reestablish_entity() 
                    under FEATURE RLC ONE SIDE RE ESTABLISHMENT
10/16/06   vk       Do not reinitialize the HS Action if the RRC_CPHY_SETUP_CNF
                    received from L1 is because of the CPHY_SETUP_REQ
                    request initiated by the SIB procedure
10/13/06   sgk      Added 7600 support under feature
                    FEATURE_UMTS_1X_HANDOVER_UMTSMSM
10/05/06   da       Made change to send PDCP config req when rate change happens.  This is
                    so that PDCP can fine tune the WM levels.
09/27/06   sgk      Fixed 7200 compiler warnings
09/12/06   vk       Deleted few lines of unwanted code under FEATURE RLC ONE SIDE RE ESTABLISHMENT
09/12/06   da       Fix for lint warnings
09/11/06   da       Taking UE to idle through CSP instead of 
                    rrcllc_self_enqueue_channel_config_to_idle() to avoid CSP stuck scenario.
09/11/06   vk       Added code to process RLC Size Change under FEATURE RLC ONE SIDE RE ESTABLISHMENT
08/29/06   sm/da    Made changes required for R6 ASN.1 migration.  Also merged
                    FEATURE_WCDMA_REL6 and FEATURE WCDMA HSUPA.
08/29/06   tkk      Added code to process deactivate request in standby state.
08/28/06   da       Added support for OOS area handling during transition from DCH.
08/25/06   da       Added change to handle cmds RRC_CONN_MODE_DEEP_SLEEP_REQ and 
                    RRC_CONN_MODE_DEEP_SLEEP_WAKEUP_REQ under 
                    FEATURE_DEEP_SLEEP_REL6_OUT_OF_SERVICE_ENHANCEMENT
08/25/06   da       Added change for going back to old configuration.  Now calling functions
                    dl_phychan_cctrch_id_in_use() and ul_phychan_is_ul_dpch_active() to
                    determine DL and UL DPCH actions when going back to old config.
08/22/06   sgk      Modifed the function rrcmeas_save_intra_freq_meas to 
                    rrcmeas_save_intra_inter_freq_meas. 
08/22/06   tkk      Added code to hit error fatal during L1 recovery when
                    BPLMN is active.
08/21/06   tkk      Added SRB#5 support.
07/07/06   sgk      Fixed lint errors.
06/05/06   sgk      Made changes to include rel5 non HSDPA functionality under 
                    FEATURE REL5 while retaining the HSDPA specifc processing 
                    under FEATURE HSDPA.
05/18/06    da      Added change to set RLC size when it is specified in R5 msg going 
                    into CELL_PCH/URA_PCH state.
05/16/06    da      Made change not to swap OC and CC back to back when UE transition
                    to PCH due to CUCNF and OC was set.  Check was needed in 
                    rrcllc_wait_state_chg_ind_handler so that the second swap doesn't 
                    take place.
                    Also removed the GCF NV dependency of HHO failure handling.
05/11/06    da      Fix for sending RNTI_UPDATE_CNF in rrcllc_wait_rlc_am_cnf_handler()
                    Should check if next_substate != LLC_WAIT_CPHY_SETUP_CNF rather
                    than next_substate == LLC_IDLE before sending RNTI_UPDATE_CNF.
05/01/06    vk      In rrcllc_check_if_hsdpa_can_be_started_reconfigured(), checked
                    in the updated beta table structure of delta ack/nack/cqi is
                    within the correct range. Set beta table bit mask in hs_dpcch_info
                    structure before starting HSDPA. Changes have been featurized
                    under FEATURE_HSDPA_PERFORMANCE_OPTIMIZATION
04/28/06    da      fix for issue where HS was not being set in call_type_mask when 
                    num_l1_req is 1.
04/25/06    da      Added change to do SCCPCH selection when URNTI changes and 
                    SCCPCH selection is required.
04/11/06    vk      In rrcllc_wait_cphy_channel_ind_handler(), forcibly set HSDPA
                    status to active when command under process indicates that
                    HSDPA was being activated
04/05/06    da      Made change to check for cmd dest and cmd id instead of just cmd id
                    when processing RRC_LLC_CMD_REQ in cphy_setup_cnf_handler.
                    This is because cmd_id is not always set.
03/31/06    tkk     Moved cnt variable under HSDPA in function 
                    "rrcllc_set_call_type_mask" to suppress compilation warning
03/29/06    vk      When LLC command Engine is set to RELEASE ALL or Release
                    all transport and physical channels, make sure that 
                    HRNTI as well as HS PSC is invalidated from RRC
                    Database when HSDPA Status is SUSPEND/ACTIVE
03/24/06    tkk     Fix for returning failure back to SIB procedure for 
                    channel drop if OC is not-set in within DCH handling.
03/18/06    da      Put hs related code under FEATURE HSDPA in function
                    rrcllc_set_call_type_mask
03/17/06    da      Added func rrcllc_set_call_type_mask() that sets bitmask 
                    to indicate L1 what kind of call [voice, data, HS] are 
                    active.
03/15/06    tkk     Lint warnings/errors cleanup
03/10/06    da      Added Initial support for PDCP under FEATURE_UMTS_PDCP
03/10/06    sm      Added smc function call to revert to old FRESH(in case of SRNS
                    relocation scenario) when UE has to revert back to old configuration
                    due to physical-Ch-Est-Failure.
02/28/06  da/sm     Modified code to support migration to Dec-05 Rel-6 ASN1
02/15/06    sgk     Added code to process CPHY_ACT_CANC request and CNF, moved 
02/07/06    sgk     Set tx diversity indicator to default FALSE value for neighbour
                    cells as the informaion is picked up from the measurement info
                    by L1 directly. Removed functions rrcllc_get_neighbor_pccpch_tx_diversity,
                    rrcllc_get_neighbor_pccpch_tx_diversity_in_discon, 
                    rrcllc_get_neighbor_pccpch_tx_diversity_from_measurement_control_sys_info.
02/07/06    vr      Changed feature name from FEATURE_SIB_SLEEP_OPTIMIZATION 
                    to FEATURE_INTER_SIB_SLEEP
01/25/06    bd      Lint clean-up
12/23/05    vk      When LLC command engine is set to RELEASE_ALL, and HSDPA Action is set
                    to SUSPEND, then set HSDPA global status to Inactive after taking L1
                    to Idle Mode
12/21/05    vr      Support for FEATURE_SIB_SLEEP_OPTIMIZATION
12/18/05    da      Made change to take UE to IDLE when CPHY_SETUP_CNF fails due to ASU.
                    Made change to ERR_FATAL when UE is transitioning from DCH to 
                    FACH and no AM chls are found [going to idle under error recovery
                    feature].
11/18/05    da      Added new function rrcllc_dequeue_cmd().  This function is used
                    to dequeue cmds from LLC internal Q.
11/11/05    vk      Corrected merge problem.
11/10/05    da      Removed extern definition of nv_rel_ind;
11/10/05    da      Checking global flag rrc_nv_rel_indicator before doing R5 related
                    processing.
11/03/05    vk      Added code to process Physical Channel Setup Failure for HSDPA
                    under FEATURE HSDPA
11/08/05    vm      Added support for WTOW Background PLMN Search. Added support for
                    sending CPHY_GO_TO_SLEEP_IND to L1.
10/27/05    da      Made change to enable tx div on PCCPCH based on SIB 5, SIB 6 or if 
                    Tx diversity is applied on any of the downlink physical channels.
                    This is as per 25.211 sec 5.3.1 and 25.331 section 8.1.1 
10/11/05    bu      If CPHY_RESUME_WCDMA_MODE_CNF (failure) is received from L1, while
                    dequeuing the internal LLC commands, if CPHY_CELL_BAR_REQ was in the
                    internal queue, now sending it to L1 instead of trashing it.
10/10/05    vk      If Data Call Setup was done in CELL_FACH and HS-DSCH rb mapping
                    information was provided, and then HSDPA was activated
                    then set the RLC Logical Channel Identity based on Radio Bearer
                    Identity in MAC HSDPA structure
10/07/05    vm      Setting new RRC/L1 interface variable cell_type in transition request
                    with the correct value.
10/05/05    da      Added check to see if OC is set for DCH by ASU before swapping
                    OC and CC for w-resumption case.
10/05/05    da      Added change to swap OC and CC after sending CHAN_CONFIG_CNF
                    to IHO and CHO for G-failure and W-resumtion case.  Changed
                    some F3 msgs.
10/04/05    da      If CNF cmd from L1 is rcvd after deadlock timer expiry and before
                    err fatal timer expiry, LLC should continue ahead and process the cmd
                    from L1.  Added change to stop RRCTMR_DELAY_ERR_FATAL_TIMER in case 
                    CNF cmd from L1 is received after this timer is started.
10/03/05    vm      Added support in LLC for checking CCM substate before waiting in  
                    LLC substate LLC_WAIT_NEW_CELL_IND during reselections.
09/28/05    ss      calling of rrcsmc_process_cipher_config is moved to 
                    procedures
09/27/05    da      In case of cphy setup cnf failure for PCCPCH and N-PCCPCH,
                    only de-allocate LC_ID for BCCH and N-BCCH if the RLC
                    action was RLC_ESTABLISH.
09/08/05    vk      Added support for uni-directional Radio Bearer for HSDPA UM Mode
                    when loop back is in progress
09/01/05    vk      While calculating the RLC size for CCCH (UM Mode), set the 
                    value of Length Indicator based on the existing RLC Size
                    calculated so that RLC could use the LI indicator. Also set MAC HS
                    Action to NOOP when CMAC_DL_CONFIG_REQ is sent to MAC for ciperhing
                    changes
08/10/05    da      Fixed compiler error.
08/10/05    vk      Added more checks before starting/reconfiguring HSDPA
08/09/05    da      Made fixes related to W-G re-selection failure handling in Disconnected 
                    CELL_PCH and URA_PCH states
08/04/05    da      Setting llc_next_substate to LLC_WAIT_CPHY_DRX_CNF after sending DRX_REQ
                    in func rrcllc_handle_commands_on_new_cell_ind().
07/29/05    vk      Removed a check for HSDPA Bit mask L1 HSDPA Action is Reconfig
07/20/05    vk      If S-PCCPCH or N-PCCPCH is up and UE is directed to
                    transition from FACH to HS, then do not set the HSDPA start action
                    in the first CPHY_SETUP_REQ. The action is only set in the second
                    CPHY_SETUP_REQ
07/18/05    da      If LC_ID is already present for N-BCCH and BCCH when trying to 
                    setup, do a reconfig.  Reconfig will just update the logical channel 
                    ID in MAC. New functions rrcllc_process_reconfig_bcch_neighbor() and
                    rrcllc_process_reconfig_bcch_serving()
07/16/05    tkk     Added support to update ordered config with connected mode 
                    timers/counters during FACH and DCH states.
07/15/05    vk      Added a comment in fn rrcllc_check_if_hsdpa_can_be_started_reconfigured()
                    to indicate the future checks to be added
07/15/05    vm      Added support for handling channel config failure in CSP.
                    Removed check for MCM procedure - RRC_PROCEDURE_MCM - altogether
                    from the file. Replaced RRC_PROCEDURE_MCM by a combination
                    of RRC_PROCEDURE_CSP and RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP.
07/09/05    sgk     Added code in rrcllc_process_funneled_cmd_req to check if 
                    the transaction id == L1_NO_CNF_TRANSACTION_ID for 
                    CPHY_MEASUREMENT_REQ with param type == L1_MEAS_CTRL_PARMS
                    and if so set next_llc_substate to LLC_IDLE instead of
                    LLC_WAIT_CPHY_MEAS_CTRL_CNF.
07/08/05    vm      On W resume failure, LC information is not cleared for CELL_PCH
                    and URA_PCH states also (in addition to CELL_DCH and CELL_FACH).
06/27/05    vm      Added recovery mechanism for handling of RLC config confirmation
                    with a failure. With the error recovery mechanism, UE will
                    go to idle. The changes are under FEATURE_RRC_L1_ERROR_RECOVERY_P1
                    feature. If the feature is not defined, then the UE now hits 
                    an error fatal instead of just printing an error message (as was the
                    case earlier).
06/24/05    da      Made change to handle CRLC_UL_REG_FOR_DATA_IND_REQ and
                    CPHY_DRX_REQ in func rrcllc_handle_commands_on_new_cell_ind
06/21/05    vk      For forced Sync A Procedure, set the HSDPA pointer to NULL
                    if nothing else has changed for HSDPA and the HSDPA action
                    is RECONFIG
06/15/05    da      Deleting C-RNTI from CC after Copying to TOC in when doing
                    chan_config due to OOS in FACH.
06/13/05    vk      Indicate to RLC in DL UM Mode for Rel 5 to use L1 as enum value
                    LI_SAME_AS_BEFORE if the RLC Action is Modify and the L1 size
                    is unspecified. Change is under FEATURE HSDPA
06/08/05    bu      Updated a MSG_HIGH in rrcllc_idle_handler().
06/01/05    vk      Forcibly set HSDPA L1 action to RECONFIG when only Sync A
                    procedure is involved and HSDPA is active and no HSDPA
                    parameter has changed
06/07/05    da      Changed prach action from reconfig to drop and add.  Also setting
                    flag process_state to LL_CONFIG_WITH_OC when LL config is done in
                    chan_config_engine. 
06/02/05    kc      Featurized HHO_FAILURE_HANDLING trigger points using bool's rather than
                    a pre-processor-directive.
06/01/05    da      Put trigger point of HHO failure handling under 
                    FEATURE_HHO_FAILURE_HANDLING 
05/26/05    vk      Added HRNTI check to determine if HSDPA can be reconfigured
                    as per Spec CR 2393 under FEATURE_SPEC_CR2393.
05/16/05    da      Added support to handle validation failure from L1
05/13/05    vk      If a AM RB is not mapped onto a DFLOW, then do not recalculate
                    the RLC size for AM Radio Bearer in CELL_FACH, CELL_PCH and
                    URA_PCH state
05/11/05    da      Added debug prints.
05/10/05    da      Made fixes for physical channel failure handling + Lint fixes.
05/05/05    svk     Modified function rrcllc_chan_config_within_fach() to handle the
                    case when SIB6 modification is causing the lower layers, L1 and MAC
                    to get reconfigured.
05/05/05    vm/bu   Added support for T-barred Feature. Added handling of new command
                    CPHY_CELL_BAR_REQ.
05/05/05    sm      Added functions/changes to handle RRC_ABORT_CIPH_CONFIG_REQ in
                    all LLC substates
05/04/05    da      In case of PCH->FACH failure, added code to deallocate LC-IDs
                    such as BCCH-FACH, CCCH-FACH and CCCH-RACH.  Removed code from
                    func rrcllc_build_cmd_to_rel_rlc where the number of ul_tm, dl_tm
                    and dl_um chans from CC were decremented by 1 when physical channel
                    failure during fach->dch transition happens.
04/29/05    da      Calling rrcllc_check_dcch_fach_mapping() to re-read RLC sizes
                    whenever there is pch-fach transition
04/26/05    vr      After sending the channel_config_cnf(failure)to procedure CHO
                    set the next substate of LLC to idle.Otherwise it would keep
                    on waiting for another Phy channel Est Ind.
04/22/05    vk      Added addtional checks for ACK/NACK values in fn
                    rrcllc_check_if_hsdpa_can_be_started_reconfigured. Also added
                    additional checks to make sure that all HSDPA parameters for FACH
                    to HS-DSCH transition are valid. Added changes to resume HSDPA after a
                    W->G Failure
04/20/05    vr      Moved sending channel_config_cnf(phy chan est ind failure)to IHO
                    before checking for failure handling restrictions in function
                    rrcllc_wait_cphy_channel_ind_handler().This is a fix for CR 62184.
                    This fix is to ensure that IHO will definitely get the confirm
                    message regardless of other conditions.
04/20/05    da      Calling rrcsmc_revert_to_old_cipher_config_db when going back to
                    old config to restore old security parameters in the case of
                    timing init HHO.
04/15/05    da      Added support for Phase 2 of dch failure handling: going back
                    to old configuration.
04/13/05    sk      Added support to handle RB release failure.  Changed the order
                    of lower layer configuration from RLC-MAC-PHY to MAC-PHY-RLC.
                    Umapping of RBs from TOC is done after successful channel
                    setup.
04/13/05    bu      If OC was set by ASU when WCDMA was suspended by IHO procedure,
                    if WTOG HO fails continue using OC. On channel setup or channel
                    establishment failure after WTOG HO failure, clear the LLC internal
                    queue before the failure handling gets triggered by IHO.
04/06/05    da      Added Initial support for BMC.  Handling of CTCH  and
                    a second SCCPCH in IDLE, CELL_PCH and URA_PCH states
                    are now supported.  CTCH is not present in CONNECTING, CELL_FACH
                    and CELL_DCH states.
04/04/05    bu      Added support to setup physical channels within CONNECTING
                    state after WTOG redirection fails. Added support in
                    rrcllc_chan_config_within_connecting.
03/29/05    vr      On a W->G CCO failure,while doing the channel config on resumption
                    use the CCTrCH id from the stored configuration instead
                    of getting a new one
03/25/05    da      Removed code that sets boolean compressed_mode_fail_status
                    to TRUE based on an invalid check in cphy_setup_cnf_handler
03/11/05    vk      Merged HSDPA code in Mainline from RRC_MSM6275 branch
03/04/05    sk      Added RRC_LLC_RE_EST_RLC_REQ command in function
                    rrcllc_wait_cphy_meas_ctrl_cnf_handler()
03/04/05    kc      Added support for Resume failure after a WtoG failure.
03/04/05    vm      Added call to function rrcllc_crlc_release_all_req() inside
                    function rrcllc_err_fatal_recovery_handler().
03/02/05   ttl      Support RRC ASN1 Release 5.
02/22/05    sk      Made llc_next_substate = LLC_IDLE in case cmd to lower layers
                    is RLC_UL_PURGE_WM_REQ
02/18/05    bu      Changed the order of SCCPCH setup in rrcllc_add_downlink_phy_chan_to_l1_cmd().
                    If SCCPCH needs to be setup it's always done first.
01/26/05    sk      Fixed an issue in channel establishment failure restriction check
                    that causes problem for RRCRBR proc for fach->dch.
01/17/05    sk      Added support for PCCH reconfig in cell_PCH/URA_PCH state
                    Swap OC and CC at the end of channel configuration.
01/14/05    sk      check for pcch logical channel and drop it during connecting->dch
                    transition. Add it during fach->pch transition
01/07/05    da      Initialized rrc_cmd_ptr->cmd.chan_config_cnf.compressed_mode_status
                    to FALSE in rrcllc_send_channel_config_cnf
01/04/05    da      Added Support for phase 1 of Physical channel establishment
                    failure handling within DCH.
12/24/04    sm      Added function rrcllc_copy_mac_cipher_config() to remove duplicate
                    code and added support for SMC_INITIATED_NON_HO_CIPHER_CFG.
12/23/04    sk      Added support to handle channel setup failure during pch->fach
                    transition.
                    Removed PCCH setup/reconfiguration during FACH setup if both pch/fach are
                    mapped on to SCCPCH.
                    Changed RNTI update handling so that RLC re-establishment happens before MAC
                    get configured.
12/08/04    sk      Fixed int to enum conversion issue in rnti update handler.
12/08/04    vn      Fixed compiler warnings
12/01/04    sk      Fixed merge issues in rrcllc_chan_config_to_re_enter_within_fach().
12/04/04    svk     In function rrcllc_add_downlink_phy_chan_to_l1_cmd(), add support
                    for processing the loopback setup for sccpch. Now loopback
                    command would be sent to lower layers for loopback mode type 1 only.
11/29/04    svk     Added a function rrcllc_cmac_ul_validatae_tfcs_table(): This function
                    will check if for all TFCI's the number of transport blocks and
                    the transport block size is within the L1 limits for transmitting
                    in 1 tti
11/24/04    svk     Merged the changes for stop and continue onto the 6.0 branch
                    from the 4.x branch
11/23/04    jh      Changes to read serving PCCPCH diversity info from SIB5,
                    if available and neighbor PCCPCH diversity info from SIB11,
                    if available.
11/22/04    sk      Added support to handle cphy_setup failure and cphy_est failure
                    during CELL_FACH->CELL_DCH and CONNECTING->CELL_DCH transition.
                    Added following new functions :
                    rrcllc_command_engine_for_failure()
                    rrcllc_build_cmd_to_rel_rlc(void)
                    rrcllc_phy_chan_failure_handling_restrictions()
                    rrcllc_release_ul_logical_chl_ids_in_new_configuration()
                    rrcllc_release_dl_logical_chl_ids_in_new_configuration()
                    rrcllc_chan_config_to_re_enter_within_connectinga()
                    rrcllc_chan_config_for_oos_within_connecting()
10/29/04    ttl     Fix the searching of RLC am_info in OC for rrcllc_process_config_dtch_rel()
                    due to the am_info maitain mechanism change.
10/29/04    ttl     Fix the RLC AM config memory pointing bug for M-PDP by leaving
                    the hole w/o replacing w/ other existing RLC entities when release
                    an RLC entity.
10/15/04    sk      Added support to handle channel config to configure RLC release
                    Added a new function rrcllc_process_config_dtch_rel()
                    Swap OC and CC before configuring RLC only so that second swapping
                    that happens after channel configuration keeps RLC/MAC/L1 on the
                    same configuration database (CC)
                    Added support to retain old C-RNTI if UE re-enters on the same cell
                    on which OOS was detected
10/11/04    sk      Removed Lint errors
                    Fixed indentations.
                    Moved rrcllc_check_dcch_fach_mapping() function to rrcllcoc.c
                    Removed unused local variables.
10/11/04    bu      Added support to handle RRC_RESUME_RLC_RB_REQ in
                    rrcllc_process_cmd(). Removed it from rrcllc_idle_handler().
10/05/04    bu      Send CPHY_SETUP_REQ to L1 to teardown PCCPCH only if
                    it's up, in Connecting/FACH/PCH states.
09/22/04    svk     1. Handle the action STOP_RB and CONTINUE_RB commadn recvd from
                      rbrc procedure or the cu procedure.
                    2. Send a command to RLC with the apporpriate action typ eset
                    if a stop/continue for a RB was recvd in the rbrc msg or cucnf msg.
09/20/04    bu      Go to LLC_IDLE instead of waiting for RRC_RESUME_RLC_RB_REQ
                    from SMC during ciphering and SRNS relocation scenarios.
                    Added handling of RRC_RESUME_RLC_RB_REQ in rrcllc_idle_handler().
                    Removed waiting for RESUME_CNF from RLC.
09/15/04    sk      Added Out of service area handling support
                    Added following functions.
                    rrcllc_chan_config_to_re_enter_within_fach
                    rrcllc_chan_config_for_oos_within_fach
                    rrcllc_chan_config_to_re_enter_within_pch
                    rrcllc_chan_config_for_oos_within_pch
                    Added a check in rrcllc_chan_config_within_fach()
                    and rrcllc_chan_config_within_pch to call the appropriate
                    chan config functions based on chan_config_reason.
                    Modified  rrcllc_handle_completion_of_chan_config_req() function
                    to handle "release_transport_physical channels" within cell_fach
                    and within_pch state.
                    Added a check in rrcllc_update_cmd_process_data_for_channel_config
08/26/04    jh      Updated to use new L1 tx_div_ind interface.
08/24/04    bu      In rrcllc_chan_config_within_dch(), handle S-BCCH release from
                    CSP.
08/19/04    sgk     Assigned rrcllc_cmd_under_process.chan_config.
                    rlc_config_req_list.dl_tm.chan_info[num_chl-1].lc_type to
                    UE_LOGCHAN_NONE instead of BCCH_FACH_RADIO_BEARER_ID as
                    rlc is not checking this variable and
                    BCCH_FACH_RADIO_BEARER_ID is not a part of the enum lc_type
                    inorder to fix lint error Type mismatch (assignment) (int/enum).
                    Put variables rrcllc_next_substate and rrc_state in function
                    rrcllc_delay_err_fatal_handler and rrc_state in function
              rrcllc_wait_cphy_idle_cnf_handler under the feature definiton
                  FEATURE_RRC_L1_ERROR_RECOVERY_P1 to solve the lint warinings
                'unreachable' and 'not accessed'
                    Removed the variable 'rnti_update_cnf_status' from the
                    function rrcllc_process_rnti_update_req to fix lint warning
                    'not accessed'.
08/18/04    jh(sk)  Swap oc and cc after channel config completion when OC is
                    not set for FACH->PCH transition, but only if the procedure
                    is CU.
08/12/04    bu      Trash Meas request in rrcllc_trash_cmds_till_first_useful().

08/09/04    kc      Fixed typo from curent_config to current_config
08/09/04    bu      In rrcllc_cphy_setup_req(), set the activation time to "NOW"
                    for LOOPBACK TEST.
08/06/04    kc      Check config_ptr_in_use and then use the ptr to send
                    ciphering configuration to MAC
08/06/04    bu      In rrcllc_chan_config_within_discon(), process the command
                    only if it's from CCM, CSP, SIB or MCM.
08/05/04    kc      Fix to use correct config-ptr during ciph configuration of MAC
                    after a handover.
08/02/04    bu      Call rrcsib_force_sib_event_init() instead of
                    rrc_sib_proc_variables_init().
07/28/04    jh      Added LBT processing in FACH.
07/26/04    sk      Swap oc and cc after channel config completion when OC is
                    not set for FACH->PCH transition.
07/17/04    bu      Reverting the change to set activation time to "NOW" for
                    LOOPBACK TEST in rrcllc_cphy_setup_req(), till other issues
                    related to this are sorted out.
07/15/04    jh      Changed name of is_ifhho_in_dch flag to is_hho_in_dch.
07/15/04    kc      Support to add and drop BCCH-on-FACH to read SIB-Mod=Ind
07/15/04    sk      Added RL failure/RLC reset handling related changes.
                    unmap RBs before configuring lower layers when RBs to be
                    released as part of chan_config_req from cu proc.
                    copy RLC info and RB mapping info from TOC to OC in
                    chan_config_in_fach_for_rl_failure even when dcch_fach
                    mapping is not present.
                    send RNTI update cnf only if cnf is requested from the proc.
07/09/04    bu      In rrcllc_cphy_setup_req(), set the activation time to "NOW"
                    for LOOPBACK TEST.
07/09/04    jh      Added additional logging for channel counts.
07/08/04    bu      In rrcllc_trash_cmds_till_first_useful(), trash the
                    CPHY_MEASUREMENT_REQ (for MEAS_CTRL).
06/24/04    bu      Queue the L1 commands other than RESUME/SUSPEND in
                    rrcllc_rrc_mode_standby_handler().
06/21/04    vk      Set appropriate bit mask in ordered config when CM parameters
                    need to be sent to L1 for FACH->DCH transition
06/08/04    bu      Configure MAC UL and DL before sending the CELL_TRANSITION_REQ
                    to L1 in rrcllc_cell_reselection_engine.
06/02/04    sk      Do not block L1 configuration in config_engine if the channel
                    config is requested by CSP proc.
05/28/04    sk      Do not block L1 configuration if the channel config is requested
                    by CSP proc
05/12/04    sk      Fixed sccpch bitmask in rrcllc_cell_reselection_within_pch()
05/10/04    vn      Call rrcrce_force_initialize() in rrcllc_err_fatal_recovery_handler,
                    and rrcllc_wait_rlc_rel_all_cnf_handler instead of
                    rrcrce_change_substate_to_rrcrce_initial().
05/04/04    sk      Fixed a debug print in fach2pch channel config.
04/20/04    sk      Added transaction_id field in channel config cmd.
04/13/04    bu      In rrcllc_cell_reselection_within_fach() update the RNTI information
                    in both ordered and current config.
04/06/04    bu      Removed the feature definitions from rrcllc_substate_e_type.
                    Also removed use of FEATURE INTERRAT CELL RESELECTION WTOG in
                    rrcllc_chan_config_within_discon(). Added
                    FEATURE_RRC_L1_ERROR_RECOVERY_P1 for CPHY_ACQ_REQ case.
04/02/04    jh/sk   Merged Sanjay's changes to add PCCH when necessary in DCH to
                    FACH transition, and to add or drop PCCH as necessary when
                    transitioning FACH<->PCH.
03/24/04    bu      In rrcllc_err_fatal_recovery_handler(), use llc_stored_cmd_ptr
                    instead of cmd_ptr while dequeing commands from LLC internal
                    queue.
03/22/04    bu      Added a new function rrcllc_free_cmd_and_embedded_buf() which
                    will take of freeing the embedded pointers in a RRC command,
                    e.g. CPHY_MEASUREMENT_REQ and TRAFFIC_VOLUME_REQ when freeing those
                    commands from the LLC internal queue. Also added various missing
                    cases where the above commands were not being properly handled in
                    various LLC substates.
03/18/04    bu      In rrcllc_free_cmd_buf() free the embedded pointer for measurement
                    and traffic volume request (if found) before freeing the RRC
                    command.
03/18/04    bu      On a RESUME_CNF (Failure), while dequeing and clearing the LLC
                    commands if DEACT_REQ or STOP_REQ is dequeued, start processing
                    it right away. Otherwise free all other commands. Also fixed a
                    possible memory leak.
03/15/04    bu      Removed the use of FEATURE DUALMODE BASELINE. This feature is
                    always defined (even for singlemode builds).
03/10/04    bu      If RESUME_CNF comes back with a FAILURE status, clear the
                    internal LLC queue as UE will start IDLE mode cell selection.
                    Also removed the step to start dequeing commands from LLC queue
                    when LLC goes to IDLE after receiving RESUME_CNF as we always
                    want the next command from MCM or the procedure dealing with the
                    particular Inter_RAT procedure to be processed first before
                    processing commands from the internal LLC queue (if any).
03/06/04    bu      Don't dequeue commands from the LLC queue when LLC goes to it's
                    IDLE state after receiving SUSPEND_CNF from L1.
03/04/04    ttl     Added FEATURE_CELLPCH_URAPCH for code of Cell_PCH/URA_PCH.
03/04/04    bu      Put rrcllc_wait_cphy_start_wcdma_mode_cnf_handler() under
                    FEATURE_RRC_L1_ERROR_RECOVERY_P1.
03/01/04    bu      Error recovery if CPHY_IDLE_REQ gets stuck.
02/27/04    jh/sk   Merged fixes from Sanjay: Re-read SCCPCH info for PCH
                    from SIBs when doing FACH->PCH transition.
02/26/04    jh      Added support for storing the logical channel ID for new
                    UM and TM RLC channels in addition to incrementing the
                    counter.
02/25/04    jh      Fixed incomplete implementation of previous change.
02/26/04    jh      In the case of a Cell Change Order failure, use the same
                    code as for the processing of a Mode Control failure,
                    restoring the configuration from current config into
                    ordered config.
02/23/04    bu      Stop the deadlock timer in rrcllc_l1_deadlock_handler().
02/20/04    bu      Added more support for ERR_FATAL recovery. If RRC detects a deadlock
                    with L1 for ACQ_REQ or it receives a OPERATIONAL_ERROR_IND from L1,
                    it will STOP & START L1 before triggering the existing ERROR_FATAL
                    recovery mechanism.
02/10/04    bu      Changed the MSG_HIGHs to ERRs when RRC-L1 deadlock is detected
                    and when ERR_FATAL recovery is triggered.
02/05/04    bu      Added support for ERR_FATAL recovery. Support is under
                    FEATURE_RRC_L1_ERROR_RECOVERY_P1.
02/06/04    jh      Added rrcllc_check_dcch_fach_mapping(),
                    rrcllc_chan_config_dch_to_pch(),
                    rrcllc_chan_config_fach_to_pch_or_ura_pch(),
                    rrcllc_chan_config_ura_pch_to_fach(),
                    rrcllc_chan_config_pch_to_fach() and,
                    rrcllc_chan_config_within_pch() to support CELL_PCH and
                    URA_PCH states, as well as various logic changes to
                    accomodate these transitions.
01/26/04    kc      Fix to send MAC Ciphering configuration only if a TM bearer
                    config has changed.
01/15/03    bu      Clear the CCTrchId and the semi-permanent data related to
                    S-PCCPCH on a setup failure.
12/11/03    jh      Changed to wait for CPHY_CHANNEL_INDICATION before sending
                    reconfig complete messages when doing inter-frequency
                    hard handover.
12/10/03    bu      In rrcllc_chan_config_with_discon() return a failure if
                    the CHANNEL_CONFIG_REQ is requesting for operations on the
                    RBs which should not be handled in DISCONNECTED state.
12/10/03    bu      Added support for Inter-RAT cell reselection in CELL_FACH.
12/04/03    vn      While sending CPHY_SETUP_REQ, fill in sdu_time from Ordered Config.
12/02/03    sk/vn   Added support for mapping DCCHs on FACH/RACH for a
                    Radio Link Failure.
12/02/03    kc      Reset ciph_status value during reconfiguration if SRNS
                    relocation is not done and ciphering was not enabled.
11/24/03    kc      Added correct check for Timing_Init vs Timing_Maintained
                    in DCH->DCH Interfrequency Hard Handovers
11/21/03    bu      Added support to do DROP and ADD instead of seamless reconfig
                    for an Inter-frequency Hard Handover within DCH.
11/21/03    bu      In rrcllc_chan_config_with_discon(), send the serving cell
                    PCCPCH release to L1 only if it is up.
11/13/03    jh      Properly update process_state when done configuring lower
                    layers on behalf of a reconfig procedure.
11/17/03    jh      Added command engine, RB re-establishment code, and other
                    processing for SRNS relocation.
10/29/03    bu      Added support to send frequency information in N-PCCPCH setup
                    and CPHY_CELL_TRANSITION_REQ to L1, for Inter-frequency cell
                    reselections.
10/23/03    svk     rrcllc_chan_config_within_dch() : Do call this function
                    rrcllc_copy_cc_to_oc(); only if the config_ptr_in_use is not
                    the oredered_config. This fixes CR 35981.
10/22/03    vn      Fixed change left out from earlier checkin.
10/22/03    jh      Moved setting of frequency and scrambling code to
                    RRC_CPHY_PHYCHAN_ESTABLISHED_IND processing for interfreq
                    hard handover.
10/10/03    jh      Added support for RRC_CIPH_CONFIG_REQ in IDLE for GtoW
                    handovers.
10/09/03    vn      Disable PCH when going from Disconnected to Connecting state.
10/08/03    jh      Added processing of pending ordered config clear for state
                    change indication handler in channel config engine.
09/30/03    vn      Fixed SCCPCH selection when reselection happens in
                    Connecting state.
09/10/03    vn      For Deactivation and Stop Mode, do not ask MAC to sync up
                    with L1. Otherwise it will lead to MAC left hanging waiting
                    for a signal from L1. Any Channel Config Req for Idle will
                    be trashed on an Acq Cnf or a Freq Scan Cnf. This takes care
                    of race condition between CSP and RCR procedures.
09/09/03    jh      Added support for including frequency information in L1
                    commands.
09/04/03    jh      Added initialization of TOC for LLC_RELEASE_ALL_CHAN_ENGINE
                    and LLC_STOP_WCDMA_MODE_ENGINE upon state change to
                    DISCONNECTED.
09/03/03    bu      Print l1 debug messages while waiting for CPHY_IDLE_CNF,
                    CPHY_SETUP_CNF and CPHY_CELL_TRANSITION_CNF before doing
                    an ERR_FATAL.
08/26/03    vn      When reconfiguring MAC for Active Set Update, indicate
                    to MAC that UL configuration has not changed - so
                    UL reconfig of MAC is avoided.
08/19/03    vn      Set correct HFN for DL AM User plane RB on re-establishment.
08/05/03    vn      Added support for RLC Re-establishment. When RLC needs
                    to be re-established during RNTI_UPDATE_REQ, updates
                    RLC command buffer with RLC Config data from OC/CC,
                    updates Ciphering parameters and sends Re-establish
                    command to RLC.
07/24/03    vn      Do not force SIB and RCE to Initial substates on a
                    Discon->Discon transition. While trashing commands, send
                    a Channel Config Cnf with Failure back. This ensures on
                    a Discon->Discon, RCE and SIB complete their pending
                    processing gracefully. This prevents race conditions when
                    a Discon->Discon transition can happen without CSP's knowledge.
07/11/03    vn      Added function rrcllc_trash_cmds_till_first_useful to
                    selectively trash commands when going to Idle (from any
                    state - including Idle) or on receiving Acq Cnf/Freq Scan Cnf
                    in any RRC state. Added function calls to reset RCE and SIB
                    state machines when starting Cell selection within Idle.
                    Added processing for RRC_CPHY_ERROR_IND in non Idle states.
                    Ignore Discon->Discon Channel Config req from LLC.
06/27/03    vn      Before processing a RESELECTION_REQ, check that CCM
                    is still waiting for RESELECTION_CNF. This covers a race
                    condition where State changes to Idle after CCM sends
                    a RESELECTION_REQ.
06/25/03    vn      Added additional check to not send MAC_UL_CONFIG when
                    it is NOT a solo BCH operation. Changed RNTI UPDATE REQ
                    handling to keep all layers on the same database.
06/23/03    vn      Added support for L1 deadlock detection and recovery
                    for key RRC-L1 commands. Support for RB Reconfig with
                    only RLC parameter info.
06/17/03    bu      Removed calls to SIB and RCE init functions for
                    CHANNEL_CONFIG_REQ and added them for STOP_LOWER_LAYER_REQ
                    in rrcllc_wait_rlc_rel_all_cnf_handler().
06/04/03    jh      Added LLC support for Cell Change Order.
05/28/03    bu      Added reference to PROCEDURE_IHO under feature
                    FEATURE_INTERRAT_HANDOVER_GTOW in
                    rrcllc_wait_cphy_channel_ind_handler().
05/23/03    svk     Added event EVENT_WCDMA_RRC_PHYCHAN_EST_FAILURE
05/23/03    bu      Added calls to take SIB and RCE procedures to their initial
                    substates while stopping the WCDMA mode. The init functions
                    will be called only when the UE is already in DISCONNECTED
                    mode in rrcllc_wait_rlc_rel_all_cnf_handler();
05/01/03    kc      Added support for Inter-RAT ciphering. Added new function
                    to update RLC and MAC ciphering information.
04/29/03    vn      Added new functions rrcllc_can_oc_be_cleared_now and
                    rrcllc_clear_ordered_config_now. Ensure notify_smc is
                    checked only if clear_ordered_config is called on
                    completion of a Reconfig procedure. Enqueue Reselection
                    Req into LLC cmd Q when if comes between the point OC is
                    set and before lower layers are configured. When OC is
                    being used and Reselection Req is recd, use CC to
                    configure lower layers for reselection. On completion of
                    reselection, always go thru LLC_WAIT_NEW_CELL_IND. In
                    rrcllc_wait_new_cell_ind_handler, clear ordered config
                    if it was pending.
04/24/03    bu      Removed usage of FEATURE_L1_ACT_TIME. Activation time will be
                    initialized in the l1_cmd_hdr_type. Renamed set_seq_num to
                    seq_num.
04/10/03    vn      Always check with CSP if saving of Measurements is needed
                    before sending a CPHY_IDLE_REQ. If saving of measurements
                    needed, call the measurements function to ensure L1 does
                    not initialize intra-freq measurement data on CPHY_IDLE_REQ.
04/10/03    bu      Send deact_reason in CPHY_DEACTIVATE_REQ to L1.
04/09/03    vn      Always reconfigure L1 UL and MAC UL for any loopback mode
                    to keep all layers in sync and happy.
04/09/03    bu      Send the Channel Config confirm to IHO procedure on getting
                    the PHYCHAN_ESTABLISHMENT_IND (SUCCESS/FAILURE), while
                    transitioning to DCH if the current RRC state is DISCONNECTED.
04/03/03    bu      Bring down the serving or neighbor BCCH/BCH/PCCPCH pipe
                    if it's up while going from CONNECTING to CELL_DCH or from
                    CELL_FACH to CELL_DCH. The neighbor/serving PCCPCH is
                    dropped first. Clear the n_pccpch_is_up flag when
                    TRANSITION_REQ is sent to L1 for a successful reselection.
03/19/03    bu      Ignore any internal commands if we have started processing a
                    STOP_LOWER_LAYER_REQ. At the end of the WCDMA_MODE_DEACT_ENGINE
                    free up the internal LLC queue commands.
03/17/03    jh      Modified chan_config_within_dch() to not allocate a new
                    CCTrCH ID if we are resuming from a failed WCDMA to GSM
                    handover.  The existing CCTrCH ID copied from current
                    config is still valid and should be used instead.
03/12/03    bu      Removed the check for next state of the command under
                    process for STOP_LOWER_LAYER_REQ.
03/07/03    vn      In rrcllc_handle_completion_of_chan_config_req(),
                    fixed to clear ordered config whenever processing for CSP
                    procedure at the end of channel setup/drop in CELL_FACH.
                    This fixes issue when SIB timeout happens in CELL_FACH (during
                    reselection) and BCH is not dropped gracefully.
03/07/03    bu      Initialize the ordered config and current config for WCDMA mode
                    deactivation engine without sending a STATE_CHANGE_IND if RRC
                    state is already DISCONNECTED.
03/07/03    bu      Send the STATE_CHANGE_IND to DISCONNECTED after the
                    STOP_LOWER_LAYER_CNF has been sent back to the procedure.
03/06/03    jh      Modified chan_config_within_discon() to not allocate a new
                    CCTrCH ID if we are resuming from a failed WCDMA to GSM
                    reselection.  The existing CCTrCH ID copied from current
                    config is still valid and should be used instead.
03/06/03    bu      Updated the LLC_WCDMA_MODE_DEACT_ENGINE to properly de-configure
                    MAC and RLC. Also at the end of the command engine initiate a
                    state change to RRC_STATE_DISCONNECTED before sending the
                    RRC_STOP_LOWER_LAYER_CNF back to the procedure.
03/05/03    vn      When anyone of L1/MAC DL/UL is to be configured within
                    DCH, configure all to avoid any inter-layer sync issues.
                    It is not conditional on FEATURE_DROP_ADD_FOR_PHYCHL_RECONFIG
                    Also, on an Active set update, configure L1 UL and MAC
                    DL and UL to keep all layers in sync and on same database.
02/27/03    vn      When going to Idle, ensure Current Config is not copied
                    to Ordered Config if Ordered Config is already in use.
                    Do not initialize MAC config until L1 is sent to IDLE.
02/18/03    vn      In rrcllc_handle_completion_of_chan_config_req, swap
                    OC and CC if Ordered Config is set for DCH to FACH transition
                    by anyone of the remaining procedures.
02/18/03    vn      In rrcllc_chan_config_within_discon, handle BCH and N_BCH
                    operations independently, they are not mutually exclusive.
02/14/03    kc      Changed feature defn from INTERRAT_HANDOVER_GTOW_RRC to
                    INTERRAT_HANDOVER_GTOW
02/14/03    jh      Re-applied fix that was erroneously dropped when merging
                    from branch.  SCCPCH channel drop should not be attempted
                    when going from Disconnected to Cell DCH for GSM to WCDMA
                    handover.
02/13/03    jh      Added rrcllc_chan_config_discon_to_dch() function to
                    perform direct transition between Disconnected and
                    Cell DCH for GSM to WCDMA handover.
02/11/03    jh      Replaced macro RRCLLC_XLATE_LBT_MODE inside FEATURE_TC.
02/05/03    bu      Initialized ordered config and current config while processing
                    a STOP_LOWER_LAYER_REQ.
11/08/02    bu      Added the WCDMA stop cause in the stop command sent to L1.
11/01/02    bu      Configure RLC ciphering configuration in the
                    CHAN_CONFIG_ENGINE.
11/01/02    vn      Work with Current Config on processing for a Security
                    Mode Command for Ciphering. This ensures inter-layer sync.
10/30/02    vn      Always configure MAC in Cell_FACH. Needed for DCH->FACH.
10/30/02    bu      Added support to wait for DRX CNF before sending any other
                    command to L1. Added a new state LLC_WAIT_CPHY_DRX_CNF and
                    corresponding handler for it.
10/25/02    kc      Sending RLC Ciphering config. only after the RLC channels
                    are configured.
10/24/02    rj      Updated to use rrc_malloc and rrc_free to use dual heaps
                    in place of mem_malloc and mem_free to avoid memory
                    fragmentation
10/17/02    jh      Added support for transition back to WCDMA mode when GSM
                    handover fails during a call.
10/11/02    vn      Set the command engine to LLC_CHAN_CONFIG_ENGINE when
                    setting up channels on a failed WCDMA->GSM reselection.
10/09/02    kc      Added code to update RLC with ciphering info when AM and
                    UM radiobearers are added.
10/09/02    vn      Reconfig all lower layers within CELL_FACH so as to keep
                    them on the same config pointer usage. Do not swap OC and
                    CC when procedure is either RBE or RBRC during CELL_DCH to
                    CELL_FACH transition. This is needed so as to keep
                    "OC in use" which disallows any further swapping due to
                    RNTI Update. This prevents inter layer sync problems.
10/08/02   vn,bu    Fixed rrcllc_handle_completion_of_chan_config_req for
                    handling of Cell Reselection in CELL_FACH.
10/04/02    vn      Added new function rrcllc_chan_config_fach_to_dch to
                    configure lower layers on a FACH to DCH transition.
                    Added calls to rrcllc_discard_oc to discard Ordered Config.
                    Update channel counts on BCCH, PCCH and CCCH setups/drops.
10/03/02    vk      Sent RRC_COMPRESSED_MODE_IND command to physical channel
                    reconfiguration procedure in function
                    rrcllc_send_compressed_mode_run_time_error_ind(..)
10/03/02    vk      Added handling of RRC_CPHY_COMPRESSED_MODE_IND in
                    rrcllc_idle_handler() under FEATURE CM SUPPORTED
10/03/02    vn      Added support for setting up SCCPCH on a WTOG Reselection
                    failure in Idle mode. If Serving PCCPCH was up at the time
                    of WTOG reselection initiation, that is also setup again.
09/30/02    vn      Support for DCH->FACH transitions: Update Cell FACH RB
                    Mapping Info with log chl ID when an RB is added/modified.
                    If next state is CELL_FACH, update log chl ID in DCH
                    mapping info in TOC so that to use it at the time of FACH->DCH
                    transition later. New fn rrcllc_chan_config_dch_to_fach that
                    reads SIBs and sets up common chls. When releasing all/TrCHs,
                    initialize MAC data in OC. New command engine RELEASE_TR_PHY_
                    CHAN_ENGINE to release Phy and TrCHs before starting cell
                    selection during DCH->FACH trans process. Handle request to
                    drop Phy and TrCHs and to setup Serving BCCH in CELL_DCH state
                    during DCH->FACH transition. In rrcllc_chan_config_within_fach,
                    update OC with TOC on 1st Reconfig is CELL_FACH immediately
                    after DCH->FACH transition. Updated logic in rrcllc_update_
                    cmd_process_data_for_channel_config to construct L1 commands
                    based on current command engine. Use config_ptr_in_use to
                    decide when to swap OC/CC. Take care not to reset
                    ordered_config_status when it is set for DCH_FACH_TRANS. Added
                    a common fn to be called on completion of Channel Config Req.
09/27/02    kc      Fixed MAC cipher config bug, now first ordered_config ptr is
                    copied and then ciphering info. is copied.
09/25/02    vn      Send a TFCS pointer in CELL_TRANSITION_REQ in FACH and
                    Connecting states (for Cell Reselection). For cell reselection,
                    MAC is configured after L1 transitions to new cell. This is
                    needed to work with PRACH triggering mechanism.
09/25/02    bu      Changed l1_status to chan_cfg_status under
                    FEATURE CM SUPPORTED.
09/20/02    vn      Send PRACH parameters in Cell Transition Request when
                    cell reselection happens in Connecting or CELL_FACH states.
                    Fixed so that ROC and CC are NOT swapped if a Reconfig was
                    active when Reselection entered.
            vn      Fixes to setup and drop Neighbor and Serving BCHs in
                    Connecting and Cell_FACH states. Ensure Channel_config_req
                    is sent only once for failure.
            bu      Added support for cell reselection in CONNECTING &
                    CELL_FACH state. Added support to add SCCPCH & PRACH. A
                    new reselection_config ptr is used while configuring the
                    lower layers for cell reselection. Added a new state
                    LLC_WAIT_NEW_CELL_IND and a handler for the state. LLC
                    goes to this state after successfully transitioning to
                    the new cell. On receiving NEW_CELL_IND from CCM, LLC will
                    clear the LLC command queue. Added a new function
                    rrcllc_handle_commands_on_new_cell_ind() to ensure proper
                    handling of all the queued commands.
09/20/02    bu      Corrected the SUSPEND and RESUME confirms.
09/11/02    bu      Added funneling of SUSPEND and RESUME confirmations. SUSPEND
                    and RESUME will be supported only if
                    FEATURE INTERRAT HANDOVER WTOG or
                    FEATURE INTERRAT CELL RESELECTION WTOG are defined.
09/10/02    bu      Added support for funneling of SUSPEND and RESUME WCDMA mode
                    requests. Added new LLC states to wait for SUSPEND_CNF and
                    RESUME_CNF from L1. Added respective state handlers.
09/10/02    bu      Added check for state change required various ciphering
                    state handlers when a channel config req with next_state
                    RRC_STATE_DISCONNECTED is received.
09/09/02    vn      While sending CPHY_SETUP_REQ, check for both L1 and MAC
                    Reconfig needed flags to turn on "signal_ul_mac_at_act_time"
                    in UL and DL.
09/06/02    bu      Added support for Ciphering. Added new LLC states -
                    LLC_WAIT_CRLC_SUSPEND_CNF, LLC_WAIT_RRC_CIPH_CONFIG_REQ,
                    LLC_WAIT_RRC_RESUME_RLC_RB_REQ and LLC_WAIT_CRLC_RESUME_CNF.
                    Added handlers for all these new states. Added functions -
                    rrcllc_send_suspend_rlc_rb_cnf(),
                    rrcllc_update_ciphering_config_info(), rrcllc_resume_rlc_rb_req(),
                    rrcllc_crlc_ul_suspend_req(), rrcllc_cphy_ciphering_key_req(),
                    rrcllc_crlc_ul_cipher_config_req() and
                    rrcllc_crlc_dl_cipher_config_req().
09/03/02    vn      Merged the following from branch. Fixes race conditions
                    between Out of Service Area Ind and RRC Connection Requests
                    - CR 24223.
            vn      Wait for a State Change Indication after each change in
                    RRC state before processing next command. LLC transitions
                    to a new LLC state - WAIT_FOR_STATE_CHG_IND and keeps
                    queuing all LLC command on local queue till State Change
                    Indication is received. This ensures LLC does not
                    mis-interpret state change requests in Channel Config Req.
                    Needed to ensure RRC state doesn't change between start and
                    end points of processing a command in LLC.
            vn      When processing a Channel Config Req with a Release All,
                    do not initialize Ordered Config and LLC immediately. Init
                    lower layers, send a State Change request and wait for a State
                    Change Indication before initializing OC and LLC data. This
                    takes care of race condition between RCE and Out of Service
                    when RCE accesses data in Connecting state every T300.
08/28/02    vn      Do not expect a Physical Channel Indication to come from
                    L1 when FEATURE_WCDMA_IGNORE_DCH_CHAN_ESTAB_DCH_DROP_ADD
                    is defined and it is a Reconfiguration within Cell_DCH.
                    This is a quick fix to not do Sync Proc A on any Reconfig.
                    This solution will not work once hard handovers are supported.
08/28/02    vn      Featurized Inter-layer sync flags in MAC_UL/DL_CONFIG_REQ
                    with FEATURE MAC ACTIVATION TIME to work with all MAC VUs.
08/26/02    vn      Changes for inter-layer sync issue - set signals in
                    CPHY_SETUP_REQ whenever UL or DL MAC needs to be configured.
                    Set signals in MAC_UL/DL_CONFIG_REQ whenever UL/DL L1 needs
                    to be reconfigured. This applies to Cell_DCH state only.
08/26/02    vn      Do not send a Channel Config Cnf with Failure to procedure
                    unless it is for Neighbor BCH failure or if the current state
                    is Idle Disconnected. In cases when Channel Config Cnf with
                    Failure is not sent, enqueue a self-command to go to Idle.
08/22/02    vn      Fix to handle Neighbor BCH setup failure by not taking L1 to Idle.
08/21/02    vk      Implemented rrcllc_send_compressed_mode_run_time_error_ind(...)
                    to send compressed mode run time error event for
                    Physical Channel Reconfiguration Procedure. Also, added support
                    for receiving RRC_CPHY_COMPRESSED_MODE_IND event from L1 and
                    invoking rrcllc_modify_cm_info_in_current_config(...) to
                    modify compressed mode information. Changes have been put under
                    FEATURE CM SUPPORTED.
08/09/02    vn      Enqueue self command to go to Idle when a CPHY_SETUP_CNF
                    or a CPHY_ESTABLISHMENT_IND comes with a failure. This is
                    a stopgap arrangement till going to previous config is
                    supported. Also, do not send a CHANNEL_CONFIG_CNF if
                    procedure didn't ask for.
08/02/02    bu      Fixed a typo in RRCLLC_COMMAND_ENGINE for DUALMODE.
08/01/02    bu      Added the reselection engine in RRCLLC_COMMAND_ENGINE for
                    DUALMODE.
07/31/02    vk      Defined a global variable compressed_mode_fail_status. This
                    is set to TRUE in rrcllc_send_rrc_channel_config_cnf in case
                    the overall status of l1 command sent earlier failed due to
                    compressed mode. These changes are under FEATURE CM SUPPORTED
07/12/02    vn      Added funneling of CMAC_UL_BLOCK_RACH_TRAFFIC_REQ.
06/14/02    vk      Removed the LLC state LLC_WAIT_MEAS_CTRL_CNF and the
                    function rrcllc_wait_mac_ul_meas_ctrl_cnf_handler()
06/13/02    vn      Changed rrcllc_clear_am_info to rrcllc_clear_rlc_info
                    to clear RLC Info for all types of released RLC channels.
06/12/02    vn      Drop and Add both Downlink and Uplink DPCHs even when
                    only one of them needs to be reconfigured. This is to
                    make sure there is no loss of sync between UL and DL DPCHs.
06/11/02    vn      Fixes for Loopback mode. Dummy signalling support merged.
                    Uplink DPCH is reconfigured and not dropped and added
                    for LBT even when FEATURE_DROP_ADD.. is defined. This is
                    because DL DPCH is not reconfigured and UL can lose timing
                    if it is the only one to be dropped and added.
06/07/02    vn      Changes to handle Radio Bearer Release - no need to
                    calculate RLC sizes when RB is being released, call to
                    clear AM info in OC after receiving AM Rel Cnf from RLC.
06/05/02    vn      Added special handling for Neighbor BCH setup failures
                    in L1. The CCTrCH ID for N_PCCPCH is released and the
                    Current Config is updated. On a N_BCCH drop, N_PCCPCH is
                    dropped only if the status of N_PCCPCH in
                    semi_permanent_data indicates that it is present.
06/03/02    vn      Send the UL TFCS pointer to L1 in CPHY_SETUP_REQ when
                    setting up or reconfiguring a L1 Uplink Channel. This is
                    featurized with FEATURE_WCDMA_COMP_GF.
05/30/02    vn      Updated to do a drop and add for Uplink DPCH in place
                    of a Reconfig. Featurized this behavior in Uplink and
                    Downlink with a new FEATURE_DROP_ADD_FOR_PHYCHL_RECONFIG.
05/29/02    vn      Fixed so that RNTI Update Request picks up the Current
                    Config data to configure MAC. This change is necessiated
                    since two separate databases are maintained now.
05/17/02    vk      Added state LLC_WAIT_MAC_MEAS_CTRL_CNF in LLC. Updated
                    function rrcllc_funnel_l2_ul_req to send command
                    CMAC_UL_TRAFFIC_VOLUME_CONFIG_REQ to MAC. Updated
                    rrc_funneled_cmd_cnf function to post the received
                    command RRC_CMAC_MEAS_CTRL_CNF from LLC to Measurements.
                    Added function rrcllc_wait_mac_ul_meas_ctrl_cnf_handler
                    to handle the commands in state LLC_WAIT_MAC_MEAS_CTRL_CNF
                    of LLC. These changes have been put under
                    FEATURE TRAFFIC VOLUME MEAS
05/16/02    vn      Do an add and drop of Downlink DPCH in place of a reconfig.
                    This is needed to satisfy L1 requirements for Physical
                    Channel Reconfigurations. This affects all places where
                    DPCH is reconfigured including voice calls and any of the
                    reconfigurations. Note: A Channel Establishment Indication
                    would be expected in this case.
05/15/02    vn      Merged the following from cell reselection branch:
            vn      Fixes for reselection: Update num_trch in semi_permanent_
                    data for PCCPCH and N_PCCPCH. Drop N_BCCH/N_BCH pipe on
                    reselection, implicitly. Changed cell_reselection_engine
                    to send MAC and RLC re-config after Cell Transition Req.
                    Added processing for RLC_DL_TM_CONFIG_CNF for reselection.
                    DL CCTrCH info for PCCPCH/N_PCCPCH not stored in OC.
                    Changed from pri_scr_code to scr_code in RRC-L1 I/F.
           bu,vn    Added Cell Reselection support. Added support to setup
                    and drop Neighbor BCH/N_PCCPCH pipe to read neighbor SIBs.
                    Added new functions process_add/drop_bch_neighbor.
                    Added support for a new Cell Reselection Engine that
                    takes care of configuring all of RLC, MAC and L1 on a
                    cell reselection. Added processing for Cell Transition Cnf
                    from L1. Added new functions update_cmd_process_data_for_
05/14/02    vn      In rrcllc_add_uplink_phy_chan_to_l1_cmd, corrected logic to
                    look for a L1 command with req mask not having
                    CPHY_UL_CCTRCH_INCL or CPHY_UL_PHYCHAN_DROP_INCL bits set
                    while adding a command to add or drop Physical channel resp.
05/13/02    bu      Support for WCDMA mode deactivation - added a new WCDMA mode
                    deactivation command engine that sends a CPHY_STOP_WCDMA_MODE_REQ
                    to L1, configures MAC with no channels and sends a Release all
                    channels to RLC. Added new substate to wait for
                    CPHY_STOP_WCDMA_MODE_CNF from L1. Frees LLC internal command
                    queue when WCDMA mode deactivation is completed. These changes
                    have been added with FEATURE DUALMODE BASELINE tag.
05/07/02    vn      Fixed DL and UL mismatch in rrcllc_process_funneled_cmd_req
05/07/02    vn      Support for TrCH Reconfig: Reconfigure MAC DL and UL while
                    in DCH state based on indication in the reconfig_needed
                    flag in ordered_config.
04/23/02    vn      Action on UL and DL L1 is based on indication in
                    reconfig_needed structure of Ordered Config - support for
                    Physical channel Reconfig in Cell_DCH and Cell_FACH states.
04/22/02    vn      No separate common and dedicated TrCH info is maintained
                    anymore as either one or the other is valid. No need for
                    passing RRC state to rrcllc_copy_cc_to_oc.
04/22/02    vn      Removed rrcllc_semi_permanent_data from ordered_config_type
04/15/02    vn      Call to rrcllc_init_ordered_and_current_config_ptrs at
                    powerup. Update current_config_ptr at the end of processing
                    for Channel Config when in Idle state or in loobcak mode.
04/12/02    vn      Merged support for loopback mode 2 from branch.
04/11/02    vn      Merged the following from branch -
            vn      Fixed the Active Set Update processing when
                    FEATURE_SINGLE_OP_PER_SETUP_REQ is not defined.
            vn      Change due to UL and DL RLC sizes moving out from Common
                    AM Config in RLC-RRC IF structure.
            vn      Call new functions in Ordered Config to get RLC PDU size
                    values. Fill in RLC PDU size for UL/DL UM and AM channels.
03/18/02    vn      Updated various functions to update FACH info for all
                    FACHes whenever multiple FACHes are mapped onto SCCPCH.
03/14/02    bu      If FEATURE_l1_ACT_TIME is defined don't fill in the
                    activation time in rrcllc_cphy_deactivate_req.
03/13/02    bu      Featurized the activation time support code.
03/12/02    bu      Changed rnti_update_cnf_status in
                    rrcllc_process_rnti_update_req() to uecomdef_status_e_type
                    from a boolean.
03/08/02    vn      Updated config_dcch_dtch() to get logical channel mode
                    by searching thru' all logical channels in all FACHs.
                    Added function to go to Idle from Cell_FACH.
03/08/02    bu      Added ACTIVATION TIME support. Initialize the act_type
                    and act_time from the ordered_config in
                    rrcllc_construct_and_store_l1_cmds().
03/08/02    bu      Added processing of RRC_RNTI_UPDATE_REQ command. Added
                    function rrcllc_process_rnti_update_req() which updates
                    the rnti information and informs MAC about the change.
03/05/02    vn      Added processing in rrcllc_process_config_dcch_dtch to
                    handle DCCH/DTCH configuration when in (or next state is)
                    Cell_FACH. Added new fns rrcllc_chan_config_connecting_
                    to_fach and rrcllc_chan_config_within_fach to handle
                    channel configuration for Cell_FACH.
03/04/02    vn      Added Cell_FACH support and changes due to OC cleanup.
                    Moved rrcllc_semi_permanent_data to ordered_config_type.
                    CCTrCH and Channel parms for PCCPCH are now stored in OC.
                    No need to update num_pchs, num_bch, num_fachs as that is
                    done during OC updation. Make use of Current Config to
                    determine presence/absence of TrCHs. Removed Drop PCCH
                    processing from Disconnected state. At end of processing
                    of Channel Config Req, copy OC to CC if new RRC state is
                    Idle. Calls to new OC functions rrcllc_update_oc_from_
                    disconnected_to_connecting, update_oc_within_disconnected.
                    Ensure that init_semi_permanent_data is called only after
                    ordered_config_ptr has been initialized.
02/07/02    vn      Support for loopback mode: Update loopback mode in OC
                    on a CHANNEL_CONFIG_REQ from Loopback procedure in Cell_DCH
                    Add the loopback operation in a L1 command as per RRC/L1 IF
12/18/01    vn      In rrcllc_process_config_dcch_dtch, look for the RB ID in
                    Ordered Config AM Info to get to the right AM entity.
12/12/01    vn      In rrcllc_construct_and_store_l1_cmds, change the order
                    of channel setup commands to L1 to make sure L1 does not
                    have more than 1 Phy Channels that have BTFD enabled.
12/11/01    vn      Merged the following from branch -
            vn      No need to change RRC state or send more L1 commands
                    when a CPHY_SETUP_CNF is received with a Failure. Handle
                    failure (false) status in RRC_CPHY_PHYCHAN_ESTABLISHED_IND.
                    Process all RRC internal commands in all LLC substates.
            vn      While establishing AM channels, use the invalid logical
                    channel IDs to determine new logical channels in Ordered
                    Config. Correctly point to the Ordered Config AM data in
                    each RLC AM Config command.
            vn      While establishing user plane RBs, get the logical channel
                    mode from MAC config parameters in Ordered Config. While
                    modifying or releasing a pre-existing RB, call LCM function
                    rrclcm_get_dl/ul_rlc_lc_id(). Fixed logical channel type in
                    RLC Config data for AM channels.
12/11/01    bu      Added support to handle CPHY_SETUP_CNF failure.
11/15/01    vn      Process Lower Layer Deactivate Req in all LLC substates.
11/14/01    vn      Fixed the order of going to Idle by putting L1, MAC and
                    RLC to Idle in that order.
11/09/01    vn      While going to DCH from Connecting state, drop PCCH only
                    if PCH already up. Merged the following from branch for
                    Aset Update support -
            vn      Added support for Active Set Update. On a Channel Config Req
                    from ASU procedure, a CPHY_SETUP_REQ is sent with only the
                    ASET Flag set.
11/08/01    vk      Added break in rrc_funneled_cmd_cnf for cmd
                    RRC_CPHY_MEAS_CTRL_CNF
11/07/01    vk      Added function handler rrcllc_wait_cphy_meas_ctrl_cnf_handler
11/05/01    vk      Added support for RRC_CPHY_MEAS_CTRL_CNF command. Also
                    modified the next LLC wait to LLC_WAIT_CPHY_MEAS_CTRL_CNF
                    in case of param type being L1_MEAS_CTRL_PARMS in
                    CPHY_MEASUREMENT_REQ.
10/29/01    vn      Fixed compiler warnings.
10/26/01    vn      Support for deactivation - added a new Deactivation command
                    engine that sends a Deactivation Req to L1, configures MAC
                    with no channels and sends a Release all channels to RLC.
                    Added new substate to wait for Deactivation Confirm from L1.
                    Frees LLC internal command queue when deactivation is completed.
10/25/01    vn      In idle_handler, when updating of channel config data fails,
                    send a Channel Config Confirm with a failure to requesting
                    procedure. Allow for adding of serving BCCH in Connecting state.
                    Return status from rrcllc_update_cmd_process_data_for_channel_config
10/22/01    vn      Support for Out of Service area - rrcllc_update_semi_perma
                    nent_phychan_status updates physical channel status maintained
                    by LLC and is called from add_downlink_phy_chan_to_l1_cmd.
                    Added process_reconfig_pcch and process_reconfig_ccch to
                    reconfigure PCCH and CCCH. In chan_config_connecting_to_dch,
                    BCCH/BCH/PCCPCH are not dropped - they should be already
                    dropped by now. chan_config_within_connecting and chan_config_
                    within_discon are added to reconfig CCCH, PCCH and drop BCCH
                    in these states. Drop all channels if a state change to
                    disconnected is requested in the same state. When all physical
                    channels are removed through CPHY_IDLE_REQ, update physical
                    status in LLC semi-permamnent data thru' LLC init.
09/25/01    vn      Drop all established channels and initialize lower layers
                    if a CHANNEL_CONFIG_REQ is recd in IDLE_DISCONNECTED state
                    with a request for PCCH or BCCH drop but no request for
                    state change.
09/19/01    bu      Cleaned up the F3 messages.
09/06/01    vn      Support for frequency scan. Added a new LLC substate
                    LLC_WAIT_CPHY_FREQ_SCAN_CNF to handle freq scan confirms.
08/30/01    rj      Changed UE_MODE_ACKNOWLEDGED_DATA_PLANE and
                    UE_MODE_ACKNOWLEDGED_CONTROL_PLANE to UE_MODE_ACKNOWLEDGED_DATA
                    and UE_MODE_ACKNOWLEDGED_CONTROL respectively.
08/27/01    vn      In rrcllc_insert_downlink_sccpch_reconfig_to_l1_cmd, the
                    request mask was being incorrectly set to
                    CPHY_DL_PHYCHAN_CFG_INCL. Fixed it to be CPHY_DL_PHYCHAN_ADD_INCL.
                    Took out definition of FEATURE_RRC_SINGLE_OP_PER_SETUP_REQ.
08/17/01    vn      Merged the following from branch and compiled it with
                    FEATURE_SINGLE_OP_PER_SETUP_REQ. This feature has to be
                    defined in this file if CPHY_SETUP_REQ is to contain only
                    one operation. Also added a new function
                    rrcllc_insert_downlink_sccpch_reconfig_to_l1_cmd to handle
                    the special case for SCCPCH reconfig:
            vn      Changes made to alter the sequence of CPHY_SETUP_REQs
                    going to L1. Each L1 Setup command now has only one channel
                    operation from amongst UL/DL Add/Reconfig/Drop/Tr Block
                    Enable_Disable channel operations. The operations are
                    in this order: UL Drop, DL Add, UL Add, DL Drop.
                    This has been done as per the new request from L1.
08/09/01    vn      Changed to drop PRACH in rrcllc_chan_config_connecting_to_dch.
                    Cleaned up debug and error messages - all inter-task messages
                    set to MSG_HIGH, all intra-task messages set to MSG_MED.
08/03/01    kmp     In rrcllc_chan_config_discon_to_connecting() ensured
                    that the number of BCHs stays at 1 since OC initializes it to 0.
07/26/01    vn      Added support for multiple SCCPCHs. Added new function to
                    set pch_included in semi permanent data. Both pch_included and
                    fach_included are taken into account to decide on RLC, MAC and
                    L1 configuration. Also segregated processing for logical and
                    physical channels. Added new functions for each of the
                    RRC state transitions.
07/06/01    vn      Changed to not wait for Channel Establishment Indication
                    from L1 when a Physical channel is reconfigured and not added.
                    Expect Channel Establishment indication to come anytime
                    during the sending of multiple CPHY_SETUP_REQs to L1.
06/30/01    kmp     In rrcllc_wait_cphy_channel_ind_handler() made the
                    PHYCHAN_ESTALISHED_IND a MSG_HIGH instead of a MSG_LOW.
                    In rrcllc_cphy_setup_req() changed a MSG_MED to a MSG_HIGH.
                    In rrcllc_wait_cphy_setup_cnf_handler() changed a
                    MSG_HIGH to a MSG_MED.
06/29/01    vn      Fixed an error with CCTrCH IDs running out.
06/29/01    vn      Allocate CCTrCH ID for PRACH.
06/27/01    kmp     In rrcllc_process_add_pcch(void) removed references to
                    sibs. This is now all handled locally by
                    rrcllc_copy_sib_to_oc() in rrcllcoc.c.
06/25/01    vn      At the time of setting up PRACH, also initialize the
                    add downlink phychan pointer to valid DL physical channel
                    data. This is to ensure that AICH parameters get to L1.
06/18/01    vn      Set "context = FALSE" in RLC_DL_REGISTER_SRVC_REQ for all
                    channels. This ensures SDU_IND is enqueued to RRC internal
                    queue in task context as opposed to in interrupt context.
06/15/01    vn      Changed rrcllc_init to accept rrcllc_init_e_type as a parameter.
                    The LLC queue and CCTrCH IDs are initialized and L1 is sent
                    a CPHY_IDLE_REQ only at the time of Startup LLC initialization.
                    At the time of going to LLC_IDLE and if the LLC command engine
                    is LLC_RELEASE_ALL_CHAN_ENGINE, re-initialize LLC. Send
                    RLC_DL_REGISTER_SRVC_REQ and RLC_UL_REGISTER_SRVC_REQ only for
                    new non-DTCH logical channels that are to be setup.
06/13/01    vn      Added support for DTCH setups, reconfigs and releases. New
                    processing added for releasing DPCHs. Consolidated local UL
                    and DL physical channel data into rrcllc_semi_permanent_data_type.
                    Added processing to handle RRC state transition from
                    Connected/Connecting state to Idle Disconnected state. Added
                    calls to OC function to get RLC size. Removed redundant code.
06/07/01    vn      Added support to send RLC_REGISTER_AM_SDU_CONFIRM_CALLBACK_REQ
                    when any new AM entity is added. Also changed to not wait for
                    CPHY_CHANNEL_ESTABLISHMENT_IND in VST environment.
06/06/01    vn      In rrcllc_construct_and_store_l1_cmds, fixed a bug where
                    it was not calling rrcllc_add_downlink_phy_chan_to_l1_cmd
                    and rrcllc_add_uplink_phy_chan_to_l1_cmd for DPCH setup/release
                    case. Release CCTrCH ID when PRACH is released. Updated
                    to comply with new RLC-RRC interface for AM channels. Fixed
                    an ARM compiler error in rrc_funneled_cmd_cnf declaration.
                    Pass also SIB3 pointer to rrcllc_copy_sib_to_oc. Added a
                    call to rrccsp_get_serving_pccpch_parms to get PCCPCH parms.
06/01/01    vn      Added rrcllc_send_mac_uplink_config flag to indicate when
                    to send a MAC Uplink Config Req. Added processing for setting
                    UL_PHYCHAN_EN_DIS bitflag when enabling FACH on an already
                    setup SCCPCH. Release existing CCTrCH ID when a physical channel
                    is to be reconfigured.
05/30/01    vn      Commented out the AM processing due to RLC changes.
05/29/01    vn      Fixed bugs caught in VST/Unit testing of BCCH, PCCH and
                    CCCH setups.
05/25/01    vn      Upgraded to work with L1 VU MSM5200_L1.00.02.94. Removed
                    references to the "valid" field in l1_ul_cctrch_parms.
                    Upgraded to new RLC VU MSM5200_RLC.00.00.09. AM mode
                    changes still pending.
05/24/01    vn      NEW LLC ARCHITECTURE. The architecture consists of an
                    LLC state machine. All MAC, RLC and L1 commands to be sent
                    as a result of processing RRC_CHANNEL_CONFIG_REQ are
                    constructed and stored in LLC upfront.
05/21/01    kmp     Updated in rrcllc_rach_setup() to correctly give MAC the
                    uplink CCCH Logical channel ID. Set the CCTrCH type in
                    get_prach_sys_info() in rrcllcpcie.c instead of in
                    rrcllc_rach_setup(). In the same function, now correctly
                    configure the DL CCTrCH info, by indicating in the cmd
                    packet to enable FACH TrBlk delivery. In
                    rrcllc_process_l1_cnf() added support to change the RRC
                    state. In rrcllc_dl_ccch_config() added the RLC size and
                    dummy HFN value for now. Added rrcllc_change_state().
                    Removed setting of num_trch in rrcllc_pch_setup and
                    rrcllc_rach_setup.
05/17/01    kmp     In rrcllc_pch_setup() correctly setup the number of TrCH
                    for the DL CCTrCH Mgr in L1. Updated rrcllc_process_rlc_cnf()
                    for the UL RLC channel cnf's, and the remainnig DL.
                    Correctly set the UL/DL CCCH Logical channel IDs when
                    configuring DL/UL watermark pointers for RLC. In
                    rrcllc_process_queue() updated to add support for
                    the llc_pending_proc flag. Added an else case (for
                    failures) in rrcllc_cphy_setup_cnf(), to dispatch to
                    the approriate procedure for an L1 channel setup failure.
                    Added the fact the config is valid to the UL CCTrCH database.
05/16/01    kmp     Updated with the following: in rrcllc_cphy_l1_req()
                    changed the MSG to also include L1 cmd type. In
                    rrcllc_pch_setup(), now check the return type for
                    rrcllc_copy_sib_to_oc(), check to see if the fach_included
                    flag is set in the pcch structure to see if need to
                    setup the FACH in MAC and L1. Copy the pointers to SCCPCH
                    and PCH/FACH parameters for MAC and L1 data. Moved
                    rrcllc_get_ul_tm_ccch_rlc_size() and rrc_ul_tx_pwr_ind()
                    to rrcllcoc.c Added rrcllc_rach_setup(). Changed
                    rrcllc_pch_setup() and rrcllc_pch_release() to take no
                    parameters.
05/09/01    vn      RRC_CHANNEL_CONFIG_REQ for PCCH comes from CCM. Changed
                    assumption about requesting procedure to CCM from CSP.
05/09/01    kmp     Updated to remove ordered config stubs and add the real
                    enchilada. Fix ARM compiler warnings.
05/04/01    ram     Added function rrcllc_is_ordered_config_set which checks
                    if ordered_config is set or not.
04/29/01    rj      Included rrcscmgr.h since rrc_get_state function is moved
                    to RRCSCMGR module from RRCTASK module.
04/09/01    kmp     Added support to Send L1 to "Idle" when initializing LLC.
                    No longer send a RRC_RESET_L1_CNF since Cell Selection does
                    not process it. Fixed a major bug in rrc_cmd_cnf().
04/04/01    kmp     Fixed a bug in rrcllc_init_ordered_config() which was introduced
                    with previous checkin.
04/02/01    kmp     Added support for rrc_ul_tx_pwr_ind() needed by L1 uplink.
03/30/01    ram     Included customer.h header file.
03/30/01    rj      Changed dl_sdu_num to uint32 from uint8 to be compatible
                    with latest LED based rrcasn1.h
03/29/01    kmp     Fixed a bug in rrcllc_cphy_setup_cnf(), and added the
                    processing of RRC_CRLC_DL_TM_CONFIG_CNF, RRC_CRLC_UL_TM_CONFIG_CNF,
                    RRC_CRLC_DL_UM_CONFIG_CNF, RRC_CRLC_UL_UM_CONFIG_CNF, and
                    RRC_CRLC_AM_CONFIG_CNF. General cleanup to general code format
                    of space settings. Changed a bunch of MSG_HIGH to MSG_MED.
                    Made major overhaul to allow for the new CRLC_?L_?M_CONFIG_CNFs.
                    New function rrcllc_crlc_config_cnf() is to handle the
                    various channel config cases. Moved local rrc data base structures
                    and all function prototypes to rrcllci.h.
03/27/01    rj      Renamed rrc_cnf_cmd to rrc_cmd_data_u_type.
03/15/01    upen    Generic funneling functionality added for L1, MAC and RLC for
                    REQ/CNF commands
                    Code cleanup of REQ/CNF specific funneling functions.
                    process_int_cmd() has been re-vamped.
                    idle, setup, tx-control reqs have been removed
03/08/01    ram     In the function rrc_process_int_cmd, set the flag llc_pendin
                    cnf to FALSE for these two commands - CPHY_CELL_PARM_REQ and
                    CPHY_MEASUREMENT_REQ.
02/07/01    upen    Added L1 funneling command support for the following:
                    CPHY_CAPABILITY_REQ,CPHY_CELL_PARM_REQ,CPHY_ASET_UPDATE_REQ,
                    CPHY_HARD_HANDOFF_REQ,CPHY_BCH_SCHEDULE_REQ,CPHY_DRX_REQ,
                    CPHY_CIPHERING_KEY_REQ,CPHY_MEASUREMENT_REQ,CPHY_CELL_SELECTION_REQ,
                    CPHY_IMMEDIATE_MEAS_REQ,CPHY_INTEGRITY_KEY_REQ,
                    CPHY_INTEGRITY_KEY_MAUC_REQ,CPHY_IMMEDIATE_RESELECTION_REQ,
                    CPHY_CELL_RESELECTION_RSP,CPHY_ACTION_CANCEL_REQ.
                    Also added CPHY_CELL_SELECTION_CNF funneling support.
02/06/01    ram     Some changes made previously were lost in the last check-in
                    due to a merge problem. Changed RLC_BCCH and RLC_PCCH to
                    UE_LOGCHAN_BCCH and UE_LOGCHAN_PCCH respectively.
02/02/01    kmp     Updated for ORDERED_CONFIG processing.
02/01/01    ram     RLC_BCCH and RLC_PCCH were replaced with UE_LOGCHAN_BCCH
                    and UE_LOGCHAN_PCCH respectively to comply with new
                    uecomdef.h definitions.
01/30/01    rj      RRCLCM_DCCH, RRCLCM_PCCH are replaced with UE_LOGCHAN_DCCH
                    UE_LOGCHAN_PCCH respectively. Similarily RRCLCM_TRANSPARENT
                    is replaced with UE_MODE_TRANSPARENT.
01/23/01    kmp     Major re-vamping for new design. This is where LLC now
                    takes all command and responses to L1, MAC, and RLC and
                    dispatches them to the appropriate procedure.
01/15/01    kmp     Updated to use new interface for L1, for CCTrCH/TRCH info.
12/18/00    kmp     Fixed by in pch_setup().
12/13/00    kmp     Fixed bug in rrcllc_cphy_setup_cnf(). Updated to include
                    new PCCH code. The rrcllc_cphy_setup_cnf() still does not
                    support all fields as defined in rrc_im_channel_cnf_type.
12/12/00    kmp     Added support for setting l1_bch_ptr->cmd_hdr.act_time=0;
                    when setting up the PCCPCH.
12/11/00    kmp     Fixed bugs in get_cctrch_id() and bch_setup().
                    Updated rrcllc_l1_cphy_setup_cnf() to use new data types
                    to indicate either SUCCESS (used to be TRUE) or FAILURE
                    (used to be FALSE).
12/08/00    ram     Updated to the new command queue interface for RRC. Since
                    The command queue type is no longer passed to the
                    procedures, used CMD_BASE_MASK to determine the command
                    queues from which commands were received. This is used for
                    debugging purposes.
12/01/00    kmp     Updated for rex++. Changed Events to commands. Added
                    pch_setup() and pch_release() functions.
11/30/00    rj      The filename rrclcp.h is changed to rrclcm_v.h. The text
                    rrclcp is replaced with rrclcm.
11/09/00    kmp     Updated for review comments. Added more messaging for
                    debugging purposes.
11/07/00    kmp     Updated to use the new lower layer events definitions.
                    Updated to fix various compiler warnings and typos.
10/31/00    kmp     Update to add release of MAC channels.
10/30/00    kmp     Update to add new RLC events definitions.
10/27/00    kmp     Initial Release.

===========================================================================*/


/*===========================================================================
                           INCLUDE FILES
===========================================================================*/
#include "wcdma_variation.h"
#include "comdef.h"
#include "customer.h"
#include "dsm.h"
#include "err.h"
#include "l1dlcctrchcfg.h"
#include "l1dlphychancfg.h"
#include "l1sapcommon.h"
#include "l1rrcif.h"
#include "l1task_v.h"
#include "l1ulcfg.h"
#include "seq.h"
#include "l2dltask.h"
#include "l2ultask.h"
#include "macrrcif_v.h"
#include "macl1rrcif.h"
#include "msg.h"
#include "queue.h"
#include "rex.h"
#include "rlcrrcif_v.h"
#include "rlcdsapif.h"
#include "rrcasn1.h"
#include "rrccmd_v.h"
#include "rrccmdi.h"
#include "rrcdata_v.h"
#include "rrclcm.h"
#include "rrcllc.h"
#include "rrcllci.h"
#include "rrcllcoc.h"
#include "rrcsibdb.h"
#include "uecomdef.h"
#include "rrcscmgr.h"
#include "rrcllcoc.h"
#include "rrccsp.h"
#include "rrccspi.h"
#include "rrcsibproc.h"
#include "rrcsmc.h"
#include "rrcmeas.h"
#include "rrcrce.h"
#include "event.h"
#include "rrctmr.h"
#include "rrcccm.h"
#include "rrcsmc.h"
#include "rrcmcm.h"
#include "rrcmisc.h"
#include "rrccui.h"
#include "rrccu.h"
#include "rrcsmc.h"
#include "rrcbmc.h"
#include "rrclbt.h"
#include "rrcrbcommon.h"
#include "rrcmeasi.h"
#ifdef FEATURE_DUAL_SIM
#include "rrcwrm.h"
#endif
#ifdef FEATURE_QCHAT
#include "rrc_qchatupk.h"
#endif /*FEATURE_QCHAT*/


#ifdef FEATURE_RRC_DELAY_ERR_FATAL
#include "l1extif.h"
#endif


#include "rrclogging.h"
#include "rrclog.h"

#ifdef FEATURE_WCDMA_HS_FACH
#include "rrcenhstatecfg.h"
#include "rrcenhstateproc.h"
#endif /*FEATURE_WCDMA_HS_FACH*/

#ifdef FEATURE_WCDMA_HANDLE_MDSP_HALT
#include "rrccho.h"
#endif
#include "rrcrcr.h"

boolean rrcllc_feature_hho_failure_handling = TRUE;

#ifdef TEST_FRAMEWORK
#error code not present
#endif

#ifdef FEATURE_WCDMA_HS_RACH
#include "rrchsrachcfg.h"
#include "rlcrrcif.h"
#endif

#include "rrcrbreconfig.h"
#include "rrcrbr.h"
#include "rrctcreconfig.h"
#include "rrcpcreconfig.h"

#ifdef FEATURE_WCDMA_FAST_RETURN_TO_LTE_AFTER_CSFB 
extern rrcrce_csfb_status_e_type csfb_extended_status;
#endif

/* Global to track last active cell capability */
rrc_cell_capability_type last_active_cell_capability = RRC_CELL_CAP_INACTIVE;

/* To track the change of TOC from TOC_FOR_OOS to TOC_FOR_DCH*/
/* Scenario - If OOS happens during reconfiguration from DCH to FACH
and RRC state is not yet changed from DCH to FACH. We rely on on TOC
usage to set the reconfig status indicator in CU. This logic will not 
work in this scenario because TOC usage is changed from TOC_FOR_OOS
to TOC_FOR_DCH.*/
boolean toc_usage_change_oos_to_dch = FALSE;
/*-------------------------------------------------------------------
This macro dequeues commands fromLLC command queue. For each dequeued
command, rrcllc_idle_handler() is called to process it. The commands
from LLC command queue are dequeued till there are no more commands
on the queue and as long as LLC state returned by rrcllc_idle_handler
is LLC_IDLE.
--------------------------------------------------------------------*/

#define WHILE_LLC_IDLE_DEQUEUE_CMD_CALL_HDLR    \
{                                               \
  while((rrcllc_current_substate == LLC_IDLE) &&   \
        (( (rrc_cmd_type *)q_check(&llc_cmd_q) ) != NULL))  \
  {                                               \
    if((llc_stored_cmd_ptr = (rrc_cmd_type *) q_get(&llc_cmd_q)) != NULL)  \
    {  \
      rrcllc_current_substate = rrcllc_idle_handler(llc_stored_cmd_ptr); \
      rrcllc_free_cmd_buf(llc_stored_cmd_ptr);                  \
    }  \
  }                                                           \
}

/*-------------------------------------------------------------------
This macro adds the passed on CCTrCH ID to the list of to-be-released
CCTrCH IDs.
--------------------------------------------------------------------*/
#define RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(cctrch_id)   \
{                                                         \
  rrcllc_cmd_under_process.chan_config.cctrch_id_release_list.        \
  id[rrcllc_cmd_under_process.chan_config.cctrch_id_release_list.num_ids] =  \
      (cctrch_id);                                               \
  rrcllc_cmd_under_process.chan_config.cctrch_id_release_list.num_ids ++;    \
}

/*-------------------------------------------------------------------
This macro calls the command processing engine function
based on the value of current_cmd_engine in rrcllc_cmd_under_process.
--------------------------------------------------------------------*/

#define RRCLLC_COMMAND_ENGINE(state, next_substate_ptr)                \
( (rrcllc_cmd_under_process.chan_config.current_cmd_engine == LLC_CHAN_CONFIG_ENGINE) ? \
   (rrcllc_chan_config_engine(state, next_substate_ptr)) :             \
   ((rrcllc_cmd_under_process.chan_config.current_cmd_engine == LLC_RELEASE_ALL_CHAN_ENGINE) ? \
     (rrcllc_release_all_chan_engine(state, next_substate_ptr)) : \
     ((rrcllc_cmd_under_process.chan_config.current_cmd_engine == LLC_CELL_RESELECTION_ENGINE) ? \
       (rrcllc_cell_reselection_engine(state, next_substate_ptr)) : \
       ((rrcllc_cmd_under_process.chan_config.current_cmd_engine == LLC_STOP_WCDMA_MODE_ENGINE) ? \
         (rrcllc_stop_wcdma_mode_engine(state, next_substate_ptr)) : \
         (rrcllc_deactivation_engine(state, next_substate_ptr))       \
       )                                                          \
     )                                                            \
   )                                                              \
)


/*-------------------------------------------------------------------
This macro translates the loopback test mode from the RRC defined
values to L1 defined enum values.
--------------------------------------------------------------------*/
#define RRCLLC_XLATE_LBT_MODE(rrc_lbt_mode)             \
  (((rrc_lbt_mode) == LB_TEST_MODE_NONE) ? L1_LOOPBACK_NA :  \
     (((rrc_lbt_mode) == LB_TEST_MODE_1) ?  L1_LOOPBACK_MODE_1 : L1_LOOPBACK_MODE_2))

/*-------------------------------------------------------------------*/



/*===================================================================
                        DATA DECLARATIONS
=====================================================================*/

/********************************************************************
* RRC LLC Internal Queue Mgmt data
*********************************************************************/
/*-------------------------------------------------------------------
This is a queue to buffer commands to be processed by the Lower Layer
controller. These items are first copied from the RRC internal queue,
buffered here, and then formatted and sent to L1, MAC and RLC.
--------------------------------------------------------------------*/
LOCAL q_type                      llc_cmd_q;

/* For debugging RRC's command queues */
#ifdef FEATURE_RRC_CMD_Q_DEBUG
#error code not present
#endif /* FEATURE_RRC_CMD_Q_DEBUG */


/********************************************************************
* End RRC LLC Internal Queue Mgmt data.
*********************************************************************/

/********************************************************************
* RRC LLC CCTrCH ID Mgmt data.
*********************************************************************/
/*-------------------------------------------------------------------
This is a list CCTrCH IDs. If the CCTrCH Id is in use, the value
for a given index is set to TRUE. The "-1" is to allow for L1 to
allocate a CCTrCH ID for neighbor BCCHs.
--------------------------------------------------------------------*/
LOCAL boolean                cctrch_id_in_use[UE_MAX_CCTRCH - 1];

/********************************************************************
* End RRC LLC CCTrCH ID Mgmt data.
*********************************************************************/
/* Backup DB for RNTI during reselction if reslection fails*/
LOCAL mac_rnti_config_type                rrc_backup_rnti_info;
/* Stores the current state of LLC */
rrcllc_substate_e_type  rrcllc_current_substate;
#ifdef FEATURE_WCDMA_HANDLE_MDSP_HALT
/*Store LLC previous substate, and the usage should be restricted till Recover CNF only*/
LOCAL  rrcllc_substate_e_type  rrcllc_prev_current_substate;
#endif

/* Stores data pertaining to the current RRC internal command
 * under process.
 */
rrcllc_rrc_cmd_process_data_type  rrcllc_cmd_under_process;

rrcllc_rlc_config_req_list_type  rlc_rel_list;

/* This stores semi permamnent data for various Physical channels */
rrcllc_semi_permanent_data_type  rrcllc_semi_permanent_data;

/* Local storage of RLC data for the purpose of RLC re-establishment */
rlc_am_config_req_type rlc_am_config_for_re_est;
rlc_ul_um_config_type  rlc_ul_um_config_for_re_est;
rlc_dl_um_config_type  rlc_dl_um_config_for_re_est;

/* This structure is maintained by SMC. LLC accesses this structure while
 * re-configuring the lower layers with ciphering information
 */
extern rrcsmc_ciphering_config_info_type cipher_config_db;

uint32 curr_sccpch_index = 0;

LOCAL boolean rrcllc_rlc_cipher_update_needed = FALSE; /*flag to indicate if UM/AM RB's are setup*/

static uint8 seq_num = 0;

boolean compressed_mode_fail_status = FALSE;

boolean rrcllc_recvd_deact_req_waiting_for_resume_cnf = FALSE;

#ifdef FEATURE_WCDMA_HANDLE_MDSP_HALT
boolean dch_state_handling_needed = TRUE;
#endif



boolean rrcllc_build_cmd_and_release_lc_ids(void);
boolean rrcllc_phy_chan_failure_handling_restrictions (void);

uecomdef_status_e_type
rrcllc_command_engine(
  rrcllc_substate_e_type state,
  rrcllc_substate_e_type *next_substate_ptr
  );

rrcllc_substate_e_type
rrcllc_idle_handler(rrc_cmd_type *cmd_ptr);

uecomdef_status_e_type
rrcllc_send_rrc_channel_config_cnf
(
 rrc_proc_e_type               proc_type,
 uint32                        transaction_id,
 rrcllc_chan_cfg_status_e_type chan_cfg_status
);


/* -----------------------------------------------------------------------
** Forward Declarations
** ----------------------------------------------------------------------- */



/*===========================================================================
** -----------------------------------------------------------------------------------
**-- ----------NON-Demand paging section Srart--------------------------------------------
** -----------------------------------------------------------------------------------
  This section will have code section that will not be demand paged. Function which should be in this section are
  -RRC functions that are called by L1/L2 which are higher priority then RRC
  -RRC functions that are called in ISR context or RTOS timer call back
  -RRC functions that indirectly gets called by L1/L2 /ISR/timer call back   
  For example: Fun1() gets called by L1. Fun2() is called by Fun1(). Now both  Fun1() & Fun2() should be NON demand paged, 
  so both should be added in this section  
  Usage of pragma 
  __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED__
  void foo(void)
  {
    function body here
  }
        __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED_END__
  If you have another function to be added in the same section then again it needs to be wrapped with these pragma 
  for example:- function bar() is just below function foo() then function bar() needs to be written like this …. 
  __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED__
  void bar(void)
  {
    function body here
  }
  __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED_END__
** ----------------------------------------------------------------------- */


/*====================================================================
FUNCTION: rrcllc_get_n_bcch_setup_status()

DESCRIPTION:
  This function will return N-BCCH set up status.
  It will return TRUE if N-BCCH is set up FALSE other wise

DEPENDENCIES:
  None.

RETURN VALUE:
  TRUE : If N-BCCH is set up
  FALSE otherwise
SIDE EFFECTS:
  None.

=====================================================================*/
/***/ __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED__ /***/

boolean rrcllc_get_n_bcch_setup_status(void)
{
  boolean n_bcch_setup_status = FALSE;
  if((rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch_is_up == TRUE)&&
    ((rrclcm_check_dl_rlc_lc_id( UE_LOGCHAN_BCCH,
                                    BCCH_N_RADIO_BEARER_ID,
                                    UE_MODE_TRANSPARENT ))
        != RRCLCM_RLC_LC_ID_NOT_FOUND )
    )
  {
    n_bcch_setup_status = TRUE;
  }
  return n_bcch_setup_status;
}
/***/ __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED_END__ /***/

/*====================================================================
FUNCTION: rrcllc_get_s_bcch_setup_status()

DESCRIPTION:
  This function will return S-BCCH set up status.
  It will return TRUE if S-BCCH is set up FALSE other wise

DEPENDENCIES:
  None.

RETURN VALUE:
  TRUE : If S-BCCH is set up
  FALSE otherwise
SIDE EFFECTS:
  None.

=====================================================================*/
/***/ __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED__ /***/
boolean rrcllc_get_s_bcch_setup_status(void)
{
  boolean s_bcch_setup_status = FALSE;
  if((rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up == TRUE)&&
    ((rrclcm_check_dl_rlc_lc_id( UE_LOGCHAN_BCCH,
                                    BCCH_S_RADIO_BEARER_ID,
                                    UE_MODE_TRANSPARENT ))
        != RRCLCM_RLC_LC_ID_NOT_FOUND )
    )
  {
    s_bcch_setup_status = TRUE;
  }
  return s_bcch_setup_status;
}
/***/ __WCDMA_RRC_CODE_SEGMENT_NON_DEMANDPAGED_END__ /***/
/*====================================================================
FUNCTION: rrcllc_free_cmd_buf()

DESCRIPTION:
  This function frees a command buffer removed from the LLC command
  queue. Only commands removed from the LLC command queue can be
  passed into this function.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.

=====================================================================*/
static void rrcllc_free_cmd_buf
(
  rrc_cmd_type *cmd_buf    /* Command Buffer */
)
{
  if(cmd_buf->cmd_hdr.cmd_id == RRC_LLC_CMD_REQ)
  {
    rrccmd_free_internal_req_ptr(cmd_buf);
  }
   
#ifdef FEATURE_RRC_CMD_Q_DEBUG
  #error code not present
#endif /* FEATURE_RRC_CMD_Q_DEBUG */

  
  rrc_free( cmd_buf );


  return;
} /* rrcllc_free_cmd_buf() */

/*====================================================================
FUNCTION: rrcllc_dequeue_cmd()

DESCRIPTION:
  This function dequeues commands from LLC command queue
DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.

=====================================================================*/
void rrcllc_dequeue_cmd
(
  void
)
{
  rrc_cmd_type* llc_stored_cmd_ptr;

  WRRC_MSG1_HIGH("Q count: %d.  D-Q-ing from LLC cmd Q.", q_cnt(&llc_cmd_q));
  while((rrcllc_current_substate == LLC_IDLE) &&   
        (( (rrc_cmd_type *)q_check(&llc_cmd_q) ) != NULL))  
  {
    if((llc_stored_cmd_ptr = (rrc_cmd_type *) q_get(&llc_cmd_q))!= NULL)
    {
      rrcllc_current_substate = rrcllc_idle_handler(llc_stored_cmd_ptr); 
      rrcllc_free_cmd_buf(llc_stored_cmd_ptr);
    }
  }    
}

/*====================================================================
FUNCTION: rrcllc_reset_toc_usage_change_oos_to_dch()

DESCRIPTION:
  This function resets the value of toc_usage_change_oos_to_dch

DEPENDENCIES:
  None.

RETURN VALUE:
 boolean

SIDE EFFECTS:
  None.

=====================================================================*/
void rrcllc_reset_toc_usage_change_oos_to_dch()
{
  toc_usage_change_oos_to_dch=FALSE;
}
/*====================================================================
FUNCTION: rrcllc_get_toc_usage_change_oos_to_dch()

DESCRIPTION:
  This function returns the value of toc_usage_change_oos_to_dch

DEPENDENCIES:
  None.

RETURN VALUE:
 boolean

SIDE EFFECTS:
  None.

=====================================================================*/
boolean rrcllc_get_toc_usage_change_oos_to_dch()
{
  return toc_usage_change_oos_to_dch;
}
/*====================================================================
FUNCTION: rrcllc_copy_mac_cipher_config()

DESCRIPTION:
  This function copies the MAC cipher config present in 'cipher_config_db' to
  passed argument.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.

=====================================================================*/
static void rrcllc_copy_mac_cipher_config
(
  mac_cipher_config_type cipher_info[MAX_CN_DOMAIN]
)
{
  uint8 i=0;

  /* Update ciphering information using the global ciphering database maitained by SMC */
  for(i=0; i<RRC_MAX_CN_DOMAINS; i++)
  {
    cipher_info[i] = cipher_config_db.mac_cipher_info[i];
  }
}
/*====================================================================
FUNCTION: rrcllc_clear_config_all_db()

DESCRIPTION:
  This function is called to clear are the DB while going to disconnected

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.

=====================================================================*/
static void rrcllc_clear_config_all_db
(
  void
)
{
  
  if(current_config_ptr == NULL)
  {
    WRRC_MSG0_ERROR("CC/OC/TOC already freed.");
    return;
  }

  /* Initialize Ordered and Current Configs */
  rrcllc_init_ordered_config_status_and_data(RRC_STATE_DISCONNECTED);
  rrcllc_init_config_data(current_config_ptr, RRC_STATE_DISCONNECTED);
  
  /* Initialize Transition Config */
  rrcllc_init_config_data(transition_config.toc_ptr, RRC_STATE_DISCONNECTED);
  transition_config.toc_usage = TOC_INVALID;
  
   toc_usage_change_oos_to_dch = FALSE; 
  /* Clear RLC Logical Channel Info in LCM */
  rrclcm_clear_rlc_lc_info();
  /* Initialize LLC and initialize Command under process */
  rrcllc_init(RRCLLC_RE_INIT_FREE_Q);
  
}
/*====================================================================
FUNCTION: rrcllc_free_cmd_and_embedded_buf()

DESCRIPTION:
  This function frees an embedded pointer (if any) before freeing the
  command buffer for the command removed from the LLC command
  queue. Only commands removed from the LLC command queue can be
  passed into this function.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.

=====================================================================*/
static void rrcllc_free_cmd_and_embedded_buf
(
  rrc_cmd_type *cmd_buf    /* Command Buffer */
)
{
  if(cmd_buf->cmd_hdr.cmd_id == RRC_LLC_CMD_REQ)
  {
   rrc_free_embedd_buf_llc_req(cmd_buf);
  }
#ifdef FEATURE_RRC_CMD_Q_DEBUG
  #error code not present
#endif /* FEATURE_RRC_CMD_Q_DEBUG */

  rrc_free( cmd_buf );
  return;
} /* rrcllc_free_cmd_and_embedded_buf() */

/*====================================================================
FUNCTION: rrcllc_check_for_pccpch_mismatch()

DESCRIPTION:
  This function checks if there is PCCPCH mismatch between L1 and RRC

DEPENDENCIES:
  With L1 API

RETURN VALUE:
None

SIDE EFFECTS:
  None.
====================================================================*/

void rrcllc_check_for_pccpch_mismatch
(
  void
)
{

   /* Skip validation for mdsp recovery case as WL1 can any fail any cphy setup including PCCPCH drop */
  if((rrc_get_state() == RRC_STATE_DISCONNECTED) || wl1_is_l1_in_mdsp_recovery())
    return;

  if(
      (rrcllc_cmd_under_process.valid) &&
      (rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action == LLC_PHYCHAN_RELEASE)&&
      (rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[rrcllc_cmd_under_process.chan_config.l1_req_list.current_l1_req].
        cmd.setup.req_mask == CPHY_DL_PHYCHAN_DROP_INCL)&&
      (rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[rrcllc_cmd_under_process.chan_config.l1_req_list.current_l1_req].
        cmd.setup.drop_dl_phychan == L1_DL_PHYCHAN_PCCPCH_S)
    )
  {
    if(dlchmgr_is_ext_pccpch_active())
    {
      ERR_FATAL("SBCCH Drop went wrong at L1, dlchmgr_is_ext_pccpch_active: %d ",
             rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up,
             dlchmgr_is_ext_pccpch_active(),0);
    }
  }
}

/*====================================================================
FUNCTION: rrcllc_send_rrc_cell_reselection_cnf()

DESCRIPTION:
  This function constructs the RRC_CELL_RESELECTION_CNF primitive and
  sends it to the passed RRC procedure.

DEPENDENCIES:
  None

RETURN VALUE:
  uecomdef_status_e_type -> indicating a SUCCESS or FAILURE

SIDE EFFECTS:
  None.
====================================================================*/
static uecomdef_status_e_type
rrcllc_send_rrc_cell_reselection_cnf
(
  uecomdef_status_e_type status
)
{
  rrc_cmd_type  *rrc_cmd_ptr = rrc_get_int_cmd_buf();
  boolean hs_status_in_oc = FALSE; 
  boolean hs_status_in_cc = FALSE; 
  boolean hs_status_in_resel_ptr = FALSE;

#ifdef FEATURE_WCDMA_HS_FACH
  hs_status_in_oc = rrcllc_get_hs_status_in_e_fach(ordered_config_ptr);
  hs_status_in_cc = rrcllc_get_hs_status_in_e_fach(current_config_ptr);
#endif

  WRRC_MSG2_HIGH("Sending RRC_RESELECTION_CNF status: %d procedure %d",status,rrcllc_cmd_under_process.procedure);

  /* Fill in the local command header.*/
  rrc_cmd_ptr->cmd_hdr.cmd_id = RRC_CELL_RESELECTION_CNF;
  rrc_cmd_ptr->cmd.cell_resel_cnf.status = status;
  if((status == FAILURE ) && 
    (rrcllc_cmd_under_process.chan_config.current_cmd_engine == LLC_CELL_RESELECTION_ENGINE)
    && (rrc_get_state() == RRC_STATE_CELL_FACH ))
  {
    /*Restore the URNTI to the OC as it is still valid*/
    if (rrc_backup_rnti_info.rnti_valid != NO_RNTI_VALID)   
    {
      MSG_HIGH("Restore  CC & OC RNTI status %d CRNTI %d URNTI %d ", 
               rrc_backup_rnti_info.rnti_valid,rrc_backup_rnti_info.crnti,rrc_backup_rnti_info.urnti);
      /* copy the rnti information to both oc and cc */
      ordered_config_ptr->mac_dl_parms.rnti_info =
             current_config_ptr->mac_dl_parms.rnti_info=  rrc_backup_rnti_info;
      ordered_config_ptr->mac_ul_parms.rnti_info =
            current_config_ptr->mac_ul_parms.rnti_info = rrc_backup_rnti_info;
    }   
  }

  if(reselection_config_ptr != NULL)
  {

#ifdef FEATURE_WCDMA_HS_FACH

    hs_status_in_resel_ptr = rrcllc_get_hs_status_in_e_fach(reselection_config_ptr);

    if((status == FAILURE) && (rrcllc_cmd_under_process.chan_config.current_cmd_engine == 
          LLC_CELL_RESELECTION_ENGINE) )
    {
      if(config_ptr_in_use == ORDERED_CONFIG)
      {
        if((current_config_ptr->hs_status_in_e_fach == FALSE) && 
             (reselection_config_ptr->hs_status_in_e_fach == TRUE))
        {

          rrcllc_set_hs_status_in_e_fach(reselection_config_ptr,FALSE);
        }
      }
      else if(config_ptr_in_use == CURRENT_CONFIG)
      {
        if((ordered_config_ptr->hs_status_in_e_fach == FALSE) && 
             (reselection_config_ptr->hs_status_in_e_fach == TRUE))
        {
          rrcllc_set_hs_status_in_e_fach(reselection_config_ptr,FALSE);
        }
      }
    }

    if(status == SUCCESS)
    {
      /*To be on safer side, set HS status in FACH to FALSE here.*/
        /*This is when UE reselects from EFACH-> nonEFACH cell. If HSDPA L1 operation is STOP(rrcenhstate_add_cell_trans_info)
            when CELL TRANS REQ is sent we need to update the HS status in EFACH in OC
            Ref CR:354299*/
      if((reselection_config_ptr->hs_action_in_e_fach == HSDPA_STOP)&&
         (rrcenhstate_camped_cell_supports_e_fach() == FALSE))
      {
        rrcllc_set_hs_status_in_e_fach(ordered_config_ptr, FALSE);
        rrcllc_set_hs_status_in_e_fach(current_config_ptr, FALSE);
      }
      rrcllc_set_hs_action_in_e_fach(reselection_config_ptr, HSDPA_NOOP);
      reselection_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_NOOP;
  
#ifdef FEATURE_WCDMA_HS_RACH

      /*This is when UE reselects from HSRACH-> nonHSRACH cell. 
      Update common_edch_transmission to FALSE*/
      if((reselection_config_ptr->l1_hs_rach_req_mask == L1_HS_RACH_STOP)&&
         (rrchsrach_camped_cell_supports_hsrach() == FALSE))
      {
        rrchsrach_set_common_edch_transmission(ordered_config_ptr, FALSE);
        rrchsrach_set_common_edch_transmission(current_config_ptr, FALSE);
      }
      rrcllc_reset_mac_and_l1_for_hsrach_config_ptr(reselection_config_ptr);

#endif /*FEATURE_WCDMA_HS_RACH*/
    }
#endif /*FEATURE_WCDMA_HS_FACH*/

    if(status == SUCCESS && 
       rrc_get_state() == RRC_STATE_CELL_FACH 
     && 
       ((ordered_config.set_status == OC_SET_FOR_DCH_FACH_TRANS)
        ||
        /* DCH FACH Timer expiry case with reselection during CU */
       (rrcllc_get_toc_usage_change_oos_to_dch() == TRUE))
     &&
       ordered_config.process_state == LL_CONFIG_WITH_OC)
    {
      /*Config pointer in use is CC due to swap by reselection*/

      /*Legacy to Legacy : config pointer in use needs to be set to OC as it contains all the updated info */
      if(hs_status_in_oc == FALSE &&
         hs_status_in_cc == FALSE )
      {
        config_ptr_in_use = ORDERED_CONFIG;
      }
      else if(hs_status_in_oc != hs_status_in_cc)
      {
        /* HSFACH to legacy: Need to bring all the updated info into OC as there is no chan config by CU
           in legacy cells*/
        if(hs_status_in_resel_ptr == FALSE)
        {
          rrcllc_swap_oc_and_cc();
          config_ptr_in_use = ORDERED_CONFIG;
        }
        else /* Legacy to HSFACH: As there is channel config through CU in HSFACH cell, need to make sure CC
                has all the updated info*/
        {
          rrcllc_swap_oc_and_cc();
        }
      }
    }
  }
  if((status == SUCCESS ) && 
        (
          (rrc_get_state() == RRC_STATE_CELL_FACH ) 
          || 
          (rrc_get_state() == RRC_STATE_CELL_PCH ) 
          ||
          (rrc_get_state() == RRC_STATE_URA_PCH )
        )
    )
  {
    /*Store the old cell capability */
    rrcllc_store_last_active_cell_capability();
  }


  memset(&rrc_backup_rnti_info,0,sizeof(mac_rnti_config_type));
  /* Send the internal command */
  rrc_put_int_cmd(rrc_cmd_ptr);

  return(SUCCESS);
} /* rrcllc_send_rrc_cell_reselection_cnf */

/*====================================================================
FUNCTION: rrcllc_init_cctrch_id()

DESCRIPTION:
  This function initializes the RRC CCTRCH Data base. All CCTRCH IDs
  are marked as available for use.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_init_cctrch_id
(
  void
)
{
  int cctrch_id; /* local loop variable */

  WRRC_MSG0_HIGH("Initializing the CCTrCH Id Data Base");

  /* check for a valid CCTrCH ID */
  for(cctrch_id = 0; cctrch_id < (UE_MAX_CCTRCH-1); cctrch_id++)
  {
      cctrch_id_in_use[cctrch_id] = FALSE;
    }

  return;
} /* end rrcllc_init_cctrch_id() */

/*============================================================================
FUNCTION: rrcllc_set_cpc_dtx_action_to_stop_if_cpc_dtx_active()

DESCRIPTION:
  This function updates the l1_dtx_req_mask with stop to be sent to L1.
  If "clear_all_config_pointers" is TRUE then L1-CPC DTX info from all the config
  pointers will be cleared.
  This function is called whenever UE goes to idle/FACH un-expectedly(without
  involvement of RRC and during w2g handover).

DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
void rrcllc_set_cpc_dtx_action_to_stop_if_cpc_dtx_active
(
  boolean clear_all_config_pointers
)
{

  WRRC_MSG8_MED("RRCCPC: Stop dtx/drx if accitve : config_ptr_in_use %d (0:OC/1:CC/2:TOC), clear_all_config_pointers %d, OC DTX status: %d, OC DRX status: %d, CC DTX status: %d, CC DRX status: %d, TOC DTX status: %d, TOC DRX status: %d",
    config_ptr_in_use, clear_all_config_pointers,
    ordered_config_ptr->cpc_dtx_drx_status,ordered_config_ptr->cpc_drx_status,
    current_config_ptr->cpc_dtx_drx_status,current_config_ptr->cpc_drx_status,
    transition_config.toc_ptr->cpc_dtx_drx_status,transition_config.toc_ptr->cpc_drx_status);

  if (ORDERED_CONFIG == config_ptr_in_use)
  {
    if (TRUE == ordered_config_ptr->cpc_dtx_drx_status)
    {
      ordered_config_ptr->l1_cpc_dtx_req_mask= L1_CPC_DTX_STOP;
      ordered_config_ptr->l1_hs_scch_order_action = L1_HS_SCCH_ORDER_ACTION_BACKUP_AND_DISCARD;

      if(rrcllc_get_l1_cpc_drx_status(ordered_config_ptr) == TRUE)
      {
        ordered_config_ptr->l1_cpc_drx_req_mask = L1_CPC_DRX_STOP;
      }

      rrcllc_init_dtx_params(ordered_config_ptr);
      if(clear_all_config_pointers == TRUE)
      {
        current_config_ptr->l1_cpc_dtx_req_mask = L1_CPC_DTX_STOP;

        current_config_ptr->l1_hs_scch_order_action = L1_HS_SCCH_ORDER_ACTION_BACKUP_AND_DISCARD;

        if(rrcllc_get_l1_cpc_drx_status(current_config_ptr) == TRUE)
        {
          current_config_ptr->l1_cpc_drx_req_mask = L1_CPC_DRX_STOP;
        }

        rrcllc_init_dtx_params(current_config_ptr);

        if(rrcllc_get_l1_cpc_drx_status(transition_config.toc_ptr) == TRUE)
        {
          transition_config.toc_ptr->l1_cpc_drx_req_mask = L1_CPC_DRX_STOP;
        }

        transition_config.toc_ptr->l1_cpc_dtx_req_mask= L1_CPC_DTX_STOP;

        transition_config.toc_ptr->l1_hs_scch_order_action = 
          L1_HS_SCCH_ORDER_ACTION_BACKUP_AND_DISCARD;

        rrcllc_init_dtx_params(transition_config.toc_ptr);
      }
    }
  }
  else if(CURRENT_CONFIG == config_ptr_in_use)
  {
    if (TRUE == current_config_ptr->cpc_dtx_drx_status)
    {
      current_config_ptr->l1_cpc_dtx_req_mask = L1_CPC_DTX_STOP;

      current_config_ptr->l1_hs_scch_order_action = L1_HS_SCCH_ORDER_ACTION_BACKUP_AND_DISCARD;

      if(rrcllc_get_l1_cpc_drx_status(current_config_ptr) == TRUE)
      {
        current_config_ptr->l1_cpc_drx_req_mask = L1_CPC_DRX_STOP;
      }

      rrcllc_init_dtx_params(current_config_ptr);
      if(clear_all_config_pointers == TRUE)
      {
        ordered_config_ptr->l1_cpc_dtx_req_mask = L1_CPC_DTX_STOP;

        ordered_config_ptr->l1_hs_scch_order_action = L1_HS_SCCH_ORDER_ACTION_BACKUP_AND_DISCARD;

        if(rrcllc_get_l1_cpc_drx_status(ordered_config_ptr) == TRUE)
        {
          ordered_config_ptr->l1_cpc_drx_req_mask = L1_CPC_DRX_STOP;
        }

        rrcllc_init_dtx_params(ordered_config_ptr);
        transition_config.toc_ptr->l1_cpc_dtx_req_mask = L1_CPC_DTX_STOP;

        transition_config.toc_ptr->l1_hs_scch_order_action = 
          L1_HS_SCCH_ORDER_ACTION_BACKUP_AND_DISCARD;

        if(rrcllc_get_l1_cpc_drx_status(transition_config.toc_ptr) == TRUE)
        {
          transition_config.toc_ptr->l1_cpc_drx_req_mask = L1_CPC_DRX_STOP;
        }

        rrcllc_init_dtx_params(transition_config.toc_ptr);
      }
    }
  }
  else
  {
    WRRC_MSG0_ERROR("RRCCPC:config_ptr_in_use set to TOC un-expectedly. Check..");
  }
}



/*============================================================================
FUNCTION: rrcllc_set_mac_eul_action_to_stop_if_eul_is_active()

DESCRIPTION:
  This function updates the mac_eul_action with stop to be sent to MAC.
  This function also clears L1-E info with e_dch_transmission variable.
  If "clear_all_config_pointers" is TRUE then L1-E info from all the config
  pointers will be cleared.
  This function is called whenever UE goes to idle/FACH un-expectedly(without
  involvement of RRC and during w2g handover).

DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
static void rrcllc_set_mac_eul_action_to_stop_if_eul_is_active
(
  boolean clear_all_config_pointers
)
{
  boolean is_eul_active_at_mac = mac_is_eul_active();
  WRRC_MSG5_MED("RRCEUL: EUL if accitve : config_ptr_in_use %d (0:OC/1:CC/2:TOC), clear_all_config_pointers %d, OC EDCH status: %d, CC EDCH status: %d MAC EUL status %d",
    config_ptr_in_use, clear_all_config_pointers,
    ordered_config_ptr->e_dch_transmission,
    current_config_ptr->e_dch_transmission,
    is_eul_active_at_mac);
    
  if (ORDERED_CONFIG == config_ptr_in_use)
  {
    if ((ordered_config_ptr->e_dch_transmission == TRUE)
        ||
        (is_eul_active_at_mac == TRUE))
    {
      ordered_config_ptr->mac_eul_action = MAC_EUL_STOP;
      ordered_config_ptr->e_dch_transmission = FALSE;
      ordered_config_ptr->mac_e_reset_indicator = TRUE;
      ordered_config_ptr->mac_e_tsn_action = MAC_E_TSN_ACTION_BACKUP;
    }
#ifdef FEATURE_WCDMA_16_QAM	
    if (TRUE == ordered_config_ptr->l1_e_info.e_ul_info.e_ul_16qam_action)
    {
      ordered_config_ptr->l1_e_info.e_ul_info.e_ul_16qam_action = FALSE;
      ordered_config_ptr->l1_e_info.e_ul_info.e_ul_16qam_e_agch_table_idx = 0;
    }
#endif
    /* clean up L1 E info - this should be cleaned up ir-respective of 
       e_dch_transmission */
    rrcllc_init_l1_e_ul_info(FALSE, ordered_config_ptr);
    rrcllc_init_l1_e_dl_info(FALSE, FALSE, ordered_config_ptr);

    if (TRUE == clear_all_config_pointers)
    {
      /* clear current config */
      rrcllc_init_l1_e_ul_info(FALSE, current_config_ptr);
      rrcllc_init_l1_e_dl_info(FALSE, FALSE, current_config_ptr);
      /* clear toc */
      rrcllc_init_l1_e_ul_info(FALSE, transition_config.toc_ptr);
      rrcllc_init_l1_e_dl_info(FALSE, FALSE, transition_config.toc_ptr);
    }
  }
  else if (CURRENT_CONFIG == config_ptr_in_use)
  {
    if ((current_config_ptr->e_dch_transmission == TRUE)
        ||
        (is_eul_active_at_mac == TRUE))
    {
      current_config_ptr->mac_eul_action = MAC_EUL_STOP;
      current_config_ptr->e_dch_transmission = FALSE;
      current_config_ptr->mac_e_reset_indicator = TRUE;
      current_config_ptr->mac_e_tsn_action = MAC_E_TSN_ACTION_BACKUP;
    }
#ifdef FEATURE_WCDMA_16_QAM	
    if (TRUE == current_config_ptr->l1_e_info.e_ul_info.e_ul_16qam_action)
    {
      current_config_ptr->l1_e_info.e_ul_info.e_ul_16qam_action = FALSE;
      current_config_ptr->l1_e_info.e_ul_info.e_ul_16qam_e_agch_table_idx = 0;
    }
#endif
    /* clean up L1 E info */
    rrcllc_init_l1_e_ul_info(FALSE, current_config_ptr);
    rrcllc_init_l1_e_dl_info(FALSE, FALSE, current_config_ptr);

    if (TRUE == clear_all_config_pointers)
    {
      /* clear current config */
      rrcllc_init_l1_e_ul_info(FALSE, ordered_config_ptr);
      rrcllc_init_l1_e_dl_info(FALSE, FALSE, ordered_config_ptr);
      /* clear toc */
      rrcllc_init_l1_e_ul_info(FALSE, transition_config.toc_ptr);
      rrcllc_init_l1_e_dl_info(FALSE, FALSE, transition_config.toc_ptr);
    }
  }
  else /* pointer in use is TOC */
  {
    /* HSDPA also has the same issue if we hit this error-fatal - want to capture the same */
    ERR_FATAL("RRCEUL: config_ptr_in_use set to TOC un-expectedly. Check..", 0, 0, 0);
  }
}
#ifdef FEATURE_WCDMA_DC_HSUPA
/*============================================================================
FUNCTION: rrcllc_set_mac_sec_eul_action_to_stop_if_eul_is_active()

DESCRIPTION:  This function updates the mac_sec_eul_action with stop to be sent to MAC.
  This function also clears L1-SEC E info with e_dch_transmission variable and SEC DL FDPCH info.
  If "clear_all_config_pointers" is TRUE then L1-E info from all the config
  pointers will be cleared.
  This function is called whenever UE goes to idle/FACH un-expectedly(without
  involvement of RRC and during w2g handover).

DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
static void rrcllc_set_mac_sec_eul_action_to_stop_if_eul_is_active
(
  boolean clear_all_config_pointers
)
{
  WRRC_MSG4_MED("RRCEUL: EUL if accitve : config_ptr_in_use %d (0:OC/1:CC/2:TOC), clear_all_config_pointers %d, OC SEC EDCH status: %d, CC SEC EDCH status: %d",
    config_ptr_in_use, clear_all_config_pointers,
    ordered_config_ptr->sec_e_dch_transmission,
    current_config_ptr->sec_e_dch_transmission);

  if (ORDERED_CONFIG == config_ptr_in_use)
  {
    /*For few scenaros like fach to dch sync failure OC may not have the sec edch status
      as copy cc to oc overwirtes. MAC API is used to simplify the fix and cover other corner
      scenarios  */
    if ((TRUE == ordered_config_ptr->sec_e_dch_transmission) || (mac_hs_ul_is_sec_carrier_active()))
    {
      ordered_config_ptr->mac_sec_eul_action = MAC_SEC_EUL_STOP;
      ordered_config_ptr->sec_e_dch_transmission = FALSE;
      ordered_config_ptr->mac_e_reset_indicator = TRUE;
      ordered_config_ptr->mac_e_tsn_action = MAC_E_TSN_ACTION_BACKUP;
    }

    /* clean up L1 E info - this should be cleaned up ir-respective of 
       sec_e_dch_transmission */
    rrcllc_init_l1_sec_e_ul_info( ordered_config_ptr);
    rrcllc_init_l1_sec_e_dl_info(FALSE, FALSE, ordered_config_ptr);
    rrcllc_init_l1_dl_sec_fdpch_chan_info(ordered_config_ptr);

    if (TRUE == clear_all_config_pointers)
    {
      /* clear current config */
      rrcllc_init_l1_sec_e_ul_info( current_config_ptr);
      rrcllc_init_l1_sec_e_dl_info(FALSE, FALSE, current_config_ptr);      
      rrcllc_init_l1_dl_sec_fdpch_chan_info(current_config_ptr);
      /* clear toc */
      rrcllc_init_l1_sec_e_ul_info(transition_config.toc_ptr);
      rrcllc_init_l1_sec_e_dl_info(FALSE, FALSE, transition_config.toc_ptr);      
      rrcllc_init_l1_dl_sec_fdpch_chan_info(transition_config.toc_ptr);
    }
  }
  else if (CURRENT_CONFIG == config_ptr_in_use)
  {
        /*For few scenaros like fach to dch sync failure OC may not have the sec edch status
      as copy cc to oc overwirtes. MAC API is used to simplify the fix and cover other corner
      scenarios  */
    if ((TRUE == current_config_ptr->sec_e_dch_transmission) || (mac_hs_ul_is_sec_carrier_active()))
    {
      current_config_ptr->mac_sec_eul_action = MAC_SEC_EUL_STOP;
      current_config_ptr->sec_e_dch_transmission = FALSE;
      current_config_ptr->mac_e_reset_indicator = TRUE;
      current_config_ptr->mac_e_tsn_action = MAC_E_TSN_ACTION_BACKUP;
    }

    /* clean up L1 E info */
    rrcllc_init_l1_sec_e_ul_info(current_config_ptr);
    rrcllc_init_l1_sec_e_dl_info(FALSE, FALSE, current_config_ptr);    
    rrcllc_init_l1_dl_sec_fdpch_chan_info(current_config_ptr);

    if (TRUE == clear_all_config_pointers)
    {
      /* clear current config */
      rrcllc_init_l1_sec_e_ul_info( ordered_config_ptr);
      rrcllc_init_l1_sec_e_dl_info(FALSE, FALSE, ordered_config_ptr);      
      rrcllc_init_l1_dl_sec_fdpch_chan_info(ordered_config_ptr);
      /* clear toc */
      rrcllc_init_l1_sec_e_ul_info( transition_config.toc_ptr);
      rrcllc_init_l1_sec_e_dl_info(FALSE, FALSE, transition_config.toc_ptr);      
      rrcllc_init_l1_dl_sec_fdpch_chan_info(transition_config.toc_ptr);
    }
  }
  else /* pointer in use is TOC */
  {
    /* HSDPA also has the same issue if we hit this error-fatal - want to capture the same */
    ERR_FATAL("DC_HSUPA: config_ptr_in_use set to TOC un-expectedly. Check..", 0, 0, 0);
  }
}
#endif /* FEATURE_WCDMA_DC_HSUPA */
/*====================================================================
FUNCTION: rrcllc_set_hs_mac_l1_info_inactive()

DESCRIPTION:


DEPENDENCIES:
  None

RETURN VALUE:
  Next LLC state.

SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_set_hs_mac_l1_info_inactive
(
  void
)
{
  ordered_config_type *config_ptr;
  if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
  {
    if (config_ptr_in_use == ORDERED_CONFIG)
    {
      config_ptr = ordered_config_ptr;
    }
    else
    {
      config_ptr = current_config_ptr;
    }
    rrc_reset_mac_ehs_params(config_ptr);
  #ifdef FEATURE_WCDMA_MIMO
  
    rrcllc_init_mimo_params(config_ptr);
     
  #endif/* FEATURE_WCDMA_MIMO*/

#ifdef FEATURE_WCDMA_DC_HSDPA
    rrcllc_init_sec_hsdpa_params(config_ptr);
#endif /*FEATURE_WCDMA_DC_HSDPA*/
    WRRC_MSG1_MED("RRCHS:Setting MAC Action to STOP/NOOP since HSDPA is %d [0= Not Active,1 = Active] in MAC", mac_is_hs_cfg_active());
    if (rrc_get_hsdpa_status() != HSDPA_INACTIVE)
    {
      rrc_set_hsdpa_status(HSDPA_INACTIVE);
      if(mac_is_hs_cfg_active() == TRUE)
      {
        config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_STOP;
      }
      else
      {
        config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_NOOP;
      }
    }

#ifdef FEATURE_WCDMA_HS_FACH
    if (rrcllc_get_hs_status_in_e_fach(current_config_ptr) == TRUE)
    {
      rrcllc_set_hs_status_in_e_fach(config_ptr,FALSE);
    }
    if(mac_is_hs_cfg_active() == TRUE)
    {
      config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_STOP;
      rrcllc_set_hs_action_in_e_fach(config_ptr, HSDPA_STOP);
    }
    else
    {
       config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_NOOP;
    }
#endif

  }
}


/*====================================================================
FUNCTION: rrcllc_check_if_hsdpa_can_be_started_reconfigured()

DESCRIPTION:
  This function checks if HSDPA can be started/reconfigured by looking at the fact that
  at least one HS Queue, one DFLOW, a HS Radio Link, a PS RAB is mapped onto
  one DFLOW and H-RNTI is present

DEPENDENCIES:
  None.

RETURN VALUE:
  True/False.

SIDE EFFECTS:
  None.
====================================================================*/

boolean rrcllc_check_if_hsdpa_can_be_started_reconfigured
(
  ordered_config_type *config_ptr
)
{
  uint8 count = 0, cnt = 0, queue_cnt = 0;
  boolean config_status = FALSE;
  /* Now check if HRNTI is present */
  if (config_ptr->hrnti_status == HRNTI_INVALID)
  {
    WRRC_MSG0_ERROR("RRCHS:HRNTI invalid");
    return config_status;
  }

  /* Future checks to be added here */
  /* Check if we have valid Delta ACK/NACK Values */


  if ((config_ptr->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_ack > RRCLLC_DELTA_ACK_MAX) ||
      (config_ptr->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_nack > RRCLLC_DELTA_NACK_MAX) ||
      (config_ptr->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_cqi > RRCLLC_DELTA_CQI_MAX) ||
      (config_ptr->l1_hsdpa_info.hs_scch_info.num_ch_code == 0))
  {
    MSG_ERROR("RRCHS:Delta ack %d, Delta Nack %d, Delta CQI %d",
        config_ptr->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_ack,
        config_ptr->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_nack,
        config_ptr->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_cqi);

    return config_status;
  }
  if ((config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc == RRCLLC_INVALID_CPICH_SCR_CODE) ||
      (config_ptr->mac_dl_parms.num_dflow == 0
        && config_ptr->mac_dl_parms.num_mac_ehs_queue ==0
  ))
  {
    MSG_MED("RRCHS:Num DFLOW %d, HS PSC %x",config_ptr->mac_dl_parms.num_dflow,
            config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc,0);
    return config_status;
  }
  
  if(config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_EHS )
  {
    for (count = 0; count < config_ptr->mac_dl_parms.num_mac_ehs_queue; count++)
    {
      /* Check that there is at least one MAC-D FLow */
      if (config_ptr->mac_ehs_queue_info[count].queue_id != INVALID_QUEUE_ID )           
      {
        /* Check for no of downlink channels */
        for (cnt = 0; cnt < config_ptr->mac_dl_parms.ndlchan_macehs; cnt++)
        {
          if (((config_ptr->dl_macehs_logchan_info[cnt].queue_id) == 
                   (config_ptr->mac_ehs_queue_info[count].queue_id))&&
              (config_ptr->dl_macehs_logchan_info[cnt].rb_id < MAX_RB))
          {
             WRRC_MSG0_MED("RRCHSPA+:hsdpaconfigcomplete");
             config_status = TRUE;
             return config_status;
          }
        }
      }
    }
  }
  else if(config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_HS )
  {
  for (count = 0; count < config_ptr->mac_dl_parms.num_dflow; count++)
  {
    /* Check that there is at least one MAC-D FLow */
    if ((config_ptr->mac_dflow_info[count].mac_dflow_id != INVALID_DFLOW_ID) &&
        (config_ptr->mac_dflow_info[count].ndlchan != 0) &&
        (config_ptr->mac_dflow_info[count].no_of_queues != 0))
        
    {
      /* Check for no of downlink channels */
      for (cnt = 0; cnt < config_ptr->mac_dflow_info[count].ndlchan; cnt++)
      {
        if ((config_ptr->mac_dflow_info[count].dlchan_info[cnt].rlc_mode != UE_MODE_TRANSPARENT) &&
                    ((config_ptr->mac_dflow_info[count].dlchan_info[cnt].chan_type == UE_LOGCHAN_DTCH) ||
                    ((config_ptr->mac_dflow_info[count].dlchan_info[cnt].chan_type == UE_LOGCHAN_DCCH))) &&
                    (config_ptr->mac_dflow_info[count].dlchan_info[cnt].rb_id < MAX_RB))
        {
          /* Check for queue */
          for (queue_cnt = 0; queue_cnt < config_ptr->mac_dflow_info[count].no_of_queues; queue_cnt++)
          {
            if (config_ptr->mac_dflow_info[count].queue_info[queue_cnt].no_of_pdu_sizes != 0)
            {
              WRRC_MSG0_MED("RRCHS:hsdpaconfigcomplete");
              config_status = TRUE;
              return config_status;
            }
          }
        }
      }
    }
  }
  }

  WRRC_MSG0_HIGH("RRCHS:hsdpaconfigcomplete NOT");
  return config_status;
}

/*====================================================================
FUNCTION: rrcllc_set_hsdpa_l1_info_in_cmd_under_process()

DESCRIPTION:
  This function sets HSDPA Information in L1 struct in rrcllc_cmd_under_process

DEPENDENCIES:
  None.

RETURN VALUE:
none

SIDE EFFECTS:
  None.
====================================================================*/

void rrcllc_set_hsdpa_l1_info_in_cmd_under_process
(
  ordered_config_type *config_ptr
)
{
  hsdpa_action_enum_type hsdpa_action;

  mac_hs_e_type rrc_machs_ehs;
  rrc_machs_ehs = config_ptr->mac_dl_parms.mac_hs_or_ehs;
 
  if (config_ptr->mac_dl_parms.mac_hs_transition_type == MAC_HS_INVALID_TRANSITION)
  {
   WRRC_MSG0_ERROR("Invalid Transition type");
  }  
  else if(config_ptr->mac_dl_parms.mac_hs_transition_type ==MAC_HS_TO_EHS)
  {
      rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.hsdpa_l1_ops = 
          HSDPA_SETUP_OPS_RECFG;


      rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.hsdpa_l1_info =
              &config_ptr->l1_hsdpa_info;
      rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.hsdpa_l1_info->hs_dsch_info.
        mac_hs_or_ehs = MAC_EHS;
      rrcllc_cmd_under_process.chan_config.hsdpa_hs_to_ehs = TRUE;

  }
  else if(config_ptr->mac_dl_parms.mac_hs_transition_type ==MAC_EHS_TO_HS)
  {
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.hsdpa_l1_ops = 
        HSDPA_SETUP_OPS_RECFG;

    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.hsdpa_l1_info =
            &config_ptr->l1_hsdpa_info;
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.hsdpa_l1_info->hs_dsch_info.
      mac_hs_or_ehs = MAC_HS;
    rrcllc_cmd_under_process.chan_config.hsdpa_ehs_to_hs = TRUE;

  }
  else
  {
    hsdpa_action = rrc_get_hsdpa_action();
    switch(hsdpa_action)
    {
    case  HSDPA_NOOP:

  #ifdef FEATURE_WCDMA_MIMO
      if ((rrc_get_hsdpa_status() == HSDPA_ACTIVE)
           &&(config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
           && (CPHY_MIMO_ACTION_PRESENT(config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action)))
      {
        /* Change action to RECONFIG as per L1 request */
        rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.hsdpa_l1_ops =
              HSDPA_SETUP_OPS_RECFG;
    
        rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.hsdpa_l1_info =
        &config_ptr->l1_hsdpa_info;
    
      }
      else
  #endif    
  
      if ((config_ptr->dest_freq_present == TRUE) &&
            (config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH) &&
          (rrc_get_hsdpa_status() == HSDPA_ACTIVE))
      {
          /* Change action to RECONFIG as per L1 request */
        rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.hsdpa_l1_ops =
                HSDPA_SETUP_OPS_RECFG;
    
        rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].
            cmd.setup.hsdpa_l1_info = NULL;
        rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.hsdpa_l1_info =
                  &config_ptr->l1_hsdpa_info;
        
        rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.hsdpa_l1_info->hs_dsch_info.
              mac_hs_or_ehs = rrc_machs_ehs;
    
      }
      else
      {
        rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.hsdpa_l1_ops = 
          HSDPA_SETUP_OPS_NOOP;
   
        rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.hsdpa_l1_info = NULL;
  
      }
      break;
  
    case HSDPA_START:
  
      /* To Add preventive check Later: All the params required to setup HSDPA are present */
  
      rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.hsdpa_l1_ops =
              HSDPA_SETUP_OPS_START;
  
      rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.hsdpa_l1_info =
              &config_ptr->l1_hsdpa_info;
        rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.hsdpa_l1_info->hs_dsch_info.
            mac_hs_or_ehs = rrc_machs_ehs;
  
      rrcllc_cmd_under_process.chan_config.hsdpa_inactive_to_active = TRUE;
#ifdef FEATURE_WCDMA_HS_FACH
      if(rrcllc_get_hs_status_in_e_fach(current_config_ptr) == TRUE)
      {
        /*efach to HS in DCH transition HS action will be reconfig*/
        ordered_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_RECONFIG;
        rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.hsdpa_l1_ops =
              HSDPA_SETUP_OPS_RECFG;
        if(rrc_machs_ehs == MAC_HS)
        {
          ordered_config_ptr->mac_dl_parms.mac_hs_transition_type = MAC_EHS_TO_HS;
        } 
      }
#endif
      break;
  
    case HSDPA_RECONFIG:
      rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.hsdpa_l1_ops =
        HSDPA_SETUP_OPS_RECFG;
  
      rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.hsdpa_l1_info =
        &config_ptr->l1_hsdpa_info;
  
        rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.hsdpa_l1_info->hs_dsch_info.
            mac_hs_or_ehs = rrc_machs_ehs;
  
      break;
  
    case HSDPA_STOP:
      rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.hsdpa_l1_ops =
        HSDPA_SETUP_OPS_STOP;
  
      rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.hsdpa_l1_info = NULL;
  
      rrcllc_cmd_under_process.chan_config.hsdpa_active_to_inactive = TRUE;
  
#ifdef FEATURE_WCDMA_HS_FACH
      if(rrcllc_get_hs_status_in_e_fach(current_config_ptr) == TRUE)
      {
        /*efach to DCH transition and  HS is being stopped, invalidate HRNTI status*/
        rrc_set_hrnti_status(ordered_config_ptr,HRNTI_INVALID);
      }
#endif

      break;
  
    default:
  
      rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.hsdpa_l1_ops =
        HSDPA_SETUP_OPS_NOOP;
  
      rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.hsdpa_l1_info = NULL;
      break;
    }
  }

  if(rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.hsdpa_l1_info != NULL)
  {
    WRRC_MSG4_MED("set_hsdpa_l1_info_in_cmd_under_process: MACEHS: Transiton type(0-Invalid,1-HS to EHS,2-EHS to HS,3-No transition): %d, HS or EHS(0-Invalid,1-HS,2-Ehs): %d, L1 HS action(0-NOOP,1-STRT,2-RECFG,3-STOP): %d, hs_req_mask %x",
    config_ptr->mac_dl_parms.mac_hs_transition_type, 
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.hsdpa_l1_info->hs_dsch_info.mac_hs_or_ehs,
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.hsdpa_l1_ops,
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.hsdpa_l1_info->hs_req_mask);
  }
  
}

/*===========================================================================

FUNCTION rrcllc_update_hsdpa_mac_action_l1_ops_for_old_config

DESCRIPTION
  This  function updates the HS and EHS operations for L1 and MAC in ordered config

DEPENDENCIES
  None.

RETURN VALUE
  None.

===========================================================================*/
void rrcllc_update_hsdpa_mac_action_l1_ops_for_old_config
(
  hsdpa_setup_ops_enum_type hsdpa_l1_ops
  ,mac_hs_transition_e_type hs_transition
)
{
  rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.hsdpa_l1_ops = hsdpa_l1_ops;
  ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator = FALSE;

  ordered_config_ptr->mac_dl_parms.mac_hs_transition_type = MAC_HS_NO_TRANSITION;
  
  switch(hs_transition)
  {
    case MAC_HS_TO_EHS:
      ordered_config_ptr->mac_dl_parms.mac_hsdpa_action= HSDPA_RECONFIG;
      ordered_config_ptr->mac_dl_parms.mac_hs_transition_type = MAC_HS_TO_EHS;
      ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs = MAC_EHS;
      ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.mac_hs_or_ehs = MAC_EHS;
      rrcllc_cmd_under_process.chan_config.hsdpa_hs_to_ehs = TRUE;
      rrcllc_cmd_under_process.chan_config.hsdpa_ehs_to_hs = FALSE;
      rrc_set_hsdpa_action(HSDPA_RECONFIG);
      break;
    
    case MAC_EHS_TO_HS:
      ordered_config_ptr->mac_dl_parms.mac_hsdpa_action= HSDPA_RECONFIG;
      ordered_config_ptr->mac_dl_parms.mac_hs_transition_type = MAC_EHS_TO_HS;
      ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs = MAC_HS;
      ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.mac_hs_or_ehs = MAC_HS;
      rrcllc_cmd_under_process.chan_config.hsdpa_hs_to_ehs = FALSE;
      rrcllc_cmd_under_process.chan_config.hsdpa_ehs_to_hs = TRUE;
      rrc_set_hsdpa_action(HSDPA_RECONFIG);
      break;
    
    case MAC_HS_NO_TRANSITION:
      ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.mac_hs_or_ehs=
           ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs; 
      rrcllc_cmd_under_process.chan_config.hsdpa_hs_to_ehs = FALSE;
      rrcllc_cmd_under_process.chan_config.hsdpa_ehs_to_hs = FALSE;
      if(hsdpa_l1_ops == HSDPA_SETUP_OPS_RECFG )
      {
        ordered_config_ptr->mac_dl_parms.mac_hsdpa_action= HSDPA_RECONFIG;
        rrc_set_hsdpa_action(HSDPA_RECONFIG);
      }
      else if(hsdpa_l1_ops == HSDPA_SETUP_OPS_START)
      {
        ordered_config_ptr->mac_dl_parms.mac_hsdpa_action= HSDPA_START;
        rrc_set_hsdpa_action(HSDPA_START);
      }
      else if(hsdpa_l1_ops == HSDPA_SETUP_OPS_STOP)
      {
        ordered_config_ptr->mac_dl_parms.mac_hsdpa_action= HSDPA_STOP;
        rrc_set_hsdpa_action(HSDPA_STOP);
      }
      else
      {
         ordered_config_ptr->mac_dl_parms.mac_hsdpa_action= HSDPA_NOOP;
         rrc_set_hsdpa_action(HSDPA_NOOP);
      }
      break;
    
    default:
         rrcllc_cmd_under_process.chan_config.hsdpa_hs_to_ehs = FALSE;
         rrcllc_cmd_under_process.chan_config.hsdpa_ehs_to_hs = FALSE;
    
      ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs = MAC_HS_TYPE_INVALID;
      ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.mac_hs_or_ehs = MAC_HS_TYPE_INVALID;
      ordered_config_ptr->mac_dl_parms.mac_hs_transition_type = MAC_HS_INVALID_TRANSITION;
      break;
  }
  
  MSG_HIGH("MACEHS: Transiton type(0-Invalid,1-HS to EHS,2-EHS to HS,3-No transition): %d, HS or EHS(0-Invalid,1-HS,2-Ehs): %d, HS action(0-NOOP,1-STRT,2-RECFG,3-STOP): %d",
  ordered_config_ptr->mac_dl_parms.mac_hs_transition_type,ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs,ordered_config_ptr->mac_dl_parms.mac_hsdpa_action);
  return;
}


/*===========================================================================
FUNCTION    rrcllc_init_semi_permanent_data

DESCRIPTION
  This function initializes LLC semi-permanent data.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.
===========================================================================*/
static void  rrcllc_init_semi_permanent_data(void)
{
  uint8   trch_index;
  WRRC_MSG0_HIGH("Clearing Semiperm llc data");
  /* Indicate all downlink and uplink channels as down */
  rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up = FALSE;
  rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch_is_up = FALSE;
  rrcllc_semi_permanent_data.dl_phy_chan.sccpch_is_up = FALSE;
  rrcllc_semi_permanent_data.dl_phy_chan.dl_dpch_is_up = FALSE;
  rrcllc_semi_permanent_data.ul_phy_chan.prach_is_up =   FALSE;
  rrcllc_semi_permanent_data.ul_phy_chan.ul_dpch_is_up = FALSE;

  /* Initialize PCCPCH Transport channel bitflags */
  rrcllc_semi_permanent_data.dl_phy_chan.pccpch.cctrch_id = RRCLLC_INVALID_CCTRCH_ID;
  rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_ref_type_bf = 0;
  rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_enable_bf   = 0;
  rrcllc_semi_permanent_data.dl_phy_chan.pccpch.num_trch = 0;

  for(trch_index=0; trch_index < L1_MAX_TRCH; trch_index ++)
  {
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch.
      trch_info_array[trch_index] = NULL;
  }

  /* Initialize N_PCCPCH transport channel bitflags */
  rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch.cctrch_id = RRCLLC_INVALID_CCTRCH_ID;
  rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch.trch_ref_type_bf = 0;
  rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch.trch_enable_bf   = 0;
  rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch.num_trch = 0;

  for(trch_index=0; trch_index < L1_MAX_TRCH; trch_index ++)
  {
    rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch.
      trch_info_array[trch_index] = NULL;
  }

  /* Initialize SCCPCH Transport channel bitflags */
  rrcllc_semi_permanent_data.dl_phy_chan.sccpch.cctrch_id = RRCLLC_INVALID_CCTRCH_ID;
  rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf = 0;
  rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf   = 0;
  rrcllc_semi_permanent_data.dl_phy_chan.sccpch.num_trch = 0;
  for(trch_index=0; trch_index < L1_MAX_TRCH; trch_index ++)
  {
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.
      trch_info_array[trch_index] = NULL;
  }

  rrcllc_semi_permanent_data.dl_phy_chan.ctch_status = RRCLLC_NO_CTCH;
  /* Initialize SCCPCH Transport channel bitflags (used for CTCH ) */
  rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.cctrch_id = RRCLLC_INVALID_CCTRCH_ID;
  rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_ref_type_bf = 0;
  rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_enable_bf   = 0;
  rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.num_trch = 0;
  for(trch_index=0; trch_index < L1_MAX_TRCH; trch_index ++)
  {
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.
      trch_info_array[trch_index] = NULL;
  }

  /* Initialize DPCH Transport channel bitflags */
  rrcllc_semi_permanent_data.dl_phy_chan.dl_dpch.cctrch_id = RRCLLC_INVALID_CCTRCH_ID;
  rrcllc_semi_permanent_data.dl_phy_chan.dl_dpch.trch_ref_type_bf = 0;
  rrcllc_semi_permanent_data.dl_phy_chan.dl_dpch.trch_enable_bf   = 0;
  rrcllc_semi_permanent_data.dl_phy_chan.dl_dpch.num_trch = 0;

  for(trch_index=0; trch_index < L1_MAX_TRCH; trch_index ++)
  {
    rrcllc_semi_permanent_data.dl_phy_chan.dl_dpch.trch_info_array[trch_index] = NULL;
  }

  /* Set FACH included to FALSE */
  rrcllc_set_fach_included(FALSE);

  /* Initialize Uplink Physical channel data */
  rrcllc_semi_permanent_data.ul_phy_chan.ul_dpch_cctrch_id = RRCLLC_INVALID_CCTRCH_ID;
  rrcllc_semi_permanent_data.ul_phy_chan.prach_cctrch_id   = RRCLLC_INVALID_CCTRCH_ID;

  /* Initialize Uplink MAC Config control flag */
  rrcllc_semi_permanent_data.send_mac_uplink_config = FALSE;

} /* rrcllc_init_semi_permanent_data */


/*===========================================================================

FUNCTION   RRCLLC_CPHY_START_WCDMA_REQ

DESCRIPTION

  This function sends a CPHY_START_WCDMA_MODE_REQ to L1.

DEPENDENCIES

  None.

RETURN VALUE

  None.

SIDE EFFECTS

  None.

===========================================================================*/
static void rrcllc_cphy_start_wcdma_req( void )
{
  l1_ext_cmd_type *l1_cmd_ptr;

  /* Get a L1 command buffer */
  l1_cmd_ptr = l1_get_cmd_buf();

  /* Fill in the Command Header */
  l1_cmd_ptr->cmd_hdr.cmd_id = CPHY_START_WCDMA_MODE_REQ;

  l1_cmd_ptr->cmd_hdr.act_time_type = L1_ACTIVATION_TIME_NONE;
  l1_cmd_ptr->cmd_hdr.act_time      = 0;
#ifdef FEATURE_DUAL_SIM
  l1_cmd_ptr->cmd_hdr.sys_modem_as_id = rrc_get_as_id();
#endif
  l1_cmd_ptr->cmd.start.mdsp_image = WL1_MDSP_IMAGE_WCDMA_GSM; 
  /* Now send the primitive to L1 */
  rrc_send_l1_cmd(l1_cmd_ptr);

#ifdef FEATURE_RRC_CAPTURE_L1_DEADLOCK
  /* Start timer for L1 deadlock detection */
  rrctmr_start_timer( RRCTMR_L1_DEADLOCK_DETECT_TIMER,
                      RRCTMR_L1_DEADLOCK_DETECT_TIMER_IN_MS );
#endif


  return;
} /* end of rrcllc_cphy_start_wcdma_req */


/*====================================================================
FUNCTION: rrcllc_cphy_stop_wcdma_mode_req()

DESCRIPTION:
  This function constructs the CPHY_STOP_WCDMA_MODE_REQ primitive and sends it
  to layer 1.

DEPENDENCIES:
  None

RETURN VALUE:
  uecomdef_status_e_type -> indicating a SUCCESS or FAILURE

SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_cphy_stop_wcdma_mode_req (void)
{
  l1_ext_cmd_type *l1_cmd_ptr;

  l1_cmd_ptr = l1_get_cmd_buf();

  /* Fill in the Command Header */
  l1_cmd_ptr->cmd_hdr.cmd_id = CPHY_STOP_WCDMA_MODE_REQ;

  l1_cmd_ptr->cmd_hdr.act_time_type = L1_ACTIVATION_TIME_NONE;
  l1_cmd_ptr->cmd_hdr.act_time      = 0;

  /* Initialize the reason for stopping the WCDMA mode */
  l1_cmd_ptr->cmd.stop.cause = rrcllc_cmd_under_process.wcdma_stop_cause;

#ifdef FEATURE_RRC_CAPTURE_L1_DEADLOCK
  /* Start timer for L1 deadlock detection */
  rrctmr_start_timer( RRCTMR_L1_DEADLOCK_DETECT_TIMER,
                      RRCTMR_L1_DEADLOCK_DETECT_TIMER_IN_MS );
#endif
  WRRC_MSG0_HIGH_OPT("Dispatching out PHY cmd CPHY_STOP_WCDMA_MODE_REQ");

  rrc_send_l1_cmd(l1_cmd_ptr);

} /* end rrcllc_cphy_stop_wcdma_mode_req() */

/*====================================================================
FUNCTION: rrcllc_crlc_release_all_req()

DESCRIPTION:
  This function constructs the CRLC_RELEASE_ALL_REQ primitive and
  sends it to layer 2 Uplink task.

DEPENDENCIES:
  None

RETURN VALUE:
  uecomdef_status_e_type -> indicating a SUCCESS or FAILURE

SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_crlc_release_all_req
(
  void
)
{

  wcdma_l2_ul_cmd_type  *rlc_ptr;

  /* Get L2 DL command buffer */
  rlc_ptr = wcdma_l2_ul_get_cmd_buf();

  /* Fill in the Command Header */
  rlc_ptr->cmd_hdr.cmd_id = CRLC_RELEASE_ALL_REQ;
  WRRC_MSG0_HIGH("Dispatching out L2 cmd CRLC_RELEASE_ALL_REQ / Sending CRLC_RELEASE_ALL_REQ");
  rrcllc_init_old_ul_rlc_size_backup();
  /* Send command to L2 DL Task */
  rrc_send_l2_ul_cmd(rlc_ptr);

} /* rrcllc_crlc_release_all_req() */


#ifdef FEATURE_UMTS_PDCP

/*====================================================================
FUNCTION: rrcllc_cpdcp_release_all_req()

DESCRIPTION:
  This function constructs the COMP_CPDCP_CONFIG_REQ primitive with 
  action type set to CPDCP_RELEASE_ALL.

DEPENDENCIES:
  None

RETURN VALUE:
  uecomdef_status_e_type -> indicating a SUCCESS or FAILURE

SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_cpdcp_release_all_req(void)
{
  comp_cmd_type  *pdcp_ptr;

  /* Get PDCP command buffer */
  if ((pdcp_ptr = comp_get_cmd_buf()) == NULL)
  {
    ERR_FATAL("NULL Ptr when sending COMP_CPDCP_CONFIG_REQ ",0,0,0);
  }
  /* Fill in the Command Header */
  pdcp_ptr->hdr.cmd_id = CPDCP_CONFIG_REQ;
  
  pdcp_ptr->cmd.pdcp_cfg_req.action = RELEASE_ALL_PDCP;
  /* No need to fill out any other information as release
   * all action should blindly clean up everything.
   */
  /*FEATURE_CS_VOICE_OVER_HSPA: No need to set CSoHS action for PDCP here.*/   
  WRRC_MSG0_HIGH("Sending CPDCP_CONFIG_REQ to release all");

  /* Send command to L2 DL Task */
  comp_put_cmd(pdcp_ptr);

} /* rrcllc_crlc_release_all_req() */

#endif /* FEATURE_UMTS_PDCP */


/*********************************************************************
**          LLC Error Recovery related functions
**
**********************************************************************/

#ifdef FEATURE_RRC_L1_ERROR_RECOVERY_P1
/*===========================================================================
FUNCTION rrcllc_error_recovery_in_progress

DESCRIPTION
  This function returns a boolean indicating if ERROR recovery is in
  progress or not. Right now the boolean is set to TRUE only for ACQ_REQ
  deadlock and RRC_CPHY_OPERATIONAL_ERROR_IND handling.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.
===========================================================================*/
boolean rrcllc_error_recovery_in_progress(void)
{
  return rrcllc_cmd_under_process.err_recovery_in_progress;

} /* rrcllc_error_recovery_in_progress */


/*===========================================================================
FUNCTION rrcllc_err_fatal_recovery_handler

DESCRIPTION
  This function triggers the error recovery mechanism instead of doing an
  ERR_FATAL when the delay timer expires.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.
===========================================================================*/
rrcllc_substate_e_type rrcllc_err_fatal_recovery_handler(void)
{
  rrc_cmd_type     *llc_stored_cmd_ptr;
  rrc_cmd_type     *cmd_ptr = NULL;
  rrcllc_substate_e_type rrcllc_next_substate = LLC_IDLE;

  /* Signal SIB procedure to clear up the active event, if any */
  rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_OOS);

  /* Force RCE to go to INITIAL, taking care of ongoing timers
   * and required response to MM, depending on RCE substate and
   */
  rrcrce_force_initialize(TRUE);

  /* Initialize Ordered and Current Configs */
  rrcllc_init_ordered_config_status_and_data(RRC_STATE_DISCONNECTED);
  rrcllc_init_config_data(current_config_ptr, RRC_STATE_DISCONNECTED);

  /* Clear RLC Logical Channel Info in LCM */
  rrclcm_clear_rlc_lc_info();

  rrcllc_crlc_release_all_req();
  
#ifdef FEATURE_UMTS_PDCP
  /* Send CPDCP_CONFIG_REQ to release all PDCP entities. */
  rrcllc_cpdcp_release_all_req();
#endif /* FEATURE_UMTS_PDCP*/

  /* Initialize the CCTrCH ID's */
  rrcllc_init_cctrch_id();
  /* Initialize current physical channel data for all DL physical channels */
  rrcllc_init_semi_permanent_data();

  /* Clear the LLC internal Queue. If STOP_LOWER_LAYER_REQ/RRC_LOWER_LAYER_DEACT_REQ
   * is received start processing it. If SUSPEND_REQ is received do an ERR_FATAL for
   * now.
   */

  /* Dequeue internal LLC queue and free all buffers */
  while( q_check(&llc_cmd_q) != NULL )
  {
    if((llc_stored_cmd_ptr = (rrc_cmd_type *) q_get(&llc_cmd_q)) != NULL)
    {

       if(llc_stored_cmd_ptr->cmd_hdr.cmd_id == RRC_STOP_LOWER_LAYER_REQ)
       {
         WRRC_MSG0_ERROR("STOP WCDMA req during ERR_FATAL recovery");
         rrcllc_next_substate = rrcllc_idle_handler(llc_stored_cmd_ptr);
         rrcllc_free_cmd_buf(llc_stored_cmd_ptr);
         llc_stored_cmd_ptr = NULL;
         break;
       }
       else if(llc_stored_cmd_ptr->cmd_hdr.cmd_id == RRC_LOWER_LAYER_DEACT_REQ)
       {
         WRRC_MSG0_ERROR("DEACT req during ERR_FATAL recovery");
         rrcllc_next_substate = rrcllc_idle_handler(llc_stored_cmd_ptr);
         rrcllc_free_cmd_buf(llc_stored_cmd_ptr);
         llc_stored_cmd_ptr = NULL;
         break;
       }
       else if((llc_stored_cmd_ptr->cmd_hdr.cmd_id == RRC_LLC_CMD_REQ) &&
                (llc_stored_cmd_ptr->cmd.rrc_llc_req.cmd_dest == LAYER1_PHY))
       {
         if(llc_stored_cmd_ptr->cmd.rrc_llc_req.l1_cmd.cmd_id == CPHY_SUSPEND_WCDMA_MODE_REQ)
         {
           WRRC_MSG0_ERROR("SUSPEND Req during ERR_FATAL recovery");
           rrcllc_next_substate = rrcllc_idle_handler(llc_stored_cmd_ptr);
           rrcllc_free_cmd_buf(llc_stored_cmd_ptr);
           llc_stored_cmd_ptr = NULL;
         }
         else
         {
           /* If Measurement request or TVM is found also free the
            * embedded pointer inside the command
            */
           rrcllc_free_cmd_and_embedded_buf(llc_stored_cmd_ptr);
           llc_stored_cmd_ptr = NULL;
         }
      }
      else
      {
        /* If Measurement request or TVM is found also free the
         * embedded pointer inside the command
         */
        rrcllc_free_cmd_and_embedded_buf(llc_stored_cmd_ptr);
        llc_stored_cmd_ptr = NULL;
      }
    }
  }

  if(rrcllc_next_substate == LLC_IDLE)
  {
    /* If there was no STOP_LOWER_LAYER_REQ, send RRC_ERR_FATAL_IND
     * to CSP to trigger the recovery mechanism
    */
    WRRC_MSG0_ERROR("Sending ERR_FATAL_IND to CSP");

    cmd_ptr = rrc_get_int_cmd_buf();

    /* Reset L1 */
    cmd_ptr->cmd_hdr.cmd_id = RRC_ERR_FATAL_IND;
    rrc_put_int_cmd(cmd_ptr);
  }

  return rrcllc_next_substate;

} /* rrcllc_err_fatal_recovery_handler */

#endif /* FEATURE_RRC_L1_ERROR_RECOVERY_P1 */

#ifdef  FEATURE_RRC_CAPTURE_L1_DEADLOCK
/*===========================================================================
FUNCTION rrcllc_l1_deadlock_handler

DESCRIPTION
  This function does an ERR_FATAL when a deadlock is detected.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.
===========================================================================*/
static void rrcllc_l1_deadlock_handler( rrcllc_substate_e_type substate)
{

#ifdef FEATURE_RRC_CAPTURE_L1_DEADLOCK
  /* Stop timer for L1 deadlock detection */
  rrctmr_stop_timer( RRCTMR_L1_DEADLOCK_DETECT_TIMER );
#endif

  switch(substate)
  {
    case LLC_WAIT_CPHY_SETUP_CNF:
#ifdef FEATURE_RRC_DELAY_ERR_FATAL

      WRRC_MSG1_ERROR("Delaying ERR_FATAL for SETUP_CNF in st %d",rrc_get_state());
      /* Start timer for L1 deadlock detection */
      rrctmr_start_timer( RRCTMR_DELAY_ERR_FATAL_TIMER,
                          RRCTMR_DELAY_ERR_FATAL_TIMER_IN_MS );

      /* Print L1 debug messages */
      l1m_print_debug_msgs();

#else
      ERR_FATAL("L1 Stuck: CPHY_SETUP_REQ", 0, 0, 0);
#endif

      break;

    case LLC_WAIT_CPHY_IDLE_CNF:
#ifdef FEATURE_RRC_DELAY_ERR_FATAL

      WRRC_MSG1_ERROR("Delaying ERR_FATAL for IDLE_CNF in st %d",rrc_get_state());
      /* Start timer for L1 deadlock detection */
      rrctmr_start_timer( RRCTMR_DELAY_ERR_FATAL_TIMER,
                          RRCTMR_DELAY_ERR_FATAL_TIMER_IN_MS );

      /* Print L1 debug messages */
      l1m_print_debug_msgs();

#else
      ERR_FATAL("L1 Stuck: CPHY_IDLE_REQ", 0, 0, 0);
#endif
      break;

    case LLC_WAIT_CPHY_CELL_TRANSITION_CNF:
#ifdef FEATURE_RRC_DELAY_ERR_FATAL

      WRRC_MSG1_ERROR("Delaying ERR_FATAL for TR_CNF in st %d",rrc_get_state());
      /* Start timer for L1 deadlock detection */
      rrctmr_start_timer( RRCTMR_DELAY_ERR_FATAL_TIMER,
                        RRCTMR_DELAY_ERR_FATAL_TIMER_IN_MS );

      /* Print L1 debug messages */
      l1m_print_debug_msgs();
#else
      ERR_FATAL("L1 Stuck: CPHY_CELL_TRANSITION_REQ", 0, 0, 0);
#endif

      break;

    case LLC_WAIT_CPHY_DRX_CNF:
#ifdef FEATURE_RRC_DELAY_ERR_FATAL

      WRRC_MSG1_ERROR("Delaying ERR_FATAL for DRX_CNF in st %d",rrc_get_state());
      /* Start timer for L1 deadlock detection */
      rrctmr_start_timer( RRCTMR_DELAY_ERR_FATAL_TIMER,
                          RRCTMR_DELAY_ERR_FATAL_TIMER_IN_MS );

      /* Print L1 debug messages */
      l1m_print_debug_msgs();

#else
      ERR_FATAL("L1 Stuck: CPHY_DRX_REQ", 0, 0, 0);
#endif

      break;

    case LLC_WAIT_CPHY_SUSPEND_WCDMA_MODE_CNF:
      ERR_FATAL("L1 Stuck: CPHY_SUSPEND_WCDMA_MODE_REQ", 0, 0, 0);
      break;

    case LLC_WAIT_CPHY_RESUME_WCDMA_MODE_CNF:
      ERR_FATAL("L1 Stuck: CPHY_RESUME_WCDMA_MODE_REQ", 0, 0, 0);
      break;

    case LLC_WAIT_CPHY_STOP_WCDMA_MODE_CNF:
      ERR_FATAL("L1 Stuck: CPHY_STOP_WCDMA_MODE_REQ", 0, 0, 0);
      break;


    case LLC_WAIT_CPHY_ACQ_CNF:
#ifdef FEATURE_RRC_DELAY_ERR_FATAL

      WRRC_MSG1_ERROR("Delaying ERR_FATAL for ACQ_CNF in st %d",rrc_get_state());
      /* Start timer for L1 deadlock detection */
      rrctmr_start_timer( RRCTMR_DELAY_ERR_FATAL_TIMER,
                          RRCTMR_DELAY_ERR_FATAL_TIMER_IN_MS );

      /* Print L1 debug messages */
      l1m_print_debug_msgs();

#else
      ERR_FATAL("L1 Stuck: CPHY_ACQ", 0, 0, 0);
#endif
      break;

    case LLC_WAIT_CPHY_START_WCDMA_MODE_CNF:
      ERR_FATAL("L1 Stuck: CPHY_START_WCDMA_MODE_REQ", 0, 0, 0);
      break;
#ifdef FEATURE_WCDMA_HANDLE_MDSP_HALT
		  case LLC_WAIT_CPHY_RECOVER_CNF:
			ERR_FATAL("L1 Stuck CPHY_RECOVER_WCDMA_REQ",0,0,0);
			break;
#endif
    case LLC_WAIT_CPHY_CELL_SELECTION_CNF:
      ERR_FATAL("L1 Stuck: CPHY_CELL_SELECTION_REQ",0,0,0);
      break;

    default:
      WRRC_MSG1_ERROR("LLC stuck in %d sstate", substate);
      break;
  }
} /* rrcllc_l1_deadlock_handler */

#ifdef FEATURE_RRC_DELAY_ERR_FATAL
/*===========================================================================
FUNCTION rrcllc_delay_err_fatal_handler

DESCRIPTION
  This function does an ERR_FATAL when the delay timer expires.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.
===========================================================================*/
static rrcllc_substate_e_type rrcllc_delay_err_fatal_handler( rrcllc_substate_e_type substate)
{

  rrcllc_substate_e_type rrcllc_next_substate = substate;

#ifdef FEATURE_RRC_L1_ERROR_RECOVERY_P1
  rrc_state_e_type rrc_state;

  rrc_state = rrc_get_state();
#endif

  /* Stop timer to delaying the ERR_FATAL */
  rrctmr_stop_timer( RRCTMR_DELAY_ERR_FATAL_TIMER );

  switch(substate)
  {
    case LLC_WAIT_CPHY_SETUP_CNF:

#ifdef FEATURE_RRC_L1_ERROR_RECOVERY_P1
      if(rrc_state == RRC_STATE_DISCONNECTED)
      {
        WRRC_MSG0_ERROR("Start: ERR_FATAL recovery for SETUP_CNF");

        if(rrc_csp_bplmn_srch_in_progress () != WTOW_SEARCH_STOP || rrccsp_is_gtow_bplmn_srch_in_progress() != FALSE)
        {
          ERR_FATAL("L1 Stuck: CPHY_CPHY_SETUP_REQ .. BPLMN in prog",0,0,0);
        }
        else
        {
          rrcllc_next_substate = rrcllc_err_fatal_recovery_handler();
        }
      }
      else
      {
        ERR_FATAL("L1 Stuck: CPHY_SETUP_REQ", 0, 0, 0);
      }
#else
      ERR_FATAL("L1 Stuck: CPHY_SETUP_REQ", 0, 0, 0);
#endif
      break;

    case LLC_WAIT_CPHY_CELL_TRANSITION_CNF:

#ifdef FEATURE_RRC_L1_ERROR_RECOVERY_P1
      if(rrc_state == RRC_STATE_DISCONNECTED)
      {
        if(rrc_csp_bplmn_srch_in_progress () != WTOW_SEARCH_STOP || rrccsp_is_gtow_bplmn_srch_in_progress() != FALSE)
        {
          ERR_FATAL("L1 Stuck: CPHY_CELL_TRANSITION_REQ  .. BPLMN in prog",0,0,0);
        }
        /* If the command under process was CELL_RESELECTION_REQ then send
         * CELL_RESELECTION_CNF (FAILURE) back to the procedure.
         * Othewise start ERR_FATAL recovery procedure
         */
        if((rrcllc_cmd_under_process.valid) &&
             (rrcllc_cmd_under_process.rrc_current_cmd_id == RRC_CELL_RESELECTION_REQ))
        {
          /* Faking CPHY_TRANSITION_CNF (FAILURE) */
          WRRC_MSG0_ERROR("Faking Cell Trans Cnf failure");
          rrcllc_next_substate = LLC_IDLE;

          /* Send a Reselection CNF with Failure back to the procedure */
          /* Send a Failure status to the calling procedure */
          (void)rrcllc_send_rrc_cell_reselection_cnf(FAILURE);

          /* Clear Ordered Config if indicated in LLC Command under process */
          if(rrcllc_cmd_under_process.clear_oc_pending)
          {
            WRRC_MSG0_HIGH("Pending ClearOC on Cell Trans Cnf ");
            rrcllc_clear_ordered_config_now();
            rrcllc_cmd_under_process.clear_oc_pending = FALSE;
          }
        }
        else
        {
          WRRC_MSG0_ERROR("Start: ERR_FATAL recovery for TRANS_CNF");
          rrcllc_next_substate = rrcllc_err_fatal_recovery_handler();
        }
      }
      else
      {
        ERR_FATAL("L1 Stuck: CPHY_CELL_TRANSITION_REQ", 0, 0, 0);
      }
#else
      ERR_FATAL("L1 Stuck: CPHY_CELL_TRANSITION_REQ", 0, 0, 0);

#endif /* FEATURE_RRC_L1_ERROR_RECOVERY_P1 */

      break;

    case LLC_WAIT_CPHY_DRX_CNF:

#ifdef FEATURE_RRC_L1_ERROR_RECOVERY_P1
      if(rrc_state == RRC_STATE_DISCONNECTED)
      {
        if(rrc_csp_bplmn_srch_in_progress () != WTOW_SEARCH_STOP || rrccsp_is_gtow_bplmn_srch_in_progress() != FALSE)
        {
          ERR_FATAL("L1 Stuck: CPHY_DRX_REQ .. BPLMN in progress", 0, 0, 0);
        }
        else
        {
          WRRC_MSG0_ERROR("Start: ERR_FATAL recovery for DRX_CNF");
          rrcllc_next_substate = rrcllc_err_fatal_recovery_handler();
        }
      }
      else
      {
        ERR_FATAL("L1 Stuck: CPHY_DRX_REQ", 0, 0, 0);
      }
#else
      ERR_FATAL("L1 Stuck: CPHY_DRX_REQ", 0, 0, 0);
#endif
      break;

    case LLC_WAIT_CPHY_IDLE_CNF:
      ERR_FATAL("L1 Stuck: CPHY_IDLE_REQ", 0, 0, 0);
      break;

    case LLC_WAIT_CPHY_ACQ_CNF:

#ifdef FEATURE_RRC_L1_ERROR_RECOVERY_P1
      if(rrc_state == RRC_STATE_DISCONNECTED)
      {
        if(rrc_csp_bplmn_srch_in_progress () != WTOW_SEARCH_STOP || rrccsp_is_gtow_bplmn_srch_in_progress() != FALSE)
        {
          ERR_FATAL("L1 Stuck: CPHY_ACQ_REQ .. BPLMN in progress",0,0,0);
        }
        else
        {
          /* Start recovery procedure */
          /* Send a CPHY_STOP_WCDMA_MODE_REQ */
          rrcllc_cmd_under_process.wcdma_stop_cause = L1_RAT_CHANGE;
          rrcllc_cmd_under_process.err_recovery_in_progress = TRUE;
          rrcllc_cphy_stop_wcdma_mode_req();
          rrcllc_next_substate = LLC_WAIT_CPHY_STOP_WCDMA_MODE_CNF;
        }
      }
      else
      {
        ERR_FATAL("No error recovery in RRC state %d",rrc_state,0,0);
      }
#else
      ERR_FATAL("L1 Stuck: CPHY_ACQ_REQ", 0, 0, 0);
#endif

      break;

    default:
      WRRC_MSG1_ERROR("LLC stuck in %d sstate", substate);
      break;
  }
  return rrcllc_next_substate;   /*lint !e527 we want to suppress this lint error as
                                  * Lint recognizes ERR_FATAL as an exit point but the
                                  * compiler does not. A return after ERR_FATAL is needed
                                  * to not generate a compiler warning
                                  */


} /* rrcllc_delay_err_fatal_handler */

#endif /* FEATURE_RRC_DELAY_ERR_FATAL */

#endif  /* #ifdef  FEATURE_RRC_CAPTURE_L1_DEADLOCK */

/*********************************************************************
**          LLC Queue related functions
**
**********************************************************************/

/*===========================================================================
FUNCTION RRCLLC_QUEUE_INIT

DESCRIPTION
  This function initializes the RRC LLC queues. This function needs
  to be called once at the time of the RRC task start-up.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.
===========================================================================*/
void rrcllc_queue_init( void )
{
  /* Initialize all the command queues */
  (void)q_init(&llc_cmd_q);

#ifdef FEATURE_RRC_CMD_Q_DEBUG
  #error code not present
#endif /* FEATURE_RRC_CMD_Q_DEBUG */

  return;
} /* end rrcllc_queue_init() */

/*====================================================================
FUNCTION: rrcllc_get_cmd_buf()

DESCRIPTION:
  This function returns an LLC command buffer to the calling function.
  This function dynamically allocates memory for the necessary buffer.
  Note that this buffer MUST be freed by calling rrc_free_cmd_buf().
  The freeing is done by the function that dequeues and processes this
  command buffer.
  Calling function MUST check for a NULL return value and take necessary
  action.

DEPENDENCIES:
  None.

RETURN VALUE:
  A buffer of type rrc_cmd_type. If memory is not available, NULL
  is returned.

SIDE EFFECTS:
  None.
=====================================================================*/
static rrc_cmd_type *rrcllc_get_cmd_buf(void)
{
#ifdef FEATURE_RRC_CMD_Q_DEBUG
  #error code not present
#endif /* FEATURE_RRC_CMD_Q_DEBUG */

  return (rrc_cmd_type *)rrc_malloc(sizeof(rrc_cmd_int_type));
} /* end rrcllc_get_cmd_buf() */





/*====================================================================
FUNCTION: rrcllc_put_cmd_buf()

DESCRIPTION:
  This function puts a command buffer into RRC's internal
  command queue. Note that the command buffer must have been
  requested through a call to get_rrc_int_cmd_buf(). Also,
  The calling function must have filled all the necessary
  data including the command id before passing the buffer
  to this function.

  This function also sets the appropriate signal to the RRC
  task to indicate that a command has been placed in the
  command queue.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  A signal is set for the RRC task and this could cause a context
  switch.

=====================================================================*/
static void rrcllc_put_cmd_buf
(
  rrc_cmd_type *cmd_buf  /* The command buffer to be put in the queue */
)
{
#ifdef FEATURE_RRC_CMD_Q_DEBUG
  #error code not present
#endif /* FEATURE_RRC_CMD_Q_DEBUG */

  if(q_cnt(&llc_cmd_q) > MAX_LLC_COMMANDS_TO_QUEUE)
  {
    ERR_FATAL("MAX LLC COMMANDS reached",0,0,0);
  }
  
  /* First initialize the queue link. This is always done
  before putting an item in a queue. */
  (void) q_link(cmd_buf, &(cmd_buf->cmd_hdr.link));

  /* Then put the buffer in the queue */
  q_put(&llc_cmd_q, &(cmd_buf->cmd_hdr.link));

  WRRC_MSG2_HIGH("Dispatching deferred. %d cmds in llc_cmd_q, last cmd:rrc_cmd_e_type_value_0x%x", q_cnt(&llc_cmd_q), cmd_buf->cmd_hdr.cmd_id);
 
  return;
} /* end rrcllc_put_cmd_buf() */



/*====================================================================
FUNCTION: rrcllc_put_cmd_on_queue()

DESCRIPTION:
  This is called when unfunneled Lower Layer commands need to be
  copied from the RRC Command queue to the LLC command queue.

DEPENDENCIES:
  None.

RETURN VALUE:
  uecomdef_status_e_type - indicates whether or not the config
                           parameters were correctly set.

SIDE EFFECTS:
  None.
====================================================================*/
static uecomdef_status_e_type rrcllc_put_cmd_on_queue
(
  rrc_cmd_type *cmd_ptr
)
{
  /* Command pointer to put an internal command on LLC's queue */
  rrc_cmd_type *put_cmd_ptr;

  /* Get an LLC buffer */
  put_cmd_ptr = rrcllc_get_cmd_buf();

/* Copy the RRC Command to the LLC Command pointer */
  WCDMA_MEMCPY(put_cmd_ptr, 
               sizeof(rrc_cmd_type),
               cmd_ptr, 
               sizeof(rrc_cmd_int_type));
  
  
  if(cmd_ptr->cmd_hdr.cmd_id == RRC_LLC_CMD_REQ)
  { 
    /* delete embedded pointer allocated for MEASUREMENT_REQ */
    if(cmd_ptr->cmd.rrc_llc_req.cmd_dest == LAYER1_PHY)
    {
      if(cmd_ptr->cmd.rrc_llc_req.l1_req != NULL )
      {
       WRRC_MSG1_HIGH("copy l1 cmd %d",cmd_ptr->cmd.rrc_llc_req.l1_cmd.cmd_id);
        put_cmd_ptr->cmd.rrc_llc_req.l1_req =
            (l1_req_cmd *)rrc_malloc(sizeof(l1_req_cmd));
        WCDMA_MEMCPY(put_cmd_ptr->cmd.rrc_llc_req.l1_req,
                     sizeof(l1_req_cmd),
                     cmd_ptr->cmd.rrc_llc_req.l1_req,
                     sizeof(l1_req_cmd));
      }
    }
    /* delete embedded pointer allocated to TVM */
    else if((cmd_ptr->cmd.rrc_llc_req.cmd_dest == LAYER2_MAC_UL)
      ||(cmd_ptr->cmd.rrc_llc_req.cmd_dest == LAYER2_RLC_UL))
    {
      if(cmd_ptr->cmd.rrc_llc_req.l2_ul_req !=NULL )
      {
        WRRC_MSG1_HIGH("copy l2 UL cmd %d",cmd_ptr->cmd.rrc_llc_req.l2_ul_cmd.cmd_id);
        put_cmd_ptr->cmd.rrc_llc_req.l2_ul_req =
            (l2_ul_req_cmd *)rrc_malloc(sizeof(l2_ul_req_cmd));
        WCDMA_MEMCPY(put_cmd_ptr->cmd.rrc_llc_req.l2_ul_req,
                     sizeof(l2_ul_req_cmd),
                     cmd_ptr->cmd.rrc_llc_req.l2_ul_req,
                     sizeof(l2_ul_req_cmd));
      }
    }
    else if((cmd_ptr->cmd.rrc_llc_req.cmd_dest == LAYER2_RLC_DL)
      ||(cmd_ptr->cmd.rrc_llc_req.cmd_dest == LAYER2_MAC_DL))
    {
      if(cmd_ptr->cmd.rrc_llc_req.l2_dl_req !=NULL )
      {
        WRRC_MSG1_HIGH("copy l2 DL cmd %d",cmd_ptr->cmd.rrc_llc_req.l2_dl_cmd.cmd_id);
        put_cmd_ptr->cmd.rrc_llc_req.l2_dl_req =
           (l2_dl_req_cmd *)rrc_malloc(sizeof(l2_dl_req_cmd));
        WCDMA_MEMCPY(put_cmd_ptr->cmd.rrc_llc_req.l2_dl_req,
                     sizeof(l2_dl_req_cmd),
                     cmd_ptr->cmd.rrc_llc_req.l2_dl_req,
                     sizeof(l2_dl_req_cmd));
      }
    }
    else
    {
      // Add other commands requiring embedded pointers to be freed here
      WRRC_MSG1_ERROR("Unknown type of llc cmd re %d",cmd_ptr->cmd.rrc_llc_req.cmd_dest);
    }
  }
  /* Put the command in the buffer to be processed later */
  rrcllc_put_cmd_buf(put_cmd_ptr);

  return SUCCESS;

} /* end rrcllc_put_cmd_on_queue() */


/*====================================================================
FUNCTION: rrcllc_trash_cmds_till_first_useful()

DESCRIPTION:
  This function is a utility that goes thru LLC internal command
  queue and trashes all commands till 1st command is received that
  has to be processed. These commands are either pre-emptive commands
  like Stop Mode or Deact Lower Layer (coming from upper layers) or
  Acq Req/Freq Scan Req/Reset L1 Req that are enqueued by CSP without
  waiting for completion of processing of an earlier
  Channel Config Req (to Disconnected).

DEPENDENCIES:
  None

RETURN VALUE:
  Next LLC state.

SIDE EFFECTS:
  None.
====================================================================*/
static rrcllc_substate_e_type
rrcllc_trash_cmds_till_first_useful
(
  rrcllc_action_on_config_req_e_type  config_req_action
)
{
  boolean process_cmd = FALSE;
  rrc_cmd_type *llc_stored_cmd_ptr;

  rrcllc_substate_e_type rrcllc_next_substate = LLC_IDLE;

  /* Trash commands in internal LLC queue till one of the commands that
   * have to be processed is received. This could be one of:
   * - RESET_L1, ACQ_REQ, FREQ_SCAN_REQ, CHAN_CONFIG_REQ to Discon,
   *   STOP_LOWER_LAYER, LOWER_LAYER_DEACT
   */
  while(( q_check(&llc_cmd_q) != NULL ) &&
        ( process_cmd == FALSE))
  {
    if( (llc_stored_cmd_ptr = (rrc_cmd_type *) q_get(&llc_cmd_q)) != NULL)
    {
      switch(llc_stored_cmd_ptr->cmd_hdr.cmd_id)
      {
        case RRC_RESET_L1_REQ:
        case RRC_STOP_LOWER_LAYER_REQ:
        case RRC_LOWER_LAYER_DEACT_REQ:
             process_cmd = TRUE;
             break;
  
        case RRC_LLC_CMD_REQ:
             if(llc_stored_cmd_ptr->cmd.rrc_llc_req.cmd_dest == LAYER1_PHY)
             {
               switch(llc_stored_cmd_ptr->cmd.rrc_llc_req.l1_cmd.cmd_id)
               {
                 case CPHY_FREQ_SCAN_REQ:
                 case CPHY_ACQ_REQ:
                 case CPHY_GO_TO_SLEEP_IND:
#ifdef FEATURE_FEMTO_CSG
                 case CPHY_CELL_BAR_REQ:
#endif
               /* Process suspend request after channel config req for inter-RAT
                * redirection through connection release.
                */
                 case CPHY_SUSPEND_WCDMA_MODE_REQ:
                   process_cmd = TRUE;
                   break;
  
                 default:
                   break;
               }
             }
             else if(llc_stored_cmd_ptr->cmd.rrc_llc_req.cmd_dest == LAYER2_MAC_UL)
             {
               switch(llc_stored_cmd_ptr->cmd.rrc_llc_req.l2_ul_cmd.cmd_id)
               {
                 case CMAC_UL_TRAFFIC_VOLUME_CONFIG_REQ:
                 case CMAC_UL_BLOCK_RACH_TRAFFIC_REQ:
                   process_cmd = TRUE;
                   break;
  
                 default:
                   break;
               }
             }
             break;
  
        case RRC_CHANNEL_CONFIG_REQ:
             if(((llc_stored_cmd_ptr->cmd.chan_config_req.next_state ==
                  RRC_STATE_DISCONNECTED) &&
                 (llc_stored_cmd_ptr->cmd.chan_config_req.rrc_state_change_required)) 
                )
             {
               if(config_req_action == TRASH_CONFIG_REQ)
               {
                 /* Send a Success to the sender without doing anything
                  * - too far ahead in the game, sending an Idle at this
                  * point will make RRC and L1 go out of sync.
                  */
                 (void)rrcllc_send_rrc_channel_config_cnf(llc_stored_cmd_ptr->cmd.
                       chan_config_req.procedure,
                       llc_stored_cmd_ptr->cmd.chan_config_req.transaction_id,
                       RRCLLC_CHAN_CFG_SUCCESS);
               }
               else
               {
                 process_cmd = TRUE;
               }
             }
             else
             {
               /* Send a Failure to the sender */
               (void)rrcllc_send_rrc_channel_config_cnf(llc_stored_cmd_ptr->cmd.chan_config_req.procedure,
                             llc_stored_cmd_ptr->cmd.chan_config_req.transaction_id,
                             RRCLLC_CHAN_CFG_FAILURE_INCOMPATIBLE_STATE);
             }
             break;
  
        default:
          break;
      }
      if(process_cmd)
      {
        if((llc_stored_cmd_ptr->cmd_hdr.cmd_id ==RRC_LLC_CMD_REQ) &&
            (llc_stored_cmd_ptr->cmd.rrc_llc_req.cmd_dest == LAYER2_MAC_UL))
        {
          if((llc_stored_cmd_ptr->cmd.rrc_llc_req.l2_ul_cmd.cmd_id == CMAC_UL_TRAFFIC_VOLUME_CONFIG_REQ)
            ||( llc_stored_cmd_ptr->cmd.rrc_llc_req.l2_ul_cmd.cmd_id == CMAC_UL_BLOCK_RACH_TRAFFIC_REQ))
          {
            /* Continue trashing the rest of the msg */
            process_cmd= FALSE;
            WRRC_MSG0_HIGH("Process the MAC Req and continue with the trash logic");
          }
        }
        rrcllc_next_substate = rrcllc_idle_handler(llc_stored_cmd_ptr);
        rrcllc_free_cmd_buf(llc_stored_cmd_ptr);
        llc_stored_cmd_ptr = NULL;
      }
      else
      {
        rrcllc_free_cmd_and_embedded_buf(llc_stored_cmd_ptr);
        llc_stored_cmd_ptr = NULL;
      }
    }
  } /* while (...) */
  /* No more commands in LLC queue - OR -
   * 1st valid command has been processed.
   * Get out of here
   */

  return(rrcllc_next_substate);

} /* rrcllc_trash_cmds_till_first_useful */


/*******************************************************************
**          LLC CCTrCH management utilities
**
********************************************************************/


/*====================================================================
FUNCTION: rrcllc_get_cctrch_id()

DESCRIPTION:
  This function manages CCTrCH Id's for the UE.

DEPENDENCIES:
  None.

RETURN VALUE:
  uint8 -> A CCTrCH ID that can be used.

SIDE EFFECTS:
  cctrch_id = 0xFF -> indicates no CCTrCHs are available.
====================================================================*/
uint8 rrcllc_get_cctrch_id(void)
{
  uint8 cctrch_id; /* local loop variable */

  /* check for a valid CCTrCH ID */
  for(cctrch_id = 0; cctrch_id < (UE_MAX_CCTRCH-1); cctrch_id++)
  {
    if (cctrch_id_in_use[cctrch_id] == FALSE)
    {
      /*
      * If this case holds true, indicate that this CCTrCH ID is used,
      * break the for loop and use this index as the CCTrCH ID.
      */
      cctrch_id_in_use[cctrch_id] = TRUE;
      break;
    }
  }

  if (cctrch_id == (UE_MAX_CCTRCH-1))
  {
    /* 255 indicates no available CCTrCHs */
    cctrch_id = RRCLLC_INVALID_CCTRCH_ID;
  }
  /* always return a CCTrCH Id */
  WRRC_MSG1_HIGH("Allocate %d CCTrCH ID", cctrch_id);
  return cctrch_id;

} /* end rrcllc_get_cctrch_id() */

/*====================================================================
FUNCTION: rrcllc_clear_cctrch_id()

DESCRIPTION:
  This function clears a CCTrCH Id for later UE use.

DEPENDENCIES:
  None.

RETURN VALUE:
  ue_comdef_status_e_type -> SUCCESS indicates a CCTrCH ID was cleared
                             FAILURE indicates a CCTrCH ID was not cleared

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_clear_cctrch_id(uint8 cctrch_id)
{
  uecomdef_status_e_type status = SUCCESS;
  /*
  * Check to make sure that the CCTrCH id is in range and then
  *
  */
  if(cctrch_id < UE_MAX_CCTRCH -1)
  {
    cctrch_id_in_use[cctrch_id] = FALSE;
  }
  else
  {
    /* a zero indicates no available CCTrCHs */
    MSG_MED("Cannot free an invalid CCTrCH",0,0,0);
    status = FAILURE;
  }

  WRRC_MSG1_HIGH("Clear %d CCTrCH ID", cctrch_id);
  return status;
} /* end clear_ccrch_id() */


/*******************************************************************
**          LLC Initialization utilities
**
********************************************************************/

/*====================================================================
FUNCTION: rrcllc_set_fach_included()

DESCRIPTION:
  This function sets the fach_included flag in
  rrcllc_semi_permanent_data to the boolean value as indicated
  by the passed parameter.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void  rrcllc_set_fach_included(boolean status)
{
  rrcllc_semi_permanent_data.dl_phy_chan.fach_included = status;
}

/*====================================================================
FUNCTION: rrcllc_set_pch_included()

DESCRIPTION:
  This function sets the pch_included flag in
  rrcllc_semi_permanent_data to the boolean value as indicated
  by the passed parameter.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void  rrcllc_set_pch_included(boolean status)
{
  rrcllc_semi_permanent_data.dl_phy_chan.pch_included = status;
}


 /*====================================================================
FUNCTION: rrcllc_set_ctch_included()

DESCRIPTION:
  This function sets the pch_included flag in
  rrcllc_semi_permanent_data to the rrcllc_ctch_status_e_type value as indicated
  by the passed parameter.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void  rrcllc_set_ctch_included(rrcllc_ctch_status_e_type status)
{
  rrcllc_semi_permanent_data.dl_phy_chan.ctch_status = status;
}

/*====================================================================
FUNCTION: rrcllc_set_pch_included_for_sccpch_with_ctch()

DESCRIPTION:
  This function sets the pch_included_for_sccpch_with_ctch flag in
  rrcllc_semi_permanent_data to the boolean value as indicated
  by the passed parameter.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void  rrcllc_set_pch_included_for_sccpch_with_ctch(boolean status)
{
  rrcllc_semi_permanent_data.dl_phy_chan.pch_included_for_sccpch_with_ctch = status;
}



/*===========================================================================
FUNCTION    rrcllc_init_cmd_under_process_data

DESCRIPTION
  This function initializes the RRC LLC command under process data.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.
===========================================================================*/
static void rrcllc_init_cmd_under_process_data(void)
{
  uint8 l1_req_index;
  /* Invalidate the data first */
  rrcllc_cmd_under_process.valid = FALSE;
  rrcllc_cmd_under_process.procedure = RRC_PROCEDURE_NONE;
  rrcllc_cmd_under_process.rrc_current_cmd_id = RRC_INT_CMD_BASE;
  rrcllc_cmd_under_process.clear_oc_pending = FALSE;
  rrcllc_cmd_under_process.update_mac_with_rnti = FALSE;
  rrcllc_cmd_under_process.sccpch_selec_reqd = FALSE;
  rrcllc_cmd_under_process.chan_config.solo_bch_operation = FALSE;

  rrcllc_cmd_under_process.chan_config.chan_est_ind_rcvd = FALSE;
  rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_NO_ENGINE;
  rrcllc_cmd_under_process.chan_config.chan_config_reason = RRCLLC_CHAN_CFG_REASON_NONE;
  rrcllc_cmd_under_process.chan_config.new_freq = FALSE;
  rrcllc_cmd_under_process.is_hho_in_dch = FALSE;
#ifdef FEATURE_WCDMA_DC_HSUPA
  rrcllc_cmd_under_process.chan_config.sec_eul_new_freq = FALSE;
  rrcllc_cmd_under_process.is_hho_in_dch_for_sec_eul= FALSE;
  
#endif /* FEATURE_WCDMA_DC_HSUPA */

  rrcllc_cmd_under_process.chan_config.hsdpa_inactive_to_active = FALSE;
  rrcllc_cmd_under_process.chan_config.hsdpa_active_to_inactive = FALSE;
  rrcllc_cmd_under_process.chan_config.hsdpa_ehs_to_hs = FALSE;
  rrcllc_cmd_under_process.chan_config.hsdpa_hs_to_ehs = FALSE;
  /* Set number of CCTrCH IDs to release to 0 */
  rrcllc_cmd_under_process.chan_config.cctrch_id_release_list.num_ids = 0;

  /* Set number of stored L1 requests to 0 */
  rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req = 0;
  rrcllc_cmd_under_process.chan_config.l1_req_list.current_l1_req = -1;
  /* Initialize all L1 command buffers so they don't have any residual data values */
  for(l1_req_index=0; l1_req_index<LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD; l1_req_index++)
  {
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.hsdpa_l1_ops = HSDPA_SETUP_OPS_NOOP;
        rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.hsdpa_l1_info = NULL;
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.dl_phychan = L1_DL_PHYCHAN_NOCHAN;
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.dl_phychan_db = NULL;
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.drop_dl_phychan = L1_DL_PHYCHAN_NOCHAN;
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.dl_cctrch_info = NULL;
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.dl_ctfc_info = NULL;


    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.ul_phychan = L1_UL_NUM_PHYCHAN;
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.ul_phychan_db = NULL;
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.drop_ul_phychan = L1_UL_NUM_PHYCHAN;
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.ul_cctrch_info = NULL;

    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.req_mask = 0;
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.hho_setup_mask = 0;
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.rf_chan = 0;
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.freq_incl = FALSE;
#ifdef FEATURE_WCDMA_MTPL_THERMAL_BACKOFF 
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.is_emergency_call = FALSE;
#endif
#ifdef FEATURE_WCDMA_HS_RACH
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.hs_rach_req_mask = L1_HS_RACH_NO_OP;
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.hs_rach_e_info_ptr = NULL;
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.transition_to_dch = FALSE;
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.common_e_dch_resource_list = NULL;
#endif
#ifdef FEATURE_WCDMA_DC_HSUPA
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.sec_dl_phychan = L1_DL_PHYCHAN_NOCHAN;
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.sec_drop_dl_phychan = L1_DL_PHYCHAN_NOCHAN;
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.sec_hho_setup_mask = 0;
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.sec_rf_chan = 0;
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.sec_freq_incl = FALSE;
  
  
#endif /* FEATURE_WCDMA_DC_HSUPA */
#ifdef FEATURE_WCDMA_DC_HSDPA
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.revert_old_config = FALSE;
#endif
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.l1_rrc_config_rab = RAB_TYPE_NONE;
  }   /* for(...) */

  /* Initialize RLC config request list with number of logical channels
   * for each logical channel type set to 0
   */
  rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.nchan = 0;
  rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.nchan = 0;
  rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.nchan = 0;

  for(l1_req_index=0; l1_req_index < UE_MAX_DL_UM_CHANNEL; l1_req_index++)
  {
    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[l1_req_index].alternate_e_bit = FALSE;
  }
  for(l1_req_index=0; l1_req_index < UE_MAX_UL_UM_CHANNEL; l1_req_index++)
  {
    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.chan_info[l1_req_index].alternate_e_bit = FALSE;
  }  
#ifdef FEATURE_MAC_I
  for(l1_req_index=0; l1_req_index < UE_MAX_UL_UM_CHANNEL; l1_req_index++)
  {
    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.chan_info[l1_req_index].ul_flex_pdu_size= RLC_INVALID_PDU_SIZE;
    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.chan_info[l1_req_index].ul_flex_min_pdu_size= RRC_UL_INVALID_RLC_SIZE;
  }  
#endif /*FEATURE_MAC_I*/
  
  rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.nchan = 0;

  rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.nentity = 0;

#ifdef FEATURE_UMTS_PDCP
  rrcllc_cmd_under_process.chan_config.pdcp_config_req_list.num_rbs = 0;
#endif /* FEATURE_UMTS_PDCP */

  /* Initialize each of the physical channel action data */
  rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action
    = LLC_PHYCHAN_NO_OP;
  rrcllc_cmd_under_process.chan_config.phy_chan_action_list.n_pccpch_action
    = LLC_PHYCHAN_NO_OP;
  rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_action
    = LLC_PHYCHAN_NO_OP;
  rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_for_ctch_action
    = LLC_PHYCHAN_NO_OP;
  rrcllc_cmd_under_process.chan_config.phy_chan_action_list.ul_dpch_action
    = LLC_PHYCHAN_NO_OP;
  rrcllc_cmd_under_process.chan_config.phy_chan_action_list.dl_dpch_action
    = LLC_PHYCHAN_NO_OP;
  rrcllc_cmd_under_process.chan_config.phy_chan_action_list.prach_action
    = LLC_PHYCHAN_NO_OP;
  rrcllc_cmd_under_process.chan_config.phy_chan_action_list.aset_update
    = FALSE;
#ifdef FEATURE_WCDMA_DC_HSUPA

  rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sec_eul_aset_update
    = FALSE;
  
#endif /* FEATURE_WCDMA_DC_HSUPA */

  /* Initialize the loopback test mode to "None" */
  rrcllc_cmd_under_process.chan_config.lb_test_mode = LB_TEST_MODE_NONE;
  rrcllc_cmd_under_process.chan_config.dummy_signaling_enabled = FALSE;

  /* Initialise status of Channel Config Request */
  rrcllc_cmd_under_process.chan_config.chan_cfg_status = RRCLLC_CHAN_CFG_SUCCESS;

  rrcllc_cmd_under_process.err_recovery_in_progress = FALSE;
  /* initialize the rlc_rel_list that is used for failure handling */

  rlc_rel_list.dl_tm.nchan = 0;
  rlc_rel_list.ul_tm.nchan = 0;
  rlc_rel_list.dl_um.nchan = 0;
  rlc_rel_list.ul_um.nchan = 0;
  rlc_rel_list.am.nentity = 0;

  memset(&rrc_backup_rnti_info,0,sizeof(mac_rnti_config_type));

} /* rrcllc_init_cmd_under_process_data */


/*====================================================================
FUNCTION: rrcllc_init()

DESCRIPTION:
  This function initializes all RRCLLC data including CCTrCH ID database,
  Command under process data, LLC internal queue and
  the ORDERED_CONFIG databases. This calls a number of other
  initialization functions.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init(rrcllc_init_e_type  init_type)
{
  /* command pointer for LLC */
  rrc_cmd_type     *cmd_ptr;
  rrc_cmd_type     *llc_stored_cmd_ptr;

  WRRC_MSG1_HIGH("initialize rrcllc init_type:%d", init_type);

  /* Check if this initialization is at the startup time */
  if(init_type == RRCLLC_STARTUP_INIT)
  {
    /* Initialize the RRC LLC command queue */
    rrcllc_queue_init();
  }
  else if(init_type == RRCLLC_RE_INIT_FREE_Q)
  {
    /* Dequeue internal LLC queue and free all buffers */
    while( q_check(&llc_cmd_q) != NULL )
    {
      if( (llc_stored_cmd_ptr = (rrc_cmd_type *) q_get(&llc_cmd_q)) != NULL )
      {
        /* If Measurement request or TVM is found also free the
               * embedded pointer inside the command
               */
        rrcllc_free_cmd_and_embedded_buf(llc_stored_cmd_ptr);
        llc_stored_cmd_ptr = NULL;
      }
    }
  }
  /* Initialize the CCTrCH ID's */
  rrcllc_init_cctrch_id();

  /* Initialize Command under process data */
  rrcllc_init_cmd_under_process_data();

  if(init_type == RRCLLC_STARTUP_INIT)
  {
    transition_config.toc_ptr = NULL;
    current_config_ptr = NULL;
    ordered_config_ptr = NULL;

    rrc_set_hsdpa_action(HSDPA_NOOP);
    rrc_set_hsdpa_status(HSDPA_INACTIVE);

    /* Initialize no of RLC size per RB Struct */

    rrc_initialize_rlc_size_per_rb();
    rrc_initialize_rlc_size_change();

    /* Send Layer 1 to their Idle State */
    cmd_ptr = rrc_get_int_cmd_buf();

    /* Reset L1 */
    cmd_ptr->cmd_hdr.cmd_id = RRC_RESET_L1_REQ;
#ifdef FEATURE_DUAL_SIM
    cmd_ptr->cmd.rrc_reset_l1_req.reset_l1_cnf_needed = FALSE;
#endif
    rrc_put_int_cmd(cmd_ptr);

    transition_config.toc_usage = TOC_INVALID;
    toc_usage_change_oos_to_dch = FALSE;

  }
  /* Initialize current physical channel data for all DL physical channels */
  rrcllc_init_semi_permanent_data();

  return;
} /* rrcllc_init */

 /*====================================================================
FUNCTION: rrcllc_update_generic_cmd_process_data_for_failure()

DESCRIPTION:
  This function updates all generic fields in rrcllc_cmd_under_process
  which are NOT dependent on the RRC internal command under process

DEPENDENCIES:
  None
RETURN VALUE:
  None.
SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_update_generic_cmd_process_data_for_failure(void)
{
 /* do not delete command id, procedure id, transaction id rrc_state,chan_est_ind_rcvd cnf_needed */
  uint8 l1_req_index;
  /* Invalidate the data first */
  rrcllc_cmd_under_process.update_mac_with_rnti = FALSE;

  rrcllc_cmd_under_process.chan_config.new_freq = FALSE;
  rrcllc_cmd_under_process.is_hho_in_dch = FALSE;

#ifdef FEATURE_WCDMA_DC_HSUPA
  rrcllc_cmd_under_process.chan_config.sec_eul_new_freq = FALSE;
  rrcllc_cmd_under_process.is_hho_in_dch_for_sec_eul= FALSE;

#endif /* FEATURE_WCDMA_DC_HSUPA */
  rrcllc_cmd_under_process.valid = TRUE;

  /* Set number of CCTrCH IDs to release to 0 */
  rrcllc_cmd_under_process.chan_config.cctrch_id_release_list.num_ids = 0;

  /* Set number of stored L1 requests to 0 */
  rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req = 0;
  rrcllc_cmd_under_process.chan_config.l1_req_list.current_l1_req = -1;
  /* Initialize all L1 command buffers so they don't have any residual data values */
  for(l1_req_index=0; l1_req_index<LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD; l1_req_index++)
  {

    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.dl_phychan = L1_DL_PHYCHAN_NOCHAN;
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.dl_phychan_db = NULL;
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.drop_dl_phychan = L1_DL_PHYCHAN_NOCHAN;
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.dl_cctrch_info = NULL;
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.dl_ctfc_info = NULL;

    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.ul_phychan = L1_UL_NUM_PHYCHAN;
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.ul_phychan_db = NULL;
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.drop_ul_phychan = L1_UL_NUM_PHYCHAN;
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.ul_cctrch_info = NULL;

    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.req_mask = 0;
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.hho_setup_mask = 0;
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.rf_chan = 0;
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.freq_incl = FALSE;


#ifdef FEATURE_WCDMA_DC_HSUPA
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.sec_dl_phychan = L1_DL_PHYCHAN_NOCHAN;
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.sec_drop_dl_phychan = L1_DL_PHYCHAN_NOCHAN;
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.sec_hho_setup_mask = 0;
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.sec_rf_chan = 0;
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.sec_freq_incl = FALSE;


#endif /* FEATURE_WCDMA_DC_HSUPA */


  }   /* for(...) */

  /* Initialize RLC config request list with number of logical channels
   * for each logical channel type set to 0
   */
  rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.nchan = 0;
  rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.nchan = 0;
  rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.nchan = 0;
  rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.nchan = 0;

  rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.nentity = 0;

  /* Initialize each of the physical channel action data */
  rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action
    = LLC_PHYCHAN_NO_OP;
  rrcllc_cmd_under_process.chan_config.phy_chan_action_list.n_pccpch_action
    = LLC_PHYCHAN_NO_OP;
  rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_action
    = LLC_PHYCHAN_NO_OP;
  rrcllc_cmd_under_process.chan_config.phy_chan_action_list.ul_dpch_action
    = LLC_PHYCHAN_NO_OP;
  rrcllc_cmd_under_process.chan_config.phy_chan_action_list.dl_dpch_action
    = LLC_PHYCHAN_NO_OP;
  rrcllc_cmd_under_process.chan_config.phy_chan_action_list.prach_action
    = LLC_PHYCHAN_NO_OP;
  rrcllc_cmd_under_process.chan_config.phy_chan_action_list.aset_update
    = FALSE;

#ifdef FEATURE_WCDMA_DC_HSUPA

  rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sec_eul_aset_update
    = FALSE;

#endif /* FEATURE_WCDMA_DC_HSUPA */


  /* Initialize the loopback test mode to "None" */
  rrcllc_cmd_under_process.chan_config.lb_test_mode = LB_TEST_MODE_NONE;
  rrcllc_cmd_under_process.chan_config.dummy_signaling_enabled = FALSE;

  rrcllc_cmd_under_process.err_recovery_in_progress = FALSE;
  /* initialize the rlc_rel_list that is used for failure handling */

  rlc_rel_list.dl_tm.nchan = 0;
  rlc_rel_list.ul_tm.nchan = 0;
  rlc_rel_list.dl_um.nchan = 0;
  rlc_rel_list.ul_um.nchan = 0;
  rlc_rel_list.am.nentity = 0;

} /* rrcllc_update_generic_cmd_process_data */

/*====================================================================
FUNCTION: rrcllc_restore_urnti_to_oc_from_toc()

DESCRIPTION:
  This Function restore the URNTI value to OC from TOC

DEPENDENCIES:
None

RETUN VALUE:
None

SIDE EFFECTS:
None
====================================================================*/
static void rrcllc_restore_urnti_to_oc_from_toc
(
void
)
{
   /*Restore the URNTI to the OC as it is still valid*/
    if(transition_config.toc_usage != TOC_INVALID)
    {
      MSG_4(MSG_SSID_DFLT, MSG_LEGACY_HIGH,"TOC: DL RNTI status %d, UL RNTI status %d, DL URNTI %d, UL URNTI %d. Restore to OC if valid ", transition_config.toc_ptr->mac_dl_parms.rnti_info.rnti_valid, transition_config.toc_ptr->mac_ul_parms.rnti_info.rnti_valid,
        transition_config.toc_ptr->mac_dl_parms.rnti_info.urnti, transition_config.toc_ptr->mac_ul_parms.rnti_info.urnti);
      
      if ((transition_config.toc_ptr->mac_dl_parms.rnti_info.rnti_valid == BOTH_VALID)||
          (transition_config.toc_ptr->mac_dl_parms.rnti_info.rnti_valid == URNTI_VALID))
      {

        /* copy the rnti information to both oc and cc */
        ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = URNTI_VALID;
        ordered_config_ptr->mac_dl_parms.rnti_info.urnti = 
          transition_config.toc_ptr->mac_dl_parms.rnti_info.urnti;
      }
      if ((transition_config.toc_ptr->mac_ul_parms.rnti_info.rnti_valid == BOTH_VALID)||
          (transition_config.toc_ptr->mac_ul_parms.rnti_info.rnti_valid == URNTI_VALID))
      {
        ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = URNTI_VALID;
        ordered_config_ptr->mac_ul_parms.rnti_info.urnti=
          transition_config.toc_ptr->mac_ul_parms.rnti_info.urnti;
      }
    }
}
/*====================================================================
FUNCTION: rrcllc_update_generic_cmd_process_data()

DESCRIPTION:
  This function updates all generic fields in rrcllc_cmd_under_process
  which are NOT dependent on the RRC internal command under process

DEPENDENCIES:
  None
RETURN VALUE:
  None.
SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_update_generic_cmd_process_data(rrc_cmd_type *cmd_ptr)
{
  rrcllc_cmd_under_process.rrc_current_cmd_id = cmd_ptr->cmd_hdr.cmd_id;

  if(cmd_ptr->cmd_hdr.cmd_id == RRC_CHANNEL_CONFIG_REQ)
  {
    rrcllc_cmd_under_process.procedure = cmd_ptr->cmd.chan_config_req.procedure;
    rrcllc_cmd_under_process.chan_config_transaction_id =
    cmd_ptr->cmd.chan_config_req.transaction_id;
    /* Get the next RRC state from command if so indicated */
    if(cmd_ptr->cmd.chan_config_req.rrc_state_change_required)
    {
      rrcllc_cmd_under_process.next_rrc_state = cmd_ptr->cmd.chan_config_req.next_state;
    }
    else
    {
      rrcllc_cmd_under_process.next_rrc_state = rrc_get_state();
    }
  }
  else if( cmd_ptr->cmd_hdr.cmd_id == RRC_LLC_CMD_REQ)
  {
    /* This is an LLC command request (funneling command) */
    rrcllc_cmd_under_process.procedure = cmd_ptr->cmd.rrc_llc_req.procedure;
    /* For all commands other than RRC_CHANNEL_CONFIG_REQ, no RRC state change is needed */
    rrcllc_cmd_under_process.next_rrc_state = rrc_get_state();
  }
  else if( cmd_ptr->cmd_hdr.cmd_id == RRC_CELL_RESELECTION_REQ)
  {
    /* This is cell reselection request sent by CCM */
    rrcllc_cmd_under_process.procedure = cmd_ptr->cmd.cell_resel_req.procedure;
    rrcllc_cmd_under_process.next_rrc_state = rrc_get_state();
  }
  else if( cmd_ptr->cmd_hdr.cmd_id == RRC_STOP_LOWER_LAYER_REQ)
  {
    /* Initialize the procedure and stop cause here */
    rrcllc_cmd_under_process.procedure = cmd_ptr->cmd.stop_lower_layer_req.procedure;
    rrcllc_cmd_under_process.wcdma_stop_cause = cmd_ptr->cmd.stop_lower_layer_req.cause;
  }
  else if( cmd_ptr->cmd_hdr.cmd_id == RRC_LOWER_LAYER_DEACT_REQ)
  {
    /* Initialize the deactivation reason here */
    rrcllc_cmd_under_process.wcdma_deact_reason = cmd_ptr->cmd.lower_layer_deact_req.deact_reason;
  }
  else if( cmd_ptr->cmd_hdr.cmd_id == RRC_RNTI_UPDATE_REQ)
  {
    rrcllc_cmd_under_process.procedure = cmd_ptr->cmd.rnti_update_req.procedure;
    rrcllc_cmd_under_process.next_rrc_state = rrc_get_state();
    rrcllc_cmd_under_process.rnti_update_cnf_needed =
      cmd_ptr->cmd.rnti_update_req.cnf_required;
  }
  else if( cmd_ptr->cmd_hdr.cmd_id == RRC_LLC_RE_EST_RLC_REQ)
  {
    rrcllc_cmd_under_process.rlc_re_est_rbs = cmd_ptr->cmd.rrc_re_est_req.am_config.rb_type;
  }
  else if (cmd_ptr->cmd_hdr.cmd_id == RRC_CONN_MODE_DEEP_SLEEP_REQ) 
  {
    /* This is currently being sent by CSP only.  So hard code the proc id for now to CSP */
    rrcllc_cmd_under_process.procedure = RRC_PROCEDURE_CSP;
    rrcllc_cmd_under_process.valid = TRUE;
    rrcllc_cmd_under_process.rrc_current_cmd_id = RRC_CONN_MODE_DEEP_SLEEP_REQ;

  }
  else if (cmd_ptr->cmd_hdr.cmd_id == RRC_CONN_MODE_DEEP_SLEEP_WAKEUP_REQ) 
  {
    /* This is currently being sent by CSP only.  So hard code the proc id for now to CSP */
    rrcllc_cmd_under_process.procedure = RRC_PROCEDURE_CSP;
    rrcllc_cmd_under_process.valid = TRUE;
    rrcllc_cmd_under_process.rrc_current_cmd_id = RRC_CONN_MODE_DEEP_SLEEP_WAKEUP_REQ;

  }
#ifdef FEATURE_DUAL_SIM
  else if(cmd_ptr->cmd_hdr.cmd_id == RRC_RESET_L1_REQ)
  {
    rrcllc_cmd_under_process.send_reset_l1_cnf = cmd_ptr->cmd.rrc_reset_l1_req.reset_l1_cnf_needed;
  }
#endif
  else
  {
    /* This is a case for other commands sent to LLC from RRC procedures.
     * TBD: At present, there is only RRC_RESET_REQ which does not have a procedure
     * associated with it. Only store the command ID
     */
  }
  /* Now validate command under process data */
  rrcllc_cmd_under_process.valid = TRUE;
} /* rrcllc_update_generic_cmd_process_data */


/*********************************************************************
**          Utilities to send Confirmations
**
**********************************************************************/

/*====================================================================
FUNCTION: rrcllc_send_rrc_channel_config_cnf()

DESCRIPTION:
  This function constructs the RRC_CHANNEL_CONFIG_CNF primitive and
  sends it to the passed RRC procedure.

DEPENDENCIES:
  None

RETURN VALUE:
  uecomdef_status_e_type -> indicating a SUCCESS or FAILURE

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type
rrcllc_send_rrc_channel_config_cnf
(
 rrc_proc_e_type               proc_type,
 uint32                        transaction_id,
 rrcllc_chan_cfg_status_e_type chan_cfg_status
)
{
  rrc_cmd_type  *rrc_cmd_ptr;
#ifdef FEATURE_DUAL_SIM
  rrc_csp_scan_e_type curr_scan = rrccsp_get_curr_scan();
#endif
  rrc_cmd_ptr = rrc_get_int_cmd_buf();

  WRRC_MSG2_HIGH("Sending CHANNEL_CONFIG_CNF, proc rrc_proc_e_type_value%d, status %d",proc_type,chan_cfg_status);

  /* Fill in the local command header.*/
  rrc_cmd_ptr->cmd_hdr.cmd_id = RRC_CHANNEL_CONFIG_CNF;
  rrc_cmd_ptr->cmd.chan_config_cnf.procedure =  proc_type;
  rrc_cmd_ptr->cmd.chan_config_cnf.transaction_id =  transaction_id;
  rrc_cmd_ptr->cmd.chan_config_cnf.chan_cfg_status = chan_cfg_status;
  rrc_cmd_ptr->cmd.chan_config_cnf.compressed_mode_status = FALSE;

  if ((chan_cfg_status != RRCLLC_CHAN_CFG_SUCCESS) && (compressed_mode_fail_status == TRUE))
  {
    WRRC_MSG0_ERROR("Setting CM Fail Status");
    rrc_cmd_ptr->cmd.chan_config_cnf.compressed_mode_status =
      compressed_mode_fail_status;

    /* Now set back the compressed_mode_fail_status to default value i.e. FALSE */
    compressed_mode_fail_status =  FALSE;
  }

  if(rrcllc_cmd_under_process.chan_config.hho_ciph_update_required == TRUE)
  {
    rrc_cmd_ptr->cmd.chan_config_cnf.inter_freq_hho_status = TRUE;
    rrcllc_cmd_under_process.chan_config.hho_ciph_update_required = FALSE;
  }
  else
  {
    rrc_cmd_ptr->cmd.chan_config_cnf.inter_freq_hho_status = FALSE;
  }

  if((proc_type == RRC_PROCEDURE_RBE) || (proc_type == RRC_PROCEDURE_RBRC) || (proc_type == RRC_PROCEDURE_RBR) 
    || (proc_type == RRC_PROCEDURE_TCR) || (proc_type == RRC_PROCEDURE_PCR) || (proc_type == RRC_PROCEDURE_CU))
  {
    if(chan_cfg_status == RRCLLC_CHAN_CFG_SUCCESS)
    {
      rrc_log_event_inter_freq_hho_update_status(RRC_LOG_INTER_FREQ_HHO_SUCCESS);
    }
    else
    {
      rrc_log_event_inter_freq_hho_update_status(RRC_LOG_INTER_FREQ_HHO_FAILURE);
    }
  }

  if((chan_cfg_status != RRCLLC_CHAN_CFG_SUCCESS) &&
     ((proc_type == RRC_PROCEDURE_CU)
          || (proc_type == RRC_PROCEDURE_PCR) 
          || (proc_type == RRC_PROCEDURE_RBE)
          || (proc_type == RRC_PROCEDURE_RBR)
          || (proc_type == RRC_PROCEDURE_RBRC)
          || (proc_type == RRC_PROCEDURE_TCR)) 
    )
  {
    WRRC_MSG1_HIGH("inter_freq_hho_status:%d",
      rrc_cmd_ptr->cmd.chan_config_cnf.inter_freq_hho_status);
        /* If Step-1 is done and channel config fails, we need to revert to old cipher config */
        /* This will take care of the scenario of param validation failure at L1 for cphy-setup*/
        /* Revert may not be needed for CU procedure as CU can not set step 1, but no harm in calling
           as we protect the revert with a check */
	rrcsmc_revert_to_old_config_for_failure_message(TRUE);
  }

#ifdef WCDMA_RRC_INDICATE_CODEC_TO_CM
  if(RRC_STATE_CELL_DCH == rrcllc_cmd_under_process.next_rrc_state &&
    ((proc_type == RRC_PROCEDURE_PCR) 
      || (proc_type == RRC_PROCEDURE_RBE)
      || (proc_type == RRC_PROCEDURE_RBR)
      || (proc_type == RRC_PROCEDURE_RBRC)
      || (proc_type == RRC_PROCEDURE_TCR)))
  {
      if(RRCLLC_CHAN_CFG_SUCCESS != chan_cfg_status)
      {
        /*Send HHO complete to CM*/
        rrc_send_hho_cmd_to_cm(SYS_HO_FAIL,SYS_HO_TYPE_UMTS_UMTS);
      }
      else
      {
              /*Send HHO complete to CM*/
        rrc_send_hho_cmd_to_cm(SYS_HO_COMPLETE,SYS_HO_TYPE_UMTS_UMTS);
      }
      rrc_set_ordered_codec_status(FALSE);
  }
#endif
  /* Send the internal command */
  rrc_put_int_cmd(rrc_cmd_ptr);

  if ((proc_type == RRC_PROCEDURE_RCE) ||
      (proc_type == RRC_PROCEDURE_RBE) ||
      (proc_type == RRC_PROCEDURE_RBRC) ||
      (proc_type == RRC_PROCEDURE_RBR) ||
      (proc_type == RRC_PROCEDURE_TCR) ||
      (proc_type == RRC_PROCEDURE_PCR) ||
      (proc_type == RRC_PROCEDURE_CU) ||
      (proc_type == RRC_PROCEDURE_ASU) ||
      (proc_type == RRC_PROCEDURE_RCR) ||
      (proc_type == RRC_PROCEDURE_CHO) ||
      (proc_type == RRC_PROCEDURE_IHO)
      ||((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)
            &&(rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
            ))
  {
    /*Now we reset the HSDPA action for MAC and hs_reset_mask for L1 in Config DB*/
    rrcllc_reset_mac_and_l1_for_hsdpa();  

#ifdef FEATURE_HSPA_CALL_STATUS_IND
#ifdef FEATURE_QCHAT
    if (qchatupk_wcdma_faopts_enabled() &&
      qchatupk_delay_hspa_call_status_ind())
    {
      WRRC_MSG0_HIGH("QChat: delaying rrc_send_hspa_call_status_info for QChat");
    }
    else
#endif /* FEATURE_QCHAT */
    {
      rrc_send_hspa_call_status_info();
    }
#endif /*FEATURE_HSPA_CALL_STATUS_IND*/

#ifdef FEATURE_WCDMA_HS_RACH
  rrcllc_reset_mac_and_l1_for_hsrach(FALSE);
#endif
    rrcllc_reset_mac_and_l1_e_info_on_llc_cfg_cnf();

    if((chan_cfg_status == RRCLLC_CHAN_CFG_FAILURE_BACK_TO_OLD_CONFIG)&&
       (current_config_ptr->e_dch_transmission)&&
       (current_config_ptr->l1_e_req_mask != L1_EUL_NOOP))
    {
      /* clean up the EUL flags in CURRENT CONFIG PTR because 
      *we use CC to update bit masks for going back to old config 
      *seefunction rrcllc_set_e_req_mask_for_old_config()
      */
      WRRC_MSG0_HIGH("RRCEUL:Init EUL flgs from CC as CC->OC copy done");
      rrcllc_init_e_dch_info_before_msg_processing(current_config_ptr);
    }

    /*as part of Resume handler we would have set  current_config_ptr->l1_e_req_mask = START & after CHANC_CONFIG_CNF we don't do Swap OC and CC */
    if (((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_IHO || rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CHO)&&
                    (rrc_get_state()==RRC_STATE_CELL_DCH) &&
                    (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_DCH))
#ifdef FEATURE_DUAL_SIM
          ||((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)
                &&(rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
                &&(curr_scan == RRC_CSP_UNLOCK_BY_SCAN))
#endif 
            )
    {
      if( (current_config_ptr->e_dch_transmission)&&
           (current_config_ptr->l1_e_req_mask != L1_EUL_NOOP))
      {
        WRRC_MSG1_HIGH("RRCEUL:Reset l1_e_req_mask <Prev value=%d> in CC", current_config_ptr->l1_e_req_mask);
        current_config_ptr->l1_e_req_mask = L1_EUL_NOOP;
      }
    }

#ifdef FEATURE_WCDMA_DC_HSUPA

    rrcllc_reset_mac_and_l1_sec_e_info_on_llc_cfg_cnf();

    if((chan_cfg_status == RRCLLC_CHAN_CFG_FAILURE_BACK_TO_OLD_CONFIG)&&
       (current_config_ptr->sec_e_dch_transmission)&&
       (current_config_ptr->l1_sec_e_req_mask != L1_EUL_NOOP))
    {
      /* clean up the SEC EUL flags in CURRENT CONFIG PTR because 
      *we use CC to update bit masks for going back to old config 
      *see function rrcllc_set_sec_e_req_mask_for_old_config()
      */
      WRRC_MSG0_HIGH("DC_HSUPA:Init SECEUL flgs from CC as CC->OC copy done");
      rrcllc_init_sec_e_dch_info_before_msg_processing(current_config_ptr);
    }

    /*as part of Resume handler we would have set  current_config_ptr->l1_sec_e_req_mask = START & after CHANC_CONFIG_CNF we don't do Swap OC and CC */
    if (((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_IHO || rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CHO)&&
                    (rrc_get_state()==RRC_STATE_CELL_DCH) &&
                    (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_DCH))
#ifdef FEATURE_DUAL_SIM
          ||((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)
                &&(rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
                &&(curr_scan == RRC_CSP_UNLOCK_BY_SCAN))
#endif 
            )
    {
      if( (current_config_ptr->sec_e_dch_transmission)&&
           (current_config_ptr->l1_sec_e_req_mask != L1_EUL_NOOP))
      {
        WRRC_MSG1_HIGH("DC_HSUPA:Reset l1_sec_e_req_mask <Prev value=%d> in CC", current_config_ptr->l1_sec_e_req_mask);
        current_config_ptr->l1_sec_e_req_mask = L1_EUL_NOOP;
      }
    }
#endif /* FEATURE_WCDMA_DC_HSUPA */



    rrcllc_reset_l1_cpc_dtx_info_on_llc_cfg_cnf();


  }
#ifdef FEATURE_WCDMA_HS_FACH
  if ((proc_type == RRC_PROCEDURE_CCM) && 
        ((rrcenhstate_camped_cell_supports_e_fach()&&
          ((rrcllc_cmd_under_process.next_rrc_state ==RRC_STATE_CELL_FACH) ||
          (rrcllc_cmd_under_process.next_rrc_state ==RRC_STATE_CONNECTING)))))
  {
    rrcllc_reset_mac_and_l1_for_hsdpa();
#ifdef FEATURE_WCDMA_HS_RACH
    rrcllc_reset_mac_and_l1_for_hsrach(FALSE);
#endif
  }
#endif

  return(SUCCESS);
} /* rrcllc_send_rrc_channel_config_cnf */



/*====================================================================
FUNCTION: rrcllc_send_rrc_stop_lower_layer_cnf()

DESCRIPTION:
  This function constructs the RRC_STOP_LOWER_LAYER_CNF primitive and
  sends it to the passed RRC procedure.

DEPENDENCIES:
  None

RETURN VALUE:
  uecomdef_status_e_type -> indicating a SUCCESS or FAILURE

SIDE EFFECTS:
  None.
====================================================================*/
static uecomdef_status_e_type
rrcllc_send_rrc_stop_lower_layer_cnf
(
  void
)
{
  rrc_cmd_type  *rrc_cmd_ptr;
  rrc_cmd_ptr = rrc_get_int_cmd_buf();

  MSG_LOW("Sending RRC_STOP_LOWER_LAYER_CNF",0,0,0);

  /* Fill in the local command header.*/
  rrc_cmd_ptr->cmd_hdr.cmd_id = RRC_STOP_LOWER_LAYER_CNF;

  /* Send the internal command */
  rrc_put_int_cmd(rrc_cmd_ptr);

  return(SUCCESS);
} /* rrcllc_send_rrc_stop_lower_layer_cnf */



/*====================================================================
FUNCTION: rrcllc_send_rrc_lower_layer_deact_cnf()

DESCRIPTION:
  This function constructs the RRC_LOWER_LAYER_DEACT_CNF primitive and
  sends it to the passed RRC procedure.

DEPENDENCIES:
  None

RETURN VALUE:
  uecomdef_status_e_type -> indicating a SUCCESS or FAILURE

SIDE EFFECTS:
  None.
====================================================================*/
static uecomdef_status_e_type
rrcllc_send_rrc_lower_layer_deact_cnf
(
  void
)
{
  rrc_cmd_type  *rrc_cmd_ptr;
  rrc_cmd_ptr = rrc_get_int_cmd_buf();

  MSG_LOW("Sending RRC_LOWER_LAYER_DEACT_CNF",0,0,0);

  /* Fill in the local command header.*/
  rrc_cmd_ptr->cmd_hdr.cmd_id = RRC_LOWER_LAYER_DEACT_CNF;

  /* Send the internal command */
  rrc_put_int_cmd(rrc_cmd_ptr);

  return(SUCCESS);
} /* rrcllc_send_rrc_lower_layer_deact_cnf */

/*====================================================================
FUNCTION: rrcllc_send_re_est_rlc_cnf()

DESCRIPTION:
  This function constructs the RRC_LLC_RE_EST_RLC_CNF primitive and
  sends it to the passed RRC procedure.

DEPENDENCIES:
  None

RETURN VALUE:
  uecomdef_status_e_type -> indicating a SUCCESS or FAILURE

SIDE EFFECTS:
  None.
====================================================================*/
static uecomdef_status_e_type
rrcllc_send_re_est_rlc_cnf
(
  void
)
{
  rrc_cmd_type  *rrc_cmd_ptr;
  rrc_cmd_ptr = rrc_get_int_cmd_buf();

  MSG_LOW("Sending RRC_LLC_RE_EST_RLC_CNF",0,0,0);

  /* Fill in the local command header.*/
  rrc_cmd_ptr->cmd_hdr.cmd_id = RRC_LLC_RE_EST_RLC_CNF;

  /* Send the internal command */
  rrc_put_int_cmd(rrc_cmd_ptr);

  return(SUCCESS);
} /* rrcllc_send_re_est_rlc_cnf */

/*===========================================================================

FUNCTION          rrcllc_self_enqueue_channel_config_to_idle

DESCRIPTION       This function enqueues a Channel Config Request to LLC to
                  release all channels.

DEPENDENCIES
                  None
RETURN VALUE
                  None

SIDE EFFECTS
                  None

===========================================================================*/
static void  rrcllc_self_enqueue_channel_config_to_idle(void)
{
  rrc_cmd_type        *out_cmd_ptr = rrc_get_int_cmd_buf();
  /* Start with sending an RRC_CHANNEL_CONFIG_REQ to LLC to release all channels.
   */
  /* Populate the cmd data */
  out_cmd_ptr->cmd_hdr.cmd_id = RRC_CHANNEL_CONFIG_REQ;
  out_cmd_ptr->cmd.chan_config_req.next_state = RRC_STATE_DISCONNECTED;
  out_cmd_ptr->cmd.chan_config_req.rrc_state_change_required = TRUE;
  out_cmd_ptr->cmd.chan_config_req.num_rb_to_config = 0;
  out_cmd_ptr->cmd.chan_config_req.procedure = RRC_PROCEDURE_LLC;
  out_cmd_ptr->cmd.chan_config_req.rrc_channel_config_cnf_required = FALSE;

  rrc_put_int_cmd( out_cmd_ptr );
} /* rrcllc_self_enqueue_channel_config_to_idle */

/**********************************************************************
**        Utility to send indication from L1 to RRC procedure
**
***********************************************************************/


/*====================================================================
FUNCTION: rrcllc_send_compressed_mode_run_time_error_ind()

DESCRIPTION:
  This function constructs the RRC_CPHY_COMPRESSED_MODE_IND primitive and
  sends it to Physical Channel Reconfiguration procedure.

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_send_compressed_mode_run_time_error_ind
(
 l1_compressed_mode_ind_type* cm_ptr
)
{
  rrc_cmd_type  *rrc_cmd_ptr;
  rrc_cmd_ptr = rrc_get_int_cmd_buf();

  WRRC_MSG0_HIGH("Posting Run Time Error Cmd, Sending RRC_COMPRESSED_MODE_IND");

  /* Fill in the local command header.*/
  rrc_cmd_ptr->cmd_hdr.cmd_id = RRC_COMPRESSED_MODE_IND;
  WCDMA_MEMCPY(&rrc_cmd_ptr->cmd.cm_ind, 
               sizeof(l1_compressed_mode_ind_type),
               cm_ptr, 
               sizeof(l1_compressed_mode_ind_type));

  /* Send the internal command */
  rrc_put_int_cmd(rrc_cmd_ptr);

  return;
} /* rrcllc_send_rrc_channel_config_cnf */


/**********************************************************************
**        Utilities to send commands to lower layers
**
***********************************************************************/

/*====================================================================
FUNCTION: rrcllc_crlc_dl_tm_config_req()

DESCRIPTION:
  This function constructs the CRLC_DL_TM_CONFIG_REQ primitive and
  sends it to layer 2 downlink task.

DEPENDENCIES:
  None

RETURN VALUE:
  uecomdef_status_e_type -> indicating a SUCCESS or FAILURE

SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_crlc_dl_tm_config_req
(
  rlc_dl_tm_config_type   *parm
)
{
  /*
  * The following structure is used when sending a command to
  * setup a BCCH.
  */
  wcdma_l2_dl_cmd_type  *rlc_ptr;

  /* Get L2 DL command buffer */
  rlc_ptr = wcdma_l2_dl_get_cmd_buf();

  /* Fill in the Command Header */
  rlc_ptr->cmd_hdr.cmd_id = CRLC_DL_TM_CONFIG_REQ;

  /* Fill in the Command Data */
  rlc_ptr->cmd_data.dl_tm_config = *parm;

  WRRC_MSG0_HIGH("Dispatching out L2 cmd CRLC_DL_TM_CONFIG_REQ / Sending CRLC_DL_TM_CONFIG_REQ");
#ifdef FEATURE_WCDMA_HS_RACH
  rrchsrach_print_crlc_dl_tm_config(&rlc_ptr->cmd_data.dl_tm_config);
#endif

  /* Send command to L2 DL Task */
  rrc_send_l2_dl_cmd(rlc_ptr);

} /* rrcllc_crlc_dl_tm_config_req() */


/*====================================================================
FUNCTION: rrcllc_crlc_ul_tm_config_req()

DESCRIPTION:
  This function constructs the CRLC_UL_TM_CONFIG_REQ primitive and
  sends it to layer 2 Uplink task.

DEPENDENCIES:
  None

RETURN VALUE:
  uecomdef_status_e_type -> indicating a SUCCESS or FAILURE

SIDE EFFECTS:
  None.
====================================================================*/
static uecomdef_status_e_type rrcllc_crlc_ul_tm_config_req
(
  rlc_ul_tm_config_type   *parm
)
{
  /*
  * The following structure is used when sending a command to
  * setup a BCCH.
  */
  wcdma_l2_ul_cmd_type  *rlc_ptr;

  /* Get L2 DL command buffer */
  rlc_ptr = wcdma_l2_ul_get_cmd_buf();

  /* Fill in the Command Header */
  rlc_ptr->cmd_hdr.cmd_id = CRLC_UL_TM_CONFIG_REQ;

  /* Fill in the Command Data */
  rlc_ptr->cmd_data.ul_tm_config = *parm;
  WRRC_MSG0_HIGH("Dispatching out L2 cmd CRLC_UL_TM_CONFIG_REQ / Sending CRLC_UL_TM_CONFIG_REQ");
#ifdef FEATURE_TM_LB
  if(rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_LBT)
  {
    rlc_ptr->cmd_data.ul_tm_config.loop_back_mode = 
      (((rrcllc_cmd_under_process.chan_config.lb_test_mode) == LB_TEST_MODE_NONE) ? RLC_LOOPBACK_NA :  
       (((rrcllc_cmd_under_process.chan_config.lb_test_mode) == LB_TEST_MODE_1) ?  RLC_LOOPBACK_MODE_1 : RLC_LOOPBACK_MODE_2));

    WRRC_MSG1_HIGH("Indicated to RLC loopback mode %d", rlc_ptr->cmd_data.ul_tm_config.loop_back_mode);
  }
  else
  {
    rlc_ptr->cmd_data.ul_tm_config.loop_back_mode = RLC_LOOPBACK_NA;
  }
#endif  
#ifdef FEATURE_WCDMA_HS_RACH
  rrchsrach_print_crlc_ul_tm_config(&rlc_ptr->cmd_data.ul_tm_config);
#endif
  /* Send command to L2 UL Task */
  rrc_send_l2_ul_cmd(rlc_ptr);

  return SUCCESS;
} /* rrcllc_crlc_ul_tm_config_req() */



/*====================================================================
FUNCTION: rrcllc_crlc_dl_um_config_req()

DESCRIPTION:
  This function constructs the CRLC_DL_UM_CONFIG_REQ primitive and
  sends it to layer 2 downlink task.

DEPENDENCIES:
  None

RETURN VALUE:
  uecomdef_status_e_type -> indicating a SUCCESS or FAILURE

SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_crlc_dl_um_config_req
(
  rlc_dl_um_config_type   *parm
)
{
  /*
  * The following structure is used when sending a command to
  * setup a BCCH.
  */
  wcdma_l2_dl_cmd_type  *rlc_ptr;

  /* Get L2 DL command buffer */
  rlc_ptr = wcdma_l2_dl_get_cmd_buf();

  /* Fill in the Command Header */
  rlc_ptr->cmd_hdr.cmd_id = CRLC_DL_UM_CONFIG_REQ;

  /* Fill in the Command Data */
  rlc_ptr->cmd_data.dl_um_config = *parm;

  WRRC_MSG0_HIGH("Dispatching out L2 cmd CRLC_DL_UM_CONFIG_REQ / Sending CRLC_DL_UM_CONFIG_REQ");

#ifdef FEATURE_WCDMA_HS_RACH
  rrchsrach_print_crlc_dl_um_config(&rlc_ptr->cmd_data.dl_um_config);
#endif

  /* Send command to L2 DL Task */
  rrc_send_l2_dl_cmd(rlc_ptr);
} /* rrcllc_crlc_dl_um_config_req() */

/*====================================================================
FUNCTION: rrcllc_crlc_ul_um_config_req()

DESCRIPTION:
  This function constructs the CRLC_UL_UM_CONFIG_REQ primitive and
  sends it to layer 2 Uplink task.

DEPENDENCIES:
  None

RETURN VALUE:
  uecomdef_status_e_type -> indicating a SUCCESS or FAILURE

SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_crlc_ul_um_config_req
(
  rlc_ul_um_config_type   *parm
)
{
  /*
  * The following structure is used when sending a command to
  * setup a BCCH.
  */
  wcdma_l2_ul_cmd_type  *rlc_ptr;

  /* Get L2 UL command buffer */
  rlc_ptr = wcdma_l2_ul_get_cmd_buf();

  /* Fill in the Command Header */
  rlc_ptr->cmd_hdr.cmd_id = CRLC_UL_UM_CONFIG_REQ;

  /* Fill in the Command Data */
  rlc_ptr->cmd_data.ul_um_config = *parm;

  WRRC_MSG0_HIGH("Dispatching out L2 cmd CRLC_UL_UM_CONFIG_REQ / Sending CRLC_UL_UM_CONFIG_REQ");

#ifdef FEATURE_WCDMA_HS_RACH
  rrchsrach_print_crlc_ul_um_config(&rlc_ptr->cmd_data.ul_um_config);
#endif
  /* Send command to L2 UL Task */
  rrc_send_l2_ul_cmd(rlc_ptr);

} /* rrcllc_crlc_ul_um_config_req() */

#ifdef FEATURE_UMTS_PDCP
/*====================================================================
FUNCTION: rrcllc_cpdcp_config_req()

DESCRIPTION:
  This function constructs the COMP_CPDCP_CONFIG_REQ primitive and
  sends it to PDCP layer.

DEPENDENCIES:
  None

RETURN VALUE:
  uecomdef_status_e_type -> indicating a SUCCESS or FAILURE

SIDE EFFECTS:
  None.
====================================================================*/
static uecomdef_status_e_type rrcllc_cpdcp_config_req
(
 void
)
{

  comp_cmd_type  *pdcp_ptr;
  uint32 i= 0;

  /* Will send one pdcp command at a time.  So */
  for( i = 0; i < rrcllc_cmd_under_process.chan_config.pdcp_config_req_list.num_rbs; i++)
  {
    /* Get PDCP command buffer */
    if ((pdcp_ptr = comp_get_cmd_buf()) == NULL)
    {
      ERR_FATAL("NULL Ptr when sending CPDCP_CONFIG_REQ ",0,0,0);
    }
    /* Fill in the Command Header */
    pdcp_ptr->hdr.cmd_id = CPDCP_CONFIG_REQ;
    
    /* Fill in the Command Data */
    pdcp_ptr->cmd.pdcp_cfg_req = rrcllc_cmd_under_process.chan_config.pdcp_config_req_list.pdcp_cfg_req[i];
    
    WRRC_MSG4_HIGH("Sending COMP_CPDCP_CONFIG_REQ rb_id: %d, action: %d, UL data rate: %d, dl_data_rate: %d",
             rrcllc_cmd_under_process.chan_config.pdcp_config_req_list.pdcp_cfg_req[i].rb_id,
             rrcllc_cmd_under_process.chan_config.pdcp_config_req_list.pdcp_cfg_req[i].action,
             rrcllc_cmd_under_process.chan_config.pdcp_config_req_list.pdcp_cfg_req[i].rab_ul_rate,
             rrcllc_cmd_under_process.chan_config.pdcp_config_req_list.pdcp_cfg_req[i].rab_dl_rate);
    
    /* Send command to L2 UL Task */
    comp_put_cmd(pdcp_ptr);
  }
  return SUCCESS;
} /* rrcllc_cpdcp_config_req() */
#endif /* FEATURE_UMTS_PDCP*/

/*====================================================================
FUNCTION: rrcllc_crlc_am_config_req()

DESCRIPTION:
  This function constructs the CRLC_AM_CONFIG_REQ primitive and
  sends it to layer 2 Uplink task.

DEPENDENCIES:
  None

RETURN VALUE:
  uecomdef_status_e_type -> indicating a SUCCESS or FAILURE

SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_crlc_am_config_req
(
  rlc_am_config_req_type   *parm
)
{

  wcdma_l2_ul_cmd_type  *rlc_ptr;
  uint8 i;
  /* Get L2 UL command buffer */
  rlc_ptr = wcdma_l2_ul_get_cmd_buf();

  /* Fill in the Command Header */
  rlc_ptr->cmd_hdr.cmd_id = CRLC_AM_CONFIG_REQ;

  /* Fill in the Command Data */
  rlc_ptr->cmd_data.am_config = *parm;

  rrclog_crlc_am_req(&rlc_ptr->cmd_data.am_config);

  WRRC_MSG0_HIGH("Dispatching out L2 cmd CRLC_AM_CONFIG_REQ / Sending CRLC_AM_CONFIG_REQ");
  for(i=0; i<rlc_ptr->cmd_data.am_config.nentity; i++)
  {
    WRRC_MSG9_HIGH("RB ID: %d, ACTION: %d, ul_cfg_msk: %d, dl_cfg_mask: %d, reest_entity:%d, ul_hfn: %d, dl_hfn:%d, ul_rlc_size:%d, dl_rlc_size: %d",
    rlc_ptr->cmd_data.am_config.am_info[i]->common_config.rb_id,
    rlc_ptr->cmd_data.am_config.am_act[i].action,
    rlc_ptr->cmd_data.am_config.am_act[i].dl_cfg_mask,
    rlc_ptr->cmd_data.am_config.am_act[i].ul_cfg_mask,
    rlc_ptr->cmd_data.am_config.am_info[i]->reestab_entity,
    rlc_ptr->cmd_data.am_config.am_info[i]->rlc_ul_am_config.hfn,
    rlc_ptr->cmd_data.am_config.am_info[i]->rlc_dl_am_config.hfn,
    rlc_ptr->cmd_data.am_config.am_info[i]->rlc_ul_am_config.ul_rlc_size,
    rlc_ptr->cmd_data.am_config.am_info[i]->rlc_dl_am_config.dl_rlc_size
    );
  }
  /* Send command to L2 UL Task */
  rrc_send_l2_ul_cmd(rlc_ptr);

} /* rrcllc_crlc_am_config_req() */

/*===========================================================================
FUNCTION   rrcllc_cmac_dl_config_req_for_ciph_handover

DESCRIPTION
  This function sends a CMAC_DL_CONFIG_REQ to MAC for ciphering changes during
  a handover.  Always Current-Config-Ptr is used for handover changes.

DEPENDENCIES
  None.

RETURN VALUE
  SUCCESS: if cmd to MAC sent successfully
  FAILURE: if cmd to MAC sent successfully

SIDE EFFECTS
  None.
===========================================================================*/
static uecomdef_status_e_type  rrcllc_cmac_dl_config_req_for_ciph_handover
(
  rrcllc_mac_sync_with_l1_e_type   sync_needed
)
{
  wcdma_l2_dl_cmd_type  *l2_dl_cmd_ptr;

  /* Fill in the MAC downlink parameters and send the primitive */
  l2_dl_cmd_ptr = wcdma_l2_dl_get_cmd_buf();

  /* Fill in the Command Header */
  l2_dl_cmd_ptr->cmd_hdr.cmd_id = CMAC_DL_CONFIG_REQ;

  if(config_ptr_in_use == ORDERED_CONFIG)
  {
    ordered_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_NOOP;
    ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator = FALSE;
    ordered_config_ptr->mac_dl_parms.mac_hs_transition_type = MAC_HS_NO_TRANSITION;
    l2_dl_cmd_ptr->cmd_data.mac_config_info = ordered_config_ptr->mac_dl_parms;
  }
  else
  {
    current_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_NOOP;
    current_config_ptr->mac_dl_parms.mac_hs_reset_indicator = FALSE;
    current_config_ptr->mac_dl_parms.mac_hs_transition_type = MAC_HS_NO_TRANSITION;
    l2_dl_cmd_ptr->cmd_data.mac_config_info = current_config_ptr->mac_dl_parms;
  }

  WRRC_MSG2_HIGH("MAC DL Parms 0x%x, RRCHS: Set MACHS Action NOOP in %d (0:OC/1:CC/2:TOC)", &l2_dl_cmd_ptr->cmd_data.mac_config_info, config_ptr_in_use);

  rrcllc_copy_mac_cipher_config(l2_dl_cmd_ptr->cmd_data.mac_config_info.cipher_info);

  if(sync_needed == SYNC_WITH_L1)
  {
    l2_dl_cmd_ptr->cmd_data.mac_config_info.wait_for_l1_sig = TRUE;
    WRRC_MSG0_HIGH("MAC DL Config: Wt for L1 Sig");
  }
  else
  {
    l2_dl_cmd_ptr->cmd_data.mac_config_info.wait_for_l1_sig = FALSE;

    /* Check if it is ASU Repointing with MAC-hs Reset */
    if ((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_ASU) && 
      (l2_dl_cmd_ptr->cmd_data.mac_config_info.mac_hsdpa_action == HSDPA_RECONFIG) && 
      (l2_dl_cmd_ptr->cmd_data.mac_config_info.mac_hs_reset_indicator == TRUE))
    {
      WRRC_MSG0_HIGH("RRCHS:ASURepoint.MAC wait L1sync");
      l2_dl_cmd_ptr->cmd_data.mac_config_info.wait_for_l1_sig = TRUE;
    }
  }

  /* Initialize restore TSN parameter to FALSE */
  l2_dl_cmd_ptr->cmd_data.mac_config_info.mac_hs_restore_tsns = FALSE;

  WRRC_MSG0_HIGH("Dispatching out L2 cmd CMAC_DL_CONFIG_REQ / Sending CMAC_DL_CONFIG_REQ");
  rrc_send_l2_dl_cmd(l2_dl_cmd_ptr);

  return(SUCCESS);
} /* rrcllc_cmac_dl_config_req_for_ciph_handover */

/*===========================================================================
FUNCTION   rrcllc_cmac_dl_config_req

DESCRIPTION
  This function sends a CMAC_DL_CONFIG_REQ to MAC. It copies contents of
  Ordered Config MAC DL config. data structure into the command data.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static void  rrcllc_cmac_dl_config_req
(
  rrcllc_mac_sync_with_l1_e_type   sync_needed
)
{
  wcdma_l2_dl_cmd_type  *l2_dl_cmd_ptr;
  hsdpa_action_enum_type hsdpa_action = rrc_get_hsdpa_action();
  ordered_config_type *config_ptr = ordered_config_ptr;
  if(rrcllc_cmd_under_process.chan_config.current_cmd_engine == LLC_CELL_RESELECTION_ENGINE)
  {
    config_ptr = reselection_config_ptr;
  }

#ifdef FEATURE_WCDMA_HS_FACH
  if((rrcllc_cmd_under_process.chan_config.current_cmd_engine == LLC_RELEASE_ALL_CHAN_ENGINE) &&
     (rrcllc_get_hs_status_in_e_fach(current_config_ptr)))
  {
    ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs = MAC_EHS;
    current_config_ptr->mac_dl_parms.mac_hs_or_ehs = MAC_EHS;
  }
#endif /*FEATURE_WCDMA_HS_FACH*/

  /* Fill in the MAC downlink parameters and send the primitive */
  l2_dl_cmd_ptr = wcdma_l2_dl_get_cmd_buf();

  /* Fill in the Command Header */
  l2_dl_cmd_ptr->cmd_hdr.cmd_id = CMAC_DL_CONFIG_REQ;

  if(rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_SMC ||
     rrcllc_cmd_under_process.chan_config.solo_bch_operation)
  {
    /* Use Current Config when processing a Security Mode Command */
    l2_dl_cmd_ptr->cmd_data.mac_config_info = current_config_ptr->mac_dl_parms;
    }
    else
    {
#ifdef FEATURE_WCDMA_HS_FACH
    rrcenhstate_sync_efach_queue(config_ptr);
#endif
    l2_dl_cmd_ptr->cmd_data.mac_config_info = config_ptr->mac_dl_parms;
    l2_dl_cmd_ptr->cmd_data.mac_config_info.hs_status_in_e_fach = config_ptr->hs_status_in_e_fach;
  }

#ifdef FEATURE_WCDMA_HS_FACH
  if(l2_dl_cmd_ptr->cmd_data.mac_config_info.hs_status_in_e_fach)
  {
    WRRC_MSG0_HIGH("EFACH: Setting num_fach to Zero, so that MAC can ignore FACH info");
    l2_dl_cmd_ptr->cmd_data.mac_config_info.num_fachs = 0 ;
  }
  /*For enh FACH actions always set SYNC_WITH_L1*/
  if( !((hsdpa_action == HSDPA_START) ||
         ((rrc_get_hsdpa_status() == HSDPA_ACTIVE) && (hsdpa_action != HSDPA_STOP)) ) && 
      (l2_dl_cmd_ptr->cmd_data.mac_config_info.mac_hsdpa_action != HSDPA_NOOP)&&
      (rrcllc_cmd_under_process.chan_config.current_cmd_engine == LLC_CHAN_CONFIG_ENGINE ||
       rrcllc_cmd_under_process.chan_config.current_cmd_engine == LLC_CELL_RESELECTION_ENGINE)
    )
  {
    WRRC_MSG0_HIGH("EFACH: wait for L1 siganl MAC DL");
    sync_needed = SYNC_WITH_L1;
  }
#endif

  rrcllc_copy_mac_cipher_config(l2_dl_cmd_ptr->cmd_data.mac_config_info.cipher_info);

  if(sync_needed == SYNC_WITH_L1)
  {
    l2_dl_cmd_ptr->cmd_data.mac_config_info.wait_for_l1_sig = TRUE;
    WRRC_MSG0_MED("MAC DL Config: Wt for L1 Sig");
  }
  else
  {
    l2_dl_cmd_ptr->cmd_data.mac_config_info.wait_for_l1_sig = FALSE;
    /* Check if it is ASU Repointing with MAC-hs Reset */
    if ((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_ASU) && 
      (l2_dl_cmd_ptr->cmd_data.mac_config_info.mac_hsdpa_action == HSDPA_RECONFIG) && 
      (l2_dl_cmd_ptr->cmd_data.mac_config_info.mac_hs_reset_indicator == TRUE))
    {
      WRRC_MSG0_HIGH("RRCHS:ASURepoint.MAC wait L1sync");
      l2_dl_cmd_ptr->cmd_data.mac_config_info.wait_for_l1_sig = TRUE;
    }
  }

  if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
  {
    if(rrcllc_cmd_under_process.chan_config.solo_bch_operation &&
       (rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_SIB_READ_IN_DCH))
    {
      l2_dl_cmd_ptr->cmd_data.mac_config_info.mac_hsdpa_action = HSDPA_NOOP;
    }
    l2_dl_cmd_ptr->cmd_data.mac_config_info.mac_hs_restore_tsns = FALSE;
    if(hsdpa_msg_params.mac_hs_restore_tsns == TRUE)
    {
      l2_dl_cmd_ptr->cmd_data.mac_config_info.mac_hs_restore_tsns = TRUE;
      WRRC_MSG0_HIGH("RRC - Setting hs restore tsns to TRUE");
    }
    hsdpa_msg_params.mac_hs_restore_tsns = FALSE;
#ifdef FEATURE_WCDMA_HS_FACH
    if(l2_dl_cmd_ptr->cmd_data.mac_config_info.mac_hsdpa_action ==HSDPA_NOOP)
    {
      l2_dl_cmd_ptr->cmd_data.mac_config_info.mac_hs_reset_indicator = FALSE;
    }
#endif
    WRRC_MSG3_MED("RRCHS:MAC DL Parms 0x%x MACHSACTION 0/N:1/SET:2/RCFG:3/STOP %d, MAC-HS Reset ind %d",
             &l2_dl_cmd_ptr->cmd_data.mac_config_info, l2_dl_cmd_ptr->cmd_data.mac_config_info.mac_hsdpa_action,  l2_dl_cmd_ptr->cmd_data.mac_config_info.mac_hs_reset_indicator);
  }

#ifdef FEATURE_WCDMA_HS_FACH
  l2_dl_cmd_ptr->cmd_data.mac_config_info.reset_timer_valid = FALSE;

  if(rrcllc_cmd_under_process.chan_config.current_cmd_engine == LLC_CELL_RESELECTION_ENGINE || 
     rrcllc_cmd_under_process.chan_config.current_cmd_engine == LLC_CHAN_CONFIG_ENGINE)
  {
    if(config_ptr->hs_status_in_e_fach)
    {
      l2_dl_cmd_ptr->cmd_data.mac_config_info.reset_timer_valid = TRUE;
    }
  }

  #ifdef FEATURE_WCDMA_3C_HSDPA
   WRRC_MSG1_HIGH("3CHSDPA_DEBUG: TSN: %d",l2_dl_cmd_ptr->cmd_data.mac_config_info.tsn_extn);
  #endif

#endif
  WRRC_MSG0_HIGH("Dispatching out L2 cmd CMAC_DL_CONFIG_REQ / Sending CMAC_DL_CONFIG_REQ");

  rrclog_cmac_dl_req(l2_dl_cmd_ptr);
  rrclog_cmac_dl_hs_setup(l2_dl_cmd_ptr);
  rrc_send_l2_dl_cmd(l2_dl_cmd_ptr);

} /* rrcllc_cmac_dl_config_req */

/*===========================================================================
FUNCTION   rrcllc_cmac_dl_config_req_for_rnti_update

DESCRIPTION
  This function sends a CMAC_DL_CONFIG_REQ to MAC. This has been customized
  for the RNTI Update case.

DEPENDENCIES
  None.

RETURN VALUE
  Success/Failure

SIDE EFFECTS
  None.
===========================================================================*/
static void
rrcllc_cmac_dl_config_req_for_rnti_update(ordered_config_type *config_ptr)
{
  wcdma_l2_dl_cmd_type  *l2_dl_cmd_ptr;

  /* Fill in the MAC downlink parameters and send the primitive */
  l2_dl_cmd_ptr = wcdma_l2_dl_get_cmd_buf();

  /* Fill in the Command Header */
  l2_dl_cmd_ptr->cmd_hdr.cmd_id = CMAC_DL_CONFIG_REQ;

  /* Use Current Config when processing a Security Mode Command */
  l2_dl_cmd_ptr->cmd_data.mac_config_info = config_ptr->mac_dl_parms;
/* Update the hsdpa action directly in L2 buffer to avoid ovewriting in OC  */
  l2_dl_cmd_ptr->cmd_data.mac_config_info.mac_hsdpa_action = HSDPA_NOOP;
  l2_dl_cmd_ptr->cmd_data.mac_config_info.mac_hs_reset_indicator = FALSE;
  l2_dl_cmd_ptr->cmd_data.mac_config_info.mac_hs_transition_type = MAC_HS_NO_TRANSITION;

  rrcllc_copy_mac_cipher_config(l2_dl_cmd_ptr->cmd_data.mac_config_info.cipher_info);

  l2_dl_cmd_ptr->cmd_data.mac_config_info.wait_for_l1_sig = FALSE;

  /* Initialize restore TSN's to FALSE */
  l2_dl_cmd_ptr->cmd_data.mac_config_info.mac_hs_restore_tsns = FALSE;

  WRRC_MSG2_HIGH("MAC DL Parms 0x%x,Set MACHS Action NOOP in %d (0:OC/1:CC/2:TOC), Dispatching out L2 cmd CMAC_DL_CONFIG_REQ / Sending CMAC_DL_CONFIG_REQ",&config_ptr->mac_dl_parms, config_ptr_in_use);
  rrc_send_l2_dl_cmd(l2_dl_cmd_ptr);


} /* rrcllc_cmac_dl_config_req_for_rnti_update */

/*===========================================================================
FUNCTION   rrcllc_cmac_ul_config_req_for_ciph_handover

DESCRIPTION
  This function sends a CMAC_UL_CONFIG_REQ to MAC for ciphering changes.
  Always ciphering changes will be on CC, so just copy CC ptr and send the
  ciphering configuration to MAC for handover purposes

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static uecomdef_status_e_type  rrcllc_cmac_ul_config_req_for_ciph_handover
(
  rrcllc_mac_ul_operation_e_type mac_op,
  rrcllc_mac_sync_with_l1_e_type   sync_needed
)
{
  wcdma_l2_ul_cmd_type  *l2_ul_cmd_ptr;

  /* Fill in the MAC uplink parameters and send the primitive */
  l2_ul_cmd_ptr = wcdma_l2_ul_get_cmd_buf();

  /* Fill in the Command Header */
  l2_ul_cmd_ptr->cmd_hdr.cmd_id = CMAC_UL_CONFIG_REQ;

  if(config_ptr_in_use == ORDERED_CONFIG)
  {
    l2_ul_cmd_ptr->cmd_data.mac_config_info = ordered_config_ptr->mac_ul_parms;
  }
  else
  {
    l2_ul_cmd_ptr->cmd_data.mac_config_info = current_config_ptr->mac_ul_parms;
  }


  rrcllc_copy_mac_cipher_config(l2_ul_cmd_ptr->cmd_data.mac_config_info.cipher_info);

  if(sync_needed == SYNC_WITH_L1)
  {
    l2_ul_cmd_ptr->cmd_data.mac_config_info.wait_for_l1_sig = TRUE;
  }
  else
  {
    l2_ul_cmd_ptr->cmd_data.mac_config_info.wait_for_l1_sig = FALSE;
  }

  if(mac_op == ONLY_SWAP_PTR)
  {
    l2_ul_cmd_ptr->cmd_data.mac_config_info.mac_config_changed = MAC_CFG_NOT_CHANGED;
  }
  else
  {
    l2_ul_cmd_ptr->cmd_data.mac_config_info.mac_config_changed = MAC_CFG_CHANGED;
  }
  WRRC_MSG2_HIGH("MAC Config change status %d , wait for l1 sig %d", 
    l2_ul_cmd_ptr->cmd_data.mac_config_info.mac_config_changed, l2_ul_cmd_ptr->cmd_data.mac_config_info.wait_for_l1_sig );

  WRRC_MSG0_HIGH("Dispatching out L2 cmd CMAC_UL_CONFIG_REQ / Sending CMAC_UL_CONFIG_REQ");
  rrc_send_l2_ul_cmd(l2_ul_cmd_ptr);

  return(SUCCESS);
} /* rrcllc_cmac_ul_config_req_for_ciphering */
#ifdef FEATURE_MAC_I
/*===========================================================================
FUNCTION   rrcllc_check_if_ul_rlc_is_reestablished

DESCRIPTION
  This function ensures and returns the CRLC_SUSPEND such that all the RLC entities being suspended 
  when we send the CMAC_UL_CONFIG REQ rlc action as RLC MODIFY

DEPENDENCIES
  None.

RETURN VALUE
return CRLC_SUSPEND for rlc action Modify else CRLC_RESUME for all other cases.

SIDE EFFECTS
  None.
===========================================================================*/
static mac_ul_rlc_action_type rrcllc_check_if_ul_rlc_is_reestablished(void)
{

  uint8 entity_idx = 0;

  if(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.nentity == 0)
  {
    return CRLC_RESUME;
  }
  
  for(entity_idx = 0; entity_idx < rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.nentity;entity_idx++)
  {
    if(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_act[entity_idx].action == RLC_MODIFY)
    {
      return CRLC_SUSPEND;
    }
  }

  return CRLC_RESUME;

} /* rrcllc_check_if_ul_rlc_is_reestablished */
#endif
/*===========================================================================
FUNCTION   rrcllc_cmac_ul_config_req

DESCRIPTION
  This function sends a CMAC_UL_CONFIG_REQ to MAC. It copies contents of
  Ordered Config MAC UL config. data structure into the command data.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static void  rrcllc_cmac_ul_config_req
(
  rrcllc_mac_ul_operation_e_type mac_op,
  rrcllc_mac_sync_with_l1_e_type   sync_needed
)
{
  wcdma_l2_ul_cmd_type  *l2_ul_cmd_ptr;

  #ifdef FEATURE_WCDMA_HS_RACH
  uint32 count= 0;
  ordered_config_type *temp_config_ptr = NULL;
  #endif

  /* Fill in the MAC uplink parameters and send the primitive */
  l2_ul_cmd_ptr = wcdma_l2_ul_get_cmd_buf();

  /* Fill in the Command Header */
  l2_ul_cmd_ptr->cmd_hdr.cmd_id = CMAC_UL_CONFIG_REQ;


  /* In Cell_DCH state, if L1 UL needs to be reconfigured, ask MAC to wait for L1 */
  if(rrcllc_cmd_under_process.chan_config.current_cmd_engine == LLC_CELL_RESELECTION_ENGINE)
  {
    l2_ul_cmd_ptr->cmd_data.mac_config_info = reselection_config_ptr->mac_ul_parms;
#ifdef FEATURE_WCDMA_HS_RACH
    temp_config_ptr = reselection_config_ptr;
#endif
  }
  else if(rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_SMC)
  {
    /* Use Current Config when processing a Security Mode Command */
    l2_ul_cmd_ptr->cmd_data.mac_config_info = current_config_ptr->mac_ul_parms;
#ifdef FEATURE_WCDMA_HS_RACH    
    temp_config_ptr = current_config_ptr;
#endif
  }
  else
  {
    if((rrcllc_cmd_under_process.chan_config.solo_bch_operation))
    {
      l2_ul_cmd_ptr->cmd_data.mac_config_info = current_config_ptr->mac_ul_parms;
#ifdef FEATURE_WCDMA_HS_RACH      
      temp_config_ptr = current_config_ptr;
#endif
    }
    else
    {
      l2_ul_cmd_ptr->cmd_data.mac_config_info = ordered_config_ptr->mac_ul_parms;
#ifdef FEATURE_WCDMA_HS_RACH
      temp_config_ptr = ordered_config_ptr;
#endif
      l2_ul_cmd_ptr->cmd_data.mac_config_info.mac_e_reset_indicator = 
        ordered_config_ptr->mac_e_reset_indicator;

      l2_ul_cmd_ptr->cmd_data.mac_config_info.mac_e_tsn_action = 
        ordered_config_ptr->mac_e_tsn_action;

      l2_ul_cmd_ptr->cmd_data.mac_config_info.mac_eul_action = 
        ordered_config_ptr->mac_eul_action;
#ifdef FEATURE_WCDMA_DC_HSUPA
      l2_ul_cmd_ptr->cmd_data.mac_config_info.mac_sec_eul_action = 
        ordered_config_ptr->mac_sec_eul_action;
#endif /* FEATURE_WCDMA_DC_HSUPA */
    }
  }

#ifdef FEATURE_WCDMA_HS_RACH
  /*For all HS RACH configurations Synch with L1 should be always set */
  if(rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req != 0)
  {
    for (count=0;count < rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req;count++)
    {
      if((rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[count].cmd.setup.hs_rach_req_mask != L1_HS_RACH_NO_OP) &&
        (temp_config_ptr->mac_hs_rach_action != MAC_HS_RACH_NOOP))
        {
            WRRC_MSG0_MED("RRCHSRACH: wait for L1 signal MAC UL");
            sync_needed = SYNC_WITH_L1;
        }
    }
  }

  /* Do we need this NO OP check  ?*/
  if(temp_config_ptr->mac_hs_rach_action != MAC_HS_RACH_NOOP)
  {
    l2_ul_cmd_ptr->cmd_data.mac_config_info.hs_rach_action = 
    temp_config_ptr->mac_hs_rach_action;

    temp_config_ptr->mac_hs_rach_config.primary_e_rnti_present = 
    		temp_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present;

    temp_config_ptr->mac_hs_rach_config.primary_e_rnti = 
        temp_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti;

    /*crc_ansah: is it ok to pass null if action is no_op */
    l2_ul_cmd_ptr->cmd_data.mac_config_info.hs_rach_config_ptr = &temp_config_ptr->mac_hs_rach_config;

    l2_ul_cmd_ptr->cmd_data.mac_config_info.mac_hsrach_e_reset_indicator = 
      temp_config_ptr->mac_hsrach_e_reset_indicator;
    l2_ul_cmd_ptr->cmd_data.mac_config_info.hs_rach_to_eul_trans = 
      temp_config_ptr->hs_rach_to_eul_trans;
    
    
  }
#endif

  rrcllc_copy_mac_cipher_config(l2_ul_cmd_ptr->cmd_data.mac_config_info.cipher_info);

  if(sync_needed == SYNC_WITH_L1)
  {
    l2_ul_cmd_ptr->cmd_data.mac_config_info.wait_for_l1_sig = TRUE;
    WRRC_MSG0_MED("MAC UL Config: Wt for L1 Sig");
  }
  else
  {
    l2_ul_cmd_ptr->cmd_data.mac_config_info.wait_for_l1_sig = FALSE;
  }

  if(mac_op == ONLY_SWAP_PTR)
  {
    l2_ul_cmd_ptr->cmd_data.mac_config_info.mac_config_changed = MAC_CFG_NOT_CHANGED;
    l2_ul_cmd_ptr->cmd_data.mac_config_info.new_tfcs_list_present = FALSE;
  }
  else
  {
    if(rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_LBT)
    {
      l2_ul_cmd_ptr->cmd_data.mac_config_info.mac_config_changed = MAC_LB_CFG_CHANGED;
    }
    else if (rrclbt_is_lb_on()) 
    {
      l2_ul_cmd_ptr->cmd_data.mac_config_info.mac_config_changed = MAC_LB_AND_UL_CFG_CHANGED;
    }
    else
    {
      l2_ul_cmd_ptr->cmd_data.mac_config_info.mac_config_changed = MAC_CFG_CHANGED;
    }
  }
  WRRC_MSG2_MED("MAC config rrc_proc_e_type_value%d, mac_config_changed %d", 
      rrcllc_cmd_under_process.procedure, l2_ul_cmd_ptr->cmd_data.mac_config_info.mac_config_changed);
  l2_ul_cmd_ptr->cmd_data.mac_config_info.new_tfcs_list_present = TRUE;
  if(rrcllc_cmd_under_process.chan_config.current_cmd_engine == LLC_CHAN_CONFIG_ENGINE)
  {
    if((rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_DCH) && (rrc_get_state() == RRC_STATE_CELL_DCH))
    {
      l2_ul_cmd_ptr->cmd_data.mac_config_info.new_tfcs_list_present = ordered_config_ptr->mac_ul_parms.new_tfcs_list_present;
    }
  }

   /* During HSRACH to legacy reselection when we config MAC, MAC will be in new config and
      RLC will be in old config. RLC will crash if it tries to build PDUs in this window. To
     avoid this, we should set RLC action as SUSPEND in mac_config during reselection */
#ifdef FEATURE_MAC_I
    if((rrcllc_cmd_under_process.chan_config.current_cmd_engine == LLC_CHAN_CONFIG_ENGINE)
#ifdef FEATURE_WCDMA_HS_RACH
    || (rrcllc_cmd_under_process.chan_config.current_cmd_engine == LLC_CELL_RESELECTION_ENGINE)
#endif
    )
    {
      l2_ul_cmd_ptr->cmd_data.mac_config_info.ul_rlc_action = rrcllc_check_if_ul_rlc_is_reestablished();
      WRRC_MSG1_MED("RRCHSRACH UL RLC ACTION :%d [0=Invalid,1=Suspend, 2= Resume]",l2_ul_cmd_ptr->cmd_data.mac_config_info.ul_rlc_action);
    }
#endif

  WRRC_MSG2_MED("Dispatching out L2 cmd / MAC UL Parms 0x%x New TFCS present:%d, Sending CMAC_UL_CONFIG_REQ",&l2_ul_cmd_ptr->cmd_data.mac_config_info,l2_ul_cmd_ptr->cmd_data.mac_config_info.new_tfcs_list_present);

  /*
    Dont configure RACH for Spec CR 5334 :
    UE behavior at activation and deactivation of Enhanced Uplink in CELL_FACH state in SIB5/5bis
    HSRACH ->HSFACH case: As UE will have a valid set of RNTI we hack the number of logical channels
    in uplink to zero to block UL transmission  
    HSFACH ->HSRACH case: UE will not have a valid ERNTI to do UL tx
  */
  if((rrcllc_cmd_under_process.chan_config.current_cmd_engine == LLC_CHAN_CONFIG_ENGINE) &&
     (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP) &&
     (rrccu_get_hsrach_sib_change() == TRUE)&&
     (rrchsrach_camped_cell_supports_hsrach() == FALSE))
  {
    WRRC_MSG0_HIGH("SIB5_Delay: Init RACH mapping in this CMAC_UL");
    l2_ul_cmd_ptr->cmd_data.mac_config_info.cctrch_ptr->rach_info.ndlchan = 0;
  }

#ifdef FEATURE_WCDMA_HS_RACH

/* MAC shouldnt be configured with ERNTI when CU is going to be triggered.*/
/* rrcrb_is_cu_required is TRUE if CU is to be triggered by procedure. */
/* Procedure check is an extra protection. This will save in a case where send_initiate_cu flag is not reset properly(which will not happen ideally) */
if(((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RBE) ||
   (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RBRC) ||
   (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_TCR) ||
   (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_PCR) ||
   (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RBR)) && 
   (l2_ul_cmd_ptr->cmd_data.mac_config_info.hs_rach_config_ptr != NULL) && 
   rrcrb_is_cu_required())
{
  MSG_HIGH("ERNTI present : %d, cu_req : %d, CU substate: %d",l2_ul_cmd_ptr->cmd_data.mac_config_info.hs_rach_config_ptr->primary_e_rnti_present,rrcrb_is_cu_required(),rrccu_return_cu_substate());
  l2_ul_cmd_ptr->cmd_data.mac_config_info.hs_rach_config_ptr->primary_e_rnti_present = FALSE;
}

/* Below changes are required for the scenario 
  UE has triggered a cell update and received cell update confirm 
  now CU triggers a channel config which configures lower layers with RNTIs
  L2 can start transmitting data before rlc reestablishment. rlc reestablishment happens during rnti_update_req which happens later.
  issue can happen 
  1. When OC is set by CU 
  2. UMIC is response of CUC and cell supports HSFACH
  for 1 - if OC is set then check if OC is set and crnti will be stored
  for 2 - Use RRCLLC_CHAN_CFG_REASON_HS_FACH_DEDICATED_OPS to identify this scenario because cnrti is not stored
  Issue that we are fixing now is that before reestablishment PDUs are going out of UE 
  causing network to trigger a bad ack leading to RLC reset
*/

if((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CU) &&    
  (rrcllc_cmd_under_process.next_rrc_state != RRC_STATE_CELL_DCH) &&
  (RRCCU_STARTED == rrccu_get_cell_update_started_status()) && 
  ((rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_HS_FACH_DEDICATED_OPS) ||
  ((rrcllc_get_ordered_config_status_wo_f3() != OC_NOT_SET) && (rrccu_check_if_crnti_valid() == TRUE))))
{
  
  if ((l2_ul_cmd_ptr->cmd_data.mac_config_info.hs_rach_config_ptr != NULL)  && 
    (rrchsrach_get_common_edch_transmission(temp_config_ptr) == TRUE))
  {
    l2_ul_cmd_ptr->cmd_data.mac_config_info.hs_rach_config_ptr->primary_e_rnti_present = FALSE;
    MSG_HIGH("Delete E-RNTI",0,0,0);
  }

  MSG_HIGH("Delete CRNTI",0,0,0);
  
  if (l2_ul_cmd_ptr->cmd_data.mac_config_info.rnti_info.rnti_valid== BOTH_VALID)
  {
    l2_ul_cmd_ptr->cmd_data.mac_config_info.rnti_info.rnti_valid = URNTI_VALID;
    l2_ul_cmd_ptr->cmd_data.mac_config_info.rnti_info.rnti_valid = URNTI_VALID;
  }
  else if (l2_ul_cmd_ptr->cmd_data.mac_config_info.rnti_info.rnti_valid == CRNTI_VALID)
  {
    l2_ul_cmd_ptr->cmd_data.mac_config_info.rnti_info.rnti_valid = NO_RNTI_VALID;
    l2_ul_cmd_ptr->cmd_data.mac_config_info.rnti_info.rnti_valid = NO_RNTI_VALID;
  }
  
}
#endif
   rrc_print_cmac_ul_config(l2_ul_cmd_ptr);
  rrclog_cmac_ul_req(l2_ul_cmd_ptr);
  rrclog_cmac_ul_hs_setup(l2_ul_cmd_ptr);
  rrc_send_l2_ul_cmd(l2_ul_cmd_ptr);

} /* rrcllc_cmac_ul_config_req */


/*====================================================================
FUNCTION: rrc_print_cmac_ul_config()

DESCRIPTION:
  This function prints  cmac config of dc hsupa 

DEPENDENCIES:
  None.
RETURN VALUE:
  None
SIDE EFFECTS:
  None
====================================================================*/

void rrc_print_cmac_ul_config(wcdma_l2_ul_cmd_type* l2_ul_cmd_ptr)
{
  uint8 tfs_info_idx=0, tf_info_idx=0;
	WRRC_MSG9_HIGH("Dispatching out L2 cmd Sending CMAC_UL_CONFIG_REQ, mac_config_changed: %d New TFCS present:%d, wait_for_l1_signal: %d, mac_eul_action:%d, mac_e_reset_ind:%d, mac_e_tsn_action:%d, ul_rlc_action:%d, mac_sec_eul_action:%d, hsrach_action: %d",
		l2_ul_cmd_ptr->cmd_data.mac_config_info.mac_config_changed,
		l2_ul_cmd_ptr->cmd_data.mac_config_info.new_tfcs_list_present,
		l2_ul_cmd_ptr->cmd_data.mac_config_info.wait_for_l1_sig,
		l2_ul_cmd_ptr->cmd_data.mac_config_info.mac_eul_action,
		l2_ul_cmd_ptr->cmd_data.mac_config_info.mac_e_reset_indicator,
		l2_ul_cmd_ptr->cmd_data.mac_config_info.mac_e_tsn_action,
		l2_ul_cmd_ptr->cmd_data.mac_config_info.ul_rlc_action,
		l2_ul_cmd_ptr->cmd_data.mac_config_info.mac_sec_eul_action,
		l2_ul_cmd_ptr->cmd_data.mac_config_info.hs_rach_action
		);
  if(l2_ul_cmd_ptr->cmd_data.mac_config_info.tfcs_ptr != NULL)
  {
    for(tfs_info_idx=0;tfs_info_idx<l2_ul_cmd_ptr->cmd_data.mac_config_info.tfcs_ptr->nchan; tfs_info_idx++)
    {
      for(tf_info_idx=0; tf_info_idx<l2_ul_cmd_ptr->cmd_data.mac_config_info.tfcs_ptr->tfs_info[tfs_info_idx].ntf; tf_info_idx++)
      {
        WRRC_MSG5_HIGH("tfs_info_idx: %d, tf_info_idx: %d, ntblks: %d, tb_size: %d, tf_flag: %d",
        tfs_info_idx,tf_info_idx,l2_ul_cmd_ptr->cmd_data.mac_config_info.tfcs_ptr->tfs_info[tfs_info_idx].tf_info[tf_info_idx].ntblks,
        l2_ul_cmd_ptr->cmd_data.mac_config_info.tfcs_ptr->tfs_info[tfs_info_idx].tf_info[tf_info_idx].tb_size,
        l2_ul_cmd_ptr->cmd_data.mac_config_info.tfcs_ptr->tfs_info[tfs_info_idx].tf_info[tf_info_idx].tf_flag);
      }
    }
  }
#ifdef FEATURE_WCDMA_DC_HSUPA
	 rrcllc_print_cmac_ul_config_dchsupa(&l2_ul_cmd_ptr->cmd_data.mac_config_info);
#endif
}

#ifdef FEATURE_WCDMA_DC_HSUPA

/*====================================================================
FUNCTION: rrcllc_print_cmac_ul_config_dchsupa()

DESCRIPTION:
  This function prints  cmac config of dc hsupa 

DEPENDENCIES:
  None.
RETURN VALUE:
  None
SIDE EFFECTS:
  None
====================================================================*/

void rrcllc_print_cmac_ul_config_dchsupa
(
  mac_ul_config_type *mac_config_info
)
{ 

  if(mac_config_info->mac_sec_eul_action == MAC_SEC_EUL_NOOP)
    return;

  WRRC_MSG2_HIGH("DCHSUPA_DEBUG: sched_tx_grant_harq_allocation_2ms: %d, e_tfci_min_set: %d", 
  	mac_config_info->mac_sec_eul_config_ptr->sched_tx_config.sched_tx_grant_harq_allocation_2ms, 
  	mac_config_info->mac_sec_eul_config_ptr->e_tfci_min_set);

}
#endif
/*===========================================================================
FUNCTION   rrcllc_cmac_ul_config_req_for_rnti_update

DESCRIPTION
  This function sends a CMAC_UL_CONFIG_REQ to MAC. It has been customized
  for RNTI Update case.

DEPENDENCIES
  None.

RETURN VALUE
  Success/Failure

SIDE EFFECTS
  None.
===========================================================================*/
static void
rrcllc_cmac_ul_config_req_for_rnti_update(ordered_config_type *config_ptr)
{
  wcdma_l2_ul_cmd_type  *l2_ul_cmd_ptr;

  /* Fill in the MAC uplink parameters and send the primitive */
  l2_ul_cmd_ptr = wcdma_l2_ul_get_cmd_buf();

  /* Fill in the Command Header */
  l2_ul_cmd_ptr->cmd_hdr.cmd_id = CMAC_UL_CONFIG_REQ;

  /* Use Current Config when processing a Security Mode Command */
  l2_ul_cmd_ptr->cmd_data.mac_config_info = config_ptr->mac_ul_parms;

  rrcllc_copy_mac_cipher_config(l2_ul_cmd_ptr->cmd_data.mac_config_info.cipher_info);

  l2_ul_cmd_ptr->cmd_data.mac_config_info.wait_for_l1_sig = FALSE;

  l2_ul_cmd_ptr->cmd_data.mac_config_info.mac_config_changed = MAC_CFG_CHANGED;

#ifdef FEATURE_WCDMA_HS_RACH
/*We need to reconfigure hsrach because we want L2 to apply the ENRTI during rnti update time.
  earlier we would have deleted the ernti as part of channel config from procedure */
  if((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CU) &&(rrchsrach_get_common_edch_transmission(config_ptr) == TRUE))
  {
    rrcllc_set_hs_rach_action(config_ptr,MAC_HS_RACH_CONFIG);
      
    l2_ul_cmd_ptr->cmd_data.mac_config_info.hs_rach_action = 
    config_ptr->mac_hs_rach_action;

    config_ptr->mac_hs_rach_config.primary_e_rnti_present = 
    		config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present;

    config_ptr->mac_hs_rach_config.primary_e_rnti = 
        config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti;

    l2_ul_cmd_ptr->cmd_data.mac_config_info.hs_rach_config_ptr = &config_ptr->mac_hs_rach_config;

    l2_ul_cmd_ptr->cmd_data.mac_config_info.mac_hsrach_e_reset_indicator = 
      config_ptr->mac_hsrach_e_reset_indicator;
    l2_ul_cmd_ptr->cmd_data.mac_config_info.hs_rach_to_eul_trans = 
      config_ptr->hs_rach_to_eul_trans;

  }
#endif

  WRRC_MSG1_HIGH("Dispatching out L2 cmd CMAC_UL_CONFIG_REQ : MAC UL Parms 0x%x, Sending CMAC_UL_CONFIG_REQ",&config_ptr->mac_ul_parms);
  rrc_send_l2_ul_cmd(l2_ul_cmd_ptr);

#ifdef FEATURE_WCDMA_HS_RACH
  if((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CU) &&(rrchsrach_get_common_edch_transmission(config_ptr) == TRUE))
  {
    rrcllc_set_hs_rach_action(config_ptr,MAC_HS_RACH_NOOP);
  }
#endif
} /* rrcllc_cmac_ul_config_req_for_rnti_update */

/*===========================================================================
FUNCTION   rrcllc_cphy_setup_req

DESCRIPTION
  This function sends a CPHY_SETUP_REQ to L1. It gets a L1 command buffer,
  fills it up with the data, pointer to which is passed as a parameter to
  this function. It then sends the command over to L1.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static void
rrcllc_cphy_setup_req(l1_ext_cmd_type  *l1_stored_cmd)
{
  l1_ext_cmd_type   *l1_cmd_ptr;
  ordered_config_type *config_ptr = ordered_config_ptr;

  if(rrcllc_cmd_under_process.chan_config.current_cmd_engine == LLC_CELL_RESELECTION_ENGINE)
  {
    config_ptr = reselection_config_ptr;
  }

  l1_cmd_ptr = l1_get_cmd_buf();
  /* Fill in the Command Header, and indicate to do it Now! */
  l1_cmd_ptr->cmd_hdr.cmd_id        = CPHY_SETUP_REQ;

  /* Copy the command contents from stored CPHY_SETUP_REQ command */
  l1_cmd_ptr->cmd.setup = l1_stored_cmd->cmd.setup;

  l1_cmd_ptr->cmd_hdr.seq_num       = seq_num;
  seq_num ++;

  if((rrcllc_cmd_under_process.chan_config.solo_bch_operation) ||
     (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_LBT))
  {
    l1_cmd_ptr->cmd_hdr.act_time_type = L1_ACTIVATION_TIME_NONE;
    l1_cmd_ptr->cmd_hdr.act_time      = 0;
  }
  else
  {
    l1_cmd_ptr->cmd_hdr.act_time_type = config_ptr->act_time_type;
    l1_cmd_ptr->cmd_hdr.act_time      = config_ptr->activation_time;
    l1_cmd_ptr->cmd_hdr.sdu_time      = config_ptr->sdu_time;
  }

  /* Only when next state is Cell_DCH and either uplink or
   * downlink MAC needs to be re-configured, set this signal.
   */
  l1_cmd_ptr->cmd.setup.signal_ul_mac_at_act_time = FALSE;
  l1_cmd_ptr->cmd.setup.signal_dl_mac_at_act_time = FALSE;
  if((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_SIB)&&
    (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_DCH) &&
    (rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_SIB_READ_IN_DCH))
  {
    /*
     This is the case of bringing up S-BCCH when we are in DCH for the case of GPS
     We already said to MAC not to sync with L1 
    */
    WRRC_MSG0_HIGH("Cphy_setup_req for S-BCCH in DCH");
    l1_cmd_ptr->cmd.setup.signal_dl_mac_at_act_time = FALSE;
    l1_cmd_ptr->cmd.setup.signal_ul_mac_at_act_time = FALSE;
  }
  else
  {
    if((rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_DCH) &&
       (ordered_config.set_status != OC_SET_FOR_DCH_FACH_TRANS))
    {
      if(rrcllc_cmd_under_process.procedure != RRC_PROCEDURE_ASU)
      {
        /* Do not do inter-layer sync for ASU as MAC configuration
         * remains the same although it is being re-configured.
         */
        if((l1_cmd_ptr->cmd.setup.req_mask & CPHY_DL_PHYCHAN_DROP_INCL)  &&
             ((l1_cmd_ptr->cmd.setup.drop_dl_phychan == L1_DL_PHYCHAN_PCCPCH_S) ||
              (l1_cmd_ptr->cmd.setup.drop_dl_phychan == L1_DL_PHYCHAN_PCCPCH_N)))
        {
          WRRC_MSG0_HIGH("No inter-layer sync for N/S PCCPCH drop");
        }
        else
        {
          if((config_ptr->reconfig_needed.downlink_l1) &&
             (config_ptr->reconfig_needed.downlink_mac))
          {
            WRRC_MSG0_MED("CPHY SETUP REQ: Sig DL MAC");
            l1_cmd_ptr->cmd.setup.signal_dl_mac_at_act_time = TRUE;
          }
          if((config_ptr->reconfig_needed.uplink_l1) &&
             (config_ptr->reconfig_needed.uplink_mac))
          {
            WRRC_MSG0_MED("CPHY SETUP REQ: Sig UL MAC");
            l1_cmd_ptr->cmd.setup.signal_ul_mac_at_act_time = TRUE;
          }
        }
      }
      else
      {
            /* Procedure is ASU. Check if MAC-hs Reset is indicated and HS Action is RECONFIG 
                to ensure that MAC does not do HS-reset before L1 sends a sync and cleans up DOB */
        if ((l1_cmd_ptr->cmd.setup.hsdpa_l1_ops == HSDPA_SETUP_OPS_RECFG)  
          && 
          ((config_ptr->mac_dl_parms.mac_hs_reset_indicator == TRUE) && 
                    (config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_RECONFIG)))
        {
          WRRC_MSG0_MED("RRCHS:ASURepoint HSRESET. L1->MAC Sync");
          l1_cmd_ptr->cmd.setup.signal_dl_mac_at_act_time = TRUE;
        }
#ifdef FEATURE_WCDMA_DC_HSUPA
        if((l1_cmd_ptr->cmd.setup.sec_e_req_mask) && (config_ptr->mac_sec_eul_action != MAC_SEC_EUL_NOOP))
        {
            WRRC_MSG0_MED("DCHSUPA_DEBUG: ASU changes DCHSUPA config, signal ul mac to TRUE");
            l1_cmd_ptr->cmd.setup.signal_ul_mac_at_act_time = TRUE;
        }
#endif
#ifdef FEATURE_WCDMA_16_QAM
        if((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_ASU) &&
           (l1_cmd_ptr->cmd.setup.e_req_mask & (L1_EUL_START|L1_EUL_RECFG_UL|L1_EUL_RECFG_DL|L1_EUL_STOP)) &&
           (config_ptr->mac_eul_action != MAC_EUL_NOOP) &&
           ((ordered_config_ptr->l1_e_info.e_ul_info.e_ul_16qam_action == TRUE) || 
            (current_config_ptr->l1_e_info.e_ul_info.e_ul_16qam_action == TRUE))
          )
        {
          WRRC_MSG0_MED("HSPA+:UL 16QAM: ASU changes 16QAM config, signal ul mac to TRUE");
          l1_cmd_ptr->cmd.setup.signal_ul_mac_at_act_time = TRUE;
        }
#endif
      }
    }
  }
#ifdef FEATURE_WCDMA_HS_FACH
  /*For enh FACH actions always set signal_dl_mac_at_act_time*/
  if( (!((rrc_get_hsdpa_action() == HSDPA_START) ||
       ((rrc_get_hsdpa_status() == HSDPA_ACTIVE) && (rrc_get_hsdpa_action() != HSDPA_STOP)) ) && 
      (l1_cmd_ptr->cmd.setup.hsdpa_l1_ops != HSDPA_SETUP_OPS_NOOP) ))
  {
    WRRC_MSG0_MED("EFACH: CPHY SETUP REQ: Sig DL MAC");
    l1_cmd_ptr->cmd.setup.signal_dl_mac_at_act_time = TRUE;
  }

#endif

#ifdef FEATURE_WCDMA_HS_RACH
  /*For all HS RACH configurations Synch with L1 should be always set */
      if((l1_cmd_ptr->cmd.setup.hs_rach_req_mask != L1_HS_RACH_NO_OP) &&
        (ordered_config_ptr->mac_hs_rach_action != MAC_HS_RACH_NOOP))
  {
    WRRC_MSG0_MED("RRCHSRACH: CPHY SETUP REQ: Sig UL MAC");
    l1_cmd_ptr->cmd.setup.signal_ul_mac_at_act_time = TRUE;
  }
#endif
  WRRC_MSG0_MED("Dispatching out PHY cmd / Sending CPHY_SETUP_REQ to L1");

  if(rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_DCH)
  {
    if(l1_cmd_ptr->cmd.setup.ul_cctrch_info != NULL )
    {
      WRRC_MSG2_MED(" num trch %d num tfci %d",l1_cmd_ptr->cmd.setup.ul_cctrch_info->num_trch,l1_cmd_ptr->cmd.setup.ul_cctrch_info->num_tfci);
    }
  }


  if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
  {
    if(l1_cmd_ptr->cmd.setup.hsdpa_l1_info != NULL )
    {
      WRRC_MSG2_MED("RRCHS:L1 HSDPA Action %d HSDPA Bitmask 0x%x",
        l1_cmd_ptr->cmd.setup.hsdpa_l1_ops,
        l1_cmd_ptr->cmd.setup.hsdpa_l1_info->hs_req_mask);
    }
    else
    {
      WRRC_MSG1_MED("RRCHS:L1 HSDPA Action %d",l1_cmd_ptr->cmd.setup.hsdpa_l1_ops);
    }
  }

#ifdef FEATURE_WCDMA_HS_FACH
  /*This change is added as part of optimzation to avoid rach add and drop.
         It is added for a specific channel config sent by CU for UMIC case (PCH to FACH transition)*/
  if((rrcllc_cmd_under_process.valid) &&
     (rrcllc_cmd_under_process.chan_config.current_cmd_engine
        == LLC_CHAN_CONFIG_ENGINE) &&
        (rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_HS_FACH_DEDICATED_OPS) &&
        (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_FACH) &&
        (rrcllc_get_ordered_config_status_wo_f3() == OC_NOT_SET))
  {
     WRRC_MSG2_HIGH("RRC_DEBUG: Resetting RACH reqmask %d and hsrach req mask", l1_cmd_ptr->cmd.setup.req_mask, l1_cmd_ptr->cmd.setup.hs_rach_req_mask);
     l1_cmd_ptr->cmd.setup.req_mask &=~(CPHY_UL_PHYCHAN_ADD_INCL|CPHY_UL_PHYCHAN_DROP_INCL|CPHY_UL_CCTRCH_INCL);
#ifdef FEATURE_WCDMA_HS_RACH
     if(l1_cmd_ptr->cmd.setup.req_mask & CPHY_HS_RACH_CHAN_CFG_INCL)
     {
       l1_cmd_ptr->cmd.setup.hs_rach_req_mask = L1_HS_RACH_ERNTI_UPDATE;
     }
#endif

  }
#endif


  WRRC_MSG6_MED("CphySetup 0x%x, UL PhyDB 0x%x, CCTrCH 0x%x, DL PhyDB 0x%x, CCTrCH 0x%x",l1_cmd_ptr->cmd.setup.req_mask,
  l1_cmd_ptr->cmd.setup.ul_phychan_db,l1_cmd_ptr->cmd.setup.ul_cctrch_info,l1_cmd_ptr->cmd.setup.dl_phychan_db,l1_cmd_ptr->cmd.setup.dl_cctrch_info,0);
  
#ifdef FEATURE_WCDMA_HS_FACH
  if((rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_FACH)&&
      (l1_cmd_ptr->cmd.setup.hsdpa_l1_info != NULL)&&
      (rrcrb_is_cu_required() == TRUE)&&
      ((l1_cmd_ptr->cmd.setup.hsdpa_l1_ops == HSDPA_SETUP_OPS_START) || (l1_cmd_ptr->cmd.setup.hsdpa_l1_ops == HSDPA_SETUP_OPS_RECFG)))
  {
    if((l1_cmd_ptr->cmd.setup.hsdpa_l1_info->hs_dsch_info.efach_h_rnti_bmsk | L1_DEDICATED_H_RNTI_VALID) &&
       (l1_cmd_ptr->cmd.setup.hsdpa_l1_info->hs_dsch_info.bcch_h_rnti == l1_cmd_ptr->cmd.setup.hsdpa_l1_info->hs_dsch_info.h_rnti))
    {
      if(current_config_ptr->efach_hrnti_status == COMMON_HRNTI)
        l1_cmd_ptr->cmd.setup.hsdpa_l1_info->hs_dsch_info.h_rnti = current_config_ptr->efach_hrnti;
      else
        l1_cmd_ptr->cmd.setup.hsdpa_l1_info->hs_dsch_info.h_rnti = ordered_config_ptr->efach_hrnti;
      l1_cmd_ptr->cmd.setup.hsdpa_l1_info->hs_dsch_info.efach_h_rnti_bmsk &= L1_BCCH_H_RNTI_VALID;
      l1_cmd_ptr->cmd.setup.hsdpa_l1_info->hs_dsch_info.efach_h_rnti_bmsk |= L1_COMMON_H_RNTI_VALID;

      WRRC_MSG0_HIGH("EFACH: BCCH and HRNTI matched!!!, configuring common mode HRNTI");
    }
  }
#endif
  rrc_print_cphy_setup(&l1_cmd_ptr->cmd.setup);

  /* Now send the primitive to L1 */
  rrc_send_l1_cmd(l1_cmd_ptr);

#ifdef FEATURE_RRC_CAPTURE_L1_DEADLOCK
  /* Start timer for L1 deadlock detection */
  rrctmr_start_timer( RRCTMR_L1_DEADLOCK_DETECT_TIMER,
                      RRCTMR_L1_DEADLOCK_DETECT_TIMER_IN_MS );
#endif
} /* rrcllc_cphy_setup_req */

/*====================================================================
FUNCTION: rrc_print_cphy_setup()

DESCRIPTION:
  This function prints  cphy config of 3c hsdpa 

DEPENDENCIES:
  None.
RETURN VALUE:
  None
SIDE EFFECTS:
  None
====================================================================*/
void rrc_print_cphy_setup(l1_setup_cmd_type *l1_cmd_ptr)
{

  uint8 ix=0, count=0;
  ordered_config_type *config_ptr = NULL;

  /* Overall */
  WRRC_MSG9_HIGH("Dispatching out PHY cmd / Sending CPHY_SETUP_REQ to L1 req_mask 0X%x, Sig act UL %d, DL %d , hho_setup_mask 0X%x call_type_mask 0X%x, freq_incl %d, rf_chan %d, hsrach_req_mask:%d, transition_to_dch:%d",
   l1_cmd_ptr->req_mask,l1_cmd_ptr->signal_ul_mac_at_act_time,l1_cmd_ptr->signal_dl_mac_at_act_time,
   l1_cmd_ptr->hho_setup_mask,l1_cmd_ptr->call_type_mask,l1_cmd_ptr->freq_incl,l1_cmd_ptr->rf_chan, 
   l1_cmd_ptr->hs_rach_req_mask,l1_cmd_ptr->transition_to_dch);
  WRRC_MSG6_HIGH("ul_phy_chan: l1_ul_phychan_enum_type_value%d, dl_phy_chan: l1_dl_phychan_enum_type_value%d, drop_ul_phychan l1_ul_phychan_enum_type_value%d, drop_dl_phychan l1_dl_phychan_enum_type_value%d sec_e_req_mask: %d, call_type_mask:%d",
    l1_cmd_ptr->ul_phychan, l1_cmd_ptr->dl_phychan,l1_cmd_ptr->drop_ul_phychan,l1_cmd_ptr->drop_dl_phychan, l1_cmd_ptr->sec_e_req_mask, l1_cmd_ptr->call_type_mask
    );

  if((l1_cmd_ptr->ul_cctrch_info != NULL) && (l1_cmd_ptr->ul_cctrch_info->num_trch!= 0))
  {
    WRRC_MSG2_HIGH(" num trch %d num tfci %d",l1_cmd_ptr->ul_cctrch_info->num_trch,l1_cmd_ptr->ul_cctrch_info->num_tfci);
  }

  /* HSDPA/EFACH */
  if(l1_cmd_ptr->hsdpa_l1_info != NULL)
  {
    WRRC_MSG9_HIGH("HS_DEBUG:HS-OP:%d, REQ-MASK 0X%x, HS-TYPE %d TB_size_alignment %d, PSC %d HRNTI 0X%x\tBCCH-HRNTI 0X%x\tBIT-MASK 0X%x , hs_categ: %d",
    l1_cmd_ptr->hsdpa_l1_ops,l1_cmd_ptr->hsdpa_l1_info->hs_req_mask,
    l1_cmd_ptr->hsdpa_l1_info->hs_dsch_info.mac_hs_or_ehs,
    l1_cmd_ptr->hsdpa_l1_info->hs_dsch_info.hsdsch_tb_size_alignment_type,
    l1_cmd_ptr->hsdpa_l1_info->hs_pdsch_rl_psc,
    l1_cmd_ptr->hsdpa_l1_info->hs_dsch_info.h_rnti,
    l1_cmd_ptr->hsdpa_l1_info->hs_dsch_info.bcch_h_rnti,
    l1_cmd_ptr->hsdpa_l1_info->hs_dsch_info.efach_h_rnti_bmsk,
    rrc_return_hsdpa_category_value(l1_cmd_ptr->hsdpa_l1_info->hs_dsch_info.mac_hs_or_ehs));
    
    WRRC_MSG6_HIGH("HS_DEBUG:CCTrchId %d HARQ NumProc %d,Partition(Valid/Invalid::0/1) %d,sec_scr_code_valid %d, sec_scr_code %d num_ch_code %d",
    l1_cmd_ptr->hsdpa_l1_info->hs_dsch_info.cctrch_id,
    l1_cmd_ptr->hsdpa_l1_info->hs_dsch_info.harq_info.num_proc,
    l1_cmd_ptr->hsdpa_l1_info->hs_dsch_info.harq_info.mem_part_info_valid,
    l1_cmd_ptr->hsdpa_l1_info->hs_scch_info.sec_scr_code_valid, 
    l1_cmd_ptr->hsdpa_l1_info->hs_scch_info.sec_scr_code, 
    l1_cmd_ptr->hsdpa_l1_info->hs_scch_info.num_ch_code);

    /* EDRX*/
#ifdef FEATURE_WCDMA_HS_FACH_DRX
    WRRC_MSG5_HIGH("EFACH_DRX:t_321 %d, drx_cycle_length %d rx_burst %d,can_hs_data_interrupt_drx %d, dhrnti 0X%x ",
    l1_cmd_ptr->hsdpa_l1_info->efach_drx_info.t_321, 
    l1_cmd_ptr->hsdpa_l1_info->efach_drx_info.drx_cycle_length, 
    l1_cmd_ptr->hsdpa_l1_info->efach_drx_info.rx_burst,
    l1_cmd_ptr->hsdpa_l1_info->efach_drx_info.can_hs_data_interrupt_drx, 
    l1_cmd_ptr->hsdpa_l1_info->efach_drx_info.dhrnti);
#endif
  }
#ifdef FEATURE_WCDMA_HS_RACH

  if((l1_cmd_ptr->hs_rach_req_mask != L1_HS_RACH_NO_OP) && (l1_cmd_ptr->hs_rach_req_mask != L1_HS_RACH_STOP)
    && (l1_cmd_ptr->hs_rach_e_info_ptr != NULL))
  {
    WRRC_MSG9_HIGH("RRCHSRACH :EDL Info p_ernti_prst %d, p_ernti 0x%d, tti %d, srvg_grant %d, 3_idx_step_thres %d, EDL Info 2_idx_step_thres %d grant_selec %d ch_code %d, #Common resources	%d",
    l1_cmd_ptr->hs_rach_e_info_ptr->e_dl_info.primary_e_rnti_present,
    l1_cmd_ptr->hs_rach_e_info_ptr->e_dl_info.primary_e_rnti,
    l1_cmd_ptr->hs_rach_e_info_ptr->e_dl_info.e_tti,
    l1_cmd_ptr->hs_rach_e_info_ptr->e_dl_info.grant_config.serving_grant,
    l1_cmd_ptr->hs_rach_e_info_ptr->e_dl_info.grant_config.three_index_step_threshold,
    l1_cmd_ptr->hs_rach_e_info_ptr->e_dl_info.grant_config.two_index_step_threshold,
    l1_cmd_ptr->hs_rach_e_info_ptr->e_dl_info.grant_config.grant_selector,
    l1_cmd_ptr->hs_rach_e_info_ptr->e_dl_info.e_agch_info.ch_code,
    l1_cmd_ptr->common_e_dch_resource_list->num_e_dch_common_info
    );
  }

#endif
/* DCHSDPA */
#ifdef FEATURE_WCDMA_DC_HSDPA

if(l1_cmd_ptr->hsdpa_l1_info != NULL)
{
  if(l1_cmd_ptr->hsdpa_l1_info->hs_req_mask&CPHY_HS_SEC_HSDPA_CFG_INCL)
  {
    for(ix = 0;ix < MAX_NUM_OF_SEC_CARRIERS; ix++)
    {
      WRRC_MSG1_HIGH("SEC-HSDPA_DEBUG: SEC ACTION: %d[0-NOOP/1-START/2-RECFG/3-STOP]", l1_cmd_ptr->hsdpa_l1_info->sec_hs_carrier_info[ix].sec_hsdpa_action);
      if(L1_SEC_HSDPA_STOP != l1_cmd_ptr->hsdpa_l1_info->sec_hs_carrier_info[ix].sec_hsdpa_action)
      {
        WRRC_MSG8_HIGH("SEC-HSDPA_DEBUG: HRNTI: %d, 64QAM: %d, TB size alignment: %d, pri_cpich_src_code:%d, sec_src_code_valid: %d sec_src_code: %d, num_ch_code: %d, po_hs_dsch_sec_cell: %d",
        l1_cmd_ptr->hsdpa_l1_info->sec_hs_carrier_info[ix].h_rnti_sec_cell,
        l1_cmd_ptr->hsdpa_l1_info->sec_hs_carrier_info[ix].hs_sec_cell_64_qam_configured,
        l1_cmd_ptr->hsdpa_l1_info->sec_hs_carrier_info[ix].hs_sec_cell_tb_size_alignment_type,
        l1_cmd_ptr->hsdpa_l1_info->sec_hs_carrier_info[ix].pri_cpich_scr_code,
        l1_cmd_ptr->hsdpa_l1_info->sec_hs_carrier_info[ix].hs_sec_cell_scch_info.sec_scr_code_valid,
        l1_cmd_ptr->hsdpa_l1_info->sec_hs_carrier_info[ix].hs_sec_cell_scch_info.sec_scr_code,
        l1_cmd_ptr->hsdpa_l1_info->sec_hs_carrier_info[ix].hs_sec_cell_scch_info.num_ch_code,
        l1_cmd_ptr->hsdpa_l1_info->sec_hs_carrier_info[ix].po_hs_dsch_sec_cell);
        WRRC_MSG3_HIGH("SEC-HSDPA_DEBUG: hs_sec_cell_dl_freq: %d, revert_old_config: %d, TX mode: %d",
        l1_cmd_ptr->hsdpa_l1_info->sec_hs_carrier_info[ix].hs_sec_cell_dl_freq, 
        l1_cmd_ptr->revert_old_config, 
        l1_cmd_ptr->hsdpa_l1_info->sec_hs_carrier_info[ix].diff_txd_mode);
      }
    }
  }
}
#endif
/*DC HSUPA */

#ifdef FEATURE_WCDMA_DC_HSUPA 
  
  if(l1_cmd_ptr->sec_e_req_mask & L1_EUL_START)
  {
    WRRC_MSG5_HIGH("DCHSUPA_DEBUG: EUL: e_min_beta_ed: %d, scrambling_code_type: %d, scrambling_code: %d,dpcch_pwr_offset: %d, pcp_len: %d", l1_cmd_ptr->sec_e_info_ptr->e_ul_info.e_min_beta_ed, l1_cmd_ptr->sec_e_info_ptr->e_ul_info.dpcch_info.scrambling_code_type,
    l1_cmd_ptr->sec_e_info_ptr->e_ul_info.dpcch_info.scrambling_code, 
    l1_cmd_ptr->sec_e_info_ptr->e_ul_info.dpcch_info.dpcch_pwr_offset, 
    l1_cmd_ptr->sec_e_info_ptr->e_ul_info.dpcch_info.pcp_len);
    
    WRRC_MSG8_HIGH("DCHSUPA_DEBUG: EDL: primary_e_rnti_present: %d, secondary_e_rnti_present: %d, primary_e_rnti: %d, e_tti: %d, serving_grant: %d, three_index_step_threshold: %d,  two_index_step_threshold: %d", 
    l1_cmd_ptr->sec_e_info_ptr->e_dl_info.primary_e_rnti_present, 
    l1_cmd_ptr->sec_e_info_ptr->e_dl_info.secondary_e_rnti_present, 
    l1_cmd_ptr->sec_e_info_ptr->e_dl_info.primary_e_rnti, 
    l1_cmd_ptr->sec_e_info_ptr->e_dl_info.secondary_e_rnti, 
    l1_cmd_ptr->sec_e_info_ptr->e_dl_info.e_tti, 
    l1_cmd_ptr->sec_e_info_ptr->e_dl_info.grant_config.serving_grant, 
    l1_cmd_ptr->sec_e_info_ptr->e_dl_info.grant_config.three_index_step_threshold, 
      l1_cmd_ptr->sec_e_info_ptr->e_dl_info.grant_config.two_index_step_threshold);
    
    WRRC_MSG2_HIGH("DCHSUPA_DEBUG: EDL num_e_rl_release_info: %d  grant_selector: %d", 
     l1_cmd_ptr->sec_e_info_ptr->e_dl_info.grant_config.grant_selector,
     l1_cmd_ptr->sec_e_info_ptr->e_dl_info.num_e_rl_release_info);
    
    for(count=0; count < l1_cmd_ptr->sec_e_info_ptr->e_dl_info.num_e_rl_release_info; count++)
    {
      WRRC_MSG2_HIGH("DCHSUPA_DEBUG: EDL e_rl_release_info%d PSC: %d", count, l1_cmd_ptr->sec_e_info_ptr->e_dl_info.e_rl_release_info[count].psc);
    }

    WRRC_MSG2_HIGH("DCHSUPA_DEBUG: EDL e_serving_rl_idx: %d, num_e_dl_rl_add_recfg_info: %d", 
    l1_cmd_ptr->sec_e_info_ptr->e_dl_info.e_serving_rl_idx, l1_cmd_ptr->sec_e_info_ptr->e_dl_info.num_e_dl_rl_add_recfg_info);
    
    for(count=0; count < l1_cmd_ptr->sec_e_info_ptr->e_dl_info.num_e_dl_rl_add_recfg_info; count++)
    {
      WRRC_MSG5_HIGH("DCHSUPA_DEBUG: EDL e_dl_rl_add_recfg_info :%d e_dl_channel_mask: %d, e_rl_psc: %d,tpc_idx: %d agch ch_code: %d", 
      count, l1_cmd_ptr->sec_e_info_ptr->e_dl_info.e_dl_rl_add_recfg_info[count].e_dl_channel_mask, 
      l1_cmd_ptr->sec_e_info_ptr->e_dl_info.e_dl_rl_add_recfg_info[count].e_rl_psc, 
      l1_cmd_ptr->sec_e_info_ptr->e_dl_info.e_dl_rl_add_recfg_info[count].tpc_idx,
        l1_cmd_ptr->sec_e_info_ptr->e_dl_info.e_dl_rl_add_recfg_info[count].e_agch_info.ch_code);

      WRRC_MSG4_HIGH("DCHSUPA_DEBUG: EDL rgch rg_idx: %d, rgch signature_idx: %d, hich ch_code: %d, hich signature_idx: %d", 
      l1_cmd_ptr->sec_e_info_ptr->e_dl_info.e_dl_rl_add_recfg_info[count].e_rgch_info.rg_idx,
      l1_cmd_ptr->sec_e_info_ptr->e_dl_info.e_dl_rl_add_recfg_info[count].e_rgch_info.signature_idx,
      l1_cmd_ptr->sec_e_info_ptr->e_dl_info.e_dl_rl_add_recfg_info[count].e_hich_info.ch_code,
      l1_cmd_ptr->sec_e_info_ptr->e_dl_info.e_dl_rl_add_recfg_info[count].e_hich_info.signature_idx);
    }
    
  }
  if(l1_cmd_ptr->sec_e_req_mask & L1_EUL_RECFG_UL)
  {
    WRRC_MSG1_HIGH("DCHSUPA_DEBUG: SEC EUL e_min_beta_ed: %d ", l1_cmd_ptr->sec_e_info_ptr->e_ul_info.e_min_beta_ed);
  }
  if(l1_cmd_ptr->sec_e_req_mask & L1_EUL_RECFG_DL)
  {
    WRRC_MSG5_HIGH("DCHSUPA_DEBUG: EDL: primary_e_rnti_present: %d, secondary_e_rnti_present: %d,primary_e_rnti: %d, e_tti: %d", 
    l1_cmd_ptr->sec_e_info_ptr->e_dl_info.primary_e_rnti_present, 
    l1_cmd_ptr->sec_e_info_ptr->e_dl_info.secondary_e_rnti_present, 
    l1_cmd_ptr->sec_e_info_ptr->e_dl_info.primary_e_rnti, 
    l1_cmd_ptr->sec_e_info_ptr->e_dl_info.secondary_e_rnti, 
      l1_cmd_ptr->sec_e_info_ptr->e_dl_info.e_tti);
    
    WRRC_MSG5_HIGH("DCHSUPA_DEBUG: EDL: serving_grant: %d, three_index_step_threshold: %d,  two_index_step_threshold: %d, grant_selector: %d, num_e_rl_release_info: %d", 
    l1_cmd_ptr->sec_e_info_ptr->e_dl_info.grant_config.serving_grant, 
    l1_cmd_ptr->sec_e_info_ptr->e_dl_info.grant_config.three_index_step_threshold, 
    l1_cmd_ptr->sec_e_info_ptr->e_dl_info.grant_config.two_index_step_threshold,
    l1_cmd_ptr->sec_e_info_ptr->e_dl_info.grant_config.grant_selector,
    l1_cmd_ptr->sec_e_info_ptr->e_dl_info.num_e_rl_release_info);
    
    for(count=0; count < l1_cmd_ptr->sec_e_info_ptr->e_dl_info.num_e_rl_release_info; count++)
    {
      WRRC_MSG2_HIGH("DCHSUPA_DEBUG: EDL e_rl_release_info%d PSC: %d", count, l1_cmd_ptr->sec_e_info_ptr->e_dl_info.e_rl_release_info[count].psc);
    }
    WRRC_MSG2_HIGH("DCHSUPA_DEBUG: EDL e_serving_rl_idx: %d, num_e_dl_rl_add_recfg_info: %d", 
    l1_cmd_ptr->sec_e_info_ptr->e_dl_info.e_serving_rl_idx, l1_cmd_ptr->sec_e_info_ptr->e_dl_info.num_e_dl_rl_add_recfg_info);
    
    for(count=0; count < l1_cmd_ptr->sec_e_info_ptr->e_dl_info.num_e_dl_rl_add_recfg_info; count++)
    {
      WRRC_MSG5_HIGH("DCHSUPA_DEBUG: EDL e_dl_rl_add_recfg_info%d e_dl_channel_mask: %d, e_rl_psc: %d, tpc_idx:%d agch ch_code: %d,rgch rg_idx: %d, rgch signature_idx: %d, hich ch_code: %d, hich signature_idx: %d", 
      count, l1_cmd_ptr->sec_e_info_ptr->e_dl_info.e_dl_rl_add_recfg_info[count].e_dl_channel_mask, 
      l1_cmd_ptr->sec_e_info_ptr->e_dl_info.e_dl_rl_add_recfg_info[count].e_rl_psc, 
      l1_cmd_ptr->sec_e_info_ptr->e_dl_info.e_dl_rl_add_recfg_info[count].tpc_idx,
      l1_cmd_ptr->sec_e_info_ptr->e_dl_info.e_dl_rl_add_recfg_info[count].e_agch_info.ch_code);

      WRRC_MSG4_HIGH("DCHSUPA_DEBUG: EDL rgch rg_idx: %d, rgch signature_idx: %d, hich ch_code: %d, hich signature_idx: %d", 
      l1_cmd_ptr->sec_e_info_ptr->e_dl_info.e_dl_rl_add_recfg_info[count].e_rgch_info.rg_idx,
      l1_cmd_ptr->sec_e_info_ptr->e_dl_info.e_dl_rl_add_recfg_info[count].e_rgch_info.signature_idx,
      l1_cmd_ptr->sec_e_info_ptr->e_dl_info.e_dl_rl_add_recfg_info[count].e_hich_info.ch_code,
      l1_cmd_ptr->sec_e_info_ptr->e_dl_info.e_dl_rl_add_recfg_info[count].e_hich_info.signature_idx);

    }
  }
  
  if((l1_cmd_ptr->req_mask&CPHY_SEC_DL_PHYCHAN_CFG_INCL)|| (l1_cmd_ptr->req_mask&CPHY_SEC_DL_PHYCHAN_ADD_INCL))
  {
    for(count=0; count < l1_cmd_ptr->dl_phychan_db->sec_num_rl; count++)
    {
      WRRC_MSG8_HIGH("DCHSUPA_DEBUG: sec_rl%d pri_cpich_scr_code: %d, dpch_per_rl: %d, opt_parms_present_mask: %d, use_pri_cpich: %d,frame_offset: %d, sec_cpich_sec_scr_code %d, sec_cpich_ch_code: %d, num_dpch: %d", 
      count, l1_cmd_ptr->dl_phychan_db->sec_dl_per_rl[count].pri_cpich_scr_code, 
      l1_cmd_ptr->dl_phychan_db->sec_dl_per_rl[count].dpch_per_rl.opt_parms_present_mask,
      l1_cmd_ptr->dl_phychan_db->sec_dl_per_rl[count].dpch_per_rl.use_pri_cpich,
      l1_cmd_ptr->dl_phychan_db->sec_dl_per_rl[count].dpch_per_rl.frame_offset,
      l1_cmd_ptr->dl_phychan_db->sec_dl_per_rl[count].dpch_per_rl.sec_cpich_sec_scr_code,
      l1_cmd_ptr->dl_phychan_db->sec_dl_per_rl[count].dpch_per_rl.sec_cpich_ch_code,
      l1_cmd_ptr->dl_phychan_db->sec_dl_per_rl[count].dpch_per_rl.num_dpch);
      
      for(ix=0; ix<l1_cmd_ptr->dl_phychan_db->sec_dl_per_rl[count].dpch_per_rl.num_dpch; ix++)
      {
        WRRC_MSG4_HIGH("DCHSUPA_DEBUG: opt_parm_present_mask: %d, sec_scr_code: %d, code_number: %d, scr_code_change: %d",
        l1_cmd_ptr->dl_phychan_db->sec_dl_per_rl[count].dpch_per_rl.dl_chan_code[ix].opt_parm_present_mask,
        l1_cmd_ptr->dl_phychan_db->sec_dl_per_rl[count].dpch_per_rl.dl_chan_code[ix].sec_scr_code,
        l1_cmd_ptr->dl_phychan_db->sec_dl_per_rl[count].dpch_per_rl.dl_chan_code[ix].code_number,
        l1_cmd_ptr->dl_phychan_db->sec_dl_per_rl[count].dpch_per_rl.dl_chan_code[ix].scr_code_change);
      }
      WRRC_MSG4_HIGH("DCHSUPA_DEBUG: tpc_idx: %d, closed_loop_timing_adj_mode: %d, fdpch_sttd_ind: %d, efdpch_slot_format: %d", 
      l1_cmd_ptr->dl_phychan_db->sec_dl_per_rl[count].dpch_per_rl.tpc_idx,
      l1_cmd_ptr->dl_phychan_db->sec_dl_per_rl[count].dpch_per_rl.closed_loop_timing_adj_mode,
      l1_cmd_ptr->dl_phychan_db->sec_dl_per_rl[count].dpch_per_rl.fdpch_sttd_ind,
      l1_cmd_ptr->dl_phychan_db->sec_dl_per_rl[count].dpch_per_rl.efdpch_slot_format);
    }
  }

  if((l1_cmd_ptr->req_mask & CPHY_SEC_UL_PHYCHAN_CFG_INCL)||(l1_cmd_ptr->req_mask & CPHY_SEC_UL_PHYCHAN_ADD_INCL))
  {
    WRRC_MSG5_HIGH("DCHSUPA_DEBUG: SEC EUL DPCCH:  scrambling_code_type: %d, scrambling_code: %d, dpcch_pwr_offset: %d, pcp_len: %d", 
    l1_cmd_ptr->sec_e_info_ptr->e_ul_info.dpcch_info.scrambling_code_type, l1_cmd_ptr->sec_e_info_ptr->e_ul_info.dpcch_info.scrambling_code, 
    l1_cmd_ptr->sec_e_info_ptr->e_ul_info.dpcch_info.dpcch_pwr_offset, 
    l1_cmd_ptr->sec_e_info_ptr->e_ul_info.dpcch_info.pcp_len,0);
  }

#endif

}

/*===========================================================================
FUNCTION   rrcllc_update_oc_with_srb5_lcid

DESCRIPTION
  This function updates Logical ID for SRB#5 in OC.

DEPENDENCIES
  None.

RETURN VALUE
  Void

SIDE EFFECTS
  None.
===========================================================================*/
static void rrcllc_update_oc_with_srb5_lcid(rlc_lc_id_type srb5_lc_id)
{
  ordered_config_ptr->srb5_info.lc_id = srb5_lc_id;
} /* rrcllc_update_oc_with_srb5_lcid */


/*===========================================================================
FUNCTION   rrcllc_send_rlc_register_ul_srvc_req

DESCRIPTION
  This function registers all Uplink logical channels with RLC through
  RLC_DL_REGISTER_SRVC_REQ. All Uplink channels (TM, UM and AM) that
  have been established as indicated by rrcllc_cmd_under_process are
  registered with RLC.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static void  rrcllc_send_rlc_register_ul_srvc_req(void)
{
  l2_ul_cmd_type  *rlc_srvc_ptr;
  wcdma_l2_ul_cmd_type  *rlc_sdu_confirm_callbck_ptr;
  uint8  i;
  uint8  new_lchan_count;
  uint8  ul_am_entity_added_count;
  boolean  ul_am_entity_added = FALSE;
  boolean  rlc_ul_register_needed = FALSE;

  /* First of all, determine the need to send an Uplink Registration Request
   * to RLC. A registration request is sent only if at least one of the UL
   * TM/UM/AM channels to be established is a non-DTCH logical channel type.
   */
  for(i=0, new_lchan_count=0;
      i<rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.nchan;
      i++)
  {
    if((rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.
        ul_tm_act[i].action == RLC_ESTABLISH) &&
       (rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.
        chan_info[i].lc_type != UE_LOGCHAN_DTCH))
    {
      rlc_ul_register_needed = TRUE;
      break;
    }
  }

  for(i=0, new_lchan_count=0;
      i<rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.nchan;
      i++)
  {
    if((rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.
        ul_um_act[i].action == RLC_ESTABLISH) &&
       (rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.
        chan_info[i].lc_type != UE_LOGCHAN_DTCH))
    {
      rlc_ul_register_needed = TRUE;
      break;
    }
  }

  for(i=0, new_lchan_count=0;
      i<rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.nentity;
      i++)
  {
    if((rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.
        am_act[i].action == RLC_ESTABLISH) &&
       (rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.
        am_info[i]->common_config.lc_type != UE_LOGCHAN_DTCH))
    {
      rlc_ul_register_needed = TRUE;
      break;
    }
  }

  /* First check if there are any Uplink channels to be registered */
  if(rlc_ul_register_needed)
  {
    /* Since there are some uplink channels to be registered, allocate
     * buffer and send command
     */
    rlc_srvc_ptr = l2_ul_get_cmd_buf();
    /* Fill in the Command Header */
    rlc_srvc_ptr->cmd_hdr.cmd_id = RLC_UL_REGISTER_SRVC_REQ;
    rlc_srvc_ptr->cmd_data.ul_reg.nchan = 0;

      /* Start with UL TM channels */
    for(i=0, new_lchan_count=0;
        i<rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.nchan;
        i++)
    {
      if((rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.
          ul_tm_act[i].action == RLC_ESTABLISH) &&
         (rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.
          chan_info[i].lc_type != UE_LOGCHAN_DTCH))
      {
        /* Get logical channel ID from Ordered Config */
        rlc_srvc_ptr->cmd_data.ul_reg.
        rlc_data[rlc_srvc_ptr->cmd_data.ul_reg.nchan + new_lchan_count].lc_id =
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.chan_info[i].lc_id;

        /* Get WM pointer from LCM */
        rlc_srvc_ptr->cmd_data.ul_reg.
        rlc_data[rlc_srvc_ptr->cmd_data.ul_reg.nchan + new_lchan_count].ul_wm_ptr =
          rrclcm_get_ul_watermark_ptr(rrcllc_cmd_under_process.chan_config.
                                      rlc_config_req_list.ul_tm.chan_info[i].lc_id);
        new_lchan_count ++;
      }
    }
    rlc_srvc_ptr->cmd_data.ul_reg.nchan += new_lchan_count;

      /* Add UL UM channels */

      for(i=0, new_lchan_count=0;
          i<rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.nchan;
          i++)
      {
        if((rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.
            ul_um_act[i].action == RLC_ESTABLISH) &&
           (rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.
            chan_info[i].lc_type != UE_LOGCHAN_DTCH))
        {
          /* Get logical channel ID from Ordered Config */
          rlc_srvc_ptr->cmd_data.ul_reg.
          rlc_data[rlc_srvc_ptr->cmd_data.ul_reg.nchan + new_lchan_count].lc_id =
            rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.chan_info[i].lc_id;

          /* Get WM pointer from LCM */
          rlc_srvc_ptr->cmd_data.ul_reg.
          rlc_data[rlc_srvc_ptr->cmd_data.ul_reg.nchan + new_lchan_count].ul_wm_ptr =
            rrclcm_get_ul_watermark_ptr(rrcllc_cmd_under_process.chan_config.
                                        rlc_config_req_list.ul_um.chan_info[i].lc_id);
          new_lchan_count ++;
        }
      }
      rlc_srvc_ptr->cmd_data.ul_reg.nchan += new_lchan_count;

      /* Add UL AM channels */
      for(i=0, new_lchan_count=0;
          i<rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.nentity;
          i++)
      {
        if((rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.
            am_act[i].action == RLC_ESTABLISH) &&
           (rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.
            am_info[i]->common_config.lc_type != UE_LOGCHAN_DTCH))
        {
          ul_am_entity_added = TRUE;
          /* Get logical channel ID from Ordered Config */
          rlc_srvc_ptr->cmd_data.ul_reg.
          rlc_data[rlc_srvc_ptr->cmd_data.ul_reg.nchan + new_lchan_count].lc_id =
            rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.
            am_info[i]->common_config.ul_data_id;

          /* Get WM pointer from LCM */
          rlc_srvc_ptr->cmd_data.ul_reg.
          rlc_data[rlc_srvc_ptr->cmd_data.ul_reg.nchan + new_lchan_count].ul_wm_ptr =
            rrclcm_get_ul_watermark_ptr(rrcllc_cmd_under_process.chan_config.
                                        rlc_config_req_list.am.
                                        am_info[i]->common_config.ul_data_id);

          new_lchan_count ++;
          /* If there are 2 logical channels (control + data), add for both */
          if((rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_info[i]->common_config.ul_data_id !=
              rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_info[i]->common_config.ul_control_id) &&
             (rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_info[i]->ul_nchan == 2))
          {
            if((rlc_srvc_ptr->cmd_data.ul_reg.nchan + new_lchan_count) < UE_MAX_UL_LOGICAL_CHANNEL )
            {
            
              /* Get logical channel ID from Ordered Config */
              rlc_srvc_ptr->cmd_data.ul_reg.
              rlc_data[rlc_srvc_ptr->cmd_data.ul_reg.nchan + new_lchan_count].lc_id =
                rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_info[i]->common_config.ul_control_id;
  
              /* Get WM pointer from LCM */
              rlc_srvc_ptr->cmd_data.ul_reg.
              rlc_data[rlc_srvc_ptr->cmd_data.ul_reg.nchan + new_lchan_count].ul_wm_ptr =
                rrclcm_get_ul_watermark_ptr(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.
                                            am_info[i]->common_config.ul_control_id);
            }
            else
            {
              WRRC_MSG1_ERROR("Cant register for idx %d buffer overflow",rlc_srvc_ptr->cmd_data.ul_reg.nchan + new_lchan_count);
            }
            new_lchan_count ++;
          }
        } /* If action == RLC_ESTABLISH */
      } /* for (...) */
      rlc_srvc_ptr->cmd_data.ul_reg.nchan += new_lchan_count;

      WRRC_MSG0_HIGH("Dispatching out L2 cmd RLC_UL_REGISTER_SRVC_REQ / Sending RLC_UL_REGISTER_SRVC_REQ");
      l2_ul_put_cmd(rlc_srvc_ptr);

      /* Now send a RLC_REGISTER_AM_SDU_CONFIRM_CALLBACK_REQ to L2_UL if any AM
       * entity has been added.
       */
      if(ul_am_entity_added)
      {
          rlc_sdu_confirm_callbck_ptr = wcdma_l2_ul_get_cmd_buf();
          rlc_sdu_confirm_callbck_ptr->cmd_hdr.cmd_id =
            RLC_REGISTER_AM_SDU_CONFIRM_CALLBACK_REQ;

          for(i=0, ul_am_entity_added_count=0;
              i<rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.nentity;
              i++)
          {
            if(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_act[i].action == RLC_ESTABLISH)
            {
              rlc_sdu_confirm_callbck_ptr->cmd_data.ul_sdu_cnf_cb.
                sdu_cnf_cb[ul_am_entity_added_count].lc_id =
                  rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_info[i]->
                  common_config.ul_data_id;

              rlc_sdu_confirm_callbck_ptr->cmd_data.ul_sdu_cnf_cb.
               sdu_cnf_cb[ul_am_entity_added_count].rlc_am_sdu_cnf_cb =
                  rrclcm_post_event_for_dl_l2ack_ind;

              ul_am_entity_added_count++;

            } /* If this is an Establish */
          } /* for (all AM entities ) */

          rlc_sdu_confirm_callbck_ptr->cmd_data.ul_sdu_cnf_cb.nchan = ul_am_entity_added_count;

          WRRC_MSG0_HIGH("Dispatching out L2 cmd RLC_REG_AM_SDU_CNF_CALLBACK_REQ / Sending RLC_REG_AM_SDU_CNF_CALLBACK_REQ");
          rrc_send_l2_ul_cmd(rlc_sdu_confirm_callbck_ptr);

      }  /* ul_am_entity_added */
  } /* if(rlc_ul_register_needed) */
} /* rrcllc_send_rlc_register_ul_srvc_req */


/*===========================================================================
FUNCTION   rrcllc_send_rlc_register_dl_srvc_req

DESCRIPTION
  This function registers all Downlink logical channels with RLC through
  RLC_DL_REGISTER_SRVC_REQ. All Downlink channels (TM, UM and AM) that
  have been established as indicated by rrcllc_cmd_under_process are
  registered with RLC.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static void  rrcllc_send_rlc_register_dl_srvc_req(void)
{
  l2_dl_cmd_type  *rlc_srvc_ptr;
  uint8  i;
  uint8  new_lchan_count;
  boolean  rlc_dl_register_needed = FALSE;

  /* First of all, determine the need to send an Uplink Registration Request
   * to RLC. A registration request is sent only if at least one of the UL
   * TM/UM/AM channels to be established is a non-DTCH/CTCH logical channel type.
   */
  for(i=0, new_lchan_count=0;
      i<rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.nchan;
      i++)
  {
    if((rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.
        dl_tm_act[i].action == RLC_ESTABLISH) &&
       (rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.
        chan_info[i].lc_type != UE_LOGCHAN_DTCH))
    {
      rlc_dl_register_needed = TRUE;
      break;
    }
  }

  for(i=0, new_lchan_count=0;
      i<rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.nchan;
      i++)
  {
    if((rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.
        dl_um_act[i].action == RLC_ESTABLISH) &&
       ((rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.
        chan_info[i].lc_type != UE_LOGCHAN_DTCH) &&
        (rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.
        chan_info[i].lc_type != UE_LOGCHAN_CTCH) 
        ))
    {
      rlc_dl_register_needed = TRUE;
      break;
    }
  }

  for(i=0, new_lchan_count=0;
      i<rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.nentity;
      i++)
  {
    if((rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.
        am_act[i].action == RLC_ESTABLISH) &&
       (rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.
        am_info[i]->common_config.lc_type != UE_LOGCHAN_DTCH))
    {
      rlc_dl_register_needed = TRUE;
      break;
    }
  }

  /* First check if there are any Downlink channels to be registered */
  if(rlc_dl_register_needed)
  {
    /* Since there are some downlink channels to be registered, allocate a
     * command buffer and send command.
     */
      rlc_srvc_ptr = l2_dl_get_cmd_buf();
      /* Fill in the Command Header */
      rlc_srvc_ptr->cmd_hdr.cmd_id = RLC_DL_REGISTER_SRVC_REQ;
      rlc_srvc_ptr->cmd_data.dl_reg.nchan = 0;

      /* Start with DL TM channels */
      for(i=0, new_lchan_count=0;
          i<rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.nchan;
          i++)
      {
        if((rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.
            dl_tm_act[i].action == RLC_ESTABLISH) &&
           (rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.
            chan_info[i].lc_type != UE_LOGCHAN_DTCH))
        {
          /* Get logical channel ID from Ordered Config */
          rlc_srvc_ptr->cmd_data.dl_reg.
          rlc_data[rlc_srvc_ptr->cmd_data.dl_reg.nchan + new_lchan_count].lc_id =
            rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[i].lc_id;

          /* Get WM pointer from LCM */
          rlc_srvc_ptr->cmd_data.dl_reg.
          rlc_data[rlc_srvc_ptr->cmd_data.dl_reg.nchan + new_lchan_count].dl_wm_ptr =
            rrclcm_get_dl_watermark_ptr(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.
                                        dl_tm.chan_info[i].lc_id);

          rlc_srvc_ptr->cmd_data.dl_reg.
          rlc_data[rlc_srvc_ptr->cmd_data.dl_reg.nchan + new_lchan_count].context = FALSE;

          /* Send the function pointer that handles DL SDU */
          rlc_srvc_ptr->cmd_data.dl_reg.
          rlc_data[rlc_srvc_ptr->cmd_data.dl_reg.nchan + new_lchan_count].
          rlc_post_rx_proc_func_ptr =
            rrclcm_post_event_for_dl_sdu;

          new_lchan_count ++;
        }
      }
      rlc_srvc_ptr->cmd_data.dl_reg.nchan += new_lchan_count;

      /* Add DL UM channels */
      for(i=0, new_lchan_count=0;
          i<rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.nchan;
          i++)
      {
        if((rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.
            dl_um_act[i].action == RLC_ESTABLISH) &&
           ((rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.
            chan_info[i].lc_type != UE_LOGCHAN_DTCH) &&
          (rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.
           chan_info[i].lc_type != UE_LOGCHAN_CTCH)
            ))
        {
          /* Get logical channel ID from Ordered Config */
          rlc_srvc_ptr->cmd_data.dl_reg.
          rlc_data[rlc_srvc_ptr->cmd_data.dl_reg.nchan + new_lchan_count].lc_id =
            rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[i].lc_id;

          /* Get WM pointer from LCM */
          rlc_srvc_ptr->cmd_data.dl_reg.
          rlc_data[rlc_srvc_ptr->cmd_data.dl_reg.nchan + new_lchan_count].dl_wm_ptr =
            rrclcm_get_dl_watermark_ptr(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[i].lc_id);

          rlc_srvc_ptr->cmd_data.dl_reg.
          rlc_data[rlc_srvc_ptr->cmd_data.dl_reg.nchan + new_lchan_count].context = FALSE;

          /* Send the function pointer that handles DL SDU */
          rlc_srvc_ptr->cmd_data.dl_reg.
          rlc_data[rlc_srvc_ptr->cmd_data.dl_reg.nchan + new_lchan_count].
          rlc_post_rx_proc_func_ptr =
            rrclcm_post_event_for_dl_sdu;

          new_lchan_count ++;
        }
      }
      rlc_srvc_ptr->cmd_data.dl_reg.nchan += new_lchan_count;

      /* Add Downlink AM channels */
      for(i=0, new_lchan_count=0;
          i<rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.nentity;
          i++)
      {
        if((rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.
            am_act[i].action == RLC_ESTABLISH) &&
           (rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.
            am_info[i]->common_config.lc_type != UE_LOGCHAN_DTCH))
        {
          /* Get logical channel ID from Ordered Config */
          rlc_srvc_ptr->cmd_data.dl_reg.
          rlc_data[rlc_srvc_ptr->cmd_data.dl_reg.nchan + new_lchan_count].lc_id =
            rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.
            am_info[i]->common_config.dl_data_id;

          /* Get WM pointer from LCM */
          rlc_srvc_ptr->cmd_data.dl_reg.
          rlc_data[rlc_srvc_ptr->cmd_data.dl_reg.nchan + new_lchan_count].dl_wm_ptr =
            rrclcm_get_dl_watermark_ptr(rrcllc_cmd_under_process.chan_config.
                                        rlc_config_req_list.am.
                                        am_info[i]->common_config.dl_data_id);

          rlc_srvc_ptr->cmd_data.dl_reg.
          rlc_data[rlc_srvc_ptr->cmd_data.dl_reg.nchan + new_lchan_count].context = FALSE;

          /* Send the function pointer that handles DL SDU */
          rlc_srvc_ptr->cmd_data.dl_reg.
          rlc_data[rlc_srvc_ptr->cmd_data.dl_reg.nchan + new_lchan_count].
          rlc_post_rx_proc_func_ptr =
            rrclcm_post_event_for_dl_sdu;

          new_lchan_count ++;

          /* If there are 2 logical channels (control + data), add for both */
          if((rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_info[i]->common_config.dl_data_id !=
              rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_info[i]->common_config.dl_control_id) &&
             (rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_info[i]->dl_nchan == 2))
          {
            if((rlc_srvc_ptr->cmd_data.dl_reg.nchan + new_lchan_count) < UE_MAX_DL_LOGICAL_CHANNEL )
            {
              /* Get logical channel ID from Ordered Config */
              rlc_srvc_ptr->cmd_data.dl_reg.
              rlc_data[rlc_srvc_ptr->cmd_data.dl_reg.nchan + new_lchan_count].lc_id =
                rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_info[i]->common_config.dl_control_id;
  
              /* Get WM pointer from LCM */
              rlc_srvc_ptr->cmd_data.dl_reg.
              rlc_data[rlc_srvc_ptr->cmd_data.dl_reg.nchan + new_lchan_count].dl_wm_ptr =
                rrclcm_get_dl_watermark_ptr(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.
                                            am_info[i]->common_config.dl_control_id);
            }
            else
            {
              WRRC_MSG1_ERROR("Cant register for idx %d buffer overflow",rlc_srvc_ptr->cmd_data.dl_reg.nchan + new_lchan_count);
            }
                
            new_lchan_count ++;
          }
        } /* If action == RLC_ESTABLISH */
      } /* for (...) */
      rlc_srvc_ptr->cmd_data.dl_reg.nchan += new_lchan_count;

	  WRRC_MSG0_HIGH("Dispatching out L2 cmd RLC_DL_REGISTER_SRVC_REQ / Sending RLC_DL_REGISTER_SRVC_REQ");

      l2_dl_put_cmd(rlc_srvc_ptr);
  } /* if(rlc_dl_register_needed) */
} /* rrcllc_send_rlc_register_dl_srvc_req */


/*====================================================================
FUNCTION: rrcllc_cphy_idle_req()

DESCRIPTION:
  This function constructs the CPHY_IDLE_REQ primitive and sends it
  to layer 1.

DEPENDENCIES:
  None

RETURN VALUE:
  uecomdef_status_e_type -> indicating a SUCCESS or FAILURE

SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_cphy_idle_req (void)
{
  /* Used when sending CPHY_IDLE_REQ */
  l1_ext_cmd_type *l1_cmd_ptr;

  /* Always check with CSP if Saving of Measurements is needed
   * before sending a CPHY_IDLE_REQ. If saving of measurements
   * needed, call the measurements function to ensure L1 does
   * not initialize measurement data on CPHY_IDLE_REQ.
   */
  if(rrccsp_init_measurements_in_l1_on_cphy_idle() == FALSE)
  {
        /* Save IntraFreq Meas Criteria */
        rrcmeas_save_intra_inter_freq_meas();
  }


  if ((rrccsp_get_curr_scan() == RRC_CSP_LEAVING_CONN_MODE_SCAN) ||
      ((rrcllc_cmd_under_process.valid)&&
      (rrcllc_cmd_under_process.rrc_current_cmd_id == RRC_CHANNEL_CONFIG_REQ) &&
      (rrcllc_cmd_under_process.chan_config.current_cmd_engine == LLC_RELEASE_ALL_CHAN_ENGINE))
     )
  {
    /* tell WL1 to not use saved DCH Meas info for inter-freq */
    srchmeas_set_inter_freq_measdb_status_during_state_transition(FALSE);
    rrcllc_initialize_cm_parms();
  }

  l1_cmd_ptr = l1_get_cmd_buf();

  /* Fill in the Command Header */
  l1_cmd_ptr->cmd_hdr.cmd_id = CPHY_IDLE_REQ;
  l1_cmd_ptr->cmd_hdr.act_time_type = L1_ACTIVATION_TIME_NONE;
  l1_cmd_ptr->cmd_hdr.act_time      = 0;

  /* Now send the primitive to L1 */
  rrc_send_l1_cmd(l1_cmd_ptr);

#ifdef FEATURE_RRC_CAPTURE_L1_DEADLOCK
  /* Start timer for L1 deadlock detection */
  rrctmr_start_timer( RRCTMR_L1_DEADLOCK_DETECT_TIMER,
                      RRCTMR_L1_DEADLOCK_DETECT_TIMER_IN_MS );
#endif
} /* end rrcllc_cphy_idle_req() */



/*====================================================================
FUNCTION: rrcllc_cphy_deactivate_req()

DESCRIPTION:
  This function constructs the CPHY_DEACTIVATE_REQ primitive and sends it
  to layer 1.

DEPENDENCIES:
  None

RETURN VALUE:
  uecomdef_status_e_type -> indicating a SUCCESS or FAILURE

SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_cphy_deactivate_req (void)
{
  /* Used when sending CPHY_IDLE_REQ */
  l1_ext_cmd_type *l1_cmd_ptr;

  l1_cmd_ptr = l1_get_cmd_buf();

  /* Fill in the Command Header */
  l1_cmd_ptr->cmd_hdr.cmd_id = CPHY_DEACTIVATE_REQ;
  /* Fill in the reason for deactivation */
  l1_cmd_ptr->cmd.deact.deact_reason = rrcllc_cmd_under_process.wcdma_deact_reason;

  l1_cmd_ptr->cmd_hdr.act_time_type = L1_ACTIVATION_TIME_NONE;
  l1_cmd_ptr->cmd_hdr.act_time      = 0;

  /* Now send the primitive to L1 */
  rrc_send_l1_cmd(l1_cmd_ptr);

} /* end rrcllc_cphy_deactivate_req() */

/*====================================================================
FUNCTION: rrcllc_funnel_l1_req()

DESCRIPTION:
  This function takes the CPHY_L1_REQ command from the RRC Internal
  Procedures and sends it to L1.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_funnel_l1_req
(
  rrc_cmd_type          *cmd_ptr
)
{
  /* local cmd var to send to L1 */
  l1_ext_cmd_type  *req_cmd_ptr;

  req_cmd_ptr = l1_get_cmd_buf();

  /* Copy the Command Header */
  WCDMA_MEMCPY(&req_cmd_ptr->cmd_hdr,
               sizeof(l1_cmd_hdr_type),
               &cmd_ptr->cmd.rrc_llc_req.l1_cmd,
               sizeof(l1_cmd_hdr_type));
  
#ifdef FEATURE_DUAL_SIM
  req_cmd_ptr->cmd_hdr.sys_modem_as_id = rrc_get_as_id();
#endif
  if(cmd_ptr->cmd.rrc_llc_req.l1_req == NULL )
  {
    WRRC_MSG1_ERROR(" l1_req is NULL for cmd id 0x%x",req_cmd_ptr->cmd_hdr.cmd_id);
  }
  else
  {
    /* Copy the Command Payload */
    WCDMA_MEMCPY(&req_cmd_ptr->cmd,
                 sizeof(l1_cmd_union_type),
                 cmd_ptr->cmd.rrc_llc_req.l1_req,
                 sizeof(l1_req_cmd));
  }

  /* Send the cmd - L1 should directly handle it */
  rrc_send_l1_cmd( req_cmd_ptr );

} /* rrcllc_funnel_l1_req() */



/*====================================================================
FUNCTION: rrcllc_funnel_l2_dl_req()

DESCRIPTION: This function takes the MAC and RLC downlink REQ command
  from the RRC Internal Procedures and sends it to L2.


DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_funnel_l2_dl_req
(
  rrc_cmd_type          *cmd_ptr
)
{
  /* local cmd var to send to L2 */
  wcdma_l2_dl_cmd_type  *req_cmd_ptr;

  req_cmd_ptr = wcdma_l2_dl_get_cmd_buf();

  /* Copy the Command Header */
  WCDMA_MEMCPY(&req_cmd_ptr->cmd_hdr,
               sizeof(wcdma_l2_dl_cmd_hdr_type),
               &cmd_ptr->cmd.rrc_llc_req.l2_dl_cmd,
               sizeof(l2_dl_cmd_hdr_type));
  if(cmd_ptr->cmd.rrc_llc_req.l2_dl_req == NULL )
  {
    WRRC_MSG1_ERROR(" l2_dl_req is NULL for cmd id 0x%x",req_cmd_ptr->cmd_hdr.cmd_id);
  }
  else
  {
    /* Copy the Command Payload */
    WCDMA_MEMCPY(&req_cmd_ptr->cmd_data,
                 sizeof(wcdma_l2_dl_cmd_data_type),
                 cmd_ptr->cmd.rrc_llc_req.l2_dl_req, 
                 sizeof(l2_dl_req_cmd));
  }
  /* Send the cmd - L2 should directly handle it */
  WRRC_MSG2_HIGH("Dispatching out wcdma_l2_dl_cmd_enum_type_value%d / Sending L2 DL cmd 0x%x", req_cmd_ptr->cmd_hdr.cmd_id, req_cmd_ptr->cmd_hdr.cmd_id);

  rrc_send_l2_dl_cmd( req_cmd_ptr );

  return;

} /* rrcllc_funnel_l2_dl_req() */


/*====================================================================
FUNCTION: rrcllc_funnel_l2_ul_req()

DESCRIPTION:This function takes the MAC and RLC uplink REQ command
  from the RRC Internal Procedures and sends it to L2.


DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_funnel_l2_ul_req
(
  rrc_cmd_type          *cmd_ptr
)
{
  /* local cmd var to send to L2 */
  wcdma_l2_ul_cmd_type  *req_cmd_ptr;

  req_cmd_ptr = wcdma_l2_ul_get_cmd_buf();

  /* Copy the Command Header */
  WCDMA_MEMCPY(&req_cmd_ptr->cmd_hdr,
               sizeof(wcdma_l2_ul_cmd_hdr_type),
               &cmd_ptr->cmd.rrc_llc_req.l2_ul_cmd,
               sizeof(l2_ul_cmd_hdr_type));
  if(cmd_ptr->cmd.rrc_llc_req.l2_ul_req == NULL )
  {
    WRRC_MSG1_ERROR(" l2_ul_req is NULL for cmd id 0x%x",req_cmd_ptr->cmd_hdr.cmd_id);
  }
  else
  {
    /* Copy the Command Payload */
    WCDMA_MEMCPY(&req_cmd_ptr->cmd_data,
                 sizeof(wcdma_l2_ul_cmd_data_type),
                 cmd_ptr->cmd.rrc_llc_req.l2_ul_req,
                 sizeof(l2_ul_req_cmd));
  }

  /* Send the cmd - L2 should directly handle it */
  WRRC_MSG2_HIGH("Dispatching out wcdma_l2_ul_cmd_enum_type_value%d / Sending L2 UL cmd 0x%x ", req_cmd_ptr->cmd_hdr.cmd_id,req_cmd_ptr->cmd_hdr.cmd_id);
  rrc_send_l2_ul_cmd( req_cmd_ptr );

  return;

} /* rrcllc_funnel_l2_ul_req() */


/*********************************************************************
**        Command funneling utilities
**
**********************************************************************/

/*====================================================================
FUNCTION: rrcllc_process_funneled_cmd_req()

DESCRIPTION:
  This function takes the Command bound for the lower layer and
  calls the correct function to transform the command from an
  internal RRC structure to an L1, MAC or RLC structure.

DEPENDENCIES:
  None.

RETURN VALUE:
  Next LLC state.

SIDE EFFECTS:
  None.
====================================================================*/
static rrcllc_substate_e_type  rrcllc_process_funneled_cmd_req(rrc_cmd_type *cmd_ptr)
{
  rrcllc_substate_e_type   next_llc_substate = LLC_STATES_MAX;
  boolean                  valid_cmd = TRUE;
  l1_req_cmd * llc_cmd_l1_req =NULL;
  rrc_state_e_type  current_rrc_state = rrc_get_state();

  /*
  * Make sure that this is an LLC command request.
  */
  if( (cmd_ptr->cmd_hdr.cmd_id == RRC_LLC_CMD_REQ) &&
      (cmd_ptr->cmd.rrc_llc_req.cmd_dest == LAYER1_PHY)
    )
  {
    /* Check and see which L1 command was just received from an RRC procedure.*/
    MSG_MED("Recvd L1 cmd %d from RRC Procedure",
            cmd_ptr->cmd.rrc_llc_req.l1_cmd.cmd_id,
            cmd_ptr->cmd.rrc_llc_req.procedure, 0);

    /*lint -save -e787  This switch statement has a default clause and purposefully
                   does not handle each member of the enumerated type it is
                   switched on. */
    switch (cmd_ptr->cmd.rrc_llc_req.l1_cmd.cmd_id)
    {
      /* Cases that require LLC to wait prior to sending another request to L1 */
      case CPHY_CAPABILITY_REQ:
         next_llc_substate = LLC_WAIT_CPHY_CAPABILITY_CNF;
         break;

      case CPHY_ACQ_REQ:
#ifdef FEATURE_RRC_CAPTURE_L1_DEADLOCK
         /* Start timer for L1 deadlock detection */
         rrctmr_start_timer( RRCTMR_L1_DEADLOCK_DETECT_TIMER,
                             RRCTMR_L1_DEADLOCK_DETECT_TIMER_IN_MS );
#endif
         next_llc_substate = LLC_WAIT_CPHY_ACQ_CNF;
         break;

      case CPHY_FREQ_SCAN_REQ:
         next_llc_substate = LLC_WAIT_CPHY_FREQ_SCAN_CNF;
         break;

      case CPHY_CELL_SELECTION_REQ:
#ifdef FEATURE_RRC_CAPTURE_L1_DEADLOCK
         /* Start timer for L1 deadlock detection */
         rrctmr_start_timer( RRCTMR_L1_DEADLOCK_DETECT_TIMER,
                             RRCTMR_L1_DEADLOCK_DETECT_TIMER_IN_MS );
#endif
         next_llc_substate = LLC_WAIT_CPHY_CELL_SELECTION_CNF;
         break;

      case CPHY_CELL_TRANSITION_REQ:
#ifdef FEATURE_RRC_CAPTURE_L1_DEADLOCK
         /* Start timer for L1 deadlock detection */
         rrctmr_start_timer( RRCTMR_L1_DEADLOCK_DETECT_TIMER,
                             RRCTMR_L1_DEADLOCK_DETECT_TIMER_IN_MS );
#endif
         next_llc_substate = LLC_WAIT_CPHY_CELL_TRANSITION_CNF;
         break;

      case CPHY_IMMEDIATE_MEAS_REQ:
         next_llc_substate = LLC_WAIT_CPHY_IMMEDIATE_MEAS_CNF;
         break;

      case CPHY_INTEGRITY_KEY_MAUC_REQ:
         next_llc_substate = LLC_WAIT_CPHY_INTEGRITY_KEY_MAUC_CNF;
         break;

      case CPHY_IMMEDIATE_RESELECTION_REQ:
         next_llc_substate = LLC_WAIT_CPHY_IMMEDIATE_RESELECTION_CNF;
         break;

      case CPHY_DRX_REQ:
         if( (current_rrc_state != RRC_STATE_CELL_PCH) && 
             (current_rrc_state != RRC_STATE_URA_PCH) && 
             (current_rrc_state != RRC_STATE_DISCONNECTED)
           )
         {
           WRRC_MSG1_ERROR("Ignoring CPHY_DRX_REQ, RRC state: %d",current_rrc_state);
           valid_cmd = FALSE;
           next_llc_substate = LLC_IDLE;
         }
         else
         {
#ifdef FEATURE_RRC_CAPTURE_L1_DEADLOCK
           /* Start timer for L1 deadlock detection */
           rrctmr_start_timer( RRCTMR_L1_DEADLOCK_DETECT_TIMER,
                               RRCTMR_L1_DEADLOCK_DETECT_TIMER_IN_MS );
#endif

           next_llc_substate = LLC_WAIT_CPHY_DRX_CNF;
         }
         break;

      case CPHY_SUSPEND_WCDMA_MODE_REQ:
  #ifdef FEATURE_RRC_CAPTURE_L1_DEADLOCK
        /* Start timer for L1 deadlock detection */
        rrctmr_start_timer( RRCTMR_L1_DEADLOCK_DETECT_TIMER,
                            RRCTMR_L1_DEADLOCK_DETECT_TIMER_IN_MS );
  #endif
        if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
        {
          /* Check if HSDPA ia already ACTIVE */
          if (rrc_get_hsdpa_status() == HSDPA_ACTIVE)
          {
            /* Change HSDPA Status to Suspended as it now can be resumed
            as per Sept 04 specs. */
            WRRC_MSG0_HIGH("RRCHS:Set HSDPA Status to SUSPEND");            
            rrc_set_hsdpa_status(HSDPA_SUSPEND);
          }
        }
        next_llc_substate = LLC_WAIT_CPHY_SUSPEND_WCDMA_MODE_CNF;
        break;

      case CPHY_RESUME_WCDMA_MODE_REQ:
        rrcllc_recvd_deact_req_waiting_for_resume_cnf = FALSE;

  #ifdef FEATURE_RRC_CAPTURE_L1_DEADLOCK
        /* Start timer for L1 deadlock detection */
        rrctmr_start_timer( RRCTMR_L1_DEADLOCK_DETECT_TIMER,
                            RRCTMR_L1_DEADLOCK_DETECT_TIMER_IN_MS );
  #endif
        next_llc_substate = LLC_WAIT_CPHY_RESUME_WCDMA_MODE_CNF;
        break;

      /* Cases that DO NOT require LLC to wait prior to sending another request to L1 */
      case CPHY_MEASUREMENT_REQ:
      {
         llc_cmd_l1_req = cmd_ptr->cmd.rrc_llc_req.l1_req;
        if ((llc_cmd_l1_req != NULL ) 
            &&(llc_cmd_l1_req->meas.meas_ptr->parm_type == L1_MEAS_CTRL_PARMS))
        {
          if(llc_cmd_l1_req->meas.meas_ptr->
            u.ctrl.trans_id != L1_NO_CNF_TRANSACTION_ID)
          {
            next_llc_substate = LLC_WAIT_CPHY_MEAS_CTRL_CNF;
            break;
          }
        }
      }
      /*lint -save -e616  We mean to fall through for these cases. */
      case CPHY_CELL_PARM_REQ:
      case CPHY_HARD_HANDOFF_REQ:
      case CPHY_BCH_SCHEDULE_REQ:
      case CPHY_CIPHERING_KEY_REQ:
      case CPHY_INTEGRITY_KEY_REQ:
      case CPHY_CELL_BAR_REQ:
      case CPHY_GO_TO_SLEEP_IND:
#if defined(FEATURE_WCDMA_DRX_MANAGER)
      case CPHY_SIB_SCHED_CHANGE_IND:
#endif		
        /*lint -restore */
        /* Keep the next state as LLC_IDLE since no confirmation is needed from L1 */
         next_llc_substate = LLC_IDLE;
         break;

      /*lint -save -e616  We mean to fall through for these cases */
      case CPHY_SETUP_REQ:
      case CPHY_IDLE_REQ:
      /*lint -restore */
        /* Set valid_cmd to FALSE so as not to send the L1 command */
        valid_cmd = FALSE;
        next_llc_substate = LLC_IDLE;
        WRRC_MSG1_ERROR("This L1 REQ %d is not Allowed from RRC Procedures",
                 cmd_ptr->cmd.rrc_llc_req.l1_cmd.cmd_id);
        break;

      case CPHY_UPD_DL_SYNC_PARMS:
        next_llc_substate = LLC_IDLE;
        break;
      
      case CPHY_ACT_TIME_CANCEL_REQ:
         llc_cmd_l1_req = cmd_ptr->cmd.rrc_llc_req.l1_req;
        if(llc_cmd_l1_req != NULL )
        {
          llc_cmd_l1_req->act_cancel.seq_num = seq_num - 1;
          /* Check if LLC is waiting for CNF from L1 for the first L1 cmd sent.  Else take UE to idle */
          if (rrcllc_cmd_under_process.chan_config.l1_req_list.current_l1_req > 1)
          {
            WRRC_MSG0_HIGH("Some cmds processed by L1 already.  Go to Idle");
            /* If UE is not taken to idle in this case, UE is stuck in fach with no SRBs expect for CCCH */
            rrcllc_self_enqueue_channel_config_to_idle();
            next_llc_substate = LLC_IDLE;
          }
          else
          {
            WRRC_MSG1_HIGH("CPHY_ACT_TIME_CANCEL_REQ for seq num %d",llc_cmd_l1_req->act_cancel.seq_num);
  #ifdef FEATURE_RRC_CAPTURE_L1_DEADLOCK
            /* Start timer for L1 deadlock detection */
            rrctmr_start_timer( RRCTMR_L1_DEADLOCK_DETECT_TIMER,
                                RRCTMR_L1_DEADLOCK_DETECT_TIMER_IN_MS );
  #endif  
            next_llc_substate = LLC_WAIT_CPHY_ACT_TIME_CANCEL_CNF;
          }
        }
        else
        {
            WRRC_MSG0_ERROR("l1_req NULL for CPHY_ACT_TIME_CANCEL_REQ");
        }
        break;
        
      default:
        valid_cmd = FALSE;
        next_llc_substate = LLC_IDLE;
        WRRC_MSG1_ERROR("Invalid L1 funneled cmd %d rcv'd",
                 cmd_ptr->cmd.rrc_llc_req.l1_cmd.cmd_id);
        break;
    } /* end switch (cmd_ptr->cmd.l1_cmd) */
    /*lint -restore */

    if(valid_cmd)
    {
      rrcllc_funnel_l1_req(cmd_ptr);
    }
    else
    {
      WRRC_MSG1_HIGH_OPT("not Dispatching out l1_cmd_enum_type_value0x%x", cmd_ptr->cmd.rrc_llc_req.l1_cmd.cmd_id);
    }
  } /* end L1 req */

  /* Layer 2 MAC or RLC Uplink commands */
  else if((cmd_ptr->cmd_hdr.cmd_id == RRC_LLC_CMD_REQ) &&
          ((cmd_ptr->cmd.rrc_llc_req.cmd_dest == LAYER2_MAC_UL) ||
          (cmd_ptr->cmd.rrc_llc_req.cmd_dest == LAYER2_RLC_UL))
         )
  {
    switch (cmd_ptr->cmd.rrc_llc_req.l2_ul_cmd.cmd_id)
    {
      /* Cases that require LLC to wait prior to sending another request to L2 */
      case CRLC_UL_HFN_REQ:
       next_llc_substate = LLC_WAIT_RLC_UL_HFN_CNF;
       break;

      /* Cases that DO NOT require LLC to wait prior to sending another request to L2 */
      case CMAC_UL_TRAFFIC_VOLUME_CONFIG_REQ:
      case CMAC_UL_BLOCK_RACH_TRAFFIC_REQ:
      case CRLC_UL_CIPHER_CONFIG_REQ:
      case CRLC_UL_RESUME_REQ:
      case CRLC_UL_REG_FOR_DATA_IND_REQ:
      case CRLC_UL_UNREG_FOR_DATA_IND_REQ:
      case RLC_UL_PURGE_WM_REQ:            /*Command to purge the UL WM    */
        next_llc_substate = LLC_IDLE;
        break;

      case CMAC_UL_CONFIG_REQ:
      case CRLC_UL_TM_CONFIG_REQ:
      case CRLC_UL_UM_CONFIG_REQ:
case CRLC_AM_CONFIG_REQ:
        valid_cmd = FALSE;
        next_llc_substate = LLC_IDLE;
        WRRC_MSG1_HIGH("This L2 UL REQ %d is not Allowed from RRC Procedures",
                 cmd_ptr->cmd.rrc_llc_req.l2_ul_cmd.cmd_id);
        break;

      default:
        valid_cmd = FALSE;
        next_llc_substate = LLC_IDLE;
        WRRC_MSG1_HIGH("Invalid L2 UL funneled cmd %d rcv'd",
                 cmd_ptr->cmd.rrc_llc_req.l2_ul_cmd.cmd_id);
        break;

    } /* End L2 UL command switch */

    if(valid_cmd)
    {
      rrcllc_funnel_l2_ul_req(cmd_ptr);
    }
    else
    {
      WRRC_MSG1_HIGH_OPT("not Dispatching out L2 cmd wcdma_l2_ul_cmd_enum_type_value%d", cmd_ptr->cmd.rrc_llc_req.l2_ul_cmd.cmd_id);
    }
  } /* end else L2 UL commands */

  /* Layer 2 MAC or RLC command */
  else if((cmd_ptr->cmd_hdr.cmd_id == RRC_LLC_CMD_REQ) &&
          ((cmd_ptr->cmd.rrc_llc_req.cmd_dest == LAYER2_MAC_DL) ||
          (cmd_ptr->cmd.rrc_llc_req.cmd_dest == LAYER2_RLC_DL))
         )
  {
    switch (cmd_ptr->cmd.rrc_llc_req.l2_dl_cmd.cmd_id)
    {
      /* Cases that require LLC to wait prior to sending another request to L2 */
      case CRLC_DL_HFN_REQ:
        next_llc_substate = LLC_WAIT_RLC_DL_HFN_CNF;
        break;

      /* Cases that DO NOT require LLC to wait prior to sending another request to L2 */
      case CRLC_DL_CIPHER_CONFIG_REQ:
        next_llc_substate = LLC_IDLE;
        break;

      case CMAC_DL_CONFIG_REQ:
      case CRLC_DL_TM_CONFIG_REQ:
      case CRLC_DL_UM_CONFIG_REQ:
        valid_cmd = FALSE;
        next_llc_substate = LLC_IDLE;
        WRRC_MSG1_HIGH("This L2 DL REQ %d is not Allowed from RRC Procedures",
                 cmd_ptr->cmd.rrc_llc_req.l2_dl_cmd.cmd_id);
        break;

      default:
        valid_cmd = FALSE;
        next_llc_substate = LLC_IDLE;
        WRRC_MSG1_HIGH("Invalid L2 DL funneled cmd %d rcv'd",
                 cmd_ptr->cmd.rrc_llc_req.l2_dl_cmd.cmd_id);
        break;

    } /* end L2 DL command switch */

    if(valid_cmd)
    {
      rrcllc_funnel_l2_dl_req(cmd_ptr);
    }
    else
    {
      WRRC_MSG1_HIGH_OPT("not Dispatching out L2 cmd wcdma_l2_dl_cmd_enum_type_value%d", cmd_ptr->cmd.rrc_llc_req.l2_dl_cmd.cmd_id);
    }

  } /* end else L2 DL commands */
  else
  {
    /* Keep in the same state and make compiler happy */
    next_llc_substate = LLC_IDLE;
  }

  return(next_llc_substate);
} /* end rrcllc_process_funneled_cmd_req() */



/*====================================================================
FUNCTION: rrc_funneled_cmd_cnf()

DESCRIPTION:
  This function takes a CNF command from L1 and L2 and sends it
  to the RRC Internal Procedures.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
static void rrc_funneled_cmd_cnf
(
  rrc_cmd_type         *cmd_ptr,
  rrc_proc_e_type       proc_type,
  rrc_cmd_e_type        cnf_type
)
{
  /* local cmd var to send confirm back to RRC procs */
  rrc_cmd_type   *cnf_cmd_ptr;
  boolean        failure_flag = FALSE;

  cnf_cmd_ptr = rrc_get_int_cmd_buf();

  /*
  * Fill in the local command header.
  */
  cnf_cmd_ptr->cmd_hdr.cmd_id = RRC_LLC_CMD_CNF;

  /*
  * Starts with the rrc_llc_cnf command descriptor
  */
  cnf_cmd_ptr->cmd.rrc_llc_cnf.procedure = proc_type;

  /*
  * Now the rrc_llc_cnf command payload
  */
  switch(cnf_type)
  {
    case RRC_CPHY_ACQ_CNF:
      cnf_cmd_ptr->cmd.rrc_llc_cnf.ll_cnf = RRC_LL_CPHY_ACQ_CNF;
      WCDMA_MEMCPY(&cnf_cmd_ptr->cmd.rrc_llc_cnf.cnf,
                   sizeof(l1_acq_cnf_type),
                   &cmd_ptr->cmd,
                   sizeof(l1_acq_cnf_type)
            );
      break;
    case RRC_CPHY_FREQ_SCAN_CNF:
      cnf_cmd_ptr->cmd.rrc_llc_cnf.ll_cnf = RRC_LL_CPHY_FREQ_SCAN_CNF;
      WCDMA_MEMCPY(&cnf_cmd_ptr->cmd.rrc_llc_cnf.cnf,
                   sizeof(l1_freq_scan_cnf_type),
                   &cmd_ptr->cmd, 
                   sizeof(l1_freq_scan_cnf_type));
      break;
    case RRC_CPHY_CELL_SELECTION_CNF:
      cnf_cmd_ptr->cmd.rrc_llc_cnf.ll_cnf = RRC_LL_CPHY_CELL_SELECTION_CNF;
      WCDMA_MEMCPY(&cnf_cmd_ptr->cmd.rrc_llc_cnf.cnf,
                   sizeof(l1_cell_select_cnf_type),
                   &cmd_ptr->cmd,
                   sizeof(l1_cell_select_cnf_type));
      break;
    case RRC_CPHY_CELL_TRANSITION_CNF:
      cnf_cmd_ptr->cmd.rrc_llc_cnf.ll_cnf = RRC_LL_CPHY_CELL_TRANSITION_CNF;
      WCDMA_MEMCPY(&cnf_cmd_ptr->cmd.rrc_llc_cnf.cnf,
                   sizeof(l1_cell_transition_cnf_type),
                   &cmd_ptr->cmd,
                   sizeof(l1_cell_transition_cnf_type));
      break;

    case RRC_CPHY_MEAS_CTRL_CNF:
      cnf_cmd_ptr->cmd.rrc_llc_cnf.ll_cnf = RRC_LL_CPHY_MEAS_CTRL_CNF;
      WCDMA_MEMCPY(&cnf_cmd_ptr->cmd.rrc_llc_cnf.cnf,
                   sizeof(l1_meas_ctrl_cnf_type),
                   &cmd_ptr->cmd, 
                   sizeof(l1_meas_ctrl_cnf_type));
      break;

    case RRC_CPHY_SUSPEND_WCDMA_MODE_CNF:
      cnf_cmd_ptr->cmd.rrc_llc_cnf.ll_cnf = RRC_LL_CPHY_SUSPEND_CNF;
      WCDMA_MEMCPY(&cnf_cmd_ptr->cmd.rrc_llc_cnf.cnf,
                   sizeof(l1_suspend_cnf_type),
                   &cmd_ptr->cmd,
                   sizeof(l1_suspend_cnf_type));
      break;

    case RRC_CPHY_RESUME_WCDMA_MODE_CNF:
      cnf_cmd_ptr->cmd.rrc_llc_cnf.ll_cnf = RRC_LL_CPHY_RESUME_CNF;
      WCDMA_MEMCPY(&cnf_cmd_ptr->cmd.rrc_llc_cnf.cnf,
                   sizeof(l1_resume_cnf_type),
                   &cmd_ptr->cmd,
                   sizeof(l1_resume_cnf_type)
            );
      break;

    case RRC_CPHY_ACT_CANCEL_CNF:
      cnf_cmd_ptr->cmd.rrc_llc_cnf.ll_cnf = RRC_LL_CPHY_ACT_CANC_CNF;
      WCDMA_MEMCPY(&cnf_cmd_ptr->cmd.rrc_llc_cnf.cnf,
                   sizeof(l1_act_time_cancel_cnf_type),
                   &cmd_ptr->cmd,
                   sizeof(l1_act_time_cancel_cnf_type)
            );
      break;

    default:
      WRRC_MSG1_ERROR("Invalid Confirm 0x%x Rcv'd from Lower Layer", cnf_type);
      rrc_free_cmd_buf(cnf_cmd_ptr);
      cnf_cmd_ptr = NULL;
      failure_flag = TRUE;
      break;
  }

  if(failure_flag == FALSE)
  {
    /* Send the internal command */
    rrc_put_int_cmd(cnf_cmd_ptr);
  }
  return;

} /* end rrc_funneled_cmd_cnf() */


/* Functions to support CIPHERING */
/*===========================================================================
FUNCTION   rrcllc_send_crlc_abort_ciph_req

DESCRIPTION
  This function sends CRLC_UL_ABORT_CIPHER_CONFIG_REQ and CRLC_DL_ABORT_CIPHER_CONFIG_REQ
  to abort any on-going UL or DL cipher configuraiton.

DEPENDENCIES
  None.

RETURN VALUE
  None

SIDE EFFECTS
  None.

===========================================================================*/
static void rrcllc_send_crlc_abort_ciph_req(void)
{
  wcdma_l2_ul_cmd_type  *ul_rlc_ptr;
  wcdma_l2_dl_cmd_type  *dl_rlc_ptr;

  /* Get L2 DL command buffer */
  ul_rlc_ptr = wcdma_l2_ul_get_cmd_buf();

  /* Fill in the Command Header */
  ul_rlc_ptr->cmd_hdr.cmd_id = CRLC_UL_ABORT_CIPHER_CONFIG_REQ;

  rrcsmc_fill_crlc_ul_abort_cipher_req(&(ul_rlc_ptr->cmd_data.abort_cipher_info));

  WRRC_MSG0_HIGH("Dispatching out L2 cmd / Sending CRLC_UL_ABORT_CIPHER_CONFIG_REQ");

  /* Send command to L2 UL Task */
  rrc_send_l2_ul_cmd(ul_rlc_ptr);

  /* Get L2 DL command buffer */
  dl_rlc_ptr = wcdma_l2_dl_get_cmd_buf();

  /* Fill in the Command Header */
  dl_rlc_ptr->cmd_hdr.cmd_id = CRLC_DL_ABORT_CIPHER_CONFIG_REQ;

  rrcsmc_fill_crlc_dl_abort_cipher_req(&(dl_rlc_ptr->cmd_data.abort_cipher_info));

  WRRC_MSG0_HIGH("Dispatching out L2 cmd / Sending CRLC_DL_ABORT_CIPHER_CONFIG_REQ");

  /* Send command to L2 DL Task */
  rrc_send_l2_dl_cmd(dl_rlc_ptr);
}


/*===========================================================================
FUNCTION   rrcllc_cphy_ciphering_key_req

DESCRIPTION
  This function sends a CPHY_CIPHERING_KEY_REQ to L1. It gets a L1 command buffer,
  fills it up with the data, pointer to which is passed as a parameter to
  this function. It then sends the command over to L1.

DEPENDENCIES
  None.

RETURN VALUE
  SUCCESS or FAILURE

SIDE EFFECTS
  None.
===========================================================================*/
uecomdef_status_e_type
rrcllc_cphy_ciphering_key_req(void)
{
  l1_ext_cmd_type   *l1_cmd_ptr;
  uint8 i=0;

  l1_cmd_ptr = l1_get_cmd_buf();

  /* Fill in the Command Header, and indicate to do it Now! */
  l1_cmd_ptr->cmd_hdr.cmd_id = CPHY_CIPHERING_KEY_REQ;

  /* Copy the command contents */
  l1_cmd_ptr->cmd.cipher_key.cipher_key_req.req_mask =
    cipher_config_db.l1_cipher_info.cipher_key_req.req_mask;

  l1_cmd_ptr->cmd.cipher_key.cipher_key_req.ul_cipher_info.num_keys =
  cipher_config_db.l1_cipher_info.cipher_key_req.ul_cipher_info.num_keys;

  /*ul key info for l1*/
  for(i=0; i<l1_cmd_ptr->cmd.cipher_key.cipher_key_req.ul_cipher_info.num_keys; i++)
  {

    l1_cmd_ptr->cmd.cipher_key.cipher_key_req.ul_cipher_info.key_info[i].key_id = i;
    l1_cmd_ptr->cmd.cipher_key.cipher_key_req.ul_cipher_info.key_info[i].algorithm =
      cipher_config_db.l1_cipher_info.cipher_key_req.ul_cipher_info.key_info[i].algorithm;

    WCDMA_MEMCPY(l1_cmd_ptr->cmd.cipher_key.cipher_key_req.ul_cipher_info.key_info[i].key_val,
                 sizeof(uint8) * L1_NUM_BYTES_CIPHER_KEY,
                 cipher_config_db.l1_cipher_info.cipher_key_req.ul_cipher_info.key_info[i].key_val,
                 16);
  }

  /*dl key info for l1*/
  l1_cmd_ptr->cmd.cipher_key.cipher_key_req.dl_cipher_info.num_keys =
  cipher_config_db.l1_cipher_info.cipher_key_req.dl_cipher_info.num_keys;

  for(i=0; i<l1_cmd_ptr->cmd.cipher_key.cipher_key_req.dl_cipher_info.num_keys; i++)
  {

    l1_cmd_ptr->cmd.cipher_key.cipher_key_req.dl_cipher_info.key_info[i].key_id = i;
    l1_cmd_ptr->cmd.cipher_key.cipher_key_req.dl_cipher_info.key_info[i].algorithm =
      cipher_config_db.l1_cipher_info.cipher_key_req.dl_cipher_info.key_info[i].algorithm;
    WCDMA_MEMCPY(l1_cmd_ptr->cmd.cipher_key.cipher_key_req.dl_cipher_info.key_info[i].key_val,
                 sizeof(uint8) * L1_NUM_BYTES_CIPHER_KEY,
                 cipher_config_db.l1_cipher_info.cipher_key_req.dl_cipher_info.key_info[i].key_val,
                 16);
  }

WRRC_MSG0_HIGH("Dispatching out PHY cmd / Sending CPHY_CIPHERING_KEY_REQ to L1");
  /* Now send the primitive to L1 */
  rrc_send_l1_cmd(l1_cmd_ptr);

  return(SUCCESS);
} /* rrcllc_cphy_ciphering_key_req */


/*====================================================================
FUNCTION: rrcllc_crlc_ul_cipher_config_req()

DESCRIPTION:
  This function constructs the CRLC_UL_CIPHER_CONFIG_REQ primitive and
  sends it to layer 2 Uplink task.

DEPENDENCIES:
  None

RETURN VALUE:
  uecomdef_status_e_type -> indicating a SUCCESS or FAILURE

SIDE EFFECTS:
  None.
====================================================================*/
static uecomdef_status_e_type rrcllc_crlc_ul_cipher_config_req(void)
{

  wcdma_l2_ul_cmd_type  *rlc_ptr;
  uint32 i=0;

  /* Get L2 DL command buffer */
  rlc_ptr = wcdma_l2_ul_get_cmd_buf();

  /* Fill in the Command Header */
  rlc_ptr->cmd_hdr.cmd_id = CRLC_UL_CIPHER_CONFIG_REQ;

  /* Fill in the data */
  rlc_ptr->cmd_data.ul_cipher_config.nchan =
    cipher_config_db.rlc_ul_cipher_info.nchan;

  for(i=0; i<cipher_config_db.rlc_ul_cipher_info.nchan; i++)
  {
    rlc_ptr->cmd_data.ul_cipher_config.ciphering[i].ciph_act_sn =
      cipher_config_db.rlc_ul_cipher_info.ciphering[i].ciph_act_sn;

    rlc_ptr->cmd_data.ul_cipher_config.ciphering[i].cipher_key_id =
      cipher_config_db.rlc_ul_cipher_info.ciphering[i].cipher_key_id;

    rlc_ptr->cmd_data.ul_cipher_config.ciphering[i].cipher_mode =
      cipher_config_db.rlc_ul_cipher_info.ciphering[i].cipher_mode;

    rlc_ptr->cmd_data.ul_cipher_config.ciphering[i].hfn =
      cipher_config_db.rlc_ul_cipher_info.ciphering[i].hfn;

    rlc_ptr->cmd_data.ul_cipher_config.ciphering[i].lc_id =
      cipher_config_db.rlc_ul_cipher_info.ciphering[i].lc_id;

    rlc_ptr->cmd_data.ul_cipher_config.ciphering[i].rb_id =
      cipher_config_db.rlc_ul_cipher_info.ciphering[i].rb_id;

    rlc_ptr->cmd_data.ul_cipher_config.ciphering[i].ciph_algo =
      cipher_config_db.rlc_ul_cipher_info.ciphering[i].ciph_algo;
    WRRC_MSG3_MED("DEBUG UL: rbId:%d cipher_mode:%d Cipher Algo:%d[0=Invalid,1=UEA0,2=UEA1,4=UEA2]", 
      rlc_ptr->cmd_data.ul_cipher_config.ciphering[i].rb_id,
      rlc_ptr->cmd_data.ul_cipher_config.ciphering[i].cipher_mode, 
      rlc_ptr->cmd_data.ul_cipher_config.ciphering[i].ciph_algo);
  }

  WRRC_MSG0_HIGH("Dispatching out L2 cmd / Sending CRLC_UL_CIPHER_CONFIG_REQ");

  /* Send command to L2 UL Task */
  rrc_send_l2_ul_cmd(rlc_ptr);

  return SUCCESS;
} /* rrcllc_crlc_ul_cipher_config_req() */


/*====================================================================
FUNCTION: rrcllc_crlc_dl_cipher_config_req()

DESCRIPTION:
  This function constructs the CRLC_DL_CIPHER_CONFIG_REQ primitive and
  sends it to layer 2 Downlink task.

DEPENDENCIES:
  None

RETURN VALUE:
  uecomdef_status_e_type -> indicating a SUCCESS or FAILURE

SIDE EFFECTS:
  None.
====================================================================*/
static uecomdef_status_e_type rrcllc_crlc_dl_cipher_config_req(void)
{

  wcdma_l2_dl_cmd_type  *rlc_ptr;
  uint32 i=0;

  /* Get L2 DL command buffer */
  rlc_ptr = wcdma_l2_dl_get_cmd_buf();

  /* Fill in the Command Header */
  rlc_ptr->cmd_hdr.cmd_id = CRLC_DL_CIPHER_CONFIG_REQ;

  /* Fill in the data */
  rlc_ptr->cmd_data.dl_cipher_config.nchan =
    cipher_config_db.rlc_dl_cipher_info.nchan;

  for(i=0; i<cipher_config_db.rlc_dl_cipher_info.nchan; i++)
  {
    rlc_ptr->cmd_data.dl_cipher_config.ciphering[i].ciph_act_sn =
      cipher_config_db.rlc_dl_cipher_info.ciphering[i].ciph_act_sn;

    rlc_ptr->cmd_data.dl_cipher_config.ciphering[i].cipher_key_id =
      cipher_config_db.rlc_dl_cipher_info.ciphering[i].cipher_key_id;

    rlc_ptr->cmd_data.dl_cipher_config.ciphering[i].cipher_mode =
      cipher_config_db.rlc_dl_cipher_info.ciphering[i].cipher_mode;

    rlc_ptr->cmd_data.dl_cipher_config.ciphering[i].hfn =
      cipher_config_db.rlc_dl_cipher_info.ciphering[i].hfn;

    rlc_ptr->cmd_data.dl_cipher_config.ciphering[i].lc_id =
      cipher_config_db.rlc_dl_cipher_info.ciphering[i].lc_id;

    rlc_ptr->cmd_data.dl_cipher_config.ciphering[i].rb_id =
      cipher_config_db.rlc_dl_cipher_info.ciphering[i].rb_id;

    rlc_ptr->cmd_data.dl_cipher_config.ciphering[i].ciph_algo =
      cipher_config_db.rlc_dl_cipher_info.ciphering[i].ciph_algo;
    WRRC_MSG3_MED("RRCEUL: DEBUG: DL: rbId: %d. cipher_mode: %d, cipher_algo: UEA%d", 
      rlc_ptr->cmd_data.dl_cipher_config.ciphering[i].rb_id,
      rlc_ptr->cmd_data.dl_cipher_config.ciphering[i].cipher_mode, 
      (rlc_ptr->cmd_data.dl_cipher_config.ciphering[i].ciph_algo>>1));

  }

  WRRC_MSG0_HIGH("Dispatching out L2 cmd / Sending CRLC_DL_CIPHER_CONFIG_REQ");

  /* Send command to L2 DL Task */
  rrc_send_l2_dl_cmd(rlc_ptr);

  return SUCCESS;
} /* rrcllc_crlc_dl_cipher_config_req() */


/*====================================================================
FUNCTION: rrcllc_update_ciphering_config_info()

DESCRIPTION:
  This function constructs the RRC_CIPH_CONFIG_CNF primitive and
  sends it to SMC.

DEPENDENCIES:
  None

RETURN VALUE:
  uecomdef_status_e_type -> indicating a SUCCESS or FAILURE

SIDE EFFECTS:
  None.
====================================================================*/
static uecomdef_status_e_type rrcllc_update_ciphering_config_info(rrc_ciph_config_e_type config_cause)
{
  rrc_cmd_type  *cmd_ptr;

  /* DO NOT Copy CC to OC */
  /* Update the ciphering configuration information */
  (void)rrcsmc_update_ciphering_config_info(config_cause);

  /* Send commands to L1 */
  (void)rrcllc_cphy_ciphering_key_req();

  //if ciphering configuration is not affected for MAC, then don't bother
  //sending MAC UL/DL config req..  sending spurious mac reconfiguration
  //causes temporary garbling of UL/DL pdu's when mac is in reconfiguration.
  if(cipher_config_db.mac_ciph_config_affected == TRUE)
  {
    /* Send MAC DL Config request */
    rrcllc_cmac_dl_config_req(NO_SYNC_WITH_L1);
    /* Send MAC UL Config request - no sync needed with L1 */
    rrcllc_cmac_ul_config_req(RECONFIG_MAC, NO_SYNC_WITH_L1);

    /* Reset 'cipher_cfg_type' to default value because there is a possiblity that
       'cipher_cfg_type' might be set to 'SMC_INITIATED_NON_HO_CIPHER_CFG' when
       IE cipher mode info comes in SMC for the first time and TM RBs exist when
       SMC is received */
    cipher_config_db.mac_cipher_info[rrcsmc_get_latest_configured_cn_domain()].cipher_cfg_type = NON_HO_CIPHER_CFG;

    //reset this flag to false, as we already sent the config req to lower
    //layers
    cipher_config_db.mac_ciph_config_affected = FALSE;
  }

  /* Send RLC UL ciphering config request */
  (void)rrcllc_crlc_ul_cipher_config_req();

  /* Send RLC DL ciphering config request */
  (void)rrcllc_crlc_dl_cipher_config_req();

  /* Send ciphering configuration cnf back to SMC */
  cmd_ptr = rrc_get_int_cmd_buf();
  /* Fill in the Command Header */
  cmd_ptr->cmd_hdr.cmd_id = RRC_CIPH_CONFIG_CNF;

  cmd_ptr->cmd.rrc_cipher_config_cnf.cause= RRC_CIPHER_CONFIG_SUCCESS;

  WRRC_MSG0_HIGH("Sending RRC_CIPH_CONFIG_CNF SUCCESS to SMC");

  /* Send command to RRC internal queue */
  rrc_put_int_cmd(cmd_ptr);

  return SUCCESS;
} /* rrcllc_update_ciphering_config_info() */

/*====================================================================
FUNCTION: rrcllc_update_ciphering_config_info_for_first_tm_rb()

DESCRIPTION:
  This function updates the ciphering information in MAC.

DEPENDENCIES:
  None

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_update_ciphering_config_info_for_first_tm_rb(void)
{

  (void)rrcllc_cmac_ul_config_req_for_ciph_handover(RECONFIG_MAC, NO_SYNC_WITH_L1);
  (void)rrcllc_cmac_dl_config_req_for_ciph_handover(NO_SYNC_WITH_L1);

} /* rrcllc_update_ciphering_config_info_for_handover() */

/*====================================================================
FUNCTION: rrcllc_update_ciphering_config_info_for_handover()

DESCRIPTION:
  This function updates the ciphering information in RLC and MAC.

DEPENDENCIES:
  None

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_update_ciphering_config_info_for_handover(void)
{

  /* Send RLC UL ciphering config request */
  (void)rrcllc_crlc_ul_cipher_config_req();

  /* Send RLC DL ciphering config request */
  (void)rrcllc_crlc_dl_cipher_config_req();

  /* Configure MAC UL & DL - since L1 is not being configured,
   * do not ask MAC to wait for sync from L1
   */
  (void)rrcllc_cmac_ul_config_req_for_ciph_handover(RECONFIG_MAC, NO_SYNC_WITH_L1);
  (void)rrcllc_cmac_dl_config_req_for_ciph_handover(NO_SYNC_WITH_L1);

} /* rrcllc_update_ciphering_config_info_for_handover() */

/*====================================================================
FUNCTION: rrcllc_update_ciphering_config_info_for_reconfig()

DESCRIPTION:
  This function updates the ciphering information in RLC. MAC is not
  updated here. Will be updated in chan_config_engine.

DEPENDENCIES:
  None

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_update_ciphering_config_info_for_reconfig(void)
{

  /* Send RLC UL ciphering config request */
  (void)rrcllc_crlc_ul_cipher_config_req();

  /* Send RLC DL ciphering config request */
  (void)rrcllc_crlc_dl_cipher_config_req();

} /* rrcllc_update_ciphering_config_info_for_reconfig() */

/*====================================================================
FUNCTION: rrcllc_resume_rlc_due_to_ciph_abort()

DESCRIPTION:
  This function constructs the CRLC_UL_RESUME_REQ primitive and
  sends it to L2 UL Task.

DEPENDENCIES:
  None

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_resume_rlc_due_to_ciph_abort(void)
{
  wcdma_l2_ul_cmd_type  *rlc_ptr;
  rlc_ul_resume_type rrc_ul_resume_req;

  if (TRUE == rrcsmc_fill_ul_resume_req(&rrc_ul_resume_req))
  {
    /* Get L2 UL command buffer */
    rlc_ptr = wcdma_l2_ul_get_cmd_buf();

    /* Fill in the Command Header */
    rlc_ptr->cmd_hdr.cmd_id = CRLC_UL_RESUME_REQ;

    rlc_ptr->cmd_data.ul_resume = rrc_ul_resume_req;

    WRRC_MSG0_HIGH("Dispatching out L2 cmd / Sending CRLC_UL_RESUME_REQ");

    /* Send command to L2 UL Task */
    rrc_send_l2_ul_cmd(rlc_ptr);
  }
  else
  {
    WRRC_MSG0_HIGH("No need to resume because RBs are NOT suspended now");
  }
}
/*====================================================================
FUNCTION: rrcllc_re_est_rlc_req()

DESCRIPTION:
  This function constructs a CRLC_AM_CONFIG_REQ primitive and
  sends it to L2 UL Task.  If RBs other than RB2 are to be
  re-established, this kicks off a sequence of actions that
  re-establishes them too.

DEPENDENCIES:
  None

RETURN VALUE:
  Next RRCLLC substate depending on whether RLC needs to be re-established
  or not.

SIDE EFFECTS:
  None.
====================================================================*/
static rrcllc_substate_e_type rrcllc_process_re_est_rlc_req(rrc_cmd_type * cmd_ptr)
{
  ordered_config_type  *config_ptr;
  rrcllc_substate_e_type next_state = LLC_IDLE;

  uint32  i;

  rlc_am_config_for_re_est.nentity = 0;
  rlc_ul_um_config_for_re_est.nchan = rlc_dl_um_config_for_re_est.nchan = 0;

  if(config_ptr_in_use == ORDERED_CONFIG)
  {
    config_ptr = ordered_config_ptr;
  }
  else
  {
    config_ptr = current_config_ptr;
  }

  for(i=0; i<UE_MAX_AM_ENTITY; i++)
  {
    if(cmd_ptr->cmd.rrc_re_est_req.am_config.rb_type == RRC_RE_EST_RB_2 &&
       config_ptr->rlc_am_parms.am_info[i]->common_config.rb_id != DCCH_AM_RADIO_BEARER_ID)
    {
      continue;
    }
    else if(cmd_ptr->cmd.rrc_re_est_req.am_config.rb_type == RRC_RE_EST_NON_RB_2_UM_AM &&
            config_ptr->rlc_am_parms.am_info[i]->common_config.rb_id == DCCH_AM_RADIO_BEARER_ID)
    {
      continue;
    }
    else if (config_ptr->rlc_am_parms.am_info[i]->dl_nchan == 0 ||
             config_ptr->rlc_am_parms.am_info[i]->ul_nchan == 0)
    {
      /* This is an empty hole that is not used or under config'ng */
      continue;
    }
    else
    {
      rlc_am_config_for_re_est.am_act[rlc_am_config_for_re_est.nentity].act_incl = FALSE;
      rlc_am_config_for_re_est.am_act[rlc_am_config_for_re_est.nentity].action = RLC_MODIFY;
      rlc_am_config_for_re_est.am_act[rlc_am_config_for_re_est.nentity].ul_cfg_mask= RLC_RE_ESTABLISH_CFG;
      rlc_am_config_for_re_est.am_act[rlc_am_config_for_re_est.nentity].dl_cfg_mask= RLC_RE_ESTABLISH_CFG;
      rlc_am_config_for_re_est.am_info[rlc_am_config_for_re_est.nentity] =
        config_ptr->rlc_am_parms.am_info[i];

      //copy the hfn_srb or hfn_urb based on whether the radio bearer is a Signalling RB or
      //if the radio bearer is a User RB
      switch(config_ptr->rlc_am_parms.am_info[i]->common_config.rb_id)
      {
        case DCCH_AM_RADIO_BEARER_ID:
        case DCCH_DT_HIGH_PRI_RADIO_BEARER_ID:
        case DCCH_DT_LOW_PRI_RADIO_BEARER_ID:
          rlc_am_config_for_re_est.am_info[rlc_am_config_for_re_est.nentity]->rlc_ul_am_config.hfn =
          rlc_am_config_for_re_est.am_info[rlc_am_config_for_re_est.nentity]->rlc_dl_am_config.hfn =
            cmd_ptr->cmd.rrc_re_est_req.am_config.hfn_srb;

          //set the ciphering algorithm
          rlc_am_config_for_re_est.am_info[rlc_am_config_for_re_est.nentity]->rlc_ul_am_config.ciph_algo =
          rlc_am_config_for_re_est.am_info[rlc_am_config_for_re_est.nentity]->rlc_dl_am_config.ciph_algo=
            cmd_ptr->cmd.rrc_re_est_req.am_config.ciph_algo_srb;
          rlc_am_config_for_re_est.am_info[rlc_am_config_for_re_est.nentity]->reestab_entity = RLC_RE_ESTABLISH_DL_UL;
          MSG_HIGH("Re-establish both, %d. Re-est for RB ID %d HFN %x",
                     rlc_am_config_for_re_est.nentity,
                     config_ptr->rlc_am_parms.am_info[i]->common_config.rb_id,
                     cmd_ptr->cmd.rrc_re_est_req.am_config.hfn_srb);
          break;

        //Set HFN's for Non-SRB's
        default:
          rlc_am_config_for_re_est.am_info[rlc_am_config_for_re_est.nentity]->rlc_ul_am_config.hfn =
          rlc_am_config_for_re_est.am_info[rlc_am_config_for_re_est.nentity]->rlc_dl_am_config.hfn =
            cmd_ptr->cmd.rrc_re_est_req.am_config.hfn_urb;
          rlc_am_config_for_re_est.am_info[rlc_am_config_for_re_est.nentity]->reestab_entity = RLC_RE_ESTABLISH_DL_UL;

          //set the ciphering algorithm
          rlc_am_config_for_re_est.am_info[rlc_am_config_for_re_est.nentity]->rlc_ul_am_config.ciph_algo =
          rlc_am_config_for_re_est.am_info[rlc_am_config_for_re_est.nentity]->rlc_dl_am_config.ciph_algo =
            cmd_ptr->cmd.rrc_re_est_req.am_config.ciph_algo_urb;

          MSG_HIGH("Re-establish both, %d. Re-est for RB ID %d HFN %x",
                     rlc_am_config_for_re_est.nentity,
                     config_ptr->rlc_am_parms.am_info[i]->common_config.rb_id,
                     cmd_ptr->cmd.rrc_re_est_req.am_config.hfn_urb);

          break;
      }

      rlc_am_config_for_re_est.nentity ++;
    }
  } /* for (all nentities in OC) */

  if(cmd_ptr->cmd.rrc_re_est_req.am_config.rb_type == RRC_RE_EST_NON_RB_2_UM_AM)
  {
    WRRC_MSG1_HIGH("RE-EST UM Mode RB's RBTYPE:%d",cmd_ptr->cmd.rrc_re_est_req.am_config.rb_type);
    
    for(i=0; i<UE_MAX_DL_UM_CHANNEL; i++)
    {
      if((config_ptr->rlc_dl_um_parms.chan_info[i].rb_id == RRCLLC_INVALID_RB_ID) ||
         (config_ptr->rlc_dl_um_parms.chan_info[i].rb_id == CCCH_RADIO_BEARER_ID) ||
         (config_ptr->rlc_dl_um_parms.chan_info[i].rb_id == DCCH_AM_RADIO_BEARER_ID) ||
         (config_ptr->rlc_dl_um_parms.chan_info[i].rb_id == DCCH_DT_HIGH_PRI_RADIO_BEARER_ID) ||
         (config_ptr->rlc_dl_um_parms.chan_info[i].rb_id == DCCH_DT_LOW_PRI_RADIO_BEARER_ID))

      {
        /* This is an empty hole that is not used or under configuring */
        continue;
      }
      else if(( (config_ptr->rlc_dl_um_parms.chan_info[i].rb_id == DCCH_UM_RADIO_BEARER_ID) && 
                 (config_ptr->rlc_dl_um_parms.chan_info[i].lc_type == UE_LOGCHAN_DCCH)
               ) 
               ||
               ( (config_ptr->rlc_dl_um_parms.chan_info[i].rb_id != DCCH_UM_RADIO_BEARER_ID)  &&
                 (config_ptr->rlc_dl_um_parms.chan_info[i].lc_type == UE_LOGCHAN_DTCH)
               )
             )
      {
        WRRC_MSG2_HIGH("RST_DBG:RBID:%d LCTYPE:%d",config_ptr->rlc_dl_um_parms.chan_info[i].rb_id,
          config_ptr->rlc_dl_um_parms.chan_info[i].lc_type);

        rlc_dl_um_config_for_re_est.dl_um_act[rlc_dl_um_config_for_re_est.nchan].act_incl = FALSE;
        rlc_dl_um_config_for_re_est.dl_um_act[rlc_dl_um_config_for_re_est.nchan].action = RLC_MODIFY;
        rlc_dl_um_config_for_re_est.dl_um_act[rlc_dl_um_config_for_re_est.nchan].ul_cfg_mask= 0;
        rlc_dl_um_config_for_re_est.dl_um_act[rlc_dl_um_config_for_re_est.nchan].dl_cfg_mask= RLC_RE_ESTABLISH_CFG;
        rlc_dl_um_config_for_re_est.chan_info[rlc_dl_um_config_for_re_est.nchan].lc_type = 
          config_ptr->rlc_dl_um_parms.chan_info[i].lc_type;
        rlc_dl_um_config_for_re_est.chan_info[rlc_dl_um_config_for_re_est.nchan].rb_id = 
                 config_ptr->rlc_dl_um_parms.chan_info[i].rb_id;

        rlc_dl_um_config_for_re_est.chan_info[rlc_dl_um_config_for_re_est.nchan].rlc_size = 0;
        if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
        {
          WRRC_MSG1_HIGH("RRC:Re-estab RB %d. Set DL UM LI to 7 bits",config_ptr->rlc_ul_um_parms.chan_info[i].rb_id);
          rlc_dl_um_config_for_re_est.chan_info[rlc_dl_um_config_for_re_est.nchan].li_size = LI_7_BITS;
        }

        rlc_dl_um_config_for_re_est.chan_info[rlc_dl_um_config_for_re_est.nchan].ciph_algo =
         cmd_ptr->cmd.rrc_re_est_req.dl_um_config.ciph_algo_srb;

        rlc_dl_um_config_for_re_est.chan_info[rlc_dl_um_config_for_re_est.nchan].lc_id =
            config_ptr->rlc_dl_um_parms.chan_info[i].lc_id;

        if(config_ptr->rlc_dl_um_parms.chan_info[i].rb_id == DCCH_UM_RADIO_BEARER_ID)
        {
          rlc_dl_um_config_for_re_est.chan_info[rlc_dl_um_config_for_re_est.nchan].hfn =
            cmd_ptr->cmd.rrc_re_est_req.dl_um_config.hfn_srb;
        }
        else
        { 
          rlc_dl_um_config_for_re_est.chan_info[rlc_dl_um_config_for_re_est.nchan].hfn =
            cmd_ptr->cmd.rrc_re_est_req.dl_um_config.hfn_urb;
        }

        WRRC_MSG1_HIGH("Re-est for UM  DL HFN %x",
           rlc_dl_um_config_for_re_est.chan_info[rlc_dl_um_config_for_re_est.nchan].hfn);


        rlc_dl_um_config_for_re_est.nchan++;
      }
    }
    for(i=0; i<UE_MAX_UL_UM_CHANNEL; i++)
    {
      if((config_ptr->rlc_ul_um_parms.chan_info[i].rb_id == RRCLLC_INVALID_RB_ID) ||
         (config_ptr->rlc_ul_um_parms.chan_info[i].rb_id == CCCH_RADIO_BEARER_ID) ||
         (config_ptr->rlc_ul_um_parms.chan_info[i].rb_id == DCCH_AM_RADIO_BEARER_ID) ||
         (config_ptr->rlc_ul_um_parms.chan_info[i].rb_id == DCCH_DT_HIGH_PRI_RADIO_BEARER_ID) ||
         (config_ptr->rlc_ul_um_parms.chan_info[i].rb_id == DCCH_DT_LOW_PRI_RADIO_BEARER_ID))

      {
        /* This is an empty hole that is not used or under configuring */
        continue;
      }
      else if(( (config_ptr->rlc_ul_um_parms.chan_info[i].rb_id == DCCH_UM_RADIO_BEARER_ID) && 
                 (config_ptr->rlc_ul_um_parms.chan_info[i].lc_type == UE_LOGCHAN_DCCH)
               ) 
               ||
               ( (config_ptr->rlc_ul_um_parms.chan_info[i].rb_id != DCCH_UM_RADIO_BEARER_ID)  &&
                 (config_ptr->rlc_ul_um_parms.chan_info[i].lc_type == UE_LOGCHAN_DTCH)
               )
             )
      {
        WRRC_MSG2_HIGH("RST_DBG:RBID:%d LCTYPE:%d",config_ptr->rlc_ul_um_parms.chan_info[i].rb_id,
          config_ptr->rlc_ul_um_parms.chan_info[i].lc_type);

        rlc_ul_um_config_for_re_est.ul_um_act[rlc_ul_um_config_for_re_est.nchan].act_incl = FALSE;
        rlc_ul_um_config_for_re_est.ul_um_act[rlc_ul_um_config_for_re_est.nchan].action = RLC_MODIFY;
        rlc_ul_um_config_for_re_est.ul_um_act[rlc_ul_um_config_for_re_est.nchan].ul_cfg_mask= RLC_RE_ESTABLISH_CFG;
        rlc_ul_um_config_for_re_est.ul_um_act[rlc_ul_um_config_for_re_est.nchan].dl_cfg_mask= 0;
        rlc_ul_um_config_for_re_est.chan_info[rlc_ul_um_config_for_re_est.nchan].lc_type = 
          config_ptr->rlc_ul_um_parms.chan_info[i].lc_type;
        rlc_ul_um_config_for_re_est.chan_info[rlc_ul_um_config_for_re_est.nchan].rb_id = 
          config_ptr->rlc_ul_um_parms.chan_info[i].rb_id;

        rlc_ul_um_config_for_re_est.chan_info[rlc_ul_um_config_for_re_est.nchan].rlc_size = 0;

        rlc_ul_um_config_for_re_est.chan_info[rlc_ul_um_config_for_re_est.nchan].timer_discard=
          rrc_get_ul_um_timer_discard_for_rb_id(config_ptr->rlc_ul_um_parms.chan_info[i].rb_id);

        rlc_ul_um_config_for_re_est.chan_info[rlc_ul_um_config_for_re_est.nchan].ciph_algo =
           cmd_ptr->cmd.rrc_re_est_req.ul_um_config.ciph_algo_srb;

        rlc_ul_um_config_for_re_est.chan_info[rlc_ul_um_config_for_re_est.nchan].lc_id = 
          config_ptr->rlc_ul_um_parms.chan_info[i].lc_id;

        if(config_ptr->rlc_ul_um_parms.chan_info[i].rb_id == DCCH_UM_RADIO_BEARER_ID)
        {
          rlc_ul_um_config_for_re_est.chan_info[rlc_ul_um_config_for_re_est.nchan].hfn =
            cmd_ptr->cmd.rrc_re_est_req.ul_um_config.hfn_srb;
        }
        else
        { 
          rlc_ul_um_config_for_re_est.chan_info[rlc_ul_um_config_for_re_est.nchan].hfn =
            cmd_ptr->cmd.rrc_re_est_req.ul_um_config.hfn_urb;
        }

        WRRC_MSG1_HIGH("Re-est for UM UL HFN %x ",
           rlc_ul_um_config_for_re_est.chan_info[rlc_ul_um_config_for_re_est.nchan].hfn);

        rlc_ul_um_config_for_re_est.nchan++;
      }
    }
  }

  if(rlc_dl_um_config_for_re_est.nchan)
  {
    rrcllc_crlc_dl_um_config_req(&rlc_dl_um_config_for_re_est);
    next_state = LLC_WAIT_RLC_UM_DL_CNF;
  }
  else if(rlc_ul_um_config_for_re_est.nchan)
  {
    rrcllc_crlc_ul_um_config_req(&rlc_ul_um_config_for_re_est);
    next_state = LLC_WAIT_RLC_UM_UL_CNF;
  }
  else if(rlc_am_config_for_re_est.nentity)
  {
    rrcllc_crlc_am_config_req(&rlc_am_config_for_re_est);
    next_state = LLC_WAIT_RLC_AM_CNF;
  }

  return next_state;
}

/****************************************************************************
**              Miscellaneous utilities
**
*****************************************************************************/

/*===========================================================================
FUNCTION   rrcllc_release_ul_logical_chl_ids

DESCRIPTION
  This function releases all Uplink logical channels that are so indicated
  by rrcllc_cmd_under_process data structure.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static void  rrcllc_release_ul_logical_chl_ids(void)
{
  uint8  i;
  /* Start with UL TM channels */
  for(i=0; i<rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.nchan; i++)
  {
    if(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.ul_tm_act[i].action == RLC_RELEASE)
    {
      (void)rrclcm_deallocate_ul_rlc_lc_id(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.chan_info[i].lc_id);
    }
  }

  for(i=0; i<rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.nchan; i++)
  {
    if(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.ul_um_act[i].action == RLC_RELEASE)
    {
      (void)rrclcm_deallocate_ul_rlc_lc_id(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.chan_info[i].lc_id);
    }
  }

  for(i=0; i<rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.nentity; i++)
  {
    if(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_act[i].action == RLC_RELEASE)
    {
      (void)rrclcm_deallocate_ul_rlc_lc_id(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.
                                     am_info[i]->common_config.ul_control_id);
      if((rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_info[i]->common_config.ul_control_id !=
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_info[i]->common_config.ul_data_id) &&
         (rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_info[i]->ul_nchan == 2))
      {
        (void)rrclcm_deallocate_ul_rlc_lc_id(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.
                                       am_info[i]->common_config.ul_data_id);
      }
    }   /* if action == RLC_RELEASE */
  }   /* for(..) */

} /* rrcllc_release_ul_logical_chl_ids */


/*===========================================================================
FUNCTION   rrcllc_release_dl_logical_chl_ids

DESCRIPTION
  This function releases all Downlink logical channels that are so indicated
  by rrcllc_cmd_under_process data structure.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static void  rrcllc_release_dl_logical_chl_ids(void)
{
  uint8  i;
  /* Start with UL TM channels */
  for(i=0; i<rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.nchan; i++)
  {
    if(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.dl_tm_act[i].action == RLC_RELEASE)
    {
      (void)rrclcm_deallocate_dl_rlc_lc_id(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[i].lc_id);
    }
  }

  for(i=0; i<rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.nchan; i++)
  {
    if(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.dl_um_act[i].action == RLC_RELEASE)
    {
      (void)rrclcm_deallocate_dl_rlc_lc_id(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[i].lc_id);
    }
  }

  for(i=0; i<rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.nentity; i++)
  {
    if(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_act[i].action == RLC_RELEASE)
    {
      (void)rrclcm_deallocate_dl_rlc_lc_id(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.
                                     am_info[i]->common_config.dl_control_id);
      if((rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_info[i]->common_config.dl_control_id !=
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_info[i]->common_config.dl_data_id) &&
         (rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_info[i]->dl_nchan == 2))
      {
        (void)rrclcm_deallocate_dl_rlc_lc_id(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.
                                       am_info[i]->common_config.dl_data_id);
      }
    }   /* if action == RLC_RELEASE */
  }   /* for(..) */

} /* rrcllc_release_dl_logical_chl_ids */


/*===========================================================================
FUNCTION   rrcllc_release_ul_logical_chl_ids_in_new_configuration

DESCRIPTION
  This function releases all Uplink logical channels that are so indicated
  by rlc_rel_list data structure.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static void  rrcllc_release_ul_logical_chl_ids_in_new_configuration(void)
{
  uint8  i;
  /* Start with UL TM channels */
  for(i=0; i<rlc_rel_list.ul_tm.nchan; i++)
  {
    if(rlc_rel_list.ul_tm.ul_tm_act[i].action == RLC_RELEASE)
    {
      (void)rrclcm_deallocate_ul_rlc_lc_id(rlc_rel_list.ul_tm.chan_info[i].lc_id);
    }
  }

  for(i=0; i<rlc_rel_list.ul_um.nchan; i++)
  {
    if(rlc_rel_list.ul_um.ul_um_act[i].action == RLC_RELEASE)
    {
      (void)rrclcm_deallocate_ul_rlc_lc_id(rlc_rel_list.ul_um.chan_info[i].lc_id);
    }
  }

  for(i=0; i<rlc_rel_list.am.nentity; i++)
  {
    if(rlc_rel_list.am.am_act[i].action == RLC_RELEASE)
    {
      (void)rrclcm_deallocate_ul_rlc_lc_id(rlc_rel_list.am.
                                     am_info[i]->common_config.ul_control_id);
      if((rlc_rel_list.am.am_info[i]->common_config.ul_control_id !=
          rlc_rel_list.am.am_info[i]->common_config.ul_data_id) &&
         (rlc_rel_list.am.am_info[i]->ul_nchan == 2))
      {
        (void)rrclcm_deallocate_ul_rlc_lc_id(rlc_rel_list.am.
                                       am_info[i]->common_config.ul_data_id);
      }
    }   /* if action == RLC_RELEASE */
  }   /* for(..) */

} /* rrcllc_release_ul_logical_chl_ids_in_new_configuration */


/*===========================================================================
FUNCTION   rrcllc_release_dl_logical_chl_ids_in_new_configuration

DESCRIPTION
  This function releases all Downlink logical channels that are so indicated
  by rlc_rel_list

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static void  rrcllc_release_dl_logical_chl_ids_in_new_configuration(void)
{
  uint8  i;
  /* Start with UL TM channels */
  for(i=0; i<rlc_rel_list.dl_tm.nchan; i++)
  {
    if(rlc_rel_list.dl_tm.dl_tm_act[i].action == RLC_RELEASE)
    {
      (void)rrclcm_deallocate_dl_rlc_lc_id(rlc_rel_list.dl_tm.chan_info[i].lc_id);
    }
  }

  for(i=0; i<rlc_rel_list.dl_um.nchan; i++)
  {
    if(rlc_rel_list.dl_um.dl_um_act[i].action == RLC_RELEASE)
    {
      (void)rrclcm_deallocate_dl_rlc_lc_id(rlc_rel_list.dl_um.chan_info[i].lc_id);
    }
  }

  for(i=0; i<rlc_rel_list.am.nentity; i++)
  {
    if(rlc_rel_list.am.am_act[i].action == RLC_RELEASE)
    {
      (void)rrclcm_deallocate_dl_rlc_lc_id(rlc_rel_list.am.
                                     am_info[i]->common_config.dl_control_id);
      if((rlc_rel_list.am.am_info[i]->common_config.dl_control_id !=
          rlc_rel_list.am.am_info[i]->common_config.dl_data_id) &&
         (rlc_rel_list.am.am_info[i]->dl_nchan == 2))
      {
        (void)rrclcm_deallocate_dl_rlc_lc_id(rlc_rel_list.am.
                                       am_info[i]->common_config.dl_data_id);
      }
    }   /* if action == RLC_RELEASE */
  }   /* for(..) */

} /* rrcllc_release_dl_logical_chl_ids_in_new_configuration */

/*===========================================================================
FUNCTION   rrcllc_clear_rlc_info

DESCRIPTION
  This function clears the RLC Info for the logical channels that have been
  released.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static void  rrcllc_clear_rlc_info(void)
{

  uint8           i;
  rrc_RB_Identity rb_id;

  WRRC_MSG0_MED("nchan: clear_rlc_info() called");

  for(i=0; i<rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.nentity; i++)
  {
    if(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_act[i].action == RLC_RELEASE)
    {
      /* remove rb mapping from toc. This info has already been removed from OC during
      set_ordered_config */
      if (transition_config.toc_usage != TOC_INVALID)
      {
        unmap_rb(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_info[i]->common_config.rb_id ,
                 TOC_ONLY);
      }
      /* Clear all AM info for this AM entity in Ordered Config */
      rrcllc_delete_rlc_am_info(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.
                                am.am_info[i]->common_config.rb_id);
    }   /* if action == RLC_RELEASE */
  }   /* for(..) */

  for(i=0; i<rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.nchan; i++)
  {
    if(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.
       dl_tm.dl_tm_act[i].action == RLC_RELEASE)
    {
      rrcllc_delete_rlc_dl_tm_info(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.
                                   dl_tm.chan_info[i].lc_id);
    }
  }

  for(i=0; i<rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.nchan; i++)
  {
    if(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.
       dl_um.dl_um_act[i].action == RLC_RELEASE)
    {
      rrcllc_delete_rlc_dl_um_info(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.
                                   dl_um.chan_info[i].lc_id);
    }
  }

  for(i=0; i<rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.nchan; i++)
  {
    if(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.
       ul_tm.ul_tm_act[i].action == RLC_RELEASE)
    {
      if (transition_config.toc_usage != TOC_INVALID)
      {
        rb_id = rrclcm_get_ul_rb_id(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.
                                     ul_tm.chan_info[i].lc_id);
        if (rb_id > DCCH_DT_LOW_PRI_RADIO_BEARER_ID)
        {
          /* remove rb mapping from toc. This info has already been removed from OC during
          set_ordered_config */
            unmap_rb(rb_id, TOC_ONLY);
        }
      }
      rrcllc_delete_rlc_ul_tm_info(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.
                                   ul_tm.chan_info[i].lc_id);
    }
  }

  for(i=0; i<rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.nchan; i++)
  {
    if(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.
       ul_um.ul_um_act[i].action == RLC_RELEASE)
    {
      rrcllc_delete_rlc_ul_um_info(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.
                                   ul_um.chan_info[i].lc_id);
      if (transition_config.toc_usage != TOC_INVALID)
      {
        rb_id = rrclcm_get_ul_rb_id(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.
                                     ul_um.chan_info[i].lc_id);
        if (rb_id > DCCH_DT_LOW_PRI_RADIO_BEARER_ID)
        {
          /* remove rb mapping from toc. This info has already been removed from OC during
          set_ordered_config */
            unmap_rb(rb_id, TOC_ONLY);
        }
      }
    }
  }
}  /* rrcllc_clear_rlc_info */


#ifdef FEATURE_UMTS_PDCP
/*====================================================================
FUNCTION: rrcllc_rearrange_pdcp_info()

DESCRIPTION:
  This function deletes any holes
DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/

static void rrcllc_rearrange_pdcp_info
(
  ordered_config_type   *config_ptr
)
{
  uint8  ix=0, iy=0;

  WRRC_MSG1_MED("PDCP:Rearranging PDCP info. Number of PDCPs to be rearranged %d",config_ptr->pdcp_parms.num_rbs);

  if (config_ptr->pdcp_parms.num_rbs == 0)
  {
    return;
  }

  for(ix = MAX_RAB_TO_SETUP-1; ix > 0; ix--)
  {
    /* Check if valid data */
    if(config_ptr->pdcp_parms.pdcp_config_req[ix].in_use == TRUE)
    {
      for(iy = 0; iy < ix ; iy++)
      {
        /* Check if valid data */
        if(config_ptr->pdcp_parms.pdcp_config_req[iy].in_use == FALSE)
        {
          config_ptr->pdcp_parms.pdcp_config_req[iy] = 
            config_ptr->pdcp_parms.pdcp_config_req[ix];
          
          MSG_HIGH("Clearing PDCP info.ix %d move it ot iy % d, PDCP:rb i.d- %d info moved up", ix,iy,config_ptr->pdcp_parms.pdcp_config_req[iy].rb_id);
          
          config_ptr->pdcp_parms.pdcp_config_req[ix].in_use = FALSE;
          config_ptr->pdcp_parms.pdcp_config_req[ix].pdcp_info_changed = FALSE;
          config_ptr->pdcp_parms.pdcp_config_req[ix].rb_id = RRC_INVALID_RB_ID;
          config_ptr->pdcp_parms.pdcp_config_req[ix].pdcp_cfg_req.action = MAX_ACTION_PDCP;
          config_ptr->pdcp_parms.pdcp_config_req[ix].pdcp_cfg_req.rb_id = RRC_INVALID_RB_ID; 
          break;
        }
      }
      if (iy == ix) 
      {
        WRRC_MSG0_HIGH("PDCP: Rearranging PDCP info complete");
        break;
      }
    }
  } /* End of for (...) */
}
/*===========================================================================
FUNCTION   rrcllc_clear_pdcp_info

DESCRIPTION
  This function clears the pdcp Info for the RBs that have been released.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static void rrcllc_clear_pdcp_info(void)
{
  uint32 i = 0;
  uint32 j = 0;

  for(i=0; i < rrcllc_cmd_under_process.chan_config.pdcp_config_req_list.num_rbs; i++)
  {
    if (rrcllc_cmd_under_process.chan_config.pdcp_config_req_list.pdcp_cfg_req[i].action == RELEASE_PDCP) 
    {
      for (j = 0; j < MAX_RAB_TO_SETUP; j++) 
      {
        if (ordered_config_ptr->pdcp_parms.pdcp_config_req[j].pdcp_cfg_req.rb_id ==
            rrcllc_cmd_under_process.chan_config.pdcp_config_req_list.pdcp_cfg_req[i].rb_id) 
        {
          WRRC_MSG2_HIGH("Clearing PDCP info.i %d j % d", i,j);
          ordered_config_ptr->pdcp_parms.num_rbs--;
          ordered_config_ptr->pdcp_parms.pdcp_config_req[j].in_use = FALSE;
          ordered_config_ptr->pdcp_parms.pdcp_config_req[j].pdcp_info_changed = FALSE;
          ordered_config_ptr->pdcp_parms.pdcp_config_req[j].rb_id = RRC_INVALID_RB_ID;
          ordered_config_ptr->pdcp_parms.pdcp_config_req[j].pdcp_cfg_req.action = MAX_ACTION_PDCP;
          ordered_config_ptr->pdcp_parms.pdcp_config_req[j].pdcp_cfg_req.rb_id = RRC_INVALID_RB_ID; 
          break;
        }
      }
    }
  }

  //Rearranging PDCP info now
  rrcllc_rearrange_pdcp_info(ordered_config_ptr);
  
}
#endif /* FEATURE_UMTS_PDCP */

/*===========================================================================
FUNCTION   rrcllc_update_semi_permanent_phychan_status

DESCRIPTION
  This function updates the status of all downlink and uplink physical
  channels in semi permanent data. The status is based on operations on
  the physical channels as in command under process data.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static void  rrcllc_update_semi_permanent_phychan_status(void)
{

  /* Update for PCCPCH */
  if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action
      == LLC_PHYCHAN_SETUP)
  {
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up = TRUE;
  }
  else if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action
            == LLC_PHYCHAN_RELEASE)
  {
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up = FALSE;
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch.num_trch = 0;
  }
#ifdef FEATURE_UPDATE_SIB7_IN_FACH
/* Not Needed*/
  if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action
      == LLC_PHYCHAN_DROP_AND_ADD)
  {
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up = TRUE;
  }
#endif /*FEATURE_UPDATE_SIB7_IN_FACH*/
  /* Update for N_PCCPCH */
  if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.n_pccpch_action
      == LLC_PHYCHAN_SETUP)
  {
    rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch_is_up = TRUE;
  }
  else if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.n_pccpch_action
            == LLC_PHYCHAN_RELEASE)
  {
    rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch_is_up = FALSE;
    rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch.num_trch = 0;
  }


  if (rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch_is_up &&
      rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up) 
  {
    ERR_FATAL("N-PCCPCH+S-PCCPCH UP at same time:  Not expected",0,0,0);
  }

  /* Update for SCCPCH */
  if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_action
      == LLC_PHYCHAN_SETUP)
  {
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch_is_up = TRUE;
  }
  else if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_action
            == LLC_PHYCHAN_RELEASE)
  {
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch_is_up = FALSE;
  }

  /* Update for SCCPCH */
  if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_for_ctch_action
      == LLC_PHYCHAN_SETUP)
  {
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch_is_up = TRUE;
  }
  else if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_for_ctch_action
            == LLC_PHYCHAN_RELEASE)
  {
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch_is_up = FALSE;
  }

  /* Update for DL-DPCH */
  if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.dl_dpch_action
      == LLC_PHYCHAN_SETUP)
  {

    WRRC_MSG1_MED("DEBUG:DL DPCH action %d", 
             rrcllc_cmd_under_process.chan_config.phy_chan_action_list.dl_dpch_action);

    rrcllc_semi_permanent_data.dl_phy_chan.dl_dpch_is_up = TRUE;
  }
  else if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.dl_dpch_action
            == LLC_PHYCHAN_RELEASE)
  {
    rrcllc_semi_permanent_data.dl_phy_chan.dl_dpch_is_up = FALSE;
  }

  /* Update for UL-DPCH */
  if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.ul_dpch_action
      == LLC_PHYCHAN_SETUP)
  {
    WRRC_MSG1_MED("DEBUG:UL DPCH action %d", 
             rrcllc_cmd_under_process.chan_config.phy_chan_action_list.ul_dpch_action);

    rrcllc_semi_permanent_data.ul_phy_chan.ul_dpch_is_up = TRUE;
  }
  else if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.ul_dpch_action
            == LLC_PHYCHAN_RELEASE)
  {
    rrcllc_semi_permanent_data.ul_phy_chan.ul_dpch_is_up = FALSE;
  }

  /* Update for PRACH */
  if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.prach_action
      == LLC_PHYCHAN_SETUP)
  {
    rrcllc_semi_permanent_data.ul_phy_chan.prach_is_up = TRUE;
  }
  else if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.prach_action
            == LLC_PHYCHAN_RELEASE)
  {
    rrcllc_semi_permanent_data.ul_phy_chan.prach_is_up = FALSE;
  }

} /* rrcllc_update_semi_permanent_phychan_status */


/*===========================================================================
FUNCTION   rrcllc_clear_released_cctrch_ids

DESCRIPTION
  This function clears all CCTrCH IDs that are part of the CCTrCH ID release
  list in rrcllc_cmd_under_process.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static void  rrcllc_clear_released_cctrch_ids(void)
{
  int id_count;

  for(id_count = 0;
      id_count < rrcllc_cmd_under_process.chan_config.cctrch_id_release_list.num_ids;
      id_count ++
     )
  {
    /* Release each CCTrCH ID in the list */
    WRRC_MSG1_MED("Releasing CCTrCH ID %d",
                rrcllc_cmd_under_process.chan_config.cctrch_id_release_list.id[id_count]);
    if(rrcllc_clear_cctrch_id(rrcllc_cmd_under_process.chan_config.cctrch_id_release_list.id[id_count])
        == FAILURE)
    {
      WRRC_MSG2_ERROR("CCTrCH ID %d in rrcllc_cmd_under_process index %d not cleared",
            rrcllc_cmd_under_process.chan_config.cctrch_id_release_list.id[id_count], id_count);
      break;

    } /* If could not clear CCTrCH ID */
  } /* for(..) */
} /* rrcllc_clear_released_cctrch_ids */

/*====================================================================
FUNCTION: rrcllc_can_oc_be_cleared_now

DESCRIPTION:
  This returns a boolean depending on if the LLC state permits
  a call to clear_ordered_config_now or not.
  If a valid LLC operation is under process, OC can not be
  cleared and this function returns a FALSE. Before returning
  a FALSE, it registers a clear_ordered_config operation so
  that it is called immeditaley after a Command Engine is
  finished.

DEPENDENCIES:
  None

RETURN VALUE:
  TRUE = OC can be cleared now
  FALSE = OC can not be cleared.

SIDE EFFECTS:
  A clear ordered config event is registered.
====================================================================*/
boolean  rrcllc_can_oc_be_cleared_now(void)
{
  if((rrcllc_cmd_under_process.valid) &&
     (rrcllc_current_substate != LLC_IDLE) &&
     ((rrcllc_cmd_under_process.chan_config.current_cmd_engine
        == LLC_CHAN_CONFIG_ENGINE) ||
      (rrcllc_cmd_under_process.chan_config.current_cmd_engine
        == LLC_CELL_RESELECTION_ENGINE)))
  {
    /* If a valid command is being processed and LLC substate is not Idle
     * and Channel Config OR Reselection command engine is in progress,
     * then wait for the command engine to complete.
     * Register Clear OC event implicitly.
     */
    WRRC_MSG2_HIGH("Register ClearOC %d LLC sstate %d cmd engine",
                rrcllc_current_substate,
                rrcllc_cmd_under_process.chan_config.current_cmd_engine);
    rrcllc_cmd_under_process.clear_oc_pending = TRUE;
    return(FALSE);
  }
  else
  {
    WRRC_MSG2_MED("Allow ClearOC  LLC sstate %d cmd engine %d",
                rrcllc_current_substate,
                rrcllc_cmd_under_process.chan_config.current_cmd_engine);
    return(TRUE);
  }
} /* rrcllc_can_oc_be_cleared_now */

/*====================================================================
FUNCTION: rrcllc_clear_ordered_config_now

DESCRIPTION:
  This is called when the ORDERED_CONFIG variable needs to be cleared.
  That means the Ordered Config and Current Config pointers are swapped.

DEPENDENCIES:
  Make sure no command is under process when this is called.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_clear_ordered_config_now
(
  void
)
{
  rrc_cmd_type  *rrc_cmd_ptr;

  rrcllc_swap_oc_and_cc();

  WRRC_MSG0_HIGH("Cleared OC status now");

  /* Check if SMC needs to be notified */
  if((ordered_config.notify_smc) &&
     (ordered_config.set_status != OC_NOT_SET))
  {
    /* Send RRC_RECONFIG_COMPLETE_IND to SMC */
     rrc_cmd_ptr = rrc_get_int_cmd_buf();

    WRRC_MSG0_HIGH("Sending RRC_RECONFIG_COMPLETE_IND to SMC");

    /* Fill in the local command header.*/
    rrc_cmd_ptr->cmd_hdr.cmd_id = RRC_RECONFIG_COMPLETE_IND;

    /* Send the internal command */
    rrc_put_int_cmd(rrc_cmd_ptr);
  }

#ifdef FEATURE_GAN_3G_ROVE_IN_CONNECTED_STATE
  #error code not present
#endif


  ordered_config.set_status = OC_NOT_SET;
  ordered_config.process_state = LL_NOT_CONFIG_WITH_OC;
  ordered_config.set_by_proc  = RRC_PROCEDURE_NONE;

  /* Clear the boolean */
  ordered_config.notify_smc = FALSE;
  ordered_config.reconfig_in_progress = FALSE;


  return;
} /* end rrcllc_clear_ordered_config_now() */

boolean  rrcllc_is_cmd_under_process_for_solo_bch_operation(void)
{
  if(rrcllc_cmd_under_process.chan_config.solo_bch_operation)
  {
    return(TRUE);
  }
  else
  {
    return(FALSE);
  }
}


/*====================================================================
FUNCTION: rrcllc_update_oc_with_l1_connected_mode_timers

DESCRIPTION:
  This is called when the ORDERED_CONFIG variable needs to be updated 
  with L1 connected mode (DPCH) parameters.

DEPENDENCIES:
  None

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_update_oc_with_l1_connected_mode_timers(void)
{
  ordered_config_ptr->l1_dl_chan_parms.sync_det.N312 = 
                                         (uint16)RRC_GET_N312();
  ordered_config_ptr->l1_dl_chan_parms.sync_det.N313 = 
                                       rrc_translate_n313(RRC_GET_N313());
  ordered_config_ptr->l1_dl_chan_parms.sync_det.N315 = 
                                          (uint16)RRC_GET_N315();

  ordered_config_ptr->l1_dl_chan_parms.sync_det.T312 =  
                                     (uint8)RRC_GET_T312();
  ordered_config_ptr->l1_dl_chan_parms.sync_det.T313 = 
                                       (uint8)RRC_GET_T313();
}  /* rrcllc_update_oc_with_l1_connected_mode_timers */

/****************************************************************************
**            Channel Operation related functions
**
*****************************************************************************/


/*====================================================================
FUNCTION: rrcllc_process_add_bcch_neighbor()

DESCRIPTION:
  This function updates Ordered Config data structures and LLC internal
  data (rrcllc_cmd_under_process) on addition of neighbor BCCH.

DEPENDENCIES:
  None
RETURN VALUE:
  Status
    SUCCESS:  All data structures needed to establish neighbor BCCH
              updated successfully.
    FAILURE:  Failure to allocate resources or detection of
              an invalid value in data structures.
SIDE EFFECTS:
  None.
====================================================================*/
static uecomdef_status_e_type
rrcllc_process_add_bcch_neighbor(ordered_config_type *config_ptr)
{
  /* RLC downlink logical channel ID */
  rlc_lc_id_type        rlc_dl_log_chl_id;
  /* DL watermark pointer assigned for logical channel */
  dsm_watermark_type    *dl_log_chl_queue;

  uint8   num_chl;

  WRRC_MSG0_HIGH("ADD NEIGHBOR BCCH");

  /* Allocate a downlink logical channel ID */
  rlc_dl_log_chl_id = rrclcm_allocate_dl_rlc_lc_id
  (
    UE_LOGCHAN_BCCH,
    BCCH_N_RADIO_BEARER_ID,
    UE_MODE_TRANSPARENT,
    &dl_log_chl_queue
  );

  /* Check if able to successfully allocate DL logical channel ID */
  if(rlc_dl_log_chl_id != RRCLCM_RLC_LC_ID_ERROR)
  {
    /* 2. NOW UPDATE RLC AND MAC ORDERD CONFIG DATA STRUCTURES */

    /* Update RLC Downlink TM channel data */
    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.nchan ++;
    /* Update the count in Ordered Config also */
    config_ptr->rlc_dl_tm_parms.nchan ++;

    num_chl = rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.nchan;

    if(num_chl < UE_MAX_DL_TM_CHANNEL)
    {
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[num_chl-1].lc_id = rlc_dl_log_chl_id;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[num_chl-1].lc_type = UE_LOGCHAN_BCCH;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.dl_tm_act[num_chl-1].action = RLC_ESTABLISH;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.dl_tm_act[num_chl-1].act_incl = FALSE;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[num_chl-1].seg_ind = FALSE;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[num_chl-1].rb_id = BCCH_N_RADIO_BEARER_ID;
    }
    else
    {
      WRRC_MSG1_ERROR("Number of DL TM Log Chl %d", num_chl);
      return(FAILURE);
    }

    /* Update MAC data in Downlink */
    /* Update the bcch_id for neighbor while serving cell BCCH is kept as it is */
    /* By this point, the num_bchs in MAC Downlink Parameters should have been
     * updated. When a neighbor is added, a Serving BCH (if present before) shall
     * be dropped. Use num_bch  to access bch_info[]
     */
    /*Fixing the Array Out of Bound Error from KW*/
    if((config_ptr->mac_dl_parms.num_bchs != 0) && 
      (config_ptr->mac_dl_parms.num_bchs <= MAC_DL_MAX_CCTRCH))
    {
      config_ptr->mac_dl_parms.
        bch_info[config_ptr->mac_dl_parms.num_bchs-1].bcch_id =
      rlc_dl_log_chl_id;
    }
    else
    {
      WRRC_MSG0_ERROR("Num BCHs is 0");
      return(FAILURE);
    }
  } /* Valid Logical channel ID allocated */
  else
  {
    WRRC_MSG0_ERROR("Could not get Log Chl for neighbor BCCH");
    return(FAILURE);
  }

  return(SUCCESS);
} /* rrcllc_process_add_bcch_neighbor */


/*====================================================================
FUNCTION: rrcllc_process_reconfig_bcch_neighbor()

DESCRIPTION:
  This function updates Ordered Config data structures and LLC internal
  data (rrcllc_cmd_under_process) on addition of neighbor BCCH.

DEPENDENCIES:
  None
RETURN VALUE:
  Status
    SUCCESS:  All data structures needed to reconfig neighbor BCCH
              updated successfully.
    FAILURE:  Failure to get LC to be reconfigured or nm_bch is 
              equal to 0
SIDE EFFECTS:
  None.
====================================================================*/
static uecomdef_status_e_type
rrcllc_process_reconfig_bcch_neighbor(ordered_config_type *config_ptr)
{
  /* RLC downlink logical channel ID */
  rlc_lc_id_type        rlc_dl_log_chl_id;

  WRRC_MSG0_HIGH("RECONFIG NEIGHBOR BCCH");

  /* Get the LC id of N_BCCH */
  rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id
  (
    UE_LOGCHAN_BCCH,
    BCCH_N_RADIO_BEARER_ID,
    UE_MODE_TRANSPARENT
  );

  if(rlc_dl_log_chl_id != RRCLCM_RLC_LC_ID_NOT_FOUND)
  {
    /* Note: No need to actually reconfigure the BCCH since all BCCH
     * parameters are pre-defined. Just update the logical channel ID in
     * MAC at this point
     * Update the bcch_id for neighbor 
     * By this point, the num_bchs in MAC Downlink Parameters should have been
     * updated. When a neighbor is added, a Serving BCH (if present before) shall
     * be dropped. Use num_bch  to access bch_info[]
     */
    /*Fixing the Array Out of Bound Error from KW*/     
    if((config_ptr->mac_dl_parms.num_bchs != 0) &&
      (config_ptr->mac_dl_parms.num_bchs <= MAC_DL_MAX_CCTRCH))
    {
      config_ptr->mac_dl_parms.
        bch_info[config_ptr->mac_dl_parms.num_bchs-1].bcch_id =
        rlc_dl_log_chl_id;
    }
    else
    {
      WRRC_MSG0_ERROR("Num BCHs is 0");
      return(FAILURE);
    }
  } /* */
  else
  {
    WRRC_MSG0_ERROR("Could not get Log Chl for neighbor BCCH");
    return(FAILURE);
  }

  return(SUCCESS);
} /* rrcllc_process_reconfig_bcch_neighbor */


/*====================================================================
FUNCTION: rrcllc_process_drop_bcch_neighbor()

DESCRIPTION:
  This function updates Ordered Config data structures and LLC internal
  data (rrcllc_cmd_under_process) on release of a Neighbor BCCH.
  Note that both the Uplink and Downlink data structures are updated.

DEPENDENCIES:
  None
RETURN VALUE:
  Status
    SUCCESS: All data structures needed to release BCCH
             updated successfully.
    FAILURE: failure to allocate resources or detection of
             an invalid value in data structures.
SIDE EFFECTS:
  None.
====================================================================*/
static uecomdef_status_e_type
rrcllc_process_drop_bcch_neighbor(void)
{
  uint8   num_chl;
  /* RLC downlink logical channel ID */
  rlc_lc_id_type    rlc_dl_log_chl_id;


  WRRC_MSG0_HIGH("DROP NEIGHBOR BCCH");
  rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id(UE_LOGCHAN_BCCH,
                                                BCCH_N_RADIO_BEARER_ID,
                                                UE_MODE_TRANSPARENT);
  if(rlc_dl_log_chl_id == RRCLCM_RLC_LC_ID_NOT_FOUND)
  {
    WRRC_MSG0_ERROR("Log Chl ID for BCCH_N does NOT exist in LCM");
    return(FAILURE);
  }

  rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.nchan ++;
  num_chl = rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.nchan;
  if(num_chl < UE_MAX_DL_TM_CHANNEL)
  {
    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[num_chl-1].lc_id = rlc_dl_log_chl_id;
    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[num_chl-1].lc_type = UE_LOGCHAN_BCCH;
    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.dl_tm_act[num_chl-1].action = RLC_RELEASE;
    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[num_chl-1].rb_id = BCCH_N_RADIO_BEARER_ID;
  }
  else
  {
    WRRC_MSG1_ERROR("Number of DL TM Log Chl %d", num_chl);
    return(FAILURE);
  }

  return(SUCCESS);
} /* rrcllc_process_drop_bcch_neighbor */


/*====================================================================
FUNCTION: rrcllc_process_add_bcch_serving()

DESCRIPTION:
  This function updates Ordered Config data structures and LLC internal
  data (rrcllc_cmd_under_process) on addition of a BCCH.

DEPENDENCIES:
  None
RETURN VALUE:
  Status
    SUCCESS:  All data structures needed to establish BCCH
              updated successfully.
    FAILURE:  Failure to allocate resources or detection of
              an invalid value in data structures.
SIDE EFFECTS:
  None.
====================================================================*/
static uecomdef_status_e_type
rrcllc_process_add_bcch_serving(ordered_config_type *config_ptr)
{
  /* RLC downlink logical channel ID */
  rlc_lc_id_type        rlc_dl_log_chl_id;
  /* DL watermark pointer assigned for logical channel */
  dsm_watermark_type    *dl_log_chl_queue;

  uint8   num_chl;

  WRRC_MSG0_HIGH("ADD SERVING BCCH");
  /* Allocate a downlink logical channel ID */
  rlc_dl_log_chl_id = rrclcm_allocate_dl_rlc_lc_id
  (
    UE_LOGCHAN_BCCH,
    BCCH_S_RADIO_BEARER_ID,
    UE_MODE_TRANSPARENT,
    &dl_log_chl_queue
  );

  /* Check if able to successfully allocate DL logical channel ID */
  if(rlc_dl_log_chl_id != RRCLCM_RLC_LC_ID_ERROR)
  {
    /* 2. NOW UPDATE RLC AND MAC ORDERD CONFIG DATA STRUCTURES */

    /* Update RLC Downlink TM channel data */
    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.nchan ++;
    /* Update the count in Ordered Config also */
    config_ptr->rlc_dl_tm_parms.nchan ++;

    num_chl = rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.nchan;

    if(num_chl < UE_MAX_DL_TM_CHANNEL)
    {
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[num_chl-1].lc_id = rlc_dl_log_chl_id;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[num_chl-1].lc_type = UE_LOGCHAN_BCCH;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.dl_tm_act[num_chl-1].action = RLC_ESTABLISH;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.dl_tm_act[num_chl-1].act_incl = FALSE;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[num_chl-1].seg_ind = FALSE;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[num_chl-1].rb_id = BCCH_S_RADIO_BEARER_ID;
    }
    else
    {
      WRRC_MSG1_ERROR("Number of DL TM Log Chl %d", num_chl);
      return(FAILURE);
    }

    /* Update MAC data in Downlink */
    /* Since the S_PCCPCH shall not be added when a Neighbor BCH is up,
     * we can safely presume that only the Serving BCH is up at this time, ie
     * the num_bch in MAC Downlink Parms should be 1
     */
    /*Fixing the Array Out of Bound Error from KW*/     
    if((config_ptr->mac_dl_parms.num_bchs != 0) &&
      (config_ptr->mac_dl_parms.num_bchs <= MAC_DL_MAX_CCTRCH))
    {
      config_ptr->mac_dl_parms.
        bch_info[config_ptr->mac_dl_parms.num_bchs -1].bcch_id =
      rlc_dl_log_chl_id;
    }
    else
    {
/*lint -save -e793 */
      if(rlc_dl_log_chl_id != RRCLCM_RLC_LC_ID_ERROR)
      {
        WRRC_MSG1_HIGH("DBG_GPS_CELL_ID: Deallocating the lc id %d",
                  rlc_dl_log_chl_id);
        rrclcm_deallocate_dl_rlc_lc_id(rlc_dl_log_chl_id);
      }
      WRRC_MSG0_ERROR("Num BCHs is Zero");
/*lint -restore */
      return(FAILURE);
    }
  } /* Valid Logical channel ID allocated */
  else
  {
    WRRC_MSG0_ERROR("Could not get Log Chl for BCCH");
    return(FAILURE);
  }

  return(SUCCESS);
} /* rrcllc_process_add_bcch_serving */


/*====================================================================
FUNCTION: rrcllc_process_reconfig_bcch_serving()

DESCRIPTION:
  This function updates Ordered Config data structures and LLC internal
  data (rrcllc_cmd_under_process) on addition of a BCCH.

DEPENDENCIES:
  None
RETURN VALUE:
  Status
    SUCCESS:  All data structures needed to reconfig neighbor BCCH
              updated successfully.
    FAILURE:  Failure to get LC to be reconfigured or nm_bch is 
              equal to 0  
SIDE EFFECTS:
  None.
====================================================================*/
static uecomdef_status_e_type
rrcllc_process_reconfig_bcch_serving(ordered_config_type *config_ptr)
{
  /* RLC downlink logical channel ID */
  rlc_lc_id_type        rlc_dl_log_chl_id;


  WRRC_MSG0_HIGH("RECONFIG SERVING BCCH");
  /* Allocate a downlink logical channel ID */
  rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id
  (
    UE_LOGCHAN_BCCH,
    BCCH_S_RADIO_BEARER_ID,
    UE_MODE_TRANSPARENT
  );


  if(rlc_dl_log_chl_id != RRCLCM_RLC_LC_ID_NOT_FOUND)
  {
    /* Note: No need to actually reconfigure the BCCH since all BCCH
     * parameters are pre-defined. Just update the logical channel ID in
     * MAC at this point
     * Update the bcch_id for neighbor 
     * By this point, the num_bchs in MAC Downlink Parameters should have been
     * updated. When a neighbor is added, a Serving BCH (if present before) shall
     * be dropped. Use num_bch  to access bch_info[]
     */
    /*Fixing the Array Out of Bound Error from KW*/     
    if((config_ptr->mac_dl_parms.num_bchs != 0) &&
      (config_ptr->mac_dl_parms.num_bchs <= MAC_DL_MAX_CCTRCH))
    {
      config_ptr->mac_dl_parms.
        bch_info[config_ptr->mac_dl_parms.num_bchs-1].bcch_id =
        rlc_dl_log_chl_id;
    }
    else
    {
      WRRC_MSG0_ERROR("Num BCHs is 0");
      return(FAILURE);
    }
  } /* */
  else
  {
    WRRC_MSG0_ERROR("Could not get Log Chl for neighbor BCCH");
    return(FAILURE);
  }
 
  return(SUCCESS);
} /* rrcllc_process_reconfig_bcch_serving */

/*====================================================================
FUNCTION: rrcllc_process_drop_bcch_serving()

DESCRIPTION:
  This function updates Ordered Config data structures and LLC internal
  data (rrcllc_cmd_under_process) on release of a Serving BCCH.
  Note that both the Uplink and Downlink data structures are updated.

DEPENDENCIES:
  None
RETURN VALUE:
  Status
    SUCCESS: All data structures needed to release BCCH
             updated successfully.
    FAILURE: failure to allocate resources or detection of
             an invalid value in data structures.
SIDE EFFECTS:
  None.
====================================================================*/
static uecomdef_status_e_type
rrcllc_process_drop_bcch_serving(void)
{
  uint8   num_chl;
  /* RLC downlink logical channel ID */
  rlc_lc_id_type    rlc_dl_log_chl_id;

  WRRC_MSG0_HIGH("DROP BCCH SERVING");

  rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id(UE_LOGCHAN_BCCH,
                                                BCCH_S_RADIO_BEARER_ID,
                                                UE_MODE_TRANSPARENT);
  if(rlc_dl_log_chl_id == RRCLCM_RLC_LC_ID_NOT_FOUND)
  {
    WRRC_MSG0_ERROR("Log Chl ID for BCCH_S does NOT exist in LCM");
    return(FAILURE);
  }

  rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.nchan ++;
  num_chl = rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.nchan;
  if(num_chl < UE_MAX_DL_TM_CHANNEL)
  {
    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[num_chl-1].lc_id = rlc_dl_log_chl_id;
    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[num_chl-1].lc_type = UE_LOGCHAN_BCCH;
    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.dl_tm_act[num_chl-1].action = RLC_RELEASE;
    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[num_chl-1].rb_id = BCCH_S_RADIO_BEARER_ID;

  }
  else
  {
    WRRC_MSG1_ERROR("Number of DL TM Log Chl %d", num_chl);
    return(FAILURE);
  }

  return(SUCCESS);
} /* rrcllc_process_drop_bcch */




/*====================================================================
FUNCTION: rrcllc_process_add_ctch()

DESCRIPTION:
  This function updates Ordered Config data structures and LLC internal
  data (rrcllc_cmd_under_process) on addition of a ctch.
  Note that both the Uplink and Downlink data structures are updated.

DEPENDENCIES:
  None
RETURN VALUE:
  Status
    SUCCESS: All data structures needed to release CTCH
             updated successfully.
    FAILURE: failure to allocate resources or detection of
             an invalid value in data structures.
SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type  rrcllc_process_add_ctch(void)
{

  uint8   num_chl;
  uint32   i;
  /* RLC downlink logical channel ID */
  rlc_lc_id_type        rlc_dl_log_chl_id;
  /* DL watermark pointer assigned for logical channel */
  dsm_watermark_type    *dl_log_chl_queue;

  ordered_config_type *config_ptr;

  WRRC_MSG0_HIGH("Adding CTCH");
  if(rrcllc_cmd_under_process.chan_config.current_cmd_engine == LLC_CELL_RESELECTION_ENGINE)
  {
    config_ptr = reselection_config_ptr;
  }
  else
  {
    config_ptr = ordered_config_ptr;
  }
  /* Allocate a downlink logical channel ID */
  rlc_dl_log_chl_id = rrclcm_allocate_dl_rlc_lc_id
  (
    UE_LOGCHAN_CTCH,
    CTCH_RADIO_BEARER_ID,
    UE_MODE_UNACKNOWLEDGED,
    &dl_log_chl_queue
  );

  /* Check if able to successfully allocate DL logical channel ID */
  if(rlc_dl_log_chl_id != RRCLCM_RLC_LC_ID_ERROR)
  {
    /* Update RLC Downlink UM channel data */
    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.nchan ++;

    num_chl = rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.nchan;

    if(num_chl < UE_MAX_DL_UM_CHANNEL)
    {
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[num_chl-1].lc_id = rlc_dl_log_chl_id;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[num_chl-1].lc_type = UE_LOGCHAN_CTCH;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.dl_um_act[num_chl-1].action = RLC_ESTABLISH;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.dl_um_act[num_chl-1].act_incl = FALSE;
            /* Get RLC size from Ordered Config */
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[num_chl-1].rlc_size =
        rrcllc_get_ctch_rlc_size();
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[num_chl-1].rb_id = CTCH_RADIO_BEARER_ID;		

      /* Also update the count in Ordered Config */
      if(get_rlc_dl_um_info(CTCH_RADIO_BEARER_ID, TRUE, config_ptr) == FAILURE)
      {
        WRRC_MSG0_ERROR("Config DB could not be updated for DL UM RB CTCH_RADIO_BEARER_ID");
        return(FAILURE);		
      }			
    }
    else
    {
      WRRC_MSG1_ERROR("Number of DL UM Log Chl %d", num_chl);
      return(FAILURE);
    }

    /* Update MAC data in Downlink */
    /* PS need to revisit this part. need to find out the fach_info index that is used for CTCH
    */
    for(i = 0; i < config_ptr->mac_dl_parms.num_fachs; i ++)
    {
      config_ptr->mac_dl_parms.fach_info[i]->ccch_enable = FALSE;
      config_ptr->mac_dl_parms.fach_info[i]->ctch_id = rlc_dl_log_chl_id;
    }

  } /* Logical Channel ID was allocated */
  else
  {
    WRRC_MSG0_ERROR("Could not get Log Chl for CTCH");
    return(FAILURE);
  }

  return(SUCCESS);
} /* rrcllc_process_add_CTCH */
/*====================================================================
FUNCTION: rrcllc_process_reconfig_ctch()

DESCRIPTION:
  This function prepares a command to reconfigure CTCH. It gets the
  logical channel ID already allocated for CTCH and updates MAC data
  structure in Ordered Config with that ID.

DEPENDENCIES:
  None
RETURN VALUE:
  Status
    SUCCESS: All data structures needed to reconfig CTCH
             updated successfully.
    FAILURE: failure to allocate resources or detection of
             an invalid value in data structures.
SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type  rrcllc_process_reconfig_ctch(void)
{
  /* RLC downlink logical channel ID */
  rlc_lc_id_type  rlc_dl_log_chl_id;
  int             i;

  ordered_config_type *config_ptr;

  WRRC_MSG0_HIGH("Reconfiguring CTCH");
  if(rrcllc_cmd_under_process.chan_config.current_cmd_engine == LLC_CELL_RESELECTION_ENGINE)
  {
    config_ptr = reselection_config_ptr;
  }
  else
  {
    config_ptr = ordered_config_ptr;
  }

  /* Get the downlink logical channel ID already allocated to PCCH */
  rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id
  (
    UE_LOGCHAN_CTCH,
    CTCH_RADIO_BEARER_ID,
    UE_MODE_UNACKNOWLEDGED
  );

  /* Check if able to successfully allocate DL logical channel ID */
  if(rlc_dl_log_chl_id != RRCLCM_RLC_LC_ID_ERROR)
  {
    /* Note: No need to actually reconfigure the PCCH since all PCCH
     * parameters are pre-defined. Just update the logical channel ID in
     * MAC at this point
     */
    /* Update MAC data in Downlink */
    for(i = 0; i < config_ptr->mac_dl_parms.num_fachs; i ++)
    {
      //config_ptr->mac_dl_parms.fach_info[i]->ctch_enable = TRUE;
      config_ptr->mac_dl_parms.fach_info[i]->ccch_enable = FALSE;
      config_ptr->mac_dl_parms.fach_info[i]->ctch_id = rlc_dl_log_chl_id;
    }
  } /* Logical Channel ID was allocated */
  else
  {
    WRRC_MSG0_ERROR("Could not get Log Chl for CTCH");
    return(FAILURE);
  }

  return(SUCCESS);
} /* rrcllc_process_reconfig_ctch */


/*====================================================================
FUNCTION: rrcllc_process_drop_ctch()

DESCRIPTION:
  This function updates Ordered Config data structures and LLC internal
  data (rrcllc_cmd_under_process) on release of a CTCH.
  Note that both the Uplink and Downlink data structures are updated.

DEPENDENCIES:
  None
RETURN VALUE:
  Status
    SUCCESS: All data structures needed to release CTCH
             updated successfully.
    FAILURE: failure to allocate resources or detection of
             an invalid value in data structures.
SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type  rrcllc_process_drop_ctch(void)
{
  uint8   num_chl;
  uint32   i;
  /* RLC downlink logical channel ID */
  rlc_lc_id_type    rlc_dl_log_chl_id;
  ordered_config_type *config_ptr;

  WRRC_MSG0_HIGH("Drop CTCH");

  if(rrcllc_cmd_under_process.chan_config.current_cmd_engine == LLC_CELL_RESELECTION_ENGINE)
  {
    config_ptr = reselection_config_ptr;
  }
  else
  {
    config_ptr = ordered_config_ptr;
  }

  rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id(UE_LOGCHAN_CTCH,
                                                CTCH_RADIO_BEARER_ID,
                                                UE_MODE_UNACKNOWLEDGED);
  if(rlc_dl_log_chl_id == RRCLCM_RLC_LC_ID_NOT_FOUND)
  {
    WRRC_MSG0_ERROR("Log Chl ID for CTCH does NOT exist in LCM");
    return(FAILURE);
  }

  rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.nchan ++;
  num_chl = rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.nchan;
  if(num_chl < UE_MAX_DL_UM_CHANNEL)
  {
    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[num_chl-1].lc_id = rlc_dl_log_chl_id;
    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[num_chl-1].lc_type = UE_LOGCHAN_CTCH;
    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.dl_um_act[num_chl-1].action = RLC_RELEASE;
    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[num_chl-1].rb_id =CTCH_RADIO_BEARER_ID;

  }
  else
  {
    WRRC_MSG1_ERROR("Number of DL UM Log Chl %d", num_chl);
    return(FAILURE);
  }

  /* Set CCCH enable in FACH info to FALSE */
  for(i = 0; i < config_ptr->mac_dl_parms.num_fachs; i ++)
  {
    config_ptr->mac_dl_parms.fach_info[i]->ctch_enable = FALSE;
  }

  /* Set CCCH enable in FACH info to FALSE */
  rrcllc_init_cbs_info(config_ptr);
  
  return(SUCCESS);
} /* rrcllc_process_drop_pcch */

/*====================================================================
FUNCTION: rrcllc_clean_ctch_on_phy_channel_failure()

DESCRIPTION:
  This function updates CTCH variables in LCM database and Semi permanent data when physical
  channel setup failure happens

DEPENDENCIES:
  None
RETURN VALUE:
  None
SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_clean_ctch_on_phy_channel_failure(void)
{

  rlc_lc_id_type    rlc_dl_log_chl_id = RRCLCM_RLC_LC_ID_NOT_FOUND;
  int i;
  
  if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_action ==LLC_PHYCHAN_SETUP ||
      rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_action ==LLC_PHYCHAN_RECONFIG)
  {
    if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_for_ctch_action ==LLC_PHYCHAN_SETUP)
    {
      if(rrcllc_clear_cctrch_id(rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.cctrch_id)
          == FAILURE)
      {
        WRRC_MSG1_ERROR("CCTrCH ID %d for CTCH on SCCPCH not cleared",
              rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.cctrch_id);
      } /* If could not clear CCTrCH ID */
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch_is_up = FALSE;
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_ref_type_bf = 0;
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_enable_bf = 0;
    }
    if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_action ==LLC_PHYCHAN_SETUP &&
        rrcllc_semi_permanent_data.dl_phy_chan.ctch_status == RRCLLC_CTCH_WITH_PCCH)
    {
      rrcllc_semi_permanent_data.dl_phy_chan.ctch_status = RRCLLC_NO_CTCH;
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf &=~L1_DL_TRCH_REFTYPE_FACH_BF;
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf &=~L1_DL_TRCH_REFTYPE_FACH_BF;
    }
    rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id(UE_LOGCHAN_CTCH,
                                                  CTCH_RADIO_BEARER_ID,
                                                  UE_MODE_UNACKNOWLEDGED);
    
    if (rlc_dl_log_chl_id != RRCLCM_RLC_LC_ID_NOT_FOUND) 
    {
      for (i = 0; i < rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.nchan; i++) 
      {
        if ((rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[i].lc_id == rlc_dl_log_chl_id)&&
            (rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[i].lc_type == UE_LOGCHAN_CTCH) &&
            (rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.dl_um_act[i].action ==  RLC_ESTABLISH)) 
        {
          WRRC_MSG0_HIGH("Rel Log Chl for CTCH");
          (void)rrclcm_deallocate_dl_rlc_lc_id(rlc_dl_log_chl_id);
          if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_action ==LLC_PHYCHAN_RECONFIG)
          {
            rrcllc_semi_permanent_data.dl_phy_chan.ctch_status = RRCLLC_NO_CTCH;
            rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf &=~L1_DL_TRCH_REFTYPE_FACH_BF;
            rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf &=~L1_DL_TRCH_REFTYPE_FACH_BF;
          }
          break;
        }
      }
    }
  }
}


/*====================================================================
FUNCTION: rrcllc_process_add_pcch()

DESCRIPTION:
  This function updates Ordered Config data structures and LLC internal
  data (rrcllc_cmd_under_process) on addition of a PCCH.
  Note that both the Uplink and Downlink data structures are updated.

DEPENDENCIES:
  None
RETURN VALUE:
  Status
    SUCCESS: All data structures needed to release PCCH
             updated successfully.
    FAILURE: failure to allocate resources or detection of
             an invalid value in data structures.
SIDE EFFECTS:
  None.
====================================================================*/
static uecomdef_status_e_type  rrcllc_process_add_pcch(void)
{

  uint8   num_chl;
  /* RLC downlink logical channel ID */
  rlc_lc_id_type        rlc_dl_log_chl_id;
  /* DL watermark pointer assigned for logical channel */
  dsm_watermark_type    *dl_log_chl_queue;

  WRRC_MSG0_HIGH("Adding PCCH");
  /* Allocate a downlink logical channel ID */
  rlc_dl_log_chl_id = rrclcm_allocate_dl_rlc_lc_id
  (
    UE_LOGCHAN_PCCH,
    PCCH_RADIO_BEARER_ID,
    UE_MODE_TRANSPARENT,
    &dl_log_chl_queue
  );

  /* Check if able to successfully allocate DL logical channel ID */
  if(rlc_dl_log_chl_id != RRCLCM_RLC_LC_ID_ERROR)
  {
    /* Update RLC Downlink TM channel data */
    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.nchan ++;
    /* Also update the count in Ordered Config */
    ordered_config_ptr->rlc_dl_tm_parms.nchan ++;

    num_chl = rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.nchan;

    if(num_chl < UE_MAX_DL_TM_CHANNEL)
    {
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[num_chl-1].lc_id = rlc_dl_log_chl_id;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[num_chl-1].lc_type = UE_LOGCHAN_PCCH;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.dl_tm_act[num_chl-1].action = RLC_ESTABLISH;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.dl_tm_act[num_chl-1].act_incl = FALSE;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[num_chl-1].seg_ind = FALSE;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[num_chl-1].rb_id = PCCH_RADIO_BEARER_ID;
    }
    else
    {
      WRRC_MSG1_ERROR("Number of DL TM Log Chl %d", num_chl);
      return(FAILURE);
    }

    /* Update MAC data in Downlink */
    ordered_config_ptr->mac_dl_parms.pch_info->pcch_id = rlc_dl_log_chl_id;

  } /* Logical Channel ID was allocated */
  else
  {
    WRRC_MSG0_ERROR("Could not get Log Chl for PCCH");
    return(FAILURE);
  }

  return(SUCCESS);
} /* rrcllc_process_add_pcch */


/*====================================================================
FUNCTION: rrcllc_process_add_bcch_on_fach

DESCRIPTION:

DEPENDENCIES:
  None
RETURN VALUE:
  Status

SIDE EFFECTS:
  None.
====================================================================*/
static uecomdef_status_e_type  rrcllc_process_add_bcch_on_fach(void)
{

  uint8   num_chl, i;
  /* RLC downlink logical channel ID */
  rlc_lc_id_type        rlc_dl_log_chl_id;
  /* DL watermark pointer assigned for logical channel */
  dsm_watermark_type    *dl_log_chl_queue;


  /* Allocate a downlink logical channel ID */
  rlc_dl_log_chl_id = rrclcm_allocate_dl_rlc_lc_id
  (
    UE_LOGCHAN_BCCH,
    BCCH_FACH_RADIO_BEARER_ID,
    UE_MODE_TRANSPARENT,
    &dl_log_chl_queue
  );

  /* Check if able to successfully allocate DL logical channel ID */
  if(rlc_dl_log_chl_id != RRCLCM_RLC_LC_ID_ERROR)
  {
    WRRC_MSG0_HIGH("Bcch-Fach setup");

    /* Update RLC Downlink TM channel data */
    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.nchan ++;
    /* Also update the count in Ordered Config */
    ordered_config_ptr->rlc_dl_tm_parms.nchan ++;

    num_chl = rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.nchan;

    if(num_chl < UE_MAX_DL_TM_CHANNEL)
    {
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[num_chl-1].lc_id = rlc_dl_log_chl_id;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[num_chl-1].lc_type = UE_LOGCHAN_BCCH;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.dl_tm_act[num_chl-1].action = RLC_ESTABLISH;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.dl_tm_act[num_chl-1].act_incl = FALSE;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[num_chl-1].seg_ind = FALSE;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[num_chl-1].rb_id = BCCH_FACH_RADIO_BEARER_ID;
    }
    else
    {
      WRRC_MSG1_ERROR("Number of DL TM Log Chl %d", num_chl);
      return(FAILURE);
    }

#ifdef FEATURE_WCDMA_HS_FACH
    if(rrcllc_get_hs_status_in_e_fach(ordered_config_ptr) == FALSE)
#endif
    {
      for(i = 0; i < ordered_config_ptr->mac_dl_parms.num_fachs; i ++)
      {
        ordered_config_ptr->mac_dl_parms.fach_info[i]->bcch_enable = TRUE;
        ordered_config_ptr->mac_dl_parms.fach_info[i]->bcch_id = rlc_dl_log_chl_id;
      }
    }
  } /* Logical Channel ID was allocated */
  else
  {
    WRRC_MSG0_ERROR("Log Chl for BCCH_FACH failed");
    return(FAILURE);
  }

  return(SUCCESS);
} /* rrcllc_process_add_bcch_on_fach */


/*====================================================================
FUNCTION: rrcllc_process_reconfig_bcch_on_fach

DESCRIPTION:

DEPENDENCIES:
  None
RETURN VALUE:
  Status

SIDE EFFECTS:
  None.
====================================================================*/
static uecomdef_status_e_type  rrcllc_process_reconfig_bcch_on_fach(void)
{

  uint8   num_chl, i;
  /* RLC downlink logical channel ID */
  rlc_lc_id_type        rlc_dl_log_chl_id;


  /* Allocate a downlink logical channel ID */
  rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id
  (
    UE_LOGCHAN_BCCH,
    BCCH_FACH_RADIO_BEARER_ID,
    UE_MODE_TRANSPARENT
  );

  /* Check if able to successfully allocate DL logical channel ID */
  if(rlc_dl_log_chl_id != RRCLCM_RLC_LC_ID_ERROR)
  {
    WRRC_MSG0_HIGH("Bcch-Fach reconfig");

    /* Update RLC Downlink TM channel data */
    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.nchan ++;
    /* Also update the count in Ordered Config */
    ordered_config_ptr->rlc_dl_tm_parms.nchan ++;

    num_chl = rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.nchan;

    if(num_chl < UE_MAX_DL_TM_CHANNEL)
    {
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[num_chl-1].lc_id = rlc_dl_log_chl_id;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[num_chl-1].lc_type = UE_LOGCHAN_BCCH;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.dl_tm_act[num_chl-1].action = RLC_MODIFY;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.dl_tm_act[num_chl-1].ul_cfg_mask = 0;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.dl_tm_act[num_chl-1].dl_cfg_mask = RLC_MODIFY_CFG;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.dl_tm_act[num_chl-1].act_incl = FALSE;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[num_chl-1].seg_ind = FALSE;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[num_chl-1].rb_id = BCCH_FACH_RADIO_BEARER_ID;
    }
    else
    {
      WRRC_MSG1_ERROR("Number of DL TM Log Chl %d", num_chl);
      return(FAILURE);
    }

#ifdef FEATURE_WCDMA_HS_FACH
    if(rrcllc_get_hs_status_in_e_fach(ordered_config_ptr) == FALSE)
#endif
    {
      for(i = 0; i < ordered_config_ptr->mac_dl_parms.num_fachs; i ++)
      {
        ordered_config_ptr->mac_dl_parms.fach_info[i]->bcch_enable = TRUE;
        ordered_config_ptr->mac_dl_parms.fach_info[i]->bcch_id = rlc_dl_log_chl_id;
      }
    }
  } /* Logical Channel ID was allocated */
  else
  {
    WRRC_MSG0_ERROR("Log Chl for BCCH_FACH failed");
    return(FAILURE);
  }

  return(SUCCESS);
} /* rrcllc_process_reconfig_bcch_on_fach */

/*====================================================================
FUNCTION: rrcllc_process_reconfig_pcch()

DESCRIPTION:
  This function prepares a command to reconfigure PCCH. It gets the
  logical channel ID already allocated for PCCH and updates MAC data
  structure in Ordered Config with that ID.

DEPENDENCIES:
  None
RETURN VALUE:
  Status
    SUCCESS: All data structures needed to release PCCH
             updated successfully.
    FAILURE: failure to allocate resources or detection of
             an invalid value in data structures.
SIDE EFFECTS:
  None.
====================================================================*/
static uecomdef_status_e_type  rrcllc_process_reconfig_pcch(void)
{
  /* RLC downlink logical channel ID */
  rlc_lc_id_type        rlc_dl_log_chl_id;

  WRRC_MSG0_HIGH("Reconfiguring PCCH");
  /* Get the downlink logical channel ID already allocated to PCCH */
  rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id
  (
    UE_LOGCHAN_PCCH,
    PCCH_RADIO_BEARER_ID,
    UE_MODE_TRANSPARENT
  );

  /* Check if able to successfully allocate DL logical channel ID */
  if(rlc_dl_log_chl_id != RRCLCM_RLC_LC_ID_ERROR)
  {
    /* Note: No need to actually reconfigure the PCCH since all PCCH
     * parameters are pre-defined. Just update the logical channel ID in
     * MAC at this point
     */
    /* Update MAC data in Downlink */
    if(rrcllc_cmd_under_process.chan_config.current_cmd_engine == LLC_CELL_RESELECTION_ENGINE)
    {
      reselection_config_ptr->mac_dl_parms.pch_info->pcch_id = rlc_dl_log_chl_id;
    }
    else
    {
      ordered_config_ptr->mac_dl_parms.pch_info->pcch_id = rlc_dl_log_chl_id;
    }

  } /* Logical Channel ID was allocated */
  else
  {
    WRRC_MSG0_ERROR("Could not get Log Chl for PCCH");
    return(FAILURE);
  }

  return(SUCCESS);
} /* rrcllc_process_reconfig_pcch */

/*====================================================================
FUNCTION: rrcllc_process_drop_pcch()

DESCRIPTION:
  This function updates Ordered Config data structures and LLC internal
  data (rrcllc_cmd_under_process) on release of a PCCH.
  Note that both the Uplink and Downlink data structures are updated.

DEPENDENCIES:
  None
RETURN VALUE:
  Status
    SUCCESS: All data structures needed to release PCCH
             updated successfully.
    FAILURE: failure to allocate resources or detection of
             an invalid value in data structures.
SIDE EFFECTS:
  None.
====================================================================*/
static uecomdef_status_e_type  rrcllc_process_drop_pcch(void)
{
  uint8   num_chl;

  /* RLC downlink logical channel ID */
  rlc_lc_id_type    rlc_dl_log_chl_id;

  WRRC_MSG0_HIGH("Dropping PCCH");
  rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id(UE_LOGCHAN_PCCH,
                                                PCCH_RADIO_BEARER_ID,
                                                UE_MODE_TRANSPARENT);
  if(rlc_dl_log_chl_id == RRCLCM_RLC_LC_ID_NOT_FOUND)
  {
    WRRC_MSG0_ERROR("Log Chl ID for PCCH does NOT exist in LCM");
    return(FAILURE);
  }

  rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.nchan ++;
  num_chl = rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.nchan;
  if(num_chl < UE_MAX_DL_TM_CHANNEL)
  {
    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[num_chl-1].lc_id = rlc_dl_log_chl_id;
    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[num_chl-1].lc_type = UE_LOGCHAN_PCCH;
    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.dl_tm_act[num_chl-1].action = RLC_RELEASE;
    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[num_chl-1].rb_id = PCCH_RADIO_BEARER_ID;
  }
  else
  {
    WRRC_MSG1_ERROR("Number of DL TM Log Chl %d", num_chl);
    return(FAILURE);
  }

  return(SUCCESS);
} /* rrcllc_process_drop_pcch */

/*====================================================================
FUNCTION: rrcllc_process_drop_bcch_on_fach()

DESCRIPTION:

DEPENDENCIES:
  None
RETURN VALUE:
  Status

SIDE EFFECTS:
  None.
====================================================================*/
static uecomdef_status_e_type  rrcllc_process_drop_bcch_on_fach(void)
{
  uint8   num_chl;

  /* RLC downlink logical channel ID */
  rlc_lc_id_type    rlc_dl_log_chl_id;

  rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id(UE_LOGCHAN_BCCH,
                                                BCCH_FACH_RADIO_BEARER_ID,
                                                UE_MODE_TRANSPARENT);

  if(rlc_dl_log_chl_id == RRCLCM_RLC_LC_ID_NOT_FOUND)
  {
    WRRC_MSG0_ERROR("Log-Chl-ID BCCH-FACH does NOT exist in LCM");
    return(FAILURE);
  }

  rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.nchan ++;
  num_chl = rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.nchan;
  if(num_chl < UE_MAX_DL_TM_CHANNEL)
  {
    WRRC_MSG0_MED("Bcch-Fach released");
    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[num_chl-1].lc_id = rlc_dl_log_chl_id;
    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[num_chl-1].lc_type = UE_LOGCHAN_BCCH;
    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.dl_tm_act[num_chl-1].action = RLC_RELEASE;
    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[num_chl-1].rb_id =BCCH_FACH_RADIO_BEARER_ID;
  }
  else
  {
    WRRC_MSG1_ERROR("Number of DL TM Log Chl %d", num_chl);
    return(FAILURE);
  }

  return(SUCCESS);
} /* rrcllc_process_drop_bcch_on_fach */

/*====================================================================
FUNCTION: rrcllc_process_add_ccch()

DESCRIPTION:
  This function updates Ordered Config data structures and LLC internal
  data (rrcllc_cmd_under_process) on addition of a CCCH.
  Note that both the Uplink and Downlink data structures are updated.

DEPENDENCIES:
  None
RETURN VALUE:
  Status
                SUCCESS: All data structures needed to establish CCCH
                updated successfully.
SIDE EFFECTS:
  None.
====================================================================*/
static uecomdef_status_e_type  rrcllc_process_add_ccch(void)
{
  /* RLC Uplink logical channel ID */
  rlc_lc_id_type        rlc_ul_log_chl_id;
  /* RLC downlink logical channel ID */
  rlc_lc_id_type        rlc_dl_log_chl_id;
  /* DL watermark pointer assigned for logical channel */
  dsm_watermark_type    *dl_log_chl_queue;
  /* UL watermark pointer assigned for logical channel */
  dsm_watermark_type    *ul_log_chl_queue;

  uint32   num_chl, i;

  /* Allocate an Uplink logical channel ID */
  rlc_ul_log_chl_id = rrclcm_allocate_ul_rlc_lc_id
  (
    UE_LOGCHAN_CCCH,
    CCCH_RADIO_BEARER_ID,
    UE_MODE_TRANSPARENT,
    &ul_log_chl_queue
  );
  WRRC_MSG0_HIGH("Adding CCCH");

  /* Allocate a downlink logical channel ID */
  rlc_dl_log_chl_id = rrclcm_allocate_dl_rlc_lc_id
  (
    UE_LOGCHAN_CCCH,
    CCCH_RADIO_BEARER_ID,
    UE_MODE_UNACKNOWLEDGED,
    &dl_log_chl_queue
  );

  /* Check if able to successfully allocate UL and DL logical channel IDs */
  if((rlc_ul_log_chl_id != RRCLCM_RLC_LC_ID_ERROR) &&
     (rlc_dl_log_chl_id != RRCLCM_RLC_LC_ID_ERROR))
  {
    /* 2. NOW UPDATE RLC AND MAC ORDERD CONFIG DATA STRUCTURES */
    /* Update RLC Uplink TM channel data */
    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.nchan ++;
    /* Also update the count and logical channel ID in Ordered Config */
    ordered_config_ptr->rlc_ul_tm_parms.chan_info[
      ordered_config_ptr->rlc_ul_tm_parms.nchan].lc_id =
      rlc_ul_log_chl_id;
    ordered_config_ptr->rlc_ul_tm_parms.nchan ++;
    WRRC_MSG1_MED("nchan: Add CCCH UL TM %d after increment",
        ordered_config_ptr->rlc_ul_tm_parms.nchan);

    num_chl = rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.nchan;
    if(num_chl < UE_MAX_UL_TM_CHANNEL)
    {
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.chan_info[num_chl-1].lc_id = rlc_ul_log_chl_id;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.chan_info[num_chl-1].lc_type = UE_LOGCHAN_CCCH;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.ul_tm_act[num_chl-1].action = RLC_ESTABLISH;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.ul_tm_act[num_chl-1].act_incl = FALSE;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.chan_info[num_chl-1].seg_ind = FALSE;
      /* TBD: Interface with OC needed to get timer discard value */
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.chan_info[num_chl-1].timer_discard = 0;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.chan_info[num_chl-1].rb_id = CCCH_RADIO_BEARER_ID;
        
    }
    else
    {
      WRRC_MSG1_ERROR("Number of UL TM Log Chl %d", num_chl);
      return(FAILURE);
    }

    /* Update RLC Downlink UM channel data */
    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.nchan ++;
	
    /* Also update the count and logical channel ID in Ordered Config */
    if(get_rlc_dl_um_info(CCCH_RADIO_BEARER_ID, TRUE, ordered_config_ptr) == FAILURE)
    {
      WRRC_MSG0_ERROR("Config DB could not be updated for DL UM RB CTCH_RADIO_BEARER_ID");
      return(FAILURE);		
    }

    num_chl = rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.nchan;
    if(num_chl < UE_MAX_DL_UM_CHANNEL)
    {
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[num_chl-1].lc_id = rlc_dl_log_chl_id;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[num_chl-1].lc_type = UE_LOGCHAN_CCCH;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.dl_um_act[num_chl-1].action = RLC_ESTABLISH;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.dl_um_act[num_chl-1].act_incl = FALSE;
      /* Get RLC size from Ordered Config */
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[num_chl-1].rlc_size =
        rrcllc_get_dl_um_ccch_rlc_size();
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[num_chl-1].rb_id = CCCH_RADIO_BEARER_ID;
        
      if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
      {
        if (rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[num_chl-1].rlc_size < 1000)
        {
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[num_chl-1].li_size = LI_7_BITS;
        }
        else
        {
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[num_chl-1].li_size = LI_15_BITS;
        }
        WRRC_MSG1_HIGH("RRC:CCCH LI size %d", rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[num_chl-1].li_size);
      }
    }
    else
    {
      WRRC_MSG1_ERROR("Number of DL UM Log Chl %d", num_chl);
      return(FAILURE);
    }

    /* Update MAC Ordered Config data with Logical Channel IDs */

    /* Update MAC data in Uplink */
    ordered_config_ptr->mac_ul_parms.cctrch_ptr->cctrch_type = RACH;
    ordered_config_ptr->mac_ul_parms.cctrch_ptr->rach_info.ccch_enable = TRUE;
    ordered_config_ptr->mac_ul_parms.cctrch_ptr->rach_info.ccch_id = rlc_ul_log_chl_id;
    /* OC sets the number of Dedicated logical channels mapped to RACH to 0 */

    /* Update MAC data in Downlink */
    /* Since all FACHs could be mapped to all RBs, update info for all
     * available FACHs.
     */
    for(i = 0; i < ordered_config_ptr->mac_dl_parms.num_fachs; i ++)
    {
      ordered_config_ptr->mac_dl_parms.fach_info[i]->ccch_enable = TRUE;
      ordered_config_ptr->mac_dl_parms.fach_info[i]->ctch_enable = FALSE;
      ordered_config_ptr->mac_dl_parms.fach_info[i]->ccch_id = rlc_dl_log_chl_id;
    }
    rrcllc_init_cbs_info(ordered_config_ptr);
  } /* Successfully allocated Uplink and Downlink Logical channel IDs */
  else
  {
    WRRC_MSG0_ERROR("Could not get Log Chl for UL/DL CCCH");
    return(FAILURE);
  }

  return(SUCCESS);
} /* rrcllc_process_add_ccch */

/*====================================================================
FUNCTION: rrcllc_process_add_ccch_for_cell_pch_to_cell_fach()

DESCRIPTION:
  This function prepares commands to reconfigure CCCH. It gets the
  logical channel IDs already allocated for CCCH and updates MAC data
  structure in Ordered Config with those IDs.

DEPENDENCIES:
  None
RETURN VALUE:
  Status
                SUCCESS: All data structures needed to establish CCCH
                updated successfully.
SIDE EFFECTS:
  None.
====================================================================*/
static uecomdef_status_e_type  rrcllc_process_add_ccch_for_cell_pch_to_cell_fach(void)
{
  /* RLC Uplink logical channel ID */
  rlc_lc_id_type        rlc_ul_log_chl_id;
  /* RLC downlink logical channel ID */
  rlc_lc_id_type        rlc_dl_log_chl_id;
  /* DL watermark pointer assigned for logical channel */
  dsm_watermark_type    *dl_log_chl_queue;
  /* UL watermark pointer assigned for logical channel */
  dsm_watermark_type    *ul_log_chl_queue;

  uint32   num_chl, i;

  boolean new_ul_ccch = FALSE;
  boolean new_dl_ccch = FALSE;

  /* Get the Uplink logical channel ID already allocated for CCCH*/
  rlc_ul_log_chl_id = rrclcm_check_ul_rlc_lc_id
  (
    UE_LOGCHAN_CCCH,
    CCCH_RADIO_BEARER_ID,
    UE_MODE_TRANSPARENT
  );

  if (rlc_ul_log_chl_id == RRCLCM_RLC_LC_ID_NOT_FOUND)
  {
    /* Allocate a uplink logical channel ID */
    rlc_ul_log_chl_id = rrclcm_allocate_ul_rlc_lc_id
    (
      UE_LOGCHAN_CCCH,
      CCCH_RADIO_BEARER_ID,
      UE_MODE_TRANSPARENT,
      &ul_log_chl_queue
    );
    new_ul_ccch = TRUE;
  }



  /* Get the downlink logical channel ID already allocated for CCCH */
  rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id
  (
    UE_LOGCHAN_CCCH,
    CCCH_RADIO_BEARER_ID,
    UE_MODE_UNACKNOWLEDGED
  );
  if (rlc_dl_log_chl_id == RRCLCM_RLC_LC_ID_NOT_FOUND)
  {
    /* Allocate a downlink logical channel ID */
    rlc_dl_log_chl_id = rrclcm_allocate_dl_rlc_lc_id
    (
      UE_LOGCHAN_CCCH,
      CCCH_RADIO_BEARER_ID,
      UE_MODE_UNACKNOWLEDGED,
      &dl_log_chl_queue
    );
    new_dl_ccch = TRUE;
  }

  /* Check if able to successfully get UL and DL logical channel IDs */
  if((rlc_ul_log_chl_id != RRCLCM_RLC_LC_ID_ERROR) &&
     (rlc_dl_log_chl_id != RRCLCM_RLC_LC_ID_ERROR))
  {
    /* 2. NOW UPDATE RLC AND MAC ORDERD CONFIG DATA STRUCTURES */

    /* Update RLC Uplink TM channel data */
    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.nchan ++;
    num_chl = rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.nchan;
    if(num_chl < UE_MAX_UL_TM_CHANNEL)
    {
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.chan_info[num_chl-1].lc_id = rlc_ul_log_chl_id;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.chan_info[num_chl-1].lc_type = UE_LOGCHAN_CCCH;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.chan_info[num_chl-1].rb_id = CCCH_RADIO_BEARER_ID;
      if (new_ul_ccch)
      {
        /* new logical channel so establish the RLC */
        rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.ul_tm_act[num_chl-1].action = RLC_ESTABLISH;
        /* Also update the count in Ordered Config */
        ordered_config_ptr->rlc_ul_tm_parms.nchan ++;
        WRRC_MSG1_MED("nchan: Add CCCH UL TM %d after increment",
            ordered_config_ptr->rlc_ul_tm_parms.nchan);
      }
      else
      {
        /* logical channel was existing so modify RLC */
        rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.ul_tm_act[num_chl-1].action = RLC_MODIFY;
        rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.ul_tm_act[num_chl-1].dl_cfg_mask = 0;
        rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.ul_tm_act[num_chl-1].ul_cfg_mask = RLC_MODIFY_CFG;
      }

      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.ul_tm_act[num_chl-1].act_incl = FALSE;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.chan_info[num_chl-1].seg_ind = FALSE;
      /* TBD: Interface with OC needed to get timer discard value */
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.chan_info[num_chl-1].timer_discard = 0;
    }
    else
    {
      WRRC_MSG1_ERROR("Number of UL TM Log Chl %d", num_chl);
      return(FAILURE);
    }

    /* Update RLC Downlink UM channel data */
    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.nchan ++;
    num_chl = rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.nchan;
    if(num_chl < UE_MAX_DL_UM_CHANNEL)
    {
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[num_chl-1].lc_id = rlc_dl_log_chl_id;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[num_chl-1].lc_type = UE_LOGCHAN_CCCH;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[num_chl-1].rb_id = CCCH_RADIO_BEARER_ID;
      if (new_dl_ccch)
      {
        /* new logical channel so establish the RLC */
        rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.dl_um_act[num_chl-1].action = RLC_ESTABLISH;
		
        /* Also update the count in Ordered Config */
        if(get_rlc_dl_um_info(CCCH_RADIO_BEARER_ID, TRUE, ordered_config_ptr) == FAILURE)
        {
          WRRC_MSG0_ERROR("Config DB could not be updated for DL UM RB CCCH_RADIO_BEARER_ID");
          return(FAILURE);		
        }
      }
      else
      {
        /* logical channel was existing so modify RLC */
        rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.dl_um_act[num_chl-1].action = RLC_MODIFY;
        rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.dl_um_act[num_chl-1].ul_cfg_mask = 0;
        rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.dl_um_act[num_chl-1].dl_cfg_mask = RLC_MODIFY_CFG;
      }
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.dl_um_act[num_chl-1].act_incl = FALSE;
      /* Get RLC size from Ordered Config */
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[num_chl-1].rlc_size =
      rrcllc_get_dl_um_ccch_rlc_size();
      if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
      {
        if (rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[num_chl-1].rlc_size < 1000)
        {
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[num_chl-1].li_size = LI_7_BITS;
        }
        else
        {
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[num_chl-1].li_size = LI_15_BITS;
        }
        WRRC_MSG1_HIGH("RRC:CCCH LI size %d", rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[num_chl-1].li_size);
      }
    }
    else
    {
      WRRC_MSG1_ERROR("Number of DL UM Log Chl %d", num_chl);
      return(FAILURE);
    }

    /* Update MAC Ordered Config data with Logical Channel IDs */

    /* Update MAC data in Uplink */
    ordered_config_ptr->mac_ul_parms.cctrch_ptr->cctrch_type = RACH;
    ordered_config_ptr->mac_ul_parms.cctrch_ptr->rach_info.ccch_enable = TRUE;
    ordered_config_ptr->mac_ul_parms.cctrch_ptr->rach_info.ccch_id = rlc_ul_log_chl_id;
    /* OC sets the number of Dedicated logical channels mapped to RACH to 0 */

    /* Update MAC data in Downlink */
    for(i = 0; i < ordered_config_ptr->mac_dl_parms.num_fachs; i ++)
    {
      ordered_config_ptr->mac_dl_parms.fach_info[i]->ccch_enable = TRUE;
      ordered_config_ptr->mac_dl_parms.fach_info[i]->ccch_id = rlc_dl_log_chl_id;
    }
  } /* Successfully allocated Uplink and Downlink Logical channel IDs */
  else
  {
    WRRC_MSG0_ERROR("Could not get Log Chl for UL/DL CCCH");
    return(FAILURE);
  }

  return(SUCCESS);
} /* rrcllc_process_add_ccch_for_cell_pch_to_cell_fach */


/*====================================================================
FUNCTION: rrcllc_process_reconfig_ccch()

DESCRIPTION:
  This function prepares commands to reconfigure CCCH. It gets the
  logical channel IDs already allocated for CCCH and updates MAC data
  structure in Ordered Config with those IDs.

DEPENDENCIES:
  None
RETURN VALUE:
  Status
                SUCCESS: All data structures needed to establish CCCH
                updated successfully.
SIDE EFFECTS:
  None.
====================================================================*/
static uecomdef_status_e_type  rrcllc_process_reconfig_ccch(void)
{
  /* RLC Uplink logical channel ID */
  rlc_lc_id_type        rlc_ul_log_chl_id;
  /* RLC downlink logical channel ID */
  rlc_lc_id_type        rlc_dl_log_chl_id;

  uint32   num_chl, i;

  /* Get the Uplink logical channel ID already allocated for CCCH*/
  rlc_ul_log_chl_id = rrclcm_check_ul_rlc_lc_id
  (
    UE_LOGCHAN_CCCH,
    CCCH_RADIO_BEARER_ID,
    UE_MODE_TRANSPARENT
  );

  WRRC_MSG0_HIGH("reconfig CCCH");
  /* Get the downlink logical channel ID already allocated for CCCH */
  rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id
  (
    UE_LOGCHAN_CCCH,
    CCCH_RADIO_BEARER_ID,
    UE_MODE_UNACKNOWLEDGED
  );

  /* Check if able to successfully get UL and DL logical channel IDs */
  if((rlc_ul_log_chl_id != RRCLCM_RLC_LC_ID_ERROR) &&
     (rlc_dl_log_chl_id != RRCLCM_RLC_LC_ID_ERROR))
  {
    /* 2. NOW UPDATE RLC AND MAC ORDERD CONFIG DATA STRUCTURES */

    /* Update RLC Uplink TM channel data */
    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.nchan ++;
    num_chl = rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.nchan;
    if(num_chl < UE_MAX_UL_TM_CHANNEL)
    {
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.chan_info[num_chl-1].lc_id = rlc_ul_log_chl_id;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.chan_info[num_chl-1].lc_type = UE_LOGCHAN_CCCH;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.ul_tm_act[num_chl-1].action = RLC_MODIFY;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.ul_tm_act[num_chl-1].ul_cfg_mask = RLC_MODIFY_CFG;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.ul_tm_act[num_chl-1].dl_cfg_mask = 0;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.ul_tm_act[num_chl-1].act_incl = FALSE;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.chan_info[num_chl-1].seg_ind = FALSE;
      /* TBD: Interface with OC needed to get timer discard value */
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.chan_info[num_chl-1].timer_discard = 0;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.chan_info[num_chl-1].rb_id = CCCH_RADIO_BEARER_ID;
    }
    else
    {
      WRRC_MSG1_ERROR("Number of UL TM Log Chl %d", num_chl);
      return(FAILURE);
    }

    /* Update RLC Downlink UM channel data */
    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.nchan ++;
    num_chl = rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.nchan;
    if(num_chl < UE_MAX_DL_UM_CHANNEL)
    {
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[num_chl-1].lc_id = rlc_dl_log_chl_id;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[num_chl-1].lc_type = UE_LOGCHAN_CCCH;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.dl_um_act[num_chl-1].action = RLC_MODIFY;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.dl_um_act[num_chl-1].dl_cfg_mask = RLC_MODIFY_CFG;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.dl_um_act[num_chl-1].ul_cfg_mask = 0;
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.dl_um_act[num_chl-1].act_incl = FALSE;
      /* Get RLC size from Ordered Config */
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[num_chl-1].rlc_size =
        rrcllc_get_dl_um_ccch_rlc_size();
      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[num_chl-1].rb_id = CCCH_RADIO_BEARER_ID;
      if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
      {
        if (rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[num_chl-1].rlc_size < 1000)
        {
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[num_chl-1].li_size = LI_7_BITS;
        }
        else
        {
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[num_chl-1].li_size = LI_15_BITS;
        }
        WRRC_MSG1_HIGH("RRC:CCCH LI size %d", rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[num_chl-1].li_size);
      }
    }
    else
    {
      WRRC_MSG1_ERROR("Number of DL UM Log Chl %d", num_chl);
      return(FAILURE);
    }

    /* Update MAC Ordered Config data with Logical Channel IDs */

    /* Update MAC data in Uplink */
    ordered_config_ptr->mac_ul_parms.cctrch_ptr->cctrch_type = RACH;
    ordered_config_ptr->mac_ul_parms.cctrch_ptr->rach_info.ccch_enable = TRUE;
    ordered_config_ptr->mac_ul_parms.cctrch_ptr->rach_info.ccch_id = rlc_ul_log_chl_id;
    /* OC sets the number of Dedicated logical channels mapped to RACH to 0 */

    /* Update MAC data in Downlink */
    for(i = 0; i < ordered_config_ptr->mac_dl_parms.num_fachs; i ++)
    {
      ordered_config_ptr->mac_dl_parms.fach_info[i]->ccch_enable = TRUE;
      ordered_config_ptr->mac_dl_parms.fach_info[i]->ccch_id = rlc_dl_log_chl_id;
    }
  } /* Successfully allocated Uplink and Downlink Logical channel IDs */
  else
  {
    WRRC_MSG0_ERROR("Could not get Log Chl for UL/DL CCCH");
    return(FAILURE);
  }

  return(SUCCESS);
} /* rrcllc_process_reconfig_ccch */

/*====================================================================
FUNCTION: rrcllc_process_drop_ccch()

DESCRIPTION:
  This function updates Ordered Config data structures and LLC internal
  data (rrcllc_cmd_under_process) on release of a CCCH.
  Note that both the Uplink and Downlink data structures are updated.

DEPENDENCIES:
  None
RETURN VALUE:
  Status
    SUCCESS: All data structures needed to release CCCH
             updated successfully.
    FAILURE: failure to allocate resources or detection of
             an invalid value in data structures.
SIDE EFFECTS:
  None.
====================================================================*/
static uecomdef_status_e_type  rrcllc_process_drop_ccch(void)
{
  uint32   num_chl, i;
  /* RLC downlink logical channel ID */
  rlc_lc_id_type    rlc_dl_log_chl_id;
  rlc_lc_id_type    rlc_ul_log_chl_id;

  WRRC_MSG0_HIGH("Dropping CCCH");
  rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id(UE_LOGCHAN_CCCH,
                                                CCCH_RADIO_BEARER_ID,
                                                UE_MODE_UNACKNOWLEDGED);
  if(rlc_dl_log_chl_id == RRCLCM_RLC_LC_ID_NOT_FOUND)
  {
    WRRC_MSG0_ERROR("Log Chl ID for CCCH does NOT exist in LCM");
    return(FAILURE);
  }

  rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.nchan ++;
  num_chl = rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.nchan;
  if(num_chl < UE_MAX_DL_UM_CHANNEL)
  {
    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[num_chl-1].lc_id = rlc_dl_log_chl_id;
    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[num_chl-1].lc_type = UE_LOGCHAN_CCCH;
    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.dl_um_act[num_chl-1].action = RLC_RELEASE;
    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[num_chl-1].rb_id = CCCH_RADIO_BEARER_ID;
  }
  else
  {
    WRRC_MSG1_ERROR("Number of DL UM Log Chl %d", num_chl);
    return(FAILURE);
  }

#ifdef FEATURE_WCDMA_HS_FACH
  if(rrcllc_get_hs_status_in_e_fach(ordered_config_ptr) == FALSE)
#endif
  {
    /* Set CCCH enable in FACH info to FALSE */
    for(i = 0; i < ordered_config_ptr->mac_dl_parms.num_fachs; i ++)
    {
      ordered_config_ptr->mac_dl_parms.fach_info[i]->ccch_enable = FALSE;
    }
  }

  /* Updates for CCCH/RACH */
  rlc_ul_log_chl_id = rrclcm_check_ul_rlc_lc_id(UE_LOGCHAN_CCCH,
                                                CCCH_RADIO_BEARER_ID,
                                                UE_MODE_TRANSPARENT);
  if(rlc_ul_log_chl_id == RRCLCM_RLC_LC_ID_NOT_FOUND)
  {
    ERR_FATAL("Log Chl ID for UL CCCH does NOT exist in LCM", 0, 0, 0);
  }
  rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.nchan ++;
  num_chl = rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.nchan;
  if(num_chl < UE_MAX_UL_TM_CHANNEL)
  {
    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.chan_info[num_chl-1].lc_id = rlc_ul_log_chl_id;
    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.chan_info[num_chl-1].lc_type = UE_LOGCHAN_CCCH;
    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.ul_tm_act[num_chl-1].action = RLC_RELEASE;
    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.chan_info[num_chl-1].rb_id = CCCH_RADIO_BEARER_ID;
    WRRC_MSG0_MED("nchan: requesting UL TM release");
  }
  else
  {
    WRRC_MSG1_ERROR("Number of UL TM Log Chl %d", num_chl);
    return(FAILURE);
  }

  /* Remove RACH from MAC Ordered Config data */
  ordered_config_ptr->mac_ul_parms.cctrch_ptr->rach_info.ccch_enable = FALSE;

  return(SUCCESS);
} /* rrcllc_process_drop_ccch */

/*====================================================================
FUNCTION: rrcllc_process_config_dtch_rel()

DESCRIPTION:
  This function updates Ordered Config data structures and LLC internal
  data (rrcllc_cmd_under_process) on release of DTCH.

  Note that both the Uplink and Downlink data structures are updated.

DEPENDENCIES:
  None
RETURN VALUE:
  Status
    SUCCESS: All data structures needed to release of a DTCH are
            updated successfully.
    FAILURE: Failure to allocate resources or detection of
             an invalid value in data structures.
SIDE EFFECTS:
  None.
====================================================================*/
static uecomdef_status_e_type  rrcllc_process_config_dtch_rel(rrc_cmd_type *cmd_ptr)
{
  int          rb_count;

  uint8        i;

  uint8     num_chl;
  uint8     num_entity;

  uint8     num_oc_entity = 0;


  /* RLC Uplink logical channel ID */
  rlc_lc_id_type         rlc_ul_log_chl_id = RRCLCM_RLC_LC_ID_ERROR;
  /* RLC Downlink logical channel ID */
  rlc_lc_id_type         rlc_dl_log_chl_id = RRCLCM_RLC_LC_ID_ERROR;

  /* The presumption is that logical channel mode, type and action will
   * be the same in both Uplink and Downlink.
   */
  /* Mode of the logical channel */
  uecomdef_logch_mode_e_type  log_chl_mode = UE_MODE_MAX_NUM;
  /* Type of Logical channel */
  uecomdef_logchan_e_type   log_chl_type;
  /* RLC action on logical channel */
  rlc_channel_action_e_type   log_chl_action;


  /*===========================================================*
   * Update RLC and MAC Data for each RB in Channel Config Req.*
   *===========================================================*/

  /* Go over all RBs in the Channel Config Request */
  for (rb_count=0;
       rb_count<cmd_ptr->cmd.chan_config_req.num_rb_to_config;
       rb_count++)
  {
    if((cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id > DCCH_DT_LOW_PRI_RADIO_BEARER_ID) &&
            (cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id < MAX_RB))
    {
      if(cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_config == RELEASE_RB)
      {
        if(rrcllc_has_config_srb5(ORDERED_CONFIG, cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id) == TRUE)
        {
          WRRC_MSG0_ERROR("Exclude SRB#5 from the release list as it is not of DTCH type");
          continue;
        }
    
        log_chl_type  = UE_LOGCHAN_DTCH;
        log_chl_action  = RLC_RELEASE;

        /* This is a modify or release case. In both cases, the logical
         * channel is already up and LCM should have the mode info
         */
        /* First get the logical channel ID from RB ID */
        rlc_dl_log_chl_id = rrclcm_get_dl_rlc_lc_id
          (
            cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id
          );
        if(rlc_dl_log_chl_id == RRCLCM_RLC_LC_ID_NOT_FOUND)
        {
          WRRC_MSG1_ERROR("No log chl for RB %d in LCM",
              cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id);
          return(FAILURE);
        }
        /* Now get the mode from the logical channel */
        if( rrclcm_get_dl_rlc_mode(rlc_dl_log_chl_id, &log_chl_mode)
            == RRCLCM_FAILURE)
        {
          WRRC_MSG1_ERROR("No info for DL Log Chl ID %d", rlc_dl_log_chl_id);
          return(FAILURE);
        }
      } /* RB Release */
      else
      {
        WRRC_MSG2_ERROR("Operation %d on RB ID %d unsupported",
          cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_config,cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id);
        continue;
      }
    }  /* Action on User plane RB */
    else
    {
      WRRC_MSG2_ERROR("Invalid RB ID %d at index %d",
        cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id, rb_count);
      continue;
    }

    /* Get the Uplink and Downlink Logical channel ID of the existing channel */
    rlc_ul_log_chl_id = rrclcm_get_ul_rlc_lc_id
    (
      cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id
    );

    rlc_dl_log_chl_id = rrclcm_get_dl_rlc_lc_id
    (
      cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id
    );

    /*=======================================================*
     * Update RLC Config Data                                *
     *=======================================================*/
    /* Check if able to successfully allocate UL and DL logical channel IDs */
    if((rlc_ul_log_chl_id != RRCLCM_RLC_LC_ID_ERROR) &&
       (rlc_dl_log_chl_id != RRCLCM_RLC_LC_ID_ERROR))
    {
      if(log_chl_mode == UE_MODE_TRANSPARENT)
      {
        /* Update RLC Ordered config data for Uplink */
        rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.nchan ++;
        num_chl = rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.nchan;
        if(num_chl < UE_MAX_UL_TM_CHANNEL)
        {
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.chan_info[num_chl-1].lc_id = rlc_ul_log_chl_id;
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.chan_info[num_chl-1].lc_type = log_chl_type;
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.ul_tm_act[num_chl-1].action = log_chl_action;
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.ul_tm_act[num_chl-1].act_incl = FALSE;
          /* TBD: Interface with OC needed to get timer discard value */
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.chan_info[num_chl-1].timer_discard = 0;
          /* TBD: Hard coded value of segmentation indication for now */
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.chan_info[num_chl-1].seg_ind = FALSE;
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.chan_info[num_chl-1].rb_id = 
            cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id;
        }
        else
        {
          WRRC_MSG1_ERROR("Number of UL TM Log Chl %d", num_chl);
          return(FAILURE);
        }

        /* Update RLC Ordered config data for Downlink */
        rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.nchan ++;
        num_chl = rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.nchan;
        if(num_chl < UE_MAX_DL_TM_CHANNEL)
        {
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[num_chl-1].lc_id = rlc_dl_log_chl_id;
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[num_chl-1].lc_type = log_chl_type;
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.dl_tm_act[num_chl-1].action = log_chl_action;
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.dl_tm_act[num_chl-1].act_incl = FALSE;
          /* TBD: hardcode segmentation indication to FALSE */
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[num_chl-1].seg_ind = FALSE;
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[num_chl-1].rb_id = 
            cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id;
        }
        else
        {
          WRRC_MSG1_ERROR("Number of DL TM Log Chl %d", num_chl);
          return(FAILURE);
        }
      } /* if(log_chl_mode == UE_MODE_TRANSPARENT) */
      else if(log_chl_mode == UE_MODE_UNACKNOWLEDGED)
      {
        /* Update RLC Ordered config data for Uplink */
        rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.nchan ++;
        num_chl = rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.nchan;
        if(num_chl < UE_MAX_UL_UM_CHANNEL)
        {
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.chan_info[num_chl-1].lc_id = rlc_ul_log_chl_id;
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.chan_info[num_chl-1].lc_type = log_chl_type;
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.ul_um_act[num_chl-1].action = log_chl_action;
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.ul_um_act[num_chl-1].act_incl = FALSE;

          /* Since it is release of logical channel, no need to fill out the Timer Discard value. */
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.chan_info[num_chl-1].timer_discard = 0;
          /* since it is rb release we do not need to populate rlc size */
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.chan_info[num_chl-1].rb_id = 
            cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id;
          /* TBD: HFN value and RLC size also needs to be passed here */
        }
        else
        {
          WRRC_MSG1_ERROR("Number of UL UM Log Chl %d", num_chl);
          return(FAILURE);
        }

        /* Update RLC Ordered config data for Downlink */
        rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.nchan ++;
        num_chl = rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.nchan;
        if(num_chl < UE_MAX_DL_UM_CHANNEL)
        {
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[num_chl-1].lc_id = rlc_dl_log_chl_id;
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[num_chl-1].lc_type = log_chl_type;
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.dl_um_act[num_chl-1].action = log_chl_action;
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.dl_um_act[num_chl-1].act_incl = FALSE;
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[num_chl-1].rb_id = 
            cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id;
          /* since it is rb release we do not need to populate rlc size */
          /* TBD: HFN value also needs to be passed here */
        }
        else
        {
          WRRC_MSG1_ERROR("Number of DL UM Log Chl %d", num_chl);
          return(FAILURE);
        }
      } /* If mode is UE_MODE_UNACKNOWLEDGED */
      else if((log_chl_mode == UE_MODE_ACKNOWLEDGED_DATA) ||
              (log_chl_mode == UE_MODE_ACKNOWLEDGED_CONTROL))
      {
        /* Update RLC data for Downlink in rrcllc_cmd_under_process */
        rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.nentity ++;
        num_entity = rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.nentity;

        /* Now find the num_entity in Ordered Config */
        for (i=0; i < UE_MAX_AM_ENTITY; i++)
        {
          if((ordered_config_ptr->rlc_am_parms.am_info[i]->common_config.rb_id ==
                cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id)   &&
             ordered_config_ptr->rlc_am_parms.am_info[i]->ul_nchan &&
             ordered_config_ptr->rlc_am_parms.am_info[i]->dl_nchan
            )
          {
            /* This is the AM entity in Ordered Config for the current RB */
            break;
          }
        }

        if (i < UE_MAX_AM_ENTITY)
        {
          num_oc_entity = i;
        }
        else
        {
          WRRC_MSG0_ERROR("OC has no new AM chls");
          return(FAILURE);
        }

        /* Update RLC Ordered config data for Downlink */
        if(num_entity <= UE_MAX_AM_ENTITY)
        {
          /* Now point towards RLC Ordered Config data from RLC AM data
           * in rrcllc_cmd_under_process
           */
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_info[num_entity-1] =
              ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity];

          /* Initialize RLC AM action data in rrcllc_cmd_under_process */
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_act[num_entity-1].action
              = log_chl_action;
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_act[num_entity-1].act_incl
              = FALSE;

        }
        else
        {
          WRRC_MSG1_ERROR("Number of am entities %d exceed limit", num_entity);
          return(FAILURE);
        }
      } /* Mode is Acknowledged Data or Acknowledged Control */
    }  /* Able to successfully allocate UL and DL logical channel IDs */
    else
    {
      WRRC_MSG1_ERROR("Could not get Log Chl for RB %d",
            cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id);
      return(FAILURE);
    }
  }  /* for(all RBs in channel config request)... */
  return(SUCCESS);
} /* rrcllc_process_config_dtch_rel */

/*====================================================================
FUNCTION: rrcllc_process_add_sccpch()

DESCRIPTION:
  This function updates Ordered Config data structures and LLC internal
  data (rrcllc_cmd_under_process) on release of a CCCH.
  Note that both the Uplink and Downlink data structures are updated.

DEPENDENCIES:
  None
RETURN VALUE:
  Status
    SUCCESS: All data structures needed to release CCCH
             updated successfully.
    FAILURE: failure to allocate resources or detection of
             an invalid value in data structures.
SIDE EFFECTS:
  None.
====================================================================*/
static uecomdef_status_e_type  rrcllc_process_add_sccpch(void)
{
  uint8   cctrch_id;
  uint32 i;
  /* Get a new CCTrCH ID */
  cctrch_id = rrcllc_get_cctrch_id();
  if(cctrch_id != RRCLLC_INVALID_CCTRCH_ID)
  {
    /* Update FACH info in MAC Ordered Config */
    for(i = 0; i < ordered_config_ptr->mac_dl_parms.num_fachs; i ++)
    {
      ordered_config_ptr->mac_dl_parms.fach_info[i]->cctrch_id = cctrch_id;
    }

    /* If PCH is present, update PCH info in Ordered Config with new CCTrCH ID */
    if(ordered_config_ptr->mac_dl_parms.num_pchs != 0)
    {
      ordered_config_ptr->mac_dl_parms.pch_info->cctrch_id = cctrch_id;
    }
    /* Update SCCPCH Info in rrcllc_cmd_under_process */
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.cctrch_id =
        cctrch_id;
  }
  else
  {
    WRRC_MSG1_ERROR("Invalid CCTrCH ID %d assigned", cctrch_id);
    return(FAILURE);
  }

  MSG_LOW("LLC_PHYCHAN_SETUP on SCCPCH", 0, 0, 0);

  rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_action =
    LLC_PHYCHAN_SETUP;
  return (SUCCESS);
}


/*====================================================================
FUNCTION: rrcllc_process_reconfigure_sccpch()

DESCRIPTION:
  This function updates Ordered Config data structures and LLC internal
  data (rrcllc_cmd_under_process) on release of a CCCH.
  Note that both the Uplink and Downlink data structures are updated.

DEPENDENCIES:
  None
RETURN VALUE:
  Status
    SUCCESS: All data structures needed to release CCCH
             updated successfully.
    FAILURE: failure to allocate resources or detection of
             an invalid value in data structures.
SIDE EFFECTS:
  None.
====================================================================*/
static uecomdef_status_e_type  rrcllc_process_reconfigure_sccpch(void)
{
  uint8   cctrch_id;
  int i;

  /* Since we are reconfiguring a SCCPCH, a new CCTrCH ID needs to be allocated */
 
  /* If a valid CCTrCH ID exists for SCCPCH, add it to release list */
  if(rrcllc_semi_permanent_data.dl_phy_chan.sccpch.cctrch_id !=
     RRCLLC_INVALID_CCTRCH_ID)
  {
    RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                         dl_phy_chan.sccpch.cctrch_id);
  }
  /* Get a new CCTrCH ID */
  cctrch_id = rrcllc_get_cctrch_id();
  if(cctrch_id != RRCLLC_INVALID_CCTRCH_ID)
  {
    /* Update FACH info in MAC Ordered Config */
    for(i = 0; i < ordered_config_ptr->mac_dl_parms.num_fachs; i ++)
    {
      ordered_config_ptr->mac_dl_parms.fach_info[i]->cctrch_id = cctrch_id;
    }
 
    /* If PCH is present, update PCH info in Ordered Config with new CCTrCH ID */
    if(ordered_config_ptr->mac_dl_parms.num_pchs != 0)
    {
      ordered_config_ptr->mac_dl_parms.pch_info->cctrch_id = cctrch_id;
    }
    /* Update SCCPCH Info in rrcllc_cmd_under_process */
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.cctrch_id =
        cctrch_id;
  }
  else
  {
    WRRC_MSG1_ERROR("Invalid CCTrCH ID %d assigned", cctrch_id);
    return(FAILURE);
  }
 
  MSG_LOW("LLC_PHYCHAN_RECONFIG on SCCPCH", 0, 0, 0);
 
  rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_action =
    LLC_PHYCHAN_RECONFIG;
  return (SUCCESS);

}

#ifdef FEATURE_WCDMA_HS_FACH
/*====================================================================
FUNCTION: rrcllc_process_drop_sccpch()

DESCRIPTION:

DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS
  FAILURE

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type  rrcllc_process_drop_sccpch(void)
{
  /* If a valid CCTrCH ID exists for SCCPCH, add it to release list */
  if(rrcllc_semi_permanent_data.dl_phy_chan.sccpch.cctrch_id !=
     RRCLLC_INVALID_CCTRCH_ID)
  {
    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_action =
    LLC_PHYCHAN_RELEASE;
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf = 0;
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf = 0;
 
    RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                         dl_phy_chan.sccpch.cctrch_id);
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.cctrch_id =
     RRCLLC_INVALID_CCTRCH_ID;
  }
  else
  {
    WRRC_MSG0_ERROR("CCTrCH ID for SCCPCH invalid --> SCCPCH release failed");
    return(FAILURE);
  }

  return(SUCCESS);
}
#endif

#ifdef FEATURE_UMTS_PDCP
/*====================================================================
FUNCTION: rrcllc_is_pdcp_config_req_necessary()

DESCRIPTION:
  This function returns TRUE if rb_id passed in has PDCP related 
  information that needs a reconfig.  Else returns false.

DEPENDENCIES:
  None
RETURN VALUE:
  Boolean
SIDE EFFECTS:
  None.
====================================================================*/
static boolean rrcllc_is_pdcp_config_req_necessary(rrc_RB_Identity rb_id, 
                                            rrc_rb_cfg_e_type rb_config, uint32 *index, boolean *just_srns)
{
  boolean answer = FALSE;
  uint32 ind = 0;
  ordered_config_type  *config_ptr;

  if(config_ptr_in_use == ORDERED_CONFIG)
  {
    config_ptr = ordered_config_ptr;
  }
  else
  {
    config_ptr = current_config_ptr;
  }

  for (ind = 0; ind < MAX_RAB_TO_SETUP; ind++) 
  {
    if(config_ptr->pdcp_parms.pdcp_config_req[ind].rb_id == rb_id)
    {
      if (rb_config == ESTABLISH_RB  || rb_config == RELEASE_RB) 
      {
        answer = TRUE;
        *index = ind;
      }
      else if (((rb_config == RECONFIG_RB) 
        ||(rb_config == RECONFIG_RB_OTA)
        ) && (config_ptr->pdcp_parms.pdcp_config_req[ind].pdcp_info_changed))
      {
        answer = TRUE;
        *index = ind;
      }
      else if (rrcrb_is_srns_in_progress()) 
      {
        answer = TRUE;
        *index = ind;
        *just_srns = TRUE;
      } 
      break;
    }
  }

  return answer;
}
/*====================================================================
FUNCTION: rrcllc_process_config_pdcp()

DESCRIPTION:
  This function updates LLC internal data (rrcllc_cmd_under_process) on an establish, 
  release or a reconfiguration of PDCP.

DEPENDENCIES:
  None
RETURN VALUE:
none
SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_process_config_pdcp(rrc_cmd_type *cmd_ptr)
{

  uint32 idx1 = 0;
  uint32 idx2 = 0;
  uint32 index = 0;
  ordered_config_type  *config_ptr;
  boolean just_srns = FALSE;
  boolean rb_found = FALSE;

  if(config_ptr_in_use == ORDERED_CONFIG)
  {
    config_ptr = ordered_config_ptr;
  }
  else
  {
    config_ptr = current_config_ptr;
  }

  for(idx1 = 0; idx1 < (uint32) cmd_ptr->cmd.chan_config_req.num_rb_to_config; idx1++) 
  {
    if (TRUE == rrcllc_is_pdcp_config_req_necessary(cmd_ptr->cmd.chan_config_req.rb[idx1].rb_id,
                                                    cmd_ptr->cmd.chan_config_req.rb[idx1].rb_config,
                                                    &index, &just_srns))
    {
      if (cmd_ptr->cmd.chan_config_req.rb[idx1].rb_config == ESTABLISH_RB) 
      {
        /* Save the rb id in pdcp_cfg_req... this will be needed when released later to clear
         * config DB
         */
        config_ptr->pdcp_parms.pdcp_config_req[index].pdcp_cfg_req.rb_id =
          config_ptr->pdcp_parms.pdcp_config_req[index].rb_id; 
      }
      else if (cmd_ptr->cmd.chan_config_req.rb[idx1].rb_config == RELEASE_RB) 
      {
        WRRC_MSG0_HIGH("Building release PDCP cmd");

        config_ptr->pdcp_parms.pdcp_config_req[index].pdcp_cfg_req.action = RELEASE_PDCP;
        /* Initialize pdcp params as PDCP_INFO provides a snapshot */
        memset(&(config_ptr->pdcp_parms.pdcp_config_req[index].pdcp_cfg_req.pdcp_info), 0, sizeof(pdcp_info_type)); 
        /*We don't need it because once the PDCP action is RELEASE, the CSoHSPA action shouldn't matter.*/
      }
      else if (just_srns) 
      {
        config_ptr->pdcp_parms.pdcp_config_req[index].pdcp_cfg_req.action = RESET_COMP_ENG_PDCP; 
      }
      /* Set PDCP_info_changed to cover the RB_Setup and RB_release case*/
      config_ptr->pdcp_parms.pdcp_config_req[index].pdcp_info_changed = TRUE;
      rrcllc_cmd_under_process.chan_config.pdcp_config_req_list.num_rbs++;
      rrcllc_cmd_under_process.chan_config.pdcp_config_req_list.pdcp_cfg_req[idx2] =
        config_ptr->pdcp_parms.pdcp_config_req[index].pdcp_cfg_req;

      rrcllc_cmd_under_process.chan_config.pdcp_config_req_list.pdcp_cfg_req[idx2].rlc_dl_id = 
        rrclcm_get_dl_rlc_lc_id(cmd_ptr->cmd.chan_config_req.rb[idx1].rb_id);
      rrcllc_cmd_under_process.chan_config.pdcp_config_req_list.pdcp_cfg_req[idx2].rlc_ul_id = 
        rrclcm_get_ul_rlc_lc_id(cmd_ptr->cmd.chan_config_req.rb[idx1].rb_id);
      rrcllc_cmd_under_process.chan_config.pdcp_config_req_list.pdcp_cfg_req[idx2].rab_dl_rate = 
        rrcllc_get_dl_ded_rate(config_ptr->rrc_state_indicator,
                               cmd_ptr->cmd.chan_config_req.rb[idx1].rb_id);
      rrcllc_cmd_under_process.chan_config.pdcp_config_req_list.pdcp_cfg_req[idx2].rab_ul_rate =
        rrcllc_get_ul_ded_rate(config_ptr->rrc_state_indicator,
                               cmd_ptr->cmd.chan_config_req.rb[idx1].rb_id);
      rrcllc_cmd_under_process.chan_config.pdcp_config_req_list.pdcp_cfg_req[idx2].is_mcast_call =
        ((rrclcm_get_ul_rlc_lc_id(cmd_ptr->cmd.chan_config_req.rb[idx1].rb_id) != RRCLCM_RLC_LC_ID_NOT_FOUND)?
         FALSE : TRUE);
          
      if (rrcrb_is_srns_in_progress()) 
      {
        rrcllc_cmd_under_process.chan_config.pdcp_config_req_list.pdcp_cfg_req[idx2].srns_reloc_flag =
          PDCP_RESET_COMP_ENG;
      }
      else
      {
        rrcllc_cmd_under_process.chan_config.pdcp_config_req_list.pdcp_cfg_req[idx2].srns_reloc_flag = 
          PDCP_NO_RESET_COMP_ENG;
      }

      /* update config ptr */
      config_ptr->pdcp_parms.pdcp_config_req[index].pdcp_cfg_req = 
        rrcllc_cmd_under_process.chan_config.pdcp_config_req_list.pdcp_cfg_req[idx2];

      idx2++;
    }
  }

  /* If the rate change has changed for the Rbs that didn't get reconfigured, send
     PDCP_CONFIG_REQ.  This is needed so that PDCP re-adujusts the watermark levels
     for flow control and memory contraints
   */
  for (idx1 = 0; idx1 < config_ptr->pdcp_parms.num_rbs; idx1++) 
  {
    /* only check the data rates if only pdcp info hasn't change.  If 
       PDCP info has changed, the command is contructed in above for loop
    */
    rb_found = FALSE;
    if (!config_ptr->pdcp_parms.pdcp_config_req[idx1].pdcp_info_changed) 
    {
      /* get the rb_id index from current config */
      for (idx2 = 0; idx2 < current_config_ptr->pdcp_parms.num_rbs; idx2++) 
      {
        if (current_config_ptr->pdcp_parms.pdcp_config_req[idx2].in_use &&
            (current_config_ptr->pdcp_parms.pdcp_config_req[idx2].rb_id ==
             config_ptr->pdcp_parms.pdcp_config_req[idx1].rb_id))
        {
          /* break out of for loop.  idx2 is the index of the old info for 
             the same rb_id
           */
          rb_found = TRUE;
          break;
        }
      }
      /* Set PDCP action as Reconfig PDCP only if RB already exist in EST_RABs. We dont want to 
         send action as reconfig if RB is yet to be setup CR#830919*/
      if (rb_found && (rrc_find_rb_in_est_rabs(current_config_ptr->pdcp_parms.pdcp_config_req[idx2].rb_id) == RRC_RB_PRESENT) && 
          ((current_config_ptr->pdcp_parms.pdcp_config_req[idx2].pdcp_cfg_req.rab_dl_rate != 
           rrcllc_get_dl_ded_rate(config_ptr->rrc_state_indicator,
                                   config_ptr->pdcp_parms.pdcp_config_req[idx1].rb_id)) ||
          (current_config_ptr->pdcp_parms.pdcp_config_req[idx2].pdcp_cfg_req.rab_ul_rate !=
           rrcllc_get_ul_ded_rate(config_ptr->rrc_state_indicator,
                                   config_ptr->pdcp_parms.pdcp_config_req[idx1].rb_id))))

      {
        /* construct the pdcp reconfig message */


        config_ptr->pdcp_parms.pdcp_config_req[idx1].pdcp_cfg_req.action = RECONFIG_PDCP;
        
        index = rrcllc_cmd_under_process.chan_config.pdcp_config_req_list.num_rbs;
        rrcllc_cmd_under_process.chan_config.pdcp_config_req_list.num_rbs++;
       
        rrcllc_cmd_under_process.chan_config.pdcp_config_req_list.pdcp_cfg_req[index] =
          config_ptr->pdcp_parms.pdcp_config_req[idx1].pdcp_cfg_req;
        rrcllc_cmd_under_process.chan_config.pdcp_config_req_list.pdcp_cfg_req[index].rlc_dl_id = 
          rrclcm_get_dl_rlc_lc_id(config_ptr->pdcp_parms.pdcp_config_req[idx1].rb_id);
        rrcllc_cmd_under_process.chan_config.pdcp_config_req_list.pdcp_cfg_req[index].rlc_ul_id = 
          rrclcm_get_ul_rlc_lc_id(config_ptr->pdcp_parms.pdcp_config_req[idx1].rb_id);
        rrcllc_cmd_under_process.chan_config.pdcp_config_req_list.pdcp_cfg_req[index].rab_dl_rate = 
          rrcllc_get_dl_ded_rate(config_ptr->rrc_state_indicator,
                                 config_ptr->pdcp_parms.pdcp_config_req[idx1].rb_id);
        rrcllc_cmd_under_process.chan_config.pdcp_config_req_list.pdcp_cfg_req[index].rab_ul_rate =
          rrcllc_get_ul_ded_rate(config_ptr->rrc_state_indicator,
                                 config_ptr->pdcp_parms.pdcp_config_req[idx1].rb_id);
        rrcllc_cmd_under_process.chan_config.pdcp_config_req_list.pdcp_cfg_req[index].srns_reloc_flag = 
          PDCP_NO_RESET_COMP_ENG;
        
        /* update config ptr */
        config_ptr->pdcp_parms.pdcp_config_req[idx1].pdcp_cfg_req = 
          rrcllc_cmd_under_process.chan_config.pdcp_config_req_list.pdcp_cfg_req[index];
      }
    }

    /* Reset flag that indicates that pdcp_parms has changed */
    config_ptr->pdcp_parms.pdcp_config_req[idx1].pdcp_info_changed = FALSE;
  }
}
#endif /* FEATURE_UMTS_PDCP */

/*====================================================================
FUNCTION: rrcllc_process_config_dcch_dtch()

DESCRIPTION:
  This function updates Ordered Config data structures and LLC internal
  data (rrcllc_cmd_under_process) on an establish, release or a
  reconfiguration of a DCCH.
  Note that both the Uplink and Downlink data structures are updated.

DEPENDENCIES:
  None
RETURN VALUE:
  Status
    SUCCESS: All data structures needed to establish, release or a
             reconfiguration of a DCCH are updated successfully.
    FAILURE: Failure to allocate resources or detection of
             an invalid value in data structures.
SIDE EFFECTS:
  None.
====================================================================*/
static uecomdef_status_e_type  rrcllc_process_config_dcch_dtch(rrc_cmd_type *cmd_ptr)
{
  int          rb_count;

  uint32       num_dch;
  uint32       num_fach;
  uint32       fach_count;
  uint8        i;
  uint8        k = 0;

  boolean queue_found = FALSE;

  boolean hsdpa_found= FALSE;

  boolean dflow_found = FALSE;
  rrc_rlc_dl_um_li_e_type dl_um_l1;
  rrcsmc_re_est_start_list  start_list;
  boolean pdu_size_present = FALSE;
  boolean smc_extract_value_invoked = FALSE;
  uint32 rlc_size_old = RRCLLC_INVALID_RLC_SIZE;
  uint32 rlc_size_new = RRCLLC_INVALID_RLC_SIZE;
  boolean   e_mac_d_flow_found = FALSE;
  uecomdef_logch_mode_e_type  e_log_chan_mode = UE_MODE_MAX_NUM;
#ifdef FEATURE_MAC_I
  rlc_ul_flexi_size_info_type oc_rlc_flexi_ul_size;
#endif /* FEATURE_MAC_I */

  uint32    dlchl_count;
  /* Number of dedicated logical channels */
  uint32    num_dlchan;
  uint8     num_chl;
  uint8     num_entity;

  uint8     num_oc_entity = 0;


  /* A boolean to indicate if a DCH is found mapped to the DCCH RB under process */
  boolean   dch_found;
  boolean   valid_rb_action = FALSE;

  /* RLC Uplink logical channel ID */
  rlc_lc_id_type         rlc_ul_log_chl_id = RRCLCM_RLC_LC_ID_ERROR;
  /* RLC Downlink logical channel ID */
  rlc_lc_id_type         rlc_dl_log_chl_id = RRCLCM_RLC_LC_ID_ERROR;

  /* The presumption is that logical channel mode, type and action will
   * be the same in both Uplink and Downlink.
   */
  /* Mode of the logical channel */
  uecomdef_logch_mode_e_type  log_chl_mode = UE_MODE_MAX_NUM;

  uecomdef_logch_mode_e_type  hs_log_chl_mode = UE_MODE_MAX_NUM;

  boolean hsdpa_loopback_um_in_progress = FALSE;

  /* Type of Logical channel */
  uecomdef_logchan_e_type   log_chl_type;
  /* RLC action on logical channel */
  rlc_channel_action_e_type   log_chl_action;

  /* UL watermark pointer assigned for logical channel */
  dsm_watermark_type     *ul_log_chl_queue;
  /* DL watermark pointer assigned for logical channel */
  dsm_watermark_type     *dl_log_chl_queue;

  boolean srb5_exists = FALSE;
  uint8 rb_mapping_index;
  uint16 ul_cfg_mask = 0;
  uint16 dl_cfg_mask = 0;

#ifdef FEATURE_WCDMA_HS_RACH
  uint8 ix = 0,iy = 0;
boolean cedch_trans_in_oc = rrchsrach_get_common_edch_transmission(ordered_config_ptr);
#endif
#ifdef FEATURE_WCDMA_HS_FACH
  boolean ret_val = TRUE;
  ordered_config_type * config_ptr = NULL;
  if(rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_FACH)
  {
    if(rrcenhstate_camped_cell_supports_e_fach() == FALSE)
    {
      WRRC_MSG0_HIGH("RRC_HRB:Non-EFACH cell, restore RACH-FACH info into all databases");
      if(config_ptr_in_use == ORDERED_CONFIG)
        config_ptr = ordered_config_ptr;
      else if(config_ptr_in_use == CURRENT_CONFIG)
        config_ptr = current_config_ptr;
      ret_val = rrcllc_restore_from_hanging(config_ptr,(UL_RACH_MAPPING|DL_FACH_MAPPING));
    }
    if(ret_val == FALSE)
    {
      WRRC_MSG0_ERROR("RRC_HRB: RACH-FACH mapping restore FAILED !!!");
      return FAILURE;
    }
    else if (config_ptr != NULL)
    {
      /*This has to be set to TRUE to make sure that RACH TFC are updated*/
      config_ptr->rach_rlc_size_restriction_info.mac_update_needed = TRUE;
      rrcllc_populate_mac_rlc_size_restriction_info(config_ptr,RRC_STATE_CELL_FACH);
    }
  }
  
#endif



  /*===========================================================*
   * Update RLC and MAC Data for each RB in Channel Config Req.*
   *===========================================================*/
    
  WRRC_MSG0_HIGH("CONFIG DCCH DTCH CALLED");
    /*Check for any size change in UL for Rbs in est_rabs*/
  rrcllc_check_and_reestablish_ul_side(cmd_ptr);

  /* Go over all RBs in the Channel Config Request */
  for (rb_count=0, valid_rb_action = FALSE;
       rb_count<cmd_ptr->cmd.chan_config_req.num_rb_to_config;
       rb_count++)
  {
    valid_rb_action = FALSE;
    dch_found = FALSE;
    dflow_found = FALSE;
    queue_found = FALSE;
    ul_cfg_mask = 0;
    dl_cfg_mask = 0;
#ifdef FEATURE_MAC_I
    oc_rlc_flexi_ul_size.rrc_ul_flex_max_pdu_size = RRC_UL_INVALID_RLC_SIZE;
    oc_rlc_flexi_ul_size.rrc_ul_flex_min_pdu_size = RRC_UL_INVALID_RLC_SIZE;
    oc_rlc_flexi_ul_size.rrc_ul_li_size = LI_UNSPECIFIED;	
#endif /* FEATURE_MAC_I */
    if(cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id == DCCH_UM_RADIO_BEARER_ID)
    {
        log_chl_mode  = UE_MODE_UNACKNOWLEDGED;
        log_chl_type  = UE_LOGCHAN_DCCH;
      if(cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_config != NO_ACTION_ON_RB)
        {
        log_chl_action = rrcllc_get_log_chan_action_for_rb_action(&cmd_ptr->cmd.chan_config_req.rb[rb_count]
                                                                  ,&ul_cfg_mask ,&dl_cfg_mask);
        valid_rb_action = TRUE;
      }
      else
      {
        WRRC_MSG1_ERROR("Operation %d on RB ID unsupported",
          cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_config);
        valid_rb_action = FALSE;
        break;
      }
    }
    else if((cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id == DCCH_AM_RADIO_BEARER_ID) ||
            (cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id == DCCH_DT_HIGH_PRI_RADIO_BEARER_ID) ||
            (cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id == DCCH_DT_LOW_PRI_RADIO_BEARER_ID))
    {
      if(cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_config != NO_ACTION_ON_RB)
      {
        valid_rb_action = TRUE;
        log_chl_mode  = UE_MODE_ACKNOWLEDGED_DATA;
        log_chl_type  = UE_LOGCHAN_DCCH;
        log_chl_action = rrcllc_get_log_chan_action_for_rb_action(&cmd_ptr->cmd.chan_config_req.rb[rb_count]
                                                         ,&ul_cfg_mask ,&dl_cfg_mask
         );
      }
      else
      {
        WRRC_MSG2_ERROR("Operation %d on RB ID %d unsupported",
          cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_config,cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id);
        valid_rb_action = FALSE;
        break;
      }
    }
    else if((cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id > DCCH_DT_LOW_PRI_RADIO_BEARER_ID) &&
            (cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id < MAX_RB))
    {
      rrc_RB_Identity  rb_id = RRCLLC_INVALID_RB_ID ;
      (void)rrclcm_get_rb_id_if_dl_lc_type_exists(UE_LOGCHAN_TM_DCCH_DL, &rb_id);
      if(((rb_id == cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id)
        &&((cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_config == RECONFIG_RB
             || cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_config == RECONFIG_RB_OTA
         )||(cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_config == RELEASE_RB)
         )) ||
        (rrcllc_has_config_srb5(ORDERED_CONFIG, cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id) == TRUE))
      {     
        if(cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_config != NO_ACTION_ON_RB)
        { 
          valid_rb_action = TRUE;
          log_chl_mode = UE_MODE_TRANSPARENT;
          log_chl_type  = UE_LOGCHAN_TM_DCCH_DL;
          srb5_exists = TRUE;
         log_chl_action = rrcllc_get_log_chan_action_for_rb_action(&cmd_ptr->cmd.chan_config_req.rb[rb_count]
                                                         ,&ul_cfg_mask ,&dl_cfg_mask);
        }
        else
        { 
          WRRC_MSG2_ERROR("Operation %d on RB ID %d unsupported",
          cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_config,cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id);
          valid_rb_action = FALSE;
          break;
        }
      }
      else 
      if(cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_config != NO_ACTION_ON_RB)
      {
        valid_rb_action = TRUE;
        WRRC_MSG1_MED("RLC Action for User RB (DTCH) %d",cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_config);
        log_chl_type  = UE_LOGCHAN_DTCH;
        log_chl_action = rrcllc_get_log_chan_action_for_rb_action(&cmd_ptr->cmd.chan_config_req.rb[rb_count]
                                                         ,&ul_cfg_mask ,&dl_cfg_mask);/* Get the logical channel mode now */
        if(log_chl_action == RLC_ESTABLISH)
        {
          if(rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_DCH)
          {
            /* Get the logical channel mode if a new logical channel is to be established */
            num_dch = ordered_config_ptr->mac_ul_parms.cctrch_ptr->dch_info.ndchs;
            if(num_dch > UE_MAX_TRCH)
            {
              WRRC_MSG1_ERROR("Invalid number %d of UL DCHs in OC", num_dch);
              return(FAILURE);
            }
            if((log_chl_mode = rrcllc_get_log_chan_mode_ul_dch(cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id)) !=
                UE_MODE_MAX_NUM)
            {
              dch_found = TRUE;
            }

            /* Check if it is found in DFLOW too. The new channel could only be mapped on HSDSCH only also */
            if(ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_EHS)
            {
              hs_log_chl_mode = rrcllc_get_ehs_log_chan_mode(cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id);
              if(hs_log_chl_mode != UE_MODE_MAX_NUM)
              {
                WRRC_MSG1_MED("MACEHS: RBId %d is mapped to MACEHS queue",cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id);
                queue_found = TRUE;
              }
            }
            else if(ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_HS)
            {
              if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
              {
                if((hs_log_chl_mode = rrcllc_get_hs_log_chan_mode(cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id)) !=
                  UE_MODE_MAX_NUM)
                {
                  dflow_found = TRUE;
                }
              }
            }


            /* Check EDCH mapping info as RB may be mapped to just EDCH and not dch */
            e_log_chan_mode = rrcllc_get_e_dch_log_chan_mode(cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id);
            
            if (e_log_chan_mode != UE_MODE_MAX_NUM) 
            {
              if (log_chl_mode == UE_MODE_MAX_NUM) 
              {
                WRRC_MSG1_MED("RRCEUL: Log channel mapped to EDCH only mode%d",e_log_chan_mode);
                log_chl_mode = e_log_chan_mode;
              }
              WRRC_MSG1_MED("RRCEUL: RB_ID %d mapped to EDCH", 
                       cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id);
              e_mac_d_flow_found = TRUE;
            }

            if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
            {
              /* Preventive Check */
              if (((dch_found == TRUE) &&
                (dflow_found == TRUE 
                || queue_found == TRUE
                 )) &&
                 (hs_log_chl_mode != log_chl_mode))
              {
                WRRC_MSG2_ERROR("RRCHS:HSLog Ch Mode %d, DCH Mode %d", hs_log_chl_mode,log_chl_mode);
                return FAILURE;
              }
              if((dch_found == FALSE) && (dflow_found == FALSE) &&(queue_found == FALSE)
                 &&(e_mac_d_flow_found == FALSE)
                )
              {
                /* This is a Cell_FACH case when DCCHs are mapped to FACH instead of DCH.
                 * We do not handle it at present
                 */

                if(rrcllc_check_rb_id_exist_rb_mapping(cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id,&rb_mapping_index) == TRUE )
                {
                  log_chl_mode = rrc_ordered_hanging_rb_mapping[rb_mapping_index].logch_mode;
                }
                else
                {
                  WRRC_MSG1_ERROR("RB %d not mapped to DCH/HSDSCH/EDCH in OC, do NOT handle this case and not a Hanging RB",
                                  cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id);
                  return(FAILURE);
                }
              }
              else
              {
                if(log_chl_mode == UE_MODE_ACKNOWLEDGED)
                {
                  /* Set the mode to ACKNOWLEDGED_DATA since that is what LCM expects */
                  log_chl_mode = UE_MODE_ACKNOWLEDGED_DATA;
                }
              } /* DCH is found */
            }
            else
            {
              if(dch_found == FALSE)
              {
                /* This is a Cell_FACH case when DCCHs are mapped to FACH instead of DCH.
                 * We do not handle it at present
                 */
                if(rrcllc_check_rb_id_exist_rb_mapping(cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id,&rb_mapping_index) == TRUE )
                {
                  log_chl_mode = rrc_ordered_hanging_rb_mapping[rb_mapping_index].logch_mode;
                }
                else
                {
                  WRRC_MSG1_ERROR("RB %d not mapped to DCH/HSDSCH/EDCH in OC, do NOT handle this case and not a Hanging RB",
                                  cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id);
                  return(FAILURE);
                }
              }
              else
              {
                if(log_chl_mode == UE_MODE_ACKNOWLEDGED)
                {
                  /* Set the mode to ACKNOWLEDGED_DATA since that is what LCM expects */
                  log_chl_mode = UE_MODE_ACKNOWLEDGED_DATA;
                }
              } /* DCH is found */
            }

          } /* Next RRC state is Cell_DCH */
          else if(rrcllc_cmd_under_process.next_rrc_state ==
                  RRC_STATE_CELL_FACH)
          {
            /* Update DL and UL MAC Info in Ordered Config */
            num_dlchan = ordered_config_ptr->mac_ul_parms.cctrch_ptr->
                          rach_info.ndlchan;

            for(dlchl_count=0; dlchl_count< num_dlchan; dlchl_count++)
            {
              if((ordered_config_ptr->mac_ul_parms.cctrch_ptr->rach_info.
                  dlchan_info[dlchl_count].rb_id ==
                    cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id) &&
                 (ordered_config_ptr->mac_ul_parms.cctrch_ptr->rach_info.
                  dlchan_info[dlchl_count].chan_type ==
                    log_chl_type))
              {
                log_chl_mode  = ordered_config_ptr->mac_ul_parms.cctrch_ptr->
                                  rach_info.dlchan_info[dlchl_count].rlc_mode;

                break;
              }
            } /* For all Ded Log channels */
#ifdef FEATURE_WCDMA_HS_RACH
            if(TRUE == cedch_trans_in_oc)
            {
              log_chl_mode = rrcllc_get_e_dch_log_chan_mode(cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id);
            }
#endif
                if(log_chl_mode == UE_MODE_ACKNOWLEDGED)
                {
                  /* Set the mode to ACKNOWLEDGED_DATA since that is what LCM expects */
                  log_chl_mode = UE_MODE_ACKNOWLEDGED_DATA;
                }
          } /* Next RRC state is Cell_FACH */
        } /* (log_chl_action == RLC_ESTABLISH) */
        else
        {
          /* This is a modify or release case. In both cases, the logical
           * channel is already up and LCM should have the mode info
           */
          /* First get the logical channel ID from RB ID */
          rlc_dl_log_chl_id = rrclcm_get_dl_rlc_lc_id
            (
              cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id
            );
          if(rlc_dl_log_chl_id == RRCLCM_RLC_LC_ID_NOT_FOUND)
          {
            WRRC_MSG1_ERROR("No log chl for RB %d in LCM",
                cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id);
            return(FAILURE);
          }
          /* Now get the mode from the logical channel */
          if( rrclcm_get_dl_rlc_mode(rlc_dl_log_chl_id, &log_chl_mode)
              == RRCLCM_FAILURE)
          {
            WRRC_MSG1_ERROR("No info for DL Log Chl ID %d", rlc_dl_log_chl_id);
            return(FAILURE);
          }
          if(ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_EHS)
          {
            hs_log_chl_mode = rrcllc_get_ehs_log_chan_mode(cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id);
            if(hs_log_chl_mode != UE_MODE_MAX_NUM)
            {
              WRRC_MSG1_HIGH("MACEHS: RBId %d is mapped to MACEHS queue",cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id);
              queue_found = TRUE;
            }
          }
          else if(ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_HS)
          {
            if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
            {
              /* Check if this RB is mapped onto a DFLOW */
              if (rrcllc_check_if_rb_mapped_on_dflow(ordered_config_ptr,
                                                     cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id) == TRUE)
              {
                WRRC_MSG0_HIGH("Set DFLOW found to TRUE");
                dflow_found = TRUE;
              }
            }
          }            
        } /* This is a Modify/Delete case */
      } /* RB Establish/Release/Reconfig */
      else
      {
        valid_rb_action = FALSE;
        WRRC_MSG2_ERROR("Operation %d on RB ID %d unsupported",
          cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_config,cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id);
        break;
      }
    }  /* Action on User plane RB */
    else
    {
      valid_rb_action = FALSE;
      WRRC_MSG2_ERROR("Invalid RB ID %d at index %d",
        cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id, rb_count);
      continue;
    }

    if(valid_rb_action == TRUE)
    {
      valid_rb_action = FALSE;

      if(log_chl_action  == RLC_ESTABLISH)
      {
        if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
        {
          if ((rrclbt_is_lb_on()) && (dflow_found == TRUE 
               || queue_found == TRUE
              ) && (hs_log_chl_mode == UE_MODE_UNACKNOWLEDGED) && 
              (cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id > DCCH_DT_LOW_PRI_RADIO_BEARER_ID))
          {
            WRRC_MSG1_HIGH("HSDPA Loop Back Mode for UM RB %d", 
                     cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id);
            log_chl_mode = hs_log_chl_mode;
            hsdpa_loopback_um_in_progress = TRUE;
          }
        }
        /* Allocate new Logical channel IDs for Uplink and Downlink channels */

        if(srb5_exists != TRUE)
        {
          rlc_ul_log_chl_id = rrclcm_allocate_ul_rlc_lc_id
                            (
                              log_chl_type,
                              cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id,
                              log_chl_mode,
                              &ul_log_chl_queue
                            );
        }

        rlc_dl_log_chl_id = rrclcm_allocate_dl_rlc_lc_id
                            (
                              log_chl_type,
                              cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id,
                              log_chl_mode,
                              &dl_log_chl_queue
                            );
      }
      else if((log_chl_action == RLC_MODIFY) 
                ||(log_chl_action == RLC_RELEASE))
      {
        /* Get the Uplink and Downlink Logical channel ID of the existing channel */
        rlc_ul_log_chl_id = rrclcm_get_ul_rlc_lc_id
                            (
                              cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id
                            );

        rlc_dl_log_chl_id = rrclcm_get_dl_rlc_lc_id
                            (
                              cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id
                            );


      }

      if((srb5_exists == TRUE) && (rlc_dl_log_chl_id != RRCLCM_RLC_LC_ID_ERROR))
      {      
        srb5_exists = FALSE; /* Reset SRB#5 flag status */

        if(log_chl_action  == RLC_ESTABLISH)
        {
          uint8 trch_idx;
          
          rrcllc_update_oc_with_srb5_lcid(rlc_dl_log_chl_id); 
          WRRC_MSG1_HIGH("SRB#5's Logical Channel ID allocated is - %d .. updated in OC", rlc_dl_log_chl_id);

          trch_idx = rrcllc_find_dl_dch_trch_idx((tr_ch_id_type)ordered_config_ptr->srb5_info.trch_id);

          if (trch_idx >= UE_MAX_TRCH)
          {
            WRRC_MSG1_ERROR("DL DCH TrCH ID %d, no idx found", ordered_config_ptr->srb5_info.trch_id);
            return (FAILURE);
          }

          /* The generic function "get_srb_info_to_setup_r5" updates SRB#5 
             as type DTCH, so overwrite it as type DCCH. Since this DCCH
             has a separate DCH & no multiplexing involved, channel type is
             written at 0th index of dlchan_info.
          */

          ordered_config_ptr->dl_dch_info[trch_idx].dlchan_info[0].chan_type = UE_LOGCHAN_TM_DCCH_DL;
          ordered_config_ptr->dl_dch_info[trch_idx].dlchan_info[0].rlc_id = rlc_dl_log_chl_id;

          ordered_config_ptr->mac_dl_parms.dch_info[trch_idx]->dlchan_info[0].chan_type = UE_LOGCHAN_TM_DCCH_DL;
          ordered_config_ptr->mac_dl_parms.dch_info[trch_idx]->dlchan_info[0].rlc_id = rlc_dl_log_chl_id;
        }
        else if(log_chl_action == RLC_RELEASE)
        {
          rrcllc_init_srb5_info(transition_config.toc_ptr);
          rrcllc_init_srb5_info(ordered_config_ptr);
        }

        /* Update the Cell FACH RB Mapping Info for FACH with Logical Channel ID */
        rrcllc_update_cell_fach_dl_mapping_info_with_log_chl_id(
                      ordered_config_ptr,
                      cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id,
                      rlc_dl_log_chl_id);

        /* Update the DL DCH Info in TOC with Logical Channel ID */
        if(rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_FACH &&
           transition_config.toc_usage != TOC_INVALID)
        {
          rrcllc_update_toc_dl_dch_info_with_log_chl_id(
                      cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id,
                      rlc_dl_log_chl_id);
        }


        /* Update RLC Ordered config data for Downlink TM Channel */
        rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.nchan ++;
        num_chl = rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.nchan;
        if(num_chl < UE_MAX_DL_TM_CHANNEL)
        {
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[num_chl-1].lc_id = rlc_dl_log_chl_id;
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[num_chl-1].lc_type = log_chl_type;
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.dl_tm_act[num_chl-1].action = log_chl_action;
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.dl_tm_act[num_chl-1].ul_cfg_mask = 0;
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.dl_tm_act[num_chl-1].dl_cfg_mask = dl_cfg_mask;
          WRRC_MSG3_MED("RLC MULTIPLE: DL TM UL Mask is %x and DL Mask is %x and action is %d <0:RLC_ESTABLISH 1:RLC_RELEASE 2:RLC_MODIFY>",ul_cfg_mask,dl_cfg_mask,log_chl_action);
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.dl_tm_act[num_chl-1].act_incl = FALSE;
          /* TBD: hardcode segmentation indication to FALSE */
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[num_chl-1].seg_ind = FALSE;
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[num_chl-1].rb_id = 
            cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id;
          /* Update the watermark pointer to that of SRB#5's */
          if(rrclcm_update_db_with_srb5_wmq_info(rlc_dl_log_chl_id) == FALSE)
          {
            WRRC_MSG0_ERROR("Updating LCM with SRB#5 WMQ pointer failed");
            return(FAILURE);
          }
        }
        else
        {
          WRRC_MSG1_ERROR("Number of DL TM Log Chl %d", num_chl);
          return(FAILURE);
        }        
      }
      else
      /*=======================================================*
       * Update RLC Config Data                                *
       *=======================================================*/
      /* Check if able to successfully allocate UL and DL logical channel IDs */
      if((rlc_ul_log_chl_id != RRCLCM_RLC_LC_ID_ERROR) &&
         (rlc_dl_log_chl_id != RRCLCM_RLC_LC_ID_ERROR))
      {
        if(log_chl_mode == UE_MODE_TRANSPARENT)
        {
          /* Update RLC Ordered config data for Uplink */
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.nchan ++;
          num_chl = rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.nchan;
          if(num_chl < UE_MAX_UL_TM_CHANNEL)
          {
            rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.chan_info[num_chl-1].lc_id = rlc_ul_log_chl_id;
            rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.chan_info[num_chl-1].lc_type = log_chl_type;
            rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.ul_tm_act[num_chl-1].action = log_chl_action;
            rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.ul_tm_act[num_chl-1].dl_cfg_mask = 0;
            rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.ul_tm_act[num_chl-1].ul_cfg_mask = ul_cfg_mask;
            WRRC_MSG3_MED("RLC MULTIPLE: UL TM UL Mask is %x and DL Mask is %x and action is %d<0:RLC_ESTABLISH 1:RLC_RELEASE 2:RLC_MODIFY>",ul_cfg_mask,dl_cfg_mask,log_chl_action);
            rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.ul_tm_act[num_chl-1].act_incl = FALSE;
            /* TBD: Interface with OC needed to get timer discard value */
            rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.chan_info[num_chl-1].timer_discard = 0;
            /* TBD: Hard coded value of segmentation indication for now */
            rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.chan_info[num_chl-1].seg_ind = FALSE;
            rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.chan_info[num_chl-1].rb_id = 
              cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id;
          }
          else
          {
            WRRC_MSG1_ERROR("Number of UL TM Log Chl %d", num_chl);
            return(FAILURE);
          }

          /* Update RLC Ordered config data for Downlink */
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.nchan ++;
          num_chl = rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.nchan;
          if(num_chl < UE_MAX_DL_TM_CHANNEL)
          {
            rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[num_chl-1].lc_id = rlc_dl_log_chl_id;
            rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[num_chl-1].lc_type = log_chl_type;
            rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.dl_tm_act[num_chl-1].action = log_chl_action;
            rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.dl_tm_act[num_chl-1].ul_cfg_mask = 0;
            rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.dl_tm_act[num_chl-1].dl_cfg_mask = dl_cfg_mask;
            WRRC_MSG3_MED("DL TM RLC MULTIPLE: UL Mask is %x and DL Mask is %xand action is %d<0:RLC_ESTABLISH 1:RLC_RELEASE 2:RLC_MODIFY>",ul_cfg_mask,dl_cfg_mask,log_chl_action);
            rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.dl_tm_act[num_chl-1].act_incl = FALSE;
            /* TBD: hardcode segmentation indication to FALSE */
            rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[num_chl-1].seg_ind = FALSE;
            rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[num_chl-1].rb_id = 
              cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id;
          }
          else
          {
            WRRC_MSG1_ERROR("Number of DL TM Log Chl %d", num_chl);
            return(FAILURE);
          }
        } /* if(log_chl_mode == UE_MODE_TRANSPARENT) */
        else if(log_chl_mode == UE_MODE_UNACKNOWLEDGED)
        {
          /* Update RLC Ordered config data for Uplink */
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.nchan ++;
          num_chl = rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.nchan;
          if(num_chl < UE_MAX_UL_UM_CHANNEL)
          {
            rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.chan_info[num_chl-1].lc_id = rlc_ul_log_chl_id;
            rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.chan_info[num_chl-1].lc_type = log_chl_type;
            rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.ul_um_act[num_chl-1].action = log_chl_action;
            rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.ul_um_act[num_chl-1].ul_cfg_mask = ul_cfg_mask;
            rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.ul_um_act[num_chl-1].dl_cfg_mask = 0;
            WRRC_MSG3_MED("RLC MULTIPLE: UL UM UL Mask is %x and DL Mask is %x and action is %d<0:RLC_ESTABLISH 1:RLC_RELEASE 2:RLC_MODIFY>",ul_cfg_mask,dl_cfg_mask,log_chl_action);
            rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.ul_um_act[num_chl-1].act_incl = FALSE;
            rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.chan_info[num_chl-1].rb_id = 
              cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id;
            if ((k = get_ul_um_index(cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id)) < UE_MAX_UL_UM_CHANNEL)
            {
             rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.chan_info[num_chl-1].timer_discard
                        = ordered_config_ptr->rlc_ul_um_parms.chan_info[k].timer_discard;         
              rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.chan_info[num_chl-1].alternate_e_bit
                        = ordered_config_ptr->rlc_ul_um_parms.chan_info[k].alternate_e_bit;
              ordered_config_ptr->rlc_ul_um_parms.chan_info[k].lc_id = rlc_ul_log_chl_id;
            }

            if(log_chl_action != RLC_RELEASE)
            {
#ifdef FEATURE_MAC_I
              /* Update RLC flexible PDU size data*/
              if(rrcllc_check_edch_flexible_ul_size_configured(ordered_config_ptr,cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id))
              {
                rrcllc_get_edch_ul_rlc_flexible_params(ordered_config_ptr,cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id,&oc_rlc_flexi_ul_size);
                rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.chan_info[num_chl-1].ul_flex_min_pdu_size = oc_rlc_flexi_ul_size.rrc_ul_flex_min_pdu_size;
                rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.chan_info[num_chl-1].ul_flex_max_pdu_size = oc_rlc_flexi_ul_size.rrc_ul_flex_max_pdu_size;
                rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.chan_info[num_chl-1].ul_flex_pdu_size=RLC_FLEXIBLE_PDU_SIZE;
              }
              else
              {		
                rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.chan_info[num_chl-1].ul_flex_pdu_size=RLC_FIXED_PDU_SIZE;				
#endif /* FEATURE_MAC_I */
              rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.chan_info[num_chl-1].rlc_size =
                rrcllc_get_ul_ded_rlc_size(rrcllc_cmd_under_process.next_rrc_state,
                                           cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id);

#ifdef FEATURE_MAC_I
              }
#endif /* FEATURE_MAC_I */
            }
            /* TBD: HFN value and RLC size also needs to be passed here */
          }
          else
          {
            WRRC_MSG1_ERROR("Number of UL UM Log Chl %d", num_chl);
            return(FAILURE);
          }

          /* Update RLC Ordered config data for Downlink */
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.nchan ++;
          num_chl = rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.nchan;
          if(num_chl < UE_MAX_DL_UM_CHANNEL)
          {
            rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[num_chl-1].lc_id = rlc_dl_log_chl_id;
            rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[num_chl-1].lc_type = log_chl_type;
            rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.dl_um_act[num_chl-1].action = log_chl_action;
            rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.dl_um_act[num_chl-1].ul_cfg_mask = 0;
            rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.dl_um_act[num_chl-1].dl_cfg_mask = dl_cfg_mask;
            WRRC_MSG3_MED("RLC MULTIPLE: DL UM UL Mask is %x and DL Mask is %x and action is %d<0:RLC_ESTABLISH 1:RLC_RELEASE 2:RLC_MODIFY>",ul_cfg_mask,dl_cfg_mask,log_chl_action);
            rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.dl_um_act[num_chl-1].act_incl = FALSE;
            rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[num_chl-1].rb_id = 
              cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id;          
            if ((k = get_dl_um_index(cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id, ordered_config_ptr)) < UE_MAX_DL_UM_CHANNEL)
            {         
              rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[num_chl-1].alternate_e_bit
                        = ordered_config_ptr->rlc_dl_um_parms.chan_info[k].alternate_e_bit;	
              ordered_config_ptr->rlc_dl_um_parms.chan_info[k].lc_id = rlc_dl_log_chl_id;
            }
            if(log_chl_action != RLC_RELEASE)
            {
              /* Get RLC size from Ordered Config */
              if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
              {
                if ((log_chl_action == RLC_MODIFY) || (log_chl_action == RLC_ESTABLISH))
                {
                  dl_um_l1 = rrc_get_dl_um_li(cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id);
                
                  if (dl_um_l1 == RRC_DL_UM_INVALID_RLC)
                  {
                    if (log_chl_action == RLC_MODIFY)
                    {
                      /* Get the RLC L1 Indication from the fn call */
                      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.
                        dl_um.chan_info[num_chl-1].li_size = LI_SAME_AS_BEFORE;
                    }
                    else /* For setup */
                    {
                      /* Set LI to 7 bits */
                      WRRC_MSG1_HIGH("RRC:LI size unspecified RB Id %d. Set to 7 bits",
                               cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id);
                      
                      /* Get the RLC L1 Indication */
                      rrcllc_cmd_under_process.chan_config.rlc_config_req_list.
                        dl_um.chan_info[num_chl-1].li_size = LI_7_BITS;
                    }
                  }
                  else
                  {
                    rrcllc_cmd_under_process.chan_config.rlc_config_req_list.
                      dl_um.chan_info[num_chl-1].li_size =
                      (dl_um_l1 == RRC_DL_UM_RLC_LI_SIZE_7) ? LI_7_BITS: LI_15_BITS;
                    WRRC_MSG2_MED("RRC:RB Id %d. LI size %d",
                             cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id,dl_um_l1);
                  }
                }
              }

              rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[num_chl-1].rlc_size =
                rrcllc_get_dl_ded_rlc_size(rrcllc_cmd_under_process.next_rrc_state,
                                           cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id);

              if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
              {
                if (hsdpa_loopback_um_in_progress == FALSE)
                  WRRC_MSG2_MED("RB Id %d, UM DL RLC Size %d", cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id,
                           rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[num_chl-1].rlc_size);
              }
            }
            /* TBD: HFN value also needs to be passed here */
          }
          else
          {
            WRRC_MSG1_ERROR("Number of DL UM Log Chl %d", num_chl);
            return(FAILURE);
          }
        } /* If mode is UE_MODE_UNACKNOWLEDGED */
        else if((log_chl_mode == UE_MODE_ACKNOWLEDGED_DATA) ||
                (log_chl_mode == UE_MODE_ACKNOWLEDGED_CONTROL))
        {
          /* Update RLC data for Downlink in rrcllc_cmd_under_process */
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.nentity ++;
          num_entity = rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.nentity;

          /* Now find the num_entity in Ordered Config */
          for (i=0; i < UE_MAX_AM_ENTITY; i++)
          {
            if((ordered_config_ptr->rlc_am_parms.am_info[i]->common_config.rb_id ==
                  cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id)   &&
               ordered_config_ptr->rlc_am_parms.am_info[i]->ul_nchan &&
               ordered_config_ptr->rlc_am_parms.am_info[i]->dl_nchan
              )
            {
              /* This is the AM entity in Ordered Config for the current RB */
              break;
            }
          }

          if (i < UE_MAX_AM_ENTITY)
          {
            num_oc_entity = i;
          }
          else
          {

#ifdef FEATURE_RRC_L1_ERROR_RECOVERY_P1
            WRRC_MSG0_ERROR("No AM chls.  Taking UE to Idle");
            /* If UE is not taken to idle in this case, UE is stuck in fach with no SRBs expect for CCCH */
            rrcllc_self_enqueue_channel_config_to_idle();
            return(FAILURE);
#else
            ERR_FATAL("No AM chls during DCH_FACH transition",0,0,0);
#endif /* FEATURE_RRC_L1_ERROR_RECOVERY_P1 */

          }

          /* Update RLC Ordered config data for Downlink */
          if(num_entity <= UE_MAX_AM_ENTITY)
          {
            /* Now point towards RLC Ordered Config data from RLC AM data
             * in rrcllc_cmd_under_process
             */
            if(rrcllc_cmd_under_process.chan_config.current_cmd_engine == LLC_CELL_RESELECTION_ENGINE)
            {
              rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_info[num_entity-1] =
                reselection_config_ptr->rlc_am_parms.am_info[num_oc_entity];
            }
            else
            {
              rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_info[num_entity-1] =
                ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity];
            }

            /* Initialize RLC AM action data in rrcllc_cmd_under_process */
            rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_act[num_entity-1].action
                = log_chl_action;
            rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_act[num_entity-1].ul_cfg_mask = ul_cfg_mask;
            rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_act[num_entity-1].dl_cfg_mask = dl_cfg_mask;
            WRRC_MSG3_MED("RLC MULTIPLE:AM UL Mask is %x and DL Mask is %x and action is %d<0:RLC_ESTABLISH 1:RLC_RELEASE 2:RLC_MODIFY>",ul_cfg_mask,dl_cfg_mask,log_chl_action);
            rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_act[num_entity-1].act_incl
                = FALSE;

            if(log_chl_action == RLC_ESTABLISH)
            {
              ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->
                common_config.ul_data_id
                  = rlc_ul_log_chl_id;
              ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->
                common_config.ul_control_id
                  = rlc_ul_log_chl_id;
              /* For now, hard-code number of UL channels/AM entity to 1 */
              ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->ul_nchan = 1;

              ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->
                common_config.dl_data_id
                  = rlc_dl_log_chl_id;
              ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->
                common_config.dl_control_id
                  = rlc_dl_log_chl_id;
              /* For now, hard-code number of DL channels/AM entity to 1 */
              ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->dl_nchan = 1;

              ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->
                common_config.lc_type
                  = log_chl_type;
#ifdef FEATURE_MAC_I
             /* Update RLC flexible PDU size data*/
             if(rrcllc_check_edch_flexible_ul_size_configured(ordered_config_ptr,cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id))
             {
               rrcllc_get_edch_ul_rlc_flexible_params(ordered_config_ptr,cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id,&oc_rlc_flexi_ul_size);
               ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->rlc_ul_am_config.ul_flex_min_pdu_size= oc_rlc_flexi_ul_size.rrc_ul_flex_min_pdu_size;
               ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->rlc_ul_am_config.ul_flex_max_pdu_size= oc_rlc_flexi_ul_size.rrc_ul_flex_max_pdu_size;
               ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->rlc_ul_am_config.ul_flex_pdu_size=RLC_FLEXIBLE_PDU_SIZE;

               MSG_4(MSG_SSID_DFLT, MSG_LEGACY_HIGH,"MAC_I RLC Establish UL flexible size for AM RB Id %d Max. RLC Size %d Min RLC size %d,LI size %d",
                     cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id, oc_rlc_flexi_ul_size.rrc_ul_flex_max_pdu_size,oc_rlc_flexi_ul_size.rrc_ul_flex_min_pdu_size,
                     oc_rlc_flexi_ul_size.rrc_ul_li_size);
               if(oc_rlc_flexi_ul_size.rrc_ul_li_size != LI_UNSPECIFIED)
               {
                 ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->rlc_ul_am_config.ul_li_size = oc_rlc_flexi_ul_size.rrc_ul_li_size;
               }
               else
               {
                  return (FAILURE);
               }
             }
             else
             {
               ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->rlc_ul_am_config.ul_flex_pdu_size=RLC_FIXED_PDU_SIZE;
#endif /* FEATURE_MAC_I */
              /* Fill in the RLC size */
              ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->
                rlc_ul_am_config.ul_rlc_size =
                rrcllc_get_ul_ded_rlc_size(rrcllc_cmd_under_process.next_rrc_state,
                                           cmd_ptr->cmd.chan_config_req.
                                           rb[rb_count].rb_id);
#ifdef FEATURE_MAC_I
             }
#endif /* FEATURE_MAC_I */

              if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
              {

                if(dflow_found 
                    || queue_found
                  )
                {
                  hsdpa_found = TRUE;
                }

                /* Check if DFLOW Found and next RRC state is CELL_DCH/CELL_FACH. */
                if ((hsdpa_found)&& ((rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_DCH) ||
                  (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_FACH)))
                {
                  if(ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->rlc_dl_am_config.am_pdu_size_flexbile == TRUE )
                  {
                    WRRC_MSG2_MED("MACEHS:Est:Flex PDU RLC LI SIZE is %d for RB %d", ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->
                    rlc_dl_am_config.am_li_type,cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id);
                  }
                  else
                  {
                  WRRC_MSG2_MED("RRCHS:Est:RLC PDU SIZE is %d for RB %d", ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->
                  rlc_dl_am_config.dl_rlc_size,cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id);
                  }

                  /* Reset the dflow flag */
                  dflow_found = FALSE;
                  queue_found = FALSE;
                  hsdpa_found= FALSE;
                  /* Size has already been set */
                }

                /* If this new RB is not mapped on HSDSCH & PDU size not specified, then it is mapped on DCH/FACH. Rel 99 Scenario */
                else if ((hsdpa_found == FALSE) && (rrc_get_dl_am_rlc_pdu_size(cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id) ==
                                                    INVALID_DL_AM_PDU_RLC_SIZE) && 
                         ((rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_DCH) || 
                          (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_FACH)))
                {
                  /* Means PDU Size unspecified. So use the calculated one */
                  WRRC_MSG1_HIGH("RRCHS:Est:RLC DL AM PDU Size unspecified for RB %d.",
                    cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id);

                  /* Calculate the RLC PDU Size */
                  ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->
                    rlc_dl_am_config.dl_rlc_size =
                    rrcllc_get_dl_ded_rlc_size(rrcllc_cmd_under_process.next_rrc_state,
                    cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id);

                  MSG_HIGH("RRCHS:RB %d Calculated RLC DL AM PDU Size %d for %d st",
                    cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id,
                    ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->
                    rlc_dl_am_config.dl_rlc_size,rrcllc_cmd_under_process.next_rrc_state);

                }

                /* Next state could be DCH/FACH with RLC size specified for Rel 5 DCH/FACH */
                else if ((hsdpa_found == FALSE) && (rrc_get_dl_am_rlc_pdu_size(cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id) !=
                                                    INVALID_DL_AM_PDU_RLC_SIZE) && 
                         ((rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_DCH) || 
                          (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_FACH) ||
                          (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_PCH) ||
                          (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_URA_PCH)))
                {
                  MSG_HIGH("RRCHS:Est:RB %d DL RLC AM size %d for %d st", cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id,ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->
                  rlc_dl_am_config.dl_rlc_size,rrcllc_cmd_under_process.next_rrc_state);
                }
                else
                {
                  /* Means PDU Size unspecified. So use the calculated one */
                  WRRC_MSG1_HIGH("RRCHS:Est:RLC DL AM PDU Size unspecified for RB %d.",
                    cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id);

                  ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->
                    rlc_dl_am_config.dl_rlc_size =
                    rrcllc_get_dl_ded_rlc_size(rrcllc_cmd_under_process.next_rrc_state,
                    cmd_ptr->cmd.chan_config_req.
                    rb[rb_count].rb_id);

                  MSG_HIGH("RRCHS:RB %d Calculated RLC PDU Size is %d",
                    cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id,
                    ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->
                    rlc_dl_am_config.dl_rlc_size,0);

                }
              }
              else
              {

                ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->
                  rlc_dl_am_config.dl_rlc_size =
                  rrcllc_get_dl_ded_rlc_size(rrcllc_cmd_under_process.next_rrc_state,
                                           cmd_ptr->cmd.chan_config_req.
                                           rb[rb_count].rb_id);
              }

              /* Now point towards RLC Ordered Config data from RLC AM data
               * in rrcllc_cmd_under_process
               */
              if(rrcllc_cmd_under_process.chan_config.current_cmd_engine == LLC_CELL_RESELECTION_ENGINE)
              { 
                rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_info[num_entity-1] =
                 reselection_config_ptr->rlc_am_parms.am_info[num_oc_entity];
              } 
              else
              { 
                rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_info[num_entity-1] =
                 ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity];
              } 

            } /* If logical channel action is RLC_ESTABLISH */
            else if(log_chl_action == RLC_MODIFY)
            {
              /*Fill the LC IDs in RLC database in modify case also because
              in the below scenario LC IDs will be configured as 0.
              Rbsetup taking UE from DCH to FACH. Here OC is copied to TOC. 
              Now when RLC is configured LC IDs are filled in OC.These are not updated in TOC.
              If CU is triggered and is waiting for CUCNF. OOS happens now. 
              Then UE re-enters service. Now we copy the TOC contents to OC. 
              So the LC IDs are not present in OC and end up configuring 0 to RLC  
              */

              ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->
                common_config.ul_data_id
                  = rlc_ul_log_chl_id;
              ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->
                common_config.ul_control_id
                  = rlc_ul_log_chl_id;

              ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->
                common_config.dl_data_id
                  = rlc_dl_log_chl_id;
              ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->
                common_config.dl_control_id
                  = rlc_dl_log_chl_id;

              
              /* Fill in the RLC size */
#ifdef FEATURE_MAC_I
              if( rrcllc_check_edch_flexible_ul_size_configured(ordered_config_ptr,cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id))
              {
                 
                rrcllc_get_edch_ul_rlc_flexible_params(ordered_config_ptr,cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id,&oc_rlc_flexi_ul_size);
                
                ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->rlc_ul_am_config.ul_flex_pdu_size=RLC_FLEXIBLE_PDU_SIZE;
                ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->rlc_ul_am_config.ul_flex_min_pdu_size= oc_rlc_flexi_ul_size.rrc_ul_flex_min_pdu_size;
                ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->rlc_ul_am_config.ul_flex_max_pdu_size= oc_rlc_flexi_ul_size.rrc_ul_flex_max_pdu_size;
                /*Checked with RLC folks to find out that sending of LI_SAME_AS_BEFORE
                  can be avoided as there is no requirement from RLC to receive LI_SAME_AS_BEFORE ever. 
                  When LI_SAME_AS_BEFORE is sent to RLC, 
                  RLC looks at its old global to pick the correct value. So no harm if RRC can 
                  provide this value explicitly always in place of sending LI_SAME_AS_BEFORE. 
                  So now RRC will not send LI_SAME_AS_BEFORE ever for AM RBs. For UM RBs it will
                  still send LI_SAME_AS_BEFORE as logic for UM is different. 				   
                */              
                ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->rlc_ul_am_config.ul_li_size = oc_rlc_flexi_ul_size.rrc_ul_li_size;

                MSG_HIGH("MAC_I: RLC Modify UL flexible size for AM RB Id %d Max. RLC Size %d Min RLC size %d", cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id,
                         oc_rlc_flexi_ul_size.rrc_ul_flex_max_pdu_size,oc_rlc_flexi_ul_size.rrc_ul_flex_min_pdu_size);							
              }
              else
              {
                  /* Fill in the RLC size */
                ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->rlc_ul_am_config.ul_flex_pdu_size=RLC_FIXED_PDU_SIZE;
#endif /* FEATURE_MAC_I */
              ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->
                rlc_ul_am_config.ul_rlc_size =
                rrcllc_get_ul_ded_rlc_size(rrcllc_cmd_under_process.next_rrc_state,
                                           cmd_ptr->cmd.chan_config_req.
                                           rb[rb_count].rb_id);
#ifdef FEATURE_MAC_I
              }
#endif /* FEATURE_MAC_I */
              if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
              { 

                if(dflow_found 
                   || queue_found
                  )
                {
                  hsdpa_found = TRUE;
                }
                /* Check if Modify RB is for DFLOW and next state is DCH. If new size provided,
                it is already overwritten in OC and is now being used. Also secanrio is valid
                for DCH-->HSDSCH case when RLC SIZE is not provided. Here we use the old RLC Size */
                if ((hsdpa_found == TRUE) && ((rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_DCH) ||
                                              (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_FACH)))
                {
                  if(ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->rlc_dl_am_config.am_pdu_size_flexbile == TRUE )
                  {
                    WRRC_MSG2_HIGH("MACEHS:Mod:Flex PDU RLC LI SIZE is %d for RB %d", ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->
                    rlc_dl_am_config.am_li_type,cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id);
                  }
                  else
                  {
                  WRRC_MSG2_HIGH("RRCHS:Mod: Rb %d, RLC DL AM PDU SIZE %d",
                           cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id,
                           ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->
                           rlc_dl_am_config.dl_rlc_size);
                  }

                  /* Reset the dflow flag */
                  dflow_found = FALSE;
                  queue_found = FALSE;
                  hsdpa_found= FALSE;
                }

                /* Check if NW had explicitly indicated the DL PDU size in the message */
                if(ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->rlc_dl_am_config.am_pdu_size_flexbile)
                {
                  WRRC_MSG1_HIGH("MACEHS: Flexible PDU Size in OC for AM entity %d",num_oc_entity);
                  pdu_size_present = TRUE;
                }
                else
                {
                  pdu_size_present = 
                  ((rrc_get_dl_am_rlc_pdu_size(cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id) == 
                    INVALID_DL_AM_PDU_RLC_SIZE) ? FALSE: TRUE);
                
                }
                /* In case of Standalone RBs, if there is no old size or Old and new RLC sizes are different, 
                  Recalculate the RLC DL size in thas case */
                if((hsdpa_found == FALSE) && (pdu_size_present == FALSE) &&
                      (( ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->rlc_dl_am_config.dl_rlc_size 
                      == RRCLLC_INVALID_RLC_SIZE)||(ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->
                      rlc_dl_am_config.dl_rlc_size != rrcllc_get_dl_ded_rlc_size(rrcllc_cmd_under_process.next_rrc_state, 
                      cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id))) 
                      && ((rrcllc_cmd_under_process.next_rrc_state == 
                      RRC_STATE_CELL_DCH) ||(rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_FACH)))
                {
                  if((rrcllc_get_dl_ded_rlc_size(rrcllc_cmd_under_process.next_rrc_state, 
                        cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id)!= RRCLLC_INVALID_RLC_SIZE)
                        && (rrcllc_check_if_rb_mapped_on_dflow(ordered_config_ptr, 
                        cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id) == FALSE)
                     && (rrcllc_get_am_dl_rlc_size_ota(cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id)
                          == RRCLLC_INVALID_RLC_SIZE)
                        )
                  {                
                    ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->rlc_dl_am_config.dl_rlc_size = 
                          rrcllc_get_dl_ded_rlc_size(rrcllc_cmd_under_process.next_rrc_state, 
                          cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id);
  
                    pdu_size_present = TRUE;
  
                    MSG_HIGH("Mod RB ID %d,Recalculated RLC DL AM PDU Size is %d sizepresent %d",
                          cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id, ordered_config_ptr->rlc_am_parms.
                          am_info[num_oc_entity]->rlc_dl_am_config.dl_rlc_size,pdu_size_present);
                  }
                }
#ifdef FEATURE_MAC_I
                if(rrcllc_check_edch_flexible_ul_size_configured(ordered_config_ptr,cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id))
                {
                  pdu_size_present = TRUE;
                }
                else
#endif
                if(pdu_size_present == FALSE)
                {
                   rlc_size_old = RRCLLC_INVALID_RLC_SIZE;
                   rlc_size_new = RRCLLC_INVALID_RLC_SIZE;
  
                  rlc_size_old = rrcllc_get_am_rlc_size_for_rb(cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id, UL);
                  rlc_size_new = rrcllc_get_ul_ded_rlc_size(ordered_config_ptr->rrc_state_indicator, cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id);
              					
                  if((rlc_size_old != RRCLLC_INVALID_RLC_SIZE) && (rlc_size_new != RRCLLC_INVALID_RLC_SIZE) 
                          && (rlc_size_old != rlc_size_new))
                  {
                     pdu_size_present = TRUE;
                     WRRC_MSG2_HIGH("UL RB %d,sizepresent %d",cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id,
                                    pdu_size_present);      
                  }
                }
               
                /* Now check if DL RLC Size has changed */
                /***************************/
                
                if ((cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id > DCCH_DT_LOW_PRI_RADIO_BEARER_ID) && 
                    ((rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_DCH) ||
                     (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_PCH) ||
                     (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_URA_PCH) ||
                     (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_FACH)))
                {
                  
				  MSG_4(MSG_SSID_DFLT, MSG_LEGACY_HIGH,"RB %d, Next RRC State %d, RRCHS:Rb %d,OC RLCSize %d",cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id,
				  	rrcllc_cmd_under_process.next_rrc_state,cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id,
				  	ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->rlc_dl_am_config.dl_rlc_size);
                  
                  if (pdu_size_present == TRUE)
                  {
                    WRRC_MSG0_MED("RRCHS:rlcsizeindicated");
                    
                    /* Check if RLC Size Change indicator set */
                    if ((ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->reestab_entity == RLC_RE_ESTABLISH_DL)  ||
                        (ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->reestab_entity == RLC_RE_ESTABLISH_DL_UL)  ||
                        (ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->reestab_entity == RLC_RE_ESTABLISH_UL))
                    {
                      WRRC_MSG2_HIGH("RB %d RLCSIZECHANGED, Re-establish %d", cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id,
                               ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->reestab_entity);
                      /* Check if SRNS Relocation is in progress */
                      if (!((rrcrb_is_srns_in_progress() == TRUE) ||
                            ((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CU) &&
                             (ps_rb_re_establish_indicator == TRUE))))
                      {
                        WRRC_MSG2_HIGH("RRCHS:RB %d,Reestab(0:B,1:Dl,2:UL,3:N) %d", 
                                 cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id,ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->reestab_entity);
                        
                        if (((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RBRC) || 
                              (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RBE) ||
                              (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RBR) ||
                              (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_TCR) ||
                              (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_PCR)  ) &&
                            (rrcllc_cmd_under_process.next_rrc_state != RRC_STATE_CELL_PCH) &&
                            (rrcllc_cmd_under_process.next_rrc_state != RRC_STATE_URA_PCH))
                        {
                          rrc_set_rlc_size_change_status(rrcllc_cmd_under_process.procedure, 
                                                         TRUE,
                                                         cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id,
                                                         ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->reestab_entity);
                          if ((smc_extract_value_invoked == FALSE) && (!rrcrb_is_cu_required()))
                          {
                            (void)rrcsmc_extract_return_hfn_per_domain_and_update_start_flag(RRC_PS_DOMAIN_CN_ID);
                            smc_extract_value_invoked = TRUE;
                          }
                          else
                          {
                            WRRC_MSG1_HIGH("Not invoking extract HFN fn for RB %d", 
                                     cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id);
                          }
                        }
                        if (ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->reestab_entity == RLC_RE_ESTABLISH_DL)
                        {
                          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_act[num_entity-1].dl_cfg_mask |= RLC_RE_ESTABLISH_CFG;
                          WRRC_MSG3_MED("RLC MULTIPLE: UL Mask is %x and DL Mask is %x and action is %d<0:RLC_ESTABLISH 1:RLC_RELEASE 2:RLC_MODIFY>, RRCHS:reestablishdl",rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_act[num_entity-1].ul_cfg_mask
                            ,rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_act[num_entity-1].dl_cfg_mask,log_chl_action);
                          
                          /* Get Ciphering parameters from SMC */
                          rrcsmc_get_latest_transmitted_start_values(&start_list);
                          
                          /* Set DL & UL HFN and Ciphering Algorithm */
                          ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->rlc_dl_am_config.hfn = 
                            start_list.hfn_rab;
                          
                          ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->rlc_dl_am_config.ciph_algo = 
                            start_list.ciph_algo_urb;
                          
                          /* Change action to Re-establish as per RLC Request */
                          ordered_config_ptr->am_config[num_oc_entity].reestab_entity = RLC_RE_ESTABLISH_DL;
                        }
                        else if (ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->reestab_entity == RLC_RE_ESTABLISH_DL_UL)
                        {
                          /* Get Ciphering parameters from SMC */
                          rrcsmc_get_latest_transmitted_start_values(&start_list);
                          
                          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_act[num_entity-1].dl_cfg_mask |= RLC_RE_ESTABLISH_CFG;
                          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_act[num_entity-1].ul_cfg_mask |= RLC_RE_ESTABLISH_CFG;
                          WRRC_MSG3_MED("RLC MULTIPLE: UL Mask is %x and DL Mask is %xand action is %d<0:RLC_ESTABLISH 1:RLC_RELEASE 2:RLC_MODIFY>, RRCHS:reestablishdlul",rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_act[num_entity-1].ul_cfg_mask
                            ,rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_act[num_entity-1].dl_cfg_mask,log_chl_action);
                          
                          /* Set DL & UL HFN and Ciphering Algorithm */
                          ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->rlc_dl_am_config.hfn = 
                            start_list.hfn_rab;
                                                    
                          ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->rlc_ul_am_config.hfn = 
                            start_list.hfn_rab;
                          
                          ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->rlc_dl_am_config.ciph_algo = 
                            start_list.ciph_algo_urb;
                          ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->rlc_ul_am_config.ciph_algo = 
                            start_list.ciph_algo_urb;
                          
                          ordered_config_ptr->am_config[num_oc_entity].reestab_entity = RLC_RE_ESTABLISH_DL_UL;
                          
                        }
                        else if (ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->reestab_entity == RLC_RE_ESTABLISH_UL)
                        {
                          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_act[num_entity-1].ul_cfg_mask |= RLC_RE_ESTABLISH_CFG;
                          WRRC_MSG3_MED("RLC MULTIPLE: UL Mask is %x and DL Mask is %x and action is %d<0:RLC_ESTABLISH 1:RLC_RELEASE 2:RLC_MODIFY>, RRCHS:reestablishul",rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_act[num_entity-1].ul_cfg_mask
                            ,rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_act[num_entity-1].dl_cfg_mask,log_chl_action);
                          
                          /* Get Ciphering parameters from SMC */
                          rrcsmc_get_latest_transmitted_start_values(&start_list);
                          
                          /* Set DL & UL HFN and Ciphering Algorithm */
                          ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->rlc_ul_am_config.hfn = 
                            start_list.hfn_rab;
                          
                          ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->rlc_ul_am_config.ciph_algo = 
                            start_list.ciph_algo_urb;
                          
                          /* Change action to Re-establish as per RLC Request */
                          ordered_config_ptr->am_config[num_oc_entity].reestab_entity = RLC_RE_ESTABLISH_UL;
                        }
                        else
                        {
                          WRRC_MSG0_HIGH("RRCHS:reestablishnone");
                          /* Indicate to RLC that RLC size has not changed */
                        }
                      } /* SRNS Relocation is not in progress */
                      else
                      {
                        WRRC_MSG0_HIGH("SRNSRELOCATION or Re-est thr CU in progress");
                      }
                    } /* Compare RLC Size Change */
                  } /* PDU Size present */
                } 
              }
              else
              {  
                ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity]->
                  rlc_dl_am_config.dl_rlc_size =
                  rrcllc_get_dl_ded_rlc_size(rrcllc_cmd_under_process.next_rrc_state,
                                           cmd_ptr->cmd.chan_config_req.
                                           rb[rb_count].rb_id);
              }
              /* Now point towards RLC Ordered Config data from RLC AM data
               * in rrcllc_cmd_under_process
               */
              if(rrcllc_cmd_under_process.chan_config.current_cmd_engine == LLC_CELL_RESELECTION_ENGINE)
              { 
                rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_info[num_entity-1] =
                 reselection_config_ptr->rlc_am_parms.am_info[num_oc_entity];
              }
              else
              { 
                rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_info[num_entity-1] =
                  ordered_config_ptr->rlc_am_parms.am_info[num_oc_entity];
              } 
              /* RLC_MODIFY_CFG    0x0001  
                Remove RLC_MODIFY_CFG from the cfg_mask if RLC_RE_ESTABLISH_CFG is already set
                as the EVENT_WCDMA_RLC_CONFIG is redundant, once for RLC_RE_ESTABLISH_CFG and once more for RLC_MODIFY_CFG*/
			  
              if((rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_act[num_entity-1].ul_cfg_mask & (RLC_RE_ESTABLISH_CFG| RLC_MODIFY_CFG)) == (RLC_RE_ESTABLISH_CFG| RLC_MODIFY_CFG))
              {
	        rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_act[num_entity-1].ul_cfg_mask &=~ RLC_MODIFY_CFG ;				
              }
	      if((rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_act[num_entity-1].dl_cfg_mask & (RLC_RE_ESTABLISH_CFG| RLC_MODIFY_CFG)) == (RLC_RE_ESTABLISH_CFG| RLC_MODIFY_CFG))
              {
                rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_act[num_entity-1].dl_cfg_mask &=~ RLC_MODIFY_CFG ;				
	      }
            }
          }
          else
          {
            WRRC_MSG1_ERROR("Number of am entities %d exceed limit", num_entity);
            return(FAILURE);
          }
        } /* Mode is Acknowledged Data or Acknowledged Control */

        /*=======================================================*
         * Update MAC Ordered Config data                         *
         *=======================================================*/

        /* If logical channel action is RLC_RELEASE, we presume that MAC Ordered
         * Config data does not need any updation and the Number of DCHs would have
         * been updated by Ordered Config already.
         */
        if(log_chl_action != RLC_RELEASE)
        {
          if(rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_DCH)
          {
            /* Update MAC data for Uplink */
            num_dch = ordered_config_ptr->mac_ul_parms.cctrch_ptr->dch_info.ndchs;
            if(num_dch > UE_MAX_TRCH)
            {
              WRRC_MSG1_ERROR("Invalid number %d of UL DCHs in OC", num_dch);
              return(FAILURE);
            }
            dch_found = rrcllc_check_if_ul_dch_exist_and_update_rlc_id(cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id,
                              rlc_ul_log_chl_id,log_chl_type);
            if( dch_found == TRUE )
                {
                  /* Update the Cell FACH RB Mapping Info for RACH with Logical Channel ID */
                  rrcllc_update_cell_fach_ul_mapping_info_with_log_chl_id(
                    ordered_config_ptr,
                    cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id,
                    rlc_ul_log_chl_id);
                 /* Since this RB is mapped to a DCH, set the CCTrCH type in Uplink to DCH */
                ordered_config_ptr->mac_ul_parms.cctrch_ptr->cctrch_type = DCH;
                }

            /* Check EDCH mapping info as RB may be mapped to just EDCH and not dch */
            e_log_chan_mode = rrcllc_get_e_dch_log_chan_mode(cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id);
            
            if (e_log_chan_mode != UE_MODE_MAX_NUM) 
            {
              if (log_chl_mode == UE_MODE_MAX_NUM) 
              {
                WRRC_MSG1_HIGH("RRCEUL: Log channel mapped to EDCH only mode%d",e_log_chan_mode);
                log_chl_mode = e_log_chan_mode;
              }
              WRRC_MSG1_MED("RRCEUL: RB_ID %d mapped to EDCH", 
                       cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id);
              e_mac_d_flow_found = TRUE;
            }

            if((dch_found == FALSE)
                    && (e_mac_d_flow_found == FALSE)
                    )
            {
              /* This is a Cell_FACH case when DCCHs are mapped to FACH instead of DCH.
               * We do not handle it at present
               */
              if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
              {
                /* If loop back mode is ON for a RB that is mapped on DL for HSDPA */
                if (hsdpa_loopback_um_in_progress == FALSE)
                {
                  if(rrcllc_check_rb_id_exist_rb_mapping(cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id,&rb_mapping_index) == TRUE )
                  {
                    log_chl_mode = rrc_ordered_hanging_rb_mapping[rb_mapping_index].logch_mode;
                  }
                  else
                  {
                    WRRC_MSG1_ERROR("RB %d not mapped to DCH/EDCH in OC, do NOT handle this case",
                       cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id);
                    return(FAILURE);
                  }
                }
              }
              else

              {
                if(rrcllc_check_rb_id_exist_rb_mapping(cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id,&rb_mapping_index) == TRUE )
                {
                  log_chl_mode = rrc_ordered_hanging_rb_mapping[rb_mapping_index].logch_mode;
                }
                else
                {
                  WRRC_MSG1_ERROR("RB %d not mapped to DCH/HSDSCH/EDCH in OC, do NOT handle this case and not a Hanging RB",
                                  cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id);
                  return(FAILURE);
                }
              }
            }

            /* Update MAC data for Downlink */
            if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
            {
              /* Get the logical channel mode if a new logical channel is to be established */

              if(ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_EHS)
                {

                /* Check no of DL Dedicated Channels */
                for(dlchl_count=0; dlchl_count< ordered_config_ptr->mac_dl_parms.ndlchan_macehs; dlchl_count++)
                {
                  if(ordered_config_ptr->dl_macehs_logchan_info[dlchl_count].rb_id ==
                     cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id)
                  {
                    
                    /* This DFLOW is mapped to the same RB ID as is being setup.*/

                    ordered_config_ptr->dl_macehs_logchan_info[dlchl_count].rlc_id =
                      rlc_dl_log_chl_id;

                    /* Update the Cell FACH RB Mapping Info for FACH with Logical Channel ID */
                    rrcllc_update_cell_fach_dl_mapping_info_with_log_chl_id(
                      ordered_config_ptr,
                      cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id,
                      rlc_dl_log_chl_id);

                    queue_found = TRUE;
                    break;
                  }
                }
              }
              else if(ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_HS)
              {
                dflow_found = rrcllc_check_if_dflow_exist_and_update_rlc_id(cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id,
                                  rlc_dl_log_chl_id);
                if( dflow_found == TRUE )
                {
       /* Update the Cell FACH RB Mapping Info for RACH with Logical Channel ID */
                        rrcllc_update_cell_fach_dl_mapping_info_with_log_chl_id(
                          ordered_config_ptr,
                          cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id,
                          rlc_dl_log_chl_id);
                     /* Since this RB is mapped to a DCH, set the CCTrCH type in Uplink to DCH */
                }
              }
            }

            rrcllc_update_e_dch_mapping_info_with_log_chl_id(
              ordered_config_ptr,
              cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id,
              rlc_ul_log_chl_id);


             if(dch_found == FALSE)
             {
               /* Update the Cell FACH RB Mapping Info for RACH with Logical Channel ID */
               rrcllc_update_cell_fach_ul_mapping_info_with_log_chl_id(
                    ordered_config_ptr,
                    cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id,
                    rlc_ul_log_chl_id);
             }
           
#ifdef FEATURE_WCDMA_HS_RACH
    
              rrcllc_update_hsrach_e_dch_mapping_info_with_log_chl_id(
                  ordered_config_ptr,
                  cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id,
                  rlc_ul_log_chl_id);
#endif    
            num_dch = ordered_config_ptr->mac_dl_parms.num_dchs;
            if(num_dch > UE_MAX_TRCH)
            {
              WRRC_MSG1_ERROR("Invalid number %d of DL DCHs in OC", num_dch);
              return(FAILURE);
            }
            dch_found = rrcllc_check_if_dl_dch_exist_and_update_rlc_id(cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id,
                              rlc_dl_log_chl_id,log_chl_type);
            if( dch_found == TRUE )
                {
                  /* Update the Cell FACH RB Mapping Info for FACH with Logical Channel ID */
                  rrcllc_update_cell_fach_dl_mapping_info_with_log_chl_id(
                            ordered_config_ptr,
                            cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id,
                            rlc_dl_log_chl_id);
                }

            if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
            {
              /* Preventive Check */
              if ((dflow_found == FALSE) 
                 &&(queue_found == FALSE)
                && (dch_found == FALSE) 
                  && (e_mac_d_flow_found == FALSE)
                  )
              {
                if(rrcllc_check_rb_id_exist_rb_mapping(cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id,&rb_mapping_index) == TRUE )
                {
                  log_chl_mode = rrc_ordered_hanging_rb_mapping[rb_mapping_index].logch_mode;
                }
                else
                {
                  WRRC_MSG1_ERROR("RB %d not mapped to DCH/HSDSCH/EDCH in OC, do NOT handle this case and not a Hanging RB",
                  cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id);
                  return(FAILURE);
                }
              }
            }
            else
            {
              /* Check for the case when no DCH was found mapped to the RB */
              if(dch_found == FALSE)
              {
                /* This is a Cell_FACH case when DCCHs are mapped to FACH instead of DCH.
                 * We do not handle it at present
                 */
                if(rrcllc_check_rb_id_exist_rb_mapping(cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id,&rb_mapping_index) == TRUE )
                {
                  log_chl_mode = rrc_ordered_hanging_rb_mapping[rb_mapping_index].logch_mode;
                }
                else
                {
                  WRRC_MSG1_ERROR("RB %d not mapped to DCH in OC, do NOT handle this case and not a Hanging RB",
                            cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id);
                  return(FAILURE);
                }
              }
            }
          } /* If next state is Cell_DCH */
          else if(rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_FACH)
          {
            /* Update DL and UL MAC Info in Ordered Config */
            /* Update MAC DL Info */
            num_fach = ordered_config_ptr->mac_dl_parms.num_fachs;
            for(fach_count = 0; fach_count < num_fach; fach_count ++)
            {
              num_dlchan = ordered_config_ptr->mac_dl_parms.
                            fach_info[fach_count]->ndlchan;

              for(dlchl_count=0; dlchl_count< num_dlchan; dlchl_count++)
              {
                if((ordered_config_ptr->mac_dl_parms.fach_info[fach_count]->
                    dlchan_info[dlchl_count].rb_id ==
                      cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id) &&
                   (ordered_config_ptr->mac_dl_parms.fach_info[fach_count]->
                    dlchan_info[dlchl_count].chan_type ==
                      log_chl_type))
                {
                  ordered_config_ptr->mac_dl_parms.fach_info[fach_count]->
                    dlchan_info[dlchl_count].rlc_id = rlc_dl_log_chl_id;

                  /* Update the Cell FACH RB Mapping Info for FACH with Logical Channel ID */
                  rrcllc_update_cell_fach_dl_mapping_info_with_log_chl_id(
                            ordered_config_ptr,
                            cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id,
                            rlc_dl_log_chl_id);
                  /* Update the DL DCH Info in TOC with Logical Channel ID */
                  if(transition_config.toc_usage != TOC_INVALID)
                  {
                    rrcllc_update_toc_dl_dch_info_with_log_chl_id(
                      cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id,
                      rlc_dl_log_chl_id);
                  }

                  break;
                }
              } /* For all Ded Log channels */
            } /* For all FACHs */

#ifdef FEATURE_WCDMA_HS_FACH
            if(ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_EHS)
            {
              /* Check no of DL Dedicated Channels */
              for(dlchl_count=0; dlchl_count< ordered_config_ptr->mac_dl_parms.efach_ndlchans; dlchl_count++)
              {
                if(ordered_config_ptr->efach_dl_logchan_info[dlchl_count].rb_id ==
                   cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id)
                {
                    WRRC_MSG1_MED("EFACH: Updating mac rlc_id: %d",
                             ordered_config_ptr->efach_dl_logchan_info[dlchl_count].rlc_id);
                    ordered_config_ptr->efach_dl_logchan_info[dlchl_count].rlc_id =
                      rlc_dl_log_chl_id;
                    break;
                }
              }
            }
#endif
            

            /* Update MAC Uplink Info */
            num_dlchan = ordered_config_ptr->mac_ul_parms.cctrch_ptr->
                          rach_info.ndlchan;
            for(dlchl_count=0; dlchl_count< num_dlchan; dlchl_count++)
            {
              if((ordered_config_ptr->mac_ul_parms.cctrch_ptr->rach_info.
                  dlchan_info[dlchl_count].rb_id ==
                    cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id) &&
                 (ordered_config_ptr->mac_ul_parms.cctrch_ptr->rach_info.
                  dlchan_info[dlchl_count].chan_type ==
                    log_chl_type))
              {
                ordered_config_ptr->mac_ul_parms.cctrch_ptr->rach_info.
                  dlchan_info[dlchl_count].rlc_id = rlc_ul_log_chl_id;
                  rrcllc_update_e_dch_mapping_info_with_log_chl_id(
                    ordered_config_ptr,
                    cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id,
                    rlc_ul_log_chl_id);
#ifdef FEATURE_WCDMA_HS_RACH
                  rrcllc_update_hsrach_e_dch_mapping_info_with_log_chl_id(
                      ordered_config_ptr,
                      cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id,
                      rlc_ul_log_chl_id);
#endif
                /* Update the Cell FACH RB Mapping Info for RACH with Logical Channel ID */
                rrcllc_update_cell_fach_ul_mapping_info_with_log_chl_id(
                  ordered_config_ptr,
                  cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id,
                  rlc_ul_log_chl_id);
                /* Update the UL DCH Info in TOC with Logical Channel ID */
                if(transition_config.toc_usage != TOC_INVALID)
                {
                  rrcllc_update_toc_ul_dch_info_with_log_chl_id(
                    cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id,
                    rlc_ul_log_chl_id);
                }

                break;
              }
            } /* For all Ded Log channels */

#ifdef FEATURE_WCDMA_HS_RACH
          for(ix = 0; (ix < ordered_config_ptr->mac_hs_rach_config.hs_rach_config.num_e_mac_d_flow); ix++)
          {
            if(ordered_config_ptr->mac_hs_rach_config.hs_rach_config.e_mac_d_flow_info[ix].e_mac_d_flow_id != INVALID_DFLOW_ID)
            {
              for(iy = 0; (iy < ordered_config_ptr->mac_hs_rach_config.hs_rach_config.e_mac_d_flow_info[ix].num_logch); iy++)
              {
                if (ordered_config_ptr->mac_hs_rach_config.hs_rach_config.e_mac_d_flow_info[ix].e_ul_logch_info[iy].rb_id == cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id) 
                {
                  WRRC_MSG2_MED("RRCHSRACH: rb_id %d lc_id %d", cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id, rlc_ul_log_chl_id);
                  ordered_config_ptr->mac_hs_rach_config.hs_rach_config.e_mac_d_flow_info[ix].e_ul_logch_info[iy].rlc_id = rlc_ul_log_chl_id;
                  break;
                }
              }
            }
          }
#endif

              
          } /* If next state is Cell_FACH */
        } /* If log_chl_action != RLC_RELEASE */
      }  /* Able to successfully allocate UL and DL logical channel IDs */
      else
      {
        WRRC_MSG1_ERROR("Could not get Log Chl for RB %d",
              cmd_ptr->cmd.chan_config_req.rb[rb_count].rb_id);
        return(FAILURE);
      }
      if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
      {
        hsdpa_loopback_um_in_progress = FALSE;
      }
    } /* If Valid RB action is TRUE */
  }  /* for(all RBs in channel config request)... */
  
  /* Initialize rlc size structure */

  if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
  {
    rrc_initialize_rlc_size_per_rb();
  }

  return(SUCCESS);
} /* rrcllc_process_config_dcch_dtch */


/****************************************************************************
**                RRC_CHANNEL_CONFIG_REQ processing
**
*****************************************************************************/

/*===========================================================================
FUNCTION   rrcllc_add_sccpch_with_ctch_to_l1_cmd

DESCRIPTION
  This function analyzes data in rrc_cmd_under_process for sccpch1 (for CTCH).
  It then forms CPHY_SETUP_REQ commands for L1 and stores them in
  rrc_cmd_under_process.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.
===========================================================================*/
uecomdef_status_e_type rrcllc_add_sccpch_with_ctch_to_l1_cmd(void)
{
  l1_ext_cmd_type *l1_cmd_ptr;
  int32  l1_req_index;
  ordered_config_type *config_ptr;

  if(rrcllc_cmd_under_process.chan_config.current_cmd_engine == LLC_CELL_RESELECTION_ENGINE)
  {
    config_ptr = reselection_config_ptr;
  }
  else
  {
    config_ptr = ordered_config_ptr;
  }


  rrcllc_cmd_under_process.chan_config.l1_req_list.
    l1_req[rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req].cmd_hdr.act_time = 0;
  rrcllc_cmd_under_process.chan_config.l1_req_list.
    l1_req[rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req].cmd_hdr.act_time_type = L1_ACTIVATION_TIME_NONE;
  rrcllc_cmd_under_process.chan_config.l1_req_list.
    l1_req[rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req].cmd_hdr.cmd_id = CPHY_SETUP_REQ;

  if(rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req >=
                          LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD)
  {
    WRRC_MSG1_ERROR("No space for L1 cmd, cmd count %d",
      rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req);
    return(FAILURE);
  }

  MSG_MED("On ENTRY:# L1 DL reqs %d in cmd_under_process_data",
            rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req, 0, 0);


  if((rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_for_ctch_action
            == LLC_PHYCHAN_SETUP) ||
     (rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_for_ctch_action
            == LLC_PHYCHAN_RECONFIG))
  {
     /* It is a SCCPCH setup/reconfig/TrCH enable_disable */
     /* Update the current L1 command to include SCCPCH operation */
    for( l1_req_index = 0;
         (l1_req_index < LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD) &&
         (l1_req_index <= rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req);
         l1_req_index ++
       )
    {

      if(l1_req_index == rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req)
      {
        rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.req_mask = 0;
        rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req ++;
      }

      else if(rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.req_mask &
              CPHY_DL_CCTRCH_INCL)
      {
        /* Since this command already has a CCTrCH included, it could not be
         * used for another establish/reconfigure.
         */
        continue;
      }

      l1_cmd_ptr = &rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index];

      if(rrcllc_cmd_under_process.chan_config.new_freq)
      {
        l1_cmd_ptr->cmd.setup.freq_incl = TRUE;
        l1_cmd_ptr->cmd.setup.rf_chan = config_ptr->dest_freq;
      }
      else
      {
        l1_cmd_ptr->cmd.setup.freq_incl = FALSE;
      }
      l1_cmd_ptr->cmd.setup.req_mask |= CPHY_DL_CCTRCH_INCL;

      if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_for_ctch_action
        == LLC_PHYCHAN_SETUP)
      {
        l1_cmd_ptr->cmd.setup.req_mask |= CPHY_DL_PHYCHAN_ADD_INCL;
        l1_cmd_ptr->cmd.setup.dl_phychan  = L1_DL_PHYCHAN_SCCPCH1;
        l1_cmd_ptr->cmd.setup.dl_phychan_db = &config_ptr->l1_dl_chan_parms;
      }
      else if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_for_ctch_action
        == LLC_PHYCHAN_RECONFIG)
      {
        /* For the time being, due to L1 constraints, treat an SCCPCH reconfig as
         * an SCCPCH add and SCCPCH delete.
         */
        l1_cmd_ptr->cmd.setup.req_mask |= CPHY_DL_PHYCHAN_ADD_INCL;
        l1_cmd_ptr->cmd.setup.dl_phychan  = L1_DL_PHYCHAN_SCCPCH1;
        l1_cmd_ptr->cmd.setup.dl_phychan_db = &config_ptr->l1_dl_chan_parms;

        /* Now set the sccpch action in cmd under process to a delete */
        /* NOTE: This should go away once L1 starts supporting reconfig of SCCPCHs - TBD */
        rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_for_ctch_action
        = LLC_PHYCHAN_RELEASE;
      }

      /* Update DL CCTrCH data in Ordered Config with CCTrCH ID for SCCPCH */
      config_ptr->l1_dl_cctrch_parms_for_sccpch_with_ctch.cctrch_id =
          rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.cctrch_id;
      /* Fill in Ordered Config with current bitflags for SCCPCH */
      config_ptr->l1_dl_cctrch_parms_for_sccpch_with_ctch.trch_ref_type_bf =
          rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_ref_type_bf;
      config_ptr->l1_dl_cctrch_parms_for_sccpch_with_ctch.trch_enable_bf =
          rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_enable_bf;

      l1_cmd_ptr->cmd.setup.dl_cctrch_info  = &config_ptr->l1_dl_cctrch_parms_for_sccpch_with_ctch;
      l1_cmd_ptr->cmd.setup.dl_ctfc_info    = &config_ptr->l1_dl_ctfc_parms_for_sccpch_with_ctch;


      break;
    } /* for(...) */

    if( l1_req_index == LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD )
    {
      WRRC_MSG0_ERROR("SCCPCH setup/reconfig could not go in L1 cmd");
      return(FAILURE);
    }
  } /* It is an SCCPCH setup/reconfig */

  /* Now include Downlink channels that need to be released */
  /* Check if SCCPCH needs to be dropped */
  if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_for_ctch_action ==
                                                      LLC_PHYCHAN_RELEASE)
  {
    for(l1_req_index = 0;
        (l1_req_index < LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD) &&
        (l1_req_index <= rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req);
        l1_req_index++)
    {

      if(l1_req_index == rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req)
      {
        rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.req_mask = 0;
        rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req ++;
      }
      else if(rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.req_mask &
         CPHY_DL_PHYCHAN_DROP_INCL)
      {
        /* Since this command already has a Drop included, it could not be
         * used for another channel drop.
         */
        continue;
      }

      rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.req_mask |=
                                                     CPHY_DL_PHYCHAN_DROP_INCL;
      rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.drop_dl_phychan =
                                                         L1_DL_PHYCHAN_SCCPCH1;

      /* initialize semi perm data for ctch here. PS we might have to move this part to some other place later */
      //rrcllc_semi_permanent_data.dl_phy_chan.ctch_status = RRCLLC_NO_CTCH;
      //rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.cctrch_id = RRCLLC_INVALID_CCTRCH_ID;
      break;
    } /* for(...) */

    if( l1_req_index == LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD )
    {
      WRRC_MSG0_ERROR("SCCPCH release could not go in L1 cmd");
      return(FAILURE);
    }
  } /* SCCPCH release */

  WRRC_MSG1_HIGH("On EXIT:# L1 DL reqs %d in cmd_under_process_data",
            rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req);

  return(SUCCESS);
} /* rrcllc_add_sccpch_with_ctch_to_l1_cmd */


#ifdef FEATURE_UPDATE_SIB7_IN_FACH
/*===========================================================================
FUNCTION   rrcllc_is_process_required

DESCRIPTION
  Checks if we can ignore the channel config request
DEPENDENCIES
  None.

RETURN VALUE
boolean
TRUE if Processing is needed
FALSE if channel config request can be ignored

SIDE EFFECTS
  None.
===========================================================================*/
static boolean rrcllc_is_process_required(rrc_cmd_type *cmd_ptr)
{
  boolean process_required = TRUE;
  
  if((rrc_get_state()== RRC_STATE_CELL_FACH) && (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_FACH))
  {
    if(rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_SIB)
    {
      if(cmd_ptr->cmd.chan_config_req.num_rb_to_config ==1)
      {/*Only one Rb and that to BCCH*/
        if(cmd_ptr->cmd.chan_config_req.rb[0].rb_id == BCCH_S_RADIO_BEARER_ID)
        {
          if(cmd_ptr->cmd.chan_config_req.rb[0].rb_config == ESTABLISH_RB)
          {
            if(rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up == TRUE)
            {
              if(rrclcm_check_dl_rlc_lc_id(UE_LOGCHAN_BCCH,BCCH_S_RADIO_BEARER_ID,UE_MODE_TRANSPARENT)!=
                RRCLCM_RLC_LC_ID_NOT_FOUND)
              { /* Ignore as it is already present*/
                process_required = FALSE;
              }
            }
          }
          else if(cmd_ptr->cmd.chan_config_req.rb[0].rb_config == RELEASE_RB)
          { /* do not drop PCCPCH  in FACH*/
            process_required = FALSE;
          }
        }
      }
    }
  }
  return (process_required);
}

/*===========================================================================
FUNCTION   rrcllc_insert_downlink_s_pccpch_setup_to_l1_cmd

DESCRIPTION
  This function Constructs  Add for PCCPCH if the internal
  LLC data indicates a SETUP of PCCPCH.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.
===========================================================================*/
static uecomdef_status_e_type rrcllc_add_downlink_s_pccpch_setup_to_l1_cmd( ordered_config_type  *config_ptr)
{
  l1_ext_cmd_type *l1_cmd_ptr;
  int32  l1_req_index;
  
  /* Update the current L1 command to include PCCPCH operation */
  for( l1_req_index = 0;
       (l1_req_index < LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD) &&
       (l1_req_index <= rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req);
       l1_req_index ++
     )
  {
    if(l1_req_index == rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req)
    {
      rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.req_mask = 0;
      rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req ++;
    }
    else if(rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.req_mask &
       CPHY_DL_CCTRCH_INCL)
    {
      /* Since this command already has a CCTrCH included, it could not be
       * used for another establish/reconfigure.
       */
      continue;
    }
    
    l1_cmd_ptr = &rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index];
  
    l1_cmd_ptr->cmd.setup.req_mask |= CPHY_DL_CCTRCH_INCL;
  
    if(rrcllc_cmd_under_process.chan_config.new_freq)
    {
      l1_cmd_ptr->cmd.setup.freq_incl = TRUE;
      l1_cmd_ptr->cmd.setup.rf_chan = config_ptr->dest_freq;
    }
    else
    {
      l1_cmd_ptr->cmd.setup.freq_incl = FALSE;
    }
  
    l1_cmd_ptr->cmd.setup.req_mask |= CPHY_DL_PHYCHAN_ADD_INCL;
    l1_cmd_ptr->cmd.setup.dl_phychan  = L1_DL_PHYCHAN_PCCPCH_S;
  
    l1_cmd_ptr->cmd.setup.dl_phychan_db =
        &config_ptr->l1_dl_chan_parms;
  
  
    /* Do not update Ordered Config with PCCPCH DL CCTrCH data */
    l1_cmd_ptr->cmd.setup.dl_cctrch_info  = &rrcllc_semi_permanent_data.dl_phy_chan.pccpch;
    l1_cmd_ptr->cmd.setup.dl_ctfc_info    = NULL;
  
    break;
  }

  if( l1_req_index == LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD )
  {
    WRRC_MSG0_ERROR("PCCPCH setup/reconfig could not go in L1 cmd");
    return(FAILURE);
  }
  return(SUCCESS);
}

/*===========================================================================
FUNCTION   rrcllc_get_pccpch_tx_diversity_from_sibs

DESCRIPTION
  This function gives the TxDiversity value for the cell for which PCCPCH is setup.

DEPENDENCIES
  None.

RETURN VALUE
 TRUE if TxDiversity is to be enabled
 else FALSE
 Default value is TRUE.
SIDE EFFECTS
  None.
===========================================================================*/
boolean rrcllc_get_pccpch_tx_diversity_from_sibs(rrc_state_e_type next_state)
{
  rrc_SysInfoType5 *sib5_ptr = NULL;
  rrc_SysInfoType6 *sib6_ptr = NULL;
  rrc_plmn_identity_type plmn_id;
  rrc_int_cell_id_type cell_id;

  if(rrcllc_cmd_under_process.chan_config.current_cmd_engine == LLC_CELL_RESELECTION_ENGINE)
  {
    plmn_id = rrcllc_cmd_under_process.rrcllc_cell_resel_info.plmn_id;
    cell_id = rrcllc_cmd_under_process.rrcllc_cell_resel_info.cell_id;
    WRRC_MSG0_HIGH("Getting PLMN & Cell Id during reselection");
  }
  else
  {
    rrccsp_get_current_plmn_cell_id(&plmn_id,&cell_id);
  }

  MSG_HIGH("PLMN: -> MCC %d, MNC %d, Cell ID %d",
                                                 RRC_CSP_GET_INT_MCC(plmn_id),
                                                 RRC_CSP_GET_INT_MNC(plmn_id),
                                                 cell_id);

  /* PLMN and Cell ID of the current camped on cell are known. Get SIB3 */
  sib5_ptr = (rrc_SysInfoType5 *) rrc_sibdb_return_sib_for_cell(
                            rrc_SIB5, 
                            plmn_id, cell_id);
  if( sib5_ptr == NULL )
  {
    WRRC_MSG0_ERROR("SIB5 is not present.");
    return(TRUE);
  }

  /* if sib6 indicator is false or if rrc state is idle, look at sib5*/
  if ((next_state == RRC_STATE_DISCONNECTED) || (next_state == RRC_STATE_CONNECTING) ||
      (sib5_ptr->sib6indicator == FALSE) )
  {
    if((RRC_MSG_COMMON_BITMASK_IE_PTR(sib5_ptr,rrc_SysInfoType5,primaryCCPCH_Info)) &&  
       (RRC_CHECK_COMMON_MSG_TYPE(sib5_ptr->primaryCCPCH_Info, rrc_PrimaryCCPCH_Info_fdd)))
    {
      WRRC_MSG1_HIGH("Using PCCPCH TxDiv info from sib 5 %d", sib5_ptr->primaryCCPCH_Info.u.fdd->tx_DiversityIndicator);
      if(sib5_ptr->primaryCCPCH_Info.u.fdd->tx_DiversityIndicator)
      {
        return TRUE;
      }
      else
      {
        return FALSE;
      }
    }
  }
  else if(sib5_ptr->sib6indicator == TRUE)
  {
    sib6_ptr = (rrc_SysInfoType6 *)rrc_sibdb_return_sib_for_cell(
                              rrc_SIB6, 
                              plmn_id, cell_id);
    
    if((sib6_ptr!= NULL) && (RRC_MSG_COMMON_BITMASK_IE_PTR(sib6_ptr,rrc_SysInfoType6,primaryCCPCH_Info)))
    {
      if(RRC_CHECK_COMMON_MSG_TYPE(sib6_ptr->primaryCCPCH_Info, rrc_PrimaryCCPCH_Info_fdd))
      {
        WRRC_MSG1_HIGH("Using PCCPCH TxDiv info from sib 6 %d", sib6_ptr->primaryCCPCH_Info.u.fdd->tx_DiversityIndicator);
        if(sib6_ptr->primaryCCPCH_Info.u.fdd->tx_DiversityIndicator)
        {
          return TRUE;
        }
        else
        {
          return FALSE;
        }
      }
    }
    else if((RRC_MSG_COMMON_BITMASK_IE_PTR(sib5_ptr,rrc_SysInfoType5,primaryCCPCH_Info)) &&  
            (RRC_CHECK_COMMON_MSG_TYPE(sib5_ptr->primaryCCPCH_Info, rrc_PrimaryCCPCH_Info_fdd)))
    {
      WRRC_MSG1_HIGH("Using PCCPCH TxDiv info from sib 5 %d", sib5_ptr->primaryCCPCH_Info.u.fdd->tx_DiversityIndicator);
      if(sib5_ptr->primaryCCPCH_Info.u.fdd->tx_DiversityIndicator)
      {
        return TRUE;
      }
      else
      {
        return FALSE;
      }
    }
  }
    
  return TRUE;
} /* rrcllc_get_pccpch_tx_diversity_from_sibs */


/*===========================================================================
FUNCTION   rrcllc_update_spccpch_params_based_on_action

DESCRIPTION
This function updates rrcllc_semi_permanent_data, rrcllc_cmd_under_process, config_ptr based on
PCCPCH Action

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.
===========================================================================*/
static uecomdef_status_e_type rrcllc_update_spccpch_params_based_on_action
(
ordered_config_type *config_ptr
)
{
  uint8 cctrch_id;
  if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action ==
      LLC_PHYCHAN_SETUP
  )
  {
    if(config_ptr->mac_dl_parms.num_bchs)
    {
      WRRC_MSG1_ERROR("Number of BCHS : %d not Zero",config_ptr->mac_dl_parms.num_bchs);
    }
    else
    {
      config_ptr->mac_dl_parms.num_bchs ++;
    }

    /* Update number of transport channels on PCCPCH in L1 CCTrCH Parameters */
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch.num_trch = 1;
  
    /* Configure RLC with S-BCCH information */
    (void)rrcllc_process_add_bcch_serving(config_ptr);
    /* Update PCCPCH info in rrcllc_semi_permanent_data.dl_phy_chan */
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_ref_type_bf =
        L1_DL_TRCH_REFTYPE_SBCH_BF;
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_enable_bf =
        L1_DL_TRCH_REFTYPE_SBCH_BF;

    /* Here if reselection is in progess, pick the scr code from the resel info
       i.e rrcllc_cmd_under_process.rrcllc_cell_resel_info.scr_code
       else get it from CSP 
    */
    if(rrcllc_cmd_under_process.chan_config.current_cmd_engine == LLC_CELL_RESELECTION_ENGINE)
    {
      config_ptr->l1_dl_chan_parms.pccpch.scr_code = rrcllc_cmd_under_process.rrcllc_cell_resel_info.scr_code;
    }
    else
    {
      rrccsp_get_serving_pccpch_parms(&config_ptr->l1_dl_chan_parms.pccpch.scr_code,
                                      &config_ptr->l1_dl_chan_parms.pccpch.tx_div_ind
                                      );
    }

    /* Passing Cell FACH is intentional, since the function
      *  only distinguishes between IDLE and CONNECTED States
      */
    config_ptr->l1_dl_chan_parms.pccpch.tx_div_ind = 
         rrcllc_get_pccpch_tx_diversity_from_sibs(RRC_STATE_CELL_FACH);
    WRRC_MSG1_HIGH("tx div value is: %d",config_ptr->l1_dl_chan_parms.pccpch.tx_div_ind);

    /* Get a new CCTrCH ID for S-PCCPCH */
    cctrch_id = rrcllc_get_cctrch_id();

    /*Fixing the Array Out of Bound Error from KW*/  
    if((cctrch_id != RRCLLC_INVALID_CCTRCH_ID) &&
      (config_ptr->mac_dl_parms.num_bchs != 0) &&
      (config_ptr->mac_dl_parms.num_bchs <= MAC_DL_MAX_CCTRCH))
    {
      /* Update BCH info in MAC Ordered Config */
      config_ptr->mac_dl_parms.
        bch_info[config_ptr->mac_dl_parms.num_bchs-1].cctrch_id =
       cctrch_id;
  
      /* Update PCCPCH Info in rrcllc_cmd_under_process */
      rrcllc_semi_permanent_data.dl_phy_chan.pccpch.cctrch_id = cctrch_id;
  
      /* Indicate that Downlink MAC needs to be reconfigured */
      config_ptr->reconfig_needed.downlink_mac = TRUE;
      /* Indicate that Downlink L1 needs to be reconfigured */
      config_ptr->reconfig_needed.downlink_l1 = TRUE;
    }
    else
    {
      WRRC_MSG1_ERROR("Invalid CCTrCH ID %d assigned", cctrch_id);
      return(FAILURE);
    }
  } 
  else if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action ==
      LLC_PHYCHAN_DROP_AND_ADD
  )
  {
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch.num_trch = 1;
    (void)rrcllc_process_reconfig_bcch_serving(config_ptr);
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_ref_type_bf = L1_DL_TRCH_REFTYPE_SBCH_BF;
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_enable_bf = L1_DL_TRCH_REFTYPE_SBCH_BF;
    /* Add the CCTrCH ID for PCCPCH to the CCTrCH IDs to be released list */
    RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.dl_phy_chan.
                                        pccpch.cctrch_id);
    /* Get a new CCTrCH ID */
    cctrch_id = rrcllc_get_cctrch_id();
    if(cctrch_id != RRCLLC_INVALID_CCTRCH_ID)
    {
      /* If BCH is present, update BCH info in Ordered Config with new CCTrCH ID */
      /*Fixing the Array Out of Bound Error from KW*/  
      if((config_ptr->mac_dl_parms.num_bchs != 0) &&
        (config_ptr->mac_dl_parms.num_bchs <= MAC_DL_MAX_CCTRCH)) 
      {
        config_ptr->mac_dl_parms.bch_info[config_ptr->mac_dl_parms.num_bchs-1].cctrch_id = cctrch_id;
      }
      /* Update SCCPCH Info in rrcllc_cmd_under_process */
      rrcllc_semi_permanent_data.dl_phy_chan.pccpch.cctrch_id =
        cctrch_id;
    }
    else
    {
      WRRC_MSG1_ERROR("Invalid CCTrCH ID %d assigned", cctrch_id);
      return(FAILURE);
    }
    /*Here if reselection is in progess, pick the PSC from the resel info
      i.e rrcllc_cmd_under_process.rrcllc_cell_resel_info.scr_code
      else pick it from CSP
    */
    if(rrcllc_cmd_under_process.chan_config.current_cmd_engine == LLC_CELL_RESELECTION_ENGINE)
    {
      config_ptr->l1_dl_chan_parms.pccpch.scr_code = rrcllc_cmd_under_process.rrcllc_cell_resel_info.scr_code;
    }
    else
    {
      rrccsp_get_serving_pccpch_parms(&config_ptr->l1_dl_chan_parms.pccpch.scr_code,
                                      &config_ptr->l1_dl_chan_parms.pccpch.tx_div_ind
                                      );
    }
    
    /* Passing Cell FACH is intentional, since the function
     *  only distinguishes between IDLE and CONNECTED States
     */
    config_ptr->l1_dl_chan_parms.pccpch.tx_div_ind = 
         rrcllc_get_pccpch_tx_diversity_from_sibs(RRC_STATE_CELL_FACH);
    WRRC_MSG1_HIGH("tx div value is: %d",config_ptr->l1_dl_chan_parms.pccpch.tx_div_ind);
  }
  else if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action ==
      LLC_PHYCHAN_RELEASE
  )
  {
    if(config_ptr->mac_dl_parms.num_bchs)
    {
      config_ptr->mac_dl_parms.num_bchs --;
    }

    /* Update number of transport channels on PCCPCH in L1 CCTrCH Parameters */
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch.num_trch = 0;

    if (rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up) 
    {
      (void)rrcllc_process_drop_bcch_serving();
    }
    else
    {
      WRRC_MSG0_ERROR("BCCH not present: no need for drop");
      return FAILURE;
    }
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_ref_type_bf = 0;
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_enable_bf = 0;
    if( rrcllc_semi_permanent_data.dl_phy_chan.pccpch.cctrch_id != RRCLLC_INVALID_CCTRCH_ID)
    {
      /* Add the CCTrCH ID for PCCPCH to the CCTrCH IDs to be released list */
      RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                           dl_phy_chan.pccpch.cctrch_id);
    }
  }
  return (SUCCESS);
}
#endif /* FEATURE_UPDATE_SIB7_IN_FACH */
/*===========================================================================
FUNCTION   rrcllc_add_downlink_phy_chan_to_l1_cmd

DESCRIPTION
  This function analyzes data in rrc_cmd_under_process for each of the
  downlink physical channels. It then forms CPHY_SETUP_REQ commands for L1
  and stores them in rrc_cmd_under_process.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.
===========================================================================*/
static uecomdef_status_e_type   rrcllc_add_downlink_phy_chan_to_l1_cmd(void)
{
  l1_ext_cmd_type *l1_cmd_ptr;
  int32  l1_req_index;
  int32  l1_dpch_req_index;
  rrc_lb_test_mode_e_type lb_mode;
  boolean  dummy_signaling_enabled;
#ifdef FEATURE_WCDMA_DC_HSUPA
  int32  i;
  rrc_proc_e_type                 proc_id;
  rrcllc_oc_process_state_e_type  process_state;  
  rrcllc_oc_set_status_e_type     oc_status;
  boolean fake_cphy_setup = FALSE;
#endif /* FEATURE_WCDMA_DC_HSUPA */

  rrc_csp_scan_e_type curr_scan = rrccsp_get_curr_scan();

  if(rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req >=
                          LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD)
  {
    WRRC_MSG1_ERROR("No space for L1 cmd, cmd count %d",
      rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req);
    return(FAILURE);
  }

  MSG_MED("On ENTRY:# L1 DL reqs %d in cmd_under_process_data",
            rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req, 0, 0);

  if((rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_action
            == LLC_PHYCHAN_SETUP) ||
     (rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_action
            == LLC_PHYCHAN_SET_LBT_MODE))
  {
     /* It is a SCCPCH setup/reconfig/TrCH enable_disable */
     /* Update the current L1 command to include SCCPCH operation */
    for( l1_req_index = 0;
         (l1_req_index < LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD) &&
         (l1_req_index <= rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req);
         l1_req_index ++
       )
    {

      if(l1_req_index == rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req)
      {
        rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.req_mask = 0;
        rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req ++;
      }

      else if(rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.req_mask &
              CPHY_DL_CCTRCH_INCL)
      {
        /* Since this command already has a CCTrCH included, it could not be
         * used for another establish/reconfigure.
         */
        continue;
      }

      l1_cmd_ptr = &rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index];

      if(rrcllc_cmd_under_process.chan_config.new_freq)
      {
        l1_cmd_ptr->cmd.setup.freq_incl = TRUE;
        l1_cmd_ptr->cmd.setup.rf_chan = ordered_config_ptr->dest_freq;
      }
      else
      {
        l1_cmd_ptr->cmd.setup.freq_incl = FALSE;
      }
      l1_cmd_ptr->cmd.setup.req_mask |= CPHY_DL_CCTRCH_INCL;

      if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_action
        == LLC_PHYCHAN_SETUP)
      {
        l1_cmd_ptr->cmd.setup.req_mask |= CPHY_DL_PHYCHAN_ADD_INCL;
        l1_cmd_ptr->cmd.setup.dl_phychan  = L1_DL_PHYCHAN_SCCPCH0;
        l1_cmd_ptr->cmd.setup.dl_phychan_db = &ordered_config_ptr->l1_dl_chan_parms;
      }

      else if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_action
                == LLC_PHYCHAN_SET_LBT_MODE)
      {
        l1_cmd_ptr->cmd.setup.req_mask |= CPHY_DL_CCTRCH_INCL;
        l1_cmd_ptr->cmd.setup.req_mask |= CPHY_DL_SET_LOOPBACK_MODE_INCL;
        rrcllc_update_lbt_mode_for_fachs(RRCLLC_XLATE_LBT_MODE(
                                          rrcllc_cmd_under_process.
                                          chan_config.lb_test_mode)
                                         );
      }

      /* Update DL CCTrCH data in Ordered Config with CCTrCH ID for SCCPCH */
      ordered_config_ptr->l1_dl_cctrch_parms.cctrch_id =
          rrcllc_semi_permanent_data.dl_phy_chan.sccpch.cctrch_id;
      /* Fill in Ordered Config with current bitflags for SCCPCH */
      ordered_config_ptr->l1_dl_cctrch_parms.trch_ref_type_bf =
          rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf;
      ordered_config_ptr->l1_dl_cctrch_parms.trch_enable_bf =
          rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf;

      l1_cmd_ptr->cmd.setup.dl_cctrch_info  = &ordered_config_ptr->l1_dl_cctrch_parms;
      l1_cmd_ptr->cmd.setup.dl_ctfc_info    = &ordered_config_ptr->l1_dl_ctfc_parms;

      break;
    } /* for(...) */

    if( l1_req_index == LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD )
    {
      WRRC_MSG0_ERROR("SCCPCH setup/reconfig could not go in L1 cmd");
      return(FAILURE);
    }
  } /* It is an SCCPCH setup/reconfig */

  /*
    The Code for the SCCPCH Reconfig is Acted Upon Separately to prevent
    the Cases where ADD of the Physical channel goes ahead of Drop of it to L1

    For Example When FEATURE_UPDATE_SIB7_IN_FACH is defined, during transition
    from FACH to PCH, SCCPCH is Reconfigured and PCCPCH is Dropped.
    With the Existing code DROP of PCCPCH and ADD of SCCPCH is sent as First CPHY
    Setup Request and DROP of SCCPCH is sent as Second CPHY Setup Request which
    results in CPHY Setup Failure (SCCPCH cannot be Added as it is already up)
  */

  if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_action
            == LLC_PHYCHAN_RECONFIG)
  {
    for( l1_req_index = 0;
         (l1_req_index < LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD) &&
         (l1_req_index <= rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req);
         l1_req_index ++
       )
    {

      if(l1_req_index == rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req)
      {
        rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.req_mask = 0;
        rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req ++;
      }

      else if(rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.req_mask &
              CPHY_DL_CCTRCH_INCL)
      {
        /* Since this command already has a CCTrCH included, it could not be
         * used for another establish/reconfigure.
         */
        continue;
      }

      l1_cmd_ptr = &rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index];

      if(rrcllc_cmd_under_process.chan_config.new_freq)
      {
        l1_cmd_ptr->cmd.setup.freq_incl = TRUE;
        l1_cmd_ptr->cmd.setup.rf_chan = ordered_config_ptr->dest_freq;
      }
      else
      {
        l1_cmd_ptr->cmd.setup.freq_incl = FALSE;
      }
      l1_cmd_ptr->cmd.setup.req_mask |= CPHY_DL_CCTRCH_INCL;
      /* For the time being, due to L1 constraints, treat an SCCPCH reconfig as
      an SCCPCH add and SCCPCH delete.
      */
      l1_cmd_ptr->cmd.setup.req_mask |= CPHY_DL_PHYCHAN_ADD_INCL;
      l1_cmd_ptr->cmd.setup.dl_phychan  = L1_DL_PHYCHAN_SCCPCH0;
      l1_cmd_ptr->cmd.setup.dl_phychan_db = &ordered_config_ptr->l1_dl_chan_parms;
      /* Update DL CCTrCH data in Ordered Config with CCTrCH ID for SCCPCH */
      ordered_config_ptr->l1_dl_cctrch_parms.cctrch_id =
          rrcllc_semi_permanent_data.dl_phy_chan.sccpch.cctrch_id;
      /* Fill in Ordered Config with current bitflags for SCCPCH */
      ordered_config_ptr->l1_dl_cctrch_parms.trch_ref_type_bf =
          rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf;
      ordered_config_ptr->l1_dl_cctrch_parms.trch_enable_bf =
          rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf;

      l1_cmd_ptr->cmd.setup.dl_cctrch_info  = &ordered_config_ptr->l1_dl_cctrch_parms;
      l1_cmd_ptr->cmd.setup.dl_ctfc_info    = &ordered_config_ptr->l1_dl_ctfc_parms;

      if (rrclbt_get_lb_mode_and_dummy_sig_enabled(&lb_mode,
                                                   &dummy_signaling_enabled)) 
      {
        WRRC_MSG0_HIGH("Indicate to WL1 and MAC that loopback is still in progress");
          
        l1_cmd_ptr->cmd.setup.req_mask |= CPHY_DL_SET_LOOPBACK_MODE_INCL;
        rrcllc_update_lbt_mode_for_fachs(RRCLLC_XLATE_LBT_MODE(lb_mode)
                                        #ifdef FEATURE_DUMMY_SIGNALING
                                        #error code not present
#endif  
                                        );

        }
      break;
    }

    if( l1_req_index == LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD )
    {
      WRRC_MSG0_ERROR("SCCPCH setup/reconfig could not go in L1 cmd");
      return(FAILURE);
    }

    for(l1_req_index = 0;
        (l1_req_index < LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD) &&
        (l1_req_index <= rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req);
        l1_req_index++)
    {
 
      if(l1_req_index == rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req)
      {
        rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.req_mask = 0;
        rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req ++;
      }
      else if(rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.req_mask &
         CPHY_DL_PHYCHAN_DROP_INCL)
      {
        /* Since this command already has a Drop included, it could not be
         * used for another channel drop.
         */
        continue;
      }
 
      rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.req_mask |=
                                                     CPHY_DL_PHYCHAN_DROP_INCL;
      rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.drop_dl_phychan =
                                                         L1_DL_PHYCHAN_SCCPCH0;
      break;
    } /* for(...) */

    if( l1_req_index == LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD )
    {
      WRRC_MSG0_ERROR("SCCPCH Setup/Reconfig could not go in L1 cmd");
      return(FAILURE);
    }
  }

  /* Check if PCCPCH needs to be dropped */
  if((rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action ==
                                                      LLC_PHYCHAN_RELEASE)
#ifdef FEATURE_UPDATE_SIB7_IN_FACH
    ||(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action ==
                                                      LLC_PHYCHAN_DROP_AND_ADD)
#endif /*FEATURE_UPDATE_SIB7_IN_FACH*/
   )
  {
    for(l1_req_index = 0;
        (l1_req_index < LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD) &&
        (l1_req_index <= rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req);
        l1_req_index++)
    {
      if(l1_req_index == rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req)
      {
        rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.req_mask = 0;
        rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req ++;
      }
      else if(rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.req_mask &
         CPHY_DL_PHYCHAN_DROP_INCL)
      {
        /* Since this command already has a Drop included, it could not be
         * used for another channel drop.
         */
        continue;
      }
#ifdef FEATURE_WCDMA_HS_FACH
      else if((l1_req_index == 0)&&
              ((rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_PCH)||
              (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_URA_PCH)) &&
                     (rrc_get_state() == RRC_STATE_CELL_FACH)&&
                     (rrcenhstate_camped_cell_supports_e_fach())&&
                     (rrcllc_cmd_under_process.chan_config.phy_chan_action_list.prach_action
                    == LLC_PHYCHAN_RELEASE)&&
                    (rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_action
                    == LLC_PHYCHAN_SETUP))
      {
        /*Don't add pccpch drop in first cphy setup as it inclues rach drop along with sccpch setup*/
        /* Since this command already has a Drop included, it could not be
               * used for another channel drop.
               */
        WRRC_MSG0_HIGH("EFACH:send PCCPCH drop in 2nd cphy_setup, 1st cphy_setup include rach drop along with sccpch setup");
        continue;
      }
#endif
      else if(l1_req_index < rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req)
      {
        /* check to confirm if there is a DPCH add/reconfig occuring in a L1 command
         * after this command (in which drop PCCPCH goes). If this is so, a new L1
         * command is created to carry PCCPCH "drop". This prevents a scenario where
         * L1 is asked to "drop" a PCCPCH before a DPCH is "added".
         */
        for( l1_dpch_req_index = l1_req_index;
             l1_dpch_req_index < rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req;
             l1_dpch_req_index ++
           )
        {
          if(( (rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_dpch_req_index].
                 cmd.setup.req_mask & CPHY_DL_PHYCHAN_ADD_INCL) &&
                 ((rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_dpch_req_index].
                 cmd.setup.dl_phychan == L1_DL_PHYCHAN_DPCH)
                 || (rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_dpch_req_index].
                 cmd.setup.dl_phychan == L1_DL_PHYCHAN_FDPCH)
                 )
                 )   ||
                 ( (rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_dpch_req_index].
                 cmd.setup.req_mask & CPHY_DL_PHYCHAN_CFG_INCL) &&
                 ((rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_dpch_req_index].
                 cmd.setup.dl_phychan == L1_DL_PHYCHAN_DPCH)
                 || (rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_dpch_req_index].
                 cmd.setup.dl_phychan == L1_DL_PHYCHAN_FDPCH)
                 )
                 )
                 )
          {
              /* Move PCCPCH "drop" to a new L1 command if there is space */
             if(rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req <
                LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD)
             {
               l1_req_index = rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req;
               rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].
                 cmd.setup.req_mask = 0;
               rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req ++;
             }
             else
             {
               WRRC_MSG0_ERROR("PCCPCH release could not go in L1 cmd");
               return(FAILURE);
             }
           }
        } /* for(...) */
      } /* else if(l1_req_index < rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req) */

      rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.req_mask |=
                                                     CPHY_DL_PHYCHAN_DROP_INCL;
      rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.drop_dl_phychan =
                                                        L1_DL_PHYCHAN_PCCPCH_S;
#ifdef FEATURE_UPDATE_SIB7_IN_FACH
      if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action == LLC_PHYCHAN_DROP_AND_ADD)
      {
        /*
        We have constucted the L1 Command for DROP of PCCPCH, where as the
        L1 Command for ADD of PCCPCH is yet to be done.
        */
        rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action = LLC_PHYCHAN_SETUP;
      }
#endif /*FEATURE_UPDATE_SIB7_IN_FACH*/
      break;
    } /* for(...) */

    if( l1_req_index == LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD )
    {
      WRRC_MSG0_ERROR("PCCPCH release could not go in L1 cmd");
      return(FAILURE);
    }
  } /* PCCPCH release */

  /* Check if PCCPCH needs to be dropped */
  if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.n_pccpch_action ==
                                                      LLC_PHYCHAN_RELEASE)
  {
    for(l1_req_index = 0;
        (l1_req_index < LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD) &&
        (l1_req_index <= rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req);
        l1_req_index++)
    {
      if(l1_req_index == rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req)
      {
        rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.req_mask = 0;
        rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req ++;
      }
      else if(rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.req_mask &
         CPHY_DL_PHYCHAN_DROP_INCL)
      {
        /* Since this command already has a Drop included, it could not be
         * used for another channel drop.
         */
        continue;
      }

      rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.req_mask |=
                                                     CPHY_DL_PHYCHAN_DROP_INCL;
      rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.drop_dl_phychan =
                                                        L1_DL_PHYCHAN_PCCPCH_N;
      break;
    } /* for(...) */

    if( l1_req_index == LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD )
    {
      WRRC_MSG0_ERROR("N_PCCPCH release could not go in L1 cmd");
      return(FAILURE);
    }
  } /* N_PCCPCH release */

  /* First look at DL Physical channels that need a setup/reconfig */
  if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action
      == LLC_PHYCHAN_SETUP)
  {
    /* Update the current L1 command to include PCCPCH operation */
    for( l1_req_index = 0;
         (l1_req_index < LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD) &&
         (l1_req_index <= rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req);
         l1_req_index ++
       )
    {
      if(l1_req_index == rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req)
      {
        rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.req_mask = 0;
        rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req ++;
      }
      else if(rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.req_mask &
         CPHY_DL_CCTRCH_INCL)
      {
        /* Since this command already has a CCTrCH included, it could not be
         * used for another establish/reconfigure.
         */
        continue;
      }

      l1_cmd_ptr = &rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index];

      l1_cmd_ptr->cmd.setup.req_mask |= CPHY_DL_CCTRCH_INCL;

      if(rrcllc_cmd_under_process.chan_config.new_freq)
      {
        l1_cmd_ptr->cmd.setup.freq_incl = TRUE;
        l1_cmd_ptr->cmd.setup.rf_chan = ordered_config_ptr->dest_freq;
      }
      else
      {
        l1_cmd_ptr->cmd.setup.freq_incl = FALSE;
      }

      l1_cmd_ptr->cmd.setup.req_mask |= CPHY_DL_PHYCHAN_ADD_INCL;
      l1_cmd_ptr->cmd.setup.dl_phychan  = L1_DL_PHYCHAN_PCCPCH_S;
      /* TBD: Ordered Config should not at all be involved in PCCPCH */
      /* Initialize the DL physical channel info to Ordered Config since that is how
       * it is. This needs to be changed as PCCPCH needs to go out of OC
       */
      if(rrcllc_cmd_under_process.chan_config.solo_bch_operation)
      {
        l1_cmd_ptr->cmd.setup.dl_phychan_db =
          &current_config_ptr->l1_dl_chan_parms;
      }
      else
      {
        l1_cmd_ptr->cmd.setup.dl_phychan_db =
          &ordered_config_ptr->l1_dl_chan_parms;
      }

      /* Do not update Ordered Config with PCCPCH DL CCTrCH data */
      l1_cmd_ptr->cmd.setup.dl_cctrch_info  = &rrcllc_semi_permanent_data.dl_phy_chan.pccpch;
      l1_cmd_ptr->cmd.setup.dl_ctfc_info    = NULL;

      break;
    }

    if( l1_req_index == LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD )
    {
      WRRC_MSG0_ERROR("PCCPCH setup/reconfig could not go in L1 cmd");
      return(FAILURE);
    }
  } /* It is a DL PCCPCH setup/reconfig */

  if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.n_pccpch_action
      == LLC_PHYCHAN_SETUP)
  {
    /* Update the current L1 command to include PCCPCH operation */
    for( l1_req_index = 0;
         (l1_req_index < LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD) &&
         (l1_req_index <= rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req);
         l1_req_index ++
       )
    {
      if(l1_req_index == rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req)
      {
        rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.req_mask = 0;
        rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req ++;
      }
      else if(rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.req_mask &
         CPHY_DL_CCTRCH_INCL)
      {
        /* Since this command already has a CCTrCH included, it could not be
         * used for another establish/reconfigure.
         */
        continue;
      }

      l1_cmd_ptr = &rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index];

      l1_cmd_ptr->cmd.setup.req_mask |= CPHY_DL_CCTRCH_INCL;
      l1_cmd_ptr->cmd.setup.freq_incl = TRUE;
      if(rrcllc_cmd_under_process.chan_config.new_freq)
      {
        l1_cmd_ptr->cmd.setup.rf_chan = ordered_config_ptr->dest_freq;
      }
      else
      {
        l1_cmd_ptr->cmd.setup.rf_chan   = rrcllc_cmd_under_process.rrcllc_cell_resel_info.freq;
      }

      l1_cmd_ptr->cmd.setup.req_mask |= CPHY_DL_PHYCHAN_ADD_INCL;
      l1_cmd_ptr->cmd.setup.dl_phychan  = L1_DL_PHYCHAN_PCCPCH_N;
      /* TBD: Ordered Config should not at all be involved in PCCPCH */
      /* Initialize the DL physical channel info to Ordered Config since that is how
       * it is. This needs to be changed as PCCPCH needs to go out of OC
       */
      if(rrcllc_cmd_under_process.chan_config.solo_bch_operation)
      {
        l1_cmd_ptr->cmd.setup.dl_phychan_db =
          &current_config_ptr->l1_dl_chan_parms;
      }
      else
      {
        l1_cmd_ptr->cmd.setup.dl_phychan_db =
          &ordered_config_ptr->l1_dl_chan_parms;
      }

      /* Keep N_PCCPCH data in rrcllc_semi_permanent_data only. NO need to update
       * Ordered Config.
       */
      l1_cmd_ptr->cmd.setup.dl_cctrch_info  = &rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch;
#if defined(FEATURE_WCDMA_DRX_MANAGER)
      l1_cmd_ptr->cmd.setup.dl_phychan_db->pccpch.sib_sfn_bit_mask = rrcsib_get_sib_sleep_schedule_table_location();
#endif
      l1_cmd_ptr->cmd.setup.dl_ctfc_info    = NULL;

      break;
    }

    if( l1_req_index == LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD )
    {
      WRRC_MSG0_ERROR("PCCPCH setup/reconfig could not go in L1 cmd");
      return(FAILURE);
    }
  } /* It is a DL N_PCCPCH setup/reconfig */


  if((rrcllc_cmd_under_process.chan_config.phy_chan_action_list.dl_dpch_action
            == LLC_PHYCHAN_SETUP) ||
     (rrcllc_cmd_under_process.chan_config.phy_chan_action_list.dl_dpch_action
            == LLC_PHYCHAN_SET_LBT_MODE) ||
     (rrcllc_cmd_under_process.chan_config.phy_chan_action_list.dl_dpch_action
            == LLC_PHYCHAN_RECONFIG) ||
     (rrcllc_cmd_under_process.chan_config.phy_chan_action_list.aset_update
            == TRUE))
  {
    /* Update the current L1 command to include DPCH operation */
    for( l1_req_index = 0;
         (l1_req_index < LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD) &&
         (l1_req_index <= rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req);
         l1_req_index ++
       )
    {

      if(l1_req_index == rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req)
      {
        rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.req_mask = 0;
        rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req ++;
      }
      else if(rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.req_mask &
                CPHY_DL_CCTRCH_INCL ||
                            ((rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.req_mask &
                                CPHY_DL_PHYCHAN_DROP_INCL) &&
                             (rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.drop_dl_phychan ==
                                L1_DL_PHYCHAN_PCCPCH_S)) ||
                            ((rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.req_mask &
                                CPHY_DL_PHYCHAN_DROP_INCL) &&
                             (rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.drop_dl_phychan ==
                                L1_DL_PHYCHAN_PCCPCH_N))
                         )
      {
        /* Since this command already has a CCTrCH included, it could not be
         * used for another establish/reconfigure.
         */
        continue;
      }

      l1_cmd_ptr = &rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index];
      if(rrcllc_cmd_under_process.chan_config.new_freq)
      {
        l1_cmd_ptr->cmd.setup.freq_incl = TRUE;
        l1_cmd_ptr->cmd.setup.rf_chan = ordered_config_ptr->dest_freq;
      }
      else
      {
        l1_cmd_ptr->cmd.setup.freq_incl = FALSE;
      }

      if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.dl_dpch_action
        == LLC_PHYCHAN_SETUP)
      {
        if(!ordered_config_ptr->l1_dl_chan_parms.use_fdpch)
        {
          l1_cmd_ptr->cmd.setup.req_mask |= CPHY_DL_CCTRCH_INCL;
        }
        l1_cmd_ptr->cmd.setup.req_mask |= CPHY_DL_PHYCHAN_ADD_INCL;
        l1_cmd_ptr->cmd.setup.dl_phychan  = L1_DL_PHYCHAN_DPCH;
        if(ordered_config_ptr->l1_dl_chan_parms.use_fdpch == TRUE)
        {
          WRRC_MSG0_MED("F-DPCH to be activated");
          l1_cmd_ptr->cmd.setup.dl_phychan  = L1_DL_PHYCHAN_FDPCH;
        }
        l1_cmd_ptr->cmd.setup.dl_phychan_db = &ordered_config_ptr->l1_dl_chan_parms;
        if ((ordered_config_ptr->cm_info.tgp_seq_info_count > 0) && (rrc_get_state() == RRC_STATE_CELL_FACH)
          && (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_DCH))
        {
          WRRC_MSG0_HIGH("SETTING BIT MASK FOR CM");
          l1_cmd_ptr->cmd.setup.dl_phychan_db->dl_common.opt_parm_presence_bitmask |= DL_COMMON_INFO_COMPRESSED_MODE_INFO_PRESENT;
        }

        /* Update the connected mode timers/counters */
        rrcllc_update_oc_with_l1_connected_mode_timers();
      }
      else if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.dl_dpch_action
                == LLC_PHYCHAN_RECONFIG)
      {
        /* Instead of reconfiguring DL DPCH, add and drop it */
        if(!ordered_config_ptr->l1_dl_chan_parms.use_fdpch)
        {
          l1_cmd_ptr->cmd.setup.req_mask |= CPHY_DL_CCTRCH_INCL;
        }
        if(rrcllc_cmd_under_process.is_hho_in_dch)
        {
          /* If it's a IF HHO DCH->DCH, do an ADD and DROP instead of reconfig */
          l1_cmd_ptr->cmd.setup.req_mask |= CPHY_DL_PHYCHAN_ADD_INCL;
          l1_cmd_ptr->cmd.setup.dl_phychan  = L1_DL_PHYCHAN_DPCH;
          if(ordered_config_ptr->l1_dl_chan_parms.use_fdpch == TRUE)
          {
						WRRC_MSG0_HIGH("F-DPCH to be activated");
            l1_cmd_ptr->cmd.setup.dl_phychan  = L1_DL_PHYCHAN_FDPCH;
          }       
          l1_cmd_ptr->cmd.setup.dl_phychan_db = &ordered_config_ptr->l1_dl_chan_parms;
        }
        else
        {
          /* Do a seamless Reconfig */
          l1_cmd_ptr->cmd.setup.req_mask |= CPHY_DL_PHYCHAN_CFG_INCL;

          l1_cmd_ptr->cmd.setup.dl_phychan  = L1_DL_PHYCHAN_DPCH;
     
          if(ordered_config_ptr->l1_dl_chan_parms.use_fdpch == TRUE)
          {
						WRRC_MSG0_HIGH("F-DPCH to be activated");
            l1_cmd_ptr->cmd.setup.dl_phychan  = L1_DL_PHYCHAN_FDPCH;
          }       
          l1_cmd_ptr->cmd.setup.dl_phychan_db = &ordered_config_ptr->l1_dl_chan_parms;
        }

        if (rrclbt_get_lb_mode_and_dummy_sig_enabled(&lb_mode,
                                                     &dummy_signaling_enabled)) 
        {
          WRRC_MSG0_HIGH("Indicate to WL1 and MAC that loopback is still in progress");
          
          l1_cmd_ptr->cmd.setup.req_mask |= CPHY_DL_SET_LOOPBACK_MODE_INCL;
          rrcllc_update_lbt_mode_for_dchs(RRCLLC_XLATE_LBT_MODE(lb_mode)
                                    #ifdef FEATURE_DUMMY_SIGNALING
                                          #error code not present
#endif  
                                          );

        }

        /* Update the connected mode timers/counters */
        rrcllc_update_oc_with_l1_connected_mode_timers();
      }
      else if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.dl_dpch_action
                == LLC_PHYCHAN_SET_LBT_MODE)
      {

        if(!ordered_config_ptr->l1_dl_chan_parms.use_fdpch)
        {
          l1_cmd_ptr->cmd.setup.req_mask |= CPHY_DL_CCTRCH_INCL;
        }
        l1_cmd_ptr->cmd.setup.req_mask |= CPHY_DL_SET_LOOPBACK_MODE_INCL;
        rrcllc_update_lbt_mode_for_dchs(RRCLLC_XLATE_LBT_MODE(
                                          rrcllc_cmd_under_process.
                                          chan_config.lb_test_mode)
                                  #ifdef FEATURE_DUMMY_SIGNALING
                                          #error code not present
#endif
                                        );
      }
      else  /* This is case of stand-alone active set update */
      {
        l1_cmd_ptr->cmd.setup.req_mask |= CPHY_ASET_UPDATE_INCL;
        /* The understanding between L1-RRC is to only set the Add DL Phychan
         * DB pointer without the corresponding mask. This is so that L1 retrieves
         * info on all Radio Links.
         */
        l1_cmd_ptr->cmd.setup.dl_phychan_db = &ordered_config_ptr->l1_dl_chan_parms;
      }

      if((rrcllc_cmd_under_process.chan_config.phy_chan_action_list.dl_dpch_action
            == LLC_PHYCHAN_SETUP) ||
         (rrcllc_cmd_under_process.chan_config.phy_chan_action_list.dl_dpch_action
            == LLC_PHYCHAN_SET_LBT_MODE) ||
         (rrcllc_cmd_under_process.chan_config.phy_chan_action_list.dl_dpch_action
            == LLC_PHYCHAN_RECONFIG))
      {
        /* Update DL CCTrCH data in Ordered Config with CCTrCH ID for DPCH */
        ordered_config_ptr->l1_dl_cctrch_parms.cctrch_id =
            rrcllc_semi_permanent_data.dl_phy_chan.dl_dpch.cctrch_id;
        /* Fill in Ordered Config with current bitflags for DPCH */
        ordered_config_ptr->l1_dl_cctrch_parms.trch_ref_type_bf =
            rrcllc_semi_permanent_data.dl_phy_chan.dl_dpch.trch_ref_type_bf;
        ordered_config_ptr->l1_dl_cctrch_parms.trch_enable_bf =
            rrcllc_semi_permanent_data.dl_phy_chan.dl_dpch.trch_enable_bf;

        l1_cmd_ptr->cmd.setup.dl_cctrch_info  = &ordered_config_ptr->l1_dl_cctrch_parms;
        l1_cmd_ptr->cmd.setup.dl_ctfc_info    = &ordered_config_ptr->l1_dl_ctfc_parms;

        if(rrcllc_cmd_under_process.is_hho_in_dch)
        {
          /* Since it's a Inter-frequency HHO, change the action type
           * to a Release to add a Release command
           */
          if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.dl_dpch_action
              == LLC_PHYCHAN_RECONFIG)
          {
            rrcllc_cmd_under_process.chan_config.phy_chan_action_list.dl_dpch_action =
                                                              LLC_PHYCHAN_RELEASE;
          }
        }

      }
      break;
    } /* for(...) */

    if( l1_req_index == LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD )
    {
      WRRC_MSG0_ERROR("DPCH setup/reconfig could not go in L1 cmd");
      return(FAILURE);
    }
  } /* It is a DL DPCH setup/reconfig */


  /* Now include Downlink channels that need to be released */
  /* Check if SCCPCH needs to be dropped */
  if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_action ==
                                                      LLC_PHYCHAN_RELEASE)
  {
    for(l1_req_index = 0;
        (l1_req_index < LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD) &&
        (l1_req_index <= rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req);
        l1_req_index++)
    {

      if(l1_req_index == rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req)
      {
        rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.req_mask = 0;
        rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req ++;
      }
      else if(rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.req_mask &
         CPHY_DL_PHYCHAN_DROP_INCL)
      {
        /* Since this command already has a Drop included, it could not be
         * used for another channel drop.
         */
        continue;
      }

      rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.req_mask |=
                                                     CPHY_DL_PHYCHAN_DROP_INCL;
      rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.drop_dl_phychan =
                                                         L1_DL_PHYCHAN_SCCPCH0;
      break;
    } /* for(...) */

    if( l1_req_index == LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD )
    {
      WRRC_MSG0_ERROR("SCCPCH release could not go in L1 cmd");
      return(FAILURE);
    }
  } /* SCCPCH release */

  /* Check if DPCH needs to be dropped */
  if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.dl_dpch_action ==
                                                      LLC_PHYCHAN_RELEASE)
  {
    for(l1_req_index = 0;
        (l1_req_index < LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD) &&
        (l1_req_index <= rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req);
        l1_req_index++)
    {
      if(l1_req_index == rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req)
      {
        rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.req_mask = 0;
        rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req ++;
      }
      else if(rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.req_mask &
         CPHY_DL_PHYCHAN_DROP_INCL)
      {
        /* Since this command already has a Drop included, it could not be
         * used for another channel drop.
         */
        continue;
      }
      rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.req_mask |=
                                                     CPHY_DL_PHYCHAN_DROP_INCL;
      rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.drop_dl_phychan =
                                                         L1_DL_PHYCHAN_DPCH;
      if(ordered_config_ptr->l1_dl_chan_parms.use_fdpch == TRUE)
      {
        rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index].cmd.setup.drop_dl_phychan =
          L1_DL_PHYCHAN_FDPCH;
      }
      break;
    } /* for(...) */

    if( l1_req_index == LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD )
    {
      WRRC_MSG0_ERROR("DPCH release could not go in L1 cmd");
      return(FAILURE);
    }
  } /* DPCH release */
#ifdef FEATURE_WCDMA_DC_HSUPA

  /* adding secondary eul downlink channels */
  /* First decide whether we need to add downlink channels for secondary are not */

  oc_status = rrcllc_get_ordered_config_state_and_proc_wo_f3(&proc_id, &process_state);
  if((rrcllc_cmd_under_process.chan_config.current_cmd_engine 
     == LLC_RELEASE_TR_PHY_CHAN_ENGINE)&&
     ((OC_SET_FOR_DCH_FACH_TRANS == oc_status) &&
          ((transition_config.toc_ptr->activation_time != RRCLLC_ACTIVATION_TIME_NOW) &&
           (transition_config.toc_ptr->act_time_type == L1_ACTIVATION_TIME_CFN)) && 
          ((proc_id == RRC_PROCEDURE_RBE) ||
           (proc_id == RRC_PROCEDURE_RBR) ||
           (proc_id == RRC_PROCEDURE_RBRC) ||
           (proc_id == RRC_PROCEDURE_TCR) ||
           (proc_id == RRC_PROCEDURE_PCR)) &&
           (curr_scan == RRC_CSP_CELL_DCH_TO_CELL_FACH_SCAN)))
  {
    fake_cphy_setup = TRUE;
  }

  if ((((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RBE) ||
     (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RBRC) ||
     (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RBR) ||
     (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_TCR) ||
     (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_PCR) ||
     (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CU) ||
     (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_ASU) ||
     (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RCR) ||
     (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CHO) ||
     (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_IHO)
#ifdef FEATURE_DUAL_SIM
     || ((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)
      &&(rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
      &&(curr_scan == RRC_CSP_UNLOCK_BY_SCAN))
#endif
     )
     || (fake_cphy_setup == TRUE) ) &&
     ((ordered_config_ptr->l1_sec_e_req_mask != L1_EUL_NOOP) ||
         (ordered_config_ptr->sec_e_dch_transmission)))
  {
     if (ordered_config_ptr->l1_sec_e_req_mask & (L1_EUL_START |L1_EUL_RECFG_DL|L1_EUL_STOP))
      {
          for(i = 0;
         (i < LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD) &&
         (i <= rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req);
         i ++
           )
          {


            if ((i == rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req)
              && (ordered_config_ptr->l1_sec_e_req_mask != L1_EUL_NOOP))
            {
              ERR_FATAL("DC_HSUPA:No FDPCH found!!! This shouldn't happen :(",0,0,0);
            }
            /* If SEC EUL action is a start and Non-DCH -> DCH transition is occuring, make sure
               that EUL start goes with DPCH ADD cmd to L1*/
            else if ((ordered_config_ptr->l1_sec_e_req_mask == L1_EUL_START) &&
                     (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_DCH &&
                      current_config_ptr->rrc_state_indicator != RRC_STATE_CELL_DCH)&&
                     (!((rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i].cmd.setup.req_mask &
                        (CPHY_DL_PHYCHAN_ADD_INCL /*| CPHY_DL_PHYCHAN_ADD_INCL*/)) &&
                        ((rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i].cmd.setup.dl_phychan ==
                          L1_DL_PHYCHAN_FDPCH)
                         ))))
            {
              WRRC_MSG1_HIGH("DC_HSUPA: DC HSUPA Action Start:  Looking for primary ul FDPCH Add - not found - go to next idx %d",i);
                /* Looking for cmd that contains DPCH setup as well */
              continue;
            }
            /* if EUL Action is drop and DCH->NON-DCH transition is occuring, make sure EUL stop
                            goes with DPCH drop cmd to L1*/
            else if ((ordered_config_ptr->l1_sec_e_req_mask == L1_EUL_STOP) &&
                     (rrcllc_cmd_under_process.next_rrc_state != RRC_STATE_CELL_DCH &&
                      current_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH) &&
                     (!((rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i].cmd.setup.req_mask &
                         (CPHY_DL_PHYCHAN_DROP_INCL /*| CPHY_UL_PHYCHAN_DROP_INCL*/)) &&
                        ((rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i].cmd.setup.drop_dl_phychan ==
                          L1_DL_PHYCHAN_FDPCH)
                         ))))
            {
              WRRC_MSG1_HIGH("DC_HSUPA: DC HSUPA Action Stop:  Looking for primary eul FDPCH drop - not found - go to next idx %d",i);
              /* Looking for cmd that contains DPCH DROP  as well */
              continue;
            }

            /* loop back mode is not being taken care here*/

            l1_cmd_ptr = &rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i];
            if(rrcllc_cmd_under_process.chan_config.sec_eul_new_freq)
            {

              //why do we need to send this dl freq to L1 they cna use Dc HDPA freq?
              l1_cmd_ptr->cmd.setup.sec_freq_incl = TRUE;
              l1_cmd_ptr->cmd.setup.sec_rf_chan = ordered_config_ptr->sec_eul_dest_freq;
            }
            else
            {
              l1_cmd_ptr->cmd.setup.sec_freq_incl = FALSE;
            }

            /* If DCHSUPA is stopped through ASU, do not include ASET bitmask in the cmd */
            if((rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sec_eul_aset_update) && (!(ordered_config_ptr->l1_sec_e_req_mask & L1_EUL_STOP)))
            {
              l1_cmd_ptr->cmd.setup.req_mask |= CPHY_SEC_ASET_UPDATE_INCL;
              /* The understanding between L1-RRC is to only set the Add DL Phychan
                           * DB pointer without the corresponding mask. This is so that L1 retrieves
                           * info on all Radio Links.
                           */
              if(l1_cmd_ptr->cmd.setup.dl_phychan_db == NULL)
              {
                l1_cmd_ptr->cmd.setup.dl_phychan_db = &ordered_config_ptr->l1_dl_chan_parms;
              }
              l1_cmd_ptr->cmd.setup.sec_dl_phychan  = L1_DL_PHYCHAN_SEC_FDPCH;

            }
            else 
            {
              if(ordered_config_ptr->l1_sec_e_req_mask & L1_EUL_START)
              {
                l1_cmd_ptr->cmd.setup.req_mask |= CPHY_SEC_DL_PHYCHAN_ADD_INCL;
                l1_cmd_ptr->cmd.setup.sec_dl_phychan  = L1_DL_PHYCHAN_SEC_FDPCH;                
                if(l1_cmd_ptr->cmd.setup.dl_phychan_db == NULL)
                {
                  l1_cmd_ptr->cmd.setup.dl_phychan_db = &ordered_config_ptr->l1_dl_chan_parms;
                }
              }
              else if (ordered_config_ptr->l1_sec_e_req_mask & L1_EUL_RECFG_DL)
              {
                if(rrcllc_cmd_under_process.is_hho_in_dch_for_sec_eul)
                {
                  /* If it's a IF HHO DCH->DCH, do an ADD and DROP instead of reconfig */
                  l1_cmd_ptr->cmd.setup.req_mask |= CPHY_SEC_DL_PHYCHAN_ADD_INCL;
                  l1_cmd_ptr->cmd.setup.sec_dl_phychan  = L1_DL_PHYCHAN_SEC_FDPCH;
                  if(l1_cmd_ptr->cmd.setup.dl_phychan_db == NULL)
                  {
                    l1_cmd_ptr->cmd.setup.dl_phychan_db = &ordered_config_ptr->l1_dl_chan_parms;
                  }
                }
                else
                {
                  /* Do a seamless Reconfig */
                  l1_cmd_ptr->cmd.setup.req_mask |= CPHY_SEC_DL_PHYCHAN_CFG_INCL;              
                  l1_cmd_ptr->cmd.setup.sec_dl_phychan  = L1_DL_PHYCHAN_SEC_FDPCH;
                  if(l1_cmd_ptr->cmd.setup.dl_phychan_db == NULL)
                  {
                    l1_cmd_ptr->cmd.setup.dl_phychan_db = &ordered_config_ptr->l1_dl_chan_parms;
                  }
                }

              }

              /* If it is HHO eul req mask would have been set to START+STOP so it will care of setting downlink req mask to START+STOP */
              if (ordered_config_ptr->l1_sec_e_req_mask & L1_EUL_STOP)
              {
                l1_cmd_ptr->cmd.setup.req_mask |= CPHY_SEC_DL_PHYCHAN_DROP_INCL;              
                l1_cmd_ptr->cmd.setup.sec_drop_dl_phychan  = L1_DL_PHYCHAN_SEC_FDPCH;
              }
            }

            break;
          }
      }
    
  }
#endif /* FEATURE_WCDMA_DC_HSUPA */

  WRRC_MSG2_HIGH("no CTFCs: %d, L1 DL reqs %d in cmd_under_process_data", ordered_config_ptr->l1_dl_ctfc_parms.last_ctfc_entry_index, rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req);

  return(SUCCESS);
} /* rrcllc_add_downlink_phy_chan_to_l1_cmd */


/*===========================================================================
FUNCTION   rrcllc_add_uplink_phy_chan_to_l1_cmd

DESCRIPTION
  This function analyzes data in rrc_cmd_under_process for each of the
  uplink physical channels. It then forms CPHY_SETUP_REQ commands for L1
  and stores them in rrc_cmd_under_process.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.
===========================================================================*/
static uecomdef_status_e_type  rrcllc_add_uplink_phy_chan_to_l1_cmd(void)
{
  int32  i;
  l1_ext_cmd_type *l1_cmd_ptr = NULL;
  rrc_proc_e_type                 proc_id;
  rrcllc_oc_process_state_e_type  process_state;  
  rrcllc_oc_set_status_e_type     oc_status;
  boolean fake_cphy_setup = FALSE;

  rrc_csp_scan_e_type curr_scan = rrccsp_get_curr_scan();

  /* In the uplink it is only PRACH and DPCH and both can not be active at
   * the same time.
   * For Uplink physical channels, look for the corresponding downlink physical channel.
   * For example for DPCH in UL, look for in which CPHY_SETUP_REQ, DPCH in DL is there.
   * For PRACH, look for CPHY_SETUP_REQ that has SCCPCH in downlink. If the corresponding
   * channel is not found in any of L1 commands, flag an error.
   */

  /* First look for uplink physical channels that need a setup/reconfig */
  if((rrcllc_cmd_under_process.chan_config.phy_chan_action_list.ul_dpch_action
      == LLC_PHYCHAN_SETUP) ||
     (rrcllc_cmd_under_process.chan_config.phy_chan_action_list.ul_dpch_action
      == LLC_PHYCHAN_RECONFIG))
  {
    /* Now look for L1 command  */
    for( i = 0;
       (i < LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD) &&
       (i <= rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req);
       i ++
     )
    {
      if(i == rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req)
      {
        rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i].cmd.setup.req_mask = 0;
        rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req ++;
      }
      else if((rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i].cmd.setup.req_mask &
                 CPHY_UL_CCTRCH_INCL) ||
                ((rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i].cmd.setup.req_mask &
                    CPHY_DL_PHYCHAN_DROP_INCL) &&
                  (rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i].cmd.setup.drop_dl_phychan ==
                     L1_DL_PHYCHAN_PCCPCH_S)) ||
                   ((rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i].cmd.setup.req_mask &
                       CPHY_DL_PHYCHAN_DROP_INCL) &&
                    (rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i].cmd.setup.drop_dl_phychan ==
                       L1_DL_PHYCHAN_PCCPCH_N))
                           )
      {
        /* Since this command already has a CCTrCH included, it could not be
         * used for another establish/reconfigure.
         */
        continue;
      }

      /* Fill up the Uplink data here */
      l1_cmd_ptr = &rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i];

      l1_cmd_ptr->cmd.setup.req_mask |= CPHY_UL_CCTRCH_INCL;

      if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.ul_dpch_action
          == LLC_PHYCHAN_SETUP)
      {
        l1_cmd_ptr->cmd.setup.req_mask |= CPHY_UL_PHYCHAN_ADD_INCL;
        l1_cmd_ptr->cmd.setup.ul_phychan  = L1_UL_PHYCHAN_DPCH;
      }
      else
      {

        /* If it's a Inter-frequency Hard handover within DCH, do a Add
         * and DROP instead of a Reconfig
         */
        if(rrcllc_cmd_under_process.is_hho_in_dch)
        {
          if((rrcllc_cmd_under_process.procedure != RRC_PROCEDURE_LBT) &&
             (rrcllc_cmd_under_process.procedure != RRC_PROCEDURE_ASU))
          {
            l1_cmd_ptr->cmd.setup.req_mask |= CPHY_UL_PHYCHAN_ADD_INCL;
            l1_cmd_ptr->cmd.setup.ul_phychan  = L1_UL_PHYCHAN_DPCH;
          }
          else
          {
            /* This is a Loopback procedure, do not drop and add
             * Uplink for loopback as Downlink is not being dropped
             * and added
             * Same logic for Active Set Update.
             */
            l1_cmd_ptr->cmd.setup.req_mask |= CPHY_UL_PHYCHAN_CFG_INCL;
            l1_cmd_ptr->cmd.setup.ul_phychan  = L1_UL_PHYCHAN_DPCH;
          }
        }
        else
        {
          l1_cmd_ptr->cmd.setup.req_mask |= CPHY_UL_PHYCHAN_CFG_INCL;
          l1_cmd_ptr->cmd.setup.ul_phychan  = L1_UL_PHYCHAN_DPCH;
        }

      }

      rrcllc_update_l1_with_ul_trch(ordered_config_ptr);

      /* Update ordered config fields */
      ordered_config_ptr->l1_ul_cctrch_parms.chan = L1_UL_PHYCHAN_DPCH;

      /* Initialize pointers in CPHY_SETUP_REQ to Ordered Config structures */
      l1_cmd_ptr->cmd.setup.ul_cctrch_info =
                &ordered_config_ptr->l1_ul_cctrch_parms;

      if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.ul_dpch_action
          == LLC_PHYCHAN_SETUP)
      {
        l1_cmd_ptr->cmd.setup.ul_phychan_db =
                &ordered_config_ptr->l1_ul_chan_parms;
      }
      else
      {

        if(rrcllc_cmd_under_process.is_hho_in_dch)
        {
          if((rrcllc_cmd_under_process.procedure != RRC_PROCEDURE_LBT) &&
             (rrcllc_cmd_under_process.procedure != RRC_PROCEDURE_ASU))
          {
            l1_cmd_ptr->cmd.setup.ul_phychan_db =
                    &ordered_config_ptr->l1_ul_chan_parms;

            rrcllc_cmd_under_process.chan_config.phy_chan_action_list.
              ul_dpch_action = LLC_PHYCHAN_RELEASE;
          }
          else
          {
            /* Do not drop add Uplink for LBT as Downlink is not
             * dropped and added.
             */
            l1_cmd_ptr->cmd.setup.ul_phychan_db =
                    &ordered_config_ptr->l1_ul_chan_parms;
          }
        }
        else
        {
          l1_cmd_ptr->cmd.setup.ul_phychan_db =
                  &ordered_config_ptr->l1_ul_chan_parms;
        }
      }
      l1_cmd_ptr->cmd.setup.tfcs_ptr =
          ordered_config_ptr->mac_ul_parms.tfcs_ptr;
      break;
    } /* for(...) */

    if(i == rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req)
    {
      WRRC_MSG0_ERROR("DL L1 cmds do not have DPCH add/cfg");
      return(FAILURE);
    }
  } /* DPCH needs to be setup/reconfigured in uplink */

  else if((rrcllc_cmd_under_process.chan_config.phy_chan_action_list.prach_action
            == LLC_PHYCHAN_SETUP) ||
          (rrcllc_cmd_under_process.chan_config.phy_chan_action_list.prach_action
            == LLC_PHYCHAN_RECONFIG) ||
            (rrcllc_cmd_under_process.chan_config.phy_chan_action_list.prach_action
          == LLC_PHYCHAN_DROP_AND_ADD))
  {
    /* Now look for the L1 command
     */
    for( i = 0;
       (i < LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD) &&
       (i <= rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req);
       i ++
     )
    {
      if(i == rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req)
      {
        rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i].cmd.setup.req_mask = 0;
        rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req ++;
      }
      else if(rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i].cmd.setup.req_mask &
         CPHY_UL_CCTRCH_INCL)
      {
        /* Since this command already has a CCTrCH included, it could not be
         * used for another establish/reconfigure.
         */
        continue;
      }

      /* Fill up the Uplink data here */
      l1_cmd_ptr = &rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i];

      l1_cmd_ptr->cmd.setup.req_mask |= CPHY_UL_CCTRCH_INCL;

      if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.prach_action
          == LLC_PHYCHAN_SETUP)
      {
        l1_cmd_ptr->cmd.setup.req_mask |= CPHY_UL_PHYCHAN_ADD_INCL;
        l1_cmd_ptr->cmd.setup.ul_phychan  = L1_UL_PHYCHAN_PRACH;
      }
      else if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.prach_action
          == LLC_PHYCHAN_DROP_AND_ADD)
      {
        l1_cmd_ptr->cmd.setup.req_mask |= CPHY_UL_PHYCHAN_ADD_INCL;
        l1_cmd_ptr->cmd.setup.ul_phychan  = L1_UL_PHYCHAN_PRACH;
      }
      else
      {
        l1_cmd_ptr->cmd.setup.req_mask |= CPHY_UL_PHYCHAN_CFG_INCL;
        l1_cmd_ptr->cmd.setup.ul_phychan  = L1_UL_PHYCHAN_PRACH;
      }


      /* Update ordered config fields */
      ordered_config_ptr->l1_ul_cctrch_parms.chan = L1_UL_PHYCHAN_PRACH;

      if(ordered_config_ptr->l1_ul_cctrch_parms.num_trch == 0)
      {
        WRRC_MSG0_ERROR("Invalid: 0 TrCHs for UL PRACH in OC");
        return(FAILURE);
      }

      /* Initialize pointers in CPHY_SETUP_REQ to Ordered Config structures */
      l1_cmd_ptr->cmd.setup.ul_cctrch_info =
                &ordered_config_ptr->l1_ul_cctrch_parms;

      if ((rrcllc_cmd_under_process.chan_config.phy_chan_action_list.prach_action
          == LLC_PHYCHAN_SETUP) ||
          (rrcllc_cmd_under_process.chan_config.phy_chan_action_list.prach_action
          == LLC_PHYCHAN_DROP_AND_ADD))
      {
        l1_cmd_ptr->cmd.setup.ul_phychan_db =
                &ordered_config_ptr->l1_ul_chan_parms;
        /* Make sure that the add_dl_phychan_db pointer is set to
         * l1_dl_chan_parms in Ordered Config. This is needed since AICH
         * is setup at the same time as PRACH. The L1 DL paramters should
         * contain AICH parameters.
         */
        l1_cmd_ptr->cmd.setup.dl_phychan_db =
                &ordered_config_ptr->l1_dl_chan_parms;
      }
      else
      {
        l1_cmd_ptr->cmd.setup.ul_phychan_db =
                &ordered_config_ptr->l1_ul_chan_parms;
        /* Make sure that the cfg_dl_phychan_db pointer is set to
         * l1_dl_chan_parms in Ordered Config. This is needed since AICH
         * is setup at the same time as PRACH. The L1 DL paramters should
         * contain AICH parameters.
         */
        l1_cmd_ptr->cmd.setup.dl_phychan_db =
                &ordered_config_ptr->l1_dl_chan_parms;
      }
      l1_cmd_ptr->cmd.setup.tfcs_ptr =
          ordered_config_ptr->mac_ul_parms.tfcs_ptr;
      if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.prach_action
          == LLC_PHYCHAN_DROP_AND_ADD)
      {
        // Need to set this to RELEASE as a drop should also be performed by L1.
        rrcllc_cmd_under_process.chan_config.phy_chan_action_list.prach_action
          = LLC_PHYCHAN_RELEASE;
      }
      break;
    } /* for(...) */

    if(i == rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req)
    {
      WRRC_MSG0_ERROR("DL L1 cmds do not have SCCPCH add/cfg");
      return(FAILURE);
    }
  } /* PRACH needs to be setup/reconfigured in uplink */

  /* Now look for Uplink Physical channels that need to be dropped */
  if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.ul_dpch_action
      == LLC_PHYCHAN_RELEASE)
  {
    /* Now look for L1 command that has DPCH Drop */
    for (i = 0;
        (i < LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD) &&
        (i <= rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req);
        i++)
    {
      if(i == rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req)
      {
        rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i].cmd.setup.req_mask = 0;
        rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req ++;
      }
      else if(rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i].cmd.setup.req_mask &
         CPHY_UL_PHYCHAN_DROP_INCL)
      {
        /* Since this command already has a Drop included, it could not be
         * used for another channel drop.
         */
        continue;
      }
      /* Fill up the Uplink data here */
      l1_cmd_ptr = &rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i];
      l1_cmd_ptr->cmd.setup.req_mask |= CPHY_UL_PHYCHAN_DROP_INCL;
      l1_cmd_ptr->cmd.setup.drop_ul_phychan = L1_UL_PHYCHAN_DPCH;
      break;
    } /* for(...) */

    if(i == rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req)
    {
      WRRC_MSG0_ERROR("DL L1 cmds do not have DPCH release");
      return(FAILURE);
    }
  } /* UL DPCH needs a release */

  if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.prach_action
      == LLC_PHYCHAN_RELEASE)
  {
    /* Now look for L1 command that has SCCPCH Drop */
    /* Now look for L1 command that has DPCH Drop */
    for (i = 0;
        (i < LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD) &&
        (i <= rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req);
        i++)
    {
      if(i == rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req)
      {
        rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i].cmd.setup.req_mask = 0;
        rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req ++;
      }
      else if((rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i].cmd.setup.req_mask &
                 CPHY_UL_PHYCHAN_DROP_INCL) ||
                 ((rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i].cmd.setup.req_mask &
                     CPHY_DL_PHYCHAN_DROP_INCL) &&
                  (rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i].cmd.setup.drop_dl_phychan ==
                     L1_DL_PHYCHAN_PCCPCH_S)) ||
                 ((rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i].cmd.setup.req_mask &
                     CPHY_DL_PHYCHAN_DROP_INCL) &&
                  (rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i].cmd.setup.drop_dl_phychan ==
                     L1_DL_PHYCHAN_PCCPCH_N))
                          )
      {
        /* Since this command already has a Drop included, it could not be
         * used for another channel drop.
        */
        continue;
      }
      /* Fill up the Uplink data here */
      l1_cmd_ptr = &rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i];
      l1_cmd_ptr->cmd.setup.req_mask |= CPHY_UL_PHYCHAN_DROP_INCL;
      l1_cmd_ptr->cmd.setup.drop_ul_phychan = L1_UL_PHYCHAN_PRACH;
      break;
    } /* for(...) */

    if(i == rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req)
    {
      WRRC_MSG0_ERROR("DL L1 cmds do not have SCCPCH release");
      return(FAILURE);
    }
  } /* UL PRACH needs a release */

  /* Fist clear off the L1 eul flags from cmd under process */ 
  for(i = 0;
       (i < LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD) &&
       (i <= rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req);
       i ++
         )
  {
    l1_cmd_ptr = &rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i];
    l1_cmd_ptr->cmd.setup.e_req_mask = 0;
    l1_cmd_ptr->cmd.setup.mac_e_reset_indicator = 0;
  }

  oc_status = rrcllc_get_ordered_config_state_and_proc_wo_f3(&proc_id, &process_state);
  if((rrcllc_cmd_under_process.chan_config.current_cmd_engine 
     == LLC_RELEASE_TR_PHY_CHAN_ENGINE)&&
     ((OC_SET_FOR_DCH_FACH_TRANS == oc_status) &&
          ((transition_config.toc_ptr->activation_time != RRCLLC_ACTIVATION_TIME_NOW) &&
           (transition_config.toc_ptr->act_time_type == L1_ACTIVATION_TIME_CFN)) && 
          ((proc_id == RRC_PROCEDURE_RBE) ||
           (proc_id == RRC_PROCEDURE_RBR) ||
           (proc_id == RRC_PROCEDURE_RBRC) ||
           (proc_id == RRC_PROCEDURE_TCR) ||
           (proc_id == RRC_PROCEDURE_PCR)) &&
           (curr_scan == RRC_CSP_CELL_DCH_TO_CELL_FACH_SCAN)))
  {
    fake_cphy_setup = TRUE;
  }
  /*  Construct EUL commands only if the procedure is capable of 
      doing EUL related actions */
  if ((((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RCE) ||
       (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RBE) ||
       (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RBRC) ||
       (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RBR) ||
       (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_TCR) ||
       (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_PCR) ||
       (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CU) ||
       (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_ASU) ||
       (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RCR) ||
       (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CHO) ||
       (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_IHO)
#ifdef FEATURE_DUAL_SIM
       || ((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)
        &&(rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
        &&(curr_scan == RRC_CSP_UNLOCK_BY_SCAN))
#endif
       )
       || (fake_cphy_setup == TRUE) ) &&
       ((ordered_config_ptr->l1_e_req_mask != L1_EUL_NOOP) ||
           (ordered_config_ptr->e_dch_transmission)))
  {
    /* Now look for L1 command  */
    for(i = 0;
         (i < LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD) &&
         (i <= rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req);
         i ++
           )
    {
      if ((i == rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req)
        && (ordered_config_ptr->l1_e_req_mask != L1_EUL_NOOP))
      {
        ERR_FATAL("RRCEUL:No DPCH found!!! This shouldn't happen :(",0,0,0);
      }
      /* If EUL action is a start and Non-DCH -> DCH transition is occuring, make sure
         that EUL start goes with DPCH ADD cmd to L1*/
      else if ((ordered_config_ptr->l1_e_req_mask == L1_EUL_START) &&
               (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_DCH &&
                current_config_ptr->rrc_state_indicator != RRC_STATE_CELL_DCH)&&
               (!((rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i].cmd.setup.req_mask &
                  (CPHY_DL_PHYCHAN_ADD_INCL | CPHY_UL_PHYCHAN_ADD_INCL)) &&
                  ((rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i].cmd.setup.dl_phychan ==
                    L1_DL_PHYCHAN_DPCH)||
                   (rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i].cmd.setup.dl_phychan ==
                    L1_DL_PHYCHAN_FDPCH)||
                   (rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i].cmd.setup.ul_phychan ==
                    L1_UL_PHYCHAN_DPCH)))))
      {
        WRRC_MSG1_HIGH("RRCEUL: EUL Action Start:  Looking for DPCH Add - not found - go to next idx %d",i);
          /* Looking for cmd that contains DPCH setup as well */
        continue;
      }
      /* if EUL Action is drop and DCH->NON-DCH transition is occuring, make sure EUL stop
         goes with DPCH drop cmd to L1*/
      else if ((ordered_config_ptr->l1_e_req_mask == L1_EUL_STOP) &&
               (rrcllc_cmd_under_process.next_rrc_state != RRC_STATE_CELL_DCH &&
                current_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH) &&
               (!((rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i].cmd.setup.req_mask &
                   (CPHY_DL_PHYCHAN_DROP_INCL | CPHY_UL_PHYCHAN_DROP_INCL)) &&
                  ((rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i].cmd.setup.drop_dl_phychan ==
                    L1_DL_PHYCHAN_DPCH) ||
                   (rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i].cmd.setup.drop_dl_phychan ==
                    L1_DL_PHYCHAN_FDPCH) ||
                   (rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i].cmd.setup.drop_ul_phychan ==
                    L1_UL_PHYCHAN_DPCH)))))
      {
        WRRC_MSG1_HIGH("RRCEUL: EUL Action Stop:  Looking for DPCH drop - not found - go to next idx %d",i);
        /* Looking for cmd that contains DPCH setup as well */
        continue;
      }

      /* Fill up the Uplink data here */
      l1_cmd_ptr = &rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i];

      if (ordered_config_ptr->l1_e_req_mask & (L1_EUL_START |L1_EUL_RECFG_DL|L1_EUL_STOP))
      {
        l1_cmd_ptr->cmd.setup.req_mask |= CPHY_E_DL_CHAN_CFG_INCL;
      }
      if (ordered_config_ptr->l1_e_req_mask & (L1_EUL_START |L1_EUL_RECFG_UL|L1_EUL_STOP))
      {
        l1_cmd_ptr->cmd.setup.req_mask |= CPHY_E_UL_CHAN_CFG_INCL;
      }

      WRRC_MSG1_MED("RRCEUL: Setting uplink L1 actions cfg_incl %x ",l1_cmd_ptr->cmd.setup.req_mask);
      l1_cmd_ptr->cmd.setup.e_info_ptr =
        &ordered_config_ptr->l1_e_info;

      l1_cmd_ptr->cmd.setup.e_req_mask =
        ordered_config_ptr->l1_e_req_mask;

      l1_cmd_ptr->cmd.setup.mac_e_reset_indicator =
        ordered_config_ptr->mac_e_reset_indicator;
      break;
    }
  }

#ifdef FEATURE_WCDMA_DC_HSUPA
  /* Fist clear off the L1 sec eul flags from cmd under process */ 
  for(i = 0;
       (i < LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD) &&
       (i <= rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req);
       i ++
         )
  {
    l1_cmd_ptr = &rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i];
    l1_cmd_ptr->cmd.setup.sec_e_req_mask = 0;
//    l1_cmd_ptr->cmd.setup.mac_e_reset_indicator = 0;  check this whether required or not
  }

  oc_status = rrcllc_get_ordered_config_state_and_proc_wo_f3(&proc_id, &process_state);
  if((rrcllc_cmd_under_process.chan_config.current_cmd_engine 
     == LLC_RELEASE_TR_PHY_CHAN_ENGINE)&&
     ((OC_SET_FOR_DCH_FACH_TRANS == oc_status) &&
          ((transition_config.toc_ptr->activation_time != RRCLLC_ACTIVATION_TIME_NOW) &&
           (transition_config.toc_ptr->act_time_type == L1_ACTIVATION_TIME_CFN)) && 
          ((proc_id == RRC_PROCEDURE_RBE) ||
           (proc_id == RRC_PROCEDURE_RBR) ||
           (proc_id == RRC_PROCEDURE_RBRC) ||
           (proc_id == RRC_PROCEDURE_TCR) ||
           (proc_id == RRC_PROCEDURE_PCR)) &&
          (curr_scan == RRC_CSP_CELL_DCH_TO_CELL_FACH_SCAN)))
  {
    fake_cphy_setup = TRUE;
  }
  /*  Construct EUL commands only if the procedure is capable of 
      doing EUL related actions */
  if ((((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RBE) ||
       (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RBRC) ||
       (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RBR) ||
       (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_TCR) ||
       (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_PCR) ||
       (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CU) ||
       (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_ASU) ||
       (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RCR) ||
       (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CHO) ||
       (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_IHO)
#ifdef FEATURE_DUAL_SIM
       || ((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)
        &&(rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
        &&(curr_scan == RRC_CSP_UNLOCK_BY_SCAN))
#endif
       )
       || (fake_cphy_setup == TRUE) ) &&
       ((ordered_config_ptr->l1_sec_e_req_mask != L1_EUL_NOOP) ||
           (ordered_config_ptr->sec_e_dch_transmission)))
  {

  //check if this can be optimized 
    /* Now look for L1 command  */
    for(i = 0;
         (i < LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD) &&
         (i <= rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req);
         i ++
           )
    {
      if ((i == rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req)
        && (ordered_config_ptr->l1_sec_e_req_mask != L1_EUL_NOOP))
      {
        ERR_FATAL("DC_HSUPA:No FDPCH found!!! This shouldn't happen :(",0,0,0);
      }
      /* If EUL action is a start and Non-DCH -> DCH transition is occuring, make sure
         that EUL start goes with DPCH ADD cmd to L1*/
      else if ((ordered_config_ptr->l1_sec_e_req_mask == L1_EUL_START) &&
               (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_DCH &&
                current_config_ptr->rrc_state_indicator != RRC_STATE_CELL_DCH)&&
               (!((rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i].cmd.setup.req_mask &
                  (CPHY_SEC_DL_PHYCHAN_ADD_INCL /*| CPHY_SEC_UL_PHYCHAN_ADD_INCL*/)) &&
                  ((rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i].cmd.setup.sec_dl_phychan ==
                    L1_DL_PHYCHAN_SEC_FDPCH)
                   ))))
      {
        WRRC_MSG1_HIGH("DC_HSUPA: DC HSUPA Action Start:  Looking for FDPCH Add - not found - go to next idx %d",i);
          /* Looking for cmd that contains DPCH setup as well */
        continue;
      }
      /* if EUL Action is drop and DCH->NON-DCH transition is occuring, make sure SEC EUL stop
         goes with SEC FDPCH drop cmd to L1*/
      else if ((ordered_config_ptr->l1_sec_e_req_mask == L1_EUL_STOP) &&
               (rrcllc_cmd_under_process.next_rrc_state != RRC_STATE_CELL_DCH &&
                current_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH) &&
               (!((rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i].cmd.setup.req_mask &
                   (CPHY_SEC_DL_PHYCHAN_DROP_INCL /*| CPHY_UL_PHYCHAN_DROP_INCL*/)) &&
                  ((rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i].cmd.setup.sec_drop_dl_phychan ==
                    L1_DL_PHYCHAN_SEC_FDPCH)
                   ))))
      {
        WRRC_MSG1_HIGH("DC_HSUPA:  DC HSUPA Action Stop:  Looking for FDPCH drop - not found - go to next idx %d",i);
        /* Looking for cmd that contains DPCH DROP  as well */
        continue;
      }

      /* Fill up the Uplink data here */
      l1_cmd_ptr = &rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i];

      if (ordered_config_ptr->l1_sec_e_req_mask & (L1_EUL_START |L1_EUL_RECFG_DL|L1_EUL_STOP))
      {
        l1_cmd_ptr->cmd.setup.req_mask |= CPHY_SEC_EUL_DL_CFG_INCL;
      }
      if (ordered_config_ptr->l1_sec_e_req_mask & (L1_EUL_START |L1_EUL_RECFG_UL|L1_EUL_STOP))
      {
        l1_cmd_ptr->cmd.setup.req_mask |= CPHY_SEC_EUL_UL_CFG_INCL;
      }

      l1_cmd_ptr->cmd.setup.sec_e_info_ptr =
        &ordered_config_ptr->l1_sec_e_info;

      l1_cmd_ptr->cmd.setup.sec_e_req_mask =
        ordered_config_ptr->l1_sec_e_req_mask;

      WRRC_MSG1_HIGH("DC_HSUPA: Setting uplink L1 actions req_mask%d ",l1_cmd_ptr->cmd.setup.req_mask);

      /*we need to send START+STOP for uplink mask also if its set for edch mask*/

      if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sec_eul_aset_update)
      {
        /* for active set update procedure even if EUL is set to start+stop we need to set uplink mask as reconfig  this is because
                  for active set update dl will not be dropped */
        if((ordered_config_ptr->l1_sec_e_req_mask & L1_EUL_START)&&(ordered_config_ptr->l1_sec_e_req_mask & L1_EUL_STOP) )
        {
          l1_cmd_ptr->cmd.setup.req_mask |= CPHY_SEC_UL_PHYCHAN_CFG_INCL;
        }
        else if (ordered_config_ptr->l1_sec_e_req_mask & L1_EUL_RECFG_UL)
        {
          l1_cmd_ptr->cmd.setup.req_mask |= CPHY_SEC_UL_PHYCHAN_CFG_INCL;
        }
        else if(ordered_config_ptr->l1_sec_e_req_mask & L1_EUL_START)
        {
          l1_cmd_ptr->cmd.setup.req_mask |= CPHY_SEC_UL_PHYCHAN_ADD_INCL;
        }
        else if (ordered_config_ptr->l1_sec_e_req_mask & L1_EUL_STOP)
        {
          l1_cmd_ptr->cmd.setup.req_mask |= CPHY_SEC_UL_PHYCHAN_DROP_INCL;
        }
      }
      else
      {
        
        if(ordered_config_ptr->l1_sec_e_req_mask & L1_EUL_START)
        {
          l1_cmd_ptr->cmd.setup.req_mask |= CPHY_SEC_UL_PHYCHAN_ADD_INCL;
        }
        else if (ordered_config_ptr->l1_sec_e_req_mask & L1_EUL_RECFG_UL)
        {
          l1_cmd_ptr->cmd.setup.req_mask |= CPHY_SEC_UL_PHYCHAN_CFG_INCL;
        }

        if (ordered_config_ptr->l1_sec_e_req_mask & L1_EUL_STOP)
        {
          l1_cmd_ptr->cmd.setup.req_mask |= CPHY_SEC_UL_PHYCHAN_DROP_INCL;
        }
      }
      
/*  check if this required */
      l1_cmd_ptr->cmd.setup.mac_e_reset_indicator =
        ordered_config_ptr->mac_e_reset_indicator;
      break;
    }
  }
#endif /* FEATURE_WCDMA_DC_HSUPA */
#ifdef FEATURE_WCDMA_HS_RACH
/*No condition is needed here. Will remove this condition*/
  if(1)
  {
    /* Fist clear off the L1 eul flags from cmd under process */ 
    for(i = 0;
        (i < LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD) &&
        (i <= rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req);
         i ++
        )
    {
      l1_cmd_ptr = &rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i];
      l1_cmd_ptr->cmd.setup.hs_rach_req_mask = 0;
      //l1_cmd_ptr->cmd.setup.hs_rach_e_info_ptr->mac_hsrach_e_reset_indicator = 0;
    }

    /*HS_RACH: NEED TO ADD FOR CCM*/
    if ((((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RCE) ||
          (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RBE) ||
          (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RBRC) ||
          (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RBR) ||
          (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_TCR) ||
          (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_PCR) ||
          (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CU) ||
          (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RCR) ||
          (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CHO) ||
          (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_LBT) ||
          (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_IHO) ||
          ((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_UMI) &&
          (rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_HS_FACH_DEDICATED_OPS))||
          ((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP) &&
          (rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_RECONFIG_PCH_FACH))||
          ((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CCM) &&
          (TRUE == rrchsrach_get_ready_for_common_edch(ordered_config_ptr))) /* CAN CCM sends HS RACH STOP ?*/
          || ((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)
          && (rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
          ))) &&
          ((ordered_config_ptr->l1_hs_rach_req_mask != L1_HS_RACH_NO_OP) ||
           (TRUE == rrchsrach_get_ready_for_common_edch(ordered_config_ptr))))
    {
      for(i = 0;
          (i < LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD) &&
          (i <= rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req);
           i ++
          )
      {
        if ((i == rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req)
            && (ordered_config_ptr->l1_hs_rach_req_mask != L1_HS_RACH_NO_OP))
        {
          ERR_FATAL("RRCHSRACH:No PRACH found!!! This shouldn't happen :(",0,0,0);
        }

        /* Fill up the Uplink data here */
        l1_cmd_ptr = &rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i];
        if(!((l1_cmd_ptr->cmd.setup.ul_phychan == L1_UL_PHYCHAN_PRACH) ||
              (l1_cmd_ptr->cmd.setup.drop_ul_phychan == L1_UL_PHYCHAN_PRACH)))
        {
          WRRC_MSG0_HIGH("RRCHSRACH: Should be same cphy setup as PRACH cfg");
          continue;
        }
        /*Setting L1 HS-RACH mask*/
        if (ordered_config_ptr->l1_hs_rach_req_mask & (L1_HS_RACH_START |L1_HS_RACH_RECFG|L1_HS_RACH_STOP))
        {
          l1_cmd_ptr->cmd.setup.req_mask |= CPHY_HS_RACH_CHAN_CFG_INCL;
        }

        l1_cmd_ptr->cmd.setup.hs_rach_e_info_ptr =
            &ordered_config_ptr->l1_hs_rach_e_info;

        /*right now this is the only place available later can change it*/
        if ((ordered_config_ptr->l1_hs_rach_req_mask == L1_HS_RACH_STOP) && (!ordered_config_ptr->transition_to_dch))
        {
          ordered_config_ptr->mac_hsrach_e_reset_indicator = TRUE;
        }

        l1_cmd_ptr->cmd.setup.hs_rach_e_info_ptr->mac_hsrach_e_reset_indicator =
           ordered_config_ptr->mac_hsrach_e_reset_indicator;

        l1_cmd_ptr->cmd.setup.common_e_dch_resource_list =
            &ordered_config_ptr->common_e_dch_resource_list;

        l1_cmd_ptr->cmd.setup.transition_to_dch = ordered_config_ptr->transition_to_dch;

        WRRC_MSG1_MED("RRCHSRACH: Including HSRACH pointer HS RACH req mask 0x%x ",l1_cmd_ptr->cmd.setup.req_mask);

        l1_cmd_ptr->cmd.setup.hs_rach_req_mask =
        ordered_config_ptr->l1_hs_rach_req_mask;
        break;
      }
    }
  }

#endif

  /* Fist clear off the L1 CPC DTX flags from cmd under process */ 
  for(i = 0;
       (i < LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD) &&
       (i <= rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req);
       i ++
         )
  {
    l1_cmd_ptr = &rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i];
    l1_cmd_ptr->cmd.setup.l1_cpc_dtx_req_mask = 0;
    l1_cmd_ptr->cmd.setup.l1_cpc_drx_req_mask = 0;
  }

  /*  Construct CPC-DTX commands only if the procedure is capable of 
      doing DTX operation related actions */
  if (((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RCE) ||
       (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RBE) ||
       (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RBRC) ||
       (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RBR) ||
       (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_TCR) ||
       (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_PCR) ||
       (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CU) ||
       (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_ASU) ||
       (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RCR)||
       (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CHO) ||
       (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_IHO)
#ifdef FEATURE_DUAL_SIM
       || ((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)
          && (rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
          &&(curr_scan == RRC_CSP_UNLOCK_BY_SCAN))
#endif
      )
      && ((ordered_config_ptr->l1_cpc_dtx_req_mask != L1_CPC_DTX_NO_OP)
        || (ordered_config_ptr->l1_cpc_drx_req_mask != L1_CPC_DRX_NO_OP)
         ))
  {
    /* Now look for L1 command  */
    for(i = 0;
         (i < LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD) &&
         (i <= rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req);
         i ++
           )
    {
      if (i == rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req)
      {
        ERR_FATAL("RRCCPC:No DPCH found!!! This shouldn't happen :(",0,0,0);
      }
      /* If CPC-DTX/DRX action is a start and Non-DCH -> DCH transition is occuring, make sure
         that CPC-DTX/DRX start goes with DPCH ADD cmd to L1*/
      else if (((ordered_config_ptr->l1_cpc_dtx_req_mask == L1_CPC_DTX_START)
               || (ordered_config_ptr->l1_cpc_drx_req_mask == L1_CPC_DRX_START)
               ) &&
                (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_DCH &&
                 current_config_ptr->rrc_state_indicator != RRC_STATE_CELL_DCH)&&
                (!((rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i].cmd.setup.req_mask &
                 (CPHY_DL_PHYCHAN_ADD_INCL | CPHY_UL_PHYCHAN_ADD_INCL)) &&
                 (
                 (rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i].cmd.setup.dl_phychan ==
                  L1_DL_PHYCHAN_FDPCH)||
                (rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i].cmd.setup.ul_phychan ==
                   L1_UL_PHYCHAN_DPCH)))))
      {
        WRRC_MSG1_HIGH("RRCCPC: CPC-DTX Action Start:  Looking for DPCH Add - not found - go to next idx %d",i);
          /* Looking for cmd that contains DPCH setup as well */
        continue;
      }
      /* if CPC-DTX/DRX Action is drop and DCH->NON-DCH transition is occuring, make sure CPC-DTX/DRX stop
         goes with DPCH drop cmd to L1*/
      else if (((ordered_config_ptr->l1_cpc_dtx_req_mask == L1_CPC_DTX_STOP)
               || (ordered_config_ptr->l1_cpc_drx_req_mask == L1_CPC_DRX_STOP)
               ) &&
               (rrcllc_cmd_under_process.next_rrc_state != RRC_STATE_CELL_DCH &&
                current_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH) &&
               (!((rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i].cmd.setup.req_mask &
                   (CPHY_DL_PHYCHAN_DROP_INCL | CPHY_UL_PHYCHAN_DROP_INCL)) &&
                  ((rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i].cmd.setup.drop_dl_phychan ==
                    L1_DL_PHYCHAN_DPCH) ||
                   (rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i].cmd.setup.drop_dl_phychan ==
                    L1_DL_PHYCHAN_FDPCH) ||
                   (rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i].cmd.setup.drop_ul_phychan ==
                    L1_UL_PHYCHAN_DPCH)))))
      {
        WRRC_MSG1_HIGH("RRCCPC: CPC-DTX Action Stop:  Looking for DPCH drop - not found - go to next idx %d",i);
        /* Looking for cmd that contains DPCH setup as well */
        continue;
      }
      /*Need any check..here...?*/
      
      /* Fill up the Uplink data here */
      l1_cmd_ptr = &rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i];

      if (ordered_config_ptr->l1_cpc_dtx_req_mask & (L1_CPC_DTX_START |L1_CPC_DTX_RECONFIG|L1_CPC_DTX_STOP))
      {
        l1_cmd_ptr->cmd.setup.req_mask |= CPHY_CPC_DTX_CHAN_CFG_INCL;
        /*Since there can't be any DRX operation with out DTX, so include DRX info only if DTX info is included*/
        if (ordered_config_ptr->l1_cpc_drx_req_mask & (L1_CPC_DRX_START |L1_CPC_DRX_RECONFIG|L1_CPC_DRX_STOP))
        {
          l1_cmd_ptr->cmd.setup.req_mask |= CPHY_CPC_DRX_CHAN_CFG_INCL;
        }
      }

      l1_cmd_ptr->cmd.setup.l1_cpc_dtx_req_mask = 
           ordered_config_ptr->l1_cpc_dtx_req_mask;

      l1_cmd_ptr->cmd.setup.dtx_drx_info.dtx_drx_timing_info =
        &ordered_config_ptr->dtx_drx_timing_info;

      l1_cmd_ptr->cmd.setup.dtx_drx_info.dtx_info =
       &ordered_config_ptr->dtx_info;

      l1_cmd_ptr->cmd.setup.l1_cpc_drx_req_mask =
        ordered_config_ptr->l1_cpc_drx_req_mask;

      l1_cmd_ptr->cmd.setup.dtx_drx_info.drx_info =
        &ordered_config_ptr->drx_info;
      WRRC_MSG2_HIGH("RRCCPC: Setting setup.req_mask to include CPC_DTX-cfg 0x%x l1_cpc_dtx_req_mask 0x%x[0=NOOP,1=S,2=R,4=Stop]",
         l1_cmd_ptr->cmd.setup.req_mask,ordered_config_ptr->l1_cpc_dtx_req_mask);

      if (ordered_config_ptr->l1_cpc_drx_req_mask & (L1_CPC_DRX_START |L1_CPC_DRX_RECONFIG|L1_CPC_DRX_STOP))
      {
        WRRC_MSG2_HIGH("RRCCPC:  Setting setup.req_mask to include CPC_DRX-cfg 0x%x l1_cpc_drx_req_mask 0x%x[0=NOOP,1=S,2=R,4=Stop]",
          l1_cmd_ptr->cmd.setup.req_mask,ordered_config_ptr->l1_cpc_drx_req_mask);
      }

      break;
    }
  }
  if(((ordered_config_ptr->cpc_dtx_drx_status == TRUE)||
    (current_config_ptr->cpc_dtx_drx_status == TRUE))&&
    (l1_cmd_ptr != NULL))
  {
    WRRC_MSG2_HIGH("RRCCPC:HS_scch_order_action OC=%d,CC=%d[0:B/1:R/2:B&D/3:Init]", 
      ordered_config_ptr->l1_hs_scch_order_action, 
      current_config_ptr->l1_hs_scch_order_action);

    l1_cmd_ptr->cmd.setup.l1_hs_scch_order_action =
       ordered_config_ptr->l1_hs_scch_order_action;
      
  }


  return(SUCCESS);
} /* rrcllc_add_uplink_phy_chan_to_l1_cmd */

/*===========================================================================
FUNCTION   rrcllc_check_ps_zero_zero_status
DESCRIPTION
  This function determines the active call types [Voice, PS data, HS] and 
  sets call_type_mask bitmask appropriately.
DEPENDENCIES
  None.
RETURN VALUE
SIDE EFFECTS
  None.
===========================================================================*/
boolean rrcllc_check_ps_zero_zero_status(void)
{
  boolean ps_zero_zero_status = FALSE; // default FET is disabled
  rrc_ps_data_rate_e_type rbe_status = rrcrbe_is_dl_ps_zero_zero_size_configured_for_all_rabs();
  rrc_ps_data_rate_e_type est_status = rrc_is_dl_ps_zero_tb_size_configured_for_all_rabs();
  rrc_ps_data_rate_e_type iho_status = rrciho_is_dl_ps_zero_zero_size_configured_for_all_rabs();
  MSG_HIGH("FET:rbe_status: %d,est_status:%d,iho_status:%d",rbe_status,est_status,iho_status);
  if( RRC_STATE_CELL_DCH == rrcllc_cmd_under_process.next_rrc_state) 
  {
   // Enable FET only if all active RABs are zero configured
    if( 
           (rbe_status == RRC_PS_DATA_RATE_RAB_NOT_CONFIGURED) &&
           (est_status == RRC_PS_DATA_RATE_RAB_NOT_CONFIGURED) &&
           (iho_status == RRC_PS_DATA_RATE_RAB_NOT_CONFIGURED)
        )
     {
       //Make sure FET is disable if not even one RAB is not configured
       return ps_zero_zero_status;
     }
    if( 
        ( ((rbe_status != RRC_PS_DATA_RATE_NON_ZERO_CONFIGURED)) &&
          ((est_status != RRC_PS_DATA_RATE_NON_ZERO_CONFIGURED)) &&
          ((iho_status != RRC_PS_DATA_RATE_NON_ZERO_CONFIGURED))
        )
     )
    {
      // Enable FET only if all ACTIVE RABs are configured as zero
      ps_zero_zero_status = TRUE;
    }
  }
  return ps_zero_zero_status;
}
/*===========================================================================
FUNCTION   rrcllc_set_call_type_mask

DESCRIPTION
  This function determines the active call types [Voice, PS data, HS] and 
  sets call_type_mask bitmask appropriately.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static void rrcllc_set_call_type_mask(void)
{
  mac_rab_status_e_type rab_status;
  int32 cnt = 0;
  ordered_config_type *config_ptr = NULL;
  rab_status = rrc_query_mac_rab_status();

  if (config_ptr_in_use == ORDERED_CONFIG)
  {
    config_ptr = ordered_config_ptr;
  }
  else
  {
    config_ptr = current_config_ptr;
  }

  config_ptr->call_type_mask = 0;
  for (cnt=0; cnt < rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req; cnt++)
  {
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[cnt].cmd.setup.is_mrab_ps_present = FALSE;
  }
  switch (rab_status)
  {
    case CS_RABS: 
      {
         WRRC_MSG0_HIGH("RRCRB_CS_VOICE_RAB for CS domain");         
         config_ptr->call_type_mask = CPHY_VOICE_CALL_ACTIVE; 
         if (TRUE == rrc_query_cs_data_status())
         {
           WRRC_MSG0_HIGH("RRCRB_CS_DATA_RAB for CS domain");         
           /*For L1, CS DATA is always with CS VOICE*/
           config_ptr->call_type_mask |= CPHY_CS_DATA_CALL_ACTIVE;
         }
      }
      break;

    case PS_RABS:
      config_ptr->call_type_mask = CPHY_R99_PS_CALL_ACTIVE; 
      break;

    case CS_PLUS_PS_RABS:
    {
      config_ptr->call_type_mask = CPHY_R99_PS_CALL_ACTIVE;
      if (TRUE == rrc_query_cs_data_status())
      {
        WRRC_MSG0_HIGH("RRCRB_CS_DATA_RAB for CS domain");         
        /*For L1, CS DATA is always with CS VOICE*/
        config_ptr->call_type_mask |= CPHY_CS_DATA_CALL_ACTIVE;
      }
      else
      {
       config_ptr->call_type_mask |= CPHY_VOICE_CALL_ACTIVE;  
      }
      if((FALSE == rrc_query_cs_data_status()) && TRUE == rrcllc_check_ps_zero_zero_status())
      {
         WRRC_MSG0_HIGH("RRCRB_AMR with PS_0x0 configured");		   
         /*For L1, CS DATA is always with CS VOICE*/
         config_ptr->call_type_mask = CPHY_CS_PS_0X0_ACTIVE;
      }
    }
      break;

    default:
      WRRC_MSG0_MED("Ignore.  No cs nor PS rabs ");
      break;
  }


  if (HSDPA_ACTIVE == rrc_get_hsdpa_status()) 
  {
    if(!rrcllc_cmd_under_process.chan_config.hsdpa_active_to_inactive)
    {
      config_ptr->call_type_mask |= CPHY_HS_CALL_ACTIVE; 
    }
  }
  else
  {
    if(rrcllc_cmd_under_process.chan_config.hsdpa_inactive_to_active)
    {
      config_ptr->call_type_mask |= CPHY_HS_CALL_ACTIVE; 
    }
  }

#ifdef FEATURE_WCDMA_HS_FACH
  if((rrcllc_get_hs_status_in_e_fach(config_ptr)) && (HSDPA_STOP != rrcllc_get_hs_action_in_e_fach(config_ptr)))
  {
    config_ptr->call_type_mask |= CPHY_HS_CALL_ACTIVE;  
  }
#endif /*FEATURE_WCDMA_HS_FACH*/

  for (cnt=0; cnt < rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req; cnt++)
  {
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[cnt].cmd.setup.call_type_mask = config_ptr->call_type_mask;

#ifdef FEATURE_WCDMA_MTPL_THERMAL_BACKOFF 		
    if((rrcrce_get_rrc_est_cause() == RRC_EST_EMERGENCY_CALL) && (config_ptr->call_type_mask & CPHY_VOICE_CALL_ACTIVE))	
    {
      rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[cnt].cmd.setup.is_emergency_call = TRUE;
      WRRC_MSG1_HIGH("CphySetup emergency call set %d ",rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[cnt].cmd.setup.is_emergency_call);
    }
#endif		
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[cnt].cmd.setup.l1_rrc_config_rab = rrc_l1_query_psrab_data_64_64_is_present();			
    if ((rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_FACH) || (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_DCH))
    {
      if (TRUE == rrc_rbe_get_ps_mrabs())
      {
        rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[cnt].cmd.setup.is_mrab_ps_present = TRUE;
        WRRC_MSG1_HIGH("is_mrab_ps_present:%d",rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[cnt].cmd.setup.is_mrab_ps_present);
      }
    }
  }
  WRRC_MSG1_HIGH("active call types: %0x",config_ptr->call_type_mask);
}

/*===========================================================================
FUNCTION   rrcllc_swap_ctch_pch_drop

DESCRIPTION
 This function swaps the order of sending two Cphy setup request commands if the first command has a SCCPCH0
 drop and add included, the next command has SCCPCH1 drop included and the current command in process
 is not Cell Reselection request.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static void  rrcllc_swap_ctch_pch_drop(void)
{
  l1_ext_cmd_type *curr_l1_cmd_ptr;
  l1_ext_cmd_type *prev_l1_cmd_ptr;
  l1_ext_cmd_type temp_l1_cmd_ptr;
  int32  l1_req_index;

  for( l1_req_index = 1;
      (l1_req_index < LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD) &&
      (l1_req_index < rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req);
      l1_req_index ++
      )
  {
/* If current command has CTCH drop, previous command has SCCPCH drop and add and this is not 
reselection scenario, then swap the two CPhy setup req commands
*/
    curr_l1_cmd_ptr = &rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index];
    prev_l1_cmd_ptr = &rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index - 1];
    if(((curr_l1_cmd_ptr->cmd.setup.req_mask & CPHY_DL_PHYCHAN_DROP_INCL) &&
        (curr_l1_cmd_ptr->cmd.setup.drop_dl_phychan   == L1_DL_PHYCHAN_SCCPCH1)) &&
       ((prev_l1_cmd_ptr->cmd.setup.req_mask & CPHY_DL_PHYCHAN_ADD_INCL) &&
        (prev_l1_cmd_ptr->cmd.setup.dl_phychan  == L1_DL_PHYCHAN_SCCPCH0))&&
       ((prev_l1_cmd_ptr->cmd.setup.req_mask & CPHY_DL_PHYCHAN_DROP_INCL) &&
        (prev_l1_cmd_ptr->cmd.setup.drop_dl_phychan  == L1_DL_PHYCHAN_SCCPCH0)) &&
       (rrcllc_cmd_under_process.rrc_current_cmd_id != RRC_CELL_RESELECTION_REQ)
       )
    {
      temp_l1_cmd_ptr = *curr_l1_cmd_ptr;
      *curr_l1_cmd_ptr = *prev_l1_cmd_ptr;
      *prev_l1_cmd_ptr = temp_l1_cmd_ptr;
       WRRC_MSG0_HIGH("2 BTFD channels up. Swap CPhy setup reqs");
       break;
    }
  }
}
#ifdef FEATURE_WCDMA_HS_FACH
/*===========================================================================
FUNCTION   rrcllc_swap_ctch_pch_drop_for_efach

DESCRIPTION
 This function swaps the order of sending two Cphy setup request commands if the first command has a SCCPCH0
 drop and HS-FACH setup included, the next command has SCCPCH1 drop included and the current command in process
 is not Cell Reselection request.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static void  rrcllc_swap_ctch_pch_drop_for_efach(void)
{
  l1_ext_cmd_type *curr_l1_cmd_ptr;
  l1_ext_cmd_type *prev_l1_cmd_ptr;
  l1_ext_cmd_type temp_l1_cmd_ptr;
  int32  l1_req_index;
  ordered_config_type * config_ptr = rrcllc_get_config_ptr_in_use();
  boolean hs_status = rrcllc_get_hs_status_in_e_fach(config_ptr);
  rrc_state_e_type current_rrc_state = rrc_get_state();


  if((rrcllc_cmd_under_process.chan_config.current_cmd_engine == LLC_CHAN_CONFIG_ENGINE) &&
      (((current_rrc_state == RRC_STATE_DISCONNECTED) && (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CONNECTING))||
       (((current_rrc_state == RRC_STATE_CELL_PCH) || (current_rrc_state == RRC_STATE_URA_PCH)) && (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_FACH)))
    )
  {
    
    for( l1_req_index = 1;
        (l1_req_index < LLC_MAX_L1_CMDS_PER_RRC_INTERN_CMD) &&
        (l1_req_index < rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req);
        l1_req_index ++
        )
    {
  /* If current command has CTCH drop, previous command has SCCPCH drop and add and this is not 
  reselection scenario, then swap the two CPhy setup req commands. For reselection scenario we never send two cphy setup requests
  */

      curr_l1_cmd_ptr = &rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index];
      prev_l1_cmd_ptr = &rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[l1_req_index - 1];

      WRRC_MSG6_HIGH("curr req mask 0x%x, prev req mask 0x%x cur dl drop %d, prev dl drop %d, cmd_id 0x%x, hs_status %d", curr_l1_cmd_ptr->cmd.setup.req_mask, prev_l1_cmd_ptr->cmd.setup.req_mask
         , curr_l1_cmd_ptr->cmd.setup.drop_dl_phychan, prev_l1_cmd_ptr->cmd.setup.drop_dl_phychan, rrcllc_cmd_under_process.rrc_current_cmd_id, hs_status);
      
      if(((curr_l1_cmd_ptr->cmd.setup.req_mask & CPHY_DL_PHYCHAN_DROP_INCL) &&
          (curr_l1_cmd_ptr->cmd.setup.drop_dl_phychan   == L1_DL_PHYCHAN_SCCPCH1)) &&
         ((prev_l1_cmd_ptr->cmd.setup.req_mask & CPHY_HS_CHAN_CFG_INCL) &&
          (TRUE == hs_status))&&
         ((prev_l1_cmd_ptr->cmd.setup.req_mask & CPHY_DL_PHYCHAN_DROP_INCL) &&
          (prev_l1_cmd_ptr->cmd.setup.drop_dl_phychan  == L1_DL_PHYCHAN_SCCPCH0)) &&
         (rrcllc_cmd_under_process.rrc_current_cmd_id != RRC_CELL_RESELECTION_REQ)
         )
      {
        temp_l1_cmd_ptr = *curr_l1_cmd_ptr;
        *curr_l1_cmd_ptr = *prev_l1_cmd_ptr;
        *prev_l1_cmd_ptr = temp_l1_cmd_ptr;
         WRRC_MSG0_HIGH("EFACH Swap CPhy setup reqs as WL1 prefer CTCH SCCPCH drop before HS-FACH channels setup ");
         break;
      }
    }
  }
}
#endif
/*===========================================================================
FUNCTION   rrcllc_construct_and_store_l1_cmds

DESCRIPTION
  This function analyzes data in rrc_cmd_under_process and validates
  operations on uplink and downlink physical channels.
  It then calls rrcllc_add_downlink_phy_chan_to_l1_cmd() and
  rrcllc_add_uplink_phy_chan_to_l1_cmd() to form CPHY_SETUP_REQ
  commands for L1.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static uecomdef_status_e_type  rrcllc_construct_and_store_l1_cmds(void)
{
  uint8 cnt = 0;
  hsdpa_setup_ops_enum_type local_hs_action = HSDPA_SETUP_OPS_NOOP;
#ifdef FEATURE_WCDMA_HS_FACH
  ordered_config_type *config_ptr;

  if(config_ptr_in_use == ORDERED_CONFIG)
  {
    config_ptr = ordered_config_ptr;
  }
  else
  {
    config_ptr = current_config_ptr;
  }
#endif
  /* First initialize number of L1 commands in rrcllc_cmd_under_process */
  rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req = 0;
  /* First decide what goes in the L1 command */

  if((rrcllc_cmd_under_process.chan_config.solo_bch_operation))
  {
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd_hdr.act_time
                                               = 0;
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd_hdr.act_time_type
                                               = L1_ACTIVATION_TIME_NONE;
  }
  else
  {
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd_hdr.act_time
                                               = ordered_config_ptr->activation_time;
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd_hdr.act_time_type
                                               = ordered_config_ptr->act_time_type;
  }

  rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd_hdr.cmd_id
                                             = CPHY_SETUP_REQ;
  /* First Decide what goes in the L1 commands - this will be based on
   * the contents of chan_config.phy_chan_action_list in rrcllc_cmd_under_process
   */

  /* The following rules apply when deciding what is the sequence of Physical channel
   * setup/release/reconfig going to L1 in CPHY_SETUP_REQ:
   *  1. In Downlink, out of PCCPCH and DPCH, one of them has to be there for L1 to
   *     derive timing. If one of them is being released, make sure the other is setup
   *     first. This condition would not hold true when going from Connected mode
   *     to Idle Disconnected. In that case, all channels are released.
   *  2. If a DPCH is to be acted on in uplink, it is sent in the same CPHY_SETUP_REQ
   *     as the downlink DPCH (with same action on it).
   *  3. Between DPCH and PRACH,only one can be active at any time.
   *  4. Between DPCH and PCCPCH, only one can be active at any time.
   */
  if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
  {
    WRRC_MSG2_MED("DLdpchAct %d, ULdpchAct %d", rrcllc_cmd_under_process.
             chan_config.phy_chan_action_list.dl_dpch_action, rrcllc_cmd_under_process.
             chan_config.phy_chan_action_list.ul_dpch_action);
  }
  /* Validate chan_config.phy_chan_action_list in rrcllc_cmd_under_process */
  if((rrcllc_cmd_under_process.
          chan_config.phy_chan_action_list.dl_dpch_action == LLC_PHYCHAN_SETUP) ||
     (rrcllc_cmd_under_process.
          chan_config.phy_chan_action_list.dl_dpch_action == LLC_PHYCHAN_RECONFIG))
  {
     if((rrcllc_cmd_under_process.
          chan_config.phy_chan_action_list.prach_action == LLC_PHYCHAN_SETUP) ||
        (rrcllc_cmd_under_process.
          chan_config.phy_chan_action_list.prach_action == LLC_PHYCHAN_RECONFIG))
     {
       WRRC_MSG0_ERROR("Invalid actions: both DPCH and RACH active");
       return(FAILURE);
     }

     if((rrcllc_cmd_under_process.
          chan_config.phy_chan_action_list.sccpch_action == LLC_PHYCHAN_SETUP) ||
        (rrcllc_cmd_under_process.
          chan_config.phy_chan_action_list.sccpch_action == LLC_PHYCHAN_RECONFIG))
     {
       WRRC_MSG0_ERROR("Invalid actions: both DPCH and SCCPCH active");
       return(FAILURE);
     }
  }
  else if(rrcllc_cmd_under_process.
          chan_config.phy_chan_action_list.dl_dpch_action == LLC_PHYCHAN_RELEASE)
  {
    if(rrcllc_cmd_under_process.
          chan_config.phy_chan_action_list.prach_action == LLC_PHYCHAN_RELEASE)
    {
       WRRC_MSG0_ERROR("Invalid: Both DPCH and PRACH released");
       return(FAILURE);
    }
    else if(rrcllc_cmd_under_process.
          chan_config.phy_chan_action_list.sccpch_action == LLC_PHYCHAN_RELEASE)
    {
       WRRC_MSG0_ERROR("Invalid: Both DPCH and SCCPCH released");
       return(FAILURE);
    }
  } /* Validate chan_config.phy_chan_action_list in rrcllc_cmd_under_process */

  /* At this point, the physical channel actions have been validated */
  /* The physical channel actions in rrcllc_cmd_under_process are valid. */
  /* The actions in Downlink drive the sequence */

  /* Update the status of physical channels in semi=permanent data based on
   * the action on channels as in command under process data.
   */
  rrcllc_update_semi_permanent_phychan_status();


  (void)rrcllc_add_downlink_phy_chan_to_l1_cmd();
  (void)rrcllc_add_uplink_phy_chan_to_l1_cmd();

    if (rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_for_ctch_action
        != LLC_PHYCHAN_NO_OP)
    {
      /* build second L1 command to setup second sccpch with ctch */
      (void)rrcllc_add_sccpch_with_ctch_to_l1_cmd();
      rrcllc_swap_ctch_pch_drop();
    }

  if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
  {
    if (rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req == 0)
    {
      return SUCCESS;
    }
    
    local_hs_action = rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].
      cmd.setup.hsdpa_l1_ops;
    
#ifdef FEATURE_WCDMA_HS_FACH
    if ((rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req == 0) && 
        (local_hs_action != HSDPA_SETUP_OPS_NOOP) && 
        (rrcenhstate_camped_cell_supports_e_fach() == TRUE) &&
        (rrc_get_state()== RRC_STATE_CELL_FACH)
       )
    {
      WRRC_MSG0_HIGH("HSFACH: Constructing cphy cmd for Enh-FACH");
      rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req++;
    }
#endif /*FEATURE_WCDMA_HS_FACH*/

    WRRC_MSG2_MED("Local HSAction %d, Num l1 req %d", local_hs_action,
             rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req);
    
    if ((rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req == 1) &&
        (rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].
         cmd.setup.hsdpa_l1_ops != HSDPA_SETUP_OPS_NOOP))
    {
      WRRC_MSG0_MED("Setting HSDPA Req mask");
      rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].
        cmd.setup.req_mask |= CPHY_HS_CHAN_CFG_INCL;
   
#ifdef FEATURE_WCDMA_HS_FACH
      if(rrcllc_get_hs_status_in_e_fach(config_ptr) == TRUE)
      {
#ifdef FEATURE_WCDMA_HS_RACH
        if ((rrchsrach_camped_cell_supports_hsrach() == TRUE) && (ordered_config_ptr->ack_nack_support_on_hs_dpcch))
        {
  			rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[cnt].cmd.
                  setup.hsdpa_l1_info->hs_req_mask |=  CPHY_HS_DPCCH_CFG_INCL;
        
            WRRC_MSG1_HIGH("RRCHSRACH: hs_req_mask 0x%x",rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[cnt].cmd.
                  setup.hsdpa_l1_info->hs_req_mask);
        }
#endif
#ifdef FEATURE_WCDMA_HS_FACH_DRX
        if(rrcenhstate_get_e_fach_drx_status(rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[cnt].cmd.
                setup.hsdpa_l1_info))
        {
          rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[cnt].cmd.
              setup.hsdpa_l1_info->hs_req_mask |= CPHY_HS_E_FACH_DRX_CFG_ALL_INCL;
          rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[cnt].cmd.
              setup.hsdpa_l1_info->efach_drx_info.dhrnti = rrcllc_cmd_under_process.
              chan_config.l1_req_list.l1_req[cnt].cmd.setup.hsdpa_l1_info->hs_dsch_info.h_rnti;

        }
        else
#endif
        {
          rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[cnt].cmd.
                setup.hsdpa_l1_info->hs_req_mask |= CPHY_HS_E_FACH_CFG_ALL_INCL;
        }
      }
#endif /*FEATURE_WCDMA_HS_FACH*/
  
    }
    else
    {
      if ( (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_DCH &&
            rrc_get_state() == RRC_STATE_CELL_FACH )||
           (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_DCH &&
            rrc_get_state() == RRC_STATE_CONNECTING ) )
      {  
        WRRC_MSG0_MED("FACHTODCH in progress");
        
        for (cnt=0; cnt < rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req; cnt++)
        {
          if ((local_hs_action == HSDPA_SETUP_OPS_START)
#ifdef FEATURE_WCDMA_HS_FACH
            ||(local_hs_action == HSDPA_SETUP_OPS_RECFG)|| (local_hs_action == HSDPA_SETUP_OPS_STOP)
#endif
             )
          {
            /* Check if Uplink as well as Dl DPCH action is ADD. Need for FACH to HS scenario */
            if ((rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[cnt].cmd.setup.req_mask 
                 & CPHY_DL_PHYCHAN_ADD_INCL) &&
              ((rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[cnt].cmd.setup.dl_phychan
               == L1_DL_PHYCHAN_DPCH)
               || (rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[cnt].cmd.setup.dl_phychan
                 == L1_DL_PHYCHAN_FDPCH)
              ) && 
                (rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[cnt].cmd.setup.req_mask 
                 & CPHY_UL_PHYCHAN_ADD_INCL) &&
                (rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[cnt].cmd.setup.ul_phychan
                 == L1_UL_PHYCHAN_DPCH))
            {
              WRRC_MSG1_HIGH("Set HSDPA Reqmask for cmd no %d",cnt+1);
              rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[cnt].
                cmd.setup.req_mask |= CPHY_HS_CHAN_CFG_INCL;
              rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[cnt].
                cmd.setup.hsdpa_l1_ops = local_hs_action;
#ifdef FEATURE_WCDMA_HS_FACH
              if(local_hs_action == HSDPA_SETUP_OPS_STOP)
              {
                rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[cnt].
                 cmd.setup.hsdpa_l1_info = NULL;
              }
              else
#endif
              {
                rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[cnt].
                  cmd.setup.hsdpa_l1_info = &ordered_config_ptr->l1_hsdpa_info;
                
                rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[cnt].cmd.
                  setup.hsdpa_l1_info->hs_req_mask = CPHY_HS_DSCH_CFG_INCL | 
                  CPHY_HS_PDSCH_RL_CFG_INCL | CPHY_HS_SCCH_CFG_INCL | CPHY_HS_DPCCH_CFG_INCL;

#ifdef FEATURE_WCDMA_DC_HSDPA
                if(rrcllcpcie_return_num_sec_hsdpa_carriers(ordered_config_ptr))
                {
                  rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[cnt].cmd.
                     setup.hsdpa_l1_info->hs_req_mask |=CPHY_HS_SEC_HSDPA_CFG_INCL;
                  WRRC_MSG1_HIGH("DC-HSDPA: Added DC-HS mask for cmd no %d",cnt+1);
                }
#endif /*FEATURE_WCDMA_DC_HSDPA*/

#ifdef FEATURE_WCDMA_MIMO
                if(ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action == L1_MIMO_START)
                {
                  rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[cnt].cmd.
                     setup.hsdpa_l1_info->hs_req_mask |=CPHY_HS_MIMO_CFG_INCL;
                  WRRC_MSG1_HIGH("MIMO: Append Mimo bitmask for cmd no %d",cnt+1);
                }
#endif
              }
            }
            else
            {
              WRRC_MSG2_HIGH("Force HSAct NOOP.Req Mask %x,cmd no",
                       rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[cnt].cmd.setup.req_mask,cnt+1);
              
              rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[cnt].
                cmd.setup.hsdpa_l1_ops = HSDPA_SETUP_OPS_NOOP;
              
            }
          }
        }
      }
#ifdef FEATURE_WCDMA_HS_FACH
      else if(rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].
            cmd.setup.hsdpa_l1_ops != HSDPA_SETUP_OPS_NOOP)
      {
        WRRC_MSG0_HIGH("EFACH: Setting HSDPA Req mask");
        rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].
          cmd.setup.req_mask |= CPHY_HS_CHAN_CFG_INCL;
        if ( (local_hs_action == HSDPA_SETUP_OPS_START)
            ||(local_hs_action == HSDPA_SETUP_OPS_RECFG) )
        {
            rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].
              cmd.setup.hsdpa_l1_info = &ordered_config_ptr->l1_hsdpa_info;
            if(rrcllc_get_hs_status_in_e_fach(config_ptr) == TRUE)
            {
            
#ifdef FEATURE_WCDMA_HS_RACH
              if ((rrchsrach_camped_cell_supports_hsrach() == TRUE) && (ordered_config_ptr->ack_nack_support_on_hs_dpcch))
              {
                rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[cnt].cmd.
                      setup.hsdpa_l1_info->hs_req_mask |=  CPHY_HS_DPCCH_CFG_INCL;
            
                WRRC_MSG1_HIGH("RRCHSRACH: hs_req_mask 0x%x",rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[cnt].cmd.
                      setup.hsdpa_l1_info->hs_req_mask);
              }
#endif
#ifdef FEATURE_WCDMA_HS_FACH_DRX
              if(rrcenhstate_get_e_fach_drx_status(rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[cnt].cmd.
                setup.hsdpa_l1_info))
              {
              rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[cnt].cmd.
                    setup.hsdpa_l1_info->hs_req_mask |= CPHY_HS_E_FACH_DRX_CFG_ALL_INCL;
                rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[cnt].cmd.
                    setup.hsdpa_l1_info->efach_drx_info.dhrnti = rrcllc_cmd_under_process.
                    chan_config.l1_req_list.l1_req[cnt].cmd.setup.hsdpa_l1_info->hs_dsch_info.h_rnti;

              }
              else
#endif
              {
                rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[cnt].cmd.
                        setup.hsdpa_l1_info->hs_req_mask |= CPHY_HS_E_FACH_CFG_ALL_INCL;
              }
          }
        }
        else if(local_hs_action == HSDPA_SETUP_OPS_STOP)
        {
          rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[cnt].
             cmd.setup.hsdpa_l1_info = NULL;
        }
      }
#endif/*FEATURE_WCDMA_HS_FACH*/

    }
  }

  /* set the call type mask for L1*/
  rrcllc_set_call_type_mask();
#ifdef FEATURE_WCDMA_HS_FACH
  if (rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_for_ctch_action
      != LLC_PHYCHAN_NO_OP)
  {
    rrcllc_swap_ctch_pch_drop_for_efach();
  }
#endif
  return(SUCCESS);
} /* rrcllc_construct_and_store_l1_cmds */

/*===========================================================================
FUNCTION   rrcllc_get__pccpch_tx_diversity

DESCRIPTION
  This function gives the TxDiversity value for the serving cell.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
boolean rrcllc_get_pccpch_tx_diversity(rrc_state_e_type next_state)
{
  rrc_SysInfoType5 *sib5_ptr = NULL;
  rrc_SysInfoType6 *sib6_ptr = NULL;

  /* scr_code field should always be populated - new DL code expects scr for PCCPCH */
  rrccsp_get_serving_pccpch_parms(&current_config_ptr->l1_dl_chan_parms.pccpch.scr_code,
                                  &current_config_ptr->l1_dl_chan_parms.pccpch.tx_div_ind
                                 );


  sib5_ptr = (rrc_SysInfoType5 *)rrc_sibdb_return_sib_for_srv_cell(
    rrc_SIB5);

  /* If sib5_ptr is null, tx_div can be set to TRUE*/
  if ((rrc_ccm_get_curr_camping_status(RRC_PROCEDURE_LLC) != RRC_CAMPED_ON) ||
      (sib5_ptr == NULL) ||
      (rrc_csp_bplmn_srch_in_progress() == WTOW_SEARCH_RESUME)) 
  {
    /* Get PCCPCH channel parameters from Cell Selection into Ordered Config */
    rrccsp_get_serving_pccpch_parms(&current_config_ptr->l1_dl_chan_parms.pccpch.scr_code,
                                    &current_config_ptr->l1_dl_chan_parms.pccpch.tx_div_ind
                                    );

    WRRC_MSG1_HIGH("Using PCCPCH TxDiv info from L1: %d", 
             current_config_ptr->l1_dl_chan_parms.pccpch.tx_div_ind);
    return current_config_ptr->l1_dl_chan_parms.pccpch.tx_div_ind;
  }

  /* if sib6 indicator is false or if rrc state is idle, look at sib5*/
  if (next_state == RRC_STATE_DISCONNECTED || next_state == RRC_STATE_CONNECTING ||
      sib5_ptr->sib6indicator == FALSE) 
  {
    if((RRC_MSG_COMMON_BITMASK_IE_PTR(sib5_ptr,rrc_SysInfoType5,primaryCCPCH_Info)) &&  
       (RRC_CHECK_COMMON_MSG_TYPE(sib5_ptr->primaryCCPCH_Info, rrc_PrimaryCCPCH_Info_fdd)) &&
       (sib5_ptr->primaryCCPCH_Info.u.fdd->tx_DiversityIndicator))
    {
      WRRC_MSG0_HIGH("Using PCCPCH TxDiv info from sib 5");
      return TRUE;
    }
  }
  else if(sib5_ptr->sib6indicator == TRUE)
  {
    sib6_ptr = (rrc_SysInfoType6 *)rrc_sibdb_return_sib_for_srv_cell(
      rrc_SIB6);
    
    if((sib6_ptr!= NULL) && (RRC_MSG_COMMON_BITMASK_IE_PTR(sib6_ptr,rrc_SysInfoType6,primaryCCPCH_Info)))
    {
      if((RRC_CHECK_COMMON_MSG_TYPE(sib6_ptr->primaryCCPCH_Info, rrc_PrimaryCCPCH_Info_fdd)) &&
         (sib6_ptr->primaryCCPCH_Info.u.fdd->tx_DiversityIndicator))
      {
        WRRC_MSG0_HIGH("Using PCCPCH TxDiv info from sib 6");
        return TRUE;
      }
    }
    else if((RRC_MSG_COMMON_BITMASK_IE_PTR(sib5_ptr,rrc_SysInfoType5,primaryCCPCH_Info)) &&  
            (RRC_CHECK_COMMON_MSG_TYPE(sib5_ptr->primaryCCPCH_Info, rrc_PrimaryCCPCH_Info_fdd)) &&
            (sib5_ptr->primaryCCPCH_Info.u.fdd->tx_DiversityIndicator))
    {
      WRRC_MSG0_HIGH("Using PCCPCH TxDiv info from sib 5");
      return TRUE;
    }
  }

  /* If we fall thru, PCCPCH info is not present in sib or Tx_div is not configured for 
   * PCCPCH. As per 25.211 sec 5.3.1 if Tx diversity is applied on any of the downlink 
   * physical channels it shall also be applied on P-CCPCH.  So check for Tx_div info on 
   * SCCPCH or/and PICH 
   */
  if ((rrcllc_semi_permanent_data.dl_phy_chan.sccpch_is_up && 
       current_config_ptr->l1_dl_chan_parms.sccpch[0].tx_div_ind) 
      ||
      (rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch_is_up && 
       current_config_ptr->l1_dl_chan_parms.sccpch[1].tx_div_ind) 
      )
  {
    WRRC_MSG0_HIGH("Apply TxDiv on PCCPCH as TxDiv applies on SCCPCH"); 
    return TRUE;
  }

  if (current_config_ptr->l1_dl_chan_parms.pich.tx_div_ind) 
  {
    WRRC_MSG0_HIGH("Apply TxDiv on PCCPCH as TxDiv applies on PICH"); 
    return TRUE;
  }
    
  return FALSE;
} /* rrcllc_get_pccpch_tx_diversity */


/*===========================================================================
FUNCTION   rrcllc_chan_config_discon_to_connecting

DESCRIPTION
  This function is resposible for determining all actions on RLC, MAC
  and L1.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static uecomdef_status_e_type
rrcllc_chan_config_discon_to_connecting(rrc_cmd_type *cmd_ptr)
{

  int     i;
  rlc_lc_id_type        rlc_dl_log_chl_id; /* RLC downlink logical channel ID */

  rrc_initialize_rlc_size_change();

  rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;

  WRRC_MSG2_HIGH("Chan_config_discon2conn proc:rrc_proc_e_type_value%d, oc_status:rrcllc_oc_set_status_e_type_value%d",
           rrcllc_cmd_under_process.procedure,rrcllc_get_ordered_config_status_wo_f3());
  /* Update the variables in the ordered_config structure */
  if(rrcllc_update_oc_from_disconnected_to_connecting()
       == FAILURE)
  {
    WRRC_MSG0_ERROR("Failure updating OC, Discon->Connectng");
    return(FAILURE);
  }

#ifdef FEATURE_WCDMA_CSFB_CALL_OPT
  /* In legacy, SBCCH will never be up on entering connecting state 
     With this optimization, SBCCH setup for redirection without SIB container 
     will be dropped here */
  if(
      WCDMA_RRC_IDLE_FEATURES(RRC_CSFB_CALL_TIMELINE_OPT) && 
      rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up && 
      rrc_csfb_call_status
    )
  {
    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action =
               LLC_PHYCHAN_RELEASE;
    if(rrcllc_update_spccpch_params_based_on_action(ordered_config_ptr)==FAILURE)
    {
      return (FAILURE);
    } 
  }
#endif

  /* Now determine if OC has picked an SCCPCH with PCH transport blocks
   * on it.
   */
  rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id
  (
    UE_LOGCHAN_PCCH,
    PCCH_RADIO_BEARER_ID,
    UE_MODE_TRANSPARENT
  );
  if (rlc_dl_log_chl_id != RRCLCM_RLC_LC_ID_NOT_FOUND)
  {
    (void)rrcllc_process_drop_pcch();
  }

  /* drop ctch if it was present */
  rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id
  (
    UE_LOGCHAN_CTCH,
    CTCH_RADIO_BEARER_ID,
    UE_MODE_UNACKNOWLEDGED
  );
  if (rlc_dl_log_chl_id != RRCLCM_RLC_LC_ID_NOT_FOUND)
  {
    (void)rrcllc_process_drop_ctch();
  }

#ifdef FEATURE_WCDMA_HS_FACH
  if(rrcllc_get_hs_status_in_e_fach(ordered_config_ptr) == TRUE)
  {
    (void)rrcenhstate_process_add_ccch();
  }
  else
#endif /*FEATURE_WCDMA_HS_FACH*/
  {
    if(rrcllc_semi_permanent_data.dl_phy_chan.fach_included == FALSE)
    {
      /* This is a wrong selection of SCCPCH that does not have FACH */
      WRRC_MSG0_ERROR("SCCPCH has no FACH included DISC->CONCTNG");
      return(FAILURE);
    }
    else
    {
      /* Add CCCH */
      (void)rrcllc_process_add_ccch();
    }
  }

  /* Initialize Send MAC Uplink Config indicator to TRUE */
  rrcllc_semi_permanent_data.send_mac_uplink_config = TRUE;

  /* Downlink Physical channel processing */

#ifdef FEATURE_WCDMA_HS_FACH
  if(rrcllc_get_hs_status_in_e_fach(ordered_config_ptr) == TRUE)
  {
    if(rrcenhstate_setup_phychan() == FAILURE)
    {
      ERR_FATAL("EFACH:Setting up HS PDSCH failed",0,0,0);
      return FAILURE;
    }
  }
  else
#endif /*FEATURE_WCDMA_HS_FACH*/
  {
    /* Fix the transport channel bitmasks for SCCPCH */
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
      L1_DL_TRCH_REFTYPE_FACH_BF;
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf |=
      L1_DL_TRCH_REFTYPE_FACH_BF;

    if(rrcllc_semi_permanent_data.dl_phy_chan.pch_included)
    {
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
        L1_DL_TRCH_REFTYPE_PCH_BF;
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf &=
        ~L1_DL_TRCH_REFTYPE_PCH_BF;
    }
    else  /* No PCH on this SCCPCH */
    {
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf &=
        ~L1_DL_TRCH_REFTYPE_PCH_BF;
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf &=
        ~L1_DL_TRCH_REFTYPE_PCH_BF;
    }
    /* Downlink Physical channel processing */


#ifdef FEATURE_WCDMA_CSFB_CALL_OPT
    if(
        WCDMA_RRC_IDLE_FEATURES(RRC_CSFB_CALL_TIMELINE_OPT) &&
        (rrcllc_semi_permanent_data.dl_phy_chan.sccpch_is_up == FALSE)
      )
    {
    /* With legacy ,SCCPCH will always be up on entering connecting state
       With this opt, since PICH setup is not done, SCCPCH for FACH is added
       instead of reconfig */
      if(rrcllc_process_add_sccpch() == FAILURE)
      {
        MSG_ERROR ("Couldn't setup SCCPCH",0,0,0);
        return FAILURE;
      }
    }
    else
#endif
    {
      if(rrcllc_process_reconfigure_sccpch() == FAILURE)
      {
        WRRC_MSG0_ERROR ("Couldn't reconfigure SCCPCH");
        return FAILURE;
      }
    }
  }

  /* Uplink Physical channel processing */

  /* This is a case for addition of PRACH */
  rrcllc_cmd_under_process.chan_config.phy_chan_action_list.prach_action =
    LLC_PHYCHAN_SETUP;

  MSG_LOW("LLC_PHYCHAN_SETUP on PRACH", 0, 0, 0);

  /* CHECK OUT THE RRC_CHANNEL_CONFIG_REQ command */
  for (i=0; i<cmd_ptr->cmd.chan_config_req.num_rb_to_config; i++)
  {
    /* No action on any RB other than CCCH is allowed when moving from
     * Idle Disconnected to Idle Connecting.
     */
    if((cmd_ptr->cmd.chan_config_req.rb[i].rb_id != CCCH_RADIO_BEARER_ID) &&
       (cmd_ptr->cmd.chan_config_req.rb[i].rb_config != NO_ACTION_ON_RB))
    {
      /* TBD: How to handle this invalid command ? Log an Error for now */
      MSG_MED("RB %d:Operation %d in RRC_CHANNEL_CONFIG_REQ DISC->CONCTNG",
                cmd_ptr->cmd.chan_config_req.rb[i].rb_id,
                cmd_ptr->cmd.chan_config_req.rb[i].rb_config, 0);
    }
  } /* CHECK OUT THE RRC_CHANNEL_CONFIG_REQ command */

/* check whether CTCH was setup on a different SCCPCH before. If that is the case
then drop that physical channel.
*/
  /* If a valid CCTrCH ID exists for SCCPCH, add it to release list */
  if(rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.cctrch_id !=
     RRCLLC_INVALID_CCTRCH_ID)
  {
    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_for_ctch_action =
      LLC_PHYCHAN_RELEASE;
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_ref_type_bf = 0;
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_enable_bf = 0;

    RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                         dl_phy_chan.sccpch_with_ctch.cctrch_id);
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.cctrch_id = RRCLLC_INVALID_CCTRCH_ID;
  }

  return(SUCCESS);
} /* rrcllc_chan_config_discon_to_connecting */


/*===========================================================================
FUNCTION   rrcllc_chan_config_discon_to_dch

DESCRIPTION
  This function is resposible for determining all actions on RLC, MAC
  and L1.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static uecomdef_status_e_type
rrcllc_chan_config_discon_to_dch(rrc_cmd_type *cmd_ptr)
{
  uint8   dl_cctrch_id;
  int     dch_count;
  int     i;
#ifdef FEATURE_WCDMA_DC_HSDPA
  ordered_config_type 
*config_ptr = ordered_config_ptr;
#endif
  rrc_initialize_rlc_size_change();

  rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;

  /* Ordered Config has already been updated by procedure */

  /* 1. Action on Logical Channels */
  /* Since it is a change of state to Cell_DCH, add DCCHs */
  (void)rrcllc_process_config_dcch_dtch(cmd_ptr);

#ifdef FEATURE_UMTS_PDCP
    /* Build the command for PDCP_CONFIG_REQ*/
    rrcllc_process_config_pdcp(cmd_ptr);
#endif /* FEATURE_UMTS_PDCP*/  

  /* Downlink Physical channel processing */

  /* This is a case of adding DL_DPCH */

  rrcllc_cmd_under_process.chan_config.phy_chan_action_list.dl_dpch_action =
    LLC_PHYCHAN_SETUP;
  /* Since a new DPCH is being established, initialize the Transport channel
   * bitflag to DCH
   */
  rrcllc_semi_permanent_data.dl_phy_chan.dl_dpch.trch_ref_type_bf =
        L1_DL_TRCH_REFTYPE_DCH_BF;
  rrcllc_semi_permanent_data.dl_phy_chan.dl_dpch.trch_enable_bf =
        L1_DL_TRCH_REFTYPE_DCH_BF;

  /* Get a new CCTrCH ID */
  dl_cctrch_id = rrcllc_get_cctrch_id();
  if(dl_cctrch_id != RRCLLC_INVALID_CCTRCH_ID)
  {
    /* Update DCH info in MAC Ordered Config */
    for(dch_count=0; dch_count < ordered_config_ptr->mac_dl_parms.num_dchs; dch_count++)
    {
      ordered_config_ptr->mac_dl_parms.dch_info[dch_count]->cctrch_id
        = dl_cctrch_id;
    }
    /* Update DPCH Info in rrcllc_cmd_under_process - this presumes that
     * there is only 1 DPCH
     */
    rrcllc_semi_permanent_data.dl_phy_chan.dl_dpch.cctrch_id =
      dl_cctrch_id;
  }
  else
  {
    WRRC_MSG1_ERROR("Invalid DL CCTrCH ID %d assigned", dl_cctrch_id);
    return(FAILURE);
  }

  MSG_LOW("LLC_PHYCHAN_SETUP for DL DPCH", 0, 0, 0);

  if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
  {
    if(rrc_get_hsdpa_action() == HSDPA_START)
    {
      WRRC_MSG0_HIGH("RRCHS:hsdpa-START, RRCHS:Set CCTRCH ID");
  
      if (rrcllc_check_if_hsdpa_can_be_started_reconfigured(ordered_config_ptr) == FALSE)
      {
        WRRC_MSG0_ERROR("RRCHS:hsdparesumefailure");
        ordered_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_NOOP;
        ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator = FALSE;
        rrc_set_hsdpa_action(HSDPA_NOOP);
        ordered_config_ptr->mac_dl_parms.mac_hs_transition_type= MAC_HS_NO_TRANSITION;
        ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs= MAC_HS_TYPE_INVALID;
        ordered_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_NOOP;
      }
      else
      {
        if(ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_HS_TYPE_INVALID)
        {
          WRRC_MSG0_ERROR("MACEHS:Invalid Type, though HSDPA is ACTIVE ");
          return FAILURE;
        }
        else if(ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_EHS)
        {
          ordered_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_START;
          ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator = FALSE;
          ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs = MAC_EHS;
          ordered_config_ptr->mac_dl_parms.mac_hs_transition_type = MAC_HS_NO_TRANSITION;
        }
        else
        {
          ordered_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_START;
          ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs = MAC_HS;
          ordered_config_ptr->mac_dl_parms.mac_hs_transition_type = MAC_HS_NO_TRANSITION;
          ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator = FALSE;
        }
        WRRC_MSG1_HIGH("MACEHS: Type is %d [1-HS, 2-EHS]",ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs);
        ordered_config_ptr->l1_hsdpa_info.hs_req_mask = CPHY_HS_DSCH_CFG_INCL |
            CPHY_HS_PDSCH_RL_CFG_INCL | CPHY_HS_SCCH_CFG_INCL | CPHY_HS_DPCCH_CFG_INCL;
#ifdef FEATURE_WCDMA_MIMO
        if(rrcllc_get_mimo_action_in_config() == L1_MIMO_START)
        {
          WRRC_MSG0_HIGH("MIMO: Set MIMO action to START");
          ordered_config_ptr->l1_hsdpa_info.hs_req_mask |=CPHY_HS_MIMO_CFG_INCL;
          ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_START;
        }
        else
        {
          ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_NOOP;
        }
#endif
#ifdef FEATURE_WCDMA_DC_HSDPA
        if(config_ptr_in_use == ORDERED_CONFIG)
        {
          config_ptr = ordered_config_ptr;
        }
        else
        {
          config_ptr = current_config_ptr;
        }
        if(rrcllcpcie_return_num_sec_hsdpa_carriers(config_ptr) > 0)
        {
          /*Other bit masks will be set due top generic logic of RECONFIG of HSDPA.*/
          ordered_config_ptr->l1_hsdpa_info.hs_req_mask |=CPHY_HS_SEC_HSDPA_CFG_INCL;
          WRRC_MSG0_HIGH("DC-HSDPA: Sec hs_req_mask included ");	
        }
#endif /*FEATURE_WCDMA_DC_HSDPA*/
        /* Set beta table and hs-dpcch bit mask */
        ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 
           HS_DPCCH_BETA_HS_INFO_PRESENT_BITMASK | HS_DPCCH_MEAS_FEEDBACK_INFO_PRESENT_BITMASK;
        WRRC_MSG1_MED("RRCHS:Set CCTrCh Id %d in L1 structure, Setting HSDPA L1 Info",ordered_config_ptr->mac_dflow_info[0].cctrch_id);
  
        /* Set CCTRCH in L1 HSDSCH information */
        if(ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_EHS)
        {
          ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.cctrch_id = 
              ordered_config_ptr->mac_ehs_queue_info[0].cctrch_id;
        }
        else
        {
          ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.cctrch_id = 
             ordered_config_ptr->mac_dflow_info[0].cctrch_id;
        }
        rrcllc_set_hsdpa_l1_info_in_cmd_under_process(ordered_config_ptr);
      }
    } /* Else of HSDPA Resume */
  }
  /* Uplink physical channel processing */
  /* This is a case for addition of UL_DPCH */
  rrcllc_cmd_under_process.chan_config.phy_chan_action_list.ul_dpch_action =
    LLC_PHYCHAN_SETUP;

  MSG_LOW("LLC_PHYCHAN_SETUP for UL DPCH", 0, 0, 0);

  /* CHECK OUT THE RRC_CHANNEL_CONFIG_REQ command */
  for (i=0; i<cmd_ptr->cmd.chan_config_req.num_rb_to_config; i++)
  {
    /* No RB other than DCCH is expected in Channel Config Request when
     * moving from Disconnected to Cell_DCH.
     */
    if((cmd_ptr->cmd.chan_config_req.rb[i].rb_id != DCCH_UM_RADIO_BEARER_ID) &&
       (cmd_ptr->cmd.chan_config_req.rb[i].rb_id != DCCH_AM_RADIO_BEARER_ID) &&
       (cmd_ptr->cmd.chan_config_req.rb[i].rb_id != DCCH_DT_HIGH_PRI_RADIO_BEARER_ID) &&
       (cmd_ptr->cmd.chan_config_req.rb[i].rb_id != DCCH_DT_LOW_PRI_RADIO_BEARER_ID) &&
       (cmd_ptr->cmd.chan_config_req.rb[i].rb_config != NO_ACTION_ON_RB))
    {
      /* TBD: How to handle this invalid command ? Log an Error for now */
      MSG_MED("RB %d:Operation %d in RRC_CHANNEL_CONFIG_REQ CONCTNG->DCH",
                cmd_ptr->cmd.chan_config_req.rb[i].rb_id,
                cmd_ptr->cmd.chan_config_req.rb[i].rb_config, 0);
    }
  } /*  2. CHECK OUT THE RRC_CHANNEL_CONFIG_REQ command */

  /* Initialize Send MAC Uplink Config indicator to TRUE */
  rrcllc_semi_permanent_data.send_mac_uplink_config = TRUE;

  return(SUCCESS);
} /* rrcllc_chan_config_discon_to_dch */

/*===========================================================================
FUNCTION   rrcllc_chan_config_connecting_to_dch

DESCRIPTION
  This function is resposible for determining all actions on RLC, MAC
  and L1.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static uecomdef_status_e_type
rrcllc_chan_config_connecting_to_dch(rrc_cmd_type *cmd_ptr)
{
  uint8   dl_cctrch_id;
  int     dch_count;
  int     i;
  rlc_lc_id_type        rlc_dl_log_chl_id; /* RLC downlink logical channel ID */
  hsdpa_action_enum_type hs_action;
	
  uint8 dflow_cnt = 0, cnt = 0;

  rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;

  WRRC_MSG2_HIGH("Chan_config_connecting2dch proc:rrc_proc_e_type_value%d, oc_status:rrcllc_oc_set_status_e_type_value%d",
           rrcllc_cmd_under_process.procedure,rrcllc_get_ordered_config_status_wo_f3());
  /* Drop BCCH/BCH/PCCPCH pipe if it's up */
  if(rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up)
  {
    (void)rrcllc_process_drop_bcch_serving();
    ordered_config_ptr->mac_dl_parms.num_bchs = 0;
    /* Physical channel processing */
    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action =
      LLC_PHYCHAN_RELEASE;
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_ref_type_bf = 0;
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_enable_bf = 0;
    /* Add the CCTrCH ID for PCCPCH to the CCTrCH IDs to be released list */
    RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                          dl_phy_chan.pccpch.cctrch_id);
  }

  if(rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch_is_up)
  {
    (void)rrcllc_process_drop_bcch_neighbor();
    ordered_config_ptr->mac_dl_parms.num_bchs = 0;
    /* Physical channel processing */
    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.n_pccpch_action =
      LLC_PHYCHAN_RELEASE;
    rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch.trch_ref_type_bf = 0;
    rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch.trch_enable_bf = 0;
    /* Add the CCTrCH ID for PCCPCH to the CCTrCH IDs to be released list */
    RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                          dl_phy_chan.n_pccpch.cctrch_id);
  }
  /* Ordered Config has already been updated by procedure */

  /* 1. Action on Logical Channels */
  /* PCCH and CCCH will be released */

  /* Drop PCCH if it was present before in the Connecting state */
  rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id
  (
    UE_LOGCHAN_PCCH,
    PCCH_RADIO_BEARER_ID,
    UE_MODE_TRANSPARENT
  );
  if (rlc_dl_log_chl_id != RRCLCM_RLC_LC_ID_ERROR)
  {
    (void)rrcllc_process_drop_pcch();
  }
  /* Drop CCCH */
  (void)rrcllc_process_drop_ccch();

  /* Since it is a change of state to Cell_DCH, add DCCHs */
  if (rrcllc_process_config_dcch_dtch(cmd_ptr) == FAILURE)
  {
    (void)rrcllc_build_cmd_and_release_lc_ids(); 
    WRRC_MSG0_ERROR("FAILURE in config dcch dtch");
    return FAILURE;
  }
  /* Downlink Physical channel processing */

#ifdef FEATURE_WCDMA_HS_FACH
  if(rrcllc_get_hs_status_in_e_fach(current_config_ptr) == TRUE)
  {
    if(rrcenhstate_release_phychan(RRC_E_FACH_COMMON) == FAILURE)
    {
      WRRC_MSG0_ERROR("EFACH: releasing efach channels failed");
    }
  }
  else
#endif /*FEATURE_WCDMA_HS_FACH*/
  {
    /* This is a case of dropping SCCPCH and adding DL_DPCH */
    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_action =
      LLC_PHYCHAN_RELEASE;
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf = 0;
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf = 0;

    /* Add the CCTrCH ID for SCCPCH to the CCTrCH IDs to be released list */
    RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.dl_phy_chan.
                                       sccpch.cctrch_id);
  }
  rrcllc_cmd_under_process.chan_config.phy_chan_action_list.dl_dpch_action =
    LLC_PHYCHAN_SETUP;
  /* Since a new DPCH is being established, initialize the Transport channel
   * bitflag to DCH
   */
  rrcllc_semi_permanent_data.dl_phy_chan.dl_dpch.trch_ref_type_bf =
        L1_DL_TRCH_REFTYPE_DCH_BF;
  rrcllc_semi_permanent_data.dl_phy_chan.dl_dpch.trch_enable_bf =
        L1_DL_TRCH_REFTYPE_DCH_BF;

  /* Get a new CCTrCH ID */
  dl_cctrch_id = rrcllc_get_cctrch_id();
  if(dl_cctrch_id != RRCLLC_INVALID_CCTRCH_ID)
  {
    /* Update DCH info in MAC Ordered Config */
    for(dch_count=0; dch_count < ordered_config_ptr->mac_dl_parms.num_dchs; dch_count++)
    {
      ordered_config_ptr->mac_dl_parms.dch_info[dch_count]->cctrch_id
        = dl_cctrch_id;
    }
    /* Update DPCH Info in rrcllc_cmd_under_process - this presumes that
     * there is only 1 DPCH
     */
    rrcllc_semi_permanent_data.dl_phy_chan.dl_dpch.cctrch_id =
      dl_cctrch_id;
  }
  else
  {
    WRRC_MSG1_ERROR("Invalid DL CCTrCH ID %d assigned", dl_cctrch_id);
    return(FAILURE);
  }


  /* Check if HSDPA needs to be activated */
  
  hs_action = rrc_get_hsdpa_action();
  
  if ((hs_action == HSDPA_START)
#ifdef FEATURE_WCDMA_HS_FACH
        || (rrc_get_hsdpa_action() == HSDPA_RECONFIG)
#endif
      )
  {
    if(ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs ==  MAC_EHS )
    {
      for(cnt=0;cnt < ordered_config_ptr->mac_dl_parms.num_mac_ehs_queue;cnt++)
      {
        ordered_config_ptr->mac_dl_parms.hsdpa_ehs_queue_info[cnt]->cctrch_id = dl_cctrch_id;
      }
      for( cnt=0; cnt < ordered_config_ptr->mac_dl_parms.ndlchan_macehs; cnt++)
      {
        /* If the call setup was done in FACH, then RLC ID would not have been stored in TOC */
        rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id(
          UE_LOGCHAN_DTCH, ordered_config_ptr->dl_macehs_logchan_info[cnt].rb_id, 
          ordered_config_ptr->dl_macehs_logchan_info[cnt].rlc_mode);
        MSG_HIGH("MACEHS:RB ID %d, Old LC %d, New %d", 
                    ordered_config_ptr->dl_macehs_logchan_info[cnt].rb_id,
                    ordered_config_ptr->dl_macehs_logchan_info[cnt].rlc_id,
                      rlc_dl_log_chl_id);
        if (rlc_dl_log_chl_id != RRCLCM_RLC_LC_ID_NOT_FOUND)
        {
          ordered_config_ptr->dl_macehs_logchan_info[cnt].rlc_id = rlc_dl_log_chl_id;
        }
      }
    }
    else
    {
      /* Update CCTRCH for HSDPA in MAC Ordered Config */
      for (dflow_cnt=0; dflow_cnt < ordered_config_ptr->mac_dl_parms.num_dflow; dflow_cnt++)
      {
        WRRC_MSG1_MED("RRCHS:Set CCTrCh Id %d in MAC HSDPA info",dl_cctrch_id);
        ordered_config_ptr->mac_dl_parms.hsdpa_info[dflow_cnt]->cctrch_id
              = dl_cctrch_id;
        /* Set the RLC ID */
        for( cnt=0; cnt < ordered_config_ptr->mac_dflow_info[dflow_cnt].ndlchan; cnt++)
        {
            /* If the call setup was done in FACH, then RLC ID would not have been stored in TOC */
            rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id(
                UE_LOGCHAN_DTCH, ordered_config_ptr->mac_dflow_info[dflow_cnt].dlchan_info[cnt].rb_id, 
                ordered_config_ptr->mac_dflow_info[dflow_cnt].dlchan_info[cnt].rlc_mode);
            
            
            
            if (rlc_dl_log_chl_id == RRCLCM_RLC_LC_ID_NOT_FOUND)
            {
            /* Should not happen. But if it happens, use the old LC ID that has already been
                verified from rrcllc_config_dcch_dtch fn */
                MSG_ERROR("RRCHS:RB %d,Old LC %d,New %d Use LC", 
                    ordered_config_ptr->mac_dflow_info[dflow_cnt].dlchan_info[cnt].rb_id,
                    ordered_config_ptr->mac_dflow_info[dflow_cnt].dlchan_info[cnt].rlc_id,
                    rlc_dl_log_chl_id);
                
            }
            else
            {
                MSG_HIGH("RRCHS:RB ID %d, Old LC %d, New %d", 
                    ordered_config_ptr->mac_dflow_info[dflow_cnt].dlchan_info[cnt].rb_id,
                    ordered_config_ptr->mac_dflow_info[dflow_cnt].dlchan_info[cnt].rlc_id,
                    rlc_dl_log_chl_id);
                ordered_config_ptr->mac_dflow_info[dflow_cnt].dlchan_info[cnt].rlc_id = rlc_dl_log_chl_id;
            }
            
        }
      }
    }
        
    WRRC_MSG1_MED("RRCHS:Set CCTrCh Id %d in L1 structure, Setting HSDPA L1 Info",dl_cctrch_id);
    
    /* Set CCTRCH in L1 HSDSCH information */
    ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.cctrch_id = dl_cctrch_id;
    
	rrcllc_set_hsdpa_l1_info_in_cmd_under_process(ordered_config_ptr);

    if (rrcllc_check_if_hsdpa_can_be_started_reconfigured(ordered_config_ptr) == FALSE)
    {
        WRRC_MSG0_HIGH("RRCHS:hsdpaconfigcomplete NOT");    
        /* HSDPA ACTION has already been set to NOOP */
    }
  } 
  else
  {
      WRRC_MSG1_MED("Invalid HS Action %d", hs_action);
  }
  MSG_LOW("LLC_PHYCHAN_SETUP for DL DPCH", 0, 0, 0);

  /* Uplink physical channel processing */
  /* This is a case for deletion of PRACH and addition of UL_DPCH */
  rrcllc_cmd_under_process.chan_config.phy_chan_action_list.ul_dpch_action =
    LLC_PHYCHAN_SETUP;

  MSG_LOW("LLC_PHYCHAN_SETUP for UL DPCH", 0, 0, 0);

  rrcllc_cmd_under_process.chan_config.phy_chan_action_list.prach_action =
    LLC_PHYCHAN_RELEASE;

  MSG_LOW("LLC_PHYCHAN_RELEASE for PRACH", 0, 0, 0);

  /* CHECK OUT THE RRC_CHANNEL_CONFIG_REQ command */
  for (i=0; i<cmd_ptr->cmd.chan_config_req.num_rb_to_config; i++)
  {
    /* No RB other than DCCH is expected in Channel Config Request when
     * moving from Idle Connecting to Cell_DCH.
     */
    if((cmd_ptr->cmd.chan_config_req.rb[i].rb_id != DCCH_UM_RADIO_BEARER_ID) &&
       (cmd_ptr->cmd.chan_config_req.rb[i].rb_id != DCCH_AM_RADIO_BEARER_ID) &&
       (cmd_ptr->cmd.chan_config_req.rb[i].rb_id != DCCH_DT_HIGH_PRI_RADIO_BEARER_ID) &&
       (cmd_ptr->cmd.chan_config_req.rb[i].rb_id != DCCH_DT_LOW_PRI_RADIO_BEARER_ID) &&
       (cmd_ptr->cmd.chan_config_req.rb[i].rb_config != NO_ACTION_ON_RB))
    {
      /* TBD: How to handle this invalid command ? Log an Error for now */
      MSG_MED("RB %d:Operation %d in RRC_CHANNEL_CONFIG_REQ CONCTNG->DCH",
                cmd_ptr->cmd.chan_config_req.rb[i].rb_id,
                cmd_ptr->cmd.chan_config_req.rb[i].rb_config, 0);
    }
  } /*  2. CHECK OUT THE RRC_CHANNEL_CONFIG_REQ command */

  /* Is this is an Inter-frequency HHO? */
  if(ordered_config_ptr->dest_freq_present)
  {
    rrcllc_cmd_under_process.chan_config.new_freq = TRUE;
  }

#ifdef FEATURE_WCDMA_HS_RACH
  ordered_config_ptr->transition_to_dch = TRUE;
#endif

  return(SUCCESS);
} /* rrcllc_chan_config_connecting_to_dch */

/*===========================================================================
FUNCTION   rrcllc_chan_config_fach_to_dch

DESCRIPTION
  This function is resposible for determining all actions on RLC, MAC
  and L1 when transitioning from CELL_FACH to CELL_DCH.

DEPENDENCIES
  None.

RETURN VALUE
  Failure/Success

SIDE EFFECTS
  None.
===========================================================================*/
static uecomdef_status_e_type
rrcllc_chan_config_fach_to_dch(rrc_cmd_type *cmd_ptr)
{
  uint8   dl_cctrch_id;
  int     dch_count;
  int     i;
  rlc_lc_id_type        rlc_dl_log_chl_id; /* RLC downlink logical channel ID */

  uint8 dflow_cnt = 0, cnt = 0;

  uint8 queue_cnt=0;
  mac_hs_e_type rrc_machs_ehs;
  rrc_machs_ehs =ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs;
  

  rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;

  WRRC_MSG2_HIGH("Chan_config_fach2dch proc:rrc_proc_e_type_value%d, oc_status:rrcllc_oc_set_status_e_type_value%d",
           rrcllc_cmd_under_process.procedure,rrcllc_get_ordered_config_status_wo_f3());
  /* Drop BCCH/BCH/PCCPCH pipe if it's up */
  if(rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up)
  {
    (void)rrcllc_process_drop_bcch_serving();
    ordered_config_ptr->mac_dl_parms.num_bchs = 0;
    /* Physical channel processing */
    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action =
      LLC_PHYCHAN_RELEASE;
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_ref_type_bf = 0;
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_enable_bf = 0;
    /* Add the CCTrCH ID for PCCPCH to the CCTrCH IDs to be released list */
    RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                          dl_phy_chan.pccpch.cctrch_id);
  }

  if(rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch_is_up)
  {
    MSG_LOW("N-PCCPCH dropped on FACH->DCH", 0, 0, 0);
    (void)rrcllc_process_drop_bcch_neighbor();
    ordered_config_ptr->mac_dl_parms.num_bchs = 0;
    /* Physical channel processing */
    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.n_pccpch_action =
      LLC_PHYCHAN_RELEASE;
    rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch.trch_ref_type_bf = 0;
    rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch.trch_enable_bf = 0;
    /* Add the CCTrCH ID for PCCPCH to the CCTrCH IDs to be released list */
    RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                          dl_phy_chan.n_pccpch.cctrch_id);
  }

  /* Ordered Config has already been updated by procedure */

  /* 1. Action on Logical Channels */
  /* PCCH and CCCH will be released */

  /* Drop PCCH if it was present before in the Connecting state */
  rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id
  (
    UE_LOGCHAN_PCCH,
    PCCH_RADIO_BEARER_ID,
    UE_MODE_TRANSPARENT
  );
  if (rlc_dl_log_chl_id != RRCLCM_RLC_LC_ID_ERROR)
  {
    (void)rrcllc_process_drop_pcch();
  }

#ifdef FEATURE_WCDMA_HS_RACH
  /*For a FACH to DCH transition determine the HSRACH action here */
  if(TRUE == rrchsrach_get_common_edch_transmission(current_config_ptr))
  {
    rrchsrach_set_common_edch_transmission(ordered_config_ptr, FALSE);
    ordered_config_ptr->l1_hs_rach_req_mask = L1_HS_RACH_STOP;
    rrcllc_set_hs_rach_action(ordered_config_ptr,MAC_HS_RACH_STOP);

    if(ordered_config_ptr->e_dch_transmission == TRUE)
    {
      ordered_config_ptr->hs_rach_to_eul_trans = TRUE;
    }
  }
  else
  {
    ordered_config_ptr->l1_hs_rach_req_mask = L1_HS_RACH_NO_OP;
    rrcllc_set_hs_rach_action(ordered_config_ptr,MAC_HS_RACH_NOOP);
  }
  WRRC_MSG2_MED("HSRACH: MAC action is = %d, L1 req mask is %d (0:N/1:S/2:R/3:S)",
  ordered_config_ptr->mac_hs_rach_action,ordered_config_ptr->l1_hs_rach_req_mask);
  ordered_config_ptr->transition_to_dch = TRUE;
#endif

  //drop bcch on fach
  (void)rrcllc_process_drop_bcch_on_fach();
  /* Drop CCCH */
  (void)rrcllc_process_drop_ccch();

  /* Since it is a change of state to Cell_DCH, add DCCHs */
  if (rrcllc_process_config_dcch_dtch(cmd_ptr) == FAILURE)
  {
    (void)rrcllc_build_cmd_and_release_lc_ids(); 
      WRRC_MSG0_ERROR("FAILURE in config dcch dtch");
    return FAILURE;
  }

#ifdef FEATURE_UMTS_PDCP
  /* Build the command for PDCP_CONFIG_REQ*/
  rrcllc_process_config_pdcp(cmd_ptr);  
#endif /* FEATURE_UMTS_PDCP*/
  /* Downlink Physical channel processing */

#ifdef FEATURE_WCDMA_HS_FACH
  if(rrcllc_get_hs_status_in_e_fach(current_config_ptr) == TRUE)
  {
    if(rrcllc_get_hs_action_in_e_fach(ordered_config_ptr) == HSDPA_STOP)
    {
      (void)rrcenhstate_release_phychan(RRC_E_FACH_DEDICATED);
    }
    else
    {
      if(ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.cctrch_id !=
         RRCLLC_INVALID_CCTRCH_ID)
      {
        RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.cctrch_id);
      }
    }
  }
  else
#endif /*FEATURE_WCDMA_HS_FACH*/
  {
    /* This is a case of dropping SCCPCH and adding DL_DPCH */
    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_action =
      LLC_PHYCHAN_RELEASE;
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf = 0;
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf = 0;

    /* Add the CCTrCH ID for SCCPCH to the CCTrCH IDs to be released list */
    RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.dl_phy_chan.
                                       sccpch.cctrch_id);
  }
  rrcllc_cmd_under_process.chan_config.phy_chan_action_list.dl_dpch_action =
    LLC_PHYCHAN_SETUP;
  /* Since a new DPCH is being established, initialize the Transport channel
   * bitflag to DCH
   */
  rrcllc_semi_permanent_data.dl_phy_chan.dl_dpch.trch_ref_type_bf =
        L1_DL_TRCH_REFTYPE_DCH_BF;
  rrcllc_semi_permanent_data.dl_phy_chan.dl_dpch.trch_enable_bf =
        L1_DL_TRCH_REFTYPE_DCH_BF;

  /* Get a new CCTrCH ID */
  dl_cctrch_id = rrcllc_get_cctrch_id();
  if(dl_cctrch_id != RRCLLC_INVALID_CCTRCH_ID)
  {
    /* Update DCH info in MAC Ordered Config */
    for(dch_count=0; dch_count < ordered_config_ptr->mac_dl_parms.num_dchs; dch_count++)
    {
      ordered_config_ptr->mac_dl_parms.dch_info[dch_count]->cctrch_id
        = dl_cctrch_id;
    }
    /* Update DPCH Info in rrcllc_cmd_under_process - this presumes that
     * there is only 1 DPCH
     */
    rrcllc_semi_permanent_data.dl_phy_chan.dl_dpch.cctrch_id =
      dl_cctrch_id;
  }
  else
  {
    WRRC_MSG1_ERROR("Invalid DL CCTrCH ID %d assigned", dl_cctrch_id);
    return(FAILURE);
  }

  if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
  {
    if(rrc_get_hsdpa_action() == HSDPA_START)
    {
      if(rrc_machs_ehs == MAC_EHS)
      {
        for(queue_cnt=0;queue_cnt < ordered_config_ptr->mac_dl_parms.num_mac_ehs_queue;queue_cnt++)
        {
          ordered_config_ptr->mac_dl_parms.hsdpa_ehs_queue_info[queue_cnt]->cctrch_id = dl_cctrch_id;
        }
        for( cnt=0; cnt < ordered_config_ptr->mac_dl_parms.ndlchan_macehs; cnt++)
        {
          /* If the call setup was done in FACH, then RLC ID would not have been stored in TOC */
          rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id(
            UE_LOGCHAN_DTCH, ordered_config_ptr->dl_macehs_logchan_info[cnt].rb_id, 
            ordered_config_ptr->dl_macehs_logchan_info[cnt].rlc_mode);
          if (rlc_dl_log_chl_id == RRCLCM_RLC_LC_ID_NOT_FOUND)
          {
            /* Should not happen. But if it happens, use the old LC ID that has already been
               verified from rrcllc_config_dcch_dtch fn */
            WRRC_MSG3_MED("RRCHS:RB %d,Old LC %d,New %d Use LC", 
                          ordered_config_ptr->mac_dflow_info[dflow_cnt].dlchan_info[cnt].rb_id,
                          ordered_config_ptr->mac_dflow_info[dflow_cnt].dlchan_info[cnt].rlc_id,
                          rlc_dl_log_chl_id);
          }
          }
      }
      else
      {
        /* Update CCTRCH for HSDPA in MAC Ordered Config */
        for(dflow_cnt=0; dflow_cnt < ordered_config_ptr->mac_dl_parms.num_dflow; dflow_cnt++)
        {
          WRRC_MSG1_MED("RRCHS:Set CCTrCh Id %d in MAC HSDPA info",dl_cctrch_id);
          ordered_config_ptr->mac_dl_parms.hsdpa_info[dflow_cnt]->cctrch_id
            = dl_cctrch_id;
          /* Set the RLC ID */
          for( cnt=0; cnt < ordered_config_ptr->mac_dflow_info[dflow_cnt].ndlchan; cnt++)
          {
            /* If the call setup was done in FACH, then RLC ID would not have been stored in TOC */
            rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id(
              UE_LOGCHAN_DTCH, ordered_config_ptr->mac_dflow_info[dflow_cnt].dlchan_info[cnt].rb_id, 
              ordered_config_ptr->mac_dflow_info[dflow_cnt].dlchan_info[cnt].rlc_mode);
            
            if (rlc_dl_log_chl_id == RRCLCM_RLC_LC_ID_NOT_FOUND)
            {
                      /* Should not happen. But if it happens, use the old LC ID that has already been
                          verified from rrcllc_config_dcch_dtch fn */
              WRRC_MSG3_MED("RRCHS:RB %d,Old LC %d,New %d Use LC", 
                              ordered_config_ptr->mac_dflow_info[dflow_cnt].dlchan_info[cnt].rb_id,
                              ordered_config_ptr->mac_dflow_info[dflow_cnt].dlchan_info[cnt].rlc_id,
                              rlc_dl_log_chl_id);
                          
            }
          }
        }
      }
      WRRC_MSG1_MED("RRCHS:Set CCTrCh Id %d in L1 structure, Setting HSDPA L1 Info",dl_cctrch_id);
      
      /* Set CCTRCH in L1 HSDSCH information */
      ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.cctrch_id = dl_cctrch_id;
      
      rrcllc_set_hsdpa_l1_info_in_cmd_under_process(ordered_config_ptr);
      if (rrcllc_check_if_hsdpa_can_be_started_reconfigured(ordered_config_ptr) == FALSE)
      {
        WRRC_MSG0_ERROR("RRCHS:hsdpaconfigcomplete NOT");
        return FAILURE;
      }
    } 
  }

  MSG_LOW("LLC_PHYCHAN_SETUP for DL DPCH", 0, 0, 0);

  /* Uplink physical channel processing */
  /* This is a case for deletion of PRACH and addition of UL_DPCH */
  rrcllc_cmd_under_process.chan_config.phy_chan_action_list.ul_dpch_action =
    LLC_PHYCHAN_SETUP;

  MSG_LOW("LLC_PHYCHAN_SETUP for UL DPCH", 0, 0, 0);

  rrcllc_cmd_under_process.chan_config.phy_chan_action_list.prach_action =
    LLC_PHYCHAN_RELEASE;

  MSG_LOW("LLC_PHYCHAN_RELEASE for PRACH", 0, 0, 0);

  /* CHECK OUT THE RRC_CHANNEL_CONFIG_REQ command */
  for (i=0; i<cmd_ptr->cmd.chan_config_req.num_rb_to_config; i++)
  {
    /* No RB other than DCCH is expected in Channel Config Request when
     * moving from Idle Connecting to Cell_DCH.
     */
    if((cmd_ptr->cmd.chan_config_req.rb[i].rb_id != DCCH_UM_RADIO_BEARER_ID) &&
       (cmd_ptr->cmd.chan_config_req.rb[i].rb_id != DCCH_AM_RADIO_BEARER_ID) &&
       (cmd_ptr->cmd.chan_config_req.rb[i].rb_id != DCCH_DT_HIGH_PRI_RADIO_BEARER_ID) &&
       (cmd_ptr->cmd.chan_config_req.rb[i].rb_id != DCCH_DT_LOW_PRI_RADIO_BEARER_ID) &&
       (cmd_ptr->cmd.chan_config_req.rb[i].rb_config != NO_ACTION_ON_RB))
    {
      /* TBD: How to handle this invalid command ? Log an Error for now */
      MSG_MED("RB %d:Operation %d in RRC_CHANNEL_CONFIG_REQ CONCTNG->DCH",
                cmd_ptr->cmd.chan_config_req.rb[i].rb_id,
                cmd_ptr->cmd.chan_config_req.rb[i].rb_config, 0);
    }
  } /*  2. CHECK OUT THE RRC_CHANNEL_CONFIG_REQ command */

  /* Is this is an Inter-frequency HHO? */
  if(ordered_config_ptr->dest_freq_present)
  {
    rrcllc_cmd_under_process.chan_config.new_freq = TRUE;
  }

#ifdef FEATURE_WCDMA_DC_HSUPA
  if(ordered_config_ptr->sec_eul_is_hho)
  {
    rrcllc_cmd_under_process.chan_config.sec_eul_new_freq = TRUE;
  }

#endif /* FEATURE_WCDMA_DC_HSUPA */


  return(SUCCESS);
} /* rrcllc_chan_config_fach_to_dch */

/*===========================================================================
FUNCTION   rrcllc_chan_config_connecting_to_fach

DESCRIPTION
  This function is resposible for determining all actions on RLC, MAC
  and L1 when going from Idle Connecting to Cell FACH state.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static uecomdef_status_e_type
rrcllc_chan_config_connecting_to_fach(rrc_cmd_type *cmd_ptr)
{
  rlc_lc_id_type        rlc_dl_log_chl_id; /* RLC downlink logical channel ID */
  rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;

  WRRC_MSG2_HIGH("Chan_config_conn2fach proc:rrc_proc_e_type_value%d, oc_status:rrcllc_oc_set_status_e_type_value%d",
           rrcllc_cmd_under_process.procedure,rrcllc_get_ordered_config_status_wo_f3());

  /* Drop PCCH if it was present in the Connecting state */
  rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id
  (
    UE_LOGCHAN_PCCH,
    PCCH_RADIO_BEARER_ID,
    UE_MODE_TRANSPARENT
  );
  if (rlc_dl_log_chl_id != RRCLCM_RLC_LC_ID_ERROR)
  {
    (void)rrcllc_process_drop_pcch();
  }
#ifdef FEATURE_WCDMA_HS_FACH

  if(rrcenhstate_evaluate_efach_and_set_lower_layers_action(ordered_config_ptr,
                                                            RRC_STATE_CELL_FACH,
                                                            RRC_E_FACH_DEDICATED) == FAILURE)
  {
    WRRC_MSG0_ERROR("EFACH:Failed to configure HS-FACH");
    return FAILURE;
  }
  

  rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id
  (
    UE_LOGCHAN_CCCH,
    CCCH_RADIO_BEARER_ID,
    UE_MODE_UNACKNOWLEDGED
  );
  if (rlc_dl_log_chl_id == RRCLCM_RLC_LC_ID_ERROR)
  {
    (void)rrcenhstate_process_add_ccch();
  }
  else
  {
    (void)rrcenhstate_process_reconfig_ccch();
  }

  /*If E-FACH is being done for CONN->FACH, we should skip this check.*/
  if(rrcllc_get_hs_status_in_e_fach(ordered_config_ptr) == FALSE)
#endif /*FEATURE_WCDMA_HS_FACH*/
  {
    if(rrcllc_semi_permanent_data.dl_phy_chan.fach_included == FALSE)
    {
      /* This is a wrong selection of SCCPCH that does not have FACH */
      WRRC_MSG0_ERROR("SCCPCH has no FACH included in Cell_FACH");
      return(FAILURE);
    }
  }
  
  /* Add DCCHs and DTCHs */
  if (rrcllc_process_config_dcch_dtch(cmd_ptr) == FAILURE)
  {
    (void)rrcllc_build_cmd_and_release_lc_ids(); 
    WRRC_MSG0_ERROR("FAILURE in config dcch dtch");
    return FAILURE;
  }

#ifdef FEATURE_UMTS_PDCP
    /* Build the command for PDCP_CONFIG_REQ*/
  rrcllc_process_config_pdcp(cmd_ptr);
#endif /* FEATURE_UMTS_PDCP*/


#ifdef FEATURE_WCDMA_HS_FACH
  if(rrcllc_get_hs_status_in_e_fach(ordered_config_ptr))
  {
    if(rrcenhstate_reconfig_phychan(RRC_E_FACH_DEDICATED) == FAILURE)
    {
      ERR_FATAL("RRCENHST:Error reconfiguring HS PDSCH",0,0,0);
    }
  }
  else
#endif /*FEATURE_WCDMA_HS_FACH*/
  {
    /* Fix the transport channel bitmasks for SCCPCH */
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
      L1_DL_TRCH_REFTYPE_FACH_BF;
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf |=
      L1_DL_TRCH_REFTYPE_FACH_BF;

    if(rrcllc_semi_permanent_data.dl_phy_chan.pch_included)
    {
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
        L1_DL_TRCH_REFTYPE_PCH_BF;
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf &=
        ~L1_DL_TRCH_REFTYPE_PCH_BF;
    }
    else  /* No PCH on this SCCPCH */
    {
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf &=
        ~L1_DL_TRCH_REFTYPE_PCH_BF;
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf &=
        ~L1_DL_TRCH_REFTYPE_PCH_BF;
    }

    if(rrcllc_process_reconfigure_sccpch() == FAILURE)
    {
        WRRC_MSG0_ERROR("Couldn't reconfigure SCCPCH");
        return FAILURE;
    }
  }
  /* Uplink Physical channel processing */

  /* This is a case for addition of PRACH */
  rrcllc_cmd_under_process.chan_config.phy_chan_action_list.prach_action =
    LLC_PHYCHAN_DROP_AND_ADD;
  //LLC_PHYCHAN_RECONFIG;

  MSG_LOW("LLC_PHYCHAN_DROP_AND_ADD on PRACH", 0, 0, 0);

#ifdef FEATURE_WCDMA_HS_FACH
  if(rrcllc_get_hs_status_in_e_fach(ordered_config_ptr))
  {
    (void)rrcenhstate_process_add_bcch_on_hsdsch();
  }
  else
#endif /*FEATURE_WCDMA_HS_FACH*/
  {
    //configure bcch on fach
    (void)rrcllc_process_add_bcch_on_fach();
  }

#ifdef FEATURE_UPDATE_SIB7_IN_FACH
  
#ifdef FEATURE_WCDMA_HS_RACH
  if(rrcsib_update_sib7_hs_rach() == TRUE)
#endif
  {
  /*
  Code For Bringing up PCCPCH
  */
  if (!rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch_is_up) 
  {
    if(!rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up)
    {
      /* A S-BCCH has to be added in DL; Setup S-PCCPCH */
      rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action =
        LLC_PHYCHAN_SETUP;
      if(rrcllc_update_spccpch_params_based_on_action(ordered_config_ptr)==FAILURE)
      {
        return (FAILURE);
      }
    }
    else
    {
      WRRC_MSG0_HIGH("Serving PCCPCH already up!");
    }
  }
  else
  {
    /*
      If N-BCCH is up already, Do not bring up S-BCCH
    */
    WRRC_MSG0_HIGH("N-BCCH is up, Do not Bring up S-BCCH ");
  }
  }
#ifdef FEATURE_WCDMA_HS_RACH
  else
  {
    WRRC_MSG0_HIGH("RRCHSRACH: Skipping SIB7 update");
  }
#endif
#endif /* FEATURE_UPDATE_SIB7_IN_FACH */

#ifdef FEATURE_WCDMA_HS_RACH
  /*Code to set common edch transmission flag and determine L1 and MAC action */
  /*ERNTI should be present while going to FACH through connection setup on a HS-RACH cell*/
  if((FAILURE == rrcllc_evaluate_hs_rach_and_set_lower_layers_action(RRC_STATE_CELL_FACH,ordered_config_ptr)) ||
    ((rrchsrach_camped_cell_supports_hsrach()) && 
    (ordered_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present != TRUE)))
  {
    WRRC_MSG0_ERROR("HSRACH:Failed to configure HS-RACH");
    return FAILURE;
  }
#endif

  return (SUCCESS);
} /* rrcllc_chan_config_connecting_to_fach */


/*===========================================================================
FUNCTION   rrcllc_chan_config_to_re_enter_within_fach

DESCRIPTION
  This function is resposible for determining all actions on RLC, MAC
  and L1 when re-entering service area in Cell_FACH state.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static uecomdef_status_e_type
rrcllc_chan_config_to_re_enter_within_fach(rrc_cmd_type *cmd_ptr)
{

  rlc_lc_id_type        rlc_dl_log_chl_id; /* RLC downlink logical channel ID */
  uint8 i;
  rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;

  WRRC_MSG2_HIGH("Chan_config_re_enter_in_fach proc:rrc_proc_e_type_value%d, oc_status:rrcllc_oc_set_status_e_type_value%d",
           rrcllc_cmd_under_process.procedure,rrcllc_get_ordered_config_status_wo_f3());

  /* Update the variables in the ordered_config structure */
  if(rrcllc_update_oc_from_dch_to_fach_with_sibs()
       == FAILURE)
  {
    WRRC_MSG0_ERROR("Failure updating OC,for Reentering in FACH");
    return(FAILURE);
  }
  /* the above function copies URNTI only so copy CRNTI if the current camped
  cell is same as the one on which we detected oos */
  if (TRUE == rrc_ccm_cell_change_to_same_cell())
  {
    if (transition_config.toc_ptr->mac_dl_parms.rnti_info.rnti_valid == BOTH_VALID)
    {
      WRRC_MSG0_HIGH("copy both CRNTI & URNTI");
      /* copy the rnti information to both oc and cc */
      ordered_config_ptr->mac_dl_parms.rnti_info =
        transition_config.toc_ptr->mac_dl_parms.rnti_info;
      current_config_ptr->mac_dl_parms.rnti_info =
        transition_config.toc_ptr->mac_dl_parms.rnti_info;

      ordered_config_ptr->mac_ul_parms.rnti_info=
        transition_config.toc_ptr->mac_ul_parms.rnti_info;
      current_config_ptr->mac_ul_parms.rnti_info=
        transition_config.toc_ptr->mac_ul_parms.rnti_info;
    }

#ifdef FEATURE_WCDMA_HS_FACH
  /*Below operations are needed when a FACH->DCH configuration fails due to PHY CHAN SETUP, OOS will be triggered
   and if UE camps back on the same cell dedicated mode has to be configured to send the RBRC/PCRC/TCRC failure message.
      */ 
    if(rrcenhstate_camped_cell_supports_e_fach() && 
       rrccu_get_phy_chan_fail_indication()&&
       (transition_config.toc_ptr->efach_hrnti_status == DEDICATED_HRNTI))
    {
      ordered_config_ptr->efach_hrnti = transition_config.toc_ptr->efach_hrnti;
      ordered_config_ptr->efach_hrnti_status = transition_config.toc_ptr->efach_hrnti_status;
      WRRC_MSG1_HIGH("EFACH: Updated HRNTI from TOC to OC %d",ordered_config_ptr->efach_hrnti);

      if(FAILURE == rrcenhstate_evaluate_efach_and_set_lower_layers_action(
                                                        ordered_config_ptr,
                                                        RRC_STATE_CELL_FACH,
                                                        RRC_E_FACH_DEDICATED))
      {
        WRRC_MSG0_ERROR("EFACH:Failed to configure HS-FACH");
        return FAILURE;
      }
    }
#endif
#ifdef FEATURE_WCDMA_HS_RACH
      /*Changes to update the ERNTI and setup dedicated mode if we 
      camp back on the same cell after FACH to DCH physical channel failure and UE camps back on same cell*/
      if((rrchsrach_camped_cell_supports_hsrach() == TRUE) && 
        rrccu_get_phy_chan_fail_indication() &&
        (transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present == TRUE))
      {
        /*Restore E-RNTI from TOC to OC*/
        ordered_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = 
         transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present;
        ordered_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti = 
         transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti;

        /*Code to set common edch transmission flag and determine L1 and MAC action */

        /* The following code updates Dedicated mapping from Hanging RB to OC 
           This is required only for fach to dch phy channel failure. For all other rentry cases, we dont want
           to update HSRACH dedicated mappings to OC */
        if(FAILURE == rrcllc_evaluate_hs_rach_and_set_lower_layers_action(RRC_STATE_CELL_FACH,ordered_config_ptr))
        {
          WRRC_MSG0_ERROR("HSRACH:Failed to configure HS-RACH");
          return FAILURE;
        }
        
        rrcllc_determine_and_set_ready_for_common_edch(ordered_config_ptr,RRC_STATE_CELL_FACH);
      }
#endif
  }

#ifdef FEATURE_WCDMA_HS_RACH
  rrchsrach_set_hspa_rnti_stored_cell_pch(ordered_config_ptr,FALSE);
/*Reset ERNTI status in TOC*/
  transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = FALSE;
#endif

  rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id
  (
    UE_LOGCHAN_CCCH,
    CCCH_RADIO_BEARER_ID,
    UE_MODE_UNACKNOWLEDGED
  );
#ifdef FEATURE_WCDMA_HS_FACH
  /*Reset HRNTI status in TOC*/
  transition_config.toc_ptr->efach_hrnti_status = INVALID_HRNTI;

  if(rrcllc_get_hs_status_in_e_fach(ordered_config_ptr) == TRUE)
  {
    if (rlc_dl_log_chl_id == RRCLCM_RLC_LC_ID_ERROR)
    {
      (void)rrcenhstate_process_add_ccch();
    }
    else
    {
      (void)rrcenhstate_process_reconfig_ccch();
    }
  }
  else
#endif
  {
    if(rrcllc_semi_permanent_data.dl_phy_chan.fach_included == FALSE)
    {
      /* This is a wrong selection of SCCPCH that does not have FACH */
      WRRC_MSG0_ERROR("SCCPCH has no FACH included DCH->FACH");
      return(FAILURE);
    }
    else
    {
      if (rlc_dl_log_chl_id == RRCLCM_RLC_LC_ID_ERROR)
      {
        (void)rrcllc_process_add_ccch();
      }
      else
      {
        (void)rrcllc_process_reconfig_ccch();
      }
    }
  }

  //configure bcch on fach
  rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id
  (
    UE_LOGCHAN_BCCH,
    BCCH_FACH_RADIO_BEARER_ID,
    UE_MODE_TRANSPARENT
  );
#ifdef FEATURE_WCDMA_HS_FACH
  if(rrcllc_get_hs_status_in_e_fach(ordered_config_ptr))
  {
    if (rlc_dl_log_chl_id == RRCLCM_RLC_LC_ID_ERROR)
    {
      WRRC_MSG0_HIGH("Adding BCCH on HS-DSCH");
      (void)rrcenhstate_process_add_bcch_on_hsdsch();
    }
    else
    {
      WRRC_MSG0_HIGH("reconfig BCCH on HS-DSCH");
      (void)rrcenhstate_process_reconfig_bcch_on_hsdsch();
    }
  }
  else
#endif 
  {
    if (rlc_dl_log_chl_id == RRCLCM_RLC_LC_ID_ERROR)
    {
      WRRC_MSG0_HIGH("Adding BCCH on FACH");
      (void)rrcllc_process_add_bcch_on_fach();
    }
    else
    {
      WRRC_MSG0_HIGH("reconfig BCCH on FACH");
      (void)rrcllc_process_reconfig_bcch_on_fach();
    }
  }

#ifdef FEATURE_UMTS_PDCP
  /* Copy the saved PDCP info from TOC to OC*/
  rrcllc_copy_pdcp_parms(ordered_config_ptr, transition_config.toc_ptr);
  rrcllc_copy_pdcp_parms(current_config_ptr, transition_config.toc_ptr);
#endif /* FEATURE_UMTS_PDCP */

  /* now copy saved rlc info and rbmapping info from toc to oc */
  /* Copy all RLC Config data for AM channels */
  rrcllc_copy_rlc_parms(ordered_config_ptr, transition_config.toc_ptr);
  rrcllc_copy_rlc_parms(current_config_ptr, transition_config.toc_ptr);

    /* Save dcch+dtch mapping on fach/rach in to toc */
    rrcllc_copy_cell_fach_rb_mapping_info(ordered_config_ptr, transition_config.toc_ptr);
    rrcllc_copy_cell_fach_rb_mapping_info(current_config_ptr, transition_config.toc_ptr);

  ordered_config_ptr->rach_rlc_size_restriction_info.mac_update_needed = TRUE;
  /* Copy over the RB-oriented side of RLC size restrictions */
  rrcllc_copy_cell_fach_rlc_size_list(ordered_config_ptr, transition_config.toc_ptr);
  rrcllc_copy_cell_fach_rlc_size_list(current_config_ptr, transition_config.toc_ptr);

  /* Update the MAC layer with the newly copied RLC size restriction info */
  (void)rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, RRC_STATE_CELL_FACH);


  if(rrcllc_process_config_dcch_dtch(cmd_ptr) == FAILURE)
  {
    (void)rrcllc_build_cmd_and_release_lc_ids();   
    return(FAILURE);
  }

  /* Initialize Send MAC Uplink Config indicator to TRUE */
  rrcllc_semi_permanent_data.send_mac_uplink_config = TRUE;

  /* Indicate that both Downlink and Uplink MAC need to be reconfigured */
  ordered_config_ptr->reconfig_needed.downlink_mac = TRUE;
  ordered_config_ptr->reconfig_needed.uplink_mac = TRUE;

  /* Downlink Physical channel processing */

#ifdef FEATURE_WCDMA_HS_FACH
  if(rrcllc_get_hs_status_in_e_fach(ordered_config_ptr) == TRUE)
  {
    if(rrcenhstate_setup_phychan() == FAILURE)
    {
      ERR_FATAL("RRCENHST:Setting up HS PDSCH failed",0,0,0);
      return FAILURE;
    }
  }
  else
#endif /*FEATURE_WCDMA_HS_FACH*/
  {
    /* Fix the transport channel bitmasks for SCCPCH */
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
      L1_DL_TRCH_REFTYPE_FACH_BF;
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf |=
      L1_DL_TRCH_REFTYPE_FACH_BF;

    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf &=
      ~L1_DL_TRCH_REFTYPE_PCH_BF;

    if(rrcllc_semi_permanent_data.dl_phy_chan.pch_included)
    {
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
        L1_DL_TRCH_REFTYPE_PCH_BF;
    }
    else  /* No PCH on this SCCPCH */
    {
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf &=
        ~L1_DL_TRCH_REFTYPE_PCH_BF;
    }

    if(rrcllc_process_add_sccpch() == FAILURE)
    {
      WRRC_MSG0_ERROR ("Couldn't add SCCPCH");
      return FAILURE;
    }
  }

  /* Uplink Physical channel processing */

  /* This is a case for addition of PRACH */
  rrcllc_cmd_under_process.chan_config.phy_chan_action_list.prach_action =
    LLC_PHYCHAN_SETUP;

  MSG_LOW("LLC_PHYCHAN_SETUP on PRACH", 0, 0, 0);

  /* CHECK OUT THE RRC_CHANNEL_CONFIG_REQ command */
  for (i=0; i < cmd_ptr->cmd.chan_config_req.num_rb_to_config; i++)
  {
    /* Action allowed only on BCCH and CCCH. CCCH action in implicitely
     * done. Look for BCCH action here.
     */
    if((cmd_ptr->cmd.chan_config_req.rb[i].rb_id == BCCH_S_RADIO_BEARER_ID) &&
       (cmd_ptr->cmd.chan_config_req.rb[i].rb_config == RELEASE_RB))
    {
#ifndef FEATURE_UPDATE_SIB7_IN_FACH
      
      /* Release BCCH RB now */
      /* Set number of BCHs in MAC correctly */
      if(ordered_config_ptr->mac_dl_parms.num_bchs)
      {
        ordered_config_ptr->mac_dl_parms.num_bchs --;
      }

      /* Update number of transport channels on PCCPCH in L1 CCTrCH Parameters */
      rrcllc_semi_permanent_data.dl_phy_chan.pccpch.num_trch = 0;

      /* Release the BCCH logical channel */
      if (rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up) 
      {
        (void)rrcllc_process_drop_bcch_serving();
      }
      else
      {
        WRRC_MSG0_ERROR("BCCH not present: no need for drop");
        return FAILURE;
      }

      rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action =
        LLC_PHYCHAN_RELEASE;
      rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_ref_type_bf = 0;
      rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_enable_bf = 0;
      /* Add the CCTrCH ID for PCCPCH to the CCTrCH IDs to be released list */
      RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                            dl_phy_chan.pccpch.cctrch_id);

#else
#ifdef FEATURE_WCDMA_HS_RACH
      if(rrcsib_update_sib7_hs_rach() == TRUE)
#endif
      {
        /*
        Instead of Dropping PCCPCH, we DROP and ADD it
        */
        rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action =
           LLC_PHYCHAN_DROP_AND_ADD;
        if(rrcllc_update_spccpch_params_based_on_action(ordered_config_ptr)==FAILURE)
        {
          return (FAILURE);
        }
      }
#ifdef FEATURE_WCDMA_HS_RACH
      else
      {
        WRRC_MSG0_HIGH("RRCHSRACH: Skipping SIB7 update");
        /* Release BCCH RB now */
        /* Set number of BCHs in MAC correctly */
        if(ordered_config_ptr->mac_dl_parms.num_bchs)
        {
          ordered_config_ptr->mac_dl_parms.num_bchs --;
        }

        /* Update number of transport channels on PCCPCH in L1 CCTrCH Parameters */
        rrcllc_semi_permanent_data.dl_phy_chan.pccpch.num_trch = 0;
  
        /* Release the BCCH logical channel */
        if (rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up) 
        {
          (void)rrcllc_process_drop_bcch_serving();
        }
        else
        {
          WRRC_MSG0_ERROR("BCCH not present: no need for drop");
          return FAILURE;
        }
  
        rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action =
          LLC_PHYCHAN_RELEASE;
        rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_ref_type_bf = 0;
        rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_enable_bf = 0;
        /* Add the CCTrCH ID for PCCPCH to the CCTrCH IDs to be released list */
        RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                              dl_phy_chan.pccpch.cctrch_id);
      }
#endif
#endif /*FEATURE_UPDATE_SIB7_IN_FACH*/
    }
    else if((cmd_ptr->cmd.chan_config_req.rb[i].rb_id != CCCH_RADIO_BEARER_ID) &&
       (cmd_ptr->cmd.chan_config_req.rb[i].rb_config != NO_ACTION_ON_RB))
    {
      /* TBD: How to handle this invalid command ? Log an Error for now */
      MSG_MED("RB %d:Operation %d in RRC_CHANNEL_CONFIG_REQ re-entered in fach",
                cmd_ptr->cmd.chan_config_req.rb[i].rb_id,
                cmd_ptr->cmd.chan_config_req.rb[i].rb_config, 0);
    }
  } /* CHECK OUT THE RRC_CHANNEL_CONFIG_REQ command */

  return(SUCCESS);
} /* rrcllc_chan_config_to_re_enter_within_fach */


/*===========================================================================
FUNCTION   rrcllc_chan_config_dch_to_fach

DESCRIPTION
  This function is resposible for determining all actions on RLC, MAC
  and L1 when going from Cell_DCH to Cell_FACH state.
  Note: This function will only setup CCCH and the rest of RLC channels
  will be hooked to the pipes later, thru' explicit commands.
  This also expects a BCCH Drop request in Channel Config Request.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
uecomdef_status_e_type
rrcllc_chan_config_dch_to_fach(rrc_cmd_type *cmd_ptr)
{

  int     i;

  rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;

  WRRC_MSG2_HIGH("Chan_config_dch2fach proc:rrc_proc_e_type_value%d, oc_status:rrcllc_oc_set_status_e_type_value%d",
           rrcllc_cmd_under_process.procedure,rrcllc_get_ordered_config_status_wo_f3());
  /* Update the variables in the ordered_config structure */
  if(rrcllc_update_oc_from_dch_to_fach_with_sibs()
       == FAILURE)
  {
    WRRC_MSG0_ERROR("Failure updating OC, Discon->Connectng");
    return(FAILURE);
  }



  /*For NW triggered DCH to FACH transition case don't setup channels now itself. It will be setup later. eighter in last 
       channel config or channel config from CU */
  if(FALSE == rrcllc_check_dch_fach_reconfig_status())
    {
      if(FAILURE == rrcllc_setup_common_logical_channels_for_fach())
      {
        return(FAILURE);
      }
      if(FAILURE == rrcllc_setup_physical_channels_for_dch_to_fach())
      {
        return(FAILURE);
      }
    }


  MSG_LOW("LLC_PHYCHAN_SETUP on PRACH", 0, 0, 0);

  /* CHECK OUT THE RRC_CHANNEL_CONFIG_REQ command */
  for (i=0; i < cmd_ptr->cmd.chan_config_req.num_rb_to_config; i++)
  {
    /* Action allowed only on BCCH and CCCH. CCCH action in implicitely
     * done. Look for BCCH action here.
     */
    if((cmd_ptr->cmd.chan_config_req.rb[i].rb_id == BCCH_S_RADIO_BEARER_ID) &&
       (cmd_ptr->cmd.chan_config_req.rb[i].rb_config == RELEASE_RB))
    {
#ifndef FEATURE_UPDATE_SIB7_IN_FACH
      if(FALSE == rrcllc_check_dch_fach_reconfig_status())
      {
        /* Release BCCH RB now */
        /* Set number of BCHs in MAC correctly */
        if(ordered_config_ptr->mac_dl_parms.num_bchs)
        {
          ordered_config_ptr->mac_dl_parms.num_bchs --;
        }

        /* Update number of transport channels on PCCPCH in L1 CCTrCH Parameters */
        rrcllc_semi_permanent_data.dl_phy_chan.pccpch.num_trch = 0;

        /* Release the BCCH logical channel */
        if (rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up) 
        {
          (void)rrcllc_process_drop_bcch_serving();
        }
        else
        {
          WRRC_MSG0_ERROR("BCCH not present: no need for drop");
          return FAILURE;
        }

        rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action =
          LLC_PHYCHAN_RELEASE;
        rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_ref_type_bf = 0;
        rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_enable_bf = 0;
        /* Add the CCTrCH ID for PCCPCH to the CCTrCH IDs to be released list */
        RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                              dl_phy_chan.pccpch.cctrch_id);
      }
#else
#ifdef FEATURE_WCDMA_HS_RACH
        if(rrcsib_update_sib7_hs_rach() == TRUE)
#endif
        {
          if(TRUE == rrcllc_check_dch_fach_reconfig_status())
          {
            WRRC_MSG0_MED("dch_fach: SIB7 drop and add is not needed");
          }
          else
          {
            /*
            Instead of Dropping PCCPCH, we DROP and ADD it
            */
            rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action =
               LLC_PHYCHAN_DROP_AND_ADD;
      
            if(rrcllc_update_spccpch_params_based_on_action(ordered_config_ptr)==FAILURE)
            {
              return (FAILURE);
            }
          }
        }
#ifdef FEATURE_WCDMA_HS_RACH
        else
        {
          if(FALSE == rrcllc_check_dch_fach_reconfig_status())
          {
            WRRC_MSG0_HIGH("RRCHSRACH: Skipping SIB7 update");
            rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action =
                LLC_PHYCHAN_RELEASE;
            if(rrcllc_update_spccpch_params_based_on_action(ordered_config_ptr)==FAILURE)
            {
              return (FAILURE);
            } 
          }
        }
#endif
#endif /* FEATURE_UPDATE_SIB7_IN_FACH */
    }
    else if((cmd_ptr->cmd.chan_config_req.rb[i].rb_id != CCCH_RADIO_BEARER_ID) &&
       (cmd_ptr->cmd.chan_config_req.rb[i].rb_config != NO_ACTION_ON_RB))
    {
      /* TBD: How to handle this invalid command ? Log an Error for now */
      MSG_MED("RB %d:Operation %d in RRC_CHANNEL_CONFIG_REQ DCH->FACH",
                cmd_ptr->cmd.chan_config_req.rb[i].rb_id,
                cmd_ptr->cmd.chan_config_req.rb[i].rb_config, 0);
    }
  } /* CHECK OUT THE RRC_CHANNEL_CONFIG_REQ command */

  return(SUCCESS);
} /* rrcllc_chan_config_dch_to_fach */


/*===========================================================================
FUNCTION   rrcllc_chan_config_fach_to_pch_with_redirection

DESCRIPTION
  This function is resposible for determining all actions on RLC, MAC
  and L1 when going from Cell_FACH to Cell_PCH or URA_PCH state
  when Freq Redirection is present.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static uecomdef_status_e_type
rrcllc_chan_config_fach_to_pch_with_redirection (rrc_cmd_type *cmd_ptr)
{

  uint8   cctrch_id;
  int32   index;

  rlc_lc_id_type        rlc_dl_log_chl_id; /* RLC downlink logical channel ID */
  rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;

  WRRC_MSG2_HIGH("Chan_config_fach2pch with redirection proc:rrc_proc_e_type_value%d, oc_status:rrcllc_oc_set_status_e_type_value%d, CCM sent channel config request for FACH to PCH",
           rrcllc_cmd_under_process.procedure,rrcllc_get_ordered_config_status_wo_f3());

  rrcllc_copy_cc_to_oc();

    
  if((transition_config.toc_ptr->mac_ul_parms.rnti_info.rnti_valid == URNTI_VALID)
  ||(transition_config.toc_ptr->mac_ul_parms.rnti_info.rnti_valid == BOTH_VALID ))
  {
  
    WRRC_MSG0_HIGH("copy UNTNI to Ul MAC");
    /* Also copy the RNTI Info from TOC to OC */
    current_config_ptr->mac_ul_parms.rnti_info.urnti =
     transition_config.toc_ptr->mac_ul_parms.rnti_info.urnti;
    current_config_ptr->mac_ul_parms.rnti_info.rnti_valid = URNTI_VALID;
  
    ordered_config_ptr->mac_ul_parms.rnti_info.urnti=
     transition_config.toc_ptr->mac_ul_parms.rnti_info.urnti;
    ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = URNTI_VALID;
    
  }
  
  if((transition_config.toc_ptr->mac_dl_parms.rnti_info.rnti_valid == URNTI_VALID)
  ||(transition_config.toc_ptr->mac_dl_parms.rnti_info.rnti_valid == BOTH_VALID ))
  {
    WRRC_MSG0_HIGH("copy UNTNI to DL MAC");
    /* Also copy the RNTI Info from TOC to OC */
    current_config_ptr->mac_dl_parms.rnti_info.urnti =
     transition_config.toc_ptr->mac_dl_parms.rnti_info.urnti;
    current_config_ptr->mac_dl_parms.rnti_info.rnti_valid = URNTI_VALID;
  
    ordered_config_ptr->mac_dl_parms.rnti_info.urnti=
     transition_config.toc_ptr->mac_dl_parms.rnti_info.urnti;
    ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = URNTI_VALID;
    
  }
  
   
#ifdef FEATURE_WCDMA_HS_FACH
  rrcllc_copy_sib_to_oc_for_efach(rrcllc_cmd_under_process.next_rrc_state ,
                      RRC_E_FACH_COMMON);
#endif
  /* Update the variables in the ordered_config structure
   We need this because we have to read the SCCPCH info for PCCH again from SIB*/
  if(rrcllc_update_oc_from_fach_to_cell_pch_or_ura_pch(
    rrcllc_cmd_under_process.next_rrc_state)
       == FAILURE)
  {
    WRRC_MSG0_ERROR("Failure updating OC, FACH->PCH");
    return(FAILURE);
  }
  rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id
  (
    UE_LOGCHAN_PCCH,
    PCCH_RADIO_BEARER_ID,
    UE_MODE_TRANSPARENT
  );

  
  if(rrcllc_semi_permanent_data.dl_phy_chan.pch_included)
  {
    if (rlc_dl_log_chl_id == RRCLCM_RLC_LC_ID_ERROR)
    {
      (void)rrcllc_process_add_pcch();
    }
    else
    {
      (void)rrcllc_process_reconfig_pcch();
    }
  }
  else
  {
    WRRC_MSG0_ERROR("PCH not included for PCH transition");
    return(FAILURE);
  }
  

  /* add, drop, or reconfig ctch based on current cell */
  /* Add PCCH if it was not present before( in case of pch->fach channel
  config failure,  else reconfig*/
  if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status != RRCLLC_NO_CTCH)
  {
    /* ctch is present on this cell */
    rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id
    (
      UE_LOGCHAN_CTCH,
      CTCH_RADIO_BEARER_ID,
      UE_MODE_UNACKNOWLEDGED
    );

    if (rlc_dl_log_chl_id == RRCLCM_RLC_LC_ID_NOT_FOUND)
    {
      (void)rrcllc_process_add_ctch();
    }
    else
    {
      (void)rrcllc_process_reconfig_ctch();
    }
  }


  /* Initialize Send MAC Uplink Config indicator to TRUE */
  rrcllc_semi_permanent_data.send_mac_uplink_config = TRUE;

  /* Downlink Physical channel processing */

  /* Fix the transport channel bitmasks for SCCPCH */
  if(rrcllc_semi_permanent_data.dl_phy_chan.pch_included)
  {
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
      L1_DL_TRCH_REFTYPE_PCH_BF;
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf |=
      L1_DL_TRCH_REFTYPE_PCH_BF;
  }
  else  /* No PCH on this SCCPCH */
  {
    WRRC_MSG0_ERROR("No PCH info during FACH->PCH");
    return(FAILURE);
  }
  /* Now determine if OC has picked an SCCPCH that also carries FACH  */

  if(rrcllc_semi_permanent_data.dl_phy_chan.fach_included)
  {
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
      L1_DL_TRCH_REFTYPE_FACH_BF;
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf &=
      ~L1_DL_TRCH_REFTYPE_FACH_BF;
  }
  else
  {
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf &=
      ~L1_DL_TRCH_REFTYPE_FACH_BF;
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf &=
      ~L1_DL_TRCH_REFTYPE_FACH_BF;
  }
  
  if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status == RRCLLC_CTCH_WITH_PCCH)
  {
    /* both ctch and pcch are mapped on to same SCCPCH in this case we need to
    enable FACH */
    WRRC_MSG0_HIGH("ctch & pcch on same sccpch");
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf |=
      L1_DL_TRCH_REFTYPE_FACH_BF;
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
      L1_DL_TRCH_REFTYPE_FACH_BF;
  }
    /* Get a new CCTrCH ID */
  cctrch_id = rrcllc_get_cctrch_id();
  if(cctrch_id != RRCLLC_INVALID_CCTRCH_ID)
  {
    /* If PCH is present, update PCH info in Ordered Config with new CCTrCH ID */
    if(ordered_config_ptr->mac_dl_parms.num_pchs != 0)
    {
      ordered_config_ptr->mac_dl_parms.pch_info->cctrch_id = cctrch_id;
    }
    /* Update SCCPCH Info in rrcllc_cmd_under_process */
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.cctrch_id =
        cctrch_id;
  }
  else
  {
    WRRC_MSG1_ERROR("Invalid CCTrCH ID %d assigned", cctrch_id);
    return(FAILURE);
  }

  //drop bcch on fach

  (void)rrcllc_process_drop_bcch_on_fach();

  /* Drop CCCH */
  (void)rrcllc_process_drop_ccch();


#ifdef FEATURE_WCDMA_HS_FACH
  if(rrcllc_get_hs_status_in_e_fach(ordered_config_ptr) == FALSE)
#endif
  {
    /* Downlink Physical channel processing */

    WRRC_MSG0_HIGH("CCM Requested for FACH to PCH set SCCPCH Action as Setup");
    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_action =
      LLC_PHYCHAN_SETUP;

    /* check whether CTCH needs to be setup and whether
    different sccpch should be used for this CTCH */
    if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status == RRCLLC_CTCH_ON_DIF_SCCPCH)
    {
      rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_for_ctch_action =
        LLC_PHYCHAN_SETUP;

      rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_ref_type_bf |=
        L1_DL_TRCH_REFTYPE_FACH_BF;
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_enable_bf |=
        L1_DL_TRCH_REFTYPE_FACH_BF;

      if(rrcllc_semi_permanent_data.dl_phy_chan.pch_included_for_sccpch_with_ctch)
      {
        rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_ref_type_bf |=
          L1_DL_TRCH_REFTYPE_PCH_BF;
        rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_enable_bf &=
          ~L1_DL_TRCH_REFTYPE_PCH_BF;
      }
      else  /* No PCH on this SCCPCH */
      {
        rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_ref_type_bf &=
          ~L1_DL_TRCH_REFTYPE_PCH_BF;
        rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_enable_bf &=
          ~L1_DL_TRCH_REFTYPE_PCH_BF;
      }

      /* Get a new CCTrCH ID */
      cctrch_id = rrcllc_get_cctrch_id();

      if(cctrch_id != RRCLLC_INVALID_CCTRCH_ID)
      {
        /* If PCH is present, update PCH info in Ordered Config with new CCTrCH ID */
        if(ordered_config_ptr->mac_dl_parms.num_pchs != 0)
        /* Update FACH info in MAC Ordered Config */
        for(index = 0; index < ordered_config_ptr->mac_dl_parms.num_fachs; index ++)
        {
          ordered_config_ptr->mac_dl_parms.fach_info[index]->cctrch_id = cctrch_id;
        }
        /* Update SCCPCH Info in rrcllc_cmd_under_process */
        rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.cctrch_id =
          cctrch_id;
      }
      else
      {
        WRRC_MSG1_ERROR("Invalid CCTrCH ID %d assigned", cctrch_id);
        return(FAILURE);
      }
    }
  }


#ifdef FEATURE_UMTS_PDCP
  /* Build the command for PDCP_CONFIG_REQ*/
  rrcllc_process_config_pdcp(cmd_ptr);
  
#endif /* FEATURE_UMTS_PDCP*/

  if (ordered_config_ptr->activation_time)
  {
    WRRC_MSG1_HIGH("activation time %d in fach2pch. Ignoring",
       ordered_config_ptr->activation_time);
  }
  /* set the activation time to none */
  ordered_config_ptr->activation_time = 0;
  ordered_config_ptr->act_time_type = L1_ACTIVATION_TIME_NONE;

  MSG_HIGH("MAC dl_cfg num_fach %d, num_pch:%d,num_bch:%d",
           ordered_config_ptr->mac_dl_parms.num_fachs,
           ordered_config_ptr->mac_dl_parms.num_pchs,
           ordered_config_ptr->mac_dl_parms.num_bchs);
  
  if(ordered_config_ptr->l1_dl_cctrch_parms.num_trch > 0)
  {
    MSG_HIGH("L1 dl_cfg cctrch_type %d, ccch_en:%d,last_trchid:%d",
           ordered_config_ptr->l1_dl_cctrch_parms.cctrch_id,
           ordered_config_ptr->l1_dl_cctrch_parms.num_trch,
           ordered_config_ptr->l1_dl_cctrch_parms.trch_info_array[ordered_config_ptr->l1_dl_cctrch_parms.num_trch-1]->trch_id);
  }

  if ((ordered_config_ptr->mac_dl_parms.num_pchs<MAC_DL_MAX_CCTRCH) &&
      ( ordered_config_ptr->mac_dl_parms.num_pchs>0))
  {
    for (index=0; index<ordered_config_ptr->mac_dl_parms.num_pchs; index++)
    {
      WRRC_MSG2_HIGH("MAC PCH cctrch_id %d, pcch_id:%d",
               ordered_config_ptr->mac_dl_parms.pch_info[index].cctrch_id,
               ordered_config_ptr->mac_dl_parms.pch_info[index].pcch_id);
    }
  }
  if ((ordered_config_ptr->mac_dl_parms.num_fachs<UE_MAX_TRCH) &&
      ( ordered_config_ptr->mac_dl_parms.num_fachs>0))
  {
    for (index=0; index<ordered_config_ptr->mac_dl_parms.num_fachs; index++)
    {
      MSG_HIGH("MAC FACH ccch_enable %d, ndlchan:%d,trchid:%d",
               ordered_config_ptr->mac_dl_parms.fach_info[index]->ccch_enable,
               ordered_config_ptr->mac_dl_parms.fach_info[index]->ndlchan,
               ordered_config_ptr->mac_dl_parms.fach_info[index]->trch_id);
    }
  }
  
  MSG_6(MSG_SSID_DFLT, MSG_LEGACY_HIGH,"MAC ul_cfg cctrch_type %d, ccch_en:%d,ndlchan:%d,L1 ul_cfg cctrch_type %d, ccch_en:%d ",
           ordered_config_ptr->mac_ul_parms.cctrch_ptr->cctrch_type,
           ordered_config_ptr->mac_ul_parms.cctrch_ptr->rach_info.ccch_enable,
           ordered_config_ptr->mac_ul_parms.cctrch_ptr->rach_info.ndlchan,
           ordered_config_ptr->l1_ul_cctrch_parms.chan,
           ordered_config_ptr->l1_ul_cctrch_parms.num_trch, 0);
  {
    /*If CCM has requested for FACH to PCH */
    int i=0;
    for (i=0; i < cmd_ptr->cmd.chan_config_req.num_rb_to_config; i++)
    {
      if((cmd_ptr->cmd.chan_config_req.rb[i].rb_id == BCCH_S_RADIO_BEARER_ID) &&
         (cmd_ptr->cmd.chan_config_req.rb[i].rb_config == RELEASE_RB))
      {
        /* Release BCCH RB now */
        /* Set number of BCHs in MAC correctly */
        if(ordered_config_ptr->mac_dl_parms.num_bchs)
        {
          ordered_config_ptr->mac_dl_parms.num_bchs --;
        }

        /* Update number of transport channels on PCCPCH in L1 CCTrCH Parameters */
        rrcllc_semi_permanent_data.dl_phy_chan.pccpch.num_trch = 0;

        /* Release the BCCH logical channel */
        if (rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up) 
        {
          (void)rrcllc_process_drop_bcch_serving();
        }
        else
        {
          WRRC_MSG0_ERROR("BCCH not present: no need for drop");
          return FAILURE;
        }

        rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action =
          LLC_PHYCHAN_RELEASE;
        rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_ref_type_bf = 0;
        rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_enable_bf = 0;
        /* Add the CCTrCH ID for PCCPCH to the CCTrCH IDs to be released list */
        RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                              dl_phy_chan.pccpch.cctrch_id);
      }
    }
  }

#ifdef FEATURE_WCDMA_HS_RACH
      
  rrcllc_copy_sib_to_oc_for_hsrach(RRC_STATE_CELL_PCH);
      
  WRRC_MSG2_HIGH("RRCHSRACH:FACH->PCH with redirection ready_for_common_edch in OC = %d.hspa_rnti_stored_cell_pch in TOC %d",
    ordered_config_ptr->ready_for_common_edch,transition_config.toc_ptr->hspa_rnti_stored_cell_pch);

  /*Copy HRNTI/ERNTI from TOC for FACH to PCH redirection case into OC.*/

    WRRC_MSG2_HIGH("HSRACH:HRNTI status = %d, ERNTI status in TOC = %d",transition_config.toc_ptr->efach_hrnti_status, transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present);
  
    if(transition_config.toc_ptr->efach_hrnti_status == DEDICATED_HRNTI)
    {
      ordered_config_ptr->efach_hrnti_status = current_config_ptr->efach_hrnti_status = transition_config.toc_ptr->efach_hrnti_status;
    }

    
    if(transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present == TRUE)
    {
      ordered_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = 
      current_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = 
      transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present;
    }

    /*Copy hspa_rnti_stored_cell_pch from TOC. The value set during OTA processing will be available in TOC and not in OC*/
    ordered_config_ptr->hspa_rnti_stored_cell_pch =  transition_config.toc_ptr->hspa_rnti_stored_cell_pch;
  
  /*Determine the 2 variables while always going into PCH state*/
      rrcllc_determine_and_set_ready_for_common_edch(ordered_config_ptr,rrcllc_cmd_under_process.next_rrc_state);
    
    if(rrccsp_is_selected_cell_utran_directed())
    {
      rrcllc_check_and_invalidate_hspa_rnti_stored_cell_pch(ordered_config_ptr,rrcllc_cmd_under_process.next_rrc_state);
    }
    else
    {
      rrchsrach_set_hspa_rnti_stored_cell_pch(ordered_config_ptr, FALSE);
  }
#endif

  return(SUCCESS);
} /* rrcllc_chan_config_fach_to_cell_pch_or_ura_pch */

/*===========================================================================
FUNCTION   rrcllc_chan_config_dch_to_pch

DESCRIPTION
  This function is resposible for determining all actions on RLC, MAC
  and L1 when going from Cell_DCH to Cell_PCH or URA_PCH state.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
uecomdef_status_e_type
rrcllc_chan_config_dch_to_pch(rrc_cmd_type *cmd_ptr)
{
  uint8   cctrch_id;
  int     i;

  rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;

  WRRC_MSG2_HIGH("Chan_config_dch2pch proc:rrc_proc_e_type_value%d, oc_status:rrcllc_oc_set_status_e_type_value%d",
           rrcllc_cmd_under_process.procedure,rrcllc_get_ordered_config_status_wo_f3());

  /* Update the variables in the ordered_config structure */
  if(rrcllc_update_oc_from_dch_to_pch_with_sibs(rrcllc_cmd_under_process.next_rrc_state)
       == FAILURE)
  {
    WRRC_MSG0_ERROR("Failure updating OC, DCH->PCH");
    return(FAILURE);
  }

    /* Add PCCH */
  (void)rrcllc_process_add_pcch();
 

  if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status != RRCLLC_NO_CTCH)
  {
    (void)rrcllc_process_add_ctch();
  }

  /* Initialize Send MAC Uplink Config indicator to TRUE */
  /* rrcllc_semi_permanent_data.send_mac_uplink_config = TRUE; */

  
  /* Fix the transport channel bitmasks for SCCPCH */
  if(rrcllc_semi_permanent_data.dl_phy_chan.pch_included)
  {
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
      L1_DL_TRCH_REFTYPE_PCH_BF;
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf |=
      L1_DL_TRCH_REFTYPE_PCH_BF;
  }
  else  /* No PCH on this SCCPCH */
  {
    WRRC_MSG0_ERROR("No PCH mapped on SCCPCH");
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf &=
      ~L1_DL_TRCH_REFTYPE_PCH_BF;
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf &=
      ~L1_DL_TRCH_REFTYPE_PCH_BF;
  }

  /* Now determine if OC has picked an SCCPCH that also carries FACH
     If FACH mappping is present then keep the reference for L1 but
     disable the FACH*/
  rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf &=
    ~L1_DL_TRCH_REFTYPE_FACH_BF;

  if(rrcllc_semi_permanent_data.dl_phy_chan.fach_included)
  {
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
      L1_DL_TRCH_REFTYPE_FACH_BF;
  }
  else
  {
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf &=
      ~L1_DL_TRCH_REFTYPE_FACH_BF;
  }

  if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status == RRCLLC_CTCH_WITH_PCCH)
  {
    /* both ctch and pcch are mapped on to same SCCPCH in this case we need to
      enable FACH */
    WRRC_MSG0_HIGH("ctch & pcch on same sccpch");
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf |=
      L1_DL_TRCH_REFTYPE_FACH_BF;
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
      L1_DL_TRCH_REFTYPE_FACH_BF;
  }

  /* Get a new CCTrCH ID */
  cctrch_id = rrcllc_get_cctrch_id();
  if(cctrch_id != RRCLLC_INVALID_CCTRCH_ID)
  {
    /* If PCH is present, update PCH info in Ordered Config with new CCTrCH ID */
    if(ordered_config_ptr->mac_dl_parms.num_pchs != 0)
    {
      ordered_config_ptr->mac_dl_parms.pch_info->cctrch_id = cctrch_id;
    }
    if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status == RRCLLC_CTCH_WITH_PCCH)
    {
      /* Update FACH info in MAC Ordered Config */
      for(i = 0; i < ordered_config_ptr->mac_dl_parms.num_fachs; i ++)
      {
        ordered_config_ptr->mac_dl_parms.fach_info[i]->cctrch_id = cctrch_id;
      }
    }
    /* Update SCCPCH Info in rrcllc_cmd_under_process */
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.cctrch_id =
        cctrch_id;
  }
  else
  {
    WRRC_MSG1_ERROR("Invalid CCTrCH ID %d assigned", cctrch_id);
    return(FAILURE);
  }


  MSG_LOW("LLC_PHYCHAN_SETUP on SCCPCH", 0, 0, 0);

  rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_action =
    LLC_PHYCHAN_SETUP;
 

  /* check whether CTCH needs to be setup and whether
  different sccpch should be used for this CTCH */
  if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status == RRCLLC_CTCH_ON_DIF_SCCPCH)
  {
    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_for_ctch_action =
      LLC_PHYCHAN_SETUP;

    rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_ref_type_bf |=
      L1_DL_TRCH_REFTYPE_FACH_BF;
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_enable_bf |=
      L1_DL_TRCH_REFTYPE_FACH_BF;

    if(rrcllc_semi_permanent_data.dl_phy_chan.pch_included_for_sccpch_with_ctch)
    {
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_ref_type_bf |=
        L1_DL_TRCH_REFTYPE_PCH_BF;
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_enable_bf &=
        ~L1_DL_TRCH_REFTYPE_PCH_BF;
    }
    else  /* No PCH on this SCCPCH */
    {
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_ref_type_bf &=
        ~L1_DL_TRCH_REFTYPE_PCH_BF;
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_enable_bf &=
        ~L1_DL_TRCH_REFTYPE_PCH_BF;
    }

    /* Get a new CCTrCH ID */
    cctrch_id = rrcllc_get_cctrch_id();

    if(cctrch_id != RRCLLC_INVALID_CCTRCH_ID)
    {
      /* If PCH is present, update PCH info in Ordered Config with new CCTrCH ID */
      if(ordered_config_ptr->mac_dl_parms.num_pchs != 0)
      /* Update FACH info in MAC Ordered Config */
      for(i = 0; i < ordered_config_ptr->mac_dl_parms.num_fachs; i ++)
      {
        ordered_config_ptr->mac_dl_parms.fach_info[i]->cctrch_id = cctrch_id;
      }
      /* Update SCCPCH Info in rrcllc_cmd_under_process */
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.cctrch_id =
        cctrch_id;
    }
    else
    {
      WRRC_MSG1_ERROR("Invalid CCTrCH ID %d assigned", cctrch_id);
      return(FAILURE);
    }
  }


  /* Uplink Physical channel processing */

  /* CHECK OUT THE RRC_CHANNEL_CONFIG_REQ command */
  for (i=0; i < cmd_ptr->cmd.chan_config_req.num_rb_to_config; i++)
  {
    /* Action allowed only on BCCH and CCCH. CCCH action in implicitely
     * done. Look for BCCH action here.
     */
    if((cmd_ptr->cmd.chan_config_req.rb[i].rb_id == BCCH_S_RADIO_BEARER_ID) &&
       (cmd_ptr->cmd.chan_config_req.rb[i].rb_config == RELEASE_RB))
    {
      /* Release BCCH RB now */
      /* Set number of BCHs in MAC correctly */
      if(ordered_config_ptr->mac_dl_parms.num_bchs)
      {
        ordered_config_ptr->mac_dl_parms.num_bchs --;
      }

      /* Update number of transport channels on PCCPCH in L1 CCTrCH Parameters */
      rrcllc_semi_permanent_data.dl_phy_chan.pccpch.num_trch = 0;

      /* Release the BCCH logical channel */
      if (rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up) 
      {
        (void)rrcllc_process_drop_bcch_serving();
      }
      else
      {
        WRRC_MSG0_ERROR("BCCH not present: no need for drop");
        return FAILURE;
      }

      rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action =
        LLC_PHYCHAN_RELEASE;
      rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_ref_type_bf = 0;
      rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_enable_bf = 0;
      /* Add the CCTrCH ID for PCCPCH to the CCTrCH IDs to be released list */
      RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                            dl_phy_chan.pccpch.cctrch_id);
    }
  } /* CHECK OUT THE RRC_CHANNEL_CONFIG_REQ command */

#ifdef FEATURE_WCDMA_HS_RACH

    WRRC_MSG4_HIGH("RRCHSRACH:DCH->PCH ready_for_common_edch  = %d.TOC hspa_rnti_stored_cell_pch %d, HRNTI status = %d, ERNTI status:%d",
      ordered_config_ptr->ready_for_common_edch,transition_config.toc_ptr->hspa_rnti_stored_cell_pch,
      transition_config.toc_ptr->efach_hrnti_status, transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present);

  /*Copy HRNTI/ERNTI from TOC for FACH to PCH redirection case into OC.*/
    
  WRRC_MSG2_MED("HSRACH:HRNTI status = %d, ERNTI status in TOC = %d",transition_config.toc_ptr->efach_hrnti_status, transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present);
  
  if(transition_config.toc_ptr->efach_hrnti_status == DEDICATED_HRNTI)
  {
    ordered_config_ptr->efach_hrnti_status = current_config_ptr->efach_hrnti_status = transition_config.toc_ptr->efach_hrnti_status;
  }
    

  if(transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present == TRUE)
  {
    ordered_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = 
      current_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = 
      transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present;
  }
  
  /*Copy hspa_rnti_stored_cell_pch from TOC. The value set during OTA processing will be available in TOC and not in OC*/
  ordered_config_ptr->hspa_rnti_stored_cell_pch =  transition_config.toc_ptr->hspa_rnti_stored_cell_pch;
  
  /*Determine the 2 variables while always going into PCH state*/
  rrcllc_determine_and_set_ready_for_common_edch(ordered_config_ptr,rrcllc_cmd_under_process.next_rrc_state);

  if(rrccsp_is_selected_cell_utran_directed())
  {
    rrcllc_check_and_invalidate_hspa_rnti_stored_cell_pch(ordered_config_ptr,rrcllc_cmd_under_process.next_rrc_state);
  }
  else
  {
    rrchsrach_set_hspa_rnti_stored_cell_pch(ordered_config_ptr, FALSE);
  }

#endif

  return(SUCCESS);
} /* rrcllc_chan_config_dch_to_pch */


/*===========================================================================
FUNCTION   rrcllc_chan_config_fach_to_pch

DESCRIPTION
  This function is resposible for determining all actions on RLC, MAC
  and L1 when going from Cell_FACH to Cell_PCH or URA_PCH state.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static uecomdef_status_e_type
rrcllc_chan_config_fach_to_pch (rrc_cmd_type *cmd_ptr)
{

  uint8   cctrch_id;
  int32   index;

#ifdef FEATURE_WCDMA_HS_FACH
  rrc_proc_e_type proc_id = RRC_PROCEDURE_NONE;
  rrcllc_oc_process_state_e_type process_state;
  rrcllc_oc_set_status_e_type oc_status;
#endif

  rlc_lc_id_type        rlc_dl_log_chl_id; /* RLC downlink logical channel ID */
  rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;

  WRRC_MSG2_HIGH("Chan_config_fach2pch proc:rrc_proc_e_type_value%d, oc_status:rrcllc_oc_set_status_e_type_value%d",
           rrcllc_cmd_under_process.procedure,rrcllc_get_ordered_config_status_wo_f3());
  if (rrcllc_get_ordered_config_status_wo_f3() == OC_NOT_SET)
  {
    /* channel configuration is called without setting ordered_config
    copy cc to oc. Otherwise oc will be updated while setting ordered_config*/
    rrcllc_copy_cc_to_oc();
  }

#ifdef FEATURE_WCDMA_HS_FACH
  if(rrcenhstate_camped_cell_supports_e_fach())
  {
    rrcenhstate_stop_efach_if_active();
  }
#endif

#ifdef FEATURE_WCDMA_HS_RACH
  /* Normally hsrach stop happens when handling the OTA itself. For the special case, when we receive HRNTI and transition to PCH,
    first channel config is update HRNTI at L1/MAC. For this case, we are stopping hsrach here*/
  if (ordered_config_ptr->mac_hs_rach_action != MAC_HS_RACH_STOP)
  {
    rrchsrach_set_hsrach_action_to_stop_if_active(FALSE);
  }
#endif
 
#ifdef FEATURE_WCDMA_HS_FACH
  /*Take actions related to EFACH HSDPA when CUCNF is taking us to PCH state
  and if OC is set by any other procedure other than CU*/
  oc_status = rrcllc_get_ordered_config_state_and_proc_wo_f3(&proc_id, &process_state);

  if( (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CU) && 
    ((oc_status == OC_NOT_SET) || (proc_id != RRC_PROCEDURE_CU)))
  {
    /*Common mode confuguration: shouldnt update sib5 be done*/
    if(rrcenhstate_evaluate_efach_and_set_lower_layers_action(
         ordered_config_ptr,cmd_ptr->cmd.chan_config_req.next_state,RRC_E_FACH_DEDICATED) == FAILURE)
    {
      WRRC_MSG0_ERROR("EPCH configuration failed");
    }
  }
#endif/*FEATURE_WCDMA_HS_FACH*/

  if((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CCM)&&
    (rrcllc_cmd_under_process.chan_config.chan_config_reason==RRCLLC_CHAN_CFG_REASON_FACH_TO_PCH)
    )
  {
     return(rrcllc_chan_config_fach_to_pch_with_redirection(cmd_ptr));
  }

  /* Update the variables in the ordered_config structure
   We need this because we have to read the SCCPCH info for PCCH again from SIB*/
  if(rrcllc_update_oc_from_fach_to_cell_pch_or_ura_pch(
    rrcllc_cmd_under_process.next_rrc_state)
       == FAILURE)
  {
    WRRC_MSG0_ERROR("Failure updating OC, FACH->PCH");
    return(FAILURE);
  }

  rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id
  (
    UE_LOGCHAN_PCCH,
    PCCH_RADIO_BEARER_ID,
    UE_MODE_TRANSPARENT
  );

  
  if(rrcllc_semi_permanent_data.dl_phy_chan.pch_included)
  {
    if (rlc_dl_log_chl_id == RRCLCM_RLC_LC_ID_ERROR)
    {
      (void)rrcllc_process_add_pcch();
    }
    else
    {
      (void)rrcllc_process_reconfig_pcch();
    }
  }
  else
  {
    WRRC_MSG0_ERROR("PCH not included for PCH transition");
    return(FAILURE);
  }
 

  /* add, drop, or reconfig ctch based on current cell */
  /* Add PCCH if it was not present before( in case of pch->fach channel
  config failure,  else reconfig*/
  if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status != RRCLLC_NO_CTCH)
  {
    /* ctch is present on this cell */
    rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id
    (
      UE_LOGCHAN_CTCH,
      CTCH_RADIO_BEARER_ID,
      UE_MODE_UNACKNOWLEDGED
    );

    if (rlc_dl_log_chl_id == RRCLCM_RLC_LC_ID_NOT_FOUND)
    {
      (void)rrcllc_process_add_ctch();
    }
    else
    {
      (void)rrcllc_process_reconfig_ctch();
    }
  }


  /* Initialize Send MAC Uplink Config indicator to TRUE */
  rrcllc_semi_permanent_data.send_mac_uplink_config = TRUE;

    /* Fix the transport channel bitmasks for SCCPCH */
  if(rrcllc_semi_permanent_data.dl_phy_chan.pch_included)
  {
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
      L1_DL_TRCH_REFTYPE_PCH_BF;
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf |=
      L1_DL_TRCH_REFTYPE_PCH_BF;
  }
  else  /* No PCH on this SCCPCH */
  {
    WRRC_MSG0_ERROR("No PCH info during FACH->PCH");
    return(FAILURE);
  }
  /* Now determine if OC has picked an SCCPCH that also carries FACH  */

  if(rrcllc_semi_permanent_data.dl_phy_chan.fach_included)
  {
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
      L1_DL_TRCH_REFTYPE_FACH_BF;
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf &=
      ~L1_DL_TRCH_REFTYPE_FACH_BF;
  }
  else
  {
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf &=
      ~L1_DL_TRCH_REFTYPE_FACH_BF;
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf &=
      ~L1_DL_TRCH_REFTYPE_FACH_BF;
  } //CRC: Check bitmask for FACH
  if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status == RRCLLC_CTCH_WITH_PCCH)
  {
    /* both ctch and pcch are mapped on to same SCCPCH in this case we need to
    enable FACH */
    WRRC_MSG0_HIGH("ctch & pcch on same sccpch");
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf |=
      L1_DL_TRCH_REFTYPE_FACH_BF;
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
      L1_DL_TRCH_REFTYPE_FACH_BF;
  }


#ifdef FEATURE_WCDMA_HS_FACH
  if( (rrcllc_get_hs_status_in_e_fach(current_config_ptr) == TRUE))
  {
    if(rrcenhstate_release_phychan(RRC_E_FACH_DEDICATED) == FAILURE)
    {
      ERR_FATAL("RRCENHST:Error dropping HS PDSCH ",0,0,0);
    }
    if(rrcllc_process_add_sccpch() == FAILURE) //CRC_DEEPTI: Check if bitmask added is right
    {
      ERR_FATAL("RRCENHST:HS SCCPCH setup failed",0,0,0);
    }
  }
  else
#endif
  {
    (void)rrcllc_process_reconfigure_sccpch();
  }

  //drop bcch on fach

  (void)rrcllc_process_drop_bcch_on_fach();

  (void)rrcllc_process_drop_ccch();

  /* check whether CTCH needs to be setup and whether
  different sccpch should be used for this CTCH */
  if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status == RRCLLC_CTCH_ON_DIF_SCCPCH)
  {
    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_for_ctch_action =
      LLC_PHYCHAN_SETUP;

    rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_ref_type_bf |=
      L1_DL_TRCH_REFTYPE_FACH_BF;
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_enable_bf |=
      L1_DL_TRCH_REFTYPE_FACH_BF;

    if(rrcllc_semi_permanent_data.dl_phy_chan.pch_included_for_sccpch_with_ctch)
    {
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_ref_type_bf |=
        L1_DL_TRCH_REFTYPE_PCH_BF;
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_enable_bf &=
        ~L1_DL_TRCH_REFTYPE_PCH_BF;
    }
    else  /* No PCH on this SCCPCH */
    {
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_ref_type_bf &=
        ~L1_DL_TRCH_REFTYPE_PCH_BF;
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_enable_bf &=
        ~L1_DL_TRCH_REFTYPE_PCH_BF;
    }

    /* Get a new CCTrCH ID */
    cctrch_id = rrcllc_get_cctrch_id();

    if(cctrch_id != RRCLLC_INVALID_CCTRCH_ID)
    {
      /* If PCH is present, update PCH info in Ordered Config with new CCTrCH ID */
      /*CRC_DEEPTI:When rrcllc_process_reconfigure_sccpch is called, a CCTrCH id is set to FACH. It will be over-written here. 
      Should be fine here but should be sure that it doesnt happen for any other case.*/
      if(ordered_config_ptr->mac_dl_parms.num_pchs != 0)
      /* Update FACH info in MAC Ordered Config */
      for(index = 0; index < ordered_config_ptr->mac_dl_parms.num_fachs; index ++)
      {
        ordered_config_ptr->mac_dl_parms.fach_info[index]->cctrch_id = cctrch_id;
      }
      /* Update SCCPCH Info in rrcllc_cmd_under_process */
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.cctrch_id =
        cctrch_id;
    }
    else
    {
      WRRC_MSG1_ERROR("Invalid CCTrCH ID %d assigned", cctrch_id);
      return(FAILURE);
    }
  }

  /* Uplink physical channel processing */
  /* This is a case for deletion of PRACH */
  rrcllc_cmd_under_process.chan_config.phy_chan_action_list.prach_action =
    LLC_PHYCHAN_RELEASE;

  MSG_LOW("LLC_PHYCHAN_RELEASE for PRACH", 0, 0, 0);
  /* this channel config can be due to OTA message. Check whether
  No of RBs are more than 2. If so then it has dcch/dtch rbs. So
  configure them */
  /* Determine hspa_rnti_stored_cell_pch before calling config dcch dtch as this varible is used in config dcch dtch */  
#ifdef FEATURE_WCDMA_HS_RACH
    WRRC_MSG2_HIGH("RRCHSRACH:FACH->PCH on hs-rach cell  ready_for_common_edch  = %d.hspa_rnti_stored_cell_pch %d",
      ordered_config_ptr->ready_for_common_edch,ordered_config_ptr->hspa_rnti_stored_cell_pch);
      
    rrcllc_determine_and_set_ready_for_common_edch(ordered_config_ptr,rrcllc_cmd_under_process.next_rrc_state);
    
    rrcllc_check_and_invalidate_hspa_rnti_stored_cell_pch(ordered_config_ptr,rrcllc_cmd_under_process.next_rrc_state);
#endif
  /* Config_dcch_dtch should be called if hspa rnti is true so that RLC gets re-established */
  if ((cmd_ptr->cmd.chan_config_req.num_rb_to_config>2) ||
      (TRUE == ordered_config_ptr->hspa_rnti_stored_cell_pch))
  {
    if (rrcllc_process_config_dcch_dtch(cmd_ptr) == FAILURE)
    {
      (void)rrcllc_build_cmd_and_release_lc_ids(); 
      WRRC_MSG0_ERROR("FAILURE in config dcch dtch");
      return FAILURE;
    }
  }


#ifdef FEATURE_UMTS_PDCP
  /* Build the command for PDCP_CONFIG_REQ*/
  rrcllc_process_config_pdcp(cmd_ptr);
#endif /* FEATURE_UMTS_PDCP*/

  if (ordered_config_ptr->activation_time)
  {
  WRRC_MSG1_HIGH("activation time %d in fach2pch. Ignoring",
       ordered_config_ptr->activation_time);
  }
  /* set the activation time to none */
  ordered_config_ptr->activation_time = 0;
  ordered_config_ptr->act_time_type = L1_ACTIVATION_TIME_NONE;

  WRRC_MSG3_MED("MAC dl_cfg num_fach %d, num_pch:%d,num_bch:%d",
           ordered_config_ptr->mac_dl_parms.num_fachs,
           ordered_config_ptr->mac_dl_parms.num_pchs,
           ordered_config_ptr->mac_dl_parms.num_bchs);
  if(ordered_config_ptr->l1_dl_cctrch_parms.num_trch > 0)
  {
    WRRC_MSG3_MED("L1 dl_cfg cctrch_type %d, ccch_en:%d,last_trchid:%d",
             ordered_config_ptr->l1_dl_cctrch_parms.cctrch_id,
             ordered_config_ptr->l1_dl_cctrch_parms.num_trch,
             ordered_config_ptr->l1_dl_cctrch_parms.trch_info_array[ordered_config_ptr->l1_dl_cctrch_parms.num_trch-1]->trch_id);
  }

  if ((ordered_config_ptr->mac_dl_parms.num_pchs<MAC_DL_MAX_CCTRCH) &&
      ( ordered_config_ptr->mac_dl_parms.num_pchs>0))
  {
    for (index=0; index<ordered_config_ptr->mac_dl_parms.num_pchs; index++)
    {
      WRRC_MSG2_MED("MAC PCH cctrch_id %d, pcch_id:%d",
               ordered_config_ptr->mac_dl_parms.pch_info[index].cctrch_id,
               ordered_config_ptr->mac_dl_parms.pch_info[index].pcch_id);
    }
  }
  if ((ordered_config_ptr->mac_dl_parms.num_fachs<UE_MAX_TRCH) &&
      ( ordered_config_ptr->mac_dl_parms.num_fachs>0))
  {
    for (index=0; index<ordered_config_ptr->mac_dl_parms.num_fachs; index++)
    {
      WRRC_MSG3_MED("MAC FACH ccch_enable %d, ndlchan:%d,trchid:%d",
               ordered_config_ptr->mac_dl_parms.fach_info[index]->ccch_enable,
               ordered_config_ptr->mac_dl_parms.fach_info[index]->ndlchan,
               ordered_config_ptr->mac_dl_parms.fach_info[index]->trch_id);
    }
  }
  
  WRRC_MSG6_MED("MAC ul_cfg cctrch_type %d, ccch_en:%d,ndlchan:%d, L1 ul_cfg cctrch_type %d, ccch_en:%d",
           ordered_config_ptr->mac_ul_parms.cctrch_ptr->cctrch_type,
           ordered_config_ptr->mac_ul_parms.cctrch_ptr->rach_info.ccch_enable,
           ordered_config_ptr->mac_ul_parms.cctrch_ptr->rach_info.ndlchan,
           ordered_config_ptr->l1_ul_cctrch_parms.chan,
           ordered_config_ptr->l1_ul_cctrch_parms.num_trch, 0);

  if((ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid == CRNTI_VALID) ||
    (ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid == BOTH_VALID))
  {
    WRRC_MSG1_HIGH("CRNTI in OC %d on FACH->PCH transition",ordered_config_ptr->mac_dl_parms.rnti_info.crnti);
  }

  if((current_config_ptr->mac_dl_parms.rnti_info.rnti_valid == CRNTI_VALID) ||
    (current_config_ptr->mac_dl_parms.rnti_info.rnti_valid == BOTH_VALID))
  {
    WRRC_MSG1_HIGH("CRNTI in CC %d on FACH->PCH transition",current_config_ptr->mac_dl_parms.rnti_info.crnti);
  }
  
#ifdef FEATURE_UPDATE_SIB7_IN_FACH
  /*
  Drop PCCPCH if the Current Event is SIB7 Event
  */
  if(rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up)
  {
    if(rrc_sib_can_s_bcch_torndown_in_fach_to_pch_transition() == TRUE)
    {
      rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action =
          LLC_PHYCHAN_RELEASE;
      if(rrcllc_update_spccpch_params_based_on_action(ordered_config_ptr)==FAILURE)
      {
        return (FAILURE);
      }
    }
  }

#endif /* FEATURE_UPDATE_SIB7_IN_FACH */

  return(SUCCESS);
} /* rrcllc_chan_config_fach_to_cell_pch_or_ura_pch */

/*===========================================================================
FUNCTION   rrcllc_chan_config_dch_to_discon

DESCRIPTION
  This function is resposible for determining all actions on RLC, MAC
  and L1.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static uecomdef_status_e_type
rrcllc_chan_config_dch_to_discon(rrc_cmd_type *cmd_ptr)
{
  rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_RELEASE_ALL_CHAN_ENGINE;
  WRRC_MSG2_HIGH("Chan_config_dch2discon proc:rrc_proc_e_type_value%d, oc_status:rrcllc_oc_set_status_e_type_value%d",
           rrcllc_cmd_under_process.procedure,rrcllc_get_ordered_config_status_wo_f3());
  /* All RLC channels need to be dropped through a single command */
  /* In this case, a CPHY_IDLE_REQ needs to be sent to L1. No need to store
   * it anywhere since there are no parameters.
   */
  return(SUCCESS);
} /*lint !e715  Unused function parameter: cmd_ptr */

/*===========================================================================
FUNCTION   rrcllc_chan_config_fach_to_discon

DESCRIPTION
  This function is resposible for determining all actions on RLC, MAC
  and L1.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static uecomdef_status_e_type
rrcllc_chan_config_fach_to_discon(rrc_cmd_type *cmd_ptr)
{
  rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_RELEASE_ALL_CHAN_ENGINE;
  WRRC_MSG2_HIGH("Chan_config_fach2discon proc:rrc_proc_e_type_value%d, oc_status:rrcllc_oc_set_status_e_type_value%d",
           rrcllc_cmd_under_process.procedure,rrcllc_get_ordered_config_status_wo_f3());
  /* All RLC channels need to be dropped through a single command */
  /* In this case, a CPHY_IDLE_REQ needs to be sent to L1. No need to store
   * it anywhere since there are no parameters.
   */

  return(SUCCESS);
} /*lint !e715  Unused function parameter: cmd_ptr */

/*===========================================================================
FUNCTION   rrcllc_chan_config_connecting_to_discon

DESCRIPTION
  This function is resposible for determining all actions on RLC, MAC
  and L1.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static uecomdef_status_e_type
rrcllc_chan_config_connecting_to_discon(rrc_cmd_type *cmd_ptr)
{
  rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_RELEASE_ALL_CHAN_ENGINE;
  /* All RLC channels need to be dropped through a single command */
  /* In this case, a CPHY_IDLE_REQ needs to be sent to L1. No need to store
   * it anywhere since there are no parameters.
   */

  return(SUCCESS);
} /*lint !e715  Unused function parameter: cmd_ptr */

/*===========================================================================
FUNCTION   rrcllc_chan_config_within_dch

DESCRIPTION
  This function is resposible for determining all actions on RLC, MAC
  and L1.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static uecomdef_status_e_type
rrcllc_chan_config_within_dch(rrc_cmd_type *cmd_ptr)
{
  uint8   dl_cctrch_id = RRCLLC_INVALID_CCTRCH_ID;
  int     dch_count;
  int     rb_index;
  rlc_lc_id_type rlc_dl_log_chl_id;
  uint8 dflow_cnt = 0;
  hsdpa_action_enum_type hs_action;
  rrc_hsdpa_status_enum_type hs_status;
  uint8 queue_cnt=0;
  uint32 pnpos;
  WRRC_MSG2_HIGH("Chan_config_within_dch proc:rrc_proc_e_type_value%d, oc_status:rrcllc_oc_set_status_e_type_value%d",
           rrcllc_cmd_under_process.procedure,rrcllc_get_ordered_config_status_wo_f3());
  if((cmd_ptr->cmd.chan_config_req.procedure == RRC_PROCEDURE_CSP)
#ifdef FEATURE_DUAL_SIM
      /* During unlcok by scan don't handle Channel config req here, rather it is handled as part of IHO*/
      && !((rrccsp_get_curr_scan() == RRC_CSP_UNLOCK_BY_SCAN)
      && (cmd_ptr->cmd.chan_config_req.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP))
#endif
    )
  {
    if((cmd_ptr->cmd.chan_config_req.release_trchls) &&
       (cmd_ptr->cmd.chan_config_req.release_phychls))
    {
    /* This is a special case for releasing only physical and
     * transport channels, keeping the logical channels as they are.
     */
      rrcllc_cmd_under_process.chan_config.current_cmd_engine =
        LLC_RELEASE_TR_PHY_CHAN_ENGINE;
      rrcllc_copy_cc_to_oc();
      /* Initailize MAC data to release all Transport Channels */
      rrcllc_init_ordered_config_mac_info(ORDERED_CONFIG);

      /* Indicate that both Downlink and Uplink MAC need to be reconfigured */
      ordered_config_ptr->reconfig_needed.downlink_mac = TRUE;
      ordered_config_ptr->reconfig_needed.uplink_mac = TRUE;

      /* Return from here as no other data in Channel Config Request
       * is relevant.
       */
      WRRC_MSG0_HIGH("Released Phy and Tr Chls");
      return(SUCCESS);
    }
    else if((cmd_ptr->cmd.chan_config_req.rb[0].rb_id == BCCH_S_RADIO_BEARER_ID) &&
              (cmd_ptr->cmd.chan_config_req.rb[0].rb_config == RELEASE_RB))
    {
      rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;
      rrcllc_cmd_under_process.chan_config.solo_bch_operation = TRUE;

      /* Set number of BCHs in MAC correctly */
      if(current_config_ptr->mac_dl_parms.num_bchs)
      {
        current_config_ptr->mac_dl_parms.num_bchs --;
      }

      /* Update number of transport channels on PCCPCH in L1 CCTrCH Parameters */
      rrcllc_semi_permanent_data.dl_phy_chan.pccpch.num_trch = 0;

      if (rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up) 
      {
        (void)rrcllc_process_drop_bcch_serving();
      }
      else
      {
        WRRC_MSG0_ERROR("BCCH not present: no need for drop");
        return FAILURE;
      }
      rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_ref_type_bf = 0;
      rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_enable_bf = 0;
      rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action =
        LLC_PHYCHAN_RELEASE;

      /* Add the CCTrCH ID for PCCPCH to the CCTrCH IDs to be released list */
      RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                            dl_phy_chan.pccpch.cctrch_id);

      /* Return from here as no other data in Channel Config Request
       * is relevant.
       */
      WRRC_MSG0_HIGH("Released Serving BCCH pipe");
      return(SUCCESS);
    }
    else
    {
      WRRC_MSG0_ERROR("Unexpected Chan config from CSP");
      return(FAILURE);
    }
  }


  rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;

  if(cmd_ptr->cmd.chan_config_req.procedure == RRC_PROCEDURE_ASU)
  {
    /* No need to do anything except setting of Active Set Update flag */
    /* No need to configure DL L1 as it copies data and doesn't use pointers
     * to access data.
     */
    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.dl_dpch_action =
      LLC_PHYCHAN_NO_OP;
    /* Reconfig UL L1 to put it on new database */
    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.ul_dpch_action =
      LLC_PHYCHAN_RECONFIG;

    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.aset_update = TRUE;
#ifdef FEATURE_WCDMA_DC_HSUPA
    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sec_eul_aset_update = ordered_config_ptr->sec_ul_asu;
#endif /* FEATURE_WCDMA_DC_HSUPA */
    /* Do not reconfigure Downlink L1 at this point, only an ASET UPDATE */
    /* Pointers are not accessed by L1 DL - so not an issue */
    ordered_config_ptr->reconfig_needed.downlink_l1 = FALSE;

    /* Reconfigure Uplink L1 to put it on new database */
    ordered_config_ptr->reconfig_needed.uplink_l1 = TRUE;

    /* The following ensure that CMAC_CONFIG_REQs go to MAC DL and UL */
    ordered_config_ptr->reconfig_needed.downlink_mac = TRUE;
    ordered_config_ptr->reconfig_needed.uplink_mac = TRUE;

    MSG_LOW("ASet Update from ASU proc", 0, 0, 0);
    if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
    {
      if (rrc_get_hsdpa_status() == HSDPA_ACTIVE)
      {
        rrcllc_set_hsdpa_l1_info_in_cmd_under_process(ordered_config_ptr);
      }
    }
  }
  else if(cmd_ptr->cmd.chan_config_req.procedure == RRC_PROCEDURE_LBT)
  {
    /* Special handling for loopback mode.
     * Loopback Mode 1:
     * In this case, only L1 command is
     * to be sent. That too will only update the Loopback mode for each of the
     * DL Transport Channels that is mapped to a User plane RB. The CCTrCH ID of
     * the already established DPCH is given in the command. The request mask
     * indicates the presence of loopback mode update. All other pointers
     * are NULL.
     * Lopback Mode 2:
     * In this mode,a check is made to ensure that all User RBs are TM mode.
     * For all UL TrCHs, CRC length is set to 0.
     */
    MSG_LOW("Loopback mode %d update",
            cmd_ptr->cmd.chan_config_req.lb_test_mode, 0, 0);
    if((cmd_ptr->cmd.chan_config_req.lb_test_mode != LB_TEST_MODE_1) &&
       (cmd_ptr->cmd.chan_config_req.lb_test_mode != LB_TEST_MODE_2))
    {
      WRRC_MSG1_ERROR("Invalid Loopback mode %d",
          cmd_ptr->cmd.chan_config_req.lb_test_mode);
      return(FAILURE);
    }

    /* Process Loopback mode */
    /* First copy CC to OC and then update OC */
    if(config_ptr_in_use != ORDERED_CONFIG)
    {
      rrcllc_copy_cc_to_oc();
    }

    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.dl_dpch_action =
      LLC_PHYCHAN_SET_LBT_MODE;

    rrcllc_cmd_under_process.chan_config.lb_test_mode =
      cmd_ptr->cmd.chan_config_req.lb_test_mode;

    rrcllc_cmd_under_process.chan_config.dummy_signaling_enabled =
      cmd_ptr->cmd.chan_config_req.dummy_signaling_enabled;

    /* Always reconfigure L1 Uplink and MAC UL */
    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.ul_dpch_action =
      LLC_PHYCHAN_RECONFIG;

    ordered_config_ptr->reconfig_needed.uplink_l1 = TRUE;
    ordered_config_ptr->reconfig_needed.uplink_mac = TRUE;

  }
  else if((cmd_ptr->cmd.chan_config_req.procedure == RRC_PROCEDURE_SIB) &&
          (((rrcllc_get_ordered_config_status_wo_f3() == OC_SET_FOR_DCH_FACH_TRANS)
           || (rrcllc_get_ordered_config_status_wo_f3() == OC_SET_FOR_DCH_CELL_PCH_TRANS)
           || (rrcllc_get_ordered_config_status_wo_f3() == OC_SET_FOR_DCH_URA_PCH_TRANS)
           )
          ||(transition_config.toc_usage == TOC_FOR_OOS)
          ))
  {
    if(rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_SIB_READ_IN_DCH)
    {
      if((cmd_ptr->cmd.chan_config_req.rb[0].rb_id == BCCH_S_RADIO_BEARER_ID) &&
         (cmd_ptr->cmd.chan_config_req.rb[0].rb_config == ESTABLISH_RB))
      {
        /* 
          SIB Procedure requests for setting up S-BCCH for reading the sibs to get the cell id
          OC is set, so SIB event is already inited so dont bring the channel, By pass the request
        */
        WRRC_MSG1_ERROR("RRCGPS:Return failure for S-BCCH setup as OC is set and status is %d",rrcllc_get_ordered_config_status_wo_f3());
        return (FAILURE);
      }
      else if((cmd_ptr->cmd.chan_config_req.rb[0].rb_id == BCCH_S_RADIO_BEARER_ID) &&
              (cmd_ptr->cmd.chan_config_req.rb[0].rb_config == RELEASE_RB))
      {
        /*
          SIB has requested to drop S-BCCH, because of sib event being inited. Drop the channel if it is already up
        */
        if((rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up == TRUE) &&
           (rrclcm_check_dl_rlc_lc_id(UE_LOGCHAN_BCCH,BCCH_S_RADIO_BEARER_ID,UE_MODE_TRANSPARENT)!=
            RRCLCM_RLC_LC_ID_NOT_FOUND))
        {
          rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;
          rrcllc_cmd_under_process.chan_config.solo_bch_operation = TRUE;
          if((config_ptr_in_use == ORDERED_CONFIG)&&
             (ordered_config.process_state == LL_CONFIG_WITH_OC))
          {
            WRRC_MSG0_HIGH("RRCGPS:Copy OC  to CC for solo BCH Operation ");
            rrcllc_copy_oc_to_cc();
          }
          WRRC_MSG0_HIGH("RRCGPS: DROP S-BCCH");
          /* Set number of BCHs in MAC correctly */
          if(current_config_ptr->mac_dl_parms.num_bchs)
          {
            current_config_ptr->mac_dl_parms.num_bchs --;
          }
    
          /* Update number of transport channels on PCCPCH in L1 CCTrCH Parameters */
          rrcllc_semi_permanent_data.dl_phy_chan.pccpch.num_trch = 0;
          (void)rrcllc_process_drop_bcch_serving();
          rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_ref_type_bf = 0;
          rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_enable_bf = 0;
          rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action =
            LLC_PHYCHAN_RELEASE;
          
          /* Add the CCTrCH ID for PCCPCH to the CCTrCH IDs to be released list */
          RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                                dl_phy_chan.pccpch.cctrch_id);
          
          /* Return from here as no other data in Channel Config Request
           * is relevant.
           */
          return(SUCCESS);
        }
        else
        {
          WRRC_MSG0_HIGH("S-BCCH is not present, NO need to config L1");
          /*If S-BCCH is not present then do not act on the request, just by pass the request*/
          rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_BYPASS_ENGINE;
          return (SUCCESS);
        }
      }
    }
    /* If this is a Channel Config Request from SIB during DCH->FACH
     * transition, accept it and process it.
     */
    if((cmd_ptr->cmd.chan_config_req.rb[0].rb_id == BCCH_S_RADIO_BEARER_ID) &&
       (cmd_ptr->cmd.chan_config_req.rb[0].rb_config == ESTABLISH_RB))
    {
      rrcllc_cmd_under_process.chan_config.solo_bch_operation = TRUE;

      /* Set the Activation Time to "Now" */
      rrcllc_init_activation_time(current_config_ptr);

      /* Set number of BCHs in MAC correctly */
      current_config_ptr->mac_dl_parms.num_bchs = 1;

      /* Update number of transport channels on PCCPCH in L1 CCTrCH Parameters */
      rrcllc_semi_permanent_data.dl_phy_chan.pccpch.num_trch = 1;

      /* Add BCCH */
      rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id
        (
          UE_LOGCHAN_BCCH,
          BCCH_S_RADIO_BEARER_ID,
          UE_MODE_TRANSPARENT
        );
      if (rlc_dl_log_chl_id == RRCLCM_RLC_LC_ID_NOT_FOUND) 
      {
        (void)rrcllc_process_add_bcch_serving(current_config_ptr);
      }
      else
      {
        (void)rrcllc_process_reconfig_bcch_serving(current_config_ptr);
      }
      /* Get PCCPCH channel parameters from Cell Selection into Ordered Config */
      rrccsp_get_serving_pccpch_parms(&current_config_ptr->l1_dl_chan_parms.pccpch.scr_code,
                                      &current_config_ptr->l1_dl_chan_parms.pccpch.tx_div_ind
                                     );

      /* A BCCH has been added in DL => Setup PCCPCH */

      rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action =
        LLC_PHYCHAN_SETUP;
      /* Update PCCPCH info in rrcllc_semi_permanent_data.dl_phy_chan */
      rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_ref_type_bf =
          L1_DL_TRCH_REFTYPE_SBCH_BF;
      rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_enable_bf =
          L1_DL_TRCH_REFTYPE_SBCH_BF;

      /* Get a new CCTrCH ID */
      dl_cctrch_id = rrcllc_get_cctrch_id();

      /*Fixing the Array Out of Bound Error from KW*/
      if((dl_cctrch_id != RRCLLC_INVALID_CCTRCH_ID) &&
        (current_config_ptr->mac_dl_parms.num_bchs != 0) &&
        (current_config_ptr->mac_dl_parms.num_bchs <= MAC_DL_MAX_CCTRCH))
      {
        /* Update BCH info in MAC Ordered Config */
        current_config_ptr->mac_dl_parms.
          bch_info[current_config_ptr->mac_dl_parms.num_bchs-1].cctrch_id =
        dl_cctrch_id;

        /* Update PCCPCH Info in rrcllc_cmd_under_process */
        rrcllc_semi_permanent_data.dl_phy_chan.pccpch.cctrch_id = dl_cctrch_id;

        /* Indicate that Downlink MAC needs to be reconfigured */
        current_config_ptr->reconfig_needed.downlink_mac = TRUE;
        /* Indicate that Downlink L1 needs to be reconfigured */
        current_config_ptr->reconfig_needed.downlink_l1 = TRUE;

        MSG_LOW("LLC_PHYCHAN_SETUP for PCCPCH", 0, 0, 0);
      }
      else
      {
        WRRC_MSG1_ERROR("Invalid CCTrCH ID %d assigned", dl_cctrch_id);
        return(FAILURE);
      }
    } /* If Serving BCCH add found */
  } /* If SIB sends a Channel Config Request during DCH->FACH transition */
  else if((cmd_ptr->cmd.chan_config_req.procedure == RRC_PROCEDURE_SIB) && 
           ((rrcllc_get_ordered_config_status_wo_f3() == OC_SET_FOR_CELL_DCH) ||
           ((rrc_get_state() == RRC_STATE_CELL_DCH) && (rrcllc_get_ordered_config_status() == OC_NOT_SET))))
  { 
    /* This condition is added to address a scenario where
       SIB is trying to tear down SBCCH during the window
       of on going CHANNEL_CONFIG_REQ & CHANNEL_CONFIG_CNF phase 
       to transition to DCH & so this request that was buffered is being 
       attended to now. Generic mechanism to trash the SIB request & sending 
       failure back */
    if(rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_SIB_READ_IN_DCH)
    {
      if((cmd_ptr->cmd.chan_config_req.rb[0].rb_id == BCCH_S_RADIO_BEARER_ID) &&
        (cmd_ptr->cmd.chan_config_req.rb[0].rb_config == ESTABLISH_RB))
      {
        if(rrcllc_get_ordered_config_status() == OC_SET_FOR_CELL_DCH)
        {
          /*
          SIB Procedure requests for setting up S-BCCH for reading the sibs to get the cell id
          OC is set, so SIB event is already inited so dont bring the channel, By pass the request
          */
          if (rrc_sib_get_proc_id_for_sib_read_in_dch() == RRC_PROCEDURE_GPS) 
          {
            WRRC_MSG1_ERROR("RRCGPS:Return failure for S-BCCH setup as OC is set %d",
                     rrcllc_get_ordered_config_status_wo_f3());
            return (FAILURE);
          }
        }

        WRRC_MSG0_HIGH("RRCGPS:OC is not Set so setup S-BCCH");
        rrcllc_cmd_under_process.chan_config.solo_bch_operation = TRUE;
        /* Set the Activation Time to "Now" */
        rrcllc_init_activation_time(current_config_ptr);
        /* Set number of BCHs in MAC correctly */
        current_config_ptr->mac_dl_parms.num_bchs ++;
        /* Update number of transport channels on PCCPCH in L1 CCTrCH Parameters */
        rrcllc_semi_permanent_data.dl_phy_chan.pccpch.num_trch = 1;
        /* Add BCCH */
        rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id
          (
            UE_LOGCHAN_BCCH,
            BCCH_S_RADIO_BEARER_ID,
            UE_MODE_TRANSPARENT
          );
        if (rlc_dl_log_chl_id == RRCLCM_RLC_LC_ID_NOT_FOUND) 
        {
          if(rrcllc_process_add_bcch_serving(current_config_ptr) == FAILURE)
          {
            if(current_config_ptr->mac_dl_parms.num_bchs != 0)
            {
              WRRC_MSG1_HIGH("DBG_GPS_CELL_ID: Num of BCH in CC %d ",
                        current_config_ptr->mac_dl_parms.num_bchs);
              current_config_ptr->mac_dl_parms.num_bchs--;
              rrcllc_semi_permanent_data.dl_phy_chan.pccpch.num_trch =0;
            }
          }
        }
        else
        {
          if(rrcllc_process_reconfig_bcch_serving(current_config_ptr)  == FAILURE)
          {
            if(current_config_ptr->mac_dl_parms.num_bchs != 0)
            {
              WRRC_MSG1_HIGH("DBG_GPS_CELL_ID: Num of BCH in CC %d ",
                        current_config_ptr->mac_dl_parms.num_bchs);
              current_config_ptr->mac_dl_parms.num_bchs--;
              rrcllc_semi_permanent_data.dl_phy_chan.pccpch.num_trch =0;
            }
          }
        }
       /*
        *  Here call the l1 Function to get th PSC of the cell
        */
          (void)l1_get_hs_psc_sib_read((uint16 *)&current_config_ptr->l1_dl_chan_parms.pccpch.scr_code, &pnpos);

         rrcgps_set_psc_for_cell_id_req(current_config_ptr->l1_dl_chan_parms.pccpch.scr_code);

        WRRC_MSG1_HIGH("The PSC for S-BCCH Setup is %d",current_config_ptr->l1_dl_chan_parms.pccpch.scr_code);
        current_config_ptr->l1_dl_chan_parms.pccpch.tx_div_ind = TRUE;
        rrcllc_cmd_under_process.chan_config.new_freq = FALSE;
#ifdef FEATURE_WCDMA_DC_HSUPA
        rrcllc_cmd_under_process.chan_config.sec_eul_new_freq = FALSE;
#endif /* FEATURE_WCDMA_DC_HSUPA */


        /* A BCCH has been added in DL => Setup PCCPCH */
        rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action =
          LLC_PHYCHAN_SETUP;
          /* Update PCCPCH info in rrcllc_semi_permanent_data.dl_phy_chan */
        rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_ref_type_bf =
          L1_DL_TRCH_REFTYPE_SBCH_BF;
        rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_enable_bf =
          L1_DL_TRCH_REFTYPE_SBCH_BF;
        /* Get a new CCTrCH ID */
        dl_cctrch_id = rrcllc_get_cctrch_id();

        /*Fixing the Array Out of Bound Error from KW*/
        if((dl_cctrch_id != RRCLLC_INVALID_CCTRCH_ID) &&
          (current_config_ptr->mac_dl_parms.num_bchs != 0) &&
          (current_config_ptr->mac_dl_parms.num_bchs <= MAC_DL_MAX_CCTRCH))
        {
          /* Update BCH info in MAC Ordered Config */
          current_config_ptr->mac_dl_parms.
            bch_info[current_config_ptr->mac_dl_parms.num_bchs-1].cctrch_id =
            dl_cctrch_id;
          /* Update PCCPCH Info in rrcllc_cmd_under_process */
          rrcllc_semi_permanent_data.dl_phy_chan.pccpch.cctrch_id = dl_cctrch_id;
          /* Indicate that Downlink MAC needs to be reconfigured */
          current_config_ptr->reconfig_needed.downlink_mac = TRUE;
          /* Indicate that Downlink L1 needs to be reconfigured */
          current_config_ptr->reconfig_needed.downlink_l1 = TRUE;
          MSG_LOW("LLC_PHYCHAN_SETUP for PCCPCH", 0, 0, 0);
        }
        else
        {
          WRRC_MSG1_ERROR("Invalid CCTrCH ID %d assigned", dl_cctrch_id);
          return(FAILURE);
        }
        return (SUCCESS);
        
      }
      else if((cmd_ptr->cmd.chan_config_req.rb[0].rb_id == BCCH_S_RADIO_BEARER_ID) &&
        (cmd_ptr->cmd.chan_config_req.rb[0].rb_config == RELEASE_RB))
      {
        /*
          SIB has requested to drop S-BCCH, because of sib event being inited. Drop the channel if it is already up
        */
        if((rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up == TRUE) &&
            (rrclcm_check_dl_rlc_lc_id(UE_LOGCHAN_BCCH,BCCH_S_RADIO_BEARER_ID,UE_MODE_TRANSPARENT)!=
                RRCLCM_RLC_LC_ID_NOT_FOUND))
        {
          rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;
          rrcllc_cmd_under_process.chan_config.solo_bch_operation = TRUE;
          if((config_ptr_in_use == ORDERED_CONFIG)&&
            (ordered_config.process_state == LL_CONFIG_WITH_OC))
          {
           WRRC_MSG0_HIGH("RRCGPS:Copy OC  to CC for solo BCH Operation ");
            rrcllc_copy_oc_to_cc();
          }
          /* Set number of BCHs in MAC correctly */
          if(current_config_ptr->mac_dl_parms.num_bchs)
          {
            current_config_ptr->mac_dl_parms.num_bchs --;
          }
          /* Update number of transport channels on PCCPCH in L1 CCTrCH Parameters */
          rrcllc_semi_permanent_data.dl_phy_chan.pccpch.num_trch = 0;
          (void)rrcllc_process_drop_bcch_serving();
          rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_ref_type_bf = 0;
          rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_enable_bf = 0;
          rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action =
            LLC_PHYCHAN_RELEASE;
    
          /* Add the CCTrCH ID for PCCPCH to the CCTrCH IDs to be released list */
          RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                                dl_phy_chan.pccpch.cctrch_id);
    
          /* Return from here as no other data in Channel Config Request
           * is relevant.
           */
          return(SUCCESS);
        }
        else
        {
          /*If S-BCCH is not present then do not act on the request, just by pass the request*/
          WRRC_MSG0_HIGH("RRCGPS:S-BCCH is not present");
          rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_BYPASS_ENGINE;
          return (SUCCESS);
        }
      }
    }

    WRRC_MSG1_ERROR("Invalid channel config req from SIB %d",
          cmd_ptr->cmd.chan_config_req.chan_config_reason);
    return(FAILURE);
  }

  /* Handover to GSM failed, transitioning back to WCDMA mode */
  else if ((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_IHO)
#ifdef FEATURE_DUAL_SIM
  /* During unlcok by scan handle Channel config here as IHO*/
          || ((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)
              &&(rrccsp_get_curr_scan() == RRC_CSP_UNLOCK_BY_SCAN)
              && (cmd_ptr->cmd.chan_config_req.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP))
#endif

    )
  {
    rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;

    /* Copy Current Config to Ordered Config when procedure is IHO */
    rrcllc_copy_cc_to_oc();
    ordered_config_ptr->mac_ul_parms.new_tfcs_list_present = TRUE;
    /* Set the Activation Time to "Now" */
    rrcllc_init_activation_time(ordered_config_ptr);

    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.dl_dpch_action =
      LLC_PHYCHAN_SETUP;
    /* Since a new DPCH is being established, initialize the Transport channel
     * bitflag to DCH
     */
    rrcllc_semi_permanent_data.dl_phy_chan.dl_dpch.trch_ref_type_bf =
          L1_DL_TRCH_REFTYPE_DCH_BF;
    rrcllc_semi_permanent_data.dl_phy_chan.dl_dpch.trch_enable_bf =
          L1_DL_TRCH_REFTYPE_DCH_BF;

     /* If the num dchs is zero the cctrch_id doesn't have valid value*/
    if(ordered_config_ptr->mac_dl_parms.num_dchs > 0)
    {
    /* Use the existing CCTrCH ID copied from current config */
    dl_cctrch_id = ordered_config_ptr->mac_dl_parms.dch_info[0]->cctrch_id;
    if(dl_cctrch_id != RRCLLC_INVALID_CCTRCH_ID)
    {
      /* Update DPCH Info in rrcllc_cmd_under_process - this presumes that
       * there is only 1 DPCH
       */
      rrcllc_semi_permanent_data.dl_phy_chan.dl_dpch.cctrch_id =
        dl_cctrch_id;
    }
    else
    {
      WRRC_MSG1_ERROR("Invalid DL CCTrCH ID %d assigned", dl_cctrch_id);
      return(FAILURE);
    }
    }

    MSG_LOW("LLC_PHYCHAN_SETUP for DL DPCH", 0, 0, 0);

    if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
    {
      hs_status = rrc_get_hsdpa_status();
      if (hs_status == HSDPA_INACTIVE)
      {
        WRRC_MSG0_HIGH("RRCHS:HSDPA Inactive. Not to be Resumed");
        ordered_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_NOOP;
        ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator = FALSE;
        rrc_set_hsdpa_action(HSDPA_NOOP);
        ordered_config_ptr->mac_dl_parms.mac_hs_transition_type= MAC_HS_NO_TRANSITION;
        ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs= MAC_HS_TYPE_INVALID;
        ordered_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_NOOP;
      }
      else
      {
        WRRC_MSG0_HIGH("RRCHS:hsdparesume, Set CCTRCH ID");
        if (rrcllc_check_if_hsdpa_can_be_started_reconfigured(ordered_config_ptr) == FALSE)
        {
          WRRC_MSG0_ERROR("RRCHS:hsdparesumefailure");
          ordered_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_NOOP;
          ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator = FALSE;
          rrc_set_hsdpa_action(HSDPA_NOOP);
          ordered_config_ptr->mac_dl_parms.mac_hs_transition_type= MAC_HS_NO_TRANSITION;
          ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs= MAC_HS_TYPE_INVALID;
          ordered_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_NOOP;
        }
        else
        {
          if(ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_HS_TYPE_INVALID)
          {
            WRRC_MSG0_ERROR("MACEHS:Invalid Type, though HSDPA is ACTIVE ");
            return FAILURE;
          }
          else if(ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_EHS)
          {
            WRRC_MSG0_HIGH("MACEHS: Type is EHS");
            ordered_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_START;
            ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator = FALSE;
            rrc_set_hsdpa_action(HSDPA_START);
            ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs = MAC_EHS;
            ordered_config_ptr->mac_dl_parms.mac_hs_transition_type = MAC_HS_NO_TRANSITION;
          }
          else
          {
            ordered_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_START;
            WRRC_MSG0_HIGH("MACEHS: Type is HS");
            ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs = MAC_HS;
            ordered_config_ptr->mac_dl_parms.mac_hs_transition_type = MAC_HS_NO_TRANSITION;
            ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator = FALSE;
            rrc_set_hsdpa_action(HSDPA_START);
          }
          ordered_config_ptr->l1_hsdpa_info.hs_req_mask = CPHY_HS_DSCH_CFG_INCL |
            CPHY_HS_PDSCH_RL_CFG_INCL | CPHY_HS_SCCH_CFG_INCL | CPHY_HS_DPCCH_CFG_INCL;
#ifdef FEATURE_WCDMA_MIMO
          if(rrcllc_get_mimo_status() == RRC_MIMO_ACTIVE)
          {
            WRRC_MSG0_HIGH("MIMO: Set MIMO action to START");
            ordered_config_ptr->l1_hsdpa_info.hs_req_mask |=CPHY_HS_MIMO_CFG_INCL;
            ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_START;
          }
          else
          {
            ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_NOOP;
          }
#endif

#ifdef FEATURE_WCDMA_DC_HSDPA
          /*This is the case of W->G HO Failure where DC-HSDPA was up earlier.*/
          /*All the W-> G Ho failures has to be tested in Target and UT*/
          /*OC should be having the sec HS params , If not take from CC */
          if(rrcllcpcie_return_num_sec_hsdpa_carriers(ordered_config_ptr) > 0)
          {
            /*Other bit masks will be set due top generic logic of RECONFIG of HSDPA.*/
            ordered_config_ptr->l1_hsdpa_info.hs_req_mask |=CPHY_HS_SEC_HSDPA_CFG_INCL;
            WRRC_MSG0_HIGH("DC-HSDPA: Sec hs_req_mask included ");	
          }
#endif /*FEATURE_WCDMA_DC_HSDPA*/

          /* Set beta table and hs-dpcch bit mask */
          ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 
            HS_DPCCH_BETA_HS_INFO_PRESENT_BITMASK | HS_DPCCH_MEAS_FEEDBACK_INFO_PRESENT_BITMASK;
          WRRC_MSG1_MED("RRCHS:Set CCTrCh Id %d in L1 structure",ordered_config_ptr->mac_dflow_info[0].cctrch_id);

          /* Set CCTRCH in L1 HSDSCH information */
          if(ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_EHS)
          {
            ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.cctrch_id = 
                ordered_config_ptr->mac_ehs_queue_info[0].cctrch_id;
          }
          else
          {
            ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.cctrch_id = 
              ordered_config_ptr->mac_dflow_info[0].cctrch_id;
          }
          WRRC_MSG0_MED("RRCHS:Setting HSDPA L1 Info");
          rrcllc_set_hsdpa_l1_info_in_cmd_under_process(ordered_config_ptr);
        }
      } /* Else of HSDPA Resume */
    }

    /* Uplink physical channel processing */
    /* This is a case for deletion of PRACH and addition of UL_DPCH */
    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.ul_dpch_action =
      LLC_PHYCHAN_SETUP;

    MSG_LOW("LLC_PHYCHAN_SETUP for UL DPCH", 0, 0, 0);


    if((rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up == TRUE) &&
            (rrclcm_check_dl_rlc_lc_id(UE_LOGCHAN_BCCH,BCCH_S_RADIO_BEARER_ID,UE_MODE_TRANSPARENT)!=
                RRCLCM_RLC_LC_ID_NOT_FOUND))
    {
      WRRC_MSG0_HIGH("RRCGPS: DROP S-BCCH, Resuming Back to W due to IHO Failure");
      if(ordered_config_ptr->mac_dl_parms.num_bchs)
      {
        ordered_config_ptr->mac_dl_parms.num_bchs --;
      }
      /* Update number of transport channels on PCCPCH in L1 CCTrCH Parameters */
      rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up = FALSE;
      rrcllc_semi_permanent_data.dl_phy_chan.pccpch.num_trch = 0;
      (void)rrcllc_process_drop_bcch_serving();
      rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_ref_type_bf = 0;
      rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_enable_bf = 0;
      /* Add the CCTrCH ID for PCCPCH to the CCTrCH IDs to be released list */
      RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                          dl_phy_chan.pccpch.cctrch_id);
      /* Return from here as no other data in Channel Config Request
        * is relevant.
      */
      WRRC_MSG0_HIGH("RRCGPS: Force Init GPS ");
      rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_SIB_READ_IN_DCH);
      ordered_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_NOOP;
    }

#ifdef FEATURE_WCDMA_DC_HSUPA

    if(ordered_config_ptr->sec_e_dch_transmission == TRUE)
    {
      rrcllc_cmd_under_process.chan_config.sec_eul_new_freq = TRUE;
    }
#endif /* FEATURE_WCDMA_DC_HSUPA */

  }
  /* Packet continuity failed, transitioning back to previous config */
  else if (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CHO)
  {
    rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;
    /* Copy Current Config to Ordered Config */
    rrcllc_copy_cc_to_oc();
    ordered_config_ptr->mac_ul_parms.new_tfcs_list_present = TRUE;
    /* Set the Activation Time to "Now" */
    rrcllc_init_activation_time(ordered_config_ptr);

    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.dl_dpch_action =
      LLC_PHYCHAN_SETUP;
    /* Since a new DPCH is being established, initialize the Transport channel
     * bitflag to DCH
     */
    rrcllc_semi_permanent_data.dl_phy_chan.dl_dpch.trch_ref_type_bf =
          L1_DL_TRCH_REFTYPE_DCH_BF;
    rrcllc_semi_permanent_data.dl_phy_chan.dl_dpch.trch_enable_bf =
          L1_DL_TRCH_REFTYPE_DCH_BF;

    /* Get a new CCTrCH ID */
    dl_cctrch_id = ordered_config_ptr->mac_dl_parms.dch_info[0]->cctrch_id;
    if(dl_cctrch_id != RRCLLC_INVALID_CCTRCH_ID)
    {
      if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
      {
        hs_status = rrc_get_hsdpa_status();
        if (hs_status == HSDPA_INACTIVE)
        {
          WRRC_MSG0_HIGH("RRCHS:HSDPA Inactive. Not to be Resumed");
          ordered_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_NOOP;
          ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator = FALSE;
          rrc_set_hsdpa_action(HSDPA_NOOP);
          ordered_config_ptr->mac_dl_parms.mac_hs_transition_type= MAC_HS_NO_TRANSITION;
          ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs= MAC_HS_TYPE_INVALID;
        }
        else
        {
          WRRC_MSG0_HIGH("RRCHS:hsdparesume, Set CCTRCH ID");

          if (rrcllc_check_if_hsdpa_can_be_started_reconfigured(ordered_config_ptr) == FALSE)
          {
            WRRC_MSG0_ERROR("RRCHS:hsdparesumefailure");
            ordered_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_NOOP;
            ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator = FALSE;
            rrc_set_hsdpa_action(HSDPA_NOOP);
            ordered_config_ptr->mac_dl_parms.mac_hs_transition_type= MAC_HS_NO_TRANSITION;
            ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs= MAC_HS_TYPE_INVALID;
         
          }
          else
          {
            if(ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_HS_TYPE_INVALID)
            {
              WRRC_MSG0_ERROR("MACEHS:Invalid Type, though HSDPA is ACTIVE ");
              return FAILURE;
            }
            else if(ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_EHS)
            {
              WRRC_MSG0_HIGH("MACEHS: Type EHS ");
              ordered_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_NOOP;
              ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator = FALSE;
              rrc_set_hsdpa_action(HSDPA_START);
              ordered_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_START;
              ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs = MAC_EHS;
              ordered_config_ptr->mac_dl_parms.mac_hs_transition_type = MAC_HS_NO_TRANSITION;
            }
            else
            {
              ordered_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_START;
              WRRC_MSG0_HIGH("MACEHS: Type HS ");
              ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs = MAC_HS;
              ordered_config_ptr->mac_dl_parms.mac_hs_transition_type = MAC_HS_NO_TRANSITION;
              ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator = FALSE;
              rrc_set_hsdpa_action(HSDPA_START);
            }
            ordered_config_ptr->l1_hsdpa_info.hs_req_mask = CPHY_HS_DSCH_CFG_INCL |
              CPHY_HS_PDSCH_RL_CFG_INCL | CPHY_HS_SCCH_CFG_INCL | CPHY_HS_DPCCH_CFG_INCL;
#ifdef FEATURE_WCDMA_MIMO
            if(rrcllc_get_mimo_status() == RRC_MIMO_ACTIVE)
            {
              WRRC_MSG0_HIGH("MIMO: Set MIMO action to START after CCO Fail");
              ordered_config_ptr->l1_hsdpa_info.hs_req_mask |=CPHY_HS_MIMO_CFG_INCL;
              ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_START;
            }
            else
            {
              ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_NOOP;
            }
#endif

 #ifdef FEATURE_WCDMA_DC_HSDPA
            /*This is the case of W->G CC Fail. If DC-HSDPA was up before, we need to RECONFIG*/
            if(rrcllcpcie_return_num_sec_hsdpa_carriers(ordered_config_ptr) > 0)
            {
              WRRC_MSG1_HIGH("DC-HSDPA: Set L1 action to START after CCO Fail. hs_req_mask 0X%x",
                  ordered_config_ptr->l1_hsdpa_info.hs_req_mask);
              /*Other bit_masks are set due to generic logic of RECONFIG of HSDPA*/
              ordered_config_ptr->l1_hsdpa_info.hs_req_mask |=CPHY_HS_SEC_HSDPA_CFG_INCL;
            }
#endif /*FEATURE_WCDMA_DC_HSDPA*/ 

            /* Set beta table and hs-dpcch bit mask */
            ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 
              HS_DPCCH_BETA_HS_INFO_PRESENT_BITMASK | HS_DPCCH_MEAS_FEEDBACK_INFO_PRESENT_BITMASK;
            WRRC_MSG1_MED("RRCHS:Set CCTrCh Id %d in L1 structure",ordered_config_ptr->mac_dflow_info[0].cctrch_id);

            /* Set CCTRCH in L1 HSDSCH information */
            if(ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_EHS)
            {
              ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.cctrch_id = 
                  ordered_config_ptr->mac_ehs_queue_info[0].cctrch_id;
            }
            else
            {
              ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.cctrch_id = 
                ordered_config_ptr->mac_dflow_info[0].cctrch_id;
            }
            WRRC_MSG0_MED("RRCHS:Setting HSDPA L1 Info");
            rrcllc_set_hsdpa_l1_info_in_cmd_under_process(ordered_config_ptr);
          }
        } /* Else of HSDPA Resume */ 
      }
      /* Update DPCH Info in rrcllc_cmd_under_process - this presumes that
       * there is only 1 DPCH
       */
     /* If the num dchs is zero the cctrch_id doesn't have valid value*/
      if(ordered_config_ptr->mac_dl_parms.num_dchs > 0)
      {
      rrcllc_semi_permanent_data.dl_phy_chan.dl_dpch.cctrch_id =
        dl_cctrch_id;
    }
    }
    else
    {
      WRRC_MSG1_ERROR("Invalid DL CCTrCH ID %d assigned", dl_cctrch_id);
      return(FAILURE);
    }

    MSG_LOW("LLC_PHYCHAN_SETUP for DL DPCH", 0, 0, 0);

    /* Uplink physical channel processing */
    /* This is a case for deletion of PRACH and addition of UL_DPCH */
    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.ul_dpch_action =
      LLC_PHYCHAN_SETUP;

    MSG_LOW("LLC_PHYCHAN_SETUP for UL DPCH", 0, 0, 0);
    if((rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up == TRUE) &&
            (rrclcm_check_dl_rlc_lc_id(UE_LOGCHAN_BCCH,BCCH_S_RADIO_BEARER_ID,UE_MODE_TRANSPARENT)!=
                RRCLCM_RLC_LC_ID_NOT_FOUND))
    {
      WRRC_MSG0_HIGH("RRCGPS: DROP S-BCCH, Resuming Back to W due to CHO Failure");
      if(ordered_config_ptr->mac_dl_parms.num_bchs)
      {
        ordered_config_ptr->mac_dl_parms.num_bchs --;
      }
      /* Update number of transport channels on PCCPCH in L1 CCTrCH Parameters */
      rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up = FALSE;
      rrcllc_semi_permanent_data.dl_phy_chan.pccpch.num_trch = 0;
      (void)rrcllc_process_drop_bcch_serving();
      rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_ref_type_bf = 0;
      rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_enable_bf = 0;
      /* Add the CCTrCH ID for PCCPCH to the CCTrCH IDs to be released list */
      RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                          dl_phy_chan.pccpch.cctrch_id);
      /* Return from here as no other data in Channel Config Request
        * is relevant.
      */
      WRRC_MSG0_HIGH("RRCGPS: Force Init GPS ");
      rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_SIB_READ_IN_DCH);
      ordered_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_NOOP;
    }

#ifdef FEATURE_WCDMA_DC_HSUPA

    if( ordered_config_ptr->sec_e_dch_transmission == TRUE)
    {
      rrcllc_cmd_under_process.chan_config.sec_eul_new_freq = TRUE;
    }
#endif /* FEATURE_WCDMA_DC_HSUPA */

  }/*(rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CHO)*/

  else  /* Normal, regular case */
  {
    if ((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CU) &&
        ( cmd_ptr->cmd.chan_config_req.chan_config_reason
          == RRCLLC_CHAN_CFG_REASON_RLC_CONFIG_ONLY))
    {
      /* remove all RBs from OC and TOC before proceding with channel configuration
      */
      for (rb_index=0; rb_index<cmd_ptr->cmd.chan_config_req.num_rb_to_config; rb_index++)
      {
        if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
        {
          WRRC_MSG0_HIGH("Config RLC ONLY, Remove all RB mapping from OC/TOC");
        }
        /* Remove any existing mapping for the RB */
        unmap_rb(cmd_ptr->cmd.chan_config_req.rb[rb_index].rb_id, OC_AND_TOC);
      }
    }
    if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
    {
      if (rrcllc_process_config_dcch_dtch(cmd_ptr) == FAILURE)
      {
        (void)rrcllc_build_cmd_and_release_lc_ids();       
        WRRC_MSG0_ERROR("RRCHS:Unable to config dcch/dtch");
        return FAILURE;
      }
    }
    else
    {
      if (rrcllc_process_config_dcch_dtch(cmd_ptr) == FAILURE)
      {
        (void)rrcllc_build_cmd_and_release_lc_ids(); 
        WRRC_MSG0_ERROR("FAILURE in config dcch dtch");
        return FAILURE;
      }
    }


#ifdef FEATURE_UMTS_PDCP
    /* Build the command for PDCP_CONFIG_REQ*/
    rrcllc_process_config_pdcp(cmd_ptr);
#endif /* FEATURE_UMTS_PDCP*/

    if ((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CU) &&
        ( cmd_ptr->cmd.chan_config_req.chan_config_reason
          == RRCLLC_CHAN_CFG_REASON_RLC_CONFIG_ONLY))
    {
      /* Make sure MAC and L1 UL and DL are configured always */
      ordered_config_ptr->reconfig_needed.uplink_l1 = FALSE;
      ordered_config_ptr->reconfig_needed.downlink_l1 = FALSE;
      ordered_config_ptr->reconfig_needed.downlink_mac = FALSE;
      ordered_config_ptr->reconfig_needed.uplink_mac = FALSE;
      return(SUCCESS);
    }

    else
    {
      /* Make sure MAC and L1 UL and DL are configured always */
      ordered_config_ptr->reconfig_needed.uplink_l1 = TRUE;
      ordered_config_ptr->reconfig_needed.downlink_l1 = TRUE;
      ordered_config_ptr->reconfig_needed.downlink_mac = TRUE;
      ordered_config_ptr->reconfig_needed.uplink_mac = TRUE;
    }

    /* Downlink Physical channel processing */
    /* Look into the Reconfig needed flag to determine action on L1 */
    if(ordered_config_ptr->reconfig_needed.downlink_l1)
    {
      rrcllc_cmd_under_process.chan_config.phy_chan_action_list.dl_dpch_action =
        LLC_PHYCHAN_RECONFIG;
      /* Since the DPCH is being reconfigured, no need to initialize the
       * Transport channel bitflags since it should already be set to DCH
       */

      /* If a valid CCTrCH ID exists for DL DPCH, add it to release list */
      if(rrcllc_semi_permanent_data.dl_phy_chan.dl_dpch.cctrch_id !=
         RRCLLC_INVALID_CCTRCH_ID)
      {
        RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.dl_phy_chan.
                                             dl_dpch.cctrch_id);
      }
      /* Get a new CCTrCH ID */
      dl_cctrch_id = rrcllc_get_cctrch_id();
      if(dl_cctrch_id != RRCLLC_INVALID_CCTRCH_ID)
      {
        /* Update DCH info in MAC Ordered Config */
        for(dch_count=0; dch_count < ordered_config_ptr->mac_dl_parms.num_dchs; dch_count++)
        {
          ordered_config_ptr->mac_dl_parms.dch_info[dch_count]->cctrch_id
            = dl_cctrch_id;
        }

        if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
        {
          hs_action = rrc_get_hsdpa_action();

          if (hs_action == HSDPA_NOOP)
          {
            WRRC_MSG0_HIGH("RRCHS:CCTRCH Id for HS not set");
            /*RRC_GKG: Check the case when HSDPA action is set to NOOP but DC-HSDPA action is set*/
          }
          else
          {
            WRRC_MSG2_HIGH("RRCHS:Set CCTRCH ID %d in MAC HSDPA info, L1 structure. num_dflow: %d",dl_cctrch_id,ordered_config_ptr->mac_dl_parms.num_dflow);
            if(ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_EHS)
            {
              for(queue_cnt=0;queue_cnt < ordered_config_ptr->mac_dl_parms.num_mac_ehs_queue;queue_cnt++)
              {
                ordered_config_ptr->mac_dl_parms.hsdpa_ehs_queue_info[queue_cnt]->cctrch_id = dl_cctrch_id;
              }
            }
            else
            {
            /* Update CCTRCH for HSDPA in MAC Ordered Config */
            for(dflow_cnt=0; dflow_cnt < ordered_config_ptr->mac_dl_parms.num_dflow; dflow_cnt++)
            {
              ordered_config_ptr->mac_dl_parms.hsdpa_info[dflow_cnt]->cctrch_id
                = dl_cctrch_id;
            }
            }
            /* Set CCTRCH in L1 HSDSCH information */
            ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.cctrch_id = dl_cctrch_id;

            WRRC_MSG0_MED("RRCHS:Setting HSDPA L1 Info");
            rrcllc_set_hsdpa_l1_info_in_cmd_under_process(ordered_config_ptr);
          }
        }
        /* Update DPCH Info in rrcllc_cmd_under_process - this presumes that
         * there is only 1 DPCH
         */
        rrcllc_semi_permanent_data.dl_phy_chan.dl_dpch.cctrch_id =
          dl_cctrch_id;
      }
      else
      {
        WRRC_MSG1_ERROR("Invalid DL CCTrCH ID %d assigned", dl_cctrch_id);
        return(FAILURE);
      }

      MSG_LOW("LLC_PHYCHAN_RECONFIG for DL DPCH", 0, 0, 0);
    }
    else
    {
      rrcllc_cmd_under_process.chan_config.phy_chan_action_list.dl_dpch_action =
        LLC_PHYCHAN_NO_OP;
    }

    /* Uplink physical channel processing */
    /* Look into Reconfig Needed to determine action on Uplink DPCH */
    if(ordered_config_ptr->reconfig_needed.uplink_l1)
    {
      rrcllc_cmd_under_process.chan_config.phy_chan_action_list.ul_dpch_action =
        LLC_PHYCHAN_RECONFIG;

      MSG_LOW("LLC_PHYCHAN_RECONFIG for UL DPCH", 0, 0, 0);
    }
    else
    {
      rrcllc_cmd_under_process.chan_config.phy_chan_action_list.ul_dpch_action =
        LLC_PHYCHAN_NO_OP;
    }

    /* Is this is a hard handover and also timing initialized */
    if((ordered_config_ptr->reconfig_needed.uplink_l1 ||
        ordered_config_ptr->reconfig_needed.downlink_l1) &&
       (ordered_config_ptr->dest_freq_present))
    {
      rrcllc_cmd_under_process.chan_config.new_freq = TRUE;
      rrcllc_cmd_under_process.is_hho_in_dch        = TRUE;

      if(ordered_config_ptr->
          l1_dl_chan_parms.dl_common.dpch_common.timing_ind ==
          L1_TIMING_IND_INIT)
      {
          rrcllc_cmd_under_process.chan_config.hho_ciph_update_required = TRUE;
      }
    }
    else
    {
      rrcllc_cmd_under_process.chan_config.hho_ciph_update_required = FALSE;
    }
#ifdef FEATURE_WCDMA_DC_HSUPA

  if( ordered_config_ptr->sec_eul_is_hho )
  {
    rrcllc_cmd_under_process.chan_config.sec_eul_new_freq = TRUE;

    // check whether it is required?

    if( current_config_ptr->sec_e_dch_transmission == TRUE)
    {
      rrcllc_cmd_under_process.is_hho_in_dch_for_sec_eul= TRUE;
    }
  
  }
#endif /* FEATURE_WCDMA_DC_HSUPA */

  } /* Normal, regular case */

  return(SUCCESS);
} /* rrcllc_chan_config_within_dch */


/*===========================================================================
FUNCTION   rrcllc_set_cpc_dtx_req_mask_for_old_config

DESCRIPTION
  This function is resposible for setting the L1 CPC-DTX related action/mask
  when going back to old confuration in case of a physical channel
  failure within DCH.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static void rrcllc_set_cpc_dtx_req_mask_for_old_config
(
  boolean est_fail
)
{
  /* clean up the DTX flags in CURRENT CONFIG PTR because these flags will not be
    initialized at this point */
  rrcllc_init_cpc_dtx_info_before_msg_processing(current_config_ptr);


  WRRC_MSG1_HIGH("RRCCPC:Going back to old config, scch_order_action = %d", 
    ordered_config_ptr->l1_hs_scch_order_action);


  if(ordered_config_ptr->l1_hs_scch_order_action == 
     L1_HS_SCCH_ORDER_ACTION_BACKUP_AND_DISCARD)
  {
    current_config_ptr->l1_hs_scch_order_action = L1_HS_SCCH_ORDER_ACTION_RESTORE;
  }


  if (TRUE == est_fail)
  {
    if (ordered_config_ptr->cpc_dtx_drx_status != current_config_ptr->cpc_dtx_drx_status)
    {
      /* check whether rcvd config message STOPped CPC-DTX */
      if (FALSE == ordered_config_ptr->cpc_dtx_drx_status)
      {
        WRRC_MSG0_HIGH("RRCCPC:cpc_dtx_drx_status[OC:FALSE/CC:TRUE],Set CC cpc_dtx_req_mask :: DTX_START");
        /* set CPC-DTX action as START for L1 
        */
        current_config_ptr->l1_cpc_dtx_req_mask = L1_CPC_DTX_START;
      }
      else /* it STARTed CPC-DTX */
      {
        WRRC_MSG0_HIGH("RRCCPC:cpc_dtx_drx_status[OC:TRUE/CC:FALSE],Set CC cpc_dtx_req_mask :: DTX_STOP");
        current_config_ptr->l1_cpc_dtx_req_mask = L1_CPC_DTX_STOP;
      }
    }
    else /* it can either reconfig or no-op */
    {
      if (FALSE == ordered_config_ptr->cpc_dtx_drx_status)
      {
        /* set CPC-DTX action as NO_OP */
        current_config_ptr->l1_cpc_dtx_req_mask = L1_CPC_DTX_NO_OP;
      }
      else
      {
        /* L1 would have moved to the new config */        
        current_config_ptr->l1_cpc_dtx_req_mask = L1_CPC_DTX_START|L1_CPC_DTX_STOP;
      }
    }
  }
  else /* cphy_setup_failure */
  {         
    /* if its a seamless reconfig */
    if((FALSE == ordered_config_ptr->is_hho) &&
        (FALSE == ordered_config_ptr->dest_freq_present))
    {
      WRRC_MSG0_HIGH("RRCCPC:seamless reconfig Set dtx_req_mask : DTX_NO_OP");
      /* L1 is not expected to move to new config..hence NOOP ir-respective of 
           req_mask in ordered_config */
      current_config_ptr->l1_cpc_dtx_req_mask = L1_CPC_DTX_NO_OP;
    }
    else
    {
      if (ordered_config_ptr->cpc_dtx_drx_status != current_config_ptr->cpc_dtx_drx_status)
      {
        /* check whether rcvd config message STOPped CPC-DTX */
        if (FALSE == ordered_config_ptr->cpc_dtx_drx_status)
        {
          /* set CPC-DTX action as START for L1 */
          current_config_ptr->l1_cpc_dtx_req_mask = L1_CPC_DTX_START;
        }
        else /* it STARTed CPC-DTX */
        {
          current_config_ptr->l1_cpc_dtx_req_mask = L1_CPC_DTX_NO_OP;
        }
        WRRC_MSG1_HIGH("RRCCPC:cpc_dtx_drx_status[OC:TRUE/CC:FALSE],Set CC cpc_dtx_req_mask %d:: [0-DTX_NO_OP,1-DTX_START]",current_config_ptr->l1_cpc_dtx_req_mask);
      }
      else /* it can either reconfig or no-op */
      {
        if (FALSE == ordered_config_ptr->cpc_dtx_drx_status)
        {
          /* set CPC-DTX action as STOP */
          current_config_ptr->l1_cpc_dtx_req_mask = L1_CPC_DTX_NO_OP;
        }
        else
        {
          /* L1 would have moved to the new config 
          */
          current_config_ptr->l1_cpc_dtx_req_mask = L1_CPC_DTX_START;
        }
      }
    }
  }

  /* no need to have msg high when CPC-DTX was not active before or after the
     receipt of reconfig message */
  if ((FALSE != ordered_config_ptr->cpc_dtx_drx_status) ||
      (FALSE != current_config_ptr->cpc_dtx_drx_status))
  {
    MSG_4(MSG_SSID_DFLT, MSG_LEGACY_HIGH,"RRCCPC: NewCC: l1_dtx_req: 0x%x(4/2/1/0::Stop/Reconf/Start/Noop), cpc_dtx_drx_status: %d, OC: l1_dtx_req: 0x%x(4/2/1/0::Stop/Reconf/Start/Noop), cpc_dtx_drx_status: %d",
      current_config_ptr->l1_cpc_dtx_req_mask, current_config_ptr->cpc_dtx_drx_status,ordered_config_ptr->l1_cpc_dtx_req_mask,ordered_config_ptr->cpc_dtx_drx_status);
  }
}


/*===========================================================================
FUNCTION   rrcllc_set_cpc_dtx_req_mask_for_old_config

DESCRIPTION
  This function is resposible for setting the L1 CPC-DRX related action/mask
  when going back to old confuration in case of a physical channel
  failure within DCH.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static void rrcllc_set_cpc_drx_req_mask_for_old_config
(
  boolean est_fail
)
{
  /* clean up the DTX flags in CURRENT CONFIG PTR because these flags will not be
    initialized at this point */
  rrcllc_init_cpc_drx_info_before_msg_processing(current_config_ptr);

  WRRC_MSG0_HIGH("RRCCPC:Going back to old config, set cpc_drx_req_mask in CC");

  if (TRUE == est_fail)
  {
    if (ordered_config_ptr->cpc_drx_status != current_config_ptr->cpc_drx_status)
    {
        /* check whether rcvd config message STOPped CPC-DRX */
        if (FALSE == ordered_config_ptr->cpc_drx_status)
        {
          /* set CPC-DRX action as START for L1  */
          current_config_ptr->l1_cpc_drx_req_mask = L1_CPC_DRX_START;
        }
        else /* it STARTed CPC-DRX */
        {
          current_config_ptr->l1_cpc_drx_req_mask = L1_CPC_DRX_STOP;
        }
        WRRC_MSG2_HIGH("RRCCPC:cpc_drx_status[OC:TRUE/CC:FALSE] %d,Set CC cpc_drx_req_mask :: [0-DRX_NO_OP, 1-DRX_START] %d", ordered_config_ptr->cpc_drx_status,current_config_ptr->l1_cpc_drx_req_mask);
    }
    else /* it can either reconfig or no-op */
    {
        if (FALSE == ordered_config_ptr->cpc_drx_status)
        {
          /* set CPC-DRX action as STOP */
          current_config_ptr->l1_cpc_drx_req_mask = L1_CPC_DRX_NO_OP;
        }
        else
        {
          /* L1 would have moved to the new config */
          current_config_ptr->l1_cpc_drx_req_mask = L1_CPC_DRX_START|L1_CPC_DRX_STOP;
        }
    }
  }
  else /* cphy_setup_failure */
  {
    /* if its a seamless reconfig */
    if((FALSE == ordered_config_ptr->is_hho) &&
       (FALSE == ordered_config_ptr->dest_freq_present))
    {
      WRRC_MSG0_HIGH("RRCCPC:seamless reconfig Set drx_req_mask : DTX_NO_OP");
      /* L1 is not expected to move to new config..hence NOOP ir-respective of 
           req_mask in ordered_config */
      current_config_ptr->l1_cpc_drx_req_mask = L1_CPC_DRX_NO_OP;
    }
    else
    {
      if (ordered_config_ptr->cpc_drx_status != current_config_ptr->cpc_drx_status)
      {
        /* check whether rcvd config message STOPped CPC-DRX */
        if (FALSE == ordered_config_ptr->cpc_drx_status)
        {
          /* set CPC-DRX action as START for L1           */
          current_config_ptr->l1_cpc_drx_req_mask = L1_CPC_DRX_START;
        }
        else /* it STARTed CPC-DRX */
        {
          current_config_ptr->l1_cpc_drx_req_mask = L1_CPC_DRX_NO_OP;
        }
        WRRC_MSG2_HIGH("RRCCPC:cpc_drx_status[OC:TRUE/CC:FALSE]%d,Set CC cpc_drx_req_mask :: [0-DRX_NO_OP, 1-DRX_START]%d", ordered_config_ptr->cpc_drx_status,current_config_ptr->l1_cpc_drx_req_mask);
      }
      else /* it can either reconfig or no-op */
      {
        if (FALSE == ordered_config_ptr->cpc_drx_status)
        {
          /* set CPC-DRX action as STOP */
          current_config_ptr->l1_cpc_drx_req_mask = L1_CPC_DRX_NO_OP;
        }
        else
        {
          /* L1 would have moved to the new config */
          current_config_ptr->l1_cpc_drx_req_mask = L1_CPC_DRX_START;
        }
      }
    }
  }
  /* no need to have msg high when CPC-DRX was not active before or after the
     receipt of reconfig message */
  if ((FALSE != ordered_config_ptr->cpc_drx_status) ||
      (FALSE != current_config_ptr->cpc_drx_status))
  {
    MSG_4(MSG_SSID_DFLT, MSG_LEGACY_HIGH,"RRCCPC: NewCC: l1_drx_req: 0x%x(4/2/1/0::Stop/Reconf/Start/Noop), cpc_drx_status: %d,OC: l1_drx_req: 0x%x(4/2/1/0::Stop/Reconf/Start/Noop), cpc_drx_status: %d",
      current_config_ptr->l1_cpc_drx_req_mask, current_config_ptr->cpc_drx_status,ordered_config_ptr->l1_cpc_drx_req_mask,ordered_config_ptr->cpc_drx_status);
  }
}



/*===========================================================================
FUNCTION   rrcllc_update_l1_e_dl_info_for_old_config

DESCRIPTION
  This function fills the e_rl_release_list[] and  'e_dl_channel_mask' in 
  e_dl_rl_add_recfg_info[] of current_config_ptr.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static void rrcllc_update_l1_e_dl_info_for_old_config
(
  boolean l1_stop_and_start_needed
#ifdef FEATURE_WCDMA_DC_HSUPA
  ,boolean is_sec_eul
#endif /* FEATURE_WCDMA_DC_HSUPA */

)
{
  uint16 e_rl_idx;
  l1_e_dl_info_struct_type *ord_e_dl_info_ptr = &ordered_config_ptr->l1_e_info.e_dl_info;
  l1_e_dl_info_struct_type *curr_e_dl_info_ptr = &current_config_ptr->l1_e_info.e_dl_info;
#ifdef FEATURE_WCDMA_DC_HSUPA
  if(TRUE == is_sec_eul)
  {
    ord_e_dl_info_ptr = &ordered_config_ptr->l1_sec_e_info.e_dl_info;
    curr_e_dl_info_ptr = &current_config_ptr->l1_sec_e_info.e_dl_info;
  }
#endif /* FEATURE_WCDMA_DC_HSUPA */  
  /* move the E-DCH RLs in the ordered config to release list if RRC has to indicate 
     STOP and START to L1*/
  if (TRUE == l1_stop_and_start_needed)
  {
    for (e_rl_idx=0; 
      e_rl_idx < ord_e_dl_info_ptr->num_e_dl_rl_add_recfg_info; e_rl_idx++)
    {
      curr_e_dl_info_ptr->e_rl_release_info[e_rl_idx].psc = 
        ord_e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_rl_psc;
      curr_e_dl_info_ptr->num_e_rl_release_info++;
    }
  }
  else
  {
    curr_e_dl_info_ptr->num_e_rl_release_info = 0;
  }

  /* since its going to be START of E-DCH indicate as ADD for all the DL channels
     present in E-DCH RLs */
  for (e_rl_idx=0; 
    e_rl_idx < curr_e_dl_info_ptr->num_e_dl_rl_add_recfg_info; e_rl_idx++)
  {

    /* Indicate agch add only for serving RL*/
    if (e_rl_idx == curr_e_dl_info_ptr->e_serving_rl_idx)
    {
      if(curr_e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_dl_channel_mask & L1_E_AGCH_INFO_PRESENT)
      {
        curr_e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_dl_channel_mask |= L1_E_AGCH_INFO_ADD;
      }
    }
    if(curr_e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_dl_channel_mask & L1_E_RGCH_INFO_PRESENT)
    {
      curr_e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_dl_channel_mask |= L1_E_RGCH_INFO_ADD;
    }

    /* HICH will always be present in E-DCH active set, hence no need to check 
       for ther present flag */
    curr_e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_dl_channel_mask |= L1_E_HICH_INFO_ADD;
  }
}

/*===========================================================================
FUNCTION   rrcllc_set_e_req_mask_for_old_config

DESCRIPTION
  This function is resposible for setting the L1 and MAC EUL related action/mask
  when going back to old confuration in case of a physical channel
  failure within DCH.  Takes in boolean value to indicate wheter phy chan
  est or phy chan setup failed.  For setup failure, dpch action will be
  setup.  For establishment failure, L1 E-DCH ACTION will be STOP and START if 
  reconfig message reconfigures E-DCH.
  At the end of function exeution, L1 and MAC e-dch info is filled in current_config_ptr
  so that it can be directly copied to ordered_config_ptr. 

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static void rrcllc_set_e_req_mask_for_old_config
(
  boolean est_fail
)
{

  rrcllc_mac_sync_with_l1_e_type   sync_btwn_mac_and_l1_needed = NO_SYNC_WITH_L1;
  
  /* clean up the EUL flags in CURRENT CONFIG PTR because these flags will not be
    initialized at this point */
  rrcllc_init_e_dch_info_before_msg_processing(current_config_ptr);

  if (TRUE == est_fail)
  {
    /* if its establishment failure then it indicates that MAC as well as L1 would
       have moved to new config. Hence we need to revert back to old config and 
       release new conifg */

    if (TRUE == ordered_config_ptr->mac_e_reset_indicator)
    {
      /* MAC e would have reset by now, hence we have to make sure that
         MAC should revert back to old TSN */
      current_config_ptr->mac_e_reset_indicator = FALSE;
      current_config_ptr->mac_e_tsn_action = MAC_E_TSN_ACTION_REVERT;
    }
    else /* make sure that these below variables are set properly */
    {
      current_config_ptr->mac_e_reset_indicator = FALSE;
      current_config_ptr->mac_e_tsn_action = MAC_E_TSN_ACTION_BACKUP;
    }

    if (ordered_config_ptr->e_dch_transmission != current_config_ptr->e_dch_transmission)
    {
      /* check whether rcvd config message STOPped E_DCH */
      if (FALSE == ordered_config_ptr->e_dch_transmission)
      {
        /* set EUL action as START  - no need to reset the MAC in this case */
        current_config_ptr->mac_eul_action = MAC_EUL_START;
        current_config_ptr->l1_e_req_mask = L1_EUL_START;

        rrcllc_update_l1_e_dl_info_for_old_config(FALSE
#ifdef FEATURE_WCDMA_DC_HSUPA
                                                , FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
                                                  );
      }
      else /* it STARTed E_DCH  */
      {
        /* set EUL action as STOP */
        current_config_ptr->mac_eul_action = MAC_EUL_STOP;
        current_config_ptr->l1_e_req_mask = L1_EUL_STOP;
        /* set mac e reset indicator to TRUE whenever there is a STOP of EUL */
        current_config_ptr->mac_e_reset_indicator = TRUE;
      }
    }
    else /* it can either reconfig or no-op */
    {
      if (FALSE == ordered_config_ptr->e_dch_transmission)
      {
        /* if we are inside this if, then it means that its a no-op for MAC and L1 */
        ordered_config_ptr->mac_eul_action = MAC_EUL_NOOP;
  
        /* set EUL action as STOP */
        ordered_config_ptr->l1_e_req_mask = L1_EUL_NOOP;
      }
      else
      {
        /* L1 would have moved to the new config */
        current_config_ptr->l1_e_req_mask = L1_EUL_STOP|L1_EUL_START;

        rrcllc_update_l1_e_dl_info_for_old_config(TRUE
#ifdef FEATURE_WCDMA_DC_HSUPA
                                                , FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
                                                  );
        /* no need to reconfigure MAC is mac config has not changed */
        if (ordered_config_ptr->mac_eul_action == MAC_EUL_CONFIG)
        {
          current_config_ptr->mac_eul_action = MAC_EUL_CONFIG;
        }
        else
        {
          current_config_ptr->mac_eul_action = MAC_EUL_NOOP;
        }
      }
    }
  }
  else /* cphy_setup_failure */
  {

      /* No activation time when configuring MAC due to Security Mode Command */      
    if((rrcllc_cmd_under_process.chan_config.current_cmd_engine == LLC_CHAN_CONFIG_ENGINE) &&
      (rrcllc_cmd_under_process.procedure != RRC_PROCEDURE_SMC) &&
      (rrcllc_cmd_under_process.procedure != RRC_PROCEDURE_ASU))
    {
      if((rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_DCH) &&
        (ordered_config.set_status != OC_SET_FOR_DCH_FACH_TRANS))
      {
        if(ordered_config_ptr->reconfig_needed.uplink_l1)
        {
          sync_btwn_mac_and_l1_needed = SYNC_WITH_L1;
        }
      }
    }
    /* If sync between mac and l1 is not set, MAC will apply the config right away. 
       In that case, we should send TSN action as revert */
    if ((TRUE == ordered_config_ptr->mac_e_reset_indicator) && (sync_btwn_mac_and_l1_needed == NO_SYNC_WITH_L1))
    {
      /* MAC e would have reset by now, hence we have to make sure that
         MAC should revert back to old TSN */
      current_config_ptr->mac_e_reset_indicator = FALSE;
      current_config_ptr->mac_e_tsn_action = MAC_E_TSN_ACTION_REVERT;
    }
    else /* make sure that these below variables are set properly */
    {
      current_config_ptr->mac_e_reset_indicator = FALSE;
      current_config_ptr->mac_e_tsn_action = MAC_E_TSN_ACTION_BACKUP;
    }

    /* if its a seamless reconfig */
    if ((FALSE == ordered_config_ptr->is_hho) &&
        (FALSE == ordered_config_ptr->dest_freq_present))
    {
      /* MAC would have moved to the new config, hence set the mask accordingly */
      switch(ordered_config_ptr->mac_eul_action)
      {
        case MAC_EUL_NOOP:
          current_config_ptr->mac_eul_action = MAC_EUL_NOOP;
          break;

        case MAC_EUL_CONFIG:
          current_config_ptr->mac_eul_action = MAC_EUL_CONFIG;
          break;

        case MAC_EUL_STOP:
          /* if its a STOP then for reverting back it should be START */
          current_config_ptr->mac_eul_action = MAC_EUL_START;
          break;

        case MAC_EUL_START:
          current_config_ptr->mac_eul_action = MAC_EUL_STOP;
          break;

        default:
          ERR_FATAL("RRCEUL invalid mac_eul_action- should not happen", 0, 0, 0);
      }

      /* L1 is not expected to move to new config..hence NOOP ir-respective of 
         req_mask in ordered_config */
      current_config_ptr->l1_e_req_mask = L1_EUL_NOOP;
    }
    else /* if its HHO case */
    {
      /* no-op for MAC because MAC shouldnt have moved to the new config
         because its waiting for L1-SYNC-IND */
      current_config_ptr->mac_eul_action = MAC_EUL_NOOP;

      if (ordered_config_ptr->e_dch_transmission != current_config_ptr->e_dch_transmission)
      {
        /* check whether rcvd config message STOPped E_DCH */
        if (FALSE == ordered_config_ptr->e_dch_transmission)
        {
         /* set EUL action as START for L1 */
          current_config_ptr->l1_e_req_mask = L1_EUL_START;

           rrcllc_update_l1_e_dl_info_for_old_config(FALSE
#ifdef FEATURE_WCDMA_DC_HSUPA
                                                  , FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
       
                                                   );
        }
        else /* it STARTed E_DCH  */
        {
          current_config_ptr->l1_e_req_mask = L1_EUL_NOOP;
        }
      }
      else /* it can either reconfig or no-op */
      {
        if (FALSE == ordered_config_ptr->e_dch_transmission)
        {
          /* set EUL action as STOP */
          ordered_config_ptr->l1_e_req_mask = L1_EUL_NOOP;
        }
        else
        {
          /* L1 would have moved to the new config */
          current_config_ptr->l1_e_req_mask = L1_EUL_START;

            rrcllc_update_l1_e_dl_info_for_old_config(FALSE
#ifdef FEATURE_WCDMA_DC_HSUPA
                                                  , FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
                                                  );
        }
      }
    }
  }


  if(TRUE == current_config_ptr->e_dch_transmission)
  {
    /*N/W may provide AGCH info for non eul serving RL. Currently L1 logic of detecting serving RL is based on 
     *AGCH info present it doesn't look at eul serving rl idx, So I don't indicate AGCH add/reconfig action for 
     *non-serving RL's. Later if this non-serving RL become serving EUL RL then we indicate AGCH as add even 
     *if N/W doesn't provide AGCH info in the reconfig message that trigger eul serving cell re-pointing, though 
     *spec clearly say N/W should provide AGCH info for serving rl but since some of the N/W doesn't comply with 
     *this we allow this kind of config 
     */
    rrcllc_clear_agch_chan_mask_for_non_serving_rl(current_config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
                                                  , FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
                                                  );
  }

  /* no need to have msg high when E-DCH was not active before or after the
     receipt of reconfig message */
  if ((FALSE != ordered_config_ptr->e_dch_transmission) ||
      (FALSE != current_config_ptr->e_dch_transmission))
  {
    MSG_8(MSG_SSID_DFLT, MSG_LEGACY_HIGH,"RRCEUL: NewCC: l1_e: 0x%x(8/4/2/1:SP/D/U/S), mac_e: 0x%x(1/2/4: S/C/SP), e_dch_txn: %d, OC: mac_eul_action: 0x%x, l1_e_req_mask: 0x%x, e_dch_txn: %d, is_hho: %d",
      current_config_ptr->l1_e_req_mask,current_config_ptr->mac_eul_action, current_config_ptr->e_dch_transmission, ordered_config_ptr->mac_eul_action,
      ordered_config_ptr->l1_e_req_mask,ordered_config_ptr->e_dch_transmission,ordered_config_ptr->e_dch_transmission,0);
  }
}
#ifdef FEATURE_WCDMA_DC_HSUPA
/*===========================================================================
FUNCTION   rrcllc_set_sec_e_req_mask_for_old_config

DESCRIPTION
  This function is resposible for setting the L1 and MAC SEC  EUL related action/mask
  when going back to old confuration in case of a physical channel
  failure within DCH.  Takes in boolean value to indicate wheter phy chan
  est or phy chan setup failed.  For setup failure,E-DCH action will be noop
  For establishment failure, L1 E-DCH ACTION will be STOP and START if 
  reconfig message reconfigures E-DCH.
  At the end of function exeution, L1 and MAC e-dch info is filled in current_config_ptr
  so that it can be directly copied to ordered_config_ptr. 

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static void rrcllc_set_sec_e_req_mask_for_old_config
(
  boolean est_fail
)
{
  /* clean up the EUL flags in CURRENT CONFIG PTR because these flags will not be
    initialized at this point */
  rrcllc_init_sec_e_dch_info_before_msg_processing(current_config_ptr);

  if (TRUE == est_fail)
  {

  /*Madhavi: est fail can occur only if channel config*/
    /* if its establishment failure then it indicates that MAC as well as L1 would
       have moved to new config. Hence we need to revert back to old config and 
       release new conifg */
#if 0
// This will be taken care by fun rrcllc_set_e_req_mask_for_old_config
    if (TRUE == ordered_config_ptr->mac_e_reset_indicator)
    {
      /* MAC e would have reset by now, hence we have to make sure that
         MAC should revert back to old TSN */
      current_config_ptr->mac_e_reset_indicator = FALSE;
      current_config_ptr->mac_e_tsn_action = MAC_E_TSN_ACTION_REVERT;
    }
    else /* make sure that these below variables are set properly */
    {
      current_config_ptr->mac_e_reset_indicator = FALSE;
      current_config_ptr->mac_e_tsn_action = MAC_E_TSN_ACTION_BACKUP;
    }
#endif
    if (ordered_config_ptr->sec_e_dch_transmission != current_config_ptr->sec_e_dch_transmission)
    {
      /* check whether rcvd config message STOPped E_DCH */
      if (FALSE == ordered_config_ptr->sec_e_dch_transmission)
      {
        /* set EUL action as START  - no need to reset the MAC in this case */
        current_config_ptr->mac_sec_eul_action = MAC_SEC_EUL_START;
        current_config_ptr->l1_sec_e_req_mask = L1_EUL_START;

        rrcllc_update_l1_e_dl_info_for_old_config(FALSE
#ifdef FEATURE_WCDMA_DC_HSUPA
                                                , TRUE
#endif /* FEATURE_WCDMA_DC_HSUPA */
                                                  );
      }
      else /* it STARTed E_DCH  */
      {
        /* set EUL action as STOP */
        current_config_ptr->mac_sec_eul_action = MAC_SEC_EUL_STOP;
        current_config_ptr->l1_sec_e_req_mask = L1_EUL_STOP;
        /* set mac e reset indicator to TRUE whenever there is a STOP of EUL */
        current_config_ptr->mac_e_reset_indicator = TRUE;
      }
    }
    else /* it can either reconfig or no-op */
    {
      if (FALSE == ordered_config_ptr->sec_e_dch_transmission)
      {
        /* if we are inside this if, then it means that its a no-op for MAC and L1 */
        ordered_config_ptr->mac_sec_eul_action = MAC_SEC_EUL_NOOP;
  
        /* set EUL action as STOP */
        ordered_config_ptr->l1_sec_e_req_mask = L1_EUL_NOOP;
      }
      else
      {
        /* L1 would have moved to the new config */
        current_config_ptr->l1_sec_e_req_mask = L1_EUL_STOP|L1_EUL_START;

        rrcllc_update_l1_e_dl_info_for_old_config(TRUE
#ifdef FEATURE_WCDMA_DC_HSUPA
                                                , TRUE
#endif /* FEATURE_WCDMA_DC_HSUPA */
                                                  );

        /* no need to reconfigure MAC is mac config has not changed */
        if (ordered_config_ptr->mac_sec_eul_action == MAC_SEC_EUL_CONFIG)
        {
          current_config_ptr->mac_sec_eul_action = MAC_SEC_EUL_CONFIG;
        }
        else
        {
          current_config_ptr->mac_sec_eul_action = MAC_SEC_EUL_NOOP;
        }
      }
    }
  }
  else /* cphy_setup_failure */
  {

#if 0


    // This will be taken care by fun rrcllc_set_e_req_mask_for_old_config
    if (TRUE == ordered_config_ptr->mac_e_reset_indicator)
    {
      /* MAC e would have reset by now, hence we have to make sure that
         MAC should revert back to old TSN */
      current_config_ptr->mac_e_reset_indicator = FALSE;
      current_config_ptr->mac_e_tsn_action = MAC_E_TSN_ACTION_REVERT;
    }
    else /* make sure that these below variables are set properly */
    {
      current_config_ptr->mac_e_reset_indicator = FALSE;
      current_config_ptr->mac_e_tsn_action = MAC_E_TSN_ACTION_BACKUP;
    }
#endif
    /* if its a seamless reconfig */
  /* If it is HHO on primary, it is hho on secondary also. 
     In case of DCHSUPA stop, sec_eul_is_hho will not be set to TRUE. 
     So when reverting to old config on such cases, checking sec_eul_is_hho doesnt look correct */
  /* for cases where only sec_is_hho is TRUE, and primary is_hho is not TRUE, CPHY_SETUP failure due to 
     ACQ failure on secondary should not happen. */
    if (ordered_config_ptr->dest_freq_present == FALSE)                                                    
    {
      /* MAC would have moved to the new config, hence set the mask accordingly */
      switch(ordered_config_ptr->mac_sec_eul_action)
      {
        case MAC_SEC_EUL_NOOP:
          current_config_ptr->mac_sec_eul_action = MAC_SEC_EUL_NOOP;
          break;

        case MAC_SEC_EUL_CONFIG:
          current_config_ptr->mac_sec_eul_action = MAC_SEC_EUL_CONFIG;
          break;

        case MAC_SEC_EUL_STOP:
          /* if its a STOP then for reverting back it should be START */
          current_config_ptr->mac_sec_eul_action = MAC_SEC_EUL_START;
          break;

        case MAC_SEC_EUL_START:
          current_config_ptr->mac_sec_eul_action = MAC_SEC_EUL_STOP;
          break;

        default:
          ERR_FATAL("DC_HSUPA: invalid mac_eul_action- should not happen", 0, 0, 0);
      }

      /* L1 is not expected to move to new config..hence NOOP ir-respective of 
         req_mask in ordered_config */
      current_config_ptr->l1_sec_e_req_mask = L1_EUL_NOOP;
    }
    else /* if its HHO case */
    {
      /* no-op for MAC because MAC shouldnt have moved to the new config
         because its waiting for L1-SYNC-IND */
      current_config_ptr->mac_sec_eul_action = MAC_SEC_EUL_NOOP;

      if (ordered_config_ptr->sec_e_dch_transmission != current_config_ptr->sec_e_dch_transmission)
      {
        /* check whether rcvd config message STOPped E_DCH */
        if (FALSE == ordered_config_ptr->sec_e_dch_transmission)
        {
         /* set EUL action as START for L1 */
          current_config_ptr->l1_sec_e_req_mask = L1_EUL_START;

          rrcllc_update_l1_e_dl_info_for_old_config(FALSE, TRUE);
        }
        else /* it STARTed E_DCH  */
        {
          current_config_ptr->l1_sec_e_req_mask = L1_EUL_NOOP;
        }
      }
      else /* it can either reconfig or no-op */
      {
        if (FALSE == ordered_config_ptr->sec_e_dch_transmission)
        {
          /* set EUL action as STOP */
          ordered_config_ptr->l1_sec_e_req_mask = L1_EUL_NOOP;
        }
        else
        {
          /* L1 would have moved to the new config */
          current_config_ptr->l1_sec_e_req_mask = L1_EUL_START;

          rrcllc_update_l1_e_dl_info_for_old_config(FALSE
#ifdef FEATURE_WCDMA_DC_HSUPA
                                                   , TRUE
#endif /* FEATURE_WCDMA_DC_HSUPA */
                                                  );
        }
      }
    }
  }


  if(TRUE == current_config_ptr->sec_e_dch_transmission)
  {
    /*N/W may provide AGCH info for non eul serving RL. Currently L1 logic of detecting serving RL is based on 
     *AGCH info present it doesn't look at eul serving rl idx, So I don't indicate AGCH add/reconfig action for 
     *non-serving RL's. Later if this non-serving RL become serving EUL RL then we indicate AGCH as add even 
     *if N/W doesn't provide AGCH info in the reconfig message that trigger eul serving cell re-pointing, though 
     *spec clearly say N/W should provide AGCH info for serving rl but since some of the N/W doesn't comply with 
     *this we allow this kind of config 
     */
    rrcllc_clear_agch_chan_mask_for_non_serving_rl(current_config_ptr, TRUE);
  }

  /* no need to have msg high when E-DCH was not active before or after the
     receipt of reconfig message */
  if ((FALSE != ordered_config_ptr->sec_e_dch_transmission) ||
      (FALSE != current_config_ptr->sec_e_dch_transmission))
  {
    MSG_HIGH("DC_HSUPA: NewCC: l1_e: 0x%x(8/4/2/1:SP/D/U/S), mac_e: 0x%x(1/2/4: S/C/SP), e_dch_txn: %d",
      current_config_ptr->l1_sec_e_req_mask, 
      current_config_ptr->mac_sec_eul_action,
      current_config_ptr->sec_e_dch_transmission);

    MSG_5(MSG_SSID_DIAG, MSG_LEGACY_HIGH,
      "DC_HSUPA: OC: mac_eul_action: 0x%x, l1_e_req_mask: 0x%x, e_dch_txn: %d, is_hho: %d",
      ordered_config_ptr->mac_sec_eul_action, ordered_config_ptr->l1_sec_e_req_mask,
      ordered_config_ptr->sec_e_dch_transmission, ordered_config_ptr->sec_eul_is_hho, 0);
  }
}

#endif /* FEATURE_WCDMA_DC_HSUPA */
#ifdef FEATURE_QSH_EVENT_METRIC
/*===========================================================================
FUNCTION   rrcllc_qsh_log_w_to_w_ho_fail_stats

DESCRIPTION
  This function logs w to w HO fail stats

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static void rrcllc_qsh_log_w_to_w_ho_fail_stats(void)
{
  wrrc_call_end_data_log_type call_end_data;
  call_end_data.type = WRRC_CALL_END_TYPE_HO_FAIL;
  call_end_data.cause.ho_fail_type = SYS_HANDOVER_FAILURE_W_TO_W_FAILURE;
  wrrc_qsh_log_conn_end_info(WRRC_METRIC_LOG,&call_end_data);
}
#endif
/*===========================================================================
FUNCTION   rrcllc_is_oc_non_hho_config

DESCRIPTION
  Function checks if OC has HHO config 
  (OC has completely different set of RL when compared to CC)

DEPENDENCIES
  None.

RETURN VALUE
boolean

SIDE EFFECTS
  None.
===========================================================================*/

static boolean rrcllc_is_oc_hho_config()
{
  uint8 oc_rl_idx, cc_rl_idx;

  for(oc_rl_idx=0; oc_rl_idx<ordered_config_ptr->l1_dl_chan_parms.num_rl; oc_rl_idx++)
  {
    for(cc_rl_idx=0; cc_rl_idx<current_config_ptr->l1_dl_chan_parms.num_rl; cc_rl_idx++)
    {
      if(ordered_config_ptr->l1_dl_chan_parms.dl_per_rl[oc_rl_idx].pri_cpich_scr_code == current_config_ptr->l1_dl_chan_parms.dl_per_rl[cc_rl_idx].pri_cpich_scr_code)
      {
        /* OC has same RL as in CC, NON HHO case */
        return FALSE;
      }
    }
  }
  return TRUE;
}
/*===========================================================================
FUNCTION   rrcllc_chan_config_within_dch_for_old_config

DESCRIPTION
  This function is resposible for determining all actions on RLC, MAC
  and L1 when going back to old confuration in case of a physical channel
  failure within DCH.  Takes in boolean value to indicate wheter phy chan
  est or phy chan setup failed.  For setup failure, dpch action will be
  setup.  For establishment failure, dpch action will be reconfig(drop/add)

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static uecomdef_status_e_type
rrcllc_chan_config_within_dch_for_old_config(boolean est_fail)
{
  uint8   dl_cctrch_id;
  int     dch_count;
  uint8   dl_cctrch_id_in_use;
  boolean  dpch_reconfig_required = FALSE;
  uint8 hsdsch_count;
  uint8 queue_cnt=0;
  boolean hs_reset = FALSE;
  rrc_freq_type rrc_freq = rrc_ccm_get_curr_camped_freq();
#ifdef FEATURE_WCDMA_DC_HSDPA
  uint8 ix = 0;
#endif
rrcllc_mac_sync_with_l1_e_type sync_needed_btwn_mac_and_l1 = NO_SYNC_WITH_L1;

  WRRC_MSG2_HIGH("Chan_config_within_dch_for_old_config proc:rrc_proc_e_type_value%d, oc_status:rrcllc_oc_set_status_e_type_value%d",
           rrcllc_cmd_under_process.procedure,rrcllc_get_ordered_config_status_wo_f3());
#ifdef FEATURE_WCDMA_DC_HSDPA
  rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.revert_old_config = TRUE;
#endif

  rrcllc_set_e_req_mask_for_old_config(est_fail);


  rrcllc_set_cpc_dtx_req_mask_for_old_config(est_fail);


    rrcllc_set_cpc_drx_req_mask_for_old_config(est_fail);

#ifdef FEATURE_WCDMA_DC_HSUPA
    rrcllc_set_sec_e_req_mask_for_old_config(est_fail);
#endif

  dl_cctrch_id_in_use = dl_phychan_cctrch_id_in_use(&dpch_reconfig_required);

  WRRC_MSG2_HIGH("DPCH_DEBUG:dl_cctrch_id_in_use=%d,dpch_reconfig_required=%d",dl_cctrch_id_in_use,dpch_reconfig_required);

  /* check whether old configuration involved HHO and also set the other bitmasks before
  copying CC to OC */
  if (ordered_config_ptr->dest_freq_present)
  {
#ifdef FEATURE_QSH_EVENT_METRIC  
    rrcllc_qsh_log_w_to_w_ho_fail_stats();
#endif   
    /* check whether it was same as before (intra freq HHO0 */
    if (ordered_config_ptr->dest_freq == rrc_freq)
    {
      WRRC_MSG2_HIGH("Old reconfig was intra-freq HHO. HHO type %d [0-INIT, 1- MAINTAIN], Dest freq in oc %d", ordered_config_ptr->l1_dl_chan_parms.dl_common.dpch_common.timing_ind, ordered_config_ptr->dest_freq);
      if(ordered_config_ptr->
          l1_dl_chan_parms.dl_common.dpch_common.timing_ind ==
          L1_TIMING_IND_INIT)
      {
        rrcsmc_revert_to_old_cipher_config_db();
        rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.hho_setup_mask |=
        CPHY_HHO_INTRAF_TI_HHO_INCL;
      }
	  /*Requirement from L1: if OC config is a HHO config only fill hho setup mask as  CPHY_HHO_INTRAF_TM_HHO_INCL
            For forced SYNC A cases, fill HHO setup mask to CPHY_HHO_NOT_A_HHO_INCL*/		  
      else if(TRUE == rrcllc_is_oc_hho_config())
      {
        rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.hho_setup_mask |=
        CPHY_HHO_INTRAF_TM_HHO_INCL;
      }
      else
      {
        rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.hho_setup_mask |=
        CPHY_HHO_NOT_A_HHO_INCL;
      }
    }
    else
    {
      WRRC_MSG2_HIGH("Old reconfig was inter-freq HHO. HHO type %d [0-INIT, 1- MAINTAIN], Dest freq in oc %d", ordered_config_ptr->l1_dl_chan_parms.dl_common.dpch_common.timing_ind, ordered_config_ptr->dest_freq);
      if(ordered_config_ptr->
          l1_dl_chan_parms.dl_common.dpch_common.timing_ind ==
          L1_TIMING_IND_INIT)
      {
        rrcsmc_revert_to_old_cipher_config_db();
        rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.hho_setup_mask |=
        CPHY_HHO_INTERF_TI_HHO_INCL;
      }
      else
      {
        rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.hho_setup_mask |=
        CPHY_HHO_INTERF_TM_HHO_INCL;
      }
    }

    /* always populate the old frequency while going back to old configuration */
    rrcllc_cmd_under_process.chan_config.new_freq = TRUE;
    rrcllc_cmd_under_process.is_hho_in_dch = TRUE;

  }
  else
  {
    WRRC_MSG0_HIGH("Going back to old config for seamless reconfig");
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.hho_setup_mask= 
      CPHY_HHO_NOT_A_HHO_INCL;
  }
#ifdef FEATURE_WCDMA_DC_HSUPA

  /* If it is HHO on primary, it is hho on secondary also. 
     In case of DCHSUPA stop, sec_eul_is_hho will not be set to TRUE. 
     So when reverting to old config on such cases, checking sec_eul_is_hho doesnt look correct */
  /* for cases where only sec_is_hho is TRUE, and primary is_hho is not TRUE, CPHY_SETUP failure due to 
     ACQ failure on secondary should not happen. */
  /* dest_freq_present is a super set of is_hho flag. Using this to include
     secondary freq.*/
  if (ordered_config_ptr->dest_freq_present)
  {

// check whether do we need to set sec eul hho bitmask type
    
    /* always populate the old frequency while going back to old configuration */
    rrcllc_cmd_under_process.chan_config.sec_eul_new_freq = TRUE;
    rrcllc_cmd_under_process.is_hho_in_dch_for_sec_eul = TRUE;

   /* L1 is no longer using sec_hho_setup_mask. The following code needs cleanup */

    if(current_config_ptr->sec_e_dch_transmission)
    {
        if(ordered_config_ptr->sec_eul_dest_freq == current_config_ptr->sec_eul_dest_freq)
        {
          WRRC_MSG1_HIGH("DC_HSUPA:Old reconfig was intra-freq HHO. HHO type %d [0-INIT, 1- MAINTAIN]",ordered_config_ptr->l1_dl_chan_parms.dl_common.dpch_common.timing_ind);
          if(ordered_config_ptr->
              l1_dl_chan_parms.dl_common.dpch_common.timing_ind ==
              L1_TIMING_IND_INIT)
          {
            rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.sec_hho_setup_mask |=
            CPHY_HHO_INTRAF_TI_HHO_INCL;
          }
          else
          {
            rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.sec_hho_setup_mask |=
            CPHY_HHO_INTRAF_TM_HHO_INCL;
          }
        }
        else
        {
          WRRC_MSG1_HIGH("DC_HSUPA: Old reconfig was inter-freq HHO. HHO type %d [0-INIT, 1- MAINTAIN]",ordered_config_ptr->l1_dl_chan_parms.dl_common.dpch_common.timing_ind);
          if(ordered_config_ptr->
              l1_dl_chan_parms.dl_common.dpch_common.timing_ind ==
              L1_TIMING_IND_INIT)
          {
            rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.sec_hho_setup_mask |=
            CPHY_HHO_INTERF_TI_HHO_INCL;
          }
          else
          {
            rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.sec_hho_setup_mask |=
            CPHY_HHO_INTERF_TM_HHO_INCL;
          }
        }

        
    }
    else
    {
      WRRC_MSG0_HIGH("DC_HSUPA: Going back to old config for seamless reconfig");
      rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.sec_hho_setup_mask= 
        CPHY_HHO_NOT_A_HHO_INCL;
    }

  }
  else
  {
    WRRC_MSG0_HIGH("DC_HSUPA: Going back to old config for seamless reconfig");
    rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.sec_hho_setup_mask= 
      CPHY_HHO_NOT_A_HHO_INCL;
  }

#endif



  /* If needed revert back to old FRESH value, if the message from which this 
     function is called results in SRNS relocation.
     We need to revert to old FRESH value if IE integrity protection mode info is 
     provided in the reconfig message (i.e. if its a SRNS relocation scenario) */
  rrcsmc_revert_back_to_old_fresh_for_srns_relocation();
    MSG_HIGH("hs-reset-ind %d, active-to-inactive %d, inactive-to-active %d",
		ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator,
		rrcllc_cmd_under_process.chan_config.hsdpa_active_to_inactive,
		rrcllc_cmd_under_process.chan_config.hsdpa_inactive_to_active);

  if((ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator == TRUE) ||
      (rrcllc_cmd_under_process.chan_config.hsdpa_active_to_inactive == TRUE))
  {

    WRRC_MSG0_HIGH("RRCHS: HSReset on New Config indicated");
    hs_reset = TRUE;
  }

  rrcllc_copy_cc_to_oc();
  ordered_config_ptr->mac_ul_parms.new_tfcs_list_present = TRUE;


  /* No activation time when configuring MAC due to Security Mode Command */
  if((rrcllc_cmd_under_process.chan_config.current_cmd_engine == LLC_CHAN_CONFIG_ENGINE) &&
    (rrcllc_cmd_under_process.procedure != RRC_PROCEDURE_SMC))
  {
    if((rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_DCH) &&
      (ordered_config.set_status != OC_SET_FOR_DCH_FACH_TRANS))
    {
    /* There is no solo BCH operation in this case, so use
    * Ordered Config Pointer.
      */
      if(ordered_config_ptr->reconfig_needed.downlink_l1)
      {
        sync_needed_btwn_mac_and_l1 = SYNC_WITH_L1;
      }
    }
  }
  /* set the bitmask to indicate l1 that this channel config is to go
     back to old configuration */
  /* Requirement from L1: For foced sync A failure, do not set hho_setup_mask to CPHY_HHO_RESUME_TO_OLD_CONFIG_HHO_INCL. */
  if(!(rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.hho_setup_mask & CPHY_HHO_NOT_A_HHO_INCL))
 {
   rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.hho_setup_mask |=
    CPHY_HHO_RESUME_TO_OLD_CONFIG_HHO_INCL;
 }

#ifdef FEATURE_WCDMA_DC_HSUPA
  rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.sec_hho_setup_mask |=
    CPHY_HHO_RESUME_TO_OLD_CONFIG_HHO_INCL;

#endif


  ordered_config_ptr->dest_freq = rrc_freq;
  /* Make sure MAC and L1 UL and DL are configured always */
  ordered_config_ptr->reconfig_needed.uplink_l1 = TRUE;
  ordered_config_ptr->reconfig_needed.downlink_l1 = TRUE;
  ordered_config_ptr->reconfig_needed.downlink_mac = TRUE;
  ordered_config_ptr->reconfig_needed.uplink_mac = TRUE;

  /* make activation time as NOW, going back to old configuration
  should always have "NOW" */
  ordered_config_ptr->activation_time = RRCLLC_ACTIVATION_TIME_NOW;
  ordered_config_ptr->act_time_type   = L1_ACTIVATION_TIME_NONE;


  /*crc:kiran:- Will this creat out of sync in DTX operation Btween UE & N/W..?
  *do we need to set enabling_delay = 0...?
  */
  WRRC_MSG0_HIGH("RRCCPC:Going back to old config, set enabling_delay as Zero");
  ordered_config_ptr->dtx_drx_timing_info.enabling_delay = 
    L1_NUM_RADIO_FRAMES_0;


    /*  If there was an establishement indication failure, then RRC needs to send
     *  a drop for the CPHY_SETUP_REQ that failed, and and ADD to go back to old config.
     *  If its just a setup failure, then RRC needs to just send an add to go back to old config.
     */
    if (est_fail)
    {

      WRRC_MSG0_HIGH("L1 DPCH ACTION RECONFIG");
      rrcllc_cmd_under_process.chan_config.phy_chan_action_list.dl_dpch_action =
        LLC_PHYCHAN_RECONFIG;
      rrcllc_cmd_under_process.chan_config.phy_chan_action_list.ul_dpch_action =
        LLC_PHYCHAN_RECONFIG;
    }
    else
    {
      WRRC_MSG0_HIGH("L1 DPCH ACTION SETUP");
      /* set the action based on the return value of L1 functions. 
       * if return value is true, that means DPCH is active in which case a reconfig
       * is needed to go back to old configuration.  if FALSE, this implies DPCH is not up, 
       * so the dpch_action need to indicate setup for the old configuration.
       */
      /* if dl_phychan_cctrch_id_in_use returns 0xFF, that means no hw channel
       * associated with DPCH.  L1 will need a setup.  Else L1 needs a reconfig.
       */
      if (dpch_reconfig_required == TRUE)
      {
        rrcllc_cmd_under_process.chan_config.phy_chan_action_list.dl_dpch_action =
          LLC_PHYCHAN_RECONFIG;
      }
      else
      {
        rrcllc_cmd_under_process.chan_config.phy_chan_action_list.dl_dpch_action =
          LLC_PHYCHAN_SETUP;
      }

      if (ul_phychan_is_ul_dpch_active()) 
      {
        rrcllc_cmd_under_process.chan_config.phy_chan_action_list.ul_dpch_action =
          LLC_PHYCHAN_RECONFIG;
      }
      else
      {
        rrcllc_cmd_under_process.chan_config.phy_chan_action_list.ul_dpch_action =
          LLC_PHYCHAN_SETUP;
      }
      WRRC_MSG2_HIGH("L1 DL DPCH ACTION %d, UL DPCH ACTION %d [1-SETUP, 3-RECONFIG]",rrcllc_cmd_under_process.chan_config.phy_chan_action_list.dl_dpch_action, rrcllc_cmd_under_process.chan_config.phy_chan_action_list.ul_dpch_action);
      /* Since a new DPCH is being established, initialize the Transport channel
       * bitflag to DCH
       */
      rrcllc_semi_permanent_data.dl_phy_chan.dl_dpch.trch_ref_type_bf =
        L1_DL_TRCH_REFTYPE_DCH_BF;
      rrcllc_semi_permanent_data.dl_phy_chan.dl_dpch.trch_enable_bf =
        L1_DL_TRCH_REFTYPE_DCH_BF;
    }

    /* Check which CCTRCH id is used by DL L1.  This is needed as L1 needs a new CCTRCH id
     * for each new reconfig msg otherwise their validation will fail.  If L1 DL is already
     * using the new CCTRCH id, this means it has committed to the new config.  Action
     * should be reconfig, which is drop and add.  Else action should be stop. 
     */

    if ((dl_cctrch_id_in_use != rrcllc_semi_permanent_data.dl_phy_chan.dl_dpch.cctrch_id)
        && (dpch_reconfig_required == TRUE))
    {
      /* L1 is still on old CCTRCH id.  No need to get new CCTRCH id.  Keep using the one
       * in semi permanent data
       */
      dl_cctrch_id = rrcllc_semi_permanent_data.dl_phy_chan.dl_dpch.cctrch_id;
    }
    else
    {
      /* If a valid CCTrCH ID exists for DL DPCH, add it to release list */
      if(rrcllc_semi_permanent_data.dl_phy_chan.dl_dpch.cctrch_id !=
         RRCLLC_INVALID_CCTRCH_ID)
      {
        RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.dl_phy_chan.
                                             dl_dpch.cctrch_id);
      }
      /* Get a new CCTrCH ID */
      dl_cctrch_id = rrcllc_get_cctrch_id();
    }

    if(dl_cctrch_id != RRCLLC_INVALID_CCTRCH_ID)
    {
      /* Update DCH info in MAC Ordered Config */
      for(dch_count=0; dch_count < ordered_config_ptr->mac_dl_parms.num_dchs; dch_count++)
      {
        ordered_config_ptr->mac_dl_parms.dch_info[dch_count]->cctrch_id
          = dl_cctrch_id;
      }
      if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
      {
        WRRC_MSG0_HIGH("RRCHS:Set hs_req_mask to Zero");
        ordered_config_ptr->l1_hsdpa_info.hs_req_mask = 0;

        if (est_fail == TRUE)
        {
          /* Check current HSDPA status */
          if ((rrcllc_cmd_under_process.chan_config.hsdpa_active_to_inactive == FALSE) &&
              (rrcllc_cmd_under_process.chan_config.hsdpa_inactive_to_active == FALSE) &&
              (rrc_get_hsdpa_status() == HSDPA_ACTIVE))
          {
#ifdef FEATURE_WCDMA_MIMO
             if(rrcllc_get_mimo_status() == RRC_MIMO_ACTIVE)
             {
                ordered_config_ptr->l1_hsdpa_info.hs_req_mask |=CPHY_HS_MIMO_CFG_INCL;
                ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_RECFG;
             }
             else
             {
               if(hs_get_mimo_state() == TRUE)
               {
                 ordered_config_ptr->l1_hsdpa_info.hs_req_mask |= CPHY_HS_MIMO_CFG_INCL;
                 ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_STOP;
               }
               else
               {
                 ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_NOOP;
               }
             }
             WRRC_MSG1_HIGH("MIMO:Set MIMO Action to %d [0-NOOP, 2-RECFG, 3-STOP]",ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action);
#endif
            if(rrcllc_cmd_under_process.chan_config.hsdpa_hs_to_ehs)
            {
              rrcllc_update_hsdpa_mac_action_l1_ops_for_old_config(
                 HSDPA_SETUP_OPS_RECFG,
                 MAC_EHS_TO_HS);
            }
            else if (rrcllc_cmd_under_process.chan_config.hsdpa_ehs_to_hs)
            {
              
              rrcllc_update_hsdpa_mac_action_l1_ops_for_old_config(
                HSDPA_SETUP_OPS_RECFG,
                MAC_HS_TO_EHS);
            }
            else 
            {
            WRRC_MSG0_HIGH("HSCUR ACT, HSPRE ACT, RES ACT");
              rrcllc_update_hsdpa_mac_action_l1_ops_for_old_config(HSDPA_SETUP_OPS_RECFG
              ,  MAC_HS_NO_TRANSITION);
            }
            if(hs_reset == TRUE)
            {
              WRRC_MSG0_HIGH("RRCHS: Restore TSN");
              hsdpa_msg_params.mac_hs_restore_tsns = TRUE;
            }
          }
          
          else if (rrcllc_cmd_under_process.chan_config.hsdpa_active_to_inactive == TRUE)
          {
#ifdef FEATURE_WCDMA_MIMO
             if(rrcllc_get_mimo_status() == RRC_MIMO_ACTIVE)
             {
                ordered_config_ptr->l1_hsdpa_info.hs_req_mask |=CPHY_HS_MIMO_CFG_INCL;
                ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_START;
             }
             else
             {
               if(hs_get_mimo_state() == TRUE)
               {
                 ordered_config_ptr->l1_hsdpa_info.hs_req_mask |=CPHY_HS_MIMO_CFG_INCL;
                 ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_STOP;
               }
               else
               {
                 ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_NOOP;
               }
             }
             WRRC_MSG1_HIGH("MIMO:Set MIMO Action to %d [0-NOOP,1-START,3-STOP]",ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action);
#endif

            rrcllc_update_hsdpa_mac_action_l1_ops_for_old_config(HSDPA_SETUP_OPS_START
,MAC_HS_NO_TRANSITION
); 
            /*Set Status as Inactive in RRC, as MAC has already the HS status updated 
              as Inactive.RRC and MAC needs to be in Sync.*/
            rrc_set_hsdpa_status(HSDPA_INACTIVE);

#ifdef FEATURE_WCDMA_HS_FACH
            /*To be on safer side, set HS status in FACH to FALSE here.*/
            rrcllc_set_hs_status_in_e_fach(ordered_config_ptr, FALSE);
#endif /*FEATURE_WCDMA_HS_FACH*/

            rrcllc_cmd_under_process.chan_config.hsdpa_active_to_inactive= FALSE;
            rrcllc_cmd_under_process.chan_config.hsdpa_inactive_to_active = TRUE;
            if(hs_reset == TRUE)
            {
              WRRC_MSG0_HIGH("RRCHS: Restore TSN");
              hsdpa_msg_params.mac_hs_restore_tsns = TRUE;
            }
          }
          
          else if (rrcllc_cmd_under_process.chan_config.hsdpa_inactive_to_active == TRUE)
          {
#ifdef FEATURE_WCDMA_MIMO
           rrcllc_init_mimo_params(ordered_config_ptr);
#endif

#ifdef FEATURE_WCDMA_DC_HSDPA
           rrcllc_init_sec_hsdpa_params(ordered_config_ptr);
#endif /*FEATURE_WCDMA_DC_HSDPA*/

            rrcllc_update_hsdpa_mac_action_l1_ops_for_old_config(HSDPA_SETUP_OPS_STOP
            ,MAC_HS_NO_TRANSITION
);
            rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.hsdpa_l1_ops = 
                 HSDPA_SETUP_OPS_NOOP;
            /*Set Status as active in RRC, as MAC has already the HS status updated as active.
              RRC and MAC needs to be in Sync.*/
            rrc_set_hsdpa_status(HSDPA_ACTIVE);
            rrcllc_cmd_under_process.chan_config.hsdpa_inactive_to_active = FALSE;
            rrcllc_cmd_under_process.chan_config.hsdpa_active_to_inactive = TRUE;
            WRRC_MSG0_HIGH("RRCHS: GOing to old config,L1 action NOOP and MAC Action Stop");
          }
          else
          {
#ifdef FEATURE_WCDMA_MIMO
             rrcllc_init_mimo_params(ordered_config_ptr);
#endif
#ifdef FEATURE_WCDMA_DC_HSDPA
            rrcllc_init_sec_hsdpa_params(ordered_config_ptr);
#endif /*FEATURE_WCDMA_DC_HSDPA*/

            rrcllc_update_hsdpa_mac_action_l1_ops_for_old_config(HSDPA_SETUP_OPS_NOOP
            ,MAC_HS_NO_TRANSITION
);

            rrcllc_cmd_under_process.chan_config.hsdpa_inactive_to_active = FALSE;
            rrcllc_cmd_under_process.chan_config.hsdpa_active_to_inactive = FALSE;
          }
          
        } /* End of Est Failure */
        else
        {
          /* In this case, we need to call L1 fn to determine where L1 is as for HSDPA as it 
          cannot guarantee if it would have acted on the last HSDPA Configuration */
        
          /* Get current status of HSDPA */
          if (rrc_get_hsdpa_status() == HSDPA_ACTIVE)
          {
            /* Reinitialize the variables */
            rrcllc_cmd_under_process.chan_config.hsdpa_inactive_to_active = FALSE;
            rrcllc_cmd_under_process.chan_config.hsdpa_active_to_inactive = FALSE;
            
            /* Call L1 fn */
            if (hs_get_cur_state() == FALSE)
            {
              WRRC_MSG0_HIGH("RRCHS: L1 HSACT:START, MAC:RECFG");
              rrcllc_update_hsdpa_mac_action_l1_ops_for_old_config(HSDPA_SETUP_OPS_START
                ,MAC_HS_NO_TRANSITION
);
              
              /* Send Reconfig if HS is already active at MAC */
              if(mac_is_hs_cfg_active() == TRUE)
              {
                ordered_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_RECONFIG;
                rrc_set_hsdpa_action(HSDPA_RECONFIG);
              }
              else
              {
                /*Send Start, as HS is stopped at MAC even-though cphy setup is failed  */
                ordered_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_START;
                rrc_set_hsdpa_action(HSDPA_START);
              }


#ifdef FEATURE_WCDMA_MIMO
              if(rrcllc_get_mimo_status() == RRC_MIMO_ACTIVE)
              {
                if(hs_get_mimo_state() == TRUE)
                {
                  ordered_config_ptr->l1_hsdpa_info.hs_req_mask |=CPHY_HS_MIMO_CFG_INCL;
                  ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_RECFG;
                }
                else
                {
                  ordered_config_ptr->l1_hsdpa_info.hs_req_mask |=CPHY_HS_MIMO_CFG_INCL;
                  ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_START;
                }
              }
              else
              {
                if(hs_get_mimo_state() == TRUE)
                {
                  ordered_config_ptr->l1_hsdpa_info.hs_req_mask |=CPHY_HS_MIMO_CFG_INCL;
                  ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_STOP;
                }
                else
                {
                  ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_NOOP;
                }
              }
              WRRC_MSG1_HIGH("MIMO:Set MIMO Action to %d [0-NOOP,1-START,2-RECONFIG,4-STOP]",ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action);
#endif

            }
            else
            {
              if(rrcllc_cmd_under_process.chan_config.hsdpa_hs_to_ehs)
              {
                rrcllc_update_hsdpa_mac_action_l1_ops_for_old_config(HSDPA_SETUP_OPS_RECFG,MAC_EHS_TO_HS);
              }
              else if (rrcllc_cmd_under_process.chan_config.hsdpa_ehs_to_hs)
              {
                rrcllc_update_hsdpa_mac_action_l1_ops_for_old_config(HSDPA_SETUP_OPS_RECFG,MAC_HS_TO_EHS);
              }
              else
              {
                WRRC_MSG0_HIGH("RRCHS: L1 HSACT:RECFG, MAC:RECFG");
                rrcllc_update_hsdpa_mac_action_l1_ops_for_old_config(HSDPA_SETUP_OPS_RECFG
                ,MAC_HS_NO_TRANSITION
);
              
              }
#ifdef FEATURE_WCDMA_MIMO
              if(rrcllc_get_mimo_status() == RRC_MIMO_ACTIVE)
              {
                if(hs_get_mimo_state() == TRUE)
                {
                  ordered_config_ptr->l1_hsdpa_info.hs_req_mask |=CPHY_HS_MIMO_CFG_INCL;
                  ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_RECFG;
                }
                else
                {
                  ordered_config_ptr->l1_hsdpa_info.hs_req_mask |=CPHY_HS_MIMO_CFG_INCL;
                  ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_START;
                }
              }
              else
              {
                if(hs_get_mimo_state() == TRUE)
                {
                  ordered_config_ptr->l1_hsdpa_info.hs_req_mask |=CPHY_HS_MIMO_CFG_INCL;
                  ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_STOP;
                }
                else
                {
                  ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_NOOP;
                }
              }
              WRRC_MSG1_HIGH("MIMO:Set MIMO Action to %d [0-NOOP,1-START,2-RECONFIG,3-STOP]",ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action);
#endif

            }
            
            ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator = FALSE;
          /* If sync between mac and l1 is not set, MAC will apply the config right away. 
             In that case, we should restore the old TSNs */
            if((hs_reset == TRUE) && (sync_needed_btwn_mac_and_l1 == NO_SYNC_WITH_L1))
            {
              WRRC_MSG0_HIGH("RRCHS: Restore TSN");
              hsdpa_msg_params.mac_hs_restore_tsns = TRUE;
            }
          } /* HSDPA on old CFG active */
          else
          {
            WRRC_MSG0_HIGH("RRCHS:HSDPA InActive on OldCfg, L1 HSACT:NOOP, MAC:NOOP");

            /* Reinitialize the variables */
            rrcllc_cmd_under_process.chan_config.hsdpa_inactive_to_active = FALSE;
            rrcllc_cmd_under_process.chan_config.hsdpa_active_to_inactive = FALSE;

 #ifdef FEATURE_WCDMA_MIMO
            rrcllc_init_mimo_params(ordered_config_ptr);
 #endif
#ifdef FEATURE_WCDMA_DC_HSDPA
            rrcllc_init_sec_hsdpa_params(ordered_config_ptr);
#endif /*FEATURE_WCDMA_DC_HSDPA*/

            rrcllc_update_hsdpa_mac_action_l1_ops_for_old_config(HSDPA_SETUP_OPS_NOOP
 ,MAC_HS_NO_TRANSITION
 );
          }
        }
        
        if ((rrc_get_hsdpa_action() == HSDPA_START) ||
            (rrc_get_hsdpa_action() == HSDPA_RECONFIG))
        {
          if(ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_EHS)
          {
            for(queue_cnt=0;queue_cnt<ordered_config_ptr->mac_dl_parms.num_mac_ehs_queue;queue_cnt++)
            {
              ordered_config_ptr->mac_ehs_queue_info[queue_cnt].cctrch_id = dl_cctrch_id;
            }
          }
          else if(ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs  == MAC_HS)
          {
          /* Update HS-DSCH info in MAC Ordered Config */
          for(hsdsch_count=0; hsdsch_count < ordered_config_ptr->mac_dl_parms.num_dflow; hsdsch_count++)
          {
            WRRC_MSG1_HIGH("RRCHS: New CCTRCH ID for HS %d", dl_cctrch_id);
            /* Set CCTRCH ID in HSDPA structure */

            ordered_config_ptr->mac_dl_parms.hsdpa_info[hsdsch_count]->cctrch_id
              = dl_cctrch_id;
          }
          }
          /* Set CCTRCH in L1 HSDSCH information */
          ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.cctrch_id = dl_cctrch_id;
          
          ordered_config_ptr->l1_hsdpa_info.hs_req_mask |= (CPHY_HS_DSCH_CFG_INCL |
            CPHY_HS_PDSCH_RL_CFG_INCL | CPHY_HS_SCCH_CFG_INCL | CPHY_HS_DPCCH_CFG_INCL);
 #ifdef FEATURE_WCDMA_MIMO
          if(rrcllc_get_mimo_status() == RRC_MIMO_ACTIVE)
          {
            if(!(ordered_config_ptr->l1_hsdpa_info.hs_req_mask & CPHY_HS_MIMO_CFG_INCL))
            {
              ordered_config_ptr->l1_hsdpa_info.hs_req_mask |=CPHY_HS_MIMO_CFG_INCL;
              ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_RECFG;
            }
          }
          else
          {
            if(!(ordered_config_ptr->l1_hsdpa_info.hs_req_mask & CPHY_HS_MIMO_CFG_INCL))
            {
              ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_NOOP;
            }
          }
            WRRC_MSG1_HIGH("MIMO: l1_mimo_action = %d",ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action);
#endif         

#ifdef FEATURE_WCDMA_DC_HSDPA
         for(ix=0; ix<MAX_NUM_OF_SEC_CARRIERS; ix++)
         {
           if(ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[ix].sec_hsdpa_action == L1_SEC_HSDPA_RECFG)
          {
            ordered_config_ptr->l1_hsdpa_info.hs_req_mask |=CPHY_HS_SEC_HSDPA_CFG_INCL;
             break;
            }
         }
#endif
          /* Set beta table and hs-dpcch bit mask */
          ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 
            HS_DPCCH_BETA_HS_INFO_PRESENT_BITMASK | HS_DPCCH_MEAS_FEEDBACK_INFO_PRESENT_BITMASK;

          rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.hsdpa_l1_info =
            &ordered_config_ptr->l1_hsdpa_info;
          
          if (rrcllc_check_if_hsdpa_can_be_started_reconfigured(ordered_config_ptr) == FALSE)
          {
            WRRC_MSG0_ERROR("RRCHS:hsdpaconfigcomplete NOT");
            return FAILURE;
          }
        }
      }
      /* Update DPCH Info in rrcllc_cmd_under_process - this presumes that
       * there is only 1 DPCH
       */
      rrcllc_semi_permanent_data.dl_phy_chan.dl_dpch.cctrch_id =
        dl_cctrch_id;
    }
    else
    {
      WRRC_MSG1_ERROR("Invalid CCTrCH ID %d assigned", dl_cctrch_id);
      return(FAILURE);
    }

  return(SUCCESS);
} /* rrcllc_chan_config_within_dch */


/*===========================================================================
FUNCTION   rrcllc_chan_config_for_oos_within_fach

DESCRIPTION
  This function is resposible for determining all actions on RLC, MAC
  and L1.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static uecomdef_status_e_type
rrcllc_chan_config_for_oos_within_fach(rrc_cmd_type *cmd_ptr)
{
  WRRC_MSG2_HIGH("Chan_config_for_oos_within_fach proc:rrc_proc_e_type_value%d, oc_status:rrcllc_oc_set_status_e_type_value%d",
           rrcllc_cmd_under_process.procedure,rrcllc_get_ordered_config_status_wo_f3());

  if(cmd_ptr->cmd.chan_config_req.procedure == RRC_PROCEDURE_CSP)
  {
    if((cmd_ptr->cmd.chan_config_req.release_trchls) &&
       (cmd_ptr->cmd.chan_config_req.release_phychls))
    {
      /* This is a special case for releasing only physical and
       * transport channels, keeping the logical channels as they are.
       */
      rrcllc_cmd_under_process.chan_config.current_cmd_engine =
        LLC_RELEASE_TR_PHY_CHAN_ENGINE;

      /* if TOC is TOC_FOR_OOS then don't updat toc with CC */
      if ((transition_config.toc_usage != TOC_FOR_OOS) 
          && (transition_config.toc_usage!=TOC_FOR_OOS_WITH_DCH_INFO)
          && (transition_config.toc_usage!=TOC_FOR_OOS_WITHOUT_DCH_INFO)
          )
      {
        /* Also copy the RNTI Info from TOC to OC */
        transition_config.toc_ptr->mac_ul_parms.rnti_info =
          current_config_ptr->mac_ul_parms.rnti_info;
        transition_config.toc_ptr->mac_dl_parms.rnti_info =
          current_config_ptr->mac_dl_parms.rnti_info ;
#ifdef FEATURE_WCDMA_HS_RACH
        /* Checking camped cell supports HSRACH is not correct here
          because when CSP posts rel trch and phch and we hit this code
          sibdb doesnt have an active cell so take ernti back up blndly */
          transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = 
           current_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present;
          transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti = 
           current_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti;

#endif
      }
#ifdef FEATURE_WCDMA_HS_FACH
      if(current_config_ptr->efach_hrnti_status == DEDICATED_HRNTI)
      {
        WRRC_MSG1_HIGH("EFACH: Backup HRNTI from CC to TOC : 0x%x",current_config_ptr->efach_hrnti);
        transition_config.toc_ptr->efach_hrnti = current_config_ptr->efach_hrnti;
        transition_config.toc_ptr->efach_hrnti_status = DEDICATED_HRNTI;
      }
#endif

      /* Now delete C-RNTI from CC */
      if (current_config_ptr->mac_ul_parms.rnti_info.rnti_valid == BOTH_VALID)
      {
        current_config_ptr->mac_ul_parms.rnti_info.rnti_valid = URNTI_VALID;
        current_config_ptr->mac_dl_parms.rnti_info.rnti_valid = URNTI_VALID;
      }
      else if (current_config_ptr->mac_ul_parms.rnti_info.rnti_valid == CRNTI_VALID)
      {
        current_config_ptr->mac_ul_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
        current_config_ptr->mac_dl_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
      }

#ifdef FEATURE_WCDMA_HS_RACH
          /* Clear ERNTI in CC. Later when CC gets copied to OC, we do not want
             ernti to be configured. ERNTI will be restored from TOC if we 
             camp back on same cell */
      current_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = FALSE;

#endif

      rrcllc_copy_cc_to_oc();
      /* copy rlc parameters dcch+dtch mapping on fach/rach to TOC so that
      we can copy them back to cc once ue re-enters service area and we need
      to setup dcch+dtch along with
      ccch */

      /* if TOC is TOC_FOR_OOS then don't updat toc with CC */
      if ((transition_config.toc_usage != TOC_FOR_OOS) 
          && (transition_config.toc_usage!=TOC_FOR_OOS_WITH_DCH_INFO)
          && (transition_config.toc_usage!=TOC_FOR_OOS_WITHOUT_DCH_INFO)
          )
      {

#ifdef FEATURE_UMTS_PDCP
        /* Copy all pdcp info into TOC */
        rrcllc_copy_pdcp_parms(transition_config.toc_ptr, current_config_ptr);
#endif  /* FEATURE_UMTS_PDCP*/

        rrcllc_init_reestablish_entity(ORDERED_AND_CURRENT_CONFIG);
        if(current_config_ptr->rlc_am_parms.nentity == 0 )
        {
          WRRC_MSG0_ERROR("Num AM entity in Current config is 0");
        }
        /* Copy all RLC Config data for AM channels */
        rrcllc_copy_rlc_parms(transition_config.toc_ptr, current_config_ptr);

        /* Copy over the RB-oriented side of RLC size restrictions */
        rrcllc_copy_cell_fach_rlc_size_list(transition_config.toc_ptr, current_config_ptr);

        /* Save dcch+dtch mapping on fach/rach in to toc */
        rrcllc_copy_cell_fach_rb_mapping_info(transition_config.toc_ptr, current_config_ptr);
      }
      /* Initailize MAC data to release all Transport Channels */
      rrcllc_init_ordered_config_mac_info(ORDERED_CONFIG);
      
      rrcllc_restore_urnti_to_oc_from_toc();
      /* Indicate that both Downlink and Uplink MAC need to be reconfigured */
      ordered_config_ptr->reconfig_needed.downlink_mac = TRUE;
      ordered_config_ptr->reconfig_needed.uplink_mac = TRUE;

      /* Return from here as no other data in Channel Config Request
       * is relevant.
       */
      WRRC_MSG0_HIGH("Released Phy and Tr Chls");
/* Store the cell capability of previous cell */
      rrcllc_store_last_active_cell_capability();
    }
  } /* Normal, regular case */
  return(SUCCESS);
} /* rrcllc_chan_config_for_oos_within_fach */

/*===========================================================================
FUNCTION   rrcllc_chan_config_for_oos_within_fach

DESCRIPTION
  This function is resposible for determining all actions on RLC, MAC
  and L1 when Re-direction info is received in OTA msg for FACH->FACh.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static uecomdef_status_e_type
rrcllc_chan_config_within_fach_for_redirection(rrc_cmd_type *cmd_ptr)
{
  int i;

  rrcllc_bch_op_e_type  bch_op = RRCLLC_NO_OP_BCH;
  rrcllc_ccch_op_e_type  ccch_op = RRCLLC_NO_OP_CCCH;
#ifdef FEATURE_UPDATE_SIB7_IN_FACH
  ordered_config_type  *config_ptr = ordered_config_ptr;
#endif/* FEATURE_UPDATE_SIB7_IN_FACH*/
  uint8  cctrch_id;

  rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;

  for (i=0; i<cmd_ptr->cmd.chan_config_req.num_rb_to_config; i++)
  {
    if((cmd_ptr->cmd.chan_config_req.rb[i].rb_id == BCCH_S_RADIO_BEARER_ID) &&
        (cmd_ptr->cmd.chan_config_req.rb[i].rb_config == RELEASE_RB))
    {
      rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;
      bch_op = RRCLLC_DROP_BCH;
    }
    else if((cmd_ptr->cmd.chan_config_req.rb[i].rb_id == CCCH_RADIO_BEARER_ID) &&
        (cmd_ptr->cmd.chan_config_req.rb[i].rb_config == RECONFIG_RB))
    {
      ccch_op = RRCLLC_RECONFIG_CCCH;
  
      /* Also copy the RNTI Info from TOC to OC */
      current_config_ptr->mac_ul_parms.rnti_info=
         transition_config.toc_ptr->mac_ul_parms.rnti_info;
      current_config_ptr->mac_dl_parms.rnti_info =
         transition_config.toc_ptr->mac_dl_parms.rnti_info ;
  
      ordered_config_ptr->mac_ul_parms.rnti_info=
         transition_config.toc_ptr->mac_ul_parms.rnti_info;
      ordered_config_ptr->mac_dl_parms.rnti_info =
         transition_config.toc_ptr->mac_dl_parms.rnti_info ;
      /*CCM has requested to reconfigure CCCH and Release S-BCCH which was after cell selection in FACH
        Do not break, Go ahead and update the bch_op variable*/
  
      /* Initialize Send MAC Uplink Config indicator to TRUE */
      WRRC_MSG0_HIGH("Configure UL MAC also");
      rrcllc_semi_permanent_data.send_mac_uplink_config = TRUE;
      ordered_config_ptr->reconfig_needed.uplink_mac = TRUE;
    }
  }
  
  if (ccch_op == RRCLLC_RECONFIG_CCCH)
  {
    rrcllc_copy_cc_to_oc();
    if (rrcllc_update_oc_in_fach_with_sibs(ordered_config_ptr) ==
        FAILURE)
    {
      WRRC_MSG0_ERROR("Failure updating OC with SIB; In FACH");
      return(FAILURE);
    }
  
#ifdef FEATURE_WCDMA_HS_FACH
    if(rrcllc_get_hs_status_in_e_fach(ordered_config_ptr) == TRUE)
    {
      (void)rrcenhstate_process_reconfig_ccch();
    }
    else
#endif
    {
      //fach included check this ...
      if(rrcllc_semi_permanent_data.dl_phy_chan.fach_included == FALSE)
      {
        /* This is a wrong selection of SCCPCH that does not have PCH */
        WRRC_MSG0_ERROR("SCCPCH has no FACH included in CELL_FACH state");
        return(FAILURE);
      }
      /* Prepare a Reconfig CCCH command for RLC */
      (void)rrcllc_process_reconfig_ccch();
    }
  }
   
  
  if(bch_op == RRCLLC_DROP_BCH)
  {
    WRRC_MSG0_HIGH("CCM has requested to drop S-BCCH along with CCCH Reconfig");
#ifdef FEATURE_WCDMA_HS_RACH
    if (rrcsib_update_sib7_hs_rach() == TRUE)
    {
#ifdef FEATURE_UPDATE_SIB7_IN_FACH
      /*If FEATURE_UPDATE_SIB7_IN_FACH is defined, do not drop the channel, just reconfigure it  */
      (void)rrcllc_process_reconfig_bcch_serving(config_ptr);
#endif
    }
    else
    {
      if(ordered_config_ptr->mac_dl_parms.num_bchs)
      {
        ordered_config_ptr->mac_dl_parms.num_bchs --;
      }
  
      /* Update number of transport channels on PCCPCH in L1 CCTrCH Parameters */
      rrcllc_semi_permanent_data.dl_phy_chan.pccpch.num_trch = 0;
      if (rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up) 
      {
        (void)rrcllc_process_drop_bcch_serving();
      }
      else
      {
        WRRC_MSG0_ERROR("BCCH not present: no need for drop");
        return FAILURE;
      }
    }
#else
#ifdef FEATURE_UPDATE_SIB7_IN_FACH
    /*If FEATURE_UPDATE_SIB7_IN_FACH is defined, do not drop the channel, just reconfigure it
    */
    (void)rrcllc_process_reconfig_bcch_serving(config_ptr);
#else
    if(ordered_config_ptr->mac_dl_parms.num_bchs)
    {
      ordered_config_ptr->mac_dl_parms.num_bchs --;
    }

    /* Update number of transport channels on PCCPCH in L1 CCTrCH Parameters */
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch.num_trch = 0;
    if (rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up) 
    {
      (void)rrcllc_process_drop_bcch_serving();
    }
    else
    {
      WRRC_MSG0_ERROR("BCCH not present: no need for drop");
      return FAILURE;
    }
#endif
#endif /* FEATURE_WCDMA_HS_RACH*/
  }
#ifdef FEATURE_WCDMA_HS_FACH
  if(rrcllc_get_hs_status_in_e_fach(ordered_config_ptr) == TRUE)
  {
    (void)rrcenhstate_process_reconfig_bcch_on_hsdsch();
  }
  else
#endif
  {
    (void)rrcllc_process_reconfig_bcch_on_fach();
  }

  if((bch_op == RRCLLC_DROP_BCH) &&
     (rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up))
  {
#ifdef FEATURE_UPDATE_SIB7_IN_FACH
#ifdef FEATURE_WCDMA_HS_RACH
    if (rrcsib_update_sib7_hs_rach() == TRUE)
#endif
    {
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch.num_trch = 1;
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_ref_type_bf = L1_DL_TRCH_REFTYPE_SBCH_BF;
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_enable_bf = L1_DL_TRCH_REFTYPE_SBCH_BF;
    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action =
    LLC_PHYCHAN_DROP_AND_ADD;
    WRRC_MSG0_HIGH("Reconfigure S-BCCH");
    RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.dl_phy_chan.
                                      pccpch.cctrch_id);
    /* Get a new CCTrCH ID */
    cctrch_id = rrcllc_get_cctrch_id();
    if(cctrch_id != RRCLLC_INVALID_CCTRCH_ID)
    {
      /* If BCH is present, update BCH info in Ordered Config with new CCTrCH ID */
      if((config_ptr->mac_dl_parms.num_bchs != 0) &&
        (config_ptr->mac_dl_parms.num_bchs <= MAC_DL_MAX_CCTRCH))
      {
        config_ptr->mac_dl_parms.bch_info[config_ptr->mac_dl_parms.num_bchs-1].cctrch_id = cctrch_id;
      }
      /* Update SCCPCH Info in rrcllc_cmd_under_process */
      rrcllc_semi_permanent_data.dl_phy_chan.pccpch.cctrch_id =
        cctrch_id;
    }
    else
    {
      WRRC_MSG1_ERROR("Invalid CCTrCH ID %d assigned", cctrch_id);
      return(FAILURE);
    }
    }
#ifdef FEATURE_WCDMA_HS_RACH
    else 
    {
      rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action =
      LLC_PHYCHAN_RELEASE;
      rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_ref_type_bf = 0;
      rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_enable_bf = 0;
      /* Add the CCTrCH ID for PCCPCH to the CCTrCH IDs to be released list */
      RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                            dl_phy_chan.pccpch.cctrch_id);
    }
#endif

#else
    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action =
      LLC_PHYCHAN_RELEASE;
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_ref_type_bf = 0;
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_enable_bf = 0;
    /* Add the CCTrCH ID for PCCPCH to the CCTrCH IDs to be released list */
    RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                          dl_phy_chan.pccpch.cctrch_id);
#endif
  }

  
/* Downlink Physical channel processing */
  /* Force Reconfigurations of MAC and L1 in ALL cases so that all layers
   * remain on the same Ordered Config or Current Config pointer. Otherwise
   * selective reconfigurations of layers can put them "out of sync".
   */
  ordered_config_ptr->reconfig_needed.uplink_l1 = TRUE;
  ordered_config_ptr->reconfig_needed.downlink_l1 = TRUE;

  ordered_config_ptr->reconfig_needed.uplink_mac = TRUE;
  ordered_config_ptr->reconfig_needed.downlink_mac = TRUE;

#ifdef FEATURE_WCDMA_HS_FACH
  if(rrcllc_get_hs_status_in_e_fach(ordered_config_ptr) == TRUE)
  {
    if(rrcenhstate_setup_phychan() == FAILURE)
    {
      return FAILURE;
    }
  }
  else
#endif
  {
    /* Fix the transport channel bitmasks for SCCPCH */
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
      L1_DL_TRCH_REFTYPE_FACH_BF;
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf |=
      L1_DL_TRCH_REFTYPE_FACH_BF;

    if(rrcllc_semi_permanent_data.dl_phy_chan.pch_included)
    {
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
        L1_DL_TRCH_REFTYPE_PCH_BF;
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf &=
        ~L1_DL_TRCH_REFTYPE_PCH_BF;
    }
    else  /* No PCH on this SCCPCH */
    {
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf &=
        ~L1_DL_TRCH_REFTYPE_PCH_BF;
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf &=
        ~L1_DL_TRCH_REFTYPE_PCH_BF;
    }
    if(rrcllc_process_add_sccpch() == FAILURE)
    {
      WRRC_MSG0_ERROR ("Couldn't setup SCCPCH");
      return FAILURE;
    }
  }
  /* This is a case for addition of PRACH */
  rrcllc_cmd_under_process.chan_config.phy_chan_action_list.prach_action =
    LLC_PHYCHAN_SETUP;

  return (SUCCESS);
}
/*===========================================================================
FUNCTION   rrcllc_chan_config_within_fach

DESCRIPTION
  This function is resposible for determining all actions on RLC, MAC
  and L1.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static uecomdef_status_e_type
rrcllc_chan_config_within_fach(rrc_cmd_type *cmd_ptr)
{
  int i;
  int     rb_index;

  rrcllc_bch_op_e_type  bch_op = RRCLLC_NO_OP_BCH;
  rrcllc_nbch_op_e_type  nbch_op = RRCLLC_NO_OP_NBCH;
  rrcllc_ccch_op_e_type  ccch_op = RRCLLC_NO_OP_CCCH;

  ordered_config_type  *config_ptr = ordered_config_ptr;
  rlc_lc_id_type rlc_dl_log_chl_id;
  uint8  cctrch_id;

#ifdef FEATURE_WCDMA_HS_FACH
  
  boolean sib5_change = FALSE;

  rrc_CellUpdateCause       cu_cause = rrc_CellUpdateCause_cellUpdateCause_ext;
#ifdef FEATURE_WCDMA_HS_RACH
boolean backup_hspa_rnti_stored_cell_pch = FALSE;
#endif
#endif

  rrc_proc_e_type                 proc_id;
  rrcllc_oc_process_state_e_type  process_state;  
  uint8 dch_fach_common_chn_setup_in_progress = RRC_DCH_FACH_TRANISITION_CHANNEL_INVALID;
  (void)rrcllc_get_ordered_config_state_and_proc_wo_f3(&proc_id, &process_state);
  /*Check if Cell capability has changed and set the type accordingly*/
  if ((rrcllc_cmd_under_process.chan_config.chan_config_reason ==
         RRCLLC_CHAN_CFG_REASON_RECONFIG_PCH_FACH) &&
      (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP))
  {
    rrcllc_set_sib5_change_in_progress_flag();
  }


#ifdef FEATURE_WCDMA_HS_FACH
  if((cmd_ptr->cmd.chan_config_req.chan_config_reason == 
      RRCLLC_CHAN_CFG_REASON_HS_FACH_DEDICATED_OPS) &&
      (cmd_ptr->cmd.chan_config_req.is_oc_set == FALSE))
  {
  /*Back up and restore the hspa_rnti_stored_cell_pch because during copy CC to OC it will be lost*/
#ifdef FEATURE_WCDMA_HS_RACH
    backup_hspa_rnti_stored_cell_pch = ordered_config_ptr->hspa_rnti_stored_cell_pch;
#endif
    rrcllc_copy_cc_to_oc();
#ifdef FEATURE_WCDMA_HS_RACH
    ordered_config_ptr->hspa_rnti_stored_cell_pch = backup_hspa_rnti_stored_cell_pch;
#endif
  }
#endif


#ifdef FEATURE_UPDATE_SIB7_IN_FACH
#ifdef FEATURE_WCDMA_HS_RACH
  if (rrcsib_update_sib7_hs_rach() == TRUE)
#endif
  {
  if(rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_SIB)
  {
    if(rrcllc_is_process_required(cmd_ptr)==FALSE)
    {
      rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_BYPASS_ENGINE;
      WRRC_MSG0_HIGH("S-PCCPCH is already UP");
      return (SUCCESS);
    }
  }
  }
#endif /*FEATURE_UPDATE_SIB7_IN_FACH*/

  if(rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)
  {
    if (rrcllc_cmd_under_process.chan_config.chan_config_reason ==
         RRCLLC_CHAN_CFG_REASON_RE_ENTERING_SERVICE)
    {
      WRRC_MSG0_HIGH("Config for re-entering svc in FACH");
      return (rrcllc_chan_config_to_re_enter_within_fach(cmd_ptr));
    }
    else  if (rrcllc_cmd_under_process.chan_config.chan_config_reason ==
         RRCLLC_CHAN_CFG_REASON_OUT_OF_SERVICE)
    {
      return rrcllc_chan_config_for_oos_within_fach(cmd_ptr);
    }
    else if((cmd_ptr->cmd.chan_config_req.release_trchls) &&
       (cmd_ptr->cmd.chan_config_req.release_phychls))
    {
      /* This is a special case for releasing only physical and
      * transport channels, keeping the logical channels as they are.
      */
      rrcllc_cmd_under_process.chan_config.current_cmd_engine =
        LLC_RELEASE_TR_PHY_CHAN_ENGINE;
      rrcllc_copy_cc_to_oc();
      /* Initailize MAC data to release all Transport Channels */
      rrcllc_init_ordered_config_mac_info(ORDERED_CONFIG);
      rrcllc_restore_urnti_to_oc_from_toc();
      /* Indicate that both Downlink and Uplink MAC need to be reconfigured */
      ordered_config_ptr->reconfig_needed.downlink_mac = TRUE;
      ordered_config_ptr->reconfig_needed.uplink_mac = TRUE;

      /* Return from here as no other data in Channel Config Request
       * is relevant.
       */
      WRRC_MSG0_HIGH("Released Phy and Tr Chls in FACH State");
      return(SUCCESS);
    }
  }
  if(rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CCM)
  {
    if (rrcllc_cmd_under_process.chan_config.chan_config_reason ==
         RRCLLC_CHAN_CFG_REASON_RE_ENTERING_SERVICE)
    {
      return (rrcllc_chan_config_to_re_enter_within_fach(cmd_ptr));
    }
    if (rrcllc_cmd_under_process.chan_config.chan_config_reason ==
         RRCLLC_CHAN_CFG_REASON_WITHIN_FACH)
    {
      WRRC_MSG0_HIGH("Config For Frequency REdirection from CCM in FACH");
      return (rrcllc_chan_config_within_fach_for_redirection(cmd_ptr));
    }
  }
  rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;

  WRRC_MSG2_HIGH("Chan_config_withinfach proc:rrc_proc_e_type_value%d, oc_status:rrcllc_oc_set_status_e_type_value%d",
           rrcllc_cmd_under_process.procedure,rrcllc_get_ordered_config_status_wo_f3());

  if(!((rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
          && (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)) &&
     rrcllc_cmd_under_process.procedure != RRC_PROCEDURE_CHO &&
     rrcllc_cmd_under_process.procedure != RRC_PROCEDURE_LBT)
  {
    for (i=0; i<cmd_ptr->cmd.chan_config_req.num_rb_to_config; i++)
    {
      if((cmd_ptr->cmd.chan_config_req.rb[i].rb_id == BCCH_S_RADIO_BEARER_ID) &&
          (cmd_ptr->cmd.chan_config_req.rb[i].rb_config == ESTABLISH_RB))
      {
        rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;
        bch_op = RRCLLC_ADD_BCH;
      }
      else if((cmd_ptr->cmd.chan_config_req.rb[i].rb_id == BCCH_S_RADIO_BEARER_ID) &&
          (cmd_ptr->cmd.chan_config_req.rb[i].rb_config == RELEASE_RB))
      {
        rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;
        bch_op = RRCLLC_DROP_BCH;
      }
      else if((cmd_ptr->cmd.chan_config_req.rb[i].rb_id == BCCH_N_RADIO_BEARER_ID) &&
              (cmd_ptr->cmd.chan_config_req.rb[i].rb_config == ESTABLISH_RB))
      {
        if((rrc_get_state() == RRC_STATE_CELL_DCH) ||
           (rrcllc_get_ordered_config_status_wo_f3() == OC_SET_FOR_CELL_DCH))
        {
          rrcllc_cmd_under_process.chan_config.chan_cfg_status =
            RRCLLC_CHAN_CFG_FAILURE_INCOMPATIBLE_STATE;

          WRRC_MSG0_ERROR("Neighbor BCCH setup oborted");
          return(FAILURE);
        }
        else if(rrc_csp_is_reselection_cleared())
        { 
          /* Return failure as DL wk indication was received for this cell and reselection data (freq/scr)
                       have been cleared*/
          rrcllc_cmd_under_process.chan_config.chan_cfg_status =
            RRCLLC_CHAN_CFG_FAILURE_CFG_CANCELLED;
          WRRC_MSG0_ERROR("Reselect info cleared. N-BCCH setup aborted.");
          return (FAILURE);
        }
        else
        {
          rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;
          nbch_op = RRCLLC_ADD_NBCH;
#ifdef FEATURE_UPDATE_SIB7_IN_FACH
          if(rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up==TRUE)
          {
            /*
            Drop BCH when there is request for ADD NBCH and PCCPCH is up
            This is For handling of Downlink Weak where SIB sends for Establish of NBCCH but not
            relases of SBCCH
            */
            bch_op = RRCLLC_DROP_BCH;
          }
#endif /* FEATURE_UPDATE_SIB7_IN_FACH*/
        }
      }
      else if((cmd_ptr->cmd.chan_config_req.rb[i].rb_id == BCCH_N_RADIO_BEARER_ID) &&
          (cmd_ptr->cmd.chan_config_req.rb[i].rb_config == RELEASE_RB))
      {
        rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;
        nbch_op = RRCLLC_DROP_NBCH;
#ifdef FEATURE_UPDATE_SIB7_IN_FACH
#ifdef FEATURE_WCDMA_HS_RACH
        if (rrcsib_update_sib7_hs_rach() == TRUE)
#endif
        {
        if(rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up==FALSE)
        {
          /*
          ADD BCH when there is request for DROP NBCH and PCCPCH is not up
          */
          bch_op = RRCLLC_ADD_BCH;
        }
        }
#endif /* FEATURE_UPDATE_SIB7_IN_FACH*/
      }
      else if(((cmd_ptr->cmd.chan_config_req.rb[i].rb_id == CCCH_RADIO_BEARER_ID)||
           (cmd_ptr->cmd.chan_config_req.rb[i].rb_id == PCCH_RADIO_BEARER_ID))&&
          (cmd_ptr->cmd.chan_config_req.rb[i].rb_config == RECONFIG_RB))
      {
      /*Check if CCCH Reconfig is posted by CSP due to SIB change when UE is in FACH state
              or if PCCH Reconfig is posted in the narrow window where PCH->FACH transition is in progress*/
        if ((rrcllc_cmd_under_process.chan_config.chan_config_reason ==
               RRCLLC_CHAN_CFG_REASON_RECONFIG_PCH_FACH) &&
              (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP))
        {
          rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;
          ccch_op = RRCLLC_RECONFIG_CCCH;
          // No need to continue for other rb's
          break;
        }
      }
    } /* for(..) */
    /* UPDATE RLC AND MAC ORDERD CONFIG DATA STRUCTURES */

    /* Update the variables in the ordered_config structure */

    if (ccch_op != RRCLLC_NO_OP_CCCH)
    {
      rrcllc_copy_cc_to_oc();
      if (rrcllc_update_oc_in_fach_with_sibs(ordered_config_ptr) ==
          FAILURE)
      {
        WRRC_MSG0_ERROR("Failure updating OC with SIB; In FACH");
        return(FAILURE);
      }

      if((ccch_op == RRCLLC_ADD_CCCH) || (ccch_op == RRCLLC_RECONFIG_CCCH))
      {
        //fach included check this ...
        if((rrcllc_semi_permanent_data.dl_phy_chan.fach_included == FALSE) 
#ifdef FEATURE_WCDMA_HS_FACH
               &&(rrcllc_get_hs_status_in_e_fach(ordered_config_ptr) == FALSE)
#endif
        )
        {
          /* This is a wrong selection of SCCPCH that does not have PCH */
          WRRC_MSG0_ERROR("SCCPCH has no FACH included in CELL_FACH state");
          return(FAILURE);
        }
#ifdef FEATURE_WCDMA_HS_FACH
        if(rrcllc_get_hs_status_in_e_fach(ordered_config_ptr) == TRUE)
        {
          if (ccch_op == RRCLLC_ADD_CCCH)
          {
            (void)rrcenhstate_process_add_ccch();
          }
          else
          {
            (void)rrcenhstate_process_reconfig_ccch();
          }
        }
        else
#endif
        {
        if(ccch_op == RRCLLC_ADD_CCCH)
        {
          /* Prepare an Add PCCH command for RLC */
          (void)rrcllc_process_add_ccch();
        }
        else
        {
          /* Prepare a Reconfig CCCH command for RLC */
          (void)rrcllc_process_reconfig_ccch();
        }
        }
      } /* If there is an Add or Reconfig on CCCH */
    } /* If CCCH is to be added or reconfigured OR If BCH is to be added or dropped */
    else if((bch_op != RRCLLC_NO_OP_BCH) ||
       (nbch_op != RRCLLC_NO_OP_NBCH))
    {
      /* A solo BCH operation in progress */
      config_ptr = current_config_ptr;
      rrcllc_cmd_under_process.chan_config.solo_bch_operation = TRUE;

      /* If Lower Layers have been configured with Ordered Config, copy
       * OC to CC before proceeding further.
       */
      if((config_ptr_in_use == ORDERED_CONFIG) &&
         (ordered_config.process_state == LL_CONFIG_WITH_OC))
      {
        rrcllc_copy_oc_to_cc();
      }

      if (rrcllc_update_oc_for_serving_neighbor_bch_in_connected(config_ptr,
                                                                 bch_op,
                                                                 nbch_op)
            == FAILURE)
      {
        WRRC_MSG0_ERROR("Failure updating CC for SBCH/NBCH; In FACH");
        return(FAILURE);
      }
      if(bch_op == RRCLLC_ADD_BCH)
      {
        rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id
          (
            UE_LOGCHAN_BCCH,
            BCCH_S_RADIO_BEARER_ID,
            UE_MODE_TRANSPARENT
          );
        if (rlc_dl_log_chl_id == RRCLCM_RLC_LC_ID_NOT_FOUND) 
        {
          (void)rrcllc_process_add_bcch_serving(config_ptr);
        }
        else
        {
          (void)rrcllc_process_reconfig_bcch_serving(config_ptr);
        }
      }
      if(bch_op == RRCLLC_DROP_BCH)
      {
        if (rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up) 
        {
          (void)rrcllc_process_drop_bcch_serving();
        }
        else
        {
          if((nbch_op == RRCLLC_ADD_NBCH)&&
            (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_SIB))
          {
            WRRC_MSG0_ERROR("BCCH not present: Ignore drop since nbch_op action is add");
            bch_op = RRCLLC_NO_OP_BCH;
          }
          else
          {
            WRRC_MSG0_ERROR("BCCH not present: no need for drop,return failure");
            return FAILURE;
          }
        }
      }
      if(nbch_op == RRCLLC_ADD_NBCH)
      {
        rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id
          (
            UE_LOGCHAN_BCCH,
            BCCH_N_RADIO_BEARER_ID,
            UE_MODE_TRANSPARENT
          );
        if (rlc_dl_log_chl_id == RRCLCM_RLC_LC_ID_NOT_FOUND) 
        {
          (void)rrcllc_process_add_bcch_neighbor(config_ptr);
        }
        else
        {
          (void)rrcllc_process_reconfig_bcch_neighbor(config_ptr);
        }
      }
      if(nbch_op == RRCLLC_DROP_NBCH)
      {
        (void)rrcllc_process_drop_bcch_neighbor();
      }
    }
    else
    {

      /* Treat the special case for DCH to FACH transition */
      if((transition_config.toc_usage == TOC_FOR_DCH_AND_FACH)
         || (transition_config.toc_usage == TOC_FOR_OOS)
         ||(transition_config.toc_usage == TOC_FOR_FACH_AND_PCH)
         ||(transition_config.toc_usage == TOC_FOR_FACH_AND_PCH_WITH_DCH_INFO)
         ||(transition_config.toc_usage == TOC_FOR_OOS_WITH_DCH_INFO)
         ||(transition_config.toc_usage == TOC_FOR_OOS_WITHOUT_DCH_INFO)
         )
      {
        /* If TOC can be used for FACH, this implies this Channel Config
         * within FACH is not due to any OTA message, but as part of
         * DCH to FACH transition process.
         */
        /* Now update Ordered Config with data from Transition Config */
        rrcllc_update_oc_in_fach_with_toc();

#ifdef FEATURE_WCDMA_HS_RACH
         if (transition_config.toc_usage != TOC_FOR_OOS)
        {
           /*Restore RNTI from TOC to OC*/
          ordered_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = 
           transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present;
          ordered_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti = 
            transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti;
        }
#endif

        
        /* Update CC also with TOC. So that even after this recovery
          * if OOS is triggered during CU, then again when TOC is 
          * backed up valid values are taken
          */
        if( transition_config.toc_usage == TOC_FOR_OOS)
        {
#ifdef FEATURE_UMTS_PDCP
          /* Copy the saved PDCP info from TOC to CC*/
          rrcllc_copy_pdcp_parms(current_config_ptr, transition_config.toc_ptr);
#endif /* FEATURE_UMTS_PDCP */
        
          /* now copy saved rlc info and rbmapping info from toc to oc */
          /* Copy all RLC Config data for AM channels */
          rrcllc_copy_rlc_parms(current_config_ptr, transition_config.toc_ptr);
        
          /* Save dcch+dtch mapping on fach/rach in to toc */
          rrcllc_copy_cell_fach_rb_mapping_info(current_config_ptr, transition_config.toc_ptr);
        
          /* Copy over the RB-oriented side of RLC size restrictions */
        
          rrcllc_copy_cell_fach_rlc_size_list(current_config_ptr, transition_config.toc_ptr);
        }
        
        /* Indicate that now onwards TOC can be used for CELL_DCH state only */
        WRRC_MSG1_HIGH("TOC Status %d ",transition_config.toc_usage);
        if((transition_config.toc_usage == TOC_FOR_FACH_AND_PCH)||
            (transition_config.toc_usage == TOC_FOR_OOS_WITHOUT_DCH_INFO))
        {
          transition_config.toc_usage = TOC_INVALID;
        }
        else if ((transition_config.toc_usage == TOC_FOR_FACH_AND_PCH_WITH_DCH_INFO)||
            (transition_config.toc_usage == TOC_FOR_OOS_WITH_DCH_INFO))
        {
          transition_config.toc_usage = TOC_FOR_DCH;
        }
        else
        {
          /* dch_fach_common_chn_setup_in_progress variable determines if common channels are to be setup now */
          dch_fach_common_chn_setup_in_progress = rrcllc_dch_fach_check_channel_setup_skip_status();

          if(RRC_DCH_FACH_TRANISITION_CHANNEL_SETUP == dch_fach_common_chn_setup_in_progress)
          {
            if(FAILURE == rrcllc_setup_common_logical_channels_for_fach())
            {
              WRRC_MSG0_HIGH("DCH to FACH common logical channel setup failure");
              return FAILURE;
            }
          }
          else if (RRC_DCH_FACH_TRANISITION_CHANNEL_INVALID == dch_fach_common_chn_setup_in_progress)
          {
            /* Increment DL UM and UL TM Nchans to accomodate the already existing CCCH.*/
            if(get_rlc_dl_um_info(CCCH_RADIO_BEARER_ID, TRUE, ordered_config_ptr) == FAILURE)
            {
              WRRC_MSG0_ERROR("Config DB could not be updated for DL UM RB CTCH_RADIO_BEARER_ID");
              return(FAILURE);
            }
            ordered_config_ptr->rlc_ul_tm_parms.nchan ++;
            WRRC_MSG1_MED("nchan: FACH CCCH up UL TM %d after increment, Updated OC with TOC within FACH",
                ordered_config_ptr->rlc_ul_tm_parms.nchan);
          }
          /* Track the change in toc usage to use it in cu */

         if(transition_config.toc_usage == TOC_FOR_OOS)
         {
           toc_usage_change_oos_to_dch = TRUE;
         }
          transition_config.toc_usage = TOC_FOR_DCH;
        }
      }

      /* Incase the rb mapping info is absent on transition to FACH from DCH, or during the FACH to FACH redirection
            UE will move to disconned from connnected state, coz, spec mandates the mapping info on transition to eFACH or HSRACH */
      if((RRC_STATE_CELL_FACH == rrcllc_cmd_under_process.next_rrc_state)
        &&((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RBE) 
        ||(rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RBRC) 
        ||(rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RBR) 
        ||(rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_TCR) 
        ||(rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_PCR) 
        ||((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CU) 
           &&((cmd_ptr->cmd.chan_config_req.chan_config_reason == RRCLLC_CHAN_CFG_REASON_HS_FACH_DEDICATED_OPS)||
               (cmd_ptr->cmd.chan_config_req.chan_config_reason == RRCLLC_CHAN_CFG_EPCH_HRNTI_ONLY)))))
      {
#ifdef FEATURE_WCDMA_HS_RACH
         if ((TRUE == rrchsrach_camped_cell_supports_hsrach())
          && (FALSE == rrcllc_check_mappings_in_channel_config_req_and_srb(&cmd_ptr->cmd.chan_config_req,UL_EDCH_MAPPING|DL_MAC_EHS_MAPPING)))
         {
            WRRC_MSG0_ERROR("RRCHSRACH:transition to idle from connected -> rb mapping info is not present");
            rrc_transition_to_disconnected_state(RRC_PROCEDURE_LLC,RRC_TX_TO_DISCON_OTHER);
            rrcllc_cmd_under_process.chan_config.cnf_needed = FALSE;
            return (FAILURE);
          }
          else
#endif /*FEATURE_WCDMA_HS_RACH*/
#ifdef FEATURE_WCDMA_HS_FACH
         /* if cell supports hs_fach check hs_fach mappings */      
          if((FALSE == rrchsrach_camped_cell_supports_hsrach()) && (TRUE == rrcenhstate_camped_cell_supports_e_fach()) 
           &&(FALSE == rrcllc_check_mappings_in_channel_config_req_and_srb(&cmd_ptr->cmd.chan_config_req,UL_RACH_MAPPING|DL_MAC_EHS_MAPPING)))
          {
            WRRC_MSG0_ERROR("RRCHSFACH:transition to idle from connected -> rb mapping info is not present");
            rrc_transition_to_disconnected_state(RRC_PROCEDURE_LLC,RRC_TX_TO_DISCON_OTHER);
            rrcllc_cmd_under_process.chan_config.cnf_needed = FALSE;
            return (FAILURE);
          }
          else
#endif
         /* else check rach/fach mappings present or not for a legacy cell*/      
        if (FALSE == rrcllc_check_dcch_fach_mapping(ordered_config_ptr))
        {
           WRRC_MSG0_ERROR("RRC:Legacy cell transition to idle from connected -> rb mapping info is not present");
           rrc_transition_to_disconnected_state(RRC_PROCEDURE_LLC,RRC_TX_TO_DISCON_OTHER);
           rrcllc_cmd_under_process.chan_config.cnf_needed = FALSE;
           return (FAILURE);
        }
     }


#ifdef FEATURE_WCDMA_HS_FACH
      if(cmd_ptr->cmd.chan_config_req.chan_config_reason == 
                  RRCLLC_CHAN_CFG_REASON_HS_FACH_DEDICATED_OPS)
      {
        (void)rrccu_get_cell_update_started_status_with_cause(&cu_cause);

        ordered_config_ptr->efach_hrnti = transition_config.toc_ptr->efach_hrnti;
        ordered_config_ptr->efach_hrnti_status = transition_config.toc_ptr->efach_hrnti_status;
        WRRC_MSG1_HIGH("EFACH: Updated HRNTI from TOC to OC %d",ordered_config_ptr->efach_hrnti);

        if(FAILURE == rrcenhstate_evaluate_efach_and_set_lower_layers_action(
                        ordered_config_ptr,RRC_STATE_CELL_FACH,RRC_E_FACH_DEDICATED))
        {
          WRRC_MSG0_ERROR("EFACH:Cant start HS-FACH ");
          return FAILURE;
        }

#ifdef FEATURE_WCDMA_HS_RACH
		ordered_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = 
		   transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present;
        ordered_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti = 
		   transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti;
#endif

      }
      else if(cmd_ptr->cmd.chan_config_req.chan_config_reason == 
                      RRCLLC_CHAN_CFG_REASON_HS_FACH_COMMON_OPS)
      {
        WRRC_MSG1_HIGH("EFACH: configure e-fach for common mode, cfg ptr in use: %d",
                  config_ptr_in_use);
        if(config_ptr_in_use != ORDERED_CONFIG)
        {
          rrcllc_copy_cc_to_oc();
        }
        rrcllc_copy_sib_to_oc_for_efach(RRC_STATE_CELL_FACH,RRC_E_FACH_COMMON);

#ifdef FEATURE_WCDMA_HS_RACH
      if(TRUE == rrchsrach_camped_cell_supports_hsrach())
      {
        /*Configure common mode*/
        rrcllc_copy_sib_to_oc_for_hsrach(RRC_STATE_CELL_FACH);
	/* For common mode ops, ERNTI shouldnt be configured */
	/* This channel config is for sending CU, so ERNTI can be cleared on all DBs */
	ordered_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = FALSE;
	current_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = FALSE;
        transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = FALSE;
      }
#endif
      if(rrcllc_check_dch_fach_reconfig_status())
      {
        dch_fach_common_chn_setup_in_progress = RRC_DCH_FACH_TRANISITION_CHANNEL_SETUP;
        if(FAILURE == rrcllc_setup_common_logical_channels_for_fach())
        {
          WRRC_MSG0_HIGH("DCH to FACH common logical channel setup failure");
          return FAILURE;
        }
      }
      }
#ifdef FEATURE_WCDMA_HS_FACH
      else if(cmd_ptr->cmd.chan_config_req.chan_config_reason == 
                  RRCLLC_CHAN_CFG_EPCH_HRNTI_ONLY)
      {
        rrcllc_set_hs_status_in_e_fach(current_config_ptr, TRUE);
        rrcllc_set_hs_action_in_e_fach(current_config_ptr,HSDPA_RECONFIG);
        current_config_ptr->hrnti = current_config_ptr->l1_hsdpa_info.hs_dsch_info.h_rnti;
        //rrcllc_set_hs_mode_in_e_pch(current_config_ptr,RRC_E_PCH_DHRNTI_DECODING);

        rrcenhstate_set_hsdpa_l1_info_in_cmd_under_process(current_config_ptr);
        current_config_ptr->reconfig_needed.downlink_l1 = TRUE;
        current_config_ptr->l1_hsdpa_info.hs_dsch_info.efach_h_rnti_bmsk = (L1_DEDICATED_H_RNTI_VALID | L1_BCCH_H_RNTI_VALID);

        current_config_ptr->efach_hrnti = transition_config.toc_ptr->efach_hrnti;
        current_config_ptr->efach_hrnti_status = transition_config.toc_ptr->efach_hrnti_status;

#ifdef FEATURE_WCDMA_HS_RACH
      /*For ERNTI only update case drop and add PRACH which is used later
      when setting the HS_RACH req mask*/
      if(TRUE == rrchsrach_camped_cell_supports_hsrach())
      {
        /*PRACH add/drop must be added to send the ERNTI update to L1*/
        current_config_ptr->l1_hs_rach_req_mask = L1_HS_RACH_STOP |L1_HS_RACH_START ;
        rrcllc_set_hs_rach_action(current_config_ptr,MAC_HS_RACH_CONFIG);

        rrcllc_cmd_under_process.chan_config.phy_chan_action_list.prach_action =
          LLC_PHYCHAN_DROP_AND_ADD; //LLC_PHYCHAN_RECONFIG;

        WRRC_MSG0_HIGH("RRCHSRACH : LLC_PHYCHAN_DROP_AND_ADD on PRACH");
      
        current_config_ptr->reconfig_needed.uplink_l1 = TRUE;
        current_config_ptr->reconfig_needed.uplink_mac = TRUE;
      }
#endif
      
        return(SUCCESS);
      }
#endif
#endif

      if ((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CU) &&
          ( cmd_ptr->cmd.chan_config_req.chan_config_reason
            == RRCLLC_CHAN_CFG_REASON_RLC_CONFIG_ONLY))
      {

#ifdef FEATURE_UMTS_PDCP
        /* Build the command for PDCP_CONFIG_REQ.*/
        rrcllc_process_config_pdcp(cmd_ptr);
#endif /* FEATURE_UMTS_PDCP*/
        /* first swap oc and cc */
        rrcllc_swap_oc_and_cc();
        /* remove all RBs from OC and TOC before proceding with channel configuration
        */
        for (rb_index=0; rb_index<cmd_ptr->cmd.chan_config_req.num_rb_to_config; rb_index++)
        {
          /* Remove any existing mapping for the RB */
          unmap_rb(cmd_ptr->cmd.chan_config_req.rb[rb_index].rb_id, OC_AND_TOC);
        }
        (void)rrcllc_process_config_dtch_rel(cmd_ptr);
        /* this is just RB release so no need to reconfig mac and l1 */
        ordered_config_ptr->reconfig_needed.uplink_l1 = FALSE;
        ordered_config_ptr->reconfig_needed.downlink_l1 = FALSE;

        ordered_config_ptr->reconfig_needed.uplink_mac = FALSE;
        ordered_config_ptr->reconfig_needed.downlink_mac = FALSE;
        /*
        This was added to ensure the databases are in sync.
        After sending CU for RL failure, PSRAB(RB-16) was released and hang-OC was updated.
        But since there is no CHANNEL_CONFIG_CNF CC-hang still contains the PS RAB. If CU-Cnf 
        releases PS-RAB again or does'nt include it. Since CC-hang has and OC doesnt have PS-RB
        we will end up establishing it !!
        */
        if(cmd_ptr->cmd.chan_config_req.rrc_channel_config_cnf_required == FALSE)
        {
          rrcllc_copy_ordered_hanging_rb_mapping_to_current();
        }
        return(SUCCESS);
      }
#ifdef FEATURE_WCDMA_HS_FACH
      if(((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RBE) ||
           (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RBRC) ||
           (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RBR) ||
           (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_TCR) ||
           (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_PCR) ||
           (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CU) ||
           (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_UMI)||
           (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CCM)) &&
           ((cmd_ptr->cmd.chan_config_req.chan_config_reason == 
             RRCLLC_CHAN_CFG_REASON_HS_FACH_DEDICATED_OPS) ||
            (cmd_ptr->cmd.chan_config_req.chan_config_reason == 
           RRCLLC_CHAN_CFG_REASON_NONE) ))
      {
        if(rrcllc_get_hs_status_in_e_fach(ordered_config_ptr) == TRUE)
        {
           if(FAILURE == rrcenhstate_evaluate_efach_and_set_lower_layers_action(
                                                             ordered_config_ptr,
                                                             RRC_STATE_CELL_FACH,
                                                             RRC_E_FACH_DEDICATED))
          {
            WRRC_MSG0_ERROR("EFACH:Failed to configure EFACH");
            return FAILURE;
          }
        }
#ifdef FEATURE_WCDMA_HS_RACH
        if(TRUE == rrchsrach_camped_cell_supports_hsrach())
        {
          if(FAILURE == rrcllc_evaluate_hs_rach_and_set_lower_layers_action(RRC_STATE_CELL_FACH,ordered_config_ptr))
          {
            WRRC_MSG0_ERROR("RRCHSRACH:Failed to configure HS-RACH");
            return FAILURE;
          }
        }
#endif
      } 
#endif

      if(rrcllc_process_config_dcch_dtch(cmd_ptr) == FAILURE)
      {
        (void)rrcllc_build_cmd_and_release_lc_ids(); 
        return(FAILURE);
      }

#ifdef FEATURE_UMTS_PDCP
      /* Build the command for PDCP_CONFIG_REQ*/
      rrcllc_process_config_pdcp(cmd_ptr);
#endif /* FEATURE_UMTS_PDCP*/

    }
  } 
  else
  {
    /* If OC is set for FACH to PCH transition, all the FACH configurations are in CC */
    /* On resume, to configure FACH, do a swap of CC to OC */
    if (((rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
         && (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)) &&
        ((OC_SET_FOR_CELL_DCH == rrcllc_get_ordered_config_status_wo_f3())||
        (rrcllc_get_ordered_config_status_wo_f3() == OC_SET_FOR_FACH_CELL_PCH_TRANS) || (rrcllc_get_ordered_config_status_wo_f3() == OC_SET_FOR_FACH_URA_PCH_TRANS)))
    {
      /* OC is set for DCH.... This means there is a Chan_config_req to take UE to DCH in LLC-Q that is
       * yet to be processed. CC has the FACH info and OC has the DCH info. so swap CC and OC so 
       * that when re-setting up FACH channels, we would look at the right DB.  After swapping CC would 
       * have the DCH information.  at the end of configuring lower layers with OC, 
       * we need to swap CC and OC, and set the config_ptr_in_use to OC so when processing the chan_config_req 
       * to take UE to DCH, OC would have the correct DCH info.
       */
      WRRC_MSG0_HIGH("OC set for DCH/FACH->PCH.  phychan_resetup in fach");
      rrcllc_swap_oc_and_cc();
      /* Set the config_ptr_in_use to OC*/
      config_ptr_in_use = ORDERED_CONFIG;
    }


    /* Use Ordered Config here */
    config_ptr = ordered_config_ptr;

    rrcllc_cmd_under_process.chan_config.solo_bch_operation = FALSE;
    rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;
    /* Copy Current Config to Ordered Config when procedure IS NOT lbt */
    if (cmd_ptr->cmd.chan_config_req.procedure != RRC_PROCEDURE_LBT)
    {
      /* If OC is set for FACH to PCH transition, all the FACH configurations are in CC */
      /* Skip Copy of CC to OC is needed not to overwrite the fach configuration with pch configuration */
      if (((rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
           && (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)) &&
          ((OC_SET_FOR_CELL_DCH == rrcllc_get_ordered_config_status_wo_f3()) ||
          (rrcllc_get_ordered_config_status_wo_f3() == OC_SET_FOR_FACH_CELL_PCH_TRANS) || (rrcllc_get_ordered_config_status_wo_f3() == OC_SET_FOR_FACH_URA_PCH_TRANS)))
      {
        WRRC_MSG0_HIGH("Skipping CC to OC");
      }
      else
      {
        rrcllc_copy_cc_to_oc();
      }
      /* Set the Activation Time to "Now" */
      rrcllc_init_activation_time(config_ptr);
    }
    else
    {
      WRRC_MSG1_HIGH("Loopback mode %d update",
              cmd_ptr->cmd.chan_config_req.lb_test_mode);
      if((cmd_ptr->cmd.chan_config_req.lb_test_mode != LB_TEST_MODE_1) &&
         (cmd_ptr->cmd.chan_config_req.lb_test_mode != LB_TEST_MODE_2))
      {
        WRRC_MSG1_ERROR("Invalid Loopback mode %d",
            cmd_ptr->cmd.chan_config_req.lb_test_mode);
        return(FAILURE);
      }

      /* First copy CC to OC and then update OC */
      if(config_ptr_in_use != ORDERED_CONFIG)
      {
        rrcllc_copy_cc_to_oc();
      }
#ifdef FEATURE_WCDMA_HS_FACH
      if(rrcllc_get_hs_status_in_e_fach(ordered_config_ptr) == TRUE)
      {
        if(rrcenhstate_reconfig_phychan(RRC_E_FACH_DEDICATED) == FAILURE)
        {
          ERR_FATAL("EFACH:Error reconfiguring HS PDSCH",0,0,0);
        }
      }
      else
#endif
      {
        rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_action =
          LLC_PHYCHAN_SET_LBT_MODE;
      }

      rrcllc_cmd_under_process.chan_config.lb_test_mode =
        cmd_ptr->cmd.chan_config_req.lb_test_mode;

      rrcllc_cmd_under_process.chan_config.dummy_signaling_enabled =
        cmd_ptr->cmd.chan_config_req.dummy_signaling_enabled;

      /* Always reconfigure L1 Uplink and MAC UL */
      rrcllc_cmd_under_process.chan_config.phy_chan_action_list.prach_action =
        LLC_PHYCHAN_DROP_AND_ADD; //LLC_PHYCHAN_RECONFIG;


      ordered_config_ptr->reconfig_needed.uplink_l1 = TRUE;
      ordered_config_ptr->reconfig_needed.uplink_mac = TRUE;

#ifdef FEATURE_WCDMA_HS_RACH
      if(TRUE == rrchsrach_get_common_edch_transmission(ordered_config_ptr))
      {
        /*PRACH add/drop must be added to send the ERNTI update to L1*/
        ordered_config_ptr->l1_hs_rach_req_mask = L1_HS_RACH_STOP |L1_HS_RACH_START ;
        rrcllc_set_hs_rach_action(ordered_config_ptr,MAC_HS_RACH_CONFIG);
      }
#endif

      return(SUCCESS);
    }
  }

  if(bch_op == RRCLLC_ADD_BCH ||
      ((((rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
          && (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP))
          || rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CHO) 
      && (rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up)))
  {

      current_config_ptr->l1_dl_chan_parms.pccpch.tx_div_ind =
      rrcllc_get_pccpch_tx_diversity(RRC_STATE_CELL_FACH);
 
    /* A BCCH has been added in DL => Setup PCCPCH */

    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action =
      LLC_PHYCHAN_SETUP;
    /* Update PCCPCH info in rrcllc_semi_permanent_data.dl_phy_chan */
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_ref_type_bf =
        L1_DL_TRCH_REFTYPE_SBCH_BF;
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_enable_bf =
        L1_DL_TRCH_REFTYPE_SBCH_BF;
  
    if(!((rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
          && (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)) &&
       rrcllc_cmd_under_process.procedure != RRC_PROCEDURE_CHO)
    {
      /* Get a new CCTrCH ID */
      cctrch_id = rrcllc_get_cctrch_id();
    }
    else
    {
      /* Update SCCPCH CCTrCh from semi_permanent data */
      cctrch_id = rrcllc_semi_permanent_data.dl_phy_chan.pccpch.cctrch_id;
    }

    /*Fixing the Array Out of Bound Error from KW*/
    if((cctrch_id != RRCLLC_INVALID_CCTRCH_ID) &&
      (config_ptr->mac_dl_parms.num_bchs <= MAC_DL_MAX_CCTRCH) &&
      (config_ptr->mac_dl_parms.num_bchs != 0))
    {
      /* Update BCH info in MAC Ordered Config */
      config_ptr->mac_dl_parms.
        bch_info[config_ptr->mac_dl_parms.num_bchs-1].cctrch_id =
      cctrch_id;

      /* Update PCCPCH Info in rrcllc_cmd_under_process */
      rrcllc_semi_permanent_data.dl_phy_chan.pccpch.cctrch_id = cctrch_id;

      MSG_LOW("LLC_PHYCHAN_SETUP for PCCPCH", 0, 0, 0);
    }
    else
    {
      WRRC_MSG1_ERROR("Invalid CCTrCH ID %d assigned", cctrch_id);
      return(FAILURE);
    }
  } /* If Serving BCCH add found */

  if((nbch_op == RRCLLC_ADD_NBCH)||
      ((((rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
          && (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)) ||
        rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CHO) &&
         (rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch_is_up)))
  {
    /* Get PCCPCH channel parameters from Cell Selection into Ordered Config */
    rrccsp_get_neighbor_pccpch_parms(&rrcllc_cmd_under_process.rrcllc_cell_resel_info.scr_code,
                                     &rrcllc_cmd_under_process.rrcllc_cell_resel_info.freq);
    config_ptr->l1_dl_chan_parms.pccpch.scr_code =
      rrcllc_cmd_under_process.rrcllc_cell_resel_info.scr_code;

    /* If we have read SIB11, we should use the diversity info contained
       therein. */

      current_config_ptr->l1_dl_chan_parms.pccpch.tx_div_ind =
        FALSE;
      WRRC_MSG0_HIGH("Using N-PCCPCH TxDiv info from L1");

    /* A BCCH has been added in DL => Setup PCCPCH */

    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.n_pccpch_action =
      LLC_PHYCHAN_SETUP;
    /* Update PCCPCH info in config_ptr->rrcllc_semi_permanent_data.dl_phy_chan */
    rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch.trch_ref_type_bf =
        L1_DL_TRCH_REFTYPE_NBCH_BF;
    rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch.trch_enable_bf =
        L1_DL_TRCH_REFTYPE_NBCH_BF;

    if(!((rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
          && (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)) &&
       rrcllc_cmd_under_process.procedure != RRC_PROCEDURE_CHO)
    {
      /* Get a new CCTrCH ID */
      cctrch_id = rrcllc_get_cctrch_id();
    }
    else
    {
      /* Update SCCPCH CCTrCh from semi_permanent data */
      cctrch_id = rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch.cctrch_id;
    }

    /*Fixing the Array Out of Bound Error from KW*/
    if((cctrch_id != RRCLLC_INVALID_CCTRCH_ID) &&
      (config_ptr->mac_dl_parms.num_bchs <= MAC_DL_MAX_CCTRCH) &&
      (config_ptr->mac_dl_parms.num_bchs != 0))
    {
      /* Update BCH info in MAC Ordered Config */
      config_ptr->mac_dl_parms.
        bch_info[config_ptr->mac_dl_parms.num_bchs - 1].cctrch_id =
      cctrch_id;

      /* Update PCCPCH Info in rrcllc_cmd_under_process */
      rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch.cctrch_id = cctrch_id;

      MSG_LOW("LLC_PHYCHAN_SETUP for PCCPCH", 0, 0, 0);
    }
    else
    {
      WRRC_MSG1_ERROR("Invalid CCTrCH ID %d assigned", cctrch_id);
      return(FAILURE);
    }
  } /* If Neighbor BCCH add found */

  if((bch_op == RRCLLC_DROP_BCH) &&
     (rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up))
  {
    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action =
      LLC_PHYCHAN_RELEASE;
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_ref_type_bf = 0;
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_enable_bf = 0;
    /* Add the CCTrCH ID for PCCPCH to the CCTrCH IDs to be released list */
    RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                          dl_phy_chan.pccpch.cctrch_id);
  } /* If Serving BCCH drop found */

  /* Neighbor BCH is a special case. The pipe may be incompletely setup.
   * in that case, do not do anything with L1.
   */

  if((nbch_op == RRCLLC_DROP_NBCH) &&
     (rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch_is_up))
  {
    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.n_pccpch_action =
      LLC_PHYCHAN_RELEASE;
    rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch.trch_ref_type_bf = 0;
    rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch.trch_enable_bf = 0;
    /* Add the CCTrCH ID for PCCPCH to the CCTrCH IDs to be released list */
    RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                          dl_phy_chan.n_pccpch.cctrch_id);
  } /* If Neighbor BCCH drop found */

  if(!((rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
          && (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)) &&
     rrcllc_cmd_under_process.procedure != RRC_PROCEDURE_CHO)
  {
    /* Now return from here if there was any operation on Serving or Neighbor
     * BCH. This is because BCH operation can not co-exist with DCCH/DTCH operation
     * in any case
     */
    if((nbch_op != RRCLLC_NO_OP_NBCH) || (bch_op != RRCLLC_NO_OP_BCH))
    {
      return(SUCCESS);
    }
  }
  /* if the channel config is due to rb release due to re-est
  timer expiry then do not configure mac and l1 */
  if (((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CU) &&
      ( cmd_ptr->cmd.chan_config_req.chan_config_reason
        == RRCLLC_CHAN_CFG_REASON_RLC_CONFIG_ONLY)) &&
       (TRUE == rrcllc_check_dcch_fach_mapping(ordered_config_ptr)))
  {
    /* Make sure MAC and L1 UL and DL are configured always */
    ordered_config_ptr->reconfig_needed.uplink_l1 = FALSE;
    ordered_config_ptr->reconfig_needed.downlink_l1 = FALSE;
    ordered_config_ptr->reconfig_needed.downlink_mac = FALSE;
    ordered_config_ptr->reconfig_needed.uplink_mac = FALSE;
    return(SUCCESS);
  }

#ifdef FEATURE_WCDMA_HS_FACH
  if((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP) &&
      (rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_RECONFIG_PCH_FACH) &&
      (rrcenhstate_camped_cell_supports_e_fach() == TRUE)
    )
  {
    rrc_cmd_type *cmd_local_ptr = NULL;
    switch (rrcllc_get_sib5_change_in_progress_flag())
    {
       /* 
         Following code is used for the following cases 
         (1) Legacy->EFACH - sib5_change_in_progress_flag = CELL_CAP_CHANGED
         (2) EFACH->HSRACH and HSRACH->EFACH and Legacy->HSRACH
                		If Delay CU NV enabled and CU not started -sib5_change_in_progress_flag = SIB5CHANGE_HSRACH_DELAY_CU
                else sib5_change_in_progress_flag = CELL_CAP_CHANGED
         (3) EFACH->EFACH and HSRACH->HSRACH - sib5_change_in_progress_flag = NO_CHANGE_IN_CELL_CAP
      */
      case NO_CHANGE_IN_CELL_CAP:
        WRRC_MSG0_HIGH("EFACH:SIB5 changed, EFACH->EFACH");

        /*If Common mode is being configured, break here as copy sib to oc has taken care of 
          required actions.
          Scenario: SIB5 change when UE waits for Cellupdate Confirm and OC not set like PCH->FACH,
                    OOS and reselections */
        if(current_config_ptr->efach_hrnti_status == COMMON_HRNTI)
        {
          if(rrcenhstate_reconfig_phychan(RRC_E_FACH_COMMON) == FAILURE)
          {
            ERR_FATAL("EFACH:Error reconfiguring HS PDSCH",0,0,0);
          }
          (void)rrcenhstate_process_reconfig_bcch_on_hsdsch();
          /*Decrementing because of SIB5 change */
          ordered_config_ptr->rlc_dl_tm_parms.nchan--; 

          cmd_local_ptr = (rrc_cmd_type *)rrc_malloc(sizeof(rrc_cmd_type));
          /* Build Channel config to reconfig srb 1 alone */
          cmd_local_ptr->cmd.chan_config_req.rb[0].rb_id = DCCH_UM_RADIO_BEARER_ID;
          cmd_local_ptr->cmd.chan_config_req.rb[0].rb_config = RECONFIG_RB;
          cmd_local_ptr->cmd.chan_config_req.num_rb_to_config = 1;
          cmd_local_ptr->cmd.chan_config_req.release_phychls = FALSE;
          cmd_local_ptr->cmd.chan_config_req.release_trchls = FALSE;
          WRRC_MSG0_HIGH("RRC_CHANNEL_CONFIG_REQ to reconfig SRB-1");
          if(rrcllc_process_config_dcch_dtch(cmd_local_ptr) == FAILURE)
          {
            (void)rrcllc_build_cmd_and_release_lc_ids();       
            WRRC_MSG0_HIGH("EFACH:SIB5 change, config_dcch_dtch failed");
            rrc_free(cmd_local_ptr);
            return(FAILURE);
          }
          rrc_free(cmd_local_ptr);
          break;
        }

      /* Fall through for Dedicated mode */
#ifdef FEATURE_WCDMA_HS_RACH
      case SIB5CHANGE_HSRACH_DELAY_CU:
#endif
      case CELL_CAP_CHANGED:
        if(rrcllc_get_hs_status_in_e_fach(current_config_ptr) == FALSE)
        {
           /* This is the case of cell upgraded to support EFACH */
           WRRC_MSG0_HIGH("EFACH:SIB5 changed, cell upgraded to support EFACH");
          if(rrcenhstate_setup_phychan() == FAILURE)
          {
            ERR_FATAL("EFACH:Setting up HS PDSCH failed",0,0,0);
          }
          rrcllc_set_hs_status_in_e_fach(ordered_config_ptr, TRUE);
  
          (void)rrcenhstate_process_reconfig_ccch();
          (void)rrcenhstate_process_reconfig_bcch_on_hsdsch();
          /*Decrementing because of SIB5 change */
          ordered_config_ptr->rlc_dl_tm_parms.nchan--;
          break;
        }
        else
        {
          /* For dedicated mode, as OC is updated with Sibs, 
           we need to restore dedicated mappings to OC again. This is ensured by calling below function*/
          if(FAILURE == rrcenhstate_evaluate_efach_and_set_lower_layers_action(
                                                      ordered_config_ptr,
                                                      RRC_STATE_CELL_FACH,
                                                      RRC_E_FACH_DEDICATED))
          {
            WRRC_MSG0_ERROR("EFACH:Failed to configure HS-FACH");
            return FAILURE;
          }
           /*Reconfig has to be happen after restore of mapping*/
          if(rrcenhstate_reconfig_phychan(RRC_E_FACH_DEDICATED) == FAILURE)
          {
            ERR_FATAL("EFACH:Error reconfiguring HS PDSCH",0,0,0);
          }
          (void)rrcenhstate_process_reconfig_bcch_on_hsdsch();
          /*Decrementing because of SIB5 change */
          ordered_config_ptr->rlc_dl_tm_parms.nchan--;
#ifdef FEATURE_WCDMA_HS_RACH
        /* Hsrach action needs to be updated only if there is no change in cell capablity. For delay CU case hsrach 
           action will be already updated */
          if(rrcllc_get_sib5_change_in_progress_flag() == NO_CHANGE_IN_CELL_CAP)
          {
            if(FAILURE == rrcllc_evaluate_hs_rach_and_set_lower_layers_action(RRC_STATE_CELL_FACH,ordered_config_ptr))
            {
              WRRC_MSG0_ERROR("RRCHSRACH:Failed to configure HS-RACH");
              return FAILURE;
            }
          }
#endif
          cmd_local_ptr = (rrc_cmd_type *)rrc_malloc(sizeof(rrc_cmd_type));
          rrcllc_build_chan_config_req_cmd_for_est_rbs(cmd_local_ptr);
          if(rrcllc_process_config_dcch_dtch(cmd_local_ptr) == FAILURE)
          {
            (void)rrcllc_build_cmd_and_release_lc_ids();       
            WRRC_MSG0_ERROR("EFACH:SIB5 change, config_dcch_dtch failed");
            rrc_free(cmd_local_ptr);
            return(FAILURE);
          }
          rrc_free(cmd_local_ptr);
            
#ifdef FEATURE_WCDMA_HS_RACH
          /* Set rrccu_hsrach_delay_cu_sib_change flag to true for delay CU case */
          if(rrcllc_get_sib5_change_in_progress_flag() == SIB5CHANGE_HSRACH_DELAY_CU)
          {
            rrccu_set_hsrach_sib_change(TRUE);
          }
#endif
        }
        break;
      case CELL_CHANGE_ACTIVE:
       /*Should not happen as rrcllc_set_sib5_change_in_progress_flag() should have set it from
         ACTIVE to either CELL_CAP_CHANGED/NO_CHANGE_IN_CELL_CAP/SIB5CHANGE_HSRACH_DELAY_CU*/
      default:
        break;
    }
    sib5_change = TRUE;
  }

    /* Downlink Physical channel processing */
    /* Force Reconfigurations of MAC and L1 in ALL cases so that all layers
     * remain on the same Ordered Config or Current Config pointer. Otherwise
     * selective reconfigurations of layers can put them "out of sync".
     */

  /*WL1/MAC config will be skipped for HS-FACH and CU is going to be triggered*/
  if(RRC_DCH_FACH_TRANISITION_CHANNEL_INVALID == dch_fach_common_chn_setup_in_progress)
  {
    ordered_config_ptr->reconfig_needed.uplink_l1 = TRUE;
    ordered_config_ptr->reconfig_needed.downlink_l1 = TRUE;
  
    ordered_config_ptr->reconfig_needed.uplink_mac = TRUE;
    ordered_config_ptr->reconfig_needed.downlink_mac = TRUE;
  }
  
  if(ordered_config_ptr->reconfig_needed.downlink_l1)
  {

    if(rrcllc_get_hs_status_in_e_fach(ordered_config_ptr) == TRUE)
    {
      if(((rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
            && (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP))||
           (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CHO))
      {
        /*CCTrch-id has to be cleared before allocating new CCTrch-Id when W to G HO fails */
        if(ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.cctrch_id !=
           RRCLLC_INVALID_CCTRCH_ID)
        {
          RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.cctrch_id);
        }
        if(rrcenhstate_setup_phychan() == FAILURE)
        {
          ERR_FATAL("EFACH:Error reconfiguring HS PDSCH",0,0,0);
        }
        else
        {
          WRRC_MSG0_HIGH("EFACH:Special case CCO Fail,resume set START to L1 & Reconfig to MAC");
          ordered_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_RECONFIG;
        }
          
  #ifdef FEATURE_WCDMA_HS_RACH
      if(rrchsrach_camped_cell_supports_hsrach())
      {
          /*The below function might have already been called in rrcllc_update_oc_in_fach_with_sibs
          if not called then call the below function to update the sib into oc*/
          //rrcllc_copy_sib_to_oc_for_hsrach(RRC_STATE_CELL_FACH);
                
          /* Restore the mapping for for dedicated mode config*/
        if(FAILURE == rrcllc_evaluate_hs_rach_and_set_lower_layers_action(RRC_STATE_CELL_FACH,ordered_config_ptr))
        {
          WRRC_MSG0_ERROR("RRCHSRACH:Failed to configure HS-RACH");
          return FAILURE;
        }
        else
        {
          WRRC_MSG0_HIGH("RRCHSRACH:Special case CCO Fail,resume -set START to L1 & Reconfig to MAC");
          ordered_config_ptr->l1_hs_rach_req_mask = L1_HS_RACH_START;
          rrcllc_set_hs_rach_action(ordered_config_ptr,MAC_HS_RACH_CONFIG);
        }
      }
  #endif
      }
      else if(!sib5_change)
      {
        (void)rrcenhstate_process_reconfig_ccch();
        if(rrcenhstate_reconfig_phychan(RRC_E_FACH_DEDICATED) == FAILURE)
        {
          ERR_FATAL("EFACH:Error reconfiguring HS PDSCH",0,0,0);
        }
      }
    }
  else
#endif
    {
      /* We come here ONLY WHEN no operation on BCH/NBCH */
      if(rrcllc_semi_permanent_data.dl_phy_chan.fach_included == FALSE)
      {
        if (((rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
             && (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)) &&
            OC_SET_FOR_CELL_DCH == rrcllc_get_ordered_config_status_wo_f3()) 
        {
          WRRC_MSG0_HIGH("OC set for DCH.  phychan_resetup in fach");
          /* Don't fail this config.  fach_included flag was reset as part of setting
               OC for FACH->DCH.  Here just continue with re-setting up FACH, and later
               send channel config cnf to procedure that set oc for DCH so to 
               send a failure to NW.
               */
        }
        else
        {
          /* This is a wrong selection of SCCPCH that does not have FACH */
          WRRC_MSG0_ERROR("SCCPCH has no FACH included in Cell_FACH");
          return(FAILURE);
        }
      }
  
      /* Fix the transport channel bitmasks for SCCPCH */
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
        L1_DL_TRCH_REFTYPE_FACH_BF;
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf |=
        L1_DL_TRCH_REFTYPE_FACH_BF;
  
      if(rrcllc_semi_permanent_data.dl_phy_chan.pch_included)
      {
        rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
          L1_DL_TRCH_REFTYPE_PCH_BF;
        rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf &=
          ~L1_DL_TRCH_REFTYPE_PCH_BF;
      }
      else  /* No PCH on this SCCPCH */
      {
        rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf &=
          ~L1_DL_TRCH_REFTYPE_PCH_BF;
        rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf &=
          ~L1_DL_TRCH_REFTYPE_PCH_BF;
      }
  #ifdef FEATURE_WCDMA_HS_FACH
       /* Sib5 change: EFACH to non efach. Stop efach and configure sccpch  */
      if(rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP &&
         rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_RECONFIG_PCH_FACH && 
         rrcllc_get_hs_status_in_e_fach(current_config_ptr) == TRUE && 
         rrcenhstate_camped_cell_supports_e_fach() == FALSE)
      {
        rrc_cmd_type *cmd_local_ptr = NULL;
        
        /*Reconfig bcch and ccch for legacy as it was added for efach  */
        /*restore legayc fach/rach mapping and congiure lower layers with mapping*/
        rrcllc_set_hs_status_in_e_fach(ordered_config_ptr, FALSE);
        rrcenhstate_init_efach_mapping(ordered_config_ptr);
        rrcenhstate_init_efach_queues(ordered_config_ptr);
        (void)rrcllc_restore_from_hanging(ordered_config_ptr, UL_RACH_MAPPING|DL_FACH_MAPPING);
        (void)rrcllc_process_reconfig_bcch_on_fach();
        /*Decrementing because of SIB5 change */
        ordered_config_ptr->rlc_dl_tm_parms.nchan--;
        (void)rrcllc_process_reconfig_ccch();
  
        cmd_local_ptr = (rrc_cmd_type *)rrc_malloc(sizeof(rrc_cmd_type));	  
        rrcllc_build_chan_config_req_cmd_for_est_rbs(cmd_local_ptr);
  
        if(rrcllc_process_config_dcch_dtch(cmd_local_ptr) == FAILURE)
        {
         (void)rrcllc_build_cmd_and_release_lc_ids();       
          WRRC_MSG0_ERROR("EFACH:SIB5 change, config_dcch_dtch failed");
          rrc_free(cmd_local_ptr);
          return(FAILURE);
        }
        rrc_free(cmd_local_ptr);
  
        WRRC_MSG0_HIGH("EFACH:SIB5 changed, cell downgraded to non-EFACH");
       /* Rlease HS-PDSCH */      
        rrcenhstate_release_phychan(RRC_E_FACH_DEDICATED);
  
        /* add sccpch */
        rrcllc_process_add_sccpch();
      }
      else
  #endif
  
      /* This is a case for reconfiguration of SCCPCH since an SCCPCH
       * was already up for PCH in Connecting state.
       */
      {
        MSG_LOW("LLC_PHYCHAN_RECONFIG on SCCPCH", 0, 0, 0);
  
        if(!((rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
              && (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)) &&
           rrcllc_cmd_under_process.procedure != RRC_PROCEDURE_CHO)
        {
          rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_action =
            LLC_PHYCHAN_RECONFIG;
        }
        else
        {
          MSG_LOW("LLC_PHYCHAN_SETUP on SCCPCH", 0, 0, 0);
  
          rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_action =
            LLC_PHYCHAN_SETUP;
        }
  
        if(!((rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
              && (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)) &&
           rrcllc_cmd_under_process.procedure != RRC_PROCEDURE_CHO)
        {
          /* Since we are reconfiguring a SCCPCH, a new CCTrCH ID needs to be allocated */
          /* If a valid CCTrCH ID exists for SCCPCH, add it to release list */
          if(rrcllc_semi_permanent_data.dl_phy_chan.sccpch.cctrch_id !=
             RRCLLC_INVALID_CCTRCH_ID)
          {
            RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                                 dl_phy_chan.sccpch.cctrch_id);
          }
        }
  
        if(!((rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
              && (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)) &&
           rrcllc_cmd_under_process.procedure != RRC_PROCEDURE_CHO)
        {
          /* Get a new CCTrCH ID */
          cctrch_id = rrcllc_get_cctrch_id();
        }
        else
        {
          /* Update SCCPCH CCTrCh from semi_permanent data */
          cctrch_id = rrcllc_semi_permanent_data.dl_phy_chan.sccpch.cctrch_id;
        }
  
        if(cctrch_id != RRCLLC_INVALID_CCTRCH_ID)
        {
          /* Update FACH info in MAC Ordered Config */
          for(i = 0; i < ordered_config_ptr->mac_dl_parms.num_fachs; i ++)
          {
            ordered_config_ptr->mac_dl_parms.fach_info[i]->cctrch_id = cctrch_id;
          }
          /* If PCH is present, update PCH info in Ordered Config with new CCTrCH ID */
          if(ordered_config_ptr->mac_dl_parms.num_pchs != 0)
          {
            ordered_config_ptr->mac_dl_parms.pch_info->cctrch_id = cctrch_id;
          }
          /* Update SCCPCH Info in rrcllc_cmd_under_process */
          rrcllc_semi_permanent_data.dl_phy_chan.sccpch.cctrch_id =
              cctrch_id;
        }
        else
        {
          WRRC_MSG1_ERROR("Invalid CCTrCH ID %d assigned", cctrch_id);
          return(FAILURE);
        }
      }  /* Reconfig is needed for L1 */
    }
  }
  else
  {
    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_action =
      LLC_PHYCHAN_NO_OP;
  }

  /* Uplink Physical channel processing */
  /* Look into Reconfig Needed to determine PRACH action */
  if(ordered_config_ptr->reconfig_needed.uplink_l1)
  {
    if (rrcllc_cmd_under_process.chan_config.chan_config_reason ==
       RRCLLC_CHAN_CFG_REASON_RECONFIG_PCH_FACH)
    {
      rrcllc_cmd_under_process.chan_config.phy_chan_action_list.prach_action =
                LLC_PHYCHAN_DROP_AND_ADD;

    }
    else if(!((rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
         && (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)) &&
       rrcllc_cmd_under_process.procedure != RRC_PROCEDURE_CHO)
    {
      rrcllc_cmd_under_process.chan_config.phy_chan_action_list.prach_action =
        LLC_PHYCHAN_DROP_AND_ADD; //LLC_PHYCHAN_RECONFIG;
      MSG_LOW("LLC_PHYCHAN_DROP_AND_ADD on PRACH", 0, 0, 0);
    }
    else
    {
      /* This is a case for addition of PRACH */
      rrcllc_cmd_under_process.chan_config.phy_chan_action_list.prach_action =
        LLC_PHYCHAN_SETUP;

      MSG_LOW("LLC_PHYCHAN_SETUP on PRACH", 0, 0, 0);
    }

  }
  else
  {
    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.prach_action =
      LLC_PHYCHAN_NO_OP;
  }
  if(RRC_DCH_FACH_TRANISITION_CHANNEL_SETUP == dch_fach_common_chn_setup_in_progress)
  {
    rrcllc_setup_physical_channels_for_dch_to_fach();
#ifdef FEATURE_WCDMA_HS_RACH	
    if(rrcsib_update_sib7_hs_rach() == FALSE)
    {
      rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action =
          LLC_PHYCHAN_RELEASE;
      if(rrcllc_update_spccpch_params_based_on_action(ordered_config_ptr)==FAILURE)
      {
        return (FAILURE);
      }
    }
#endif
  }
    /*This code is not needed. Added to keep the MAC and WL1 hs actions in synch*/
  else if(RRC_DCH_FACH_TRANISITION_SKIP_CHANNEL_SETUP == dch_fach_common_chn_setup_in_progress)
  {
#ifdef FEATURE_WCDMA_HS_FACH
    rrcllc_set_hs_status_in_e_fach(ordered_config_ptr, FALSE);
    ordered_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_NOOP;            
    rrcllc_set_hs_action_in_e_fach(ordered_config_ptr,HSDPA_NOOP);           
#ifdef FEATURE_WCDMA_HS_RACH

    rrchsrach_set_common_edch_transmission(ordered_config_ptr, FALSE);
    rrchsrach_set_ready_for_common_edch(ordered_config_ptr, FALSE);
    ordered_config_ptr->l1_hs_rach_req_mask = L1_HS_RACH_NO_OP;
    rrcllc_set_hs_rach_action(ordered_config_ptr,MAC_HS_RACH_NOOP);           
#endif
#endif
  }
  return (SUCCESS);
} /* rrcllc_chan_config_within_fach */


 /*===========================================================================
FUNCTION   rrcllc_chan_config_within_fach_for_rl_failure

DESCRIPTION
  This function is resposible for determining all actions on RLC, MAC
  and L1.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static uecomdef_status_e_type
rrcllc_chan_config_within_fach_for_rl_failure(rrc_cmd_type *cmd_ptr)
{
  int i;

  uint8  cctrch_id;
  boolean config_dcch_dtch = FALSE;

  rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;
  WRRC_MSG2_HIGH("Chan_config_withinfach_for_rlfailure proc:rrc_proc_e_type_value%d, oc_status:rrcllc_oc_set_status_e_type_value%d",
           rrcllc_cmd_under_process.procedure,rrcllc_get_ordered_config_status_wo_f3());
  /* Start with copying CC to OC */
  /* this is to avoid the problem when dcch_fach mapping is not present */
  rrcllc_copy_cc_to_oc();

#ifdef FEATURE_WCDMA_HS_RACH
   /* Configure lower layers for hsrach cell only if hsrach mappings are valid */
   if(TRUE == rrchsrach_camped_cell_supports_hsrach())
   {
     if(SUCCESS == rrcllc_evaluate_hs_rach_and_set_lower_layers_action(RRC_STATE_CELL_FACH,ordered_config_ptr))
     {
       config_dcch_dtch = TRUE;
     }
   }
   else
#endif
   if(TRUE == rrcllc_check_dcch_fach_mapping(transition_config.toc_ptr))
   {
     config_dcch_dtch = TRUE;
   }


   /*check whether RB1-RB4 mapping on FACH exists in ordered config */
  if (transition_config.toc_usage == TOC_FOR_DCH_AND_FACH)
  {
    if(TRUE == config_dcch_dtch)
    {
      /*Get the RLC and MAC configuration parameters for dedicated
       logical channels  from TOC */
      rrcllc_update_oc_in_fach_with_toc_for_rl_failure();

      if (rrcllc_process_config_dcch_dtch(cmd_ptr) == FAILURE)
      {
        (void)rrcllc_build_cmd_and_release_lc_ids(); 
        WRRC_MSG0_ERROR("FAILURE in config dcch dtch");
        return FAILURE;
      }
      /* Indicate that now onwards TOC can be used for CELL_DCH state only */
      transition_config.toc_usage = TOC_FOR_DCH;
    }
    else
    {
      /* dcch mapping on fach can not be found
      return failure */
      WRRC_MSG0_ERROR("DCCH mapping on FACH not present");

      /*Get the RLC and MAC configuration parameters for dedicated
       logical channels  from TOC */
      rrcllc_update_oc_in_fach_with_toc_for_rl_failure();
      /* Indicate that now onwards TOC can be used for CELL_DCH state only */
      transition_config.toc_usage = TOC_FOR_DCH;

      /* copy oc back to CC so that cc will also have RLC(RB) info
      This is required even if the dcch/fach mapping is not present */
      rrcllc_copy_oc_to_cc();
      /* swap oc and cc now so that when oc is cleared by cu procedure
      there will be another swap that points the config db for lower layers
      to the currect db pointer.*/
      rrcllc_swap_oc_and_cc();
      return(FAILURE);
    }
  }
  else
  {
    /* Should not come here */
    WRRC_MSG0_ERROR("TOC is invalid");
    return(FAILURE);
  }

#ifdef FEATURE_WCDMA_HS_FACH
  if(rrcllc_get_hs_status_in_e_fach(ordered_config_ptr) == FALSE)
#endif
  {
    if(rrcllc_semi_permanent_data.dl_phy_chan.fach_included == FALSE)
    {
      /* This is a wrong selection of SCCPCH that does not have FACH */
      WRRC_MSG0_ERROR("SCCPCH has no FACH included in Cell_FACH");
      return(FAILURE);
    }
  }

  /* Downlink Physical channel processing */
  /* Force Reconfigurations of MAC and L1 in ALL cases so that all layers
   * remain on the same Ordered Config or Current Config pointer. Otherwise
   * selective reconfigurations of layers can put them "out of sync".
   */
  ordered_config_ptr->reconfig_needed.uplink_l1 = TRUE;
  ordered_config_ptr->reconfig_needed.downlink_l1 = TRUE;

  ordered_config_ptr->reconfig_needed.uplink_mac = TRUE;
  ordered_config_ptr->reconfig_needed.downlink_mac = TRUE;

#ifdef FEATURE_WCDMA_HS_FACH
  if(rrcllc_get_hs_status_in_e_fach(ordered_config_ptr))
  {
    if(rrcenhstate_reconfig_phychan(RRC_E_FACH_DEDICATED) == FAILURE)
    {
      ERR_FATAL("RRCENHST:Error reconfiguring HS PDSCH",0,0,0);
    }
  }
  else
#endif /*FEATURE_WCDMA_HS_FACH*/
  {
    /* Fix the transport channel bitmasks for SCCPCH */
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
      L1_DL_TRCH_REFTYPE_FACH_BF;
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf |=
      L1_DL_TRCH_REFTYPE_FACH_BF;

    if(rrcllc_semi_permanent_data.dl_phy_chan.pch_included)
    {
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
        L1_DL_TRCH_REFTYPE_PCH_BF;
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf &=
        ~L1_DL_TRCH_REFTYPE_PCH_BF;
    }
    else  /* No PCH on this SCCPCH */
    {
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf &=
        ~L1_DL_TRCH_REFTYPE_PCH_BF;
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf &=
        ~L1_DL_TRCH_REFTYPE_PCH_BF;
    }

    /* This is a case for reconfiguration of SCCPCH since an SCCPCH
     * was already up for PCH in Connecting state.
     */

    if(ordered_config_ptr->reconfig_needed.downlink_l1)
    {
      MSG_LOW("LLC_PHYCHAN_RECONFIG on SCCPCH", 0, 0, 0);

      rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_action =
        LLC_PHYCHAN_RECONFIG;

      /* Since we are reconfiguring a SCCPCH, a new CCTrCH ID needs to be allocated */
      /* If a valid CCTrCH ID exists for SCCPCH, add it to release list */
      if(rrcllc_semi_permanent_data.dl_phy_chan.sccpch.cctrch_id !=
         RRCLLC_INVALID_CCTRCH_ID)
      {
        RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                             dl_phy_chan.sccpch.cctrch_id);
      }
      /* Get a new CCTrCH ID */
      cctrch_id = rrcllc_get_cctrch_id();
      if(cctrch_id != RRCLLC_INVALID_CCTRCH_ID)
      {
        /* Update FACH info in MAC Ordered Config */
        for(i = 0; i < ordered_config_ptr->mac_dl_parms.num_fachs; i ++)
        {
          ordered_config_ptr->mac_dl_parms.fach_info[i]->cctrch_id = cctrch_id;
        }
        /* If PCH is present, update PCH info in Ordered Config with new CCTrCH ID */
        if(ordered_config_ptr->mac_dl_parms.num_pchs != 0)
        {
          ordered_config_ptr->mac_dl_parms.pch_info->cctrch_id = cctrch_id;
        }
        /* Update SCCPCH Info in rrcllc_cmd_under_process */
        rrcllc_semi_permanent_data.dl_phy_chan.sccpch.cctrch_id =
            cctrch_id;
      }
      else
      {
        WRRC_MSG1_ERROR("Invalid CCTrCH ID %d assigned", cctrch_id);
        return(FAILURE);
      }
    }  /* Reconfig is needed for L1 */
    else
    {
      rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_action =
        LLC_PHYCHAN_NO_OP;
    }
  }

  /* Uplink Physical channel processing */
  /* Look into Reconfig Needed to determine PRACH action */
  if(ordered_config_ptr->reconfig_needed.uplink_l1)
  {
    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.prach_action =
      LLC_PHYCHAN_DROP_AND_ADD; //LLC_PHYCHAN_RECONFIG;
    MSG_LOW("LLC_PHYCHAN_DROP_AND_ADD on PRACH", 0, 0, 0);
  }
  else
  {
    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.prach_action =
      LLC_PHYCHAN_NO_OP;
  }

  //rrcllc_print_rlc_info(ordered_config_ptr);
#ifdef FEATURE_UMTS_PDCP
  rrcllc_print_pdcp_info(ordered_config_ptr);
#endif /* FEATURE_UMTS_PDCP */

  return(SUCCESS);

} /* rrcllc_chan_config_within_fach_for_rl_failure */


/*===========================================================================
FUNCTION   rrcllc_chan_config_pch_to_fach

DESCRIPTION
  This function is resposible for determining all actions on RLC, MAC
  and L1.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
/*lint -e715 */
static uecomdef_status_e_type
rrcllc_chan_config_pch_to_fach(rrc_cmd_type *cmd_ptr)
{

#ifdef FEATURE_WCDMA_HS_FACH
  int      index;
#endif

  rlc_lc_id_type        rlc_dl_log_chl_id; /* RLC downlink logical channel ID */
  rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;

  WRRC_MSG2_HIGH("Chan_config_pch2fach proc:rrc_proc_e_type_value%d, oc_status:rrcllc_oc_set_status_e_type_value%d",
           rrcllc_cmd_under_process.procedure,rrcllc_get_ordered_config_status_wo_f3());

  /* Update the variables in the ordered_config structure */

  if(rrcllc_update_oc_from_pch_to_fach()
       == FAILURE)
  {
    WRRC_MSG0_ERROR("Failure updating OC, Cell_PCH->Cell_FACH");
    return(FAILURE);
  }


  /* Drop PCCH */
  rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id
  (
    UE_LOGCHAN_PCCH,
    PCCH_RADIO_BEARER_ID,
    UE_MODE_TRANSPARENT
  );
  if (rlc_dl_log_chl_id != RRCLCM_RLC_LC_ID_NOT_FOUND)
  {
    (void)rrcllc_process_drop_pcch();
  }
  else
  {
    WRRC_MSG0_ERROR("NO PCCH before PCH->FACH transition");
  }

  /* Drop PCCH */
  rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id
  (
    UE_LOGCHAN_CTCH,
    CTCH_RADIO_BEARER_ID,
    UE_MODE_UNACKNOWLEDGED
  );
  if (rlc_dl_log_chl_id != RRCLCM_RLC_LC_ID_NOT_FOUND)
  {
    (void)rrcllc_process_drop_ctch();
  }
  else
  {
    WRRC_MSG0_HIGH("CTCH not present to drop");
  }


#ifdef FEATURE_WCDMA_HS_FACH
  if(rrcllc_get_hs_status_in_e_fach(ordered_config_ptr) == TRUE)
  {
    if(rrcenhstate_process_add_ccch() == FAILURE)
    {
      return FAILURE;
    }
  }
  else
#endif
  {
    if(rrcllc_semi_permanent_data.dl_phy_chan.fach_included == FALSE)
    {
      /* This is a wrong selection of SCCPCH that does not have FACH */
      WRRC_MSG0_ERROR("SCCPCH has no FACH included Cell_PCH->Cell_FACH");
      return(FAILURE);
    }
    else
    {
      /* Add CCCH */
      WRRC_MSG0_HIGH("Adding CCCH");
      (void)rrcllc_process_add_ccch_for_cell_pch_to_cell_fach();
    }
  }
#ifdef FEATURE_WCDMA_HS_FACH
  if(rrcllc_get_hs_status_in_e_fach(ordered_config_ptr) == TRUE)
  {
    /*This shuld not happen when hs_status_in_e_fach is TRUE*/
    WRRC_MSG0_HIGH("EFACH:legacy pch to efach transition. Adding bcch on fach");
    (void)rrcenhstate_process_add_bcch_on_hsdsch();
  }
  else
#endif 
  {
    (void)rrcllc_process_add_bcch_on_fach();
  }
  /* Initialize Send MAC Uplink Config indicator to TRUE */
  rrcllc_semi_permanent_data.send_mac_uplink_config = TRUE;

  /* Downlink Physical channel processing */
#ifdef FEATURE_WCDMA_HS_FACH
  if(rrcllc_get_hs_status_in_e_fach(ordered_config_ptr) == TRUE)
  {
    if(rrcenhstate_setup_phychan() == FAILURE)
    {
      return FAILURE;
    }
  }
  else
#endif
  {
    /* Fix the transport channel bitmasks for SCCPCH */
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
      L1_DL_TRCH_REFTYPE_FACH_BF;
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf |=
      L1_DL_TRCH_REFTYPE_FACH_BF;

    if(rrcllc_semi_permanent_data.dl_phy_chan.pch_included)
    {
      /*pch mapping is present but do not enable the PCH */
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
        L1_DL_TRCH_REFTYPE_PCH_BF;
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf &=
        ~L1_DL_TRCH_REFTYPE_PCH_BF;
    }
    else  /* No PCH on this SCCPCH */
    {
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf &=
        ~L1_DL_TRCH_REFTYPE_PCH_BF;
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf &=
        ~L1_DL_TRCH_REFTYPE_PCH_BF;
    }

    if(rrcllc_process_reconfigure_sccpch() == FAILURE)
    {
      WRRC_MSG0_ERROR ("Couldn't reconfigure SCCPCH");
      return FAILURE;
    }
  }

	/* Downlink Physical channel processing */
#ifdef FEATURE_WCDMA_HS_FACH
  if(rrcllc_get_hs_status_in_e_fach(ordered_config_ptr) == TRUE)
  {
    /* rb mapping info and RLC info are alrady copied in to cc while entering
    pch state. So no need to look at TOC at this point of time */
    if (rrcllc_process_config_dcch_dtch(cmd_ptr) == FAILURE)
    {
      (void)rrcllc_build_cmd_and_release_lc_ids(); 
      WRRC_MSG0_ERROR("FAILURE in config dcch dtch");
      return FAILURE;
    }
  }
  else
#endif
  {
    if (TRUE == rrcllc_check_dcch_fach_mapping(ordered_config_ptr))
    {
        /* rb mapping info and RLC info are alrady copied in to cc while entering
        pch state. So no need to look at TOC at this point of time */
      if (rrcllc_process_config_dcch_dtch(cmd_ptr) == FAILURE)
      {
        (void)rrcllc_build_cmd_and_release_lc_ids(); 
        WRRC_MSG0_ERROR("FAILURE in config dcch dtch");
        return FAILURE;
      }
    }
  }
/* check whether CTCH was setup on a different SCCPCH before. If that is the case
then drop that physical channel.
*/
  /* If a valid CCTrCH ID exists for SCCPCH, add it to release list */
  if(rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.cctrch_id !=
     RRCLLC_INVALID_CCTRCH_ID)
  {
    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_for_ctch_action =
      LLC_PHYCHAN_RELEASE;
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_ref_type_bf = 0;
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_enable_bf = 0;

    RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                         dl_phy_chan.sccpch_with_ctch.cctrch_id);
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.cctrch_id = RRCLLC_INVALID_CCTRCH_ID;
  }

  /* Uplink Physical channel processing */

  /* This is a case for addition of PRACH */
  rrcllc_cmd_under_process.chan_config.phy_chan_action_list.prach_action =
    LLC_PHYCHAN_SETUP;

  /* set the activation time to none */
  ordered_config_ptr->activation_time = 0;
  ordered_config_ptr->act_time_type = L1_ACTIVATION_TIME_NONE;

  MSG_LOW("LLC_PHYCHAN_SETUP on PRACH", 0, 0, 0);

  /*check whether RB1-RB4 mapping on FACH exists in ordered config */

 // if (transition_config.toc_usage != TOC_INVALID)
 // {
 //   if (TRUE == rrcllc_check_dcch_fach_mapping(transition_config.toc_ptr))
 //   {
 //     /*Get the RLC and MAC configuration parameters for dedicated
 //      logical channels  from TOC */
 //     rrcllc_update_oc_for_pch_to_fach_with_toc();
//
//      (void)rrcllc_process_config_dcch_dtch(cmd_ptr);
 //   }
 //   /* Now we are going to be in Cell_FACH. So make TOC usage valid
 //   only in Cell_DCH otherwise it will create problem in successive
 //   channel configs within Cell_FACH due to OTA messages */
 //   transition_config.toc_usage = TOC_FOR_DCH;
 // }
  WRRC_MSG3_MED("MAC dl_cfg num_fach %d, num_pch:%d,num_bch:%d",
           ordered_config_ptr->mac_dl_parms.num_fachs,
           ordered_config_ptr->mac_dl_parms.num_pchs,
           ordered_config_ptr->mac_dl_parms.num_bchs);

#ifdef FEATURE_WCDMA_HS_FACH
  if(rrcllc_get_hs_status_in_e_fach(ordered_config_ptr) == FALSE)
  {
    WRRC_MSG3_MED("L1 dl_cfg cctrch_type %d, ccch_en:%d,last_trchid:%d",
             ordered_config_ptr->l1_dl_cctrch_parms.cctrch_id,
             ordered_config_ptr->l1_dl_cctrch_parms.num_trch,
             ordered_config_ptr->l1_dl_cctrch_parms.trch_info_array[ordered_config_ptr->l1_dl_cctrch_parms.num_trch-1]->trch_id);

    if ((ordered_config_ptr->mac_dl_parms.num_fachs<UE_MAX_TRCH) &&
        ( ordered_config_ptr->mac_dl_parms.num_fachs>0))
    {
      for (index=0; index<ordered_config_ptr->mac_dl_parms.num_fachs; index++)
      {
        WRRC_MSG3_MED("MAC FACH ccch_en:%d, ndlchan:%d,trchid:%d",
                 ordered_config_ptr->mac_dl_parms.fach_info[index]->ccch_enable,
                 ordered_config_ptr->mac_dl_parms.fach_info[index]->ndlchan,
                 ordered_config_ptr->mac_dl_parms.fach_info[index]->trch_id);
      }
    }
  }
#endif
  WRRC_MSG8_MED("MAC ul_cfg cctrch_type %d,ccch_en:%d,ndlchan:%d, L1 ul_cfg chan %d, ntrch:%d, L1 PRACH config sig 0x%x, sub_chan:0x%x,num_asc:%d",
           ordered_config_ptr->mac_ul_parms.cctrch_ptr->cctrch_type,
           ordered_config_ptr->mac_ul_parms.cctrch_ptr->rach_info.ccch_enable,
           ordered_config_ptr->mac_ul_parms.cctrch_ptr->rach_info.ndlchan,
           ordered_config_ptr->l1_ul_cctrch_parms.chan,
           ordered_config_ptr->l1_ul_cctrch_parms.num_trch,
           ordered_config_ptr->l1_ul_chan_parms.prach_cfg.avail_sig_mask,
           ordered_config_ptr->l1_ul_chan_parms.prach_cfg.avail_sub_chan_mask,
           ordered_config_ptr->l1_ul_chan_parms.prach_cfg.asc_cfg.num_asc);


  if((ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid == CRNTI_VALID) ||
    (ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid == BOTH_VALID))
  {
    WRRC_MSG1_HIGH("CRNTI in OC %d on PCH->FACH transition",ordered_config_ptr->mac_dl_parms.rnti_info.crnti);
  }

  if((current_config_ptr->mac_dl_parms.rnti_info.rnti_valid == CRNTI_VALID) ||
    (current_config_ptr->mac_dl_parms.rnti_info.rnti_valid == BOTH_VALID))
  {
    WRRC_MSG1_HIGH("CRNTI in CC %d on PCH->FACH transition",current_config_ptr->mac_dl_parms.rnti_info.crnti);
  }
  
#ifdef FEATURE_UPDATE_SIB7_IN_FACH
#ifdef FEATURE_WCDMA_HS_RACH
  if (rrcsib_update_sib7_hs_rach() == TRUE)
#endif
  {
  if(!rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch_is_up)
  {
    /*
    Setup PCCCPH if it not present Earlier
    */
    rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id
    (
              UE_LOGCHAN_BCCH,
              BCCH_S_RADIO_BEARER_ID,
              UE_MODE_TRANSPARENT
    );
    if ((rlc_dl_log_chl_id == RRCLCM_RLC_LC_ID_NOT_FOUND) && (!rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up))
    {
#ifdef FEATURE_QCHAT
      if(!qchatupk_wcdma_wftcs_enabled() ||
        (qchatupk_wcdma_wftcs_enabled() && !qchatupk_is_tch_setup_in_progress()))
      {
#endif /*FEATURE_QCHAT*/    
        /* A S-BCCH has to be added in DL; Setup S-PCCPCH */
        rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action =
          LLC_PHYCHAN_SETUP;
        if(rrcllc_update_spccpch_params_based_on_action(ordered_config_ptr)==FAILURE)
        {
          return (FAILURE);
        }
#ifdef FEATURE_QCHAT
      }
      else
      {
        WRRC_MSG0_HIGH("QCHAT is skipping setting up of BCCH for PCH->FACH");
        qchatupk_process_skip_bcch_add_on_pch_to_fach();
      }
#endif /*FEATURE_QCHAT*/  
    }
    else
    {
      WRRC_MSG0_HIGH("S-BCCH is already up. Do not bring it up again ");
    }
  }
  else
  {
    /*
      If N-BCCH is up already, Do not bring up S-BCCH
    */
    WRRC_MSG0_HIGH("N-BCCH is up, Do not Bring up S-BCCH ");
  }
  }
#endif /* FEATURE_UPDATE_SIB7_IN_FACH */

#ifdef FEATURE_WCDMA_HS_RACH
  rrchsrach_set_hspa_rnti_stored_cell_pch(current_config_ptr,FALSE);
  rrchsrach_set_hspa_rnti_stored_cell_pch(ordered_config_ptr,FALSE);
#endif

  return(SUCCESS);
}
/*lint +e715 */


/*===========================================================================
FUNCTION   rrcllc_chan_config_for_oos_within_pch

DESCRIPTION
  This function is resposible for determining all actions on RLC, MAC
  and L1.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static uecomdef_status_e_type
rrcllc_chan_config_for_oos_within_pch(rrc_cmd_type *cmd_ptr)
{
  WRRC_MSG2_HIGH("Chan_config_for_oos_within_pch proc:rrc_proc_e_type_value%d, oc_status:rrcllc_oc_set_status_e_type_value%d",
           rrcllc_cmd_under_process.procedure,rrcllc_get_ordered_config_status_wo_f3());
  if(cmd_ptr->cmd.chan_config_req.procedure == RRC_PROCEDURE_CSP)
  {
    if((cmd_ptr->cmd.chan_config_req.release_trchls) &&
       (cmd_ptr->cmd.chan_config_req.release_phychls))
    {
    /* This is a special case for releasing only physical and
     * transport channels, keeping the logical channels as they are.
     */
      rrcllc_cmd_under_process.chan_config.current_cmd_engine =
        LLC_RELEASE_TR_PHY_CHAN_ENGINE;
      rrcllc_copy_cc_to_oc();
      /* copy rlc parameters dcch+dtch mapping on fach/rach to TOC so that
      we can copy them back to cc once ue re-enters service area and we need
      to setup dcch+dtch along with
      ccch */
      /* if TOC is TOC_FOR_OOS then don't updat toc with CC */
      if (transition_config.toc_usage != TOC_FOR_OOS) 
      {
        /* Also copy the RNTI Info from TOC to OC */
        transition_config.toc_ptr->mac_ul_parms.rnti_info =
          current_config_ptr->mac_ul_parms.rnti_info;
        transition_config.toc_ptr->mac_dl_parms.rnti_info =
          current_config_ptr->mac_dl_parms.rnti_info ;

        transition_config.toc_ptr->utran_drx_cycle_length = 
          current_config_ptr->utran_drx_cycle_length;
#ifdef FEATURE_WCDMA_HS_RACH
          /*store E-RNTI from CC to TOC if valid*/
          transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = 
           current_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present;
          transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti = 
           current_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti;

          transition_config.toc_ptr->efach_hrnti_status = current_config_ptr->efach_hrnti_status;
          transition_config.toc_ptr->efach_hrnti = current_config_ptr->efach_hrnti;
          /* Clear ERNTI in OC and CC. Later when after swap, CC gets copied to OC, we do not want
          ernti to be configured. ERNTI will be restored from TOC if we 
          camp back on same cell 
          */
          current_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = FALSE;
          ordered_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = FALSE;

#endif

#ifdef FEATURE_UMTS_PDCP
        /* Copy all pdcp info into TOC */
        rrcllc_copy_pdcp_parms(transition_config.toc_ptr, current_config_ptr);
#endif /* FEATURE_UMTS_PDCP */

        rrcllc_init_reestablish_entity(ORDERED_AND_CURRENT_CONFIG);
        if(current_config_ptr->rlc_am_parms.nentity == 0 )
        {
          WRRC_MSG0_ERROR("Num AM entity in Current config is 0");
        }
        /* Copy all RLC Config data for AM channels */
        rrcllc_copy_rlc_parms(transition_config.toc_ptr, current_config_ptr);

        /* Copy over the RB-oriented side of RLC size restrictions */
        rrcllc_copy_cell_fach_rlc_size_list(transition_config.toc_ptr, current_config_ptr);

        /* Save dcch+dtch mapping on fach/rach in to toc */
        rrcllc_copy_cell_fach_rb_mapping_info(transition_config.toc_ptr, current_config_ptr);
      }
      /* Initailize MAC data to release all Transport Channels */
      rrcllc_init_ordered_config_mac_info(ORDERED_CONFIG);
      
      rrcllc_restore_urnti_to_oc_from_toc();
      /* Indicate that both Downlink and Uplink MAC need to be reconfigured */
      ordered_config_ptr->reconfig_needed.downlink_mac = TRUE;
      ordered_config_ptr->reconfig_needed.uplink_mac = TRUE;

      /* Return from here as no other data in Channel Config Request
       * is relevant.
       */
      WRRC_MSG0_HIGH("Released Phy and Tr Chls");

      rrcllc_store_last_active_cell_capability();
    }
  } /* Normal, regular case */
  return(SUCCESS);
} /* rrcllc_chan_config_for_oos_within_pch */

/*===========================================================================
FUNCTION   rrcllc_chan_config_to_re_enter_within_pch

DESCRIPTION
  This function is resposible for determining all actions on RLC, MAC
  and L1 when re-entering service area in Cell_FACH state.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static uecomdef_status_e_type
rrcllc_chan_config_to_re_enter_within_pch(rrc_cmd_type *cmd_ptr)
{

  uint8   cctrch_id;
  int     i;
  rlc_lc_id_type        rlc_dl_log_chl_id; /* RLC downlink logical channel ID */
#ifdef FEATURE_WCDMA_HS_FACH
  //rrc_SysInfoType5    *sib5_ptr = NULL;
#endif

  rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;


  WRRC_MSG2_HIGH("Chan_config_re_enter_in_pch proc:rrc_proc_e_type_value%d, oc_status:rrcllc_oc_set_status_e_type_value%d",
           rrcllc_cmd_under_process.procedure,rrcllc_get_ordered_config_status_wo_f3());

     /* Update the variables in the ordered_config structure */
  if(rrcllc_update_oc_from_dch_to_pch_with_sibs(rrcllc_cmd_under_process.next_rrc_state)
       == FAILURE)
  {
    WRRC_MSG0_ERROR("Failure updating OC, reenter in PCH");
    return(FAILURE);
  }

  /* Add PCCH if it was not present before( in case of pch->fach channel
  config failure,  else reconfig*/
  rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id
  (
    UE_LOGCHAN_PCCH,
    PCCH_RADIO_BEARER_ID,
    UE_MODE_TRANSPARENT
  );

  
  if (rlc_dl_log_chl_id == RRCLCM_RLC_LC_ID_NOT_FOUND)
  {
    (void)rrcllc_process_add_pcch();
  }
  else
  {
    (void)rrcllc_process_reconfig_pcch();
  }
 if((rrc_ccm_cell_change_to_same_cell() == TRUE) || 
     ((rrccu_check_for_ura_reselection() == FALSE) && (rrc_get_state() == RRC_STATE_URA_PCH)))
  {
    WRRC_MSG0_HIGH("Restoring UTRAN drx cycle co-efficient,since re-enter in (CELL-PCH on same cell/same URA-ID in URA-PCH)");
    ordered_config_ptr->utran_drx_cycle_length = transition_config.toc_ptr->utran_drx_cycle_length ;
  }
#ifdef FEATURE_WCDMA_HS_RACH
  /* the above function copies URNTI only so copy CRNTI if the current camped
  cell is same as the one on which we detected oos */
  if (TRUE == rrc_ccm_cell_change_to_same_cell())
  {   
    if(rrchsrach_camped_cell_supports_hsrach() == TRUE) 
    {
        /*Restore E-RNTI from TOC to OC*/
        ordered_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = 
         transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present;
        ordered_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti = 
         transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti;

        ordered_config_ptr->efach_hrnti_status = transition_config.toc_ptr->efach_hrnti_status;
        ordered_config_ptr->efach_hrnti = transition_config.toc_ptr->efach_hrnti;
        current_config_ptr->efach_hrnti_status = transition_config.toc_ptr->efach_hrnti_status;
        current_config_ptr->efach_hrnti = transition_config.toc_ptr->efach_hrnti;

       if (transition_config.toc_ptr->mac_dl_parms.rnti_info.rnti_valid == BOTH_VALID)
       {
         WRRC_MSG0_HIGH("copy both CRNTI & URNTI");
         /* copy the rnti information to both oc and cc */
         ordered_config_ptr->mac_dl_parms.rnti_info =
           transition_config.toc_ptr->mac_dl_parms.rnti_info;
         current_config_ptr->mac_dl_parms.rnti_info =
           transition_config.toc_ptr->mac_dl_parms.rnti_info;
       
         ordered_config_ptr->mac_ul_parms.rnti_info =
           transition_config.toc_ptr->mac_ul_parms.rnti_info;
         current_config_ptr->mac_ul_parms.rnti_info=
           transition_config.toc_ptr->mac_ul_parms.rnti_info;
       }
       /*Common EDCH transmission not valid in PCH state*/
        rrchsrach_set_common_edch_transmission(ordered_config_ptr, FALSE);
        rrcllc_determine_and_set_ready_for_common_edch(ordered_config_ptr,RRC_STATE_CELL_PCH);
        rrcllc_determine_and_set_hspa_rnti_stored_cell_pch(ordered_config_ptr,RRC_STATE_CELL_PCH);
    }
  }
  else
  {
    /*If we dont camp back on the same cell then reset the 
      hspa_rnti_stored_cell_pch and ready_for_common_edch*/
    rrchsrach_set_hspa_rnti_stored_cell_pch(ordered_config_ptr, FALSE);
    rrchsrach_set_ready_for_common_edch(ordered_config_ptr, FALSE);
  }
  transition_config.toc_ptr->efach_hrnti_status = INVALID_HRNTI;
  /*Invalidate ERNTI in TOC as they are stale now*/
  transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = FALSE;  

  /*8.5.47  Actions related to READY_FOR_COMMON_EDCH variable (FDD 
            and 1.28 Mcps TDD only) 
    If any of the above conditions is not met and the variable READY_FOR_COMMON_EDCH is set to TRUE, the UE shall: 
    1>  set the variable READY_FOR_COMMON_EDCH to FALSE; 
    1>  if in CELL_FACH, CELL_PCH, URA_PCH state or in Idle mode: 
      2>  if the variable HSPA_RNTI_STORED_CELL_PCH is set to FALSE: 
         3>  clear variable E-RNTI.
  */
  if(rrcllc_get_hspa_rnti_stored_cell_pch(ordered_config_ptr) == FALSE)
  {
    ordered_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = FALSE;
    ordered_config_ptr->efach_hrnti_status = INVALID_HRNTI;
  }

#endif
  rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id(
    UE_LOGCHAN_CTCH,
    CTCH_RADIO_BEARER_ID,
    UE_MODE_UNACKNOWLEDGED
    );
  if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status != RRCLLC_NO_CTCH)
  {
    /* Add PCCH if it was not present before( in case of pch->fach channel
      config failure,  else reconfig */
    if (rlc_dl_log_chl_id == RRCLCM_RLC_LC_ID_NOT_FOUND)
    {
      (void)rrcllc_process_add_ctch();
    }
    else
    {
      (void)rrcllc_process_reconfig_ctch();
    }
  }
  else if (rlc_dl_log_chl_id != RRCLCM_RLC_LC_ID_NOT_FOUND)
  {
    (void)rrcllc_process_drop_ctch();
  }

  /* check whether any ccch channel needs to be released
  This would be the case where channel config from pch->fach fails
  and cu initiates cell selection with cause oos. During previous channel
  config pcch was dropped and ccch was established however state was not
  changed from pch to fach because of cphy_setup_failure */
  rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id
  (
    UE_LOGCHAN_CCCH,
    CCCH_RADIO_BEARER_ID,
    UE_MODE_UNACKNOWLEDGED
  );
  if (rlc_dl_log_chl_id != RRCLCM_RLC_LC_ID_ERROR)
  {
    (void)rrcllc_process_drop_ccch();
  }
  //configure bcch on fach
  rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id
  (
    UE_LOGCHAN_BCCH,
    BCCH_FACH_RADIO_BEARER_ID,
    UE_MODE_TRANSPARENT
  );
  if (rlc_dl_log_chl_id != RRCLCM_RLC_LC_ID_ERROR)
  {
    (void)rrcllc_process_drop_bcch_on_fach();
  }


#ifdef FEATURE_UMTS_PDCP
  /* Copy the saved PDCP info from TOC to OC*/
  rrcllc_copy_pdcp_parms(ordered_config_ptr, transition_config.toc_ptr);
#endif /* FEATURE_UMTS_PDCP */

  /* now copy saved rlc info and rbmapping info from toc to oc */
  /* Copy all RLC Config data for AM channels */
  rrcllc_copy_rlc_parms(ordered_config_ptr, transition_config.toc_ptr);

    /* Save dcch+dtch mapping on fach/rach in to toc */
  rrcllc_copy_cell_fach_rb_mapping_info(ordered_config_ptr, transition_config.toc_ptr);

  /* Also copy the RNTI Info from TOC to OC */
  ordered_config_ptr->mac_ul_parms.rnti_info =
    transition_config.toc_ptr->mac_ul_parms.rnti_info;
  ordered_config_ptr->mac_dl_parms.rnti_info =
    transition_config.toc_ptr->mac_dl_parms.rnti_info;

  ordered_config_ptr->rach_rlc_size_restriction_info.mac_update_needed = TRUE;
  /* Copy over the RB-oriented side of RLC size restrictions */
  rrcllc_copy_cell_fach_rlc_size_list(ordered_config_ptr, transition_config.toc_ptr);

  /* Update the MAC layer with the newly copied RLC size restriction info */
  (void)rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, RRC_STATE_CELL_FACH);

#ifdef FEATURE_WCDMA_HS_FACH
  if(rrcllc_get_hs_status_in_e_fach(ordered_config_ptr) == FALSE)
#endif
  {

    /* Fix the transport channel bitmasks for SCCPCH */
    if(rrcllc_semi_permanent_data.dl_phy_chan.pch_included)
    {
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
        L1_DL_TRCH_REFTYPE_PCH_BF;
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf |=
        L1_DL_TRCH_REFTYPE_PCH_BF;
    }
    else  /* No PCH on this SCCPCH */
    {
      WRRC_MSG0_ERROR("No PCH mapped on SCCPCH");
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf &=
        ~L1_DL_TRCH_REFTYPE_PCH_BF;
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf &=
        ~L1_DL_TRCH_REFTYPE_PCH_BF;
    }
    /* Now determine if OC has picked an SCCPCH that also carries FACH
       If FACH mappping is present then keep the reference for L1 but
       disable the FACH*/
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf &=
      ~L1_DL_TRCH_REFTYPE_FACH_BF;

    if(rrcllc_semi_permanent_data.dl_phy_chan.fach_included)
    {
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
        L1_DL_TRCH_REFTYPE_FACH_BF;
    }
    else
    {
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf &=
        ~L1_DL_TRCH_REFTYPE_FACH_BF;
    }
    if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status == RRCLLC_CTCH_WITH_PCCH)
    {
      /* both ctch and pcch are mapped on to same SCCPCH in this case we need to
      enable FACH */
      WRRC_MSG0_HIGH("ctch & pcch on same sccpch");
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf |=
        L1_DL_TRCH_REFTYPE_FACH_BF;
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
        L1_DL_TRCH_REFTYPE_FACH_BF;
    }

    /* Get a new CCTrCH ID */
    cctrch_id = rrcllc_get_cctrch_id();
    if(cctrch_id != RRCLLC_INVALID_CCTRCH_ID)
    {
      /* If PCH is present, update PCH info in Ordered Config with new CCTrCH ID */
      if(ordered_config_ptr->mac_dl_parms.num_pchs != 0)
      {
        ordered_config_ptr->mac_dl_parms.pch_info->cctrch_id = cctrch_id;
      }
      if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status == RRCLLC_CTCH_WITH_PCCH)
      {
        /* Update FACH info in MAC Ordered Config */
        for(i = 0; i < ordered_config_ptr->mac_dl_parms.num_fachs; i ++)
        {
          ordered_config_ptr->mac_dl_parms.fach_info[i]->cctrch_id = cctrch_id;
        }
      }
      /* Update SCCPCH Info in rrcllc_cmd_under_process */
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.cctrch_id =
          cctrch_id;
    }
    else
    {
      WRRC_MSG1_ERROR("Invalid CCTrCH ID %d assigned", cctrch_id);
      return(FAILURE);
    }

    MSG_LOW("LLC_PHYCHAN_SETUP on SCCPCH", 0, 0, 0);

    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_action =
      LLC_PHYCHAN_SETUP;
  }

  if(rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.cctrch_id !=
     RRCLLC_INVALID_CCTRCH_ID)
  {
    RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                         dl_phy_chan.sccpch_with_ctch.cctrch_id);
  }

  if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status == RRCLLC_CTCH_ON_DIF_SCCPCH)
  {
    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_for_ctch_action =
      LLC_PHYCHAN_SETUP;

    rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_ref_type_bf |=
      L1_DL_TRCH_REFTYPE_FACH_BF;
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_enable_bf |=
      L1_DL_TRCH_REFTYPE_FACH_BF;

    if(rrcllc_semi_permanent_data.dl_phy_chan.pch_included_for_sccpch_with_ctch)
    {
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_ref_type_bf |=
        L1_DL_TRCH_REFTYPE_PCH_BF;
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_enable_bf &=
        ~L1_DL_TRCH_REFTYPE_PCH_BF;
    }
    else  /* No PCH on this SCCPCH */
    {
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_ref_type_bf &=
        ~L1_DL_TRCH_REFTYPE_PCH_BF;
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_enable_bf &=
        ~L1_DL_TRCH_REFTYPE_PCH_BF;
    }

    if(!((rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
            && (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)))
    {
      /* Get a new CCTrCH ID */
      cctrch_id = rrcllc_get_cctrch_id();
    }
    else
    {
      /* Use the old CCTrCH ID that we copied from current config */
      cctrch_id = ordered_config_ptr->mac_dl_parms.pch_info->cctrch_id;
    }

    if(cctrch_id != RRCLLC_INVALID_CCTRCH_ID)
    {
      /* Update FACH info in MAC Ordered Config */
      for(i = 0; i < ordered_config_ptr->mac_dl_parms.num_fachs; i ++)
      {
        ordered_config_ptr->mac_dl_parms.fach_info[i]->cctrch_id = cctrch_id;
      }

      /* Update SCCPCH Info in rrcllc_cmd_under_process */
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.cctrch_id = cctrch_id;
    }
    else
    {
      WRRC_MSG1_ERROR("Invalid CCTrCH ID %d assigned", cctrch_id);
      return(FAILURE);
    }
  }


  /* Uplink Physical channel processing */

  /* CHECK OUT THE RRC_CHANNEL_CONFIG_REQ command */
  for (i=0; i < cmd_ptr->cmd.chan_config_req.num_rb_to_config; i++)
  {
    /* Action allowed only on BCCH and CCCH. CCCH action in implicitely
     * done. Look for BCCH action here.
     */
    if((cmd_ptr->cmd.chan_config_req.rb[i].rb_id == BCCH_S_RADIO_BEARER_ID) &&
       (cmd_ptr->cmd.chan_config_req.rb[i].rb_config == RELEASE_RB))
    {
      /* Release BCCH RB now */
      /* Set number of BCHs in MAC correctly */

      if (ordered_config_ptr->mac_dl_parms.num_bchs) 
      {
        ordered_config_ptr->mac_dl_parms.num_bchs --;
      }

      /* Update number of transport channels on PCCPCH in L1 CCTrCH Parameters */
      rrcllc_semi_permanent_data.dl_phy_chan.pccpch.num_trch = 0;

      /* Release the BCCH logical channel */
      if (rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up) 
      {
        (void)rrcllc_process_drop_bcch_serving();
      }
      else
      {
        WRRC_MSG0_ERROR("BCCH not present: no need for drop");
        return FAILURE;
      }

      rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action =
        LLC_PHYCHAN_RELEASE;
      rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_ref_type_bf = 0;
      rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_enable_bf = 0;
      /* Add the CCTrCH ID for PCCPCH to the CCTrCH IDs to be released list */
      RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                            dl_phy_chan.pccpch.cctrch_id);
    }
  } /* CHECK OUT THE RRC_CHANNEL_CONFIG_REQ command */

  /* Initialize Send MAC Uplink Config indicator to TRUE */
  rrcllc_semi_permanent_data.send_mac_uplink_config = TRUE;

  /* Indicate that both Downlink and Uplink MAC need to be reconfigured */
  ordered_config_ptr->reconfig_needed.downlink_mac = TRUE;
  ordered_config_ptr->reconfig_needed.uplink_mac = TRUE;

  /* Downlink Physical channel processing */

  return(SUCCESS);
} /* rrcllc_chan_config_to_re_enter_within_pch */

/*===========================================================================
FUNCTION   rrcllc_chan_config_within_pch

DESCRIPTION
  This function is resposible for determining all actions on RLC, MAC
  and L1.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static uecomdef_status_e_type
rrcllc_chan_config_within_pch(rrc_cmd_type *cmd_ptr)
{
  int i;
  rrcllc_bch_op_e_type  bch_op  = RRCLLC_NO_OP_BCH;
  rrcllc_nbch_op_e_type nbch_op = RRCLLC_NO_OP_NBCH;
  rrcllc_pch_op_e_type  pch_op  = RRCLLC_NO_OP_PCH;
  ordered_config_type  *config_ptr = ordered_config_ptr;
  rlc_lc_id_type rlc_dl_log_chl_id;
  uint8  cctrch_id;


  if(rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)
  {
    if (rrcllc_cmd_under_process.chan_config.chan_config_reason ==
         RRCLLC_CHAN_CFG_REASON_RE_ENTERING_SERVICE)
    {
      return (rrcllc_chan_config_to_re_enter_within_pch(cmd_ptr));
    }
    else  if (rrcllc_cmd_under_process.chan_config.chan_config_reason ==
         RRCLLC_CHAN_CFG_REASON_OUT_OF_SERVICE)
    {
      return rrcllc_chan_config_for_oos_within_pch(cmd_ptr);
    }
  }
  if(rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CCM)
  {
    if (rrcllc_cmd_under_process.chan_config.chan_config_reason ==
         RRCLLC_CHAN_CFG_REASON_RE_ENTERING_SERVICE)
    {
      return (rrcllc_chan_config_to_re_enter_within_pch(cmd_ptr));
    }
  }

  if(rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)
  {
    if(cmd_ptr->cmd.chan_config_req.num_rb_to_config ==1)
    {/*Only one Rb and that to BCCH*/
      if(cmd_ptr->cmd.chan_config_req.rb[0].rb_id == BCCH_S_RADIO_BEARER_ID)
      {
        if(cmd_ptr->cmd.chan_config_req.rb[0].rb_config == RELEASE_RB)
        {
          if(rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up == FALSE)
          { /* Ignore as it is already dropped*/
            rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_BYPASS_ENGINE;
            rrcllc_cmd_under_process.chan_config.solo_bch_operation = TRUE;
            WRRC_MSG0_HIGH("S-BCCH is Absent, bypass the release of S-BCCH");
            return (SUCCESS);
          }
        }
      }
    }
  }
  WRRC_MSG2_HIGH("Chan_config_within_pch proc:rrc_proc_e_type_value%d, oc_status:rrcllc_oc_set_status_e_type_value%d",
           rrcllc_cmd_under_process.procedure,rrcllc_get_ordered_config_status_wo_f3());
  rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;

  if(!((rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
       && (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)))
  {
    for (i=0; i<cmd_ptr->cmd.chan_config_req.num_rb_to_config; i++)
    {
      if((cmd_ptr->cmd.chan_config_req.rb[i].rb_id == BCCH_S_RADIO_BEARER_ID) &&
         (cmd_ptr->cmd.chan_config_req.rb[i].rb_config == ESTABLISH_RB))
      {
        rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;
        bch_op = RRCLLC_ADD_BCH;
      }
      else if((cmd_ptr->cmd.chan_config_req.rb[i].rb_id == BCCH_S_RADIO_BEARER_ID) &&
              (cmd_ptr->cmd.chan_config_req.rb[i].rb_config == RELEASE_RB))
      {
        rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;
        bch_op = RRCLLC_DROP_BCH;
      }
      else if((cmd_ptr->cmd.chan_config_req.rb[i].rb_id == BCCH_N_RADIO_BEARER_ID) &&
              (cmd_ptr->cmd.chan_config_req.rb[i].rb_config == ESTABLISH_RB))
      {
        if((rrc_get_state() == RRC_STATE_CELL_DCH) ||
           (rrcllc_get_ordered_config_status_wo_f3() == OC_SET_FOR_CELL_DCH))
        {
          rrcllc_cmd_under_process.chan_config.chan_cfg_status =
            RRCLLC_CHAN_CFG_FAILURE_INCOMPATIBLE_STATE;
          
          WRRC_MSG0_ERROR("Neighbor BCCH setup oborted");
          return(FAILURE);
        }
        else if(rrc_csp_is_reselection_cleared())
        { 
          /* Return failure as DL wk indication was received for this cell and reselection data (freq/scr)
                       have been cleared*/
          rrcllc_cmd_under_process.chan_config.chan_cfg_status =
            RRCLLC_CHAN_CFG_FAILURE_CFG_CANCELLED;
          WRRC_MSG0_ERROR("Reselect info cleared. N-BCCH setup aborted.");
          return (FAILURE);
        }
        else
        {
          rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;
          nbch_op = RRCLLC_ADD_NBCH;
        }
      }
      else if((cmd_ptr->cmd.chan_config_req.rb[i].rb_id == BCCH_N_RADIO_BEARER_ID) &&
              (cmd_ptr->cmd.chan_config_req.rb[i].rb_config == RELEASE_RB))
      {
        rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;
        nbch_op = RRCLLC_DROP_NBCH;
      }
      else if((cmd_ptr->cmd.chan_config_req.rb[i].rb_id == PCCH_RADIO_BEARER_ID) &&
              (cmd_ptr->cmd.chan_config_req.rb[i].rb_config == RECONFIG_RB))
      {
        if(current_config_ptr->mac_dl_parms.num_pchs == 0)
        {
          WRRC_MSG0_ERROR("PCCH reconfig: PCH not present");
          return(FAILURE);
        }
        else
        {
          rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;
          pch_op = RRCLLC_RECONFIG_PCH;
          WRRC_MSG0_HIGH("Reconfig PCCH");
        }
      }
      else if((cmd_ptr->cmd.chan_config_req.rb[i].rb_id == CCCH_RADIO_BEARER_ID) &&
          (cmd_ptr->cmd.chan_config_req.rb[i].rb_config == RECONFIG_RB))
      {
      /*Check if CCCH Reconfig is posted by CSP due to SIB change in the narrow window where
              FACH->PCH transition is in progress*/
        if ((rrcllc_cmd_under_process.chan_config.chan_config_reason ==
               RRCLLC_CHAN_CFG_REASON_RECONFIG_PCH_FACH) &&
              (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP))
        {
          if(current_config_ptr->mac_dl_parms.num_pchs == 0)
          {
            WRRC_MSG0_ERROR("PCCH reconfig: PCH not present");
            return(FAILURE);
          }
          else
          {
            rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;
            pch_op = RRCLLC_RECONFIG_PCH;
            WRRC_MSG0_HIGH("Reconfig PCCH");
          }
        }
      }
    } /* for(..) */
    
    /* UPDATE RLC AND MAC ORDERD CONFIG DATA STRUCTURES */
    
    /* Update the variables in the ordered_config structure */

    if((bch_op != RRCLLC_NO_OP_BCH) ||
       (nbch_op != RRCLLC_NO_OP_NBCH))
    {
      /* A solo BCH operation in progress */
      config_ptr = current_config_ptr;
      rrcllc_cmd_under_process.chan_config.solo_bch_operation = TRUE;
      
      /* If Lower Layers have been configured with Ordered Config, copy
       * OC to CC before proceeding further.
       */
      if((config_ptr_in_use == ORDERED_CONFIG) &&
         (ordered_config.process_state == LL_CONFIG_WITH_OC))
      {
        rrcllc_copy_oc_to_cc();
      }
      
      if (rrcllc_update_oc_for_serving_neighbor_bch_in_connected(config_ptr,
                                                                 bch_op,
                                                                 nbch_op)
          == FAILURE)
      {
        WRRC_MSG0_ERROR("Failure updating CC for SBCH/NBCH; In FACH");
        return(FAILURE);
      }
      if(bch_op == RRCLLC_ADD_BCH)
      {
        rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id
          (
            UE_LOGCHAN_BCCH,
            BCCH_S_RADIO_BEARER_ID,
            UE_MODE_TRANSPARENT
            );
        if (rlc_dl_log_chl_id == RRCLCM_RLC_LC_ID_NOT_FOUND) 
        {
          (void)rrcllc_process_add_bcch_serving(config_ptr);
        }
        else
        {
          (void)rrcllc_process_reconfig_bcch_serving(config_ptr);
        }
      }
      if(bch_op == RRCLLC_DROP_BCH)
      {
        if (rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up) 
        {
          (void)rrcllc_process_drop_bcch_serving();
        }
        else
        {
          if((nbch_op == RRCLLC_ADD_NBCH)&&
            (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_SIB))
          {
            WRRC_MSG0_ERROR("BCCH not present: Ignore drop since nbch_op action is add");
            bch_op = RRCLLC_NO_OP_BCH;
          }
          else
          {
            WRRC_MSG0_ERROR("BCCH not present: no need for drop, send failuer");
            return FAILURE;
          }
        }
      }
      if(nbch_op == RRCLLC_ADD_NBCH)
      {
        rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id
          (
            UE_LOGCHAN_BCCH,
            BCCH_N_RADIO_BEARER_ID,
            UE_MODE_TRANSPARENT
            );
        if (rlc_dl_log_chl_id == RRCLCM_RLC_LC_ID_NOT_FOUND) 
        {
          (void)rrcllc_process_add_bcch_neighbor(config_ptr);
        }
        else
        {
          (void)rrcllc_process_reconfig_bcch_neighbor(config_ptr);
        }
      }
      if(nbch_op == RRCLLC_DROP_NBCH)
      {
        (void)rrcllc_process_drop_bcch_neighbor();
      }
    }
    
    /* check for pcch reconfiguration */
    else if(pch_op != RRCLLC_NO_OP_PCH)
    {
      rrcllc_copy_cc_to_oc();
      config_ptr = ordered_config_ptr;
      /* update_oc_in_pch_for_pcch_reconfig will also update CTCH info*/
      (void)rrcllc_update_oc_in_pch_for_pcch_reconfig(config_ptr,rrc_get_state());
      /* Prepare a Reconfig PCCH command for RLC */
      (void)rrcllc_process_reconfig_pcch();
      rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id
      (
        UE_LOGCHAN_CTCH,
        CTCH_RADIO_BEARER_ID,
        UE_MODE_UNACKNOWLEDGED
      );
      if(rrcllc_semi_permanent_data.dl_phy_chan.ctch_status != RRCLLC_NO_CTCH)
      {
        /* ctch is present on this cell */
        if (rlc_dl_log_chl_id == RRCLCM_RLC_LC_ID_NOT_FOUND)
        {
          (void)rrcllc_process_add_ctch();
        }
        else
        {
          (void)rrcllc_process_reconfig_ctch();
        }
      }
      else if(rlc_dl_log_chl_id != RRCLCM_RLC_LC_ID_NOT_FOUND)
      {
        (void)rrcllc_process_drop_ctch();
      }
    }
    else
    {
      /* Treat the special case for DCH to PCH transition */
      if((transition_config.toc_usage == TOC_FOR_DCH_AND_FACH)
         || (transition_config.toc_usage == TOC_FOR_OOS)
         ||(transition_config.toc_usage == TOC_FOR_FACH_AND_PCH)
         ||(transition_config.toc_usage == TOC_FOR_FACH_AND_PCH_WITH_DCH_INFO)
         ||(transition_config.toc_usage == TOC_FOR_OOS_WITH_DCH_INFO)
         ||(transition_config.toc_usage == TOC_FOR_OOS_WITHOUT_DCH_INFO)
         )
      {
        /* Update Ordered Config with data from Transition Config */
        rrcllc_update_oc_in_pch_with_toc();
        /* TOC is still good for transition back to FACH state. */
        WRRC_MSG0_HIGH("Updated OC with TOC within PCH");
        /* copy oc back to CC so that cc will also have RLC(RB) info
        This is required even if the dcch/fach mapping is not present */
        rrcllc_copy_oc_to_cc();
        /*swap oc and cc here because we  are going to configure
        only RLC and skip mac and L1 so they will be still pointing
        at CC. If we do not swap oc and cc here then RLC gets configured
        with OC but MAC and L1 configuration still remains on CC. later when
        OC and CC get swappped after clearing oc, CC becomes OC and subsequent
        configuration  will use OC hence l1 might see corrupted data
        Note this should be applicable for only DCH->PCH transtion where we
        skip configuring MAC and L1*/
        rrcllc_swap_oc_and_cc();
        if((transition_config.toc_usage == TOC_FOR_FACH_AND_PCH)||
            (transition_config.toc_usage == TOC_FOR_OOS_WITHOUT_DCH_INFO))
        {
          transition_config.toc_usage = TOC_INVALID;
        }
        else if ((transition_config.toc_usage == TOC_FOR_FACH_AND_PCH_WITH_DCH_INFO)||
            (transition_config.toc_usage == TOC_FOR_OOS_WITH_DCH_INFO))
        {
          transition_config.toc_usage = TOC_FOR_DCH;
        }
        else
        {
          transition_config.toc_usage = TOC_FOR_DCH;
        }
      }

      if(rrcllc_process_config_dcch_dtch(cmd_ptr) == FAILURE)
      {
        (void)rrcllc_build_cmd_and_release_lc_ids();       
        return(FAILURE);
      }
    }
  } /* if !((rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP) */
  else
  {
    /* Use Ordered Config here */
    config_ptr = ordered_config_ptr;
    rrcllc_cmd_under_process.chan_config.solo_bch_operation = FALSE;

    rrcllc_copy_cc_to_oc();
    /* Set the Activation Time to "Now" */
    rrcllc_init_activation_time(config_ptr);
  }


  if(bch_op == RRCLLC_ADD_BCH || 
     (((rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
          && (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)) 
      && (rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up)))
  {

      current_config_ptr->l1_dl_chan_parms.pccpch.tx_div_ind =
      rrcllc_get_pccpch_tx_diversity(RRC_STATE_CELL_PCH);

    /* A BCCH has been added in DL => Setup PCCPCH */

    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action =
      LLC_PHYCHAN_SETUP;
    /* Update PCCPCH info in rrcllc_semi_permanent_data.dl_phy_chan */
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_ref_type_bf =
        L1_DL_TRCH_REFTYPE_SBCH_BF;
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_enable_bf =
        L1_DL_TRCH_REFTYPE_SBCH_BF;


    if(!((rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
          && (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)))
    {
      /* Get a new CCTrCH ID */
      cctrch_id = rrcllc_get_cctrch_id();
    }
    else
    {
      /* Update SCCPCH CCTrCh from semi_permanent data */
      cctrch_id = rrcllc_semi_permanent_data.dl_phy_chan.pccpch.cctrch_id;
    }

    /*Fixing the Array Out of Bound Error from KW*/
    if((cctrch_id != RRCLLC_INVALID_CCTRCH_ID) &&
      (config_ptr->mac_dl_parms.num_bchs <= MAC_DL_MAX_CCTRCH) &&
      (config_ptr->mac_dl_parms.num_bchs != 0))
    {
      /* Update BCH info in MAC Ordered Config */
      config_ptr->mac_dl_parms.
        bch_info[config_ptr->mac_dl_parms.num_bchs-1].cctrch_id =
      cctrch_id;

      /* Update PCCPCH Info in rrcllc_cmd_under_process */
      rrcllc_semi_permanent_data.dl_phy_chan.pccpch.cctrch_id = cctrch_id;

      MSG_LOW("LLC_PHYCHAN_SETUP for PCCPCH", 0, 0, 0);
    }
    else
    {
      WRRC_MSG1_ERROR("Invalid CCTrCH ID %d assigned", cctrch_id);
      return(FAILURE);
    }
  } /* If Serving BCCH add found */

  if(nbch_op == RRCLLC_ADD_NBCH || 
     (((rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
       && (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)) &&
      (rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch_is_up)))
  {
    /* Get PCCPCH channel parameters from Cell Selection into Ordered Config */
    rrccsp_get_neighbor_pccpch_parms(&rrcllc_cmd_under_process.rrcllc_cell_resel_info.scr_code,
                                     &rrcllc_cmd_under_process.rrcllc_cell_resel_info.freq);
    config_ptr->l1_dl_chan_parms.pccpch.scr_code =
      rrcllc_cmd_under_process.rrcllc_cell_resel_info.scr_code;

    /* If we have read SIB11, we should use the diversity info contained
       therein. */

      current_config_ptr->l1_dl_chan_parms.pccpch.tx_div_ind =
        FALSE;

      WRRC_MSG0_HIGH("Using N-PCCPCH TxDiv info from L1");


    /* A BCCH has been added in DL => Setup PCCPCH */

    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.n_pccpch_action =
      LLC_PHYCHAN_SETUP;
    /* Update PCCPCH info in config_ptr->rrcllc_semi_permanent_data.dl_phy_chan */
    rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch.trch_ref_type_bf =
        L1_DL_TRCH_REFTYPE_NBCH_BF;
    rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch.trch_enable_bf =
        L1_DL_TRCH_REFTYPE_NBCH_BF;


    if(!((rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
          && (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)))
    {
      /* Get a new CCTrCH ID */
      cctrch_id = rrcllc_get_cctrch_id();
    }
    else
    {
      /* Update SCCPCH CCTrCh from semi_permanent data */
      cctrch_id = rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch.cctrch_id;
    }

    /*Fixing the Array Out of Bound Error from KW*/
    if((cctrch_id != RRCLLC_INVALID_CCTRCH_ID) &&
      (config_ptr->mac_dl_parms.num_bchs <= MAC_DL_MAX_CCTRCH) &&
      (config_ptr->mac_dl_parms.num_bchs != 0))
    {
      /* Update BCH info in MAC Ordered Config */
      config_ptr->mac_dl_parms.
        bch_info[config_ptr->mac_dl_parms.num_bchs - 1].cctrch_id =
      cctrch_id;

      /* Update PCCPCH Info in rrcllc_cmd_under_process */
      rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch.cctrch_id = cctrch_id;

      MSG_LOW("LLC_PHYCHAN_SETUP for PCCPCH", 0, 0, 0);
    }
    else
    {
      WRRC_MSG1_ERROR("Invalid CCTrCH ID %d assigned", cctrch_id);
      return(FAILURE);
    }
  } /* If Neighbor BCCH add found */

  if((bch_op == RRCLLC_DROP_BCH) &&
     (rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up))
  {
    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action =
      LLC_PHYCHAN_RELEASE;
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_ref_type_bf = 0;
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_enable_bf = 0;
    /* Add the CCTrCH ID for PCCPCH to the CCTrCH IDs to be released list */
    RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                          dl_phy_chan.pccpch.cctrch_id);
  } /* If Serving BCCH drop found */

  /* Neighbor BCH is a special case. The pipe may be incompletely setup.
   * in that case, do not do anything with L1.
   */

  if((nbch_op == RRCLLC_DROP_NBCH) &&
     (rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch_is_up))
  {
    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.n_pccpch_action =
      LLC_PHYCHAN_RELEASE;
    rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch.trch_ref_type_bf = 0;
    rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch.trch_enable_bf = 0;
    /* Add the CCTrCH ID for PCCPCH to the CCTrCH IDs to be released list */
    RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                          dl_phy_chan.n_pccpch.cctrch_id);
  } /* If Neighbor BCCH drop found */

  /* Now return from here if there was any operation on Serving or Neighbor
   * BCH. This is because BCH operation can not co-exist with DCCH/DTCH operation
   * in any case
   */
  if(!((rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
       && (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)))
  {
    if((nbch_op != RRCLLC_NO_OP_NBCH) || (bch_op != RRCLLC_NO_OP_BCH))
    {
      return(SUCCESS);
    }
  }

  /* Downlink Physical channel processing */
  /* Force Reconfigurations of MAC and L1 in ALL cases so that all layers
   * remain on the same Ordered Config or Current Config pointer. Otherwise
   * selective reconfigurations of layers can put them "out of sync".
   */
  if(((rrc_get_state() == RRC_STATE_CELL_PCH) ||
      (rrc_get_state() == RRC_STATE_URA_PCH)) &&
     ((rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_PCH) ||
      (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_URA_PCH)))
  {
    if(rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)
    {
      /* this is reconfiguration due to sib modification. Need to
      reconfigure L1 */
      ordered_config_ptr->reconfig_needed.uplink_l1 = TRUE;
      ordered_config_ptr->reconfig_needed.downlink_l1 = TRUE;
    }
    else
    {
      ordered_config_ptr->reconfig_needed.uplink_l1 = FALSE;
      ordered_config_ptr->reconfig_needed.downlink_l1 = FALSE;
    }
  }
  else
  {
    ordered_config_ptr->reconfig_needed.uplink_l1 = TRUE;
    ordered_config_ptr->reconfig_needed.downlink_l1 = TRUE;
  }

  ordered_config_ptr->reconfig_needed.uplink_mac = TRUE;
  ordered_config_ptr->reconfig_needed.downlink_mac = TRUE;

#ifdef FEATURE_WCDMA_HS_FACH
  if(rrcllc_get_hs_status_in_e_fach(ordered_config_ptr) == FALSE)
#endif
  {
    /* Fix the transport channel bitmasks for SCCPCH */
    if(rrcllc_semi_permanent_data.dl_phy_chan.fach_included == TRUE)
    {
      /* SCCPCH that has FACH */
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf =
        L1_DL_TRCH_REFTYPE_FACH_BF;
    }
    else
    {
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf &=
        ~L1_DL_TRCH_REFTYPE_FACH_BF;
    }
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf &=
      ~L1_DL_TRCH_REFTYPE_FACH_BF;

    if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status == RRCLLC_CTCH_WITH_PCCH)
    {
      /* both ctch and pcch are mapped on to same SCCPCH in this case we need to
      enable FACH */
      WRRC_MSG0_HIGH("ctch & pcch on same sccpch");
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf |=
        L1_DL_TRCH_REFTYPE_FACH_BF;
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
        L1_DL_TRCH_REFTYPE_FACH_BF;
    }
    if(rrcllc_semi_permanent_data.dl_phy_chan.pch_included)
    {
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
        L1_DL_TRCH_REFTYPE_PCH_BF;
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf |=
        L1_DL_TRCH_REFTYPE_PCH_BF;
    }
    else  /* No PCH on this SCCPCH */
    {
      WRRC_MSG0_ERROR("SCCPCH has no PCH included in Cell_PCH/URA_PCH");
      return(FAILURE);
    }

  /* This is a case for reconfiguration of SCCPCH since an SCCPCH
   * was already up for PCH in Connecting state.
   */

    if(ordered_config_ptr->reconfig_needed.downlink_l1)
    {

      if(!((rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
            && (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)))
      {
        MSG_LOW("LLC_PHYCHAN_RECONFIG on SCCPCH", 0, 0, 0);
        rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_action =
          LLC_PHYCHAN_RECONFIG;
      }
      else
      {
        MSG_LOW("LLC_PHYCHAN_SETUP on SCCPCH", 0, 0, 0);
      
        rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_action =
          LLC_PHYCHAN_SETUP;
      }
    
      if(!((rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
            && (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)))
       
      {
        /* Since we are reconfiguring a SCCPCH, a new CCTrCH ID needs to be allocated */
        /* If a valid CCTrCH ID exists for SCCPCH, add it to release list */
        if(rrcllc_semi_permanent_data.dl_phy_chan.sccpch.cctrch_id !=
           RRCLLC_INVALID_CCTRCH_ID)
        {
          RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                               dl_phy_chan.sccpch.cctrch_id);
        }
        /* Get a new CCTrCH ID */
        cctrch_id = rrcllc_get_cctrch_id();
      }
      else
      {
        /* Update SCCPCH CCTrCh from semi_permanent data */
        cctrch_id = rrcllc_semi_permanent_data.dl_phy_chan.sccpch.cctrch_id;
      }

      if(cctrch_id != RRCLLC_INVALID_CCTRCH_ID)
      {
        /* If PCH is present, update PCH info in Ordered Config with new CCTrCH ID */
        if(ordered_config_ptr->mac_dl_parms.num_pchs != 0)
        {
          ordered_config_ptr->mac_dl_parms.pch_info->cctrch_id = cctrch_id;
          if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status == RRCLLC_CTCH_WITH_PCCH)
          {
            /* Update FACH info in MAC Ordered Config */
            for(i = 0; i < config_ptr->mac_dl_parms.num_fachs; i ++)
            {
              config_ptr->mac_dl_parms.fach_info[i]->cctrch_id = cctrch_id;
            }
          }
        }
        else
        {
          WRRC_MSG0_ERROR("MAC dl parms num_pch=0");
        }
        /* Update SCCPCH Info in rrcllc_cmd_under_process */
        rrcllc_semi_permanent_data.dl_phy_chan.sccpch.cctrch_id =
          cctrch_id;
      }
      else
      {
        WRRC_MSG1_ERROR("Invalid CCTrCH ID %d assigned", cctrch_id);
        return(FAILURE);
      }

      if(!((rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
          && (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)))
      {
        if(rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.cctrch_id !=
           RRCLLC_INVALID_CCTRCH_ID)
        {
          RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                               dl_phy_chan.sccpch_with_ctch.cctrch_id);
          rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.cctrch_id = RRCLLC_INVALID_CCTRCH_ID;
          /* there was a separate SCCPCH with  CTCH before this reselection
          Now determine whether to delete this channel or not */
          if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status != RRCLLC_CTCH_ON_DIF_SCCPCH)
          {
            /* release the second sccpch for ctch */
            rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_for_ctch_action =
              LLC_PHYCHAN_RELEASE;
            rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_ref_type_bf = 0;
            rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_enable_bf = 0;
          }
          //  Need a reconfig (add & drop)
          else
          {
            rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_for_ctch_action =
              LLC_PHYCHAN_RECONFIG;
          }
        }
        else if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status == RRCLLC_CTCH_ON_DIF_SCCPCH)
        {
          /* CTCH wasn't on a different sccpch than pcch or CTCH was not there in the previous cell at all. */
          rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_for_ctch_action =
            LLC_PHYCHAN_SETUP;
        }
      }
      else
      {
        if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status == RRCLLC_CTCH_ON_DIF_SCCPCH)
        {
          /* CTCH wasn't on a different sccpch than pcch or CTCH was not there in the previous cell at all. */
          rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_for_ctch_action =
            LLC_PHYCHAN_SETUP;
        }
      }
       /* check whether CTCH needs to be setup and whether
      different sccpch should be used for this CTCH */
      if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status == RRCLLC_CTCH_ON_DIF_SCCPCH)
      {
        rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_ref_type_bf |=
          L1_DL_TRCH_REFTYPE_FACH_BF;
        rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_enable_bf |=
          L1_DL_TRCH_REFTYPE_FACH_BF;

        if(rrcllc_semi_permanent_data.dl_phy_chan.pch_included_for_sccpch_with_ctch)
        {
          rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_ref_type_bf |=
            L1_DL_TRCH_REFTYPE_PCH_BF;
          rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_enable_bf &=
            ~L1_DL_TRCH_REFTYPE_PCH_BF;
        }
        else  /* No PCH on this SCCPCH */
        {
          rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_ref_type_bf &=
            ~L1_DL_TRCH_REFTYPE_PCH_BF;
          rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_enable_bf &=
            ~L1_DL_TRCH_REFTYPE_PCH_BF;
        }

        if(!((rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
             && (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)))
        
        {
          /* Get a new CCTrCH ID */
          cctrch_id = rrcllc_get_cctrch_id();
        }
        else
        {
          /* Update SCCPCH CCTrCh from semi_permanent data */
          cctrch_id = rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.cctrch_id;
        }

        if(cctrch_id != RRCLLC_INVALID_CCTRCH_ID)
        {
          /* Update FACH info in MAC Ordered Config */
          for(i = 0; i < ordered_config_ptr->mac_dl_parms.num_fachs; i ++)
          {
            ordered_config_ptr->mac_dl_parms.fach_info[i]->cctrch_id = cctrch_id;
          }

          /* Update SCCPCH Info in rrcllc_cmd_under_process */
          rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.cctrch_id = cctrch_id;
        }
        else
        {
          WRRC_MSG1_ERROR("Invalid CCTrCH ID %d assigned", cctrch_id);
          return(FAILURE);
        }
      }
    }  /* Reconfig is needed for L1 */
    else
    {
      rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_action =
        LLC_PHYCHAN_NO_OP;
    }
  }

  return (SUCCESS);
} /* rrcllc_chan_config_within_pch */



/*===========================================================================
FUNCTION   rrcllc_chan_config_to_re_enter_within_connecting

DESCRIPTION
  This function is resposible for determining all actions on RLC, MAC
  and L1 when re-entering service area in connecting state.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static uecomdef_status_e_type
rrcllc_chan_config_to_re_enter_within_connecting(rrc_cmd_type *cmd_ptr)
{

  int     i;

  rlc_lc_id_type        rlc_dl_log_chl_id; /* RLC downlink logical channel ID */

  rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;

  WRRC_MSG2_HIGH("Chan_config_re_enter_in_connecting proc:rrc_proc_e_type_value%d, oc_status:rrcllc_oc_set_status_e_type_value%d",
           rrcllc_cmd_under_process.procedure,rrcllc_get_ordered_config_status_wo_f3());

  /* Update the variables in the ordered_config structure */
  if(rrcllc_update_oc_from_disconnected_to_connecting()
       == FAILURE)
  {
    WRRC_MSG0_ERROR("Failure updating OC, Discon->Connectng");
    return(FAILURE);
  }
  /* the above function copies URNTI only so copy CRNTI if the current camped
  cell is same as the one on which we detected oos */
#ifdef FEATURE_WCDMA_HS_FACH
  if(rrcllc_get_hs_status_in_e_fach(ordered_config_ptr) == TRUE)
  {
    rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id
    (
      UE_LOGCHAN_CCCH,
      CCCH_RADIO_BEARER_ID,
      UE_MODE_UNACKNOWLEDGED
    );
    if (rlc_dl_log_chl_id == RRCLCM_RLC_LC_ID_ERROR)
    {
      (void)rrcenhstate_process_add_ccch();
    }
    else
    {
      (void)rrcenhstate_process_reconfig_ccch();
    }
  }
  else
#endif
  {
    if(rrcllc_semi_permanent_data.dl_phy_chan.fach_included == FALSE)
    {
      /* This is a wrong selection of SCCPCH that does not have FACH */
      WRRC_MSG0_ERROR("SCCPCH has no FACH included DCH->FACH");
      return(FAILURE);
    }
    else
    {
      rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id
      (
        UE_LOGCHAN_CCCH,
        CCCH_RADIO_BEARER_ID,
        UE_MODE_UNACKNOWLEDGED
      );
      if (rlc_dl_log_chl_id == RRCLCM_RLC_LC_ID_ERROR)
      {
        (void)rrcllc_process_add_ccch();
      }
      else
      {
        (void)rrcllc_process_reconfig_ccch();
      }
    }
  }

  /* Indicate that both Downlink and Uplink MAC need to be reconfigured */
  //ordered_config_ptr->reconfig_needed.uplink_mac = TRUE;

  /* Initialize Send MAC Uplink Config indicator to TRUE */
  rrcllc_semi_permanent_data.send_mac_uplink_config = TRUE;

  /* Downlink Physical channel processing */
#ifdef FEATURE_WCDMA_HS_FACH
  if(rrcllc_get_hs_status_in_e_fach(ordered_config_ptr) == TRUE)
  {
    if(rrcenhstate_setup_phychan() == FAILURE)
    {
      ERR_FATAL("RRCENHST:Setting up HS PDSCH failed",0,0,0);
      return FAILURE;
    }
  }
  else
#endif /*FEATURE_WCDMA_HS_FACH*/
  {
    /* Fix the transport channel bitmasks for SCCPCH */
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
      L1_DL_TRCH_REFTYPE_FACH_BF;
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf |=
      L1_DL_TRCH_REFTYPE_FACH_BF;

    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf &=
      ~L1_DL_TRCH_REFTYPE_PCH_BF;

    if(rrcllc_semi_permanent_data.dl_phy_chan.pch_included)
    {
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
        L1_DL_TRCH_REFTYPE_PCH_BF;
    }
    else  /* No PCH on this SCCPCH */
    {
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf &=
        ~L1_DL_TRCH_REFTYPE_PCH_BF;
    }
    if(rrcllc_process_add_sccpch() == FAILURE)
    {
      WRRC_MSG0_ERROR ("Couldn't add SCCPCH");
      return FAILURE;
    }
  }

  /* Uplink Physical channel processing */

  /* This is a case for addition of PRACH */
  rrcllc_cmd_under_process.chan_config.phy_chan_action_list.prach_action =
    LLC_PHYCHAN_SETUP;

  MSG_LOW("LLC_PHYCHAN_SETUP on PRACH", 0, 0, 0);

  /* CHECK OUT THE RRC_CHANNEL_CONFIG_REQ command */
  for (i=0; i < cmd_ptr->cmd.chan_config_req.num_rb_to_config; i++)
  {
    /* Action allowed only on BCCH and CCCH. CCCH action in implicitely
     * done. Look for BCCH action here.
     */
    if((cmd_ptr->cmd.chan_config_req.rb[i].rb_id == BCCH_S_RADIO_BEARER_ID) &&
       (cmd_ptr->cmd.chan_config_req.rb[i].rb_config == RELEASE_RB))
    {
      /* Release BCCH RB now */
      /* Set number of BCHs in MAC correctly */
      if(ordered_config_ptr->mac_dl_parms.num_bchs)
      {
        ordered_config_ptr->mac_dl_parms.num_bchs --;
      }

      /* Update number of transport channels on PCCPCH in L1 CCTrCH Parameters */
      rrcllc_semi_permanent_data.dl_phy_chan.pccpch.num_trch = 0;

      /* Release the BCCH logical channel */
      if (rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up) 
      {
        (void)rrcllc_process_drop_bcch_serving();
      }
      else
      {
        WRRC_MSG0_ERROR("BCCH not present: no need for drop");
        return FAILURE;
      }

      rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action =
        LLC_PHYCHAN_RELEASE;
      rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_ref_type_bf = 0;
      rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_enable_bf = 0;
      /* Add the CCTrCH ID for PCCPCH to the CCTrCH IDs to be released list */
      RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                            dl_phy_chan.pccpch.cctrch_id);
    }
    else if((cmd_ptr->cmd.chan_config_req.rb[i].rb_id != CCCH_RADIO_BEARER_ID) &&
       (cmd_ptr->cmd.chan_config_req.rb[i].rb_config != NO_ACTION_ON_RB))
    {
      /* TBD: How to handle this invalid command ? Log an Error for now */
      MSG_MED("RB %d:Operation %d in RRC_CHANNEL_CONFIG_REQ re-entered in fach",
                cmd_ptr->cmd.chan_config_req.rb[i].rb_id,
                cmd_ptr->cmd.chan_config_req.rb[i].rb_config, 0);
    }
  } /* CHECK OUT THE RRC_CHANNEL_CONFIG_REQ command */

  return(SUCCESS);
} /* rrcllc_chan_config_to_re_enter_within_connecting */



/*===========================================================================
FUNCTION   rrcllc_chan_config_for_oos_within_connecting

DESCRIPTION
  This function is resposible for determining all actions on RLC, MAC
  and L1.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static uecomdef_status_e_type
rrcllc_chan_config_for_oos_within_connecting(rrc_cmd_type *cmd_ptr)
{
  WRRC_MSG2_HIGH("Chan_config_for_oos_within_connecting proc:rrc_proc_e_type_value%d, oc_status:rrcllc_oc_set_status_e_type_value%d",
           rrcllc_cmd_under_process.procedure,rrcllc_get_ordered_config_status_wo_f3());

  if(cmd_ptr->cmd.chan_config_req.procedure == RRC_PROCEDURE_CSP)
  {
    if((cmd_ptr->cmd.chan_config_req.release_trchls) &&
       (cmd_ptr->cmd.chan_config_req.release_phychls))
    {
    /* This is a special case for releasing only physical and
     * transport channels, keeping the logical channels as they are.
     */
      rrcllc_cmd_under_process.chan_config.current_cmd_engine =
        LLC_RELEASE_TR_PHY_CHAN_ENGINE;
      rrcllc_copy_cc_to_oc();

      /* Initailize MAC data to release all Transport Channels */
      rrcllc_init_ordered_config_mac_info(ORDERED_CONFIG);

      /* Indicate that both Downlink and Uplink MAC need to be reconfigured */
      ordered_config_ptr->reconfig_needed.downlink_mac = TRUE;
      ordered_config_ptr->reconfig_needed.uplink_mac = TRUE;

      /* Return from here as no other data in Channel Config Request
       * is relevant.
       */
      WRRC_MSG0_HIGH("Released Phy and Tr Chls");
    }
  } /* Normal, regular case */
  return(SUCCESS);
} /* rrcllc_chan_config_for_oos_within_connecting */


/*===========================================================================
FUNCTION   rrcllc_chan_config_within_connecting

DESCRIPTION
  This function is resposible for determining all actions on RLC, MAC
  and L1 in response to a Channel Config command in Connecting state.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static uecomdef_status_e_type
rrcllc_chan_config_within_connecting(rrc_cmd_type *cmd_ptr)
{
  int i;
  rrcllc_bch_op_e_type  bch_op = RRCLLC_NO_OP_BCH;
  rrcllc_nbch_op_e_type  nbch_op = RRCLLC_NO_OP_NBCH;
  ordered_config_type  *config_ptr = ordered_config_ptr;
  uint8     cctrch_id;
  rlc_lc_id_type rlc_dl_log_chl_id;

  if(rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)
  {
    if (rrcllc_cmd_under_process.chan_config.chan_config_reason ==
         RRCLLC_CHAN_CFG_REASON_RE_ENTERING_SERVICE)
    {
      return (rrcllc_chan_config_to_re_enter_within_connecting(cmd_ptr));
    }
    else  if (rrcllc_cmd_under_process.chan_config.chan_config_reason ==
         RRCLLC_CHAN_CFG_REASON_OUT_OF_SERVICE)
    {
      return rrcllc_chan_config_for_oos_within_connecting(cmd_ptr);
    }
  }
  if(rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CCM)
  {
    if (rrcllc_cmd_under_process.chan_config.chan_config_reason ==
         RRCLLC_CHAN_CFG_REASON_RE_ENTERING_SERVICE)
    {
      return (rrcllc_chan_config_to_re_enter_within_connecting(cmd_ptr));
    }
  }

  WRRC_MSG2_HIGH("Chan_config_within_connecting proc:rrc_proc_e_type_value%d, oc_status:rrcllc_oc_set_status_e_type_value%d",
           rrcllc_cmd_under_process.procedure,rrcllc_get_ordered_config_status_wo_f3());

  if((rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
      && (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RCE))
  {
    /* Re-setup the physical channels */
    /* Use Ordered Config here */
    config_ptr = ordered_config_ptr;

    rrcllc_cmd_under_process.chan_config.solo_bch_operation = FALSE;
    rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;
    rrcllc_copy_cc_to_oc();
    /* Set the Activation Time to "Now" */
    rrcllc_init_activation_time(config_ptr);

    /* Initialize Send MAC Uplink Config indicator to TRUE */
    rrcllc_semi_permanent_data.send_mac_uplink_config = TRUE;

    /* Downlink Physical channel processing */
#ifdef FEATURE_WCDMA_HS_FACH
    if(rrcllc_get_hs_status_in_e_fach(ordered_config_ptr) == TRUE)
    {    
      /*Clearing CCTrch-id before allocating new CCTrch-Id when W to G HO fails */
      if(ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.cctrch_id !=RRCLLC_INVALID_CCTRCH_ID)
      {
        RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.cctrch_id);
      }
      if(rrcenhstate_setup_phychan() == FAILURE)
      {
        return FAILURE;
      }
      else
      {
        WRRC_MSG0_HIGH("EFACH:Special case Redirection fail,resume set START to L1 & Reconfig to MAC");
        ordered_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_RECONFIG;
      }
#ifdef FEATURE_WCDMA_HS_RACH
      if(rrchsrach_get_common_edch_transmission(ordered_config_ptr))
      {
        ordered_config_ptr->l1_hs_rach_req_mask = L1_HS_RACH_START;
        rrcllc_set_hs_rach_action(ordered_config_ptr,MAC_HS_RACH_CONFIG);
      }
#endif
    }
    else
#endif
    {
      /* Fix the transport channel bitmasks for SCCPCH */
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
        L1_DL_TRCH_REFTYPE_FACH_BF;
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf |=
        L1_DL_TRCH_REFTYPE_FACH_BF;

      if(rrcllc_semi_permanent_data.dl_phy_chan.pch_included)
      {
        rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
          L1_DL_TRCH_REFTYPE_PCH_BF;
        rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf &=
          ~L1_DL_TRCH_REFTYPE_PCH_BF;
      }
      else  /* No PCH on this SCCPCH */
      {
        rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf &=
          ~L1_DL_TRCH_REFTYPE_PCH_BF;
        rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf &=
          ~L1_DL_TRCH_REFTYPE_PCH_BF;
      }

      WRRC_MSG0_HIGH("LLC_PHYCHAN_SETUP on SCCPCH");
 
      rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_action =
        LLC_PHYCHAN_SETUP;

      /* Update SCCPCH CCTrCh from semi_permanent data */
      cctrch_id = rrcllc_semi_permanent_data.dl_phy_chan.sccpch.cctrch_id;

      if(cctrch_id != RRCLLC_INVALID_CCTRCH_ID)
      {
        /* Update FACH info in MAC Ordered Config */
        for(i = 0; i < ordered_config_ptr->mac_dl_parms.num_fachs; i ++)
        {
          ordered_config_ptr->mac_dl_parms.fach_info[i]->cctrch_id = cctrch_id;
        }
        /* If PCH is present, update PCH info in Ordered Config with new CCTrCH ID */
        if(ordered_config_ptr->mac_dl_parms.num_pchs != 0)
        {
          ordered_config_ptr->mac_dl_parms.pch_info->cctrch_id = cctrch_id;
        }
      }
      else
      {
        WRRC_MSG1_ERROR("Invalid CCTrCH ID %d assigned", cctrch_id);
        return(FAILURE);
      }
    }
    /* This is a case for addition of PRACH */
    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.prach_action =
      LLC_PHYCHAN_SETUP;

    WRRC_MSG0_HIGH("LLC_PHYCHAN_SETUP on PRACH");

    return (SUCCESS);
  }
  else if ((rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_RECONFIG_PCH_FACH)
      && (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)) 
  {
    config_ptr = ordered_config_ptr;
    rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;

    rrcllc_copy_cc_to_oc();
    if (rrcllc_update_oc_from_disconnected_to_connecting() ==
        FAILURE)
    {
      WRRC_MSG0_ERROR("Failure updating OC with SIB; In connecting");
      return(FAILURE);
    }

#ifdef FEATURE_WCDMA_HS_FACH
    if(rrcllc_get_hs_status_in_e_fach(ordered_config_ptr) == TRUE)
    {
      (void)rrcenhstate_process_reconfig_ccch();
    }
    else
#endif /*FEATURE_WCDMA_HS_FACH*/
    {
        //fach included check this ...
      if(rrcllc_semi_permanent_data.dl_phy_chan.fach_included == FALSE)
      {
        /* This is a wrong selection of SCCPCH that does not have PCH */
        WRRC_MSG0_ERROR("SCCPCH has no FACH included in CONNECTING state");
        return(FAILURE);
      }

      /* Prepare a Reconfig CCCH command for RLC */
      (void)rrcllc_process_reconfig_ccch(); 
    }

    /* Force Reconfigurations of MAC and L1 in ALL cases so that all layers
     * remain on the same Ordered Config or Current Config pointer. Otherwise
     * selective reconfigurations of layers can put them "out of sync".
     */
    config_ptr->reconfig_needed.uplink_l1 = TRUE;
    config_ptr->reconfig_needed.downlink_l1 = TRUE;
    
    config_ptr->reconfig_needed.uplink_mac = TRUE;
    config_ptr->reconfig_needed.downlink_mac = TRUE;

#ifdef FEATURE_WCDMA_HS_FACH
    if(rrcllc_get_hs_status_in_e_fach(ordered_config_ptr) == TRUE)
    {
      if(rrcenhstate_reconfig_phychan(RRC_E_FACH_COMMON) == FAILURE)
      {
        ERR_FATAL("RRCENHST:Setting up HS PDSCH failed",0,0,0);
        return FAILURE;
      }
    }
    else
#endif /*FEATURE_WCDMA_HS_FACH*/
    {
      /* Fix the transport channel bitmasks for SCCPCH */
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
        L1_DL_TRCH_REFTYPE_FACH_BF;
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf |=
        L1_DL_TRCH_REFTYPE_FACH_BF;
    
      if(rrcllc_semi_permanent_data.dl_phy_chan.pch_included)
      {
        rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
          L1_DL_TRCH_REFTYPE_PCH_BF;
        rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf &=
          ~L1_DL_TRCH_REFTYPE_PCH_BF;
      }
      else  /* No PCH on this SCCPCH */
      {
        rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf &=
          ~L1_DL_TRCH_REFTYPE_PCH_BF;
        rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf &=
          ~L1_DL_TRCH_REFTYPE_PCH_BF;
      }
      if(rrcllc_process_reconfigure_sccpch() == FAILURE)
      {
          return FAILURE;
      }
    }

    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.prach_action =
      LLC_PHYCHAN_DROP_AND_ADD;
    
    WRRC_MSG0_HIGH("LLC_PHYCHAN_DROP_AND_ADD for PRACH");

    return SUCCESS;
  }

  for (i=0; i<cmd_ptr->cmd.chan_config_req.num_rb_to_config; i++)
  {
    if((cmd_ptr->cmd.chan_config_req.rb[i].rb_id == BCCH_S_RADIO_BEARER_ID) &&
        (cmd_ptr->cmd.chan_config_req.rb[i].rb_config == ESTABLISH_RB))
    {
      rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;
      bch_op = RRCLLC_ADD_BCH;
    }
    else if((cmd_ptr->cmd.chan_config_req.rb[i].rb_id == BCCH_S_RADIO_BEARER_ID) &&
        (cmd_ptr->cmd.chan_config_req.rb[i].rb_config == RELEASE_RB))
    {
      rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;
      bch_op = RRCLLC_DROP_BCH;
    }
    else if((cmd_ptr->cmd.chan_config_req.rb[i].rb_id == BCCH_N_RADIO_BEARER_ID) &&
            (cmd_ptr->cmd.chan_config_req.rb[i].rb_config == ESTABLISH_RB))
    {
      if((rrc_get_state() == RRC_STATE_CELL_DCH) ||
         (rrcllc_get_ordered_config_status_wo_f3() == OC_SET_FOR_CELL_DCH))
      {
        rrcllc_cmd_under_process.chan_config.chan_cfg_status =
          RRCLLC_CHAN_CFG_FAILURE_INCOMPATIBLE_STATE;
        WRRC_MSG0_ERROR("Neighbor BCCH setup oborted");
        return(FAILURE);
      }
      else if(rrc_csp_is_reselection_cleared())
      { 
        /* Return failure as DL wk indication was received for this cell and reselection data (freq/scr)
                     have been cleared*/
        rrcllc_cmd_under_process.chan_config.chan_cfg_status =
          RRCLLC_CHAN_CFG_FAILURE_CFG_CANCELLED;
        WRRC_MSG0_ERROR("Reselect info cleared. N-BCCH setup aborted.");
        return (FAILURE);
      }
      else
      {
        rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;
        nbch_op = RRCLLC_ADD_NBCH;
      }
    }
    else if((cmd_ptr->cmd.chan_config_req.rb[i].rb_id == BCCH_N_RADIO_BEARER_ID) &&
        (cmd_ptr->cmd.chan_config_req.rb[i].rb_config == RELEASE_RB))
    {
      rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;
      nbch_op = RRCLLC_DROP_NBCH;
    }
  } /* for(..) */

  /* UPDATE RLC AND MAC ORDERD CONFIG DATA STRUCTURES */
  /* Update the variables in the ordered_config structure */

  if((bch_op != RRCLLC_NO_OP_BCH) ||
     (nbch_op != RRCLLC_NO_OP_NBCH))
  {
    /* Since within Connecting, only a BCH operation is possible */
    config_ptr = current_config_ptr;
    rrcllc_cmd_under_process.chan_config.solo_bch_operation = TRUE;

    if (rrcllc_update_oc_for_serving_neighbor_bch_in_connected(config_ptr,
                                                               bch_op,
                                                               nbch_op)
          == FAILURE)
    {
      WRRC_MSG0_ERROR("Failure updating OC; In FACH");
      return(FAILURE);
    }
    if(bch_op == RRCLLC_ADD_BCH)
    {
      rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id
        (
          UE_LOGCHAN_BCCH,
          BCCH_S_RADIO_BEARER_ID,
          UE_MODE_TRANSPARENT
        );
      if (rlc_dl_log_chl_id == RRCLCM_RLC_LC_ID_NOT_FOUND) 
      {
        (void)rrcllc_process_add_bcch_serving(config_ptr);
      }
      else
      {
        (void)rrcllc_process_reconfig_bcch_serving(config_ptr);
      }
    }
    if(bch_op == RRCLLC_DROP_BCH)
    {
      if (rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up) 
      {
        (void)rrcllc_process_drop_bcch_serving();
      }
      else
      {
        if((nbch_op == RRCLLC_ADD_NBCH)&&
           (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_SIB))
        {
          WRRC_MSG0_ERROR("BCCH not present: Ignore drop since nbch_op action is add");
          bch_op = RRCLLC_NO_OP_BCH;
        }
        else
        {
          WRRC_MSG0_ERROR("BCCH not present: no need for drop, return failure");
          return FAILURE;
        }
      }
    }
    if(nbch_op == RRCLLC_ADD_NBCH)
    {
      rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id
        (
          UE_LOGCHAN_BCCH,
          BCCH_N_RADIO_BEARER_ID,
          UE_MODE_TRANSPARENT
        );
      if (rlc_dl_log_chl_id == RRCLCM_RLC_LC_ID_NOT_FOUND) 
      {
        (void)rrcllc_process_add_bcch_neighbor(config_ptr);
      }
      else
      {
        (void)rrcllc_process_reconfig_bcch_neighbor(config_ptr);
      }
    }
    if(nbch_op == RRCLLC_DROP_NBCH)
    {
      (void)rrcllc_process_drop_bcch_neighbor();
    }
  }

  if(bch_op == RRCLLC_ADD_BCH)
  {

      current_config_ptr->l1_dl_chan_parms.pccpch.tx_div_ind =
      rrcllc_get_pccpch_tx_diversity(RRC_STATE_CONNECTING);

    /* A BCCH has been added in DL => Setup PCCPCH */

    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action =
      LLC_PHYCHAN_SETUP;
    /* Update PCCPCH info in rrcllc_semi_permanent_data.dl_phy_chan */
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_ref_type_bf =
        L1_DL_TRCH_REFTYPE_SBCH_BF;
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_enable_bf =
        L1_DL_TRCH_REFTYPE_SBCH_BF;

    /* Get a new CCTrCH ID */
    cctrch_id = rrcllc_get_cctrch_id();

    /*The last two ckecks are added to resolve Array Out Of Bound issue fro KW*/
    if((cctrch_id != RRCLLC_INVALID_CCTRCH_ID) && 
      (config_ptr->mac_dl_parms.num_bchs <= MAC_DL_MAX_CCTRCH) && 
      (config_ptr->mac_dl_parms.num_bchs != 0))
    {
      /* Update BCH info in MAC Ordered Config */
      config_ptr->mac_dl_parms.
        bch_info[config_ptr->mac_dl_parms.num_bchs-1].cctrch_id =
      cctrch_id;

      /* Update PCCPCH Info in rrcllc_cmd_under_process */
      rrcllc_semi_permanent_data.dl_phy_chan.pccpch.cctrch_id = cctrch_id;

      MSG_LOW("LLC_PHYCHAN_SETUP for PCCPCH", 0, 0, 0);
    }
    else
    {
      WRRC_MSG1_ERROR("Invalid CCTrCH ID %d assigned", cctrch_id);
      return(FAILURE);
    }
  } /* If Serving BCCH add found */

  if(nbch_op == RRCLLC_ADD_NBCH)
  {
    /* Get PCCPCH channel parameters from Cell Selection into Ordered Config */
    rrccsp_get_neighbor_pccpch_parms(&rrcllc_cmd_under_process.rrcllc_cell_resel_info.scr_code,
                                     &rrcllc_cmd_under_process.rrcllc_cell_resel_info.freq);
    config_ptr->l1_dl_chan_parms.pccpch.scr_code =
      rrcllc_cmd_under_process.rrcllc_cell_resel_info.scr_code;

    /* If we have read SIB11, we should use the diversity info contained
       therein. */

      current_config_ptr->l1_dl_chan_parms.pccpch.tx_div_ind =
        FALSE;
      WRRC_MSG0_HIGH("Using N-PCCPCH TxDiv info from L1");


    /* A BCCH has been added in DL => Setup PCCPCH */

    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.n_pccpch_action =
      LLC_PHYCHAN_SETUP;
    /* Update PCCPCH info in config_ptr->rrcllc_semi_permanent_data.dl_phy_chan */
    rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch.trch_ref_type_bf =
        L1_DL_TRCH_REFTYPE_NBCH_BF;
    rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch.trch_enable_bf =
        L1_DL_TRCH_REFTYPE_NBCH_BF;

    /* Get a new CCTrCH ID */
    cctrch_id = rrcllc_get_cctrch_id();

    /*The last two ckecks are added to resolve Array Out Of Bound issue fro KW*/
    if((cctrch_id != RRCLLC_INVALID_CCTRCH_ID) && 
      (config_ptr->mac_dl_parms.num_bchs <= MAC_DL_MAX_CCTRCH) && 
      (config_ptr->mac_dl_parms.num_bchs != 0))
    {
      /* Update BCH info in MAC Ordered Config */
      config_ptr->mac_dl_parms.
        bch_info[config_ptr->mac_dl_parms.num_bchs - 1].cctrch_id =
      cctrch_id;

      /* Update PCCPCH Info in rrcllc_cmd_under_process */
      rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch.cctrch_id = cctrch_id;

      MSG_LOW("LLC_PHYCHAN_SETUP for PCCPCH", 0, 0, 0);
    }
    else
    {
      WRRC_MSG1_ERROR("Invalid CCTrCH ID %d assigned", cctrch_id);
      return(FAILURE);
    }
  } /* If Neighbor BCCH add found */

  if((bch_op == RRCLLC_DROP_BCH) &&
      (rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up))
  {
    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action =
      LLC_PHYCHAN_RELEASE;
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_ref_type_bf = 0;
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_enable_bf = 0;
    /* Add the CCTrCH ID for PCCPCH to the CCTrCH IDs to be released list */
    RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                          dl_phy_chan.pccpch.cctrch_id);
  } /* If Serving BCCH drop found */

  /* Neighbor BCH is a special case. The pipe may be incompletely setup.
   * in that case, do not do anything with L1.
   */

  if((nbch_op == RRCLLC_DROP_NBCH) &&
     (rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch_is_up))
  {
    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.n_pccpch_action =
      LLC_PHYCHAN_RELEASE;
    rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch.trch_ref_type_bf = 0;
    rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch.trch_enable_bf = 0;
    /* Add the CCTrCH ID for PCCPCH to the CCTrCH IDs to be released list */
    RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                          dl_phy_chan.n_pccpch.cctrch_id);
  } /* If Neighbor BCCH drop found */

  return(SUCCESS);

} /* rrcllc_chan_config_within_connecting */

/*===========================================================================
FUNCTION   rrcllc_chan_config_within_discon

DESCRIPTION
  This function is resposible for determining all actions on RLC, MAC
  and L1 in response to a Channel Config command in Disconnected state.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static uecomdef_status_e_type
rrcllc_chan_config_within_discon(rrc_cmd_type *cmd_ptr)
{
  int i;
  rrcllc_bch_op_e_type  bch_op = RRCLLC_NO_OP_BCH;
  rrcllc_nbch_op_e_type  nbch_op = RRCLLC_NO_OP_NBCH;
  rrcllc_pch_op_e_type  pch_op = RRCLLC_NO_OP_PCH;
  ordered_config_type  *config_ptr = ordered_config_ptr;
  uint8     cctrch_id = RRCLLC_INVALID_CCTRCH_ID;
  rlc_lc_id_type        rlc_dl_log_chl_id; /* RLC downlink logical channel ID */

  WRRC_MSG2_HIGH("Chan_config_within_discon proc:rrc_proc_e_type_value%d, oc_status:rrcllc_oc_set_status_e_type_value%d",
           rrcllc_cmd_under_process.procedure,rrcllc_get_ordered_config_status_wo_f3());

  if((rrcllc_cmd_under_process.procedure != RRC_PROCEDURE_CCM) &&
      (rrcllc_cmd_under_process.procedure != RRC_PROCEDURE_CSP) &&
        (rrcllc_cmd_under_process.procedure != RRC_PROCEDURE_SIB)
     )
  {
    WRRC_MSG1_ERROR("Unexp cmd from proc rrc_proc_e_type_value%d within discon",rrcllc_cmd_under_process.procedure);
    return(FAILURE);
  }

  if(rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)
  {

    if(cmd_ptr->cmd.chan_config_req.num_rb_to_config ==1)
    {/*Only one Rb and that to BCCH*/
      if(cmd_ptr->cmd.chan_config_req.rb[0].rb_id == BCCH_S_RADIO_BEARER_ID)
      {
        if(cmd_ptr->cmd.chan_config_req.rb[0].rb_config == RELEASE_RB)
        {
          if(rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up == FALSE)
          { /* Ignore as it is already dropped*/
            rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_BYPASS_ENGINE;
            rrcllc_cmd_under_process.chan_config.solo_bch_operation = TRUE;
            WRRC_MSG0_HIGH("S-BCCH is Absent, bypass the release of S-BCCH");
            return (SUCCESS);
          }
        }
      }
    }
  }
  if(!((rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
          && (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)))
  {
    for (i=0; i<cmd_ptr->cmd.chan_config_req.num_rb_to_config; i++)
    {
      if((cmd_ptr->cmd.chan_config_req.rb[i].rb_id == PCCH_RADIO_BEARER_ID) &&
              (cmd_ptr->cmd.chan_config_req.rb[i].rb_config == ESTABLISH_RB))
      {
        if(current_config_ptr->mac_dl_parms.num_pchs)
        {
          WRRC_MSG0_ERROR("PCCH add: PCH already present");
          return(FAILURE);
        }
        else
        {
          rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;
          pch_op = RRCLLC_ADD_PCH;
        }
      }
      else if((cmd_ptr->cmd.chan_config_req.rb[i].rb_id == PCCH_RADIO_BEARER_ID) &&
              (cmd_ptr->cmd.chan_config_req.rb[i].rb_config == RECONFIG_RB))
      {
        if(current_config_ptr->mac_dl_parms.num_pchs == 0)
        {
          WRRC_MSG0_ERROR("PCCH reconfig: PCH not present");
          return(FAILURE);
        }
        else
        {
          rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;
          pch_op = RRCLLC_RECONFIG_PCH;
          WRRC_MSG0_HIGH("Reconfig PCCH");
        }
      }
      else if((cmd_ptr->cmd.chan_config_req.rb[i].rb_id == BCCH_S_RADIO_BEARER_ID) &&
          (cmd_ptr->cmd.chan_config_req.rb[i].rb_config == ESTABLISH_RB))
      {
        rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;
        bch_op = RRCLLC_ADD_BCH;
      }
      else if((cmd_ptr->cmd.chan_config_req.rb[i].rb_id == BCCH_S_RADIO_BEARER_ID) &&
          (cmd_ptr->cmd.chan_config_req.rb[i].rb_config == RELEASE_RB))
      {
        rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;
        bch_op = RRCLLC_DROP_BCH;
      }
      else if((cmd_ptr->cmd.chan_config_req.rb[i].rb_id == BCCH_N_RADIO_BEARER_ID) &&
              (cmd_ptr->cmd.chan_config_req.rb[i].rb_config == ESTABLISH_RB))
      {
        
        if(rrc_csp_is_reselection_cleared())
        { 
          /* Return failure as DL wk indication was received for this cell and reselection data (freq/scr)
                       have been cleared*/
          rrcllc_cmd_under_process.chan_config.chan_cfg_status =
            RRCLLC_CHAN_CFG_FAILURE_CFG_CANCELLED;
          WRRC_MSG0_ERROR("Reselect info cleared. N-BCCH setup aborted.");
          return (FAILURE);
        }
        else
        {
          rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;
          nbch_op = RRCLLC_ADD_NBCH;
        }
      }
      else if((cmd_ptr->cmd.chan_config_req.rb[i].rb_id == BCCH_N_RADIO_BEARER_ID) &&
          (cmd_ptr->cmd.chan_config_req.rb[i].rb_config == RELEASE_RB))
      {
        rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;
        nbch_op = RRCLLC_DROP_NBCH;
      }
      else
      {
        WRRC_MSG0_ERROR("No action needed for RBs in chl cfg req");
        return FAILURE;
      }
    } /* for(..) */


    if((bch_op != RRCLLC_NO_OP_BCH) ||
       (nbch_op != RRCLLC_NO_OP_NBCH) ||
       (pch_op != RRCLLC_NO_OP_PCH))
    {
      if(pch_op == RRCLLC_NO_OP_PCH)
      {
        /* Indicate this is a solo BCH operation */
        rrcllc_cmd_under_process.chan_config.solo_bch_operation = TRUE;
        config_ptr = current_config_ptr;
      }
      else
      {
        rrcllc_copy_cc_to_oc();
        config_ptr = ordered_config_ptr;
      }
      /* UPDATE RLC AND MAC ORDERD CONFIG DATA STRUCTURES */

      /* Update the variables in the ordered_config structure */
      if (rrcllc_update_oc_in_disconnected(config_ptr, bch_op, nbch_op, pch_op)
            == FAILURE)
      {
        WRRC_MSG0_ERROR("Failure updating OC; In Disconnected");
        return(FAILURE);
      }

      if(bch_op == RRCLLC_ADD_BCH)
      {
        rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id
          (
            UE_LOGCHAN_BCCH,
            BCCH_S_RADIO_BEARER_ID,
            UE_MODE_TRANSPARENT
          );
        if (rlc_dl_log_chl_id == RRCLCM_RLC_LC_ID_NOT_FOUND) 
        {
          (void)rrcllc_process_add_bcch_serving(config_ptr);
        }
        else
        {
          (void)rrcllc_process_reconfig_bcch_serving(config_ptr);
        }
      }
      if(bch_op == RRCLLC_DROP_BCH)
      {

        if (rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up) 
        {
          (void)rrcllc_process_drop_bcch_serving();
        }
        else
        {
          if((nbch_op == RRCLLC_ADD_NBCH)&&
            (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_SIB))
          {
            WRRC_MSG0_ERROR("BCCH not present: Ignore drop since nbch_op action is add");
            bch_op = RRCLLC_NO_OP_BCH;
          }
          else
          {
            WRRC_MSG0_ERROR("BCCH not present: no need for drop, return failure");
            return FAILURE;
          }
        }
      }
      if(nbch_op == RRCLLC_ADD_NBCH)
      {

        rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id
        (
          UE_LOGCHAN_BCCH,
          BCCH_N_RADIO_BEARER_ID,
          UE_MODE_TRANSPARENT
        );
        if (rlc_dl_log_chl_id == RRCLCM_RLC_LC_ID_NOT_FOUND) 
        {
          (void)rrcllc_process_add_bcch_neighbor(config_ptr);
        }
        else
        {
          (void)rrcllc_process_reconfig_bcch_neighbor(config_ptr);
        }
      }

      if(nbch_op == RRCLLC_DROP_NBCH)
      {
        (void)rrcllc_process_drop_bcch_neighbor();
      }

      if((pch_op == RRCLLC_ADD_PCH) || (pch_op == RRCLLC_RECONFIG_PCH))
      {
        if(rrcllc_semi_permanent_data.dl_phy_chan.pch_included == FALSE)
        {
          /* This is a wrong selection of SCCPCH that does not have PCH */
          WRRC_MSG0_ERROR("SCCPCH has no PCH included in DISCONNECTED state");
          return(FAILURE);
        }
        if(pch_op == RRCLLC_ADD_PCH)
        {
          /* Prepare an Add PCCH command for RLC */
          (void)rrcllc_process_add_pcch();

        }
        else
        {
          /* Prepare a Reconfig PCCH command for RLC */
          (void)rrcllc_process_reconfig_pcch();
        }

        rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id
        (
          UE_LOGCHAN_CTCH,
          CTCH_RADIO_BEARER_ID,
          UE_MODE_UNACKNOWLEDGED
        );
        if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status != RRCLLC_NO_CTCH)
        {
          /* Add PCCH if it was not present before( in case of pch->fach channel
          config failure,  else reconfig*/
          if (rlc_dl_log_chl_id == RRCLCM_RLC_LC_ID_NOT_FOUND)
          {
            (void)rrcllc_process_add_ctch();
          }
          else
          {
            (void)rrcllc_process_reconfig_ctch();
          }
        }
        else if (rlc_dl_log_chl_id != RRCLCM_RLC_LC_ID_NOT_FOUND)
        {
          (void)rrcllc_process_drop_ctch();
        }
      } /* If there is an Add or Reconfig on PCH */

    } /* If PCH is to be added or reconfigured OR If BCH is to be added or dropped */
  } /* If NOT Procedure CSP and ch cfg reason is not RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP */
  else
  {
    /* Use Ordered Config here */
    config_ptr = ordered_config_ptr;

    rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_CHAN_CONFIG_ENGINE;
    rrcllc_copy_cc_to_oc();
    /* Set the Activation Time to "Now" */
    rrcllc_init_activation_time(config_ptr);
  }

  /* Downlink Physical channel processing */
  if((pch_op == RRCLLC_ADD_PCH) || (pch_op == RRCLLC_RECONFIG_PCH) ||
       ((rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
          && (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP))
    )
  {
    /* If a PCCH is to be added, this is also a case for adding SCCPCH. If
     * PCCH is to be reconfigured and SCCPCH is not up, SCCPCH has to be added
     */
    if((pch_op == RRCLLC_ADD_PCH) || 
         ((rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
          && (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP))
      )
    {
      rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_action =
        LLC_PHYCHAN_SETUP;
      MSG_LOW("LLC_PHYCHAN_SETUP for SCCPCH", 0, 0, 0);
    }
    else if(pch_op == RRCLLC_RECONFIG_PCH)
    {
      /* This is a case when PCCH is to be reconfigured and SCCPCH is already up.
       * Reconfigure SCCPCH also.
       */
      rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_action =
        LLC_PHYCHAN_RECONFIG;
      MSG_LOW("LLC_PHYCHAN_RECONFIG for SCCPCH", 0, 0, 0);
      /* If SCCPCH is already up, add the old CCTrCH ID to the release list */
      RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                             dl_phy_chan.sccpch.cctrch_id);
    }

    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf =
      L1_DL_TRCH_REFTYPE_PCH_BF;
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf =
      L1_DL_TRCH_REFTYPE_PCH_BF;

    /* Now determine if OC has picked an SCCPCH that also carries FACH  */
    if(rrcllc_semi_permanent_data.dl_phy_chan.fach_included)
    {
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
        L1_DL_TRCH_REFTYPE_FACH_BF;
    }
    if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status == RRCLLC_CTCH_WITH_PCCH)
    {
      /* both ctch and pcch are mapped on to same SCCPCH in this case we need to
      enable FACH */
      WRRC_MSG0_HIGH("ctch & pcch on same sccpch");
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf |=
        L1_DL_TRCH_REFTYPE_FACH_BF;
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
        L1_DL_TRCH_REFTYPE_FACH_BF;
    }

    if(!((rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
          && (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)))
    {
    /* Get a new CCTrCH ID */
      cctrch_id = rrcllc_get_cctrch_id();
    }
    else
    {
      /* Use the old CCTrCH ID that we copied from current config */
      cctrch_id = config_ptr->mac_dl_parms.pch_info->cctrch_id;
    }

    if(cctrch_id != RRCLLC_INVALID_CCTRCH_ID)
    {
      /* Update PCH info in MAC Ordered Config */
      config_ptr->mac_dl_parms.pch_info->cctrch_id = cctrch_id;

      if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status == RRCLLC_CTCH_WITH_PCCH)
      {
        /* Update FACH info in MAC Ordered Config */
        for(i = 0; i < config_ptr->mac_dl_parms.num_fachs; i ++)
        {
          config_ptr->mac_dl_parms.fach_info[i]->cctrch_id = cctrch_id;
        }
      }

      /* Update SCCPCH Info in rrcllc_cmd_under_process */
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.cctrch_id = cctrch_id;
    }
    else
    {
      WRRC_MSG1_ERROR("Invalid CCTrCH ID %d assigned", cctrch_id);
      return(FAILURE);
    }

    if(!((rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
         && (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)))
    {
  
      if(rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.cctrch_id !=
         RRCLLC_INVALID_CCTRCH_ID)
      {
        RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                             dl_phy_chan.sccpch_with_ctch.cctrch_id);

        rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.cctrch_id = RRCLLC_INVALID_CCTRCH_ID;
        /* there was a separate SCCPCH with  CTCH before this reselection  
        Now determine whether to delete this channel or not */
        if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status != RRCLLC_CTCH_ON_DIF_SCCPCH)
        {
          /* release the second sccpch for ctch */
          rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_for_ctch_action =
            LLC_PHYCHAN_RELEASE;
          rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_ref_type_bf = 0;
          rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_enable_bf = 0;
        }
        //  Need a reconfig (add & drop)
        else
        {
          rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_for_ctch_action =
            LLC_PHYCHAN_RECONFIG;
        }
      }
      else if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status == RRCLLC_CTCH_ON_DIF_SCCPCH)
      {
        /* CTCH wasn't on a different sccpch than pcch or CTCH was not there in the previous cell at all. */
        rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_for_ctch_action =
          LLC_PHYCHAN_SETUP;
      }
    }
    else
    {
      if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status == RRCLLC_CTCH_ON_DIF_SCCPCH)
      {
        /* CTCH wasn't on a different sccpch than pcch or CTCH was not there in the previous cell at all. */
        rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_for_ctch_action =
          LLC_PHYCHAN_SETUP;
        WRRC_MSG0_HIGH("LLC_PHYCHAN_SETUP for SCCPCH2");
      }
    }
     /* check whether CTCH needs to be setup and whether
    different sccpch should be used for this CTCH */
    if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status == RRCLLC_CTCH_ON_DIF_SCCPCH)
    {
      //rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_for_ctch_action =
      //  LLC_PHYCHAN_SETUP;

      rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_ref_type_bf |=
        L1_DL_TRCH_REFTYPE_FACH_BF;
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_enable_bf |=
        L1_DL_TRCH_REFTYPE_FACH_BF;

      if(rrcllc_semi_permanent_data.dl_phy_chan.pch_included_for_sccpch_with_ctch)
      {
        rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_ref_type_bf |=
          L1_DL_TRCH_REFTYPE_PCH_BF;
        rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_enable_bf &=
          ~L1_DL_TRCH_REFTYPE_PCH_BF;
      }
      else  /* No PCH on this SCCPCH */
      {
        rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_ref_type_bf &=
          ~L1_DL_TRCH_REFTYPE_PCH_BF;
        rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_enable_bf &=
          ~L1_DL_TRCH_REFTYPE_PCH_BF;
      }

      if(!((rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
              && (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)))
      {
        /* Get a new CCTrCH ID */
        cctrch_id = rrcllc_get_cctrch_id();
      }
      else
      {
        /* Use the old CCTrCH ID that we copied from current config */
        cctrch_id = rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.cctrch_id;
      }

      if(cctrch_id != RRCLLC_INVALID_CCTRCH_ID)
      {
        /* Update FACH info in MAC Ordered Config */
        for(i = 0; i < ordered_config_ptr->mac_dl_parms.num_fachs; i ++)
        {
          ordered_config_ptr->mac_dl_parms.fach_info[i]->cctrch_id = cctrch_id;
        }

        /* Update SCCPCH Info in rrcllc_cmd_under_process */
        rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.cctrch_id = cctrch_id;
      }
      else
      {
        WRRC_MSG1_ERROR("Invalid CCTrCH ID %d assigned", cctrch_id);
        return(FAILURE);
      }
    }
  } /* if (add_pcch_found) */


  if((bch_op == RRCLLC_ADD_BCH)||
     (((rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
       && (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)) &&
      (rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up))
     )
  {
    
    current_config_ptr->l1_dl_chan_parms.pccpch.tx_div_ind =
      rrcllc_get_pccpch_tx_diversity(RRC_STATE_DISCONNECTED);

    /* A BCCH has been added in DL => Setup PCCPCH */
    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action =
      LLC_PHYCHAN_SETUP;
    /* Update PCCPCH info in rrcllc_semi_permanent_data.dl_phy_chan */
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_ref_type_bf =
        L1_DL_TRCH_REFTYPE_SBCH_BF;
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_enable_bf =
        L1_DL_TRCH_REFTYPE_SBCH_BF;

    if(!((rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
          && (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)))
    {
      /* Get a new CCTrCH ID */
      cctrch_id = rrcllc_get_cctrch_id();
    }
    else
    {
      if((config_ptr->mac_dl_parms.num_bchs <= MAC_DL_MAX_CCTRCH) &&
        (config_ptr->mac_dl_parms.num_bchs != 0))
      {
        /* Use the old CCTrCH ID that we copied from current config */
        cctrch_id = config_ptr->mac_dl_parms.
          bch_info[config_ptr->mac_dl_parms.num_bchs-1].cctrch_id;
      }
    }

    if((cctrch_id != RRCLLC_INVALID_CCTRCH_ID) &&
      (config_ptr->mac_dl_parms.num_bchs <= MAC_DL_MAX_CCTRCH) &&
      (config_ptr->mac_dl_parms.num_bchs != 0))
    {
      /* Update BCH info in MAC Ordered Config */
      config_ptr->mac_dl_parms.
        bch_info[config_ptr->mac_dl_parms.num_bchs-1].cctrch_id =
      cctrch_id;

      /* Update PCCPCH Info in rrcllc_cmd_under_process */
      rrcllc_semi_permanent_data.dl_phy_chan.pccpch.cctrch_id = cctrch_id;

      MSG_LOW("LLC_PHYCHAN_SETUP for PCCPCH", 0, 0, 0);
    }
    else
    {
      WRRC_MSG1_ERROR("Invalid CCTrCH ID %d assigned", cctrch_id);
      return(FAILURE);
    }
  } /* If Serving BCCH add found */

  if(nbch_op == RRCLLC_ADD_NBCH)
  {
    /* Get PCCPCH channel parameters from Cell Selection into Ordered Config */
    rrccsp_get_neighbor_pccpch_parms(&rrcllc_cmd_under_process.rrcllc_cell_resel_info.scr_code,
                                     &rrcllc_cmd_under_process.rrcllc_cell_resel_info.freq);
    config_ptr->l1_dl_chan_parms.pccpch.scr_code =
      rrcllc_cmd_under_process.rrcllc_cell_resel_info.scr_code;

    /* If we have read SIB11, we should use the diversity info contained
       therein. */

      current_config_ptr->l1_dl_chan_parms.pccpch.tx_div_ind =
        FALSE;

      WRRC_MSG0_HIGH("Using N-PCCPCH TxDiv info from L1");


    /* A BCCH has been added in DL => Setup PCCPCH */

    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.n_pccpch_action =
      LLC_PHYCHAN_SETUP;
    /* Update PCCPCH info in config_ptr->rrcllc_semi_permanent_data.dl_phy_chan */
    rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch.trch_ref_type_bf =
        L1_DL_TRCH_REFTYPE_NBCH_BF;
    rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch.trch_enable_bf =
        L1_DL_TRCH_REFTYPE_NBCH_BF;

    if(!((rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
          && (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)))
    {
      /* Get a new CCTrCH ID */
      cctrch_id = rrcllc_get_cctrch_id();
    }
    else
    {
      if((config_ptr->mac_dl_parms.num_bchs <= MAC_DL_MAX_CCTRCH) &&
        (config_ptr->mac_dl_parms.num_bchs != 0))
      {    
        /* Use the old CCTrCH ID that we copied from current config */
        cctrch_id = config_ptr->mac_dl_parms.
          bch_info[config_ptr->mac_dl_parms.num_bchs - 1].cctrch_id;
      }
    }

    if((cctrch_id != RRCLLC_INVALID_CCTRCH_ID) &&
      (config_ptr->mac_dl_parms.num_bchs <= MAC_DL_MAX_CCTRCH) &&
      (config_ptr->mac_dl_parms.num_bchs != 0))
    {
      /* Update BCH info in MAC Ordered Config */
      config_ptr->mac_dl_parms.
        bch_info[config_ptr->mac_dl_parms.num_bchs - 1].cctrch_id =
      cctrch_id;

      /* Update PCCPCH Info in rrcllc_cmd_under_process */
      rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch.cctrch_id = cctrch_id;

      MSG_LOW("LLC_PHYCHAN_SETUP for PCCPCH", 0, 0, 0);
    }
    else
    {
      WRRC_MSG1_ERROR("Invalid CCTrCH ID %d assigned", cctrch_id);
      return(FAILURE);
    }
  } /* If Neighbor BCCH add found */


  if((bch_op == RRCLLC_DROP_BCH) &&
     (rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up))
  {
    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action =
      LLC_PHYCHAN_RELEASE;
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_ref_type_bf = 0;
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch.trch_enable_bf = 0;
    /* Add the CCTrCH ID for PCCPCH to the CCTrCH IDs to be released list */
    RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                          dl_phy_chan.pccpch.cctrch_id);
  } /* If Serving BCCH drop found */

  /* Neighbor BCH is a special case. The pipe may be incompletely setup.
   * in that case, do not do anything with L1.
   */

  if((nbch_op == RRCLLC_DROP_NBCH) &&
     (rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch_is_up))
  {
    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.n_pccpch_action =
      LLC_PHYCHAN_RELEASE;
    rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch.trch_ref_type_bf = 0;
    rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch.trch_enable_bf = 0;
    /* Add the CCTrCH ID for PCCPCH to the CCTrCH IDs to be released list */
    RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                          dl_phy_chan.n_pccpch.cctrch_id);
  } /* If Neighbor BCCH drop found */

  return(SUCCESS);
} /* rrcllc_chan_config_within_discon */


/*====================================================================
FUNCTION: rrcllc_update_cmd_process_data_for_channel_config()

DESCRIPTION:
  This function updates all data items in rrcllc_cmd_under_process that
  are relevant to the processing of only RRC_CHANNEL_CONFIG_REQ.

DEPENDENCIES:
  None
RETURN VALUE:
  None
SIDE EFFECTS:
  None.
====================================================================*/
static uecomdef_status_e_type
rrcllc_update_cmd_process_data_for_channel_config(rrc_cmd_type *cmd_ptr)
{
  rrc_state_e_type  current_rrc_state;

  /* Store some crucial data */
  rrcllc_cmd_under_process.chan_config.cnf_needed =
    cmd_ptr->cmd.chan_config_req.rrc_channel_config_cnf_required;

  rrcllc_cmd_under_process.chan_config.chan_config_reason =
    cmd_ptr->cmd.chan_config_req.chan_config_reason;

  /* First, determine all logical channels that need to be established,
   * released or reconfigured.
   */
  /* Start with implicit channel release/establishment (based on RRC state changes) */
  current_rrc_state = rrc_get_state();

  /* Check if an RRC state transition is involved in processing this command */
  if((rrcllc_cmd_under_process.next_rrc_state != current_rrc_state) &&
     (cmd_ptr->cmd.chan_config_req.rrc_state_change_required == TRUE))
  {
    /* Go over all possible state changes */
    if((current_rrc_state == RRC_STATE_DISCONNECTED) &&
       (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CONNECTING))
    {
      /* IDLE_DISCONNECTED --> IDLE_CONNECTING */
      if(rrcllc_chan_config_discon_to_connecting(cmd_ptr) == FAILURE)
      {
        return(FAILURE);
      }
    }
    else if((current_rrc_state == RRC_STATE_DISCONNECTED) &&
            (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_DCH))
    {
      /* IDLE_DISCONNECTED --> CELL_DCH */
      if(rrcllc_chan_config_discon_to_dch(cmd_ptr) == FAILURE)
      {
        return(FAILURE);
      }
    }
    else if((current_rrc_state == RRC_STATE_CONNECTING) &&
            (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_DCH))
    {
      /* IDLE_CONNECTING --> CELL_DCH */
      if(rrcllc_chan_config_connecting_to_dch(cmd_ptr) == FAILURE)
      {
        return(FAILURE);
      }
    }
    else if((current_rrc_state == RRC_STATE_CELL_FACH) &&
            (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_DCH))
    {
      /* CELL_FACH --> CELL_DCH */
      if(rrcllc_chan_config_fach_to_dch(cmd_ptr) == FAILURE)
      {
        return(FAILURE);
      }
    }
    else if((current_rrc_state == RRC_STATE_CONNECTING) &&
            (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_FACH))
    {
      /* IDLE_CONNECTING --> CELL_FACH */
      if(rrcllc_chan_config_connecting_to_fach(cmd_ptr) == FAILURE)
      {
        return(FAILURE);
      }
    }
    else if((current_rrc_state == RRC_STATE_CELL_DCH) &&
            (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_FACH))
    {
      /* Cell_DCH --> Cell_FACH */
      if(rrcllc_chan_config_dch_to_fach(cmd_ptr) == FAILURE)
      {
        return(FAILURE);
      }
    }

    else if((current_rrc_state == RRC_STATE_CELL_DCH) &&
            ((rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_PCH) ||
             (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_URA_PCH)))
    {
      /* Cell_DCH --> Cell_PCH */
      if(rrcllc_chan_config_dch_to_pch(cmd_ptr) == FAILURE)
      {
        return(FAILURE);
      }
    }
    else if((current_rrc_state == RRC_STATE_CELL_FACH) &&
            ((rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_PCH) ||
             (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_URA_PCH)))
    {
      /* Cell_FACH --> Cell_PCH */
      if(rrcllc_chan_config_fach_to_pch(cmd_ptr) == FAILURE)
      {
        return(FAILURE);
      }
    }
    else if((current_rrc_state == RRC_STATE_CELL_DCH) &&
            (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_DISCONNECTED))
    {
      /* Cell_DCH --> DISCONNECTED */
      if(rrcllc_chan_config_dch_to_discon(cmd_ptr) == FAILURE)
      {
        return(FAILURE);
      }
    }
    else if ((current_rrc_state == RRC_STATE_CELL_FACH) &&
            (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_DISCONNECTED))
    {
     /* Cell_FACH --> DISCONNECTED */
      if(rrcllc_chan_config_fach_to_discon(cmd_ptr) == FAILURE)
      {
        return(FAILURE);
      }
    }
    else if(((current_rrc_state == RRC_STATE_CELL_PCH) ||
             (current_rrc_state == RRC_STATE_URA_PCH)) &&
            (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_FACH))
    {
      /* Cell_PCH --> Cell_FACH */
      if(rrcllc_chan_config_pch_to_fach(cmd_ptr) == FAILURE)
      {
        return(FAILURE);
      }
    }
    else if (((current_rrc_state == RRC_STATE_CELL_PCH) ||
         (current_rrc_state == RRC_STATE_URA_PCH)) &&
            (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_DISCONNECTED))
    {
     /* Cell_FACH --> DISCONNECTED */
      if(rrcllc_chan_config_fach_to_discon(cmd_ptr) == FAILURE)
      {
        return(FAILURE);
      }
    }
    else if((current_rrc_state == RRC_STATE_CONNECTING) &&
            (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_DISCONNECTED))
    {
      /* Connecting --> DISCONNECTED */
      if(rrcllc_chan_config_connecting_to_discon(cmd_ptr) == FAILURE)
      {
        return(FAILURE);
      }
    }
    else if(((current_rrc_state == RRC_STATE_CELL_PCH) ||
         (current_rrc_state == RRC_STATE_URA_PCH)) &&
            (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_DCH))
    {
      /* Cell_PCH/URA_PCH --> Cell_DCH */
      /* Send a Failure to the sender */
      WRRC_MSG0_ERROR("Cell_PCH/URA_PCH --> Cell_DCH not possible, send failuer");

      return(FAILURE);
    }
  } /* If there is a change of RRC state */
  else if((rrcllc_cmd_under_process.next_rrc_state == current_rrc_state) &&
          (cmd_ptr->cmd.chan_config_req.rrc_state_change_required == TRUE) &&
          (current_rrc_state == RRC_STATE_DISCONNECTED))
  {
    /* Treat Discon->Discon only when LLC is not the initiating procedure. This
     * is to avoid any out-of-sync issues between procedures.
     */
    if(rrcllc_cmd_under_process.procedure != RRC_PROCEDURE_LLC)
    {
      rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_RELEASE_ALL_CHAN_ENGINE;
      /* All RLC channels need to be dropped through a single command */
    }
    else
    {
      WRRC_MSG0_ERROR("Discon->Discon from LLC is ignored");
      return(FAILURE);
    }
  }
  else  /* No RRC state change asked for */
  {
    if(current_rrc_state == RRC_STATE_CELL_DCH)
    {
      if(rrcllc_chan_config_within_dch(cmd_ptr) == FAILURE)
      {
        return(FAILURE);
      }
    }
    else if(current_rrc_state == RRC_STATE_CELL_FACH)
    {
      if((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CU) &&
         (cmd_ptr->cmd.chan_config_req.chan_config_reason == RRCLLC_CHAN_CFG_REASON_RL_FAILURE))
      {
        if(rrcllc_chan_config_within_fach_for_rl_failure(cmd_ptr) == FAILURE)
        {
          return(FAILURE);
        }
      }
      else if(rrcllc_chan_config_within_fach(cmd_ptr) == FAILURE)
      {
        return(FAILURE);
      }
    }
    else if((current_rrc_state == RRC_STATE_CELL_PCH)||
            (current_rrc_state == RRC_STATE_URA_PCH))
    {
      if(rrcllc_chan_config_within_pch(cmd_ptr) == FAILURE)
      {
        return(FAILURE);
      }
    }
    else if(current_rrc_state == RRC_STATE_DISCONNECTED)
    {
      if(rrcllc_chan_config_within_discon(cmd_ptr) == FAILURE)
      {
        return(FAILURE);
      }
    } /* If state is IDLE_DISCONNECTED */

    else if(current_rrc_state == RRC_STATE_CONNECTING)
    {
      if(rrcllc_chan_config_within_connecting(cmd_ptr) == FAILURE)
      {
        return(FAILURE);
      }
    } /* If state is RRC_STATE_CONNECTING */
  }  /* No RRC state change */

  /* No need to store any L1 cmds for "Release all channels" case. */
  /* If any one of these command engines are active, do not send a
   * CPHY_SETUP_REQ.
   */
  if((rrcllc_cmd_under_process.chan_config.current_cmd_engine ==
      LLC_RELEASE_ALL_CHAN_ENGINE) ||
      (rrcllc_cmd_under_process.chan_config.current_cmd_engine ==
      LLC_DEACT_ENGINE) ||
      (rrcllc_cmd_under_process.chan_config.current_cmd_engine ==
      LLC_STOP_WCDMA_MODE_ENGINE) ||
     (rrcllc_cmd_under_process.chan_config.current_cmd_engine ==
      LLC_RELEASE_TR_PHY_CHAN_ENGINE)
     ||(rrcllc_cmd_under_process.chan_config.current_cmd_engine ==
      LLC_BYPASS_ENGINE)
    )
  {
    return(SUCCESS);
  }
  /* if it is channel config within pch and the procedure is not sib or csp
  then do not build L1 command as we do not configure l1 */
  else if(
          (
           ((rrc_get_state() == RRC_STATE_CELL_PCH)||
            (rrc_get_state() == RRC_STATE_URA_PCH)
           ) &&
           (
            (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_PCH) ||
            (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_URA_PCH)
           )
          ) &&
          (
           (rrcllc_cmd_under_process.procedure != RRC_PROCEDURE_SIB) &&
           (rrcllc_cmd_under_process.procedure != RRC_PROCEDURE_CCM) &&
           (rrcllc_cmd_under_process.procedure != RRC_PROCEDURE_CSP) 
          )
        )
  {
    return(SUCCESS);
  }
  else
  {
    if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
    {
      /* This is the point to form L1 commands and store them in rrcllc_cmd_under_process */
      if (rrcllc_construct_and_store_l1_cmds() == FAILURE)
        return FAILURE;
      else
        return SUCCESS;
    }
    else
    {
      (void)rrcllc_construct_and_store_l1_cmds();
      return(SUCCESS);
    }
  }
} /* rrcllc_update_cmd_process_data_for_channel_config */



/*===========================================================================
FUNCTION   rrcllc_stop_wcdma_mode_engine

DESCRIPTION
 This function is responsible for sending commands to lower layer while
 processing an RRC_STOP_LOWER_LAYER_REQ message that results in
 deactivating lower layers.

 The current LLC state as passed to the function helps to decide the next command.
 The returned value is the next LLC state. If LLC_IDLE is returned, it signals
 the end of processing lower layer commands for RRC_STOP_LOWER_LAYER_REQ. Before
 going to LLC_IDLE, the LLC is initialized with a call to rrcllc_init() with
 RRCLLC_RE_INIT as the initialization type.

 The following sequence of lower layer commands is followed:
 CPHY_STOP_WCDMA_MODE_REQ
 MAC_DL_CONFIG_REQ
 MAC_UL_CONFIG_REQ
 CRLC_RELEASE_ALL_REQ

DEPENDENCIES
  None.

RETURN VALUE
  Next LLC state.

SIDE EFFECTS
  None.
===========================================================================*/
static uecomdef_status_e_type
rrcllc_stop_wcdma_mode_engine
(
  rrcllc_substate_e_type current_substate,
  rrcllc_substate_e_type *next_substate
)
{
  if(rrcllc_cmd_under_process.rrc_current_cmd_id != RRC_STOP_LOWER_LAYER_REQ)
  {
    WRRC_MSG0_ERROR("Expected RRC_STOP_LOWER_LAYER_REQ");
    return(FAILURE);
  }
#ifdef FEATURE_UMTS_1X_HANDOVER_UMTSMSM
  #error code not present
#endif
  switch(current_substate)
  {
    case LLC_IDLE:
      {
        /* Send a CPHY_STOP_WCDMA_MODE_REQ */
        rrcllc_cphy_stop_wcdma_mode_req();
        *next_substate = LLC_WAIT_CPHY_STOP_WCDMA_MODE_CNF;
      }
      break;

    case LLC_WAIT_CPHY_STOP_WCDMA_MODE_CNF:
      {
        /* Since L1 has been sent to Idle, it is safe to initialize
         * MAC config data now.
         */
        if((current_config_ptr != NULL) && (ordered_config_ptr != NULL))
        {
          if(config_ptr_in_use == CURRENT_CONFIG)
          {
            /* Copy CC to OC ONLY IF Current Config is being used at present */
            rrcllc_copy_cc_to_oc();
          }

          /* Initailize MAC data to release all Transport Channels */
          rrcllc_init_ordered_config_mac_info(ORDERED_CONFIG);

          rrcllc_set_hs_mac_l1_info_inactive();

          /* Send MAC DL Config request */
          rrcllc_cmac_dl_config_req(NO_SYNC_WITH_L1);
          rrcllc_set_mac_eul_action_to_stop_if_eul_is_active(FALSE);
#ifdef FEATURE_WCDMA_DC_HSUPA
          rrcllc_set_mac_sec_eul_action_to_stop_if_eul_is_active(FALSE);
#endif /* FEATURE_WCDMA_DC_HSUPA */
#ifdef FEATURE_WCDMA_HS_RACH
          rrchsrach_set_hsrach_action_to_stop_if_active(FALSE);
#endif

          rrcllc_set_cpc_dtx_action_to_stop_if_cpc_dtx_active(FALSE);

#ifdef FEATURE_HSPA_CALL_STATUS_IND
          rrc_send_hspa_call_status_info();
#endif /* FEATURE_HSPA_CALL_STATUS_IND*/
          /* Send MAC UL Config request */
          rrcllc_cmac_ul_config_req(RECONFIG_MAC, NO_SYNC_WITH_L1);
        }
        else
        {
          WRRC_MSG2_ERROR("OC %d CC %d NULL ",current_config_ptr,ordered_config_ptr);
        }
        rrcllc_crlc_release_all_req();
        *next_substate = LLC_WAIT_RLC_REL_ALL_CNF;
      }

      break;

    case LLC_WAIT_RLC_REL_ALL_CNF:
      {
        /* Logical channel information will be released inside the STATE_CHANGE_IND
         * handler
         */
#ifdef FEATURE_UMTS_PDCP
        /* Send CPDCP_CONFIG_REQ to release all PDCP entities. */
        rrcllc_cpdcp_release_all_req();
#endif /* FEATURE_UMTS_PDCP*/

        *next_substate = LLC_IDLE;
      }
      break;

#ifdef FEATURE_UMTS_1X_HANDOVER_UMTSMSM
     #error code not present
#endif

    default:
      WRRC_MSG1_ERROR("Cmd engine called in LLC state %d", current_substate);
      return(FAILURE);

  } /* switch(current_substate) */

  return(SUCCESS);
}   /* rrcllc_stop_wcdma_mode_engine */



/*===========================================================================
FUNCTION   rrcllc_release_all_chan_engine

DESCRIPTION
 This function is responsible for sending commands to lower layer while processing
 an RRC_CHANNEL_CONFIG_REQ message that results in releasing all channels.

 The current LLC state as passed to the function helps to decide the next command.
 The returned value is the next LLC state. If LLC_IDLE is returned, it signals
 the end of processing lower layer commands for RRC_CHANNEL_CONFIG_REQ. Before
 going to LLC_IDLE, the LLC is initialized with a call to rrcllc_init() with
 RRCLLC_RE_INIT as the initialization type.

 The following sequence of lower layer commands is followed:
 CRLC_RELEASE_ALL_REQ
 MAC_DL_CONFIG_REQ
 MAC_UL_CONFIG_REQ
 CPHY_IDLE_REQ

DEPENDENCIES
  None.

RETURN VALUE
  Next LLC state.

SIDE EFFECTS
  None.
===========================================================================*/
static uecomdef_status_e_type
rrcllc_release_all_chan_engine(rrcllc_substate_e_type current_substate,
                               rrcllc_substate_e_type *next_substate)
{
#ifdef FEATURE_WRLF_SYSTEM_SEL
  rrcmcm_state_e_type  mcm_substate = rrcmcm_get_substate();
#endif
  if((rrcllc_cmd_under_process.rrc_current_cmd_id != RRC_CHANNEL_CONFIG_REQ) ||
     (rrcllc_cmd_under_process.valid == FALSE))
  {
    WRRC_MSG0_ERROR("RRCLLC command under process: Not Channel Config Req");
    return(FAILURE);
  }
  switch(current_substate)
  {
    case LLC_IDLE:
#ifdef FEATURE_WRLF_SYSTEM_SEL
      /* During conn mode OOS, do not send IDLE_REQ to L1 
          * If re-establishmen timer expires or HARD ABORT is recvd from NAS when
             - RRC is in INACTIVE state.
             - L1 is just stopped for STOP_WCDMA_MODE_REQ and MCM is waiting for L1 STOP_CNF
          If re-establishment timer expires when RRC just received service_req and sent START_WCDMA_REQ to L1,
             send IDLE_REQ to L1. 
             - If MCM is wating for START_CONFIRM from L1 and if Lock is not with wcdma, block idle req as L1 will ignore idle_req
               L1 will ignore IDLE_REQ when W mode is inactive which and LLC will be stuck waiting for IDLE_CNF
     */
#ifdef FEATURE_DUAL_SIM    
      if((RRC_IS_CONN_MODE_OOS_SRCH_IN_PROGRESS() &&
         (rrcllc_cmd_under_process.rrc_current_cmd_id == RRC_CHANNEL_CONFIG_REQ) &&
         (((RRC_MODE_INACTIVE == rrcmcm_get_rrc_mode()) && (mcm_substate != RRCMCM_WAIT_START_CNF))
       || (mcm_substate == RRCMCM_WAIT_STOP_CNF) || ((mcm_substate == RRCMCM_WAIT_START_CNF) && (!WRM_STATE_IS_IN_LOCK(WCDMA_TRM))))))
      {
        WRRC_MSG1_HIGH("Block IDLE_REQ, mcm_substate %d",mcm_substate);
      }
      else      
#else
   if(!(RRC_IS_CONN_MODE_OOS_SRCH_IN_PROGRESS() &&
   (rrcllc_cmd_under_process.rrc_current_cmd_id == RRC_CHANNEL_CONFIG_REQ) &&
   (((RRC_MODE_INACTIVE == rrcmcm_get_rrc_mode()) && (mcm_substate != RRCMCM_WAIT_START_CNF))
	 || (mcm_substate == RRCMCM_WAIT_STOP_CNF))) )

#endif
#endif
      {
        /* This is the starting point - go in the order below */
        /* Send a CPHY_IDLE_REQ */

      rrcllc_cphy_idle_req();
      *next_substate = LLC_WAIT_CPHY_IDLE_CNF;
      break;
      }

    case LLC_WAIT_CPHY_IDLE_CNF:  /*lint !e616 */
      {
        /* Since L1 has been sent to Idle, it is safe to initialize
         * MAC config data now.
         */
        if(config_ptr_in_use == CURRENT_CONFIG)
        {
          /* Copy CC to OC ONLY IF Current Config is being used at present */
          rrcllc_copy_cc_to_oc();
        }

        /* Initailize MAC data to release all Transport Channels */
        rrcllc_init_ordered_config_mac_info(ORDERED_CONFIG);

        if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
        {
          rrcllc_set_hs_mac_l1_info_inactive();

          rrc_set_hrnti_status(ordered_config_ptr,HRNTI_INVALID);
          rrc_set_hrnti_status(current_config_ptr,HRNTI_INVALID);
          rrc_set_hrnti_status(transition_config.toc_ptr,HRNTI_INVALID);

#ifdef FEATURE_WCDMA_HS_FACH
          ordered_config_ptr->efach_hrnti_status = INVALID_HRNTI;
          current_config_ptr->efach_hrnti_status = INVALID_HRNTI;
          transition_config.toc_ptr->efach_hrnti_status = INVALID_HRNTI;
#endif

          ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc = RRCLLC_INVALID_CPICH_SCR_CODE;
          current_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc = RRCLLC_INVALID_CPICH_SCR_CODE;
          transition_config.toc_ptr->l1_hsdpa_info.hs_pdsch_rl_psc = RRCLLC_INVALID_CPICH_SCR_CODE;

#ifdef FEATURE_WCDMA_MIMO
          rrcllc_init_mimo_params(ordered_config_ptr);
          rrcllc_init_mimo_params(current_config_ptr);
           
#endif/* FEATURE_WCDMA_MIMO*/

#ifdef FEATURE_WCDMA_DC_HSDPA
          /*As a safe-guard, we are initing DC-HS in OC/CC though it would
          have been inited in Config Ptr in use by now which might suffice.*/
          rrcllc_init_sec_hsdpa_params(ordered_config_ptr);
          rrcllc_init_sec_hsdpa_params(current_config_ptr);
#endif /*FEATURE_WCDMA_DC_HSDPA*/
            
        }

        /* Send MAC DL Config request */
        rrcllc_cmac_dl_config_req(NO_SYNC_WITH_L1);
        rrcllc_set_mac_eul_action_to_stop_if_eul_is_active(TRUE);
#ifdef FEATURE_WCDMA_DC_HSUPA
        rrcllc_set_mac_sec_eul_action_to_stop_if_eul_is_active(TRUE);
#endif /* FEATURE_WCDMA_DC_HSUPA */
#ifdef FEATURE_WCDMA_HS_RACH
        rrchsrach_set_hsrach_action_to_stop_if_active(TRUE);
#endif


        rrcllc_set_cpc_dtx_action_to_stop_if_cpc_dtx_active(TRUE);

#ifdef FEATURE_HSPA_CALL_STATUS_IND
        rrc_send_hspa_call_status_info();
#endif /* FEATURE_HSPA_CALL_STATUS_IND*/
        /* Send MAC UL Config request */
        rrcllc_cmac_ul_config_req(RECONFIG_MAC, NO_SYNC_WITH_L1);
        rrcllc_crlc_release_all_req();
        *next_substate = LLC_WAIT_RLC_REL_ALL_CNF;
      }
      break;

    case LLC_WAIT_RLC_REL_ALL_CNF:
      {
#ifdef FEATURE_UMTS_PDCP
        /* Send CPDCP_CONFIG_REQ to release all PDCP entities. */
        rrcllc_cpdcp_release_all_req();

#endif /* FEATURE_UMTS_PDCP*/
        /* Call an LCM function here to release all logical channel
         * IDs and the watermark queues associated with them.
         */
        *next_substate = LLC_IDLE;
      }
      break;

    default:
      WRRC_MSG1_ERROR("Cmd engine called in LLC state %d", current_substate);
      return(FAILURE);
  } /* switch(current_substate) */

  return(SUCCESS);
}   /* rrcllc_release_all_chan_engine */


/*===========================================================================
FUNCTION   rrcllc_release_tr_phy_chan_engine

DESCRIPTION
 This function is responsible for sending commands to lower layer while processing
 an RRC_CHANNEL_CONFIG_REQ message that results in releasing Physical and
 Transport channels, keeping the logical channels intact.

 The following sequence of lower layer commands is followed:
 MAC_DL_CONFIG_REQ
 MAC_UL_CONFIG_REQ
 CPHY_IDLE_REQ

DEPENDENCIES
  None.

RETURN VALUE
  Next LLC state.

SIDE EFFECTS
  None.
===========================================================================*/
static uecomdef_status_e_type
rrcllc_release_tr_phy_chan_engine(rrcllc_substate_e_type current_substate,
                                  rrcllc_substate_e_type *next_substate)
{


  uint8   dl_cctrch_id;
  rrc_proc_e_type                 proc_id;
  rrcllc_oc_process_state_e_type  process_state;  
  rrcllc_oc_set_status_e_type     oc_status;
#ifdef FEATURE_RRC_DELAY_DCH_FACH
  rlc_lc_id_type ul_lc_id = RRCLCM_RLC_LC_ID_NOT_FOUND;
#endif
  if((rrcllc_cmd_under_process.rrc_current_cmd_id != RRC_CHANNEL_CONFIG_REQ) ||
     (rrcllc_cmd_under_process.valid == FALSE))
  {
    WRRC_MSG0_ERROR("RRCLLC command under process: Not Channel Config Req");
    return(FAILURE);
  }
  switch(current_substate)
  {
    case LLC_IDLE:
    {
      /* In DCH->FACH case, need to send fake CPHY_SETUP_REQ to L1 with activation time.
         This is because CPHY_IDLE_REQ doesn't handle act time.  If activation time is 
        not present, RRC can immediatly send CPHY_IDLE_REQ.
      */

      oc_status = rrcllc_get_ordered_config_state_and_proc_wo_f3(&proc_id, &process_state);

      if ((OC_SET_FOR_DCH_FACH_TRANS == oc_status) &&
          ((transition_config.toc_ptr->activation_time != RRCLLC_ACTIVATION_TIME_NOW) &&
           (transition_config.toc_ptr->act_time_type == L1_ACTIVATION_TIME_CFN)) && 
          ((proc_id == RRC_PROCEDURE_RBE) ||
           (proc_id == RRC_PROCEDURE_RBR) ||
           (proc_id == RRC_PROCEDURE_RBRC) ||
           (proc_id == RRC_PROCEDURE_TCR) ||
           (proc_id == RRC_PROCEDURE_PCR)) &&
          (rrccsp_get_curr_scan() == RRC_CSP_CELL_DCH_TO_CELL_FACH_SCAN))
      {
        /*Give L1 fake reconfig with same config, and new cctrch id*/
        rrcllc_copy_cc_to_oc();
        ordered_config_ptr->dest_freq_present = FALSE;
        rrcllc_cmd_under_process.chan_config.phy_chan_action_list.dl_dpch_action =
          LLC_PHYCHAN_RECONFIG;
        rrcllc_cmd_under_process.chan_config.phy_chan_action_list.ul_dpch_action =
          LLC_PHYCHAN_RECONFIG;
        
        /* Copy the activation time from TOC */
        ordered_config_ptr->activation_time = transition_config.toc_ptr->activation_time;
        ordered_config_ptr->act_time_type   = transition_config.toc_ptr->act_time_type;
        ordered_config_ptr->sdu_time = transition_config.toc_ptr->sdu_time;

      /* If a valid CCTrCH ID exists for DL DPCH, add it to release list */
        if(rrcllc_semi_permanent_data.dl_phy_chan.dl_dpch.cctrch_id !=
           RRCLLC_INVALID_CCTRCH_ID)
        {
          RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.dl_phy_chan.
                                               dl_dpch.cctrch_id);
        }

        /* Get a new CCTrCH ID */
        dl_cctrch_id = rrcllc_get_cctrch_id();
        
        if (RRCLLC_INVALID_CCTRCH_ID != dl_cctrch_id) 
        {
          rrcllc_semi_permanent_data.dl_phy_chan.dl_dpch.cctrch_id =
            dl_cctrch_id;
          
          /* construct l1 commands */
          (void)rrcllc_construct_and_store_l1_cmds();
          
          if(rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req)
          {
            rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.req_mask = 0;
            WRRC_MSG0_MED("RRC_DEBUG:Resetting the cphy setup req mask ");
            rrcllc_cphy_setup_req(&rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0]);
            *next_substate = LLC_WAIT_CPHY_SETUP_CNF;
            break;
          }
        }
        else
        {
          WRRC_MSG1_ERROR("Invalid CCTrCH ID %d assigned", dl_cctrch_id);
        }
      }
    }
    case LLC_WAIT_CPHY_SETUP_CNF: /*lint !e616  Fall thru from above */
    {
      /* Send a CPHY_IDLE_REQ */
      if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
      {
        if (rrc_get_hsdpa_status() != HSDPA_INACTIVE)
        {
          WRRC_MSG0_HIGH("RRCHS:Send CPHY_IDLE_REQ. HSDPA to stop");
        }
      }
#ifdef FEATURE_RRC_DELAY_DCH_FACH
        ul_lc_id = rrclcm_check_ul_rlc_lc_id ( UE_LOGCHAN_DCCH,
                                               DCCH_AM_RADIO_BEARER_ID,
                                               UE_MODE_ACKNOWLEDGED_DATA);
        /* Call L2 API to stop retransmitting control Pdus. For DCH-FACH transition L2 sends retransmits control 
           Pdu thrice to increase the probability that n/w RLC gets L2 ack for DCH-FACH reconfiguration */ 
        if (ul_lc_id != RRCLCM_RLC_LC_ID_NOT_FOUND)
        {
          (void)rlc_rrc_set_status_pdu_tx_cnt(ul_lc_id, 0);
        }
#endif
      rrcllc_cphy_idle_req();
      *next_substate = LLC_WAIT_CPHY_IDLE_CNF;
    }
    break;

    case LLC_WAIT_CPHY_IDLE_CNF:
    {

      if ((OC_SET_FOR_DCH_FACH_TRANS == rrcllc_get_ordered_config_status_wo_f3()) &&
          ((transition_config.toc_ptr->activation_time != RRCLLC_ACTIVATION_TIME_NOW) &&
           (transition_config.toc_ptr->act_time_type == L1_ACTIVATION_TIME_CFN)))  
      {
        /* Initailize MAC data to release all Transport Channels */
        rrcllc_init_ordered_config_mac_info(ORDERED_CONFIG);

        rrcllc_restore_urnti_to_oc_from_toc();
        /* Indicate that both Downlink and Uplink MAC need to be reconfigured */
        ordered_config_ptr->reconfig_needed.downlink_mac = TRUE;
        ordered_config_ptr->reconfig_needed.uplink_mac = TRUE;
      }
      
      if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
      {
        /* Preventive Check SET HSDPA Action in MAC to NOOP */
        current_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_NOOP;
        ordered_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_NOOP;
        

          rrcllc_set_hs_mac_l1_info_inactive();

        /* Invalidate HRNTI & PSC */
          
        rrc_set_hrnti_status(ordered_config_ptr,HRNTI_INVALID);
        rrc_set_hrnti_status(current_config_ptr,HRNTI_INVALID);
        rrc_set_hrnti_status(transition_config.toc_ptr,HRNTI_INVALID);

        if((transition_config.toc_usage == TOC_FOR_DCH_AND_FACH) || 
             (transition_config.toc_usage == TOC_FOR_DCH))
        {
          ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator =
                transition_config.toc_ptr->mac_dl_parms.mac_hs_reset_indicator;
          WRRC_MSG1_HIGH("RRCHS: MAC HS reset Ind in TOC %d",transition_config.toc_ptr->mac_dl_parms.mac_hs_reset_indicator);
          transition_config.toc_ptr->mac_dl_parms.mac_hs_reset_indicator = FALSE;
        }   
        ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc = RRCLLC_INVALID_CPICH_SCR_CODE;
        current_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc = RRCLLC_INVALID_CPICH_SCR_CODE;
        transition_config.toc_ptr->l1_hsdpa_info.hs_pdsch_rl_psc = RRCLLC_INVALID_CPICH_SCR_CODE;
          
#ifdef FEATURE_WCDMA_MIMO
        rrcllc_init_mimo_params(ordered_config_ptr);
        rrcllc_init_mimo_params(current_config_ptr);
           
#endif/* FEATURE_WCDMA_MIMO*/
          
#ifdef FEATURE_WCDMA_DC_HSDPA
          /*As a safe-guard, we are initing DC-HS in OC/CC though it would
            have been inited in Config Ptr in use by now which might suffice.*/
          rrcllc_init_sec_hsdpa_params(ordered_config_ptr);
          rrcllc_init_sec_hsdpa_params(current_config_ptr);
          rrcllc_init_sec_hsdpa_params(transition_config.toc_ptr);
#endif /*FEATURE_WCDMA_DC_HSDPA*/


      }
        /* Send MAC DL Config request */
      rrcllc_cmac_dl_config_req(NO_SYNC_WITH_L1);
      if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
      {
        /* Preventive Check SET HSDPA Action in MAC to NOOP */
        current_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_NOOP;
        ordered_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_NOOP;
        WRRC_MSG0_MED("RRCHS:Resetting MAC action in OC and CC");
      }
      
      rrcllc_set_mac_eul_action_to_stop_if_eul_is_active(TRUE);
#ifdef FEATURE_WCDMA_DC_HSUPA
      rrcllc_set_mac_sec_eul_action_to_stop_if_eul_is_active(TRUE);
#endif /* FEATURE_WCDMA_DC_HSUPA */
#ifdef FEATURE_WCDMA_HS_RACH
      /*No need to reset here. We will call this function again at channel_config_cnf*/
      /*Stop mac along with idle_req*/
      rrchsrach_set_hsrach_action_to_stop_if_active(TRUE);
#endif


      rrcllc_set_cpc_dtx_action_to_stop_if_cpc_dtx_active(TRUE);

#ifdef FEATURE_HSPA_CALL_STATUS_IND
      rrc_send_hspa_call_status_info();
#endif /* FEATURE_HSPA_CALL_STATUS_IND*/

      /* Send MAC UL Config request */
      rrcllc_cmac_ul_config_req(RECONFIG_MAC, NO_SYNC_WITH_L1);
      *next_substate = LLC_IDLE;
    }
    break;
    
    default:
      WRRC_MSG1_ERROR("Cmd engine called in LLC state %d", current_substate);
      return(FAILURE);
  } /* switch(current_substate) */

  return(SUCCESS);
}   /* rrcllc_release_tr_phy_chan_engine */

/*===========================================================================
FUNCTION   rrcllc_deactivation_engine

DESCRIPTION
 This function is responsible for sending commands to lower layer while
 processing an RRC_LOWER_LAYER_DEACT_REQ message that results in
 deactivating lower layers.

 The current LLC state as passed to the function helps to decide the next command.
 The returned value is the next LLC state. If LLC_IDLE is returned, it signals
 the end of processing lower layer commands for RRC_LOWER_LAYER_DEACT_REQ. Before
 going to LLC_IDLE, the LLC is initialized with a call to rrcllc_init() with
 RRCLLC_RE_INIT as the initialization type.

 The following sequence of lower layer commands is followed:
 CPHY_DEACTIVATE_REQ
 MAC_DL_CONFIG_REQ
 MAC_UL_CONFIG_REQ
 CRLC_RELEASE_ALL_REQ

DEPENDENCIES
  None.

RETURN VALUE
  Next LLC state.

SIDE EFFECTS
  None.
===========================================================================*/
static uecomdef_status_e_type
rrcllc_deactivation_engine
(
  rrcllc_substate_e_type current_substate,
  rrcllc_substate_e_type *next_substate
)
{
  if(rrcllc_cmd_under_process.rrc_current_cmd_id != RRC_LOWER_LAYER_DEACT_REQ)
  {
    WRRC_MSG0_ERROR("Expected RRC_LOWER_LAYER_DEACT_REQ");
    return(FAILURE);
  }
  switch(current_substate)
  {
    case LLC_IDLE:
      {
        /* Send a CPHY_DEACTIVATE_REQ */
        rrcllc_cphy_deactivate_req();
        *next_substate = LLC_WAIT_CPHY_DEACTIVATE_CNF;
      }
      break;

    case LLC_WAIT_CPHY_DEACTIVATE_CNF:
      {
        if((current_config_ptr != NULL) && (ordered_config_ptr != NULL))
        {
          rrcllc_set_hs_mac_l1_info_inactive();

          /* Send MAC DL Config request */
          rrcllc_cmac_dl_config_req(NO_SYNC_WITH_L1);
          rrcllc_set_mac_eul_action_to_stop_if_eul_is_active(FALSE);
#ifdef FEATURE_WCDMA_DC_HSUPA
          rrcllc_set_mac_sec_eul_action_to_stop_if_eul_is_active(FALSE);
#endif /* FEATURE_WCDMA_DC_HSUPA */
#ifdef FEATURE_WCDMA_HS_RACH
          rrchsrach_set_hsrach_action_to_stop_if_active(FALSE);
#endif


          rrcllc_set_cpc_dtx_action_to_stop_if_cpc_dtx_active(FALSE);

#ifdef FEATURE_HSPA_CALL_STATUS_IND
          rrc_send_hspa_call_status_info();
#endif /* FEATURE_HSPA_CALL_STATUS_IND*/

          /* Send MAC UL Config request */
          rrcllc_cmac_ul_config_req(RECONFIG_MAC, NO_SYNC_WITH_L1);          
        }
        else
        {
          WRRC_MSG2_ERROR("OC %d CC %d NULL ",current_config_ptr,ordered_config_ptr);
        }
        /* Release all logical channels in RLC */
        rrcllc_crlc_release_all_req();
        *next_substate = LLC_WAIT_RLC_REL_ALL_CNF;
      }
      break;

    case LLC_WAIT_RLC_REL_ALL_CNF:
      {
#ifdef FEATURE_UMTS_PDCP
        /* Send CPDCP_CONFIG_REQ to release all PDCP entities. */
        rrcllc_cpdcp_release_all_req();
#endif /* FEATURE_UMTS_PDCP*/
        /* Call an LCM function here to release all logical channel
         * IDs and the watermark queues associated with them.
         */
        rrclcm_clear_rlc_lc_info();
        *next_substate = LLC_IDLE;
      }
      break;

    default:
      WRRC_MSG1_ERROR("Cmd engine called in LLC state %d", current_substate);
      return(FAILURE);
  } /* switch(current_substate) */

  return(SUCCESS);
}   /* rrcllc_deactivation_engine */

/*===========================================================================
FUNCTION   rrcllc_chan_config_engine

DESCRIPTION
 This function is responsible for sending commands to lower layer while processing
 an RRC_CHANNEL_CONFIG_REQ message. Since the lower layer commands and their number
 is dependent on the contents of RRC_CHANNEL_CONFIG_REQ, this function looks into
 rrcllc_cmd_under_process to get to the next lower layer command.
 The current LLC state as passed to the function helps to decide the next command.
 The returned value is the next LLC state. If LLC_IDLE is sent, it signals the end
 of processing lower layer commands for RRC_CHANNEL_CONFIG_REQ.
 In general, the following sequence of commands is followed:
 RLC_DL_TM_CONFIG_REQ
 RLC_UL_TM_CONFIG_REQ
 RLC_DL_UM_CONFIG_REQ
 RLC_UL_UM_CONFIG_REQ
 RLC_AM_CONFIG_REQ
 MAC_DL_CONFIG_REQ
 MAC_UL_CONFIG_REQ
 CPHY_SETUP_REQs


DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static uecomdef_status_e_type
rrcllc_chan_config_engine(rrcllc_substate_e_type current_substate,
                                    rrcllc_substate_e_type *next_substate)
{

  int   count;
  int   i;
  
  rrcllc_mac_ul_operation_e_type   mac_op;
  rrcllc_mac_sync_with_l1_e_type   sync_needed_with_l1;
  boolean mac_dl_req_sent=FALSE;
#if defined(FEATURE_WCDMA_DC_HSUPA) || defined (FEATURE_WCDMA_16_QAM)
  boolean sync_needed_btwn_l1_mac_for_asu = FALSE;
#endif
#ifdef FEATURE_WCDMA_HS_RACH
  static int32 pccpch_drop_index = -1;
  boolean delay_bch_drop_for_hsrach_to_dch = FALSE;
    
  /*Optimization to speed up transition from FACH to DCH state by delaying the PCCPCH drop
    Will come into effect when
    1.Optimization is valid for HSRACH to DCH state transition only
    2.Legacy behavior will be followed for all HHO cases(No Change) 
      and if N-BCH is up at the time of Reconfiguration(as L1 may crash )
    3.The Drop will occur post FACH to DCH transition, only when the serving cell
      matches the first entry in the RL list( captured by rrcllc_cmd_under_process.chan_config.new_freq)
    4.In case of a CPHY SETUP FAILURE, L1 will drop PCCPCH when RRC will send the subsequent CPHY_IDLE
   
    Note: PHY CHAN ESTABLISHMENT indication will not fail for the direct HSRACH to DCH transition’ 
    i.e when the optimization kicks in
  */

  if(rrc_get_state() == RRC_STATE_CELL_FACH &&
     rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_DCH &&
     rrchsrach_get_common_edch_transmission(current_config_ptr) == TRUE &&
     rrcllc_cmd_under_process.chan_config.new_freq == FALSE)
    delay_bch_drop_for_hsrach_to_dch = TRUE;

#endif

  if((rrcllc_cmd_under_process.rrc_current_cmd_id != RRC_CHANNEL_CONFIG_REQ) ||
    (rrcllc_cmd_under_process.valid == FALSE))
  {
    WRRC_MSG0_ERROR("RRCLLC command under process: Not Channel Config Req");
    return(FAILURE);
  }
  /*Skip channel config engine for dch to fach tranistion excpet if there is pccpch drop*/
  if(rrcllc_check_dch_fach_reconfig_status()
        && (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_FACH)
        && (rrc_get_state() == RRC_STATE_CELL_DCH)
        && (rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req == 0))
  {
    WRRC_MSG0_HIGH("dch_fach: Not configuring lower layers for dch to fach transition");
    return SUCCESS;
  }

  if((RRC_DCH_FACH_TRANISITION_SKIP_CHANNEL_SETUP == rrcllc_dch_fach_check_channel_setup_skip_status()) && (LLC_IDLE == current_substate))
  {
    WRRC_MSG0_HIGH("dch_fach: ignore lower layer configuration for dch to fach transition");
    /*Skip configuring MAC and WL1 as common mode will be configured later from CU. set the substate as LLC_WAIT_CPHY_CHANNEL_IND so that 
       RLC alone gets configured*/
    /* substate has to be set to LLC_WAIT_CPHY_CHANNEL_IND to send DL TM request */
    current_substate = LLC_WAIT_CPHY_CHANNEL_IND;
  }
  if ((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CU) &&
    (rrcllc_cmd_under_process.chan_config.chan_config_reason ==
    RRCLLC_CHAN_CFG_REASON_RLC_CONFIG_ONLY))
  {
    /* no need to configure mac and l1 in this case */
    *next_substate = LLC_WAIT_CPHY_CHANNEL_IND;
  }
  switch(current_substate)
  {
  case LLC_IDLE:
    /* Send MAC DL Config request only if needed */
    /* When reconfiguring within DCH, reconfigure DL MAC only when the
    * reconfig_needed flag in Ordered Config says so.
    */
    if(rrcllc_cmd_under_process.chan_config.solo_bch_operation)
    {
      /* Always configure DL MAC for a Solo BCH operation */
      rrcllc_cmac_dl_config_req(NO_SYNC_WITH_L1);
      mac_dl_req_sent=TRUE;
    }
    else if((((ordered_config_ptr->rrc_state_indicator != RRC_STATE_CELL_DCH) ||
      (current_config_ptr->rrc_state_indicator != RRC_STATE_CELL_DCH)) ||
      ((ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH) &&
      (current_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH) &&
      (ordered_config_ptr->reconfig_needed.downlink_mac))))
    {
      
      sync_needed_with_l1 = NO_SYNC_WITH_L1;
      
      /* No activation time when configuring MAC due to Security Mode Command */
      if(rrcllc_cmd_under_process.procedure != RRC_PROCEDURE_SMC)
      {
        if((rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_DCH) &&
          (ordered_config.set_status != OC_SET_FOR_DCH_FACH_TRANS))
          
        {
        /* There is no solo BCH operation in this case, so use
        * Ordered Config Pointer.
          */
          if(ordered_config_ptr->reconfig_needed.downlink_l1)
          {
            sync_needed_with_l1 = SYNC_WITH_L1;
          }
        }
      }
      
      rrcllc_cmac_dl_config_req(sync_needed_with_l1);
      mac_dl_req_sent=TRUE;
    }
    else if ((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_IHO || rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CHO)&&
                (rrc_get_state()==RRC_STATE_CELL_DCH) &&
                (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_DCH))
    {
      if(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.nchan)
      {
        /*In case of IHO, we donot configure MAC and RLC earlier, with FEATURE_WCDMA_GPS_CELL_ID_READING we check if serving cell is up
        and if it is we tear down, so need to configure MAC and RLC*/
        for(i=0;i<rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.nchan;i++)
        {
          if(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[i].lc_type == UE_LOGCHAN_BCCH &&
            rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.dl_tm_act[i].action == RLC_RELEASE &&
            mac_dl_req_sent == FALSE)
          {
            WRRC_MSG0_HIGH("RRCGPS:Sending MAC DL Config Request for Dropping S-BCCH during IHO/CHO to G fails");
            rrcllc_cmac_dl_config_req(NO_SYNC_WITH_L1);
          }
        }
      }
    }
    /* Send a MAC UL Config ONLY IF it is NOT a Solo BCH Operation */
    if(rrcllc_cmd_under_process.chan_config.solo_bch_operation == FALSE)
    {
      /* Send a MAC Uplink Config only if so indicated */
      if(rrcllc_semi_permanent_data.send_mac_uplink_config == TRUE)
      {
        /* Send MAC Uplink Config request only if needed */
        /* When reconfiguring within DCH, reconfigure DL MAC only when the
        * reconfig_needed flag in Ordered Config says so.
        */
        if(((ordered_config_ptr->rrc_state_indicator != RRC_STATE_CELL_DCH) ||
          (current_config_ptr->rrc_state_indicator != RRC_STATE_CELL_DCH)) ||
          ((ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH) &&
          (current_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH) &&
          (ordered_config_ptr->reconfig_needed.uplink_mac)))
        {
          /* For ASU, we only want an underhand pointer swapping */
          if(rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_ASU)
          {
            mac_op = ONLY_SWAP_PTR;
          }
          else
          {
            mac_op = RECONFIG_MAC;
          }
#ifdef FEATURE_WCDMA_DC_HSUPA
          if((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_ASU) &&
             (ordered_config_ptr->mac_sec_eul_action != MAC_SEC_EUL_NOOP))
          {
            WRRC_MSG0_HIGH("DCHSUPA_DEBUG: ASU changes DCHSUPA config, MAC OP set to RECFG");
            mac_op = RECONFIG_MAC;
          
            if (rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req != 0)
            {
              for (count=0;count < rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req;count++)
              {
                if(rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[count].cmd.setup.sec_e_req_mask & (L1_EUL_START|L1_EUL_RECFG_UL|L1_EUL_RECFG_DL|L1_EUL_STOP))
                {
                    WRRC_MSG0_HIGH("DCHSUPA_DEBUG: SEC L1 E REQ MASK PRESENT");
                    sync_needed_btwn_l1_mac_for_asu = TRUE;
                    break;
                }
              }
            }
          }
#endif
#ifdef FEATURE_WCDMA_16_QAM
          if((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_ASU) &&
             (ordered_config_ptr->mac_eul_action != MAC_EUL_NOOP) &&
             ( (ordered_config_ptr->l1_e_info.e_ul_info.e_ul_16qam_action == TRUE) || 
               (current_config_ptr->l1_e_info.e_ul_info.e_ul_16qam_action == TRUE) ) )
          {
            WRRC_MSG0_HIGH("HSPA+:UL 16QAM ASU changes 16QAM config, MAC OP set to RECFG");
            mac_op = RECONFIG_MAC;

            if (rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req != 0)
            {
              for (count=0;count < rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req;count++)
              {
                if(rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[count].cmd.setup.e_req_mask & (L1_EUL_START|L1_EUL_RECFG_UL|L1_EUL_RECFG_DL|L1_EUL_STOP))
                {
                    WRRC_MSG0_HIGH("16QAM_DEBUG: L1 E REQ MASK PRESENT");
                    sync_needed_btwn_l1_mac_for_asu = TRUE;
                    break;
                }
              }
            }
          }
#endif
          sync_needed_with_l1 = NO_SYNC_WITH_L1;
          
          /* No activation time when configuring MAC due to Security Mode Command */
          if(
          ((rrcllc_cmd_under_process.procedure != RRC_PROCEDURE_SMC) &&
            (rrcllc_cmd_under_process.procedure != RRC_PROCEDURE_ASU))
#if defined(FEATURE_WCDMA_DC_HSUPA)  || defined (FEATURE_WCDMA_16_QAM)
             ||
             (sync_needed_btwn_l1_mac_for_asu == TRUE)
#endif
            )
          {
            if((rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_DCH) &&
              (ordered_config.set_status != OC_SET_FOR_DCH_FACH_TRANS))
            {
              if(ordered_config_ptr->reconfig_needed.uplink_l1)
              {
#if defined( FEATURE_WCDMA_DC_HSUPA) || defined (FEATURE_WCDMA_16_QAM)
                WRRC_MSG0_MED("DCHSUPA_DEBUG|HSPA+:: ASU changes DCHSUPA|UL 16QAM config, wait for L1 signal set");
#endif
                sync_needed_with_l1 = SYNC_WITH_L1;
              }
            }
          }
          
          /* Send MAC UL Config request */
          rrcllc_cmac_ul_config_req(mac_op, sync_needed_with_l1);
        }
      } /* Send MAC UL Config is TRUE */
    } /* Not a Solo BCH Operation */
    
      /* Since we do not expect any CNF, no need to break here - go to
      * the next point to send CPHY_SETUP_REQ
    */
    case LLC_WAIT_CPHY_SETUP_CNF:
      if(rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req != 0)
      {
        rrcllc_cmd_under_process.chan_config.l1_req_list.current_l1_req ++;
        count = rrcllc_cmd_under_process.chan_config.l1_req_list.current_l1_req;
        
        if(count < rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req)
        {
#ifdef FEATURE_WCDMA_HS_RACH
          /*Save the index for PCCPCH drop, we will use this after L1 transitions to DCH*/
          if((delay_bch_drop_for_hsrach_to_dch == TRUE) &&
             (rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[count].cmd.setup.req_mask & CPHY_DL_PHYCHAN_DROP_INCL) &&
             (rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[count].cmd.setup.drop_dl_phychan == L1_DL_PHYCHAN_PCCPCH_S))
          {
            WRRC_MSG0_HIGH("HSRACH: Delay PCCPCH DROP to L1");
            pccpch_drop_index = count;
            rrcllc_cmd_under_process.chan_config.l1_req_list.current_l1_req ++;
            count = rrcllc_cmd_under_process.chan_config.l1_req_list.current_l1_req;
          }
#endif
          rrcllc_cphy_setup_req(&rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[count]);          
          *next_substate = LLC_WAIT_CPHY_SETUP_CNF;
          break;
        }
        else  /* No more L1 cmds */
        {
          /* No more CPHY_SETUP_REQ commands in rrcllc_cmd_under_process */
          /* If any of the CPHY_SETUP_REQs had a Setup/Reconfig for a DL DPCH,
          * expect a Channel Ind from L1. Otherwise go to Idle
          */
          /* First check if a Channel Establishment Indication has already been
          * received from L1.
          */
          if(rrcllc_cmd_under_process.chan_config.chan_est_ind_rcvd == FALSE)
          {
            for(i=0; i<rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req; i++)
            {
              /* For VST, do not wait for a Channel Indication */
              if((rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i].cmd.
                setup.req_mask & CPHY_DL_PHYCHAN_ADD_INCL) &&
                   ((rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i].cmd.
                    setup.dl_phychan  == L1_DL_PHYCHAN_DPCH)
                    || (rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[i].cmd.
                    setup.dl_phychan  == L1_DL_PHYCHAN_FDPCH)
                   ))
              {
                /* A DPCH setup/reconfig went to L1 in this CPHY_SETUP_REQ */
                *next_substate = LLC_WAIT_CPHY_CHANNEL_IND;
                break;
              }
            } /* for(...) */
            
              /* If we're doing IFHHO, we must wait for the Channel
            Establishment Indication */
            if(rrcllc_cmd_under_process.chan_config.new_freq)
            {
              WRRC_MSG0_HIGH("IFHHO waiting for CPHY_CHANNEL_IND");
              *next_substate = LLC_WAIT_CPHY_CHANNEL_IND;
            }
          } /* Channel Est Indication has not been received so far */
          else
          {
            /* Channel Establishment Indication already received */
            if(rrcllc_cmd_under_process.chan_config.new_freq)
            {
              rrc_ccm_update_for_inter_freq_hard_handover(
                ordered_config_ptr->dest_freq, ordered_config_ptr->dest_psc);
            }
            // *next_substate = LLC_IDLE;
          }
          
          /* Here, release all CCTrCH IDs since all CPHY_SETUP_REQs have been sent
          * to L1 and their respective Confirmations received.
          */
          rrcllc_clear_released_cctrch_ids();
          
          if (*next_substate == LLC_WAIT_CPHY_CHANNEL_IND)
          {
            break;
          }
        } /* No more L1 cmds */
      } /* Number of L1 cmds not zero */
      
    case LLC_WAIT_CPHY_CHANNEL_IND: /*lint !e616  Fall thru from above */
      if(rrcllc_cmd_under_process.chan_config.new_freq)
      {
        rrc_ccm_update_for_inter_freq_hard_handover(
          ordered_config_ptr->dest_freq, ordered_config_ptr->dest_psc);
      }
#ifdef FEATURE_WCDMA_HS_RACH
      /*Note: CPHY_SETUP_CNF for PCCPCH drop will be ignored by LLC since substate is not LLC_WAIT_CPHY_SETUP_CNF
        There should not be any race conditions with GPS event since drop takes only 10ms
      */
      else if(delay_bch_drop_for_hsrach_to_dch == TRUE &&
              pccpch_drop_index != -1)
      {
        WRRC_MSG0_HIGH("HSRACH: Sending the delayed PCCPCH DROP to L1");
        rrcllc_cphy_setup_req(&rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[pccpch_drop_index]);
        pccpch_drop_index = -1;
      }
#endif
      WRRC_MSG3_MED("RLC DL TM entities in [CC|OC|TOC]:[%d|%d|%d]", 
                current_config_ptr->rlc_dl_tm_parms.nchan,
                ordered_config_ptr->rlc_dl_tm_parms.nchan,
                transition_config.toc_ptr->rlc_dl_tm_parms.nchan);
      if(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.nchan > 0)
      {
        rrcllc_crlc_dl_tm_config_req(&rrcllc_cmd_under_process.
          chan_config.rlc_config_req_list.dl_tm);
        *next_substate = LLC_WAIT_RLC_TM_DL_CNF;
        break;
      }
      
    case LLC_WAIT_RLC_TM_DL_CNF: /*lint !e616  Fall thru from above */
      if((rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.nchan > 0)
#ifdef FEATURE_TM_LB
         ||
         ((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_LBT) && 
          (rrcllc_cmd_under_process.chan_config.lb_test_mode == LB_TEST_MODE_2))
#endif
         )
      {
        if((rrcllc_crlc_ul_tm_config_req(&rrcllc_cmd_under_process.
          chan_config.rlc_config_req_list.ul_tm))
          == FAILURE)
        {
          WRRC_MSG0_ERROR("Could not send RLC UL TM Config Request");
          return(FAILURE);
        }
        *next_substate = LLC_WAIT_RLC_TM_UL_CNF;
        break;
      }
      
    case LLC_WAIT_RLC_TM_UL_CNF: /*lint !e616  Fall thru from above */
      if(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.nchan > 0)
      {
        rrcllc_crlc_dl_um_config_req(&rrcllc_cmd_under_process.
        chan_config.rlc_config_req_list.dl_um);
        *next_substate = LLC_WAIT_RLC_UM_DL_CNF;
        break;
      }
      
    case LLC_WAIT_RLC_UM_DL_CNF: /*lint !e616  Fall thru from above */
      if(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.nchan > 0)
      {
        rrcllc_crlc_ul_um_config_req(&rrcllc_cmd_under_process.
          chan_config.rlc_config_req_list.ul_um);
        *next_substate = LLC_WAIT_RLC_UM_UL_CNF;
        break;
      }
      
    case LLC_WAIT_RLC_UM_UL_CNF: /*lint !e616  Fall thru from above */
      if(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.nentity > 0)
      {
        rrcllc_crlc_am_config_req(&rrcllc_cmd_under_process.
          chan_config.rlc_config_req_list.am);
        *next_substate = LLC_WAIT_RLC_AM_CNF;
        break;
      }
      
    case LLC_WAIT_RLC_AM_CNF: /*lint !e616  Fall thru from above */
      /*In case of Voice Transition, CSoDCH -> CSoHS, following case will deconfigure the MVS 
      and release the vocoder then configure PDCP*/
      
      /*In case of Voice Transition CSoHS -> CSoDCH, first PDCP will be de-configured and Vocoder will
      be released. Then RBE/CU procedure will configure MVS and acquire Vocoder*/
#ifdef FEATURE_UMTS_PDCP
      if (rrcllc_cmd_under_process.chan_config.pdcp_config_req_list.num_rbs > 0) 
      {
        rrcllc_cpdcp_config_req();
        /*If the sending of CPDCP_CONFIG_REQ is successful, check whether Voice Transition is happening or not.*/
      }
#endif /* FEATURE_UMTS_PDCP */
      
      /* We're done configuring lower layers now.  We need to update the
      * process_state if we're currently executing a reconfiguration
      * procedure.
      */
      if(rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CU ||
        rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_PCR ||
        rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RBE ||
        rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RCE ||
        rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RBR ||
        rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RBRC ||
        rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_TCR ||
        rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_ASU ||
        rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_UMI)
      {
      WRRC_MSG1_MED("RRCGPS:Current procedure setting LL_CONFIG_WITH_OC is %d",rrcllc_cmd_under_process.procedure);
        ordered_config.process_state = LL_CONFIG_WITH_OC;
      }
      
      /* Configure RLC with the ciphering information */
      if(rrcllc_rlc_cipher_update_needed == TRUE)
      {
        rrcllc_update_ciphering_config_info_for_reconfig();
        /* Reset the cipher_update_needed flag */
        rrcllc_rlc_cipher_update_needed = FALSE;
      }
      /* Here register logical channels with RLC and send a Config to MAC */
      rrcllc_send_rlc_register_ul_srvc_req();
      rrcllc_send_rlc_register_dl_srvc_req();
      
      /* Release all Logical channel IDs that need to be released */
      rrcllc_release_ul_logical_chl_ids();
      rrcllc_release_dl_logical_chl_ids();
      rrcllc_clear_rlc_info();
#ifdef FEATURE_UMTS_PDCP
      /* If pdcp was released, Clear the information saved in oredered_config*/
      if (rrcllc_cmd_under_process.chan_config.pdcp_config_req_list.num_rbs > 0) 
      {
        rrcllc_clear_pdcp_info();
      }
#endif /* FEATURE_UMTS_PDCP */
      
      
      *next_substate = LLC_IDLE;
      break;
      
    default:
      WRRC_MSG1_ERROR("Cmd engine called in LLC state %d", current_substate);
      return(FAILURE);
  } /* switch(curr_state) */
  
  return(SUCCESS);
  
} /* rrcllc_chan_config_engine */
/*====================================================================
FUNCTION: rrcllc_need_to_send_rlc_re_est()

DESCRIPTION:
  This function checks if RLC re-establishment needs to be done. If
  yes, then it updates the RLC Re-establishment command buffer and
  returns a TRUE value.

DEPENDENCIES:
  None.

RETURN VALUE:
  TRUE: RLC Re-establishment needs to be done.
  FALSE: Otherwise

SIDE EFFECTS:
  None.
====================================================================*/
static boolean rrcllc_need_to_send_rlc_re_est(boolean srb_re_est, boolean urb_re_est)
{
  ordered_config_type  *config_ptr;
  rrcsmc_re_est_start_list  start_list;
  rrcllc_oc_set_status_e_type     oc_status;
  rrc_proc_e_type                 proc_id;
  rrcllc_oc_process_state_e_type  process_state;  
  uint32  i=0, local_start_value=0;
  rrc_state_e_type dest_state = rrccu_get_dest_state();

  rlc_am_config_for_re_est.nentity = 0;

  if(config_ptr_in_use == ORDERED_CONFIG)
  {
    config_ptr = ordered_config_ptr;
  }
  else
  {
    config_ptr = current_config_ptr;
  }

  /* Now get Ciphering parameters from SMC */
  rrcsmc_get_latest_transmitted_start_values(&start_list);

  oc_status = rrcllc_get_ordered_config_state_and_proc_wo_f3(&proc_id, &process_state);

  if((TRUE == rrcllc_reconfig_in_progress()) &&
     (oc_status != OC_NOT_SET) &&
     (proc_id == RRC_PROCEDURE_RBE) &&
     (RRCRB_WAIT_FOR_CELL_UPDATE_CNF == rrcrbe_get_current_sub_state()) &&
     (TRUE == rrcsmc_get_start_value_to_transmit_flag_status()))
  {
    local_start_value = rrcsmc_get_start_value_to_transmit();
    if(local_start_value !=0)
    {
      rrcsmc_update_start_list_with_latest_transmitted_start_value(&start_list);
    }
  }
    
  for(i=0; i<UE_MAX_AM_ENTITY; i++)
  {
    switch(config_ptr->rlc_am_parms.am_info[i]->common_config.rb_id)
    {
      case DCCH_AM_RADIO_BEARER_ID:
      case DCCH_DT_HIGH_PRI_RADIO_BEARER_ID:
      case DCCH_DT_LOW_PRI_RADIO_BEARER_ID:
        if((rlc_am_config_for_re_est.nentity < UE_MAX_AM_ENTITY) &&
           (srb_re_est &&
           /* make sure that this is not an empty hole  */
           config_ptr->rlc_am_parms.am_info[i]->ul_nchan &&
           config_ptr->rlc_am_parms.am_info[i]->dl_nchan))
        {
          rlc_am_config_for_re_est.am_act[rlc_am_config_for_re_est.nentity].act_incl = FALSE;
          rlc_am_config_for_re_est.am_act[rlc_am_config_for_re_est.nentity].action = RLC_MODIFY;
          rlc_am_config_for_re_est.am_act[rlc_am_config_for_re_est.nentity].ul_cfg_mask = RLC_RE_ESTABLISH_CFG;
          rlc_am_config_for_re_est.am_act[rlc_am_config_for_re_est.nentity].dl_cfg_mask = RLC_RE_ESTABLISH_CFG;
          rlc_am_config_for_re_est.am_info[rlc_am_config_for_re_est.nentity] =
            config_ptr->rlc_am_parms.am_info[i];
          rlc_am_config_for_re_est.am_info[rlc_am_config_for_re_est.nentity]->rlc_ul_am_config.hfn =
          rlc_am_config_for_re_est.am_info[rlc_am_config_for_re_est.nentity]->rlc_dl_am_config.hfn =
            start_list.hfn_srb;

          rlc_am_config_for_re_est.am_info[rlc_am_config_for_re_est.nentity]->rlc_ul_am_config.ciph_algo =
          rlc_am_config_for_re_est.am_info[rlc_am_config_for_re_est.nentity]->rlc_dl_am_config.ciph_algo =
            start_list.ciph_algo_srb;
          rlc_am_config_for_re_est.am_info[rlc_am_config_for_re_est.nentity]->reestab_entity = RLC_RE_ESTABLISH_DL_UL;
          rlc_am_config_for_re_est.nentity ++;
          MSG_HIGH("Re-establish both, %d. Re-est for RB ID %d HFN %d",
                     rlc_am_config_for_re_est.nentity,
                     config_ptr->rlc_am_parms.am_info[i]->common_config.rb_id,
                     start_list.hfn_srb);
        }
        break;

      default:
        if((rlc_am_config_for_re_est.nentity < UE_MAX_AM_ENTITY) &&
           (urb_re_est &&
           /* make sure that this is not an empty hole  */
           config_ptr->rlc_am_parms.am_info[i]->ul_nchan &&
           config_ptr->rlc_am_parms.am_info[i]->dl_nchan))
        {
          rlc_am_config_for_re_est.am_act[rlc_am_config_for_re_est.nentity].act_incl = FALSE;
          rlc_am_config_for_re_est.am_act[rlc_am_config_for_re_est.nentity].action = RLC_MODIFY;
          rlc_am_config_for_re_est.am_act[rlc_am_config_for_re_est.nentity].ul_cfg_mask = RLC_RE_ESTABLISH_CFG;
          rlc_am_config_for_re_est.am_act[rlc_am_config_for_re_est.nentity].dl_cfg_mask = RLC_RE_ESTABLISH_CFG;
          rlc_am_config_for_re_est.am_info[rlc_am_config_for_re_est.nentity] =
            config_ptr->rlc_am_parms.am_info[i];
          rlc_am_config_for_re_est.am_info[rlc_am_config_for_re_est.nentity]->rlc_ul_am_config.hfn =
          rlc_am_config_for_re_est.am_info[rlc_am_config_for_re_est.nentity]->rlc_dl_am_config.hfn =
            start_list.hfn_rab;

          rlc_am_config_for_re_est.am_info[rlc_am_config_for_re_est.nentity]->rlc_ul_am_config.ciph_algo =
          rlc_am_config_for_re_est.am_info[rlc_am_config_for_re_est.nentity]->rlc_dl_am_config.ciph_algo =
            start_list.ciph_algo_urb;

          rlc_am_config_for_re_est.am_info[rlc_am_config_for_re_est.nentity]->reestab_entity = RLC_RE_ESTABLISH_DL_UL;

          rlc_am_config_for_re_est.nentity ++;
          MSG_HIGH("Re-establish both, %d. Re-est for RB ID %d HFN %d",
                     rlc_am_config_for_re_est.nentity,
                     config_ptr->rlc_am_parms.am_info[i]->common_config.rb_id,
                     start_list.hfn_rab);
        }
        break;
    }
  } /* for (all nentities in OC) */


  if(rlc_am_config_for_re_est.nentity)
  {
    /* Memcopy here is to ensure that we take back up of RLC size if rnti update has RAB re-est set to TRUW */
    /* Preventing the below memcpy to avoid taking backup for PCH states */
    if(!((rrccu_get_cell_update_started_status() == RRCCU_STARTED) && ((RRC_STATE_CELL_PCH == dest_state) ||(RRC_STATE_URA_PCH == dest_state)))
      && (urb_re_est))
    {
      WCDMA_MEMCPY(&rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am, sizeof(rlc_am_config_req_type),&rlc_am_config_for_re_est,sizeof(rlc_am_config_req_type)); 
    }
    rrcllc_crlc_am_config_req(&rlc_am_config_for_re_est);
    return(TRUE);
  }
  else
  {
    return(FALSE);
  }

} /* rrcllc_need_to_send_rlc_re_est */

/*====================================================================
FUNCTION: rrcllc_send_rnti_update_cnf()

DESCRIPTION:
  This function sends RNTI_UPDATE_CNF message to the procedure
  as indicated in rrcllc_cmd_under_process.

DEPENDENCIES:
  None.

RETURN VALUE:
  None
SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_send_rnti_update_cnf(uecomdef_status_e_type rnti_update_cnf_status)
{
  /* Send RRC_RNTI_UPDATE_CNF */
  rrc_cmd_type  *rrc_cmd_ptr;
  rrc_cmd_ptr = rrc_get_int_cmd_buf();

  MSG_MED("Sending RRC_RNTI_UPDATE_CNF to Proc rrc_proc_e_type_value%d",rrcllc_cmd_under_process.procedure,0,0);

  /* Fill in the local command header.*/
  rrc_cmd_ptr->cmd_hdr.cmd_id = RRC_RNTI_UPDATE_CNF;
  /* Fill in the procedure id */
  rrc_cmd_ptr->cmd.rnti_update_cnf.procedure =  rrcllc_cmd_under_process.procedure;
  rrc_cmd_ptr->cmd.rnti_update_cnf.status = rnti_update_cnf_status;

  /* Send the internal command */
  rrc_put_int_cmd(rrc_cmd_ptr);

} /* rrcllc_send_rnti_update_cnf */


/*====================================================================
FUNCTION: rrcllc_restore_rnti_info()

DESCRIPTION:
  This function restores old RNTI info in config_ptr

DEPENDENCIES:
  None.

RETURN VALUE:

SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_restore_rnti_info(mac_rnti_valid_e_type svd_rnti_validity, 
                              uint32 svd_urnti,
                              uint16 svd_crnti )
{
  MSG_HIGH("Restoring RNTI info in config db urnti %d crnti %d rnti_validity %d",
           svd_urnti, svd_crnti, svd_rnti_validity);

  ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = svd_rnti_validity;
  current_config_ptr->mac_ul_parms.rnti_info.rnti_valid = svd_rnti_validity;
  ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = svd_rnti_validity;
  current_config_ptr->mac_dl_parms.rnti_info.rnti_valid = svd_rnti_validity;
  transition_config.toc_ptr->mac_ul_parms.rnti_info.rnti_valid = svd_rnti_validity;
  transition_config.toc_ptr->mac_dl_parms.rnti_info.rnti_valid = svd_rnti_validity;
  ordered_config_ptr->mac_ul_parms.rnti_info.urnti = svd_urnti;
  current_config_ptr->mac_ul_parms.rnti_info.urnti = svd_urnti;
  ordered_config_ptr->mac_dl_parms.rnti_info.urnti = svd_urnti;
  current_config_ptr->mac_dl_parms.rnti_info.urnti = svd_urnti;
  transition_config.toc_ptr->mac_ul_parms.rnti_info.urnti = svd_urnti;
  transition_config.toc_ptr->mac_dl_parms.rnti_info.urnti = svd_urnti;
  ordered_config_ptr->mac_ul_parms.rnti_info.crnti = svd_crnti;
  current_config_ptr->mac_ul_parms.rnti_info.crnti = svd_crnti;
  ordered_config_ptr->mac_dl_parms.rnti_info.crnti = svd_crnti;
  current_config_ptr->mac_dl_parms.rnti_info.crnti = svd_crnti;
  transition_config.toc_ptr->mac_ul_parms.rnti_info.crnti = svd_crnti;
  transition_config.toc_ptr->mac_dl_parms.rnti_info.crnti = svd_crnti;
}
 

/*====================================================================
FUNCTION: rrcllc_process_rnti_update_req()

DESCRIPTION:
  This function updates the rnti information and updates MAC
  accordingly.

DEPENDENCIES:
  None.

RETURN VALUE:
  Next RRCLLC substate depending on whether RLC needs to be re-established
  or not.

SIDE EFFECTS:
  None.
====================================================================*/
static rrcllc_substate_e_type rrcllc_process_rnti_update_req(rrc_cmd_type *cmd_ptr)
{
  ordered_config_type *config_ptr;

  rrcllc_substate_e_type  return_substate = LLC_IDLE;
  uint8 cctrch_id = 0 , i = 0;
  uint32 svd_urnti = 0;
  uint16 svd_crnti = 0;
  mac_rnti_valid_e_type svd_rnti_validity = NO_RNTI_VALID;
  rrc_SysInfoType5    *sib5_ptr = NULL;
  rrc_SysInfoType6    *sib6_ptr = NULL;
  rrclog_crnti_event crnti_event;
  rrclog_urnti_event urnti_event;

  
  rrc_SCCPCH_SystemInformationList  * sccpch_sys_info_list = {0};
  uint8 new_sccpch_index = 0;

  if(config_ptr_in_use == CURRENT_CONFIG)
  {
    config_ptr = current_config_ptr;
  }
  else
  {
    config_ptr = ordered_config_ptr;
  }

  /* save the crnti and urnti.  If for some reason RNTI update 
   * request fails, we have to restore old values back to config_ptr
   */
  svd_rnti_validity = config_ptr->mac_ul_parms.rnti_info.rnti_valid;
  svd_urnti = config_ptr->mac_ul_parms.rnti_info.urnti;
  svd_crnti = config_ptr->mac_ul_parms.rnti_info.crnti;

    /* Incase of cell reselection from hsrach to legacy cell network may not have provided the mappings
    in cell update confirm we we need to do mapping check if umic is response for cucnf and then go to idle*/
   if((RRC_STATE_CELL_FACH == rrcllc_cmd_under_process.next_rrc_state)
   	&& (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CU)
   	&& ((cmd_ptr->cmd.rnti_update_req.crnti_action == RRC_RNTI_UPDATE)
   	|| (cmd_ptr->cmd.rnti_update_req.urnti_action == RRC_RNTI_UPDATE)))
   {

#ifdef FEATURE_WCDMA_HS_FACH
     if(
#ifdef FEATURE_WCDMA_HS_RACH
            (FALSE == rrchsrach_camped_cell_supports_hsrach())&&
#endif
            (FALSE == rrcenhstate_camped_cell_supports_e_fach()))
#endif
     {
         /* else check rach/fach mappings present or not for a legacy cell*/      
       if (FALSE == rrcllc_check_dcch_fach_mapping(config_ptr))
        {
          WRRC_MSG0_HIGH("RRC:Legacy cell transition to idle from connected -> rb mapping info is not present");
          rrc_transition_to_disconnected_state(RRC_PROCEDURE_LLC,RRC_TX_TO_DISCON_OTHER);          
          rrcllc_cmd_under_process.rnti_update_cnf_needed = FALSE;
          cmd_ptr->cmd.rnti_update_req.cnf_required = FALSE;
          return return_substate;
        }
      }
   }

  /* Handle C-RNTI cases */
  if (cmd_ptr->cmd.rnti_update_req.crnti_action == RRC_RNTI_UPDATE)
  {
    WRRC_MSG1_HIGH("New C-RNTI %d", cmd_ptr->cmd.rnti_update_req.crnti);
    crnti_event.crnti_value = cmd_ptr->cmd.rnti_update_req.crnti;

    event_report_payload( EVENT_WCDMA_RRC_CRNTI,
                     sizeof(crnti_event),
                     (void *)&crnti_event);
    ordered_config_ptr->mac_ul_parms.rnti_info.crnti = (uint16)cmd_ptr->cmd.rnti_update_req.crnti;
    ordered_config_ptr->mac_dl_parms.rnti_info.crnti = (uint16)cmd_ptr->cmd.rnti_update_req.crnti;
    current_config_ptr->mac_ul_parms.rnti_info.crnti = (uint16)cmd_ptr->cmd.rnti_update_req.crnti;
    current_config_ptr->mac_dl_parms.rnti_info.crnti = (uint16)cmd_ptr->cmd.rnti_update_req.crnti;
    transition_config.toc_ptr->mac_ul_parms.rnti_info.crnti = (uint16)cmd_ptr->cmd.rnti_update_req.crnti;
    transition_config.toc_ptr->mac_dl_parms.rnti_info.crnti = (uint16)cmd_ptr->cmd.rnti_update_req.crnti;
    /* Check rnti_valid flag in Config_ptr and update this in OC/CC 
       we need not copy urnti to config_ptr NOT in use as same URNTI exists in CC/OC
    */
    if (config_ptr->mac_ul_parms.rnti_info.rnti_valid == URNTI_VALID)
    {
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = BOTH_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = BOTH_VALID;
      current_config_ptr->mac_ul_parms.rnti_info.rnti_valid = BOTH_VALID;
      current_config_ptr->mac_dl_parms.rnti_info.rnti_valid = BOTH_VALID;
      transition_config.toc_ptr->mac_ul_parms.rnti_info.rnti_valid = BOTH_VALID;
      transition_config.toc_ptr->mac_dl_parms.rnti_info.rnti_valid = BOTH_VALID;
      /* Copy the URNTI from config_ptr to TOC so that correct URNTI exist in TOC - CR#754612 */
      transition_config.toc_ptr->mac_ul_parms.rnti_info.urnti = config_ptr->mac_ul_parms.rnti_info.urnti;
      transition_config.toc_ptr->mac_dl_parms.rnti_info.urnti = config_ptr->mac_dl_parms.rnti_info.urnti;
    }
    else if (config_ptr->mac_ul_parms.rnti_info.rnti_valid == NO_RNTI_VALID)
    {
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = CRNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = CRNTI_VALID;
      current_config_ptr->mac_ul_parms.rnti_info.rnti_valid = CRNTI_VALID;
      current_config_ptr->mac_dl_parms.rnti_info.rnti_valid = CRNTI_VALID;
      transition_config.toc_ptr->mac_ul_parms.rnti_info.rnti_valid = CRNTI_VALID;
      transition_config.toc_ptr->mac_dl_parms.rnti_info.rnti_valid = CRNTI_VALID;

    }
  }
  else if (cmd_ptr->cmd.rnti_update_req.crnti_action == RRC_RNTI_DELETE)
  {
    WRRC_MSG0_HIGH("Delete C-RNTI");
    ordered_config_ptr->mac_ul_parms.rnti_info.crnti = 0;
    ordered_config_ptr->mac_dl_parms.rnti_info.crnti = 0;
    current_config_ptr->mac_ul_parms.rnti_info.crnti = 0;
    current_config_ptr->mac_dl_parms.rnti_info.crnti = 0;
      transition_config.toc_ptr->mac_ul_parms.rnti_info.crnti = 0;
      transition_config.toc_ptr->mac_dl_parms.rnti_info.crnti = 0;
    if (config_ptr->mac_ul_parms.rnti_info.rnti_valid == BOTH_VALID)
    {
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = URNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = URNTI_VALID;
      current_config_ptr->mac_ul_parms.rnti_info.rnti_valid = URNTI_VALID;
      current_config_ptr->mac_dl_parms.rnti_info.rnti_valid = URNTI_VALID;
      transition_config.toc_ptr->mac_ul_parms.rnti_info.rnti_valid = URNTI_VALID;
      transition_config.toc_ptr->mac_dl_parms.rnti_info.rnti_valid = URNTI_VALID;

    }
    else if (config_ptr->mac_ul_parms.rnti_info.rnti_valid == CRNTI_VALID)
    {
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
      current_config_ptr->mac_ul_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
      current_config_ptr->mac_dl_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
      transition_config.toc_ptr->mac_ul_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
      transition_config.toc_ptr->mac_dl_parms.rnti_info.rnti_valid = NO_RNTI_VALID;

    }
#ifdef FEATURE_WCDMA_HS_RACH
  /*Delete ERNTI along with CRNTI always*/
  ordered_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present=FALSE;
  current_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present=FALSE;
  transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present=FALSE;
#endif
  }
  else
  {
    MSG_LOW("No change required for C-RNTI",0,0,0);
  }

  /* Handle U-RNTI cases */
  if (cmd_ptr->cmd.rnti_update_req.urnti_action == RRC_RNTI_UPDATE)
  {
    WRRC_MSG1_HIGH("New U-RNTI %d", cmd_ptr->cmd.rnti_update_req.urnti);

    urnti_event.urnti_value = cmd_ptr->cmd.rnti_update_req.urnti;

    event_report_payload( EVENT_WCDMA_RRC_URNTI,
                     sizeof(urnti_event),
                     (void *)&urnti_event);

    ordered_config_ptr->mac_ul_parms.rnti_info.urnti = cmd_ptr->cmd.rnti_update_req.urnti;
    ordered_config_ptr->mac_dl_parms.rnti_info.urnti = cmd_ptr->cmd.rnti_update_req.urnti;
    current_config_ptr->mac_ul_parms.rnti_info.urnti = cmd_ptr->cmd.rnti_update_req.urnti;
    current_config_ptr->mac_dl_parms.rnti_info.urnti = cmd_ptr->cmd.rnti_update_req.urnti;
    transition_config.toc_ptr->mac_ul_parms.rnti_info.urnti = cmd_ptr->cmd.rnti_update_req.urnti;
    transition_config.toc_ptr->mac_dl_parms.rnti_info.urnti = cmd_ptr->cmd.rnti_update_req.urnti;
    /* Check rnti_valid flag in Config_ptr and update this in OC/CC 
       we need not copy crnti to config_ptr NOT in use as same CRNTI exists in CC/OC
       CRNTI delete happens only through RNTI update req and this code deletes CRNTI
       in both CC/OC at the same time. Same is the case when new CRNTI is added. So 
       both OC/CC will have same CRNTI.
    */
    if (config_ptr->mac_ul_parms.rnti_info.rnti_valid == CRNTI_VALID)
    {
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = BOTH_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = BOTH_VALID;
      current_config_ptr->mac_ul_parms.rnti_info.rnti_valid = BOTH_VALID;
      current_config_ptr->mac_dl_parms.rnti_info.rnti_valid = BOTH_VALID;
      transition_config.toc_ptr->mac_ul_parms.rnti_info.rnti_valid = BOTH_VALID;
      transition_config.toc_ptr->mac_dl_parms.rnti_info.rnti_valid = BOTH_VALID;
      transition_config.toc_ptr->mac_ul_parms.rnti_info.crnti = config_ptr->mac_ul_parms.rnti_info.crnti;
      transition_config.toc_ptr->mac_dl_parms.rnti_info.crnti = config_ptr->mac_dl_parms.rnti_info.crnti;
    }
    else if (config_ptr->mac_ul_parms.rnti_info.rnti_valid == NO_RNTI_VALID)
    {
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = URNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = URNTI_VALID;
      current_config_ptr->mac_ul_parms.rnti_info.rnti_valid = URNTI_VALID;
      current_config_ptr->mac_dl_parms.rnti_info.rnti_valid = URNTI_VALID;
      transition_config.toc_ptr->mac_ul_parms.rnti_info.rnti_valid = URNTI_VALID;
      transition_config.toc_ptr->mac_dl_parms.rnti_info.rnti_valid = URNTI_VALID;
    }
#ifdef FEATURE_WCDMA_HS_FACH
    if(rrcllc_get_hs_status_in_e_fach(config_ptr) == FALSE)
#endif
    {

      if (config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
          config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
          config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH) 
      {
        /* Determine if SCCPCH selection is required here */
        sib5_ptr = (rrc_SysInfoType5 *)
        rrc_sibdb_return_sib_for_srv_cell(rrc_SIB5);

        if (sib5_ptr != NULL && sib5_ptr->sib6indicator == TRUE)        
        {
          sib6_ptr = (rrc_SysInfoType6 *)
          rrc_sibdb_return_sib_for_srv_cell(rrc_SIB6);
          if (sib6_ptr != NULL && 
  			(RRC_MSG_COMMON_BITMASK_IE_TYPE2_PTR(sib6_ptr,sCCPCH_SystemInformationList)))
          {
            /* Determine the SCCPCH index from SIB 6 SCCPCH List */
            sccpch_sys_info_list = &sib6_ptr->sCCPCH_SystemInformationList;
          }
          else
          {
            /* Determine the SCCPCH index from SIB 5 SCCPCH List */
            sccpch_sys_info_list = &sib5_ptr->sCCPCH_SystemInformationList;
          }
        }
        else if (sib5_ptr != NULL) 
        {
          /* Determine the SCCPCH index from SIB 5 SCCPCH List */
          sccpch_sys_info_list = &sib5_ptr->sCCPCH_SystemInformationList;
        }
        else
        {
          /* SIB5 and SIB 6 not present */
          WRRC_MSG0_ERROR("sib5 and sib6 not present");

          if (TRUE == rrcllc_cmd_under_process.rnti_update_cnf_needed)
          {
            /* Send RNTI Update Confirm */
            rrcllc_send_rnti_update_cnf(FAILURE);
          }
          /* restore old rnti values in config ptr */
          rrcllc_restore_rnti_info(svd_rnti_validity, svd_urnti, svd_crnti);
          return return_substate;
        }

        new_sccpch_index = (uint8)get_sccpch_index(config_ptr, sccpch_sys_info_list, RRC_STATE_CELL_FACH);

        if (curr_sccpch_index != new_sccpch_index) 
        {
          WRRC_MSG0_HIGH("New SCCPCH selection required due to URNTI update");
          rrcllc_cmd_under_process.sccpch_selec_reqd = TRUE;
          if(config_ptr_in_use == CURRENT_CONFIG)
          {
            /* If Current Config is in use, use OC for Reselection */
            rrcllc_copy_cc_to_oc();
            config_ptr = ordered_config_ptr;
          }
          else if ((config_ptr_in_use == ORDERED_CONFIG) &&
                   (ordered_config.process_state == LL_CONFIG_WITH_OC))
          {
           /* If Ordered Config is in use AND Lower layers have been configured
            * with OC data, Copy OC to CC and have config_ptr point to CC
            */
            rrcllc_copy_oc_to_cc();
            config_ptr = current_config_ptr;
          }
          else
          {
            /* If Ordered Config is in use AND Lower layers have NOT been
             * configured - URNTI update is not handled in this situation.
             * Should not have come here.
             */
            WRRC_MSG1_ERROR("OC in use, proc rrc_proc_e_type_value%d, LL not config", ordered_config.set_by_proc);
            if (TRUE == rrcllc_cmd_under_process.rnti_update_cnf_needed)
            {
              /* Send RNTI Update Confirm */
              rrcllc_send_rnti_update_cnf(FAILURE);
            }
            /* restore old rnti values in config ptr */
            rrcllc_restore_rnti_info(svd_rnti_validity, svd_urnti, svd_crnti);
            return return_substate;
          } 

          if (rrcllc_update_oc_in_fach_with_sibs(config_ptr) ==
              FAILURE)
          {
            WRRC_MSG0_ERROR("Failure updating OC with SIB; In FACH");
            if (TRUE == rrcllc_cmd_under_process.rnti_update_cnf_needed)
            {
              /* Send RNTI Update Confirm */
              rrcllc_send_rnti_update_cnf(FAILURE);
            }
            /* restore old rnti values in config ptr */
            rrcllc_restore_rnti_info(svd_rnti_validity, svd_urnti, svd_crnti);

          }

          /* SCCPCH Processing */
          rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_action =
            LLC_PHYCHAN_RECONFIG;

          WRRC_MSG0_HIGH("LLC_PHYCHAN_RECONFIG on SCCPCH due to RNTI update");

          rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf =
            L1_DL_TRCH_REFTYPE_FACH_BF;
          rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf =
            L1_DL_TRCH_REFTYPE_FACH_BF;
          rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf &=
            ~L1_DL_TRCH_REFTYPE_PCH_BF;

          /* Now determine if OC has picked an SCCPCH that also carries FACH  */
          if(rrcllc_semi_permanent_data.dl_phy_chan.pch_included == FALSE)
          {
            /* SCCPCH that does not have FACH */
            rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf &=
              ~L1_DL_TRCH_REFTYPE_PCH_BF;
          }
          else
          {
            /* Fix the transport channel bitmasks for SCCPCH */
            rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
              L1_DL_TRCH_REFTYPE_PCH_BF;
          }

          /* At this time, both SCCPCH and N_PCCPCH would be up. Add
           * their CCTrCH IDs to the CCTrCH IDs to be released list.
           */
          if(rrcllc_semi_permanent_data.dl_phy_chan.sccpch.cctrch_id !=
             RRCLLC_INVALID_CCTRCH_ID)
          {
            RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                                 dl_phy_chan.sccpch.cctrch_id);
          }

          /* Get a new CCTrCH ID */
          cctrch_id = rrcllc_get_cctrch_id();
          if(cctrch_id != RRCLLC_INVALID_CCTRCH_ID)
          {
            /* Update FACH info in MAC Ordered Config */
            for( i = 0; i < config_ptr->mac_dl_parms.num_fachs; i ++)
            {
              config_ptr->mac_dl_parms.fach_info[i]->cctrch_id = cctrch_id;
            }

            config_ptr->mac_dl_parms.pch_info->cctrch_id = cctrch_id;

            /* Update SCCPCH Info in rrcllc_cmd_under_process */
            rrcllc_semi_permanent_data.dl_phy_chan.sccpch.cctrch_id =
              cctrch_id;
          }
          else
          {
            WRRC_MSG1_ERROR("Invalid CCTrCH ID %d assigned", cctrch_id);
            if (TRUE == rrcllc_cmd_under_process.rnti_update_cnf_needed)
            {
              /* Send RNTI Update Confirm */
              rrcllc_send_rnti_update_cnf(FAILURE);
            }
            /* restore old rnti values in config ptr */
            rrcllc_restore_rnti_info(svd_rnti_validity, svd_urnti, svd_crnti);
            return return_substate;
          }

          /* The Semi permanent data is all updated now. Copy fields into reselection config */
          config_ptr->l1_dl_cctrch_parms.trch_enable_bf =
            rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf;

          config_ptr->l1_dl_cctrch_parms.trch_ref_type_bf =
            rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf;

          config_ptr->l1_dl_cctrch_parms.cctrch_id =
            rrcllc_semi_permanent_data.dl_phy_chan.sccpch.cctrch_id;

          /* Uplink Physical channel processing */
          /* This is a case for addition of PRACH */
          rrcllc_cmd_under_process.chan_config.phy_chan_action_list.prach_action =
            LLC_PHYCHAN_DROP_AND_ADD;

          WRRC_MSG0_HIGH("LLC_PHYCHAN_DROP_AND_ADD on PRACH bcuz RNTI update");

          (void)rrcllc_add_downlink_phy_chan_to_l1_cmd();
          (void)rrcllc_add_uplink_phy_chan_to_l1_cmd();
        }
      }
    }
  }
  else if (cmd_ptr->cmd.rnti_update_req.urnti_action == RRC_RNTI_DELETE)
  {
    WRRC_MSG0_HIGH("Delete U-RNTI");
    ordered_config_ptr->mac_ul_parms.rnti_info.urnti = 0;
    ordered_config_ptr->mac_dl_parms.rnti_info.urnti = 0;
    current_config_ptr->mac_ul_parms.rnti_info.urnti = 0;
    current_config_ptr->mac_dl_parms.rnti_info.urnti = 0;
    transition_config.toc_ptr->mac_ul_parms.rnti_info.urnti = 0;
    transition_config.toc_ptr->mac_dl_parms.rnti_info.urnti = 0;
    if (config_ptr->mac_ul_parms.rnti_info.rnti_valid == BOTH_VALID)
    {
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = CRNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = CRNTI_VALID;
      current_config_ptr->mac_ul_parms.rnti_info.rnti_valid = CRNTI_VALID;
      current_config_ptr->mac_dl_parms.rnti_info.rnti_valid = CRNTI_VALID;
      transition_config.toc_ptr->mac_ul_parms.rnti_info.rnti_valid = CRNTI_VALID;
      transition_config.toc_ptr->mac_dl_parms.rnti_info.rnti_valid = CRNTI_VALID;
    }
    else if (config_ptr->mac_ul_parms.rnti_info.rnti_valid == URNTI_VALID)
    {
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
      current_config_ptr->mac_ul_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
      current_config_ptr->mac_dl_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
      transition_config.toc_ptr->mac_ul_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
      transition_config.toc_ptr->mac_dl_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
    }

  }
  else
  {
    MSG_LOW("No change required for U-RNTI",0,0,0);
  }

  /* Update MAC if there has been a change in the rnti information */
  if (cmd_ptr->cmd.rnti_update_req.crnti_action == RRC_RNTI_NOCHANGE &&
      cmd_ptr->cmd.rnti_update_req.urnti_action == RRC_RNTI_NOCHANGE)
  {
    MSG_LOW("Don't send the config requests to MAC",0,0,0);
    rrcllc_cmd_under_process.update_mac_with_rnti = FALSE;
  }
  else
  {
    rrcllc_cmd_under_process.update_mac_with_rnti = TRUE;
  }
       /*
         a). Skip size change detection if rlc_re_establish_rab is TRUE as we always re-establish all DATA RBs irrespective
             of size change.
         b). rrcllc_cmd_under_process.update_mac_with_rnti is required because if rlc unrecoverable error happens on SRB then 
             there will be 2 rnti_update_reqs first one to reestablish srbs and second one to update rnti so skip doing size change checks           
             in the first rnti update 
       */

    if ((RRC_PROCEDURE_CU == cmd_ptr->cmd.rnti_update_req.procedure) &&
        (!cmd_ptr->cmd.rnti_update_req.rlc_re_establish_rab) && 
        (rrcllc_cmd_under_process.update_mac_with_rnti == TRUE))
    {
      if(TRUE  == rrcllc_check_and_reestablish_ul_during_rnti_update_req())
      {
        return_substate = LLC_WAIT_RLC_AM_CNF;			  
      }
    }

  /* Send RLC RE-establish depending on which RBs need to be re-established
   * as per RNTI_UPDATE_REQ
   */
  if((cmd_ptr->cmd.rnti_update_req.rlc_re_establish_srb) ||
     (cmd_ptr->cmd.rnti_update_req.rlc_re_establish_rab))
  {
    if( rrcllc_need_to_send_rlc_re_est(cmd_ptr->cmd.rnti_update_req.rlc_re_establish_srb,
                                       cmd_ptr->cmd.rnti_update_req.rlc_re_establish_rab) ==
        TRUE)
    {
        return_substate = LLC_WAIT_RLC_AM_CNF;
    } /* RLC Re-est is not sent */
  } /* RLC RE-establish boolean is TRUE */
  if ((return_substate != LLC_WAIT_RLC_AM_CNF) &&
      (rrcllc_cmd_under_process.update_mac_with_rnti))
  {
    /* Send MAC UL Config request */
    rrcllc_cmac_ul_config_req_for_rnti_update(config_ptr);
    /* Send MAC DL Config request */
    rrcllc_cmac_dl_config_req_for_rnti_update(config_ptr);
  }

  if (rrcllc_cmd_under_process.sccpch_selec_reqd) 
  {
    rrcllc_cphy_setup_req(&rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0]);

    return_substate = LLC_WAIT_CPHY_SETUP_CNF;
  }

  if((return_substate == LLC_IDLE) &&
     (TRUE == cmd_ptr->cmd.rnti_update_req.cnf_required))
  {
    rrcllc_send_rnti_update_cnf(SUCCESS);
  }

  return(return_substate);
}  /* rrcllc_process_rnti_update_req  */


/*====================================================================
FUNCTION: rrcllc_send_cell_transition_req()

DESCRIPTION:
  This function constructs the CPHY_CELL_TRANSITION_REQ primitive and
  sends it to L1.

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_send_cell_transition_req(rrc_state_e_type  curr_rrc_state)
{
  /* local cmd var to send to L1 */
  l1_ext_cmd_type  *transition_req_ptr = NULL;

  transition_req_ptr = l1_get_cmd_buf();

  /* Now send a Cell Transition Request to L1 */
  transition_req_ptr->cmd_hdr.cmd_id = CPHY_CELL_TRANSITION_REQ;
  transition_req_ptr->cmd.cell_trans.cell_trans_params.select_type = L1_ASET_UPD_CELL_RESELECTION;
  transition_req_ptr->cmd.cell_trans.cell_trans_params.tg_freq_excl = FALSE;
  transition_req_ptr->cmd.cell_trans.cell_trans_params.tg_cell_excl = FALSE;
  transition_req_ptr->cmd.cell_trans.cell_trans_params.resel_fail_cause = L1_RESEL_FAIL_CAUSE_NONE;

  transition_req_ptr->cmd.cell_trans.cell_trans_params.cell_type = L1_RESEL_WCDMA;
  transition_req_ptr->cmd.cell_trans.setup_cmd.freq_incl = TRUE;
  transition_req_ptr->cmd.cell_trans.setup_cmd.rf_chan=
    (uint16)rrcllc_cmd_under_process.rrcllc_cell_resel_info.freq;
  transition_req_ptr->cmd.cell_trans.cell_trans_params.scr_code =
    (uint16)rrcllc_cmd_under_process.rrcllc_cell_resel_info.scr_code;
  transition_req_ptr->cmd.cell_trans.setup_cmd.req_mask = 0;
  transition_req_ptr->cmd.cell_trans.setup_cmd.mac_e_reset_indicator = FALSE;
  transition_req_ptr->cmd.cell_trans.setup_cmd.call_type_mask = 0;
  transition_req_ptr->cmd.cell_trans.setup_cmd.l1_rrc_config_rab = RAB_TYPE_NONE;
  transition_req_ptr->cmd.cell_trans.setup_cmd.is_emergency_call = FALSE;
  transition_req_ptr->cmd.cell_trans.setup_cmd.transition_to_dch = FALSE;
  transition_req_ptr->cmd.cell_trans.setup_cmd.dl_phychan_db= NULL;
  transition_req_ptr->cmd.cell_trans.setup_cmd.ul_phychan_db = NULL;
  transition_req_ptr->cmd.cell_trans.setup_cmd.e_info_ptr = NULL;
#ifdef FEATURE_WCDMA_HS_RACH
  transition_req_ptr->cmd.cell_trans.setup_cmd.hs_rach_e_info_ptr = NULL;
#endif

  transition_req_ptr->cmd.cell_trans.setup_cmd.l1_hs_scch_order_action = L1_HS_SCCH_ORDER_ACTION_BACKUP;

 
#ifdef FEATURE_WCDMA_HS_FACH  
  transition_req_ptr->cmd.cell_trans.setup_cmd.signal_dl_mac_at_act_time = FALSE;
  transition_req_ptr->cmd.cell_trans.setup_cmd.signal_ul_mac_at_act_time = FALSE;
  rrcenhstate_add_cell_trans_info(&transition_req_ptr->cmd.cell_trans);
  if(rrcllc_get_hs_status_in_e_fach(reselection_config_ptr) == TRUE)
  {
    transition_req_ptr->cmd.cell_trans.setup_cmd.dl_phychan =
      L1_DL_PHYCHAN_NOCHAN;

    transition_req_ptr->cmd.cell_trans.setup_cmd.dl_phychan_db =
      &reselection_config_ptr->l1_dl_chan_parms;
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch_is_up = FALSE;
  }
  else
#endif
  {
    /* SCCPCH setup through Cell Transition Request */
    transition_req_ptr->cmd.cell_trans.setup_cmd.req_mask|=
      (CPHY_DL_CCTRCH_INCL |
       CPHY_DL_PHYCHAN_ADD_INCL);
  
    transition_req_ptr->cmd.cell_trans.setup_cmd.dl_cctrch_info =
      &reselection_config_ptr->l1_dl_cctrch_parms;
  
    transition_req_ptr->cmd.cell_trans.setup_cmd.dl_phychan =
      L1_DL_PHYCHAN_SCCPCH0;
  
    transition_req_ptr->cmd.cell_trans.setup_cmd.dl_phychan_db =
      &reselection_config_ptr->l1_dl_chan_parms;
  
    transition_req_ptr->cmd.cell_trans.setup_cmd.dl_ctfc_info =
      &reselection_config_ptr->l1_dl_ctfc_parms;
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch_is_up = TRUE;
  }
  if((curr_rrc_state == RRC_STATE_CELL_FACH) ||
     (curr_rrc_state == RRC_STATE_CONNECTING))
  {
    /* Establish PRACH in these states */
    transition_req_ptr->cmd.cell_trans.setup_cmd.req_mask |=
        CPHY_UL_CCTRCH_INCL | CPHY_UL_PHYCHAN_ADD_INCL;
    transition_req_ptr->cmd.cell_trans.setup_cmd.ul_phychan = L1_UL_PHYCHAN_PRACH;
    transition_req_ptr->cmd.cell_trans.setup_cmd.ul_phychan_db =
      &reselection_config_ptr->l1_ul_chan_parms;
    transition_req_ptr->cmd.cell_trans.setup_cmd.ul_cctrch_info =
      &reselection_config_ptr->l1_ul_cctrch_parms;
    transition_req_ptr->cmd.cell_trans.setup_cmd.tfcs_ptr =
      reselection_config_ptr->mac_ul_parms.tfcs_ptr;
#ifdef FEATURE_WCDMA_HS_RACH
      if (reselection_config_ptr->l1_hs_rach_req_mask & (L1_HS_RACH_START |L1_HS_RACH_RECFG|L1_HS_RACH_STOP))
     {
       transition_req_ptr->cmd.cell_trans.setup_cmd.req_mask |= CPHY_HS_RACH_CHAN_CFG_INCL;
       WRRC_MSG1_HIGH("RRCHSRACH: Setting HS RACH req mask 0x%x",transition_req_ptr->cmd.cell_trans.setup_cmd.req_mask);
     }

      if(reselection_config_ptr->mac_hs_rach_action != MAC_HS_RACH_NOOP)
      {
        transition_req_ptr->cmd.cell_trans.setup_cmd.signal_ul_mac_at_act_time = TRUE;
        WRRC_MSG0_HIGH("CPHY_CELL_TRANSITION_REQ: Sig UL MAC");
      }
      
     transition_req_ptr->cmd.cell_trans.setup_cmd.hs_rach_e_info_ptr =
       &reselection_config_ptr->l1_hs_rach_e_info;

     transition_req_ptr->cmd.cell_trans.setup_cmd.common_e_dch_resource_list =
       &reselection_config_ptr->common_e_dch_resource_list;
             
     WRRC_MSG0_HIGH("RRCHSRACH: Including EUL pointer ");

     transition_req_ptr->cmd.cell_trans.setup_cmd.hs_rach_req_mask =
       reselection_config_ptr->l1_hs_rach_req_mask;

     transition_req_ptr->cmd.cell_trans.setup_cmd.hs_rach_e_info_ptr->mac_hsrach_e_reset_indicator =
       reselection_config_ptr->mac_hsrach_e_reset_indicator;;

#endif
  }
  else
  {
    /* For Idle disconnected, init all UL parms */
    transition_req_ptr->cmd.cell_trans.setup_cmd.ul_phychan = L1_UL_PHYCHAN_NONE;
    transition_req_ptr->cmd.cell_trans.setup_cmd.ul_phychan_db = NULL;
    transition_req_ptr->cmd.cell_trans.setup_cmd.ul_cctrch_info = NULL;
  }

    transition_req_ptr->cmd.cell_trans.cell_trans_params.pccpch_tx_div_ind = rrcllc_get_correct_pccpch_tx_diversity_from_sibs(curr_rrc_state);
  /* Clear the N-PCCPCH flag */
  rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch_is_up = FALSE;
#ifdef FEATURE_UPDATE_SIB7_IN_FACH
#ifdef FEATURE_WCDMA_HS_RACH
  if (rrcsib_update_sib7_hs_rach() == TRUE)
#endif
  {
  /*
  Update Semi Permanent data for PCCPCH
  */
  if(rrc_get_state() == RRC_STATE_CELL_FACH)
  {
    rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up = TRUE;
  }
  }
#endif  /*FEATURE_UPDATE_SIB7_IN_FACH*/


  /* Send the cmd - L1 should directly handle it */
  WRRC_MSG1_HIGH("Sending L1 cmd 0x%x", transition_req_ptr->cmd_hdr.cmd_id);
#ifdef FEATURE_WCDMA_HS_FACH
    rrcenhstate_print_cell_transition_req(&transition_req_ptr->cmd.cell_trans);
#ifdef FEATURE_WCDMA_HS_RACH
    if (reselection_config_ptr->l1_hs_rach_req_mask & (L1_HS_RACH_START |L1_HS_RACH_RECFG|L1_HS_RACH_STOP))
    {
      rrchsrach_print_cell_transition_req(&transition_req_ptr->cmd.cell_trans);
    }
#endif
#endif
  WRRC_MSG0_HIGH_OPT("Dispatching out PHY cmd CPHY_CELL_TRANSITION_REQ primitive");
  rrc_send_l1_cmd( transition_req_ptr );

#ifdef FEATURE_RRC_CAPTURE_L1_DEADLOCK
  /* Start timer for L1 deadlock detection */
  rrctmr_start_timer( RRCTMR_L1_DEADLOCK_DETECT_TIMER,
                      RRCTMR_L1_DEADLOCK_DETECT_TIMER_IN_MS );
#endif

} /* rrcllc_send_cell_transition_req */

#ifdef FEATURE_WCDMA_HS_FACH
/*===========================================================================
FUNCTION   rrcllc_build_chan_config_req_cmd_for_est_rbs

DESCRIPTION
  This function is resposible for determining all actions on RLC, MAC
  and L1 when re-entering service area in Cell_FACH state.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
void rrcllc_build_chan_config_req_cmd_for_est_rbs
(
  rrc_cmd_type *cmd_ptr
)
{
  uint32 count=0;
  uint32 urb_count=0;
  uint32 rab_count;
  uint32 rb_count;
  rlc_lc_id_type ul_rlc_lc_id = RRCLCM_RLC_LC_ID_NOT_FOUND;
  rrc_RB_Identity rb_id;

  /*add dcch+dtch RBs in to chan config. Read this info from
       established_rabs variable */
  cmd_ptr->cmd.chan_config_req.rb[count].rb_id = DCCH_UM_RADIO_BEARER_ID;
  cmd_ptr->cmd.chan_config_req.rb[count++].rb_config = RECONFIG_RB;
  cmd_ptr->cmd.chan_config_req.rb[count].rb_id = DCCH_AM_RADIO_BEARER_ID;
  cmd_ptr->cmd.chan_config_req.rb[count++].rb_config = RECONFIG_RB;
  cmd_ptr->cmd.chan_config_req.rb[count].rb_id = DCCH_DT_HIGH_PRI_RADIO_BEARER_ID;
  cmd_ptr->cmd.chan_config_req.rb[count++].rb_config = RECONFIG_RB;
  
  /* check whether RB4 was present or not */
  ul_rlc_lc_id = rrclcm_check_ul_rlc_lc_id(UE_LOGCHAN_DCCH, 
                           DCCH_DT_LOW_PRI_RADIO_BEARER_ID,
                           UE_MODE_ACKNOWLEDGED_DATA);
 
  if(ul_rlc_lc_id == RRCLCM_RLC_LC_ID_NOT_FOUND)
  {
    WRRC_MSG0_HIGH("No RB4 in CELL_FACH");
  }
  else 
  {
    cmd_ptr->cmd.chan_config_req.rb[count].rb_id = DCCH_DT_LOW_PRI_RADIO_BEARER_ID;
    cmd_ptr->cmd.chan_config_req.rb[count++].rb_config = RECONFIG_RB;
  }
  /*setup the user plane RBs also at this time. Do not have to worry about the
       ul transmission as it will not happen until we get a valid C-RNTI in the 
       cell update confirm message */
  for (rab_count=0; rab_count<MAX_RAB_TO_SETUP; rab_count++)
  {
    if (
        ((rrc_est_rabs.rabs[rab_count].cn_domain == RRC_CS_DOMAIN_CN_ID)|| 
        (rrc_est_rabs.rabs[rab_count].cn_domain == RRC_PS_DOMAIN_CN_ID)) && 
        (rrc_est_rabs.rabs[rab_count].num_rbs_for_rab > 0))
    {
      /*it is a valid established rab, now compare each rb-id in this established rab with 
             the rb-id received in the message */
      for (rb_count=0; ((rb_count<rrc_est_rabs.rabs[rab_count].num_rbs_for_rab) && (rb_count<MAX_RB_PER_RAB) && (count<MAX_RB)); rb_count++)
      {
        cmd_ptr->cmd.chan_config_req.rb[count].rb_id = (uint16)
               rrc_est_rabs.rabs[rab_count].rb_for_rab[rb_count].rb_id;
        cmd_ptr->cmd.chan_config_req.rb[count++].rb_config = RECONFIG_RB;
        urb_count++;
      }
    } /*end of if*/
  }/* rab_count loop */
 
  if((rrclcm_get_rb_id_if_dl_lc_type_exists(UE_LOGCHAN_TM_DCCH_DL, &rb_id) == RRCLCM_SUCCESS) && (count<MAX_RB))
  {
    cmd_ptr->cmd.chan_config_req.rb[count].rb_id = (rb_id_type)rb_id;
    cmd_ptr->cmd.chan_config_req.rb[count++].rb_config = RECONFIG_RB;
  }
  cmd_ptr->cmd.chan_config_req.num_rb_to_config = (uint16)count;
 
  cmd_ptr->cmd.chan_config_req.release_phychls = FALSE;
  cmd_ptr->cmd.chan_config_req.release_trchls = FALSE;
  WRRC_MSG2_HIGH("Dispatching RRC_CHANNEL_CONFIG_REQ within LLC / RRC_CHANNEL_CONFIG_REQ to reconfig %dRBs,uplane RBs:%d",
            count,urb_count);
}
#endif


/*===========================================================================
FUNCTION   rrcllc_cell_reselection_within_fach

DESCRIPTION
  This function is resposible for determining all actions on RLC, MAC
  and L1 in response to a Cell Reselection command in CELL_FACH state.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static uecomdef_status_e_type
rrcllc_cell_reselection_within_fach(void)
{
  uint8 cctrch_id;
  int i;
  rrc_proc_e_type proc_id;
  rrcllc_oc_process_state_e_type process_state;
#ifdef FEATURE_WCDMA_HS_FACH
  rrc_cmd_type *cmd_local_ptr = NULL;
  ordered_config_type *prev_config_ptr;
#ifdef FEATURE_WCDMA_HS_RACH
  boolean backup_common_edch_transmission = FALSE;
#endif
#endif

  /* Pointer for reselection. */
  (void)rrcllc_get_ordered_config_state_and_proc_wo_f3(&proc_id, &process_state);
  if(config_ptr_in_use == CURRENT_CONFIG)
  {
    
    /* If Current Config is in use, use OC for Reselection */
    rrcllc_copy_cc_to_oc();
    if(!((proc_id == rlc_size_change_in_progress.proc_id) && 
          (rrc_get_rlc_size_change_status_for_procedure_id(proc_id))))
    {
      rrcllc_init_reestablish_entity(ORDERED_CONFIG_ONLY);
    }

    reselection_config_ptr = ordered_config_ptr;
#ifdef FEATURE_WCDMA_HS_FACH
    prev_config_ptr = current_config_ptr;
#endif
  }
  else if ((config_ptr_in_use == ORDERED_CONFIG) &&
           (ordered_config.process_state == LL_CONFIG_WITH_OC))
  {
    /* If Ordered Config is in use AND Lower layers have been configured
     * with OC data, Copy OC to CC and have reselection_ptr point to CC
     */
    rrcllc_copy_oc_to_cc();
    /* Do not init the re-establish entity if rlc_size_change_status is set by reconfig procedure 
       This is added to take care of cases when OC is set by a reconfig procedure and cell reselection happens
    */
    if(!((proc_id == rlc_size_change_in_progress.proc_id) && 
          (rrc_get_rlc_size_change_status_for_procedure_id(proc_id))))
    {
      rrcllc_init_reestablish_entity(CURRENT_CONFIG_ONLY);
    }

    reselection_config_ptr = current_config_ptr;
#ifdef FEATURE_WCDMA_HS_FACH
    prev_config_ptr = ordered_config_ptr;
#endif
  }
  else
  {
    /* If Ordered Config is in use AND Lower layers have NOT been
     * configured - Reselection Req is not handled in this situation.
     * Should not have come here.
     */
    WRRC_MSG1_ERROR("OC in use, proc rrc_proc_e_type_value%d, LL not config", ordered_config.set_by_proc);
    return(FAILURE);
  }

  /* Notify the SIB procedure about the cell reselection status */
  /* Note: this needs to be done before OC reads any SIBs */
  (void)rrcsib_change_serving_cell_status(TRUE, TRUE,
                                    rrcllc_cmd_under_process.rrcllc_cell_resel_info.plmn_id,
                                    rrcllc_cmd_under_process.rrcllc_cell_resel_info.cell_id);

  /* UPDATE RLC AND MAC ORDERD CONFIG DATA STRUCTURES */
  /* Update the variables in the ordered_config structure */
  if (rrcllc_update_oc_for_resel(RRC_STATE_CELL_FACH) == FAILURE)
  {
    WRRC_MSG0_ERROR("Failure updating OC; In CELL_FACH");
    return(FAILURE);
  }

#ifdef FEATURE_WCDMA_HS_RACH

  /*configure dedicated mode after reselection so that mappings are provided to mac
    if dedicated config fails configure common mode so that CU can be sent*/
  backup_common_edch_transmission = reselection_config_ptr->common_edch_transmission;
  
  if(FAILURE == rrcllc_evaluate_hs_rach_and_set_lower_layers_action(RRC_STATE_CELL_FACH,reselection_config_ptr))
  {
    WRRC_MSG1_HIGH("Dedicated mode configuration of HSRACH failed restore the backed up cedch %d",backup_common_edch_transmission);
    reselection_config_ptr->common_edch_transmission = backup_common_edch_transmission;
  }
  
  /*reset the hsrach action in OC because we are going to determine it again based 
  on reselection ptr*/
  ordered_config_ptr->l1_hs_rach_req_mask = L1_HS_RACH_NO_OP;
  rrcllc_set_hs_rach_action(ordered_config_ptr,MAC_HS_RACH_NOOP);           

  rrcllc_determine_hsrach_action_for_reselection(prev_config_ptr, reselection_config_ptr);
#endif


#ifdef FEATURE_WCDMA_HS_FACH
  if(rrcllc_get_hs_status_in_e_fach(reselection_config_ptr) == FALSE)
  { /* Prepare a Reconfig CCCH command for RLC */
    (void)rrcllc_process_reconfig_ccch();
    (void)rrcllc_process_reconfig_bcch_on_fach();
    /*Decrementing for reselection*/
    ordered_config_ptr->rlc_dl_tm_parms.nchan--;
    if(rrcllc_get_hs_status_in_e_fach(prev_config_ptr) == TRUE)
    { 
      /* Prepare a Reconfig CCCH command for RLC */
      cmd_local_ptr = (rrc_cmd_type *)rrc_malloc(sizeof(rrc_cmd_type));
      rrcllc_build_chan_config_req_cmd_for_est_rbs(cmd_local_ptr);
      if(rrcllc_process_config_dcch_dtch(cmd_local_ptr) == FAILURE)
      {
        (void)rrcllc_build_cmd_and_release_lc_ids();       
        WRRC_MSG0_ERROR("EFACH:config_dcch_dtch eFACH to Legacyresel");
        rrc_free(cmd_local_ptr);
        return(FAILURE);
      }
      rrc_free(cmd_local_ptr);
    }
  }
  else
  {
    (void)rrcenhstate_process_reconfig_ccch();
    (void)rrcenhstate_process_reconfig_bcch_on_hsdsch();
     /*Decrementing for reselection*/
    ordered_config_ptr->rlc_dl_tm_parms.nchan--;
    if(rrcllc_get_hs_status_in_e_fach(prev_config_ptr) == FALSE)
    { 
      WRRC_MSG0_HIGH("EFACH:Legacy to eFACH resel");
    }
    /* CUC may come on SRB1, hence re-configuring only SRB1 here for proper rlc id*/
    cmd_local_ptr = (rrc_cmd_type *)rrc_malloc(sizeof(rrc_cmd_type));
    cmd_local_ptr->cmd.chan_config_req.num_rb_to_config = 1;
    cmd_local_ptr->cmd.chan_config_req.rb[0].rb_id = DCCH_UM_RADIO_BEARER_ID;
    cmd_local_ptr->cmd.chan_config_req.rb[0].rb_config = RECONFIG_RB;
    if(rrcllc_process_config_dcch_dtch(cmd_local_ptr) == FAILURE)
    {
      (void)rrcllc_build_cmd_and_release_lc_ids();     
      WRRC_MSG0_ERROR("EFACH: Reselected to E-FACH cell. SRB1 configuration FAILED ");
      rrc_free(cmd_local_ptr);
      return(FAILURE);
    }
    rrc_free(cmd_local_ptr);
  }
#endif


  /* The Neighbor BCCH/BCH pipes need to be dropped now */
  reselection_config_ptr->mac_dl_parms.num_bchs = 0;

  /* Now drop N_BCCH */
  (void)rrcllc_process_drop_bcch_neighbor();

  if(rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch.cctrch_id !=
   RRCLLC_INVALID_CCTRCH_ID)
  {
    RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                         dl_phy_chan.n_pccpch.cctrch_id);
  }

#ifdef FEATURE_WCDMA_HS_FACH
  if(rrcllc_get_hs_status_in_e_fach(reselection_config_ptr) == FALSE)
#endif
  {
  
    /* SCCPCH Processing */
    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_action =
      LLC_PHYCHAN_SETUP;

    MSG_LOW("LLC_PHYCHAN_SETUP on SCCPCH", 0, 0, 0);

    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf =
      L1_DL_TRCH_REFTYPE_FACH_BF;
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf =
      L1_DL_TRCH_REFTYPE_FACH_BF;
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf &=
      ~L1_DL_TRCH_REFTYPE_PCH_BF;


    /* Now determine if OC has picked an SCCPCH that also carries FACH  */
    if(rrcllc_semi_permanent_data.dl_phy_chan.pch_included == FALSE)
    {
      /* SCCPCH that does not have FACH */
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf &=
        ~L1_DL_TRCH_REFTYPE_PCH_BF;
    }
    else
    {
      /* Fix the transport channel bitmasks for SCCPCH */
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
        L1_DL_TRCH_REFTYPE_PCH_BF;
    }

    /* At this time, both SCCPCH and N_PCCPCH would be up. Add
     * their CCTrCH IDs to the CCTrCH IDs to be released list.
     */
    if(rrcllc_semi_permanent_data.dl_phy_chan.sccpch.cctrch_id !=
       RRCLLC_INVALID_CCTRCH_ID)
    {
      RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                           dl_phy_chan.sccpch.cctrch_id);
    }
    /* Get a new CCTrCH ID */
    cctrch_id = rrcllc_get_cctrch_id();
    if(cctrch_id != RRCLLC_INVALID_CCTRCH_ID)
    {
      /* Update FACH info in MAC Ordered Config */
      for(i = 0; i < reselection_config_ptr->mac_dl_parms.num_fachs; i ++)
      {
        reselection_config_ptr->mac_dl_parms.fach_info[i]->cctrch_id = cctrch_id;
      }

      reselection_config_ptr->mac_dl_parms.pch_info->cctrch_id = cctrch_id;

      /* Update SCCPCH Info in rrcllc_cmd_under_process */
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.cctrch_id =
          cctrch_id;
    }
    else
    {
      WRRC_MSG1_ERROR("Invalid CCTrCH ID %d assigned", cctrch_id);
      return(FAILURE);
    }

    /* The Semi permanent data is all updated now. Copy fields into reselection config */
    reselection_config_ptr->l1_dl_cctrch_parms.trch_enable_bf =
        rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf;

    reselection_config_ptr->l1_dl_cctrch_parms.trch_ref_type_bf =
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf;
 
    reselection_config_ptr->l1_dl_cctrch_parms.cctrch_id =
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.cctrch_id;
  }
  /* Uplink Physical channel processing */
  /* This is a case for addition of PRACH */
  rrcllc_cmd_under_process.chan_config.phy_chan_action_list.prach_action =
    LLC_PHYCHAN_SETUP;

  WRRC_MSG1_HIGH("LLC_PHYCHAN_SETUP on PRACH, backup the RNTI info before reselection %d",
      reselection_config_ptr->mac_dl_parms.rnti_info.rnti_valid);
  rrc_backup_rnti_info =
          reselection_config_ptr->mac_dl_parms.rnti_info ;
         
  /* Delete C-RNTI in OC and CC */
  current_config_ptr->mac_ul_parms.rnti_info.crnti = 0;
  current_config_ptr->mac_dl_parms.rnti_info.crnti = 0;

  /* Invalidate C-RNTI in MAC. U-RNTI to be ivalidated in future. */
  if((current_config_ptr->mac_dl_parms.rnti_info.rnti_valid == BOTH_VALID) ||
       (current_config_ptr->mac_dl_parms.rnti_info.rnti_valid == URNTI_VALID))
  {
    current_config_ptr->mac_dl_parms.rnti_info.rnti_valid = URNTI_VALID;
  }
  else
  {
    current_config_ptr->mac_dl_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
  }
#ifdef FEATURE_WCDMA_HS_FACH
  ordered_config_ptr->efach_hrnti_status = INVALID_HRNTI;
  current_config_ptr->efach_hrnti_status = INVALID_HRNTI;
  transition_config.toc_ptr->efach_hrnti_status = INVALID_HRNTI;
#endif
#ifdef FEATURE_WCDMA_HS_RACH
  /*Delete ERNTI in both CC and OC (L1 and MAC). ERNTI is not valid across reselections*/
  ordered_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = FALSE;
  current_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = FALSE;
  transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = FALSE;
  /*Will add to reset E-rnti for mac also*/
#endif
  /* Invalidate C-RNTI in MAC. U-RNTI to be ivalidated in future. */
  if((current_config_ptr->mac_ul_parms.rnti_info.rnti_valid == BOTH_VALID) ||
       (current_config_ptr->mac_ul_parms.rnti_info.rnti_valid == URNTI_VALID))
  {
    current_config_ptr->mac_ul_parms.rnti_info.rnti_valid = URNTI_VALID;
  }
  else
  {
    current_config_ptr->mac_ul_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
  }

  ordered_config_ptr->mac_ul_parms.rnti_info.crnti = 0;
  ordered_config_ptr->mac_dl_parms.rnti_info.crnti = 0;

  /* Invalidate C-RNTI in MAC. U-RNTI to be ivalidated in future. */
  if((ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid == BOTH_VALID) ||
       (ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid == URNTI_VALID))
  {
    ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = URNTI_VALID;
  }
  else
  {
    ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
  }

  /* Invalidate C-RNTI in MAC. U-RNTI to be ivalidated in future. */
  if((ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid == BOTH_VALID) ||
       (ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid == URNTI_VALID))
  {
    ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = URNTI_VALID;
  }
  else
  {
    ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
  }

#ifdef FEATURE_UPDATE_SIB7_IN_FACH
#ifdef FEATURE_WCDMA_HS_RACH
  if (rrcsib_update_sib7_hs_rach() == TRUE)
#endif
  {
  /* A S-BCCH has to be added in DL; Setup S-PCCPCH */
  rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action =
    LLC_PHYCHAN_SETUP;
  if(rrcllc_update_spccpch_params_based_on_action(reselection_config_ptr)==FAILURE)
  {
    return (FAILURE);
  }
  }
#endif /* FEATURE_UPDATE_SIB7_IN_FACH */


  return(SUCCESS);
} /* rrcllc_cell_reselection_within_fach */


/*===========================================================================
FUNCTION   rrcllc_cell_reselection_within_pch

DESCRIPTION
  This function is resposible for determining all actions on RLC, MAC
  and L1 in response to a Cell Reselection command in CELL_PCH/URA_PCH state.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static uecomdef_status_e_type
rrcllc_cell_reselection_within_pch(rrc_state_e_type state)
{
  uint8 cctrch_id;
  int i;
  rlc_lc_id_type        rlc_dl_log_chl_id; /* RLC downlink logical channel ID */
#ifdef FEATURE_WCDMA_HS_RACH
  ordered_config_type *prev_config_ptr;
#endif
  /* Pointer for reselection. */
  if(config_ptr_in_use == CURRENT_CONFIG)
  {
    /* If Current Config is in use, use OC for Reselection */
    rrcllc_copy_cc_to_oc();
    rrcllc_init_reestablish_entity(ORDERED_CONFIG_ONLY);
    reselection_config_ptr = ordered_config_ptr;
#ifdef FEATURE_WCDMA_HS_RACH
    prev_config_ptr = current_config_ptr;
#endif
  }
  else if ((config_ptr_in_use == ORDERED_CONFIG) &&
           (ordered_config.process_state == LL_CONFIG_WITH_OC))
  {
    /* If Ordered Config is in use AND Lower layers have been configured
     * with OC data, Copy OC to CC and have reselection_ptr point to CC
     */
    rrcllc_copy_oc_to_cc();
    rrcllc_init_reestablish_entity(CURRENT_CONFIG_ONLY);
    reselection_config_ptr = current_config_ptr;
#ifdef FEATURE_WCDMA_HS_RACH
    prev_config_ptr = ordered_config_ptr;
#endif
  }
  else
  {
    /* If Ordered Config is in use AND Lower layers have NOT been
     * configured - Reselection Req is not handled in this situation.
     * Should not have come here.
     */
    WRRC_MSG1_ERROR("OC in use, proc rrc_proc_e_type_value%d, LL not config", ordered_config.set_by_proc);
    return(FAILURE);
  }

  /* Notify the SIB procedure about the cell reselection status */
  /* Note: this needs to be done before OC reads any SIBs */
  (void)rrcsib_change_serving_cell_status(TRUE, TRUE,
                                    rrcllc_cmd_under_process.rrcllc_cell_resel_info.plmn_id,
                                    rrcllc_cmd_under_process.rrcllc_cell_resel_info.cell_id);

  /* UPDATE RLC AND MAC ORDERD CONFIG DATA STRUCTURES */
  /* Update the variables in the ordered_config structure */
  if (rrcllc_update_oc_for_resel(state) == FAILURE)
  {
    WRRC_MSG1_ERROR("Failure updating OC; In %d state", state);
    return(FAILURE);
  }

  if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status == RRCLLC_CTCH_ON_DIF_SCCPCH )
  {
    (void)rrcllc_copy_sib_to_oc_for_sccpch_with_ctch(state);
  }
  /* The Neighbor BCCH/BCH pipes need to be dropped now */
  reselection_config_ptr->mac_dl_parms.num_bchs = 0;

  /* Now drop N_BCCH */
  (void)rrcllc_process_drop_bcch_neighbor();

  /* add, drop, or reconfig ctch based on current cell */
  /* Add PCCH if it was not present before( in case of pch->fach channel
  config failure,else reconfig*/

  /* ctch is present on this cell */
  rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id (
    UE_LOGCHAN_CTCH,
    CTCH_RADIO_BEARER_ID,
    UE_MODE_UNACKNOWLEDGED
    );

  if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status != RRCLLC_NO_CTCH)
  {
    if (rlc_dl_log_chl_id == RRCLCM_RLC_LC_ID_NOT_FOUND)
    {
      (void)rrcllc_process_add_ctch();
    }
    else
    {
      (void)rrcllc_process_reconfig_ctch();
    }
  }
  else
  {
    if (rlc_dl_log_chl_id != RRCLCM_RLC_LC_ID_NOT_FOUND)
    {
      (void)rrcllc_process_drop_ctch();
    }
  }

  /* At this time,N_PCCPCH would be up. Delete the CCTrchId for N-PCCPCH */
  if(rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch.cctrch_id !=
   RRCLLC_INVALID_CCTRCH_ID)
  {
    RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                         dl_phy_chan.n_pccpch.cctrch_id);
  }

    /* SCCPCH Processing */
  rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_action =
    LLC_PHYCHAN_SETUP;

  MSG_LOW("LLC_PHYCHAN_SETUP on SCCPCH", 0, 0, 0);

  rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf &=
    ~L1_DL_TRCH_REFTYPE_FACH_BF;
  rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
    L1_DL_TRCH_REFTYPE_PCH_BF;
  rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf =
    L1_DL_TRCH_REFTYPE_PCH_BF;

  /* Now determine if OC has picked an SCCPCH that also carries FACH  */
  if(rrcllc_semi_permanent_data.dl_phy_chan.pch_included == FALSE)
  {
    WRRC_MSG0_ERROR("PCH should be included");
    /* SCCPCH that does not have FACH */
  }

  /* Now determine if OC has picked an SCCPCH that also carries FACH  */
  if(rrcllc_semi_permanent_data.dl_phy_chan.fach_included == TRUE)
  {
    /* SCCPCH that has FACH */
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf =
      L1_DL_TRCH_REFTYPE_FACH_BF;
  }
  else
  {
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf &=
      ~L1_DL_TRCH_REFTYPE_FACH_BF;
  }


  if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status == RRCLLC_CTCH_WITH_PCCH)
  {
    /* both ctch and pcch are mapped on to same SCCPCH in this case we need to
    enable FACH */
    WRRC_MSG0_HIGH("ctch & pcch on same sccpch");
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf |=
      L1_DL_TRCH_REFTYPE_FACH_BF;
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
      L1_DL_TRCH_REFTYPE_FACH_BF;
  }

  /* At this time, both SCCPCH and N_PCCPCH would be up. Add
   * their CCTrCH IDs to the CCTrCH IDs to be released list.
   */
  if(rrcllc_semi_permanent_data.dl_phy_chan.sccpch.cctrch_id !=
     RRCLLC_INVALID_CCTRCH_ID)
  {
    RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                         dl_phy_chan.sccpch.cctrch_id);
  }
  if(rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch.cctrch_id !=
   RRCLLC_INVALID_CCTRCH_ID)
  {
    RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                         dl_phy_chan.n_pccpch.cctrch_id);
  }

  if(rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.cctrch_id !=
     RRCLLC_INVALID_CCTRCH_ID)
  {
    RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                         dl_phy_chan.sccpch_with_ctch.cctrch_id);
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.cctrch_id = RRCLLC_INVALID_CCTRCH_ID;
     /* there was a separate SCCPCH with  CTCH before this reselection
    Now determine whether to delete this channel or not */
    if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status != RRCLLC_CTCH_ON_DIF_SCCPCH)
    {
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_ref_type_bf = 0;
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_enable_bf = 0;
    }
  }

  /* Get a new CCTrCH ID */
  cctrch_id = rrcllc_get_cctrch_id();
  if(cctrch_id != RRCLLC_INVALID_CCTRCH_ID)
  {
      /* Update FACH info in MAC Ordered Config */
      for(i = 0; i < reselection_config_ptr->mac_dl_parms.num_fachs; i ++)
      {
        reselection_config_ptr->mac_dl_parms.fach_info[i]->cctrch_id = cctrch_id;
      }

    reselection_config_ptr->mac_dl_parms.pch_info->cctrch_id = cctrch_id;

    /* Update SCCPCH Info in rrcllc_cmd_under_process */
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.cctrch_id =
        cctrch_id;
  }
  else
  {
    WRRC_MSG1_ERROR("Invalid CCTrCH ID %d assigned", cctrch_id);
    return(FAILURE);
  }

  /* check whether CTCH needs to be setup and whether
  different sccpch should be used for this CTCH */
  if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status == RRCLLC_CTCH_ON_DIF_SCCPCH)
  {
    WRRC_MSG0_HIGH("Building cmd under process of SCCPCH with CTCH");
    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_for_ctch_action =
      LLC_PHYCHAN_SETUP;

    rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_ref_type_bf =
      L1_DL_TRCH_REFTYPE_FACH_BF;
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_enable_bf =
      L1_DL_TRCH_REFTYPE_FACH_BF;

    if(rrcllc_semi_permanent_data.dl_phy_chan.pch_included_for_sccpch_with_ctch)
    {
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_ref_type_bf |=
        L1_DL_TRCH_REFTYPE_PCH_BF;
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_enable_bf &=
        ~L1_DL_TRCH_REFTYPE_PCH_BF;
    }
    else  /* No PCH on this SCCPCH */
    {
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_ref_type_bf &=
        ~L1_DL_TRCH_REFTYPE_PCH_BF;
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_enable_bf &=
        ~L1_DL_TRCH_REFTYPE_PCH_BF;
    }

  }


  /* The Semi permanent data is all updated now. Copy fields into reselection config */
  reselection_config_ptr->l1_dl_cctrch_parms.trch_enable_bf =
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf;

  reselection_config_ptr->l1_dl_cctrch_parms.trch_ref_type_bf =
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf;

  reselection_config_ptr->l1_dl_cctrch_parms.cctrch_id =
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.cctrch_id;

#ifdef FEATURE_WCDMA_HS_FACH
  ordered_config_ptr->efach_hrnti_status = INVALID_HRNTI;
  current_config_ptr->efach_hrnti_status = INVALID_HRNTI;
  transition_config.toc_ptr->efach_hrnti_status = INVALID_HRNTI;
#endif
#ifdef FEATURE_WCDMA_HS_RACH
  rrcllc_determine_hsrach_action_for_reselection(prev_config_ptr, reselection_config_ptr);
  /*Delete ERNTI in both CC and OC (L1 and MAC). ERNTI is not valid across reselections*/
  ordered_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = FALSE;
  current_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = FALSE;
  transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = FALSE;
#endif


  return(SUCCESS);
} /* rrcllc_cell_reselection_within_pch */


/*===========================================================================
FUNCTION   rrcllc_cell_reselection_within_connecting

DESCRIPTION
  This function is resposible for determining all actions on RLC, MAC
  and L1 in response to a Cell Reselection command in CONNECTING state.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static uecomdef_status_e_type
rrcllc_cell_reselection_within_connecting(void)
{
  uint8 cctrch_id;
  int i;
#ifdef FEATURE_WCDMA_HS_RACH
  ordered_config_type *prev_config_ptr;
#endif

  /* Pointer for reselection. */
  if(config_ptr_in_use == CURRENT_CONFIG)
  {
    /* If Current Config is in use, use OC for Reselection */
    rrcllc_copy_cc_to_oc();
    reselection_config_ptr = ordered_config_ptr;
#ifdef FEATURE_WCDMA_HS_RACH
    prev_config_ptr = current_config_ptr;
#endif
  }
  else if ((config_ptr_in_use == ORDERED_CONFIG) &&
           (ordered_config.process_state == LL_CONFIG_WITH_OC))
  {
    /* If Ordered Config is in use AND Lower layers have been configured
     * with OC data, Copy OC to CC and have reselection_ptr point to CC
     */
    rrcllc_copy_oc_to_cc();
    reselection_config_ptr = current_config_ptr;
#ifdef FEATURE_WCDMA_HS_RACH
    prev_config_ptr = ordered_config_ptr;
#endif

  }
  else
  {
    /* If Ordered Config is in use AND Lower layers have NOT been
     * configured - Reselection Req is not handled in this situation.
     * Should not have come here.
     */
    WRRC_MSG1_ERROR("OC in use, proc rrc_proc_e_type_value%d, LL not config", ordered_config.set_by_proc);
    return(FAILURE);
  }


  /* Notify the SIB procedure about the cell reselection status */
  /* Note: this needs to be done before OC reads any SIBs */
  (void)rrcsib_change_serving_cell_status(TRUE, TRUE,
                                    rrcllc_cmd_under_process.rrcllc_cell_resel_info.plmn_id,
                                    rrcllc_cmd_under_process.rrcllc_cell_resel_info.cell_id);

  /* UPDATE RLC AND MAC ORDERD CONFIG DATA STRUCTURES */
  /* Update the variables in the ordered_config structure */
  if (rrcllc_update_oc_for_resel(RRC_STATE_CONNECTING) == FAILURE)
  {
    WRRC_MSG0_ERROR("Failure updating OC; In CELL_FACH");
    return(FAILURE);
  }
#ifdef FEATURE_WCDMA_HS_FACH
  if(rrcllc_get_hs_status_in_e_fach(reselection_config_ptr) == FALSE)
  {
    /* Prepare a Reconfig CCCH command for RLC */
    (void)rrcllc_process_reconfig_ccch();
  }
  else
  {
    (void)rrcenhstate_process_reconfig_ccch();
  }
#endif
#ifdef FEATURE_WCDMA_HS_RACH
  rrcllc_determine_hsrach_action_for_reselection(prev_config_ptr, reselection_config_ptr);
#endif

  /* The Neighbor BCCH/BCH pipes need to be dropped now */
  reselection_config_ptr->mac_dl_parms.num_bchs = 0;

  /* Now drop N_BCCH */
  (void)rrcllc_process_drop_bcch_neighbor();

  if(rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch.cctrch_id !=
   RRCLLC_INVALID_CCTRCH_ID)
  {
    RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                         dl_phy_chan.n_pccpch.cctrch_id);
  }

#ifdef FEATURE_WCDMA_HS_FACH
  if(rrcllc_get_hs_status_in_e_fach(reselection_config_ptr) == FALSE) 
#endif
  {
    /* SCCPCH Processing */
    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_action =
      LLC_PHYCHAN_SETUP;

    MSG_LOW("LLC_PHYCHAN_SETUP on SCCPCH", 0, 0, 0);

    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf =
      L1_DL_TRCH_REFTYPE_FACH_BF;
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf =
      L1_DL_TRCH_REFTYPE_FACH_BF;
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf &=
      ~L1_DL_TRCH_REFTYPE_PCH_BF;


    /* Now determine if OC has picked an SCCPCH that also carries FACH  */
    if(rrcllc_semi_permanent_data.dl_phy_chan.pch_included == FALSE)
    {
      /* SCCPCH that does not have FACH */
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf &=
        ~L1_DL_TRCH_REFTYPE_PCH_BF;
    }
    else
    {
      /* Fix the transport channel bitmasks for SCCPCH */
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
        L1_DL_TRCH_REFTYPE_PCH_BF;
    }

    /* At this time, both SCCPCH and N_PCCPCH would be up. Add
     * their CCTrCH IDs to the CCTrCH IDs to be released list.
     */
    if(rrcllc_semi_permanent_data.dl_phy_chan.sccpch.cctrch_id !=
       RRCLLC_INVALID_CCTRCH_ID)
    {
      RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                         dl_phy_chan.sccpch.cctrch_id);
    }
    /* Get a new CCTrCH ID */
    cctrch_id = rrcllc_get_cctrch_id();
    if(cctrch_id != RRCLLC_INVALID_CCTRCH_ID)
    {
      /* Update FACH info in MAC Ordered Config */
      for(i = 0; i < reselection_config_ptr->mac_dl_parms.num_fachs; i ++)
      {
        reselection_config_ptr->mac_dl_parms.fach_info[i]->cctrch_id = cctrch_id;
      }

      reselection_config_ptr->mac_dl_parms.pch_info->cctrch_id = cctrch_id;

      /* Update SCCPCH Info in rrcllc_cmd_under_process */
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.cctrch_id =
          cctrch_id;
    }
    else
    {
      WRRC_MSG1_ERROR("Invalid CCTrCH ID %d assigned", cctrch_id);
      return(FAILURE);
    }

    /* The Semi permanent data is all updated now. Copy fields into reselection config */
    reselection_config_ptr->l1_dl_cctrch_parms.trch_enable_bf =
        rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf;

    reselection_config_ptr->l1_dl_cctrch_parms.trch_ref_type_bf =
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf;

    reselection_config_ptr->l1_dl_cctrch_parms.cctrch_id =
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.cctrch_id;
  }
  /* Uplink Physical channel processing */
  /* This is a case for addition of PRACH */
  rrcllc_cmd_under_process.chan_config.phy_chan_action_list.prach_action =
    LLC_PHYCHAN_SETUP;

  MSG_LOW("LLC_PHYCHAN_SETUP on PRACH", 0, 0, 0);

  /* Delete C-RNTI in OC and CC */
  reselection_config_ptr->mac_ul_parms.rnti_info.crnti = 0;
  reselection_config_ptr->mac_dl_parms.rnti_info.crnti = 0;

  /* Invalidate C-RNTI in MAC. U-RNTI to be ivalidated in future. */
  if((reselection_config_ptr->mac_dl_parms.rnti_info.rnti_valid == BOTH_VALID) ||
       (reselection_config_ptr->mac_dl_parms.rnti_info.rnti_valid == URNTI_VALID))
  {
    reselection_config_ptr->mac_dl_parms.rnti_info.rnti_valid = URNTI_VALID;
  }
  else
  {
    reselection_config_ptr->mac_dl_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
  }

  /* Invalidate C-RNTI in MAC. U-RNTI to be ivalidated in future. */
  if((reselection_config_ptr->mac_ul_parms.rnti_info.rnti_valid == BOTH_VALID) ||
       (reselection_config_ptr->mac_ul_parms.rnti_info.rnti_valid == URNTI_VALID))
  {
    reselection_config_ptr->mac_ul_parms.rnti_info.rnti_valid = URNTI_VALID;
  }
  else
  {
    reselection_config_ptr->mac_ul_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
  }
#ifdef FEATURE_WCDMA_HS_FACH
  WRRC_MSG0_HIGH("EFACH: Invalidating HRNTI due to reselection");
  ordered_config_ptr->efach_hrnti_status = INVALID_HRNTI;
  current_config_ptr->efach_hrnti_status = INVALID_HRNTI;
  transition_config.toc_ptr->efach_hrnti_status = INVALID_HRNTI;
#endif
#ifdef FEATURE_WCDMA_HS_RACH
  /*Delete ERNTI in both CC and OC (L1 and MAC). ERNTI is not valid across reselections*/
  ordered_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = FALSE;
  current_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = FALSE;
  /*Will add to reset E-rnti for mac also*/
#endif

  return(SUCCESS);
} /* rrcllc_cell_reselection_within_connecting */


/*===========================================================================
FUNCTION   rrcllc_cell_reselection_within_discon

DESCRIPTION
  This function is resposible for determining all actions on RLC, MAC
  and L1 in response to a Cell Reselection command in Idle-Disconnected state.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static uecomdef_status_e_type
rrcllc_cell_reselection_within_discon(void)
{
  uint8 cctrch_id;
  int i;
  rlc_lc_id_type        rlc_dl_log_chl_id; /* RLC downlink logical channel ID */

  /* In Disconnected state, use OC for Reselection */
  rrcllc_copy_cc_to_oc();
  /* Pointer for reselection. Initially points to the datbase pointed to by OC */
  reselection_config_ptr = ordered_config_ptr;

  /* Notify the SIB procedure about the cell reselection status */
  /* Note: this needs to be done before OC reads any SIBs */
  (void)rrcsib_change_serving_cell_status(TRUE, TRUE,
                                    rrcllc_cmd_under_process.rrcllc_cell_resel_info.plmn_id,
                                    rrcllc_cmd_under_process.rrcllc_cell_resel_info.cell_id);

  /* UPDATE RLC AND MAC ORDERD CONFIG DATA STRUCTURES */
  /* Update the variables in the ordered_config structure */
  if (rrcllc_update_oc_for_resel(RRC_STATE_DISCONNECTED)
        == FAILURE)
  {
    WRRC_MSG0_ERROR("Failure updating OC; In Disconnected");
    return(FAILURE);
  }
  if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status == RRCLLC_CTCH_ON_DIF_SCCPCH )
  {
    (void)rrcllc_copy_sib_to_oc_for_sccpch_with_ctch(RRC_STATE_DISCONNECTED);
  }

  if(reselection_config_ptr->mac_dl_parms.num_pchs == 0)
  {
    WRRC_MSG0_ERROR("SCCPCH with no PCH; In Disconnected");
    return(FAILURE);
  } /* If there is a Reconfig on PCH */
  else
  {
    /* Prepare a Reconfig PCCH command for RLC */
    (void)rrcllc_process_reconfig_pcch();
  }


  /* add, drop, or reconfig ctch based on current cell */
  /* Add PCCH if it was not present before( in case of pch->fach channel
  config failure, else reconfig*/

  rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id(
    UE_LOGCHAN_CTCH,
    CTCH_RADIO_BEARER_ID,
    UE_MODE_UNACKNOWLEDGED
    );
  if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status != RRCLLC_NO_CTCH)
  {
    if (rlc_dl_log_chl_id == RRCLCM_RLC_LC_ID_NOT_FOUND)
    {
      (void)rrcllc_process_add_ctch();
    }
    else
    {
      (void)rrcllc_process_reconfig_ctch();
    }
  }
  else
  {
    if (rlc_dl_log_chl_id != RRCLCM_RLC_LC_ID_NOT_FOUND)
    {
      (void)rrcllc_process_drop_ctch();
    }
  }


  /* The Neighbor BCCH/BCH pipes need to be dropped now */
  reselection_config_ptr->mac_dl_parms.num_bchs = 0;

  /* Now drop N_BCCH */
  (void)rrcllc_process_drop_bcch_neighbor();

  /* SCCPCH Processing */
  rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_action =
    LLC_PHYCHAN_SETUP;

  MSG_LOW("LLC_PHYCHAN_SETUP on SCCPCH", 0, 0, 0);

  rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf =
    L1_DL_TRCH_REFTYPE_PCH_BF;
  rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf =
    L1_DL_TRCH_REFTYPE_PCH_BF;
  rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf &=
    ~L1_DL_TRCH_REFTYPE_FACH_BF;


  /* Now determine if OC has picked an SCCPCH that also carries FACH  */
  if(rrcllc_semi_permanent_data.dl_phy_chan.fach_included == FALSE)
  {
    /* SCCPCH that does not have FACH */
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf &=
      ~L1_DL_TRCH_REFTYPE_FACH_BF;
  }
  else
  {
    /* Fix the transport channel bitmasks for SCCPCH */
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
      L1_DL_TRCH_REFTYPE_FACH_BF;
  }

  if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status == RRCLLC_CTCH_WITH_PCCH)
  {
    /* both ctch and pcch are mapped on to same SCCPCH in this case we need to
    enable FACH */
    WRRC_MSG0_HIGH("ctch & pcch on same sccpch");
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf |=
      L1_DL_TRCH_REFTYPE_FACH_BF;
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
      L1_DL_TRCH_REFTYPE_FACH_BF;
  }

  /* At this time, both SCCPCH and N_PCCPCH would be up. Add
   * their CCTrCH IDs to the CCTrCH IDs to be released list.
   */
  if(rrcllc_semi_permanent_data.dl_phy_chan.sccpch.cctrch_id !=
     RRCLLC_INVALID_CCTRCH_ID)
  {
    RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                         dl_phy_chan.sccpch.cctrch_id);
  }
  if(rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch.cctrch_id !=
   RRCLLC_INVALID_CCTRCH_ID)
  {
    RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                         dl_phy_chan.n_pccpch.cctrch_id);
  }

  if(rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.cctrch_id !=
     RRCLLC_INVALID_CCTRCH_ID)
  {
    RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(rrcllc_semi_permanent_data.
                                         dl_phy_chan.sccpch_with_ctch.cctrch_id);
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.cctrch_id = RRCLLC_INVALID_CCTRCH_ID;
     /* there was a separate SCCPCH with  CTCH before this reselection
    Now determine whether to delete this channel or not */
    if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status != RRCLLC_CTCH_ON_DIF_SCCPCH)
    {
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_ref_type_bf = 0;
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_enable_bf = 0;
    }
  }

  /* Get a new CCTrCH ID */
  cctrch_id = rrcllc_get_cctrch_id();
  if(cctrch_id != RRCLLC_INVALID_CCTRCH_ID)
  {
    /* Update FACH info in MAC Ordered Config */
    for(i = 0; i < reselection_config_ptr->mac_dl_parms.num_fachs; i ++)
    {
      reselection_config_ptr->mac_dl_parms.fach_info[i]->cctrch_id = cctrch_id;
    }

    reselection_config_ptr->mac_dl_parms.pch_info->cctrch_id = cctrch_id;

    /* Update SCCPCH Info in rrcllc_cmd_under_process */
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.cctrch_id =
        cctrch_id;
  }
  else
  {
    WRRC_MSG1_ERROR("Invalid CCTrCH ID %d assigned", cctrch_id);
    return(FAILURE);
  }

  /* The Semi permanent data is all updated now. Copy fields into ordered config */
  reselection_config_ptr->l1_dl_cctrch_parms.trch_enable_bf =
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf;

  reselection_config_ptr->l1_dl_cctrch_parms.trch_ref_type_bf =
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf;

  reselection_config_ptr->l1_dl_cctrch_parms.cctrch_id =
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.cctrch_id;



  /* check whether CTCH needs to be setup and whether
  different sccpch should be used for this CTCH */
  if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status == RRCLLC_CTCH_ON_DIF_SCCPCH)
  {
    WRRC_MSG0_HIGH("Building cmd under process of SCCPCH with CTCH");
    rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_for_ctch_action =
      LLC_PHYCHAN_SETUP;

    rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_ref_type_bf =
      L1_DL_TRCH_REFTYPE_FACH_BF;
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_enable_bf =
      L1_DL_TRCH_REFTYPE_FACH_BF;

    if(rrcllc_semi_permanent_data.dl_phy_chan.pch_included_for_sccpch_with_ctch)
    {
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_ref_type_bf |=
        L1_DL_TRCH_REFTYPE_PCH_BF;
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_enable_bf &=
        ~L1_DL_TRCH_REFTYPE_PCH_BF;
    }
    else  /* No PCH on this SCCPCH */
    {
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_ref_type_bf &=
        ~L1_DL_TRCH_REFTYPE_PCH_BF;
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.trch_enable_bf &=
        ~L1_DL_TRCH_REFTYPE_PCH_BF;
    }


  }

  return(SUCCESS);
} /* rrcllc_cell_reselection_within_discon */


/*====================================================================
FUNCTION: rrcllc_update_cmd_process_data_for_cell_reselection()

DESCRIPTION:
  This function updates all data items in rrcllc_cmd_under_process that
  are relevant to the processing of only RRC_CELL_RESELECTION_REQ.

DEPENDENCIES:
  None
RETURN VALUE:
  None
SIDE EFFECTS:
  None.
====================================================================*/
static uecomdef_status_e_type
rrcllc_update_cmd_process_data_for_cell_reselection(rrc_cmd_type *cmd_ptr)
{
  rrc_state_e_type  current_rrc_state;
  uecomdef_status_e_type status = SUCCESS;

  rrcllc_cmd_under_process.rrcllc_cell_resel_info.freq     = cmd_ptr->cmd.cell_resel_req.freq;
  rrcllc_cmd_under_process.rrcllc_cell_resel_info.scr_code = cmd_ptr->cmd.cell_resel_req.scr_code;
  rrcllc_cmd_under_process.rrcllc_cell_resel_info.plmn_id  = cmd_ptr->cmd.cell_resel_req.plmn_id;
  rrcllc_cmd_under_process.rrcllc_cell_resel_info.cell_id  = cmd_ptr->cmd.cell_resel_req.cell_id;

  current_rrc_state = rrc_get_state();

  /* Go over all possible state changes */
  switch(current_rrc_state)
  {
    case RRC_STATE_DISCONNECTED:
      if(rrcllc_cell_reselection_within_discon() == FAILURE)
      {
        return(FAILURE);
      }
      break;

    case RRC_STATE_CONNECTING:
      /* CCCH reconfig */
      if(rrcllc_cell_reselection_within_connecting() == FAILURE)
      {
        return(FAILURE);
      }

      break;

    case RRC_STATE_CELL_FACH:
      if(rrcllc_cell_reselection_within_fach() == FAILURE)
      {
        return(FAILURE);
      }

      break;

    case RRC_STATE_CELL_PCH:
    case RRC_STATE_URA_PCH:
      if(rrcllc_cell_reselection_within_pch(current_rrc_state) == FAILURE)
      {
        return(FAILURE);
      }

      break;


    case RRC_STATE_CELL_DCH:
      WRRC_MSG0_ERROR("No cell reselection in CELL_DCH");
      status = FAILURE;
      break;

    default:
      WRRC_MSG1_ERROR("Invalid RRC state %d",current_rrc_state);
      status = FAILURE;
      break;
  }

  return(status);
}  /* rrcllc_update_cmd_process_data_for_cell_reselection */


/*===========================================================================
FUNCTION   rrcllc_cell_reselection_engine

DESCRIPTION
 This function is responsible for sending commands to lower layer while processing
 an RRC_CELL_RESELECTION_REQ message. The lower layer commands and their number
 will depend on the current state of RRC. The current LLC state as passed to the
 function helps to decide the next command. The returned value is the next LLC
 state. If LLC_IDLE is sent, it signals the end of processing lower layer commands
 for RRC_CELL_RESELECTION_REQ. In general, the following sequence of commands is
 followed:
 RLC_DL_TM_CONFIG_REQ
 RLC_UL_TM_CONFIG_REQ
 RLC_DL_UM_CONFIG_REQ
 RLC_UL_UM_CONFIG_REQ
 RLC_AM_CONFIG_REQ
 MAC_DL_CONFIG_REQ
 MAC_UL_CONFIG_REQ
 CPHY_SETUP_REQs


DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static uecomdef_status_e_type
rrcllc_cell_reselection_engine(rrcllc_substate_e_type current_substate,
                                 rrcllc_substate_e_type *next_substate)
{
  uint8 i = 0;
  uint8 cctrch_id;
  rrc_state_e_type  curr_rrc_state;
#ifdef FEATURE_UPDATE_SIB7_IN_FACH
  int count=0;
#endif /*FEATURE_UPDATE_SIB7_IN_FACH*/
  if((rrcllc_cmd_under_process.rrc_current_cmd_id != RRC_CELL_RESELECTION_REQ) ||
     (rrcllc_cmd_under_process.valid == FALSE))
  {
    WRRC_MSG0_ERROR("RRCLLC cmd under process not Cell Resel Req");
    return(FAILURE);
  }
  curr_rrc_state = rrc_get_state();
  switch(current_substate)
  {
    case LLC_IDLE:

      /* Send MAC DL Config request */
      rrcllc_cmac_dl_config_req(NO_SYNC_WITH_L1);
#ifdef FEATURE_WCDMA_HS_RACH
      if(reselection_config_ptr->mac_hs_rach_action != MAC_HS_RACH_NOOP)
      {
        WRRC_MSG0_HIGH("RRCHSRACH: wait for L1 signal MAC UL");
        rrcllc_cmac_ul_config_req(RECONFIG_MAC, SYNC_WITH_L1);
      }
      else
#endif
      {
        /* Send a MAC Uplink Config only if so indicated */
        if(rrcllc_semi_permanent_data.send_mac_uplink_config == TRUE)
        {
          /* Send MAC UL Config request */
          rrcllc_cmac_ul_config_req(RECONFIG_MAC, NO_SYNC_WITH_L1);
        }
      }
      rrcllc_send_cell_transition_req(curr_rrc_state);
      *next_substate = LLC_WAIT_CPHY_CELL_TRANSITION_CNF;
      break;

    case LLC_WAIT_CPHY_CELL_TRANSITION_CNF:
      rrcllc_clear_released_cctrch_ids();

      /* check wether we need to send another l1 command to
      release or add or reconfig */
      if (rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_for_ctch_action !=
          LLC_PHYCHAN_NO_OP)
      {

        /* Get a new CCTrCH ID */
        cctrch_id = rrcllc_get_cctrch_id();

        if(cctrch_id != RRCLLC_INVALID_CCTRCH_ID)
        {
          /* Update FACH info in MAC Ordered Config */
          for(i = 0; i < reselection_config_ptr->mac_dl_parms.num_fachs; i ++)
          {
            if (reselection_config_ptr->mac_dl_parms.fach_info[i]->ctch_enable == TRUE)
            {
                reselection_config_ptr->mac_dl_parms.fach_info[i]->cctrch_id = cctrch_id;
            }
          }
          /* Update SCCPCH Info in rrcllc_cmd_under_process */
          rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.cctrch_id = cctrch_id;
        }
        else
        {
          WRRC_MSG1_ERROR("Invalid CCTrCH ID %d assigned", cctrch_id);
          return(FAILURE);
        }

        WRRC_MSG1_HIGH("CPHY_SETUP_REQ for CTCH after resel - %d",curr_rrc_state);
        (void)rrcllc_add_sccpch_with_ctch_to_l1_cmd();

        if(rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req != 0)
        {
          rrcllc_cphy_setup_req(&rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0]);
          *next_substate = LLC_WAIT_CPHY_SETUP_CNF;
        }

        /* reset sccpch_for_ctch_Action once CPHY_SETUP_REQ has be sent */
        rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_for_ctch_action =
          LLC_PHYCHAN_NO_OP;
        break;
      }

     case LLC_WAIT_CPHY_SETUP_CNF:  /*lint !e616  Fall thru from above */

#ifdef FEATURE_UPDATE_SIB7_IN_FACH
#ifdef FEATURE_WCDMA_HS_RACH
      if (rrcsib_update_sib7_hs_rach() == TRUE)
#endif
      {
      /*
      Send CPHY Setup Request for Set up of PCCPCH if the current state is FACH
      */
      if(rrc_get_state()==RRC_STATE_CELL_FACH)
      {
        if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_for_ctch_action !=
            LLC_PHYCHAN_NO_OP)
        {
          rrcllc_cmd_under_process.chan_config.l1_req_list.current_l1_req ++;
        }
  
        count = rrcllc_cmd_under_process.chan_config.l1_req_list.current_l1_req;
        if(count < rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req)
        {
          if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action ==LLC_PHYCHAN_SETUP)
          {
            (void)rrcllc_add_downlink_s_pccpch_setup_to_l1_cmd(reselection_config_ptr);
          }
          if(rrcllc_cmd_under_process.chan_config.l1_req_list.num_l1_req != 0)
          {
            rrcllc_cmd_under_process.chan_config.l1_req_list.current_l1_req ++;
            count= rrcllc_cmd_under_process.chan_config.l1_req_list.current_l1_req;
            rrcllc_cphy_setup_req(&rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[count]);
            rrcllc_cmd_under_process.chan_config.l1_req_list.current_l1_req ++;
            *next_substate = LLC_WAIT_CPHY_SETUP_CNF;
          }
          break;
        }
      }
     }
#endif /*FEATURE_UPDATE_SIB7_IN_FACH*/

      /* All the L1 commands are done. LLC goes back to IDLE substate */
      /* Here, release all CCTrCH IDs since all CPHY_SETUP_REQs have been sent
       * to L1 and their respective Confirmations received.
       */
      WRRC_MSG3_MED("RLC DL TM entities in [CC|OC|TOC]:[%d|%d|%d]", 
        current_config_ptr->rlc_dl_tm_parms.nchan,
        ordered_config_ptr->rlc_dl_tm_parms.nchan,
        transition_config.toc_ptr->rlc_dl_tm_parms.nchan);
      if(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.nchan > 0)
      {
        rrcllc_crlc_dl_tm_config_req(&rrcllc_cmd_under_process.
                                         chan_config.rlc_config_req_list.dl_tm);
        *next_substate = LLC_WAIT_RLC_TM_DL_CNF;
        break;
      }

    case LLC_WAIT_RLC_TM_DL_CNF: /*lint !e616  Fall thru from above */
      if(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.nchan > 0)
      {
        if((rrcllc_crlc_ul_tm_config_req(&rrcllc_cmd_under_process.
                                         chan_config.rlc_config_req_list.ul_tm))
           == FAILURE)
        {
          WRRC_MSG0_ERROR("Could not send RLC UL TM Config Request");
          return(FAILURE);
        }
        *next_substate = LLC_WAIT_RLC_TM_UL_CNF;
        break;
      }

    case LLC_WAIT_RLC_TM_UL_CNF: /*lint !e616  Fall thru from above */
      if(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.nchan > 0)
      {
        rrcllc_crlc_dl_um_config_req(&rrcllc_cmd_under_process.
                                         chan_config.rlc_config_req_list.dl_um);
        *next_substate = LLC_WAIT_RLC_UM_DL_CNF;
        break;
      }

    case LLC_WAIT_RLC_UM_DL_CNF: /*lint !e616  Fall thru from above */
      if(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.nchan > 0)
      {
        rrcllc_crlc_ul_um_config_req(&rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um);
        *next_substate = LLC_WAIT_RLC_UM_UL_CNF;
        break;
      }

    case LLC_WAIT_RLC_UM_UL_CNF: /*lint !e616  Fall thru from above */
      if(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.nentity > 0)
      {
        rrcllc_crlc_am_config_req(&rrcllc_cmd_under_process.
                                      chan_config.rlc_config_req_list.am);
        *next_substate = LLC_WAIT_RLC_AM_CNF;
        break;
      }

    case LLC_WAIT_RLC_AM_CNF: /*lint !e616  Fall thru from above */
      /* No need to register logical channels with RLC
       * since no new logical channels are setup at Reselection time.
       */

      /* Release all Logical channel IDs that need to be released */
#ifdef FEATURE_UPDATE_SIB7_IN_FACH
#ifdef FEATURE_WCDMA_HS_RACH
      if (rrcsib_update_sib7_hs_rach() == TRUE)
#endif
      {
      if(rrc_get_state()==RRC_STATE_CELL_FACH)
      {
        rrcllc_send_rlc_register_dl_srvc_req();
      }
      }
#endif
      rrcllc_release_ul_logical_chl_ids();
      rrcllc_release_dl_logical_chl_ids();
      rrcllc_clear_rlc_info();

      *next_substate = LLC_WAIT_NEW_CELL_IND;
      break;

    default:
      WRRC_MSG1_ERROR("Cmd engine called in LLC state %d", current_substate);
      return(FAILURE);
  } /* switch(curr_state) */

  return(SUCCESS);

} /* rrcllc_cell_reselection_engine */
/*====================================================================
FUNCTION: rrcllc_check_and_send_tvm_cmd_if_needed_for_dch_fach_transition

DESCRIPTION:
  This function checks and sends TVM command to MAC if needed during
  DCH-FACH transition

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_check_and_send_tvm_cmd_if_needed_for_dch_fach_transition()
{
  /* DCH - FACH without CU involved case - send TVM command after 4th channel config 
     DCH - FACH with CU involved - R99 cell - Send TVM command after 4th channel config
     DCH - FACH with CU involved - EFACH cell - Skip after 4th channel config, send after 5th channel config 
  */
  if((RRC_DCH_FACH_TRANISITION_CHANNEL_SETUP == rrcllc_dch_fach_check_channel_setup_skip_status()) ||
      ((TRUE == rrcllc_check_dch_fach_reconfig_status()) &&
       (rrcllc_cmd_under_process.chan_config.chan_config_reason ==
                      RRCLLC_CHAN_CFG_REASON_HS_FACH_COMMON_OPS)))
  {
    rrctvm_process_dch_to_fach();
  }
}

/*====================================================================
FUNCTION: rrcllc_handle_completion_of_chan_config_req()

DESCRIPTION:
  This function does common processing on the completion of a
  Channel Config Req command, when the next LLC state is LLC_IDLE.

DEPENDENCIES:
  None

RETURN VALUE:
  Next LLC substate.

SIDE EFFECTS:
  None.
====================================================================*/
static rrcllc_substate_e_type
rrcllc_handle_completion_of_chan_config_req(void)
{
  rrc_state_e_type  rrc_state;
  rrcllc_substate_e_type  return_substate = LLC_IDLE;
  rrc_cmd_type* llc_stored_cmd_ptr;

  MSG_MED("Sending RRC_CHANNEL_CONFIG_CNF to procedure %d",
                 rrcllc_cmd_under_process.procedure, 0, 0);

  /* Send TVM command to MAC after setting up common channels - CR#762284 */
  rrcllc_check_and_send_tvm_cmd_if_needed_for_dch_fach_transition();

  if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
  {
    if (rrcllc_cmd_under_process.chan_config.hsdpa_inactive_to_active == TRUE)
    {
        rrc_set_hsdpa_status(HSDPA_ACTIVE);

#ifdef FEATURE_WCDMA_HS_FACH
        /*To be on safer side, set HS status in FACH to FALSE here.*/
        rrcllc_set_hs_action_in_e_fach(ordered_config_ptr, HSDPA_NOOP);
#endif /*FEATURE_WCDMA_HS_FACH*/

#ifdef FEATURE_WCDMA_LOG_RRC_STATES
        if(rrc_get_state() == RRC_STATE_CELL_DCH)
        {
          SMEM_LOG_EVENT_EX(SMEM_LOG_AREA_CIRCULAR_POWER, SMEM_LOG_RRC_DCH_STATE_HS_ON, 0, 0, 0, 0);
        }
#endif /*FEATURE_WCDMA_LOG_RRC_STATES*/
    }

    if (rrcllc_cmd_under_process.chan_config.hsdpa_active_to_inactive == TRUE)
    {
        rrc_set_hsdpa_status(HSDPA_INACTIVE);
#ifdef FEATURE_WCDMA_LOG_RRC_STATES
        if(rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_DCH)
        {
          SMEM_LOG_EVENT_EX(SMEM_LOG_AREA_CIRCULAR_POWER, SMEM_LOG_RRC_DCH_STATE, 0, 0, 0, 0);
        }
#endif /*FEATURE_WCDMA_LOG_RRC_STATES*/

#ifdef FEATURE_WCDMA_MIMO
        
          rrcllc_update_mimo_status(RRC_MIMO_INACTIVE);
          rrcllc_init_mimo_params(ordered_config_ptr);
        
#endif/* FEATURE_WCDMA_MIMO*/
#ifdef FEATURE_WCDMA_DC_HSDPA
        rrcllc_init_sec_hsdpa_params(ordered_config_ptr);
#endif /*FEATURE_WCDMA_DC_HSDPA*/
        //Invalidate HRNTI in both CC/OC 
        ordered_config_ptr->hrnti_status = HRNTI_INVALID;
        current_config_ptr->hrnti_status = HRNTI_INVALID;
        ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc = RRCLLC_INVALID_CPICH_SCR_CODE;
        current_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc = RRCLLC_INVALID_CPICH_SCR_CODE;
    }

#ifdef FEATURE_WCDMA_MIMO

           
    if(rrc_get_hsdpa_status()==HSDPA_ACTIVE)
    {
      l1_dl_hs_mimo_action_enum_type mimo_action
        = rrcllc_get_mimo_action_in_config();
      if((mimo_action == L1_MIMO_START) || (mimo_action == L1_MIMO_RECFG) )
      {
        rrcllc_update_mimo_status(RRC_MIMO_ACTIVE);
      }
      else if(mimo_action == L1_MIMO_STOP)
      {
        rrcllc_update_mimo_status(RRC_MIMO_INACTIVE);
      }
    }
#endif/* FEATURE_WCDMA_MIMO*/

  }
#ifdef FEATURE_QSH_EVENT_METRIC
  wrrc_qsh_update_serving_cell_metrics();
  if((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RBE)
     ||
     (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RBR)
     ||
     (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_IHO)
     ||
     (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CHO)
     ||
     (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CU)
     ||
     (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP))
  {
    wrrc_qsh_log_mrab_status(WRRC_METRIC_LOG);
  }
#endif
  if(rrcllc_cmd_under_process.chan_config.cnf_needed)
  {
    (void)rrcllc_send_rrc_channel_config_cnf(rrcllc_cmd_under_process.procedure,
                        rrcllc_cmd_under_process.chan_config_transaction_id,
                                             RRCLLC_CHAN_CFG_SUCCESS);
#ifdef FEATURE_QSH_EVENT_METRIC
     wrrc_qsh_log_aset_params(WRRC_METRIC_UPDATE);
    if((rrcllc_get_ordered_config_status() == OC_SET_FOR_CELL_DCH)
       &&
      (ordered_config_ptr->is_hho == TRUE))
    {
      wrrc_qsh_log_iho_stats(WCDMA_RAT_MOB, WRRC_METRIC_UPDATE);
    }
#endif
  }
#ifdef FEATURE_WCDMA_HS_FACH
  /*For these channel config reasons chan config cnf required flag will be always FALSE. Resetting HS action for these reasons here. */
  else if(rrcllc_cmd_under_process.chan_config.chan_config_reason ==
            RRCLLC_CHAN_CFG_REASON_HS_FACH_DEDICATED_OPS)
  {
    rrcllc_reset_mac_and_l1_for_hsdpa();
  }
#endif

#ifdef FEATURE_WCDMA_HS_RACH
    /* In connecting state reselection started and RRC sent a cphy_setup to
    setup nbch meanwhile rrc connection setup is received to move to DCH state.
    Now OC is set and HSRACH action is set as STOP in OC.
    Now CPHY_SETUP_CNF for NBCH is received which resets the HSRACH action */
  if ((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RCE) ||
      (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RBE) ||
      (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RBRC) ||
      (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RBR) ||
      (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_TCR) ||
      (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_PCR) ||
      (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CU) ||
      (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_ASU) ||
      (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RCR) ||
      (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CHO) ||
      (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_IHO) ||
      (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_LBT) ||
      ((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP) &&
       (rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_RECONFIG_PCH_FACH))
      ||((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)
            &&(rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
            ))
    {
      /*Dont reset the hsrach action in OC for RRCLLC_CHAN_CFG_EPCH_HRNTI_ONLY cause because action in OC because 
      Lower layers are not yet configured with OC*/
      if(rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_EPCH_HRNTI_ONLY)
      {
        rrcllc_reset_mac_and_l1_for_hsrach_config_ptr(current_config_ptr);
      }
      else
      {
        rrcllc_reset_mac_and_l1_for_hsrach(FALSE);
      }
    }
#endif

  /* If a change of state was requested, change the RRC state now */
  rrc_state = rrc_get_state();
  if(rrc_state != rrcllc_cmd_under_process.next_rrc_state)
  {
    /* Go to a state where it waits for a State Change Indication */
    return_substate = LLC_WAIT_FOR_STATE_CHG_IND;

    rrc_initiate_state_change(rrcllc_cmd_under_process.next_rrc_state);

    if((rrc_state == RRC_STATE_DISCONNECTED) &&
       (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CONNECTING))
    {
      rrcllc_clear_ordered_config_now();
    }
    else  if ((rrc_state == RRC_STATE_CELL_FACH) &&
        (OC_SET_FOR_CELL_DCH == rrcllc_get_ordered_config_status_wo_f3()))
    {
      /* set the transition config back to TOC valid for DCH */
      /*fach->dch transtion was successful make TOC as invalid */
      transition_config.toc_usage = TOC_INVALID;
    }
    /*Trashing CPHY_DRX_REQ and CPHY_CELL_PARM_REQ in DCH state and CPHY_CELL_PARM_REQ in FACH state */
    if(l1m_is_connected() || l1m_state_is_fach()) 
    {
      if( (llc_stored_cmd_ptr = (rrc_cmd_type *)q_check(&llc_cmd_q)) != NULL )
      {
        if((llc_stored_cmd_ptr->cmd_hdr.cmd_id == RRC_LLC_CMD_REQ)
          && (llc_stored_cmd_ptr->cmd.rrc_llc_req.cmd_dest == LAYER1_PHY)
          &&(((llc_stored_cmd_ptr->cmd.rrc_llc_req.l1_cmd.cmd_id == CPHY_CELL_PARM_REQ)
          && l1m_is_connected())
          ||(llc_stored_cmd_ptr->cmd.rrc_llc_req.l1_cmd.cmd_id == CPHY_DRX_REQ)))
        {
          rrc_cmd_type *llc_cmd_ptr;
          if(( llc_cmd_ptr = (rrc_cmd_type *) q_get(&llc_cmd_q) )!= NULL)
          {
            WRRC_MSG1_HIGH("Trashing %d L1 cmd, L1 is in DCH or FACH state ",llc_stored_cmd_ptr->cmd.rrc_llc_req.l1_cmd.cmd_id);
            rrcllc_free_cmd_and_embedded_buf(llc_cmd_ptr);
            llc_cmd_ptr = NULL;
          }
        }
      }
    }
  }
  else /* No accompanying State Change */
  {
    if(rrc_state == RRC_STATE_CELL_DCH)
    {
      if(rrcllc_cmd_under_process.chan_config.current_cmd_engine ==
         LLC_RELEASE_TR_PHY_CHAN_ENGINE)
      {
        /* Initialize Ordered and Current Configs maintaining the
         * RRC state */
        rrcllc_init_config_data(ordered_config_ptr, rrc_get_state());
        rrcllc_init_config_data(current_config_ptr, rrc_get_state());

        /* Initialize LLC and initialize Command under process */
        rrcllc_init(RRCLLC_RE_INIT);
        /* Do it for historical reasons */
        rrcllc_swap_oc_and_cc();
      }

      if(rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_LBT)
      {
        rrcllc_clear_ordered_config_now();
      }
      else if((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_IHO) ||
              (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CHO)
#ifdef FEATURE_DUAL_SIM
              ||((rrcllc_cmd_under_process.chan_config.chan_config_reason 
                 == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
              && (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)&&
              (rrccsp_get_curr_scan() == RRC_CSP_UNLOCK_BY_SCAN))
#endif
              )
      {

        WRRC_MSG1_HIGH("DBG_GPS_CELL_ID: Swap OC and CC, proc id rrc_proc_e_type_value%d",
                  rrcllc_cmd_under_process.procedure);
        if((ordered_config.set_status == OC_SET_FOR_CELL_DCH) &&
           (ordered_config.set_by_proc == RRC_PROCEDURE_ASU))
        {
          WRRC_MSG0_HIGH("Keep using OC since it has ASU info");
        }
        else
        {
          /* This must have been G-W resumption case.  Swap OC and CC
           * at this point
           */
          rrcllc_swap_oc_and_cc();
        }
      }
#if(0)
      if(ordered_config.set_status == OC_SET_FOR_DCH_FACH_TRANS)
      {
        /* Do not clear Ordered Config status when that is set for a
         * DCH to FACH transition.
         */
        if((rrcllc_cmd_under_process.procedure != RRC_PROCEDURE_RBE) &&
           (rrcllc_cmd_under_process.procedure != RRC_PROCEDURE_RBR) &&
           (rrcllc_cmd_under_process.procedure != RRC_PROCEDURE_RBRC) &&
           (rrcllc_cmd_under_process.procedure != RRC_PROCEDURE_PCR) &&
           (rrcllc_cmd_under_process.procedure != RRC_PROCEDURE_TCR))
        {
          /* Swap OC and CC ONLY when the procedure for Channel Config Req
           * is NOT RBE, NOT RBR, NOT RBRC, NOT PCRC and NOT TCRC.
           * This is so that the Ordered Config remains
           * in use from the point RBs are added/reconfigured in CELL_FACH till
           * a L2 ack is received.
           */
          rrcllc_swap_oc_and_cc();
        }
      }  /* if(ordered_config.set_status == OC_SET_FOR_DCH_FACH_TRANS) */
#endif
      if((rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_SIB_READ_IN_DCH)&&
          (ordered_config.set_status!=OC_NOT_SET))
      {
        /*AS OC is already Set, and we are using the CC, copy the BCH infor from CC to OC*/
        rrcllc_copy_bch_info_from_cc_to_oc();
        ordered_config_ptr->rlc_dl_tm_parms.nchan = current_config_ptr->rlc_dl_tm_parms.nchan;
        if(rrcllc_cmd_under_process.clear_oc_pending == TRUE)
        {
          /*OC Clearing is pending and the current channel config request is completed so clear the ordered config now*/
          rrcllc_clear_ordered_config_now();
          rrcllc_cmd_under_process.clear_oc_pending = FALSE;
        }
      }
    } /* Within CELL_DCH state */

    else if((rrc_state == RRC_STATE_CELL_FACH) ||
            (rrc_state == RRC_STATE_CELL_PCH)  ||
            (rrc_state == RRC_STATE_URA_PCH))
    {
      if(rrcllc_cmd_under_process.chan_config.solo_bch_operation)
      {
        /* For solo BCH operation, check what needs to be done based
         * on the status of Ordered Config.
         */
        if(config_ptr_in_use == ORDERED_CONFIG)
        {
          if(ordered_config.process_state == LL_NOT_CONFIG_WITH_OC)
          {
            /* Copy relevant BCH data from CC to OC */
            rrcllc_copy_bch_info_from_cc_to_oc();
          }
          else
          {
            /* ordered_config.process_state == LL_CONFIG_WITH_OC */
            /* Copy relevant BCH data from CC to OC */
            rrcllc_copy_bch_info_from_cc_to_oc();
            /* No need to swap here as CC has been used to configure
             * only DL L1 and MAC.
             */
          }

          /* Before leaving check if a pending clear ordered config is present */
          if(rrcllc_cmd_under_process.clear_oc_pending)
          {
            WRRC_MSG0_HIGH("Pending ClearOC during ChanConfig");
            rrcllc_clear_ordered_config_now();
            rrcllc_cmd_under_process.clear_oc_pending = FALSE;
          }
        }
        else
        {
          if((rrcllc_cmd_under_process.clear_oc_pending == TRUE)&&
              (ordered_config.set_status!=OC_NOT_SET))
          {
            WRRC_MSG0_HIGH("Clearing pending OC after SIB config");
            /*AS OC is already Set, and we are using the CC, copy the BCH infor from CC to OC*/
            rrcllc_copy_bch_info_from_cc_to_oc();
            ordered_config_ptr->rlc_dl_tm_parms.nchan = current_config_ptr->rlc_dl_tm_parms.nchan;
            /*OC Clearing is pending and the current channel config request is completed so clear the ordered config now*/
            rrcllc_clear_ordered_config_now();
            rrcllc_cmd_under_process.clear_oc_pending = FALSE;
          }
        }
      } /* Solo BCH operation */
      else
      {
        if(rrcllc_cmd_under_process.chan_config.current_cmd_engine ==
           LLC_RELEASE_TR_PHY_CHAN_ENGINE)
        {
          /* Initialize Ordered and Current Configs maintaining the
           * RRC state */
          rrcllc_init_config_data(ordered_config_ptr, rrc_get_state());
          rrcllc_init_config_data(current_config_ptr, rrc_get_state());

          /* Initialize LLC and initialize Command under process */
          rrcllc_init(RRCLLC_RE_INIT);
          /* Do it for historical reasons */
          rrcllc_swap_oc_and_cc();
        }
        else if ((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CU) &&
                  ((rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_RLC_CONFIG_ONLY)
#ifdef FEATURE_WCDMA_HS_FACH
                    ||(rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_HS_FACH_COMMON_OPS)
                    ||((rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_HS_FACH_DEDICATED_OPS)&&
                       (rrcllc_get_ordered_config_status_wo_f3() == OC_NOT_SET)&&
                       (rrccu_check_if_registered_reconfig_proc_is_successful() != TRUE))
#endif
         ))
        {
          /* do not swap oc and cc because since we have skipped configuring
          mac and l1 the configuration for these two layers is still pointing at
          cc. Just copy oc to cc */
          rrcllc_swap_oc_and_cc();
        }
#ifdef FEATURE_WCDMA_HS_FACH
        // added for spec compliance CR: 4463 - HRNT update via UMI message in EFACH state
        else if ((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_UMI) && rrcenhstate_camped_cell_supports_e_fach() &&
                 (rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_HS_FACH_DEDICATED_OPS) &&
                 (rrcllc_get_ordered_config_status_wo_f3() == OC_NOT_SET) )
        {
          WRRC_MSG0_HIGH("EFACH: procedure UMI");
          rrcllc_swap_oc_and_cc();
        }
#endif
        else if ((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP) &&
          (rrcllc_cmd_under_process.chan_config.chan_config_reason ==
         RRCLLC_CHAN_CFG_REASON_RECONFIG_PCH_FACH))
        {
          if (rrc_state == RRC_STATE_CELL_FACH)
          {
#ifdef FEATURE_WCDMA_HS_RACH
            if(rrcllc_get_sib5_change_in_progress_flag() == CELL_CAP_CHANGED ||
               rrcllc_get_sib5_change_in_progress_flag() == SIB5CHANGE_HSRACH_DELAY_CU)
            {
              ordered_config_ptr->hspa_rnti_stored_cell_pch=FALSE;
            }
#endif
            switch(rrcllc_get_sib5_change_in_progress_flag())
            {
              case SIB5CHANGE_HSRACH_DELAY_CU:
                /*Register with L2 for UL indication in FACH state*/
                rlc_ul_reg_data_ind_in_fach(RLC_REG_DATA_IND_IN_FACH);
                break;
              case CELL_CAP_CHANGED:
                /*Trigger Cell Update immediately if Cell capability changes*/
                rrccu_send_cell_update_initiate_req(RRC_CELL_RESELECTION);
                break;
              case NO_CHANGE_IN_CELL_CAP:
              default:
                break;
            }
          }
          rrcllc_reset_mac_and_l1_for_hsdpa();
          /*Reset the flag to INACTIVE as SIB5 update is completed*/
          rrcllc_clear_sib5_change_in_progress_flag();

#ifdef FEATURE_WCDMA_HS_RACH
          /*Reset the hspa_rnti flag when we move from a hsrach to legacy cell*/
          if((rrc_state == RRC_STATE_CELL_PCH) && (rrchsrach_camped_cell_supports_hsrach() == FALSE))
          {
            ordered_config_ptr->hspa_rnti_stored_cell_pch=FALSE;
            WRRC_MSG1_HIGH("RRCHSRACH Clearing hspa_rnti_stored_cell_pch in OC %d ",ordered_config_ptr->hspa_rnti_stored_cell_pch);
          }
#endif

          rrcllc_swap_oc_and_cc();
          /* Send a cell change ind to BMC after SIB mod ind */
          if((rrc_state == RRC_STATE_CELL_PCH) || (rrc_state == RRC_STATE_URA_PCH))
          {
            rrcbmc_send_rrc_new_cell_ind_message();
          }
        }
        else if (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CCM)
        {
          if (rrcllc_cmd_under_process.chan_config.chan_config_reason ==
               RRCLLC_CHAN_CFG_REASON_RE_ENTERING_SERVICE)
          {
            rrcllc_swap_oc_and_cc();
          }
          else if (rrcllc_cmd_under_process.chan_config.chan_config_reason ==
               RRCLLC_CHAN_CFG_REASON_WITHIN_FACH)
          {
            rrcllc_swap_oc_and_cc();
          }
        }
        else if(rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_LBT)
        {
          rrcllc_clear_ordered_config_now();
        }
        else if(((rrcllc_cmd_under_process.chan_config.chan_config_reason 
                                                    == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
                 && (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)) 
                || rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CHO)
        {
          rrcllc_swap_oc_and_cc();
          if((rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
              && (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)&&
              ((rrcllc_get_ordered_config_status_wo_f3() == OC_SET_FOR_FACH_CELL_PCH_TRANS) || (rrcllc_get_ordered_config_status_wo_f3() == OC_SET_FOR_FACH_URA_PCH_TRANS)))
      	  {
            /* when OC is set for FACH to PCH transition and IRAT reselecction fails,
               we try to resume. In this case, we allocate a new CCTRCH id and it is present in CC at this point.
               Once L2 ACK is received, when we try to configure lower layeres for PCH,
               we configure from OC. So we copy the cctrch id from CC to OC to make sure 
               that we free the latest cctrch id and allocate a new one */
            ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.cctrch_id = current_config_ptr->l1_hsdpa_info.hs_dsch_info.cctrch_id;            
          }

          if (((rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
               && (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)) &&
              OC_SET_FOR_CELL_DCH == rrcllc_get_ordered_config_status_wo_f3()) 
          {
            /* Chan_config_req is in the Q to take UE to DCH.  OC has the correct info for DCH 
             * Transition so set the config ptr in use to OC.
             */
            WRRC_MSG0_HIGH("OC set for DCH.  setting config otr to OC");
            /* Set the config_ptr_in_use to OC since Chan_config_req to take UE to DCH is expected*/
            config_ptr_in_use = ORDERED_CONFIG;
          }
        }
        /* Procedure will call clear ordered config on a L2 Ack */
      }
    } /* Within CELL_FACH state */

    else if((rrc_state == RRC_STATE_DISCONNECTED) ||
             (rrc_state == RRC_STATE_CONNECTING))
    {
      if(rrcllc_cmd_under_process.chan_config.solo_bch_operation)
      {
        /* For solo BCH operation, check what needs to be done based
         * on the status of Ordered Config.
         */
        if(config_ptr_in_use == ORDERED_CONFIG)
        {
          if(ordered_config.process_state == LL_NOT_CONFIG_WITH_OC)
          {
            /* Copy relevant BCH data from CC to OC */
            rrcllc_copy_bch_info_from_cc_to_oc();
          }
          else
          {
            WRRC_MSG0_ERROR("LL config in Cnctng/Discon");
          }
          /* No need to check for pending clear ordered config
           * in Connecting or Disconnected state
           */
        } /* OC is in use */
        else /* CC is in use */
        {
          /* Do nothing - lower layers have been configured with CC already */
        }
      } /* Solo BCH operation */
      else if ((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP) &&
        (rrcllc_cmd_under_process.chan_config.chan_config_reason ==
       RRCLLC_CHAN_CFG_REASON_RECONFIG_PCH_FACH))
      {
        rrcllc_clear_sib5_change_in_progress_flag();
        /* do not swap oc and cc because since we have skipped configuring
        mac and l1 the configuration for these two layers is still pointing at
        cc. Just copy oc to cc */
#ifdef FEATURE_WCDMA_HS_FACH
        if((rrcllc_get_hs_status_in_e_fach(current_config_ptr) == FALSE) && 
            ((( (rrcenhstate_camped_cell_supports_e_fach() == TRUE) && 
                   rrc_state == RRC_STATE_CELL_FACH) &&
                   (rrcllc_check_if_hs_can_be_started_reconfigured_in_e_fach(
                           ordered_config_ptr,rrcllc_cmd_under_process.next_rrc_state,RRC_E_FACH_DEDICATED) == FALSE)))
         )
        {
          /*SIB5 change: from legacy to efach support, Initiate CU*/
          rrccu_send_cell_update_initiate_req(RRC_CELL_RESELECTION);
          rrcllc_reset_mac_and_l1_for_hsdpa();
        }
#endif

        rrcllc_swap_oc_and_cc();
        if(rrc_state == RRC_STATE_DISCONNECTED)
        {
          /* Send a cell change ind to BMC after SIB mod ind */
          rrcbmc_send_rrc_new_cell_ind_message();
        }
      }
      else
      {
        rrcllc_clear_ordered_config_now();
      }
    } /* Within Disconnected or Connecting state */
  } /* No accompanying state change */

  return(return_substate);
} /* rrcllc_handle_completion_of_chan_config_req */


/*===========================================================================
FUNCTION   rrcllc_re_est_rlc_engine

DESCRIPTION
 This function is responsible for sending commands to lower layer while processing
 an RRC_LLC_RE_EST_RLC_REQ message. The lower layer commands and their number
 will depend on the current state of RRC. The current LLC state as passed to the
 function helps to decide the next command. The returned value is the next LLC
 state. In general, the following sequence of commands is followed:
 RLC_DL_UM_CONFIG_REQ
 RLC_UL_UM_CONFIG_REQ
 RLC_AM_CONFIG_REQ
 MAC_DL_CONFIG_REQ
 MAC_UL_CONFIG_REQ
 RLC_RESUME_REQ


DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.
===========================================================================*/
static uecomdef_status_e_type
rrcllc_re_est_rlc_engine(rrcllc_substate_e_type current_substate,
                                 rrcllc_substate_e_type *next_substate)
{
  if((rrcllc_cmd_under_process.rrc_current_cmd_id != RRC_LLC_RE_EST_RLC_REQ) ||
     (rrcllc_cmd_under_process.valid == FALSE))
  {
    WRRC_MSG0_ERROR("RRCLLC cmd under process not Re Est RLC Req");
    return(FAILURE);
  }

  switch(current_substate)
  {
    case LLC_WAIT_RLC_UM_DL_CNF:
      if(rlc_ul_um_config_for_re_est.nchan > 0)
      {
        rrcllc_crlc_ul_um_config_req(&rlc_ul_um_config_for_re_est);
        *next_substate = LLC_WAIT_RLC_UM_UL_CNF;
        break;
      }

    case LLC_WAIT_RLC_UM_UL_CNF: /*lint !e616  Fall thru from above */
      if(rlc_am_config_for_re_est.nentity > 0)
      {
        rrcllc_crlc_am_config_req(&rlc_am_config_for_re_est);
        *next_substate = LLC_WAIT_RLC_AM_CNF;
        break;
      }

    case LLC_WAIT_RLC_AM_CNF: /*lint !e616  Fall thru from above */
      if(rrcllc_cmd_under_process.rlc_re_est_rbs == RRC_RE_EST_RB_2)
      {
        (void)rrcllc_send_re_est_rlc_cnf();
        *next_substate = LLC_IDLE;
      }
      else
      {
        /* Send RLC re-establish confirm to SMC */
        (void)rrcllc_send_re_est_rlc_cnf();

        *next_substate = LLC_IDLE;
      }
      break;

    default:
      WRRC_MSG1_ERROR("Cmd engine called in LLC state %d", current_substate);
      return(FAILURE);
  } /* switch(curr_state) */

  return(SUCCESS);

} /* rrcllc_re_est_rlc_engine */

/*********************************************************************
**                      LLC State Handlers
**
**********************************************************************/

/*====================================================================
FUNCTION: rrcllc_process_stop_lower_layer_req()

DESCRIPTION:
  This function processes the RRC_STOP_LOWER_LAYER_REQ command and calls
  LLC_WCDMA_MODE_DEACT_ENGINE.

DEPENDENCIES:
  None

RETURN VALUE:
  Next LLC state.

SIDE EFFECTS:
  None.
====================================================================*/
static rrcllc_substate_e_type rrcllc_process_stop_lower_layer_req(rrc_cmd_type *cmd_ptr)
{
  rrc_state_e_type  rrc_state;
  rrcllc_substate_e_type  rrcllc_next_substate = LLC_IDLE;

  rrcllc_update_generic_cmd_process_data(cmd_ptr);
  rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_STOP_WCDMA_MODE_ENGINE;

  if(rrcllc_command_engine(rrcllc_current_substate, &rrcllc_next_substate)
  == FAILURE)
  {
    ERR_FATAL("RRC Config request processing failure", 0, 0, 0);
  }

  if(rrcllc_next_substate == LLC_IDLE)
  {

    /* This implies no more lower layer commands are to be sent */
    /* Send a RRC_STOP_LOWER_LAYER_CNF back to the procedure and
    * change RRC state
    */
    MSG_MED("Sending RRC_STOP_LOWER_LAYER_CNF", 0, 0, 0);
    (void)rrcllc_send_rrc_stop_lower_layer_cnf();

    /* If a change of state was requested, change the RRC state now */
    rrc_state = rrc_get_state();

    if(rrc_state != RRC_STATE_DISCONNECTED)
    {
      /* This procesiing only when next state is Disconnected */
      rrc_initiate_state_change(RRC_STATE_DISCONNECTED);

      /* Set LLC state back to LLC_WAIT_FOR_STATE_CHG_IND to waut for Release Confirm */
      rrcllc_clear_config_all_db();
      /* Get out of here */
      rrcllc_next_substate = LLC_IDLE;
      if(rrc_state == RRC_STATE_CONNECTING)
      {
        WRRC_MSG0_ERROR("Resolved OOS and RCE race condition");
      }
    }
    else /* Next and current state - both disconnected or next state NOT disconnected (not possible ?) */
    {
      /* Initialize Ordered and Current Configs */
      rrcllc_init_ordered_config_status_and_data(RRC_STATE_DISCONNECTED);
      rrcllc_init_config_data(current_config_ptr, RRC_STATE_DISCONNECTED);

      /* Clear RLC Logical Channel Info in LCM */
      rrclcm_clear_rlc_lc_info();
      /* Initialize LLC and initialize Command under process */
      rrcllc_init(RRCLLC_RE_INIT_FREE_Q);
      /* Get out of here */
      rrcllc_next_substate = LLC_IDLE;

    } /* next RRC state is not different than current one */
  }

  return rrcllc_next_substate;
} /* rrcllc_process_stop_lower_layer_req */

/*====================================================================
FUNCTION: rrcllc_process_deactivate_req()

DESCRIPTION:
  This function processes the RRC_LOWER_LAYER_DEACT_REQ command and calls
  LLC_WCDMA_MODE_DEACT_ENGINE.

DEPENDENCIES:
  None

RETURN VALUE:
  Next LLC state.

SIDE EFFECTS:
  None.
====================================================================*/
static rrcllc_substate_e_type rrcllc_process_deactivate_req(rrc_cmd_type *cmd_ptr)
{
  rrcllc_substate_e_type  rrcllc_next_substate = LLC_IDLE;

  rrcllc_update_generic_cmd_process_data(cmd_ptr);
  rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_DEACT_ENGINE;
  
  if(rrcllc_command_engine(rrcllc_current_substate, &rrcllc_next_substate)
     == FAILURE)
  {
    ERR_FATAL("RRC Config request processing failure", 0, 0, 0);
  }

  if(rrcllc_next_substate == LLC_IDLE)
  {
    /* This implies no more lower layer commands are to be sent */
    /* Send a RRC_LOWER_LAYER_DEACT_CNF back to the procedure and
     * change RRC state
     */
  
    WRRC_MSG0_HIGH("Sending RRC_LOWER_LAYER_DEACT_CNF");
    (void)rrcllc_send_rrc_lower_layer_deact_cnf();

    /* Initialize LLC here with a Free Queue initialization type */
    rrcllc_init(RRCLLC_RE_INIT_FREE_Q);
  }

  return rrcllc_next_substate;
}/* rrcllc_process_deactivate_req */

/*====================================================================
FUNCTION: rrcllc_rrc_mode_standby_handler()

DESCRIPTION:
  This function is a handler for commands received by LLC when RRC mode
  is STANDBY. Commands received are enqueued in LLC internal queue and
  are processed only if RRC mode becomes ACTIVE again. If a WCDMA mode is
  stopped the internal LLC queue is cleared.

DEPENDENCIES:
  None

RETURN VALUE:
  Next LLC state.

SIDE EFFECTS:
  None.
====================================================================*/
static rrcllc_substate_e_type rrcllc_rrc_mode_standby_handler (rrc_cmd_type *cmd_ptr)
{
  rrcllc_substate_e_type  rrcllc_next_substate = LLC_IDLE;

  switch(cmd_ptr->cmd_hdr.cmd_id)
  {
    case RRC_LLC_CMD_REQ:
      /* Process CPHY_RESUME_WCDMA_MODE_REQ and CPHY_SUSPEND_WCDMA_MODE_REQ in this mode
       * We need to handle CPHY_SUSPEND_WCDMA_MODE_REQ here as MCM changes RRC mode to
       * RRC_MODE_STANDBY before sending CPHY_SUSPEND_WCDMA_MODE_REQ
       */
      if(cmd_ptr->cmd.rrc_llc_req.cmd_dest == LAYER1_PHY)
      {
        if(cmd_ptr->cmd.rrc_llc_req.l1_cmd.cmd_id == CPHY_RESUME_WCDMA_MODE_REQ ||
           cmd_ptr->cmd.rrc_llc_req.l1_cmd.cmd_id == CPHY_SUSPEND_WCDMA_MODE_REQ ||
           /*GO TO SLEEP needs to be processed the scenarios where
                  1. BPLMN search timer expired and GO TO SLEEP is sent to suspend the search(l1 in BPLMN_PCH state)
                  2. RRC immediately releases the lock causing a MODE change indication to SUSPEND to be sent,RRC mode is updated to SUSPEND
                  3. LLC queue has GO_TO_SLEEP indication followed by the suspend request 
                  */
           cmd_ptr->cmd.rrc_llc_req.l1_cmd.cmd_id == CPHY_GO_TO_SLEEP_IND) 
        {
          /* Initialize Command under process data before processing the command */
          rrcllc_init_cmd_under_process_data();
          rrcllc_update_generic_cmd_process_data(cmd_ptr);
          rrcllc_next_substate = rrcllc_process_funneled_cmd_req(cmd_ptr);
        }
        else
        {
          WRRC_MSG1_HIGH("%d cmd enqueued in LLC during Standby",
                       cmd_ptr->cmd.rrc_llc_req.l1_cmd.cmd_id);
          /* Enqueue the command in LLC internal queue */
          (void)rrcllc_put_cmd_on_queue(cmd_ptr);
        }
      }
      else
      {
        WRRC_MSG1_HIGH("%d cmd enqueued in LLC during Standby",
                     cmd_ptr->cmd.rrc_llc_req.l1_cmd.cmd_id);
        /* Enqueue the command in LLC internal queue */
        (void)rrcllc_put_cmd_on_queue(cmd_ptr);
      }
      break;

    case RRC_STOP_LOWER_LAYER_REQ:
      rrcllc_next_substate = rrcllc_process_stop_lower_layer_req(cmd_ptr);
      break;

    case RRC_LOWER_LAYER_DEACT_REQ:
      WRRC_MSG0_HIGH("Lower layer deactivation being processed in standby state");
      rrcllc_next_substate = rrcllc_process_deactivate_req(cmd_ptr);
      break;

    case RRC_CMAC_STATUS_IND:
      /* Update RACH tx stats here */
      if(cmd_ptr->cmd.cmac_status_ind == MAX_RACH_CYCLES_REACHED)
      {
        /*MAC has hit MAX RACH transmission cycle, so update RACH tx parameters count here*/
        RRC_DEBUG_INCREMENT_STATS(RACH_RRC_RETRY_FAIL_DUE_TO_CMAC_STATUS_IND);
      }
      MSG_MED("No processing for CMAC_STATUS_IND",0,0,0);
      break;
    
    case RRC_CHANNEL_CONFIG_REQ:
      if( cmd_ptr->cmd.chan_config_req.procedure == RRC_PROCEDURE_ASU )
      {
        WRRC_MSG0_HIGH("Received Chan Config Req for ASU in Standby State");
        (void)rrcllc_send_rrc_channel_config_cnf(RRC_PROCEDURE_ASU,
                                           cmd_ptr->cmd.chan_config_req.transaction_id,
                                           RRCLLC_CHAN_CFG_FAILURE_INCOMPATIBLE_STATE);
      }
      else if (rrcmcm_get_substate() == RRCMCM_WAIT_SUSPEND_CNF)
      {

        /* For the scenario PCCPCH setup/drop is triggered due to cell id in dch feature
        while moving to standby state ignore the channel config request. LLC behavior 
        is inconsistent because it is processing BCCH drop but requeuing the BCCH add
        leading to issue later */
        if((rrc_get_state() == RRC_STATE_CELL_DCH) &&
          (cmd_ptr->cmd.chan_config_req.chan_config_reason == RRCLLC_CHAN_CFG_REASON_SIB_READ_IN_DCH) &&
          (cmd_ptr->cmd.chan_config_req.rb[0].rb_id == BCCH_S_RADIO_BEARER_ID ) &&
                 ((cmd_ptr->cmd.chan_config_req.rb[0].rb_config == RELEASE_RB)||
                 (cmd_ptr->cmd.chan_config_req.rb[0].rb_config == ESTABLISH_RB)))
        {
          WRRC_MSG0_HIGH("Ignore the S-BCCH setup/Drop in Standby mode");
        }
        /* handle this command in Standby State only between the window when
           the MCM module has submitted the SUSPEND req to LLC, and it is still
           present in LLC queue and not being processed. So if any Chan Config 
           is present in LLC queue before the Susped req is processed, then LLC 
           should act on that Chan Config Req.
           Chan Config Req should not be acted on by LLC, when L1 is already in Suspend
           state, so in that case just queue it.
         */
        else if((cmd_ptr->cmd.chan_config_req.rb[0].rb_id == BCCH_S_RADIO_BEARER_ID ||
                  cmd_ptr->cmd.chan_config_req.rb[0].rb_id == BCCH_N_RADIO_BEARER_ID) &&
                 (cmd_ptr->cmd.chan_config_req.rb[0].rb_config == RELEASE_RB))
        {
          WRRC_MSG0_HIGH("Act on  S-BCCH/N-BCCH Drop");
          rrcllc_init_cmd_under_process_data();
          rrcllc_next_substate = rrcllc_process_chan_config_request(cmd_ptr);
        }
        else if(cmd_ptr->cmd.chan_config_req.procedure == RRC_PROCEDURE_CSP &&
                cmd_ptr->cmd.chan_config_req.release_trchls &&
                cmd_ptr->cmd.chan_config_req.release_phychls)
        {
          WRRC_MSG0_HIGH("Process Released Phy and Tr Chls in RRC Standby Mode");
          rrcllc_init_cmd_under_process_data();
          rrcllc_next_substate = rrcllc_process_chan_config_request(cmd_ptr);
        }
        /* For the scenario of inter-RAT redirection via RRC connection release message, handle chan_config
           to release all channels before triggering redirection. */
        else if((cmd_ptr->cmd.chan_config_req.procedure == RRC_PROCEDURE_CSP) &&
                 (cmd_ptr->cmd.chan_config_req.next_state == RRC_STATE_DISCONNECTED) &&
                 (RRC_STATE_DISCONNECTED != rrc_get_state())&&
                 (RRC_CSP_INTER_RAT_REDIRECTION_SCAN == rrccsp_get_curr_scan()) &&
                 ((rrcrcr_is_proc_active())
        #ifdef FEATURE_WCDMA_FAST_RETURN_TO_LTE_AFTER_CSFB 
        /* For the scenario where transition to disconnected due to RCE/CU
           and fast return to LTE happenning simultaneously*/
                  ||(csfb_extended_status != CSFB_INVALID)
        #endif
        ))
        {
          WRRC_MSG0_HIGH("Process Release All Channels in RRC Standby Mode");
          rrcllc_init_cmd_under_process_data();
          rrcllc_next_substate = rrcllc_process_chan_config_request(cmd_ptr);
        }
        else
        {
          WRRC_MSG1_HIGH("%d cmd enqueued in LLC during Standby", cmd_ptr->cmd_hdr.cmd_id);
          /* Enqueue the command in LLC internal queue */
          (void)rrcllc_put_cmd_on_queue(cmd_ptr);
        }
      }
      else
      {
        WRRC_MSG1_HIGH("%d cmd enqueued in LLC during Standby", cmd_ptr->cmd_hdr.cmd_id);
        /* Enqueue the command in LLC internal queue */
        (void)rrcllc_put_cmd_on_queue(cmd_ptr);
      }
      break;

    case RRC_RESET_L1_REQ:
      if (rrcmcm_get_substate() == RRCMCM_WAIT_SUSPEND_CNF)
      {
       /* handle this command in Standby State only between the window when
          the MCM module has submitted the SUSPEND req to LLC, and it is still
          present in LLC queue and not being processed. So if any Reset Req 
          is present in LLC queu before the Susped req is processed, then LLC 
          should act on that Reset Req.
          L1 Reset Req should not be acted on by LLC, when L1 is already in Suspend
          state, so in that case just queue it.
        */
        WRRC_MSG0_HIGH("Process L1 reset request in RRC Standby Mode");
        rrcllc_init_cmd_under_process_data();
        rrcllc_update_generic_cmd_process_data(cmd_ptr);
        rrcllc_cphy_idle_req();
        rrcllc_next_substate = LLC_WAIT_CPHY_IDLE_CNF;
      }
      else
      {
        WRRC_MSG1_HIGH("%d cmd enqueued in LLC during Standby", cmd_ptr->cmd_hdr.cmd_id);
        /* Enqueue the command in LLC internal queue */
        (void)rrcllc_put_cmd_on_queue(cmd_ptr);
      }
      break;
      
    default:
      WRRC_MSG1_HIGH("%d cmd enqueued in LLC during Standby", cmd_ptr->cmd_hdr.cmd_id);
      /* Enqueue the command in LLC internal queue */
      (void)rrcllc_put_cmd_on_queue(cmd_ptr);
      break;
  }

  return rrcllc_next_substate;

}


/*====================================================================
FUNCTION: rrcllc_idle_handler()

DESCRIPTION:
  This function is a handler for LLC_IDLE state and takes care of
  all incoming commands and Confirms from RRC procedures, MAC,
  RLC and L1.

DEPENDENCIES:
  None

RETURN VALUE:
  Next LLC state.

SIDE EFFECTS:
  None.
====================================================================*/
rrcllc_substate_e_type rrcllc_idle_handler(rrc_cmd_type *cmd_ptr)
{

  rrc_state_e_type  rrc_state;

  rrcllc_substate_e_type  rrcllc_next_substate = LLC_IDLE;

  rrc_mode_e_type   rrc_mode;
  /* Change RRC substate here to Idle to prevent any scenario where
   * a command is processed in idle_handler when LLC state is non Idle. That
   * can lead to an Err Fatal.
   */
   rrcllc_current_substate = LLC_IDLE;

  /* Should already be reset in the CHAN_CONFIG_ENGINE. But just ensuring that */
  rrcllc_rlc_cipher_update_needed = FALSE;

  MSG_MED("Cmd 0x%x recvd in LLC_IDLE",
                          cmd_ptr->cmd_hdr.cmd_id, 0, 0);

  /* If RRC mode is STANDBY, enqueue the command in LLC internal queue.
   * This command(s) will be processed if we come back to active
   */

 rrc_mode = rrcmcm_get_rrc_mode();

 if(rrc_mode != RRC_MODE_STANDBY)
 {

  /* Initialize Command under process data in preparation for the
   * processing of incoming command
   */
  rrcllc_init_cmd_under_process_data();

  switch(cmd_ptr->cmd_hdr.cmd_id)
  {
    case RRC_CHANNEL_CONFIG_REQ:
      {
        rrcllc_next_substate = rrcllc_process_chan_config_request(cmd_ptr);
      }
      break;

    case RRC_LOWER_LAYER_DEACT_REQ:
      {
        rrcllc_update_generic_cmd_process_data(cmd_ptr);
        rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_DEACT_ENGINE;
        if(rrcllc_command_engine(rrcllc_current_substate, &rrcllc_next_substate)
        == FAILURE)
        {
          ERR_FATAL("RRC Config request processing failure", 0, 0, 0);
        }

        if(rrcllc_next_substate == LLC_IDLE)
        {
          /* This implies no more lower layer commands are to be sent */
          /* Send a RRC_LOWER_LAYER_DEACT_CNF back to the procedure and
          * change RRC state
          */
          MSG_MED("Sending RRC_LOWER_LAYER_DEACT_CNF", 0, 0, 0);
          (void)rrcllc_send_rrc_lower_layer_deact_cnf();

          /* Initialize LLC here with a Free Queue initialization type */
          rrcllc_init(RRCLLC_RE_INIT_FREE_Q);
        }
      }
      break;

    case RRC_RESET_L1_REQ:
      rrcllc_update_generic_cmd_process_data(cmd_ptr);
      rrcllc_cphy_idle_req();
      rrcllc_next_substate = LLC_WAIT_CPHY_IDLE_CNF;
      break;

    case RRC_LLC_CMD_REQ:
      rrcllc_update_generic_cmd_process_data(cmd_ptr);
      rrcllc_next_substate = rrcllc_process_funneled_cmd_req(cmd_ptr);
      break;

    case RRC_RNTI_UPDATE_REQ:
      rrcllc_update_generic_cmd_process_data(cmd_ptr);
      rrcllc_next_substate = rrcllc_process_rnti_update_req(cmd_ptr);

      break;

    case RRC_CELL_RESELECTION_REQ:
      if((ordered_config.set_status != OC_NOT_SET) &&
         (ordered_config.process_state == LL_NOT_CONFIG_WITH_OC) &&
         (config_ptr_in_use == ORDERED_CONFIG))
      {
        /* Ordered Config is SET -AND-
         * Lower layers have not been configured -AND -
         * config_ptr_in_use is OC
         *   Enqueue Reselection Req till Lower Layers are configured with OC
         */
        /*If UE is waiting for L2 ACK during FACH to PCH transition and Cell Reselec Req 
              is received, send reselec cnf failure back to CSP.*/
        if((rrcccm_waiting_for_reselection_cnf()) && (((ordered_config.set_status == OC_SET_FOR_FACH_CELL_PCH_TRANS)||
            (ordered_config.set_status == OC_SET_FOR_FACH_URA_PCH_TRANS))&&
            ((RRCRB_WAIT_FOR_L2_ACK == rrcrb_get_proc_sub_state(ordered_config.set_by_proc)) ||
            (RRCCU_WAIT_FOR_L2_ACK == rrccu_return_cu_substate())))
            )
        {
          (void)rrcllc_send_rrc_cell_reselection_cnf(FAILURE);
        }
        else  if(( (rrc_cmd_type *)q_check(&llc_cmd_q) ) != NULL)
        {
          /* i.e. if there is alreasy one cmd in LLC cmd queue */
          (void)rrcllc_put_cmd_on_queue(cmd_ptr);
          MSG_HIGH("Queuing Resel OC rrcllc_oc_set_status_e_type_value%d status %d procstate proc rrc_proc_e_type_value%d proc",
                     ordered_config.set_status, ordered_config.process_state,
                     ordered_config.set_by_proc);
        }
        else
        {
          rrc_cmd_type   *rrc_out_cmd_ptr;
          rrc_out_cmd_ptr = rrc_get_int_cmd_buf();
            rrc_out_cmd_ptr->cmd_hdr.cmd_id = cmd_ptr->cmd_hdr.cmd_id;
            WCDMA_MEMCPY(&rrc_out_cmd_ptr->cmd,
                         sizeof(rrc_cmd_data_u_type),
                         &cmd_ptr->cmd, 
                         sizeof(rrc_cmd_int_q_u_type));
            /* Send the Internal cmd to RRC */
            WRRC_MSG1_HIGH("Re-Post cmd to internal q  cmd id %d ", 
                    cmd_ptr->cmd_hdr.cmd_id);
            rrc_put_int_cmd( rrc_out_cmd_ptr );
          }
      }
      else
      {
        WRRC_MSG0_HIGH("Rxed CELL_RESELECTION_REQ from CCM");
        rrc_log_nv_status();
        rrc_log_feature_state_variables_status(current_config_ptr);

        if(ordered_config.set_status != OC_NOT_SET)
        {
          WRRC_MSG2_HIGH("OC status: rrcllc_oc_set_status_e_type_value%d Cfg in use: %d, proc resel",
                   ordered_config.set_status, config_ptr_in_use);
        }

        rrc_state = rrc_get_state();
        /* First check if CCM still wants to proceed with reselection */
        if((rrcccm_waiting_for_reselection_cnf())&&((rrcllc_get_ordered_config_status_wo_f3() == OC_SET_FOR_CELL_DCH) ||
           (rrc_state == RRC_STATE_CELL_DCH)))
        {
          /* Reselection should not be honored in CELL_DCH state or if there is an on-going Reconfig
           * which is taking us to CELL_DCH state
           */
          (void)rrcllc_send_rrc_cell_reselection_cnf(FAILURE);
        }
        else
        {
          rrcllc_update_generic_cmd_process_data(cmd_ptr);
          rrcllc_cmd_under_process.chan_config.current_cmd_engine  = LLC_CELL_RESELECTION_ENGINE;

          if(rrcllc_update_cmd_process_data_for_cell_reselection(cmd_ptr) == SUCCESS)
          {
            if((RRCLLC_COMMAND_ENGINE(rrcllc_current_substate, &rrcllc_next_substate) == FAILURE))
            {
              ERR_FATAL("RRC Config request processing failure", 0, 0, 0);
            }

            if(rrcllc_next_substate == LLC_WAIT_NEW_CELL_IND)
            {
              /* A swapping ensures the data space used to configure lower layers
               * for reselection will not be used for configuration in the next
               * reconfiguration. If CC was used for reselection, a L2 Ack will
               * make CC point to that data space again, ensuring the above condition.
               */
              rrcllc_swap_oc_and_cc();


              /* First check if CCM still wants to proceed with reselection */
              if(rrcccm_waiting_for_reselection_cnf() == FALSE)
              {
                /* No need to send a CNF, nobody is waiting for it */
                rrcllc_next_substate = LLC_IDLE;
              }
              else
              {
                /* Processing of Cell Reselection request succeeded
                 * Send a Cell Reselection Confirm with a Success to the requesting procedure
                 */
                (void)rrcllc_send_rrc_cell_reselection_cnf(SUCCESS);
              }
            }
          }
          else
          {
            /* Updating of Cell Reselection command data failed */
            /* Send a Cell Reselection Confirm with a failure to the requesting procedure */
            /* Clear any newly allocated lc ids here as update cmd under process failed */
             rrcllc_build_cmd_and_release_lc_ids ();
            (void)rrcllc_send_rrc_cell_reselection_cnf(FAILURE);
          }
        }
      } /* OC is not set -OR- config_ptr_in_use NOT OC -OR-
         * OC process state LL_CONFIG_WITH_OC
         */
      break;

    case RRC_ABORT_CIPH_CONFIG_REQ:
      WRRC_MSG1_HIGH("Received RRC_ABORT_CIPH_CONFIG_REQ from SMC in Idle substate,Action:%d",
                 cmd_ptr->cmd.rrc_abort_ciph_config_req.abort_action);

      switch (cmd_ptr->cmd.rrc_abort_ciph_config_req.abort_action)
      {
        case RRC_ABORT_CIPH_ACTION_L1KEY_RLC_RESUME:
        {
          /* Send commands to L1 */
          (void)rrcllc_cphy_ciphering_key_req();

          /* Send abort cipher command to RLC */
          rrcllc_send_crlc_abort_ciph_req();

          /* Resume any suspended RBs */
          rrcllc_resume_rlc_due_to_ciph_abort();
          break;
        }

        default:
        {
          WRRC_MSG1_ERROR("Unexpected action: %d requested from SMC  for ABORTing Cipher Config",
                cmd_ptr->cmd.rrc_abort_ciph_config_req.abort_action);
          break;
        }
      }
    break;

    case RRC_LLC_RE_EST_RLC_REQ:
      WRRC_MSG0_HIGH("Rxed RLC RE EST REQ from SMC");
      rrcllc_update_generic_cmd_process_data(cmd_ptr);
      rrcllc_cmd_under_process.chan_config.current_cmd_engine = LLC_RE_EST_RLC_ENGINE;
      rrcllc_next_substate = rrcllc_process_re_est_rlc_req(cmd_ptr);
      break;

    case RRC_STOP_LOWER_LAYER_REQ:
#ifdef FEATURE_WRLF_SYSTEM_SEL
      if(RRC_IS_CONN_MODE_OOS_SRCH_IN_PROGRESS())
      {
        WRRC_MSG0_HIGH("Rcvd RRC_STOP_LOWER_LAYER_REQ");
        rrcllc_update_generic_cmd_process_data(cmd_ptr);
        /* Send a CPHY_STOP_WCDMA_MODE_REQ */
        rrcllc_cphy_stop_wcdma_mode_req();
        rrcllc_next_substate = LLC_WAIT_CPHY_STOP_WCDMA_MODE_CNF;
      }
      else
#endif
      {
        rrcllc_next_substate = rrcllc_process_stop_lower_layer_req(cmd_ptr);
      }
      break;

    case RRC_CPHY_COMPRESSED_MODE_IND:
      if (rrcllc_modify_cm_info_in_current_config(&cmd_ptr->cmd.cm_ind) == SUCCESS)
      {
        rrcllc_send_compressed_mode_run_time_error_ind(&cmd_ptr->cmd.cm_ind);
      }
      break;

    case RRC_CIPH_CONFIG_REQ:
      WRRC_MSG0_HIGH("Rcv'd RRC_CIPH_CONFIG_REQ from SMC");
      rrcllc_cmd_under_process.procedure = RRC_PROCEDURE_SMC;
      (void)rrcllc_update_ciphering_config_info(cmd_ptr->cmd.rrc_ciph_config_req.config_cause);
      rrcllc_next_substate = LLC_IDLE;
      break;

#ifdef FEATURE_RRC_L1_ERROR_RECOVERY_P1
    case RRC_CPHY_OPERATIONAL_ERROR_IND:
    WRRC_MSG1_ERROR("Error src type = %d",cmd_ptr->cmd.op_err_ind.src);

      rrc_state = rrc_get_state();
      if(rrc_state == RRC_STATE_DISCONNECTED)
      {
        if(rrc_csp_bplmn_srch_in_progress () != WTOW_SEARCH_STOP || rrccsp_is_gtow_bplmn_srch_in_progress() != FALSE)
        {
          ERR_FATAL("Error recovery is NOT supported when BPLMN is underway",0,0,0);
        }
        else
        {
          /* Start recovery procedure */
          /* Send a CPHY_STOP_WCDMA_MODE_REQ */
          rrcllc_cmd_under_process.wcdma_stop_cause = L1_RAT_CHANGE;
          rrcllc_cmd_under_process.err_recovery_in_progress = TRUE;
          rrcllc_cphy_stop_wcdma_mode_req();
          rrcllc_next_substate = LLC_WAIT_CPHY_STOP_WCDMA_MODE_CNF;
        }
      }
      else
      {
        WRRC_MSG1_ERROR("Ignoring OPER_ERR_IND in RRC state %d",rrc_state);
      }
      break;
#endif
  case RRC_CONN_MODE_DEEP_SLEEP_REQ:  
    WRRC_MSG0_HIGH("Rcvd RRC_CONN_MODE_DEEP_SLEEP_REQ");
    rrcllc_update_generic_cmd_process_data(cmd_ptr);
    /* Send a CPHY_STOP_WCDMA_MODE_REQ */
    rrcllc_cphy_stop_wcdma_mode_req();
    rrcllc_next_substate = LLC_WAIT_CPHY_STOP_WCDMA_MODE_CNF;
    break;


  case RRC_CONN_MODE_DEEP_SLEEP_WAKEUP_REQ:
    WRRC_MSG0_HIGH("Rcvd RRC_CONN_MODE_DEEP_SLEEP_WAKEUP_REQ");
    rrcllc_update_generic_cmd_process_data(cmd_ptr);
    /* Send START_WCDMA_MODE_REQ and wait for confirmation from L1 */
    rrcllc_cphy_start_wcdma_req();
    rrcllc_next_substate = LLC_WAIT_CPHY_START_WCDMA_MODE_CNF;
    break;
    default:
      WRRC_MSG1_HIGH("Cmd rrc_cmd_e_type_value_0x%x not expected in LLC_IDLE", cmd_ptr->cmd_hdr.cmd_id);
      break;

  } /* switch(cmd_ptr->cmd_hdr.cmd_id) */
 }
 else
 {
   /* Handle commands in Standby mode */
   rrcllc_next_substate = rrcllc_rrc_mode_standby_handler(cmd_ptr);
 }


 return(rrcllc_next_substate);
} /* rrcllc_idle_handler */

/*====================================================================
FUNCTION: rrcllc_wait_cphy_act_time_canc_cnf_handler()

DESCRIPTION:
  This function is a handler for LLC_WAIT_CPHY_ACT_TIME_CANC_CNF state and
  takes care of all incoming commands and Confirms from RRC procedures,
  MAC, RLC and L1.

DEPENDENCIES:
  None

RETURN VALUE:
  Next LLC state.

SIDE EFFECTS:
  None.
====================================================================*/
static rrcllc_substate_e_type rrcllc_wait_cphy_act_time_canc_cnf_handler(rrc_cmd_type *cmd_ptr)
{
  uint8   cctrch_id;      
  rrcllc_oc_process_state_e_type  process_state;  
  rrc_proc_e_type proc_id;
  rrcllc_substate_e_type  rrcllc_next_substate = LLC_IDLE;
  
  switch(cmd_ptr->cmd_hdr.cmd_id)
  {
    case RRC_CPHY_ACT_CANCEL_CNF:
#ifdef FEATURE_RRC_CAPTURE_L1_DEADLOCK
      /* Stop timer for L1 deadlock detection */
      rrctmr_stop_timer( RRCTMR_L1_DEADLOCK_DETECT_TIMER );
#endif

#ifdef FEATURE_RRC_DELAY_ERR_FATAL
      /* Stop Delay Err Fatal timer if started*/
      if (rrctmr_get_remaining_time(RRCTMR_DELAY_ERR_FATAL_TIMER) > 0) 
      {
        rrctmr_stop_timer(RRCTMR_DELAY_ERR_FATAL_TIMER);
        WRRC_MSG0_ERROR("Stopped Delay Err Fatal timer in SETUP_CNF");
      }
      
#endif /*FEATURE_RRC_DELAY_ERR_FATAL*/            
      WRRC_MSG1_HIGH("Rcv'd RRC_CPHY_ACT_CANCEL_CNF from L1: %d", 
               cmd_ptr->cmd.setup_cnf.status);
      
    if(cmd_ptr->cmd.act_cancel_cnf.status == TRUE)
    {
      WRRC_MSG1_HIGH("L1 cleared pending cmd seq num %d", cmd_ptr->cmd.act_cancel_cnf.seq_num);
      /* build the command to release LC_IDs if they are established in this channel config */
      (void)rrcllc_get_ordered_config_state_and_proc_wo_f3(&proc_id, &process_state);
      rrc_funneled_cmd_cnf(cmd_ptr, RRC_PROCEDURE_CU, cmd_ptr->cmd_hdr.cmd_id);
      rrcllc_next_substate = LLC_IDLE; 

      (void)rrcllc_build_cmd_and_release_lc_ids();

#ifdef FEATURE_UMTS_PDCP
      if (rrcllc_cmd_under_process.chan_config.pdcp_config_req_list.num_rbs > 0) 
      {
        rrcllc_cmd_under_process.chan_config.pdcp_config_req_list.num_rbs = 0;
        WRRC_MSG0_HIGH("Skipping the PDCP Config due to going back to old config.");
      }
#endif /* FEATURE_UMTS_PDCP */
  
      /* Clear newly allocated CCTrCH instead of CCTrCH that's already in the
       *  release list. This is because L1 is yet to commit to the new CCTrCH.
       */
      cctrch_id = rrcllc_semi_permanent_data.dl_phy_chan.dl_dpch.cctrch_id;
       
      WRRC_MSG1_HIGH("DCH->DCH ACT CANC. Putting old CCTrCH id in semi perm: %d ",rrcllc_cmd_under_process.
               chan_config.cctrch_id_release_list.num_ids);
        
      rrcllc_semi_permanent_data.dl_phy_chan.dl_dpch.cctrch_id = 
        rrcllc_cmd_under_process.chan_config.cctrch_id_release_list.id[0];
               
      
      rrcllc_cmd_under_process.chan_config.cctrch_id_release_list.num_ids = 0;
      if (cctrch_id != RRCLLC_INVALID_CCTRCH_ID)
      {
        RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(cctrch_id);
      }
      else
      {
        WRRC_MSG1_ERROR("cctrch_id %d to release is invalid ",cctrch_id);
      }
      /* Clear any CCTRCH IDs in the Release list */
      rrcllc_clear_released_cctrch_ids();
      if(ordered_config_ptr->dest_freq_present)
      {
        rrcsmc_revert_to_old_cipher_config_db(); 
      }
      (void)rrcllc_send_rrc_channel_config_cnf(proc_id,
        rrcllc_cmd_under_process.chan_config_transaction_id,
        RRCLLC_CHAN_CFG_FAILURE_CFG_CANCELLED);
    }
    else
    {
      WRRC_MSG1_HIGH("L1 failed ACT CANC seq num %d, Can not handle the failure", cmd_ptr->cmd.act_cancel_cnf.seq_num);
      rrcllc_self_enqueue_channel_config_to_idle();
    }
    break;
    
    case RRC_CPHY_COMPRESSED_MODE_IND:
      if (rrcllc_modify_cm_info_in_current_config(&cmd_ptr->cmd.cm_ind) == SUCCESS)
      {
        rrcllc_send_compressed_mode_run_time_error_ind(&cmd_ptr->cmd.cm_ind);
      }
      break;
  case RRC_CPHY_SETUP_CNF:
    WRRC_MSG0_HIGH("Received CPHY_SETUP_CNF in ACT canc state going to idle");
    rrcllc_self_enqueue_channel_config_to_idle();
    break;

    case RRC_LLC_CMD_REQ:
    case RRC_STOP_LOWER_LAYER_REQ:
    case RRC_RNTI_UPDATE_REQ:
    case RRC_RESET_L1_REQ:
    case RRC_LOWER_LAYER_DEACT_REQ:
    case RRC_CHANNEL_CONFIG_REQ:
    case RRC_CELL_RESELECTION_REQ:
    case RRC_ABORT_CIPH_CONFIG_REQ:
    case RRC_CIPH_CONFIG_REQ:
      if(( ((uint32) cmd_ptr->cmd_hdr.cmd_id) & CMD_BASE_MASK ) == (uint32)RRC_INT_CMD_BASE)
      {
        (void)rrcllc_put_cmd_on_queue(cmd_ptr);
        MSG_MED("RRC Internal cmd recvd", 0, 0, 0);
      }
      break;
    default:
      WRRC_MSG1_ERROR("Cmd 0x%x not expected in LLC_WAIT_CPHY_ACT_TIME_CANC_CNF",
                                   cmd_ptr->cmd_hdr.cmd_id);
    break;
    
  }
  return rrcllc_next_substate;
}
        
#ifdef FEATURE_DUAL_SIM
/*====================================================================
FUNCTION: rrc_send_no_resource_available_from_l1_to_csp()

DESCRIPTION:
  This function posts NO_RESOURCE_AVAILABLE_FROM_L1 command to 
  internal command queue.

DEPENDENCIES:
  None

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrc_send_no_resource_available_from_l1_to_csp()
{
  /* local cmd var to send confirm back to RRC procs */
  rrc_cmd_type *cmd_ptr = rrc_get_int_cmd_buf();

  cmd_ptr->cmd_hdr.cmd_id = RRC_NO_RESOURCE_AVAILABLE_FROM_L1;
  rrc_put_int_cmd(cmd_ptr);
  return;
}
#endif

/*====================================================================
FUNCTION: rrcllc_wait_cphy_setup_cnf_handler()

DESCRIPTION:
  This function is a handler for LLC_WAIT_CPHY_SETUP_CNF state and
  takes care of all incoming commands and Confirms from RRC procedures,
  MAC, RLC and L1.

DEPENDENCIES:
  None

RETURN VALUE:
  Next LLC state.

SIDE EFFECTS:
  None.
====================================================================*/
static rrcllc_substate_e_type rrcllc_wait_cphy_setup_cnf_handler(rrc_cmd_type *cmd_ptr)
{
  rrc_state_e_type  rrc_state = rrc_get_state();
  /* RLC downlink logical channel ID */
  rlc_lc_id_type    rlc_dl_log_chl_id;
  rlc_lc_id_type    rlc_ul_log_chl_id;
  rrcllc_substate_e_type  rrcllc_next_substate = LLC_WAIT_CPHY_SETUP_CNF;
  rrc_cmd_type* llc_stored_cmd_ptr;
  uint8   cctrch_id= RRCLLC_INVALID_CCTRCH_ID;
  uint8 i;


  MSG_MED("Cmd 0x%x recvd in LLC_WAIT_CPHY_SETUP_CNF",
                          cmd_ptr->cmd_hdr.cmd_id, 0, 0);
#ifdef FEATURE_DUAL_SIM
  if(cmd_ptr->cmd_hdr.cmd_id == RRC_CPHY_SETUP_CNF &&
     cmd_ptr->cmd.setup_cnf.status == FALSE &&
     cmd_ptr->cmd.setup_cnf.status_type == L1_SETUP_STATUS_WRM_LOCK_FAIL)
  {
    WRRC_MSG1_HIGH("DSIM: CPHY_SETUP failed with casue %d, send RRC_NO_RESOURCE_AVAILABLE_FROM_L1 to CSP",cmd_ptr->cmd.setup_cnf.status_type);
    cmd_ptr->cmd.setup_cnf.status_type = L1_SETUP_STATUS_VALIDATION_FAIL;
    rrc_send_no_resource_available_from_l1_to_csp();
	   if((rrc_get_state()== RRC_STATE_DISCONNECTED) && 
       (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_DISCONNECTED) &&
       (rrcllc_cmd_under_process.chan_config.solo_bch_operation == TRUE) &&
       (rrcllc_cmd_under_process.chan_config.phy_chan_action_list.n_pccpch_action == LLC_PHYCHAN_RELEASE) &&
       (rrcllc_cmd_under_process.chan_config.current_cmd_engine == LLC_CHAN_CONFIG_ENGINE))
    {
      /* NBCH drop failed. Don't send cell_transition failure to L1 */
      /* Assumption here is that next command in LLC queue is cell transition req */
      if( (llc_stored_cmd_ptr = (rrc_cmd_type *)q_check(&llc_cmd_q)) != NULL )
      {
        
        if((llc_stored_cmd_ptr->cmd_hdr.cmd_id == RRC_LLC_CMD_REQ)
          && (llc_stored_cmd_ptr->cmd.rrc_llc_req.cmd_dest == LAYER1_PHY)
         &&(llc_stored_cmd_ptr->cmd.rrc_llc_req.l1_cmd.cmd_id == CPHY_CELL_TRANSITION_REQ))
        {
          rrc_cmd_type *llc_cmd_ptr;
          if(( llc_cmd_ptr = (rrc_cmd_type *) q_get(&llc_cmd_q) )!= NULL)
          {
            WRRC_MSG0_HIGH("Trash CPHY_CELL_TRANSITION_REQ after NBCH drop fails due to no lock");
            rrcllc_free_cmd_and_embedded_buf(llc_cmd_ptr);
            llc_cmd_ptr = NULL;
          }

        }
        llc_stored_cmd_ptr = NULL;
      }
    }
  }
#endif

  switch(cmd_ptr->cmd_hdr.cmd_id)
  {
    case RRC_CPHY_SETUP_CNF:
      WRRC_MSG1_HIGH("Rcv'd RRC_CPHY_SETUP_CNF from L1: %d", 
               cmd_ptr->cmd.setup_cnf.status);

#ifdef FEATURE_RRC_CAPTURE_L1_DEADLOCK
      /* Stop timer for L1 deadlock detection */
      rrctmr_stop_timer( RRCTMR_L1_DEADLOCK_DETECT_TIMER );
#endif

#ifdef FEATURE_RRC_DELAY_ERR_FATAL
      /* Stop Delay Err Fatal timer if started*/
      if (rrctmr_get_remaining_time(RRCTMR_DELAY_ERR_FATAL_TIMER) > 0) 
      {
        rrctmr_stop_timer(RRCTMR_DELAY_ERR_FATAL_TIMER);
        WRRC_MSG0_ERROR("Stopped Delay Err Fatal timer in SETUP_CNF");
      }
#endif /*FEATURE_RRC_DELAY_ERR_FATAL*/


      if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
      {
      /* If the response from L1 to this cmd is because of the CPHY_SETUP_REQ
        sent from SIB/CSP procedure, then do not reinitialize the HS action variable */
        if ((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_SIB)
            ||(rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP))
        {
          WRRC_MSG0_HIGH("RRCHS:HS Action not re-initialized");
        }
        else
        {
          WRRC_MSG0_MED("RRCHS:Reinitialize HS Action");
          rrc_set_hsdpa_action(HSDPA_NOOP);
        }
      }
      /* In the case when L1 gets a Setup of S-BCCH it will send a CPHY_SETUP_CNF
       * very fast, the CRC validation is skipped. Later if the CRC validation fails , then
       * L1 will send a DL_WEAK_IND, and implicitly drop S-BCCH. So in this case
       * when a BCCH Drop is sent by LLC L1 will always send a CPHY_SETUP_CNF with 
       * failure for the BCCH drop. So convert the Failure to success implicitly in
       * this case.
       */
      if((cmd_ptr->cmd.setup_cnf.status == FALSE)&&
        (rrcllc_cmd_under_process.valid) &&
        (rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_SIB_READ_IN_DCH)&&
        (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_SIB)&&
        (rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action == LLC_PHYCHAN_RELEASE)&&
        (rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[rrcllc_cmd_under_process.chan_config.l1_req_list.current_l1_req].
        cmd.setup.req_mask == CPHY_DL_PHYCHAN_DROP_INCL)&&
        (rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[rrcllc_cmd_under_process.chan_config.l1_req_list.current_l1_req].
        cmd.setup.drop_dl_phychan == L1_DL_PHYCHAN_PCCPCH_S))
      {
        WRRC_MSG0_HIGH("RRCGPS: Failure of S-PCCPCH drop is ignored,Treat it as SUCCESS. Go ahead and clean RLC");
        cmd_ptr->cmd.setup_cnf.status = TRUE;
      }
      /* Check to see if the status is a Success */
      if(cmd_ptr->cmd.setup_cnf.status == TRUE)
      {
        if(rrcllc_cmd_under_process.rrc_current_cmd_id == RRC_RNTI_UPDATE_REQ)
        {
          WRRC_MSG0_HIGH("Rcvd CPHY_SETUP_CNF due to RNTI Update");
          
          /* Clear any CCTRCH IDs in the Release list */
          rrcllc_clear_released_cctrch_ids();
          
          if (TRUE == rrcllc_cmd_under_process.rnti_update_cnf_needed)
          {
            /* Send RNTI Update Confirm */
            rrcllc_send_rnti_update_cnf(SUCCESS);
          }
          rrcllc_swap_oc_and_cc();
          rrcllc_next_substate = LLC_IDLE;
        }
        else
        {
          if(rrcllc_command_engine(rrcllc_current_substate, &rrcllc_next_substate)
            == FAILURE)
          {
            ERR_FATAL("RRC Config request processing failure", 0, 0, 0);
          }
          if(rrcllc_next_substate == LLC_IDLE)
          {
          /* This implies no more lower layer commands are to be sent - Can this happen
          * in LLC_IDLE ?
            */
            /* Send a RRC Config CNF back to the procedure and change RRC state */
            if((rrcllc_cmd_under_process.valid) &&
              (rrcllc_cmd_under_process.rrc_current_cmd_id == RRC_CHANNEL_CONFIG_REQ))
            {
              
              if ((rrcllc_cmd_under_process.chan_config.chan_cfg_status ==
                RRCLLC_CHAN_CFG_FAILURE_PHY_CHL) &&
                ((rrc_state == RRC_STATE_CELL_DCH) &&
                (OC_SET_FOR_CELL_DCH == rrcllc_get_ordered_config_status_wo_f3())))
              {
              /* going back to old config is successful.
                Send channel config cnf back to the procedure */
                if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
                {
                /*Set Status as Inactive/Active in RRC, same as  MAC .
                   as it has acted on CMAC_CONFIG.RRC and MAC needs to be in Sync.*/
                  if(rrcllc_cmd_under_process.chan_config.hsdpa_inactive_to_active)
                  {
                    rrc_set_hsdpa_status(HSDPA_ACTIVE);
#ifdef FEATURE_WCDMA_HS_FACH
                    /*To be on safer side, set HS status in FACH to FALSE here.*/
                    rrcllc_set_hs_status_in_e_fach(ordered_config_ptr, FALSE);
#endif /*FEATURE_WCDMA_HS_FACH*/
                  }
                  else if (rrcllc_cmd_under_process.chan_config.hsdpa_active_to_inactive)
                  {
                    rrc_set_hsdpa_status(HSDPA_INACTIVE);
                  }
                }
                    
            
                (void)rrcllc_send_rrc_channel_config_cnf(rrcllc_cmd_under_process.procedure,
                  rrcllc_cmd_under_process.chan_config_transaction_id,
                  RRCLLC_CHAN_CFG_FAILURE_PHY_CHL);
                rrcllc_next_substate = LLC_IDLE;
              }
              else
              {
                if(rrcllc_cmd_under_process.chan_config.new_freq)
                {
                  rrc_ccm_update_for_inter_freq_hard_handover(
                    ordered_config_ptr->dest_freq, ordered_config_ptr->dest_psc);
                }
                rrcllc_next_substate = rrcllc_handle_completion_of_chan_config_req();
              }
            } /* if(rrcllc_cmd_under_process.valid)... */
          } /* if(rrcllc_next_substate == LLC_IDLE) */
        }
      }  /* If Setup CNF has a Successful status */
      else
      {
        /* Process the Setup Cnf failure */
        WRRC_MSG0_ERROR("Rxed Cphy Setup Cnf failure");

        /*Check if there is a PCCPCH mismatch between L1 and RRC*/
        rrcllc_check_for_pccpch_mismatch();

        rrcllc_next_substate = LLC_IDLE;
        /* No more lower layer commands are to be sent */
        /* Send a RRC Config CNF with Failure back to the procedure */
        if((rrcllc_cmd_under_process.valid) &&
           (rrcllc_cmd_under_process.rrc_current_cmd_id == RRC_CHANNEL_CONFIG_REQ))
        {


          /*For Channel configurations with multiple CPHY Setups, RRC does not handle validation failures
            other than the first setup. Ex: FACH to DCH transition
            Issue: To handle such cases we will need to revert the channels setup/torndown by previous CPHY and update 
            internal database accordingly.
            Converting failure cause from validation to setup will ensure proper recovery as OOS will be triggered and 
            all channels will be established.
          */
          if((rrc_get_state() == RRC_STATE_CELL_FACH) &&
             (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_DCH) &&
             (rrcllc_cmd_under_process.chan_config.l1_req_list.current_l1_req > 0) &&
             (cmd_ptr->cmd.setup_cnf.status_type == L1_SETUP_STATUS_VALIDATION_FAIL))
          {
            MSG_HIGH("Resetting failure status from L1_SETUP_STATUS_VALIDATION_FAIL to L1_SETUP_STATUS_SETUP_FAIL",0,0,0);
            cmd_ptr->cmd.setup_cnf.status_type = L1_SETUP_STATUS_SETUP_FAIL;
          }
          /* Reset the sib-5 change in progress flag if cphy failed for sib-5 mod channel configuration */
          if((rrcllc_cmd_under_process.chan_config.chan_config_reason ==
                                        RRCLLC_CHAN_CFG_REASON_RECONFIG_PCH_FACH)
              &&
             (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP))
          {
            rrcllc_clear_sib5_change_in_progress_flag();
          }

          if((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CU) &&
             (rrcllc_cmd_under_process.chan_config.chan_config_reason ==
              RRCLLC_CHAN_CFG_REASON_PCH_TO_FACH))
          {
            /* Make sure S_PCCPCH status reflects this:
             * Release CCTrCH ID allocated for S_PCCPCH, update status
             * in semi permanent data.
             */
            WRRC_MSG0_ERROR("Chan config failed for pch->fach");
            if(rrcllc_clear_cctrch_id(rrcllc_semi_permanent_data.dl_phy_chan.
                                      sccpch.cctrch_id)
                == FAILURE)
            {
              WRRC_MSG1_ERROR("CCTrCH ID %d for SCCPCH not cleared",
                    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.cctrch_id);
            } /* If could not clear CCTrCH ID */
            rrcllc_semi_permanent_data.dl_phy_chan.sccpch_is_up = FALSE;

            /* Clear any CCTRCH IDs in the Release list */
            rrcllc_clear_released_cctrch_ids();

            /* set the transition config back to TOC valid for both DCH and FACH */
            //transition_config.toc_usage = TOC_FOR_DCH_AND_FACH;

            /* RLC entities for CCCH DL/UL and also for BCCH on FACH
            are already established. Release those entities before sending channel
            config cnf back to CU. */

           /*BCCH-FACH */
            rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id(UE_LOGCHAN_BCCH,
                                                          BCCH_FACH_RADIO_BEARER_ID,
                                                          UE_MODE_TRANSPARENT);

            if (rlc_dl_log_chl_id != RRCLCM_RLC_LC_ID_NOT_FOUND)
            {
              WRRC_MSG0_HIGH("PCH->FACH failure.  Deallocating BCCH_FACH");
              (void)rrclcm_deallocate_dl_rlc_lc_id(rlc_dl_log_chl_id);
            }

            /*ccch-RACH */
            rlc_ul_log_chl_id = rrclcm_check_ul_rlc_lc_id(UE_LOGCHAN_CCCH,
                                                          CCCH_RADIO_BEARER_ID,
                                                          UE_MODE_TRANSPARENT);

            if (rlc_ul_log_chl_id != RRCLCM_RLC_LC_ID_NOT_FOUND)
            {
              WRRC_MSG0_HIGH("PCH->FACH failure.  Deallocating CCCH_RACH");
              (void)rrclcm_deallocate_ul_rlc_lc_id(rlc_ul_log_chl_id);
            }

            /*ccch-FACH */
            rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id(UE_LOGCHAN_CCCH,
                                                          CCCH_RADIO_BEARER_ID,
                                                          UE_MODE_UNACKNOWLEDGED);

            if (rlc_dl_log_chl_id != RRCLCM_RLC_LC_ID_NOT_FOUND)
            {
              WRRC_MSG0_HIGH("PCH->FACH failure.  Deallocating CCCH_FACH");
              (void)rrclcm_deallocate_dl_rlc_lc_id(rlc_dl_log_chl_id);
            }

#ifdef FEATURE_UPDATE_SIB7_IN_FACH
            if(rrcllc_cmd_under_process.chan_config.
                    phy_chan_action_list.pccpch_action == LLC_PHYCHAN_SETUP)
            {
              rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id(UE_LOGCHAN_BCCH,BCCH_S_RADIO_BEARER_ID,
                                                            UE_MODE_TRANSPARENT);
  
              /* de-allocate LC_ID if only RLC action for S-BCCH was RLC_ESTABLISH */
              if (rlc_dl_log_chl_id != RRCLCM_RLC_LC_ID_NOT_FOUND) 
              {
                for (i = 0; i < rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.nchan; i ++) 
                {
                  if ((rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[i].lc_id == rlc_dl_log_chl_id)&&
                      (rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[i].lc_type == UE_LOGCHAN_BCCH) &&
                      (rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.dl_tm_act[i].action ==  RLC_ESTABLISH)) 
                  {
                    WRRC_MSG0_HIGH("Rel Log Chl for BCCH_S");
                    (void)rrclcm_deallocate_dl_rlc_lc_id(rlc_dl_log_chl_id);
                    /* also update config db */
                    if (ordered_config_ptr->rlc_dl_tm_parms.nchan)
                    {
                      ordered_config_ptr->rlc_dl_tm_parms.nchan --;
                    }
                    /* Set number of BCHs in MAC correctly */
                    if(ordered_config_ptr->mac_dl_parms.num_bchs)
                    {
                      ordered_config_ptr->mac_dl_parms.num_bchs --;
                    }
                    break;
                  }
                }
              }
  
              if(rrcllc_clear_cctrch_id(rrcllc_semi_permanent_data.dl_phy_chan.
                                        pccpch.cctrch_id)
                 == FAILURE)
              {
                WRRC_MSG1_ERROR("CCTrCH ID %d for S_PCCPCH not cleared",
                    rrcllc_semi_permanent_data.dl_phy_chan.pccpch.cctrch_id);
              } /* If could not clear CCTrCH ID */
              rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up = FALSE;
  
              /* Clear any CCTRCH IDs in the Release list */
              rrcllc_clear_released_cctrch_ids();
            }
#endif /*FEATURE_UPDATE_SIB7_IN_FACH*/


            if(rrcllc_cmd_under_process.chan_config.cnf_needed)
            {
              (void)rrcllc_send_rrc_channel_config_cnf(rrcllc_cmd_under_process.procedure,
                                 rrcllc_cmd_under_process.chan_config_transaction_id,
                                                       RRCLLC_CHAN_CFG_FAILURE_PHY_CHL);
               MSG_MED("RRC_CHANNEL_CONFIG_CNF to proc rrc_proc_e_type_value%d proc",
                             rrcllc_cmd_under_process.procedure, 0, 0);
            }
          }  /* If a pch->fach failed */
          /* Special handling for the case when Neighbor BCH setup fails.
           * This needs to be handled separate from any other setup
           * failure since we do not want to start full acquisition.
           */
          else if(rrcllc_cmd_under_process.chan_config.
                  phy_chan_action_list.n_pccpch_action ==
                  LLC_PHYCHAN_SETUP)
          {
            /* Neighbor BCH setup failed */
            /* Make sure N_PCCPCH status reflects this:
             * Release CCTrCH ID allocated for N PCCPCH, update status
             * in semi permanent data.
             */


            rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id(UE_LOGCHAN_BCCH,
                                                          BCCH_N_RADIO_BEARER_ID,
                                                          UE_MODE_TRANSPARENT);

            /* de-allocate LC_ID if only RLC action for N-BCCH was RLC_ESTABLISH */
            if (rlc_dl_log_chl_id != RRCLCM_RLC_LC_ID_NOT_FOUND) 
            {
              for (i = 0; i < rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.nchan; i ++) 
              {
                if ((rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[i].lc_id == rlc_dl_log_chl_id)&&
                    (rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[i].lc_type == UE_LOGCHAN_BCCH) &&
                    (rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.dl_tm_act[i].action ==  RLC_ESTABLISH)) 
                {
                  WRRC_MSG0_HIGH("Rel Log Chl for BCCH_N");
                  (void)rrclcm_deallocate_dl_rlc_lc_id(rlc_dl_log_chl_id);
                  /* also update config db */
                  if (current_config_ptr->rlc_dl_tm_parms.nchan)
                  {
                    current_config_ptr->rlc_dl_tm_parms.nchan --;
                  }
                  /* Set number of BCHs in MAC correctly */
                  if(current_config_ptr->mac_dl_parms.num_bchs)
                  {
                    current_config_ptr->mac_dl_parms.num_bchs --;
                  }
                  break;
                }
              }
            }

            if(rrcllc_clear_cctrch_id(rrcllc_semi_permanent_data.dl_phy_chan.
                                      n_pccpch.cctrch_id)
                == FAILURE)
            {
              WRRC_MSG1_ERROR("CCTrCH ID %d for N PCCPCH not cleared",
                    rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch.cctrch_id);
            } /* If could not clear CCTrCH ID */
            rrcllc_semi_permanent_data.dl_phy_chan.n_pccpch_is_up = FALSE;

            /* Now clear Ordered Config to correctly reflect the
             * status of N BCCH pipe for RLC and MAC
             */
            if(rrcllc_cmd_under_process.chan_config.solo_bch_operation == FALSE)
            {
              /* Clear any CCTRCH IDs in the Release list */
              rrcllc_clear_released_cctrch_ids();
              /* Only if this is not a solo BCH operation, clear the
               * ordered config. It should be a solo BCH operation,
               * so this should not happen.
               */
              rrcllc_clear_ordered_config_now();
            }
#ifdef FEATURE_UPDATE_SIB7_IN_FACH
            else if(rrcllc_cmd_under_process.chan_config.
                      phy_chan_action_list.pccpch_action == LLC_PHYCHAN_RELEASE)
            {
              rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up = TRUE;
              current_config_ptr->mac_dl_parms.num_bchs ++;
            }
#endif
            if(rrcllc_cmd_under_process.chan_config.cnf_needed)
            {
              (void)rrcllc_send_rrc_channel_config_cnf(rrcllc_cmd_under_process.procedure,
                                 rrcllc_cmd_under_process.chan_config_transaction_id,
                                                       RRCLLC_CHAN_CFG_FAILURE_PHY_CHL);
               MSG_MED("RRC_CHANNEL_CONFIG_CNF to rrc_proc_e_type_value%d proc",
                             rrcllc_cmd_under_process.procedure, 0, 0);
            }

          } /* If a Neighbor PCCPCH setup failed */
#ifdef FEATURE_UPDATE_SIB7_IN_FACH
          else if( ( rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action == LLC_PHYCHAN_SETUP)
                       &&(rrcllc_cmd_under_process.chan_config.solo_bch_operation))
#else
          else if( rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action == LLC_PHYCHAN_SETUP)
#endif
          {
            /* BCH setup failed */
            /* Make sure S_PCCPCH status reflects this:
             * Release CCTrCH ID allocated for S_PCCPCH, update status
             * in semi permanent data.
             */
            if(rrcllc_clear_cctrch_id(rrcllc_semi_permanent_data.dl_phy_chan.
                                      pccpch.cctrch_id)
                == FAILURE)
            {
              WRRC_MSG1_ERROR("CCTrCH ID %d for S PCCPCH not cleared",
                    rrcllc_semi_permanent_data.dl_phy_chan.pccpch.cctrch_id);
            } /* If could not clear CCTrCH ID */
            rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up = FALSE;

            /* Clear any CCTRCH IDs in the Release list */
            rrcllc_clear_released_cctrch_ids();

            /* Now clear Ordered Config to correctly reflect the
             * status of S BCCH pipe for RLC and MAC
             */
            if(rrcllc_cmd_under_process.chan_config.solo_bch_operation == FALSE)
            {
              /* Only if this is not a solo BCH operation, clear the
               * ordered config. It should be a solo BCH operation,
               * so this should not happen.
               */
              rrcllc_clear_ordered_config_now();
            }
            
            rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id(UE_LOGCHAN_BCCH,
                                                          BCCH_S_RADIO_BEARER_ID,
                                                          UE_MODE_TRANSPARENT);
            
            if (rlc_dl_log_chl_id != RRCLCM_RLC_LC_ID_NOT_FOUND) 
            {
              /* de-allocate LC_ID if only RLC action for BCCH was RLC_ESTABLISH */
              for (i = 0; i < rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.nchan; i ++) 
              {
                if ((rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[i].lc_id == rlc_dl_log_chl_id)&&
                    (rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[i].lc_type == UE_LOGCHAN_BCCH) &&
                    (rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.dl_tm_act[i].action ==  RLC_ESTABLISH)) 
                {
                  WRRC_MSG0_HIGH("Rel Log Chl for BCCH_S");
                  (void)rrclcm_deallocate_dl_rlc_lc_id(rlc_dl_log_chl_id);
                  /* also update config db */
                  if (current_config_ptr->rlc_dl_tm_parms.nchan)
                  {
                    current_config_ptr->rlc_dl_tm_parms.nchan --;
                  }
                  /* Set number of BCHs in MAC correctly */
                  if(current_config_ptr->mac_dl_parms.num_bchs)
                  {
                    current_config_ptr->mac_dl_parms.num_bchs --;
                  }                  
                  break;
                }
              }
            }

            if((rrc_get_state()==RRC_STATE_CELL_DCH)&&
                (rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_SIB_READ_IN_DCH)&&
                (ordered_config.set_status!=OC_NOT_SET))
            {
              /*AS OC is already Set, and we are using the CC, copy the BCH infor from CC to OC*/
              rrcllc_copy_bch_info_from_cc_to_oc();
              ordered_config_ptr->rlc_dl_tm_parms.nchan = current_config_ptr->rlc_dl_tm_parms.nchan;
              if(rrcllc_cmd_under_process.clear_oc_pending == TRUE)
              {
                /*OC Clearing is pending and the current channel config request is completed so clear the ordered config now*/
                rrcllc_clear_ordered_config_now();
                rrcllc_cmd_under_process.clear_oc_pending = FALSE;
              }
             
            }
            if(rrcllc_cmd_under_process.chan_config.cnf_needed)
            {
              (void)rrcllc_send_rrc_channel_config_cnf(rrcllc_cmd_under_process.procedure,
                                 rrcllc_cmd_under_process.chan_config_transaction_id,
                                                       RRCLLC_CHAN_CFG_FAILURE_PHY_CHL);
               MSG_MED("RRC_CHANNEL_CONFIG_CNF to %d proc",
                             rrcllc_cmd_under_process.procedure, 0, 0);
            }
          }  /* If a Serving PCCPCH setup failed */
          else if ((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP) &&
                   (rrcllc_cmd_under_process.chan_config.current_cmd_engine == LLC_RELEASE_TR_PHY_CHAN_ENGINE))
          {
            WRRC_MSG0_HIGH("Continue with IDLE_REQ. Fake CPHY_SETUP_REQ has failed for some reason");
            if(rrcllc_command_engine(rrcllc_current_substate, &rrcllc_next_substate)
               == FAILURE)
            {
              ERR_FATAL("RRC Config request processing failure", 0, 0, 0);
            }
            if(rrcllc_next_substate == LLC_IDLE)
            {
              /* This implies no more lower layer commands are to be sent - Can this happen
                 in LLC_IDLE ?
              */
              /* Send a RRC Config CNF back to the procedure and change RRC state */
              if((rrcllc_cmd_under_process.valid) &&
                 (rrcllc_cmd_under_process.rrc_current_cmd_id == RRC_CHANNEL_CONFIG_REQ))
              {
                rrcllc_next_substate = rrcllc_handle_completion_of_chan_config_req();
              } /* if(rrcllc_cmd_under_process.valid)... */
            } /* if(rrcllc_next_substate == LLC_IDLE) */
          }
          else
          {
#ifdef FEATURE_UPDATE_SIB7_IN_FACH
            if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action ==
              LLC_PHYCHAN_SETUP)
            {
              /* BCH setup failed */
              /* Make sure S_PCCPCH status reflects this:
               * Release CCTrCH ID allocated for S_PCCPCH, update status
               * in semi permanent data.
               */
              if(rrcllc_clear_cctrch_id(rrcllc_semi_permanent_data.dl_phy_chan.
                                        pccpch.cctrch_id)
                  == FAILURE)
              {
                WRRC_MSG1_ERROR("CCTrCH ID %d for S PCCPCH not cleared",
                      rrcllc_semi_permanent_data.dl_phy_chan.pccpch.cctrch_id);
              } /* If could not clear CCTrCH ID */
              rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up = FALSE;
     
              /* Now clear Ordered Config to correctly reflect the
               * status of S BCCH pipe for RLC and MAC
               */
     
              rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id(UE_LOGCHAN_BCCH,
                                                            BCCH_S_RADIO_BEARER_ID,
                                                            UE_MODE_TRANSPARENT);
              
              if (rlc_dl_log_chl_id != RRCLCM_RLC_LC_ID_NOT_FOUND) 
              {
                /* de-allocate LC_ID if only RLC action for BCCH was RLC_ESTABLISH */
                for (i = 0; i < rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.nchan; i ++) 
                {
                  if ((rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[i].lc_id == rlc_dl_log_chl_id)&&
                      (rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[i].lc_type == UE_LOGCHAN_BCCH) &&
                      (rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.dl_tm_act[i].action ==  RLC_ESTABLISH)) 
                  {
                    WRRC_MSG0_HIGH("Rel Log Chl for BCCH_S");
                    (void)rrclcm_deallocate_dl_rlc_lc_id(rlc_dl_log_chl_id);
                    /* also update config db */
                    if (ordered_config_ptr->rlc_dl_tm_parms.nchan)
                    {
                      ordered_config_ptr->rlc_dl_tm_parms.nchan --;
                    }
                    /* Set number of BCHs in MAC correctly */
                    if(ordered_config_ptr->mac_dl_parms.num_bchs)
                    {
                      ordered_config_ptr->mac_dl_parms.num_bchs --;
                    }                  
                    break;
                  }
                }
              }
            }
#endif
            /*
              Clean CTCH variables if the next state is either Disconnected or PCH
            */
            if(rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_DISCONNECTED ||
               rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_PCH ||
               rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_URA_PCH)
            {
              rrcllc_clean_ctch_on_phy_channel_failure();
            }

            if(rrc_state == RRC_STATE_DISCONNECTED)
            {
              rrcllc_discard_oc();

              if(rrcllc_cmd_under_process.chan_config.cnf_needed)
              {
                (void)rrcllc_send_rrc_channel_config_cnf(rrcllc_cmd_under_process.procedure,
                                   rrcllc_cmd_under_process.chan_config_transaction_id,
                                                         RRCLLC_CHAN_CFG_FAILURE_PHY_CHL);
              }
            }
            else /* Current state is NOT disconnected - State change will work */
            {

              /* Clear LLC internal queue */
              if(((rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PHYCHAN_RESETUP)
                    && (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)) && 
                   (rrc_state == RRC_STATE_CELL_FACH))
              {
                /* Initialize LLC and initialize Command under process */
                rrcllc_init(RRCLLC_RE_INIT_FREE_Q);
              }
           
              if (cmd_ptr->cmd.setup_cnf.status_type == L1_SETUP_STATUS_VALIDATION_FAIL)
              {
                /* If failure was due to validation, clear newly allocated CCTrCH instead 
                   of CCTrCH that's already in the release list.  This is because L1 is yet
                   to commit to the new CCTrCH.  If DCH->DCH transition, we have to put back
                   old CCTrCH id for dl_dpch and ul_dpch back to semi permanent data because it
                   is still in use by L1 and so that it can be released on the next chan config 
                   req.  Don't have to worry for connecting->dch or fach->dch
                 */
                /*In the case of ASU, there was no reconfig of DL DPCH so no new
                  CCTRCH Id was allocated
                 */
                if((rrcllc_cmd_under_process.chan_config.phy_chan_action_list.dl_dpch_action
                    != LLC_PHYCHAN_NO_OP) || 
                    (rrcllc_cmd_under_process.procedure != RRC_PROCEDURE_ASU)) 
                {
                  cctrch_id = rrcllc_semi_permanent_data.dl_phy_chan.dl_dpch.cctrch_id;
                
                  if ((OC_SET_FOR_CELL_DCH == rrcllc_get_ordered_config_status_wo_f3()) && (rrc_state == RRC_STATE_CELL_DCH))
                  {
                    WRRC_MSG1_HIGH("DCH->DCH failure. Putting old CCTrCH id in semi perm: %d ",rrcllc_cmd_under_process.
                             chan_config.cctrch_id_release_list.num_ids);
                    
                    rrcllc_semi_permanent_data.dl_phy_chan.dl_dpch.cctrch_id = 
                      rrcllc_cmd_under_process.chan_config.cctrch_id_release_list.id[0];
                           
                  }
  
  
                  rrcllc_cmd_under_process.chan_config.cctrch_id_release_list.num_ids = 0;
                  if (cctrch_id != RRCLLC_INVALID_CCTRCH_ID)
                  {
                    RRCLLC_ADD_CCTRCH_ID_TO_RELEASE_LIST(cctrch_id);
                  }
                  else
                  {
                    WRRC_MSG1_ERROR("cctrch_id %d to release is invalid ",cctrch_id);
                  }
                }
              }
         
              /* Clear any CCTRCH IDs in the Release list */
              rrcllc_clear_released_cctrch_ids();

              if (rrcllc_cmd_under_process.chan_config.chan_cfg_status ==
                RRCLLC_CHAN_CFG_FAILURE_PHY_CHL)
              {
                WRRC_MSG0_HIGH("Going back to old config failed");
                (void)rrcllc_send_rrc_channel_config_cnf(rrcllc_cmd_under_process.procedure,
                                       rrcllc_cmd_under_process.chan_config_transaction_id,
                                                         RRCLLC_CHAN_CFG_FAILURE_BACK_TO_OLD_CONFIG);
                /*Now, L1 will be stuck in ACQ state. So it cannot handle Meas req cmd. So trash it, 
                if it is queued. Also, if a channel config request to go to disconnected is quened, 
                handle it.*/
                if(rrc_get_state()== RRC_STATE_CELL_DCH)
                {
                  WRRC_MSG0_HIGH("Trash meas req cmd and process chan config req cmd if queued");
                  rrcllc_next_substate = rrcllc_trash_cmds_till_first_useful(PROCESS_CONFIG_REQ);
                }
                return rrcllc_next_substate;
              }
              WRRC_MSG0_HIGH("Setting failure cause in cfg_status");
              /* update the chan_config_status */
              rrcllc_cmd_under_process.chan_config.chan_cfg_status =
                RRCLLC_CHAN_CFG_FAILURE_PHY_CHL;

              /* check for restrictions (rb released in the channel config)  if true
              then enter IDLE */
              if (TRUE ==  rrcllc_phy_chan_failure_handling_restrictions())
              {
                WRRC_MSG0_HIGH("Can not handle the failure");

                if((rrcllc_cmd_under_process.chan_config.cnf_needed) && 
                   ((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP) ||
                    (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CCM) ||
                    (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CHO)||
                    (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_IHO)))
                {
                  (void)rrcllc_send_rrc_channel_config_cnf(rrcllc_cmd_under_process.procedure,
                                     rrcllc_cmd_under_process.chan_config_transaction_id,
                                                           RRCLLC_CHAN_CFG_FAILURE_PHY_CHL);
                }

                /*Now, L1 will be stuck in ACQ state. So it cannot handle Meas req cmd. */
                if(rrc_get_state()== RRC_STATE_CELL_DCH)
                {
                  if( (llc_stored_cmd_ptr = (rrc_cmd_type *)q_check(&llc_cmd_q)) != NULL )
                  {
                    if((llc_stored_cmd_ptr->cmd_hdr.cmd_id == RRC_LLC_CMD_REQ)
                      && (llc_stored_cmd_ptr->cmd.rrc_llc_req.cmd_dest == LAYER1_PHY)
                     &&(llc_stored_cmd_ptr->cmd.rrc_llc_req.l1_cmd.cmd_id == CPHY_MEASUREMENT_REQ))
                    {
                      rrc_cmd_type *llc_cmd_ptr;
                      if(( llc_cmd_ptr = (rrc_cmd_type *) q_get(&llc_cmd_q) )!= NULL)
                      {
                        WRRC_MSG0_HIGH("UE in DCH state. Moving to Discon.Trashing Meas Req");
                        rrcllc_free_cmd_and_embedded_buf(llc_cmd_ptr);
                        llc_cmd_ptr = NULL;
                      }
                    }
                  }
                }
                WRRC_MSG0_HIGH("Trash queued commands till first useful command");
                rrcllc_next_substate = rrcllc_trash_cmds_till_first_useful(TRASH_CONFIG_REQ);
                rrc_transition_to_disconnected_state(RRC_PROCEDURE_LLC, RRC_TX_TO_DISCON_OTHER);
                return rrcllc_next_substate;
              }

              /* build the command to release LC_IDs if they are established in this
              channel config */
              (void)rrcllc_build_cmd_and_release_lc_ids(); 
           
#ifdef FEATURE_UMTS_PDCP
              if (rrcllc_cmd_under_process.chan_config.pdcp_config_req_list.num_rbs > 0) 
              {
                rrcllc_cmd_under_process.chan_config.pdcp_config_req_list.num_rbs = 0;
                WRRC_MSG0_HIGH("Skipping the PDCP Config due to going back to old config.");
              }
#endif /* FEATURE_UMTS_PDCP */       
              
              /* Check if L1 failure was due to validation*/
              if (cmd_ptr->cmd.setup_cnf.status_type == L1_SETUP_STATUS_VALIDATION_FAIL)
              {
                WRRC_MSG0_ERROR("Cphy setup cnf failue due to validation");
                
                /* Currently handling validation failure for DCH->DCH and FACH->DCH failure
                 * Scenarios.  Other cases, go thru physical channel establishement failure 
                 * handling
                 */

                (void)rrcllc_send_rrc_channel_config_cnf(rrcllc_cmd_under_process.procedure,
                                                         rrcllc_cmd_under_process.chan_config_transaction_id,
                                                         RRCLLC_CHAN_CFG_FAILURE_OTHER);
                return rrcllc_next_substate;

              } /* if validation failure */
              
              else if ((OC_SET_FOR_CELL_DCH == rrcllc_get_ordered_config_status_wo_f3()) && (rrc_state == RRC_STATE_CELL_DCH))
              {
                /* Triggering going back to old configuration only if GCF flag is define.  Else send
                failure message to procedure. */
                if (TRUE == rrcllc_feature_hho_failure_handling)                
                {
                  rrcllc_current_substate = LLC_IDLE;
                  /* clean the command under process now */
                  rrcllc_update_generic_cmd_process_data_for_failure();

                  /*call function to build MAC and L1 commands to take UE back to
                  old configuration */

                  WRRC_MSG0_HIGH("Trigger going back to OLD CFG");
                  if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
                  {
                    if ((rrcllc_chan_config_within_dch_for_old_config(FALSE) == FAILURE) ||
                        (rrcllc_construct_and_store_l1_cmds() == FAILURE))
                    {
                      WRRC_MSG0_ERROR("Cannot handle FAILURE-->IDLE");
                      rrcllc_self_enqueue_channel_config_to_idle();
                      return rrcllc_next_substate;
                    }
                  }
                  else 
                  {
                    (void)rrcllc_chan_config_within_dch_for_old_config(FALSE);
                    /* construct l1 commands */
                    (void)rrcllc_construct_and_store_l1_cmds();
                  }

                  if(rrcllc_command_engine(rrcllc_current_substate, &rrcllc_next_substate)
                     == FAILURE)
                  {
                    ERR_FATAL("RRC Config request processing failure", 0, 0, 0);
                  }
                }
                else /* GCF flag is not set */
                {
                  if(rrcllc_cmd_under_process.chan_config.cnf_needed)
                  {
                    /* In the failure case send the channel config cnf to the procedure and enter
                     * LLC_IDLE */
                    (void)rrcllc_send_rrc_channel_config_cnf(rrcllc_cmd_under_process.procedure,
                                                             rrcllc_cmd_under_process.chan_config_transaction_id,
                                                             RRCLLC_CHAN_CFG_FAILURE_BACK_TO_OLD_CONFIG);
                  }
                }
              } /* if dch->dch failure*/
              /* This covers the cases for wildcard->DCH */
              else if (OC_SET_FOR_CELL_DCH == rrcllc_get_ordered_config_status_wo_f3() && 
                       (rrc_state == RRC_STATE_CONNECTING || rrc_state == RRC_STATE_CELL_FACH ))
              {
                /*If RCE has requested for Channel config from Connecting to DCH then dont call the rrcsib_force_sib_event_init
                   function because it is taken care by CSP*/
                if(!(rrc_state == RRC_STATE_CONNECTING &&
                      rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RCE))
                {
                  WRRC_MSG0_HIGH("Calling SIB force init");
                  /* Signal SIB procedure to clear up the active event, if any */
                  rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_OOS);
                }

                /*Made changes to reset common edch transmission variable when cphy setup fails
                  on connecting  to dch channel config*/
                if((rrc_state == RRC_STATE_CONNECTING) &&
                   (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RCE) &&
		           (rrcllc_get_hs_rach_action(ordered_config_ptr) == MAC_HS_RACH_STOP))
    		    {
    		      rrchsrach_set_common_edch_transmission(ordered_config_ptr,TRUE);
    		    }

                if(rrcllc_cmd_under_process.chan_config.cnf_needed)
                {
                  /* In the failure case send the channel config cnf to the procedure and enter
                   * LLC_IDLE */
                  (void)rrcllc_send_rrc_channel_config_cnf(rrcllc_cmd_under_process.procedure,
                                                           rrcllc_cmd_under_process.chan_config_transaction_id,
                                                           RRCLLC_CHAN_CFG_FAILURE_PHY_CHL);
                } 
              } /* else if connecting->dch || fach->dch*/
              else if(rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_IHO)
              {
                WRRC_MSG0_HIGH("DPCH setup failed after WTOG HO failure");
                if((rrcllc_next_substate == LLC_IDLE) &&
                    (rrcllc_cmd_under_process.chan_config.cnf_needed))
                {
                  (void)rrcllc_send_rrc_channel_config_cnf(rrcllc_cmd_under_process.procedure,
                                         rrcllc_cmd_under_process.chan_config_transaction_id,
                                                           RRCLLC_CHAN_CFG_FAILURE_PHY_CHL);
                }

                /* Dequeue internal LLC queue and free all buffers */
                while( q_check(&llc_cmd_q) != NULL )
                {
                  if ((llc_stored_cmd_ptr = (rrc_cmd_type *) q_get(&llc_cmd_q))!= NULL)
                  {
                    if(llc_stored_cmd_ptr->cmd_hdr.cmd_id == RRC_LOWER_LAYER_DEACT_REQ)
                    {
                      WRRC_MSG0_HIGH("Handling DEACT req");
                      rrcllc_next_substate = rrcllc_idle_handler(llc_stored_cmd_ptr);
                      rrcllc_free_cmd_buf(llc_stored_cmd_ptr);
                      llc_stored_cmd_ptr = NULL;
                      break;
                    }
                    else if(llc_stored_cmd_ptr->cmd_hdr.cmd_id == RRC_STOP_LOWER_LAYER_REQ)
                    {
                      WRRC_MSG0_HIGH("Handling STOP_LOWER_LAYER_REQ");
                      rrcllc_next_substate = rrcllc_idle_handler(llc_stored_cmd_ptr);
                      rrcllc_free_cmd_buf(llc_stored_cmd_ptr);
                      llc_stored_cmd_ptr = NULL;
                      break;
                    }
                    else if((llc_stored_cmd_ptr->cmd_hdr.cmd_id == RRC_CHANNEL_CONFIG_REQ) &&
                            (llc_stored_cmd_ptr->cmd.chan_config_req.next_state ==
                              RRC_STATE_DISCONNECTED) &&
                            (llc_stored_cmd_ptr->cmd.chan_config_req.rrc_state_change_required))
                    {
                      WRRC_MSG0_HIGH("Handling Chl config request (to IDLE)");
                      rrcllc_next_substate = rrcllc_idle_handler(llc_stored_cmd_ptr);
                      rrcllc_free_cmd_buf(llc_stored_cmd_ptr);
                      llc_stored_cmd_ptr = NULL;
                      break;
                    }
                    else
                    {
                      /* If Measurement request or TVM is found also free the
                       * embedded pointer inside the command
                       */
                      WRRC_MSG1_HIGH("Freeing command %d",llc_stored_cmd_ptr->cmd_hdr.cmd_id);
                      rrcllc_free_cmd_and_embedded_buf(llc_stored_cmd_ptr);
                      llc_stored_cmd_ptr = NULL;
                    }
                  }
                }
              } /* else if IHO */

              /* rb release is not required and also there are no restrictions
              so continue the failure handling. Send channel_config_cnf with failure
              indication to the procedure */
              else
              {
                WRRC_MSG0_HIGH("Calling SIB force init");
                /* Signal SIB procedure to clear up the active event, if any */
                rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_OOS);

                (void)rrcllc_send_rrc_channel_config_cnf(rrcllc_cmd_under_process.procedure,
                                       rrcllc_cmd_under_process.chan_config_transaction_id,
                                                         RRCLLC_CHAN_CFG_FAILURE_PHY_CHL);
                rrcllc_next_substate = LLC_IDLE;

              }
            } /* current state is not disconnected*/
          } /* failure for normal reconfig */
        } /* if rrcllc_cmd_under_process.valid */
#ifdef FEATURE_UPDATE_SIB7_IN_FACH
        else if((rrcllc_cmd_under_process.valid) &&
           (rrcllc_cmd_under_process.rrc_current_cmd_id == RRC_CELL_RESELECTION_REQ))
        {
          if(rrc_get_state() == RRC_STATE_CELL_FACH)
          {
            if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.pccpch_action == LLC_PHYCHAN_SETUP)
            {
              /* BCH setup failed */
              /* Make sure S_PCCPCH status reflects this:
               * Release CCTrCH ID allocated for S_PCCPCH, update status
               * in semi permanent data.
               */
              rrcllc_next_substate = LLC_IDLE;
              if(rrcllc_clear_cctrch_id(rrcllc_semi_permanent_data.dl_phy_chan.pccpch.cctrch_id)
                  == FAILURE)
              {
                WRRC_MSG1_ERROR("CCTrCH ID %d for S PCCPCH not cleared",rrcllc_semi_permanent_data.dl_phy_chan.pccpch.cctrch_id);
              } /* If could not clear CCTrCH ID */
              rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up =FALSE;
              
              rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id(UE_LOGCHAN_BCCH,
                                                            BCCH_S_RADIO_BEARER_ID,
                                                            UE_MODE_TRANSPARENT);
              
              if (rlc_dl_log_chl_id != RRCLCM_RLC_LC_ID_NOT_FOUND) 
              {
                /* de-allocate LC_ID if only RLC action for BCCH was RLC_ESTABLISH */
                for (i = 0; i < rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.nchan; i ++) 
                {
                  if ((rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[i].lc_id == rlc_dl_log_chl_id)&&
                      (rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[i].lc_type == UE_LOGCHAN_BCCH) &&
                      (rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.dl_tm_act[i].action ==  RLC_ESTABLISH)) 
                  {
                    WRRC_MSG0_HIGH("Rel Log Chl for BCCH_S");
                    (void)rrclcm_deallocate_dl_rlc_lc_id(rlc_dl_log_chl_id);
                    /* also update config db */
                    if (reselection_config_ptr->rlc_dl_tm_parms.nchan)
                    {
                      reselection_config_ptr->rlc_dl_tm_parms.nchan --;
                    }
                    /* Set number of BCHs in MAC correctly */
                    if(reselection_config_ptr->mac_dl_parms.num_bchs)
                    {
                      reselection_config_ptr->mac_dl_parms.num_bchs --;
                    }                  
                    break;
                  }
                }
              }
            }
          }
          {
            rrc_state_e_type temp_rrc_state = rrc_get_state();
            if(temp_rrc_state== RRC_STATE_DISCONNECTED ||
               temp_rrc_state== RRC_STATE_CELL_PCH||
               temp_rrc_state== RRC_STATE_URA_PCH)
            {
              if(rrcllc_cmd_under_process.chan_config.phy_chan_action_list.sccpch_for_ctch_action ==LLC_PHYCHAN_SETUP)
              {
                if(rrcllc_clear_cctrch_id(rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.cctrch_id)
                    == FAILURE)
                {
                  WRRC_MSG1_ERROR("CCTrCH ID %d for CTCH on SCCPCH not cleared",
                        rrcllc_semi_permanent_data.dl_phy_chan.sccpch_with_ctch.cctrch_id);
                } 
                rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id(UE_LOGCHAN_CTCH,
                                                              CTCH_RADIO_BEARER_ID,
                                                              UE_MODE_UNACKNOWLEDGED);
                
                if (rlc_dl_log_chl_id != RRCLCM_RLC_LC_ID_NOT_FOUND) 
                {
                  for (i = 0; i < rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.nchan; i ++) 
                  {
                    if ((rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[i].lc_id == rlc_dl_log_chl_id)&&
                        (rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[i].lc_type == UE_LOGCHAN_CTCH) &&
                        (rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.dl_um_act[i].action ==  RLC_ESTABLISH)) 
                    {
                      WRRC_MSG0_HIGH("Rel Log Chl for CTCH");
                      (void)rrclcm_deallocate_dl_rlc_lc_id(rlc_dl_log_chl_id);
                      break;
                    }
                  }
                }
              }
            }
          }
          /* No more lower layer commands are to be sent */
          /* Send a Reselection CNF with Failure back to the procedure */
          /* Send a Failure status to the calling procedure */
          (void)rrcllc_send_rrc_cell_reselection_cnf(FAILURE);

          /* Clear Ordered Config if indicated in LLC Command under process */
          if(rrcllc_cmd_under_process.clear_oc_pending)
          {
            WRRC_MSG0_HIGH("Pending ClearOC on Cell Trans Cnf ");
            rrcllc_clear_ordered_config_now();
            rrcllc_cmd_under_process.clear_oc_pending = FALSE;
          }
        }

#endif /* FEATURE_UPDATE_SIB7_IN_FACH*/
        if(rrcllc_cmd_under_process.rrc_current_cmd_id == RRC_RNTI_UPDATE_REQ)
        {
          WRRC_MSG0_HIGH("Rcvd CPHY_SETUP_CNF due to RNTI Update failed");
          
          if (TRUE == rrcllc_cmd_under_process.rnti_update_cnf_needed)
          {
            /* Cannot handle this failure because we have lost old URNTI
               since we have overwritten in CC and OC.  Go to idle */
            rrcllc_self_enqueue_channel_config_to_idle();
          }
        }
        /* TBD: Restore all internal LLC data like the Semi permanent data to
         * the state it was before this failed RRC_CHANNEL_CONFIG_REQ was
         * processed. This needs to be done in future when going to previous
         * config is supported. For now, leave the Semi-permanent data to the
         * present state and hope the calling procedure releases all channels.
         */
      }
      break;

    case RRC_CPHY_PHYCHAN_ESTABLISHED_IND:
      /* Channel Establishment indicates a Success */
      WRRC_MSG0_HIGH("Rcv'd RRC_CPHY_PHYCHAN_ESTABLISHED_IND from L1");
      /* Set the Channel Establishment Indication received flag in
       * Command under process */
      if(cmd_ptr->cmd.phy_est_ind.status == TRUE)
      {
        rrcllc_cmd_under_process.chan_config.chan_est_ind_rcvd = TRUE;

        if(rrcllc_command_engine(rrcllc_current_substate, &rrcllc_next_substate)
           == FAILURE)
        {
          ERR_FATAL("RRC Config request processing failure", 0, 0, 0);
        }
        if(rrcllc_cmd_under_process.chan_config.new_freq)
        {
          rrc_ccm_update_for_inter_freq_hard_handover(
          ordered_config_ptr->dest_freq, ordered_config_ptr->dest_psc);
        }

        if(rrcllc_next_substate == LLC_IDLE)
        {
          if(rrcllc_cmd_under_process.chan_config.cnf_needed &&
               rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_IHO)
          {
            (void)rrcllc_send_rrc_channel_config_cnf(rrcllc_cmd_under_process.procedure,
                                                     rrcllc_cmd_under_process.chan_config_transaction_id,
                                                     RRCLLC_CHAN_CFG_SUCCESS);
          }
        }
      }
      else /* Status == FALSE */
      {
        /* Channel Establishment Ind has a failure status */
        WRRC_MSG0_ERROR("Rxed Cphy Chl Est Ind failure");
        rrcllc_next_substate = LLC_IDLE;
        /* No more lower layer commands are to be sent */
        /* Send a RRC Config CNF with Failure back to the procedure */
        if((rrcllc_cmd_under_process.valid) &&
           (rrcllc_cmd_under_process.rrc_current_cmd_id == RRC_CHANNEL_CONFIG_REQ))
        {
          WRRC_MSG0_HIGH("Chl Est Failure - go to Idle");

          /* For now, disable sending a Failure message as that goes before
           * LLC gets to process its self-enqueued command and that doesn't
           * help.
           */
          /* Self-enqueue a Channel Config Request that takes UE to Idle */
          rrcllc_self_enqueue_channel_config_to_idle();
        } /* if(rrcllc_cmd_under_process.valid)... */

        /* TBD: Restore all internal LLC data like the Semi permanent data to
         * the state it was before this failed RRC_CHANNEL_CONFIG_REQ was
         * processed. This needs to be done in future when going to previous
         * config is supported. For now, leave the Semi-permanent data to the
         * present state and hope the calling procedure releases all channels.
         */
      }
      break;

    case RRC_CPHY_COMPRESSED_MODE_IND:
      if (rrcllc_modify_cm_info_in_current_config(&cmd_ptr->cmd.cm_ind) == SUCCESS)
      {
        rrcllc_send_compressed_mode_run_time_error_ind(&cmd_ptr->cmd.cm_ind);
      }
      break;

    case RRC_LLC_CMD_REQ:
      if((cmd_ptr->cmd.rrc_llc_req.cmd_dest == LAYER1_PHY) && 
         (cmd_ptr->cmd.rrc_llc_req.l1_cmd.cmd_id == CPHY_UPD_DL_SYNC_PARMS)) 
      {
        /* This is to take care of a narrow window where UMI might come on 
           previous config and L1 timers have to be updated appropriately */

        if(rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_DCH)
        {
          WRRC_MSG1_HIGH("UMI in WAIT_FOR_CPHY_SETUP_CNF handler activation case",
                    0);

          WCDMA_RRC_TASK_LOCK();

          /* Update the connected mode timers/counters */
          rrcllc_update_oc_with_l1_connected_mode_timers();
          WCDMA_RRC_TASK_FREE();
        }
        else
        {
          WRRC_MSG1_ERROR("Cmd 0x%x not expected in RRC non-DCH state",
                           cmd_ptr->cmd_hdr.cmd_id);
        }
        break;
      } /* lint !e616  This break is needed only for "CPHY_UPD_DL_SYNC_PARMS"
      
           case */
      if((cmd_ptr->cmd.rrc_llc_req.cmd_dest == LAYER1_PHY) &&
         (cmd_ptr->cmd.rrc_llc_req.l1_cmd.cmd_id == CPHY_ACT_TIME_CANCEL_REQ)) 
      {
        rrcllc_update_generic_cmd_process_data(cmd_ptr);
        rrcllc_next_substate = rrcllc_process_funneled_cmd_req(cmd_ptr);
        break;
      }    /* lint !e616  This break is needed only for "CPHY_ACT_TIME_CANCEL_REQ"  case */

    case RRC_STOP_LOWER_LAYER_REQ:
    case RRC_RNTI_UPDATE_REQ:
    case RRC_RESET_L1_REQ:
    case RRC_LOWER_LAYER_DEACT_REQ:
    case RRC_CHANNEL_CONFIG_REQ:
    case RRC_CELL_RESELECTION_REQ:
    case RRC_ABORT_CIPH_CONFIG_REQ:
    case RRC_CIPH_CONFIG_REQ:
    case RRC_LLC_RE_EST_RLC_REQ:
    case RRC_CONN_MODE_DEEP_SLEEP_REQ:
    case RRC_CONN_MODE_DEEP_SLEEP_WAKEUP_REQ:

      if(( ((uint32) cmd_ptr->cmd_hdr.cmd_id) & CMD_BASE_MASK ) == (uint32)RRC_INT_CMD_BASE)
      {
        (void)rrcllc_put_cmd_on_queue(cmd_ptr);
        MSG_MED("RRC Internal cmd recvd", 0, 0, 0);
      }
      break;

    default:
      WRRC_MSG1_ERROR("Cmd 0x%x not expected in LLC_WAIT_CPHY_SETUP_CNF",
                                   cmd_ptr->cmd_hdr.cmd_id);
      break;
  } /* switch() */

  return(rrcllc_next_substate);

} /* rrcllc_wait_cphy_setup_cnf_handler */


/*====================================================================
FUNCTION: rrcllc_build_cmd_and_release_lc_ids()

DESCRIPTION:
  This function releases any newly allocated LC_IDs

DEPENDENCIES:
  None

RETURN VALUE:
  boolean rlc_config_reqd
                      TRUE  : LC_ID configuration is required
                      FALSE : LC_ID configuration is not required

SIDE EFFECTS:
  None.
====================================================================*/
boolean rrcllc_build_cmd_and_release_lc_ids(void)
{
  boolean rlc_config_reqd = FALSE;
  //boolean go_to_idle = FALSE;
  uint8 lc_id;
  uint32 index;
  uint8 num_chl = 0;
  rrc_RB_Identity rb_id;
  /* No more lower layer commands are to be sent */
  /* Send a RRC Config CNF with Failure back to the procedure */
  WRRC_MSG0_HIGH("Phy Chan Failure.  Release lc ids");


  /* Now release the RBs that were setup during this channel config
  No need to address modified RBs because at latere step after moving to cell_FACH
  RLC will get configured again with information in CC  and modified RBs will be reconfigured
  again with RLC info in CC */

  /* check for any dl_tm channels being setup in the failed channel config */
  if(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.nchan > 0)
  {
    uecomdef_logchan_e_type  dl_sdu_type = UE_LOGCHAN_NONE;
    boolean                  update_lc_type_for_srb5 = FALSE;

    for (index=0; index<rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.nchan; index++)
    {
      if (rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.dl_tm_act[index].action == RLC_ESTABLISH)
      {
        lc_id = rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[index].lc_id;
        rb_id = rrclcm_get_dl_rb_id(lc_id);

        if(rrclcm_get_dl_lc_type(lc_id, &dl_sdu_type) == RRCLCM_SUCCESS)
        {
          if(dl_sdu_type == UE_LOGCHAN_TM_DCCH_DL)
          {
            update_lc_type_for_srb5 = TRUE;
          }
        }

        WRRC_MSG2_HIGH("RLC DL TM rel lc_id:%d,rb_id:%d", lc_id, rb_id);

        /* build RLC command */
        if (DCCH_DT_HIGH_PRI_RADIO_BEARER_ID < rb_id)
        {
          rlc_rel_list.dl_tm.chan_info[num_chl].lc_id   = lc_id;

          if(update_lc_type_for_srb5)
          {
            rlc_rel_list.dl_tm.chan_info[num_chl].lc_type = UE_LOGCHAN_TM_DCCH_DL;
            update_lc_type_for_srb5 = FALSE;
          }
          else if (rb_id == BCCH_S_RADIO_BEARER_ID ||
                   rb_id == BCCH_N_RADIO_BEARER_ID ||
                   rb_id == BCCH_FACH_RADIO_BEARER_ID)
          {
            rlc_rel_list.dl_tm.chan_info[num_chl].lc_type = UE_LOGCHAN_BCCH;
          }
          else if(rb_id == PCCH_RADIO_BEARER_ID)
          {
            rlc_rel_list.dl_tm.chan_info[num_chl].lc_type = UE_LOGCHAN_PCCH;
          }
          else
          {
            rlc_rel_list.dl_tm.chan_info[num_chl].lc_type = UE_LOGCHAN_DTCH;
          }
          
          rlc_rel_list.dl_tm.dl_tm_act[num_chl].action  = RLC_RELEASE;
          rlc_rel_list.dl_tm.dl_tm_act[num_chl].act_incl= FALSE;
          /* TBD: hardcode segmentation indication to FALSE */
          rlc_rel_list.dl_tm.chan_info[num_chl].seg_ind = FALSE;
          /* since it is rb release we do not need to populate rlc size */
          num_chl++;
          rlc_config_reqd = TRUE;
        }
        else
        {
          WRRC_MSG1_HIGH("DL TM lc_id %d can not be released", lc_id);
        }
      }
    }
    rlc_rel_list.dl_tm.nchan = num_chl;
  }
  num_chl = 0;

  /* check for any dl_tm channels being setup in the failed channel config */
  if(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.nchan > 0)
  {
    for (index=0; index<rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.nchan; index++)
    {
      if (rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.ul_tm_act[index].action == RLC_ESTABLISH)
      {
        lc_id = rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_tm.chan_info[index].lc_id;
        rb_id = rrclcm_get_ul_rb_id(lc_id);
        WRRC_MSG2_HIGH("RLC UL TM rel lc_id:%d,rb_id:%d", lc_id, rb_id);
        if ((DCCH_DT_HIGH_PRI_RADIO_BEARER_ID < rb_id) ||
            (CCCH_RADIO_BEARER_ID == rb_id))
        {
          rlc_rel_list.ul_tm.chan_info[num_chl].lc_id   = lc_id;
          if(CCCH_RADIO_BEARER_ID == rb_id)
          {
            rlc_rel_list.ul_tm.chan_info[num_chl].lc_type = UE_LOGCHAN_CCCH;
          }
          else
          {
            rlc_rel_list.ul_tm.chan_info[num_chl].lc_type = UE_LOGCHAN_DTCH;
          }
          rlc_rel_list.ul_tm.ul_tm_act[num_chl].action  = RLC_RELEASE;
          rlc_rel_list.ul_tm.ul_tm_act[num_chl].act_incl= FALSE;
          /* TBD: hardcode segmentation indication to FALSE */
          rlc_rel_list.ul_tm.chan_info[num_chl].seg_ind = FALSE;
          /* since it is rb release we do not need to populate rlc size */
          num_chl++;
          rlc_config_reqd = TRUE;
        }
        else
        {
          WRRC_MSG1_HIGH("UL TM lc_id %d can not be released", lc_id);
        }
      }
    }
    rlc_rel_list.ul_tm.nchan = num_chl;
  }
  num_chl = 0;

  /* check for any dl_um channels being setup in the failed channel config */
  if(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.nchan > 0)
  {
    for (index=0; index<rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.nchan; index++)
    {
      if (rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.dl_um_act[index].action == RLC_ESTABLISH)
      {
        lc_id = rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[index].lc_id;
        rb_id =  rrclcm_get_dl_rb_id(lc_id);
        WRRC_MSG2_HIGH("RLC DL UM rel lc_id:%d,rb_id:%d", lc_id, rb_id);

        rlc_rel_list.dl_um.chan_info[num_chl].lc_id = lc_id;

        if(rb_id == CTCH_RADIO_BEARER_ID)
        {
          rlc_rel_list.dl_um.chan_info[num_chl].lc_type = UE_LOGCHAN_CTCH;
        }
        else if(rb_id == CCCH_RADIO_BEARER_ID)
        {
          rlc_rel_list.dl_um.chan_info[num_chl].lc_type = UE_LOGCHAN_CCCH;
        }
        else if (rb_id > DCCH_DT_HIGH_PRI_RADIO_BEARER_ID)
        {
          rlc_rel_list.dl_um.chan_info[num_chl].lc_type = UE_LOGCHAN_DTCH;
        }
        else
        {
          rlc_rel_list.dl_um.chan_info[num_chl].lc_type = UE_LOGCHAN_DCCH;
        }
        rlc_rel_list.dl_um.dl_um_act[num_chl].action = RLC_RELEASE;
        rlc_rel_list.dl_um.dl_um_act[num_chl].act_incl = FALSE;
        num_chl++;
        rlc_config_reqd = TRUE;
      }
    }
    rlc_rel_list.dl_um.nchan = num_chl;
  }
  num_chl = 0;
  /* check for any ul_um channels being setup in the failed channel config */
  if(rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.nchan > 0)
  {
    for (index=0; index<rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.nchan; index++)
    {
      if (rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.ul_um_act[index].action == RLC_ESTABLISH)
      {
        lc_id = rrcllc_cmd_under_process.chan_config.rlc_config_req_list.ul_um.chan_info[index].lc_id;
        rb_id = rrclcm_get_ul_rb_id(lc_id);
        WRRC_MSG2_HIGH("RLC UL UM rel lc_id:%d,rb_id:%d", lc_id, rb_id);

        /* build RLC command to release RBs */
        rlc_rel_list.ul_um.chan_info[num_chl].lc_id = lc_id;
        if (rb_id > DCCH_DT_HIGH_PRI_RADIO_BEARER_ID)
        {
          rlc_rel_list.ul_um.chan_info[num_chl].lc_type = UE_LOGCHAN_DTCH;
        }
        else
        {
          rlc_rel_list.ul_um.chan_info[num_chl].lc_type = UE_LOGCHAN_DCCH;
        }
        rlc_rel_list.ul_um.ul_um_act[num_chl].action = RLC_RELEASE;
        rlc_rel_list.ul_um.ul_um_act[num_chl].act_incl = FALSE;

        /* Though it's release yet filling in timer_discard for the sake of consistency. */
        rlc_rel_list.ul_um.chan_info[num_chl].timer_discard = 
                rrc_get_ul_um_timer_discard_for_rb_id(rb_id);
        /* since it is rb release we do not need to populate rlc size */
        num_chl++;
        rlc_config_reqd = TRUE;
      }
    }
    rlc_rel_list.ul_um.nchan = num_chl;
  }
  num_chl = 0;

  if (rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.nentity > 0)
  {
    for (index=0; index<rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.nentity; index++)
    {
      WRRC_MSG2_HIGH("RLC AM config lc_id:%d, action:%d",
                rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_info[index]->common_config.ul_data_id,
                rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_act[index].action);
      if (rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_act[index].action == RLC_ESTABLISH)
      {
        /* Now point towards RLC configuration in oc which is already stored in cmd_under_process
         */
        rlc_rel_list.am.am_info[num_chl] =
          rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am.am_info[index];

        /* Initialize RLC AM action data in rrcllc_cmd_under_process */
        rlc_rel_list.am.am_act[num_chl].action   = RLC_RELEASE;
        rlc_rel_list.am.am_act[num_chl].act_incl = FALSE;
        num_chl++;
        rlc_config_reqd = TRUE;
      }
    }
    rlc_rel_list.am.nentity = num_chl;
  }

  if (rlc_config_reqd)
  {
    /* Release all Logical channel IDs that need to be released */
    rrcllc_release_ul_logical_chl_ids_in_new_configuration();
    rrcllc_release_dl_logical_chl_ids_in_new_configuration();
  }

  return (rlc_config_reqd);
}   /* rrcllc_build_cmd_and_release_lc_ids */

/*====================================================================
FUNCTION: rrcllc_phy_chan_failure_handling_restrictions()

DESCRIPTION:
  This function checks  for any restrictions before proceeding with cphy
  channel failure handling.

DEPENDENCIES:
  None

RETURN VALUE:
  boolean
                      TRUE  : Do not proceed with channel config enter idle
                      FALSE : No restrictions, proceed with channel config

SIDE EFFECTS:
  None.
====================================================================*/
boolean rrcllc_phy_chan_failure_handling_restrictions (void)
{
  boolean abort_chan_config = FALSE;
  rrc_state_e_type  rrc_state = rrc_get_state();

  /* check whether this channel config is for connecting to DCH or CELL_FACH to CELL_DCH
  transition. If not then enter IDLE */
  if (!(((rrc_state == RRC_STATE_CONNECTING) || (rrc_state == RRC_STATE_CELL_FACH) || (rrc_state == RRC_STATE_CELL_DCH)) &&
      (OC_SET_FOR_CELL_DCH == rrcllc_get_ordered_config_status_wo_f3())))
  {
    WRRC_MSG0_HIGH("Failure handling is not supported");
    abort_chan_config = TRUE;
  }

  return (abort_chan_config);
}   /* rrcllc_phy_chan_failure_handling_restrictions */

/*====================================================================
FUNCTION: rrcllc_wait_cphy_channel_ind_handler()

DESCRIPTION:
  This function is a handler for LLC_WAIT_CPHY_CHANNEL_IND state and
  takes care of all incoming commands and Confirms from RRC procedures,
  MAC, RLC and L1.

DEPENDENCIES:
  None

RETURN VALUE:
  Next LLC state.

SIDE EFFECTS:
  None.
====================================================================*/
static rrcllc_substate_e_type rrcllc_wait_cphy_channel_ind_handler(rrc_cmd_type *cmd_ptr)
{

  rrc_state_e_type  rrc_state;
  rrc_cmd_type* llc_stored_cmd_ptr;
  boolean iho_failure = FALSE;

  rrcllc_substate_e_type  rrcllc_next_substate = LLC_WAIT_CPHY_CHANNEL_IND;
  MSG_MED("Cmd 0x%x recvd in LLC_WAIT_CPHY_CHANNEL_IND",
                          cmd_ptr->cmd_hdr.cmd_id, 0, 0);

  rrc_state = rrc_get_state();

  switch(cmd_ptr->cmd_hdr.cmd_id)
  {
    case RRC_CPHY_PHYCHAN_ESTABLISHED_IND:
      /* Channel Establishment indicates a Success */
      WRRC_MSG1_HIGH("Rcv'd RRC_CPHY_PHYCHAN_ESTABLISHED_IND from L1: %d", cmd_ptr->cmd.phy_est_ind.status);

      /* This implies no more lower layer commands are to be sent */
      /* Send a RRC Config CNF back to the procedure and change RRC state */
      if((rrcllc_cmd_under_process.valid) &&
         (rrcllc_cmd_under_process.rrc_current_cmd_id == RRC_CHANNEL_CONFIG_REQ))
      {
        /*MSG_MED("Sending RRC_CHANNEL_CONFIG_CNF to procedure %d",
                       rrcllc_cmd_under_process.procedure, 0, 0); */

        if(cmd_ptr->cmd.phy_est_ind.status == TRUE)
        {
          if(rrcllc_command_engine(rrcllc_current_substate, &rrcllc_next_substate)
             == FAILURE)
          {
            ERR_FATAL("RRC Config request processing failure", 0, 0, 0);
          }
          if(rrcllc_cmd_under_process.chan_config.new_freq)
          {
            rrc_ccm_update_for_inter_freq_hard_handover(
              ordered_config_ptr->dest_freq, ordered_config_ptr->dest_psc);
          }
          if(rrcllc_next_substate == LLC_IDLE)
          {
            if(rrcllc_cmd_under_process.chan_config.cnf_needed)
            {
              if (rrcllc_cmd_under_process.chan_config.chan_cfg_status ==
                  RRCLLC_CHAN_CFG_FAILURE_PHY_CHL)
              {
                if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
                {
                  /*Set Status as Inactive/Active in RRC, same as  MAC .
                   as it has acted on CMAC_CONFIG.RRC and MAC needs to be in Sync.*/
                  if(rrcllc_cmd_under_process.chan_config.hsdpa_inactive_to_active)
                  {
                    rrc_set_hsdpa_status(HSDPA_ACTIVE);

#ifdef FEATURE_WCDMA_HS_FACH
                    /*To be on safer side, set HS status in FACH to FALSE here.*/
                    rrcllc_set_hs_status_in_e_fach(ordered_config_ptr, FALSE);
#endif /*FEATURE_WCDMA_HS_FACH*/

                  }
                  else if (rrcllc_cmd_under_process.chan_config.hsdpa_active_to_inactive)
                  {
                    rrc_set_hsdpa_status(HSDPA_INACTIVE);
                  }
                }

                WRRC_MSG0_HIGH("Going back to old config Succeeded");
                (void)rrcllc_send_rrc_channel_config_cnf(rrcllc_cmd_under_process.procedure,
                                                         rrcllc_cmd_under_process.chan_config_transaction_id,
                                                         RRCLLC_CHAN_CFG_FAILURE_PHY_CHL);
              }
              else
              {
                rrcllc_next_substate = rrcllc_handle_completion_of_chan_config_req();
              }
            } /* if(rrcllc_cmd_under_process.chan_config.cnf_needed) */

          }

        }
        else  /* Status == FALSE */
        {

          /* Channel Establishment Ind has a failure status */
          WRRC_MSG0_ERROR("Rxed Cphy Chl Est Ind failure");

          event_report(EVENT_WCDMA_RRC_PHYCHAN_EST_FAILURE);
          
           /*Since HS is stopeed at MAC and L1 and phy chanl establishment failed, reset e-fach status*/
#ifdef FEATURE_WCDMA_HS_FACH
          if(rrcllc_get_hs_action_in_e_fach(ordered_config_ptr) == HSDPA_STOP)
          {
            rrcllc_set_hs_status_in_e_fach(ordered_config_ptr, FALSE);
            rrcllc_set_hs_status_in_e_fach(current_config_ptr, FALSE);
          }
#endif /*FEATURE_WCDMA_HS_FACH*/

          /* update the chan_config_status */
          rrcllc_next_substate = LLC_IDLE;

          if (rrcllc_cmd_under_process.chan_config.chan_cfg_status ==
              RRCLLC_CHAN_CFG_FAILURE_PHY_CHL)
          {
            WRRC_MSG0_ERROR("Going back to old config failed");
            if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
            {
              /*Set Status as Inactive/Active in RRC, same as  MAC .
                   as it has acted on CMAC_CONFIG.RRC and MAC needs to be in Sync.*/
              if(rrcllc_cmd_under_process.chan_config.hsdpa_inactive_to_active)
              {
                rrc_set_hsdpa_status(HSDPA_ACTIVE);

#ifdef FEATURE_WCDMA_HS_FACH
                /*To be on safer side, set HS status in FACH to FALSE here.*/
                rrcllc_set_hs_status_in_e_fach(ordered_config_ptr, FALSE);
#endif /*FEATURE_WCDMA_HS_FACH*/

              }
              else if (rrcllc_cmd_under_process.chan_config.hsdpa_active_to_inactive)
              {
                rrc_set_hsdpa_status(HSDPA_INACTIVE);
              }
            }
            (void)rrcllc_send_rrc_channel_config_cnf(rrcllc_cmd_under_process.procedure,
                                                     rrcllc_cmd_under_process.chan_config_transaction_id,
                                                     RRCLLC_CHAN_CFG_FAILURE_BACK_TO_OLD_CONFIG);

            return rrcllc_next_substate;
          }

          rrcllc_cmd_under_process.chan_config.chan_cfg_status =
            RRCLLC_CHAN_CFG_FAILURE_PHY_CHL;

          /* Send Channel Config CNF only to CHO procedure */
          if((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CHO) &&
             (rrcllc_cmd_under_process.chan_config.cnf_needed))
          {
            (void)rrcllc_send_rrc_channel_config_cnf(rrcllc_cmd_under_process.procedure,
                                   rrcllc_cmd_under_process.chan_config_transaction_id,
                                                     RRCLLC_CHAN_CFG_FAILURE_PHY_CHL);
          }

          /* Handle IHO */
          else if((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_IHO)
#ifdef FEATURE_DUAL_SIM
         /* During unlcok by scan don't handle Channel config cnf here as IHO*/
                    || ((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)
                        &&(rrccsp_get_curr_scan() == RRC_CSP_UNLOCK_BY_SCAN))
#endif
                  )
          {
            WRRC_MSG0_ERROR("DPCH sync failed after WTOG HO failure");
	    iho_failure = TRUE;
            rrcllc_next_substate = LLC_IDLE;
          }

          /* check for restrictions (rb released in the channel config)  if true
          then enter IDLE */
          else if (TRUE ==  rrcllc_phy_chan_failure_handling_restrictions())
          {
            WRRC_MSG0_ERROR("Can not handle the failure");
            rrcllc_self_enqueue_channel_config_to_idle();
          }

          /* build the command to release LC_IDs if they are established in this
          channel config */
          (void)rrcllc_build_cmd_and_release_lc_ids();

          if((OC_SET_FOR_CELL_DCH == rrcllc_get_ordered_config_status_wo_f3()) && (rrc_state == RRC_STATE_CELL_DCH) )
          {

            /* Triggering going back to old configuration only if GCF flag is define.  Else send
               failure message to procedure. */
            if (TRUE == rrcllc_feature_hho_failure_handling)
            {
              rrcllc_current_substate = LLC_IDLE;
              /* clean the command under process now */
              rrcllc_update_generic_cmd_process_data_for_failure();
              
              /* call function to build MAC and L1 commands to take UE back to
                old configuration */

              (void)rrcllc_chan_config_within_dch_for_old_config(TRUE);
              /* construct l1 commands */
              (void)rrcllc_construct_and_store_l1_cmds();
              
              if(rrcllc_command_engine(rrcllc_current_substate, &rrcllc_next_substate)
                 == FAILURE)
              { 
                ERR_FATAL("RRC Config request processing failure", 0, 0, 0);
              }
            }
            else 
            {
              if((rrcllc_next_substate == LLC_IDLE) &&
                 (rrcllc_cmd_under_process.chan_config.cnf_needed))
              {
                /* In the failure case send the channel config cnf to the procedure and enter
                 * LLC_IDLE */
                (void)rrcllc_send_rrc_channel_config_cnf(rrcllc_cmd_under_process.procedure,
                                                         rrcllc_cmd_under_process.chan_config_transaction_id,
                                                         RRCLLC_CHAN_CFG_FAILURE_BACK_TO_OLD_CONFIG);
              }
            }
          } /* if dch-> dch*/
          /* if connecting ->dch or fach->dch failure*/
          else if(rrcllc_cmd_under_process.chan_config.cnf_needed)
          {
            WRRC_MSG0_HIGH("Calling SIB force init");
            if((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_RCE)&& 
                (rrcrce_get_rce_sub_state() == RRCRCE_WAIT_FOR_SRB_SETUP_CNF))
            {
              WRRC_MSG0_HIGH("dont call abort sib, as rce wll do so if req");
            }
            else
            {
              /* Signal SIB procedure to clear up the active event, if any */
              rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_OOS);
            }


            if (rrcllc_cmd_under_process.chan_config.hsdpa_inactive_to_active == TRUE)
            {
              /* For FACH->HS failure scenario for Physical Channel Failure, make HSDPA
              to TRUE so that MAC could be in sync with RRC */
              WRRC_MSG0_HIGH("RRCHS:Force HSDPA stat to ACTIVE");
              rrc_set_hsdpa_status(HSDPA_ACTIVE);

#ifdef FEATURE_WCDMA_HS_FACH
              /*To be on safer side, set HS status in FACH to FALSE here.*/
              rrcllc_set_hs_status_in_e_fach(ordered_config_ptr, FALSE);
#endif /*FEATURE_WCDMA_HS_FACH*/
  
            }
#ifdef FEATURE_WCDMA_MIMO

           
            if(rrc_get_hsdpa_status()==HSDPA_ACTIVE)
            {
              l1_dl_hs_mimo_action_enum_type mimo_action 
                    =rrcllc_get_mimo_action_in_config();
              
              if((mimo_action == L1_MIMO_START) || (mimo_action == L1_MIMO_RECFG) )
              {
                rrcllc_update_mimo_status(RRC_MIMO_ACTIVE);
              }
              else if(mimo_action == L1_MIMO_STOP)
              {
                rrcllc_update_mimo_status(RRC_MIMO_INACTIVE);
              }
            }
#endif/* FEATURE_WCDMA_MIMO*/

            (void)rrcllc_send_rrc_channel_config_cnf(rrcllc_cmd_under_process.procedure,
                                                     rrcllc_cmd_under_process.chan_config_transaction_id,
                                                     RRCLLC_CHAN_CFG_FAILURE_PHY_CHL);

          } 

          if(iho_failure == TRUE)
          {
            iho_failure = FALSE;
            /* Dequeue internal LLC queue and free all buffers */
            while( q_check(&llc_cmd_q) != NULL )
            {
              if((llc_stored_cmd_ptr = (rrc_cmd_type *) q_get(&llc_cmd_q))!= NULL)
              {
                if(llc_stored_cmd_ptr->cmd_hdr.cmd_id == RRC_LOWER_LAYER_DEACT_REQ)
                {
                  WRRC_MSG0_HIGH("Handling DEACT req");
                  rrcllc_next_substate = rrcllc_idle_handler(llc_stored_cmd_ptr);
                  rrcllc_free_cmd_buf(llc_stored_cmd_ptr);
                  llc_stored_cmd_ptr = NULL;
                  break;
                }
                else if(llc_stored_cmd_ptr->cmd_hdr.cmd_id == RRC_STOP_LOWER_LAYER_REQ)
                {
                  WRRC_MSG0_HIGH("Handling STOP_LOWER_LAYER_REQ");
                  rrcllc_next_substate = rrcllc_idle_handler(llc_stored_cmd_ptr);
                  rrcllc_free_cmd_buf(llc_stored_cmd_ptr);
                  llc_stored_cmd_ptr = NULL;
                  break;
                }
                else if((llc_stored_cmd_ptr->cmd_hdr.cmd_id == RRC_CHANNEL_CONFIG_REQ) &&
                  (llc_stored_cmd_ptr->cmd.chan_config_req.next_state ==
                  RRC_STATE_DISCONNECTED) &&
                  (llc_stored_cmd_ptr->cmd.chan_config_req.rrc_state_change_required))
                {
                  WRRC_MSG0_HIGH("Handling Chl config request (to IDLE)");
                  rrcllc_next_substate = rrcllc_idle_handler(llc_stored_cmd_ptr);
                  rrcllc_free_cmd_buf(llc_stored_cmd_ptr);
                  llc_stored_cmd_ptr = NULL;
                  break;
                }
                else
                {
                  /* If Measurement request or TVM is found also free the
                   * embedded pointer inside the command
                   */
                  WRRC_MSG1_HIGH("Freeing command %d",llc_stored_cmd_ptr->cmd_hdr.cmd_id);
                  rrcllc_free_cmd_and_embedded_buf(llc_stored_cmd_ptr);
                  llc_stored_cmd_ptr = NULL;
                }
              }
            }
          }
        } /* else status is false*/
      } /* rrcllc_cmd_under_process.valid */
      break;

    case RRC_CPHY_COMPRESSED_MODE_IND:
      if (rrcllc_modify_cm_info_in_current_config(&cmd_ptr->cmd.cm_ind) == SUCCESS)
      {
        rrcllc_send_compressed_mode_run_time_error_ind(&cmd_ptr->cmd.cm_ind);
      }
      break;

    case RRC_STOP_LOWER_LAYER_REQ:
    case RRC_RNTI_UPDATE_REQ:
    case RRC_LLC_CMD_REQ:
    case RRC_RESET_L1_REQ:
    case RRC_LOWER_LAYER_DEACT_REQ:
    case RRC_CHANNEL_CONFIG_REQ:
    case RRC_CELL_RESELECTION_REQ:
    case RRC_ABORT_CIPH_CONFIG_REQ:
    case RRC_CIPH_CONFIG_REQ:

      if(( ((uint32)cmd_ptr->cmd_hdr.cmd_id) & (uint32)CMD_BASE_MASK ) == (uint32)RRC_INT_CMD_BASE)
      {
        (void)rrcllc_put_cmd_on_queue(cmd_ptr);
        MSG_MED("RRC Internal cmd recvd", 0, 0, 0);
      }
      break;

    default:
      WRRC_MSG1_ERROR("Cmd 0x%x not expected in LLC_WAIT_CPHY_CHANNEL_IND",
                                   cmd_ptr->cmd_hdr.cmd_id);
      break;
  } /* switch() */

  return(rrcllc_next_substate);

} /* rrcllc_wait_cphy_channel_ind_handler */

/*====================================================================
FUNCTION: rrcllc_send_reset_l1_cnf()

DESCRIPTION:
  This function sends a L1 RESET CNF to the internal command queue

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
#ifdef FEATURE_DUAL_SIM
void rrcllc_send_reset_l1_cnf(void)
{
  /* local cmd var to send confirm back to RRC procs */
  rrc_cmd_type   *cmd_ptr;
  cmd_ptr = rrc_get_int_cmd_buf();
  cmd_ptr->cmd_hdr.cmd_id = RRC_RESET_L1_CNF;
  rrc_put_int_cmd(cmd_ptr);
  return;
}
#endif

/*====================================================================
FUNCTION: rrcllc_wait_cphy_idle_cnf_handler()

DESCRIPTION:
  This function is a handler for LLC_WAIT_CPHY_IDLE_CNF state and
  takes care of all incoming commands and Confirms from RRC procedures,
  MAC, RLC and L1.

DEPENDENCIES:
  None

RETURN VALUE:
  Next LLC state.

SIDE EFFECTS:
  None.
====================================================================*/
static rrcllc_substate_e_type rrcllc_wait_cphy_idle_cnf_handler(rrc_cmd_type *cmd_ptr)
{
#ifdef FEATURE_RRC_L1_ERROR_RECOVERY_P1
  rrc_state_e_type  rrc_state = rrc_get_state();
#endif
  rrcllc_substate_e_type  rrcllc_next_substate = LLC_WAIT_CPHY_IDLE_CNF;

  MSG_MED("Cmd 0x%x recvd in LLC_WAIT_CPHY_IDLE_CNF",
                          cmd_ptr->cmd_hdr.cmd_id, 0, 0);

  /*
    Cases for intentional dumping of commands
  */
  if((cmd_ptr->cmd_hdr.cmd_id == RRC_LLC_CMD_REQ)&&
      (cmd_ptr->cmd.rrc_llc_req.cmd_dest == LAYER1_PHY)&&
      (cmd_ptr->cmd.rrc_llc_req.l1_cmd.cmd_id == CPHY_MEASUREMENT_REQ) &&
      (rrcllc_cmd_under_process.chan_config.current_cmd_engine == LLC_RELEASE_ALL_CHAN_ENGINE))
  {
    WRRC_MSG1_HIGH("Ignore the Measurement request to L1 as Release All Channel engine is running and LLC substate is %d",rrcllc_next_substate);
    rrc_free_embedd_buf_llc_req(cmd_ptr );
    return rrcllc_next_substate;
  }
  
#ifdef FEATURE_DUAL_SIM
  /*If Preemption handling is in progress and CSP is waiting for RESET L1 CNF, ignore the cmds to L1 as L1 is being put to IDLE*/
  if((rrc_csp_waiting_to_release_lock()) && 
     (rrcllc_cmd_under_process.rrc_current_cmd_id == RRC_RESET_L1_REQ) &&
     (rrcllc_cmd_under_process.send_reset_l1_cnf))
  {
     boolean ignore_cmd = FALSE;
     if((cmd_ptr->cmd_hdr.cmd_id == RRC_LLC_CMD_REQ) &&
        (cmd_ptr->cmd.rrc_llc_req.cmd_dest == LAYER1_PHY))
     {
       switch(cmd_ptr->cmd.rrc_llc_req.l1_cmd.cmd_id)
       {
         case CPHY_MEASUREMENT_REQ:
          rrc_free_embedd_buf_llc_req(cmd_ptr );
         case CPHY_DRX_REQ:
         case CPHY_CELL_PARM_REQ:
         case CPHY_CELL_TRANSITION_REQ:
          ignore_cmd = TRUE;
          WRRC_MSG1_HIGH("Ignore L1 cmd %d as Preemption handling is in progress",cmd_ptr->cmd.rrc_llc_req.l1_cmd.cmd_id);
          break;
         default:
          break;
       }
     }
     if(ignore_cmd)
     {
       return rrcllc_next_substate;
     }
  }
#endif

  switch(cmd_ptr->cmd_hdr.cmd_id)
  {
    case RRC_CPHY_IDLE_CNF:
      WRRC_MSG0_HIGH("Rcv'd CPHY_IDLE_CNF from L1");

#ifdef FEATURE_RRC_CAPTURE_L1_DEADLOCK
      /* Stop timer for L1 deadlock detection */
      rrctmr_stop_timer( RRCTMR_L1_DEADLOCK_DETECT_TIMER );
#endif

#ifdef FEATURE_RRC_DELAY_ERR_FATAL
      /* Stop Delay Err Fatal timer if started*/
      if (rrctmr_get_remaining_time(RRCTMR_DELAY_ERR_FATAL_TIMER) > 0) 
      {
        rrctmr_stop_timer(RRCTMR_DELAY_ERR_FATAL_TIMER);
        WRRC_MSG0_ERROR("Stopped Delay Err Fatal timer in IDLE_CNF");
      }
#endif /*FEATURE_RRC_DELAY_ERR_FATAL*/

#ifdef FEATURE_RRC_L1_ERROR_RECOVERY_P1
      if(cmd_ptr->cmd.idle_cnf.status)
      {
#endif
        /*lint -save -e539 */
        if((rrcllc_cmd_under_process.valid) &&
           (rrcllc_cmd_under_process.rrc_current_cmd_id == RRC_CHANNEL_CONFIG_REQ))
        {
          if(rrcllc_command_engine(rrcllc_current_substate, &rrcllc_next_substate)
             == FAILURE)
          {
            ERR_FATAL("RRC Config request processing failure", 0, 0, 0);
          }
          if(rrcllc_next_substate == LLC_IDLE)
          {
            /* This implies no more lower layer commands are to be sent - Can this happen
             * in LLC_IDLE ?
             */
            /* Send a RRC Config CNF back to the procedure and change RRC state */
            if((rrcllc_cmd_under_process.valid) &&
               (rrcllc_cmd_under_process.rrc_current_cmd_id == RRC_CHANNEL_CONFIG_REQ))
            {
              rrcllc_next_substate = rrcllc_handle_completion_of_chan_config_req();
            } /* if(rrcllc_cmd_under_process.valid)... */
          } /* if(rrcllc_next_substate == LLC_IDLE) */
        } /* if(rrcllc_cmd_under_process.valid)... */
        else
        {
          rrcllc_next_substate = LLC_IDLE;

#ifdef FEATURE_DUAL_SIM
          if((rrcllc_cmd_under_process.valid) &&
             (rrcllc_cmd_under_process.rrc_current_cmd_id == RRC_RESET_L1_REQ) &&
             (rrcllc_cmd_under_process.send_reset_l1_cnf))
          {
            rrcllc_send_reset_l1_cnf();
          }
#endif

          /* Initialize LLC here with a NON-Startup initialization type */
          rrcllc_init(RRCLLC_RE_INIT);
        }
        /*lint -restore */
#ifdef FEATURE_RRC_L1_ERROR_RECOVERY_P1
      }
      else
      {
        /* Trigger error recovery */
        if((rrc_state == RRC_STATE_DISCONNECTED) ||
           (rrcrce_get_num_retries_count() >= 4))
        {
          /* Start recovery procedure */
          /* Send a CPHY_STOP_WCDMA_MODE_REQ */
          rrcllc_cmd_under_process.wcdma_stop_cause = L1_RAT_CHANGE;
          rrcllc_cmd_under_process.err_recovery_in_progress = TRUE;
          rrcllc_cphy_stop_wcdma_mode_req();
          rrcllc_next_substate = LLC_WAIT_CPHY_STOP_WCDMA_MODE_CNF;
        }
        else
        {
          ERR_FATAL("No error recovery in RRC state %d",rrc_state,0,0);
        }
      }
#endif /* FEATURE_RRC_L1_ERROR_RECOVERY_P1 */

      break;

    case RRC_CPHY_COMPRESSED_MODE_IND:
      if (rrcllc_modify_cm_info_in_current_config(&cmd_ptr->cmd.cm_ind) == SUCCESS)
      {
        rrcllc_send_compressed_mode_run_time_error_ind(&cmd_ptr->cmd.cm_ind);
      }
      break;

    case RRC_STOP_LOWER_LAYER_REQ:
    case RRC_RNTI_UPDATE_REQ:
    case RRC_LLC_CMD_REQ:
    case RRC_RESET_L1_REQ:
    case RRC_LOWER_LAYER_DEACT_REQ:
    case RRC_CHANNEL_CONFIG_REQ:
    case RRC_CELL_RESELECTION_REQ:
    case RRC_ABORT_CIPH_CONFIG_REQ:
    case RRC_CIPH_CONFIG_REQ:
    case RRC_CONN_MODE_DEEP_SLEEP_REQ:
    case RRC_CONN_MODE_DEEP_SLEEP_WAKEUP_REQ:
      if(( ((uint32)cmd_ptr->cmd_hdr.cmd_id) & CMD_BASE_MASK ) == (uint32)RRC_INT_CMD_BASE)
      {
        (void)rrcllc_put_cmd_on_queue(cmd_ptr);
        MSG_MED("RRC Internal cmd recvd", 0, 0, 0);
      }
      break;

    default:
      WRRC_MSG1_ERROR("Cmd 0x%x not expected in LLC_WAIT_CPHY_IDLE_CNF",
                                   cmd_ptr->cmd_hdr.cmd_id);
      break;
  } /* switch() */

  return(rrcllc_next_substate);

} /* rrcllc_wait_cphy_idle_cnf_handler */

/*====================================================================
FUNCTION: rrcllc_wait_cphy_drx_cnf_handler()

DESCRIPTION:
  This function is a handler for LLC_WAIT_CPHY_DRX_CNF state.

DEPENDENCIES:
  None

RETURN VALUE:
  Next LLC state.

SIDE EFFECTS:
  None.
====================================================================*/
static rrcllc_substate_e_type rrcllc_wait_cphy_drx_cnf_handler(rrc_cmd_type *cmd_ptr)
{

  rrcllc_substate_e_type  rrcllc_next_substate = LLC_WAIT_CPHY_DRX_CNF;

  MSG_MED("Cmd 0x%x recvd in LLC_WAIT_CPHY_DRX_CNF",
                          cmd_ptr->cmd_hdr.cmd_id, 0, 0);

  switch(cmd_ptr->cmd_hdr.cmd_id)
  {
    case RRC_CPHY_DRX_CNF:
#ifdef FEATURE_RRC_CAPTURE_L1_DEADLOCK
      /* Stop timer for L1 deadlock detection */
      rrctmr_stop_timer( RRCTMR_L1_DEADLOCK_DETECT_TIMER );
#endif

#ifdef FEATURE_RRC_DELAY_ERR_FATAL
      /* Stop Delay Err Fatal timer if started*/
      if (rrctmr_get_remaining_time(RRCTMR_DELAY_ERR_FATAL_TIMER) > 0) 
      {
        rrctmr_stop_timer(RRCTMR_DELAY_ERR_FATAL_TIMER);
        WRRC_MSG0_ERROR("Stopped Delay Err Fatal timer in DRX_CNF");
      }
#endif /*FEATURE_RRC_DELAY_ERR_FATAL*/

      WRRC_MSG0_HIGH("Rcv'd CPHY_DRX_CNF from L1");
      rrcllc_next_substate = LLC_IDLE;
      break;

    case RRC_CPHY_COMPRESSED_MODE_IND:
      if (rrcllc_modify_cm_info_in_current_config(&cmd_ptr->cmd.cm_ind) == SUCCESS)
      {
        rrcllc_send_compressed_mode_run_time_error_ind(&cmd_ptr->cmd.cm_ind);
      }
      break;

    case RRC_STOP_LOWER_LAYER_REQ:
    case RRC_RNTI_UPDATE_REQ:
    case RRC_LLC_CMD_REQ:
    case RRC_RESET_L1_REQ:
    case RRC_LOWER_LAYER_DEACT_REQ:
    case RRC_CHANNEL_CONFIG_REQ:
    case RRC_CELL_RESELECTION_REQ:
    case RRC_ABORT_CIPH_CONFIG_REQ:
    case RRC_CIPH_CONFIG_REQ:
      if(( ((uint32)cmd_ptr->cmd_hdr.cmd_id) & CMD_BASE_MASK ) == (uint32)RRC_INT_CMD_BASE)
      {
        (void)rrcllc_put_cmd_on_queue(cmd_ptr);
        MSG_MED("RRC Internal cmd recvd", 0, 0, 0);
      }
      break;

    default:
      WRRC_MSG1_ERROR("Cmd 0x%x not expected in LLC_WAIT_CPHY_DRX_CNF",
                                   cmd_ptr->cmd_hdr.cmd_id);
      break;
  } /* switch() */

  return(rrcllc_next_substate);

} /* rrcllc_wait_cphy_drx_cnf_handler */


/*====================================================================
FUNCTION: rrcllc_wait_cphy_start_wcdma_mode_cnf_handler()

DESCRIPTION:
  This function is a handler for LLC_WAIT_CPHY_START_WCDMA_MODE_CNF state and
  takes care of all incoming commands and Confirms from RRC procedures,
  MAC, RLC and L1.

DEPENDENCIES:
  None

RETURN VALUE:
  Next LLC state.

SIDE EFFECTS:
  None.
====================================================================*/
static rrcllc_substate_e_type rrcllc_wait_cphy_start_wcdma_mode_cnf_handler(rrc_cmd_type *cmd_ptr)
{
  rrcllc_substate_e_type  rrcllc_next_substate = LLC_WAIT_CPHY_START_WCDMA_MODE_CNF;

  MSG_MED("Cmd 0x%x recvd in LLC_WAIT_CPHY_START_WCDMA_MODE_CNF",
                          cmd_ptr->cmd_hdr.cmd_id, 0, 0);

  switch(cmd_ptr->cmd_hdr.cmd_id)
  {
    case RRC_CPHY_START_WCDMA_MODE_CNF:

#ifdef FEATURE_RRC_CAPTURE_L1_DEADLOCK
      /* Stop timer for L1 deadlock detection */
      rrctmr_stop_timer( RRCTMR_L1_DEADLOCK_DETECT_TIMER);
#endif

      WRRC_MSG0_HIGH("Rcv'd RRC_CPHY_START_WCDMA_MODE_CNF from L1");

#ifdef FEATURE_RRC_L1_ERROR_RECOVERY_P1
      if(rrcllc_cmd_under_process.err_recovery_in_progress)
      {
        rrcllc_cmd_under_process.err_recovery_in_progress = FALSE;
        /* Start Error recovery procedure */
        WRRC_MSG0_ERROR("Start: ERR_FATAL recovery");
        rrcllc_next_substate = rrcllc_err_fatal_recovery_handler();
      }
      else
#endif /* FEATURE_RRC_L1_ERROR_RECOVERY_P1 */
      {
        if ((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP) && 
            (rrcllc_cmd_under_process.rrc_current_cmd_id == RRC_CONN_MODE_DEEP_SLEEP_WAKEUP_REQ)) 
        {
          WRRC_MSG0_HIGH("Rvcd start_cnf for RRC_CONN_MODE_DEEP_SLEEP_WAKEUP_REQ");
          
          rrcllc_next_substate = LLC_IDLE;
        }
        else
        {
          ERR_FATAL("Unexpected CPHY_START_WCDMA_MODE_CNF",0,0,0);
        }
      }
      break;

    case RRC_LOWER_LAYER_DEACT_REQ:
      if(( (cmd_ptr->cmd_hdr.cmd_id) & CMD_BASE_MASK ) == RRC_INT_CMD_BASE)
      {
        (void)rrcllc_put_cmd_on_queue(cmd_ptr);
      }
      break;

    default:
      (void)rrcllc_put_cmd_on_queue(cmd_ptr);

      break;
  } /* switch() */

  return(rrcllc_next_substate);

} /* rrcllc_wait_cphy_start_wcdma_mode_cnf_handler */

#ifdef FEATURE_UMTS_1X_HANDOVER_UMTSMSM
#error code not present
#endif

/*====================================================================
FUNCTION: rrcllc_wait_cphy_stop_wcdma_mode_cnf_handler()

DESCRIPTION:
  This function is a handler for LLC_WAIT_CPHY_STOP_WCDMA_MODE_CNF state and
  takes care of all incoming commands and Confirms from RRC procedures,
  MAC, RLC and L1.

DEPENDENCIES:
  None

RETURN VALUE:
  Next LLC state.

SIDE EFFECTS:
  None.
====================================================================*/
static rrcllc_substate_e_type rrcllc_wait_cphy_stop_wcdma_mode_cnf_handler(rrc_cmd_type *cmd_ptr)
{
  rrc_state_e_type rrc_state;
  rrcllc_substate_e_type  rrcllc_next_substate = LLC_WAIT_CPHY_STOP_WCDMA_MODE_CNF;
#ifdef FEATURE_WRLF_SYSTEM_SEL
  rrc_cmd_type     *llc_stored_cmd_ptr;
  rrc_cmd_type     *llc_next_stored_cmd_ptr;
#endif

  MSG_MED("Cmd 0x%x recvd in LLC_WAIT_CPHY_STOP_WCDMA_MODE_CNF",
                          cmd_ptr->cmd_hdr.cmd_id, 0, 0);

  switch(cmd_ptr->cmd_hdr.cmd_id)
  {
    case RRC_CPHY_STOP_WCDMA_MODE_CNF:
      WRRC_MSG0_HIGH("Rcv'd RRC_CPHY_STOP_WCDMA_MODE_CNF from L1");

#ifdef FEATURE_RRC_CAPTURE_L1_DEADLOCK
      /* Stop timer for L1 deadlock detection */
      rrctmr_stop_timer( RRCTMR_L1_DEADLOCK_DETECT_TIMER);
#endif

#ifdef FEATURE_TRIPLE_SIM
      /*Send CTCH not supported indication to deactivate BMC on WCDMA Stop*/
      rrcbmc_send_cell_change_on_wcdma_stop();
#endif

      if(rrcllc_cmd_under_process.err_recovery_in_progress)
      {
        WRRC_MSG0_ERROR("ERR Recovery ON - cleaning lower layers");
        if(ordered_config.set_status == OC_NOT_SET)
        {
          /* Copy CC to OC ONLY IF Current Config is being used at present */
          rrcllc_copy_cc_to_oc();
        }

        /* Initailize MAC data to release all Transport Channels */
        rrcllc_init_ordered_config_mac_info(ORDERED_CONFIG);

       rrcllc_set_hs_mac_l1_info_inactive();

        /* Send MAC DL Config request */
        rrcllc_cmac_dl_config_req(NO_SYNC_WITH_L1);
        rrcllc_set_mac_eul_action_to_stop_if_eul_is_active(FALSE);
#ifdef FEATURE_WCDMA_DC_HSUPA
        rrcllc_set_mac_sec_eul_action_to_stop_if_eul_is_active(FALSE);
#endif /* FEATURE_WCDMA_DC_HSUPA */
#ifdef FEATURE_WCDMA_HS_RACH
        rrchsrach_set_hsrach_action_to_stop_if_active(FALSE);
#endif


#ifdef FEATURE_HSPA_CALL_STATUS_IND
        rrc_send_hspa_call_status_info();
#endif /* FEATURE_HSPA_CALL_STATUS_IND*/

        /* Send MAC UL Config request */
        rrcllc_cmac_ul_config_req(RECONFIG_MAC, NO_SYNC_WITH_L1);
        rrcllc_crlc_release_all_req();
#ifdef FEATURE_UMTS_PDCP
        /* Send CPDCP_CONFIG_REQ to release all PDCP entities. */
        rrcllc_cpdcp_release_all_req();
#endif /* FEATURE_UMTS_PDCP*/

        /* If a change of state was requested, change the RRC state now */
        rrc_state = rrc_get_state();

        if(rrc_state != RRC_STATE_DISCONNECTED)
        {
          WRRC_MSG0_HIGH("UE in connecting");
          /* This procesiing only when next state is Disconnected */
          rrc_initiate_state_change(RRC_STATE_DISCONNECTED);
        }

        /* Send START_WCDMA_MODE_REQ and wait for confirmation from L1 */
        rrcllc_cphy_start_wcdma_req();
        rrcllc_next_substate = LLC_WAIT_CPHY_START_WCDMA_MODE_CNF;
      }
      else
      {
        if((rrcllc_cmd_under_process.valid) &&
           (rrcllc_cmd_under_process.rrc_current_cmd_id == RRC_STOP_LOWER_LAYER_REQ))
        {
#ifdef FEATURE_WRLF_SYSTEM_SEL
          if(RRC_IS_CONN_MODE_OOS_SRCH_IN_PROGRESS())
          {
            WRRC_MSG0_HIGH("WRLF: Sending RRC_STOP_LOWER_LAYER_CNF to MCM");
            (void)rrcllc_send_rrc_stop_lower_layer_cnf();

            /* Dequeue internal LLC queue and free all buffers */
            llc_stored_cmd_ptr = (rrc_cmd_type *) q_check(&llc_cmd_q);
            while( llc_stored_cmd_ptr != NULL )
            {
              WRRC_MSG1_HIGH("WRLF: Cmd 0x%x in llc queue", llc_stored_cmd_ptr->cmd_hdr.cmd_id);
              llc_next_stored_cmd_ptr = (rrc_cmd_type *) q_next(&llc_cmd_q, &llc_stored_cmd_ptr->cmd_hdr.link);
              if(!((llc_stored_cmd_ptr->cmd_hdr.cmd_id == RRC_CHANNEL_CONFIG_REQ) &&
                   (llc_stored_cmd_ptr->cmd.chan_config_req.rrc_state_change_required) &&
                   (llc_stored_cmd_ptr->cmd.chan_config_req.next_state == RRC_STATE_DISCONNECTED)))
              {
#ifdef FEATURE_Q_NO_SELF_QPTR
                q_delete(&llc_cmd_q, &llc_stored_cmd_ptr->cmd_hdr.link );
#else
                q_delete( &llc_stored_cmd_ptr->cmd_hdr.link );
#endif

                /* If Measurement request or TVM is found also free the
                       * embedded pointer inside the command
                       */
                WRRC_MSG1_HIGH("WRLF: Cmd to be freed from llc queue", llc_stored_cmd_ptr->cmd_hdr.cmd_id);
                rrcllc_free_cmd_and_embedded_buf(llc_stored_cmd_ptr);
                llc_stored_cmd_ptr = NULL;
              }
               llc_stored_cmd_ptr = llc_next_stored_cmd_ptr;
            }

            /* Initialize Command under process data */
            rrcllc_init_cmd_under_process_data();

            rrcllc_next_substate = LLC_IDLE;
          }
          else
#endif
          {
            if(rrcllc_command_engine(rrcllc_current_substate, &rrcllc_next_substate)
               == FAILURE)
            {
              ERR_FATAL("RRC Stop Lower Layer request failure", 0, 0, 0);
            }
            if(rrcllc_next_substate == LLC_IDLE)
            {
              /* This implies no more lower layer commands are to be sent */
              /* Send a RRC Config CNF back to the procedure and change RRC state */
              MSG_MED("Sending RRC_STOP_LOWER_LAYER_CNF to procedure %d",
                           rrcllc_cmd_under_process.procedure, 0, 0);
              (void)rrcllc_send_rrc_stop_lower_layer_cnf();

              /* If a change of state was requested, change the RRC state now */
              rrc_state = rrc_get_state();

              if(rrc_state != RRC_STATE_DISCONNECTED)
              {
                /* This procesiing only when next state is Disconnected */
                rrc_initiate_state_change(RRC_STATE_DISCONNECTED);

                /* Set LLC state back to LLC_WAIT_FOR_STATE_CHG_IND to waut for Release Confirm */
                rrcllc_clear_config_all_db();
                /* Get out of here */
                rrcllc_next_substate = LLC_IDLE;
              
                if(rrc_state == RRC_STATE_CONNECTING)
                {
                  WRRC_MSG0_ERROR("Resolved OOS and RCE race condition");
                }
              }
              else /* Next and current state - both disconnected or next state NOT disconnected (not possible ?) */
              {
                /* Initialize Ordered and Current Configs */
                rrcllc_init_ordered_config_status_and_data(RRC_STATE_DISCONNECTED);
                rrcllc_init_config_data(current_config_ptr, RRC_STATE_DISCONNECTED);
  
                /* Clear RLC Logical Channel Info in LCM */
                rrclcm_clear_rlc_lc_info();
                /* Initialize LLC and initialize Command under process */
                rrcllc_init(RRCLLC_RE_INIT_FREE_Q);

                /* Get out of here */
                rrcllc_next_substate = LLC_IDLE;

              } /* next RRC state is not different than current one */
            }  /* If next state is LLC_IDLE */
          }
        } /* if(rrcllc_cmd_under_process.valid)... */
        else if ((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP) && 
                 (rrcllc_cmd_under_process.rrc_current_cmd_id == RRC_CONN_MODE_DEEP_SLEEP_REQ)) 
        {
          WRRC_MSG0_HIGH("Rvcd stop_cnf for RRC_CONN_MODE_DEEP_SLEEP_REQ");
          rrcllc_next_substate = LLC_IDLE;
        }
      }

      break;

    case RRC_LOWER_LAYER_DEACT_REQ:
      if(( ((uint32)cmd_ptr->cmd_hdr.cmd_id) & CMD_BASE_MASK ) == (uint32)RRC_INT_CMD_BASE)
      {
        (void)rrcllc_put_cmd_on_queue(cmd_ptr);
        MSG_MED("RRC Internal cmd recvd", 0, 0, 0);
      }
      break;

    case RRC_LLC_CMD_REQ:
      if(cmd_ptr->cmd.rrc_llc_req.cmd_dest == LAYER1_PHY)
      {
        if(cmd_ptr->cmd.rrc_llc_req.l1_cmd.cmd_id == CPHY_MEASUREMENT_REQ)
        {
          (void)rrcllc_put_cmd_on_queue(cmd_ptr);
          MSG_MED("RRC Internal cmd recvd", 0, 0, 0);
        }
        else if(cmd_ptr->cmd.rrc_llc_req.l1_cmd.cmd_id == CPHY_ACQ_REQ)
        {
          (void)rrcllc_put_cmd_on_queue(cmd_ptr);
        }
        else if(cmd_ptr->cmd.rrc_llc_req.l1_cmd.cmd_id == CPHY_SUSPEND_WCDMA_MODE_REQ )
        {
          (void)rrcllc_put_cmd_on_queue(cmd_ptr);
        }
      }
      else if(cmd_ptr->cmd.rrc_llc_req.cmd_dest == LAYER2_MAC_UL)
      {
        if(cmd_ptr->cmd.rrc_llc_req.l2_ul_cmd.cmd_id == CMAC_UL_TRAFFIC_VOLUME_CONFIG_REQ)
        {
          (void)rrcllc_put_cmd_on_queue(cmd_ptr);
        }
      }
      break;

    case RRC_CONN_MODE_DEEP_SLEEP_WAKEUP_REQ:
      if(( ((uint32)cmd_ptr->cmd_hdr.cmd_id) & CMD_BASE_MASK ) == (uint32)RRC_INT_CMD_BASE)
      {
        WRRC_MSG0_HIGH("Deep Sleep wakeup req rcvd when wting for stop_cnf. EnQ it");
        (void)rrcllc_put_cmd_on_queue(cmd_ptr);        
      }
      break;

    case RRC_CHANNEL_CONFIG_REQ:
      if(((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP) &&
             (rrcllc_cmd_under_process.rrc_current_cmd_id == RRC_CONN_MODE_DEEP_SLEEP_REQ) &&
                 (cmd_ptr->cmd.chan_config_req.procedure == RRC_PROCEDURE_CSP))
#ifdef FEATURE_WRLF_SYSTEM_SEL
         || ((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_MCM) &&
                 (rrcllc_cmd_under_process.rrc_current_cmd_id == RRC_STOP_LOWER_LAYER_REQ) &&
                     (cmd_ptr->cmd.chan_config_req.procedure == RRC_PROCEDURE_CSP))
#endif
         )
      {
        WRRC_MSG0_HIGH("Chan config req rcvd when wting for stop_cnf. EnQ it");
        (void)rrcllc_put_cmd_on_queue(cmd_ptr);        
      }
      else
      {
        if((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_MCM) &&
            (rrcllc_cmd_under_process.rrc_current_cmd_id == RRC_STOP_LOWER_LAYER_REQ) &&
             (cmd_ptr->cmd.chan_config_req.procedure == RRC_PROCEDURE_CU) && 
              (cmd_ptr->cmd.chan_config_req.chan_config_reason == RRCLLC_CHAN_CFG_REASON_PCH_TO_FACH))
        {
          WRRC_MSG0_HIGH("Trashing Channel config req from CU as WCDMA STOP MODE REQ is in progress");
        }
        else
        {
          if(cmd_ptr->cmd.chan_config_req.rrc_channel_config_cnf_required)
          {
            (void)rrcllc_send_rrc_channel_config_cnf(cmd_ptr->cmd.chan_config_req.procedure,
                                                     cmd_ptr->cmd.chan_config_req.transaction_id,
                                                     RRCLLC_CHAN_CFG_FAILURE_INCOMPATIBLE_STATE); 
          }
        }
      }
      break;

      case RRC_RESET_L1_REQ:
        if((rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP) && 
                 (rrcllc_cmd_under_process.rrc_current_cmd_id == RRC_CONN_MODE_DEEP_SLEEP_REQ) 
           )
        {
          WRRC_MSG0_HIGH("Reset L1 req rcvd when wting for stop_cnf. EnQ it");
          (void)rrcllc_put_cmd_on_queue(cmd_ptr);        
        }
      break;
      
    default:
      WRRC_MSG1_ERROR("Cmd 0x%x not expected in LLC_WAIT_CPHY_STOP_WCDMA_MODE_CNF",
                                   cmd_ptr->cmd_hdr.cmd_id);
      break;
  } /* switch() */

  return(rrcllc_next_substate);

} /* rrcllc_wait_cphy_stop_wcdma_mode_cnf_handler */


/*====================================================================
FUNCTION: rrcllc_wait_cphy_suspend_wcdma_mode_cnf_handler()

DESCRIPTION:
  This function is a handler for LLC_WAIT_CPHY_SUSPEND_WCDMA_MODE_CNF state and
  takes care of all incoming commands and Confirms from RRC procedures,
  MAC, RLC and L1.

DEPENDENCIES:
  None

RETURN VALUE:
  Next LLC state.

SIDE EFFECTS:
  None.
====================================================================*/
static rrcllc_substate_e_type rrcllc_wait_cphy_suspend_wcdma_mode_cnf_handler(rrc_cmd_type *cmd_ptr)
{

  rrcllc_substate_e_type  rrcllc_next_substate = LLC_WAIT_CPHY_SUSPEND_WCDMA_MODE_CNF;

  MSG_MED("Cmd 0x%x recvd in LLC_WAIT_CPHY_SUSPEND_WCDMA_MODE_CNF",
                          cmd_ptr->cmd_hdr.cmd_id, 0, 0);

  switch(cmd_ptr->cmd_hdr.cmd_id)
  {
    case RRC_CPHY_SUSPEND_WCDMA_MODE_CNF:
      WRRC_MSG0_HIGH("Rcv'd RRC_CPHY_SUSPEND_WCDMA_MODE_CNF from L1");
#ifdef FEATURE_RRC_CAPTURE_L1_DEADLOCK
      /* Stop timer for L1 deadlock detection */
      rrctmr_stop_timer( RRCTMR_L1_DEADLOCK_DETECT_TIMER );
#endif
      rrc_funneled_cmd_cnf(cmd_ptr, rrcllc_cmd_under_process.procedure, cmd_ptr->cmd_hdr.cmd_id);
      rrcllc_next_substate = LLC_IDLE;
      break;

    case RRC_CPHY_COMPRESSED_MODE_IND:
      if (rrcllc_modify_cm_info_in_current_config(&cmd_ptr->cmd.cm_ind) == SUCCESS)
      {
        rrcllc_send_compressed_mode_run_time_error_ind(&cmd_ptr->cmd.cm_ind);
      }
      break;

    case RRC_STOP_LOWER_LAYER_REQ:
    case RRC_RNTI_UPDATE_REQ:
    case RRC_LLC_CMD_REQ:
    case RRC_RESET_L1_REQ:
    case RRC_LOWER_LAYER_DEACT_REQ:
    case RRC_CHANNEL_CONFIG_REQ:
    case RRC_CELL_RESELECTION_REQ:
    case RRC_ABORT_CIPH_CONFIG_REQ:
    case RRC_CIPH_CONFIG_REQ:
      if((cmd_ptr->cmd_hdr.cmd_id == RRC_CHANNEL_CONFIG_REQ ) &&
         (cmd_ptr->cmd.chan_config_req.procedure == RRC_PROCEDURE_ASU ))
      {
        WRRC_MSG0_HIGH("Received Chan Config Req for ASU in Standby State");
        (void)rrcllc_send_rrc_channel_config_cnf( RRC_PROCEDURE_ASU,
                                            cmd_ptr->cmd.chan_config_req.transaction_id,
                                            RRCLLC_CHAN_CFG_FAILURE_INCOMPATIBLE_STATE);
      }
      else
      {
        if(( ((uint32)cmd_ptr->cmd_hdr.cmd_id) & CMD_BASE_MASK ) == (uint32)RRC_INT_CMD_BASE)
        {
          (void)rrcllc_put_cmd_on_queue(cmd_ptr);
          MSG_MED("RRC Internal cmd recvd", 0, 0, 0);
        }
      }
      break;

    default:
      WRRC_MSG1_ERROR("Cmd 0x%x not expected in LLC_WAIT_CPHY_SUSPEND_WCDMA_MODE_CNF",
                                   cmd_ptr->cmd_hdr.cmd_id);
      break;
  } /* switch() */

  return(rrcllc_next_substate);

} /* rrcllc_wait_cphy_suspend_wcdma_mode_cnf_handler */


/*====================================================================
FUNCTION: rrcllc_wait_cphy_resume_wcdma_mode_cnf_handler()

DESCRIPTION:
  This function is a handler for LLC_WAIT_CPHY_RESUME_WCDMA_MODE_CNF state and
  takes care of all incoming commands and Confirms from RRC procedures,
  MAC, RLC and L1.

DEPENDENCIES:
  None

RETURN VALUE:
  Next LLC state.

SIDE EFFECTS:
  None.
====================================================================*/
static rrcllc_substate_e_type rrcllc_wait_cphy_resume_wcdma_mode_cnf_handler(rrc_cmd_type *cmd_ptr)
{

  rrcllc_substate_e_type  rrcllc_next_substate = LLC_WAIT_CPHY_RESUME_WCDMA_MODE_CNF;
  rrc_cmd_type *llc_stored_cmd_ptr;
  rrc_state_e_type rrc_state;

  MSG_MED("Cmd 0x%x recvd in LLC_WAIT_CPHY_RESUME_WCDMA_MODE_CNF",
                         cmd_ptr->cmd_hdr.cmd_id, 0, 0);

  if(cmd_ptr->cmd_hdr.cmd_id == RRC_LOWER_LAYER_DEACT_REQ)
  {
    WRRC_MSG0_HIGH("Received RRC_LOWER_LAYER_DEACT_REQ in LLC_WAIT_CPHY_RESUME_WCDMA_MODE_CNF Substate");
    rrcllc_recvd_deact_req_waiting_for_resume_cnf = TRUE;
  }

  switch(cmd_ptr->cmd_hdr.cmd_id)
  {
    case RRC_CPHY_RESUME_WCDMA_MODE_CNF:
      WRRC_MSG0_HIGH("Rcv'd RRC_CPHY_RESUME_WCDMA_MODE_CNF from L1");
#ifdef FEATURE_RRC_CAPTURE_L1_DEADLOCK
      /* Stop timer for L1 deadlock detection */
      rrctmr_stop_timer( RRCTMR_L1_DEADLOCK_DETECT_TIMER );
#endif

      /* First send the confirm back to MCM */
      rrc_funneled_cmd_cnf(cmd_ptr, rrcllc_cmd_under_process.procedure, cmd_ptr->cmd_hdr.cmd_id);

      /* Set the next LLC substate to IDLE */
      rrcllc_next_substate = LLC_IDLE;

      /* If RESUME_CNF has failed then clean up the LLC queue as cell
       * selection will be initiated by MCM
       */

      if(cmd_ptr->cmd.resume_cnf.status == FALSE)
      {
        WRRC_MSG0_HIGH("Resume failed, cleaning LLC queue/data");
        /*Clearing the Variable */
        rrcllc_recvd_deact_req_waiting_for_resume_cnf = FALSE;
        /* Dequeue internal LLC queue and free all buffers */
        while( q_check(&llc_cmd_q) != NULL )
        {
          if((llc_stored_cmd_ptr = (rrc_cmd_type *) q_get(&llc_cmd_q))!= NULL)
          {
            if(llc_stored_cmd_ptr->cmd_hdr.cmd_id == RRC_LOWER_LAYER_DEACT_REQ)
            {
              WRRC_MSG0_HIGH("DEACT req during WCDMA RESUME");
              rrcllc_next_substate = rrcllc_idle_handler(llc_stored_cmd_ptr);
              rrcllc_free_cmd_buf(llc_stored_cmd_ptr);
              llc_stored_cmd_ptr = NULL;
              break;
            }
            else if(llc_stored_cmd_ptr->cmd_hdr.cmd_id == RRC_STOP_LOWER_LAYER_REQ)
            {
              WRRC_MSG0_HIGH("STOP WCDMA req during WCDMA RESUME");
              rrcllc_next_substate = rrcllc_idle_handler(llc_stored_cmd_ptr);
              rrcllc_free_cmd_buf(llc_stored_cmd_ptr);
              llc_stored_cmd_ptr = NULL;
              break;
            }
            else if((llc_stored_cmd_ptr->cmd_hdr.cmd_id == RRC_LLC_CMD_REQ) &&
                      (llc_stored_cmd_ptr->cmd.rrc_llc_req.cmd_dest == LAYER1_PHY) &&
                      (llc_stored_cmd_ptr->cmd.rrc_llc_req.l1_cmd.cmd_id == CPHY_CELL_BAR_REQ)
#ifdef FEATURE_DUAL_SIM
                    && (cmd_ptr->cmd.resume_cnf.fail_type != WL1_FAILED_NO_WRM_LOCK)
#endif
                )
            {
              WRRC_MSG0_HIGH("CPHY_CELL_BAR_REQ req during WCDMA RESUME");
              rrcllc_update_generic_cmd_process_data(llc_stored_cmd_ptr);
              rrcllc_next_substate = rrcllc_process_funneled_cmd_req(llc_stored_cmd_ptr);
              rrcllc_free_cmd_buf(llc_stored_cmd_ptr);
              llc_stored_cmd_ptr = NULL;
            }
            else
            {
              /* If Measurement request or TVM is found also free the
               * embedded pointer inside the command
               */
              WRRC_MSG1_HIGH("Freeing command %d",llc_stored_cmd_ptr->cmd_hdr.cmd_id);
              rrcllc_free_cmd_and_embedded_buf(llc_stored_cmd_ptr);
              llc_stored_cmd_ptr = NULL;
            }
          }
        }
#ifdef FEATURE_WCDMA_HS_RACH        
       WRRC_MSG0_HIGH("RRCHSRACH: Reset hspa_rnti_stored_cell_pch on resume failure");
       rrchsrach_set_hspa_rnti_stored_cell_pch(((config_ptr_in_use == CURRENT_CONFIG)? current_config_ptr : ordered_config_ptr),FALSE);
#endif

        rrc_state = rrc_get_state();

        if( (RRC_STATE_CELL_FACH != rrc_state) && (RRC_STATE_CELL_DCH != rrc_state) 
            && (RRC_STATE_CELL_PCH != rrc_state) && (RRC_STATE_URA_PCH != rrc_state) )
        {
          if(rrcllc_next_substate == LLC_IDLE)
          {
            /* Initialize Ordered and Current Configs */
            rrcllc_init_ordered_config_status_and_data(RRC_STATE_DISCONNECTED);
            rrcllc_init_config_data(current_config_ptr, RRC_STATE_DISCONNECTED);

            /* Clear RLC Logical Channel Info in LCM */
            rrclcm_clear_rlc_lc_info();
            rrcllc_crlc_release_all_req();
#ifdef FEATURE_UMTS_PDCP
            /* Send CPDCP_CONFIG_REQ to release all PDCP entities. */
            rrcllc_cpdcp_release_all_req();
#endif /* FEATURE_UMTS_PDCP*/

            /* Initialize LLC and initialize Command under process */
            rrcllc_init(RRCLLC_RE_INIT_FREE_Q);
          }
        }
        else /* We are in DCH/FACH */
        {
          /* Initialize LLC and initialize Command under process */
          rrcllc_init(RRCLLC_RE_INIT_FREE_Q);
          rrcllc_next_substate = LLC_IDLE;
        }
      }
      else /* RESUME of L1 is successful */
      {
        if (TRUE == current_config_ptr->e_dch_transmission)
        {
          /* update 'l1_e_req_mask' in current_config database with L1_EUL_START 
             because this will be copied to ordered config before sending CPHY_SETUP_REQ 
             through RRC_CHANNEL_CONFIG_REQ */
          MSG_HIGH("RRCEUL: e_dch_txn is TRUE, set L1_EUL_START(prev: %d), MAC-e: %d, reset: %d", 
            current_config_ptr->l1_e_req_mask,
            current_config_ptr->mac_eul_action, 
            current_config_ptr->mac_e_reset_indicator);

          current_config_ptr->l1_e_req_mask = L1_EUL_START;

          /* update L1 E DL information to indicate ADD accordingly */
          rrcllc_update_l1_e_dl_info_for_old_config(FALSE
#ifdef FEATURE_WCDMA_DC_HSUPA
                                                  , FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
                                                    );
        }

        if (TRUE == current_config_ptr->cpc_dtx_drx_status)
        {
          /* update 'l1_cpc_dtx_req_mask' in current_config database with L1_CPC_DTX_START 
                     because this will be copied to ordered config before sending CPHY_SETUP_REQ 
                     through RRC_CHANNEL_CONFIG_REQ */
          WRRC_MSG2_HIGH("RRCCPC: dtx_drx_status is TRUE, set L1_CPC_DTX_START(prev: %d),enb_delay(prev:%)", 
                  current_config_ptr->l1_cpc_dtx_req_mask,
                  current_config_ptr->dtx_drx_timing_info.enabling_delay);
          current_config_ptr->l1_cpc_dtx_req_mask = L1_CPC_DTX_START;
          current_config_ptr->dtx_drx_timing_info.enabling_delay = L1_NUM_RADIO_FRAMES_0;

          current_config_ptr->l1_hs_scch_order_action = L1_HS_SCCH_ORDER_ACTION_RESTORE;


          if (TRUE == current_config_ptr->cpc_drx_status)
          {
            WRRC_MSG1_HIGH("RRCCPC: cpc_drx_status is TRUE, set L1_CPC_DRX_START(prev: %d)", 
                                  current_config_ptr->l1_cpc_drx_req_mask);
            current_config_ptr->l1_cpc_drx_req_mask = L1_CPC_DRX_START;
          }

        }

#ifdef FEATURE_WCDMA_DC_HSUPA
        if (TRUE == current_config_ptr->sec_e_dch_transmission)
        {
          /* update 'l1_e_req_mask' in current_config database with L1_EUL_START 
             because this will be copied to ordered config before sending CPHY_SETUP_REQ 
             through RRC_CHANNEL_CONFIG_REQ */
          MSG_HIGH("DC_HSUPA: e_dch_txn is TRUE, set L1_SEC_EUL_START(prev: %d), MAC-e: %d, reset: %d", 
            current_config_ptr->l1_sec_e_req_mask,
            current_config_ptr->mac_sec_eul_action, 
            current_config_ptr->mac_e_reset_indicator);

          current_config_ptr->l1_sec_e_req_mask = L1_EUL_START;

          /* update L1 E DL information to indicate ADD accordingly */
          rrcllc_update_l1_e_dl_info_for_old_config(FALSE
#ifdef FEATURE_WCDMA_DC_HSUPA
                                                  , TRUE
#endif /* FEATURE_WCDMA_DC_HSUPA */
                                                    );
        }

#endif

      }
      if(cmd_ptr->cmd.resume_cnf.status == TRUE)
      {
        if(rrcllc_recvd_deact_req_waiting_for_resume_cnf == TRUE)
        {
          rrcllc_recvd_deact_req_waiting_for_resume_cnf = FALSE;
          while( q_check(&llc_cmd_q) != NULL )
          {
            if((llc_stored_cmd_ptr = (rrc_cmd_type *) q_get(&llc_cmd_q)) != NULL)
            {
              if(llc_stored_cmd_ptr->cmd_hdr.cmd_id == RRC_LOWER_LAYER_DEACT_REQ)
              {
                WRRC_MSG0_HIGH("DEACT req during WCDMA RESUME");
                rrcllc_next_substate = rrcllc_idle_handler(llc_stored_cmd_ptr);
                rrcllc_free_cmd_buf(llc_stored_cmd_ptr);
                llc_stored_cmd_ptr = NULL;
                break;
              }
              else
              {
                WRRC_MSG0_HIGH("Freeing Pending messages in LLC Queue beacuse DEACT REQ is received");
                rrcllc_free_cmd_and_embedded_buf(llc_stored_cmd_ptr);
                llc_stored_cmd_ptr = NULL;
              }
            }
          }
        }
      }

      break;

    case RRC_CPHY_COMPRESSED_MODE_IND:
      if (rrcllc_modify_cm_info_in_current_config(&cmd_ptr->cmd.cm_ind) == SUCCESS)
      {
        rrcllc_send_compressed_mode_run_time_error_ind(&cmd_ptr->cmd.cm_ind);
      }
      break;

    case RRC_STOP_LOWER_LAYER_REQ:
    case RRC_RNTI_UPDATE_REQ:
    case RRC_LLC_CMD_REQ:
    case RRC_RESET_L1_REQ:
    case RRC_LOWER_LAYER_DEACT_REQ:
    case RRC_CHANNEL_CONFIG_REQ:
    case RRC_CELL_RESELECTION_REQ:
    case RRC_ABORT_CIPH_CONFIG_REQ:
    case RRC_CIPH_CONFIG_REQ:
      if(( ((uint32)cmd_ptr->cmd_hdr.cmd_id) & CMD_BASE_MASK ) == (uint32)RRC_INT_CMD_BASE)
      {
        (void)rrcllc_put_cmd_on_queue(cmd_ptr);
        MSG_MED("RRC Internal cmd recvd", 0, 0, 0);
      }
      break;

    default:
      WRRC_MSG1_ERROR("Cmd 0x%x not expected in LLC_WAIT_CPHY_RESUME_WCDMA_MODE_CNF",
                                   cmd_ptr->cmd_hdr.cmd_id);
      break;
  } /* switch() */

  return(rrcllc_next_substate);

} /* rrcllc_wait_cphy_resume_wcdma_mode_cnf_handler */

/*====================================================================
FUNCTION: rrcllc_wait_cphy_deactivate_cnf_handler()

DESCRIPTION:
  This function is a handler for LLC_WAIT_CPHY_DEACTIVATE_CNF state and
  takes care of all incoming commands and Confirms from RRC procedures,
  MAC, RLC and L1.

DEPENDENCIES:
  None

RETURN VALUE:
  Next LLC state.

SIDE EFFECTS:
  None.
====================================================================*/
static rrcllc_substate_e_type rrcllc_wait_cphy_deactivate_cnf_handler(rrc_cmd_type *cmd_ptr)
{

  rrcllc_substate_e_type  rrcllc_next_substate = LLC_WAIT_CPHY_DEACTIVATE_CNF;

  MSG_MED("Cmd 0x%x recvd in LLC_WAIT_CPHY_DEACTIVATE_CNF",
                          cmd_ptr->cmd_hdr.cmd_id, 0, 0);

  switch(cmd_ptr->cmd_hdr.cmd_id)
  {
    case RRC_CPHY_DEACTIVATE_CNF:
      WRRC_MSG0_HIGH("Rcv'd RRC_CPHY_DEACTIVATE_CNF from L1");

      if((rrcllc_cmd_under_process.valid) &&
         (rrcllc_cmd_under_process.rrc_current_cmd_id == RRC_LOWER_LAYER_DEACT_REQ))
      {
        if(rrcllc_command_engine(rrcllc_current_substate, &rrcllc_next_substate)
           == FAILURE)
        {
          ERR_FATAL("RRC Lower Layer Deact request failure", 0, 0, 0);
        }
        if(rrcllc_next_substate == LLC_IDLE)
        {
          /* This implies no more lower layer commands are to be sent */
          /* Send a RRC Config CNF back to the procedure and change RRC state */
          MSG_MED("Sending RRC_LOWER_LAYER_DEACT_CNF to procedure %d",
                         rrcllc_cmd_under_process.procedure, 0, 0);
          (void)rrcllc_send_rrc_lower_layer_deact_cnf();

          /* Do not change the RRC state */
          /* Initialize LLC here with a Free Queue initialization type */
          rrcllc_init(RRCLLC_RE_INIT_FREE_Q);

        }  /* If next state is LLC_IDLE */
      } /* if(rrcllc_cmd_under_process.valid)... */
      break;

    case RRC_CPHY_COMPRESSED_MODE_IND:
      if (rrcllc_modify_cm_info_in_current_config(&cmd_ptr->cmd.cm_ind) == SUCCESS)
      {
        rrcllc_send_compressed_mode_run_time_error_ind(&cmd_ptr->cmd.cm_ind);
      }
      break;

    case RRC_STOP_LOWER_LAYER_REQ:
    case RRC_RNTI_UPDATE_REQ:
    case RRC_LLC_CMD_REQ:
    case RRC_RESET_L1_REQ:
    case RRC_LOWER_LAYER_DEACT_REQ:
    case RRC_CHANNEL_CONFIG_REQ:
    case RRC_CELL_RESELECTION_REQ:
    case RRC_ABORT_CIPH_CONFIG_REQ:
    case RRC_CIPH_CONFIG_REQ:
      if(( ((uint32)cmd_ptr->cmd_hdr.cmd_id) & CMD_BASE_MASK ) == (uint32)RRC_INT_CMD_BASE)
      {
        (void)rrcllc_put_cmd_on_queue(cmd_ptr);
        MSG_MED("RRC Internal cmd recvd", 0, 0, 0);
      }
      break;

    default:
      WRRC_MSG1_ERROR("Cmd 0x%x not expected in LLC_WAIT_CPHY_IDLE_CNF",
                                   cmd_ptr->cmd_hdr.cmd_id);
      break;
  } /* switch() */

  return(rrcllc_next_substate);

} /* rrcllc_wait_cphy_deactivate_cnf_handler */


/*====================================================================
FUNCTION: rrcllc_wait_cphy_acq_cnf_handler()

DESCRIPTION:
  This function is a handler for LLC_WAIT_CPHY_ACQ_CNF state and
  takes care of all incoming commands and Confirms from RRC procedures,
  MAC, RLC and L1.

DEPENDENCIES:
  None

RETURN VALUE:
  Next LLC state.

SIDE EFFECTS:
  None.
====================================================================*/
static rrcllc_substate_e_type rrcllc_wait_cphy_acq_cnf_handler(rrc_cmd_type *cmd_ptr)
{

  rrcllc_substate_e_type  rrcllc_next_substate = LLC_WAIT_CPHY_ACQ_CNF;

  MSG_MED("Cmd 0x%x recvd in LLC_WAIT_CPHY_ACQ_CNF",
                          cmd_ptr->cmd_hdr.cmd_id, 0, 0);

  switch(cmd_ptr->cmd_hdr.cmd_id)
  {
    case RRC_CPHY_ACQ_CNF:
#ifdef FEATURE_RRC_CAPTURE_L1_DEADLOCK
      /* Stop timer for L1 deadlock detection */
      rrctmr_stop_timer( RRCTMR_L1_DEADLOCK_DETECT_TIMER );
#endif

#ifdef FEATURE_RRC_DELAY_ERR_FATAL
      /* Stop Delay Err Fatal timer if started*/
      if (rrctmr_get_remaining_time(RRCTMR_DELAY_ERR_FATAL_TIMER) > 0) 
      {
        rrctmr_stop_timer(RRCTMR_DELAY_ERR_FATAL_TIMER);
        WRRC_MSG0_ERROR("Stopped Delay Err Fatal timer in ACQ_CNF");
      }
#endif /*FEATURE_RRC_DELAY_ERR_FATAL*/

      WRRC_MSG0_HIGH("Rcv'd CPHY_ACQ_CNF from L1");
      rrc_funneled_cmd_cnf(cmd_ptr, rrcllc_cmd_under_process.procedure, cmd_ptr->cmd_hdr.cmd_id);
      /* Trash all commands till the 1st useful command is dequeued */
      rrcllc_next_substate = rrcllc_trash_cmds_till_first_useful(TRASH_CONFIG_REQ);
      break;

    case RRC_STOP_LOWER_LAYER_REQ:
    case RRC_RNTI_UPDATE_REQ:
    case RRC_LLC_CMD_REQ:
    case RRC_RESET_L1_REQ:
    case RRC_LOWER_LAYER_DEACT_REQ:
    case RRC_CHANNEL_CONFIG_REQ:
    case RRC_CELL_RESELECTION_REQ:
    case RRC_ABORT_CIPH_CONFIG_REQ:
    case RRC_CIPH_CONFIG_REQ:
      if(( ((uint32)cmd_ptr->cmd_hdr.cmd_id) & CMD_BASE_MASK ) == (uint32)RRC_INT_CMD_BASE)
      {
        (void)rrcllc_put_cmd_on_queue(cmd_ptr);
        MSG_MED("RRC Internal cmd recvd", 0, 0, 0);
      }
      break;

    default:
      WRRC_MSG1_ERROR("Cmd 0x%x not expected in LLC_WAIT_CPHY_ACQ_CNF",
                                   cmd_ptr->cmd_hdr.cmd_id);
      break;
  } /* switch() */

  return(rrcllc_next_substate);

} /* rrcllc_wait_cphy_acq_cnf_handler */


/*====================================================================
FUNCTION: rrcllc_wait_cphy_freq_scan_cnf_handler()

DESCRIPTION:
  This function is a handler for LLC_WAIT_CPHY_FREQ_SCAN_CNF state and
  takes care of all incoming commands and Confirms from RRC procedures,
  MAC, RLC and L1.

DEPENDENCIES:
  None

RETURN VALUE:
  Next LLC state.

SIDE EFFECTS:
  None.
====================================================================*/
static rrcllc_substate_e_type
rrcllc_wait_freq_scan_cnf_handler(rrc_cmd_type *cmd_ptr)
{

  rrcllc_substate_e_type  rrcllc_next_substate = LLC_WAIT_CPHY_FREQ_SCAN_CNF;

  MSG_MED("Cmd 0x%x recvd in LLC_WAIT_CPHY_FREQ_SCAN_CNF",
                          cmd_ptr->cmd_hdr.cmd_id, 0, 0);

  switch(cmd_ptr->cmd_hdr.cmd_id)
  {
    case RRC_CPHY_FREQ_SCAN_CNF:
      WRRC_MSG0_HIGH("Rcv'd RRC_CPHY_FREQ_SCAN_CNF from L1");
      rrc_funneled_cmd_cnf(cmd_ptr, rrcllc_cmd_under_process.procedure, cmd_ptr->cmd_hdr.cmd_id);
      /* Trash all commands till the 1st useful command is dequeued */
      rrcllc_next_substate = rrcllc_trash_cmds_till_first_useful(TRASH_CONFIG_REQ);
      break;

    case RRC_CPHY_COMPRESSED_MODE_IND:
      if (rrcllc_modify_cm_info_in_current_config(&cmd_ptr->cmd.cm_ind) == SUCCESS)
      {
        rrcllc_send_compressed_mode_run_time_error_ind(&cmd_ptr->cmd.cm_ind);
      }
      break;

    case RRC_STOP_LOWER_LAYER_REQ:
    case RRC_RNTI_UPDATE_REQ:
    case RRC_LLC_CMD_REQ:
    case RRC_RESET_L1_REQ:
    case RRC_LOWER_LAYER_DEACT_REQ:
    case RRC_CHANNEL_CONFIG_REQ:
    case RRC_CELL_RESELECTION_REQ:
    case RRC_ABORT_CIPH_CONFIG_REQ:
    case RRC_CIPH_CONFIG_REQ:
      if(( ((uint32)cmd_ptr->cmd_hdr.cmd_id) & CMD_BASE_MASK ) == (uint32)RRC_INT_CMD_BASE)
      {
        (void)rrcllc_put_cmd_on_queue(cmd_ptr);
        MSG_MED("RRC Internal cmd recvd", 0, 0, 0);
      }
      break;

    default:
      WRRC_MSG1_ERROR("Cmd 0x%x not expected in LLC_WAIT_CPHY_FREQ_SCAN_CNF",
                                   cmd_ptr->cmd_hdr.cmd_id);
      break;
  } /* switch() */

  return(rrcllc_next_substate);

} /* rrcllc_wait_freq_scan_cnf_handler */


/*====================================================================
FUNCTION: rrcllc_wait_cphy_capability_cnf_handler()

DESCRIPTION:
  This function is a handler for LLC_WAIT_CPHY_CAPABILITY_CNF state and
  takes care of all incoming commands and Confirms from RRC procedures,
  MAC, RLC and L1.

DEPENDENCIES:
  None

RETURN VALUE:
  Next LLC state.

SIDE EFFECTS:
  None.
====================================================================*/
static rrcllc_substate_e_type
rrcllc_wait_cphy_capability_cnf_handler(rrc_cmd_type *cmd_ptr)
{

  rrcllc_substate_e_type  rrcllc_next_substate = LLC_WAIT_CPHY_CAPABILITY_CNF;

  MSG_MED("Cmd 0x%x recvd in LLC_WAIT_CPHY_CAPABILITY_CNF",
                          cmd_ptr->cmd_hdr.cmd_id, 0, 0);

  switch(cmd_ptr->cmd_hdr.cmd_id)
  {
    case RRC_CPHY_CAPABILITY_CNF:
      WRRC_MSG0_HIGH("Rcv'd RRC_CPHY_CAPABILITY_CNF from L1");
      rrc_funneled_cmd_cnf(cmd_ptr, rrcllc_cmd_under_process.procedure, cmd_ptr->cmd_hdr.cmd_id);
      rrcllc_next_substate = LLC_IDLE;
      break;

    case RRC_CPHY_COMPRESSED_MODE_IND:
      if (rrcllc_modify_cm_info_in_current_config(&cmd_ptr->cmd.cm_ind) == SUCCESS)
      {
        rrcllc_send_compressed_mode_run_time_error_ind(&cmd_ptr->cmd.cm_ind);
      }
      break;

    case RRC_STOP_LOWER_LAYER_REQ:
    case RRC_RNTI_UPDATE_REQ:
    case RRC_LLC_CMD_REQ:
    case RRC_RESET_L1_REQ:
    case RRC_LOWER_LAYER_DEACT_REQ:
    case RRC_CHANNEL_CONFIG_REQ:
    case RRC_CELL_RESELECTION_REQ:
    case RRC_ABORT_CIPH_CONFIG_REQ:
    case RRC_CIPH_CONFIG_REQ:
      if(( ((uint32)cmd_ptr->cmd_hdr.cmd_id) & CMD_BASE_MASK ) == (uint32)RRC_INT_CMD_BASE)
      {
        (void)rrcllc_put_cmd_on_queue(cmd_ptr);
        MSG_MED("RRC Internal cmd recvd", 0, 0, 0);
      }
      break;


    default:
      WRRC_MSG1_ERROR("Unexpected Cmd 0x%x in LLC_WAIT_CPHY_CAPABILITY_CNF",
                                   cmd_ptr->cmd_hdr.cmd_id);
      break;
  } /* switch() */

  return(rrcllc_next_substate);

} /* rrcllc_wait_cphy_capability_cnf_handler */



/*====================================================================
FUNCTION: rrcllc_wait_cphy_cell_select_cnf_handler()

DESCRIPTION:
  This function is a handler for LLC_WAIT_CPHY_CELL_SELECTION_CNF state and
  takes care of all incoming commands and Confirms from RRC procedures,
  MAC, RLC and L1.

DEPENDENCIES:
  None

RETURN VALUE:
  Next LLC state.

SIDE EFFECTS:
  None.
====================================================================*/
static rrcllc_substate_e_type
rrcllc_wait_cphy_cell_select_cnf_handler(rrc_cmd_type *cmd_ptr)
{

  rrcllc_substate_e_type  rrcllc_next_substate = LLC_WAIT_CPHY_CELL_SELECTION_CNF;

  MSG_MED("Cmd 0x%x recvd in LLC_WAIT_CPHY_CELL_SELECTION_CNF",
                          cmd_ptr->cmd_hdr.cmd_id, 0, 0);

  switch(cmd_ptr->cmd_hdr.cmd_id)
  {
    case RRC_CPHY_CELL_SELECTION_CNF:
      WRRC_MSG0_HIGH("Rcv'd RRC_CPHY_CELL_SELECTION_CNF");
#ifdef FEATURE_RRC_CAPTURE_L1_DEADLOCK
      /* Stop timer for L1 deadlock detection */
      rrctmr_stop_timer( RRCTMR_L1_DEADLOCK_DETECT_TIMER );
#endif
      rrc_funneled_cmd_cnf(cmd_ptr, rrcllc_cmd_under_process.procedure, cmd_ptr->cmd_hdr.cmd_id);
      rrcllc_next_substate = LLC_IDLE;
      break;

    case RRC_STOP_LOWER_LAYER_REQ:
    case RRC_RNTI_UPDATE_REQ:
    case RRC_LLC_CMD_REQ:
    case RRC_RESET_L1_REQ:
    case RRC_LOWER_LAYER_DEACT_REQ:
    case RRC_CHANNEL_CONFIG_REQ:
    case RRC_CELL_RESELECTION_REQ:
    case RRC_ABORT_CIPH_CONFIG_REQ:
    case RRC_CIPH_CONFIG_REQ:
      if(( ((uint32)cmd_ptr->cmd_hdr.cmd_id) & CMD_BASE_MASK ) == (uint32)RRC_INT_CMD_BASE)
      {
        (void)rrcllc_put_cmd_on_queue(cmd_ptr);
        MSG_MED("RRC Internal cmd recvd", 0, 0, 0);
      }
      break;

    default:
      WRRC_MSG1_ERROR("Unexpected Cmd 0x%x in LLC_WAIT_CPHY_CELL_SELECTION_CNF",
                                   cmd_ptr->cmd_hdr.cmd_id);
      break;
  } /* switch() */

  return(rrcllc_next_substate);

} /* rrcllc_wait_cphy_cell_select_cnf_handler */


/*====================================================================
FUNCTION: rrcllc_wait_cphy_cell_trans_cnf_handler()

DESCRIPTION:
  This function is a handler for LLC_WAIT_CPHY_CELL_TRANSITION_CNF
  state and takes care of all incoming commands and Confirms from RRC
  procedures, MAC, RLC and L1.

DEPENDENCIES:
  None

RETURN VALUE:
  Next LLC state.

SIDE EFFECTS:
  None.
====================================================================*/
static rrcllc_substate_e_type
rrcllc_wait_cphy_cell_trans_cnf_handler(rrc_cmd_type *cmd_ptr)
{

  rrcllc_substate_e_type  rrcllc_next_substate = LLC_WAIT_CPHY_CELL_TRANSITION_CNF;

  MSG_MED("Cmd 0x%x recvd in LLC_WAIT_CPHY_CELL_TRANSITION_CNF",
                          cmd_ptr->cmd_hdr.cmd_id, 0, 0);

  switch(cmd_ptr->cmd_hdr.cmd_id)
  {
    case RRC_CPHY_CELL_TRANSITION_CNF:
      WRRC_MSG0_HIGH("Rcv'd RRC_CPHY_CELL_TRANSITION_CNF");

#ifdef FEATURE_RRC_CAPTURE_L1_DEADLOCK
      /* Stop timer for L1 deadlock detection */
      rrctmr_stop_timer( RRCTMR_L1_DEADLOCK_DETECT_TIMER );
#endif

#ifdef FEATURE_RRC_DELAY_ERR_FATAL
      /* Stop Delay Err Fatal timer if started*/
      if (rrctmr_get_remaining_time(RRCTMR_DELAY_ERR_FATAL_TIMER) > 0) 
      {
        rrctmr_stop_timer(RRCTMR_DELAY_ERR_FATAL_TIMER);
        WRRC_MSG0_ERROR("Stopped Delay Err Fatal timer in TRANS_CNF");
      }
#endif /*FEATURE_RRC_DELAY_ERR_FATAL*/

        if(cmd_ptr->cmd.cell_transition_cnf.status == TRUE)
        {
#ifdef FEATURE_QSH_EVENT_METRIC
          wrrc_qsh_update_serving_cell_metrics();
#endif
        }
      if((rrcllc_cmd_under_process.valid) &&
           (rrcllc_cmd_under_process.rrc_current_cmd_id == RRC_CELL_RESELECTION_REQ))
      {
        if(cmd_ptr->cmd.cell_transition_cnf.status == TRUE)
        {
          if(rrcllc_command_engine(rrcllc_current_substate, &rrcllc_next_substate)
               == FAILURE)
          {
              ERR_FATAL("RRC Config request processing failure", 0, 0, 0);
          }
          else if(rrcllc_next_substate == LLC_WAIT_NEW_CELL_IND)
          {
            /* This implies no more lower layer commands are to be sent. Send a RRC
             * RESLECTION CNF back to the procedure */
            if((rrcllc_cmd_under_process.valid) &&
               (rrcllc_cmd_under_process.rrc_current_cmd_id == RRC_CELL_RESELECTION_REQ))
            {
              /* A swapping ensures the data space used to configure lower layers
               * for reselection will not be used for configuration in the next
               * reconfiguration. If CC was used for reselection, a L2 Ack will
               * make CC point to that data space again, ensuring the above condition.
               */
              rrcllc_swap_oc_and_cc();

              /* First check if CCM still wants to proceed with reselection */
              if(rrcccm_waiting_for_reselection_cnf() == FALSE)
              {
                /* No need to send a CNF, nobody is waiting for it */
                rrcllc_next_substate = LLC_IDLE;
              }
              else
              {
                /* Processing of Cell Reselection request succeeded
                 * Send a Cell Reselection Confirm with a Success to the requesting procedure
                 */
                (void)rrcllc_send_rrc_cell_reselection_cnf(SUCCESS);
              }
            }
          } /* if(rrcllc_next_substate == LLC_WAIT_NEW_CELL_IND) */
        } /* Successful status in Cell Transition Confirm */
        else  /* Cell Transition Status is Failure */
        {
          /* Process the Setup Cnf failure */
          WRRC_MSG0_ERROR("Rxed Cell Trans Cnf failure");
          rrcllc_next_substate = LLC_IDLE;
          /* No more lower layer commands are to be sent */
          /* Send a Reselection CNF with Failure back to the procedure */
          WRRC_MSG1_HIGH("Sending RRC_RESELECTION_CNF Failure to procedure %d",
                         rrcllc_cmd_under_process.procedure);
#ifdef FEATURE_UPDATE_SIB7_IN_FACH
          if(rrc_get_state()== RRC_STATE_CELL_FACH)
          {
            rlc_lc_id_type    rlc_dl_log_chl_id;
            int i=0;
            if(rrcllc_cmd_under_process.chan_config.
                    phy_chan_action_list.pccpch_action == LLC_PHYCHAN_SETUP)
            {
              /* BCH setup failed */
              /* Make sure S_PCCPCH status reflects this:
               * Release CCTrCH ID allocated for S_PCCPCH, update status
               * in semi permanent data.
               */
              if(rrcllc_clear_cctrch_id(rrcllc_semi_permanent_data.dl_phy_chan.
                                        pccpch.cctrch_id)
                  == FAILURE)
              {
                WRRC_MSG1_ERROR("CCTrCH ID %d for S PCCPCH not cleared",
                      rrcllc_semi_permanent_data.dl_phy_chan.pccpch.cctrch_id);
              } /* If could not clear CCTrCH ID */
              rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up = FALSE;

              rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id(UE_LOGCHAN_BCCH,
                                                            BCCH_S_RADIO_BEARER_ID,
                                                            UE_MODE_TRANSPARENT);
              
              if (rlc_dl_log_chl_id != RRCLCM_RLC_LC_ID_NOT_FOUND) 
              {
                /* de-allocate LC_ID if only RLC action for BCCH was RLC_ESTABLISH */
                for (i = 0; i < rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.nchan; i ++) 
                {
                  if ((rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[i].lc_id == rlc_dl_log_chl_id)&&
                      (rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.chan_info[i].lc_type == UE_LOGCHAN_BCCH) &&
                      (rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_tm.dl_tm_act[i].action ==  RLC_ESTABLISH)) 
                  {
                    WRRC_MSG0_HIGH("Rel Log Chl for BCCH_S");
                    (void)rrclcm_deallocate_dl_rlc_lc_id(rlc_dl_log_chl_id);
                    /* also update config db */
                    if (reselection_config_ptr->rlc_dl_tm_parms.nchan)
                    {
                      reselection_config_ptr->rlc_dl_tm_parms.nchan --;
                    }
                    /* Set number of BCHs in MAC correctly */
                    if(reselection_config_ptr->mac_dl_parms.num_bchs)
                    {
                      reselection_config_ptr->mac_dl_parms.num_bchs --;
                    }                  
                    break;
                  }
                }
              }
            }
          }
#endif
#ifdef FEATURE_WCDMA_HS_FACH
          /*If reselection failed from non-EFACH to EFACH cell, make sure to reset the sccpch_is_up 
            to TRUE as we set it to FALSE while sending cell transition req*/
          if(rrcllc_get_hs_action_in_e_fach(reselection_config_ptr) == HSDPA_START)
          {
            WRRC_MSG0_HIGH("EFACH: Cell Transition from non eFACH -> eFACH cell failed");
            rrcllc_semi_permanent_data.dl_phy_chan.sccpch_is_up = TRUE;
          }
#endif
          {
            rrc_state_e_type temp_rrc_state = rrc_get_state();
            if(temp_rrc_state== RRC_STATE_DISCONNECTED ||
               temp_rrc_state== RRC_STATE_CELL_PCH||
               temp_rrc_state== RRC_STATE_URA_PCH)
            {
              rlc_lc_id_type    rlc_dl_log_chl_id;
              int i=0;
              rlc_dl_log_chl_id = rrclcm_check_dl_rlc_lc_id(UE_LOGCHAN_CTCH,
                                                            CTCH_RADIO_BEARER_ID,
                                                            UE_MODE_UNACKNOWLEDGED);
              
              if (rlc_dl_log_chl_id != RRCLCM_RLC_LC_ID_NOT_FOUND) 
              {
                for (i = 0; i < rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.nchan; i ++) 
                {
                  if ((rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[i].lc_id == rlc_dl_log_chl_id)&&
                      (rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.chan_info[i].lc_type == UE_LOGCHAN_CTCH) &&
                      (rrcllc_cmd_under_process.chan_config.rlc_config_req_list.dl_um.dl_um_act[i].action ==  RLC_ESTABLISH)) 
                  {
                    WRRC_MSG0_HIGH("Rel Log Chl for CTCH");
                    (void)rrclcm_deallocate_dl_rlc_lc_id(rlc_dl_log_chl_id);
                    /* also update config db */
                    break;
                  }
                }
              }
            }
          }

          /* Send a Failure status to the calling procedure */
          (void)rrcllc_send_rrc_cell_reselection_cnf(FAILURE);

          /* Clear Ordered Config if indicated in LLC Command under process */
          if(rrcllc_cmd_under_process.clear_oc_pending)
          {
            WRRC_MSG0_HIGH("Pending ClearOC on Cell Trans Cnf ");
            rrcllc_clear_ordered_config_now();
            rrcllc_cmd_under_process.clear_oc_pending = FALSE;
          }
        }  /* Cell Transition Status is Failure */
      } /* Reselection Engine is active */
      else
      {
        rrc_funneled_cmd_cnf(cmd_ptr, rrcllc_cmd_under_process.procedure, cmd_ptr->cmd_hdr.cmd_id);
        /*Call CSP function to indicate CSP that cel transition CNF is received*/
        rrc_csp_cell_trans_cnf_rcvd_at_llc();
        rrcllc_next_substate = LLC_IDLE;
      }
      break;

    case RRC_STOP_LOWER_LAYER_REQ:
    case RRC_RNTI_UPDATE_REQ:
    case RRC_LLC_CMD_REQ:
    case RRC_RESET_L1_REQ:
    case RRC_LOWER_LAYER_DEACT_REQ:
    case RRC_CHANNEL_CONFIG_REQ:
    case RRC_CELL_RESELECTION_REQ:
    case RRC_ABORT_CIPH_CONFIG_REQ:
    case RRC_CIPH_CONFIG_REQ:
      if(( ((uint32)cmd_ptr->cmd_hdr.cmd_id) & CMD_BASE_MASK ) == (uint32)RRC_INT_CMD_BASE)
      {
        (void)rrcllc_put_cmd_on_queue(cmd_ptr);
        MSG_MED("RRC Internal cmd recvd", 0, 0, 0);
      }
      break;

    default:
      WRRC_MSG1_ERROR("Unexpected Cmd 0x%x in LLC_WAIT_CPHY_CELL_TRANSITION_CNF",
                                   cmd_ptr->cmd_hdr.cmd_id);
      break;
  } /* switch() */

  return(rrcllc_next_substate);

} /* rrcllc_wait_cphy_cell_trans_cnf_handler */


/*====================================================================
FUNCTION: rrcllc_wait_cphy_meas_ctrl_cnf_handler()

DESCRIPTION:
  This function is a handler for LLC_WAIT_CPHY_MEAS_CTRL_CNF state and
  takes care of all incoming commands and Confirms from RRC procedures,
  MAC, RLC and L1.

DEPENDENCIES:
  None

RETURN VALUE:
  Next LLC state.

SIDE EFFECTS:
  None.
====================================================================*/
static rrcllc_substate_e_type
rrcllc_wait_cphy_meas_ctrl_cnf_handler(rrc_cmd_type *cmd_ptr)
{
  rrcllc_substate_e_type  rrcllc_next_substate = LLC_WAIT_CPHY_MEAS_CTRL_CNF;

  MSG_MED("Cmd 0x%x recvd in LLC_WAIT_CPHY_MEAS_CTRL_CNF",
                          cmd_ptr->cmd_hdr.cmd_id, 0, 0);

  switch(cmd_ptr->cmd_hdr.cmd_id)
  {
    case RRC_CPHY_MEAS_CTRL_CNF:
      WRRC_MSG0_HIGH("Rcv'd RRC_CPHY_MEAS_CTRL_CNF");
      rrc_funneled_cmd_cnf(cmd_ptr, rrcllc_cmd_under_process.procedure, cmd_ptr->cmd_hdr.cmd_id);
      rrcllc_next_substate = LLC_IDLE;
      break;

    case RRC_CPHY_COMPRESSED_MODE_IND:
      if (rrcllc_modify_cm_info_in_current_config(&cmd_ptr->cmd.cm_ind) == SUCCESS)
      {
        rrcllc_send_compressed_mode_run_time_error_ind(&cmd_ptr->cmd.cm_ind);
      }
      break;

    case RRC_STOP_LOWER_LAYER_REQ:
    case RRC_RNTI_UPDATE_REQ:
    case RRC_LLC_CMD_REQ:
    case RRC_RESET_L1_REQ:
    case RRC_LOWER_LAYER_DEACT_REQ:
    case RRC_CHANNEL_CONFIG_REQ:
    case RRC_CELL_RESELECTION_REQ:
    case RRC_ABORT_CIPH_CONFIG_REQ:
    case RRC_LLC_RE_EST_RLC_REQ:
    case RRC_CIPH_CONFIG_REQ:
      if(( ((uint32)cmd_ptr->cmd_hdr.cmd_id) & CMD_BASE_MASK ) == (uint32)RRC_INT_CMD_BASE)
      {
        (void)rrcllc_put_cmd_on_queue(cmd_ptr);
        MSG_MED("RRC Internal cmd recvd", 0, 0, 0);
      }
      break;

    case RRC_CPHY_ERROR_IND:
      WRRC_MSG0_HIGH("Rcv'd RRC_CPHY_ERROR_IND");
      /*Inform rrcmeas reg the trashing of meas failure */
      rrcmeas_trash_and_send_meas_failure();
      rrcllc_next_substate = LLC_IDLE;
      break;

    default:
      WRRC_MSG1_ERROR("Unexpected Cmd 0x%x in LLC_WAIT_CPHY_MEAS_CTRL_CNF",
                                   cmd_ptr->cmd_hdr.cmd_id);
      break;
  } /* switch() */

  return(rrcllc_next_substate);

} /* rrcllc_wait_cphy_meas_ctrl_cnf_handler */


/*====================================================================
FUNCTION: rrcllc_wait_rlc_tm_ul_cnf_handler()

DESCRIPTION:
  This function is a handler for LLC_WAIT_RLC_TM_UL_CNF
  state and takes care of all incoming commands and Confirms from RRC
  procedures, MAC, RLC and L1.

DEPENDENCIES:
  None

RETURN VALUE:
  Next LLC state.

SIDE EFFECTS:
  None.
====================================================================*/
static rrcllc_substate_e_type rrcllc_wait_rlc_tm_ul_cnf_handler(rrc_cmd_type *cmd_ptr)
{

  int          log_chl_index;
  rrcllc_substate_e_type  rrcllc_next_substate = LLC_WAIT_RLC_TM_UL_CNF;

  boolean   failure_flag = FALSE;

  MSG_MED("Cmd 0x%x recvd in LLC_WAIT_RLC_TM_UL_CNF",
                          cmd_ptr->cmd_hdr.cmd_id, 0, 0);

  switch(cmd_ptr->cmd_hdr.cmd_id)
  {
    case RRC_CRLC_UL_TM_CONFIG_CNF:
      {
        WRRC_MSG0_HIGH("Rcv'd RRC_CRLC_UL_TM_CONFIG_CNF");
        /* Look in the confirmation for a failure */
        for(log_chl_index = 0;
            log_chl_index < cmd_ptr->cmd.crlc_ul_tm_config_cnf.nchan;
            log_chl_index ++
           )
        {
          if(cmd_ptr->cmd.crlc_ul_tm_config_cnf.
              tm_config_result[log_chl_index].result == FAILURE)
          {
            failure_flag = TRUE;
            break;
          }
        }

        if(failure_flag == TRUE)
        {
          #ifdef FEATURE_RRC_L1_ERROR_RECOVERY_P1
          
          WRRC_MSG0_ERROR("Failure in RLC UL TM Cfg CNF handled by self-posting Ch Cfg to Idle");
          rrcllc_self_enqueue_channel_config_to_idle();
          rrcllc_next_substate = LLC_IDLE;

          #else
          
          ERR_FATAL("Failure in RLC UL TM Config CNF",0,0,0);

          #endif
        }
        else  /* No Failure */
        {

          if(rrcllc_command_engine(rrcllc_current_substate, &rrcllc_next_substate)
             == FAILURE)
          {
            ERR_FATAL("RRC Config request processing failure", 0, 0, 0);
          }

          if(rrcllc_next_substate == LLC_IDLE)
          {
            /* This implies no more lower layer commands are to be sent - Can this happen
             * in LLC_IDLE ?
             */
            /* Send a RRC Config CNF back to the procedure and change RRC state */
            if((rrcllc_cmd_under_process.valid) &&
               (rrcllc_cmd_under_process.rrc_current_cmd_id == RRC_CHANNEL_CONFIG_REQ))
            {
              if (rrcllc_cmd_under_process.chan_config.chan_cfg_status == RRCLLC_CHAN_CFG_SUCCESS)
              {
                rrcllc_next_substate = rrcllc_handle_completion_of_chan_config_req();
              }
              else
              {
                /* In the failure case send the channel config cnf to the procedure and enter
                LLC_IDLE */
                (void)rrcllc_send_rrc_channel_config_cnf(rrcllc_cmd_under_process.procedure,
                                       rrcllc_cmd_under_process.chan_config_transaction_id,
                                                         RRCLLC_CHAN_CFG_FAILURE_PHY_CHL);
              }
            } /* if(rrcllc_cmd_under_process.valid)... */
          } /* if(rrcllc_next_substate == LLC_IDLE) */

          else if(rrcllc_next_substate == LLC_WAIT_NEW_CELL_IND)
          {
            /* This implies no more lower layer commands are to be sent. Send a RRC
             * RESLECTION CNF back to the procedure */
            if((rrcllc_cmd_under_process.valid) &&
               (rrcllc_cmd_under_process.rrc_current_cmd_id == RRC_CELL_RESELECTION_REQ))
            {
              /* A swapping ensures the data space used to configure lower layers
               * for reselection will not be used for configuration in the next
               * reconfiguration. If CC was used for reselection, a L2 Ack will
               * make CC point to that data space again, ensuring the above condition.
               */

              rrcllc_swap_oc_and_cc();

              /* First check if CCM still wants to proceed with reselection */
              if(rrcccm_waiting_for_reselection_cnf() == FALSE)
              {
                /* No need to send a CNF, nobody is waiting for it */
                rrcllc_next_substate = LLC_IDLE;
              }
              else
              {
                /* Processing of Cell Reselection request succeeded
                 * Send a Cell Reselection Confirm with a Success to the requesting procedure
                 */
                (void)rrcllc_send_rrc_cell_reselection_cnf(SUCCESS);
              }
            }
          } /* if(rrcllc_next_substate == LLC_WAIT_NEW_CELL_IND) */
        } /* No failure in Confirm */
      }
      break;

    case RRC_CPHY_COMPRESSED_MODE_IND:
      if (rrcllc_modify_cm_info_in_current_config(&cmd_ptr->cmd.cm_ind) == SUCCESS)
      {
        rrcllc_send_compressed_mode_run_time_error_ind(&cmd_ptr->cmd.cm_ind);
      }
      break;

    case RRC_STOP_LOWER_LAYER_REQ:
    case RRC_RNTI_UPDATE_REQ:
    case RRC_LLC_CMD_REQ:
    case RRC_RESET_L1_REQ:
    case RRC_LOWER_LAYER_DEACT_REQ:
    case RRC_CHANNEL_CONFIG_REQ:
    case RRC_CELL_RESELECTION_REQ:
    case RRC_ABORT_CIPH_CONFIG_REQ:
    case RRC_CIPH_CONFIG_REQ:
      if(( ((uint32)cmd_ptr->cmd_hdr.cmd_id) & CMD_BASE_MASK ) == (uint32)RRC_INT_CMD_BASE)
      {
        (void)rrcllc_put_cmd_on_queue(cmd_ptr);
        MSG_MED("RRC Internal cmd recvd", 0, 0, 0);
      }
      break;

    default:
      WRRC_MSG1_ERROR("Cmd 0x%x not expected in LLC_WAIT_RLC_TM_UL_CNF",
                                   cmd_ptr->cmd_hdr.cmd_id);
      break;
  } /* switch() */

  return(rrcllc_next_substate);

} /* rrcllc_wait_rlc_tm_ul_cnf_handler */


/*====================================================================
FUNCTION: rrcllc_wait_rlc_tm_dl_cnf_handler()

DESCRIPTION:
  This function is a handler for LLC_WAIT_RLC_TM_DL_CNF
  state and takes care of all incoming commands and Confirms from RRC
  procedures, MAC, RLC and L1.

DEPENDENCIES:
  None

RETURN VALUE:
  Next LLC state.

SIDE EFFECTS:
  None.
====================================================================*/
static rrcllc_substate_e_type rrcllc_wait_rlc_tm_dl_cnf_handler(rrc_cmd_type *cmd_ptr)
{

  int          log_chl_index;
  boolean      failure_flag = FALSE;
  rrcllc_substate_e_type  rrcllc_next_substate = LLC_WAIT_RLC_TM_DL_CNF;

  MSG_MED("Cmd 0x%x recvd in LLC_WAIT_RLC_TM_DL_CNF",
                          cmd_ptr->cmd_hdr.cmd_id, 0, 0);

  switch(cmd_ptr->cmd_hdr.cmd_id)
  {
    case RRC_CRLC_DL_TM_CONFIG_CNF:
      {
        WRRC_MSG0_HIGH("Rcv'd RRC_CRLC_DL_TM_CONFIG_CNF");
        /* Look in the confirmation for a failure */
        for(log_chl_index = 0;
            log_chl_index < cmd_ptr->cmd.crlc_dl_tm_config_cnf.nchan;
            log_chl_index ++
           )
        {
          if(cmd_ptr->cmd.crlc_dl_tm_config_cnf.
              tm_config_result[log_chl_index].result == FAILURE)
          {
            failure_flag = TRUE;
            break;
          }
        }

        if(failure_flag == TRUE)
        {
          #ifdef FEATURE_RRC_L1_ERROR_RECOVERY_P1
          
          WRRC_MSG0_ERROR("Failure in RLC DL TM Cfg CNF handled by self-posting Ch Cfg to Idle");
          rrcllc_self_enqueue_channel_config_to_idle();
          rrcllc_next_substate = LLC_IDLE;

          #else
          
          ERR_FATAL("Failure in RLC DL TM Cfg CNF",0,0,0);

          #endif
        }
        else  /* No failure */
        {

          if(rrcllc_command_engine(rrcllc_current_substate, &rrcllc_next_substate)
             == FAILURE)
          {
            ERR_FATAL("RRC Config request processing failure", 0, 0, 0);
          }

          if(rrcllc_next_substate == LLC_IDLE)
          {
            /* This implies no more lower layer commands are to be sent
             */
            /* Send a RRC Config CNF back to the procedure and change RRC state */
            if((rrcllc_cmd_under_process.valid) &&
               (rrcllc_cmd_under_process.rrc_current_cmd_id == RRC_CHANNEL_CONFIG_REQ))
            {
              if (rrcllc_cmd_under_process.chan_config.chan_cfg_status == RRCLLC_CHAN_CFG_SUCCESS)
              {
                rrcllc_next_substate = rrcllc_handle_completion_of_chan_config_req();
              }
              else
              {
                /* In the failure case send the channel config cnf to the procedure and enter
                LLC_IDLE */
                (void)rrcllc_send_rrc_channel_config_cnf(rrcllc_cmd_under_process.procedure,
                                       rrcllc_cmd_under_process.chan_config_transaction_id,
                                                         RRCLLC_CHAN_CFG_FAILURE_PHY_CHL);
              }
            } /* if(rrcllc_cmd_under_process.valid)... */
          } /* if(rrcllc_next_substate == LLC_IDLE) */

          else if(rrcllc_next_substate == LLC_WAIT_NEW_CELL_IND)
          {
            /* This implies no more lower layer commands are to be sent. Send a RRC
             * RESLECTION CNF back to the procedure */
            if((rrcllc_cmd_under_process.valid) &&
               (rrcllc_cmd_under_process.rrc_current_cmd_id == RRC_CELL_RESELECTION_REQ))
            {
              /* A swapping ensures the data space used to configure lower layers
               * for reselection will not be used for configuration in the next
               * reconfiguration. If CC was used for reselection, a L2 Ack will
               * make CC point to that data space again, ensuring the above condition.
               */
              rrcllc_swap_oc_and_cc();

              /* First check if CCM still wants to proceed with reselection */
              if(rrcccm_waiting_for_reselection_cnf() == FALSE)
              {
                /* No need to send a CNF, nobody is waiting for it */
                rrcllc_next_substate = LLC_IDLE;
              }
              else
              {
                /* Processing of Cell Reselection request succeeded
                 * Send a Cell Reselection Confirm with a Success to the requesting procedure
                 */
                (void)rrcllc_send_rrc_cell_reselection_cnf(SUCCESS);
              }
            }
          } /* if(rrcllc_next_substate == LLC_WAIT_NEW_CELL_IND ) */
        } /* No failure */
      }
      break;

    case RRC_CPHY_COMPRESSED_MODE_IND:
      if (rrcllc_modify_cm_info_in_current_config(&cmd_ptr->cmd.cm_ind) == SUCCESS)
      {
        rrcllc_send_compressed_mode_run_time_error_ind(&cmd_ptr->cmd.cm_ind);
      }
      break;

    case RRC_STOP_LOWER_LAYER_REQ:
    case RRC_RNTI_UPDATE_REQ:
    case RRC_LLC_CMD_REQ:
    case RRC_RESET_L1_REQ:
    case RRC_LOWER_LAYER_DEACT_REQ:
    case RRC_CHANNEL_CONFIG_REQ:
    case RRC_CELL_RESELECTION_REQ:
    case RRC_ABORT_CIPH_CONFIG_REQ:
    case RRC_CIPH_CONFIG_REQ:
    case RRC_CONN_MODE_DEEP_SLEEP_REQ:
    case RRC_CONN_MODE_DEEP_SLEEP_WAKEUP_REQ:

      if(( ((uint32)cmd_ptr->cmd_hdr.cmd_id) & CMD_BASE_MASK ) == (uint32)RRC_INT_CMD_BASE)
      {
        (void)rrcllc_put_cmd_on_queue(cmd_ptr);
        MSG_MED("RRC Internal cmd recvd", 0, 0, 0);
      }
      break;

    default:
      WRRC_MSG1_ERROR("Cmd 0x%x not expected in LLC_WAIT_RLC_TM_DL_CNF",
                                   cmd_ptr->cmd_hdr.cmd_id);
      break;
  } /* switch() */

  return(rrcllc_next_substate);

} /* rrcllc_wait_rlc_tm_dl_cnf_handler */



/*====================================================================
FUNCTION: rrcllc_wait_rlc_um_ul_cnf_handler()

DESCRIPTION:
  This function is a handler for LLC_WAIT_RLC_UM_UL_CNF
  state and takes care of all incoming commands and Confirms from RRC
  procedures, MAC, RLC and L1.

DEPENDENCIES:
  None

RETURN VALUE:
  Next LLC state.

SIDE EFFECTS:
  None.
====================================================================*/
static rrcllc_substate_e_type rrcllc_wait_rlc_um_ul_cnf_handler(rrc_cmd_type *cmd_ptr)
{

  int   log_chl_index;
  boolean   failure_flag = FALSE;
  rrcllc_substate_e_type  rrcllc_next_substate = LLC_WAIT_RLC_UM_UL_CNF;

  MSG_MED("Cmd 0x%x recvd in LLC_WAIT_RLC_UM_UL_CNF",
                          cmd_ptr->cmd_hdr.cmd_id, 0, 0);

  switch(cmd_ptr->cmd_hdr.cmd_id)
  {
    case RRC_CRLC_UL_UM_CONFIG_CNF:
      {
        WRRC_MSG0_HIGH("Rcv'd RRC_CRLC_UL_UM_CONFIG_CNF");
        /* Look in the confirmation for a failure */
        for(log_chl_index = 0;
            log_chl_index < cmd_ptr->cmd.crlc_ul_um_config_cnf.nchan;
            log_chl_index ++
           )
        {
          if(cmd_ptr->cmd.crlc_ul_um_config_cnf.
              um_config_result[log_chl_index].result == FAILURE)
          {
            failure_flag = TRUE;
            break;
          }
        } /* for (..) */

        if(failure_flag == TRUE)
        {
          #ifdef FEATURE_RRC_L1_ERROR_RECOVERY_P1
          
          WRRC_MSG0_ERROR("Failure in RLC UL UM Cfg CNF handled by self-posting Ch Cfg to Idle");
          rrcllc_self_enqueue_channel_config_to_idle();
          rrcllc_next_substate = LLC_IDLE;

          #else
          
          ERR_FATAL("Failure in RLC UL UM Config CNF",0,0,0);

          #endif
        }
        else  /* No failure */
        {
          if(rrcllc_command_engine(rrcllc_current_substate, &rrcllc_next_substate)
             == FAILURE)
          {
            ERR_FATAL("RRC Config request processing failure", 0, 0, 0);
          }

          if(rrcllc_next_substate == LLC_IDLE)
          {
            /* This implies no more lower layer commands are to be sent - Can this happen
             * in LLC_IDLE ?
             */
            /* Send a RRC Config CNF back to the procedure and change RRC state */
            if((rrcllc_cmd_under_process.valid) &&
               (rrcllc_cmd_under_process.rrc_current_cmd_id == RRC_CHANNEL_CONFIG_REQ))
            {
              if (rrcllc_cmd_under_process.chan_config.chan_cfg_status == RRCLLC_CHAN_CFG_SUCCESS)
              {
                rrcllc_next_substate = rrcllc_handle_completion_of_chan_config_req();
              }
              else
              {
                /* In the failure case send the channel config cnf to the procedure and enter
                LLC_IDLE */
                (void)rrcllc_send_rrc_channel_config_cnf(rrcllc_cmd_under_process.procedure,
                                       rrcllc_cmd_under_process.chan_config_transaction_id,
                                                         RRCLLC_CHAN_CFG_FAILURE_PHY_CHL);
              }
            } /* if(rrcllc_cmd_under_process.valid)... */
          } /* if(rrcllc_next_substate == LLC_IDLE) */

          else if(rrcllc_next_substate == LLC_WAIT_NEW_CELL_IND)
          {
            /* This implies no more lower layer commands are to be sent. Send a RRC
             * RESLECTION CNF back to the procedure */
            if((rrcllc_cmd_under_process.valid) &&
               (rrcllc_cmd_under_process.rrc_current_cmd_id == RRC_CELL_RESELECTION_REQ))
            {
              /* A swapping ensures the data space used to configure lower layers
               * for reselection will not be used for configuration in the next
               * reconfiguration. If CC was used for reselection, a L2 Ack will
               * make CC point to that data space again, ensuring the above condition.
               */
              rrcllc_swap_oc_and_cc();

              /* First check if CCM still wants to proceed with reselection */
              if(rrcccm_waiting_for_reselection_cnf() == FALSE)
              {
                /* No need to send a CNF, nobody is waiting for it */
                rrcllc_next_substate = LLC_IDLE;
              }
              else
              {
                /* Processing of Cell Reselection request succeeded
                 * Send a Cell Reselection Confirm with a Success to the requesting procedure
                 */
                (void)rrcllc_send_rrc_cell_reselection_cnf(SUCCESS);
              }
            }
          } /* if(rrcllc_next_substate == LLC_WAIT_NEW_CELL_IND) */
        }  /* No failure */
      }
      break;

    case RRC_CPHY_COMPRESSED_MODE_IND:
      if (rrcllc_modify_cm_info_in_current_config(&cmd_ptr->cmd.cm_ind) == SUCCESS)
      {
        rrcllc_send_compressed_mode_run_time_error_ind(&cmd_ptr->cmd.cm_ind);
      }
      break;

    case RRC_STOP_LOWER_LAYER_REQ:
    case RRC_RNTI_UPDATE_REQ:
    case RRC_LLC_CMD_REQ:
    case RRC_RESET_L1_REQ:
    case RRC_LOWER_LAYER_DEACT_REQ:
    case RRC_CHANNEL_CONFIG_REQ:
    case RRC_CELL_RESELECTION_REQ:
    case RRC_ABORT_CIPH_CONFIG_REQ:
    case RRC_CIPH_CONFIG_REQ:
      if(( ((uint32)cmd_ptr->cmd_hdr.cmd_id) & CMD_BASE_MASK ) == (uint32)RRC_INT_CMD_BASE)
      {
        (void)rrcllc_put_cmd_on_queue(cmd_ptr);
        MSG_MED("RRC Internal cmd recvd", 0, 0, 0);
      }
      break;

    default:
      WRRC_MSG1_ERROR("Cmd 0x%x not expected in LLC_WAIT_RLC_UM_UL_CNF",
                                   cmd_ptr->cmd_hdr.cmd_id);
      break;
  } /* switch() */

  return(rrcllc_next_substate);

} /* rrcllc_wait_rlc_um_ul_cnf_handler */


/*====================================================================
FUNCTION: rrcllc_wait_rlc_um_dl_cnf_handler()

DESCRIPTION:
  This function is a handler for LLC_WAIT_RLC_UM_DL_CNF
  state and takes care of all incoming commands and Confirms from RRC
  procedures, MAC, RLC and L1.

DEPENDENCIES:
  None

RETURN VALUE:
  Next LLC state.

SIDE EFFECTS:
  None.
====================================================================*/
static rrcllc_substate_e_type rrcllc_wait_rlc_um_dl_cnf_handler(rrc_cmd_type *cmd_ptr)
{

  int   log_chl_index;
  boolean   failure_flag = FALSE;
  rrcllc_substate_e_type  rrcllc_next_substate = LLC_WAIT_RLC_UM_DL_CNF;

  MSG_MED("Cmd 0x%x recvd in LLC_WAIT_RLC_UM_DL_CNF",
                          cmd_ptr->cmd_hdr.cmd_id, 0, 0);

  switch(cmd_ptr->cmd_hdr.cmd_id)
  {
    case RRC_CRLC_DL_UM_CONFIG_CNF:
      {
        WRRC_MSG0_HIGH("Rcv'd RRC_CRLC_DL_UM_CONFIG_CNF");
        /* Look in the confirmation for a failure */
        for(log_chl_index = 0;
            log_chl_index < cmd_ptr->cmd.crlc_dl_um_config_cnf.nchan;
            log_chl_index ++
           )
        {
          if(cmd_ptr->cmd.crlc_dl_um_config_cnf.
              um_config_result[log_chl_index].result == FAILURE)
          {
            failure_flag = TRUE;
            break;
          }
        }

        if(failure_flag == TRUE)
        {
          #ifdef FEATURE_RRC_L1_ERROR_RECOVERY_P1
          
          WRRC_MSG0_ERROR("Failure in RLC DL UM Cfg CNF handled by self-posting Ch Cfg to Idle");
          rrcllc_self_enqueue_channel_config_to_idle();
          rrcllc_next_substate = LLC_IDLE;

          #else
          
          ERR_FATAL("Failure in RLC DL UM Config CNF",0,0,0);

          #endif
        }
        else  /* No failure */
        {

          if(rrcllc_command_engine(rrcllc_current_substate, &rrcllc_next_substate)
             == FAILURE)
          {
            ERR_FATAL("RRC Config request processing failure", 0, 0, 0);
          }

          if(rrcllc_next_substate == LLC_IDLE)
          {
            /* This implies no more lower layer commands are to be sent - Can this happen
             * in LLC_IDLE ?
             */
            /* Send a RRC Config CNF back to the procedure and change RRC state */
            if((rrcllc_cmd_under_process.valid) &&
               (rrcllc_cmd_under_process.rrc_current_cmd_id == RRC_CHANNEL_CONFIG_REQ))
            {
              if (rrcllc_cmd_under_process.chan_config.chan_cfg_status == RRCLLC_CHAN_CFG_SUCCESS)
              {
                rrcllc_next_substate = rrcllc_handle_completion_of_chan_config_req();
              }
              else
              {
                /* In the failure case send the channel config cnf to the procedure and enter
                LLC_IDLE */
                (void)rrcllc_send_rrc_channel_config_cnf(rrcllc_cmd_under_process.procedure,
                                       rrcllc_cmd_under_process.chan_config_transaction_id,
                                                         RRCLLC_CHAN_CFG_FAILURE_PHY_CHL);
              }
            } /* if(rrcllc_cmd_under_process.valid)... */
          } /* if(rrcllc_next_substate == LLC_IDLE) */

          else if(rrcllc_next_substate == LLC_WAIT_NEW_CELL_IND)
          {
            /* This implies no more lower layer commands are to be sent. Send a RRC
             * RESLECTION CNF back to the procedure */
            if((rrcllc_cmd_under_process.valid) &&
               (rrcllc_cmd_under_process.rrc_current_cmd_id == RRC_CELL_RESELECTION_REQ))
            {
              /* A swapping ensures the data space used to configure lower layers
               * for reselection will not be used for configuration in the next
               * reconfiguration. If CC was used for reselection, a L2 Ack will
               * make CC point to that data space again, ensuring the above condition.
               */
              rrcllc_swap_oc_and_cc();

              /* First check if CCM still wants to proceed with reselection */
              if(rrcccm_waiting_for_reselection_cnf() == FALSE)
              {
                /* No need to send a CNF, nobody is waiting for it */
                rrcllc_next_substate = LLC_IDLE;
              }
              else
              {
                /* Processing of Cell Reselection request succeeded
                 * Send a Cell Reselection Confirm with a Success to the requesting procedure
                 */
                (void)rrcllc_send_rrc_cell_reselection_cnf(SUCCESS);
              }
            }
          } /* if(rrcllc_next_substate == LLC_WAIT_NEW_CELL_IND ) */
        } /* No failure */
      }
      break;

    case RRC_CPHY_COMPRESSED_MODE_IND:
      if (rrcllc_modify_cm_info_in_current_config(&cmd_ptr->cmd.cm_ind) == SUCCESS)
      {
        rrcllc_send_compressed_mode_run_time_error_ind(&cmd_ptr->cmd.cm_ind);
      }
      break;

    case RRC_STOP_LOWER_LAYER_REQ:
    case RRC_RNTI_UPDATE_REQ:
    case RRC_LLC_CMD_REQ:
    case RRC_RESET_L1_REQ:
    case RRC_LOWER_LAYER_DEACT_REQ:
    case RRC_CHANNEL_CONFIG_REQ:
    case RRC_CELL_RESELECTION_REQ:
    case RRC_ABORT_CIPH_CONFIG_REQ:
    case RRC_CIPH_CONFIG_REQ:
      if(( ((uint32)cmd_ptr->cmd_hdr.cmd_id) & CMD_BASE_MASK ) == (uint32)RRC_INT_CMD_BASE)
      {
        (void)rrcllc_put_cmd_on_queue(cmd_ptr);
        MSG_MED("RRC Internal cmd recvd", 0, 0, 0);
      }
      break;

    default:
      WRRC_MSG1_ERROR("Cmd 0x%x not expected in LLC_WAIT_RLC_UM_DL_CNF",
                                   cmd_ptr->cmd_hdr.cmd_id);
      break;
  } /* switch() */

  return(rrcllc_next_substate);

} /* rrcllc_wait_rlc_um_dl_cnf_handler */


/*====================================================================
FUNCTION: rrcllc_wait_rlc_am_cnf_handler()

DESCRIPTION:
  This function is a handler for LLC_WAIT_RLC_AM_CNF
  state and takes care of all incoming commands and Confirms from RRC
  procedures, MAC, RLC and L1.

DEPENDENCIES:
  None

RETURN VALUE:
  Next LLC state.

SIDE EFFECTS:
  None.
====================================================================*/
static rrcllc_substate_e_type rrcllc_wait_rlc_am_cnf_handler(rrc_cmd_type *cmd_ptr)
{

  uint32  rb_index;
  boolean failure_flag = FALSE;
  ordered_config_type *config_ptr;
  rrcllc_substate_e_type  rrcllc_next_substate = LLC_WAIT_RLC_AM_CNF;

  MSG_MED("Cmd 0x%x recvd in LLC_WAIT_RLC_AM_CNF",
                          cmd_ptr->cmd_hdr.cmd_id, 0, 0);

  switch(cmd_ptr->cmd_hdr.cmd_id)
  {
    case RRC_CRLC_AM_CONFIG_CNF:
      {
        WRRC_MSG0_HIGH("Rcv'd RRC_CRLC_AM_CONFIG_CNF from RLC");
        /* Look in the confirmation for a failure */
        for(rb_index = 0; rb_index < cmd_ptr->cmd.crlc_am_config_cnf.nchan; rb_index ++)
        {
          if(cmd_ptr->cmd.crlc_am_config_cnf.
              am_config_result[rb_index].result == FAILURE)
          {
            failure_flag = TRUE;
            break;
          }
        }

        if(failure_flag == TRUE)
        {
          #ifdef FEATURE_RRC_L1_ERROR_RECOVERY_P1
          
          WRRC_MSG0_ERROR("Failure in RLC AM Cfg CNF handled by self-posting Ch Cfg to Idle");
          rrcllc_self_enqueue_channel_config_to_idle();
          rrcllc_next_substate = LLC_IDLE;

          #else
          
          ERR_FATAL("Failure in RLC AM Config CNF",0,0,0);

          #endif
        }
        else  /* No failure */
        {
           /*Check and take back up of UL size*/
          rrcllc_check_and_take_backup_rlc_parms();
          if(rrcllc_cmd_under_process.rrc_current_cmd_id == RRC_RNTI_UPDATE_REQ)
          {
            if (rrcllc_cmd_under_process.update_mac_with_rnti)
            {
              if (!rrcllc_cmd_under_process.sccpch_selec_reqd) 
              {
                if(config_ptr_in_use == CURRENT_CONFIG)
                {
                  config_ptr = current_config_ptr;
                }
                else
                {
                  config_ptr = ordered_config_ptr;
                }
              }
              else
              {
                config_ptr = ordered_config_ptr;

                if ((config_ptr_in_use == ORDERED_CONFIG) &&
                    (ordered_config.process_state == LL_CONFIG_WITH_OC))
                {
                  config_ptr = current_config_ptr;
                }
              }

              /* Send MAC UL Config request */
              rrcllc_cmac_ul_config_req_for_rnti_update(config_ptr);
              

              /* Send MAC DL Config request */
              rrcllc_cmac_dl_config_req_for_rnti_update(config_ptr);

              if (rrcllc_cmd_under_process.sccpch_selec_reqd) 
              {
                rrcllc_cphy_setup_req(&rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0]);
                rrcllc_next_substate = LLC_WAIT_CPHY_SETUP_CNF;
              }
            }
            /* If UE is not waiting for CPHY_SETUP_CNF then go ahead 
             * and set LLC substate to IDLE as no more LL cmd will go
             */
            if (rrcllc_next_substate != LLC_WAIT_CPHY_SETUP_CNF)
            {
              rrcllc_next_substate = LLC_IDLE;
              if (TRUE == rrcllc_cmd_under_process.rnti_update_cnf_needed)
              {
                /* Send RNTI Update Confirm */
                rrcllc_send_rnti_update_cnf(SUCCESS);
              }
            }
          }
          else /* For all other commands under process */
          {

            if(rrcllc_command_engine(rrcllc_current_substate, &rrcllc_next_substate)
               == FAILURE)
            {
              ERR_FATAL("RRC Config request processing failure", 0, 0, 0);
            }

            if(rrcllc_next_substate == LLC_IDLE)
            {
              /* This implies no more lower layer commands are to be sent - Can this happen
               * in LLC_IDLE ?
               */
              /* Send a RRC Config CNF back to the procedure and change RRC state */
              if((rrcllc_cmd_under_process.valid) &&
                 (rrcllc_cmd_under_process.rrc_current_cmd_id == RRC_CHANNEL_CONFIG_REQ))
              {
                if (rrcllc_cmd_under_process.chan_config.chan_cfg_status == RRCLLC_CHAN_CFG_SUCCESS)
                {
                  rrcllc_next_substate = rrcllc_handle_completion_of_chan_config_req();
                }
                else
                {
                  /* In the failure case send the channel config cnf to the procedure and enter
                  LLC_IDLE */
                  (void)rrcllc_send_rrc_channel_config_cnf(rrcllc_cmd_under_process.procedure,
                                         rrcllc_cmd_under_process.chan_config_transaction_id,
                                                           RRCLLC_CHAN_CFG_FAILURE_PHY_CHL);
                }
              } /* if(rrcllc_cmd_under_process.valid)... */
            } /* if(rrcllc_next_substate == LLC_IDLE) */

            else if(rrcllc_next_substate == LLC_WAIT_NEW_CELL_IND)
            {
              /* This implies no more lower layer commands are to be sent. Send a RRC
               * RESLECTION CNF back to the procedure */
              if((rrcllc_cmd_under_process.valid) &&
                 (rrcllc_cmd_under_process.rrc_current_cmd_id == RRC_CELL_RESELECTION_REQ))
              {
                /* A swapping ensures the data space used to configure lower layers
                 * for reselection will not be used for configuration in the next
                 * reconfiguration. If CC was used for reselection, a L2 Ack will
                 * make CC point to that data space again, ensuring the above condition.
                 */
                rrcllc_swap_oc_and_cc();

                /* First check if CCM still wants to proceed with reselection */
                if(rrcccm_waiting_for_reselection_cnf() == FALSE)
                {
                  /* No need to send a CNF, nobody is waiting for it */
                  rrcllc_next_substate = LLC_IDLE;
                }
                else
                {
                  /* Processing of Cell Reselection request succeeded
                   * Send a Cell Reselection Confirm with a Success to the requesting procedure
                   */
                  (void)rrcllc_send_rrc_cell_reselection_cnf(SUCCESS);
                }
              }
            } /* if(rrcllc_next_substate == LLC_WAIT_NEW_CELL_IND) */
          }  /* For all other commands under process */
        } /* No failure */
      }
      break;

    case RRC_CPHY_COMPRESSED_MODE_IND:
      if (rrcllc_modify_cm_info_in_current_config(&cmd_ptr->cmd.cm_ind) == SUCCESS)
      {
        rrcllc_send_compressed_mode_run_time_error_ind(&cmd_ptr->cmd.cm_ind);
      }
      break;

    case RRC_STOP_LOWER_LAYER_REQ:
    case RRC_RNTI_UPDATE_REQ:
    case RRC_LLC_CMD_REQ:
    case RRC_RESET_L1_REQ:
    case RRC_LOWER_LAYER_DEACT_REQ:
    case RRC_CHANNEL_CONFIG_REQ:
    case RRC_CELL_RESELECTION_REQ:
    case RRC_ABORT_CIPH_CONFIG_REQ:
    case RRC_CIPH_CONFIG_REQ:
      if(( ((uint32)cmd_ptr->cmd_hdr.cmd_id) & CMD_BASE_MASK ) == (uint32)RRC_INT_CMD_BASE)
      {
        (void)rrcllc_put_cmd_on_queue(cmd_ptr);
        MSG_MED("RRC Internal cmd recvd", 0, 0, 0);
      }
      break;

    default:
      WRRC_MSG1_ERROR("Cmd 0x%x not expected in LLC_WAIT_RLC_AM_CNF",
                                   cmd_ptr->cmd_hdr.cmd_id);
      break;
  } /* switch() */

  return(rrcllc_next_substate);

} /* rrcllc_wait_rlc_am_cnf_handler */


/*====================================================================
FUNCTION: rrcllc_wait_rlc_dl_hfn_cnf_handler()

DESCRIPTION:
  This function is a handler for LLC_WAIT_RLC_DL_HFN_CNF
  state and takes care of all incoming commands and Confirms from RRC
  procedures, MAC, RLC and L1.

DEPENDENCIES:
  None

RETURN VALUE:
  Next LLC state.

SIDE EFFECTS:
  None.
====================================================================*/
static rrcllc_substate_e_type rrcllc_wait_rlc_dl_hfn_cnf_handler(rrc_cmd_type *cmd_ptr)
{
  rrcllc_substate_e_type  rrcllc_next_substate = LLC_WAIT_RLC_DL_HFN_CNF;
  MSG_MED("Cmd 0x%x recvd in LLC_WAIT_RLC_DL_HFN_CNF",
                          cmd_ptr->cmd_hdr.cmd_id, 0, 0);

  switch(cmd_ptr->cmd_hdr.cmd_id)
  {
    case RRC_CRLC_DL_HFN_CNF:
      WRRC_MSG0_HIGH("Rcv'd RRC_CRLC_DL_HFN_CNF from RLC");
      rrc_funneled_cmd_cnf(cmd_ptr, rrcllc_cmd_under_process.procedure, cmd_ptr->cmd_hdr.cmd_id);
      rrcllc_next_substate = LLC_IDLE;
      break;

    case RRC_CPHY_COMPRESSED_MODE_IND:
      if (rrcllc_modify_cm_info_in_current_config(&cmd_ptr->cmd.cm_ind) == SUCCESS)
      {
        rrcllc_send_compressed_mode_run_time_error_ind(&cmd_ptr->cmd.cm_ind);
      }
      break;

    case RRC_STOP_LOWER_LAYER_REQ:
    case RRC_RNTI_UPDATE_REQ:
    case RRC_LLC_CMD_REQ:
    case RRC_RESET_L1_REQ:
    case RRC_LOWER_LAYER_DEACT_REQ:
    case RRC_CHANNEL_CONFIG_REQ:
    case RRC_CELL_RESELECTION_REQ:
    case RRC_ABORT_CIPH_CONFIG_REQ:
    case RRC_CIPH_CONFIG_REQ:
      if(( ((uint32)cmd_ptr->cmd_hdr.cmd_id) & CMD_BASE_MASK ) == (uint32)RRC_INT_CMD_BASE)
      {
        (void)rrcllc_put_cmd_on_queue(cmd_ptr);
        MSG_MED("RRC Internal cmd recvd", 0, 0, 0);
      }
      break;

    default:
      WRRC_MSG1_ERROR("Unexpected Cmd 0x%x in LLC_WAIT_RLC_DL_HFN_CNF",
                                   cmd_ptr->cmd_hdr.cmd_id);
      break;
  } /* switch() */

  return(rrcllc_next_substate);

} /* rrcllc_wait_rlc_dl_hfn_cnf_handler */


/*====================================================================
FUNCTION: rrcllc_wait_rlc_rel_all_cnf_handler()

DESCRIPTION:
  This function is a handler for LLC_WAIT_RLC_REL_ALL_CNF
  state and takes care of all incoming commands and Confirms from RRC
  procedures, MAC, RLC and L1.

DEPENDENCIES:
  None

RETURN VALUE:
  Next LLC state.

SIDE EFFECTS:
  None.
====================================================================*/
static rrcllc_substate_e_type rrcllc_wait_rlc_rel_all_cnf_handler(rrc_cmd_type *cmd_ptr)
{
  rrc_state_e_type  rrc_state;

  rrcllc_substate_e_type  rrcllc_next_substate = LLC_WAIT_RLC_REL_ALL_CNF;

  MSG_MED("Cmd 0x%x recvd in LLC_WAIT_RLC_REL_ALL_CNF",
                          cmd_ptr->cmd_hdr.cmd_id, 0, 0);

  /*
    Cases for intentional dumping of commands
  */
  if((cmd_ptr->cmd_hdr.cmd_id == RRC_LLC_CMD_REQ)&&
      (cmd_ptr->cmd.rrc_llc_req.cmd_dest == LAYER1_PHY)&&
      (cmd_ptr->cmd.rrc_llc_req.l1_cmd.cmd_id == CPHY_MEASUREMENT_REQ) &&
      (rrcllc_cmd_under_process.chan_config.current_cmd_engine == LLC_RELEASE_ALL_CHAN_ENGINE))
  {
    WRRC_MSG1_HIGH("Ignore the Measurement request to L1 as Release All Channel engine is running and LLC substate is %d",rrcllc_next_substate);
    rrc_free_embedd_buf_llc_req(cmd_ptr );
    return rrcllc_next_substate;
  }
  switch(cmd_ptr->cmd_hdr.cmd_id)
  {
    case RRC_CRLC_RELEASE_ALL_CNF:
      WRRC_MSG0_HIGH("Rcv'd RRC_CRLC_RELEASE_ALL_CNF from RLC");
      if(rrcllc_command_engine(rrcllc_current_substate, &rrcllc_next_substate)
         == FAILURE)
      {
        ERR_FATAL("RRC Config request processing failure", 0, 0, 0);
      }
      if(rrcllc_next_substate == LLC_IDLE)
      {
        /* This implies no more lower layer commands are to be sent
         */
        /* Send a RRC Config CNF back to the procedure and change RRC state */
        if((rrcllc_cmd_under_process.valid) &&
           (rrcllc_cmd_under_process.rrc_current_cmd_id == RRC_CHANNEL_CONFIG_REQ))
        {
          MSG_MED("Sending RRC_CHANNEL_CONFIG_CNF to procedure %d",
                         rrcllc_cmd_under_process.procedure, 0, 0);
          if(rrcllc_cmd_under_process.chan_config.cnf_needed)
          {
            (void)rrcllc_send_rrc_channel_config_cnf(rrcllc_cmd_under_process.procedure,
                                   rrcllc_cmd_under_process.chan_config_transaction_id,
                                                     RRCLLC_CHAN_CFG_SUCCESS);
          }
          /* If a change of state was requested, change the RRC state now */
          rrc_state = rrc_get_state();

          if((rrc_state != RRC_STATE_DISCONNECTED) &&
             (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_DISCONNECTED))
          {
            /* This procesiing only when next state is Disconnected */
            rrc_initiate_state_change(rrcllc_cmd_under_process.next_rrc_state);

            /* Set LLC state back to LLC_WAIT_FOR_STATE_CHG_IND to waut for Release Confirm */
            rrcllc_next_substate = LLC_WAIT_FOR_STATE_CHG_IND;
            if(rrc_state == RRC_STATE_CONNECTING)
            {
              WRRC_MSG0_ERROR("Going Connetng->Idle");
            }
          }
          else /* Next and current state - both disconnected or next state NOT disconnected (not possible ?) */
          {
            /* Initialize Ordered and Current Configs */
            rrcllc_init_ordered_config_status_and_data(RRC_STATE_DISCONNECTED);
            rrcllc_init_config_data(current_config_ptr, RRC_STATE_DISCONNECTED);

            /* Clear RLC Logical Channel Info in LCM */
            rrclcm_clear_rlc_lc_info();
            /* Initialize LLC and initialize Command under process */
            rrcllc_init(RRCLLC_RE_INIT);

            /* Force RCE to go to INITIAL, taking care of ongoing timers
             * and required response to MM, depending on RCE substate and
             */
            rrcrce_force_initialize(TRUE);

            /* Get out of here */
            rrcllc_next_substate = rrcllc_trash_cmds_till_first_useful(PROCESS_CONFIG_REQ);

          } /* next RRC state is not different than current one */
        } /* if(rrcllc_cmd_under_process.valid)... */
        else if((rrcllc_cmd_under_process.valid) &&
                (rrcllc_cmd_under_process.rrc_current_cmd_id
                  == RRC_LOWER_LAYER_DEACT_REQ))
        {
          /* This implies no more lower layer commands are to be sent */
          /* Send a RRC_LOWER_LAYER_DEACT_CNF back to the procedure and
           * change RRC state
           */
          MSG_MED("Sending RRC_LOWER_LAYER_DEACT_CNF to procedure %d",
                         rrcllc_cmd_under_process.procedure, 0, 0);
          (void)rrcllc_send_rrc_lower_layer_deact_cnf();

          /* Initialize LLC here with a Free Queue initialization type */
          rrcllc_init(RRCLLC_RE_INIT_FREE_Q);
        } /* Processing a Lower Layer Deact Confirm */
        else if((rrcllc_cmd_under_process.valid) &&
        (rrcllc_cmd_under_process.rrc_current_cmd_id
          == RRC_STOP_LOWER_LAYER_REQ))
        {

          MSG_MED("Sending RRC_STOP_LOWER_LAYER_CNF to procedure %d",
                         rrcllc_cmd_under_process.procedure, 0, 0);
          (void)rrcllc_send_rrc_stop_lower_layer_cnf();

          /* If a change of state was requested, change the RRC state now */
          rrc_state = rrc_get_state();

          if(rrc_state != RRC_STATE_DISCONNECTED)
          {
            /* This procesiing only when next state is Disconnected */
            rrc_initiate_state_change(RRC_STATE_DISCONNECTED);
            rrcllc_clear_config_all_db();
            /* Get out of here */
            rrcllc_next_substate = LLC_IDLE;
            if(rrc_state == RRC_STATE_CONNECTING)
            {
              WRRC_MSG0_ERROR("Going Connetng->Idle");
            }
          }
          else /* Next and current state - both disconnected or next state NOT disconnected (not possible ?) */
          {
            /* Signal SIB procedure to clear up the active event, if any */
            rrcsib_force_sib_event_init(RRCSIB_ABORT_DUE_TO_OOS);

            /* Force RCE to go to INITIAL, taking care of ongoing timers
             * and required response to MM, depending on RCE substate and
             */
            rrcrce_force_initialize(TRUE);

            /* Initialize Ordered and Current Configs */
            rrcllc_init_ordered_config_status_and_data(RRC_STATE_DISCONNECTED);
            rrcllc_init_config_data(current_config_ptr, RRC_STATE_DISCONNECTED);

            /* Clear RLC Logical Channel Info in LCM */
            rrclcm_clear_rlc_lc_info();
            /* Initialize LLC and initialize Command under process */
            rrcllc_init(RRCLLC_RE_INIT_FREE_Q);

            /* Get out of here */
            rrcllc_next_substate = LLC_IDLE;

          } /* next RRC state is not different than current one */

        } /* Processing Stop Lower Layer Confirm */
      } /* if(rrcllc_next_substate == LLC_IDLE) */
      break;

    case RRC_CPHY_COMPRESSED_MODE_IND:
      if (rrcllc_modify_cm_info_in_current_config(&cmd_ptr->cmd.cm_ind) == SUCCESS)
      {
        rrcllc_send_compressed_mode_run_time_error_ind(&cmd_ptr->cmd.cm_ind);
      }
      break;

    case RRC_STOP_LOWER_LAYER_REQ:
    case RRC_RNTI_UPDATE_REQ:
    case RRC_LLC_CMD_REQ:
    case RRC_RESET_L1_REQ:
    case RRC_CHANNEL_CONFIG_REQ:
    case RRC_CELL_RESELECTION_REQ:
    case RRC_ABORT_CIPH_CONFIG_REQ:
    case RRC_CIPH_CONFIG_REQ:
      if((( ((uint32)cmd_ptr->cmd_hdr.cmd_id) & CMD_BASE_MASK ) == (uint32)RRC_INT_CMD_BASE) &&
         (rrcllc_cmd_under_process.chan_config.current_cmd_engine != LLC_STOP_WCDMA_MODE_ENGINE))
      {
        (void)rrcllc_put_cmd_on_queue(cmd_ptr);
        MSG_MED("RRC Internal cmd recvd", 0, 0, 0);
      }
      else
      {
        if(cmd_ptr->cmd_hdr.cmd_id == RRC_LLC_CMD_REQ)
        {
          if(cmd_ptr->cmd.rrc_llc_req.cmd_dest == LAYER1_PHY)
          {
            if(cmd_ptr->cmd.rrc_llc_req.l1_cmd.cmd_id == CPHY_MEASUREMENT_REQ)
            {
              (void)rrcllc_put_cmd_on_queue(cmd_ptr);
              MSG_MED("RRC Internal cmd recvd", 0, 0, 0);
            }
          }
          else if(cmd_ptr->cmd.rrc_llc_req.cmd_dest == LAYER2_MAC_UL)
          {
            if(cmd_ptr->cmd.rrc_llc_req.l2_ul_cmd.cmd_id == CMAC_UL_TRAFFIC_VOLUME_CONFIG_REQ)
            {
              (void)rrcllc_put_cmd_on_queue(cmd_ptr);
              MSG_MED("RRC Internal cmd recvd", 0, 0, 0);
            }
          }
        }
      }

      break;

    case RRC_LOWER_LAYER_DEACT_REQ:
      if(( ((uint32)cmd_ptr->cmd_hdr.cmd_id) & CMD_BASE_MASK ) == (uint32)RRC_INT_CMD_BASE)
      {
        (void)rrcllc_put_cmd_on_queue(cmd_ptr);
        MSG_MED("RRC Internal cmd recvd", 0, 0, 0);
      }
      break;

    default:
      WRRC_MSG1_ERROR("Unexpected Cmd 0x%x in LLC_WAIT_RLC_REL_ALL_CNF",
                                   cmd_ptr->cmd_hdr.cmd_id);
      break;
  } /* switch() */

  return(rrcllc_next_substate);

} /* rrcllc_wait_rlc_rel_all_cnf_handler */


/*====================================================================
FUNCTION: rrcllc_wait_rlc_ul_hfn_cnf_handler()

DESCRIPTION:
  This function is a handler for LLC_WAIT_RLC_UL_HFN_CNF
  state and takes care of all incoming commands and Confirms from RRC
  procedures, MAC, RLC and L1.

DEPENDENCIES:
  None

RETURN VALUE:
  Next LLC state.

SIDE EFFECTS:
  None.
====================================================================*/
static rrcllc_substate_e_type rrcllc_wait_rlc_ul_hfn_cnf_handler(rrc_cmd_type *cmd_ptr)
{

  rrcllc_substate_e_type  rrcllc_next_substate = LLC_WAIT_RLC_UL_HFN_CNF;

  MSG_MED("Cmd 0x%x recvd in LLC_WAIT_RLC_UL_HFN_CNF",
                          cmd_ptr->cmd_hdr.cmd_id, 0, 0);

  switch(cmd_ptr->cmd_hdr.cmd_id)
  {
    case RRC_CRLC_UL_HFN_CNF:
      WRRC_MSG0_HIGH("Rcv'd RRC_CRLC_UL_HFN_CNF from RLC");
      rrc_funneled_cmd_cnf(cmd_ptr, rrcllc_cmd_under_process.procedure, cmd_ptr->cmd_hdr.cmd_id);
      rrcllc_next_substate = LLC_IDLE;
      break;

    case RRC_CPHY_COMPRESSED_MODE_IND:
      if (rrcllc_modify_cm_info_in_current_config(&cmd_ptr->cmd.cm_ind) == SUCCESS)
      {
        rrcllc_send_compressed_mode_run_time_error_ind(&cmd_ptr->cmd.cm_ind);
      }
      break;

    case RRC_STOP_LOWER_LAYER_REQ:
    case RRC_RNTI_UPDATE_REQ:
    case RRC_LLC_CMD_REQ:
    case RRC_RESET_L1_REQ:
    case RRC_LOWER_LAYER_DEACT_REQ:
    case RRC_CHANNEL_CONFIG_REQ:
    case RRC_CELL_RESELECTION_REQ:
    case RRC_ABORT_CIPH_CONFIG_REQ:
    case RRC_CIPH_CONFIG_REQ:
      if(( ((uint32)cmd_ptr->cmd_hdr.cmd_id) & CMD_BASE_MASK ) == (uint32)RRC_INT_CMD_BASE)
      {
        (void)rrcllc_put_cmd_on_queue(cmd_ptr);
        MSG_MED("RRC Internal cmd recvd", 0, 0, 0);
      }
      break;

    default:
      WRRC_MSG1_ERROR("Unexpected Cmd 0x%x in LLC_WAIT_RLC_UL_HFN_CNF",
                                   cmd_ptr->cmd_hdr.cmd_id);
      break;
  } /* switch() */

  return(rrcllc_next_substate);

} /* rrcllc_wait_rlc_ul_hfn_cnf_handler */


/*====================================================================
FUNCTION: rrcllc_wait_mac_ul_hfn_cnf_handler()

DESCRIPTION:
  This function is a handler for LLC_WAIT_MAC_UL_HFN_CNF
  state and takes care of all incoming commands and Confirms from RRC
  procedures, MAC, RLC and L1.

DEPENDENCIES:
  None

RETURN VALUE:
  Next LLC state.

SIDE EFFECTS:
  None.
====================================================================*/
static rrcllc_substate_e_type rrcllc_wait_mac_ul_hfn_cnf_handler(rrc_cmd_type *cmd_ptr)
{

  rrcllc_substate_e_type  rrcllc_next_substate = LLC_WAIT_MAC_UL_HFN_CNF;

  MSG_MED("Cmd 0x%x recvd in LLC_WAIT_MAC_UL_HFN_CNF",
                          cmd_ptr->cmd_hdr.cmd_id, 0, 0);

  switch(cmd_ptr->cmd_hdr.cmd_id)
  {
    case RRC_CMAC_UL_HFN_CNF:
      WRRC_MSG0_HIGH("Rcv'd RRC_CMAC_UL_HFN_CNF from MAC");
      rrc_funneled_cmd_cnf(cmd_ptr, rrcllc_cmd_under_process.procedure, cmd_ptr->cmd_hdr.cmd_id);
      rrcllc_next_substate = LLC_IDLE;
      break;

    case RRC_CPHY_COMPRESSED_MODE_IND:
      if (rrcllc_modify_cm_info_in_current_config(&cmd_ptr->cmd.cm_ind) == SUCCESS)
      {
        rrcllc_send_compressed_mode_run_time_error_ind(&cmd_ptr->cmd.cm_ind);
      }
      break;

    case RRC_STOP_LOWER_LAYER_REQ:
    case RRC_RNTI_UPDATE_REQ:
    case RRC_LLC_CMD_REQ:
    case RRC_RESET_L1_REQ:
    case RRC_LOWER_LAYER_DEACT_REQ:
    case RRC_CHANNEL_CONFIG_REQ:
    case RRC_CELL_RESELECTION_REQ:
    case RRC_ABORT_CIPH_CONFIG_REQ:
    case RRC_CIPH_CONFIG_REQ:
      if(( ((uint32)cmd_ptr->cmd_hdr.cmd_id) & CMD_BASE_MASK ) == (uint32)RRC_INT_CMD_BASE)
      {
        (void)rrcllc_put_cmd_on_queue(cmd_ptr);
        MSG_MED("RRC Internal cmd recvd", 0, 0, 0);
      }
      break;

    default:
      WRRC_MSG1_ERROR("Unexpected Cmd 0x%x in LLC_WAIT_MAC_UL_HFN_CNF",
                                   cmd_ptr->cmd_hdr.cmd_id);
      break;
  } /* switch() */

  return(rrcllc_next_substate);

} /* rrcllc_wait_mac_ul_hfn_cnf_handler */


/*====================================================================
FUNCTION: rrcllc_wait_mac_dl_hfn_cnf_handler()

DESCRIPTION:
  This function is a handler for LLC_WAIT_MAC_DL_HFN_CNF
  state and takes care of all incoming commands and Confirms from RRC
  procedures, MAC, RLC and L1.

DEPENDENCIES:
  None

RETURN VALUE:
  Next LLC state.

SIDE EFFECTS:
  None.
====================================================================*/
static rrcllc_substate_e_type rrcllc_wait_mac_dl_hfn_cnf_handler(rrc_cmd_type *cmd_ptr)
{

  rrcllc_substate_e_type  rrcllc_next_substate = LLC_WAIT_MAC_DL_HFN_CNF;

  MSG_MED("Cmd 0x%x recvd in LLC_WAIT_MAC_DL_HFN_CNF",
                          cmd_ptr->cmd_hdr.cmd_id, 0, 0);

  switch(cmd_ptr->cmd_hdr.cmd_id)
  {
    case RRC_CMAC_DL_HFN_CNF:
      WRRC_MSG0_HIGH("Rcv'd RRC_CMAC_DL_HFN_CNF from MAC");
      rrc_funneled_cmd_cnf(cmd_ptr, rrcllc_cmd_under_process.procedure, cmd_ptr->cmd_hdr.cmd_id);
      rrcllc_next_substate = LLC_IDLE;
      break;

    case RRC_CPHY_COMPRESSED_MODE_IND:
      if (rrcllc_modify_cm_info_in_current_config(&cmd_ptr->cmd.cm_ind) == SUCCESS)
      {
        rrcllc_send_compressed_mode_run_time_error_ind(&cmd_ptr->cmd.cm_ind);
      }
      break;

    case RRC_STOP_LOWER_LAYER_REQ:
    case RRC_RNTI_UPDATE_REQ:
    case RRC_LLC_CMD_REQ:
    case RRC_RESET_L1_REQ:
    case RRC_LOWER_LAYER_DEACT_REQ:
    case RRC_CHANNEL_CONFIG_REQ:
    case RRC_CELL_RESELECTION_REQ:
    case RRC_ABORT_CIPH_CONFIG_REQ:
    case RRC_CIPH_CONFIG_REQ:
      if(( ((uint32)cmd_ptr->cmd_hdr.cmd_id) & CMD_BASE_MASK ) == (uint32)RRC_INT_CMD_BASE)
      {
        (void)rrcllc_put_cmd_on_queue(cmd_ptr);
        MSG_MED("RRC Internal cmd recvd", 0, 0, 0);
      }
      break;

    default:
      WRRC_MSG1_ERROR("Unexpected Cmd 0x%x in LLC_WAIT_MAC_DL_HFN_CNF",
                                   cmd_ptr->cmd_hdr.cmd_id);
      break;
  } /* switch() */

  return(rrcllc_next_substate);

} /* rrcllc_wait_mac_dl_hfn_cnf_handler */


/*====================================================================
FUNCTION: rrcllc_wait_state_chg_ind_handler()

DESCRIPTION:
  This function is a handler for LLC_WAIT_FOR_STATE_CHG_IND
  state. On receiving RRC_STATE_CHANGE_IND, the LLC command queue
  is trashed in different ways depending on the command that caused
  state to be changed to "Disconnected".
  Any other command is enqueued in the LLC internal queue.

DEPENDENCIES:
  None

RETURN VALUE:
  Next LLC state.

SIDE EFFECTS:
  None.
====================================================================*/
static rrcllc_substate_e_type  rrcllc_wait_state_chg_ind_handler(rrc_cmd_type *cmd_ptr)
{
  rrcllc_substate_e_type  rrcllc_next_substate = LLC_WAIT_FOR_STATE_CHG_IND;

  MSG_MED("Cmd 0x%x recvd in LLC_WAIT_MAC_DL_HFN_CNF",
                          cmd_ptr->cmd_hdr.cmd_id, 0, 0);

  switch(cmd_ptr->cmd_hdr.cmd_id)
  {
    case RRC_STATE_CHANGE_IND:
      if(rrcllc_cmd_under_process.chan_config.current_cmd_engine ==
         LLC_RELEASE_ALL_CHAN_ENGINE)
      {
        WRRC_MSG0_HIGH("Init Chl Config data on state chg");
        /* Initialize Ordered and Current Configs */
        rrcllc_init_ordered_config_status_and_data(RRC_STATE_DISCONNECTED);
        rrcllc_init_config_data(current_config_ptr, RRC_STATE_DISCONNECTED);


        /* Initialize Transition Config */
        rrcllc_init_config_data(transition_config.toc_ptr, RRC_STATE_DISCONNECTED);
        transition_config.toc_usage = TOC_INVALID;


        /* Clear RLC Logical Channel Info in LCM */
        rrclcm_clear_rlc_lc_info();
        /* Initialize LLC and initialize Command under process */
        rrcllc_init(RRCLLC_RE_INIT);
        /* Trash all commands till the 1st useful command is dequeued */
        rrcllc_next_substate = rrcllc_trash_cmds_till_first_useful(PROCESS_CONFIG_REQ);
      }
      else if(rrcllc_cmd_under_process.chan_config.current_cmd_engine ==
              LLC_CHAN_CONFIG_ENGINE)
      {

        /* Get out of here */
        rrcllc_next_substate = LLC_IDLE;

        /* Clear Ordered Config if indicated in LLC Command under process */
        if(rrcllc_cmd_under_process.clear_oc_pending)
        {
          WRRC_MSG0_HIGH("Pending ClearOC on Cell Trans Cnf ");
          rrcllc_clear_ordered_config_now();
          rrcllc_cmd_under_process.clear_oc_pending = FALSE;
        }
        else
        {

         /* If this is during DCH to FACH transition, swap OC and CC
          * pointers, so that OC can be used for any upcoming
          * Reconfig.
          */
          if((ordered_config.set_status == OC_SET_FOR_DCH_FACH_TRANS)
           || (ordered_config.set_status == OC_SET_FOR_DCH_CELL_PCH_TRANS)
           || (ordered_config.set_status == OC_SET_FOR_DCH_URA_PCH_TRANS)
           || (transition_config.toc_usage == TOC_FOR_OOS)
             )
          {
            rrcllc_swap_oc_and_cc();
          }

          else if ((cmd_ptr->cmd.state_change_ind.new_state == RRC_STATE_CELL_FACH) &&
                   ((cmd_ptr->cmd.state_change_ind.previous_state == RRC_STATE_CELL_PCH) ||
                   (cmd_ptr->cmd.state_change_ind.previous_state == RRC_STATE_URA_PCH)))
          {
            /* this would be the case when CU procedure initiates CELL_PCH/URA_PCH to CELL_FACH
            transition without setting ordered config */
            rrcllc_swap_oc_and_cc();
          }
      
          else if ((cmd_ptr->cmd.state_change_ind.previous_state == RRC_STATE_CELL_FACH) &&
                   ((cmd_ptr->cmd.state_change_ind.new_state == RRC_STATE_CELL_PCH) ||
                   (cmd_ptr->cmd.state_change_ind.new_state == RRC_STATE_URA_PCH)))
          {
            if((ordered_config.set_status != OC_SET_FOR_FACH_CELL_PCH_TRANS)
               && (ordered_config.set_status != OC_SET_FOR_FACH_URA_PCH_TRANS)
               && (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CU)
               )
            {
              /* this would be the case when FACH->PCH transition happens without
                 setting ordered config.variable. If this transition happens through a
                 reconfiguration message or cellupdate conf where OC is set then the
                 swappin of cc and oc will be taken care when we clear the oc */
              /* Clear off process state now as its scope is over */
              /* CR#743573 - URA update confirm to PCH state is not
                 resetting process_state */
              ordered_config.process_state = LL_NOT_CONFIG_WITH_OC;
              rrcllc_swap_oc_and_cc();
            }
            else if(rrcllc_cmd_under_process.chan_config.chan_config_reason ==
                RRCLLC_CHAN_CFG_REASON_FACH_TO_PCH)
            {
              rrcllc_swap_oc_and_cc();
            }
          } 

        }
      }
      else if(rrcllc_cmd_under_process.chan_config.current_cmd_engine ==
              LLC_STOP_WCDMA_MODE_ENGINE)
      {
        WRRC_MSG0_HIGH("Init Chl Config data on state chg");
        /* Initialize Ordered and Current Configs */
        rrcllc_init_ordered_config_status_and_data(RRC_STATE_DISCONNECTED);
        rrcllc_init_config_data(current_config_ptr, RRC_STATE_DISCONNECTED);

        /* Initialize Transition Config */
        rrcllc_init_config_data(transition_config.toc_ptr, RRC_STATE_DISCONNECTED);
        transition_config.toc_usage = TOC_INVALID;


        /* Clear RLC Logical Channel Info in LCM */
        rrclcm_clear_rlc_lc_info();
        /* Initialize LLC and initialize Command under process */
        rrcllc_init(RRCLLC_RE_INIT_FREE_Q);


        /* Get out of here */
        rrcllc_next_substate = LLC_IDLE;
      }
      else
      {
        WRRC_MSG2_ERROR("LLC state %d engine %d, state chg ind", rrcllc_current_substate,
            rrcllc_cmd_under_process.chan_config.current_cmd_engine);
        /* Get out of here */
        rrcllc_next_substate = LLC_IDLE;
      }
      break;

    case RRC_CPHY_COMPRESSED_MODE_IND:
      if (rrcllc_modify_cm_info_in_current_config(&cmd_ptr->cmd.cm_ind) == SUCCESS)
      {
        rrcllc_send_compressed_mode_run_time_error_ind(&cmd_ptr->cmd.cm_ind);
      }
      break;

    case RRC_STOP_LOWER_LAYER_REQ:
    case RRC_RNTI_UPDATE_REQ:
    case RRC_LLC_CMD_REQ:
    case RRC_RESET_L1_REQ:
    case RRC_LOWER_LAYER_DEACT_REQ:
    case RRC_CHANNEL_CONFIG_REQ:
    case RRC_CELL_RESELECTION_REQ:
      if(( ((uint32)cmd_ptr->cmd_hdr.cmd_id) & CMD_BASE_MASK ) == (uint32)RRC_INT_CMD_BASE)
      {
        (void)rrcllc_put_cmd_on_queue(cmd_ptr);
        MSG_MED("RRC Internal cmd recvd", 0, 0, 0);
      }
      break;

    default:
      WRRC_MSG1_ERROR("Unexpected Cmd 0x%x in LLC_WAIT_MAC_DL_HFN_CNF",
                                   cmd_ptr->cmd_hdr.cmd_id);
      break;
  }

  return(rrcllc_next_substate);

} /* rrcllc_wait_state_chg_ind_handler() */
/*====================================================================
FUNCTION: rrcllc_wait_rrc_resume_rlc_rb_req_handler()

DESCRIPTION:
  This function is a handler for LLC_WAIT_RRC_RESUME_RLC_RB_REQ
  state. If RRC_RESUME_RLC_RB_REQ is received from SMC, it sends
  CRLC_UL_RESUME_REQ and waits for the confirm in
  LLC_WAIT_RRC_CRLC_UL_RESUME_CNF state. Any other command is enqueued
  in the LLC internal queue.

DEPENDENCIES:
  None

RETURN VALUE:
  Next LLC state.

SIDE EFFECTS:
  None.
====================================================================*/
static rrcllc_substate_e_type rrcllc_wait_rrc_resume_rlc_rb_req_handler(rrc_cmd_type *cmd_ptr)
{

  rrcllc_substate_e_type  rrcllc_next_substate = LLC_WAIT_RRC_RESUME_RLC_RB_REQ;

  MSG_MED("Cmd 0x%x recvd in LLC_WAIT_RRC_RESUME_RLC_RB_REQ",
                          cmd_ptr->cmd_hdr.cmd_id, 0, 0);

  switch(cmd_ptr->cmd_hdr.cmd_id)
  {
    case RRC_CHANNEL_CONFIG_REQ:
      if((cmd_ptr->cmd.chan_config_req.next_state == RRC_STATE_DISCONNECTED) &&
          (cmd_ptr->cmd.chan_config_req.rrc_state_change_required == TRUE))
      {
        /* Should all the previously enqueued commands be dequeued? (TBD) */
        /* Now Process the Channel Config Request to Idle */
        rrcllc_next_substate = rrcllc_idle_handler(cmd_ptr);
      }
      else
      {
        (void)rrcllc_put_cmd_on_queue(cmd_ptr);
        MSG_MED("RRC Channel Config request recvd", 0, 0, 0);
      }
      break;


    case RRC_CPHY_COMPRESSED_MODE_IND:
      if (rrcllc_modify_cm_info_in_current_config(&cmd_ptr->cmd.cm_ind) == SUCCESS)
      {
        rrcllc_send_compressed_mode_run_time_error_ind(&cmd_ptr->cmd.cm_ind);
      }
      break;

    case RRC_STOP_LOWER_LAYER_REQ:
    case RRC_RNTI_UPDATE_REQ:
    case RRC_LLC_CMD_REQ:
    case RRC_RESET_L1_REQ:
    case RRC_LOWER_LAYER_DEACT_REQ:
    case RRC_CELL_RESELECTION_REQ:
    case RRC_ABORT_CIPH_CONFIG_REQ:
    case RRC_CIPH_CONFIG_REQ:
      if(( ((uint32)cmd_ptr->cmd_hdr.cmd_id) & CMD_BASE_MASK ) == (uint32)RRC_INT_CMD_BASE)
      {
        (void)rrcllc_put_cmd_on_queue(cmd_ptr);
        MSG_MED("RRC Internal cmd recvd", 0, 0, 0);
      }
      break;

    default:
      WRRC_MSG1_ERROR("Unexpected Cmd 0x%x in LLC_WAIT_RRC_RESUME_RLC_RB_REQ",
                                   cmd_ptr->cmd_hdr.cmd_id);
      break;
  } /* switch() */

  return(rrcllc_next_substate);

} /* rrcllc_wait_rrc_resume_rlc_rb_req_handler */


/*====================================================================
FUNCTION: rrcllc_wait_crlc_ul_resume_cnf_handler()

DESCRIPTION:
  This function is a handler for LLC_WAIT_RRC_RESUME_RLC_RB_REQ
  state. If RRC_CRLC_UL_RESUME_CNF is received from RLC, LLC goes back
  to LLC_IDLE state. Any other command is enqueued in the LLC internal
  queue.

DEPENDENCIES:
  None

RETURN VALUE:
  Next LLC state.

SIDE EFFECTS:
  None.
====================================================================*/
static rrcllc_substate_e_type rrcllc_wait_crlc_ul_resume_cnf_handler(rrc_cmd_type *cmd_ptr)
{

  rrcllc_substate_e_type  rrcllc_next_substate = LLC_WAIT_RRC_CRLC_UL_RESUME_CNF;

  MSG_MED("Cmd 0x%x recvd in LLC_WAIT_RRC_CRLC_UL_RESUME_CNF",
                          cmd_ptr->cmd_hdr.cmd_id, 0, 0);

  switch(cmd_ptr->cmd_hdr.cmd_id)
  {
    case RRC_CRLC_RESUME_CNF:
      WRRC_MSG0_HIGH("Rcv'd RRC_CRLC_RESUME_CNF from RLC");
      rrcllc_next_substate = LLC_IDLE;
      break;

    case RRC_CHANNEL_CONFIG_REQ:
      if((cmd_ptr->cmd.chan_config_req.next_state == RRC_STATE_DISCONNECTED) &&
          (cmd_ptr->cmd.chan_config_req.rrc_state_change_required == TRUE))
      {
        /* Should all the previously enqueued commands be dequeued? (TBD) */
        /* Now Process the Channel Config Request to Idle */
        rrcllc_next_substate = rrcllc_idle_handler(cmd_ptr);
      }
      else
      {
        (void)rrcllc_put_cmd_on_queue(cmd_ptr);
        MSG_MED("RRC Channel Config request recvd", 0, 0, 0);
      }
      break;


    case RRC_CPHY_COMPRESSED_MODE_IND:
      if (rrcllc_modify_cm_info_in_current_config(&cmd_ptr->cmd.cm_ind) == SUCCESS)
      {
        rrcllc_send_compressed_mode_run_time_error_ind(&cmd_ptr->cmd.cm_ind);
      }
      break;

    case RRC_STOP_LOWER_LAYER_REQ:
    case RRC_RNTI_UPDATE_REQ:
    case RRC_LLC_CMD_REQ:
    case RRC_RESET_L1_REQ:
    case RRC_LOWER_LAYER_DEACT_REQ:
    case RRC_CELL_RESELECTION_REQ:
    case RRC_ABORT_CIPH_CONFIG_REQ:
    case RRC_CIPH_CONFIG_REQ:
      if(( ((uint32)cmd_ptr->cmd_hdr.cmd_id) & CMD_BASE_MASK ) == (uint32)RRC_INT_CMD_BASE)
      {
        (void)rrcllc_put_cmd_on_queue(cmd_ptr);
        MSG_MED("RRC Internal cmd recvd", 0, 0, 0);
      }
      break;

    default:
      WRRC_MSG1_ERROR("Unexpected Cmd 0x%x in LLC_WAIT_RRC_CRLC_UL_RESUME_CNF",
                                   cmd_ptr->cmd_hdr.cmd_id);
      break;
  } /* switch() */

  return(rrcllc_next_substate);

} /* rrcllc_wait_crlc_ul_resume_cnf_handler */


/*====================================================================
FUNCTION: rrcllc_handle_llc_commands_on_new_cell_ind()

DESCRIPTION:
  This function handles all the commands queued in LLC queue and
  returns the appropriate state.It will call idle_handle for the
  appropriate commands and trash the funneled ones.

DEPENDENCIES:
  None

RETURN VALUE:
  Next LLC state.

SIDE EFFECTS:
  None.
====================================================================*/
static rrcllc_substate_e_type rrcllc_handle_commands_on_new_cell_ind(rrc_cmd_type *cmd_ptr)
{
  rrc_cmd_type *llc_stored_cmd_ptr;
  rrcllc_substate_e_type rrcllc_next_substate = LLC_IDLE;
  rrc_cmd_type  *rrc_cmd_ptr;

  switch(cmd_ptr->cmd_hdr.cmd_id)
  {
    case RRC_CHANNEL_CONFIG_REQ:
      if(((cmd_ptr->cmd.chan_config_req.rrc_state_change_required == FALSE) && 
           (rrc_get_state() != RRC_STATE_DISCONNECTED)) ||
         (cmd_ptr->cmd.chan_config_req.next_state != RRC_STATE_DISCONNECTED))
      {
        /* Send a Channel Config Confirm with a failure to the requesting procedure */
        (void)rrcllc_send_rrc_channel_config_cnf(cmd_ptr->cmd.chan_config_req.procedure,
                                           cmd_ptr->cmd.chan_config_req.transaction_id,
                                           RRCLLC_CHAN_CFG_FAILURE_INCOMPATIBLE_STATE);
      }
      else
      {
        /* Dequeue internal LLC queue and free all buffers */
        while( q_check(&llc_cmd_q) != NULL )
        {
          if((llc_stored_cmd_ptr = (rrc_cmd_type *) q_get(&llc_cmd_q))!= NULL)
          {
            /* If Measurement request or TVM is found also free the
             * embedded pointer inside the command
             */
            rrcllc_free_cmd_and_embedded_buf(llc_stored_cmd_ptr);
            llc_stored_cmd_ptr = NULL;
          }
        }

        /* Now Process the Channel Config Request to Idle */
        rrcllc_next_substate = rrcllc_idle_handler(cmd_ptr);
      }
      rrcllc_free_cmd_buf(cmd_ptr);

      break;

    case RRC_RNTI_UPDATE_REQ:
      /* Send RRC_RNTI_UPDATE_CNF, if requested by the calling procedure */
      if (cmd_ptr->cmd.rnti_update_req.cnf_required == TRUE)
      {
        rrc_cmd_ptr = rrc_get_int_cmd_buf();
        WRRC_MSG1_HIGH("Sending RRC_RNTI_UPDATE_CNF(FAILURE) to Proc rrc_proc_e_type_value%d",cmd_ptr->cmd.rnti_update_req.procedure);

        /* Fill in the local command header.*/
        rrc_cmd_ptr->cmd_hdr.cmd_id = RRC_RNTI_UPDATE_CNF;
        /* Fill in the procedure id */
        rrc_cmd_ptr->cmd.rnti_update_cnf.procedure =  cmd_ptr->cmd.rnti_update_req.procedure;
        rrc_cmd_ptr->cmd.rnti_update_cnf.status = FAILURE;

        /* Send the internal command */
        rrc_put_int_cmd(rrc_cmd_ptr);
      }
      rrcllc_free_cmd_buf(cmd_ptr);
      break;

    case RRC_STOP_LOWER_LAYER_REQ:
      WRRC_MSG0_HIGH("Rxed STOP_LOWER_LAYER_REQ");
      /* Dequeue internal LLC queue and free all buffers */
      while( q_check(&llc_cmd_q) != NULL )
      {
        if((llc_stored_cmd_ptr = (rrc_cmd_type *) q_get(&llc_cmd_q))!= NULL)
        {
          /* If Measurement request or TVM is found also free the
           * embedded pointer inside the command
           */
          rrcllc_free_cmd_and_embedded_buf(llc_stored_cmd_ptr);
          llc_stored_cmd_ptr = NULL;
        }
      }
      rrcllc_next_substate = rrcllc_idle_handler(cmd_ptr);
      rrcllc_free_cmd_buf(cmd_ptr);
      break;

    case RRC_LOWER_LAYER_DEACT_REQ:
      WRRC_MSG0_HIGH("Rxed LOWER_LAYER_DEACT_REQ");
      /* Dequeue internal LLC queue and free all buffers */
      while( q_check(&llc_cmd_q) != NULL )
      {
        if((llc_stored_cmd_ptr = (rrc_cmd_type *) q_get(&llc_cmd_q))!= NULL)
        {
          /* If Measurement request or TVM is found also free the
                  * embedded pointer inside the command
                  */
          rrcllc_free_cmd_and_embedded_buf(llc_stored_cmd_ptr);
          llc_stored_cmd_ptr = NULL;
        }
      }
      rrcllc_next_substate = rrcllc_idle_handler(cmd_ptr);
      rrcllc_free_cmd_buf(cmd_ptr);
      break;

    case RRC_LLC_CMD_REQ:

      WRRC_MSG0_HIGH("Rxed RRC_LLC_CMD_REQ");
      /* Here make sure to process CRLC_UL_REG_FOR_DATA_IND_REQ && 
         CPHY_DRX_REQ if UE is in one of the PCH states
       */
      if (cmd_ptr->cmd.rrc_llc_req.cmd_dest == LAYER2_RLC_UL && 
          ((cmd_ptr->cmd.rrc_llc_req.l2_ul_cmd.cmd_id == CRLC_UL_REG_FOR_DATA_IND_REQ)
          ||(cmd_ptr->cmd.rrc_llc_req.l2_ul_cmd.cmd_id == CRLC_UL_UNREG_FOR_DATA_IND_REQ))) 
      {
        rrcllc_funnel_l2_ul_req(cmd_ptr);
      }
      else if (cmd_ptr->cmd.rrc_llc_req.cmd_dest == LAYER1_PHY &&
               cmd_ptr->cmd.rrc_llc_req.l1_cmd.cmd_id == CPHY_DRX_REQ) 
      {
        rrcllc_funnel_l1_req(cmd_ptr);
        rrcllc_next_substate = LLC_WAIT_CPHY_DRX_CNF;
      }
      else
      {
        WRRC_MSG1_HIGH("Ignoring the cmd Dest %d ",cmd_ptr->cmd.rrc_llc_req.cmd_dest);
      }

      rrcllc_free_cmd_and_embedded_buf(cmd_ptr);
      break;

    case RRC_CIPH_CONFIG_REQ:
      /* Send ciphering configuration cnf back to SMC */
      rrc_cmd_ptr = rrc_get_int_cmd_buf();
      /* Fill in the Command Header */
      rrc_cmd_ptr->cmd_hdr.cmd_id = RRC_CIPH_CONFIG_CNF;
    
      rrc_cmd_ptr->cmd.rrc_cipher_config_cnf.cause= RRC_CIPHER_CONFIG_FAIL_DIDNT_CONFIG_LL;
    
      WRRC_MSG0_HIGH("Rcv'd RRC_CIPH_CONFIG_REQ from SMC in LLC_WAIT_NEW_CELL_IND, Sending RRC_CIPH_CONFIG_CNF FAIL_DIDNT_CONFIG_LL to SMC");
    
      /* Send command to RRC internal queue */
      rrc_put_int_cmd(rrc_cmd_ptr);

      rrcllc_free_cmd_buf(cmd_ptr);
      break;

    default:
      WRRC_MSG1_ERROR("Discarding funneled Cmd 0x%x recvd in LLC_WAIT_NEW_CELL_IND",
                  cmd_ptr->cmd_hdr.cmd_id);
      /* If Measurement request or TVM is found also free the
       * embedded pointer inside the command
       */
      rrcllc_free_cmd_and_embedded_buf(cmd_ptr);
      break;
  }

  return rrcllc_next_substate;
} /* rrcllc_handle_commands_on_new_cell_ind */
#ifdef FEATURE_WCDMA_HANDLE_MDSP_HALT

/*====================================================================
FUNCTION: rrcllc_send_resume_cnf_to_mcm()

DESCRIPTION:
  This function sends resume_cnf to MCM.

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_send_resume_cnf_to_mcm(void)
{
  /* local cmd var to send confirm back to RRC procs */
  rrc_cmd_type   *cnf_cmd_ptr;
  cnf_cmd_ptr = rrc_get_int_cmd_buf();
  cnf_cmd_ptr->cmd_hdr.cmd_id = RRC_LLC_CMD_CNF;
  cnf_cmd_ptr->cmd.rrc_llc_cnf.procedure = RRC_PROCEDURE_MCM;
  cnf_cmd_ptr->cmd.rrc_llc_cnf.ll_cnf = RRC_LL_CPHY_RESUME_CNF;
  cnf_cmd_ptr->cmd.rrc_llc_cnf.cnf.resume_cnf.status = FALSE;
#ifdef FEATURE_DUAL_SIM
  cnf_cmd_ptr->cmd.rrc_llc_cnf.cnf.resume_cnf.fail_type = WL1_FAILED_NORMAL;
#endif
  WRRC_MSG0_HIGH("Posted Resume CNF to MCM");
}

/*====================================================================
FUNCTION: rrcllc_initiate_cell_selection()

DESCRIPTION:
  This function will send initiate cell selection to CSP

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_initiate_cell_selection_for_recovery(void)
{
  rrc_cmd_type *int_cmd_ptr = NULL;
  if(rrcllc_prev_current_substate == LLC_WAIT_CPHY_RESUME_WCDMA_MODE_CNF)
  {
    rrcllc_send_resume_cnf_to_mcm();
    rrcllc_prev_current_substate = LLC_IDLE;
  }
  int_cmd_ptr =  rrc_get_int_cmd_buf();  
  int_cmd_ptr->cmd_hdr.cmd_id = RRC_INITIATE_CELL_SELECTION_IND;
  int_cmd_ptr->cmd.initiate_cell_sel_ind.cause = RRC_CELL_SEL_ON_MDSP_HALT;
  int_cmd_ptr->cmd.initiate_cell_sel_ind.proc = RRC_PROCEDURE_LLC;
  rrc_put_int_cmd(int_cmd_ptr); 
  WRRC_MSG0_HIGH("Sending Initiate cell selection indication");
}

/*====================================================================
FUNCTION: rrcllc_initiate_cell_selection()

DESCRIPTION:
  This function send CPHY_RECOVER_WCDMA_REQ to WL1

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_send_cphy_recover_wcdma_req(void)
{

  l1_ext_cmd_type *l1_cmd_ptr = l1_get_cmd_buf();

  /* Fill in the Command Header */
  l1_cmd_ptr->cmd_hdr.cmd_id = CPHY_RECOVER_WCDMA_REQ;
  rrc_send_l1_cmd(l1_cmd_ptr);

#ifdef FEATURE_RRC_CAPTURE_L1_DEADLOCK
  /* Start timer for L1 deadlock detection */
  rrctmr_start_timer( RRCTMR_L1_DEADLOCK_DETECT_TIMER,
                      RRCTMR_L1_DEADLOCK_DETECT_TIMER_IN_MS );
#endif

}

/*====================================================================
FUNCTION: rrcllc_handle_mdsp_halt_ind()

DESCRIPTION:
  This function handles mDSP halt indication from L1.

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
static rrcllc_substate_e_type rrcllc_handle_mdsp_halt_ind(void)
{
  rrcllc_substate_e_type rrcllc_next_substate = rrcllc_current_substate;
  boolean can_handle_mdsp_halt_ind = TRUE;
  rrcmcm_state_e_type mcm_state = rrcmcm_get_substate();
  /*Stop the WL1 timers is */
  #ifdef FEATURE_RRC_CAPTURE_L1_DEADLOCK
   rrctmr_stop_timer(RRCTMR_L1_DEADLOCK_DETECT_TIMER);
  #endif
  #ifdef FEATURE_RRC_DELAY_ERR_FATAL
   rrctmr_stop_timer(RRCTMR_DELAY_ERR_FATAL_TIMER);
  #endif

  /*If MCM is waiting for START/STOP, RRC cannot handle the mdsp halt indication*/
  if((RRCMCM_WAIT_START_CNF == mcm_state) ||
     (RRCMCM_WAIT_STOP_CNF_FOR_MODE_CHANGE == mcm_state) ||
     (RRCMCM_WAIT_STOP_CNF == mcm_state))
  {
    WRRC_MSG1_HIGH("MCM state %d, cannot handle",mcm_state);
    can_handle_mdsp_halt_ind = FALSE;
  }
  if(!can_handle_mdsp_halt_ind)
  {
    ERR_FATAL("Cannot handle MDSP HALT_IND",0,0,0);
  }

  if((rrcllc_cmd_under_process.valid) &&
    (rrcllc_cmd_under_process.rrc_current_cmd_id == RRC_CHANNEL_CONFIG_REQ))
  {
      if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
      {
      /*Set Status as Inactive/Active in RRC, same as  MAC .
         as it has acted on CMAC_CONFIG.RRC and MAC needs to be in Sync.*/
        if((rrcllc_cmd_under_process.chan_config.hsdpa_inactive_to_active) && (mac_is_hs_cfg_active() == TRUE))
        {
          WRRC_MSG0_HIGH("RRCHS:HSDPAACTIVE");
          rrc_set_hsdpa_status(HSDPA_ACTIVE);
        }
      }
  }
						
  /*Initialize the LLC internal queue*/
  rrcllc_queue_init();

  /*Send the Recover req to WL1*/
  rrcllc_send_cphy_recover_wcdma_req();
  rrcllc_next_substate = LLC_WAIT_CPHY_RECOVER_CNF;
  rrcllc_prev_current_substate = rrcllc_current_substate;
  return rrcllc_next_substate;
}


/*====================================================================
FUNCTION: rrcllc_wait_cphy_recover_wcdma_cnf()

DESCRIPTION:
  This function is a handler for LLC_WAIT_CPHY_RECOVER_CNF

DEPENDENCIES:
  None

RETURN VALUE:
  Next LLC state.

SIDE EFFECTS:
  None.
====================================================================*/
static rrcllc_substate_e_type rrcllc_wait_cphy_recover_wcdma_cnf(rrc_cmd_type *cmd_ptr)
{
  rrcllc_substate_e_type rrcllc_next_substate = LLC_WAIT_CPHY_RECOVER_CNF;
  boolean put_cmd_on_queue = FALSE;
  switch(cmd_ptr->cmd_hdr.cmd_id)
  {
    case RRC_CPHY_RECOVER_WCDMA_CNF:
      rrctmr_stop_timer( RRCTMR_L1_DEADLOCK_DETECT_TIMER);
      rrcllc_next_substate = LLC_IDLE;
      if((dch_state_handling_needed) && (rrc_get_state() == RRC_STATE_CELL_DCH) && 
             (OC_NOT_SET == rrcllc_get_ordered_config_status_wo_f3()) &&
             (RRCCSP_CAMPED_SUIT_CELL == rrc_get_csp_substate()) &&
             (!rrciho_is_gtow_ho_active()) && 
             (!rrciho_is_wtog_ho_active()) &&
             (!rrccho_is_gtow_pcco_in_progress()) &&
             (!rrccho_is_wtog_cco_active()) &&
             (!rrc_is_voice_rab_present())
        )
      {
        if(!rrccu_handle_mdsp_halt_recov_in_dch())
        {
          rrcllc_initiate_cell_selection_for_recovery();
        }
      }
      else
      {
        /*Post initiate cell selection to CSP*/
        rrcllc_initiate_cell_selection_for_recovery();
      }
      break;
    case RRC_STOP_LOWER_LAYER_REQ:
      WRRC_MSG0_HIGH("STOP Lower layer req, put the cmd on LLC internal queue");
      put_cmd_on_queue = TRUE;
      break;
    default :
      WRRC_MSG1_ERROR("Ignore cmd id %d waiting for recovery cnf",cmd_ptr->cmd_hdr.cmd_id);
      break;
  }
  if(put_cmd_on_queue)
  {
    (void)rrcllc_put_cmd_on_queue(cmd_ptr);
  }
  return rrcllc_next_substate;
}
#endif

/*====================================================================
FUNCTION: rrcllc_wait_new_cell_ind_handler()

DESCRIPTION:
  This function is a handler for LLC_WAIT_NEW_CELL_IND
  state and takes care of all incoming commands and Confirms from RRC
  procedures, MAC, RLC and L1.

DEPENDENCIES:
  None

RETURN VALUE:
  Next LLC state.

SIDE EFFECTS:
  None.
====================================================================*/
static rrcllc_substate_e_type rrcllc_wait_new_cell_ind_handler(rrc_cmd_type *cmd_ptr)
{

  rrcllc_substate_e_type  rrcllc_next_substate = LLC_WAIT_NEW_CELL_IND;
  rrc_cmd_type *llc_cmd_ptr;

  MSG_MED("Cmd 0x%x recvd in LLC_WAIT_NEW_CELL_IND",
                          cmd_ptr->cmd_hdr.cmd_id, 0, 0);

  switch(cmd_ptr->cmd_hdr.cmd_id)
  {
    case RRC_NEW_CELL_IND:
      WRRC_MSG0_HIGH("Rcv'd RRC_NEW_CELL_IND from CCM");

      /* Clear Ordered Config if indicated in LLC Command under process */
      if(rrcllc_cmd_under_process.clear_oc_pending)
      {
        WRRC_MSG0_HIGH("Pending ClearOC on NEW_CELL_IND");
        rrcllc_clear_ordered_config_now();
      }
      /* Clear the LLC internal queue. If there is a Channel Config Req to go to Idle
       * process it. The commands from LLC command queue are dequeued till there are
       * no more commands on the queue and as long as LLC state returned is LLC_IDLE.
       */

      rrcllc_next_substate = LLC_IDLE;

      if(rrc_get_state() == RRC_STATE_DISCONNECTED)
      {
        MSG_MED("No special processing in DISCON state",0,0,0);
      }
      else
      {
        while((rrcllc_next_substate == LLC_IDLE) &&
               (( (rrc_cmd_type *)q_check(&llc_cmd_q) ) != NULL))
        {
          if((llc_cmd_ptr = (rrc_cmd_type *) q_get(&llc_cmd_q))!= NULL)
          {
            rrcllc_next_substate = rrcllc_handle_commands_on_new_cell_ind(llc_cmd_ptr);
            llc_cmd_ptr = NULL;
          }
        }
      }

      break;

    case RRC_LLC_CMD_REQ:
      if(cmd_ptr->cmd.rrc_llc_req.cmd_dest == LAYER1_PHY)
      {
        /* Check and see which L1 command was just received from an RRC procedure.*/
        MSG_MED("Recvd L1 cmd %d from RRC Procedure",
                cmd_ptr->cmd.rrc_llc_req.l1_cmd.cmd_id,
                cmd_ptr->cmd.rrc_llc_req.procedure, 0);

        switch (cmd_ptr->cmd.rrc_llc_req.l1_cmd.cmd_id)
        {
          case CPHY_MEASUREMENT_REQ:
          case CPHY_CELL_PARM_REQ:
            /* Handle them right away */
            rrcllc_funnel_l1_req(cmd_ptr);
            break;
          default:
            /* Enqueue the command in LLC internal queue */
            (void)rrcllc_put_cmd_on_queue(cmd_ptr);
            WRRC_MSG0_HIGH("RRC Internal cmd recvd");
            break;
        }
      }
      else if(cmd_ptr->cmd.rrc_llc_req.cmd_dest == LAYER2_MAC_UL)
      {
        
        MSG_MED("Recvd L2 cmd %d from RRC Procedure",
                cmd_ptr->cmd.rrc_llc_req.l2_ul_cmd.cmd_id,
                cmd_ptr->cmd.rrc_llc_req.procedure, 0);

        switch (cmd_ptr->cmd.rrc_llc_req.l2_ul_cmd.cmd_id)
        {
          case CMAC_UL_TRAFFIC_VOLUME_CONFIG_REQ :
            /* Handle them right away */
            rrcllc_funnel_l2_ul_req(cmd_ptr);
            break;
          default:
            /* Enqueue the command in LLC internal queue */
            (void)rrcllc_put_cmd_on_queue(cmd_ptr);
            WRRC_MSG0_HIGH("RRC Internal cmd recvd");
            break;
        }
      }
      else
      {
        /* Enqueue the command in LLC internal queue */
        (void)rrcllc_put_cmd_on_queue(cmd_ptr);
        WRRC_MSG0_HIGH("RRC Internal cmd recvd");
      }
      break;

    case RRC_STOP_LOWER_LAYER_REQ:
    case RRC_RNTI_UPDATE_REQ:
    case RRC_RESET_L1_REQ:
    case RRC_LOWER_LAYER_DEACT_REQ:
    case RRC_CHANNEL_CONFIG_REQ:
    case RRC_CELL_RESELECTION_REQ:
    case RRC_ABORT_CIPH_CONFIG_REQ:
    case RRC_CIPH_CONFIG_REQ:
      if(( ((uint32)cmd_ptr->cmd_hdr.cmd_id) & CMD_BASE_MASK ) == (uint32)RRC_INT_CMD_BASE)
      {
        (void)rrcllc_put_cmd_on_queue(cmd_ptr);
        WRRC_MSG0_HIGH("RRC Internal cmd recvd");
      }
      break;

    default:
      WRRC_MSG1_ERROR("Unexpected Cmd 0x%x in LLC_WAIT_NEW_CELL_IND",
                                   cmd_ptr->cmd_hdr.cmd_id);
      break;
  } /* switch() */

  return(rrcllc_next_substate);

} /* rrcllc_wait_new_cell_ind_handler */


/********************************************************************
**                LLC Main Entry Point
**
*********************************************************************/


/*====================================================================
FUNCTION: rrcllc_process_cmd()

DESCRIPTION:
  This function is the main entry point for LLC. It is called by RRC
  dispatcher for all commands that are meant to be for LLC.
  This function depending on the existing LLC state, calls the
  corresponding LLC state handler.
  If the next LLC state as returned from LLC state handler is
  LLC_IDLE, the LLC command queue is dequeued and the new command
  processed till there are no more commands in LLC command queue.

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_process_cmd(rrc_cmd_type *cmd_ptr)
{
  rrc_cmd_type  *llc_stored_cmd_ptr;

  rrc_state_e_type  rrc_state = rrc_get_state();

  WRRC_MSG2_HIGH_OPT("function rrcllc_process_cmd is called in rrc_state = rrc_state_e_type_value%d and rrcllc_current_substate rrcllc_substate_e_type_value%d", rrc_state, rrcllc_current_substate);
  rrc_crash_debug_save_proc_substates(RRC_PROCEDURE_LLC,rrcllc_current_substate,cmd_ptr->cmd_hdr.cmd_id);

#ifdef FEATURE_UMTS_1X_HANDOVER_UMTSMSM
  #error code not present
#endif

#ifdef FEATURE_RRC_L1_ERROR_RECOVERY_P1
  if((cmd_ptr->cmd_hdr.cmd_id == RRC_CPHY_OPERATIONAL_ERROR_IND) &&
     (rrcllc_current_substate != LLC_IDLE))
  {
    /* Ignore the OPER_ERR_IND for now */
    WRRC_MSG1_ERROR("Rxed OPER_ERR_IND in LLC sstate %d, ignored",rrcllc_current_substate);
    WRRC_MSG1_ERROR("Error src type = %d",cmd_ptr->cmd.op_err_ind.src);
    return;
  }
#endif

#ifdef FEATURE_RRC_CAPTURE_L1_DEADLOCK
  if(cmd_ptr->cmd_hdr.cmd_id ==
     RRCTMR_L1_DEADLOCK_DETECT_TIMER_EXPIRED_IND)
  {
    rrcllc_l1_deadlock_handler(rrcllc_current_substate);
    return;
  }
#ifdef FEATURE_RRC_DELAY_ERR_FATAL
  if(cmd_ptr->cmd_hdr.cmd_id == RRCTMR_DELAY_ERR_FATAL_TIMER_EXPIRED_IND)
  {
    rrcllc_current_substate = rrcllc_delay_err_fatal_handler(rrcllc_current_substate);
    return;
  }
#endif /* FEATURE_RRC_DELAY_ERR_FATAL */

#endif /* FEATURE_RRC_CAPTURE_L1_DEADLOCK */

  if(cmd_ptr->cmd_hdr.cmd_id == RRC_CPHY_ERROR_IND)
  {
#ifndef FEATURE_RRC_ERROR_DETECT
    if(rrc_state != RRC_STATE_DISCONNECTED)
    {
      WRRC_MSG1_ERROR("Cphy Err Ind in %d LLC state", rrcllc_current_substate);
      rrcllc_current_substate = LLC_IDLE;
      /* Self-enqueue a Channel Config Request that takes UE to Idle */
      rrcllc_self_enqueue_channel_config_to_idle();
    }
#else
    /* Ignore measurment err ind from L1 if llc is not waiting for meas cnf, otherwise Meas proc has to be informed   
        regarding the thrash and move the llc state to Idle */
    if((cmd_ptr->cmd.err_ind.cmd_id == CPHY_CELL_PARM_REQ) || (cmd_ptr->cmd.err_ind.cmd_id == CPHY_DRX_REQ)
        || ((cmd_ptr->cmd.err_ind.cmd_id == CPHY_MEASUREMENT_REQ) && (rrcllc_current_substate != LLC_WAIT_CPHY_MEAS_CTRL_CNF)))
    {
      WRRC_MSG2_ERROR("Cphy Err Ind for RRC cmd 0x%x in LLC state %d",cmd_ptr->cmd.err_ind.cmd_id, rrcllc_current_substate);
      if((rrcllc_current_substate == LLC_WAIT_CPHY_DRX_CNF) && (cmd_ptr->cmd.err_ind.cmd_id == CPHY_DRX_REQ))
      {
        rrcllc_current_substate = LLC_IDLE;
      }
      return;
    }
    else if((cmd_ptr->cmd.err_ind.cmd_id == CPHY_MEASUREMENT_REQ) && (rrcllc_current_substate == LLC_WAIT_CPHY_MEAS_CTRL_CNF))
    {
      WRRC_MSG2_ERROR("Cphy Err Ind for RRC cmd 0x%x in LLC state %d",cmd_ptr->cmd.err_ind.cmd_id, rrcllc_current_substate);
    }
    else
    {
      ERR_FATAL("Cphy Err Ind for RRC cmd 0x%x in LLC state %d",cmd_ptr->cmd.err_ind.cmd_id, rrcllc_current_substate, 0);
    }
#endif /* FEATURE_RRC_ERROR_DETECT */
  } 
#ifdef FEATURE_WCDMA_HANDLE_MDSP_HALT
	if(RRC_CPHY_MDSP_HALT_IND == cmd_ptr->cmd_hdr.cmd_id)
	{
	  rrcllc_current_substate = rrcllc_handle_mdsp_halt_ind();
	  return;
	}
#endif

  switch(rrcllc_current_substate)
  {
    case LLC_IDLE:
      rrcllc_current_substate = rrcllc_idle_handler(cmd_ptr);
      break;

    case LLC_WAIT_CPHY_SETUP_CNF:
      rrcllc_current_substate = rrcllc_wait_cphy_setup_cnf_handler(cmd_ptr);
      WHILE_LLC_IDLE_DEQUEUE_CMD_CALL_HDLR;
      break;

    case LLC_WAIT_CPHY_CHANNEL_IND:
      rrcllc_current_substate = rrcllc_wait_cphy_channel_ind_handler(cmd_ptr);
      WHILE_LLC_IDLE_DEQUEUE_CMD_CALL_HDLR;
      break;

    case LLC_WAIT_CPHY_IN_SYNC_IND:
      WRRC_MSG0_ERROR("LLC state: LLC_WAIT_CPHY_IN_SYNC_IND not supported");
      break;

    case LLC_WAIT_CPHY_IDLE_CNF:
      rrcllc_current_substate = rrcllc_wait_cphy_idle_cnf_handler(cmd_ptr);
      WHILE_LLC_IDLE_DEQUEUE_CMD_CALL_HDLR;
      break;

    case LLC_WAIT_CPHY_DEACTIVATE_CNF:
      rrcllc_current_substate = rrcllc_wait_cphy_deactivate_cnf_handler(cmd_ptr);
      WHILE_LLC_IDLE_DEQUEUE_CMD_CALL_HDLR;
      break;

    case LLC_WAIT_CPHY_ACQ_CNF:
      rrcllc_current_substate = rrcllc_wait_cphy_acq_cnf_handler(cmd_ptr);
      WHILE_LLC_IDLE_DEQUEUE_CMD_CALL_HDLR;
      break;

    case LLC_WAIT_CPHY_FREQ_SCAN_CNF:
      rrcllc_current_substate = rrcllc_wait_freq_scan_cnf_handler(cmd_ptr);
      WHILE_LLC_IDLE_DEQUEUE_CMD_CALL_HDLR;
      break;

    case LLC_WAIT_CPHY_CAPABILITY_CNF:
      rrcllc_current_substate = rrcllc_wait_cphy_capability_cnf_handler(cmd_ptr);
      WHILE_LLC_IDLE_DEQUEUE_CMD_CALL_HDLR;
      break;

    case LLC_WAIT_CPHY_CELL_SELECTION_CNF:
      rrcllc_current_substate = rrcllc_wait_cphy_cell_select_cnf_handler(cmd_ptr);
      WHILE_LLC_IDLE_DEQUEUE_CMD_CALL_HDLR;
      break;

    case LLC_WAIT_CPHY_CELL_TRANSITION_CNF:
      rrcllc_current_substate = rrcllc_wait_cphy_cell_trans_cnf_handler(cmd_ptr);
      WHILE_LLC_IDLE_DEQUEUE_CMD_CALL_HDLR;
      break;

    case LLC_WAIT_CPHY_MEAS_CTRL_CNF:
      rrcllc_current_substate = rrcllc_wait_cphy_meas_ctrl_cnf_handler(cmd_ptr);
      WHILE_LLC_IDLE_DEQUEUE_CMD_CALL_HDLR;
      break;

    case LLC_WAIT_MAC_UL_HFN_CNF:
      rrcllc_current_substate = rrcllc_wait_mac_ul_hfn_cnf_handler(cmd_ptr);
      WHILE_LLC_IDLE_DEQUEUE_CMD_CALL_HDLR;
      break;

    case LLC_WAIT_MAC_DL_HFN_CNF:
      rrcllc_current_substate = rrcllc_wait_mac_dl_hfn_cnf_handler(cmd_ptr);
      WHILE_LLC_IDLE_DEQUEUE_CMD_CALL_HDLR;
      break;

    case LLC_WAIT_RLC_TM_UL_CNF:
      rrcllc_current_substate = rrcllc_wait_rlc_tm_ul_cnf_handler(cmd_ptr);
      WHILE_LLC_IDLE_DEQUEUE_CMD_CALL_HDLR;
      break;

    case LLC_WAIT_RLC_TM_DL_CNF:
      rrcllc_current_substate = rrcllc_wait_rlc_tm_dl_cnf_handler(cmd_ptr);
      WHILE_LLC_IDLE_DEQUEUE_CMD_CALL_HDLR;
      break;

    case LLC_WAIT_RLC_UM_UL_CNF:
      rrcllc_current_substate = rrcllc_wait_rlc_um_ul_cnf_handler(cmd_ptr);
      WHILE_LLC_IDLE_DEQUEUE_CMD_CALL_HDLR;
      break;

    case LLC_WAIT_RLC_UM_DL_CNF:
      rrcllc_current_substate = rrcllc_wait_rlc_um_dl_cnf_handler(cmd_ptr);
      WHILE_LLC_IDLE_DEQUEUE_CMD_CALL_HDLR;
      break;

    case LLC_WAIT_RLC_AM_CNF:
      rrcllc_current_substate = rrcllc_wait_rlc_am_cnf_handler(cmd_ptr);
      WHILE_LLC_IDLE_DEQUEUE_CMD_CALL_HDLR;
      break;

    case LLC_WAIT_RLC_UL_HFN_CNF:
      rrcllc_current_substate = rrcllc_wait_rlc_ul_hfn_cnf_handler(cmd_ptr);
      WHILE_LLC_IDLE_DEQUEUE_CMD_CALL_HDLR;
      break;

    case LLC_WAIT_RLC_DL_HFN_CNF:
      rrcllc_current_substate = rrcllc_wait_rlc_dl_hfn_cnf_handler(cmd_ptr);
      WHILE_LLC_IDLE_DEQUEUE_CMD_CALL_HDLR;
      break;

    case LLC_WAIT_RLC_REL_ALL_CNF:
      rrcllc_current_substate = rrcllc_wait_rlc_rel_all_cnf_handler(cmd_ptr);
      WHILE_LLC_IDLE_DEQUEUE_CMD_CALL_HDLR;
      break;

    case LLC_WAIT_NEW_CELL_IND:
      rrcllc_current_substate = rrcllc_wait_new_cell_ind_handler(cmd_ptr);
      WHILE_LLC_IDLE_DEQUEUE_CMD_CALL_HDLR;
      break;

    case LLC_WAIT_CPHY_STOP_WCDMA_MODE_CNF:
      rrcllc_current_substate = rrcllc_wait_cphy_stop_wcdma_mode_cnf_handler(cmd_ptr);
      WHILE_LLC_IDLE_DEQUEUE_CMD_CALL_HDLR;
      break;
    case LLC_WAIT_CPHY_SUSPEND_WCDMA_MODE_CNF:
      rrcllc_current_substate = rrcllc_wait_cphy_suspend_wcdma_mode_cnf_handler(cmd_ptr);
      break;

    case LLC_WAIT_CPHY_RESUME_WCDMA_MODE_CNF:
      rrcllc_current_substate = rrcllc_wait_cphy_resume_wcdma_mode_cnf_handler(cmd_ptr);
      break;
    case LLC_WAIT_FOR_STATE_CHG_IND:
      rrcllc_current_substate = rrcllc_wait_state_chg_ind_handler(cmd_ptr);
      WHILE_LLC_IDLE_DEQUEUE_CMD_CALL_HDLR;
      break;

    case LLC_WAIT_RRC_RESUME_RLC_RB_REQ:
      rrcllc_current_substate = rrcllc_wait_rrc_resume_rlc_rb_req_handler(cmd_ptr);
      WHILE_LLC_IDLE_DEQUEUE_CMD_CALL_HDLR;
      break;

    case LLC_WAIT_RRC_CRLC_UL_RESUME_CNF:
      rrcllc_current_substate = rrcllc_wait_crlc_ul_resume_cnf_handler(cmd_ptr);
      WHILE_LLC_IDLE_DEQUEUE_CMD_CALL_HDLR;
      break;

    case LLC_WAIT_CPHY_DRX_CNF:
      rrcllc_current_substate = rrcllc_wait_cphy_drx_cnf_handler(cmd_ptr);
      WHILE_LLC_IDLE_DEQUEUE_CMD_CALL_HDLR;
      break;

    case LLC_WAIT_CPHY_START_WCDMA_MODE_CNF:
      rrcllc_current_substate = rrcllc_wait_cphy_start_wcdma_mode_cnf_handler(cmd_ptr);
      WHILE_LLC_IDLE_DEQUEUE_CMD_CALL_HDLR;
      break;

    case LLC_WAIT_CPHY_ACT_TIME_CANCEL_CNF :
      rrcllc_current_substate = rrcllc_wait_cphy_act_time_canc_cnf_handler(cmd_ptr);
      WHILE_LLC_IDLE_DEQUEUE_CMD_CALL_HDLR;
      break;
#ifdef FEATURE_UMTS_1X_HANDOVER_UMTSMSM
    #error code not present
#endif
#ifdef FEATURE_WCDMA_HANDLE_MDSP_HALT
		 case LLC_WAIT_CPHY_RECOVER_CNF:
		   rrcllc_current_substate = rrcllc_wait_cphy_recover_wcdma_cnf(cmd_ptr);
		   WHILE_LLC_IDLE_DEQUEUE_CMD_CALL_HDLR;
		   break;
#endif

    default:
      WRRC_MSG1_ERROR("LLC state %d not supported", rrcllc_current_substate);
      break;

  } /* switch(rrcllc_current_substate) */
} /* void rrcllc_process_cmd(rrc_cmd_type *cmd_ptr) */

/*====================================================================
FUNCTION: rrcllc_command_engine()

DESCRIPTION:
  This function calls the appropriate LLC command engine based
  on the current command engine setting.

DEPENDENCIES:
  None

RETURN VALUE:
  Success/Failure

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type
rrcllc_command_engine(
  rrcllc_substate_e_type state,
  rrcllc_substate_e_type *next_substate_ptr
  )
{
  uecomdef_status_e_type return_status;
  switch(rrcllc_cmd_under_process.chan_config.current_cmd_engine)
  {
    case LLC_CHAN_CONFIG_ENGINE:
      return_status = rrcllc_chan_config_engine(state, next_substate_ptr);
      break;

    case LLC_RELEASE_ALL_CHAN_ENGINE:
      return_status = rrcllc_release_all_chan_engine(state, next_substate_ptr);
      break;

    case LLC_RELEASE_TR_PHY_CHAN_ENGINE:
      return_status = rrcllc_release_tr_phy_chan_engine(state, next_substate_ptr);
      break;

    case LLC_CELL_RESELECTION_ENGINE:
      return_status = rrcllc_cell_reselection_engine(state, next_substate_ptr);
      break;

    case LLC_STOP_WCDMA_MODE_ENGINE:
      return_status = rrcllc_stop_wcdma_mode_engine(state, next_substate_ptr);
      break;

    case LLC_DEACT_ENGINE:
      return_status = rrcllc_deactivation_engine(state, next_substate_ptr);
      break;

    case LLC_RE_EST_RLC_ENGINE:
      return_status = rrcllc_re_est_rlc_engine(state, next_substate_ptr);
      break;

    case LLC_BYPASS_ENGINE:
      return_status = SUCCESS;
      break;
    default:
      WRRC_MSG1_ERROR("Unknown cmd engine %d",
          rrcllc_cmd_under_process.chan_config.current_cmd_engine);
      return_status = FAILURE;
      break;
  }

  return(return_status);
}

/*====================================================================
FUNCTION: rrcllc_return_current_substate()

DESCRIPTION:
  This function returns the current llc substate.

DEPENDENCIES:
  None.

RETURN VALUE:
  current llc substate.

SIDE EFFECTS:
  None.

=====================================================================*/
rrcllc_substate_e_type rrcllc_return_current_substate(void)
{
  return rrcllc_current_substate; 
}

/*====================================================================
FUNCTION: rrcllc_is_rab_release_in_progress()

DESCRIPTION:
  This function returns true if rrcllc is processing rab release due to T314/315 timer expiry. 
  This function was introduced to handle a corner case where Cell Update Confirm was received while 
  RAB release was in progress
  Scenario: 
1.CS call is going on
2.RLC RESET, UE moves to FACH and does CU
3.CS RAB Re-establishment timer expires and we release the RAB
4.While releasing the RAB(waiting for RRC_CRLC_DL_TM_CONFIG_CNF), UE receives CU-CNF to DCH state
5.CU-CNF updates OC, UE now receives RRC_CRLC_DL_TM_CONFIG_CNF
6.OC and CC are Swapped as rab-release is completed
7.LLC does Channel config to DCH 

DEPENDENCIES:
  None.

RETURN VALUE:
  current llc substate.

SIDE EFFECTS:
  None.

=====================================================================*/
boolean rrcllc_is_rab_release_in_progress(void)
{
  if((rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_FACH)&&
     (rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CU) &&
     (rrcllc_cmd_under_process.chan_config.current_cmd_engine == LLC_CHAN_CONFIG_ENGINE) &&
     (rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_RLC_CONFIG_ONLY)&&
     (rrcllc_return_current_substate() != LLC_IDLE))
  {
    return TRUE;
  }

  else return FALSE;
  
}

/*====================================================================
FUNCTION: rrcllc_check_going_to_old_config()

DESCRIPTION:
  This function checks if going back to old config is ongoing.

DEPENDENCIES:
  None.

RETURN VALUE:
  TRUE   going back to old confing in progress.
  FALSE  going back to old confing is not in progress

SIDE EFFECTS:
  None.

=====================================================================*/
boolean rrcllc_check_going_to_old_config(void)
{
  if(rrcllc_cmd_under_process.chan_config.l1_req_list.l1_req[0].cmd.setup.hho_setup_mask &
    CPHY_HHO_RESUME_TO_OLD_CONFIG_HHO_INCL)
  {
    return TRUE;
  }
  return FALSE;
}

/*====================================================================
FUNCTION: rrcllc_check_sufficient_act_time()

DESCRIPTION:
  This function checks if there is sufficient activation time to kill
  the pending configuration.

DEPENDENCIES:
  None.

RETURN VALUE:
  TRUE   Sufficient activation time .
  FALSE  Insufficient activation time.

SIDE EFFECTS:
  None.

=====================================================================*/
boolean rrcllc_check_sufficient_act_time(void)
{
  int16    current_frame;
  int16    max_frame_count;
  int16    sdu_to_act_frames, sdu_to_current_frames;
  int16 activate_action_time = 0;

  current_frame   = (int16)seq_get_cfn();
  max_frame_count = MAX_CFN_COUNT;

  /* Grab the activation time from the command header. */
  activate_action_time = (int16)ordered_config_ptr->activation_time;
                            
  /* Frames from reception of command in RLC to its real activation time, and
   ** to the current frame. */
  sdu_to_act_frames     = activate_action_time - (int16)ordered_config_ptr->sdu_time;
  sdu_to_current_frames = current_frame        - (int16)ordered_config_ptr->sdu_time;
                             
  /* Results are never really negative.  Normalize to make positive. */
  if (sdu_to_act_frames < 0)
  {
    sdu_to_act_frames += max_frame_count;
  }
               
  if (sdu_to_current_frames < 0)
  {
    sdu_to_current_frames += max_frame_count;
  }
                  
  /* Did processing delay cause us to miss our activation time?  The
  ** sequencer begins processing a pending command 1 frame before its
  ** activation time.  So if we're just 3 frames away, treat it as missed,
  ** and initiate processing now. */
  MSG_6(MSG_SSID_DFLT, MSG_LEGACY_HIGH,"Act time:%d Curr Frame:%d, SDUt %d toCurFr %d toActFr %d Act time missed %d",
  activate_action_time, current_frame,ordered_config_ptr->sdu_time,sdu_to_current_frames, sdu_to_act_frames,((sdu_to_current_frames + 3) > sdu_to_act_frames));
  if ((sdu_to_current_frames + 3) > sdu_to_act_frames)
  {
    /* Rats!  We missed the activation time.  Process command now! */
    return FALSE;
  }
  return TRUE;
}

/*====================================================================
FUNCTION: rrcllc_get_n_bcch_setup_status()

DESCRIPTION:
  This function will return N-BCCH set up status.
  It will return TRUE if N-BCCH is set up FALSE other wise

DEPENDENCIES:
  None.

RETURN VALUE:
  TRUE : If N-BCCH is set up
  FALSE otherwise
SIDE EFFECTS:
  None.

=====================================================================*/
uecomdef_status_e_type rrcllc_get_bcch_psc(uint32* psc)
{
  uecomdef_status_e_type ret_value = SUCCESS;
  ordered_config_type *cfg_ptr = NULL;
  cfg_ptr = rrcllc_get_config_ptr_in_use();
  if (rrcllc_semi_permanent_data.dl_phy_chan.pccpch_is_up)
  {
    *psc = (cfg_ptr->l1_dl_chan_parms.pccpch.scr_code >> 4); 
  }
  else
  {
    WRRC_MSG0_ERROR("PCCPCH is not up.");
    ret_value = FAILURE;
  }

  return ret_value;
}

/*====================================================================
FUNCTION: rrcllc_check_if_chan_config_in_progress_for_sib5_change()

DESCRIPTION:
  This function will return TRUE if channels are being configured for sib5 change (Requested by CSP)
  It will return FALSE other wise

DEPENDENCIES:
  None.

RETURN VALUE:
  TRUE : if channels are being configured for sib change
  FALSE otherwise
SIDE EFFECTS:
  None.

=====================================================================*/
boolean rrcllc_check_if_chan_config_in_progress_for_sib5_change
(
  void
)
{
  boolean status=FALSE;
  if((rrcllc_current_substate != LLC_IDLE &&
     rrcllc_cmd_under_process.valid &&
     rrcllc_cmd_under_process.rrc_current_cmd_id == RRC_CHANNEL_CONFIG_REQ &&
     rrcllc_cmd_under_process.chan_config.chan_config_reason == RRCLLC_CHAN_CFG_REASON_RECONFIG_PCH_FACH &&
     rrcllc_cmd_under_process.procedure == RRC_PROCEDURE_CSP)||
     rrcllc_get_sib5_change_in_progress_flag() != CELL_CHANGE_INACTIVE)
  {
    status = TRUE;
  }
  return status;
}

/*====================================================================
FUNCTION: rrcllc_process_chan_config_request()

DESCRIPTION:
  This function will process the channel config request

DEPENDENCIES:
  None.

RETURN VALUE:
  Next LLC State
  
SIDE EFFECTS:
  None.

=====================================================================*/
rrcllc_substate_e_type rrcllc_process_chan_config_request
(
  rrc_cmd_type *cmd_ptr
)
{
  rrcllc_substate_e_type  rrcllc_next_substate = LLC_IDLE;
    rrc_cmd_type* llc_stored_cmd_ptr;
  rrc_state_e_type rrc_state = rrc_get_state();
#ifdef FEATURE_WCDMA_HS_FACH  
  ordered_config_type  *config_ptr = NULL;
#endif
  WRRC_MSG0_MED("In Process chan config request");
  rrc_log_nv_status();
  rrc_log_feature_state_variables_status(ordered_config_ptr);
  rrc_log_rb_mapping_info(ordered_config_ptr);
#ifdef FEATURE_WCDMA_HS_FACH  
  if(config_ptr_in_use == ORDERED_CONFIG)
  {
    config_ptr = ordered_config_ptr;
  }
  else
  {
    config_ptr = current_config_ptr;
  }
#endif
  if((cmd_ptr->cmd.chan_config_req.procedure == RRC_PROCEDURE_CSP) &&
      (cmd_ptr->cmd.chan_config_req.chan_config_reason ==
            RRCLLC_CHAN_CFG_REASON_RECONFIG_PCH_FACH))
  {

#ifdef FEATURE_WCDMA_HS_FACH 
     /*we are going to ignore the channel config if CU has already has been started*/
     if ((ordered_config.set_status != OC_NOT_SET) && 
         (RRC_STATE_CELL_FACH == rrc_state) && 
           ((rrcrb_get_proc_sub_state(ordered_config.set_by_proc) != RRCRB_INITIAL) || ( RRCCU_STARTED == rrccu_get_cell_update_started_status()))
           &&  ((TRUE == rrcenhstate_camped_cell_supports_e_fach()) || (TRUE == rrcllc_get_hs_status_in_e_fach(config_ptr ))))
     {
       rrcllc_clear_sib5_change_in_progress_flag();
       /* we will not be able to handle the channel config here as it goes for exception and hence moving UE to IDLE */
       rrc_transition_to_disconnected_state(RRC_PROCEDURE_LLC,
                                            RRC_TX_TO_DISCON_OTHER);
       return rrcllc_next_substate;
     }
#endif
  }

#ifdef FEATURE_WCDMA_HS_FACH 
    /*we are going to ignore the channel config if CU has already has been started*/
    if((cmd_ptr->cmd.chan_config_req.chan_config_reason == RRCLLC_CHAN_CFG_REASON_HS_FACH_COMMON_OPS) &&
      (RRC_STATE_CELL_FACH == rrc_state) && 
      rrcsib_update_sibs_active_for_bcch_mod() &&
      (rrcllc_get_hs_status_in_e_fach(current_config_ptr) != rrcenhstate_camped_cell_supports_e_fach())
       )
      {
        WRRC_MSG1_HIGH("Update SIBs is in progress with HSFACH capability change and CU is triggered go to idle RRC State %d",rrc_state);
        /* we will not be able to handle the channel config here as it goes for exception and hence moving UE to IDLE */
        rrc_transition_to_disconnected_state(RRC_PROCEDURE_LLC,RRC_TX_TO_DISCON_OTHER);
        return rrcllc_next_substate;
      }
#endif


    
  /*If DRX req was posted after PCCH Reconfig due to SIB5 change when PCH 
       to FACH or Disconnected to Connecting transition was in progress, trash the 
       DRX request because now the state is either FACH/Connecting.*/
       
  if((cmd_ptr->cmd.chan_config_req.procedure == RRC_PROCEDURE_CSP) &&
     (cmd_ptr->cmd.chan_config_req.chan_config_reason ==
           RRCLLC_CHAN_CFG_REASON_RECONFIG_PCH_FACH)&&
     ((rrc_state == RRC_STATE_CELL_FACH)||
      (rrc_state == RRC_STATE_CONNECTING))
     )
  {
    if( (llc_stored_cmd_ptr = (rrc_cmd_type *)q_check(&llc_cmd_q)) != NULL )
    {
      if((llc_stored_cmd_ptr->cmd_hdr.cmd_id == RRC_LLC_CMD_REQ)
          && (llc_stored_cmd_ptr->cmd.rrc_llc_req.cmd_dest == LAYER1_PHY)
          &&(llc_stored_cmd_ptr->cmd.rrc_llc_req.l1_cmd.cmd_id == CPHY_DRX_REQ))
      {
        rrc_cmd_type *llc_cmd_ptr;
        if((llc_cmd_ptr = (rrc_cmd_type *) q_get(&llc_cmd_q))!= NULL)
        {
          WRRC_MSG1_HIGH("RRC State is %d. Trash DRX req",rrc_state);
          rrcllc_free_cmd_and_embedded_buf(llc_cmd_ptr);
          llc_cmd_ptr = NULL;
        }
      }
    }
  }

  if((cmd_ptr->cmd.chan_config_req.procedure == RRC_PROCEDURE_SIB) &&
     (cmd_ptr->cmd.chan_config_req.chan_config_reason == RRCLLC_CHAN_CFG_REASON_SIB_READ_IN_DCH) &&
     (cmd_ptr->cmd.chan_config_req.rb[0].rb_id == BCCH_S_RADIO_BEARER_ID) &&
     (cmd_ptr->cmd.chan_config_req.rb[0].rb_config == ESTABLISH_RB) &&
     (ordered_config.set_status != OC_NOT_SET) &&
     (ordered_config.process_state == LL_NOT_CONFIG_WITH_OC) &&
     (config_ptr_in_use == ORDERED_CONFIG))
  {
    if(rrc_sib_is_current_event_sib_read_in_dch() == FALSE)
    {
      /* Send a Failure to the sender */
      (void)rrcllc_send_rrc_channel_config_cnf(cmd_ptr->cmd.chan_config_req.procedure,
                    cmd_ptr->cmd.chan_config_req.transaction_id,
                    RRCLLC_CHAN_CFG_FAILURE_INCOMPATIBLE_STATE);
    }
    else
    {
      rrc_cmd_type   *rrc_out_cmd_ptr;
      
      if((rrc_out_cmd_ptr = rrc_get_int_cmd_buf()) != NULL)
      {  
        rrc_out_cmd_ptr->cmd_hdr.cmd_id = cmd_ptr->cmd_hdr.cmd_id;
        WCDMA_MEMCPY(&rrc_out_cmd_ptr->cmd, 
                     sizeof(rrc_cmd_int_q_u_type),
                     &cmd_ptr->cmd, 
                     sizeof(rrc_cmd_int_q_u_type));
        /* Send the Internal cmd to RRC */
        WRRC_MSG1_HIGH("Re-Post cmd to internal q  cmd id %d ", 
                cmd_ptr->cmd_hdr.cmd_id);
        rrc_put_int_cmd( rrc_out_cmd_ptr );
      }
      else
      {
        ERR_FATAL("Failure to get Int Cmd buf for resel ind", 0, 0, 0);
      }

      MSG_HIGH("Queuing chan_config for PCCPCH setup OC rrcllc_oc_set_status_e_type_value%d status %d procstate proc rrc_proc_e_type_value%d proc",
             ordered_config.set_status, ordered_config.process_state,
             ordered_config.set_by_proc);
    }
  }
  else
  {
    rrcllc_update_generic_cmd_process_data(cmd_ptr);
    if(rrcllc_update_cmd_process_data_for_channel_config(cmd_ptr) == SUCCESS)
    {
      /* This function updates the ciphering information for a reconfiguration for
         UM/AM and TM Radio Bearers.  Only if UM/AM bearers are added success is
         returned.  If SUCCESS is returned by SMC then RLC commands are sent to
         update RLC UM and AM ciphering configuration */
      {
        if (SUCCESS == 
            rrcsmc_update_ciphering_config_info_for_reconfig(&rrcllc_cmd_under_process.chan_config.rlc_config_req_list,
                                                             rrcllc_cmd_under_process.procedure))
        {
          rrcllc_rlc_cipher_update_needed = TRUE;
        }
      }
      if(rrcllc_command_engine(rrcllc_current_substate, &rrcllc_next_substate)
         == FAILURE)
      {
        ERR_FATAL("RRC Config request processing failure", 0, 0, 0);
      }
      
      if(rrcllc_next_substate == LLC_IDLE)
      {
        /* This implies no more lower layer commands are to be sent - Can this happen
         * in LLC_IDLE ?
         */
        /* Send a RRC Config CNF back to the procedure and change RRC state */
        if((rrcllc_cmd_under_process.valid) &&
           (rrcllc_cmd_under_process.rrc_current_cmd_id == RRC_CHANNEL_CONFIG_REQ))
        {
          rrcllc_next_substate = rrcllc_handle_completion_of_chan_config_req();
        } /* if(rrcllc_cmd_under_process.valid)... */
      } /* if(rrcllc_next_substate == LLC_IDLE) */
    } /* If Channel Config Command data updated successfully */
    else
    {
      /* Updating of Channel Config Command data failed */
      /* Send a Channel Config Confirm with a failure to the requesting procedure */
      /*Discard the OC only if it was set by the procedure that has sent current channel config request */
      if(( rrcllc_get_ordered_config_status_wo_f3() != OC_NOT_SET) && (ordered_config.set_by_proc == rrcllc_cmd_under_process.procedure ))
      {
        WRRC_MSG0_HIGH("Discard Oc and set config_ptr_in_use to CURRENT_CONFIG  ");
        rrcllc_discard_oc();
      }
#ifdef FEATURE_WCDMA_HS_RACH
      /*If channel_config_req fails then we need to release the allocated lc ids */
      (void)rrcllc_build_cmd_and_release_lc_ids(); 
#endif

      MSG_MED("Sending RRC_CHANNEL_CONFIG_CNF (Failure)to procedure %d",
              rrcllc_cmd_under_process.procedure, 0, 0);
      if(rrcllc_cmd_under_process.chan_config.cnf_needed)
      {
        (void)rrcllc_send_rrc_channel_config_cnf(rrcllc_cmd_under_process.procedure,
                                                 rrcllc_cmd_under_process.chan_config_transaction_id,
                                                 RRCLLC_CHAN_CFG_FAILURE_OTHER);
      }
    }
  }
  return rrcllc_next_substate;
}

/*===========================================================================

FUNCTION: rrcllc_get_log_chan_action_for_rb_action

DESCRIPTION:
  This  function returns the RLC action based on RB Action

DEPENDENCIES:
  None.

RETURN VALUE:
  RLC Action

SIDE EFFECTS:
  None
===========================================================================*/
rlc_channel_action_e_type rrcllc_get_log_chan_action_for_rb_action
(
  rrc_rb_config_type *rb_config
    , uint16 *ul_cfg_mask,
     uint16 * dl_cfg_mask
)
{
  rlc_channel_action_e_type log_chan_action =RLC_MODIFY ;


  switch(rb_config->rb_config)
  {
    case ESTABLISH_RB:
     log_chan_action = RLC_ESTABLISH;
     break;
    case RELEASE_RB:
     log_chan_action = RLC_RELEASE;
     break;
    case RECONFIG_RB:
     log_chan_action = RLC_MODIFY;
     *ul_cfg_mask = RLC_MODIFY_CFG;
     *dl_cfg_mask = RLC_MODIFY_CFG;
      break;
    case  RECONFIG_RB_OTA:

          log_chan_action  = RLC_MODIFY;
          *ul_cfg_mask = rb_config->ul_cfg_mask;
          *dl_cfg_mask = rb_config->dl_cfg_mask;
     break;

    default:
      WRRC_MSG1_ERROR("In valid rb_config %d",rb_config);
  }
  return log_chan_action;
}

/*===========================================================================

FUNCTION: rrcllc_curr_cmd_rel_all_req

DESCRIPTION:
  This  function returns if the current cmd is CRLC REL all req. 
  In that state L2 ack can be ignored.

DEPENDENCIES:
  None.

RETURN VALUE:
TRUE/FALSE

SIDE EFFECTS:
  None
===========================================================================*/
boolean rrcllc_curr_cmd_rel_all_req
(
  void
)
{
  if(((rrcllc_cmd_under_process.chan_config.current_cmd_engine == LLC_RELEASE_ALL_CHAN_ENGINE)
     ||(rrcllc_cmd_under_process.chan_config.current_cmd_engine == LLC_STOP_WCDMA_MODE_ENGINE)
     ||(rrcllc_cmd_under_process.chan_config.current_cmd_engine == LLC_DEACT_ENGINE))
     && (rrcllc_current_substate != LLC_IDLE))
  {
    WRRC_MSG1_HIGH(" Current engine %d",rrcllc_cmd_under_process.chan_config.current_cmd_engine);
    return TRUE;
  }
  return FALSE;
}

/*===========================================================================
FUNCTION   rrcllc_get_correct_pccpch_tx_diversity_from_sibs

DESCRIPTION
  This function gives the TxDiversity value for the cell for which PCCPCH is setup.

DEPENDENCIES
  None.

RETURN VALUE
 TRUE if TxDiversity is to be enabled
 else FALSE
 Default value is TRUE.
SIDE EFFECTS
  None.
===========================================================================*/
boolean rrcllc_get_correct_pccpch_tx_diversity_from_sibs(rrc_state_e_type next_state)
{
  rrc_SysInfoType5 *sib5_ptr = NULL;
  rrc_SysInfoType6 *sib6_ptr = NULL;
  rrc_plmn_identity_type plmn_id;
  rrc_int_cell_id_type cell_id;

  WRRC_MSG1_HIGH("current_cmd_engine: %d",rrcllc_cmd_under_process.chan_config.
current_cmd_engine);

  if(rrcllc_cmd_under_process.chan_config.current_cmd_engine == 
LLC_CELL_RESELECTION_ENGINE)
  {
    plmn_id = rrcllc_cmd_under_process.rrcllc_cell_resel_info.plmn_id;
    cell_id = rrcllc_cmd_under_process.rrcllc_cell_resel_info.cell_id;
    WRRC_MSG0_HIGH("Getting PLMN & Cell Id during reselection");
  }
  else
  {
    rrccsp_get_current_plmn_cell_id(&plmn_id,&cell_id);
  }

  MSG_HIGH("PLMN: -> MCC %d, MNC %d, Cell ID %d",
                                                 RRC_CSP_GET_INT_MCC(plmn_id),
                                                 RRC_CSP_GET_INT_MNC(plmn_id),
                                                 cell_id);

  /* PLMN and Cell ID of the current camped on cell are known. Get SIB3 */
  sib5_ptr = (rrc_SysInfoType5 *) rrc_sibdb_return_sib_for_cell(
                            rrc_SIB5, 
                            plmn_id, cell_id);
  if( sib5_ptr == NULL )
  {
    WRRC_MSG0_ERROR("SIB5 is not present.");
    return(FALSE);
  }

  /* if sib6 indicator is false or if rrc state is idle, look at sib5*/
  if ((next_state == RRC_STATE_DISCONNECTED) || (next_state == 
RRC_STATE_CONNECTING) ||
      (sib5_ptr->sib6indicator == FALSE) )
  {
    if((RRC_MSG_COMMON_BITMASK_IE_PTR(sib5_ptr,rrc_SysInfoType5,
primaryCCPCH_Info)) &&  
       (RRC_CHECK_COMMON_MSG_TYPE(sib5_ptr->primaryCCPCH_Info, 
rrc_PrimaryCCPCH_Info_fdd)))
    {
      WRRC_MSG1_HIGH("PCCPCH TxDiv is from sib 5 is %d",sib5_ptr->primaryCCPCH_Info.u.fdd->tx_DiversityIndicator);
      if(sib5_ptr->primaryCCPCH_Info.u.fdd->tx_DiversityIndicator)
      {
        return TRUE;
      }
      else
      {
        return FALSE;
      }
    }
    else
    {
      WRRC_MSG0_HIGH("PCCPCH TxDiv is not supported by NW");
      return FALSE;
    }
  }
  else if(sib5_ptr->sib6indicator == TRUE)
  {
    sib6_ptr = (rrc_SysInfoType6 *)rrc_sibdb_return_sib_for_cell(
                              rrc_SIB6, 
                              plmn_id, cell_id);
    if((sib6_ptr!= NULL) && (RRC_MSG_COMMON_BITMASK_IE_PTR(sib6_ptr,
rrc_SysInfoType6,primaryCCPCH_Info)))
    {
      if(RRC_CHECK_COMMON_MSG_TYPE(sib6_ptr->primaryCCPCH_Info, 
rrc_PrimaryCCPCH_Info_fdd))
      {
        WRRC_MSG1_HIGH("Using PCCPCH TxDiv info from sib 6 %d",sib6_ptr->primaryCCPCH_Info.u.fdd->tx_DiversityIndicator);
        if(sib6_ptr->primaryCCPCH_Info.u.fdd->tx_DiversityIndicator)
        {
          return TRUE;
        }
        else
        {
          return FALSE;
        }
      }
      else
      {
        WRRC_MSG0_HIGH("PCCPCH TxDiv is not supported by NW");
        return FALSE;
      }
    }
    else if((RRC_MSG_COMMON_BITMASK_IE_PTR(sib5_ptr,rrc_SysInfoType5,
primaryCCPCH_Info)) &&  
            (RRC_CHECK_COMMON_MSG_TYPE(sib5_ptr->primaryCCPCH_Info, 
rrc_PrimaryCCPCH_Info_fdd)))
    {
      WRRC_MSG1_HIGH("Using PCCPCH TxDiv info from sib 5 %d", sib5_ptr->primaryCCPCH_Info.u.fdd->tx_DiversityIndicator);
      if(sib5_ptr->primaryCCPCH_Info.u.fdd->tx_DiversityIndicator)
      {
        return TRUE;
      }
      else
      {
        return FALSE;
      }
    }
    else
    {
      WRRC_MSG0_HIGH("PCCPCH TxDiv is not supported by NW");
      return FALSE;
    }
  }
  WRRC_MSG0_HIGH("PCCPCH TxDiv is set to FALSE"); 
  return FALSE;
} /* rrcllc_get_pccpch_tx_diversity_from_sibs */

/*===========================================================================

FUNCTION: rrcllc_get_new_ul_size_info

DESCRIPTION:
  This  function gets the new rlc info 

DEPENDENCIES:
  None.

RETURN VALUE:
  RLC reestablish action

SIDE EFFECTS:
  None
===========================================================================*/
static uecomdef_status_e_type rrcllc_get_new_ul_size_info
(
  uint8 rb_id,
  ul_rlc_size_info *new_ul_rlc_info
)
{
  rlc_ul_flexi_size_info_type oc_rlc_flexi_ul_size;
  uint32 new_ul_fixed_size = RRCLLC_INVALID_RLC_SIZE;
  ordered_config_type  *config_ptr;
  
  if(config_ptr_in_use == ORDERED_CONFIG)
  {
    config_ptr = ordered_config_ptr;
  }
  else
  {
    config_ptr = current_config_ptr;
  }
  
  WRRC_MSG1_MED("ULREESTABLISHMENT: Config ptr in use: %d [0=OC,1=CC]", config_ptr_in_use);
  /* New RLC size change needs to be known only if new state is FACH or DCH or 
  when going to PCH and hspa_rnti_stored_cel_pch must be true  
  No other use case to do rlc reestablishment in UL side*/
  if((rrcllc_cmd_under_process.next_rrc_state== RRC_STATE_CELL_DCH) ||
     (rrcllc_cmd_under_process.next_rrc_state== RRC_STATE_CELL_FACH)   
#ifdef FEATURE_WCDMA_HS_RACH
    ||
    (
     (rrcllc_cmd_under_process.next_rrc_state== RRC_STATE_CELL_PCH) && (config_ptr->hspa_rnti_stored_cell_pch == TRUE)
    )
#endif
    )
  {
#ifdef FEATURE_WCDMA_HS_RACH
    /*Update the mappings in config_ptr if hspa_rnti_stored_cell_pch is TRUE to get the new size */
    if((rrcllc_cmd_under_process.next_rrc_state== RRC_STATE_CELL_PCH) && (config_ptr->hspa_rnti_stored_cell_pch == TRUE))
    {
      if(rrchsrach_camped_cell_supports_hsrach())
      {
        WRRC_MSG0_HIGH("ULREESTABLISHMENT: Updating HSRACH mappings into config_ptr ");
        /*Update mappings into OC because config DCCH DTCH function always looks into OC*/
        if(rrcllc_update_hs_rach_params(ordered_config_ptr) == FAILURE)
        {
          WRRC_MSG0_HIGH("ULREESTABLISHMENT: Updation of HSRACH mappings  into ordered_config_ptr failed ");
          return FAILURE;
        }

        if(rrcllc_update_hs_rach_params(config_ptr) == FAILURE)
        {
          WRRC_MSG0_HIGH("ULREESTABLISHMENT: Updation of HSRACH mappings  into config_ptr failed ");
          return FAILURE;
        }
               
      }
    }
#endif

    if (rrcllc_check_edch_flexible_ul_size_configured(config_ptr,rb_id))
    {
      rrcllc_get_edch_ul_rlc_flexible_params(config_ptr,rb_id,&oc_rlc_flexi_ul_size);
      new_ul_rlc_info->ul_rlc_pdu_type = RLC_FLEXIBLE_PDU_SIZE;
      new_ul_rlc_info->ul_flex_li_size = oc_rlc_flexi_ul_size.rrc_ul_li_size;
      WRRC_MSG2_HIGH("ULREESTABLISHMENT: RB ID %d has Flexible size and UL LI size %d[0=LI7,1=LI15]",rb_id,oc_rlc_flexi_ul_size.rrc_ul_li_size);
    }
    else
    {
      new_ul_fixed_size = rrcllc_get_ul_ded_rlc_size(rrcllc_cmd_under_process.next_rrc_state,rb_id);
      new_ul_rlc_info->ul_rlc_pdu_type = RLC_FIXED_PDU_SIZE;
      new_ul_rlc_info->ul_fixed_rlc_size = new_ul_fixed_size;
      WRRC_MSG2_HIGH("ULREESTABLISHMENT: RB ID %d has Fixed size and UL Fixed size %d ",rb_id,new_ul_fixed_size);
    }
    
  }
  else 
  {
    WRRC_MSG0_ERROR("ULREESTABLISHMENT: No use case to reach here ");
    return FAILURE;
  }

  return SUCCESS;

}
/*===========================================================================

FUNCTION: rrcllc_set_hspa_rnti_false_if_needed

DESCRIPTION:
  This  function sets HSPA RNTI to false if UL size alone changes

DEPENDENCIES:
  None.

RETURN VALUE:
Returns True if HSPA RNTI is set to true. Returns false if HSPA RNTI is made false

SIDE EFFECTS:
  None
===========================================================================*/
static boolean rrcllc_set_hspa_rnti_false_if_needed
(boolean is_ul_reestablished, uint8 rb_id)
{
  uint8 am_entity_idx = 0;
  ordered_config_type *config_ptr;

  if(config_ptr_in_use == ORDERED_CONFIG)
  {
    config_ptr = ordered_config_ptr;
  }
  else
  {
    config_ptr = current_config_ptr;
  }

  am_entity_idx = get_am_index_in_config_ptr(rb_id,config_ptr);

  if(UE_MAX_AM_ENTITY == am_entity_idx)
  {
    WRRC_MSG1_ERROR("ULREESTABLISHMENT: Couldnt find the AM entity in config_ptr for rb id %d",rb_id);
    return FALSE;
  }

  if(config_ptr->am_config[am_entity_idx].reestab_entity == RLC_RE_ESTABLISH_NONE)
  {
   /* For PCH transition if HSPA RNTI is TRUE and UL needs re-establishment make HSPA RNTI to FALSE
      so that CU is triggered to facilitate inclusion of start value. Re-establish only after CUC is received */  
    MSG_HIGH("ULREESTABLISHMENT: hspa_rnti_stored_cell_pch:%d,is_ul_reestablished:%d, ul_reestab_for_pch_trans:%d",
    config_ptr->hspa_rnti_stored_cell_pch,is_ul_reestablished,ul_reestab_for_pch_trans);
    if ((TRUE == config_ptr->hspa_rnti_stored_cell_pch) && (TRUE == is_ul_reestablished) && 
        (FALSE == ul_reestab_for_pch_trans))
    {
      WRRC_MSG0_HIGH("Set hspa_rnti_stored_cell_pch to FALSE");
      ordered_config_ptr->hspa_rnti_stored_cell_pch = FALSE; 
      current_config_ptr->hspa_rnti_stored_cell_pch = FALSE; 
      transition_config.toc_ptr->hspa_rnti_stored_cell_pch = FALSE;
      return FALSE;
    }            
  }
  return TRUE;
}
  
/*===========================================================================

FUNCTION: rrcllc_check_if_rb_needs_to_be_reestablished

DESCRIPTION:
  This  function checks if a particular RB needs to be reestablished

DEPENDENCIES:
  None.

RETURN VALUE:
  RLC reestablish action

SIDE EFFECTS:
  None
===========================================================================*/
static boolean rrcllc_check_if_rb_needs_to_be_reestablished
(
  uint8 rb_id
)
{
ul_rlc_size_info new_ul_rlc_info;
uint8 old_idx = MAX_NO_USER_RB;
boolean reestablish_needed = FALSE;
  uecomdef_status_e_type        rv = FAILURE;
  
  /*Get old size */
  RRC_GET_OLD_BACKUP_SIZE_INDEX(rb_id,old_idx);

  if(FAILURE == rv)
  {
    WRRC_MSG1_ERROR("ULREESTABLISHMENT: Unable to get the old size for RB ID %d",rb_id);
    return FALSE;  
  }
  
   
  if(FAILURE == rrcllc_get_new_ul_size_info(rb_id,&new_ul_rlc_info))
  {
    WRRC_MSG1_ERROR("ULREESTABLISHMENT: Unable to get the new size for RB ID %d",rb_id);
    return FALSE;
  }
  

  /*Old size is flexible */
  if(RLC_FLEXIBLE_PDU_SIZE == rrc_old_ul_rlc_size_backup[old_idx].ul_rlc_pdu_type)
  {
    /*Old size is flexible and new size is also flexible*/
    if(RLC_FLEXIBLE_PDU_SIZE == new_ul_rlc_info.ul_rlc_pdu_type)
    {
      if((rrc_old_ul_rlc_size_backup[old_idx].ul_flex_li_size!=LI_UNSPECIFIED) &&(new_ul_rlc_info.ul_flex_li_size!=LI_UNSPECIFIED) &&
        (new_ul_rlc_info.ul_flex_li_size!=rrc_old_ul_rlc_size_backup[old_idx].ul_flex_li_size))
      {
        reestablish_needed = TRUE;
        MSG_HIGH("ULREESTABLISHMENT: Flexible %d [0=LI7,1=LI15] to Flexible %d [0=LI7,1=LI15] size change for RB ID %d",
          rrc_old_ul_rlc_size_backup[old_idx].ul_flex_li_size,new_ul_rlc_info.ul_flex_li_size,rb_id);
      }
      else
      {
        MSG_HIGH("ULREESTABLISHMENT: No reestablishment Flexible %d [0=LI7,1=LI15] to Flexible %d [0=LI7,1=LI15] for RB ID %d",
          rrc_old_ul_rlc_size_backup[old_idx].ul_flex_li_size,new_ul_rlc_info.ul_flex_li_size,rb_id);
      }
    }
    /*Old size is flexible and new size is fixed*/
    else if (RLC_FIXED_PDU_SIZE == new_ul_rlc_info.ul_rlc_pdu_type)
    {
      reestablish_needed = TRUE;
      MSG_HIGH("ULREESTABLISHMENT: Flexible LI %d [0=LI7,1=LI15] to Fixed %d size change for RB ID %d",
        rrc_old_ul_rlc_size_backup[old_idx].ul_flex_li_size,new_ul_rlc_info.ul_fixed_rlc_size,rb_id);
    }
    else
    {
      MSG_ERROR("ULREESTABLISHMENT: Flexible LI %d [0=LI7,1=LI15] to unknown new pdu size %d for RB ID %d",
          rrc_old_ul_rlc_size_backup[old_idx].ul_flex_li_size,new_ul_rlc_info.ul_rlc_pdu_type,rb_id);
    }
  }
  /*Old size is fixed*/
  else if (RLC_FIXED_PDU_SIZE == rrc_old_ul_rlc_size_backup[old_idx].ul_rlc_pdu_type)
  {
    /*Old size is fixed and new size is flexible*/
    if(RLC_FLEXIBLE_PDU_SIZE == new_ul_rlc_info.ul_rlc_pdu_type)
    {
      if(LI_15_BITS == new_ul_rlc_info.ul_flex_li_size)
      {
        reestablish_needed = TRUE;
        MSG_HIGH("ULREESTABLISHMENT: Fixed %d to Flexible LI %d [0=LI7,1=LI15] size change for RB ID %d",
          rrc_old_ul_rlc_size_backup[old_idx].ul_fixed_rlc_size,new_ul_rlc_info.ul_flex_li_size,rb_id);
      }
      else
      {
        MSG_HIGH("ULREESTABLISHMENT: No reestablishment Fixed %d  to Flexible LI %d [0=LI7,1=LI15] for RB ID %d",
          rrc_old_ul_rlc_size_backup[old_idx].ul_fixed_rlc_size,new_ul_rlc_info.ul_flex_li_size,rb_id);
      }
    }
    /*Old size is fixed and new size is also fixed*/
    else if (RLC_FIXED_PDU_SIZE == new_ul_rlc_info.ul_rlc_pdu_type)
    {
      if(( RRCLLC_INVALID_RLC_SIZE != new_ul_rlc_info.ul_fixed_rlc_size) &&( RRCLLC_INVALID_RLC_SIZE != rrc_old_ul_rlc_size_backup[old_idx].ul_fixed_rlc_size) 
        && (new_ul_rlc_info.ul_fixed_rlc_size != rrc_old_ul_rlc_size_backup[old_idx].ul_fixed_rlc_size))
      {
        reestablish_needed = TRUE;
        MSG_HIGH("ULREESTABLISHMENT: Fixed %d to Fixed %d size change for RB ID %d",
          rrc_old_ul_rlc_size_backup[old_idx].ul_fixed_rlc_size,new_ul_rlc_info.ul_fixed_rlc_size,rb_id);
      }
      else
      {
        MSG_HIGH("ULREESTABLISHMENT: No reestablishment Fixed%d  to Fixed %d for RB ID %d",
          rrc_old_ul_rlc_size_backup[old_idx].ul_fixed_rlc_size,new_ul_rlc_info.ul_fixed_rlc_size,rb_id);
      }
    }
    else
    {
      MSG_ERROR("ULREESTABLISHMENT: Fixed %d to unknown new pdu size %d for RB ID %d",
        rrc_old_ul_rlc_size_backup[old_idx].ul_fixed_rlc_size,new_ul_rlc_info.ul_rlc_pdu_type,rb_id);
    }
  }
  else
  {
    WRRC_MSG1_HIGH("ULREESTABLISHMENT: Unknown Old PDU size %d ",rrc_old_ul_rlc_size_backup[old_idx].ul_rlc_pdu_type);
  }

WRRC_MSG2_MED("ULREESTABLISHMENT: is ul reestablishment needed %d for rb id %d",reestablish_needed,rb_id);
return reestablish_needed;

}

/*===========================================================================

FUNCTION: rrcllc_add_rb_to_chan_config_req

DESCRIPTION:
  This  function gets the new rlc info 

DEPENDENCIES:
  None.

RETURN VALUE:
  RLC reestablish action

SIDE EFFECTS:
  None
===========================================================================*/
static uecomdef_status_e_type rrcllc_add_rb_to_chan_config_req
(
  rrc_channel_config_req_type * chan_config_req,
  uint8 rb_id
)
{
  uint8 num_rb = 0;
      
  if(chan_config_req->num_rb_to_config < (MAX_RB -1))
  {
    num_rb = chan_config_req->num_rb_to_config;
    chan_config_req->rb[num_rb].rb_id = rb_id;
    chan_config_req->rb[num_rb++].rb_config = RECONFIG_RB;
    chan_config_req->num_rb_to_config =num_rb;
    WRRC_MSG2_HIGH("ULREESTABLISHMENT: Added RB ID %d to channel config request num_rb %d",rb_id,num_rb);
    return SUCCESS;
  }
  else
  {
    WRRC_MSG1_HIGH("ULREESTABLISHMENT: RB ID %d couldnt be added because no space in channel config request",rb_id);
    return FAILURE;
  }

}

/*===========================================================================

FUNCTION: rrcllc_set_reestablish_entity_for_ul

DESCRIPTION:
  This  function gets the new rlc info 

DEPENDENCIES:
  None.

RETURN VALUE:
  RLC reestablish action

SIDE EFFECTS:
  None
===========================================================================*/
uecomdef_status_e_type rrcllc_set_reestablish_entity_for_ul
(
  uint8 rb_id,
  boolean is_ul_reestab_required
)
{
  uint8 am_entity_idx = 0,old_idx;
  uecomdef_status_e_type        rv = FAILURE;
  
  am_entity_idx = get_am_index_in_config_ptr(rb_id,ordered_config_ptr);

  if(UE_MAX_AM_ENTITY == am_entity_idx)
  {
    WRRC_MSG1_ERROR("ULREESTABLISHMENT: Couldnt find the AM entity in config_ptr for rb id %d",rb_id);
    return FAILURE;
  }

  RRC_GET_OLD_BACKUP_SIZE_INDEX(rb_id,old_idx);

  if(FAILURE == rv)
  {
    WRRC_MSG0_HIGH("ULREESTABLISHMENT: Unable to get index in Old database");
    return FAILURE;
  }

  WRRC_MSG2_HIGH("ULREESTABLISHMENT: Old Reestablish entity %d [0=DL/UL,1=DL,2=UL,3=None] set by legacy code : rlc_one_sided_reest %d",
    ordered_config_ptr->am_config[am_entity_idx].reestab_entity,ordered_config_ptr->rlc_one_sided_reest[am_entity_idx]); 

  if(is_ul_reestab_required)
  {
    if((ordered_config_ptr->am_config[am_entity_idx].reestab_entity == RLC_RE_ESTABLISH_NONE) ||
      (ordered_config_ptr->am_config[am_entity_idx].reestab_entity == RLC_RE_ESTABLISH_DL))
    {

       if(ordered_config_ptr->rlc_one_sided_reest[am_entity_idx])
       {
        if(ordered_config_ptr->am_config[am_entity_idx].reestab_entity == RLC_RE_ESTABLISH_DL)
        {
           ordered_config_ptr->am_config[am_entity_idx].reestab_entity = RLC_RE_ESTABLISH_DL_UL;
        }
        else
        {
           ordered_config_ptr->am_config[am_entity_idx].reestab_entity = RLC_RE_ESTABLISH_UL;
        }
       }
       else
       {
         ordered_config_ptr->am_config[am_entity_idx].reestab_entity = RLC_RE_ESTABLISH_DL_UL;
       }
   
    } 
    else if (ordered_config_ptr->am_config[am_entity_idx].reestab_entity == RLC_RE_ESTABLISH_UL)
    {
      WRRC_MSG0_HIGH("ULREESTABLISHMENT: UL reestab_entity already set");
    }
  }

  WRRC_MSG1_HIGH("ULREESTABLISHMENT: New code set the Reestablish entity to %d [0=DL/UL,1=DL,2=UL,3=None]",ordered_config_ptr->am_config[am_entity_idx].reestab_entity);
  
return SUCCESS;
}

/*===========================================================================

FUNCTION: rrcllc_check_if_fixed_to_flexible_li7_ul_size_change

DESCRIPTION:
  This  function checks if fixed to flexible LI 7 size change happened for a particular RB 

DEPENDENCIES:
  None.

RETURN VALUE:
None

SIDE EFFECTS:
  None
===========================================================================*/
static boolean rrcllc_check_if_fixed_to_flexible_li7_ul_size_change
(
  rb_id_type  rb_id,
  rlc_ul_am_config_type rlc_ul_am_config
)
{
  uint8 old_idx = MAX_NO_USER_RB;
  uecomdef_status_e_type        rv = FAILURE;
    rrcllc_oc_set_status_e_type oc_status;
  rrc_proc_e_type                 proc_id;
  rrcllc_oc_process_state_e_type  process_state;
  
  RRC_GET_OLD_BACKUP_SIZE_INDEX(rb_id,old_idx);

   if(FAILURE == rv)
  {
    WRRC_MSG1_ERROR("ULREESTABLISHMENT: OLD size not found for RB ID %d",rb_id);
    return FALSE;
  }

  oc_status = rrcllc_get_ordered_config_state_and_proc_wo_f3(&proc_id, &process_state);  
   /* Avoid taking backup if  reconfig procedures involves CU, we should detect size change only after CU confirm.*/ 
  if((oc_status!=OC_NOT_SET) && (rrcrb_is_cu_required()))
  {
     WRRC_MSG2_ERROR("ULREESTABLISHMENT: OC %d is set by Procedure id %d and CU is going to be triggered by procedure",
        oc_status,proc_id);
      return FALSE;
  }
   
  if((rrc_old_ul_rlc_size_backup[old_idx].ul_rlc_pdu_type == RLC_FIXED_PDU_SIZE) && 
    ((rlc_ul_am_config.ul_flex_pdu_size == RLC_FLEXIBLE_PDU_SIZE) && (rlc_ul_am_config.ul_li_size == LI_7_BITS)))
  {
    WRRC_MSG1_ERROR("ULREESTABLISHMENT: Fixed to Flexible LI7 size change detected for RB ID %d",rb_id);
    return TRUE;
  }

  WRRC_MSG1_ERROR("ULREESTABLISHMENT: Fixed to Flexible LI7 size not changed for RB ID %d",rb_id);
  return FALSE;
}

/*===========================================================================

FUNCTION: rrcllc_backup_old_ul_rlc_size

DESCRIPTION:
  This  function returns the first empty index in the backup ul RLC size.
  This also checks if the RB ID already exists in the backup already.
  this also stores the old rlc size.

DEPENDENCIES:
  None.

RETURN VALUE:
None

SIDE EFFECTS:
  None
===========================================================================*/
static void rrcllc_backup_old_ul_rlc_size
(
  rb_id_type  rb_id,
  rlc_ul_am_config_type rlc_ul_am_config
)
{
  uint8 new_index;
  uecomdef_status_e_type        rv = FAILURE;
  
  RRC_GET_OLD_BACKUP_SIZE_INDEX(rb_id,new_index);

   if(FAILURE == rv)
  {
    WRRC_MSG1_ERROR("ULREESTABLISHMENT: Could not backup the size for RB ID %d",rb_id);
    return;
  }
   
  rrc_old_ul_rlc_size_backup[new_index].ul_rlc_pdu_type = rlc_ul_am_config.ul_flex_pdu_size;
  rrc_old_ul_rlc_size_backup[new_index].ul_fixed_rlc_size = rlc_ul_am_config.ul_rlc_size;
  rrc_old_ul_rlc_size_backup[new_index].ul_flex_li_size = rlc_ul_am_config.ul_li_size;
    
  MSG_5(MSG_SSID_DFLT, MSG_LEGACY_HIGH,"ULREESTABLISHMENT: New index %d for RB ID %d Backed up parms UL PDU Type %d [0=Fixed,1=Flex] ul_rlc_size %d ul_li_size %d[0=LI7,1=LI15, 2=Same_as_before,3=Unspecified] ",
               new_index,rb_id,rrc_old_ul_rlc_size_backup[new_index].ul_rlc_pdu_type,rrc_old_ul_rlc_size_backup[new_index].ul_fixed_rlc_size,
               rrc_old_ul_rlc_size_backup[new_index].ul_flex_li_size);

}

/*===========================================================================

FUNCTION: rrcllc_init_old_ul_rlc_size_backup

DESCRIPTION:
  This  function clears the old stored size for all entries 

DEPENDENCIES:
  None.

RETURN VALUE:
None

SIDE EFFECTS:
  None
===========================================================================*/
 void rrcllc_init_old_ul_rlc_size_backup(void)
{
  uint8 ix = MAX_NO_USER_RB;

  WRRC_MSG0_HIGH("ULREESTABLISHMENT: Initing the back up ul size rrcllc_init_old_ul_rlc_size ");
      
  for(ix=0;ix < MAX_NO_USER_RB;ix++)
  {
    rrc_old_ul_rlc_size_backup[ix].ul_rlc_pdu_type = RLC_INVALID_PDU_SIZE;
    rrc_old_ul_rlc_size_backup[ix].ul_fixed_rlc_size = RRCLLC_INVALID_RLC_SIZE;
    rrc_old_ul_rlc_size_backup[ix].ul_flex_li_size = LI_UNSPECIFIED;
  }
  last_active_cell_capability = RRC_CELL_CAP_INACTIVE;
}


/*===========================================================================

FUNCTION: rrcllc_check_and_take_backup_rlc_parms

DESCRIPTION:
  This  function checks and takes back up of old UL RLC size parameters

DEPENDENCIES:
  None.

RETURN VALUE:
None

SIDE EFFECTS:
  None
===========================================================================*/
void rrcllc_check_and_take_backup_rlc_parms
(
  void
)
{
  uint8 am_entity_idx_new=0;
  ordered_config_type *config_ptr;
  rlc_am_config_req_type *am_config = &rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am;
  rb_id_type  rb_id = 0;
      
  if(config_ptr_in_use == ORDERED_CONFIG)
  {
    config_ptr = ordered_config_ptr;
  }
  else
  {
    config_ptr = current_config_ptr;
  }

    /*Dont take backup of old ul size only if the procedure is not one of the below*/
  if((rrcllc_cmd_under_process.procedure !=RRC_PROCEDURE_RBE ) &&
    (rrcllc_cmd_under_process.procedure !=RRC_PROCEDURE_RBRC ) &&
    (rrcllc_cmd_under_process.procedure !=RRC_PROCEDURE_RBR ) &&
    (rrcllc_cmd_under_process.procedure !=RRC_PROCEDURE_TCR ) &&
    (rrcllc_cmd_under_process.procedure !=RRC_PROCEDURE_PCR ) &&
    (rrcllc_cmd_under_process.procedure !=RRC_PROCEDURE_CU ) &&
    (rrcllc_cmd_under_process.procedure !=RRC_PROCEDURE_IHO ))
    {
      WRRC_MSG1_MED("ULREESTABLISHMENT: Procedure id %d so skipping backing up the size"
        ,rrcllc_cmd_under_process.procedure);
      return;
    }

  /*Dont take backup of old ul size only if the dest state is PCH and hspa_rnti_stored_cell_pch is FALSE*/
   if (((rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_PCH ) 
#ifdef FEATURE_WCDMA_HS_RACH
      && (config_ptr->hspa_rnti_stored_cell_pch == FALSE)
#endif
      ) ||(rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_URA_PCH ))
  {
    WRRC_MSG1_HIGH("ULREESTABLISHMENT: Next state is %d and hspa_rnti_stored_cell_pch false so skipping backing up the size"
      ,rrcllc_cmd_under_process.next_rrc_state);
    return;
  }


  for(am_entity_idx_new=0; am_entity_idx_new<am_config->nentity; am_entity_idx_new++)
  {

    WRRC_MSG3_MED("rb_id %d RLC action %d [0=EST,1=REL,2=MOD] am_config->am_info[am_entity_idx_new]->ul_nchan %d"
        ,am_config->am_info[am_entity_idx_new]->common_config.rb_id,am_config->am_act[am_entity_idx_new].action,am_config->am_info[am_entity_idx_new]->ul_nchan);

    if((am_config->nentity < UE_MAX_AM_ENTITY) &&
       ( am_config->am_info[am_entity_idx_new]->common_config.rb_id > DCCH_DT_LOW_PRI_RADIO_BEARER_ID ) &&
       (am_config->am_info[am_entity_idx_new]->ul_nchan && am_config->am_info[am_entity_idx_new]->dl_nchan)
    /*For RB release ul_nchan is 0 so moving it inside*/
      )
    {

      rb_id = am_config->am_info[am_entity_idx_new]->common_config.rb_id;
   
        /*Take backup  if "rlc action is RLC_ESTABLISH" or 
        "if rlc action is RLC_MODIFY and reestab_entity is either RLC_RE_ESTABLISH_UL or RLC_RE_ESTABLISH_DL_UL" or
        "if rlc action is RLC_MODIFY and there is size change from fixed to flexible li7" */
      if(((am_config->am_act[am_entity_idx_new].action == RLC_ESTABLISH) ||
            ((am_config->am_act[am_entity_idx_new].action == RLC_MODIFY) && 
             ((am_config->am_info[am_entity_idx_new]->reestab_entity == RLC_RE_ESTABLISH_UL) || 
               (am_config->am_info[am_entity_idx_new]->reestab_entity == RLC_RE_ESTABLISH_DL_UL) ||             
               (rrcllc_check_if_fixed_to_flexible_li7_ul_size_change(rb_id,am_config->am_info[am_entity_idx_new]->rlc_ul_am_config) == TRUE)
              )
             )))

      {
         rrcllc_backup_old_ul_rlc_size(rb_id,am_config->am_info[am_entity_idx_new]->rlc_ul_am_config);
      }
      else if(am_config->am_act[am_entity_idx_new].action == RLC_RELEASE)
      {
         rrcllc_clear_old_ul_rlc_size(rb_id);
      }
    }
  } /* for (all nentities in OC) */

}


/*===========================================================================

FUNCTION: rrcllc_check_and_reestablish_ul_side

DESCRIPTION:
  This  function checks if conditions are satisfied for reestablishing and then
  sets the reestablish entity. It also adds the RB to channel config request if the rb is
  not part of channel config request 

DEPENDENCIES:
  None.

RETURN VALUE:
None

SIDE EFFECTS:
  None
===========================================================================*/
void rrcllc_check_and_reestablish_ul_side
(
  rrc_cmd_type *cmd_ptr
)
{

  ordered_config_type *config_ptr;
  uint32 rab_count,rb_count;
  uint8 rb_id,rb_index=0;		
  uint16 ul_cfg_mask = 0,dl_cfg_mask = 0;
  boolean is_ul_reestab_required[MAX_RB] = {FALSE};
  rrcllc_oc_set_status_e_type oc_status;
  boolean add_rb_to_chan_conf[MAX_RB] = {FALSE};
  
  if(config_ptr_in_use == ORDERED_CONFIG)
  {
    config_ptr = ordered_config_ptr;
  }
  else
  {
    config_ptr = current_config_ptr;
  }

  oc_status = rrcllc_get_ordered_config_status_wo_f3();

  /* Skip the size change checks if Procedure is not one of the below and for CU next state is not fach*/
  if(((rrcllc_cmd_under_process.procedure !=RRC_PROCEDURE_RBE ) &&
    (rrcllc_cmd_under_process.procedure !=RRC_PROCEDURE_RBRC ) &&
    (rrcllc_cmd_under_process.procedure !=RRC_PROCEDURE_RBR ) &&
    (rrcllc_cmd_under_process.procedure !=RRC_PROCEDURE_TCR ) &&
    (rrcllc_cmd_under_process.procedure !=RRC_PROCEDURE_PCR ))
    &&
    /*RL failure scenario we will block size change detection*/
    (rrcllc_cmd_under_process.procedure !=RRC_PROCEDURE_CU || rrcllc_cmd_under_process.next_rrc_state ==RRC_STATE_CELL_FACH))
    {
      WRRC_MSG2_MED("ULREESTABLISHMENT: SKIP ULREEST Procedure id %d so skip checking the size change checks next state %d"
        ,rrcllc_cmd_under_process.procedure,rrcllc_cmd_under_process.next_rrc_state);
      return;
    }

  
  /* Dont do size change checks if next state is PCH and hapa_rnti_stored_cell_pch is false*/
    if (((rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_CELL_PCH )
#ifdef FEATURE_WCDMA_HS_RACH
  && (config_ptr->hspa_rnti_stored_cell_pch == FALSE)
#endif
  ) || (rrcllc_cmd_under_process.next_rrc_state == RRC_STATE_URA_PCH ))
  {
    WRRC_MSG1_HIGH("ULREESTABLISHMENT: SKIP ULREEST Next state is %d and hspa_rnti_stored_cell_pch is FALSE so skipping backing up the size"
      ,rrcllc_cmd_under_process.next_rrc_state);
    return;
  }
  /* If  a reconfig procedures involve CU, we should detect size change only after CU confirm  */ 
  if((oc_status!=OC_NOT_SET) && (rrcrb_is_cu_required()))
  {
     WRRC_MSG1_HIGH("ULREESTABLISHMENT: SKIP ULREEST OC %d is set by Procedure id %d and CU is going to be triggered by procedure",
        oc_status);
      return;
  }


  /* Check whether this RB exists in established_rab db */
  for (rab_count=0; rab_count<MAX_RAB_TO_SETUP; rab_count++)
  {
    if ((rrc_est_rabs.rabs[rab_count].cn_domain == RRC_PS_DOMAIN_CN_ID) &&
          ((rrc_est_rabs.rabs[rab_count].num_rbs_for_rab > 0) &&
          (rrc_est_rabs.rabs[rab_count].rab_id !=  RRC_INVALID_RAB_ID)))
    {
      for (rb_count=0; rb_count<rrc_est_rabs.rabs[rab_count].num_rbs_for_rab; rb_count++)
      {
        rb_id = rrc_est_rabs.rabs[rab_count].rb_for_rab[rb_count].rb_id;

        rb_index = rrcllc_check_if_rbid_present_in_chan_config_within_index (&cmd_ptr->cmd.chan_config_req,rb_id,cmd_ptr->cmd.chan_config_req.num_rb_to_config);

        WRRC_MSG2_MED("ULREESTABLISHMENT: RB index %d for rb id %d",rb_index,rb_id);
              
        /*Do size change checks if the RB is present in est_rabs but not present in the channel config request */
        if((rb_index <= MAX_RB) && (rb_id > DCCH_DT_LOW_PRI_RADIO_BEARER_ID) && (rb_id <= MAX_RB))
        {
          if(MAX_RB == rb_index)
          {
            is_ul_reestab_required[rb_id-1] = rrcllc_check_if_rb_needs_to_be_reestablished(rb_id);
            add_rb_to_chan_conf[rb_id-1] = is_ul_reestab_required[rb_id-1];
          }
          /*Do size change checks if the RB is action is modify only */
          else if(RLC_MODIFY == rrcllc_get_log_chan_action_for_rb_action(&cmd_ptr->cmd.chan_config_req.rb[rb_index],&ul_cfg_mask ,&dl_cfg_mask))
          {
            is_ul_reestab_required[rb_id-1] = rrcllc_check_if_rb_needs_to_be_reestablished(rb_id);
          }
          else
          {
            WRRC_MSG1_HIGH("ULREESTABLISHMENT: Size change checks not done for rb id %d",rb_id);
          }
  
          /* Make HSPA RNTI false if UL size changes for PCH state transition so that start value is sent
             to n/w in CU. If CUC takes UE to PCH, we need not reset HSPA RNTI flag as start is already included
             in CU.
          */
          if((RRC_STATE_CELL_PCH == rrcllc_cmd_under_process.next_rrc_state) &&
             (rrcllc_cmd_under_process.procedure != RRC_PROCEDURE_CU) &&
             (FALSE == rrcllc_set_hspa_rnti_false_if_needed(is_ul_reestab_required[rb_id-1],rb_id))) 
          {
            WRRC_MSG0_HIGH("ULREESTABLISHMENT:hspa_rnti_stored_cell_pch is False. Do not re-establish UL");
            return;
          }
        }
      }
    } /*end of if*/
  }/* rab_count loop */

  /* Set the re-establish entity in config_ptr */
  for(rb_id = (DCCH_DT_LOW_PRI_RADIO_BEARER_ID + 1);rb_id <= MAX_RB;rb_id++)
  {
    if(is_ul_reestab_required[rb_id-1])
    {
      if(add_rb_to_chan_conf[rb_id-1])
      {
        rrcllc_add_rb_to_chan_config_req(&cmd_ptr->cmd.chan_config_req,rb_id);
      }
      rrcllc_set_reestablish_entity_for_ul(rb_id,is_ul_reestab_required[rb_id-1]);
    }
    
  }

}

/*====================================================================
FUNCTION: rrcllc_store_last_active_cell_capability()

DESCRIPTION:
  This function stores the capability of the old cell

DEPENDENCIES:
  None.

RETURN VALUE:
  TRUE: RLC Re-establishment needs to be done.
  FALSE: Otherwise

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_store_last_active_cell_capability()
{

  if(RRC_CELL_CAP_INACTIVE == last_active_cell_capability)
  {
    /* Do not update cell_capability if rl failure or rlc unrecoverable error happened. If oos/cell-reselection happens after rlfailure or 
           unrecoverable error, cell capability of last active cell should not be updated  */
    if(rrc_check_cu_started_with_cause_rlfailure_rlc_unrecoverable_error())
    {
      WRRC_MSG0_HIGH("ULREESTABLISHMENT: CU started,skip saving last active cell capability");
    }
    else if(rrchsrach_get_previous_cell_supports_hsrach())
    {
      last_active_cell_capability = RRC_CELL_CAP_HSRACH;
    }   
    else
    {
      last_active_cell_capability = RRC_CELL_CAP_LEGACY;
    }
    WRRC_MSG1_HIGH("ULREESTABLISHMENT: Storing the old cell cpability as % d[1=R99,2=HSFACH,3=HSRACH]",last_active_cell_capability); 
  }
}

/*====================================================================
FUNCTION: rrcllc_get_old_cell_capability()

DESCRIPTION:
  This function gets the the capability of the old cell

DEPENDENCIES:
  None.

RETURN VALUE:
rrc_cell_capability_type

SIDE EFFECTS:
  None.
====================================================================*/
rrc_cell_capability_type rrcllc_get_old_cell_capability()
{

  return last_active_cell_capability;

}
/*====================================================================
FUNCTION: rrcllc_check_if_hsrach_to_legacy_cell_change_happened()

DESCRIPTION:
  This function checks if hsrach to legacy cell change happened or not
DEPENDENCIES:
  None.

RETURN VALUE:
rrc_cell_capability_type

SIDE EFFECTS:
  None.
====================================================================*/
boolean rrcllc_check_if_hsrach_to_legacy_cell_change_happened()
{

  rrc_CellUpdateCause       cu_cause;
  
  if(RRC_CELL_CAP_INACTIVE == last_active_cell_capability)
  {
    WRRC_MSG1_HIGH("ULREESTABLISHMENT: OLD cell capability %d not stored yet ",last_active_cell_capability); 
    return FALSE;
  }


  WRRC_MSG2_HIGH("ULREESTABLISHMENT: old cell capability %d [1=R99,2=HSFACH,3=HSRACH] Next state %d ",
    last_active_cell_capability,rrcllc_cmd_under_process.next_rrc_state); 

  if((RRC_CELL_CAP_HSRACH == last_active_cell_capability) &&
    (FALSE == rrchsrach_camped_cell_supports_hsrach()) && 
    (rrcllc_cmd_under_process.next_rrc_state ==RRC_STATE_CELL_FACH) &&
    (RRCCU_STARTED == rrccu_get_cell_update_started_status_with_cause(&cu_cause)) &&
    (((cu_cause == rrc_CellUpdateCause_cellReselection)) || 
      ((cu_cause == rrc_CellUpdateCause_re_enteredServiceArea) )))
  {
    WRRC_MSG2_HIGH("ULREESTABLISHMENT: CU cause %d OC status % d ",cu_cause,ordered_config.set_status);
    last_active_cell_capability = RRC_CELL_CAP_INACTIVE;
    return TRUE;
  }

  return FALSE;
}


  /*====================================================================
  FUNCTION: rrc_check_if_proc_is_active()
  
  DESCRIPTION:
  This function checks if a procedure is active.
  
  DEPENDENCIES:
    None.
  
  RETURN VALUE:
    TRUE: Re config procedure is active and dest state is not PCH
    FALSE: Otherwise
  
  SIDE EFFECTS:
    None.
  ====================================================================*/
boolean rrc_check_if_proc_is_active(rrc_proc_e_type *proc_id)
{

  *proc_id = RRC_PROCEDURE_NONE;
  /* Return TRUE only if next state is not PCH as size change status flag needs to be set for non PCH states only*/
  if((rrcrbe_get_current_sub_state() != RRCRB_INITIAL) && 
  (rrcrbe_get_dest_state()!=RRC_STATE_CELL_PCH && rrcrbe_get_dest_state()!=RRC_STATE_URA_PCH)) 
  {
    *proc_id = RRC_PROCEDURE_RBE;
  }
  else if ((rrcrbrc_get_current_sub_state() != RRCRB_INITIAL) && 
  (rrcrbrc_get_dest_state()!=RRC_STATE_CELL_PCH && rrcrbrc_get_dest_state()!=RRC_STATE_URA_PCH))
  {
    *proc_id = RRC_PROCEDURE_RBRC;
  }

  else if((rrcrbr_get_current_sub_state() != RRCRB_INITIAL) && 
  (rrcrbr_get_dest_state()!=RRC_STATE_CELL_PCH && rrcrbr_get_dest_state()!=RRC_STATE_URA_PCH))
  {
    *proc_id = RRC_PROCEDURE_RBR;
  }
  else if((rrcpcrc_get_current_sub_state() != RRCRB_INITIAL) && 
  (rrcpcrc_get_dest_state()!=RRC_STATE_CELL_PCH && rrcpcrc_get_dest_state()!=RRC_STATE_URA_PCH))
  {
    *proc_id = RRC_PROCEDURE_PCR;
  }
  else if((rrctcrc_get_current_sub_state() != RRCRB_INITIAL) && 
  (rrctcrc_get_dest_state()!=RRC_STATE_CELL_PCH && rrctcrc_get_dest_state()!=RRC_STATE_URA_PCH))
  {
    *proc_id = RRC_PROCEDURE_TCR;
  }

  if(*proc_id != RRC_PROCEDURE_NONE)
  {
    return TRUE;
  }
  else
  {
    return FALSE;
  }
}

  
/*====================================================================
FUNCTION: rrcllc_check_and_reestablish_ul_during_rnti_update_req()

DESCRIPTION:
  This function checks if RLC re-establishment needs to be done. If
  yes, then it updates the RLC Re-establishment command buffer and
  returns a TRUE value.

DEPENDENCIES:
  None.

RETURN VALUE:
  TRUE: RLC Re-establishment needs to be done.
  FALSE: Otherwise

SIDE EFFECTS:
  None.
====================================================================*/
boolean rrcllc_check_and_reestablish_ul_during_rnti_update_req()
{
  ordered_config_type  *config_ptr;
  rrcsmc_re_est_start_list  start_list;
  rrcllc_oc_set_status_e_type     oc_status;
  rrcllc_oc_process_state_e_type  process_state;  
  uint32 local_start_value=0;
  uint8 am_entity_idx_new =0;
  rlc_am_config_req_type rlc_am_config_for_re_est;
  rb_id_type  rb_id = MAX_RB;
  rrc_state_e_type dest_state = rrccu_get_dest_state();
  boolean is_ul_reestab_required = FALSE;
  rlc_reestablish_e_type old_reestab_entity;
  rrc_proc_e_type  proc_id = RRC_PROCEDURE_NONE;
  rlc_am_config_for_re_est.nentity = 0;


  if(config_ptr_in_use == ORDERED_CONFIG)
  {
    config_ptr = ordered_config_ptr;
  }
  else
  {
    config_ptr = current_config_ptr;
  }

  oc_status = rrcllc_get_ordered_config_state_and_proc_wo_f3(&proc_id, &process_state);

  if(rrcllc_cmd_under_process.next_rrc_state != RRC_STATE_CELL_FACH)
  {
    WRRC_MSG1_ERROR("ULREESTABLISHMENT: SKIP ULREEST Next state is not FACH %d",rrcllc_cmd_under_process.next_rrc_state);
    return FALSE;
  }
   
  if((rrccu_get_cell_update_started_status() == RRCCU_STARTED) && ((RRC_STATE_CELL_PCH == dest_state) ||(RRC_STATE_URA_PCH == dest_state)))
  {
    WRRC_MSG1_ERROR("ULREESTABLISHMENT:SKIP ULREEST CU is active and dest state is PCH %d ",dest_state);
    return FALSE;
  }

  /* Now get Ciphering parameters from SMC */
  rrcsmc_get_latest_transmitted_start_values(&start_list);

  if((TRUE == rrcllc_reconfig_in_progress()) &&
     (oc_status != OC_NOT_SET) &&
     (proc_id == RRC_PROCEDURE_RBE) &&
     (RRCRB_WAIT_FOR_CELL_UPDATE_CNF == rrcrbe_get_current_sub_state()) &&
     (TRUE == rrcsmc_get_start_value_to_transmit_flag_status()))
  {
    local_start_value = rrcsmc_get_start_value_to_transmit();
    if(local_start_value !=0)
    {
      rrcsmc_update_start_list_with_latest_transmitted_start_value(&start_list);
    }
  }

  for(am_entity_idx_new=0; am_entity_idx_new<UE_MAX_AM_ENTITY; am_entity_idx_new++)
  {
  
    rb_id = config_ptr->rlc_am_parms.am_info[am_entity_idx_new]->common_config.rb_id;
  
    if((rlc_am_config_for_re_est.nentity < UE_MAX_AM_ENTITY) && (rb_id > DCCH_DT_LOW_PRI_RADIO_BEARER_ID )&&
       (config_ptr->rlc_am_parms.am_info[am_entity_idx_new]->ul_nchan && config_ptr->rlc_am_parms.am_info[am_entity_idx_new]->dl_nchan))
    {
      is_ul_reestab_required = FALSE;

      is_ul_reestab_required = rrcllc_check_if_rb_needs_to_be_reestablished(rb_id);

      old_reestab_entity = config_ptr->am_config[am_entity_idx_new].reestab_entity;

      /* CR 708464 Set the config mask only if UL size change happened. Legacy code blindly sets
         re-establish entity to DL_UL for DCH to FACH transition if RLC info is not given, but
         config mask will be set only if there is actual size change. 
         So the following code should set the config mask only if UL size change happened */
      if(is_ul_reestab_required)
      {
        if((config_ptr->am_config[am_entity_idx_new].reestab_entity == RLC_RE_ESTABLISH_DL) ||
            (config_ptr->am_config[am_entity_idx_new].reestab_entity == RLC_RE_ESTABLISH_NONE))
        {
          if((config_ptr->rlc_one_sided_reest[am_entity_idx_new]) || (rrcllc_check_if_hsrach_to_legacy_cell_change_happened()))
          {
            if(config_ptr->am_config[am_entity_idx_new].reestab_entity == RLC_RE_ESTABLISH_DL)
            {
              config_ptr->am_config[am_entity_idx_new].reestab_entity = RLC_RE_ESTABLISH_DL_UL;
            }
            else
            {
              config_ptr->am_config[am_entity_idx_new].reestab_entity = RLC_RE_ESTABLISH_UL;
            }            
          }
          else
          {
             config_ptr->am_config[am_entity_idx_new].reestab_entity = RLC_RE_ESTABLISH_DL_UL;
          }                                    
        }
      WRRC_MSG2_HIGH("ULREESTABLISHMENT: RNTI_UPDATE Setting the Reestablish entity %d [0=DL/UL,1=DL,2=UL,3=None] entity idx %d",config_ptr->am_config[am_entity_idx_new].reestab_entity,am_entity_idx_new);      

        rlc_am_config_for_re_est.am_act[rlc_am_config_for_re_est.nentity].act_incl = FALSE;
        rlc_am_config_for_re_est.am_act[rlc_am_config_for_re_est.nentity].action = RLC_MODIFY;
        rlc_am_config_for_re_est.am_info[rlc_am_config_for_re_est.nentity] = config_ptr->rlc_am_parms.am_info[am_entity_idx_new];
        
        /* Update RLC size change status so that start value is included appropriately in reconfiguration complete message */
        if(rrc_check_if_proc_is_active(&proc_id))
        {
      
          WRRC_MSG0_HIGH("ULREESTABLISHMENT: Setting rlc size change status to true");
         /*rb_id doesnt matter because CU CNF wont be received after RNTI UPDATE*/
         rrc_set_rlc_size_change_status(proc_id,TRUE,rb_id,config_ptr->am_config[am_entity_idx_new].reestab_entity);
        }

        if (config_ptr->am_config[am_entity_idx_new].reestab_entity == RLC_RE_ESTABLISH_UL)
        {
          rlc_am_config_for_re_est.am_act[rlc_am_config_for_re_est.nentity].ul_cfg_mask = RLC_RE_ESTABLISH_CFG;
          rlc_am_config_for_re_est.am_act[rlc_am_config_for_re_est.nentity].dl_cfg_mask = 0;
          rlc_am_config_for_re_est.am_info[rlc_am_config_for_re_est.nentity]->rlc_ul_am_config.hfn = start_list.hfn_rab;
          rlc_am_config_for_re_est.am_info[rlc_am_config_for_re_est.nentity]->rlc_ul_am_config.ciph_algo =start_list.ciph_algo_urb;
                  rlc_am_config_for_re_est.nentity ++;
        }
        else if (config_ptr->am_config[am_entity_idx_new].reestab_entity == RLC_RE_ESTABLISH_DL_UL)
        {
          rlc_am_config_for_re_est.am_act[rlc_am_config_for_re_est.nentity].ul_cfg_mask = RLC_RE_ESTABLISH_CFG;
          rlc_am_config_for_re_est.am_act[rlc_am_config_for_re_est.nentity].dl_cfg_mask = RLC_RE_ESTABLISH_CFG;
          rlc_am_config_for_re_est.am_info[rlc_am_config_for_re_est.nentity]->rlc_ul_am_config.hfn =
          rlc_am_config_for_re_est.am_info[rlc_am_config_for_re_est.nentity]->rlc_dl_am_config.hfn
            = start_list.hfn_rab;
          rlc_am_config_for_re_est.am_info[rlc_am_config_for_re_est.nentity]->rlc_ul_am_config.ciph_algo =
          rlc_am_config_for_re_est.am_info[rlc_am_config_for_re_est.nentity]->rlc_dl_am_config.ciph_algo 
            =start_list.ciph_algo_urb;
                  rlc_am_config_for_re_est.nentity ++;
        }
      }

      MSG_5(MSG_SSID_DFLT, MSG_LEGACY_HIGH,"ULREESTABLISHMENT :RB ID %d nentity %d HFN %d Old Reestablish entity %d [0=DL/UL,1=DL,2=UL,3=None] New reestab_entity %d [0=DL/UL,1=DL,2=UL,3=None] ",
         rb_id,rlc_am_config_for_re_est.nentity,start_list.hfn_rab,old_reestab_entity,config_ptr->am_config[am_entity_idx_new].reestab_entity);
    }
  } /* for (all nentities in OC) */

  if(rlc_am_config_for_re_est.nentity > 0) 
  {
    WCDMA_MEMCPY(&rrcllc_cmd_under_process.chan_config.rlc_config_req_list.am, sizeof(rlc_am_config_req_type),&rlc_am_config_for_re_est,
      sizeof(rlc_am_config_req_type)); 
  
    rrcllc_crlc_am_config_req(&rlc_am_config_for_re_est);
    return TRUE;
  }
  else
  {
    return FALSE;
  }

} /* rrcllc_check_and_reestablish_ul_during_rnti_update_req */

/*===========================================================================

FUNCTION: rrcllc_clear_old_ul_rlc_size

DESCRIPTION:
  This  function clears the old stored size for a particular RB ID

DEPENDENCIES:
  None.

RETURN VALUE:
None

SIDE EFFECTS:
  None
===========================================================================*/
void rrcllc_clear_old_ul_rlc_size
(
  rb_id_type  rb_id
)
{

  uecomdef_status_e_type        rv = FAILURE;
  uint8 ix;
  RRC_GET_OLD_BACKUP_SIZE_INDEX(rb_id,ix);

   if(FAILURE == rv)
  {
    WRRC_MSG1_ERROR("ULREESTABLISHMENT: Couldnt get correct index for RB ID %d",rb_id);
    return;
  }
   
  WRRC_MSG1_ERROR("ULREESTABLISHMENT: RB ID %d being cleared in back up RLC list ",rb_id);
  rrc_old_ul_rlc_size_backup[ix].ul_rlc_pdu_type = RLC_INVALID_PDU_SIZE;
  rrc_old_ul_rlc_size_backup[ix].ul_fixed_rlc_size = RRCLLC_INVALID_RLC_SIZE;
  rrc_old_ul_rlc_size_backup[ix].ul_flex_li_size = LI_UNSPECIFIED;
}
/*===========================================================================

FUNCTION: rrcllc_check_dch_fach_reconfig_progres_status

DESCRIPTION:


DEPENDENCIES:
  None.

RETURN VALUE:
TRUE/FALSE

SIDE EFFECTS:
  None
===========================================================================*/
boolean rrcllc_check_dch_fach_reconfig_status
(
  void
)
{

  rrc_proc_e_type                 proc_id;
  rrcllc_oc_process_state_e_type  process_state;  
  rrcllc_oc_set_status_e_type     oc_status;
  oc_status = rrcllc_get_ordered_config_state_and_proc_wo_f3(&proc_id, &process_state);

  if(feature_dch_fach_opt_enabled && (OC_SET_FOR_DCH_FACH_TRANS == oc_status) &&
           ((proc_id == RRC_PROCEDURE_RBE) ||
            (proc_id == RRC_PROCEDURE_RBR) ||
            (proc_id == RRC_PROCEDURE_RBRC) ||
            (proc_id == RRC_PROCEDURE_TCR) ||
            (proc_id == RRC_PROCEDURE_PCR)) )
  {
    return TRUE;
  }
  /* Will add changes here to consider DCH to FACH timer expiry
     using TOC status and previous state */
  return FALSE;
}
/*===========================================================================

FUNCTION: rrcllc_dch_fach_check_channel_setup_skip_status

DESCRIPTION:
This function determines whether common channel setup needs to be skipped.

DEPENDENCIES:
  None.

RETURN VALUE:
1. RRC_DCH_FACH_TRANISITION_SKIP_CHANNEL_SETUP - if channel setup is skipped
2. RRC_DCH_FACH_TRANISITION_CHANNEL_SETUP - if channels are to be setup
3. RRC_DCH_FACH_TRANISITION_CHANNEL_INVALID - if optimization is not applied

SIDE EFFECTS:
  None
===========================================================================*/
uint8 rrcllc_dch_fach_check_channel_setup_skip_status
(
  void
)
{
  rrc_proc_e_type                 proc_id;
  rrcllc_oc_process_state_e_type  process_state;  
  (void)rrcllc_get_ordered_config_state_and_proc_wo_f3(&proc_id, &process_state);

  if((rrcllc_check_dch_fach_reconfig_status()) && (rrcllc_cmd_under_process.procedure == proc_id))
  {
    if((rrcrb_is_cu_going_to_be_triggered(rrcllc_cmd_under_process.procedure)== TRUE) &&
        (rrcenhstate_camped_cell_supports_e_fach() == TRUE))
    {
      /*Skip channel setup if EFACH is active and CU is going to be triggered*/
      return RRC_DCH_FACH_TRANISITION_SKIP_CHANNEL_SETUP;
    }
    else
    {
      /*Setup all channels*/
      return RRC_DCH_FACH_TRANISITION_CHANNEL_SETUP;
    }
  }
  /*eighter this not DCH to fach tranistion or channel config is not from procedure*/
  return RRC_DCH_FACH_TRANISITION_CHANNEL_INVALID;
}

/*===========================================================================

FUNCTION: rrcllc_setup_common_logical_channels_for_fach

DESCRIPTION:


DEPENDENCIES:
  None.

RETURN VALUE:
TRUE/FALSE

SIDE EFFECTS:
  None
===========================================================================*/
uecomdef_status_e_type rrcllc_setup_common_logical_channels_for_fach
(
  void
)

{
#ifdef FEATURE_WCDMA_HS_FACH
  if(rrcllc_get_hs_status_in_e_fach(ordered_config_ptr) == TRUE)
  {
    (void)rrcenhstate_process_add_ccch();
  }
  else
#endif /*FEATURE_WCDMA_HS_FACH*/
  {
    if(rrcllc_semi_permanent_data.dl_phy_chan.fach_included == FALSE)
    {
      /* This is a wrong selection of SCCPCH that does not have FACH */
      WRRC_MSG0_ERROR("SCCPCH has no FACH included DCH->FACH");
      return(FAILURE);
    }
    else
    {
      /* Add CCCH */
      (void)rrcllc_process_add_ccch();
    }
  }

  WRRC_MSG0_HIGH("Adding BCCH ON FACH");
#ifdef FEATURE_WCDMA_HS_FACH
  if(rrcllc_get_hs_status_in_e_fach(ordered_config_ptr))
  {
    (void)rrcenhstate_process_add_bcch_on_hsdsch();
  }
  else
#endif
  {
    (void)rrcllc_process_add_bcch_on_fach();
  }
  /* Initialize Send MAC Uplink Config indicator to TRUE */
  rrcllc_semi_permanent_data.send_mac_uplink_config = TRUE;
  return SUCCESS;
}

/*===========================================================================

FUNCTION: rrcllc_setup_physical_channels_for_dch_to_fach

DESCRIPTION:


DEPENDENCIES:
  None.

RETURN VALUE:
TRUE/FALSE

SIDE EFFECTS:
  None
===========================================================================*/
uecomdef_status_e_type rrcllc_setup_physical_channels_for_dch_to_fach
(
  void
)
{
  #ifdef FEATURE_WCDMA_HS_FACH
  if(rrcllc_get_hs_status_in_e_fach(ordered_config_ptr) == TRUE)
  {
    if(rrcenhstate_setup_phychan() == FAILURE)
    {
      ERR_FATAL("RRCENHST:Setting up HS PDSCH failed",0,0,0);
      return FAILURE;
    }
  }
  else
#endif /*FEATURE_WCDMA_HS_FACH*/
  {
    /* Fix the transport channel bitmasks for SCCPCH */
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
      L1_DL_TRCH_REFTYPE_FACH_BF;
    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf |=
      L1_DL_TRCH_REFTYPE_FACH_BF;

    rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_enable_bf &=
      ~L1_DL_TRCH_REFTYPE_PCH_BF;

    if(rrcllc_semi_permanent_data.dl_phy_chan.pch_included)
    {
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf |=
        L1_DL_TRCH_REFTYPE_PCH_BF;
    }
    else  /* No PCH on this SCCPCH */
    {
      rrcllc_semi_permanent_data.dl_phy_chan.sccpch.trch_ref_type_bf &=
        ~L1_DL_TRCH_REFTYPE_PCH_BF;
    }

    if(rrcllc_process_add_sccpch() == FAILURE)
    {
      WRRC_MSG0_ERROR("Couldn't reconfigure SCCPCH");
      return FAILURE;
    }
  }

  /* Uplink Physical channel processing */

  /* This is a case for addition of PRACH */
  rrcllc_cmd_under_process.chan_config.phy_chan_action_list.prach_action =
    LLC_PHYCHAN_SETUP;

  return SUCCESS;
}



/*===========================================================================
FUNCTION rrcllc_get_current_substate()

DESCRIPTION
  This function will return current llc
  procedure's sub state.
DEPENDENCIES
  None

RETURN VALUE
  return current llc sub state.
SIDE EFFECTS
none
===========================================================================*/
uint8  rrcllc_get_current_substate(void)
{
  return ((uint8)rrcllc_current_substate);
} /*rrcllc_get_current_substate*/  
#ifdef FEATURE_QSH_DUMP
/*===========================================================================
FUNCTION wrrc_qsh_dump_llc_debug

DESCRIPTION
  This function dumps llc globals

DEPENDENCIES
  None


RETURN VALUE
None


SIDE EFFECTS
  None

===========================================================================*/
__attribute__((section(".uncompressible.text")))
size_t wrrc_qsh_dump_llc_debug(uint8* dump_addr, size_t size)
{
  wrrc_qsh_dump_tag_llc_debug llc_globals;
  uint8 i;
  qsh_client_dump_tag_hdr_init((qsh_dump_tag_hdr_s *)dump_addr,WRRC_QSH_DUMP_TAG_LLC_DEBUG,
                                     (sizeof(wrrc_qsh_dump_tag_llc_debug) - sizeof(qsh_dump_tag_hdr_s)));
  WCDMA_MEMCPY(&llc_globals,sizeof(wrrc_qsh_dump_tag_llc_debug),
    (wrrc_qsh_dump_tag_llc_debug*)dump_addr, sizeof(wrrc_qsh_dump_tag_llc_debug));


  for(i=0;i<5;i++)
  {
    llc_globals.cphy_setup_req_mask[i] = 0;
  }
  llc_globals.rrc_current_cmd_id = rrcllc_cmd_under_process.rrc_current_cmd_id;
  llc_globals.current_cmd_engine = rrcllc_cmd_under_process.chan_config.current_cmd_engine;
  llc_globals.chan_config_reason = rrcllc_cmd_under_process.chan_config.chan_config_reason;
  llc_globals.int_cmd_q_cnt = rrc_int_cmd_q.cnt;
  llc_globals.llc_cmd_q_cnt = llc_cmd_q.cnt;
  llc_globals.mm_cmd_q_cnt = rrc_mm_cmd_q.cnt;
  llc_globals.l1_cmd_q_cnt = rrc_l1_cmd_q.cnt;
  llc_globals.rrcllc_current_substate = rrcllc_current_substate;
  llc_globals.procedure = rrcllc_cmd_under_process.procedure;
  llc_globals.next_rrc_state = rrcllc_cmd_under_process.next_rrc_state;
  llc_globals.cmd_under_process_valid = rrcllc_cmd_under_process.valid & 0x01;

  if(sizeof(llc_globals) >= size)
  {
    WCDMA_MEMCPY((wrrc_qsh_dump_tag_llc_debug*)dump_addr, size,&llc_globals, size);
    return size;
  }
  else
  {
    WCDMA_MEMCPY((wrrc_qsh_dump_tag_llc_debug*)dump_addr, sizeof(llc_globals),&llc_globals, sizeof(llc_globals));
    return ((size_t)sizeof(llc_globals));
  }
}
#endif
/*===========================================================================

FUNCTION: rrcllc_get_current_chan_conf_under_process_procedure

DESCRIPTION:This function returns the procedure which has triggered channel config under process

DEPENDENCIES:
  None.

RETURN VALUE:
  rrc_proc_e_type

SIDE EFFECTS:
  None
===========================================================================*/
rrc_proc_e_type rrcllc_get_current_chan_conf_under_process_procedure(void)
{
  return rrcllc_cmd_under_process.procedure;
}
#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
/*===========================================================================

FUNCTION: rrcllc_post_reconfig_complete_ind_for_failure

DESCRIPTION:


DEPENDENCIES:
  None.

RETURN VALUE:
TRUE/FALSE

SIDE EFFECTS:
  None
===========================================================================*/

void rrcllc_post_reconfig_complete_ind_for_failure(void)
{
  rrc_cmd_type  *rrc_cmd_ptr;

  /* Check if SMC needs to be notified */
  if((rrctfcc_is_reconfig_in_progress() == TRUE) || 
     (rrcsmc_is_reconfig_in_progress() == TRUE))
  {
    /* Send RRC_RECONFIG_COMPLETE_IND to SMC */
     rrc_cmd_ptr = rrc_get_int_cmd_buf();

    WRRC_MSG0_HIGH("Sending RRC_RECONFIG_COMPLETE_IND to SMC");

    /* Fill in the local command header.*/
    rrc_cmd_ptr->cmd_hdr.cmd_id = RRC_RECONFIG_COMPLETE_IND;

    /* Send the internal command */
    rrc_put_int_cmd(rrc_cmd_ptr);
  }

}
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/