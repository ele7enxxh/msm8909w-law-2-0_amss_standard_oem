# vi: tw=128 ts=3 sw=3 et :
# @file tms_builder_rcinit_info.py
# @brief This file contains the API for the Run Control Framework, API 3.0
#===============================================================================
# NOTE: The @brief description above does not appear in the PDF.
# The tms_mainpage.dox file contains the group/module descriptions that
# are displayed in the output PDF generated using Doxygen and LaTeX. To
# edit or update any of the group/module text in the PDF, edit the
# tms_mainpage.dox file or contact Tech Pubs.
#===============================================================================
#===============================================================================
# Copyright (c) 2015 Qualcomm Technologies, Inc.
# All Rights Reserved.
# Confidential and Proprietary - Qualcomm Technologies, Inc.
#===============================================================================
#===============================================================================
# Edit History
# $Header: //components/rel/core.mpss/3.5.c12.3/bsp/build/scripts/tms_builder_rcinit_info.py#1 $
# $DateTime: 2016/12/13 07:59:23 $
# $Change: 11985146 $
# $Author: mplcsds1 $
#===============================================================================

# Module Version, Python Standard PEP8, 2001, https://www.python.org/dev/peps/pep-0008/
__version__ = "$Header: //components/rel/core.mpss/3.5.c12.3/bsp/build/scripts/tms_builder_rcinit_info.py#1 $"

# Shared Library Version, Semantic Versioning 2.0.0, http://semver.org/
__version_info__ = "3.0.0"

# NOTE: Debug instruments exposed by adding to command line as
# build.cmd build_target BUILD_VER=00000 --debug=stacktrace --debuginfo=tms

#===============================================================================
# Description
#===============================================================================

# This SCONS tool is the build time support for the RCINIT Framework;
# client users to the framework will supply within their software
# delivery at least one call to this tool. The tool includes a number
# of pseudo builder method calls for use by the clients. The input to
# the pseudo builder method calls is used for the final target
# output, an autogenerated C source file.

#===============================================================================
# Module Imports
#===============================================================================

import os
import csv
from SCons.Script import *
import inspect
import re
import hashlib

#===============================================================================
# Module Scope Definitions
#===============================================================================

TOOL_USES_FLAG = 'USES_RCINIT_INFO'

RCINIT_INFO_NAME        = 'rcinit_info_name'                # internal key
RCINIT_INFO_API         = 'rcinit_info_api'                 # internal key
RCINIT_INFO_PLIST       = 'rcinit_info_plist'               # internal key
RCINIT_INFO_PLISTSZ     = 'rcinit_info_plist_size'          # internal key
RCINIT_INFO_DLIST       = 'rcinit_info_dlist'               # internal key
RCINIT_INFO_DLISTSZ     = 'rcinit_info_dlist_size'          # internal key
RCINIT_INFO_ENTRY       = 'rcinit_info_entry'               # internal key
RCINIT_INFO_HASH        = 'rcinit_info_hash'                # internal key
RCINIT_INFO_GROUP       = 'rcinit_info_group'               # internal key
RCINIT_INFO_PRIO        = 'rcinit_info_prio'                # internal key
RCINIT_INFO_PRIO_ALIAS  = 'rcinit_info_prio_alias'          # internal key
RCINIT_INFO_STACK_SIZE  = 'rcinit_info_stack_size'          # internal key
RCINIT_INFO_AFFINITY    = 'rcinit_info_affinity'            # internal key
RCINIT_INFO_STACK_SECT  = 'rcinit_info_stack_sect'          # internal key
RCINIT_INFO_DEFINED     = 'rcinit_info_defined'             # internal key
RCINIT_INFO_HEAP_SLIMIT = 'rcinit_info_heap_slimit'         # internal key
RCINIT_INFO_HEAP_HLIMIT = 'rcinit_info_heap_hlimit'         # internal key

RCINIT_INFO_API_POLICYFN   = 'RCINIT_TASK_POLICYFN'         # internal key
RCINIT_INFO_API_INITFN     = 'RCINIT_TASK_INITFN'           # internal key
RCINIT_INFO_API_TASK_DAL   = 'RCINIT_TASK_DAL'              # internal key
RCINIT_INFO_API_TASK_POSIX = 'RCINIT_TASK_POSIX'            # internal key
RCINIT_INFO_API_TASK_QURT  = 'RCINIT_TASK_QURT'             # internal key
RCINIT_INFO_API_TASK_REX   = 'RCINIT_TASK_REX'              # internal key

RCINIT_GROUP_0 = 'RCINIT_GROUP_0'                           # internal key
RCINIT_GROUP_1 = 'RCINIT_GROUP_1'
RCINIT_GROUP_2 = 'RCINIT_GROUP_2'
RCINIT_GROUP_3 = 'RCINIT_GROUP_3'
RCINIT_GROUP_4 = 'RCINIT_GROUP_4'
RCINIT_GROUP_5 = 'RCINIT_GROUP_5'
RCINIT_GROUP_6 = 'RCINIT_GROUP_6'
RCINIT_GROUP_7 = 'RCINIT_GROUP_7'

THREAD_TCB = 'tcb_name'                                     # internal tracking (TA deprecated)
THREAD_STACK = 'stack_name'                                 # internal tracking (TA deprecated)

RCINIT_NULL = 'RCINIT_NULL'                                 # internal key
RCINIT_STKSZ_ZERO = 'RCINIT_STKSZ_ZERO'                     # internal key
RCINIT_PRIO_INITFN = 'RCINIT_PRIO_INITFN'                   # internal key
RCINIT_PRIO_POLICYFN = 'RCINIT_PRIO_POLICYFN'               # internal key
RCINIT_AFFINITY_ALL = 'RCINIT_AFFINITY_ALL'                 # internal key
RCINIT_AFFINITY_SINGLE = 'RCINIT_AFFINITY_SINGLE'

RCINIT_PRIO_ALIAS_FILE = 'RCINIT_PRIO_ALIAS_FILE'           # internal key

RCINIT_NOPOLICY_ORDERED_LIST = 'RCINIT_ORDERED_COLLECTOR'   # internal key
RCINIT_POLICY_USE_LIST = 'RCINIT_POLICY_USAGE_COLLECTOR'    # internal key

RCINIT_INFOS_LIST = 'RCINIT_INFOS_COLLECTOR'                # internal key
RCINIT_PLISTS_DICT = 'RCINIT_PLISTS_COLLECTOR'              # internal key
RCINIT_PRIO_ALIAS_DICT = 'RCINIT_PRIO_ALIAS_COLLECTOR'      # internal key

RCINIT_NAME_MAXLEN = 15                                     # ALL PL, ALL NHLOS API
RCINIT_OUTPUT_NA = '-'
RCINIT_OUTPUT_LEN = '*'
RCINIT_OUTPUT_TRUE = 'Y'
RCINIT_OUTPUT_FALSE = 'N'

RCINIT_STACK_OVERHEAD = 128                                 # internal estimate size of first exception frame
RCINIT_STACK_ROUNDUP = 4096                                 # internal estimate size roundup to target page size

RCINIT_STACK_SECTION = '.bss.stack_'

RCINIT_PRIORITY_ALIAS_MAP_FILE = 'rcinit_task_prio.csv'     # Required, IMAGE OWNER delivered

RCINIT_EXT_PB = '.c'                                        # internal key
RCINIT_EXT_PL = '.rcpl'                                     # internal key
RCINIT_EXT_CSV = '.csv'                                     # internal key
RCINIT_EXT_LOG = '.txt'                                     # internal key

RCINIT_POC_IO =   '(POC IMAGE OWNER)'                       # Owner of Image
RCINIT_POC_TA =   '(POC TECH AREA)'                         # Owner of Tech Area
RCINIT_POC_HBA =  '(POC HOST BUILD ENV)'                    # Owner of Host (Harvester, Blade Server, ...)

RCINIT_BUILD_TAGS    = 'build_tags'                         # internal key
RCINIT_TARGET        = 'target'                             # internal key
RCINIT_SOURCE        = 'source'                             # internal key

TOOL_DEF_FILE = 'file'
TOOL_DEF_LINE = 'line'

RCINIT_AUTOGEN_TEMPLATE = 'RCINIT_AUTOGEN_TEMPLATE'
RCINIT_AUTOGEN_INFO_TEXT = 'RCINIT_AUTOGEN_INFO_TEXT'
RCINIT_AUTOGEN_RCPL_TEXT = 'RCINIT_AUTOGEN_RCPL_TEXT'
RCINIT_AUTOGEN_RCPB_TEXT = 'RCINIT_AUTOGEN_RCPB_TEXT'

RCINIT_AUTOGEN_TEMPLATE_FILE = 'rcinit_autogen.in'
RCINIT_AUTOGEN_TEMPLATE_OUTPUT = '${{IMAGE_NAME}}/rcinit_{}.c'

RCINIT_POLICY_DEFAULT = ['default']

RCINIT_INFO_APIS = [                                        # internal keys
   RCINIT_INFO_API_POLICYFN,
   RCINIT_INFO_API_INITFN,
   RCINIT_INFO_API_TASK_DAL,
   RCINIT_INFO_API_TASK_POSIX,
   RCINIT_INFO_API_TASK_QURT,
   RCINIT_INFO_API_TASK_REX,
]

RCINIT_INFO_API_TASK = [                                    # internal keys
   RCINIT_INFO_API_TASK_DAL,
   RCINIT_INFO_API_TASK_POSIX,
   RCINIT_INFO_API_TASK_QURT,
   RCINIT_INFO_API_TASK_REX,
]

RCINIT_INFO_GROUP_KEYS = {
    RCINIT_GROUP_0 : 0,
    RCINIT_GROUP_1 : 1,
    RCINIT_GROUP_2 : 2,
    RCINIT_GROUP_3 : 3,
    RCINIT_GROUP_4 : 4,
    RCINIT_GROUP_5 : 5,
    RCINIT_GROUP_6 : 6,
    RCINIT_GROUP_7 : 7,
}

RCINIT_INFO_GROUP_MAX = len(RCINIT_INFO_GROUP_KEYS)

valid_pri_order = [
   'SHARED_IST_PRI_ORDER',
   'SHARED_IST_SERVICE_PRI_ORDER',
   'SHARED_DRIVER_PRI_ORDER',
   'SHARED_DRIVER_SERVICE_PRI_ORDER',
   'SHARED_FOREGROUND_PRI_ORDER',
   'SHARED_FOREGROUND_SERVICE_PRI_ORDER',
   'SHARED_BACKGROUND_PRI_ORDER',
   'SHARED_BACKGROUND_SERVICE_PRI_ORDER',
   'SHARED_IDLE_PRI_ORDER',
   'SHARED_IDLE_SERVICE_PRI_ORDER',
   ]

# Keyword Replacements

RCINIT_KEYSMAP = {
   'build_id'                       : RCINIT_BUILD_TAGS,
   'build_ids'                      : RCINIT_BUILD_TAGS,
   'targets'                        : RCINIT_TARGET,
   'sources'                        : RCINIT_SOURCE,
   'name'                           : RCINIT_INFO_NAME,
   'policy_name'                    : RCINIT_INFO_NAME,
   'init_name'                      : RCINIT_INFO_NAME,
   'thread_name'                    : RCINIT_INFO_NAME,
   'api'                            : RCINIT_INFO_API,
   'type'                           : RCINIT_INFO_API,
   'thread_type'                    : RCINIT_INFO_API,
   'plist'                          : RCINIT_INFO_PLIST,
   'policy_optin'                   : RCINIT_INFO_PLIST,
   'dlist'                          : RCINIT_INFO_DLIST,
   'dependency'                     : RCINIT_INFO_DLIST,
   'dependencies'                   : RCINIT_INFO_DLIST,
   'entry'                          : RCINIT_INFO_ENTRY,
   'function'                       : RCINIT_INFO_ENTRY,
   'policy_function'                : RCINIT_INFO_ENTRY,
   'init_function'                  : RCINIT_INFO_ENTRY,
   'thread_entry'                   : RCINIT_INFO_ENTRY,
   'hash'                           : RCINIT_INFO_HASH,
   'group'                          : RCINIT_INFO_GROUP,
   'sequence_group'                 : RCINIT_INFO_GROUP,
   'prio'                           : RCINIT_INFO_PRIO,
   'priority'                       : RCINIT_INFO_PRIO,
   'prio_alias'                     : RCINIT_INFO_PRIO_ALIAS,
   'priority_amss_order'            : RCINIT_INFO_PRIO_ALIAS,
   'stack'                          : RCINIT_INFO_STACK_SIZE,
   'stack_size'                     : RCINIT_INFO_STACK_SIZE,
   'stack_size_bytes'               : RCINIT_INFO_STACK_SIZE,
   'stack_sect'                     : RCINIT_INFO_STACK_SECT,
   'heap'                           : RCINIT_INFO_HEAP_SLIMIT,
   'heap_size_bytes'                : RCINIT_INFO_HEAP_SLIMIT,
   'heap_slimit'                    : RCINIT_INFO_HEAP_SLIMIT,
   'heap_soft_limit'                : RCINIT_INFO_HEAP_SLIMIT,
   'heap_hlimit'                    : RCINIT_INFO_HEAP_HLIMIT,
   'heap_hard_limit'                : RCINIT_INFO_HEAP_HLIMIT,
}

# Value Replacements

RCINIT_VALSMAP = {
   RCINIT_INFO_API :
   {
      'DAL'                         : RCINIT_INFO_API_TASK_DAL,
      'RCINIT_TASK_DALTASK'         : RCINIT_INFO_API_TASK_DAL,
      'PTHREAD'                     : RCINIT_INFO_API_TASK_POSIX,
      'RCINIT_TASK_PTHREAD'         : RCINIT_INFO_API_TASK_POSIX,
      'QURT'                        : RCINIT_INFO_API_TASK_QURT,
      'RCINIT_TASK_QURTTASK'        : RCINIT_INFO_API_TASK_QURT,
      'REX'                         : RCINIT_INFO_API_TASK_REX,
      'RCINIT_TASK_REXTASK'         : RCINIT_INFO_API_TASK_REX,
   },
   RCINIT_INFO_ENTRY :
   {
      'NULL'                        : RCINIT_NULL,
   },
   RCINIT_INFO_GROUP :
   {
      '0'                           : RCINIT_GROUP_0,
      '1'                           : RCINIT_GROUP_1,
      '2'                           : RCINIT_GROUP_2,
      '3'                           : RCINIT_GROUP_3,
      '4'                           : RCINIT_GROUP_4,
      '5'                           : RCINIT_GROUP_5,
      '6'                           : RCINIT_GROUP_6,
      '7'                           : RCINIT_GROUP_7,
      'NONE'                        : RCINIT_GROUP_7,
      'NULL'                        : RCINIT_GROUP_7,
      'PARKED'                      : RCINIT_GROUP_7,
   },
   RCINIT_INFO_AFFINITY :
   {
      'REX_ANY_SMT_MASK'            : RCINIT_AFFINITY_ALL,
      'REX_ANY_CPU_AFFINITY_MASK'   : RCINIT_AFFINITY_ALL,
      'REX_SINGLE_CPU_AFFINITY_MASK': RCINIT_AFFINITY_SINGLE,
   },
}

#===============================================================================
# SCONS Hooks
#===============================================================================

# exists: determines if the compilers, assemblers, linkers, tools,
# etc.. are available and present. this controls the generation of a
# construction environment assosicated to env.

def exists(env, **kw):
   ''' SCONS Tool, Exists, Check Conditions to Install a Construction Environment '''
   return True

# generate: this generates a construction environment for use by
# scons; the environment is provided to use.

def generate(env, **kw):
   ''' SCONS Tool, Generate, Generate a Construction Environment '''

   IMAGE_NAME = env.get('IMAGE_NAME', None)

   # This tool supplies a USES_ flag for clients to utilize in the
   # construction environment.

   env.AddUsesFlags(TOOL_USES_FLAG)

   # Locate the *REQUIRED* autogen template file. It is to be supplied
   # within the BUILD_ROOT.

   tool_load_autogen_template(None, None, env)

   # Locate the *REQUIRED* priority alias file. It is to be supplied
   # by the IMAGE OWNER at FindConfigFiles() or IMAGE_ROOT.

   tool_load_alias_map(None, None, env)

   # Client exposed methods to the tool. These function as 'pseudo
   # builders' to collect client information, validate, and then save
   # to the 'globals' construction environment.

   # Infosrc Builders

   builder_1 = Builder(
      action = tool_create_output_c,
      suffix = '.c',
      src_suffix = '.in',
      emitter=tool_emitter_adds_hash)

   env.Append(BUILDERS = {'RCInitInfoSource' : builder_1 })

   env.AddMethod(tool_method_add_task_kw,    'AddRCInitTaskInfo')
   env.AddMethod(tool_method_add_func_kw,    'AddRCInitFuncInfo')
   env.AddMethod(tool_method_add_plcy_kw,    'AddRCInitPlcyInfo')

   # This tool saves 'globals' build information into the construction
   # environment that is provided upon the first generate() call. This
   # allows for the tool to track across the different construction
   # environments that tech areas create (redundantly) with use of the
   # env.Clone()

   env[IMAGE_NAME] = env
   env[IMAGE_NAME][RCINIT_INFOS_LIST] = []
   env[IMAGE_NAME][RCINIT_PLISTS_DICT] = {}
   env[IMAGE_NAME][RCINIT_POLICY_USE_LIST] = RCINIT_POLICY_DEFAULT
   env[IMAGE_NAME][RCINIT_NOPOLICY_ORDERED_LIST] = [ [] for i in range(RCINIT_INFO_GROUP_MAX) ]

#===============================================================================

def tool_method_add_task_kw(env, **kw):
   ''' Method Add Task with Keywords
   '''
   frame, filename, line_number, function_name, lines, index = inspect.getouterframes(inspect.currentframe())[2]
   kw[RCINIT_INFO_DEFINED] = { TOOL_DEF_FILE : filename, TOOL_DEF_LINE : line_number }

   IMAGE_NAME = env.get('IMAGE_NAME', None)

   kw = tool_cannonize_keyword(env, **kw)

   # Check Build Tags
   if not RCINIT_BUILD_TAGS in kw or 0 >= len(kw[RCINIT_BUILD_TAGS]):
      return ''

   # Keyword : rcinit_info_api
   if not RCINIT_INFO_API in kw:
      kw[RCINIT_INFO_API] = RCINIT_INFO_API_TASK_REX
   if not kw[RCINIT_INFO_API] in RCINIT_INFO_API_TASK:
      env.TmsError([RCINIT_POC_TA, 'Valid NHLOS KERNEL API required', kw[RCINIT_INFO_NAME], kw[RCINIT_INFO_API]])

   # Keywords : Output Sanatized and Range Checked Keywords
   kw = kw_validate_name(env,
      **kw_validate_plist(env,
         **kw_validate_dlist(env,
            **kw_validate_group(env,
               **kw_validate_entry(env,
                  **kw_validate_stack(env,
                     **kw_validate_prio(env, **kw)))))))

   # Keyword : target
   if not RCINIT_TARGET in kw:
      kw[RCINIT_TARGET] = RCINIT_AUTOGEN_TEMPLATE_OUTPUT.format(kw[RCINIT_INFO_NAME])

   # Keyword : source
   if not RCINIT_SOURCE in kw:
      kw[RCINIT_SOURCE] = []
   if not env[RCINIT_AUTOGEN_TEMPLATE] in kw[RCINIT_SOURCE]:
      kw[RCINIT_SOURCE].append(env[RCINIT_AUTOGEN_TEMPLATE])
   if not kw[RCINIT_INFO_DEFINED][TOOL_DEF_FILE] in kw[RCINIT_SOURCE]:
      kw[RCINIT_SOURCE].append(kw[RCINIT_INFO_DEFINED][TOOL_DEF_FILE])

   env.Clean(Alias(IMAGE_NAME), kw[RCINIT_TARGET])
   env.Depends(kw[RCINIT_TARGET], kw[RCINIT_SOURCE])

   # Ignore output creation on appropriate SCONS options
   if env.GetOption('clean') or env.GetOption('no_exec'):
      env.TmsDebug([ IMAGE_NAME, 'CLEAN/NO_EXEC during tool action' ])
   else:
      env.RCInitInfoSource(kw[RCINIT_TARGET], kw[RCINIT_SOURCE], RCINIT_KW=str(kw))
      env.RequirePublicApi([ 'TMS', 'DEBUGTOOLS', 'DAL', 'KERNEL', ])
      #env.AddObject(kw[RCINIT_BUILD_TAGS], kw[RCINIT_TARGET])

   if not any(_ent[RCINIT_INFO_NAME] == kw[RCINIT_INFO_NAME] for _ent in env[IMAGE_NAME][RCINIT_INFOS_LIST]):
      env[IMAGE_NAME][RCINIT_INFOS_LIST].append(kw)
      env.TmsDebug(['Create info entry', IMAGE_NAME, kw[RCINIT_TARGET], ':::', kw[RCINIT_SOURCE]])

   return kw[RCINIT_TARGET]

#===============================================================================

def tool_method_add_func_kw(env, **kw):
   ''' Method Add Function with Keywords
   '''
   frame, filename, line_number, function_name, lines, index = inspect.getouterframes(inspect.currentframe())[2]
   kw[RCINIT_INFO_DEFINED] = { TOOL_DEF_FILE : filename, TOOL_DEF_LINE : line_number }

   IMAGE_NAME = env.get('IMAGE_NAME', None)

   kw = tool_cannonize_keyword(env, **kw)

   # Check Build Tags
   if not RCINIT_BUILD_TAGS in kw or 0 >= len(kw[RCINIT_BUILD_TAGS]):
      return ''

   # Keyword : rcinit_info_api
   kw[RCINIT_INFO_API] = RCINIT_INFO_API_INITFN

   # Keywords : Output Sanatized and Range Checked Keywords
   kw = kw_validate_name(env,
      **kw_validate_plist(env,
         **kw_validate_dlist(env,
            **kw_validate_group(env,
               **kw_validate_entry(env,
                  **kw_validate_stack(env,
                     **kw_validate_prio(env, **kw)))))))

   # Keyword : target
   if not RCINIT_TARGET in kw:
      kw[RCINIT_TARGET] = RCINIT_AUTOGEN_TEMPLATE_OUTPUT.format(kw[RCINIT_INFO_NAME])

   # Keyword : source
   if not RCINIT_SOURCE in kw:
      kw[RCINIT_SOURCE] = []
   if not env[RCINIT_AUTOGEN_TEMPLATE] in kw[RCINIT_SOURCE]:
      kw[RCINIT_SOURCE].append(env[RCINIT_AUTOGEN_TEMPLATE])
   if not kw[RCINIT_INFO_DEFINED][TOOL_DEF_FILE] in kw[RCINIT_SOURCE]:
      kw[RCINIT_SOURCE].append(kw[RCINIT_INFO_DEFINED][TOOL_DEF_FILE])

   env.Clean(Alias(IMAGE_NAME), kw[RCINIT_TARGET])
   env.Depends(kw[RCINIT_TARGET], kw[RCINIT_SOURCE])
   env.Precious(kw[RCINIT_TARGET])

   # Ignore output creation on appropriate SCONS options
   if env.GetOption('clean') or env.GetOption('no_exec'):
      env.TmsDebug([ IMAGE_NAME, 'CLEAN/NO_EXEC during tool action' ])
   else:
      env.RCInitInfoSource(kw[RCINIT_TARGET], kw[RCINIT_SOURCE], RCINIT_KW=str(kw))
      env.RequirePublicApi([ 'TMS', 'DEBUGTOOLS', 'DAL', 'KERNEL', ])
      #env.AddObject(kw[RCINIT_BUILD_TAGS], kw[RCINIT_TARGET])

   if not any(_ent[RCINIT_INFO_NAME] == kw[RCINIT_INFO_NAME] for _ent in env[IMAGE_NAME][RCINIT_INFOS_LIST]):
      env[IMAGE_NAME][RCINIT_INFOS_LIST].append(kw)
      env.TmsDebug(['Create info entry', IMAGE_NAME, kw[RCINIT_TARGET], ':::', kw[RCINIT_SOURCE]])

   return kw[RCINIT_TARGET]

#===============================================================================

def tool_method_add_plcy_kw(env, **kw):
   ''' Method Add Policy with Keywords
   '''
   frame, filename, line_number, function_name, lines, index = inspect.getouterframes(inspect.currentframe())[2]
   kw[RCINIT_INFO_DEFINED] = { TOOL_DEF_FILE : filename, TOOL_DEF_LINE : line_number }

   IMAGE_NAME = env.get('IMAGE_NAME', None)

   kw = tool_cannonize_keyword(env, **kw)

   # Check Build Tags
   if not RCINIT_BUILD_TAGS in kw or 0 >= len(kw[RCINIT_BUILD_TAGS]):
      return ''

   # Keyword : rcinit_info_api
   kw[RCINIT_INFO_API] = RCINIT_INFO_API_POLICYFN

   # Keywords : Output Sanatized and Range Checked Keywords
   kw = kw_validate_name(env,
      **kw_validate_plist(env,
         **kw_validate_dlist(env,
            **kw_validate_group(env,
               **kw_validate_entry(env,
                  **kw_validate_stack(env,
                     **kw_validate_prio(env, **kw)))))))

   # Keyword : target
   if not RCINIT_TARGET in kw:
      kw[RCINIT_TARGET] = RCINIT_AUTOGEN_TEMPLATE_OUTPUT.format(kw[RCINIT_INFO_NAME])

   # Keyword : source
   if not RCINIT_SOURCE in kw:
      kw[RCINIT_SOURCE] = []
   if not env[RCINIT_AUTOGEN_TEMPLATE] in kw[RCINIT_SOURCE]:
      kw[RCINIT_SOURCE].append(env[RCINIT_AUTOGEN_TEMPLATE])
   if not kw[RCINIT_INFO_DEFINED][TOOL_DEF_FILE] in kw[RCINIT_SOURCE]:
      kw[RCINIT_SOURCE].append(kw[RCINIT_INFO_DEFINED][TOOL_DEF_FILE])

   env.Clean(Alias(IMAGE_NAME), kw[RCINIT_TARGET])
   env.Depends(kw[RCINIT_TARGET], kw[RCINIT_SOURCE])
   env.Precious(kw[RCINIT_TARGET])

   # Ignore output creation on appropriate SCONS options
   if env.GetOption('clean') or env.GetOption('no_exec'):
      env.TmsDebug([ IMAGE_NAME, 'CLEAN/NO_EXEC during tool action' ])
   else:
      env.RCInitInfoSource(kw[RCINIT_TARGET], kw[RCINIT_SOURCE], RCINIT_KW=str(kw))
      env.RequirePublicApi([ 'TMS', 'DEBUGTOOLS', 'DAL', 'KERNEL', ])
      #env.AddObject(kw[RCINIT_BUILD_TAGS], kw[RCINIT_TARGET])

   if not any(_ent[RCINIT_INFO_NAME] == kw[RCINIT_INFO_NAME] for _ent in env[IMAGE_NAME][RCINIT_INFOS_LIST]):
      env[IMAGE_NAME][RCINIT_INFOS_LIST].append(kw)
      env.TmsDebug(['Create info entry', IMAGE_NAME, kw[RCINIT_TARGET], ':::', kw[RCINIT_SOURCE]])

   return kw[RCINIT_TARGET]

#===============================================================================

def tool_emitter_adds_hash(target, source, env):
   import os
   target = [ env.RealPath(str(target[i])) for i in range(len(target)) ]
   target += [ str(target[i]) + '.md5' for i in range(len(target)) ]
   env.Precious([ str(target[i]) for i in range(len(target)) ])
   env.TmsDebug(['emitter', target, ':::', source ])
   return target, source

#===============================================================================

def tool_create_output_c(target, source, env):
   ''' Output C File '''
   env.TmsDebug([target])

   if isinstance(target, str):
      env.TmsError([target, 'FAILS'])

   content = ''

   if 'RCINIT_CONTENT' in env:
      env.TmsDebug([str(target[0]), 'content from RCINIT_CONTENT'])
      content = env['RCINIT_CONTENT']

   if 'RCINIT_KW' in env:
      kw = eval(env['RCINIT_KW'])
      env.TmsDebug([str(target[0]), 'content from RCINIT_KW'])
      content = env[RCINIT_AUTOGEN_INFO_TEXT].format(
         scons_tool_name = __name__,
         scons_tool_version = __version_info__,
         scons_client_build_tags = [ _ent for _ent in kw[RCINIT_BUILD_TAGS] if env.IsTargetEnable(_ent) ] if RCINIT_BUILD_TAGS in kw else [],
         scons_client_defined_file = kw[RCINIT_INFO_DEFINED][TOOL_DEF_FILE] if RCINIT_INFO_DEFINED in kw else '',
         scons_client_defined_line = kw[RCINIT_INFO_DEFINED][TOOL_DEF_LINE] if RCINIT_INFO_DEFINED in kw else '',
         rcinit_info_name = kw[RCINIT_INFO_NAME] if RCINIT_INFO_NAME in kw else RCINIT_NULL,
         rcinit_info_api = kw[RCINIT_INFO_API] if RCINIT_INFO_API in kw else -1,
         rcinit_info_entry = kw[RCINIT_INFO_ENTRY] if RCINIT_INFO_ENTRY in kw else RCINIT_NULL,
         rcinit_info_plist = ' '.join([ '"%s",' % _ent for _ent in kw[RCINIT_INFO_PLIST]]) if RCINIT_INFO_PLIST in kw else '',
         rcinit_info_plist_size = len(kw[RCINIT_INFO_PLIST]) if RCINIT_INFO_PLIST in kw else 0,
         rcinit_info_dlist = ' '.join([ '"%s",' % _ent for _ent in kw[RCINIT_INFO_DLIST]]) if RCINIT_INFO_DLIST in kw else '',
         rcinit_info_dlist_size = len(kw[RCINIT_INFO_DLIST]) if RCINIT_INFO_DLIST in kw else 0,
         rcinit_info_hash = kw[RCINIT_INFO_HASH] if RCINIT_INFO_HASH in kw else 0,
         rcinit_info_group = kw[RCINIT_INFO_GROUP] if RCINIT_INFO_GROUP in kw else 0,
         rcinit_info_affinity = kw[RCINIT_INFO_AFFINITY] if RCINIT_INFO_AFFINITY in kw else '0',
         rcinit_info_prio = kw[RCINIT_INFO_PRIO] if RCINIT_INFO_PRIO in kw else '255',
         rcinit_info_prio_alias = kw[RCINIT_INFO_PRIO_ALIAS] if RCINIT_INFO_PRIO_ALIAS in kw else '',
         rcinit_info_stack_size = kw[RCINIT_INFO_STACK_SIZE] if RCINIT_INFO_STACK_SIZE in kw else 0,
         rcinit_info_stack_sect = kw[RCINIT_INFO_STACK_SECT] if RCINIT_INFO_STACK_SECT in kw else '.bss',
         rcinit_info_heap_slimit = kw[RCINIT_INFO_HEAP_SLIMIT] if RCINIT_INFO_HEAP_SLIMIT in kw else 0,
         rcinit_info_heap_hlimit = kw[RCINIT_INFO_HEAP_HLIMIT] if RCINIT_INFO_HEAP_HLIMIT in kw else 0,
         tcb_name = kw[THREAD_TCB] if THREAD_TCB in kw else RCINIT_NULL,
         stack_name = kw[THREAD_STACK] if THREAD_STACK in kw else RCINIT_NULL,
         define_rcinit_info_api_policyfn = 'define' if RCINIT_INFO_API in kw and RCINIT_INFO_API_POLICYFN == kw[RCINIT_INFO_API] else 'undef',
         define_rcinit_info_api_initfn = 'define' if RCINIT_INFO_API in kw and RCINIT_INFO_API_INITFN == kw[RCINIT_INFO_API] else 'undef',
         define_rcinit_info_api_task_dal = 'define' if RCINIT_INFO_API in kw and RCINIT_INFO_API_TASK_DAL == kw[RCINIT_INFO_API] else 'undef',
         define_rcinit_info_api_task_posix = 'define' if RCINIT_INFO_API in kw and RCINIT_INFO_API_TASK_POSIX == kw[RCINIT_INFO_API] else 'undef',
         define_rcinit_info_api_task_qurt = 'define' if RCINIT_INFO_API in kw and RCINIT_INFO_API_TASK_QURT == kw[RCINIT_INFO_API] else 'undef',
         define_rcinit_info_api_task_rex = 'define' if RCINIT_INFO_API in kw and RCINIT_INFO_API_TASK_REX == kw[RCINIT_INFO_API] else 'undef',
         define_rcinit_info_entry = 'define' if RCINIT_INFO_ENTRY in kw and RCINIT_NULL != kw[RCINIT_INFO_ENTRY] else 'undef',
         define_tcb_name = 'define' if THREAD_TCB in kw and RCINIT_NULL != kw[THREAD_TCB] else 'undef',
         define_stack_name = 'define' if THREAD_STACK in kw and RCINIT_NULL != kw[THREAD_STACK] else 'undef',
      )

   m = hashlib.md5()
   m.update(content)
   hash_this = m.hexdigest()

   hash_file = str(target[0]) + '.md5'

   hash_prev = ''
   try:
      with open(hash_file, 'r') as input:
         hash_prev = input.read()
   except:
      pass

   if hash_this != hash_prev:
      with open(str(target[0]), 'w') as output:
         output.write(env.CreateFileBanner(os.path.basename(str(target[0])), style='C'))
         output.write('\n')
         output.write(content)
      with open(hash_file, 'w') as output:
         output.write(hash_this)

   return 0

#===============================================================================

def tool_create_output_txt(target, source, env):
   ''' Output PL File '''
   env.TmsDebug([target])

   content = env['RCINIT_CONTENT']

   m = hashlib.md5()
   m.update(content)
   hash_this = m.hexdigest()

   hash_file = str(target[0]) + '.md5'

   hash_prev = ''
   try:
      with open(hash_file, 'r') as input:
         hash_prev = input.read()
   except:
      pass

   if hash_this != hash_prev:
      with open(str(target[0]), 'w') as output:
         output.write(content)
      with open(hash_file, 'w') as output:
         output.write(hash_this)

   return 0

#===============================================================================

def tool_load_autogen_template(target, source, env):

   input_content = ''
   env[RCINIT_AUTOGEN_TEMPLATE] = ''
   file = env.TmsGetPath(env.get('BUILD_ROOT'), RCINIT_AUTOGEN_TEMPLATE_FILE)[0]
   try:
      with open(file, 'r') as input:
         env[RCINIT_AUTOGEN_TEMPLATE] = file
         input_content = input.read()
   except:
      env.TmsError([RCINIT_POC_HBA, 'Fails!!'])

   text = re.findall(r'--RCPB--(.*?)--RCPB--', input_content, re.DOTALL | re.MULTILINE)
   env[RCINIT_AUTOGEN_RCPB_TEXT] = text[0]

   text = re.findall(r'--RCPL--(.*?)--RCPL--', input_content, re.DOTALL | re.MULTILINE)
   env[RCINIT_AUTOGEN_RCPL_TEXT] = text[0]

   text = re.findall(r'--INFO--(.*?)--INFO--', input_content, re.DOTALL | re.MULTILINE)
   env[RCINIT_AUTOGEN_INFO_TEXT] = text[0]

   env.TmsDebug([RCINIT_POC_HBA, 'autogen template', env[RCINIT_AUTOGEN_TEMPLATE]])

#===============================================================================

def tool_load_alias_map(target, source, env):
   ''' Load ALIAS MAP to Construction Environment '''

   env[RCINIT_PRIO_ALIAS_DICT] = {}

   file_alias_map = None

   # Locate Alias Mappings

   if source != None:
      file_alias_map = source
   elif env.PathExists('${BUILD_ROOT}/build/scripts/build_utils.py'):
      env.LoadToolScript('build_utils', toolpath = ['${BUILD_ROOT}/build/scripts'])
      file_alias_map = env.FindConfigFiles(RCINIT_PRIORITY_ALIAS_MAP_FILE)
      if file_alias_map != None and len(file_alias_map) != 0:
         file_alias_map = file_alias_map[0]
   elif env.has_key('IMAGE_ROOT'):
      if 0 < len(env.TmsGetPath(env.get('IMAGE_ROOT'), RCINIT_PRIORITY_ALIAS_MAP_FILE)):
         file_alias_map = env.TmsGetPath(env.get('IMAGE_ROOT'), RCINIT_PRIORITY_ALIAS_MAP_FILE)[0]
   else:
      env.TmsError([RCINIT_POC_HBA, 'IMAGE_ROOT not available'])

   # Warnings for Deprecated ALIAS MAP Existing in Build

   checkfile = env.TmsGetPath(env.get('IMAGE_ROOT'), 'rcinit_task_govern.csv')
   if 0 < len(checkfile):
      env.TmsDebug([RCINIT_POC_IO, 'ALIAS MAP remove obsolete copy at', checkfile])
   checkfile = env.TmsGetPath(env.get('IMAGE_ROOT'), 'rcinit_legacy_info.csv')
   if 0 < len(checkfile):
      env.TmsDebug([RCINIT_POC_IO, 'ALIAS MAP remove obsolete copy at', checkfile])
   checkfile = env.TmsGetPath(env.get('IMAGE_ROOT'), 'rcinit_task_prio.csv')
   if file_alias_map != None and 0 < len(checkfile) and not file_alias_map in checkfile:
      env.TmsDebug([RCINIT_POC_IO, 'ALIAS MAP remove obsolete copy at', checkfile])
   if file_alias_map == None:
      env.TmsDebug([RCINIT_POC_IO, 'ALIAS MAP absent'])
      return 0

   # Load Alias Mappings

   try:
      with open(file_alias_map, 'r') as file:
         reader = csv.DictReader(file)
         for row in reader:
            alias = row['TASK_LEGACY_AMSS_PRI_ORDER'].upper()
            order = row['NONHLOS_PRIORITY']
            if alias[0] != '#':
               if re.search('^[A-Z0-9_]+_PRI_ORDER$', alias) == None:
                  env.TmsDebug([RCINIT_POC_IO, 'ALIAS MAP entry must match naming scheme *_PRI_ORDER or use comment prefix "#" ', alias])
               if alias in env[RCINIT_PRIO_ALIAS_DICT].keys() and env[RCINIT_PRIO_ALIAS_DICT][alias] != order:
                  env.TmsError([RCINIT_POC_IO, 'ALIAS MAP duplicate alias', alias])
               if env.TmsIsInt(order):
                  env[RCINIT_PRIO_ALIAS_DICT][alias] = order
               else:
                  env.TmsError([RCINIT_POC_IO, 'ALIAS MAP non numeric mapping', alias])
   except:
      env.TmsError([RCINIT_POC_IO, 'ALIAS MAP error', file_alias_map])

   # Check Shared Priority Alias Mappings

   for pri_1 in valid_pri_order:
      if not pri_1 in env[RCINIT_PRIO_ALIAS_DICT].keys():
         if env.GetUsesFlag('USES_RCINIT_OPTION_CHECK_SHARED_PRI_ORDER'):
            env.TmsError([RCINIT_POC_IO, 'ALIAS MAP entry missing', pri_1])
         else:
            env.TmsDebug([RCINIT_POC_IO, 'ALIAS MAP entry missing', pri_1])
      for pri_2 in valid_pri_order:
         if pri_2 == pri_1:
            break
         if pri_2 in env[RCINIT_PRIO_ALIAS_DICT].keys() and pri_1 in env[RCINIT_PRIO_ALIAS_DICT].keys():
            if env.TmsToInt(env[RCINIT_PRIO_ALIAS_DICT][pri_1]) >= env.TmsToInt(env[RCINIT_PRIO_ALIAS_DICT][pri_2]):
               if env.GetUsesFlag('USES_RCINIT_OPTION_CHECK_SHARED_PRI_ORDER'):
                  env.TmsError([RCINIT_POC_IO, 'ALIAS MAP order wrong', pri_1, pri_2])
               else:
                  env.TmsDebug([RCINIT_POC_IO, 'ALIAS MAP order wrong', pri_1, pri_2])

   env[RCINIT_PRIO_ALIAS_FILE] = file_alias_map

#===============================================================================

def tool_cannonize_keyword(env, **kw):

   if RCINIT_BUILD_TAGS in kw:
      kw[RCINIT_BUILD_TAGS] = [ _ent for _ent in kw[RCINIT_BUILD_TAGS] if env.IsTargetEnable(_ent) ]
   else:
      env.TmsError([RCINIT_POC_TA, 'requires', RCINIT_BUILD_TAGS])

   for key in kw.keys():
      if key in RCINIT_KEYSMAP:
         kw[RCINIT_KEYSMAP[key]] = kw[key]
         #env.TmsDebug(['keyword remap', key, RCINIT_KEYSMAP[key]])
         #del kw[key]

   for key in kw.keys():
      if key in RCINIT_VALSMAP.keys():
         if kw[key] in RCINIT_VALSMAP[key].keys():
            #env.TmsDebug(['value remap', kw[key], RCINIT_VALSMAP[key][kw[key]]])
            kw[key] = RCINIT_VALSMAP[key][kw[key]]

   return kw

#===============================================================================

def kw_validate_name(env, **kw):
   IMAGE_NAME = env.get('IMAGE_NAME', None)
   if RCINIT_INFO_NAME in kw:
      kw[RCINIT_INFO_NAME] = kw[RCINIT_INFO_NAME].lower()
   else:
      env.TmsError([RCINIT_POC_TA, 'requires', RCINIT_INFO_NAME])
   kw[RCINIT_INFO_HASH] = '{:#x}'.format(env.TmsNameHash(kw[RCINIT_INFO_NAME]))
   for entry in env[IMAGE_NAME][RCINIT_INFOS_LIST]:
      if entry[RCINIT_INFO_NAME] == kw[RCINIT_INFO_NAME]:
         env.TmsDebug([RCINIT_POC_TA, 'Requires unique name', kw[RCINIT_INFO_NAME]])
   return kw

#===============================================================================

def kw_validate_plist(env, **kw):
   IMAGE_NAME = env.get('IMAGE_NAME', None)
   if not RCINIT_INFO_PLIST in kw:
      kw[RCINIT_INFO_PLIST] = RCINIT_POLICY_DEFAULT
   if not isinstance(kw[RCINIT_INFO_PLIST], list):
      env.TmsError([RCINIT_POC_TA, 'Create valid list', RCINIT_INFO_PLIST, kw[RCINIT_INFO_NAME]])
   kw[RCINIT_INFO_PLIST] = [ _ent.lower() for _ent in kw[RCINIT_INFO_PLIST] ]
   env[IMAGE_NAME][RCINIT_NOPOLICY_ORDERED_LIST][env.TmsToInt(RCINIT_INFO_GROUP_KEYS[kw[RCINIT_INFO_GROUP]])].append(kw)
   for policy in kw[RCINIT_INFO_PLIST]:
      if policy not in env[IMAGE_NAME][RCINIT_PLISTS_DICT]:
         env[IMAGE_NAME][RCINIT_PLISTS_DICT][policy] = [ [] for i in range(RCINIT_INFO_GROUP_MAX) ]
      env[IMAGE_NAME][RCINIT_PLISTS_DICT][policy][env.TmsToInt(RCINIT_INFO_GROUP_KEYS[kw[RCINIT_INFO_GROUP]])].append(kw)
   return kw

#===============================================================================

def kw_validate_dlist(env, **kw):
   if not RCINIT_INFO_DLIST in kw:
      kw[RCINIT_INFO_DLIST] = []
   if not isinstance(kw[RCINIT_INFO_DLIST], list):
      env.TmsError([RCINIT_POC_TA, 'Create valid list', RCINIT_INFO_DLIST, kw[RCINIT_INFO_NAME]])
   kw[RCINIT_INFO_DLIST] = [ _ent.lower() for _ent in kw[RCINIT_INFO_DLIST] ]
   kw[RCINIT_INFO_DLISTSZ] = len(kw[RCINIT_INFO_DLIST])
   return kw

#===============================================================================

def kw_validate_group(env, **kw):
   if not RCINIT_INFO_GROUP in kw or not kw[RCINIT_INFO_GROUP] in RCINIT_INFO_GROUP_KEYS.keys():
      env.TmsError([RCINIT_POC_TA, 'Use a valid group for', kw[RCINIT_INFO_NAME]])
   return kw

#===============================================================================

def kw_validate_entry(env, **kw):
   if RCINIT_INFO_API in kw and RCINIT_INFO_API_POLICYFN == kw[RCINIT_INFO_API]:
      if not RCINIT_INFO_ENTRY in kw:
         kw[RCINIT_INFO_ENTRY] = kw[RCINIT_INFO_NAME] + '_policy'
         env.TmsDebug([RCINIT_POC_TA, 'Create explicit entry point for', kw[RCINIT_INFO_NAME]])
      kw[RCINIT_INFO_AFFINITY] = RCINIT_AFFINITY_ALL
      kw[THREAD_TCB] = RCINIT_NULL
   if RCINIT_INFO_API in kw and RCINIT_INFO_API_INITFN == kw[RCINIT_INFO_API]:
      if not RCINIT_INFO_ENTRY in kw:
         kw[RCINIT_INFO_ENTRY] = kw[RCINIT_INFO_NAME] + '_init'
         env.TmsDebug([RCINIT_POC_TA, 'Create explicit entry point for', kw[RCINIT_INFO_NAME]])
      kw[RCINIT_INFO_AFFINITY] = RCINIT_AFFINITY_ALL
      kw[THREAD_TCB] = RCINIT_NULL
   if RCINIT_INFO_API in kw and kw[RCINIT_INFO_API] in RCINIT_INFO_API_TASK:
      if not RCINIT_INFO_ENTRY in kw:
         kw[RCINIT_INFO_ENTRY] = kw[RCINIT_INFO_NAME] + '_task'
         env.TmsDebug([RCINIT_POC_TA, 'Create explicit entry point for', kw[RCINIT_INFO_NAME]])
      if not RCINIT_INFO_AFFINITY in kw:
         kw[RCINIT_INFO_AFFINITY] = RCINIT_AFFINITY_ALL
      else:
         env.TmsDebug([RCINIT_POC_TA, 'Remove NHLOS affinity that is not applicable for', kw[RCINIT_INFO_NAME]])
      if not THREAD_TCB in kw:
         if RCINIT_INFO_API == RCINIT_INFO_API_TASK_REX:
            kw[THREAD_TCB] = kw[RCINIT_INFO_NAME] + '_tcb'
         else:
            kw[THREAD_TCB] = RCINIT_NULL
      else:
         env.TmsDebug([RCINIT_POC_TA, 'Do not create explicit TCB definition for', kw[RCINIT_INFO_NAME]])
   return kw

#===============================================================================

def kw_validate_stack(env, **kw):
   if RCINIT_INFO_API in kw and kw[RCINIT_INFO_API] in RCINIT_INFO_API_TASK:
      if not RCINIT_INFO_STACK_SIZE in kw or not env.TmsIsInt(kw[RCINIT_INFO_STACK_SIZE]):
         env.TmsError([RCINIT_POC_TA, 'Use a valid stack size for', kw[RCINIT_INFO_NAME]])
      if not THREAD_STACK in kw:
         kw[THREAD_STACK] = RCINIT_NULL
         if env.GetUsesFlag('USES_RCINIT_OPTION_STATIC_STACK') and RCINIT_NULL != kw[RCINIT_INFO_ENTRY]:
            kw[THREAD_STACK] = 'stack_' + kw[RCINIT_INFO_NAME]
      else:
         env.TmsDebug([RCINIT_POC_TA, 'Do not create explicit STACK definition for', kw[RCINIT_INFO_NAME]])
   else:
      kw[RCINIT_INFO_STACK_SIZE] = RCINIT_STKSZ_ZERO
      kw[THREAD_STACK] = RCINIT_NULL
   if not RCINIT_INFO_STACK_SECT in kw:
      kw[RCINIT_INFO_STACK_SECT] = RCINIT_STACK_SECTION + kw[RCINIT_INFO_NAME]
   return kw

#===============================================================================

def kw_validate_prio(env, **kw):
   if RCINIT_INFO_API in kw and RCINIT_INFO_API_POLICYFN == kw[RCINIT_INFO_API]:
      kw[RCINIT_INFO_PRIO] = RCINIT_PRIO_POLICYFN
      kw[RCINIT_INFO_PRIO_ALIAS] = RCINIT_PRIO_POLICYFN
   if RCINIT_INFO_API in kw and RCINIT_INFO_API_INITFN == kw[RCINIT_INFO_API]:
      kw[RCINIT_INFO_PRIO] = RCINIT_PRIO_INITFN
      kw[RCINIT_INFO_PRIO_ALIAS] = RCINIT_PRIO_INITFN
   if RCINIT_INFO_API in kw and kw[RCINIT_INFO_API] in RCINIT_INFO_API_TASK:
      if RCINIT_INFO_PRIO_ALIAS in kw and kw[RCINIT_INFO_PRIO_ALIAS] in env[RCINIT_PRIO_ALIAS_DICT].keys():
         kw[RCINIT_INFO_PRIO] = env[RCINIT_PRIO_ALIAS_DICT][kw[RCINIT_INFO_PRIO_ALIAS]]
         env.TmsDebug([RCINIT_POC_TA, 'ALIAS MAP referenced for', kw[RCINIT_INFO_NAME]])
      elif RCINIT_INFO_PRIO in kw and kw[RCINIT_INFO_PRIO] in env[RCINIT_PRIO_ALIAS_DICT].keys():
         kw[RCINIT_INFO_PRIO_ALIAS] = kw[RCINIT_INFO_PRIO]
         kw[RCINIT_INFO_PRIO] = env[RCINIT_PRIO_ALIAS_DICT][kw[RCINIT_INFO_PRIO]]
         env.TmsDebug([RCINIT_POC_TA, 'ALIAS MAP referenced for', kw[RCINIT_INFO_NAME]])
      elif RCINIT_INFO_PRIO in kw and env.TmsIsInt(kw[RCINIT_INFO_PRIO]):
         kw[RCINIT_INFO_PRIO] = kw[RCINIT_INFO_PRIO]
         kw[RCINIT_INFO_PRIO_ALIAS] = kw[RCINIT_INFO_PRIO]
         if env.GetUsesFlag('USES_RCINIT_OPTION_FORCE_ALIASMAP'):
            env.TmsError([RCINIT_POC_TA, 'ALIAS MAP not referenced for', kw[RCINIT_INFO_NAME]])
         else:
            env.TmsDebug([RCINIT_POC_TA, 'ALIAS MAP not referenced for', kw[RCINIT_INFO_NAME]])
      else:
         env.TmsError([RCINIT_POC_TA, 'ALIAS MAP entry required for', kw[RCINIT_INFO_NAME]])
      if ('SHARED_IST_PRI_ORDER' in env[RCINIT_PRIO_ALIAS_DICT].keys() and
         env.TmsToInt(kw[RCINIT_INFO_PRIO]) > env.TmsToInt(env[RCINIT_PRIO_ALIAS_DICT]['SHARED_IST_PRI_ORDER'])):
         if env.GetUsesFlag('USES_RCINIT_OPTION_CHECK_SHARED_PRI_ORDER'):
            env.TmsError([RCINIT_POC_TA, 'Use ALIAS MAP SHARED_IST_PRI_ORDER or lower', kw[RCINIT_INFO_NAME]])
         else:
            env.TmsDebug([RCINIT_POC_TA, 'Use ALIAS MAP SHARED_IST_PRI_ORDER or lower', kw[RCINIT_INFO_NAME]])
      elif ('SHARED_IDLE_SERVICE_PRI_ORDER' in env[RCINIT_PRIO_ALIAS_DICT].keys() and
         env.TmsToInt(kw[RCINIT_INFO_PRIO]) < env.TmsToInt(env[RCINIT_PRIO_ALIAS_DICT]['SHARED_IDLE_SERVICE_PRI_ORDER'])):
         if env.GetUsesFlag('USES_RCINIT_OPTION_CHECK_SHARED_PRI_ORDER'):
            env.TmsError([RCINIT_POC_TA, 'Use ALIAS MAP SHARED_IDLE_SERVICE_PRI_ORDER or higher', kw[RCINIT_INFO_NAME]])
         else:
            env.TmsDebug([RCINIT_POC_TA, 'Use ALIAS MAP SHARED_IDLE_SERVICE_PRI_ORDER or higher', kw[RCINIT_INFO_NAME]])
   return kw
