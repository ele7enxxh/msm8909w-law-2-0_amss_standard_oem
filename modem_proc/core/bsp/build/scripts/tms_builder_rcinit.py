# vi: tw=128 ts=3 sw=3 et :
# @file tms_builder_rcinit.py
# @brief This file contains the API for the Run Control Framework, API 3.0
#===============================================================================
# NOTE: The @brief description above does not appear in the PDF.
# The tms_mainpage.dox file contains the group/module descriptions that
# are displayed in the output PDF generated using Doxygen and LaTeX. To
# edit or update any of the group/module text in the PDF, edit the
# tms_mainpage.dox file or contact Tech Pubs.
#===============================================================================
#===============================================================================
# Copyright (c) 2015 Qualcomm Technologies Incorporated.
# All Rights Reserved.
# Qualcomm Confidential and Proprietary.
#===============================================================================
#===============================================================================
# Edit History
# $Header: //components/rel/core.mpss/3.5.c12.3/bsp/build/scripts/tms_builder_rcinit.py#1 $
# $DateTime: 2016/12/13 07:59:23 $
# $Change: 11985146 $
# $Author: mplcsds1 $
#===============================================================================

# Module Version, Python Standard PEP8, 2001, https://www.python.org/dev/peps/pep-0008/
__version__ = "$Header: //components/rel/core.mpss/3.5.c12.3/bsp/build/scripts/tms_builder_rcinit.py#1 $"

# Shared Library Version, Semantic Versioning 2.0.0, http://semver.org/
__version_info__ = "0.0.0"

# NOTE: Debug instruments exposed by adding to command line as
# build.cmd build_target BUILD_VER=00000 --debug=stacktrace --debuginfo=rcinit

#===============================================================================
# Description
#===============================================================================

# This SCONS tool is the build time support for the RCINIT Framework;
# client users to the framework will supply within their software
# delivery at least one call to this tool. The tool includes a number
# of pseudo builder method calls for use by the clients. The input to
# the pseudo builder method calls is used for the final target
# output, an autogenerated C source file.
#
# The tool collates input from PLAYLIST content, and generates a
# PLAYBOOK.
#
# PLAYLIST : Input (eg, SCONS File Metadata, Intermediate Output RCPL)
# SCONS File Metadata optionally is captured as intermediate output
#
# PLAYBOOK : Output (eg, C Source Module)
#
# Includes various warning messages that can be detected at build
# time. The warnings identify potential issues at runtime where the
# software could potentially have issues -- due to name size
# overruns, non-unique string names to the critial length, etc...

#===============================================================================
# Examples
#===============================================================================

# Use Case: Task, REX API Task (RCINIT V1/V2) Playlist Entry
#---------------------------------------------------------------
#
#if 'USES_RCINIT' in env and 'USES_REX' in env:
# env.AddRCInitTask( # SCONS METADATA PLAYLIST
#  RCINIT_IMG,
#  {
#   'sequence_group'             : 'RCINIT_GROUP_6',
#   'thread_name'                : 'rcinit_exrex',
#   'thread_type'                : 'RCINIT_TASK_REXTASK',
#   'thread_entry'               : 'rcinit_example_rextask',   # REQUIRED
#   'priority_amss_order'        : 'RCINIT_PRI_ORDER',         # aka alias_map entry
#   'stack_size_bytes'           : '4096',
#   'policy_optin'               : [ 'default', 'ftm', ],      # V2
#  })

# Use Case: Task, REX API Task (RCINIT V1/V2) Playlist Entry 'Dynamic' Use Case
#---------------------------------------------------------------
#
#if 'USES_RCINIT' in env and 'USES_REX' in env:
# env.AddRCInitTask( # SCONS METADATA PLAYLIST
#  RCINIT_IMG,
#  {
#   'sequence_group'             : 'RCINIT_GROUP_6',
#   'thread_name'                : 'rcinit_exrex',
#   'thread_type'                : 'RCINIT_TASK_REXTASK',
#   'thread_entry'               : 'RCINIT_NULL',              # REQUIRED: NO ENTRY POINT
#   'priority_amss_order'        : 'RCINIT_PRI_ORDER',         # aka alias_map entry
#   'stack_size_bytes'           : '4096',
#   'policy_optin'               : [ 'default', 'ftm', ],      # V2
#  })

# 'thread_entry' : 'RCINIT_NULL', is required.

# Runtime accessor calls are used by the TECHNOLOGY TEAM to query the build
# time database for priority and stack size information. See RCINIT.H API for
# further information on rcinit_lookup* functions available per PL, and per
# KERNEL API.

# Use Case: Initialization Function (RCINIT V1/V2) Playlist Entry
#---------------------------------------------------------------
#
#if 'USES_RCINIT' in env:
# env.AddRCInitFunc( # SCONS METADATA PLAYLIST
#  RCINIT_IMG,
#  {
#   'sequence_group'             : 'RCINIT_GROUP_7',
#   'init_name'                  : 'rcinit_exifn7',
#   'init_function'              : 'rcinit_example_initfn',
#   'policy_optin'               : [ 'default', 'ftm', ],       # V2
#  })

# Use Case: Task, DAL Workloop API (RCINIT V2) Playlist Entry
#---------------------------------------------------------------
#
#if 'USES_RCINIT' in env and 'USES_DAL' in env:
# env.AddRCInitTask( # SCONS METADATA PLAYLIST
#  RCINIT_IMG,
#  {
#   'sequence_group'             : 'RCINIT_GROUP_6',
#   'thread_name'                : 'rcinit_exdal',
#   'thread_type'                : 'RCINIT_TASK_DALTASK',
#   'thread_entry'               : 'rcinit_example_daltask',   # REQUIRED
#   'priority_amss_order'        : 'RCINIT_PRI_ORDER',         # aka alias_map entry
#   'stack_size_bytes'           : '4096',
#   'policy_optin'               : [ 'default', 'ftm', ],
#  })

# Use Case: Task, POSIX Pthread API (RCINIT V2) Playlist Entry
#---------------------------------------------------------------
#
#if 'USES_RCINIT' in env and 'USES_POSIX' in env:
#  env.AddRCInitTask( # SCONS METADATA PLAYLIST
#   RCINIT_IMG,
#   {
#    'sequence_group'             : 'RCINIT_GROUP_6',
#    'thread_name'                : 'rcinit_expthr',
#    'thread_type'                : 'RCINIT_TASK_POSIX',
#    'thread_entry'               : 'rcinit_example_posix',    # REQUIRED
#    'priority_amss_order'        : 'RCINIT_PRI_ORDER',        # aka alias_map entry
#    'stack_size_bytes'           : '4096',
#    'policy_optin'               : [ 'default', 'ftm', ],
#   })

# Use Case: Task, QURT Thread API (RCINIT V2) Playlist Entry
#---------------------------------------------------------------
#
#if 'USES_RCINIT' in env and 'USES_QURT' in env:
# env.AddRCInitTask( # SCONS METADATA PLAYLIST
#  RCINIT_IMG,
#  {
#   'sequence_group'             : 'RCINIT_GROUP_6',
#   'thread_name'                : 'rcinit_exqurt',
#   'thread_type'                : 'RCINIT_TASK_QURTTASK',
#   'thread_entry'               : 'rcinit_example_qurttask',  # REQUIRED
#   'priority_amss_order'        : 'RCINIT_PRI_ORDER',         # aka alias_map entry
#   'stack_size_bytes'           : '4096',
#   'policy_optin'               : [ 'default', 'ftm', ],
#  })

# Use Case: Policy Function (RCINIT V2) Playlist Entry
#---------------------------------------------------------------
#
#if 'USES_RCINIT' in env:
# env.AddRCInitPolicy( # SCONS METADATA PLAYLIST
#  RCINIT_IMG,
#  {
#   'sequence_group'             : 'RCINIT_GROUP_3',
#   'policy_name'                : 'DEFAULT_POLICY',
#   'policy_function'            : 'rcinit_example_policyfn',
#   'policy_optin'               : [ 'default', 'ftm', ],
#  })

#===============================================================================
# IMAGE OWNER Installation Notes, Best Practices
#===============================================================================

# RCINIT Shared Objects
# ----------------------------------------
#
# IMAGE OWNER will:
#
# 1. Define USES_RCINIT_OPTION_PLAYBOOK_SHARED_OBJECT in the image level SCONS build file near
# the scons tools loading. Enabling the extension will enforce priority aliases to be
# used by the TECHNOLOGY TEAM. All priority aliases are configured by the IMAGE OWNER.
#
#  # Before the first occurrence of env.LoadSoftwareAreaUnits() with other
#  # env.AddUsesFlags() calls:
#
#  env.AddUsesFlags(...)
#  env.AddUsesFlags('USES_RCINIT_OPTION_PLAYBOOK_SHARED_OBJECT')
#
# 2. Use instructions below for Playbook/Playlist, but substitute in the expected behaviors
# using SCONS tools env.AddRCInitPlaybook(), env.AddSharedObject().

# RCINIT Force Priority ALIAS MAP Extension
# ----------------------------------------
#
# IMAGE OWNER will:
#
# 1. Define USES_RCINIT_OPTION_FORCE_ALIASMAP in the image level SCONS build file near
# the scons tools loading. Enabling the extension will enforce priority aliases to be
# used by the TECHNOLOGY TEAM. All priority aliases are configured by the IMAGE OWNER.
#
#  # Before the first occurrence of env.LoadSoftwareAreaUnits() with other
#  # env.AddUsesFlags() calls:
#
#  env.AddUsesFlags(...)
#  env.AddUsesFlags('USES_RCINIT_OPTION_FORCE_ALIASMAP')
#
# 2. Insure that changes are applicable to all image level SCONS build files which
# enforce the policy. This includes *_img.scons files as well as *_libs.scons files.
# Enforced use of the priority alias mapping is performed per software area.
#
# 3. (OPTIONAL) When IMAGE OWNER misconfigures the following 'SYSTEM' priority ordering policy in
# he ALIAS MAP reporting is triggered for triage. The ordering policy below reflects from
# highest to lowest an order from the system perspective. Invalid configuratioin is
# reported for the IMAGE OWNER to correct. Only the order of the SHARED_* priority ALIAS
# MAP entries are checked. There will not be individual checking for TECH AREA specific
# tasks -- the TECH AREA can make reference to one of the following ALIAS MAP entries
# when configuration of priority order is important.
#
# 'SYSTEM' ALIAS MAP Entry                Name             Acronym  Description
# SHARED_IST_PRI_ORDER                    Uber High High   UHH      Interrupt (Logical match for "~DOG_PRI_ORDER, ~TIMER_PRI_ORDER")
# SHARED_IST_SERVICE_PRI_ORDER            Uber High Low    UHL      Interrupt Services
# SHARED_DRIVER_PRI_ORDER                 High High        HH       Device Driver
# SHARED_DRIVER_SERVICE_PRI_ORDER         High Low         HL       Device Driver Services
# SHARED_FOREGROUND_PRI_ORDER             Nominal High     NH       Foreground Running
# SHARED_FOREGROUND_SERVICE_PRI_ORDER     Nominal Low      NL       Foreground Running Services
# SHARED_BACKGROUND_PRI_ORDER             Low High         LH       Background Running
# SHARED_BACKGROUND_SERVICE_PRI_ORDER     Low Low          LL       Background Running Services
# SHARED_IDLE_PRI_ORDER                   Unter Low High   ULH      Idle
# SHARED_IDLE_SERVICE_PRI_ORDER           Unter Low Low    ULL      Idle Services (Logical match for "~SLEEP_PRI_ORDER+1")
#
# Priority alias mapping with RCINIT Framework uses ordering that follows from the set
# defined [HIGHEST(255) .. LOWEST(0)] reguardless of how the NHLOS defines priority.
# NHLOS priority mapping is supplied at runtime as necessary only at task creation.
#
# (OPTIONAL) SHARED_*_PRI_ORDER Checking enabled via USES_RCINIT_OPTION_CHECK_SHARED_PRI_ORDER
# (OPTIONAL) Enforces NHLOS Name Limit via USES_RCINIT_OPTION_CHECK_NHLOS_UNIQUE
#
# TECHNOLOGY TEAM will:
#
# 1. Insure that the task priority alias used for env.AddRCInitTask() metadata for
# 'priority_amss_order' is a string alias, and is already located within the configured
# priority ALIAS MAP supplied for the image. The priority aliases are configured by the
# IMAGE OWNER. Failure to use a recognised priority alias by name will result in an
# incomplete build.
#
# 2. Not utilize priority alone as the exclusive method to protect any shared resource.
# Priority alone is not a sufficient runtime tool to supply adequate shared resource
# protection; the TECHNOLOGY TEAM will supply adequate runtime protection to the shared
# resource by use of an appropriate runtime KERNEL API. Such use can include KERNEL API
# supplied for mutex, semaphore, barrier, critical section, spinlock, ... as protection
# of the shared resource. TECHNOLOGY TEAM must assume that IMAGE OWNER may arbitrarily
# manipulate the priority ALIAS MAP without any type of TECHNOLOGY TEAM involvement.
#
# 3. Range check runtime priority against results supplied from calls to a runtime
# KERNEL API where priority is utilized as one of many methods in protecting a shared
# resource. The TECHNOLOGY TEAM is encouraged to use runtime KERNEL API to query
# runtime priority and verify the result is within an expected range.

# RCINIT Static Stack Extension
# ----------------------------------------
#
#  IMAGE OWNER will:
#
# 1. Define USES_RCINIT_OPTION_STATIC_STACK in the image level SCONS build file near the
# the SCONS tools loading.
#
#  # Before the first occurrence of env.LoadSoftwareAreaUnits() with other
#  # env.AddUsesFlags() calls:
#
#  env.AddUsesFlags(...)
#  env.AddUsesFlags('USES_RCINIT_OPTION_STATIC_STACK')
#
# 2. Alter the heap resource size to reduce heap resource over commitment. Typically
# this information is located in the config directory. One general file cust_config.xml
# may contain heap size information that requires the size to be reduced. The stacks supplied
# by RCINIT by default are heap resource allocations, so it is imperative to not over commit
# heap resource when the stacks are changed to static allocations to avoid crashing.
#
# 3. Verify the linker control script (scatter link file) to insure that there is an
# appropriate mapping for stack sections to be allocated in .bss.stack_* area. The task data
# sections are expected to be allocated to .bss.task_*. Typical linker control scripts
# templates are typically located in the config directory.
#
# 4. IMAGE OWNER may optionally relocate individual stacks on a per task basis by altering
# the link control script to refer to the individual sections by name, the section suffix
# is related to the task name. The default stack section name is .bss.stack_TASKNAME where
# the IMAGE OWNER will replace TASKNAME. This can have implications on targets that require
# task stacks to be present in non-paged on-chip memory for example.
#
# 5. IMAGE OWNER may optionally relocate individual task control data on a per task basis
# by altering the link control script to refer to the individual sections by name, the
# section suffix is related to the task name. The default data section prefix is
# .bss.task_TASKNAME where the IMAGE OWNER will replace TASKNAME. This can have implications
# on targets that require specific task control blocks to be present in non-paged on-chip
# memory for example.

# RCINIT Playbook Extension
# ----------------------------------------
#
# 1. Insure build_tags is the variable name that is used to reflect
# the list of build tag aliases associated to the image/library.
# Edit the scons file if necessary; do not attempt to use a different
# variable name.
#
# build_tags = [ ... ]
#
# 2. BUILD TAGS ARE IMPORTANT; if any specific intermediate output
# is not present, or empty (0 bytes size), that is an indication that
# the build_tags list may not match client specified build_tags. Have
# the TECH AREA *add* a specific build_tag alias to the TECH AREA SCONS
# build file. An IMAGE OWNER should never add a TECH AREA build tag to
# the SCONS file of the image/library.
#
# 3. Edit the InitImageVars() parameters to specify 'build_tags = build_tags'
# The IMAGE OWNER needs to own and protect build_tags from arbitrary
# modification. BUILD TAGS ARE IMPORTANT.
#
# 4. Edit the InitImageVars() parameters to specify 'dnt_builder.py' is
# included with the list of other tools.
#
#env.InitImageVars(
#   ...
#   build_tags = build_tags,
#   ...
#   tools = ['buildspec_builder.py',
#            ...,
#            '${BUILD_ROOT}/core/bsp/build/scripts/dnt_builder.py',
#            ...,
#   )
#
# 5. Edit the UsesFlags section to include the following line. It must
# follow the InitImageVars() call, and it must precede all LoadAreaSoftwareUnits()
# calls. When there are no LoadAreaSoftwareUnits() calls, it must precede all
# link steps in the *_img.scons file.
#
#  # Before the first occurrence of env.LoadSoftwareAreaUnits() with other
#  # env.AddUsesFlags() calls:
#
#  env.AddUsesFlags(...)
#  env.AddUsesFlags('USES_RCINIT_OPTION_PLAYBOOK')
#
# For every IMAGE being created (*_img.scons)
#
# 6. Copy, Paste the following fragment into *_img.scons files.
#
# 7. There should be limited modification to the SCONS scripting below.
# Modify Variable PLAYLISTS only to reference intermediate outputs by path.
# Do not modify or decorate any of the output files; TECH AREAs have expectations
# of existing names. Do not pollute the inherited construction environment with
# changes to CFLAGS, RequiredPublicApi(), or RequireRestrictedApi(). Construction
# environment of the *_img.scons file is inherited to all dependents loaded.

"""
#--- RCINIT Playbook Extension, Image Specific Details --------------------- BEG

# Preceeds all LoadAreaSoftwareUnits().
#---------------------------------------------------------------
env.AddUsesFlags('USES_RCINIT_OPTION_PLAYBOOK')
#---------------------------------------------------------------

# LoadAreaSoftwareUnits()

#---------------------------------------------------------------
# Follows all LoadAreaSoftwareUnits(). Precedes Link Step Details.
# IMAGE OWNER supplies PLAYLISTS. Avoid other customization this step.
#---------------------------------------------------------------

PLAYLISTS = [ # IMAGE_OWNER ADDS SPECIFIC PLAYLISTS, ONE PER LIBRARY, EXPLICIT, NOT AUTO_MAGIC
   '${BUILD_ROOT}/build/bsp/core_root_libs/build/AAAAAAAA/rcinit_playlist.rcpl', # LIBRARY EXPANDS AS $SHORT_BUILDPATH
   #'${BUILD_ROOT}/build/bsp/ssc_root_libs/build/AAAAAAAA/rcinit_playlist.rcpl', # LIBRARY EXPANDS AS $SHORT_BUILDPATH
]

# FOR SCONS TOOL EMITTERS TO PLACE OUTPUT PROPERLY
if not os.path.exists(env.RealPath('${SHORT_BUILDPATH}')):
   if Execute(Mkdir(env.RealPath('${SHORT_BUILDPATH}'))):
      raise Exception('HOST BUILD ENVIRONMENT, Fails Directory Creation')

# ONLY WHEN DNT_BUILDER SCONS TOOL LOADED
if 'USES_RCINIT' in env and 'USES_RCINIT_OPTION_PLAYBOOK' in env:

   # NEVER POLLUTE ENV CONSTRUCTION ENVIRONMENT WHICH GETS INHERITED
   playbook_env = env.Clone()

   # PLAYBOOK C OUTPUT THIS IMAGE (REQUIRED)
   rcinit_out_c = playbook_env.RealPath('${SHORT_BUILDPATH}/rcinit_autogen.c')
   playbook_env.AddRCInitPlaybook(build_tags, rcinit_out_c, PLAYLISTS)
   rcinit_obj = playbook_env.AddObject(build_tags, rcinit_out_c)
   playbook_env.Depends(build_tags, rcinit_out_c)     # Manage explicit detail outside of AreaUnit
   image_objs.append(rcinit_obj)                      # Manage explicit detail outside of AreaUnit

   # PLAYBOOK TXT OUTPUT THIS IMAGE (REQUIRED)
   rcinit_out_txt = playbook_env.RealPath('${SHORT_BUILDPATH}/${TARGET_NAME}_rcinit_output_log.txt')
   playbook_env.AddRCInitPlaybook(build_tags, rcinit_out_txt, None)
   playbook_env.AddArtifact(build_tags, rcinit_out_txt)
   playbook_env.Depends(build_tags, rcinit_out_txt)   # Manage explicit detail outside of AreaUnit
   image_units.append(rcinit_out_txt)                 # Manage explicit detail outside of AreaUnit

#--- RCINIT Playbook Extension, Image Specific Details --------------------- END
"""

# For every LIBRARY being created (*_libs.scons)
#
# 8. Copy, Paste the following fragment into *_libs.scons files.
#
# 9. There should be no modification to the SCONS scripting below.
# Do not modify or decorate any of the output files; TECH AREAs have expectations
# of existing names. Do not pollute the inherited construction environment with
# changes to CFLAGS, RequiredPublicApi(), or RequireRestrictedApi(). Construction
# environment of the *_libs.scons file is inherited to all dependents loaded.

"""
#--- RCINIT Playbook Extension, Library Specific Details ------------------- BEG

# Preceeds all LoadAreaSoftwareUnits().
#---------------------------------------------------------------
env.AddUsesFlags('USES_RCINIT_OPTION_PLAYBOOK')
#---------------------------------------------------------------

# LoadAreaSoftwareUnits()

#---------------------------------------------------------------
# Follows all LoadAreaSoftwareUnits(). Precedes Link Step Details.
# IMAGE OWNER supplies PLAYLISTS. Avoid other customization this step.
#---------------------------------------------------------------

PLAYLISTS = [ ] # NONE USED

# FOR SCONS TOOL EMITTERS TO PLACE OUTPUT PROPERLY
if not os.path.exists(env.RealPath('${SHORT_BUILDPATH}')):
   if Execute(Mkdir(env.RealPath('${SHORT_BUILDPATH}'))):
      raise Exception('HOST BUILD ENVIRONMENT, Fails Directory Creation')

# ONLY WHEN DNT_BUILDER SCONS TOOL LOADED
if 'USES_RCINIT' in env and 'USES_RCINIT_OPTION_PLAYBOOK' in env:

   # NEVER POLLUTE ENV CONSTRUCTION ENVIRONMENT WHICH GETS INHERITED
   playlist_env = env.Clone()

   # PLAYLIST OUTPUT THIS LIBRARY
   rcinit_out_rcpl = playlist_env.RealPath('${SHORT_BUILDPATH}/rcinit_playlist.rcpl')
   playlist_env.AddRCInitPlaylist(build_tags, rcinit_out_rcpl)
   playlist_env.AddArtifact(build_tags, rcinit_out_rcpl)
   playlist_env.Depends(build_tags, rcinit_out_rcpl)     # Manage explicit detail outside of AreaUnit
   image_units.append(rcinit_out_rcpl)                   # Manage explicit detail outside of AreaUnit

   # PLAYBOOK TXT OUTPUT THIS LIBRARY
   rcinit_out_txt = playlist_env.RealPath('${SHORT_BUILDPATH}/rcinit_playlist.txt')
   playlist_env.AddRCInitPlaybook(build_tags, rcinit_out_txt, None)
   playlist_env.AddArtifact(build_tags, rcinit_out_txt)
   playlist_env.Depends(rcinit_out_txt, rcinit_out_rcpl) # Manage explicit detail outside of AreaUnit
   image_units.append(rcinit_out_txt)                    # Manage explicit detail outside of AreaUnit

#--- RCINIT Playbook Extension, Library Specific Details ------------------- END
"""

#===============================================================================
# Module Imports
#===============================================================================

import os
import sys
import socket
import csv
import fnmatch
from SCons.Script import *
import operator
from operator import itemgetter
from collections import OrderedDict
import inspect
import re
import hashlib

#===============================================================================
# Module Scope Definitions
#===============================================================================

RCINIT_USES_FLAG = 'USES_RCINIT'
RCINIT_PRIORITY_ALIAS_MAP_FILE = 'rcinit_task_prio.csv' # Required, IMAGE OWNER delivered

RCINIT_DEPENDENCIES = 'dependencies'            # TECH AREA supplied (optional)
RCINIT_SEQUENCE_GROUP = 'sequence_group'        # TECH AREA supplied
RCINIT_POLICY_OPTIN = 'policy_optin'            # TECH AREA supplied (optional)
RCINIT_POLICY_DEFAULT = ['default']

THREAD_NAME = 'thread_name'                     # TECH AREA supplied
THREAD_ENTRY = 'thread_entry'                   # TECH AREA supplied
THREAD_TCB = 'tcb_name'                         # TECH AREA supplied (deprecated)
THREAD_STACK = 'stack_size_bytes'               # TECH AREA supplied
THREAD_STACK_STATIC = 'stack_section'           # TECH AREA supplied
THREAD_PRIORITY = 'priority_amss_order'         # TECH AREA supplied
THREAD_PRIORITY_ALIAS = 'priority_amss_order_enum' # TECH AREA supplied
THREAD_AFFINITY = 'cpu_affinity'                # TECH AREA supplied (deprecated)
THREAD_HEAP_QUOTA = 'heap_quota_bytes'          # TECH AREA supplied

THREAD_API = 'thread_type'                      # TECH AREA supplied
THREAD_API_POSIX = 'RCINIT_TASK_POSIX'
THREAD_API_REX = 'RCINIT_TASK_REXTASK'
THREAD_API_QURT = 'RCINIT_TASK_QURTTASK'
THREAD_API_DAL = 'RCINIT_TASK_DALTASK'
THREAD_API_FUNC = 'RCINIT_TASK_INITFN'
THREAD_API_POLICY = 'RCINIT_TASK_POLICYFN'
THREAD_API_TYPES = [THREAD_API_POSIX, THREAD_API_REX, THREAD_API_QURT, THREAD_API_DAL, THREAD_API_FUNC]

INIT_NAME = 'init_name'                         # TECH AREA supplied
INIT_ENTRY = 'init_function'                    # TECH AREA supplied

POLICY_NAME = 'policy_name'                     # IMAGE OWNER supplied
POLICY_ENTRY = 'policy_function'                # IMAGE OWNER supplied

RCINIT_INFO_NAME = 'name'                       # internal key
RCINIT_INFO_TYPE = 'type'                       # internal key
RCINIT_INFO_HASH = 'hash'                       # internal key
RCINIT_INFO_GROUP = 'group'                     # internal key
RCINIT_INFO_API = 'api'                         # internal key
RCINIT_INFO_ENTRY = 'entry'                     # internal key
RCINIT_INFO_DEPENDENCY = 'dependency'           # internal key
RCINIT_INFO_POLICY = 'policy'                   # internal key
RCINIT_INFO_FUNCTION = 'function'               # internal key
RCINIT_INFO_TASK = 'task'                       # internal key
RCINIT_INFO_PRIORITY = 'priority'               # internal key
RCINIT_INFO_PRIORITY_ALIAS = 'priority_alias'   # internal key
RCINIT_INFO_STACK = 'stack'                     # internal key
RCINIT_INFO_STACK_STATIC = 'section'            # internal key
RCINIT_INFO_AFFINITY = 'affinity'               # internal key
RCINIT_INFO_HEAP_QUOTA = 'heap_quota'           # internal key
RCINIT_INFO_DEFINED = 'defined'                 # internal key

RCINIT_DEPENDENCIES_FILTER = 'dependencies_filter' # internal key
RCINIT_INTERNAL_ORDER = '_order'                # internal key

RCINIT_NULL = 'RCINIT_NULL'                     # internal key
RCINIT_STKSZ_ZERO = 'RCINIT_STKSZ_ZERO'         # internal key
RCINIT_PRIO_INITFN = 'RCINIT_PRIO_INITFN'       # internal key
RCINIT_AFFINITY_ALL = 'RCINIT_AFFINITY_ALL'     # internal key

RCINIT_PRIO_ALIAS_FILE = 'RCINIT_PRIO_ALIAS_FILE' # internal key
RCINIT_PRIO_ALIAS_DICT = 'RCINIT_PRIO_ALIAS_DICT' # internal key

#env_rcinit[]
RCINIT_INFO_LIST = 'RCINIT_INFO_COLLECTOR'      # internal key

#env_rcinit_pol[]
RCINIT_POLICY_DICT = 'RCINIT_POLICY_COLLECTOR'  # internal key
RCINIT_NOPOLICY_ORDERED_LIST = 'RCINIT_ORDERED_COLLECTOR' # internal key
RCINIT_POLICY_USE_LIST = 'RCINIT_POLICY_USAGE_COLLECTOR' # internal key

RCINIT_NAME_MAXLEN = 15                         # ALL PL, ALL NHLOS API
RCINIT_OUTPUT_NA = '-'
RCINIT_OUTPUT_LEN = '*'
RCINIT_OUTPUT_TRUE = 'Y'
RCINIT_OUTPUT_FALSE = 'N'

HEAP_QUOTA_DICT = "TASK_HEAP_QUOTA_DICT"       #internal key
HEAP_QUOTA_RCPL_LIST = 'HEAP_QUOTA_RCPL_LIST'
HEAP_QUOTA_RCPL_DICT = 'HEAP_QUOTA_RCPL_DICT'

#dict that defines possible run levels
RCINIT_SEQUENCE_GROUP_KEYS = {                  # internal key mapping
    'RCINIT_GROUP_0' : '0',      '0' : '0',
    'RCINIT_GROUP_1' : '1',      '1' : '1',
    'RCINIT_GROUP_2' : '2',      '2' : '2',
    'RCINIT_GROUP_3' : '3',      '3' : '3',
    'RCINIT_GROUP_4' : '4',      '4' : '4',
    'RCINIT_GROUP_5' : '5',      '5' : '5',
    'RCINIT_GROUP_6' : '6',      '6' : '6',
    'RCINIT_GROUP_7' : '7',      '7' : '7',
    'RCINIT_GROUP_PARKED' : '7',
}

RCINIT_SEQUENCE_GROUP_MAX = 8                   # internal value
RCINIT_STACK_OVERHEAD = 128                     # internal estimate size of first exception frame
RCINIT_STACK_ROUNDUP = 4096                     # internal estimate size roundup to target page size

RCINIT_STACK_SECTION = '.bss.stack_'            # internal value (Treat as BSS, ZI)
RCINIT_STACK_PREFIX = 'rcinit_stk_'             # internal value (symbol prefix to generated stack data)
RCINIT_STACK_SUFFIX = ''                        # internal value (symbol suffix to generated stack data)

RCINIT_TCB_SECTION = '.bss.task_'               # internal value (Treat as BSS, ZI)
RCINIT_TCB_PREFIX = 'rcinit_tsk_'               # internal value (symbol prefix to generated task data)
RCINIT_TCB_SUFFIX = ''                          # internal value (symbol suffix to generated task data)

RCINIT_EXT_PB = '.c'                            # internal key
RCINIT_EXT_PL = '.rcpl'                         # internal key
RCINIT_EXT_HASH = '.md5'                        # internal key
RCINIT_EXT_CSV = '.csv'                         # internal key
RCINIT_EXT_LOG = '.txt'                         # internal key

# Shared Construction Environment 'globals'
ENV_RCINIT = 'ENV_RCINIT'                       # internal key
ENV_RCINIT_POL = 'ENV_RCINIT_POL'               # internal key
ENV_HEAP_QUOTA = 'ENV_HEAP_QUOTA'               # internal key

RCINIT_ALIAS_PLAYBOOK = 'rcinit_alias_playbook' # internal key
RCINIT_ALIAS_PLAYLIST = 'rcinit_alias_playlist' # internal key

ENV_ALIAS_PLAYBOOK_DEPENDS = None               # internal key
ENV_ALIAS_PLAYLIST_DEPENDS = None               # internal key

RCINIT_POC_TMS =  '(TMS)'                       # Owner of TMS Deliverable
RCINIT_POC_IO =   '(IMAGE OWNER)'               # Owner of Image
RCINIT_POC_TA =   '(TECH AREA)'                 # Owner of Tech Area
RCINIT_POC_HBA =  '(HOST BUILD ENV)'            # Owner of Host (Harvester, Blade Server, ...)

RCINIT_OUTPUT_HASHED = True                     # internal key
RCINIT_CHECK_SHARED_PRI_ORDER = False           # internal key

RCINIT_PBSOURCE = 'RCINIT_PBSOURCE'             # internal key
RCINIT_PLSOURCE = 'RCINIT_PLSOURCE'             # internal key

#===============================================================================
# SCONS Hooks
#===============================================================================

# exists: determines if the compilers, assemblers, linkers, tools,
# etc.. are available and present. this controls the generation of a
# construction environment assosicated to env.

def exists(env):
   ''' SCONS Tool, Exists, Check Conditions to Install a Construction Environment '''
   env.TmsDebug('exists()')

   return True

# generate: this generates a construction environment for use by
# scons; the environment is provided to use.

def generate(env):
   ''' SCONS Tool, Generate, Generate a Construction Environment '''
   env.TmsDebug('generate()')

   # Hint for SCONS debug output supplied by this tool
   #env.TmsInfo(env, 'Additional diagnostics with command line flag additions "--debug=stacktrace --debuginfo=rcinit"')

   # This tool supplies a USES_ flag for clients to utilize in the
   # construction environment.

   env.AddUsesFlags(RCINIT_USES_FLAG)

   # This tool saves 'globals' build information into the construction
   # environment that is provided by client calls of exported
   # methods. Two symbols are setup to assist in keeping policy data
   # seperated from nominal data -- even though there is one
   # construction environment...

   env[ENV_RCINIT] = env         # use first env for construction env task/function dictionary
   env[ENV_RCINIT_POL] = env     # use first env for construction env policy utilization dictionary
   env[ENV_HEAP_QUOTA] = env     # use first env for construction env heap quota dictionary

   env_rcinit = env[ENV_RCINIT]           # construct env task/function dictionary
   env_rcinit_pol = env[ENV_RCINIT_POL]   # construct env policy utilization dictionary
   env_heap_quota = env[ENV_HEAP_QUOTA]   # construct env heap quota dictionary

   # Initialization of the construction environment 'globals'
   # information.

   env_rcinit[RCINIT_INFO_LIST] = []
   env_rcinit_pol[RCINIT_POLICY_DICT] = {}
   env_rcinit_pol[RCINIT_POLICY_USE_LIST] = RCINIT_POLICY_DEFAULT
   env_rcinit_pol[RCINIT_NOPOLICY_ORDERED_LIST] = [[],[],[],[],[],[],[],[]]

   env_rcinit[RCINIT_PBSOURCE] = []
   env_rcinit[RCINIT_PLSOURCE] = []

   env_heap_quota[HEAP_QUOTA_DICT] = {}
   
   # Locate the *REQUIRED* priority alias file. It is to be supplied
   # by the IMAGE OWNER at FindConfigFiles() or IMAGE_ROOT.

   fileItemPrio = None
   env[RCINIT_PRIO_ALIAS_DICT] = {}

   # Pathing to Configuration Files by Tool

   if env.PathExists('${BUILD_ROOT}/build/scripts/build_utils.py'):

      env.LoadToolScript('build_utils', toolpath = ['${BUILD_ROOT}/build/scripts'])

      fileItemPrio = env.FindConfigFiles(RCINIT_PRIORITY_ALIAS_MAP_FILE)

      if fileItemPrio is not None and len(fileItemPrio) != 0:
         env[RCINIT_PRIO_ALIAS_FILE] = fileItemPrio[0]
         prioReader = csv.DictReader(open(env[RCINIT_PRIO_ALIAS_FILE], 'r'))
         for row in prioReader:
            env[RCINIT_PRIO_ALIAS_DICT][row['TASK_LEGACY_AMSS_PRI_ORDER']] = row['NONHLOS_PRIORITY']
            if None == re.search('^[A-Z0-9_]+_PRI_ORDER$', row['TASK_LEGACY_AMSS_PRI_ORDER']):
               env.TmsInfo(RCINIT_POC_IO + ' ALIAS MAP entry must match naming scheme [A-Z0-9]+_PRI_ORDER ' + row['TASK_LEGACY_AMSS_PRI_ORDER'])
         env.TmsDebug(RCINIT_POC_IO + ' ALIAS MAP present for the build object')
      else:
         if env.GetUsesFlag('USES_RCINIT_OPTION_FORCE_ALIASMAP'):
            env.TmsError(RCINIT_POC_IO + ' FORCED ALIAS MAP absent for the build object')
         else:
            env.TmsInfo(RCINIT_POC_IO + ' ALIAS MAP absent for the build object')

   # Pathing to Configuration Files by 'Hard Coded' Location

   else:

      if fileItemPrio == None:
         if env.has_key('IMAGE_ROOT'):
            fileItemPrio = getFileLocation(env, env.get('IMAGE_ROOT'), RCINIT_PRIORITY_ALIAS_MAP_FILE)
            if fileItemPrio is not None:
               env[RCINIT_PRIO_ALIAS_FILE] = fileItemPrio
               prioReader = csv.DictReader(open(env[RCINIT_PRIO_ALIAS_FILE], 'r'))
               for row in prioReader:
                  env[RCINIT_PRIO_ALIAS_DICT][row['TASK_LEGACY_AMSS_PRI_ORDER']] = row['NONHLOS_PRIORITY']
                  if None == re.search('^[A-Z0-9_]+_PRI_ORDER$', row['TASK_LEGACY_AMSS_PRI_ORDER']):
                     env.TmsInfo(RCINIT_POC_IO + ' ALIAS MAP entry must match naming scheme [A-Z0-9]+_PRI_ORDER ' + row['TASK_LEGACY_AMSS_PRI_ORDER'])
               env.TmsDebug(RCINIT_POC_IO + ' ALIAS MAP present for the build object')
            else:
               if env.GetUsesFlag('USES_RCINIT_OPTION_FORCE_ALIASMAP'):
                  env.TmsError(RCINIT_POC_IO + ' FORCED ALIAS MAP absent for the build object')
               else:
                  env.TmsInfo(RCINIT_POC_IO + ' ALIAS MAP absent for the build object')
         else:
            env.TmsError(RCINIT_POC_IO + ' IMAGE_ROOT not available')

   # validate the removal of deprecated files (a-family, obsolete)
   if env.has_key('IMAGE_ROOT'):
      checkfile = getFileLocation(env, env.get('IMAGE_ROOT'), 'rcinit_task_govern.csv')
      if checkfile != None:
         env.TmsInfo(RCINIT_POC_IO + ' Remove obsolete file ' + checkfile)
      checkfile = getFileLocation(env, env.get('IMAGE_ROOT'), 'rcinit_legacy_info.csv')
      if checkfile != None:
         env.TmsInfo(RCINIT_POC_IO + ' Remove obsolete file ' + checkfile)
      checkfile = getFileLocation(env, env.get('IMAGE_ROOT'), 'rcinit_task_prio.csv')
      if fileItemPrio != None and checkfile != None and fileItemPrio != checkfile:
         env.TmsInfo(RCINIT_POC_IO + ' Remove duplicate ALIAS MAP not referred to by build object ' + checkfile)

   #Optional Priority Check SHARED_*, Existence and Validate Order
   if (RCINIT_CHECK_SHARED_PRI_ORDER or env.GetUsesFlag('USES_RCINIT_OPTION_CHECK_SHARED_PRI_ORDER')) and fileItemPrio != None:

      # HIGHEST
      if not 'SHARED_IST_PRI_ORDER' in env[RCINIT_PRIO_ALIAS_DICT]:
         env.TmsError(RCINIT_POC_IO + ' Add ALIAS MAP entry SHARED_IST_PRI_ORDER (Highest)')

      # HIGHEST
      if not 'SHARED_IST_SERVICE_PRI_ORDER' in env[RCINIT_PRIO_ALIAS_DICT]:
         env.TmsError(RCINIT_POC_IO + ' Add ALIAS MAP entry SHARED_IST_SERVICE_PRI_ORDER (Highest)')
      elif env[RCINIT_PRIO_ALIAS_DICT]['SHARED_IST_SERVICE_PRI_ORDER'] > env[RCINIT_PRIO_ALIAS_DICT]['SHARED_IST_PRI_ORDER']:
         env.TmsError(RCINIT_POC_IO + ' Change ALIAS MAP entry SHARED_IST_SERVICE_PRI_ORDER (Highest) value lower than SHARED_IST_PRI_ORDER')

      # HIGH
      if not 'SHARED_DRIVER_PRI_ORDER' in env[RCINIT_PRIO_ALIAS_DICT]:
         env.TmsError(RCINIT_POC_IO + ' Add ALIAS MAP entry SHARED_DRIVER_PRI_ORDER (High)')
      elif env[RCINIT_PRIO_ALIAS_DICT]['SHARED_DRIVER_PRI_ORDER'] > env[RCINIT_PRIO_ALIAS_DICT]['SHARED_IST_SERVICE_PRI_ORDER']:
         env.TmsError(RCINIT_POC_IO + ' Change ALIAS MAP entry SHARED_DRIVER_PRI_ORDER (High) value lower than SHARED_IST_SERVICE_PRI_ORDER')

      # HIGH
      if not 'SHARED_DRIVER_SERVICE_PRI_ORDER' in env[RCINIT_PRIO_ALIAS_DICT]:
         env.TmsError(RCINIT_POC_IO + ' Add ALIAS MAP entry SHARED_DRIVER_SERVICE_PRI_ORDER (High)')
      elif env[RCINIT_PRIO_ALIAS_DICT]['SHARED_DRIVER_SERVICE_PRI_ORDER'] > env[RCINIT_PRIO_ALIAS_DICT]['SHARED_DRIVER_PRI_ORDER']:
         env.TmsError(RCINIT_POC_IO + ' Change ALIAS MAP entry SHARED_DRIVER_SERVICE_PRI_ORDER (High) value lower than SHARED_DRIVER_PRI_ORDER')

      # MIDDLE
      if not 'SHARED_FOREGROUND_PRI_ORDER' in env[RCINIT_PRIO_ALIAS_DICT]:
         env.TmsError(RCINIT_POC_IO + ' Add ALIAS MAP entry SHARED_FOREGROUND_PRI_ORDER (Middle)')
      elif env[RCINIT_PRIO_ALIAS_DICT]['SHARED_FOREGROUND_PRI_ORDER'] > env[RCINIT_PRIO_ALIAS_DICT]['SHARED_DRIVER_SERVICE_PRI_ORDER']:
         env.TmsError(RCINIT_POC_IO + ' Change ALIAS MAP entry SHARED_FOREGROUND_PRI_ORDER (Middle) value lower than SHARED_DRIVER_SERVICE_PRI_ORDER')

      # MIDDLE
      if not 'SHARED_FOREGROUND_SERVICE_PRI_ORDER' in env[RCINIT_PRIO_ALIAS_DICT]:
         env.TmsError(RCINIT_POC_IO + ' Add ALIAS MAP entry SHARED_FOREGROUND_SERVICE_PRI_ORDER (Middle)')
      elif env[RCINIT_PRIO_ALIAS_DICT]['SHARED_FOREGROUND_SERVICE_PRI_ORDER'] > env[RCINIT_PRIO_ALIAS_DICT]['SHARED_FOREGROUND_PRI_ORDER']:
         env.TmsError(RCINIT_POC_IO + ' Change ALIAS MAP entry SHARED_FOREGROUND_SERVICE_PRI_ORDER (Middle) value lower than SHARED_FOREGROUND_PRI_ORDER')

      # LOW
      if not 'SHARED_BACKGROUND_PRI_ORDER' in env[RCINIT_PRIO_ALIAS_DICT]:
         env.TmsError(RCINIT_POC_IO + ' Add ALIAS MAP entry SHARED_BACKGROUND_PRI_ORDER (Low)')
      elif env[RCINIT_PRIO_ALIAS_DICT]['SHARED_BACKGROUND_PRI_ORDER'] > env[RCINIT_PRIO_ALIAS_DICT]['SHARED_FOREGROUND_SERVICE_PRI_ORDER']:
         env.TmsError(RCINIT_POC_IO + ' Change ALIAS MAP entry SHARED_BACKGROUND_PRI_ORDER (Low) value lower than SHARED_FOREGROUND_SERVICE_PRI_ORDER')

      # LOW
      if not 'SHARED_BACKGROUND_SERVICE_PRI_ORDER' in env[RCINIT_PRIO_ALIAS_DICT]:
         env.TmsError(RCINIT_POC_IO + ' Add ALIAS MAP entry SHARED_BACKGROUND_SERVICE_PRI_ORDER (Low)')
      elif env[RCINIT_PRIO_ALIAS_DICT]['SHARED_BACKGROUND_SERVICE_PRI_ORDER'] > env[RCINIT_PRIO_ALIAS_DICT]['SHARED_BACKGROUND_PRI_ORDER']:
         env.TmsError(RCINIT_POC_IO + ' Change ALIAS MAP entry SHARED_BACKGROUND_SERVICE_PRI_ORDER (Low) value lower than SHARED_BACKGROUND_PRI_ORDER')

      # LOWEST
      if not 'SHARED_IDLE_PRI_ORDER' in env[RCINIT_PRIO_ALIAS_DICT]:
         env.TmsError(RCINIT_POC_IO + ' Add ALIAS MAP entry SHARED_IDLE_PRI_ORDER (Lowest)')
      elif env[RCINIT_PRIO_ALIAS_DICT]['SHARED_IDLE_PRI_ORDER'] > env[RCINIT_PRIO_ALIAS_DICT]['SHARED_BACKGROUND_SERVICE_PRI_ORDER']:
         env.TmsError(RCINIT_POC_IO + ' Change ALIAS MAP entry SHARED_IDLE_PRI_ORDER (Lowest) value lower than SHARED_BACKGROUND_SERVICE_PRI_ORDER')

      # LOWEST
      if not 'SHARED_IDLE_SERVICE_PRI_ORDER' in env[RCINIT_PRIO_ALIAS_DICT]:
         env.TmsError(RCINIT_POC_IO + ' Add ALIAS MAP entry SHARED_IDLE_SERVICE_PRI_ORDER (Lowest)')
      elif env[RCINIT_PRIO_ALIAS_DICT]['SHARED_IDLE_SERVICE_PRI_ORDER'] > env[RCINIT_PRIO_ALIAS_DICT]['SHARED_IDLE_PRI_ORDER']:
         env.TmsError(RCINIT_POC_IO + ' Change ALIAS MAP entry SHARED_IDLE_SERVICE_PRI_ORDER (Lowest) value lower than SHARED_IDLE_PRI_ORDER')

   # Final step is to associate this tool to the construction
   # environment. This activates the RCInitBuilder() for use.

   action = env.GetBuilderAction(tool_action, action_source = None)
   builder = env.Builder(action = action, emitter = tool_emitter)

   env.Append(BUILDERS = {'RCInitBuilder' : builder}) # internalized

   # Client exposed methods to the tool. These function as 'pseudo
   # builders' to collect client information, validate, and then save
   # to the 'globals' construction environment.

   env.AddMethod(tool_method_add_task, 'AddRCInitTask')
   env.AddMethod(tool_method_add_function, 'AddRCInitFunc')
   env.AddMethod(tool_method_add_policy, 'AddRCInitPolicy')

   env.AddMethod(tool_method_add_playbook, 'AddRCInitPlaybook')
   env.AddMethod(tool_method_add_playlist, 'AddRCInitPlaylist')
   env.AddMethod(tool_method_add_heapquota, 'AddHeapQuota')   

#===============================================================================

# emitter: run while reading sconscripts; used to tweak the targets
# and sources of the build step (eg, library building might also
# create intermediates that need to be added to targets, or cleanup
# artifacts). there is no file system activity here, just the
# specification of dependency.

# Returns: tuple of 2 lists, [target], [source]

def tool_emitter(target, source, env):
   ''' SCONS Tool, Emitter, Sanitize Target/Source Dependency '''
   env.TmsDebug('tool_emitter('+str(target[0])+')')

   # 'globals' information saved in the construction environment
   env_rcinit = env[ENV_RCINIT]           # construct env task/function dictionary

   targets = []
   sources = []

   if env.has_key(RCINIT_PRIO_ALIAS_FILE):
      rcinit_prio = env[RCINIT_PRIO_ALIAS_FILE]
      sources.append(rcinit_prio)
      env.TmsDebug('Source  ' + rcinit_prio)

   for s in source:
      if s != None:

         source_full = env.RealPath(str(s))
         source_path = os.path.split(source_full)[0]
         source_stem, source_ext = os.path.splitext(source_full)

         env.Precious(source_full)
         sources.append(source_full)

         env.TmsDebug('Explicit source ' + source_full)

   for s in env_rcinit[RCINIT_PLSOURCE]:
      if s != None:

         source_full = env.RealPath(str(s))
         source_path = os.path.split(source_full)[0]
         source_stem, source_ext = os.path.splitext(source_full)

         env.Precious(source_full)
         sources.append(source_full)

         env.TmsDebug('Derived source ' + source_full)

   # Anticipated target dependency information. The associated files
   # are created with the target as intended side effect.

   # Pull apart target and source pathing information for utilization
   # by tool_emitter.

   # output target doesnt have to be created; it just needs to be made
   # known to SCONS in case it is created.

   if target != None:
      for t in target:
         if t != None:

            target_full = env.RealPath(str(t))
            target_path = os.path.split(target_full)[0]
            target_stem, target_ext = os.path.splitext(target_full)

            if target_ext == RCINIT_EXT_PB:     # Always PB

               output = File(target_stem + RCINIT_EXT_PB)
               env.Clean(target_full, output)   # Explicit Clean, Command Line -c
               targets.append(output)           # Target accepted

               output = File(target_stem + RCINIT_EXT_PB + RCINIT_EXT_HASH)
               env.Clean(target_full, output)   # Explicit Clean, Command Line -c
               targets.append(output)           # Target accepted

               env.TmsDebug('target ' + target_stem + RCINIT_EXT_PB)

            elif target_ext == RCINIT_EXT_PL:   # Always PL

               output = File(target_stem + RCINIT_EXT_PL)
               env.Clean(target_full, output)   # Explicit Clean, Command Line -c
               targets.append(output)           # Target accepted

               output = File(target_stem + RCINIT_EXT_PL + RCINIT_EXT_HASH)
               env.Clean(target_full, output)   # Explicit Clean, Command Line -c
               targets.append(output)           # Target accepted

               env.TmsDebug('target ' + target_stem + RCINIT_EXT_PL)

            elif target_ext == RCINIT_EXT_LOG:  # Alwyas PB

               output = File(target_stem + RCINIT_EXT_LOG)
               env.Clean(target_full, output)   # Explicit Clean, Command Line -c
               targets.append(output)           # Target accepted

               output = File(target_stem + RCINIT_EXT_LOG + RCINIT_EXT_HASH)
               env.Clean(target_full, output)   # Explicit Clean, Command Line -c
               targets.append(output)           # Target accepted

               env.TmsDebug('target ' + target_stem + RCINIT_EXT_LOG)

            elif target_ext == RCINIT_EXT_CSV:  # PB/PL

               output = File(target_stem + RCINIT_EXT_CSV)
               env.Clean(target_full, output)   # Explicit Clean, Command Line -c
               targets.append(output)           # Target accepted

               output = File(target_stem + RCINIT_EXT_CSV + RCINIT_EXT_HASH)
               env.Clean(target_full, output)   # Explicit Clean, Command Line -c
               targets.append(output)           # Target accepted

               env.TmsDebug('target ' + target_stem + RCINIT_EXT_LOG)

            else:
               env.TmsError(RCINIT_POC_HBA + ' Fails with unknown target extension ' + target_full)

   return targets, sources

#===============================================================================

# action: this is the portion of the tool that takes the source list
# and creates a target from it.

def tool_action(target, source, env):
   ''' SCONS Tool, Action Function, ... '''
   env.TmsDebug('tool_action('+str(target[0])+')')

   # Ignore output creation on appropriate SCONS options
   if env.GetOption('clean') or env.GetOption('no_exec'):
      env.TmsDebug('TARGET CLEAN/NO_EXEC during tool action')
      return 0 # Indicate SUCCESS back

   # 'globals' information saved in the construction environment
   env_rcinit = env[ENV_RCINIT]           # construct env task/function dictionary
   env_rcinit_pol = env[ENV_RCINIT_POL]   # construct env policy utilization dictionary
   env_heap_quota = env[ENV_HEAP_QUOTA]   # construct env heap quota dictionary

   RCINIT_STACK_SIZE_DYNAMIC = 0                      # internal stats
   RCINIT_STACK_SIZE_STATIC = 0                       # internal stats
   RCINIT_STACK_SIZE_TOTAL = 0                        # internal stats
   RCINIT_STACK_SIZE_LARGEST = 0                      # internal stats
   RCINIT_STACK_SIZE_LARGEST_NAME = RCINIT_OUTPUT_NA  # internal stats

   RCINIT_PRIORITY_MAXIMUM = 0                        # internal stats
   RCINIT_PRIORITY_MAXIMUM_NAME = RCINIT_OUTPUT_NA    # internal stats
   RCINIT_PRIORITY_MINIMUM = 255                      # internal stats
   RCINIT_PRIORITY_MINIMUM_NAME = RCINIT_OUTPUT_NA    # internal stats
   HEAP_QUOTA_FIELD = 'RCINIT_NULL'
   heapQuotaDict = None

   target_full = env.RealPath(str(target[0]))
   target_path = os.path.split(target_full)[0]
   target_stem, target_ext = os.path.splitext(target_full)

   # Loading of Playlist files to create the Playbook; tool_emitter has already
   # sanatized the list to those that exist.

   playlists = map(lambda x: str(x), source)
   for playlist in playlists:
      playlist_stem, playlist_ext = os.path.splitext(env.RealPath(playlist))
      if playlist_ext == RCINIT_EXT_PL and playlist_stem != target_stem:
         env.TmsDebug('Loading Playlist ' + playlist_stem + playlist_ext)
         try:
            with open(playlist, 'r') as input:
               for line in input:
                  entry = eval(line)
                  if isinstance(entry, OrderedDict):
                     if entry.has_key(RCINIT_INFO_TYPE):
                        if entry[RCINIT_INFO_TYPE] == RCINIT_INFO_TASK:
                           tool_method_add_task(env, None, entry)
                        elif entry[RCINIT_INFO_TYPE] == RCINIT_INFO_FUNCTION:
                           tool_method_add_function(env, None, entry)
                        elif entry[RCINIT_INFO_TYPE] == RCINIT_INFO_POLICY:
                           tool_method_add_policy(env, None, entry)
                        elif entry[RCINIT_INFO_TYPE]== THREAD_HEAP_QUOTA:
                           tool_method_add_heapquota(env,None,entry)
                        else:
                           env.TmsError(RCINIT_POC_IO + ' Specified Playlist incorrect internal format, no matching type {:s}'.format(playlist))
                     else:
                        env.TmsError(RCINIT_POC_IO + ' Specified Playlist incorrect internal format, no type {:s}'.format(playlist))
                  else:
                     env.TmsError(RCINIT_POC_IO + ' Specified Playlist incorrect internal format, no matching instance {:s}'.format(playlist))
         except:
            raise Exception(RCINIT_POC_HBA + ' Fails with ' + playlist)

   # Prepare the Playbook output
   PlaybookOutput = []

   PlaybookOutput.append('/*build_id     {:s}*/\n'.format(env.get('BUILD_ID')))
   PlaybookOutput.append('/*version_info {:s}*/\n'.format(__version_info__))

   PlaybookOutput.append('''
/* DYNAMIC STACKS are allocated at runtime from the heap resource. STATIC STACKS can */
/* be placed at link time by use of the section name. Link time stack address        */
/* placement is outside of the RCINIT Framework domain; consult the tools linker     */
/* manual for section placement by link script files during link time.               */
''')

   #generate header includes
   PlaybookOutput.append('\n\n')
   PlaybookOutput.append('#include "dll_api.h"\n')
   if env.GetUsesFlag('USES_DAL'):
      PlaybookOutput.append('#include "rcinit_dal.h"\n')
   if env.GetUsesFlag('USES_POSIX'):
      PlaybookOutput.append('#include "rcinit_posix.h"\n')
   if env.GetUsesFlag('USES_QURT'):
      PlaybookOutput.append('#include "rcinit_qurt.h"\n')
   if env.GetUsesFlag('USES_REX'):
      PlaybookOutput.append('#include "rcinit_rex.h"\n')
   PlaybookOutput.append('#include "memheap.h"\n')

   PlaybookOutput.append('''
#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic ignored "-Wmissing-field-initializers"
#endif\n''')

   PlaybookOutput.append('\n#if defined(__cplusplus)\nextern "C" {\n#endif\n')

   PlaybookOutput.append('\n/* ******************************** */\n')

   #loop through tasks that registered with rcinit
   rcinit_ents = sorted(env_rcinit[RCINIT_INFO_LIST], key=lambda k: k[RCINIT_INFO_NAME])
   for entry in rcinit_ents:
      HEAP_QUOTA_FIELD = 'RCINIT_NULL'
      heapQuotaDict = None
      PlaybookOutput.append('''
/**
name       {0:s}
type       {1:s}
defined    {2:s}
policy     {3:s}
dependency {4:s}
*/\n'''.format(entry[RCINIT_INFO_NAME], entry[RCINIT_INFO_TYPE], entry[RCINIT_INFO_DEFINED], entry[RCINIT_INFO_POLICY],
   entry[RCINIT_INFO_DEPENDENCY]))

      # Policy List
      PlaybookOutput.append('''
static char const* const rcinit_ro_p_{0:s}[{1:s}+1] = (char const* const[{1:s}+1]) {{
{2:s} RCINIT_NULL
}};
'''.format(entry[RCINIT_INFO_NAME], str(len(entry[RCINIT_INFO_POLICY])),
      ''.join([ ' "%s",' % _ent for _ent in entry[RCINIT_INFO_POLICY]])))

      # Dependency List
      PlaybookOutput.append('''
static char const* const rcinit_ro_d_{0:s}[{1:s}+1] = (char const* const[{1:s}+1]) {{
{2:s} RCINIT_NULL
}};
'''.format(entry[RCINIT_INFO_NAME], str(len(entry[RCINIT_INFO_DEPENDENCY])),
   ''.join([ ' "%s",' % _ent for _ent in sorted(entry[RCINIT_INFO_DEPENDENCY])])))

      # API is Function/Policy
      if entry[RCINIT_INFO_API] == THREAD_API_FUNC or entry[RCINIT_INFO_API] == THREAD_API_POLICY:

         # Non NULL Entry
         if entry[RCINIT_INFO_ENTRY] != RCINIT_NULL:
            PlaybookOutput.append('''
/*signature*/ void {:s}(void);\n'''.format(entry[RCINIT_INFO_ENTRY]))

         # Const Memory
         PlaybookOutput.append('''
DLL_API_LOCAL const rcinit_info_t rcinit_ro_{0:s} = {{
/*name*/       "{0:s}",
/*hash*/       {1:s},
/*group*/      {9:s},
/*api*/        {2:s},
/*entry*/      (rcinit_entry_p){3:s},
/*priority*/   {4:s}, "{5:s}",
/*stack*/      {6:s},
/*heapq*/      {8:s},
/*affinity*/   {7:s},
/*policy*/     &rcinit_ro_p_{0:s},
/*dependency*/ &rcinit_ro_d_{0:s},
/*handle*/     RCINIT_NULL
}};\n'''.format(entry[RCINIT_INFO_NAME], entry[RCINIT_INFO_HASH], entry[RCINIT_INFO_API], entry[RCINIT_INFO_ENTRY],
   entry[RCINIT_INFO_PRIORITY], entry[RCINIT_INFO_PRIORITY_ALIAS], entry[RCINIT_INFO_STACK], entry[RCINIT_INFO_AFFINITY],
   HEAP_QUOTA_FIELD, entry[RCINIT_INFO_GROUP]))

      # API is DAL Workloop
      elif entry[RCINIT_INFO_API] == THREAD_API_DAL:

         # Update stats
         if env.TmsToInt(entry[RCINIT_INFO_STACK]) > RCINIT_STACK_SIZE_LARGEST:
            RCINIT_STACK_SIZE_LARGEST = int(entry[RCINIT_INFO_STACK])
            RCINIT_STACK_SIZE_LARGEST_NAME = entry[RCINIT_INFO_NAME]
         if env.TmsToInt(entry[RCINIT_INFO_PRIORITY]) < RCINIT_PRIORITY_MINIMUM:
            RCINIT_PRIORITY_MINIMUM = int(entry[RCINIT_INFO_PRIORITY])
            RCINIT_PRIORITY_MINIMUM_NAME = entry[RCINIT_INFO_NAME]
         if env.TmsToInt(entry[RCINIT_INFO_PRIORITY]) > RCINIT_PRIORITY_MAXIMUM:
            RCINIT_PRIORITY_MAXIMUM = int(entry[RCINIT_INFO_PRIORITY])
            RCINIT_PRIORITY_MAXIMUM_NAME = entry[RCINIT_INFO_NAME]

         # Static Stack
         RCINIT_STACK_SIZE_TOTAL = RCINIT_STACK_SIZE_TOTAL + env.TmsToInt(entry[RCINIT_INFO_STACK]) + RCINIT_STACK_OVERHEAD
         STACK_NAME = 'RCINIT_NULL'
         if env.GetUsesFlag('USES_RCINIT_OPTION_STATIC_STACK_') or entry[RCINIT_INFO_STACK_STATIC] != None:
            if entry[RCINIT_INFO_STACK_STATIC] == None:
               entry[RCINIT_INFO_STACK_STATIC] = RCINIT_STACK_SECTION + entry[RCINIT_INFO_NAME]
            RCINIT_STACK_SIZE_STATIC = RCINIT_STACK_SIZE_STATIC + env.TmsToInt(entry[RCINIT_INFO_STACK]) + RCINIT_STACK_OVERHEAD
            STACK_NAME = RCINIT_STACK_PREFIX + entry[RCINIT_INFO_NAME] + RCINIT_STACK_SUFFIX
            PlaybookOutput.append('''
static rcinit_stack_t {0:s}[({1:s}+sizeof(_rcxh_scope_t))/sizeof(rcinit_stack_t)] __attribute__((aligned(RCINIT_STACK_ALIGN), section("{2:s}")));\n'''.format(STACK_NAME, entry[RCINIT_INFO_STACK], entry[RCINIT_INFO_STACK_STATIC], entry[RCINIT_INFO_NAME]))
         else:
            RCINIT_STACK_SIZE_DYNAMIC = RCINIT_STACK_SIZE_DYNAMIC + env.TmsToInt(entry[RCINIT_INFO_STACK]) + RCINIT_STACK_OVERHEAD
         # Heap Quota
         if env_heap_quota[HEAP_QUOTA_DICT].has_key(entry[RCINIT_INFO_NAME]):
            heapQuotaDict = env_heap_quota[HEAP_QUOTA_DICT][entry[RCINIT_INFO_NAME]]
            HEAP_QUOTA_FIELD = '&rcinit_heapq_{0:s}'.format(entry[RCINIT_INFO_NAME])+'[0]'
            PlaybookOutput.append('''
{0:s}
static rcinit_heapq_t rcinit_heapq_{1:s}[] = {{
{2:s} RCINIT_NULL  
}};'''.format(''.join([ 'extern mem_heap_type %s;\n' % (key) for (key,val) in heapQuotaDict.items()]), entry[RCINIT_INFO_NAME], 
''.join([ '{ &%s, %s },\n' % (key,val) for (key,val) in heapQuotaDict.items()])))

         # Volatile Memory
         PlaybookOutput.append('''
static rcinit_handle_t rcinit_rw_{0:s} = {{
(rcinit_tid_p)RCINIT_NULL, {2:s}, RCINIT_NULL, RCINIT_NULL, RCINIT_NULL
}};\n'''.format(entry[RCINIT_INFO_NAME], '', STACK_NAME))

         # Non NULL Entry
         if entry[RCINIT_INFO_ENTRY] != RCINIT_NULL:
            PlaybookOutput.append('''
/*signature*/ DALResult {:s}(unsigned long, void*);\n'''.format(entry[RCINIT_INFO_ENTRY]))

         # Const Memory
         PlaybookOutput.append('''
DLL_API_LOCAL const rcinit_info_t rcinit_ro_{0:s} = {{
/*name*/       "{0:s}",
/*hash*/       {1:s},
/*group*/      {9:s},
/*api*/        {2:s},
/*entry*/      (rcinit_entry_p){3:s},
/*priority*/   {4:s}, "{5:s}",
/*stack*/      {6:s},
/*heapq*/      {8:s},
/*affinity*/   {7:s},
/*policy*/     &rcinit_ro_p_{0:s},
/*dependency*/ &rcinit_ro_d_{0:s},
/*handle*/     &rcinit_rw_{0:s}
}};\n'''.format(entry[RCINIT_INFO_NAME], entry[RCINIT_INFO_HASH], entry[RCINIT_INFO_API], entry[RCINIT_INFO_ENTRY],
   entry[RCINIT_INFO_PRIORITY], entry[RCINIT_INFO_PRIORITY_ALIAS], entry[RCINIT_INFO_STACK], entry[RCINIT_INFO_AFFINITY],
   HEAP_QUOTA_FIELD, entry[RCINIT_INFO_GROUP]))

      # API is POSIX Pthread
      elif entry[THREAD_API] == THREAD_API_POSIX:

         # Update stats
         if env.TmsToInt(entry[RCINIT_INFO_STACK]) > RCINIT_STACK_SIZE_LARGEST:
            RCINIT_STACK_SIZE_LARGEST = int(entry[RCINIT_INFO_STACK])
            RCINIT_STACK_SIZE_LARGEST_NAME = entry[RCINIT_INFO_NAME]
         if env.TmsToInt(entry[RCINIT_INFO_PRIORITY]) < RCINIT_PRIORITY_MINIMUM:
            RCINIT_PRIORITY_MINIMUM = int(entry[RCINIT_INFO_PRIORITY])
            RCINIT_PRIORITY_MINIMUM_NAME = entry[RCINIT_INFO_NAME]
         if env.TmsToInt(entry[RCINIT_INFO_PRIORITY]) > RCINIT_PRIORITY_MAXIMUM:
            RCINIT_PRIORITY_MAXIMUM = int(entry[RCINIT_INFO_PRIORITY])
            RCINIT_PRIORITY_MAXIMUM_NAME = entry[RCINIT_INFO_NAME]

         # Static Stack
         RCINIT_STACK_SIZE_TOTAL = RCINIT_STACK_SIZE_TOTAL + env.TmsToInt(entry[RCINIT_INFO_STACK]) + RCINIT_STACK_OVERHEAD
         STACK_NAME = 'RCINIT_NULL'
         if env.GetUsesFlag('USES_RCINIT_OPTION_STATIC_STACK_') or entry[RCINIT_INFO_STACK_STATIC] != None:
            if entry[RCINIT_INFO_STACK_STATIC] == None:
               entry[RCINIT_INFO_STACK_STATIC] = RCINIT_STACK_SECTION + entry[RCINIT_INFO_NAME]
            RCINIT_STACK_SIZE_STATIC = RCINIT_STACK_SIZE_STATIC + env.TmsToInt(entry[RCINIT_INFO_STACK]) + RCINIT_STACK_OVERHEAD
            STACK_NAME = RCINIT_STACK_PREFIX + entry[RCINIT_INFO_NAME] + RCINIT_STACK_SUFFIX
            PlaybookOutput.append('''
static rcinit_stack_t {0:s}[({1:s}+sizeof(_rcxh_scope_t))/sizeof(rcinit_stack_t)] __attribute__((aligned(RCINIT_STACK_ALIGN), section("{2:s}")));\n'''.format(STACK_NAME, entry[RCINIT_INFO_STACK], entry[RCINIT_INFO_STACK_STATIC], entry[RCINIT_INFO_NAME]))
         else:
            RCINIT_STACK_SIZE_DYNAMIC = RCINIT_STACK_SIZE_DYNAMIC + env.TmsToInt(entry[RCINIT_INFO_STACK]) + RCINIT_STACK_OVERHEAD
         # Heap Quota
         if env_heap_quota[HEAP_QUOTA_DICT].has_key(entry[RCINIT_INFO_NAME]):
            heapQuotaDict = env_heap_quota[HEAP_QUOTA_DICT][entry[RCINIT_INFO_NAME]]
            HEAP_QUOTA_FIELD = '&rcinit_heapq_{0:s}'.format(entry[RCINIT_INFO_NAME])+'[0]'
            PlaybookOutput.append('''
{0:s}
static rcinit_heapq_t rcinit_heapq_{1:s}[] = {{
{2:s} RCINIT_NULL  
}};'''.format(''.join([ 'extern mem_heap_type %s;\n' % (key) for (key,val) in heapQuotaDict.items()]), entry[RCINIT_INFO_NAME], 
''.join([ '{ &%s, %s },\n' % (key,val) for (key,val) in heapQuotaDict.items()])))

         # Volatile Memory
         PlaybookOutput.append('''
static rcinit_handle_t rcinit_rw_{0:s} = {{
(rcinit_tid_p)RCINIT_NULL, {2:s}, RCINIT_NULL, RCINIT_NULL, RCINIT_NULL
}};\n'''.format(entry[RCINIT_INFO_NAME], '', STACK_NAME))

         # Non NULL Entry
         if entry[RCINIT_INFO_ENTRY] != RCINIT_NULL:
            PlaybookOutput.append('''
/*signature*/ void* {:s}(void*);\n'''.format(entry[RCINIT_INFO_ENTRY]))

         # Const Memory
         PlaybookOutput.append('''
DLL_API_LOCAL const rcinit_info_t rcinit_ro_{0:s} = {{
/*name*/       "{0:s}",
/*hash*/       {1:s},
/*group*/      {9:s},
/*api*/        {2:s},
/*entry*/      (rcinit_entry_p){3:s},
/*priority*/   {4:s}, "{5:s}",
/*stack*/      {6:s},
/*heapq*/      {8:s},
/*affinity*/   {7:s},
/*policy*/     &rcinit_ro_p_{0:s},
/*dependency*/ &rcinit_ro_d_{0:s},
/*handle*/     &rcinit_rw_{0:s}
}};\n'''.format(entry[RCINIT_INFO_NAME], entry[RCINIT_INFO_HASH], entry[RCINIT_INFO_API], entry[RCINIT_INFO_ENTRY],
   entry[RCINIT_INFO_PRIORITY], entry[RCINIT_INFO_PRIORITY_ALIAS], entry[RCINIT_INFO_STACK], entry[RCINIT_INFO_AFFINITY],
   HEAP_QUOTA_FIELD, entry[RCINIT_INFO_GROUP]))

      # API is QURT Thread
      elif entry[THREAD_API] == THREAD_API_QURT:

         # Update stats
         if env.TmsToInt(entry[RCINIT_INFO_STACK]) > RCINIT_STACK_SIZE_LARGEST:
            RCINIT_STACK_SIZE_LARGEST = int(entry[RCINIT_INFO_STACK])
            RCINIT_STACK_SIZE_LARGEST_NAME = entry[RCINIT_INFO_NAME]
         if env.TmsToInt(entry[RCINIT_INFO_PRIORITY]) < RCINIT_PRIORITY_MINIMUM:
            RCINIT_PRIORITY_MINIMUM = int(entry[RCINIT_INFO_PRIORITY])
            RCINIT_PRIORITY_MINIMUM_NAME = entry[RCINIT_INFO_NAME]
         if env.TmsToInt(entry[RCINIT_INFO_PRIORITY]) > RCINIT_PRIORITY_MAXIMUM:
            RCINIT_PRIORITY_MAXIMUM = int(entry[RCINIT_INFO_PRIORITY])
            RCINIT_PRIORITY_MAXIMUM_NAME = entry[RCINIT_INFO_NAME]

         # Static Stack
         RCINIT_STACK_SIZE_TOTAL = RCINIT_STACK_SIZE_TOTAL + env.TmsToInt(entry[RCINIT_INFO_STACK]) + RCINIT_STACK_OVERHEAD
         STACK_NAME = 'RCINIT_NULL'
         if env.GetUsesFlag('USES_RCINIT_OPTION_STATIC_STACK_') or entry[RCINIT_INFO_STACK_STATIC] != None:
            if entry[RCINIT_INFO_STACK_STATIC] == None:
               entry[RCINIT_INFO_STACK_STATIC] = RCINIT_STACK_SECTION + entry[RCINIT_INFO_NAME]
            RCINIT_STACK_SIZE_STATIC = RCINIT_STACK_SIZE_STATIC + env.TmsToInt(entry[RCINIT_INFO_STACK]) + RCINIT_STACK_OVERHEAD
            STACK_NAME = RCINIT_STACK_PREFIX + entry[RCINIT_INFO_NAME] + RCINIT_STACK_SUFFIX
            PlaybookOutput.append('''
static rcinit_stack_t {0:s}[({1:s}+sizeof(_rcxh_scope_t))/sizeof(rcinit_stack_t)] __attribute__((aligned(RCINIT_STACK_ALIGN), section("{2:s}")));\n'''.format(STACK_NAME, entry[RCINIT_INFO_STACK], entry[RCINIT_INFO_STACK_STATIC], entry[RCINIT_INFO_NAME]))
         else:
            RCINIT_STACK_SIZE_DYNAMIC = RCINIT_STACK_SIZE_DYNAMIC + env.TmsToInt(entry[RCINIT_INFO_STACK]) + RCINIT_STACK_OVERHEAD

         # Heap Quota
         if env_heap_quota[HEAP_QUOTA_DICT].has_key(entry[RCINIT_INFO_NAME]):
            heapQuotaDict = env_heap_quota[HEAP_QUOTA_DICT][entry[RCINIT_INFO_NAME]]
            HEAP_QUOTA_FIELD = '&rcinit_heapq_{0:s}'.format(entry[RCINIT_INFO_NAME])+'[0]'
            PlaybookOutput.append('''
{0:s}
static rcinit_heapq_t rcinit_heapq_{1:s}[] = {{
{2:s} RCINIT_NULL  
}};'''.format(''.join([ 'extern mem_heap_type %s;\n' % (key) for (key,val) in heapQuotaDict.items()]), entry[RCINIT_INFO_NAME], 
''.join([ '{ &%s, %s },\n' % (key,val) for (key,val) in heapQuotaDict.items()])))

         # Volatile Memory
         PlaybookOutput.append('''
static rcinit_handle_t rcinit_rw_{0:s} = {{
(rcinit_tid_p)RCINIT_NULL, {2:s}, RCINIT_NULL, RCINIT_NULL, RCINIT_NULL
}};\n'''.format(entry[RCINIT_INFO_NAME], '', STACK_NAME))

         # Non NULL Entry
         if entry[RCINIT_INFO_ENTRY] != RCINIT_NULL:
            PlaybookOutput.append('''
/*signature*/ void {:s}(void*);\n'''.format(entry[RCINIT_INFO_ENTRY]))

         # Const Memory
         PlaybookOutput.append('''
DLL_API_LOCAL const rcinit_info_t rcinit_ro_{0:s} = {{
/*name*/       "{0:s}",
/*hash*/       {1:s},
/*group*/      {9:s},
/*api*/        {2:s},
/*entry*/      (rcinit_entry_p){3:s},
/*priority*/   {4:s}, "{5:s}",
/*stack*/      {6:s},
/*heapq*/      {8:s},
/*affinity*/   {7:s},
/*policy*/     &rcinit_ro_p_{0:s},
/*dependency*/ &rcinit_ro_d_{0:s},
/*handle*/     &rcinit_rw_{0:s}
}};\n'''.format(entry[RCINIT_INFO_NAME], entry[RCINIT_INFO_HASH], entry[RCINIT_INFO_API], entry[RCINIT_INFO_ENTRY],
   entry[RCINIT_INFO_PRIORITY], entry[RCINIT_INFO_PRIORITY_ALIAS], entry[RCINIT_INFO_STACK], entry[RCINIT_INFO_AFFINITY],
   HEAP_QUOTA_FIELD, entry[RCINIT_INFO_GROUP]))

      # API is REX Task
      elif entry[THREAD_API] == THREAD_API_REX:

         # Update stats
         if env.TmsToInt(entry[RCINIT_INFO_STACK]) > RCINIT_STACK_SIZE_LARGEST:
            RCINIT_STACK_SIZE_LARGEST = int(entry[RCINIT_INFO_STACK])
            RCINIT_STACK_SIZE_LARGEST_NAME = entry[RCINIT_INFO_NAME]
         if env.TmsToInt(entry[RCINIT_INFO_PRIORITY]) < RCINIT_PRIORITY_MINIMUM:
            RCINIT_PRIORITY_MINIMUM = int(entry[RCINIT_INFO_PRIORITY])
            RCINIT_PRIORITY_MINIMUM_NAME = entry[RCINIT_INFO_NAME]
         if env.TmsToInt(entry[RCINIT_INFO_PRIORITY]) > RCINIT_PRIORITY_MAXIMUM:
            RCINIT_PRIORITY_MAXIMUM = int(entry[RCINIT_INFO_PRIORITY])
            RCINIT_PRIORITY_MAXIMUM_NAME = entry[RCINIT_INFO_NAME]

         # Static Stack
         RCINIT_STACK_SIZE_TOTAL = RCINIT_STACK_SIZE_TOTAL + env.TmsToInt(entry[RCINIT_INFO_STACK]) + RCINIT_STACK_OVERHEAD
         STACK_NAME = 'RCINIT_NULL'
         if env.GetUsesFlag('USES_RCINIT_OPTION_STATIC_STACK_') or entry[RCINIT_INFO_STACK_STATIC] != None:
            if entry[RCINIT_INFO_STACK_STATIC] == None:
               entry[RCINIT_INFO_STACK_STATIC] = RCINIT_STACK_SECTION + entry[RCINIT_INFO_NAME]
            RCINIT_STACK_SIZE_STATIC = RCINIT_STACK_SIZE_STATIC + env.TmsToInt(entry[RCINIT_INFO_STACK]) + RCINIT_STACK_OVERHEAD
            STACK_NAME = RCINIT_STACK_PREFIX + entry[RCINIT_INFO_NAME] + RCINIT_STACK_SUFFIX
            PlaybookOutput.append('''
static rcinit_stack_t {0:s}[({1:s}+sizeof(_rcxh_scope_t))/sizeof(rcinit_stack_t)] __attribute__((aligned(RCINIT_STACK_ALIGN), section("{2:s}")));\n'''.format(STACK_NAME, entry[RCINIT_INFO_STACK], entry[RCINIT_INFO_STACK_STATIC], entry[RCINIT_INFO_NAME]))
         else:
            RCINIT_STACK_SIZE_DYNAMIC = RCINIT_STACK_SIZE_DYNAMIC + env.TmsToInt(entry[RCINIT_INFO_STACK]) + RCINIT_STACK_OVERHEAD

         if entry[THREAD_TCB] == RCINIT_NULL:
            # Volatile Memory
            PlaybookOutput.append('''
/*static*/ rex_tcb_type {1:s}_tcb __attribute__((aligned(RCINIT_STACK_ALIGN), section("{5:s}{0:s}"))); /* IMPLICIT */

static rcinit_handle_t rcinit_rw_{0:s} = {{
(rcinit_tid_p)&{1:s}_tcb, {2:s}, RCINIT_NULL, RCINIT_NULL, RCINIT_NULL
}};\n'''.format(entry[RCINIT_INFO_NAME], entry[RCINIT_INFO_NAME], STACK_NAME, RCINIT_TCB_PREFIX, RCINIT_TCB_SUFFIX, RCINIT_TCB_SECTION))
         else:
            # TCB Special Case
            PlaybookOutput.append('''
rex_tcb_type {1:s} __attribute__((aligned(RCINIT_STACK_ALIGN), section("{5:s}{0:s}"))); /* EXPLICIT */

static rcinit_handle_t rcinit_rw_{0:s} = {{
(rcinit_tid_p)&{1:s}, {2:s}, RCINIT_NULL, RCINIT_NULL, RCINIT_NULL
}};\n'''.format(entry[RCINIT_INFO_NAME], entry[THREAD_TCB], STACK_NAME, RCINIT_TCB_PREFIX, RCINIT_TCB_SUFFIX, RCINIT_TCB_SECTION))

         # Heap Quota
         if env_heap_quota[HEAP_QUOTA_DICT].has_key(entry[RCINIT_INFO_NAME]):
            heapQuotaDict = env_heap_quota[HEAP_QUOTA_DICT][entry[RCINIT_INFO_NAME]]
            HEAP_QUOTA_FIELD = '&rcinit_heapq_{0:s}'.format(entry[RCINIT_INFO_NAME])+'[0]'
            PlaybookOutput.append('''
{0:s}
static rcinit_heapq_t rcinit_heapq_{1:s}[] = {{
{2:s} RCINIT_NULL  
}};'''.format(''.join([ 'extern mem_heap_type %s;\n' % (key) for (key,val) in heapQuotaDict.items()]), entry[RCINIT_INFO_NAME], 
''.join([ '{ &%s, %s },\n' % (key,val) for (key,val) in heapQuotaDict.items()])))

         # Non NULL Entry
         if entry[RCINIT_INFO_ENTRY] != RCINIT_NULL:
            PlaybookOutput.append('''
/*signature*/ void {:s}(unsigned long);\n'''.format(entry[RCINIT_INFO_ENTRY]))

         # Const Memory
         PlaybookOutput.append('''
DLL_API_LOCAL const rcinit_info_t rcinit_ro_{0:s} = {{
/*name*/       "{0:s}",
/*hash*/       {1:s},
/*group*/      {9:s},
/*api*/        {2:s},
/*entry*/      (rcinit_entry_p){3:s},
/*priority*/   {4:s}, "{5:s}",
/*stack*/      {6:s},
/*heapq*/     {8:s},
/*affinity*/   {7:s},
/*policy*/     &rcinit_ro_p_{0:s},
/*dependency*/ &rcinit_ro_d_{0:s},
/*handle*/     &rcinit_rw_{0:s}
}};\n'''.format(entry[RCINIT_INFO_NAME], entry[RCINIT_INFO_HASH], entry[RCINIT_INFO_API], entry[RCINIT_INFO_ENTRY],
   entry[RCINIT_INFO_PRIORITY], entry[RCINIT_INFO_PRIORITY_ALIAS], entry[RCINIT_INFO_STACK], entry[RCINIT_INFO_AFFINITY],
   HEAP_QUOTA_FIELD, entry[RCINIT_INFO_GROUP]))

   #done generating rcinit structs

   PlaybookOutput.append('\n/* ******************************** */\n')

   #generate task map
   PlaybookOutput.append('\n')
   rcinitNames = []
   for entry in env_rcinit[RCINIT_INFO_LIST]:
      rcinitNames.append(entry[RCINIT_INFO_NAME])
   rcinitNames.sort()
   PlaybookOutput.append('DLL_API_EXPORT_HELPER const rcinit_internal_name_map_t rcinit_internal_name_map[] = {\n')
   for key in rcinitNames: PlaybookOutput.append(' {{ "{0:s}", &rcinit_ro_{0:s} }},\n'.format(key))
   PlaybookOutput.append(' { RCINIT_NULL, RCINIT_NULL }\n};\n')
   PlaybookOutput.append('DLL_API_EXPORT_HELPER const int rcinit_internal_name_map_size = sizeof(rcinit_internal_name_map) / sizeof(rcinit_internal_name_map_t);\n')

   PlaybookOutput.append('\n/* ******************************** */\n')

   #sort group levels given dependencies
   grpNum = 0
   for grpLvl in env_rcinit_pol[RCINIT_NOPOLICY_ORDERED_LIST]:
      #first generate a list of names at the group level
      taskNames = [ dict_[THREAD_NAME] for dict_ in grpLvl if dict_.has_key(THREAD_NAME)]
      initNames = [ dict_[INIT_NAME] for dict_ in grpLvl if dict_.has_key(INIT_NAME)]
      #only init functions allowed as dependencies
      grpNames = set(initNames)

      #form dictionary of vertices for topological sort
      grpDict = {}
      for item in grpLvl:
         filteredDependencies = list(set(item[RCINIT_DEPENDENCIES]) & grpNames)
         item[RCINIT_DEPENDENCIES_FILTER] = filteredDependencies
         grpDict[item[RCINIT_INFO_NAME]] = filteredDependencies

      #sort based on dependencies
      grpSorted = topological_sort(grpDict)
      grpSorted.reverse()

      #check if there was a cycle
      if len(grpSorted) != len(set(initNames) | set(taskNames)):
         env.TmsError(RCINIT_POC_TA + ' Correct the circular dependencies in the functions')

      #append an ordering to each dictionary
      for item in grpLvl:
         if item.has_key(THREAD_NAME):
            item[RCINIT_INTERNAL_ORDER] = grpSorted.index(item[THREAD_NAME])
         else:
            #exception for policy functions
            #ignore if internal ordering is already defined
            if not item.has_key(RCINIT_INTERNAL_ORDER):
               item[RCINIT_INTERNAL_ORDER] = grpSorted.index(item[INIT_NAME])

      #sort the dictionaries
      env_rcinit_pol[RCINIT_NOPOLICY_ORDERED_LIST][grpNum] = sorted(grpLvl, key=itemgetter(RCINIT_INTERNAL_ORDER))
      grpNum += 1

   #sort the nonpolicy ordered list as well for output
   for policy in env_rcinit_pol[RCINIT_POLICY_DICT]:
      grpNum = 0
      for grpLvl in env_rcinit_pol[RCINIT_POLICY_DICT][policy]:
         env_rcinit_pol[RCINIT_POLICY_DICT][policy][grpNum] = sorted(grpLvl, key=itemgetter(RCINIT_INTERNAL_ORDER))
         grpNum += 1

   #generate rcinit arrays
   for policy in env_rcinit_pol[RCINIT_POLICY_DICT]:
      #skip if policy is not used in this build
      if policy not in env_rcinit_pol[RCINIT_POLICY_USE_LIST]:
         continue
      PlaybookOutput.append('\n')
      for i in range(RCINIT_SEQUENCE_GROUP_MAX):
         PlaybookOutput.append('static const rcinit_info_t* rcinit_{:s}_{:d}[] = {{\n'.format(policy, i))
         for rcinitInfo in env_rcinit_pol[RCINIT_POLICY_DICT][policy][i]:
            PlaybookOutput.append('&rcinit_ro_{:s},\n'.format(rcinitInfo[RCINIT_INFO_NAME]))
         PlaybookOutput.append('RCINIT_NULL\n}};\n\n'.format(0))

      PlaybookOutput.append('static const rcinit_info_t** rcinit_group_{:s}[] = {{\n'.format(policy))
      for i in range(RCINIT_SEQUENCE_GROUP_MAX):
         PlaybookOutput.append('rcinit_{:s}_{:d},\n'.format(policy, i))
      PlaybookOutput.append('RCINIT_NULL\n}};\n'.format(0))
   #done generating rcinit arrays

   PlaybookOutput.append('\n/* ******************************** */\n')

   #generate policy arrays for in use policies
   policyList = list(set(env_rcinit_pol[RCINIT_POLICY_DICT].keys()) & set(env_rcinit_pol[RCINIT_POLICY_USE_LIST]))
   policyList.sort()
   PlaybookOutput.append('\n')
   PlaybookOutput.append('DLL_API_EXPORT_HELPER const rcinit_internal_policy_map_t rcinit_internal_policy_map[] = {{\n'.format(0))
   for policy  in policyList:
      PlaybookOutput.append(' {{ "{:s}", {:d} }},\n'.format(policy, policyList.index(policy)))
   PlaybookOutput.append(' {RCINIT_NULL, RCINIT_ZERO}\n')
   PlaybookOutput.append('}};\n'.format(0))
   PlaybookOutput.append('DLL_API_EXPORT_HELPER const int rcinit_internal_policy_map_size = sizeof(rcinit_internal_policy_map) / sizeof(rcinit_internal_policy_map_t);\n')

   PlaybookOutput.append('\n')
   PlaybookOutput.append('DLL_API_EXPORT_HELPER const rcinit_info_t*** rcinit_internal_groups[] = {{\n'.format(0))
   for policy in policyList:
      PlaybookOutput.append(' rcinit_group_{:s},\n'.format(policy))
   PlaybookOutput.append(' RCINIT_NULL\n')
   PlaybookOutput.append('}};\n'.format(0))

   PlaybookOutput.append('DLL_API_EXPORT_HELPER const RCINIT_NAME rcinit_internal_policy_list[] = {{\n'.format(0))
   for policy  in policyList:
      PlaybookOutput.append(' "{:s}",\n'.format(policy))
   PlaybookOutput.append(' RCINIT_NULL\n')
   PlaybookOutput.append('}};\n'.format(0))

   PlaybookOutput.append('\n/* ******************************** */\n')

   PlaybookOutput.append('\n')
   PlaybookOutput.append('DLL_API_EXPORT_HELPER rcinit_info_t**** RCINIT_PLAYBOOK_MAP_GROUP = (void*)rcinit_internal_groups;\n')
   PlaybookOutput.append('DLL_API_EXPORT_HELPER rcinit_internal_name_map_t* RCINIT_PLAYBOOK_MAP_NAME = (void*)rcinit_internal_name_map;\n')

   PlaybookOutput.append('\n#if defined(__cplusplus)\n}\n#endif\n\n')

   #form output log
   PlaybookOutputLog = []
   PlaybookOutputLog.append('****************************************\n')
   PlaybookOutputLog.append('RCINIT OUTPUT LOG\n')

   if env.has_key(RCINIT_PRIO_ALIAS_FILE):
      PlaybookOutputLog.append('\n')
      output_text = env[RCINIT_PRIO_ALIAS_FILE].replace('\\','/').lower().replace(env.get('BUILD_ROOT', None).lower()+'/', '')
      PlaybookOutputLog.append('Priority ALIAS MAP {:s} '.format(output_text))
      PlaybookOutputLog.append('\n')

   PlaybookOutputLog.append('\nUses: ')
   if env.GetUsesFlag('USES_RCINIT_OPTION_CHECK_SHARED_PRI_ORDER') or RCINIT_CHECK_SHARED_PRI_ORDER:
      PlaybookOutputLog.append('CHECK_SHARED_PRI_ORDER ')
   if env.GetUsesFlag('USES_RCINIT_OPTION_STATIC_STACK_'):
      PlaybookOutputLog.append('STATIC_STACK ')
   if env.GetUsesFlag('USES_RCINIT_OPTION_PLAYBOOK') or env.GetUsesFlag('USES_RCINIT_OPTION_PLAYBOOK_SHARED_OBJECT') or env.GetUsesFlag('USES_RCINIT_PLAYBOOK'):
      PlaybookOutputLog.append('PLAYBOOK ')
   if env.GetUsesFlag('USES_KERNEL_DAL') or env.GetUsesFlag('USES_DAL'):
      PlaybookOutputLog.append('DAL ')
   if env.GetUsesFlag('USES_KERNEL_POSIX') or env.GetUsesFlag('USES_POSIX'):
      PlaybookOutputLog.append('POSIX ')
   if env.GetUsesFlag('USES_KERNEL_QURT') or env.GetUsesFlag('USES_QURT'):
      PlaybookOutputLog.append('QURT ')
   if env.GetUsesFlag('USES_KERNEL_REX') or env.GetUsesFlag('USES_REX'):
      PlaybookOutputLog.append('REX ')
   PlaybookOutputLog.append('\n')

   PlaybookOutputLog.append('\n')
   PlaybookOutputLog.append('Build Stack Allocation ESTIMATES {:s} Total, {:s} Dynamic, {:s} Static\n'.format(
      str(roundup(RCINIT_STACK_SIZE_TOTAL, RCINIT_STACK_ROUNDUP)),
      str(roundup(RCINIT_STACK_SIZE_DYNAMIC, RCINIT_STACK_ROUNDUP)),
      str(roundup(RCINIT_STACK_SIZE_STATIC, RCINIT_STACK_ROUNDUP))))

   PlaybookOutputLog.append('\n')
   PlaybookOutputLog.append('Build Maximum Stack         {: <12s} {: <30s}\n'.format(str(RCINIT_STACK_SIZE_LARGEST), RCINIT_STACK_SIZE_LARGEST_NAME))
   PlaybookOutputLog.append('Build Minimum Priority      {: <12s} {: <30s}\n'.format(str(RCINIT_PRIORITY_MINIMUM), RCINIT_PRIORITY_MINIMUM_NAME))
   PlaybookOutputLog.append('Build Maximum Priority      {: <12s} {: <30s}\n'.format(str(RCINIT_PRIORITY_MAXIMUM), RCINIT_PRIORITY_MAXIMUM_NAME))

   PlaybookOutputLog.append('\nNOTES\n')
   PlaybookOutputLog.append('Specific field does not appy is denoted by "' + RCINIT_OUTPUT_NA + '".\n')
   PlaybookOutputLog.append('TECH AREA supplied unique name too long for NHLOS space requirements is denoted by "' + RCINIT_OUTPUT_LEN + '"; shorten it.\n')
   PlaybookOutputLog.append('"Started" field of "' + RCINIT_OUTPUT_NA + '" denotes TECH AREA function or task is not executed at runtime startup,\n')
   PlaybookOutputLog.append('reguardless of group assignment, and may indicate dynamic use case is expected. Consult with TECH AREA.\n')

   PlaybookOutputLog.append('\n')
   PlaybookOutputLog.append('****************************************\n')

   PlaybookOutputLog.append('\n')
   debuglinefmt = '{: <25.25s} {: <12.12s} {: <22.22s} {: <45.45s} {: <12.12s} {: <12.12s} {: <60.60s} {: <40.40s} {: <25.25s}\n'
   PlaybookOutputLog.append(debuglinefmt.format('Name', 'Hash', 'NHLOS API', 'NHLOS Priority', 'Stack', 'StackDyn', 'Function Dependency', 'Policy', 'Started'))
   PlaybookOutputLog.append('\n-----------------------------------------------------------------------------------\n')

   for i in range(RCINIT_SEQUENCE_GROUP_MAX):

      PlaybookOutputLog.append('*** RCINIT_GROUP_{:d}\n'.format(i))
      PlaybookOutputLog.append('\n')

      for entry in env_rcinit_pol[RCINIT_NOPOLICY_ORDERED_LIST][i]:
         #skip entry if policy doesnt apply
         filteredPolicyList = list(set(entry[RCINIT_POLICY_OPTIN]) & set(env_rcinit_pol[RCINIT_POLICY_USE_LIST]))
         if len(filteredPolicyList) == 0:
            continue
         if entry[RCINIT_INFO_TYPE] == RCINIT_INFO_FUNCTION or entry[RCINIT_INFO_TYPE] == RCINIT_INFO_POLICY:
            PlaybookOutputLog.append(debuglinefmt.format(
               RCINIT_OUTPUT_LEN + entry[RCINIT_INFO_NAME] if len(entry[RCINIT_INFO_NAME]) > RCINIT_NAME_MAXLEN else entry[RCINIT_INFO_NAME],
               entry[RCINIT_INFO_HASH], RCINIT_OUTPUT_NA, RCINIT_OUTPUT_NA, RCINIT_OUTPUT_NA,
               RCINIT_OUTPUT_NA,
               entry[RCINIT_DEPENDENCIES_FILTER], filteredPolicyList,
               RCINIT_OUTPUT_TRUE if entry[INIT_ENTRY] != RCINIT_NULL else RCINIT_OUTPUT_NA))
      for entry in env_rcinit_pol[RCINIT_NOPOLICY_ORDERED_LIST][i]:
         #skip entry if policy doesnt apply
         filteredPolicyList = list(set(entry[RCINIT_POLICY_OPTIN]) & set(env_rcinit_pol[RCINIT_POLICY_USE_LIST]))
         if len(filteredPolicyList) == 0:
            continue
         if entry[RCINIT_INFO_TYPE] == RCINIT_INFO_TASK:
            if entry[THREAD_PRIORITY_ALIAS] is not None:
               debugPrioEnum = entry[THREAD_PRIORITY_ALIAS] + '(' + entry[THREAD_PRIORITY] + ')'
            else:
               debugPrioEnum = entry[THREAD_PRIORITY]
            PlaybookOutputLog.append(debuglinefmt.format(
               RCINIT_OUTPUT_LEN + entry[RCINIT_INFO_NAME] if len(entry[RCINIT_INFO_NAME]) > RCINIT_NAME_MAXLEN else entry[RCINIT_INFO_NAME],
               entry[RCINIT_INFO_HASH], entry[THREAD_API], debugPrioEnum, entry[THREAD_STACK],
               RCINIT_OUTPUT_TRUE if entry[RCINIT_INFO_STACK_STATIC] == None else RCINIT_OUTPUT_FALSE,
               RCINIT_OUTPUT_NA, filteredPolicyList,
               RCINIT_OUTPUT_TRUE if entry[THREAD_ENTRY] != RCINIT_NULL else RCINIT_OUTPUT_NA))

      PlaybookOutputLog.append('\n-----------------------------------------------------------------------------------\n')

   PlaybookOutputLog.append('\n')
   debuglinefmt = '{: <25.25s} {: <60s}\n'
   PlaybookOutputLog.append(debuglinefmt.format('Name', 'Defined At'))
   rcinit_ents = sorted(env_rcinit[RCINIT_INFO_LIST], key=lambda k: k[RCINIT_INFO_NAME])
   for entry in rcinit_ents:
      PlaybookOutputLog.append(
         debuglinefmt.format(RCINIT_OUTPUT_LEN + entry[RCINIT_INFO_NAME] if len(entry[RCINIT_INFO_NAME]) > RCINIT_NAME_MAXLEN else entry[RCINIT_INFO_NAME],
            entry[RCINIT_INFO_DEFINED]))

   #append output log to end of file
   PlaybookOutput.append('/*\n')
   for line in PlaybookOutputLog:
      PlaybookOutput.append(line)
   PlaybookOutput.append('*/\n')

   # Output what was requested from builder based on extension

   if target_ext == RCINIT_EXT_PB:
      tool_update_file_c(env_rcinit, target_full, PlaybookOutput)

   # Intermediate Output
   elif target_ext == RCINIT_EXT_PL:
      tool_update_file_rcpl(env_rcinit, target_full, None)

   # Intermediate Output
   elif target_ext == RCINIT_EXT_CSV:
      tool_update_file_csv(env_rcinit, target_full, None)

   # Diagnostic Output
   elif target_ext == RCINIT_EXT_LOG:
      tool_update_file_log(env_rcinit, target_full, PlaybookOutputLog)

   return 0 # Indicate SUCCESS back

#===============================================================================

#===============================================================================

#===============================================================================

#===============================================================================

#===============================================================================

def tool_method_add_playbook(env, build_ids, output, input):
   ''' Method Call, Calls RCInitBuilder '''
   env.TmsDebug('tool_method_add_playbook('+str(output)+')')

   if not isinstance(input, list):
      input = [input]

   if not isinstance(output, list):
      output = [output]

   output_full = env.RealPath(str(output[0]))
   output_path = os.path.split(output_full)[0]
   output_stem, output_ext = os.path.splitext(output_full)

   if output_ext == '': # Assign RCINIT_EXT_PB
      output_full = output_stem + RCINIT_EXT_PB
      env.RequirePublicApi([ 'TMS', 'DEBUGTOOLS', 'DAL', 'DEBUGTRACE', 'SERVICES', 'SYSTEMDRIVERS', 'KERNEL', ])
      #env.RequireRestrictedApi([ 'TMS_RESTRICTED', 'DEBUGTOOLS', ])
      output = env.RCInitBuilder(target=output_full, source=input)

   elif output_ext == RCINIT_EXT_PB:
      env.RequirePublicApi([ 'TMS', 'DEBUGTOOLS', 'DAL', 'DEBUGTRACE', 'SERVICES', 'SYSTEMDRIVERS', 'KERNEL', ])
      #env.RequireRestrictedApi([ 'TMS_RESTRICTED', 'DEBUGTOOLS', ])
      output = env.RCInitBuilder(target=output_full, source=input)

   elif output_ext == RCINIT_EXT_LOG:
      output = env.RCInitBuilder(target=output_full, source=input)

   else:
      env.TmsError(RCINIT_POC_IO + ' Method call with unrecognised file type "' + output_ext + '"')

   return output, input

#===============================================================================

def tool_method_add_playlist(env, build_ids, output):
   ''' Method Call, Calls RCInitBuilder '''
   env.TmsDebug('tool_method_add_playlist('+str(output)+')')

   if not isinstance(output, list):
      output = [output]

   output_full = env.RealPath(str(output[0]))
   output_path = os.path.split(output_full)[0]
   output_stem, output_ext = os.path.splitext(output_full)

   if output_ext == '': # Assign RCINIT_EXT_PL
      output_full = output_stem + RCINIT_EXT_PL
      env.RCInitBuilder(target=output_full, source=None)

   elif output_ext == RCINIT_EXT_PL:
      env.RCInitBuilder(target=output_full, source=None)

   elif output_ext == RCINIT_EXT_CSV:
      env.RCInitBuilder(target=output_full, source=None)

   else:
      env.TmsError(RCINIT_POC_IO + ' Method call with unrecognised file type "' + output_ext + '"')

   return output, input

#===============================================================================

def tool_method_add_task(env, build_ids, input_dict):
   ''' Method Call, Adds RCINIT Task
   Validates input and stores to 'globals' construction environment
   Runs before tool_emitter() function '''

   # 'globals' information saved in the construction environment
   env_rcinit = env[ENV_RCINIT]           # construct env task/function dictionary
   env_rcinit_pol = env[ENV_RCINIT_POL]   # construct env policy utilization dictionary

   # caller python frame of interest
   frame, filename, line_number, function_name, lines, index = inspect.getouterframes(inspect.currentframe())[2]
   env_rcinit[RCINIT_PLSOURCE].append(filename)

   # define the layout of the ordered dict, all fields in expected
   # ordering of the fields

   output_dict = OrderedDict()
   output_dict[RCINIT_INFO_NAME] = None
   output_dict[RCINIT_INFO_TYPE] = RCINIT_INFO_TASK
   output_dict[RCINIT_INFO_HASH] = None
   output_dict[RCINIT_INFO_GROUP] = None
   output_dict[RCINIT_INFO_API] = None
   output_dict[RCINIT_INFO_ENTRY] = None
   output_dict[RCINIT_INFO_POLICY] = None
   output_dict[RCINIT_INFO_DEPENDENCY] = None
   output_dict[RCINIT_INFO_AFFINITY] = None
   output_dict[RCINIT_INFO_STACK] = None
   output_dict[RCINIT_INFO_STACK_STATIC] = None
   output_dict[RCINIT_INFO_PRIORITY] = None
   output_dict[RCINIT_INFO_DEFINED] = { 'file' : None, 'line' : None }
   if input_dict.has_key(RCINIT_INFO_DEFINED):
      output_dict[RCINIT_INFO_DEFINED] = input_dict[RCINIT_INFO_DEFINED]
   else:
      output_text = filename.replace('\\','/').lower().replace(env.get('BUILD_ROOT', None).lower()+'/', '')
      output_dict[RCINIT_INFO_DEFINED] = { 'file' : output_text, 'line' : line_number }

   #read in name
   if not input_dict.has_key(THREAD_NAME):
      env.TmsError(RCINIT_POC_TA + ' Create an unique name for thread')
   if len(input_dict[THREAD_NAME]) > RCINIT_NAME_MAXLEN:
      if env.GetOption('clean') or env.GetOption('no_exec'):
         pass
      else:
         if env.GetUsesFlag('USES_RCINIT_OPTION_CHECK_NHLOS_UNIQUE'):
            env.TmsError(RCINIT_POC_TA + ' Shorten unique name for NHLOS space requirements  ' + str(RCINIT_NAME_MAXLEN) + ' ' + input_dict[THREAD_NAME])
         else:
            env.TmsInfo(RCINIT_POC_TA + ' Shorten unique name for NHLOS space requirements  ' + str(RCINIT_NAME_MAXLEN) + ' ' + input_dict[THREAD_NAME])

   #ensure name is unique
   output_dict[THREAD_NAME] = input_dict[THREAD_NAME].lower()
   output_dict[RCINIT_INFO_NAME] = output_dict[THREAD_NAME]
   output_dict[RCINIT_INFO_HASH] = '{:#x}'.format(namehash(output_dict[RCINIT_INFO_NAME]))

   # Process input on SCONS Command Options
   if env.GetOption('clean') or env.GetOption('no_exec'):
      env.TmsDebug('TARGET CLEAN/NO_EXEC RCInitAddTask {:s} "{:s}" {:d}'.format(output_dict[RCINIT_INFO_NAME], output_dict[RCINIT_INFO_DEFINED]['file'], output_dict[RCINIT_INFO_DEFINED]['line']))
      return None # RETURN, IGNORED
   # Ignore input on specified BUILD_ID not being active
   elif build_ids is not None and not env.IsTargetEnable(build_ids):
      env.TmsDebug('TARGET NOT ACTIVE RCInitAddTask {:s} "{:s}" {:d}'.format(output_dict[RCINIT_INFO_NAME], output_dict[RCINIT_INFO_DEFINED]['file'], output_dict[RCINIT_INFO_DEFINED]['line']))
      return None # RETURN, IGNORED

   for threads in env_rcinit[RCINIT_INFO_LIST]:
      if threads.has_key(RCINIT_INFO_NAME) and output_dict[RCINIT_INFO_NAME] == threads[RCINIT_INFO_NAME]:
         env.TmsError(RCINIT_POC_TA + ' Create unique name for {:s}'.format(output_dict[RCINIT_INFO_NAME]))
      if threads.has_key(RCINIT_INFO_HASH) and output_dict[RCINIT_INFO_HASH] == threads[RCINIT_INFO_HASH]:
         env.TmsError(RCINIT_POC_TA + ' Create unique name for hash {:s}'.format(output_dict[RCINIT_INFO_NAME]))

   #read in policy list
   if input_dict.has_key(RCINIT_POLICY_OPTIN):
      if not isinstance(input_dict[RCINIT_POLICY_OPTIN], list):
         env.TmsError(RCINIT_POC_TA + ' Create a valid policy list for {:s}'.format(output_dict[RCINIT_INFO_NAME]))
      output_dict[RCINIT_POLICY_OPTIN] = [item.lower() for item in input_dict[RCINIT_POLICY_OPTIN]]
      output_dict[RCINIT_INFO_POLICY] = [item.lower() for item in input_dict[RCINIT_POLICY_OPTIN]]
   else:
      output_dict[RCINIT_POLICY_OPTIN] = RCINIT_POLICY_DEFAULT
      output_dict[RCINIT_INFO_POLICY] = RCINIT_POLICY_DEFAULT

   #read in sequence level
   if not input_dict.has_key(RCINIT_SEQUENCE_GROUP):
      env.TmsError(RCINIT_POC_TA + ' Use a valid group for {:s}'.format(output_dict[RCINIT_INFO_NAME]))
   if input_dict[RCINIT_SEQUENCE_GROUP] not in RCINIT_SEQUENCE_GROUP_KEYS.keys():
      env.TmsError(RCINIT_POC_TA + ' Use a valid group for {:s}'.format(output_dict[RCINIT_INFO_NAME]))
   output_dict[RCINIT_SEQUENCE_GROUP] = RCINIT_SEQUENCE_GROUP_KEYS[input_dict[RCINIT_SEQUENCE_GROUP]]
   output_dict[RCINIT_INFO_GROUP] = RCINIT_SEQUENCE_GROUP_KEYS[input_dict[RCINIT_SEQUENCE_GROUP]]

   #read in thread type
   if input_dict.has_key(THREAD_API):
      if input_dict[THREAD_API] not in THREAD_API_TYPES:
         env.TmsError(RCINIT_POC_TA + ' Use a valid NHLOS KERNEL API for {:s}'.format(output_dict[RCINIT_INFO_NAME]))
      output_dict[THREAD_API] = input_dict[THREAD_API]
      output_dict[RCINIT_INFO_API] = input_dict[THREAD_API]
   else:
      output_dict[THREAD_API] = THREAD_API_REX
      output_dict[RCINIT_INFO_API] = THREAD_API_REX

   #validation
   error = 0
   if output_dict[RCINIT_INFO_API] == THREAD_API_DAL and not env.GetUsesFlag('USES_DAL'):
      error = 1
   elif output_dict[RCINIT_INFO_API] == THREAD_API_POSIX and not env.GetUsesFlag('USES_POSIX'):
      error = 1
   elif output_dict[RCINIT_INFO_API] == THREAD_API_QURT and not env.GetUsesFlag('USES_QURT'):
      error = 1
   elif output_dict[RCINIT_INFO_API] == THREAD_API_REX and not env.GetUsesFlag('USES_REX'):
      error = 1
   if error == 1:
      env.TmsError(RCINIT_POC_TA + ' Use a valid NHLOS KERNEL API for {:s}'.format(output_dict[RCINIT_INFO_API]))

   if input_dict.has_key(THREAD_STACK):
      output_dict[THREAD_STACK] = input_dict[THREAD_STACK]
      output_dict[RCINIT_INFO_STACK] = input_dict[THREAD_STACK]
   else:
      output_dict[THREAD_STACK] = ''
      output_dict[RCINIT_INFO_STACK] = ''

   if input_dict.has_key(THREAD_STACK_STATIC):
      output_dict[THREAD_STACK_STATIC] = input_dict[THREAD_STACK_STATIC]
      output_dict[RCINIT_INFO_STACK_STATIC] = input_dict[THREAD_STACK_STATIC]

   #read in priority
   output_dict[THREAD_PRIORITY_ALIAS] = None

   # FORCE_ALIASMAP
   if env.GetUsesFlag('USES_RCINIT_OPTION_FORCE_ALIASMAP'):

      if input_dict.has_key(RCINIT_INFO_PRIORITY_ALIAS) and input_dict[RCINIT_INFO_PRIORITY_ALIAS] in env[RCINIT_PRIO_ALIAS_DICT].keys():
         output_dict[THREAD_PRIORITY] = env[RCINIT_PRIO_ALIAS_DICT][input_dict[RCINIT_INFO_PRIORITY_ALIAS]]       # NUMERIC
         output_dict[THREAD_PRIORITY_ALIAS] = input_dict[RCINIT_INFO_PRIORITY_ALIAS]                              # ALIAS
         output_dict[RCINIT_INFO_PRIORITY] = env[RCINIT_PRIO_ALIAS_DICT][input_dict[RCINIT_INFO_PRIORITY_ALIAS]]  # NUMERIC
         output_dict[RCINIT_INFO_PRIORITY_ALIAS] = input_dict[RCINIT_INFO_PRIORITY_ALIAS]                         # ALIAS

         #Optional Priority Min/Max Check
         if (RCINIT_CHECK_SHARED_PRI_ORDER or env.GetUsesFlag('USES_RCINIT_OPTION_CHECK_SHARED_PRI_ORDER')):
            if ('SHARED_IST_PRI_ORDER' in env[RCINIT_PRIO_ALIAS_DICT] and
               output_dict[THREAD_PRIORITY] > env[RCINIT_PRIO_ALIAS_DICT]['SHARED_IST_PRI_ORDER']):
               env.TmsError(RCINIT_POC_TA + ' Use lower priority from FORCED ALIAS MAP for {:s}'.format(output_dict[RCINIT_INFO_NAME]))
            elif ('SHARED_IDLE_SERVICE_PRI_ORDER' in env[RCINIT_PRIO_ALIAS_DICT] and
               output_dict[THREAD_PRIORITY] < env[RCINIT_PRIO_ALIAS_DICT]['SHARED_IDLE_SERVICE_PRI_ORDER']):
               env.TmsError(RCINIT_POC_TA + ' Use higher priority from FORCED ALIAS MAP for {:s}'.format(output_dict[RCINIT_INFO_NAME]))
            else:
               env.TmsDebug(RCINIT_POC_TA + ' Using FORCED ALIAS MAP reference for {:s}'.format(output_dict[RCINIT_INFO_NAME]))

      elif input_dict.has_key(THREAD_PRIORITY) and input_dict[THREAD_PRIORITY] in env[RCINIT_PRIO_ALIAS_DICT].keys():
         output_dict[THREAD_PRIORITY] = env[RCINIT_PRIO_ALIAS_DICT][input_dict[THREAD_PRIORITY]]                  # NUMERIC
         output_dict[THREAD_PRIORITY_ALIAS] = input_dict[THREAD_PRIORITY]                                         # ALIAS
         output_dict[RCINIT_INFO_PRIORITY] = env[RCINIT_PRIO_ALIAS_DICT][input_dict[THREAD_PRIORITY]]             # NUMERIC
         output_dict[RCINIT_INFO_PRIORITY_ALIAS] = input_dict[THREAD_PRIORITY]                                    # ALIAS

         #Optional Priority Min/Max Check
         if (RCINIT_CHECK_SHARED_PRI_ORDER or env.GetUsesFlag('USES_RCINIT_OPTION_CHECK_SHARED_PRI_ORDER')):
            if ('SHARED_IST_PRI_ORDER' in env[RCINIT_PRIO_ALIAS_DICT] and
               output_dict[THREAD_PRIORITY] > env[RCINIT_PRIO_ALIAS_DICT]['SHARED_IST_PRI_ORDER']):
               env.TmsError(RCINIT_POC_TA + ' Use lower priority from FORCED ALIAS MAP for {:s}'.format(output_dict[RCINIT_INFO_NAME]))
            elif ('SHARED_IDLE_SERVICE_PRI_ORDER' in env[RCINIT_PRIO_ALIAS_DICT] and
               output_dict[THREAD_PRIORITY] < env[RCINIT_PRIO_ALIAS_DICT]['SHARED_IDLE_SERVICE_PRI_ORDER']):
               env.TmsError(RCINIT_POC_TA + ' Use higher priority from FORCED ALIAS MAP for {:s}'.format(output_dict[RCINIT_INFO_NAME]))
            else:
               env.TmsDebug(RCINIT_POC_TA + ' Using FORCED ALIAS MAP reference for {:s}'.format(output_dict[RCINIT_INFO_NAME]))

      else:
         env.TmsError(RCINIT_POC_TA + ' Use priority from FORCED ALIAS MAP for {:s}'.format(output_dict[RCINIT_INFO_NAME]))

   # !FORCE_ALIASMAP
   else:

      if input_dict.has_key(RCINIT_INFO_PRIORITY_ALIAS) and input_dict[RCINIT_INFO_PRIORITY_ALIAS] in env[RCINIT_PRIO_ALIAS_DICT].keys():
         output_dict[THREAD_PRIORITY] = env[RCINIT_PRIO_ALIAS_DICT][input_dict[RCINIT_INFO_PRIORITY_ALIAS]]       # NUMERIC
         output_dict[THREAD_PRIORITY_ALIAS] = input_dict[RCINIT_INFO_PRIORITY_ALIAS]                              # ALIAS
         output_dict[RCINIT_INFO_PRIORITY] = env[RCINIT_PRIO_ALIAS_DICT][input_dict[RCINIT_INFO_PRIORITY_ALIAS]]  # NUMERIC
         output_dict[RCINIT_INFO_PRIORITY_ALIAS] = input_dict[RCINIT_INFO_PRIORITY_ALIAS]                         # ALIAS

         #Optional Priority Min/Max Check
         if (RCINIT_CHECK_SHARED_PRI_ORDER or env.GetUsesFlag('USES_RCINIT_OPTION_CHECK_SHARED_PRI_ORDER')):
            if ('SHARED_IST_PRI_ORDER' in env[RCINIT_PRIO_ALIAS_DICT] and
               output_dict[THREAD_PRIORITY] > env[RCINIT_PRIO_ALIAS_DICT]['SHARED_IST_PRI_ORDER']):
               env.TmsInfo(RCINIT_POC_TA + ' Use lower priority from ALIAS MAP for {:s}'.format(output_dict[RCINIT_INFO_NAME]))
            elif ('SHARED_IDLE_SERVICE_PRI_ORDER' in env[RCINIT_PRIO_ALIAS_DICT] and
               output_dict[THREAD_PRIORITY] < env[RCINIT_PRIO_ALIAS_DICT]['SHARED_IDLE_SERVICE_PRI_ORDER']):
               env.TmsInfo(RCINIT_POC_TA + ' Use higher priority from ALIAS MAP for {:s}'.format(output_dict[RCINIT_INFO_NAME]))
            else:
               env.TmsDebug(RCINIT_POC_TA + ' Using ALIAS MAP reference for {:s}'.format(output_dict[RCINIT_INFO_NAME]))

      elif input_dict.has_key(THREAD_PRIORITY) and input_dict[THREAD_PRIORITY] in env[RCINIT_PRIO_ALIAS_DICT].keys():
         output_dict[THREAD_PRIORITY] = env[RCINIT_PRIO_ALIAS_DICT][input_dict[THREAD_PRIORITY]]                  # NUMERIC
         output_dict[THREAD_PRIORITY_ALIAS] = input_dict[THREAD_PRIORITY]                                         # ALIAS
         output_dict[RCINIT_INFO_PRIORITY] = env[RCINIT_PRIO_ALIAS_DICT][input_dict[THREAD_PRIORITY]]             # NUMERIC
         output_dict[RCINIT_INFO_PRIORITY_ALIAS] = input_dict[THREAD_PRIORITY]                                    # ALIAS

         #Optional Priority Min/Max Check
         if (RCINIT_CHECK_SHARED_PRI_ORDER or env.GetUsesFlag('USES_RCINIT_OPTION_CHECK_SHARED_PRI_ORDER')):
            if ('SHARED_IST_PRI_ORDER' in env[RCINIT_PRIO_ALIAS_DICT] and
               output_dict[THREAD_PRIORITY] > env[RCINIT_PRIO_ALIAS_DICT]['SHARED_IST_PRI_ORDER']):
               env.TmsInfo(RCINIT_POC_TA + ' Use lower priority from ALIAS MAP for {:s}'.format(output_dict[RCINIT_INFO_NAME]))
            elif ('SHARED_IDLE_SERVICE_PRI_ORDER' in env[RCINIT_PRIO_ALIAS_DICT] and
               output_dict[THREAD_PRIORITY] < env[RCINIT_PRIO_ALIAS_DICT]['SHARED_IDLE_SERVICE_PRI_ORDER']):
               env.TmsInfo(RCINIT_POC_TA + ' Use higher priority from ALIAS MAP for {:s}'.format(output_dict[RCINIT_INFO_NAME]))
            else:
               env.TmsDebug(RCINIT_POC_TA + ' Using ALIAS MAP reference for {:s}'.format(output_dict[RCINIT_INFO_NAME]))

      else:
         output_dict[THREAD_PRIORITY] = input_dict[THREAD_PRIORITY]                                               # NUMERIC/ALIAS PASS TO COMPILE
         output_dict[THREAD_PRIORITY_ALIAS] = None                                                                # NA
         output_dict[RCINIT_INFO_PRIORITY] = input_dict[THREAD_PRIORITY]                                          # NUMERIC/ALIAS PASS TO COMPILE
         output_dict[RCINIT_INFO_PRIORITY_ALIAS] = input_dict[THREAD_PRIORITY]                                    # NUMERIC/ALIAS PASS TO COMPILE
         env.TmsInfo(RCINIT_POC_TA + ' Use priority from ALIAS MAP for {:s}'.format(output_dict[RCINIT_INFO_NAME]))

   #read in thread entry
   if input_dict.has_key(THREAD_ENTRY):
      if RCINIT_NULL != input_dict[THREAD_ENTRY] and None == re.search('^[A-Za-z0-9_]+Task$|^[A-Za-z0-9_]+_task$', input_dict[THREAD_ENTRY]):
         env.TmsDebug(RCINIT_POC_TA + ' Rename entry point to include suffix of "Task" or "_task" ' + input_dict[THREAD_NAME])
      output_dict[THREAD_ENTRY] = input_dict[THREAD_ENTRY]
      output_dict[RCINIT_INFO_ENTRY] = output_dict[THREAD_ENTRY]
   else:
      output_dict[THREAD_ENTRY] = output_dict[THREAD_NAME] + '_task'
      output_dict[RCINIT_INFO_ENTRY] = output_dict[THREAD_ENTRY]
      env.TmsDebug(RCINIT_POC_TA + ' Create explicit entry point for ' + input_dict[THREAD_NAME])

	#read in thread tcb
   if input_dict.has_key(THREAD_TCB):
      if RCINIT_NULL != input_dict[THREAD_TCB] and None == re.search('^[A-Za-z0-9_]+_tcb$', input_dict[THREAD_TCB]):
         env.TmsDebug(RCINIT_POC_TA + ' Rename TCB to include suffix of "_tcb" ' + input_dict[THREAD_TCB])
      output_dict[THREAD_TCB] = input_dict[THREAD_TCB]
      env.TmsInfo(RCINIT_POC_TA + ' Do not create explicit compile time TCB definition to task ' + input_dict[THREAD_NAME])
   else:
      output_dict[THREAD_TCB] = RCINIT_NULL

   #read in dependencies (not allowed for tasks)
   if input_dict.has_key(RCINIT_DEPENDENCIES) and len(input_dict[RCINIT_DEPENDENCIES]) > 0:
      env.TmsInfo(RCINIT_POC_TA + ' Remove dependencies that are not applicable to task ' + input_dict[THREAD_NAME])
   output_dict[RCINIT_DEPENDENCIES] = []
   output_dict[RCINIT_INFO_DEPENDENCY] = []

   #read in cpu affinity
   if input_dict.has_key(THREAD_AFFINITY):
      output_dict[THREAD_AFFINITY] = input_dict[THREAD_AFFINITY]
      output_dict[RCINIT_INFO_AFFINITY] = input_dict[THREAD_AFFINITY]
      if output_dict[THREAD_API] != THREAD_API_REX:
         env.TmsInfo(RCINIT_POC_TA + ' Remove NHLOS cpu_affinity that is not applicable to task ' + input_dict[THREAD_NAME])
   else:
      output_dict[THREAD_AFFINITY] = RCINIT_AFFINITY_ALL
      output_dict[RCINIT_INFO_AFFINITY] = RCINIT_AFFINITY_ALL

   #if this is a new policy, create dictionary/lists
   for policy in output_dict[RCINIT_POLICY_OPTIN]:
      if policy not in env_rcinit_pol[RCINIT_POLICY_DICT].keys():
         env_rcinit_pol[RCINIT_POLICY_DICT][policy] = []
         for i in range(RCINIT_SEQUENCE_GROUP_MAX):
            env_rcinit_pol[RCINIT_POLICY_DICT][policy].append([])
   #add entry to each policy  list
   env_rcinit_pol[RCINIT_NOPOLICY_ORDERED_LIST][env.TmsToInt(output_dict[RCINIT_SEQUENCE_GROUP])].append(output_dict)
   for policy in output_dict[RCINIT_POLICY_OPTIN]:
      env_rcinit_pol[RCINIT_POLICY_DICT][policy][env.TmsToInt(output_dict[RCINIT_SEQUENCE_GROUP])].append(output_dict)

   #add to environment descriptor
   env_rcinit[RCINIT_INFO_LIST].append(output_dict)
   env.TmsDebug('RCInitAddTask {:s} "{:s}" {:d}'.format(output_dict[RCINIT_INFO_NAME], output_dict[RCINIT_INFO_DEFINED]['file'], output_dict[RCINIT_INFO_DEFINED]['line']))

   return None

#===============================================================================

def tool_method_add_function(env, build_ids, input_dict):
   ''' Method Call, Adds RCINIT Function
   Validates input and stores to 'globals' construction environment
   Runs before tool_emitter() function '''

   # 'globals' information saved in the construction environment
   env_rcinit = env[ENV_RCINIT]           # construct env task/function dictionary
   env_rcinit_pol = env[ENV_RCINIT_POL]   # construct env policy utilization dictionary

   # caller python frame of interest
   frame, filename, line_number, function_name, lines, index = inspect.getouterframes(inspect.currentframe())[2]
   env_rcinit[RCINIT_PLSOURCE].append(filename)

   # define the layout of the ordered dict, all fields in expected
   # ordering of the fields

   output_dict = OrderedDict()
   output_dict[RCINIT_INFO_NAME] = None
   output_dict[RCINIT_INFO_TYPE] = RCINIT_INFO_FUNCTION
   output_dict[RCINIT_INFO_HASH] = None
   output_dict[RCINIT_INFO_GROUP] = None
   output_dict[RCINIT_INFO_API] = None
   output_dict[RCINIT_INFO_ENTRY] = None
   output_dict[RCINIT_INFO_POLICY] = None
   output_dict[RCINIT_INFO_DEPENDENCY] = None
   output_dict[RCINIT_INFO_AFFINITY] = None
   output_dict[RCINIT_INFO_STACK] = None
   output_dict[RCINIT_INFO_PRIORITY] = None
   output_dict[RCINIT_INFO_DEFINED] = None
   if input_dict.has_key(RCINIT_INFO_DEFINED):
      output_dict[RCINIT_INFO_DEFINED] = input_dict[RCINIT_INFO_DEFINED]
   else:
      output_text = filename.replace('\\','/').lower().replace(env.get('BUILD_ROOT', None).lower()+'/', '')
      output_dict[RCINIT_INFO_DEFINED] = { 'file' : output_text, 'line' : line_number }

   #read in name
   if not input_dict.has_key(INIT_NAME):
      env.TmsError(RCINIT_POC_TA + ' Create an unique name for function')
   if len(input_dict[INIT_NAME]) > RCINIT_NAME_MAXLEN:
      if env.GetOption('clean') or env.GetOption('no_exec'):
         pass
      else:
         if env.GetUsesFlag('USES_RCINIT_OPTION_CHECK_NHLOS_UNIQUE'):
            env.TmsError(RCINIT_POC_TA + ' Shorten unique name for NHLOS space requirements  ' + str(RCINIT_NAME_MAXLEN) + ' ' + input_dict[INIT_NAME])
         else:
            env.TmsInfo(RCINIT_POC_TA + ' Shorten unique name for NHLOS space requirements ' + str(RCINIT_NAME_MAXLEN) + ' ' + input_dict[INIT_NAME])

   #ensure name is unique
   output_dict[INIT_NAME] = input_dict[INIT_NAME].lower()
   output_dict[RCINIT_INFO_NAME] = output_dict[INIT_NAME]
   output_dict[RCINIT_INFO_HASH] = '{:#x}'.format(namehash(output_dict[RCINIT_INFO_NAME]))

   # Process input on SCONS Command Options
   if env.GetOption('clean') or env.GetOption('no_exec'):
      env.TmsDebug('TARGET CLEAN/NO_EXEC RCInitAddFunc {:s} "{:s}" {:d}'.format(output_dict[RCINIT_INFO_NAME], output_dict[RCINIT_INFO_DEFINED]['file'], output_dict[RCINIT_INFO_DEFINED]['line']))
      return None # RETURN, IGNORED
   # Ignore input on specified BUILD_ID not being active
   elif build_ids is not None and not env.IsTargetEnable(build_ids):
      env.TmsDebug('TARGET NOT ACTIVE RCInitAddFunc {:s} "{:s}" {:d}'.format(output_dict[RCINIT_INFO_NAME], output_dict[RCINIT_INFO_DEFINED]['file'], output_dict[RCINIT_INFO_DEFINED]['line']))
      return None # RETURN, IGNORED

   for threads in env_rcinit[RCINIT_INFO_LIST]:
      if threads.has_key(RCINIT_INFO_NAME) and output_dict[RCINIT_INFO_NAME] == threads[RCINIT_INFO_NAME]:
         env.TmsError(RCINIT_POC_TA + ' Create unique name for {:s}'.format(output_dict[RCINIT_INFO_NAME]))
      if threads.has_key(RCINIT_INFO_HASH) and output_dict[RCINIT_INFO_HASH] == threads[RCINIT_INFO_HASH]:
         env.TmsError(RCINIT_POC_TA + ' Create unique name for hash {:s}'.format(output_dict[RCINIT_INFO_NAME]))

   #read in policy list
   if input_dict.has_key(RCINIT_POLICY_OPTIN):
      if not isinstance(input_dict[RCINIT_POLICY_OPTIN], list):
         env.TmsError(RCINIT_POC_TA + ' Create a valid policy list for {:s}'.format(output_dict[RCINIT_INFO_NAME]))
      output_dict[RCINIT_POLICY_OPTIN] = [item.lower() for item in input_dict[RCINIT_POLICY_OPTIN]]
      output_dict[RCINIT_INFO_POLICY] = [item.lower() for item in input_dict[RCINIT_POLICY_OPTIN]]
   else:
      output_dict[RCINIT_POLICY_OPTIN] = RCINIT_POLICY_DEFAULT
      output_dict[RCINIT_INFO_POLICY] = RCINIT_POLICY_DEFAULT

   #read in init function if applicable
   if input_dict.has_key(INIT_ENTRY):
      if RCINIT_NULL != input_dict[INIT_ENTRY] and None == re.search('^[A-Za-z0-9_]+Init$|^[A-Za-z0-9_]+_init$', input_dict[INIT_ENTRY]):
         env.TmsDebug(RCINIT_POC_TA + ' Rename entry point to include suffix of "Init" or "_init" ' + input_dict[INIT_NAME])
      output_dict[INIT_ENTRY] = input_dict[INIT_ENTRY]
      output_dict[RCINIT_INFO_ENTRY] = output_dict[INIT_ENTRY]
   else:
      output_dict[INIT_ENTRY] = output_dict[INIT_NAME] + '_init'
      output_dict[RCINIT_INFO_ENTRY] = output_dict[INIT_ENTRY]
      env.TmsInfo(RCINIT_POC_TA + ' Create explicit entry point for ' + input_dict[INIT_NAME])

   #read in sequence level
   if not input_dict.has_key(RCINIT_SEQUENCE_GROUP):
      env.TmsError(RCINIT_POC_TA + ' Use a valid group for {:s}'.format(output_dict[RCINIT_INFO_NAME]))
   if input_dict[RCINIT_SEQUENCE_GROUP] not in RCINIT_SEQUENCE_GROUP_KEYS.keys():
      env.TmsError(RCINIT_POC_TA + ' Use a valid group for {:s}'.format(output_dict[RCINIT_INFO_NAME]))
   output_dict[RCINIT_SEQUENCE_GROUP] = RCINIT_SEQUENCE_GROUP_KEYS[input_dict[RCINIT_SEQUENCE_GROUP]]
   output_dict[RCINIT_INFO_GROUP] = RCINIT_SEQUENCE_GROUP_KEYS[input_dict[RCINIT_SEQUENCE_GROUP]]

   #init function, no thread type
   output_dict[THREAD_API] = THREAD_API_FUNC
   output_dict[RCINIT_INFO_API] = THREAD_API_FUNC

   #read in stack size
   output_dict[THREAD_STACK] = RCINIT_OUTPUT_NA
   output_dict[RCINIT_INFO_STACK] = RCINIT_STKSZ_ZERO

   #read in priority
   output_dict[THREAD_PRIORITY] = RCINIT_OUTPUT_NA
   output_dict[RCINIT_INFO_PRIORITY] = RCINIT_PRIO_INITFN
   output_dict[RCINIT_INFO_PRIORITY_ALIAS] = ''

   #read in cpu affinity
   output_dict[THREAD_AFFINITY] = RCINIT_AFFINITY_ALL
   output_dict[RCINIT_INFO_AFFINITY] = RCINIT_AFFINITY_ALL

   #read in dependencies
   if input_dict.has_key(RCINIT_DEPENDENCIES):
      if not isinstance(input_dict[RCINIT_DEPENDENCIES], list):
         env.TmsError(RCINIT_POC_TA + ' Create a valid dependency list for {:s}'.format(output_dict[RCINIT_INFO_NAME]))
      output_dict[RCINIT_DEPENDENCIES] = [item.lower() for item in input_dict[RCINIT_DEPENDENCIES]]
      output_dict[RCINIT_INFO_DEPENDENCY] = [item.lower() for item in input_dict[RCINIT_DEPENDENCIES]]
   else:
      output_dict[RCINIT_DEPENDENCIES] = []
      output_dict[RCINIT_INFO_DEPENDENCY] = []
      env.TmsDebug(RCINIT_POC_TA + ' Explicit dependencies not supplied for ' + input_dict[INIT_NAME])

   #if this is a new policy, create dictionary/lists
   for policy in output_dict[RCINIT_POLICY_OPTIN]:
      if policy not in env_rcinit_pol[RCINIT_POLICY_DICT].keys():
         env_rcinit_pol[RCINIT_POLICY_DICT][policy] = []
         for i in range(RCINIT_SEQUENCE_GROUP_MAX):
            env_rcinit_pol[RCINIT_POLICY_DICT][policy].append([])
   #add entry to each policy  list
   env_rcinit_pol[RCINIT_NOPOLICY_ORDERED_LIST][env.TmsToInt(output_dict[RCINIT_SEQUENCE_GROUP])].append(output_dict)
   for policy in output_dict[RCINIT_POLICY_OPTIN]:
      env_rcinit_pol[RCINIT_POLICY_DICT][policy][env.TmsToInt(output_dict[RCINIT_SEQUENCE_GROUP])].append(output_dict)

   #add to environment descriptor
   env_rcinit[RCINIT_INFO_LIST].append(output_dict)
   env.TmsDebug('RCInitAddFunc {:s} "{:s}" {:d}'.format(output_dict[RCINIT_INFO_NAME], output_dict[RCINIT_INFO_DEFINED]['file'], output_dict[RCINIT_INFO_DEFINED]['line']))

   return None

#===============================================================================

def tool_method_add_policy(env, build_ids, input_dict):
   ''' Method Call, Adds RCINIT Policy Function
   Validates input and stores to 'globals' construction environment
   Runs before tool_emitter() function '''

   # 'globals' information saved in the construction environment
   env_rcinit = env[ENV_RCINIT]           # construct env task/function dictionary
   env_rcinit_pol = env[ENV_RCINIT_POL]   # construct env policy utilization dictionary

   # caller python frame of interest
   frame, filename, line_number, function_name, lines, index = inspect.getouterframes(inspect.currentframe())[2]
   env_rcinit[RCINIT_PLSOURCE].append(filename)

   # define the layout of the ordered dict, all fields in expected
   # ordering of the fields

   output_dict = OrderedDict()
   output_dict[RCINIT_INFO_NAME] = None
   output_dict[RCINIT_INFO_TYPE] = RCINIT_INFO_POLICY
   output_dict[RCINIT_INFO_HASH] = None
   output_dict[RCINIT_INFO_GROUP] = None
   output_dict[RCINIT_INFO_API] = None
   output_dict[RCINIT_INFO_ENTRY] = None
   output_dict[RCINIT_INFO_POLICY] = None
   output_dict[RCINIT_INFO_DEPENDENCY] = None
   output_dict[RCINIT_INFO_AFFINITY] = None
   output_dict[RCINIT_INFO_STACK] = None
   output_dict[RCINIT_INFO_PRIORITY] = None
   output_dict[RCINIT_INFO_DEFINED] = None
   if input_dict.has_key(RCINIT_INFO_DEFINED):
      output_dict[RCINIT_INFO_DEFINED] = input_dict[RCINIT_INFO_DEFINED]
   else:
      output_text = filename.replace('\\','/').lower().replace(env.get('BUILD_ROOT', None).lower()+'/', '')
      output_dict[RCINIT_INFO_DEFINED] = { 'file' : output_text, 'line' : line_number }

   #read in name
   if not input_dict.has_key(POLICY_NAME):
      env.TmsError(RCINIT_POC_TA + ' Create an unique name for policy function')
   if len(input_dict[POLICY_NAME]) > RCINIT_NAME_MAXLEN:
      if env.GetOption('clean') or env.GetOption('no_exec'):
         pass
      else:
         env.TmsError(RCINIT_POC_TA + ' Shorten unique name for NHLOS space requirements  ' + str(RCINIT_NAME_MAXLEN) + ' ' + input_dict[POLICY_NAME])

	#ensure name is unique
   output_dict[INIT_NAME] = input_dict[POLICY_NAME].lower()
   output_dict[POLICY_NAME] = input_dict[POLICY_NAME].lower()
   output_dict[RCINIT_INFO_NAME] = output_dict[INIT_NAME]
   output_dict[RCINIT_INFO_HASH] = '{:#x}'.format(namehash(output_dict[RCINIT_INFO_NAME]))

   # Process input on SCONS Command Options
   if env.GetOption('clean') or env.GetOption('no_exec'):
      env.TmsDebug('TARGET CLEAN/NO_EXEC RCInitAddPolicy {:s} "{:s}" {:d}'.format(output_dict[RCINIT_INFO_NAME], output_dict[RCINIT_INFO_DEFINED]['file'], output_dict[RCINIT_INFO_DEFINED]['line']))
      return None # RETURN, IGNORED
   # Ignore input on specified BUILD_ID not being active
   elif build_ids is not None and not env.IsTargetEnable(build_ids):
      env.TmsDebug('TARGET NOT ACTIVE RCInitAddPolicy {:s} "{:s}" {:d}'.format(output_dict[RCINIT_INFO_NAME], output_dict[RCINIT_INFO_DEFINED]['file'], output_dict[RCINIT_INFO_DEFINED]['line']))
      return None # RETURN, IGNORED

   for threads in env_rcinit[RCINIT_INFO_LIST]:
      if threads.has_key(RCINIT_INFO_NAME) and output_dict[RCINIT_INFO_NAME] == threads[RCINIT_INFO_NAME]:
         env.TmsError(RCINIT_POC_TA + ' Create unique name for {:s}'.format(output_dict[RCINIT_INFO_NAME]))
      if threads.has_key(RCINIT_INFO_HASH) and output_dict[RCINIT_INFO_HASH] == threads[RCINIT_INFO_HASH]:
         env.TmsError(RCINIT_POC_TA + ' Create unique name for hash {:s}'.format(output_dict[RCINIT_INFO_NAME]))

   #read in policy list
   if input_dict.has_key(RCINIT_POLICY_OPTIN):
      if not isinstance(input_dict[RCINIT_POLICY_OPTIN], list):
         env.TmsError(RCINIT_POC_TA + ' Create a valid policy list for {:s}'.format(output_dict[RCINIT_INFO_NAME]))
      output_dict[RCINIT_POLICY_OPTIN] = [item.lower() for item in input_dict[RCINIT_POLICY_OPTIN]]
      output_dict[RCINIT_INFO_POLICY] = [item.lower() for item in input_dict[RCINIT_POLICY_OPTIN]]
   else:
      output_dict[RCINIT_POLICY_OPTIN] = RCINIT_POLICY_DEFAULT
      output_dict[RCINIT_INFO_POLICY] = RCINIT_POLICY_DEFAULT

   #read in init function if applicable
   if input_dict.has_key(POLICY_ENTRY):
      if RCINIT_NULL != input_dict[POLICY_ENTRY] and None == re.search('^[A-Za-z0-9_]+Policy$|^[A-Za-z0-9_]+_policy$', input_dict[POLICY_ENTRY]):
         env.TmsDebug(RCINIT_POC_TA + ' Rename entry point to include suffix of "Policy" or "_policy" ' + input_dict[POLICY_ENTRY])
      output_dict[INIT_ENTRY] = input_dict[POLICY_ENTRY]
      output_dict[POLICY_ENTRY] = input_dict[POLICY_ENTRY]
      output_dict[RCINIT_INFO_ENTRY] = output_dict[INIT_ENTRY]
   else:
      output_dict[INIT_ENTRY] = output_dict[INIT_NAME]
      output_dict[RCINIT_INFO_ENTRY] = output_dict[INIT_ENTRY]
      env.TmsDebug(RCINIT_POC_TA + ' Create explicit entry point for ' + input_dict[INIT_ENTRY])

   #read in sequence level
   if not input_dict.has_key(RCINIT_SEQUENCE_GROUP):
      env.TmsError(RCINIT_POC_TA + ' Use a valid group for {:s}'.format(output_dict[RCINIT_INFO_NAME]))
   if input_dict[RCINIT_SEQUENCE_GROUP] not in RCINIT_SEQUENCE_GROUP_KEYS.keys():
      env.TmsError(RCINIT_POC_TA + ' Use a valid group for {:s}'.format(output_dict[RCINIT_INFO_NAME]))
   output_dict[RCINIT_SEQUENCE_GROUP] = RCINIT_SEQUENCE_GROUP_KEYS[input_dict[RCINIT_SEQUENCE_GROUP]]
   output_dict[RCINIT_INFO_GROUP] = RCINIT_SEQUENCE_GROUP_KEYS[input_dict[RCINIT_SEQUENCE_GROUP]]

   #init function, no thread type
   output_dict[THREAD_API] = THREAD_API_POLICY
   output_dict[RCINIT_INFO_API] = THREAD_API_POLICY

   #read in stack size
   output_dict[THREAD_STACK] = RCINIT_OUTPUT_NA
   output_dict[RCINIT_INFO_STACK] = RCINIT_STKSZ_ZERO

   #read in priority
   output_dict[THREAD_PRIORITY] = RCINIT_OUTPUT_NA
   output_dict[RCINIT_INFO_PRIORITY] = RCINIT_PRIO_INITFN
   output_dict[RCINIT_INFO_PRIORITY_ALIAS] = ''

   #read in cpu affinity
   output_dict[THREAD_AFFINITY] = RCINIT_AFFINITY_ALL
   output_dict[RCINIT_INFO_AFFINITY] = RCINIT_AFFINITY_ALL

   #read in dependencies
   if input_dict.has_key(RCINIT_DEPENDENCIES):
      if not isinstance(input_dict[RCINIT_DEPENDENCIES], list):
         env.TmsError(RCINIT_POC_TA + ' Create a valid dependency list for {:s}'.format(output_dict[RCINIT_INFO_NAME]))
      output_dict[RCINIT_DEPENDENCIES] = [item.lower() for item in input_dict[RCINIT_DEPENDENCIES]]
      output_dict[RCINIT_INFO_DEPENDENCY] = [item.lower() for item in input_dict[RCINIT_DEPENDENCIES]]
   else:
      #NO DEPENDENCIES
      #Policy func is an exception -- it will always be the first init function
      output_dict[RCINIT_INTERNAL_ORDER] = -1
      output_dict[RCINIT_DEPENDENCIES] = []
      output_dict[RCINIT_INFO_DEPENDENCY] = []

   #if this is a new policy, create dictionary/lists
   for policy in output_dict[RCINIT_POLICY_OPTIN]:
      if policy not in env_rcinit_pol[RCINIT_POLICY_DICT].keys():
         env_rcinit_pol[RCINIT_POLICY_DICT][policy] = []
         for i in range(RCINIT_SEQUENCE_GROUP_MAX):
            env_rcinit_pol[RCINIT_POLICY_DICT][policy].append([])
   #add entry to each policy  list
   env_rcinit_pol[RCINIT_POLICY_USE_LIST] = list(set(env_rcinit_pol[RCINIT_POLICY_USE_LIST]) | set(output_dict[RCINIT_POLICY_OPTIN]))
   env_rcinit_pol[RCINIT_NOPOLICY_ORDERED_LIST][env.TmsToInt(output_dict[RCINIT_SEQUENCE_GROUP])].append(output_dict)
   for policy in output_dict[RCINIT_POLICY_OPTIN]:
      env_rcinit_pol[RCINIT_POLICY_DICT][policy][env.TmsToInt(output_dict[RCINIT_SEQUENCE_GROUP])].append(output_dict)

   #add to environment descriptor
   env_rcinit[RCINIT_INFO_LIST].append(output_dict)
   env.TmsDebug('RCInitAddPolicy {:s} "{:s}" {:d}'.format(output_dict[RCINIT_INFO_NAME], output_dict[RCINIT_INFO_DEFINED]['file'], output_dict[RCINIT_INFO_DEFINED]['line']))

   return None

#===============================================================================

#===============================================================================
#
def tool_method_add_heapquota(env, build_ids, input_dict):
   ''' Method Call, Adds RCINIT Task
   Validates input and stores to 'globals' construction environment
   Runs before tool_emitter() function '''

   env.TmsDebug(RCINIT_POC_TA + ' Adding heap quota for task ' + input_dict[THREAD_NAME])   
   # 'globals' information saved in the construction environment
   env_heap_quota = env[ENV_HEAP_QUOTA]           # construct env task/function dictionary
   heapq_thread_name = None

   heapq_rcpl_dict = OrderedDict()
   heapq_rcpl_dict[RCINIT_INFO_NAME] = input_dict[THREAD_NAME]
   heapq_rcpl_dict[RCINIT_INFO_TYPE] = RCINIT_INFO_HEAP_QUOTA
   heapq_rcpl_dict[HEAP_QUOTA_RCPL_DICT] = input_dict.copy()

   # define the layout of the ordered dict, all fields in expected
   # ordering of the fields

   #read in name
   if not input_dict.has_key(THREAD_NAME):
      env.TmsError(RCINIT_POC_TA + ' Create an unique name for thread')
   if len(input_dict[THREAD_NAME]) > RCINIT_NAME_MAXLEN:
      if env.GetOption('clean') or env.GetOption('no_exec'):
         pass
      else:
         if env.GetUsesFlag('USES_RCINIT_OPTION_CHECK_NHLOS_UNIQUE'):
            env.TmsError(RCINIT_POC_TA + ' Shorten unique name for NHLOS space requirements  ' + str(RCINIT_NAME_MAXLEN) + ' ' + input_dict[THREAD_NAME])
         else:
            env.TmsDebug(RCINIT_POC_TA + ' Shorten unique name for NHLOS space requirements  ' + str(RCINIT_NAME_MAXLEN) + ' ' + input_dict[THREAD_NAME])

   heapq_thread_name = input_dict[THREAD_NAME]   
   heapQuotaDict = {}
   #heapQuotaDict = env_heap_quota[HEAP_QUOTA_DICT][heapq_thread_name]
   #read in heap quota
   if not input_dict.has_key(THREAD_HEAP_QUOTA):
      env.TmsError(RCINIT_POC_TA + ' Heap quota dictionary not found ' + input_dict[THREAD_NAME])
   else:
      env.TmsDebug(RCINIT_POC_TA + ' Heap Quota for {:s}'.format(input_dict[THREAD_NAME]))	  
      for key,value in input_dict[THREAD_HEAP_QUOTA].iteritems():
         if env.TmsToInt(value) == 0:
		     env.TmsError(RCINIT_POC_TA + ' Heap quota value invalid not found ' + value)
         heapQuotaDict[key] = value #str2int(value)
         env.TmsDebug('AddHeapquota {:s} "{:s}" {:s}'.format(heapq_thread_name, key, heapQuotaDict[key]))
         #pretty(env, env_heap_quota[HEAP_QUOTA_DICT][heapq_thread_name])		 
   envDictEntry = {heapq_thread_name : heapQuotaDict}
   env_heap_quota[HEAP_QUOTA_DICT].update(envDictEntry)
   return None

#===============================================================================
def tool_update_file_c(env, target, content):
   ''' Output C File '''
   env.TmsDebug('tool_update_file_c('+target+')')

   ''' This specific output method protects its ability to output
   based upon the existence of an .md5 file. The .md5 file is created
   to reflect the content of the file from the tool perspective; any logical
   container surrounding the data is not accounted for as that is SCONS job.
   We call this a SCONS tool optimization. This output type is specifically
   protected as it will be a consumed dependency.'''

   prevsum = ''
   thissum = 'NONE'

   hash_file = target + RCINIT_EXT_HASH

   try:
      with open(hash_file, 'r') as input:
         prevsum = input.read()
   except:
      env.TmsDebug('Target not present ' + target)

   md5 = hashlib.md5()
   sorted_entry = sorted(env[RCINIT_INFO_LIST], key=lambda k: k[RCINIT_INFO_NAME])
   for entry in sorted_entry:
      # defines a unique entry
      unique_entry = (entry[RCINIT_INFO_NAME]+','+entry[RCINIT_INFO_TYPE]+','+entry[RCINIT_INFO_GROUP]+','+entry[RCINIT_INFO_API]+','+
         entry[RCINIT_INFO_ENTRY]+','+entry[RCINIT_INFO_PRIORITY]+','+entry[RCINIT_INFO_PRIORITY_ALIAS])
      md5.update(unique_entry)
   thissum = md5.hexdigest()

   # Circumvent output based on hash
   if prevsum != thissum:
      with open(target, 'w') as output:
         output.write(env.CreateFileBanner(os.path.basename(str(target)), style='C'))
         output.write('\n')
         for line in content:
            output.write(line)
      with open(hash_file, 'w') as output:
         output.write(thissum)
      env.TmsDebug('Explicit write to ' + target)
   else:
      env.TmsDebug('Using existing ' + target)

#===============================================================================

def tool_update_file_rcpl(env, target, content=None):
   ''' Output PL File '''
   env.TmsDebug('tool_update_file_rcpl('+target+')')

   ''' This specific output method protects its ability to output
   based upon the existence of an .md5 file. The .md5 file is created
   to reflect the content of the file from the tool perspective; any logical
   container surrounding the data is not accounted for as that is SCONS job.
   We call this a SCONS tool optimization. This output type is specifically
   protected as it will be a consumed dependency.'''

   prevsum = ''
   thissum = 'NONE'
   env_heap_quota = env[ENV_HEAP_QUOTA]   # construct env heap quota dictionary

   hash_file = target + RCINIT_EXT_HASH

   try:
      with open(hash_file, 'r') as input:
         prevsum = input.read()
   except:
      env.TmsDebug('Target not present ' + target)

   md5 = hashlib.md5()
   sorted_entry = sorted(env[RCINIT_INFO_LIST], key=lambda k: k[RCINIT_INFO_NAME])
   for entry in sorted_entry:
      # defines a unique entry
      unique_entry = (entry[RCINIT_INFO_NAME]+','+entry[RCINIT_INFO_TYPE]+','+entry[RCINIT_INFO_GROUP]+','+entry[RCINIT_INFO_API]+','+
         entry[RCINIT_INFO_ENTRY]+','+entry[RCINIT_INFO_PRIORITY]+','+entry[RCINIT_INFO_PRIORITY_ALIAS])
      md5.update(unique_entry)

   for taskname,heapdict in env_heap_quota[HEAP_QUOTA_DICT].items():
      md5.update(taskname)
      for heapname,heapquota in heapdict.items():
         md5.update(heapname)
         md5.update(heapquota)
   thissum = md5.hexdigest()

   # Circumvent output based on hash
   if prevsum != thissum:
      with open(target, 'w') as output:
         #sorted_entry = sorted(env[RCINIT_INFO_LIST], key=lambda k: k[RCINIT_INFO_NAME])
         for entry in sorted_entry:
            output.write(str(entry) + '\n')
         #write the heap dictionary
         for taskname,heapdict in env_heap_quota[HEAP_QUOTA_DICT].items():      
            output.write(str(OrderedDict([(THREAD_NAME,taskname),(THREAD_HEAP_QUOTA,heapdict),(RCINIT_INFO_TYPE,THREAD_HEAP_QUOTA)])) + '\n')

      with open(hash_file, 'w') as output:
         output.write(thissum)
      env.TmsDebug('Explicit write to ' + target)
   else:
      env.TmsDebug('Using existing ' + target)

#===============================================================================

def tool_update_file_log(env, target, content=None):
   ''' Output LOG File '''
   env.TmsDebug('tool_update_file_log('+target+')')

   ''' This specific output method protects its ability to output
   based upon the existence of an .md5 file. The .md5 file is created
   to reflect the content of the file from the tool perspective; any logical
   container surrounding the data is not accounted for as that is SCONS job.
   We call this a SCONS tool optimization. This output type is specifically
   protected as it will be a consumed dependency.'''

   prevsum = ''
   thissum = 'NONE'

   hash_file = target + RCINIT_EXT_HASH

   try:
      with open(hash_file, 'r') as input:
         prevsum = input.read()
   except:
      env.TmsDebug('Target not present ' + target)

   md5 = hashlib.md5()
   sorted_entry = sorted(env[RCINIT_INFO_LIST], key=lambda k: k[RCINIT_INFO_NAME])
   for entry in sorted_entry:
      # defines a unique entry
      unique_entry = (entry[RCINIT_INFO_NAME]+','+entry[RCINIT_INFO_TYPE]+','+entry[RCINIT_INFO_GROUP]+','+entry[RCINIT_INFO_API]+','+
         entry[RCINIT_INFO_ENTRY]+','+entry[RCINIT_INFO_PRIORITY]+','+entry[RCINIT_INFO_PRIORITY_ALIAS])
      md5.update(unique_entry)
   thissum = md5.hexdigest()

   # Circumvent output based on hash
   if prevsum != thissum:
      with open(target, 'w') as output:
         for line in content:
            output.write(line)
      with open(hash_file, 'w') as output:
         output.write(thissum)
      env.TmsDebug('Explicit write to ' + target)
   else:
      env.TmsDebug('Using existing ' + target)

#===============================================================================

def tool_update_file_csv(env, target, content=None):
   ''' Output CSV File '''
   env.TmsDebug('tool_update_file_csv('+target+')')

   sorted_entry = sorted(env[RCINIT_INFO_LIST], key=lambda k: k[RCINIT_INFO_NAME])
   try:
      # CSV type
      with open(target, 'w') as output:
         # CSV File Header Row, Controls Output Columns
         hd = OrderedDict([
            (RCINIT_INFO_NAME, None), (RCINIT_INFO_TYPE, None), (RCINIT_INFO_HASH, None),
            (RCINIT_INFO_GROUP, None), (RCINIT_INFO_API, None), (RCINIT_INFO_ENTRY, None),
            (RCINIT_INFO_POLICY, None), (RCINIT_INFO_DEPENDENCY, None), (RCINIT_INFO_AFFINITY, None),
            (RCINIT_INFO_STACK, None), (RCINIT_INFO_PRIORITY, None), (RCINIT_INFO_PRIORITY_ALIAS, None),
            (RCINIT_INFO_STACK_STATIC, None),
         ])
         dw = csv.DictWriter(output, delimiter=',', fieldnames=hd, extrasaction='ignore', quoting=csv.QUOTE_MINIMAL)
         dw.writeheader()
         for entry in sorted_entry:
            dw.writerow(entry)
      env.TmsDebug('Explicit write to ' + target)
   except:
      raise Exception(RCINIT_POC_HBA + ' Fails with ' + target)

#===============================================================================
# Support Functions
#===============================================================================

def getFileLocation(env, path, fileToFind):
   ''' Tool Utility Function '''
   for root, dirs, files in os.walk(path):
      for filename in fnmatch.filter(files, fileToFind):
         return os.path.join(root, filename)
   return None

def topological_sort(graph):
   ''' Tool Utility Function '''
   count = {}
   for node in graph:
      count[node] = 0
   for node in graph:
      for successor in graph[node]:
         count[successor] += 1
   ready = [ node for node in graph if count[node] == 0 ]
   result = []
   while ready:
      node = ready.pop(-1)
      result.append(node)

      for successor in graph[node]:
         count[successor] -= 1
         if count[successor] == 0:
            ready.append(successor)
   return result

def namehash(name):
   ''' Tool Utility Function '''
   tmp = 0
   hash = 0
   for i in range(len(name)):
      hash = (hash << 4) + ord(name[i])
      tmp = hash & 0xf0000000
      if tmp != 0:
         hash ^= (tmp >> 24)
      hash &= ~tmp
   return hash

def randomstring(size):
   ''' Tool Utility Function '''
   import string
   import random
   allowed = string.ascii_uppercase # add any other allowed characters here
   randomstring = ''.join([allowed[random.randint(0, len(allowed) - 1)] for x in xrange(size)])
   return randomstring

def roundup(x, y):
   ''' Tool Utility Function '''
   return x if x % y == 0 else x + y - x % y
