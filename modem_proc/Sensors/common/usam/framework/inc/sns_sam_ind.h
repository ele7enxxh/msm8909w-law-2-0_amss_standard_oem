#ifndef SNS_SAM_IND_H
#define SNS_SAM_IND_H

/*============================================================================
  @file sns_sam_ind.h

  @brief
  All indication processing (both incoming and outgoing) for the SAM
  Framework.

  Copyright (c) 2014-2016 Qualcomm Technologies, Inc.
  All Rights Reserved.
  Confidential and Proprietary - Qualcomm Technologies, Inc.
  ===========================================================================*/

/*===========================================================================
  Include Files
  ===========================================================================*/
#include <stdint.h>
#include "qmi_idl_lib.h"
#include "fixed_point.h"
#include "sns_queue.h"
#include "sns_sam.h"

/*============================================================================
  Function Declarations
  ===========================================================================*/

/**
 * Initialize all static objects contained within sns_sam_ind.c.
 *
 * @return SAM_ENONE
 *         SAM_ENOMEM Not enough memory to initialize Framework
 *         SAM_EFAILED Framework initialization failed
 */
sns_sam_err sns_sam_ind_init_fw( void );

/**
 * Handle an indication message from any source.  Send the data to all
 * algorithms that have made a request to this service.
 *
 * @param[i] indMsg Indication message to process
 *
 * @note Message buffer will be freed by caller
 */
void sns_sam_handle_ind( sns_sam_ind *indMsg );

/**
 * Process the output data generated by an algorithm instance.  Send report
 * indications as necessary, and maintain all output data queues (algorithm
 * instance and Client Request).
 *
 * @param[i] algoInst Algorithm instance which generated the data
 * @param[i] outputData Output of the recent run of the algorithm
 *
 * @return SAM_ENONE
 *         SAM_ENOMEM Not enough memory to send indication message
 *         SAM_ESTATE Unable to cancel one-shot sensor
 */
sns_sam_err sns_sam_process_output( sns_sam_algo_inst *algoInst,
  sns_sam_algo_output const *outputData );

/**
 * Handle all expired client timers.  In most cases, this will initiate
 * the flush procedure.  When processing the incoming data, periodic and/or
 * batched data will be generated and sent to the client as appropriate.
 */
void sns_sam_handle_client_timer( void );

/**
 * Handle the timer firing event for a particular client request report.  Will
 * involve generating and sending a report indication (if non batching client),
 * and the maintanence of all output data queues.
 *
 * @param[i] clientReq The client which demands a new report to be generated
 */
void sns_sam_handle_report( sam_client_req *clientReq );

/**
 * Send out all batched indications for the specified client. Will involve
 * generating and sending report indications, and the maintanence of all
 * output data queues.
 *
 * @note No indications will be sent if clientReq->clientBusy is true.
 * However, to avoid race conditions, this function should not be called
 * unless clientBusy is set to false.
 *
 * @note Indications will be sent only if flushInProgress is LAST or ONLY,
 * or if there are enough batched samples to fill at least one full indication.
 *
 * @param[i] clientReq The client which demands a new report to be sent
 * @param[i] flushInProgress How to mark the outgoing indication messages
 *            SAM_BATCH_FIRST_IND_V01 - FIRST and INT only
 *            SAM_BATCH_INTERMEDIATE_IND_V01 - INT only
 *            SAM_BATCH_LAST_IND_V01 - INT and LAST only
 *            SAM_BATCH_ONLY_IND_V01 - FIRST, INT, LAST, and/or ONLY
 */
void sns_sam_send_all_batch_ind( sam_client_req *clientReq,
    sns_sam_batch_ind_type flushInProgress );

/**
 * Flush all outputs intended for an AP client that could not be sent earlier.
 *
 */
void sns_sam_flush_missed_event_output( void );

/**
 * Flush all batched output intended for an AP client.  This function should be
 * called whenever any AP-facing algorithm needs to be flushed.
 *
 * @note Batched input/output data will be stored in the Sensors Heap.
 *       Indication messages are allocated from the default heap.  Therefore,
 *       even after the Sensors heap has been exhausted, the flush procedure
 *       should still work.  To be safe, we shoudl start flushing when the
 *       Sensors heap reaches approximately 80% utilization.
 */
void sns_sam_flush_batched_ap_output( void );

/**
 * Mark a SAM client as "not busy", which controls whether indications
 * will be sent.  Send all pending indications.
 *
 * @param[i] clientHndl SMR handle representing the client connection
 */
void sns_sam_resume_all_client( smr_qmi_client_handle clientHndl );

/**
 * Register the client timer for the given client request.  Only applicable
 * if the sensor is configured in a periodic reporting mode, or if batching
 * is enabled.
 *
 * @param[i] clientReq Client Request to update
 */
void sns_sam_register_client_timer( sam_client_req *clientReq );

/**
 * Determine if this client has enough batched output samples to generate
 * at least one full batch indication message, and still have at least one
 * sample remaining.
 *
 * @param[i] clientReq Client request in question
 *
 * @return True if there are enough samples; false otherwise
 */
SNS_SAM_UIMAGE_CODE bool
sns_sam_has_full_batch_msg( sam_client_req const *clientReq );

/**
 * Pause all timers for AP non-wakeup batching clients
 */
void sns_sam_pause_client_timers(void);

/**
 * Resume all timers for AP non-wakeup batching clients
 */
void sns_sam_resume_client_timers(void);

#endif /* SNS_SAM_IND_H */
