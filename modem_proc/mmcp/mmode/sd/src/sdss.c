/*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*

               S Y S T E M   D E T E R M I N A T I O N

              S Y S T E M   S E L E C T I O N   C O R E

GENERAL DESCRIPTION
  This file makes up the System Selection Core (SS-Core) component of SD.

  The SS-Core encapsulates all the functionality that is associated with
  processing the SS-Events that are being received from the SS-Front-end and
  for instructing the SS-Front-end of the next action to take in return to
  each SS-Event that is being processed.

  The SS-Core is built around a script engine, which is responsible for
  executing the currently active SS-Script. When the SS-Core receives an
  SS-Event from the SS-Front-end, the script engine consults the
  SS-Script component to whether an SS-Script is associated with the SS-Event
  it got. If an SS-Script is associated with the SS-Event, this script
  becomes the active SS-Script. Else, the current active script remains the
  active SS-Script.

  Note that normally a new SS-Script becomes active only when a User or
  Operation related SS-Event is being received from the SS-Front-end. In
  other words, the currently active SS-Script is responsible for handling
  the Acquisition related SS-Events that are being received during the
  acquisition process.

  The SS-Core also maintains an acquisition state machine that is being
  consulted during the acquisition and re-selection process.

  The following diagram shows a 2nd level decomposition of the SS-Core. The
  arrows in this diagram represent function calls.

                     2nd Level SS-Core Decomposition
                     -------------------------------

  +----------------------------------------------------------------------+
  |                           SS-Front-end                               |
  +----------------------------------------------------------------------+
              |
              |
  +===========|=========================================+     +-----------+
  |           |           SS-Core                       |     |           |
  |          \|/                                        |     |           |
  |  +-----------------------------------------------+  |     |           |
  |  |                  SS-Interface                 |  |     |           |
  |  |                   (sdss_xxx)                  |  |     |           |
  |  +-----------------------------------------------+  |     |           |
  |      |                  |                           |     |           |
  |      |                 \|/                          |     |           |
  |      |    +--------------------------------------+  |     |           |
  |      |    |                                      |  |     |           |
  |      |    |                                      |  |     |           |
  |      |    |               SS-Engine              |  |     |  Database |
  |      |    |            (sdss_eng_xxx)            |  |---->| (sdsr_xxx)|
  |      |    |                                      |  |     |(sdprl_xxx)|
  |      |    |                                      |  |     |           |
  |      |    +--------------------------------------+  |     |           |
  |      |          |                       |           |     |           |
  |     \|/        \|/                     \|/          |     |           |
  |  +-------------------+       +-------------------+  |     |           |
  |  |                   |       |                   |  |     |           |
  |  |                   |       |                   |  |     |           |
  |  |  SS-Acquisition   |       |     SS-Scripts    |  |     |           |
  |  |  (sdss_acq_xxx)   |       |    (sdssscr_xxx)  |  |     |           |
  |  |                   |       |                   |  |     |           |
  |  |                   |       |                   |  |     |           |
  |  +-------------------+       +-------------------+  |     |           |
  |                                                     |     |           |
  +=====================================================+     +-----------+

  SS-Interface.
    Define the interface that is visible to entities outside the SS-Core.

  SS-Engine:
    Encapsulates the functionality that is associated with executing
    SS-Scripts.

  SS-Script:
    SS-Script definitions.

  SS-Acquisition:
    Acquisition state machine - encapsulate the functionality that is
    associated with the acquisition process. The following figure shows
    each of the acquisition states and the transition between states:

                         Acquisition State Machine
                         -------------------------

                          +------------------------+
     Acquired a system    |                        |
 |<--and not interested---|   SDSS_ACQ_STT_START   |<-----------------------+
 |   in a more preferred  |                        |                        |
 |   one.                 +------------------------+                        |
 |                            /|\     |         |                           |
 |                             |      |         |--------------Acquire a most
 |         --------------------|      |                        preferred GWL
 |         |                          |                        system and have not
 |         |                          |                        yet registered on it.
 |         |                 Acquire a PRL system,              |           |
 |         |                 but interested in a                |           |
 |         |                 more preferred one                \|/          |
 |         |                          |          +------------------------+ |
 |  Acquire a system not in PRL       |          |                        | |
 |  or conflicting with SS prefs -----| ---------| SDSS_ACQ_STT_REACQ_GWL | |
 |                                    |          |                        | |
 |                                    |          +------------------------+ |
 |                                    |                        |            |
 |                                   \|/                       |            |
 |                        +------------------------+           |            |
 |   Acquired a more      |                        |  Didn't find a more    |
 |<--preferred system-----| SDSS_ACQ_STT_MORE_PREF |--preferred system----->|
 |                        |                        |  and original system   |
 |                        +------------------------+  is not usable         |
 |                                    |                        |            |
 |                                    |                        |            |
 |                           Didn't find a more                |            |
 |                           preferred system and              |            |
 |                           original system is usable         |            |
 |                                    |                        |            |
 |                                   \|/                       |            |
 |                        +------------------------+           |            |
 |                        |                        |  Failed to reacquire   |
 |                        |   SDSS_ACQ_STT_REACQ   |--the original system-->|
 |                        |                        |           |            |
 |                        +------------------------+           |            |
 |                                    |                        |            |
 |                                    | <----------------------|            |
 |                           Successfully reacquired                        |
 |                           the original system                            |
 |                                    |                                     |
 |                                   \|/                                    |
 |                        +------------------------+                        |
 |                        |                        |                        |
 +----------------------->|    SDSS_ACQ_STT_DONE   |--Receives SS-Event---->|
                      /|\ |                        |                        |
                       |  +------------------------+                        |
                       |              |                                     |
                       |              |                                     |
                       |    In an emergency call and acquired               |
       acquire full    |    service is LTE limited system on                |
    service or lmtd    |    which full service can be obtained              |
       service         |    and the band is part of phone's                 |
                       |    idle state UE capability                        |
                       |              |                                     |
                       |             \|/                                    |
                          |                        |
                       |  +----------------------------+                    |
                       |  |                            |                    |
                       |--|SDSS_ACQ_STT_REACQ_FULL_SRV |--no service  ------>
                          |                            |
                          +----------------------------+




EXTERNALIZED FUNCTIONS

  General:
    sdss_is_orig_mode
    sdss_is_hybr_pref
    sdss_is_handoff
    sdss_is_band_pref
    sdss_is_acq_specific_sid
    sdss_get_pref
    sdss_get_acc_prm
    sdss_get_sim_state
    sdss_update_sim_state
    sdss_update_srv_status

    sdss_opr_mode_update
    sdss_pref_update
    sdss_redir_update
    sdss_cdma_lock_update
    sdss_acc_term_update
    sdss_hdr_ses_close_update
    sdss_ho_update
    sdss_orig_success_update
    sdss_throttle_acq_on
    sdss_throttle_acq_off
    sdss_throttle_reset_cntrs
    sdss_sys_lost_update

    sdss_act_print
    sdss_iact_print

    sdss_eng_stack_get_state

  System Record Suport
    sdss_sr_is_mode_pref
    sdss_sr_is_band_pref
    sdss_sr_is_pref_conf
    sdss_sr_is_prl

  System Record List Suport
    sdss_sr_list_is_mode

  Major Routines
    sdss_component_init
    sdss_event_recovery
    sdss_event_proc


INITIALIZATION AND SEQUENCING REQUIREMENTS
  The SS-Core initialization function sdss_init() must be called at power-up
  before any other sdss_xxx() function is called.

Copyright (c) 2000 - 2015 by Qualcomm Technologies INCORPORATED. All Rights Reserved.

Export of this technology or software is regulated by the U.S. Government.
Diversion contrary to U.S. law prohibited.

*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*/

/* <EJECT> */
/*===========================================================================

                        EDIT HISTORY FOR MODULE

  This section contains comments describing changes made to the module.
  Notice that changes are listed in reverse chronological order.

  $Header: //commercial/MPSS.JO.2.0.c1.4/Main/modem_proc/mmcp/mmode/sd/src/sdss.c#1 $

when       who     what, where, why
--------   ---     ----------------------------------------------------------
12/13/13   sm      Add tds band for CSFB call orig
10/30/13   xs      plmn_allow handling for medium preferred sys
03/10/13   vs      Adding LTE band 27
09/30/13   sm      Adding LTE band 31
09/05/13   cl      Remove GWL out of PREF_LIST in Immediate/Recursive BSR if start_sys is GWL
08/28/13   jvo     Cleanup remaining Fusion pieces
08/20/13   cl      Initialize more_pref_scanned_list when SD exit recursive BSR
07/19/13   jvo     Remove all MDM/MSM Fusion features
07/15/13   ss      FR1860 - T/G on DSDS
07/10/13   ar      checking value of sdsr_s_type is NULL or not NULL
07/10/13   gm      Readjust sim_state on LPM if its CS/PS invalid
07/03/13   ss      Fix for LTE RRC when device in 1x & call placed in GW
06/24/13   dk      KW error fix in sdss_is_mru_3gpp()
06/21/13   gm      Selectively clear SDSR lists/systems and engine stack
05/14/13   aj      duplicate band scan avoidance enabled for emergency calls
06/04/13   xs      E911 ready ind with ac_bar info considered
04/28/13   xs      Reset bid in 1x OOS
04/28/13   xs      Fix tele bsr timeline during HDR traffic
04/28/13   xs      LTE avail and tele bsr for non-SVLTE
04/23/13   xs      Optimizing LTE avail file read/write to EFS
04/23/13   xs      FR3273: handling RPLMN
04/04/13   cl      SD checks for complete validation for scheduled system.
03/18/13   gm      Start hybrid operation flag should be enabled on ONLINE
03/01/13   mg      Fix to make the serving DO system more pref if IDL SYS is empty
02/21/13   cl      Re-initialize SD core during power-down event
02/11/13   vs      Adding LTE band 28 and 29.
02/11/13   xs      SD send acq fail to CM during HDR silent redial
02/03/13   cl      FR1975: Dynamic Switch SVLTE <-> CSFB
01/14/13   cl      Recursive BSR
01/04/13   mg      Handle DO/1x to LTE reselection failure
01/03/13   mg      Fix to scan TDS if the system record has LTE and TDS after
                   receiving LTE CS/CS_PS_INVALID.
12/28/12   jh      Only add 30sec add to timer in OPR mode.
12/03/12   xs      Added IRAT debug msg
11/23/12   sk      Initialize the LTEAvail/LTENotAvail file num to zero properly
11/16/12   xs      Fix issue of cross boundary access of ss pointer
11/02/12   skk      Updated SD construct to consider internal service status
                   (i.e. SYS_SRV_STATUS_NO_SRV_INTERNAL).
10/24/12   cl      Do not remove acq_sys from pref_lst for limited-srv-req
10/18/12   xs      Fix issue of camping RPLMN takes long time
10/15/12   gm      Continue to look for FULL srv for MOST_PREF FPLMN sys
10/10/12   qf      Make sure sd sends ok_to_orig for hdr data call if the
                   optimized ho LTE->ehrpd on going and not disturb the redir.
10/09/12   sr      Support  to derive MCC of an EvDo system from eqprl.
10/09/12   qf      not allow stack sync up if NAS is in connected state
10/05/12   cl      Avoid scan LTE-only records on MAIN during CSFB call
09/28/12   jh      Reset max_acc_prob counter upon HDR traffic start
09/26/12   vm      Fixing Lint errors
09/21/12   xs      Location based BSR extended to main
09/20/12   qf      Reset acq stt state if there is no more perferred system to
                   acquire after filtering duplicate band.
09/20/12   qf      not update band_to_avoid for successful limited gwl acquisition
09/18/12   qf      FR2502 - 3GPP scan in MMSS operation
09/18/12   qf      Suspend duplicate band scan in immediate BSR after srv lost
09/17/12   skk     Do not send internal service lost or limited service during uptime.
09/15/12   xs      LTE telescopic BSR in SVLTE support
09/14/12   ak      Move Hybrid preference back to individual stacks.
09/12/12   ak      Stop BSR timer when Ltd_reg service indication received.
08/24/12   fj      Adding LTE band 26.
08/10/12   fj      Adding LTE band 23.
08/20/12   ak      Check true_mode_pref for getting stack associated with mode
08/17/12   gm      Mainline EFS feature - Remove FEATURE_EFS
07/23/12   xs      Added support of location based BSR
07/18/12   jh      Fix LTEAvailFile not maintained across the pwr cycle/LPM
07/17/12   jh      Added LTE Available File BSR support
07/13/12   qf      Check if TOT list exists before accessing it
07/02/12   sg      Added support C+H+G+W+L mode
06/20/12   cl      Fix GWL scan in JCDMA
06/19/12   cl      Add mapping for REDIAL_LST on HYBR-2 stack
06/04/12   gm      EFUSE support for TDSCDMA
05/29/12   gm      Check for TDS bands while deciding PWR_SAVE reason
05/23/12   xs      Use user pref on main stack to update RAT priority list on Hybr2
05/16/12   ak      Validate the stack value returned by sdss_get_ss_formode() API
05/15/12   jh      LTE loss in idle to do lte scan once and go PWR_SAVE.
05/15/12   jh      Update rat_acq_order checking to compare only valid rat info
05/14/12   qf      FR1921-Eliminating 3GPP duplicate band scan
05/14/12   ak      Do not reset OOS after camping on Limited regional service.
04/24/12   sg      Add required changes to support TDS in Automatic mode
04/04/12   sg      Added support for new mode_pref SD_SS_MODE_PREF_TDS_LTE
04/02/12   gm      SD should not stay on non-associated HDR systems.
11/02/11   aj      update SDSS_IF_COND_LMTD_RESEL_ALLOWED to check hybr1/2 stack mode
03/26/12   cl      Update eHRPD zone indicates if HDR service is eHRPD
10/11/11   fj      Fix klocwork errors.
03/25/12   cl      Using GW_CAND_SYS for reacquisition after more pref scan failed
03/12/12   aj      prevent simultaneous access of HDR lists on 2 stacks
03/25/12   cl      Two BSR timer for LTE reselection requirements support
03/25/12   cl      Change SD_N_MIN_VOICE_SCANS_DEFAULT_VALUE to 0
03/23/12   gm      DIME integration fix: TMC deprecation and others.
03/14/12   cl      GW/L limited reselection to LTE/DO enhancement
03/12/12   aj      prevent simultaneous access of HDR lists on 2 stacks
03/09/12   ak      SD Free floating cleanup
02/29/12   mj      Remove obsolete script conditions, rename GWL script
                   conditions to 3GPP
02/23/12   ak      SD Free floating changes
02/17/12   xs      Loop RF chains to get supported bands
11/30/11   jh      Added feature for dynamic rat acq order change
02/12/12   aj      ensure MAP avoid systems are scanned during service loss
01/31/12   aj      update checks to allow reselection when BSR timer expires
09/22/11   jh      Added support for MCS modem capability check
                   Removed msm_support efuse check
01/31/12   aj      update SD action based on current preferences
01/20/12   sg      Adding TD-SCDMA RAT into default PRL
01/13/12   sg      Updated script to pass for TGWL configuration.
01/12/12   sg      Made changes for TGWL configuration.
01/11/12   aj      update emerg call handling on hybr2
01/06/12   ak      Make OOS timeline on main stack configurable.
01/03/12   ab      Handle manual search abort by access stratum due to RLF
01/01/12   cl      n_min_voice feature for SVLTE out of service algorithm
01/01/12   ak/cl   Enabled background PLMN search for multimode configuration.
12/22/11   gm      New power save reason for Hybr BSR reselection.
12/19/11   xs      Allow resel if SVLTE and more pref list has only 1X
11/28/11   ak      Fixing reselection timer after redirection.
11/28/11   ak      Change BSR behaviour when it involves 3GPP
11/20/11   mj      Use rfm_get_tds_band_mask()to get TDS band capability.
11/17/11   ak      Skip GW scans during LTE service domain camped.
11/17/11   cl      SD reacquired GWL system from PRL, not from TOT after
                   initial attempt to search for current GEO.
11/16/11   vk      Added API to return supported band preferance mask.
11/02/11   fj      Add support for validate and write BST/TOT into EFS.
11/14/11   xs      Fix manual network selection issue when pwr up in LTE mode
10/25/11   vk      Changes related to Manual Search rejection in RLF.
10/21/11   vk      Acquire LTE if SRV_LOST event is received in 1XCSFB call conv state.
10/18/11   rk      Added check for LTE CS capability to decide on CSFB call
10/14/11   mj      New mode_pref TDS_GSM
10/07/11   rk      Removing the conditions for updating the RAT priority list.
10/03/11   vk      Added API to check whether the requested CDMA system is supported by
                   current UE and target configuration .
09/21/11   gm      New log event for SS-timer activity
09/15/11   rk      Skip LTE only record when in CS only mode or sim is invalid
                   for PS
09/14/11   rk      Fix to put UE in emergency mode if 2G SIM is inserted when
                   UE is effectively in LTE only mode
09/14/11   ak      Move to reacquisition state after exhausting the PREF_LST.
09/14/11   ak      Fixed Acq_state machine for inter script transitions.
09/12/11   aj      use MAIN's HDR activity status to skip LTE BSR on HYBR2
09/01/11   aj      Filter 3gpp acqs on MAIN, if NAS is in connected state on LTE in HYBR2
09/02/11   xs      Remove feature flag HW_HAS_EDGE_ONLY_MODEM in mmode
08/26/11   sh      SD should not set reselection timer if sim state was set
                   to “SYS_SIM_STATE_NOT_AVAILABLE”.
08/09/11   rn      Reset thrttl upon subsc change.
08/04/11   aj      support to extend BSR timer if LTE is in conn state
08/04/11   xs      Replace FEATURE_MMODE_NIKEL with FEATURE_MMODE_SC_SVLTE
08/03/11   xs      Lint error fix
07/24/11   aj      SC SVLTE 1.0 merge to mainline
07/15/11   ak      Enabled background PLMN search for multimode configuration.
07/13/11   gm      LTE to HDR resel not allowed if 1x subscr is not available
06/17/11   gm      Check phone capability for SD action when mode is GWL
06/16/11   ak      MSM to skip GW scans when MDM in LTE/DO activity.
06/14/11   aj      Add utility API sd_misc_is_lte_full_srv_allowed()
06/03/11   gm      Introduce ABSR before trying Full srv in GWL Limited
06/02/11   rk      Fix for emergency call origination when UE camped on LTE
06/01/11   chl     Fixed lint error
05/20/11   fc      Use NV config to enable/disable ALT_EVDO_PWRUP_ALG_1.
05/17/11   rn      WCDMA channel locking feature
05/17/11   gm      Renaming HYBR_SS_ACTIVE to HDR_HYBR for HYBR_BSR fix
05/16/11   gm      HYBR_BSR should not be activated in LTE_ONLY mode
05/17/11   xs      Adding LTE band 24-25
05/15/11   rk      Fix for PS detach when CS call is present and updating RAT
                   priority list based on phone mode preferences
05/13/11   skp     Merging DSDS changes and Lint Fixes.
05/12/11   mp      BPLMN - LTE Only capable is not able to perform Manual Search
05/10/11   gm      Maintain separate copy of IDL sys for CDMA
05/06/11   ak      Rollback the change to clear IDL_SYS at pwr_save.
04/18/11   rk      Enhance IS_SRV_DOMAIN constuct to check LTE CS capability
04/14/11   skp     Adding mapping to HYBR_1 SYS for GW_FULL, LTD, and USER sys.
04/13/11   ak      Added support for scanning skipped GW systems on MSM.
04/12/11   cl      Propagate SD stacks's states to CM
04/07/11   ak      Fix issues in HDR-->LTE BSR on Fusion MDM.
03/28/11   xs      Added LTE band 41-43
03/25/11   gm      LTE (Lmtd) to DO resel support
03/15/11   cl      Remove is_active indication from service indication
03/09/11   cl      Add support for SVLTE2 MMSS arbitration
03/02/11   rk      Fixing issues for coming back to LTE after CSFB call end.
02/18/11   rk      Not update RAT priority list for normal CS call, CSFB call
                   and CSFB emerg call and both for pref_reas orig and redial
02/17/11   cl      Add support FEATURE_MMODE_REMOVE_1X for FUSION-MDM
02/16/11   gm      Extend acquisition while in ECBM & sys loss
02/14/11   rm      Adding LTE RAT-B changes
02/14/11   sv      Replace BOOLEAN with SD_BOOLEAN to avoid conflicts
02/10/11   am      Adding support for QTF.
02/07/11   xs      Dynamic FEATURE_JCDMA control in EFS
02/02/11   xs      Added SDSS_EVT_HYBR_2_USER_GET_NET_GW checking when
                   process SDSSSCR_CON_GET_NET
02/03/11   am      Add UMTS BC19-8500 band support in SD
01/28/11   fj      Remove FEATURE_SD_GWL.
01/28/11   rk      Fix for reacquire LTE after MO 1XCSFB call release
01/19/11   ak      Added support for periodic GWL scans in DO only coverage.
01/05/10   cl      Added support feature FEATURE_MMODE_MDM_LTE_HDR_ONLY and
                   FEATURE_MMODE_MSM_CDMA_ONLY
12/23/10   sv      Integrate DSDS changes
12/22/10   rm      Fixing lint errors
12/10/10   rk      Changes for e1XCSFB call
11/23/10   chl     Add 'SD_SS_MODE_PREF_ANY_BUT_HDR_LTE' to fix lint error
11/17/10   xs      Handle potential dividen by 0 issue
11/12/10   rk      Start next BPLMN search timer when NAS votes NO for resel
11/03/10   aj      DO -> LTE reselection code
10/25/10   aj      BSR after IRAT from LTE->DO should be triggered by TMR_CDMA_RESEL
10/24/10   cl      Re-trigger BSR after call is ended during
                   LTE-->HRPD hand-off.
10/12/10   sv      Enable HDR_*_COLLOC_LST for Hybr HDR stack
10/05/10   gm      Added sdss_script_name_print to simplify calling function.
10/04/10   aj      update logic to calculate rat priority list
10/01/10   ak      Merged the Fusion code from Dev branch.
09/29/10   ak      Skip GW scans during Hybrid HDR traffic.
09/27/10   gm      KW: Added comment in the code for "Not a Problem" errors
09/22/10   xs      Fixed target compilation error
09/16/10   gm      Fix unreachable code for LTE_CONN_MODE_OPT & others.
09/08/10   xs      Fixed issue of Service is OFF occurs despite Registration
                   succeeds due to SD_SS_ACC_TERM_ACC_SUCCESS.
08/30/10   rm      SD should not report disconect while doing WLAN get networks
08/20/10   cl      SD should Ignore other event in Redirection Context
08/20/10   dq      Added enhanced F3 messages for activated scripts.
08/06/10   aj      Replaced SD_ERR with SD_MSG_ERROR
08/05/10   rk      Disable LTE scan if inserted card is 2G only
08/04/10   ay      Renamed an event for LTE rlf
08/04/10   rk      Doing pure limited service aquisition when sim state is not
                   valid for current service domain preference.
08/03/10   aj      Add LTE support in sdss_sr_is_band_pref
08/03/10   ak      Updating the check for MRU[0] in HICPS.
08/02/10   gm      Add mode pref SD_SS_MODE_PREF_CDMA_LTE
07/30/10   aj      Fixed lint warning
07/26/10   gm      Enhancement to avoidance/ESS event reporting
07/14/10   mh      Fixed compile warnings
07/12/10   fj      Add support for LTE band 18, 19, 20, 21.
07/08/10   sv      Correct CAP_GWL_PREF_GWL_ONLY check
07/08/10   gm      Fix for Klocwork deferred critical errors.
07/08/10   fj      Remove LTE_EUTRAN_BAND41 since it's not in standard.
07/01/10   fj      Add support for all the LTE bands.
06/28/10   aj      RAT priority list updates for BSR 2.0
06/27/10   ay      Added EOOS support
06/25/10   fj      Call new RFM API to get LTE band capability.
06/21/10   rk      Redesign of WRLF feature.
06/18/10   aj      Add support to pass HDR subnet mask length to CM
06/18/10   aj      seperate band_cap and bst_band_cap in service request
06/09/10   gm      Fix for Klockwor/Lint errors.
06/04/10   ak      Removing dead code left over from UOOS.
06/02/10   xs      Fixed issue of DO channel avoidance time when MAP
05/26/10   aj      add support for IRAT pilot measurement
05/26/10   rm      Do not hardcode band cap with SD_SS_BAND_PREF_WCDMA_XI_1500
05/19/10   gm      Avoidance/ESS logging
05/18/10   rn      Added rat_pri_list_info in get_net_gw
05/17/10   rk/sn/rm   Reverting CONT_BSR and CONT2_BSR
05/10/10   xs      Fixed issue in constructor IS( NO_HYBR_OPR ) when
                   FEATURE_HDR_HYBRID is undefined
05/07/10   aj      fix lint errors due to api file changes
04/26/10   aj      LTE code fixes for BSR operation
04/20/10   aj      add acq state machine diagram updates
04/07/10   fj      Added HDR_LTE & CDMA_HDR_LTE in sd_ss_mode_pref_e_type.
04/05/10   fj      In sdss_sr_list_find_next(), skip scanning if the band and
                   lte_band are none.
04/05/10   aj      add sdss_get_rat_pri_sys_idx()
03/25/10   ay      Fixed typo in band definition
03/22/10   aj      kw fixes
03/23/10   rn      Replace UE_CAPABILITY with rat_priority_list_info
03/22/10   ay      Removed PWR_SCAN_GWL and NET_GWL
03/19/10   aj      MMSS support
03/19/10   sg      Add UMTS BC11-1500 band support in SD
03/15/10   ay      Lint fix
03/11/10   ay      Minor changes in LTE Connected mode
03/08/10   rp      Added support for SDSSSCR_CON_CHK_MODE_PREF_SET_SRV_STATUS
02/24/10   aj      Support PS optimized silent redial
02/17/10   rn      Get UE_cap from EFS
02/16/10   sg      Changes in SD to support eCall feature requirement.
02/09/10   jqi     ESS support.
02/06/10   rn      added lte and gw band pref in UE_CAPABILITY w/o subsc too
01/11/10   fj      Added sd_map_band_to_band_pref_lte().
01/19/10   aj      Add support for 911 over VOIP ehrpd
01/18/10   ay      Added fix in sdss_sr_list_find_next()
01/18/10   rn      corrected lte band pref in UE_CAPABILITY in ACQ_GWL
01/14/10   ay      Added support for LTE Connected mode
01/13/10   rn      removed unsupported modes from UE_CAPABILITY in ACQ_GWL
01/08/10   rn      LTE-eHRPD redirection support
01/05/10   ay      Fixed KW error
12/23/09   ak      Removing UOOS
12/22/09   ay      Removed a redundant statement
12/15/09   fj      Modified get_band_capability() to support multimode.
12/09/09   ay      Added more LTE support, modified some LTE related functions
11/05/09   fj      Add SDSS_IF_COND_CAP_LTE_PREF_LTE_ONLY to check LTE only
                   mode in scripts.
11/17/09   rn      Add UE_CAPABILITY in ACQ_GWL
11/10/09   mp      Added support for MODE_PREF_DIGITAL_LESS_WLAN
11/07/09   aj      Add hybrid version of TEMP_LST and TEMP2_LST
11/09/09   sg      Add non-demand paging macro to function that are not to be
                   demand-paged.
10/30/09   pm      Fix KW error - check if ptr is NULL
10/30/09   ay      Modified sdss_pref_update_lte()
10/21/09   sv      Moving from clk API to time API
10/14/09   ay      Added lte_band_pref in sdss_get_pref, rem featurization, added comments.
10/12/09   ay      Added GWL support :  dedicated band, capability, band pref for LTE
09/29/09   fj      Fixed Lint errors due to LTE merge.
07/30/09   fj      Removed FEATURE_LTE_PENDING for 2G/3G UT environment.
07/10/09   np      Adding LTE Code
04/17/09   fj      Removed FEATURE_LTE_PENDING, which was added in LTE 1.0
03/07/09   fj      Added LTE mode in sdss_get_mode_capability().
02/27/08   fj      Use SD_SS_MODE_PREF_LTE for LTE only mode.
07/17/09   jqi     Do not cancel the avoidance (60s due to 100% PSIST) after
                   AT exhausted all the IDLE GEO systems and AT is not in
                   origination state.
07/13/09   aj      Add placeholders for BC13 and cdma BC max
06/29/09   rk      Handling new pref_reason SD_SS_PREF_REAS_MULTIMODE_SCAN
03/20/09   rm      Renaming : sdprl_map_chan_to_blksys -> sd_map_chan_to_blksys
                   sdss_map_band_to_band_pref -> sd_map_band_to_band_pref
03/12/09   rm      Including cai_v.h
03/11/09   rk      Changes to handle limited service aquisition.
04/03/09   aj      Added support for emergency callback exit on sys lost
02/25/09   sv      Removing inclusion of sys_wlan_v.h
02/13/09   sn      For user pwr save exit event, in pwr save, continue with
                          earlier  4 + 1 GW  band group scan sequence.
02/23/09   rm      Including sys_wlan_v.h
02/10/09   fj      Filter band_capability based on mode_capability, using
                   sdss_get_supp_mode_band_pref().
01/21/09   rk      Added new construct IS_BAND_PREF_CHGD.
01/09/09   rm      Reverting the fix - After get_netowrks srv_req with SYNC_UP
                   should not be sent to NAS. Also make ss_state to OPR
                   after get_netowrks.
12/05/08   sn      UOOS GW lmtd search for multimode phones when GW subs not
                   available.
12/11/08   sv      Excluding WLAN systems from checking Roam Preference
11/28/08   rm      In UOOS report Limited service to NAS if sim state is
                   CS_PS_Invalid. Reverting part of the fix for CR-124247
11/13/08   rm      After get_netowrks srv_req with SYNC_UP should not be sent
                   to NAS. Also make ss_state to OPR after get_netowrks.
11/05/08   sv      Moved sdssscr_flag_e_type to sdss_flag_e_type
                   Added sdss_update_flag to update stack_sync_up_flag
10/23/08   ak      Fixing the no firmware scenario
10/02/08   aj      Bandclass support for BC17, 18, 19
09/29/08   rk      Change the ss state ACQ when SD sends srv req and not got cnf.
09/26/08   cl      Fix the system to use TMR_HDR_REDIR under DO Redirection
09/25/08   sv      Memory reduction changes
09/18/08   rm      Adding acq_order_pref in sd_ss_act_get_net_gw_s_type.
09/15/08   pk      Added support for WLAN UOoS
09/15/08   rm      Store true_mode_pref in HYBR mode.
08/29/08   rm      Searching for GW systems in Automatic mode when SIM
                   is not avilable
08/25/08   ak      Fixed the general compiler warnings.
08/20/08   st      resolved Klockwork issues
08/12/08   ak      Implemented the new Sprint BSR algorithm
07/31/08   fj      HDR acquisition issue. Modify sdss_get_mode_capability.
07/30/08   sv      - Added is_stack_syncup_in_progress to indicate the sync-up status
                   - Filter the stack sync-up event when call orig on HDR
                   - If Stack sync-up has conflicting preferences, update acq list
07/10/08   rm      Assigning srv_req_type before checking for pref changes
06/20/08   sn      BSR 2.0 changes
06/25/08   sn      Added new IS script construct SDSSSCR_COND_SIM_DOMAIN_VALID
                   in sdss_eng_scr_con_is
06/11/08   fj      Added mode_capability in sdss_s_type,
                   replaced is_hdr_not_supported from sdss_s_type with mode_capability
                   (SD_SS_MODE_PREF_HDR),
                   modified sdss_get_band_capability to EXTERN function,
                   added function sdss_get_mode_capability.
06/12/08   aj      Klocwork fixes
06/10/08   rm      Report ACQ_FAIL when phone moves to POWER_SAVE state while
                   in UOOS
05/22/08   vk/sv   modified code to handle roam only preference
04/30/08   cl      Adding support for API sd_misc_sys_avoid_list, which list all
                   the avoided systems. HDR/SCHR use this info to update their
                   scan list when doing OFS.
04/28/08   rn      Reset the acq_scan_status if user changes the preferences
04/24/08   rm      Correcting comment style
04/24/08   rm      Removing feature flag FEATURE_CM_NAS_SERVICE_REQ_TYPE
03/19/08   cl      Fixing UOOS Time to support Auto Mode Builds.
03/20/08   rm      Lint Clean
03/17/08   vs      Added prev_sys_info to the sd state structure,
                   Added functions to get/set prev_sys_info,
                   Made changes to clear prev_sys_info when starting
                   a GW acquisition.
03/14/08   rm      CM-NAS interface for new service req type
03/11/08   vk      Corrected code for GW case for SD_SS_MODE_PREF_GW
02/19/08   cl      Optimize the execution time of SD API sd_misc_is_fts_mode
02/20/08   vs      Made changes to clear SDSR_PREV_COLLOC_LST
                   when starting a GW acquisition
02/13/08   vs      Added SDSS_IF_COND_SS_STATE to check selection state
01/22/08   rm      Reverted the changes done for- support for SIM Invalid
                   and UOOS
12/11/07   rn      Allow GSM ONLY if the hardware is EDGE ONLY
11/28/07   jqi/ak  Prevented NULL pointer access in the schedule list.
10/03/07   bh      Moved to new API and supported client stub
09/18/07   pk      Added support for non-Hybrid UOOS
09/04/07   cl      Change the interface that detect HDR Support
08/29/07   sk      Fixed error in MOST_PREF classification of a system to
                   ignore systems that shall not be acquired due to user pref
                   or target capability.
06/19/07   cl      Featurize the fix 118758 with FEATURE_SD_DETECT_HDR_HW
06/19/07   cl      Adding support for 6175 to detect HDR hardware
06/15/07   rp      Adding rem_uoos_awake_time and rem_uoos_sleep_time
06/06/07   pk      UOOS enhancements...
05/29/07   pk      Added support for SIM Invalid and UOOS
05/02/07   jqi     DO not turn off the redirection afer IHO if the expected
                   SID/NID of the redirected system is WILDCARD.
                   Expanded 1x system reselection timer value from 16-bit to
                   32-bit.
05/01/07   rp      Correct sdss_pref_update to update orig_mode correctly
04/23/07   jqi     Added Filtering support for stopping HDR activity.
                   Added support for sd_misc_is_orig_mode.
03/28/07   jqi     Cancelled the avoidance until acq fail during redial.
03/28/07   sk      Added new GW UOOS wakeup time for GCF fix.
                   Added sdss_is_gprs_anite_gcf().
03/23/07   pk      Disabling 1X acquisition throttling for VoIP -> 1X hho
02/26/07   pk      Added sdss_get_ss_for_mode for all featurizations
01/04/07   pk      Added support for VoIP -> 1X Handoffs
12/01/06   pk      Added support for Automatic mode for CDMA + GSM UOOS
                   builds
12/03/06   ka      Adding sdss_map_mode_pref_to_mode()
11/29/06   ka      Limited service resel timer expiry results in sending
                   MEAS_BACK action instead of full service req. Satisfies
                   GCF 6.1.2.6.
11/20/06   pk      Added support for HYBR_GW cont...
11/16/06   pk      Using sys_simultaneous_mode_e_type for hybr_gw
11/15/06   pk      Added support for HYBR_GW
11/13/06   ic      Lint fixes
11/07/06   sk      Memory reduction effort.
                   - Hand optimized sdss_map_band_pref_to_band().
10/02/06   sk      Added support for AVOID_CANCEL_COND.
09/22/06   RP      Added BC15, BC16 support.
09/17/06   sk      Added all WLAN bands to WLAN band capability.
08/29/06   sk      Added WLAN Adhoc support.
08/24/06   pk      Added support for IF construct and GCF test fixes
08/24/06   pk      Added support for sdss_nv_init
08/23/06   jqi     Added support for system reselection during BCMCS flow.
08/15/06   pk      Added support for GW UOOS
08/07/06   pk      Added support for 1X UOOS
08/08/06   sk      Updated sdss_get_cdma_request_mode() to handle new SD mode
                   prefs.
07/13/06   jqi     Added the system lost reason for HDR system lost event.
07/07/06   sk      Added sdss_get_srv_status().
05/22/06   jqi     Made use of the chan list for HDR oh info.
05/17/06   jqi     Added ss information in sdsr table to differenciate the
                   avoidance over different SD instances.
05/09/06   jqi     Fixed compilation errors.
05/08/06   sk      Added support for expected SID for HDR.
04/28/06   sk      Added new list PWR_SAVE_LST.
                   Added protection against invalid list/position when
                   returning to a ACQ that was interrupted by a new script.
                   Added protection to prevent multiple instances of the same
                   script from running in the engine stack. Featurized under
                   FEATURE_PREVENT_SCRIPT_MULTI_INST_EXEC.
04/17/05   jqi     Added EGSRDM support.
04/09/06   jqi     Increased Register Failure Counter to 6 in over reach.
                   Made "1x Reselection Threshold" as a configurable NV item.
                   Mainline FEATURE_SILENT_REDIAL_20.
                   Connection Deny reason(network busy), avoid the channel
                   60s.
                   No TCA and NoRTC ACK, 3 failures avoid 60s or encountering
                   ACQ_FAIL, whichever come first.
                   Scan all channels during overreach wake up.
                   Do not cancel avoidance when entering power save mode.
                   Added null pointer check in sdsr_list_is_fade.
                   Mainline FEATURE_SILENT_REDIAL_20
03/27/06   dk      Added wlan power save mode pref script.
03/20/06   sk      Added support for acquisition type NOT_LESS_PREF_OR_HOME.
03/9/06    jqi     DO system reselection optimization(Sys resl at DO MO call
                   end.)
                   Multichannel avoidance.
                   Reset the DO failure counter when Subnet ID is changed.
                   Do not change sd state if only srv domain is changed.
03/07/06   sk      Added support for SD_SS_SRV_DOMAIN_PREF_NONE.
03/05/06   jqi     Merged WCDMA BC3,4,8 and 9 support.
02/08/06   pk      Replaced SD_ERR with SD_MSG_ERROR
01/16/06   sk      Fixed bug in conditional scheduling of systems.
                   Fixed bug that resulted in the scheduled system's acq type
                   being used for the first system in the acquisition list.
01/09/06   sk      Made changes to treat custom home system as home system.
                   Added new acquisition type MORE_PREF_THAN_SRV_SYS
                   Changed acquisition type NOT_LESS_PREF to check only upto
                   roaming indicator.
12/22/05   jqi     Merged background PLMN search support.
12/12/05   jqi     Lint fixes.
12/02/05   jqi     Lint 8 fixes.
11/08/05   jqi     Added support for 1x acquisition throttling for BCMCS
                   activity.
11/07/05   jqi     Added F3 message.
                   Removed the featurization around the sdss_is_hybr_pref().
11/02/05   sk      Fixed all Lint and compiler warnings.
                   Added WLAN bands/band_prefs mapping for all 2400 and 5000
                   bands.
10/19/05   jqi     Added more debug message.
10/14/05   jqi     Added BC14 support.
10/08/05   jqi     Ignore the roaming preference for GSM/WCDMA operation.
10/05/05   sk      Added support for configuring SD values from NV.
09/12/05   jqi     Lint fixes.
09/10/05   pk      Added support for IS_TIME_GR(INSTANCE, SRV_VAL, TIME) and
                   DEL_CNT( LIST, START_POS, CNT )
09/07/05   jqi     Fixed compilation errors.
09/01/05   jqi     DO system reselection optimization.
                   Use different scripts based on the SS item during event
                   recovery process.
08/19/05   sk      Initialized event counters and times during power up.
08/05/05   jqi     Added support for Best preferred acquisition for DO.
07/21/05   jqi     Added 1xEV-DO system reselection on hybrid operation.
07/11/05   jqi     Added avoidance timer for access failures and fades.
07/08/05   sk      Added generic event counters and timestamps to SS core
                   and added sdss_event_cnt_update() to update them.
                   Added IS_EVENT_CNT construct to the SD engine
                   Fixed Lint warnings.
06/30/05   jqi     Lint fixes.
06/26/05   ic      Lint and compiler warnings cleanup
06/06/05   jqi     Minimize 1x miss pages when DO is reverse link limited.
                   Avoidance: 2m(after 1 failure), 4m( after 2), 8m(after 3),
                   16m(after 6).
05/16/05   jqi     Skip the HDR record if FEATURE_HDR is not supported.
05/13/05   ka      Handling SDSS_EVT_WLAN_ACQ_BAD_SYS in acquisiton event
                   processing.
05/16/05   pk      Enhanced SDSSSCR_CON_CHK_SET_SRV_STATUS script to process
                   Bit masks of the SRV status. The new construct supports
                   sdssscr_srv_status_val_e_type parameters.
05/16/05   pk      Added support for SDSSSCR_CON_CHK_SET_SRV_STATUS script

05/04/05   jqi     Added support to process HDR bad system event while in
                   acquisition state.
                   Replace CELL/PCS with BC0/BC1 while checking the band
                   capability.
02/24/05   pk      Fixed lint errors.
01/30/05   sj      Added support for WLAN.
01/27/05   ka      Added support for Band class 10, 11, 12
01/17/05   jqi     Lint fix.
01/11/04   jqi     Lint fixes for newer version of Lint 7.50ab
01/06/04   jqi     Lint fixes.
01/06/05   sj      Fixed issue of ACQ event being circulated to different
                   engine which did not issue the corresponding ACQ action.
                   May happen because of PREV_SCR.
12/04/04   jqi     Power save mode optimization for GSM/UMTS targets.
10/26/04   jqi     Read subscription items only when the subscription is
                   available.
10/08/04   jqi     Fixed a typo.
08/08/04   sj      Added parameter to sdss_subsc_avail_update() to specify
                   SS-Main or SS-HDR. And adjust mode_pref according to
                   subscription status on SS-HDR.
08/26/04   jqi     Added WCDMA 1800 band support.
08/26/04   jqi     Lint fix.
08/20/04   sj      Added support for Auto A/B.
08/06/04   sj      Check for collocated association wih 1x srv_sys only if it
                   is populated.
08/03/04   sj      Added function to query the operating mode.
07/29/04   jqi     Quadband optimizatioin - eliminate scheduling.
07/15/04   sj      In throttle state _enter_pwr_save, ignore if throttle
                   is disabled or not and move to power_save state.
07/14/04   sj      Changed calls to update_srv_status to include srv_domain.
                   Changed issue with updating prev_*_pref in update_pref().
                   Added support for construct to check if srv domain pref is
                   CS+PS.
                   Added support for construct to check for current registered
                   srv_domain.
07/09/04   sj      For pref_update & is_pref_chgd, compare only the filtered
                   mode/band preferences.
06/30/04   RC      Now incrementing the schedule of a system only if the
                   scheduled acquisition attempt completes.
06/30/04   jqi     Quad-band enhancement for get network requst.
                   More quad-band enhancement for manual mode.
06/22/04   jqi     Capable to skip the system record in schedule list.
06/21/04   RC      Improve association (collocation) determination algorithm
                   for HDR systems while in hybrid operation - CR 44638.
06/21/04   jqi     Use sd nam selection indication when there is a
                   subscription change.
06/07/04   jqi     More quad-band enhancement for automatic mode.
06/02/04   sj      Place phone in emergency mode if GW is unavailable.
05/25/04   jqi     Fixed mode preference reset issue after power up.
05/19/04   jqi     Added quad-band enhancement to stay longer within a band
                   group prior to trying to acquire a new one when system is
                   lost.
05/07/04   jqi     Fixed the typo.
05/06/04   jqi     Renamed T32, KPCS, BC5,6 with band mapping features.
                   Added support for FEATURE_RF_GET_BAND_CAPABILITY.
05/03/04   jqi     Added UMTS 1700.850,800 band support.
04/19/04   jqi     Lint fix - for error level : error.
04/14/04   sj      Fixed issue with default acq. throttle table.
04/13/04   sj      Added support for acquisition throttling.
04/09/04   jqi     Print out band preference in sdss_act_print.
03/18/04   jqi     Kept band and mode consistent before passing to the GW
                   stack. Filtered out unqalified system record during GW PWR
                   SCAN.
02/27/04   jqi     Eliminate system scan whose bands does not comply with
                   target capability or system mode or mode preference.
02/06/04   SJ      Changed param type for get_acc_prm().
01/23/04   JQ      Passed down most recent acquired band group to GW stack
                   during early power scan.
01/22/04   SJ      Added support for new script construct is_pref_chgd().
12/12/03   RC      Added support for FEATURE_INT_ROAMING
12/08/03   SJ      Added support for multistage full srv reselection.
11/17/03   SJ      Updates for HDR usability and new hdr power save.
11/10/03   RC      Added support for SDSSSCR_CON_IS_NET_SEL script construct.
11/05/03   JQ      Do not error fatal while validating PRL.
                   More MRU3 updates.
10/31/03   RC      Added GSM/WCDMA support for fall-back to limited service.
10/24/03   RC      Changed SDSR_GW_LST to contain a single system of mode
                   SD_MODE_GW.
10/09/03   jqi     Adjusted band preference enum.
09/24/03   RC      In sdss_eng_scr_con_cont() set timer to 1s upon getting a
                   non-timer event if timer already expired.
08/26/03   SJ      Added ss parameter to sdss_get_pref().
08/18/03   RC      Fixed issues with IS-683D implementation.
07/28/03   RC      Restart OTASP acquisitions if orig_mode = ORIG_START.
06/10/03   RC      Added counter to track CDMA available indications.
05/23/03   RC      Initialize new_acq_cnt to 200 in sdss_init().
05/23/03   RC      Set scr_timer=0 when moving to next script construct.
05/21/03   RC      Fixed a problem with time based schedule initialization.
05/07/03   JQ      CR27630-MSG_LEVEL reference cleanup.
05/06/03   JQ      Added IS683B PRL support.
04/28/03   RC      Added support for event logging.
04/23/03   SJ      Added early power scan support for GSM/WCDMA.
03/07/03   SJ      Changed MSG level for few debug messages.
02/26/03   SJ      Added support for Band Class 8 & 9.
01/20/03   jqi     Added support for band class 6.
01/16/03   SJ      Featurized use of CAI defines.
12/17/02   SJ      Return TRUE in band_pref supported for GSM/WCDMA/GPS.
12/09/02   RC      Added support for FEATURE_JCDMA.
11/07/02   RC      Added support for new hybrid-HDR power-save algorithm.
07/17/02   RC      Added error recovery when the END script construct is
                   reached.
07/01/02   RC      Added error recovery when the SS-Client reports a system
                   selection event that is not allowed relative to the
                   current state of SD.
05/29/02   RC      Set the scr_timer to 0 when it is expired.
05/02/02   RC      Changed some SD_MSG_HIGH to SD_MSG_LOW.
03/08/02   hxw     Added FEATURE_GPSONE_MSBASED to support MSBased gpsOne.
02/12/02   RC      Added sdss_eng_stack_get_state().
01/25/02   sj      Added support for Tiered Service - User Zone feature.
01/23/02   RC      Added support for Rel. 3.0 CDMA-HDR hybrid operation.
12/12/01   RC      Added support for CDMA-HDR hybrid operation.
12/07/01   jqi     Added support for band class 5.
10/30/01   RC      Added support for IS-683C collcated systems.
09/07/01   RC      Added support for T53 and JCDMA features.
07/20/01   RC      Added support for IS-683C.
05/23/01   RC      Eliminated compiler warnings.
04/26/01   RC      Modified reacquisition schedules.
03/27/01   RC      Changes to support tri-mode targets.
03/09/01   RC      Changes per 11th week of I&T.
02/26/01   RC      Changes to support dual-mode targets.
02/01/01   RC      Changes per 8th week of I&T.
01/12/01   RC      Changes per 7th week of I&T.
01/12/01   RC      Changes per 6th week of I&T.
01/03/01   RC      Changes per 4th week of I&T.
12/14/00   RC      Changes per 3rd week of I&T.
12/04/00   RC      Changes per 2nd week of I&T.
11/27/00   RC      Changes per 1st week of I&T.
11/17/00   RC      Initial release.

===========================================================================*/


/* <EJECT> */
/*===========================================================================

                     INCLUDE FILES FOR MODULE

===========================================================================*/

#include "mmcp_variation.h"
#include "sdss.h"     /* External interface to sdss.c */
#include "sdssscr.h"  /* External interface to sdssscr.c (SS-Script) */

#include "sdcmd.h"

/* Featurization of string map generation. If we are not using a low
** memory target, the corresponding string maps will be generated.
** Additionally, the feature for enhanced debug messages will be enabled. */
#ifdef FEATURE_SD_ENHANCED_DEBUG_MSG
#define FEATURE_SD_ENABLE_DEBUG_STRINGS
#include "sdssscrtables.h"
#undef FEATURE_SD_ENABLE_DEBUG_STRINGS
#endif

/*
Copied from country_list cmutils.c "460" entries

{ 13568, 14335,   86,    "00", "13",   "0", NETWORK_SOLUTION_ABSENT,  460 },  China 13568
{ 25600, 26111,   86,    "00", "13",   "0", NETWORK_SOLUTION_ABSENT,  460 },  China 25600
{ 13568, 14335,   86,    "00", "15",   "0", NETWORK_SOLUTION_ABSENT,  460 },  China 13568
{ 25600, 26111,   86,    "00", "15",   "0", NETWORK_SOLUTION_ABSENT,  460 },  China 25600
{ 13568, 14335,   86,    "00", "18",   "0", NETWORK_SOLUTION_ABSENT,  460 },  China 13568
{ 25600, 26111,   86,    "00", "18",   "0", NETWORK_SOLUTION_ABSENT,  460 },  China 25600
*/
#define CHINA_SID_RANGE1_START 13568
#define CHINA_SID_RANGE1_END   14335

#define CHINA_SID_RANGE2_START 25600
#define CHINA_SID_RANGE2_END   26111

#include "sdsr.h"     /* External interface to SDSR.C (System Record)*/
#include "sd.h"       /* External interface to sd.c */
#include "sd_v.h"
#include "sdi.h"      /* Internal interface to sd.c */
#include "bit.h"      /* Bit packing/unpacking services */
#include "sdprl.h"    /* External interface to SDPRL.C */
#include "sdnv.h"     /* External interface to sdnv.c */
#include "sddbg.h"    /* SD debug macros */
#include "sdlog.h"    /* SD20 logging */
#include "event.h"    /* Event reporting services */


#include "customer.h" /* Customer configuration file */
#include "comdef.h"   /* Definition for basic types and macros */
#include "msg.h"      /* Message output services */
#include "err.h"      /* Error and error fatal services */
#include <stringl/stringl.h>
#ifdef SD_USES_CAI
#include "cai.h"      /* Over the air messages definitions */
#include "cai_v.h"
#endif
#include "time_svc.h"      /* Interface to clock services */
#include "sys.h"      /* Declarations for common types. */
#include "sys_v.h"
#ifdef FEATURE_SD_LTE
#include "sys_eplmn_list.h"
#endif
#include "rfm.h"
#include "policyman.h"

#ifdef FEATURE_ECALL_IVS
#include "ecall_modem_apis.h"
#endif

#include "sdefs.h"
#include "sdmmss.h"

#include "trm.h" /* MCS modem capability */

#include "mm.h"

/* Get the hardware mode and band capability */
#include "policyman.h"
#include "sdcmd.h"

#ifdef FEATURE_MMODE_QTF
#error code not present
#endif /* FEATURE_MMODE_QTF */

#include <string.h>
#ifdef SD_UNIT_TEST
#include "stringl.h"
#else
#include <stringl/stringl.h>
#endif

#ifdef FEATURE_MMODE_QTF
#error code not present
#endif
#include <math.h>
#include "sdcmd.h"

/* <EJECT> */
/*===========================================================================

            LOCAL DEFINITIONS AND DECLARATIONS FOR MODULE

This section contains local definitions for constants, macros, types,
variables and other items needed by this module.

===========================================================================*/

/* <EJECT> */
/*---------------------------------------------------------------------------
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
-------------------------------- ACQUISITION THROTTLE  ----------------------
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
---------------------------------------------------------------------------*/

/*
                         Throttle acquisition State Machine
                         ---------------------------------

                          +------------------------+
                          |                        |          ( IACT_ACQ ||
                          |                        |          ( PWR_SAVE_ENTER ||
                          |                        |          ( TIMEOUT ) &
                          |         INACT          |<--------- THRTTL_OFF /-----
                          |                        |          => ACQUIRE
                          +------------------------+        ( From any state )
                                     |
                                     |
                                  IACT_ACQ &
                                  THRTTL_ON
                                     |          +--------------------------+
                                     |          ^                          |
                                     |          |                          |
                                     |          |                          |
                                    \|/         |                          |
                         +------------------------+                        |
                         |                        |       IACT_ACQ &       |
           +>----------->|          ACQ           |<------THRTTL_ON &------+
           |             |                        |       acq_count < MAX in stage
           |             +------------------------+
           |                         |
           |                         |
           |                       IACT_ACQ &
           |                       THRTTL_ON &
           |                       acq_count > MAX in stage
           |                         |
           |                        \|/
           |               +------------------------+
           |               |                        |
           |  IACT_ACQ &   |     ENTER_PWR_SAVE     |
           +<-THRTTL_ON/ --|                        |
           |  =>ACQUIRE    |                        |
           |               +------------------------+
           |                          |
           |                          |
           |                      PWR_SAVE_ENTER &
           |                       THRTTL_ON/THRTTL_OFF
           |                          |
           |                         \|/
           |  (IACT_ACQ ||  +------------------------+
           |  TIMEOUT )&    |                        |
           +<-THRTTL_ON/ ---|       PWR_SAVE         |
             =>ACQUIRE      |                        |
                            +------------------------+
*/


/* Enumeration that defines the state of the throttling.
*/
typedef enum {

  SDSS_THRTTL_STATE_INACT,              /* Throttling is not in progress.
                                        */

  SDSS_THRTTL_STATE_ACQ,                /* Throttling is enabled and acquisition
                                        ** is pending.
                                        */

  SDSS_THRTTL_STATE_ENTER_PWR_SAVE,     /* Throttling SM is waiting for power save
                                        ** enter event.
                                        */

  SDSS_THRTTL_STATE_PWR_SAVE,           /* Throttling is in power save.
                                        */

  SDSS_THRTTL_STATE_MAX                 /* Internal use.
                                        */

} sdss_thrttl_state_e_type;



/* Enumeration that defines whether the event was consumed or not.
*/
typedef enum {

  SDSS_THRTTL_EVT_STATUS_CONSUMED,      /* Event given to throttle SM is
                                        ** consumed.
                                        */

  SDSS_THRTTL_EVT_STATUS_NOT_CONSUMED,  /* Event given to throttle SM is
                                        ** not consumed, proceed with rest
                                        ** of processing.
                                        */

  SDSS_THRTTL_EVT_STATUS_MAX

} sdss_thrttl_evt_status_e_type;
/*lint -esym(749, SDSS_THRTTL_EVT_STATUS_MAX ) */ /* Sym not defined */

/* Type that defines the acquisition throttling algorithm in terms of
** delay between stages and number of acquisitions in each stage.
*/
typedef struct {

  /* Delay in seconds from the previous stage.
  */
  dword                     delay;

  /* Number of acquisitions in this stage, if num_acq = 0,
  ** skip this stage.
  */
  unsigned int              num_acq;

} sdss_thrttl_stage_param_s_type;


/* Type for holding the state variables that are associated with the
** acquisition throttle mechanism.
*/
typedef struct {

  /* State of the throttling mechanism.
  */
  sdss_thrttl_state_e_type        state;

  /* Flag to indicate if throttling was enabled.
  */
  boolean                         is_thrttl_on;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Pointer to table which defines acquisition throttle algorithm.
  */
  sdss_thrttl_stage_param_s_type  *thrttl_tbl_ptr;

  /* Number of stages.
  */
  unsigned int                    num_stages;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Current stage in the throttle table.
  */
  unsigned int                    curr_stage;

  /* Field to keep track of number of acquisitions in each stage.
  */
  unsigned int                    acq_count;

  /* The last acqusition action which was throttled.
  */
  sdss_iact_s_type                last_acq_iact;

} sdss_acq_thrttl_s_type;


/* Default acquisition throttling table.
*/
static sdss_thrttl_stage_param_s_type dflt_thrttl_tbl[] =
{
  /* { delay(seconds), number of acquisitions }
  */
  #if defined(SD_DEBUG)
  #error code not present
#else
  {5, 1},
  {5, 1},
  {5, 1},
  {5, 1},
  {10,1}
  #endif
};

/* MAX value for Acq_sys_time_interval
*/
#define SYS_ACQ_SYS_TIME_INTERVAL_MAX               0xFFFFFFFF
#define BSR_UPTIME_NONE    0

/*---------------------------------------------------------------------------
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
-----------   Avoidance Better Service Reselection   ------------------------
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
---------------------------------------------------------------------------*/

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

/* Holding ABSR related information.
*/

typedef struct {

  /* ABSR indication is activated or not.
  */
  boolean                     is_activated;

  /* Number of ABSRs per BSR.
  */
  uint32                      num_per_bsr;

  /* Current BSR Counter
  */
  uint32                      cnt;

} sdss_absr_s_type;

/* Holding ABSR related information.
*/

typedef struct {

  /* SPLMN.
  */
 sys_plmn_id_s_type    splmn;

  /* System on which this splmn rxed
  */
 sys_sys_mode_e_type   sys;

} sdss_splmn_rat_info_type;

#ifdef FEATURE_EOOS
#error code not present
#endif

/* Static local variables for LTEAvailFile/LTENotAvailFile
*/

static sdss_lte_avail_file_s_type sdss_lte_avail_file;
static sdss_lte_avail_file_s_type sdss_lte_not_avail_file;

const char* sdss_lte_avail_e_type_string_map[] = {
    "Unknown",
    "LteAvail",
    "LteNotAvail",
    "Max"
};

/* <EJECT> */
/*---------------------------------------------------------------------------
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
--------------------------------- GENERAL -----------------------------------
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
---------------------------------------------------------------------------*/

#define NEW_ACQ_INIT(ss) (ss*(255/SD_SS_MAX)+1)
#define NEW_ACQ_MAX(ss) (ss+1)*(255/SD_SS_MAX)

typedef struct {
  /* Query the operator name from EFS
  */
  sd_operator_e_type           sd_operator_name;

  /* Indicate whether FULL SRV REQ is needed during emergency mode
  */
  boolean            cfg_full_srv_req_in_emerg;

  boolean is_alternate_redial_algorithm;

  boolean is_ral_stored_in_efs;

  boolean wifi_e911_wwan_full_srv;

}sdss_sub_config_s_type;
/*
** This struct will contain all the parameters which have UE wide relevance
** and are not restricted to stack.
**
** The value will be same for all SD stacks so to avoid redundancy and possible
** mismatch these items will be stored in the common struct.
*/
typedef struct {
  sdss_sub_config_s_type sub_config[MAX_SIMS];
  /* Operating mode - represent the current operating mode indication.
  */
  sdss_opr_mode_e_type        opr_mode_main;
  sdss_opr_mode_e_type        opr_mode_hybr2;
  sdss_opr_mode_e_type        opr_mode_hybr3;
  boolean                       is_manual_search_bst;

  sd_bst_tbl_s_type             manual_search_bst;

  /* Indicate whether QRD Features are enabled
  */
  boolean            sd_qmss_enabled;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* TRM capability
  */
  trm_simul_cap_return_data   trm_cap;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Populate the mode preference based on the featurization, HW capability,
  ** filter out the mode without any supported bands, and filter out the band
  ** without any supported mode.
  */
  sd_ss_mode_pref_e_type      mode_capability;

  /* 3G band capability.
  */
  sd_ss_band_pref_e_type      band_capability;


  /* band capability for LTE
  */
  sys_lte_band_mask_e_type    lte_band_capability;


  /* band capability for TD-SCDMA
  */
  sd_ss_band_pref_e_type      tds_band_capability;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* is_c2k_alt_algr: set to TRUE when C2K ALT ALGR needs to be
  ** triggered, based on NV-EFS item - C2K_ALT_ALGR
  */
  boolean                     is_c2k_alt_algr;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* is_hybr_hdr_irat : set to TRUE when DO CP sends redirection/resel
  ** indication to SD informing that IRAT from LTE to Hybrid DO should be
  ** performed. It is set to FALSE when redirection fails or when LTE is
  ** added back to the mode pref after successful redirection
  */
  boolean                     is_hybr_hdr_irat;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* The flag to indicate Optimized LTE->ehrpd handoff is in progress.
   ** Set to 1 when HDRCP indicates the redir_type is opt HO.
   ** Reset when
   ** 1. hdr overhead information is received
   ** 2. or redir failure/abort occurs
   */
  boolean                     is_opt_ho_lte_do;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Indication of LTE activity on MDM. Maintained on MSM and updated by
  ** call back from MDM
  */
  boolean                     lte_activity_status;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* indicates if HDR was in OPR state when 1x service changed and
  ** realign operation needs to be performed. This flag is set from SD MAIN
  ** and cleared once processed by SD's HYBR1 instance
  */
  boolean                       is_hdr_opr_realign_pref_lst;

  /* indicates if 1x is in the process of realigning HDR's colloc list.
  ** If this flag is set, HDR should not attempt to do the same.
  */
  boolean                       is_1x_realign_hdr_srv_colloc_lst;

  /* Indicated whether the UE is allowed to register with the network or only
  ** camp on it without registering.
  */
  sd_ss_pref_camp_mode_e_type   camp_mode;

  /* Indicated whether the UE is emergency attached or not
  */
  boolean                      is_emerg_attached;

  /* Indicated whether the UE is emergency barred or not
  */
  sys_lte_emerg_access_status_e_type emerg_bar_status;

  /* Indicates whether Emergency call after LU in LPM needed to send to 
     Network or not
  */
  boolean            cfg_emerg_call_after_lu_in_lpm;
  
  /* Romaing indication update in L to 1X handoff is needed or not
  */
  boolean            cfg_roam_ind_update_in_l_to_1x_ho;
  
  #ifdef FEATURE_MMODE_DYNAMIC_SV_OPERATION_SWITCH
  /* Indicated if the SV dynamic switch opr is enabled
  */
  boolean                       is_sv_dynamic_switch_enabled;

  /* Indicated the current sv_opr_mode that UE is operating in
  */
  sdss_sv_opr_action_e_type     sv_opr_action;
  #endif /* FEATURE_MMODE_DYNAMIC_SV_OPERATION_SWITCH */

  sys_overall_feature_t       onebuild_feature;

  /* Identifies feature that is enabled in this instance of common build */

  sys_subs_feature_t                   subs_feature[SD_SS_MAX];

  sys_subs_feature_t                   pm_subs_feature[SD_SS_MAX];

    /* Current feature to be enabled in super-build */
 #if defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)

  byte cdma_imsi[SD_CT_CDMA_IMSI_LEN];

  #endif
   /*  Indicate if the system records to be avoided are updated
   */
   boolean is_avoid_lst_updated;

   /* Is the new optimized silent redial feature enabled */
  boolean is_ehrpd_opt_redial;
   
  /*Buffer srv lost updated due to TRM failure*/
  
  boolean buffer_int_srv_lost;

  boolean                   c2k_resel_splmn_supp;
  sdss_splmn_rat_info_type  splmns[SD_MAX_SPLMN_IDS*2];
  int                       splmn_num;
  sys_sys_mode_e_type       last_splmn_rx_mode;
   
  /** CS registation status on lte network 
  */
  sys_lte_cs_capability_e_type         lte_cs_capability;

  boolean is_extend_lbsr_when_1x_activity;
    /* Boolean flag to indicate that the fix to extend LTE BSR on HYBR_2
    ** when 1x is TRAFFIC or ACCESS states on MAIN is ENABLED 
    */ 

  boolean is_1x_sib8_scan_opt_enabled;
  /* The feature to scan 1x sys based on 1XSIB8 info - enabled or disabled */

  boolean n_loops_1xsib8_scan;
  /* Number of times to scan the new sequence if feature is enabled */

  sys_specialization_t   special_volte_e911_calls;
  /* Indicates the PM value  for special_volte_e911_calls*/  

  boolean                        is_force_kick_hybr2;
   /*Inidcate whether HYBR_2 needs to brought into OOS timeline */
   
  /* Rules for scan_scope */
  uint16                         sd_scan_scope_rule;
   
  /*Check if Scan Scope Rule NV is available*/
  boolean                        is_scan_scope_rule_avail;

   /* Indicates whether Emergency call in no subscription should be 
      tried on 1x first or not
  */
  boolean            cfg_emerg_call_1x_scan_first;

  /* Indicates what enhanced F3s need to be enabled*/
  uint16                         enhanced_f3_dbg_rule;
  
}sdss_common_s_type;

/* Type for holding the state variables that are associated with the system
** selection core.
*/
typedef struct {

  /* Service status - represent the current service status - no-ervice,
  ** limited service, full service.
  ** Service domain - represent whether it is CS or PS or both.
  */
  sys_srv_status_e_type       srv_status;
  sys_srv_domain_e_type       srv_domain;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Origination mode - represent the current origination mode indication.
  */
  sd_ss_orig_mode_e_type      orig_mode;

  /* The previous origination mode.
  */
  sd_ss_orig_mode_e_type      orig_mode_prev;

  /* The most recent reason for updating the SS-Preference.
  */
  sd_ss_pref_reas_e_type      pref_reason;

  /* Mode, band, roam and hybrid preferences - represent the current system
  ** selection preferences.
  */
  sd_ss_mode_pref_e_type      mode_pref;

  /* Indication whether PRL supports HDR or not based on current BAND PREF.
  */
  boolean                     is_prl_support_hdr;

  /* Indicate if sub2->hybr3
  */
  boolean                     is_sub2_map_to_hybr3;

  sd_ss_mode_pref_e_type      true_mode_pref;
  sd_ss_mode_pref_e_type      user_mode_pref;
  sd_ss_mode_pref_e_type      user_true_mode_pref;

  /* Store last global mode pref forced by user */
  sd_ss_mode_pref_e_type      user_global_mode_pref;

  sd_ss_band_pref_e_type      band_pref;
  sys_lte_band_mask_e_type    lte_band_pref;
  sd_ss_band_pref_e_type      tds_band_pref;
  sd_ss_band_pref_e_type      user_band_pref;
  sd_ss_prl_pref_e_type       prl_pref;
  sd_ss_roam_pref_e_type      roam_pref;
  sd_ss_hybr_pref_e_type      hybr_pref;

  /* Other preferences related to GSM/WCDMA.
  */
  sd_ss_srv_domain_pref_e_type domain_pref;
  sd_ss_acq_order_pref_e_type  acq_order_pref;
  sys_acq_status_e_type        acq_status;

  /* Indicate if trm resource is released on the other sub while acq status is still no resource.
  ** Set the flag upon receiving pref_update reason 
  ** = SD_SS_PREF_UPDATE_REASON_TRM_UNLOCK and acq_status = no resource.
  ** Reset when acq_status is updated upon receiving service cnf from NAS.
  */
  boolean                      is_trm_unlock_in_progress;
  
  sys_rat_pri_list_info_s_type  rat_pri_list_info;
  /* last rat pri list obtained in idle mode
  */
  sys_rat_pri_list_info_s_type  idle_rat_pri_list_info;

  /* last rat pri list obtained in emergency mode
  */
  sys_rat_pri_list_info_s_type  emerg_rat_pri_list_info;


  /* The origination mode prior to making emergency call
  */
  sd_ss_orig_mode_e_type        idle_orig_mode;

  sd_rat_acq_order_s_type       rat_acq_order;
  /* rat acq order to be used in emerg_mode
  i.e. no sim or E911 call orig */
  sd_rat_acq_order_s_type       emerg_rat_acq_order;
  #ifdef FEATURE_EOOS
  #error code not present
#endif

  /* Previous Mode, band, roam, hybrid, domain and acq_order preferences.
  */
  sd_ss_mode_pref_e_type      prev_mode_pref;
  sd_ss_band_pref_e_type      prev_band_pref;
  sys_lte_band_mask_e_type    lte_prev_band_pref;
  sd_ss_band_pref_e_type      tds_prev_band_pref;
  sd_ss_prl_pref_e_type       prev_prl_pref;
  sd_ss_roam_pref_e_type      prev_roam_pref;
  sd_ss_hybr_pref_e_type      prev_hybr_pref;
  sd_ss_srv_domain_pref_e_type prev_domain_pref;
  sd_ss_acq_order_pref_e_type  prev_acq_order_pref;
  sys_rat_pri_list_info_s_type prev_rat_pri_list_info;

  /* The band-class and PCS frequency block/Cellular system that are
  ** associated with OTASP origination mode. Note that these fields are
  ** ignored when orig_mode != OTASP.
  */
  sd_band_e_type              otasp_band;
  sd_blksys_e_type            otasp_blksys;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* The event that triggered the stack processing
  */
  sdss_evt_e_type             true_event;

  boolean                     is_true_event_processed;

  #ifdef FEATURE_HICPS_STACK_SYNC_UP
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Are we in the process of stack sync-up
  */
  boolean                     is_stack_syncup_in_progress;
  #endif /* FEATURE_HICPS_STACK_SYNC_UP */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* System Selection State - indicates whether the system selection is in
  ** acquisition state or operation state.
  **
  ** Note that being in acquisition state corresponds to the SS-Client being
  ** in initialization state (of CDMA, AMPS or HDR) whereas being in
  ** operation state corresponds to the SS-Client being in states other than
  ** initialization, like idle, access or traffic.
  */
  sdss_state_e_type           ss_state;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Acquisition type - indicate the last acquisition type being attempted.
  */
  sdssscr_acq_e_type          acq_type;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Acquisition start time - record the uptime as of the last time
  ** the START_TIME construct was executed.
  */
  dword                       acq_start_time;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  #ifdef LTE_CONN_MODE_OPT
  /* Time in [ms] when the LTE connected mode expires. If set to 0, the UE is
  ** no longer in connected mode. Also there is a dedicated report coming
  ** from NAS that wouild indicate that the LTE connected mode has expired.
  */

  dword                       lte_conn_mode_uptime;
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Indication if the system is in LTE Connected mode
  */
  boolean                     lte_in_conn_mode;

  /* Flag to indicate if RLF processing has to be done
  ** during emergency call
  */
  boolean                     is_RLF_during_emerg;

  /* Flag to indicate if FULL service reqeust has to be triggered
  ** during emergency call
  */
  boolean                     is_full_srv_req_during_emerg;

  #if defined ( FEATURE_WRLF_SYSTEM_SEL)
  /* Time in [ms] when the  suitable search timer expires.
  **.Also there is a dedicated report coming
  ** from NAS that wouild indicate that the WCDMA suitable search timer has expired.
  */

  dword                       wcdma_suitable_search_time;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Indication if the system is in WCDMA Connected mode
  */

  boolean                     wcdma_in_conn_mode;
  #endif /* FEATURE_WRLF_SYSTEM_SEL */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* New-acquisition counter - incremented every time a NEW_ACQ script
  ** construct is encountered.
  **
  ** NOTE! This value should never be set to 0 (as 0 is reserved to indicate
  ** that the new-acquisition counter shall be ignored).
  */
  byte                        new_acq_cnt;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Script execution control counter. This counter is being incremented each
  ** time control is returned to the SS-Front-end. Its is being used for
  ** detecting SS-Script loops that does not return control to the
  ** SS-Front-end.
  */
  int                         scr_ctrl_cnt;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Redirection parameters - represent the current redirection,
  ** RETURN_IF_FAILED, IGNORE_CDMA, Max Redirect Delay and redirection
  ** uptime.
  **
  ** Redirection - represent the redirection type.
  **
  ** Is valid - indicate whether the redirection is valid for this target.
  **
  ** Expected SID - If the MS is being redirected to a specific system,
  ** indicate the SID of that system; otherwise, set to SD_WILDCARD_SID.
  **
  ** Expected NID - If the MS is being redirected to a specific network,
  ** indicate the NID of that network; otherwise, set to SD_WILDCARD_NID.
  **
  ** RETURN_IF_FAILED indicate whether the MS is required to return to the
  ** system from which it is redirected upon failure to obtain service using
  ** the redirection criteria.
  **
  ** IGNORE_CDMA indicate whether the MS is to ignore the CDMA Capability
  ** Message (i.e. CDMA available indication) on the AMPS system to which
  ** the MS is being redirected.
  **
  ** Maximum redirect delay. When the BS redirects the MS from a CDMA system
  ** to an AMPS system (using GSRDM), this field indicate the maximum
  ** redirect delay value (in units of 8 second increments) to be used in the
  ** AMPS registration randomization algorithm. Note that the
  ** max_redirect_delay is a redirection parameter that needs to be passed
  ** into AMPS CP - SD is merely a path-through. This variable is ignored
  ** when it is set to SD_SS_MAX_REDIR_DELAY_NONE.
  **
  ** Redirection uptime - record the uptime when the most recent redirection
  ** indication was received from the SS-front-end.
  */
  sd_ss_redir_e_type          redir;
  boolean                     redir_is_valid;
  word                        redir_expected_sid;
  word                        redir_expected_nid;
  boolean                     redir_is_rif;
  boolean                     redir_is_ignore_cdma;
  word                        redir_max_redirect_delay;
  dword                       redir_uptime;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Handoff - represent the current handoff indication.
  */
  sd_ss_ho_e_type             handoff;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Access reason and termination - represent the most recent access reason
  ** and access termination reason.
  */
  sd_ss_acc_reas_e_type       acc_reas;
  sd_ss_acc_term_e_type       acc_term;

  /* Indicate how many times registration access has failed continuously.
  */
  int                         acc_fail_cnt;

  /* Indicate the uptime where registration access have started failing.
  */
  dword                       acc_fail_start_time;

  /* HDR session close - represent the most recent HDR session close reason.
  */
  sd_ss_ses_close_e_type      ses_close;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* CDMA locked - represent the CDMA locked until power cycle indication.
  */
  boolean                     is_cmda_locked;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* SIM state, applicable for GSM/WCDMA networks.
  */
  sys_sim_state_e_type        sim_state;

  /* APP type of GWL apps
  */
  mmgsdi_app_enum_type          gwl_app_type ;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* SRDA - indicate whether the silent redial with AMPS feature is enabled.
  */
  boolean                     is_srda;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Reselection state - represent the current reselection state.
  */
  sdss_resel_stt_e_type       resel_state;

  /* Reselection mode - represent the current reselection mode.
  */
  sdss_resel_mode_e_type      resel_mode;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Flag to indicate if GW subscription is available.
  */
  boolean                     is_gw_subsc_avail;

  /* Flag to indicate if 1X subscription is available.
  */
  boolean                     is_1x_subsc_avail;

  /* Flag to indicate if GW2 subscription is available.
  */
  boolean                     is_gw2_subsc_avail;

  /* Flag to indicate if GW3 subscription is available.
  */
  boolean                     is_gw3_subsc_avail;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Acquisition throttle state information.
  */
  sdss_acq_thrttl_s_type      acq_thrttl;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  boolean                     is_hdr_activity;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  boolean                     is_cdma_activity;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* mode pref for get network request
  */
  sd_ss_mode_pref_e_type      get_net_mode_pref;

  /* band pref for get network request.
  */
  sd_ss_band_pref_e_type      get_net_band_pref;

  /*  Band pref for LTE network request*/
  sys_lte_band_mask_e_type    get_net_band_pref_lte;

  /*  Band pref for TD-SCDMA network request*/
  sd_ss_band_pref_e_type      get_net_band_pref_tds;

  /* The list, the starting list position of get network request, the list
  ** position of the last get network request.
  */
  sdsr_e_type                 get_net_list;

  int                         get_net_list_start_pos;

  int                         get_net_list_pos;

  /* Network List type for Get Net request
  */
  sd_network_list_type_e_type  get_net_list_type;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Acquisition list and position - indicates the list and position
  ** most recently attempted acquisition.
  */
  sdsr_e_type                 acq_list;
  int                         acq_pos;

  /* Assosiation tag of the Previous System - indicates the association tag
  ** , from prl, of the recent succesfully connected CDMA System.
  **
  ** Updates: Set to ass-tag of the CDMA system acquired.
  **          Clear the ass-tag when trying for GSM system.
  **
  ** Used to determine the realign_hdr flag, for CM to kick HDR
  */
  sdss_sys_addn_info_s_type  prev_sys_info;

  /* Last engine which issue the acquisition action.
  ** Made void else needs forward declaration.
  */
  void*                       last_acq_eng_ptr;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Indicate how many times session negotiation or access has timed out
  ** continuously.
  */
  int                         event_cnt[SDSS_CNTED_EVT_MAX];

  /* Indicate the uptime where session negotiation or access started timing
  ** out.
  */
  dword                       event_uptime[SDSS_CNTED_EVT_MAX];

  /* Indicate the system SID associated with the event.
  **
  ** Initial to 0.
  **
  ** Updated when the system SID is changed.
  **
  */
  sd_sid2_u_type              event_sid;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Indicate the uptime when a continue wait timer should be started
  **
  ** The uptime can be zero out during power up or clear it explicitly in
  ** the script.
  **
  */
  dword                       cont_uptime[SDSSSCR_CONT_TYPE_MAX];


  /* The very recent HDR Activity start/stop uptime -indicates the uptime in
  ** seconds when activity is started or stopped, which can used to get the
  ** the duration of the very recent HDR activity.
  */
  dword                       hdr_bcmcs_start_uptime;

  dword                       hdr_bcmcs_stop_uptime;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Indicate user preference updated status upon user ss pref event.
  */
  sdss_pref_updated_e_type    ss_pref_updated_status;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Indicate the system lost reason upon system lost event - represent the
  ** most recent system lost reason.
  **
  ** Initialize: None at Power up
  **
  ** Update: whereeven there is a HDR system lost operation event reported.
  */
  sd_ss_sys_lost_e_type       sys_lost;


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Parameters for GW uniform scan
  */

  /* Flag to check GCF testing
  */
  boolean                     gprs_anite_gcf;

  /* GWL scan status
  */
  sd_ss_gwl_scan_status_e_type acq_gwl_scan_status;


  /* Use timer, the timer values are set to valid values
  */
  boolean                     acq_gwl_use_timer;

  /* Is this a new acquisition or the continuation of previous scan
  */
  boolean                     acq_gwl_new_acq;

  /* Time for UMTS scan
  */
  dword                       acq_gwl_wcdma_scan_time;

  /* Time for gsm scan
  */
  dword                       acq_gwl_gsm_scan_time;

  /* Time for LTE scan
  */
  dword                       acq_gwl_lte_scan_time;


  /* It is set to the time when the EOOS starts.
  ** It is reset when the UE is in no longer OoS.
  */

  dword                       acq_start_eoos;
  boolean                     eoos_active;

  /* The service request type to be sent to NAS */
  sd_ss_srv_req_type_e_type   srv_req_type;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  boolean                     is_eng_scr_timer_set;
  /* Flag to check if the script timer is set
  */

  dword                       eng_scr_timer;
  /* the script timer
  */

  dword                       bsr_timer;
  /* Uptime for BSR
  */

  sd_sid2_u_type              bsr_sid;
  /* SID/PLMN for which BSR timer is started
  */

  sd_sys_s_type               bsr_sys;

  byte                        gw_pwr_save_acq_stage_val;
  /* GW pwr save acq stage value.
  */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Regstration status - represent whether MS is registered or not.
  */
  sys_reg_status_e_type       cdma_reg_status;

  /* ABSR
  */
  sdss_absr_s_type            absr;

  /* is_map_scan : used within int_srv_lost[] to keep track of whether
  ** at least one MAP scan is completed.
  ** It is reset to FALSE after at least one MAP avoid scan is completed
  */
  boolean                     is_map_scan;


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* is_mmss_operation : set to TRUE if equivalent PRL is generated
  ** successfully. False , otherwise
  */
  boolean                     is_mmss_operation;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #ifdef FEATURE_EOOS
  #error code not present
#endif

  /* n_min_voice_scans determine how many loop of voice scan needs to be
  ** done at power-up before data scans are triggered.
  */
  uint32                      n_min_voice_scans;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* is_hybr_2_bsr : set to TRUE when HYBR2 stack is in BSR state based on
  ** service on either MAIN or HYBR1 stack
  */
  boolean                     is_hybr_2_bsr;

  /* is_hybr2_lte_irat_fail : set to TRUE when we fail on DO to LTE reselection
  ** and reset to FALSE after we go to PWR_SAVE. Only used for HYBR2 stack
  */
  boolean                     is_hybr2_lte_irat_fail;

  /* iBSR_pwrup : SET to FALSE on power up and SET to TRUE once immediate BSR is done on
  ** powerup for SVLTE configuration.
  */
  boolean                     iBSR_pwrup;

  boolean                     is_eHRPD_zone;


  /* lte_avail_1x : indicates if acquired 1x system is in LTE Available area.
  ** prev_lte_avail_1x : inidicates previous lte_avail_1x flag.
  ** This flag is updated based on LTEAvailFile/LTENotAvailFile.
  */
  sdss_lte_avail_e_type       lte_avail_1x;
  sdss_lte_avail_e_type       prev_lte_avail_1x;

  /* Is HDR deactivated due to GWL acq on hybr2
  */
  boolean                     is_hdr_deact_by_hybr2_bsr;
/* Store the plmn list status*/

  sys_plmn_list_status_e_type   plmn_list_status;

  uint32                        plmn_list_length;


  /* LTE CS capability */
  sys_lte_cs_capability_e_type  lte_cs_capability;
  sys_extend_srv_info_e_type    ext_srv_info;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #ifdef FEATURE_AVOID_DUP_BAND_SCAN

  /* Store the parameters related to 3GPP avoid duplicate band scan */
  sdss_avoid_dup_band_scan_s_type    avoid_dup_band_scan;

  #endif

  /* Indicate if UE is in service lost state currently
   ** The flag is set upon receiving a service lost event.
   */
  boolean                      is_in_srv_lost_state;


  #ifdef FEATURE_MMSS_3_1
  boolean                      is_non_mmss_type;
  #endif

  /* Indicate if long BSR timer should be used. It is determined by received MCC and NV settings
  */
  boolean                      is_loc_based_bsr;

  /* Indicate if location change is due to moving from long BSR DO area to short BSR DO area */
  boolean                      is_loc_chg_move_out;

  /* Record the actual loop of LTE tele bsr. how many LTE tele bsr timer run. start from 1 */
  uint32                      telescope_bsr_current_loop_lte;

  /* Record the times 1x BSR timer has run. starting from 1 */
  uint32                      telescope_bsr_current_loop_1x;

  /* Record the current loaded BSR timer on main stack. init to 0 */
  //dword                       telescope_bsr_timer_main;

  /* TRUE indicates LTE BSR timer not expired so LTE scan should be skipped */
  boolean                     is_skip_lte_pref_scan;

  /* TRUE indicates 1X BSR timer not expired so 1X scan should be skipped */
  boolean                     is_skip_1x_pref_scan;

  /* Indicate if lte tele BSR timer is running*/
  boolean                     is_lte_tele_bsr_timer;

   /* Indicate if 1x BSR timer is running */
  boolean                     is_1x_bsr_timer;

   /* Indicate if SD has not completed 1x scans and should extend the BSR timer */
  boolean                     is_extend_1x_bsr_timer;

  /* Indicate main stack BSR uptime */
  dword                       telescope_bsr_timer_main_uptime;

  /* If base station id is changed */
  boolean                     is_bid_change;
  /* If more pref list has LTE sys changed */
  boolean                     is_pref_lte_change;
  dword                       bsr_uptime_lte;
  dword                       bsr_uptime_1x;
  boolean                     is_lte_long_bsr;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Indicate if the MCC of more preferred PLMN system has a match in NV
   */
   boolean                     is_mcc_match_found;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Below CSG info is stored for sending the CM_SERVICE_REQ  again for the
  ** last serving CSG in case of WRLF failures till the suitable timer expiry
  */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* csg_id: Indicates the CSG Id coming from system selection preferences.
  */
  sys_csg_id_type                csg_id;

  /* csg_rat: Indicates the CSG RAT coming from system selection preferences.
  */
  sys_radio_access_tech_e_type   csg_rat;

  /* csg_net_sel_mode_type: Indicates the CSG net_sel_mode coming from system selection preferences.
  */
  sys_network_selection_mode_e_type  csg_net_sel_mode_type;

  /* csg_srv_req_type: Indicates the CSG srv_req_type coming from system selection preferences.
  ** currently, only persmissible value is SD_SS_SRV_REQ_TYPE_USER_SELECTION_CSG_RPLMN
  */
  sd_ss_srv_req_type_e_type     csg_srv_req_type;

  /* csg_plmn: Indicates the CSG PLMN coming from system selection preferences.
  */
  sys_plmn_id_s_type       csg_plmn;

  /* csg_man_plmn_type: Indicates the CSG Manual PLMN type coming from system selection preferences.
  */
  sd_manually_selected_plmn_e_type    csg_man_plmn_type;

  boolean                            is_non_rplmn_csg_selection;

  boolean                        is_1xcsfb_ecbm;
  /* Indicates the ECBM support when ORIG_MODE is 1XCSFB_EMERG_ORIG */

  boolean                        is_1xcsfb_ecbm_supp;
  /* Indicates the EFS Item value, for 1XCSFB_ECBM feature enabled/disabled */

  /* Indicates the device support for SVDO */
  sd_ss_mode_pref_e_type        operator_capability;

  /* Voice domain pref */
  sys_voice_domain_pref_e_type  voice_domain_pref;

  /* Previous Voice domain pref */
  sys_voice_domain_pref_e_type  prev_voice_domain_pref;

  /* This flag indicates whether GW system should be removed out of the pref_list
     during recursive BSR phase. The logic behind it is explained:
     - When a GWL system is acquired, we rely on NAS to do HPLMN search to move to
     move to more preferred GWL systems. Hence, SD scripts removed GWL system
     out of the SRV_PREF_LST. However, during Idle BSR, because we're doing
     recursively, the next pref_list is built without this constraint, adding
     back the GWL system on it.
     Hence, SD issued acquisition on GWL system during BSR phase after finding first
     1X more pref system. Because this GWL system found is RPLMN system, SD
     terminate the BSR process and camp on it. Thus, it ends up with the previous
     less preferred GWL system. */
  boolean                     remove_gwl_on_bsr;

  sys_scan_scope_e_type          scan_scope;
  /* Indicates the scope (full band/acq-db only) of Scanning Search */

  sd_ss_pref_update_reason_e_type pref_update_reas;
  /* Indicates the preference update reason sent by CM
  ** during pref_sys_chgd command  */

  boolean                         manual_search_in_wrlf ;
  /* Indicates manual search in wcdma and lte */ 

  boolean                        is_1xcsfb_call_end_opt;
  /* Indicates the EFS Item value, for 1XCSFBcall end optimisation  feature enabled/disabled */

  boolean is_override_e911_add_info;
  /* flag to indicate that, in service request override E911 additional info */

  sys_plmn_mcc_list              mcc_list_info;
  /* Holds the mcc list information extracted from PRL for cdma/hdr */
  

  boolean                        is_1xsib8_scan_allowed;
  /* Indicates if scanning 1x sys based on 1XSIB8 info is allowed */

  uint8                          loop_num_1xsib8_scan;
  /* Indicates the number of times new sequence is scanned */

  boolean                        is_sdprl_failed;
  /* Indicates if sdprl_nam_sel failed */

  boolean                        is_pref_update_called;
  /* Indicates that sdss_pref_update is called for nam_sel */
  sys_call_mode_t                      call_mode;
  /* Indicates call mode, normal or Volte only, from PM */
  boolean                        is_pref_chg_in_ltd_reg;
    /* Flag set if preferences are changed due to call end when UE in 
    ** limited regional service */

  boolean                        is_dds_switchback_from_temp;
   /* Determines whether DDS switch is permanent and was preceded by
    ** limited regional service */

  boolean                                is_emerg_in_roam;
   /* Flag to check if e911 is intiated when in Roam, if so LTE will removed
      for  volte specialized device */

  sys_plmn_list_s_type           more_pref_plmn_list;
  /* contains the more preferred list of PLMNs ( as compared to the camped 3GPP2 system).
     Information is obtained from the PRL and does not account for forbidden PLMNs/ plmn blocking.
     Valid only on MAIN and HYBR1, when UE has service on 1x/HDR or HDR respectively */

  boolean                        is_special_volte_redial;
   /*Flag TRUE to indicate CSFB call to VOLTE redial is ongoing */
   
  boolean                        is_volte_call_on;
    /* flag to check presence of Volte call */
} sdss_s_type;

/* Macro to map a script constract parameter into a system record list in the
** context of a script engine.
*/
#define ENG_LIST( list )        sdss_sr_list_map( eng_ptr->ss_ptr, \
  (sdsr_e_type) list)

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

/* <EJECT> */
/*---------------------------------------------------------------------------
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
-------------------------------- SCHEDULING ---------------------------------
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
---------------------------------------------------------------------------*/

/* Array of reacquisition schedules.
**
** This array is indexed using sdssscr_sched_e_type enum values. The ith
** element in this array represent the time in seconds that corresponds to
** the ith sdssscr_sched_e_type enum value. SCHED_START, SCHED_END and
** SCHED_LOOP are magic values that represents the beginning and end of each
** reacquisition schedules.
*/
#define SCHED_START ((byte) (-1))
#define SCHED_END   ((byte) (-2))
#define SCHED_LOOP  ((byte) (-3))

static const byte   sdss_sched_arr[SDSSSCR_SCHED_MAX] = {

  /* ------------------------------------
  ** Time based schedules (low priority).
  ** ------------------------------------
  */
  SCHED_END,    /* SDSSSCR_SCHED_REACQ_TIME_LOW - for range checking */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Power-up.
  */
  SCHED_START,  /* SDSSSCR_SCHED_REACQ_PWR_UP */
  0,            /* SDSSSCR_SCHED_REACQ_PWR_UP_1 */
  1,            /* SDSSSCR_SCHED_REACQ_PWR_UP_2 */
  SCHED_END,    /* SDSSSCR_SCHED_REACQ_PWR_UP_3 */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ------------------------------------
  ** Time based schedules (high priority).
  ** ------------------------------------
  */
  SCHED_END,    /* SDSSSCR_SCHED_REACQ_TIME_HIGH - for range checking */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Reacquire 1 time.
  */
  SCHED_START,  /* SDSSSCR_SCHED_REACQ_1_TIME */
  0,            /* SDSSSCR_SCHED_REACQ_1_TIME_1 */
  SCHED_END,    /* SDSSSCR_SCHED_REACQ_1_TIME_2 */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Reacquire 2 times.
  */
  SCHED_START,  /* SDSSSCR_SCHED_REACQ_2_TIMES */
  0,            /* SDSSSCR_SCHED_REACQ_2_TIMES_1 */
  0,            /* SDSSSCR_SCHED_REACQ_2_TIMES_2 */
  SCHED_END,    /* SDSSSCR_SCHED_REACQ_2_TIMES_3 */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Reacquire every 1s.
  */
  SCHED_START,  /* SDSSSCR_SCHED_REACQ_EVERY_1S */
  1,            /* SDSSSCR_SCHED_REACQ_EVERY_1S_1 */
  SCHED_LOOP,   /* SDSSSCR_SCHED_REACQ_EVERY_1S_2 */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Reacquire every 2s.
  */
  SCHED_START,  /* SDSSSCR_SCHED_REACQ_EVERY_2S */
  2,            /* SDSSSCR_SCHED_REACQ_EVERY_2S_1 */
  SCHED_LOOP,   /* SDSSSCR_SCHED_REACQ_EVERY_2S_2 */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Reacquire every 4s.
  */
  SCHED_START,  /* SDSSSCR_SCHED_REACQ_EVERY_4S */
  4,            /* SDSSSCR_SCHED_REACQ_EVERY_4S_1 */
  SCHED_LOOP,   /* SDSSSCR_SCHED_REACQ_EVERY_4S_2 */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Reacquire every 2s.
  */
  SCHED_START,  /* SDSSSCR_SCHED_REACQ_EVERY_8S */
  8,            /* SDSSSCR_SCHED_REACQ_EVERY_8S_1 */
  SCHED_LOOP,   /* SDSSSCR_SCHED_REACQ_EVERY_8S_2 */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* System lost during operation.
  */
  SCHED_START,  /* SDSSSCR_SCHED_REACQ_SYS_LOST */
  0,            /* SDSSSCR_SCHED_REACQ_SYS_LOST_1 */
  0,            /* SDSSSCR_SCHED_REACQ_SYS_LOST_2 */
  0,            /* SDSSSCR_SCHED_REACQ_SYS_LOST_3 */
  1,            /* SDSSSCR_SCHED_REACQ_SYS_LOST_4 */
  1,            /* SDSSSCR_SCHED_REACQ_SYS_LOST_5 */
  2,            /* SDSSSCR_SCHED_REACQ_SYS_LOST_6 */
  2,            /* SDSSSCR_SCHED_REACQ_SYS_LOST_7 */
  4,            /* SDSSSCR_SCHED_REACQ_SYS_LOST_8 */
  4,            /* SDSSSCR_SCHED_REACQ_SYS_LOST_9 */
  SCHED_START,  /* SDSSSCR_SCHED_REACQ_SYS_LOST_10 */
  8,            /* SDSSSCR_SCHED_REACQ_SYS_LOST_11 */
  SCHED_LOOP,   /* SDSSSCR_SCHED_REACQ_SYS_LOST_12 */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* System lost during acquisition.
  */
  SCHED_START,  /* SDSSSCR_SCHED_REACQ_ACQ_LOST */
  0,            /* SDSSSCR_SCHED_REACQ_ACQ_LOST_1 */
  0,            /* SDSSSCR_SCHED_REACQ_ACQ_LOST_2 */
  1,            /* SDSSSCR_SCHED_REACQ_ACQ_LOST_3 */
  2,            /* SDSSSCR_SCHED_REACQ_ACQ_LOST_4 */
  2,            /* SDSSSCR_SCHED_REACQ_ACQ_LOST_5 */
  4,            /* SDSSSCR_SCHED_REACQ_ACQ_LOST_6 */
  4,            /* SDSSSCR_SCHED_REACQ_ACQ_LOST_7 */
  8,            /* SDSSSCR_SCHED_REACQ_ACQ_LOST_8 */
  8,            /* SDSSSCR_SCHED_REACQ_ACQ_LOST_9 */
  SCHED_END,    /* SDSSSCR_SCHED_REACQ_ACQ_LOST_10 */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* AMPS system lost during operation.
  */
  SCHED_START,  /* SDSSSCR_SCHED_REACQ_AMPS_SYS_LOST */
  0,            /* SDSSSCR_SCHED_REACQ_AMPS_SYS_LOST_1 */
  1,            /* SDSSSCR_SCHED_REACQ_AMPS_SYS_LOST_2 */
  1,            /* SDSSSCR_SCHED_REACQ_AMPS_SYS_LOST_3 */
  2,            /* SDSSSCR_SCHED_REACQ_AMPS_SYS_LOST_4 */
  2,            /* SDSSSCR_SCHED_REACQ_AMPS_SYS_LOST_5 */
  4,            /* SDSSSCR_SCHED_REACQ_AMPS_SYS_LOST_6 */
  4,            /* SDSSSCR_SCHED_REACQ_AMPS_SYS_LOST_7 */
  SCHED_START,  /* SDSSSCR_SCHED_REACQ_AMPS_SYS_LOST_8 */
  8,            /* SDSSSCR_SCHED_REACQ_AMPS_SYS_LOST_9 */
  SCHED_LOOP,   /* SDSSSCR_SCHED_REACQ_AMPS_SYS_LOST_10 */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* AMPS control channel acquisition failure.
  */
  SCHED_START,  /* SDSSSCR_SCHED_REACQ_AMPS_ACQ_LOST */
  0,            /* SDSSSCR_SCHED_REACQ_AMPS_ACQ_LOST_1 */
  1,            /* SDSSSCR_SCHED_REACQ_AMPS_ACQ_LOST_2 */
  1,            /* SDSSSCR_SCHED_REACQ_AMPS_ACQ_LOST_3 */
  2,            /* SDSSSCR_SCHED_REACQ_AMPS_ACQ_LOST_4 */
  2,            /* SDSSSCR_SCHED_REACQ_AMPS_ACQ_LOST_5 */
  4,            /* SDSSSCR_SCHED_REACQ_AMPS_ACQ_LOST_6 */
  4,            /* SDSSSCR_SCHED_REACQ_AMPS_ACQ_LOST_7 */
  SCHED_END,    /* SDSSSCR_SCHED_REACQ_AMPS_ACQ_LOST_8 */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -------------------------------------
  ** Count based schedules (low priority).
  ** -------------------------------------
  */
  SCHED_END,    /* SDSSSCR_SCHED_REACQ_CNT_LOW - for range checking */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -------------------------------------
  ** Count based schedules (high priority).
  ** -------------------------------------
  */
  SCHED_END,    /* SDSSSCR_SCHED_REACQ_CNT_HIGH - for range checking */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Reacquire immidiately and alternate with 1 system there after.
  */
  SCHED_START,  /* SDSSSCR_SCHED_REACQ_EVERY_1 */
  0,            /* SDSSSCR_SCHED_REACQ_EVERY_1_1 */
  SCHED_START,  /* SDSSSCR_SCHED_REACQ_EVERY_1_2 */
  1,            /* SDSSSCR_SCHED_REACQ_EVERY_1_3 */
  SCHED_LOOP,   /* SDSSSCR_SCHED_REACQ_EVERY_1_4 */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Reacquire immidiately and alternate with 2 systems there after.
  */
  SCHED_START,  /* SDSSSCR_SCHED_REACQ_EVERY_2 */
  0,            /* SDSSSCR_SCHED_REACQ_EVERY_2_1 */
  SCHED_START,  /* SDSSSCR_SCHED_REACQ_EVERY_2_2 */
  2,            /* SDSSSCR_SCHED_REACQ_EVERY_2_3 */
  SCHED_LOOP,   /* SDSSSCR_SCHED_REACQ_EVERY_2_4 */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Reacquire immidiately and alternate with 3 systems there after.
  */
  SCHED_START,  /* SDSSSCR_SCHED_REACQ_EVERY_3 */
  0,            /* SDSSSCR_SCHED_REACQ_EVERY_3_1 */
  SCHED_START,  /* SDSSSCR_SCHED_REACQ_EVERY_3_2 */
  3,            /* SDSSSCR_SCHED_REACQ_EVERY_3_3 */
  SCHED_LOOP,   /* SDSSSCR_SCHED_REACQ_EVERY_3_4 */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Reacquire immidiately and alternate with 4 systems there after.
  */
  SCHED_START,  /* SDSSSCR_SCHED_REACQ_EVERY_4 */
  0,            /* SDSSSCR_SCHED_REACQ_EVERY_4_1 */
  SCHED_START,  /* SDSSSCR_SCHED_REACQ_EVERY_4_2 */
  4,            /* SDSSSCR_SCHED_REACQ_EVERY_4_3 */
  SCHED_LOOP,   /* SDSSSCR_SCHED_REACQ_EVERY_4_4 */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Reacquire immidiately and alternate with 8 systems there after.
  */
  SCHED_START,  /* SDSSSCR_SCHED_REACQ_EVERY_8 */
  0,            /* SDSSSCR_SCHED_REACQ_EVERY_8_1 */
  SCHED_START,  /* SDSSSCR_SCHED_REACQ_EVERY_8_2 */
  8,            /* SDSSSCR_SCHED_REACQ_EVERY_8_3 */
  SCHED_LOOP,   /* SDSSSCR_SCHED_REACQ_EVERY_8_4 */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Emergency system lost/access failure.
  */
  SCHED_START,  /* SDSSSCR_SCHED_REACQ_EMERG_LOST */
  0,            /* SDSSSCR_SCHED_REACQ_EMERG_LOST_1 */
  3,            /* SDSSSCR_SCHED_REACQ_EMERG_LOST_2 */
  3,            /* SDSSSCR_SCHED_REACQ_EMERG_LOST_3 */
  3,            /* SDSSSCR_SCHED_REACQ_EMERG_LOST_4 */
  6,            /* SDSSSCR_SCHED_REACQ_EMERG_LOST_5 */
  6,            /* SDSSSCR_SCHED_REACQ_EMERG_LOST_6 */
  6,            /* SDSSSCR_SCHED_REACQ_EMERG_LOST_7 */
  SCHED_END,    /* SDSSSCR_SCHED_REACQ_EMERG_LOST_8 */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* GW full system acquisition failure.
  */
  SCHED_START,  /* SDSSSCR_SCHED_REACQ_GW_FULL_ACQ_LOST */
  0,            /* SDSSSCR_SCHED_REACQ_GW_FULL_ACQ_LOST_1 */
  SCHED_START,  /* SDSSSCR_SCHED_REACQ_GW_FULL_ACQ_LOST_2 */
  1,            /* SDSSSCR_SCHED_REACQ_GW_FULL_ACQ_LOST_3 */
  1,            /* SDSSSCR_SCHED_REACQ_GW_FULL_ACQ_LOST_4 */
  1,            /* SDSSSCR_SCHED_REACQ_GW_FULL_ACQ_LOST_5 */
  3,            /* SDSSSCR_SCHED_REACQ_GW_FULL_ACQ_LOST_6 */
  SCHED_LOOP,   /* SDSSSCR_SCHED_REACQ_GW_FULL_ACQ_LOST_7 */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* GW ltd system acquisition failure.
  */
  SCHED_START,  /* SDSSSCR_SCHED_REACQ_GW_LTD_ACQ_LOST */
  1,            /* SDSSSCR_SCHED_REACQ_GW_LTD_ACQ_LOST_1 */
  SCHED_START,  /* SDSSSCR_SCHED_REACQ_GW_LTD_ACQ_LOST_2 */
  1,            /* SDSSSCR_SCHED_REACQ_GW_LTD_ACQ_LOST_3 */
  1,            /* SDSSSCR_SCHED_REACQ_GW_LTD_ACQ_LOST_4 */
  1,            /* SDSSSCR_SCHED_REACQ_GW_LTD_ACQ_LOST_5 */
  3,            /* SDSSSCR_SCHED_REACQ_GW_LTD_ACQ_LOST_6 */
  SCHED_LOOP,   /* SDSSSCR_SCHED_REACQ_GW_LTD_ACQ_LOST_7 */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* GW full system acquisition failure when orig is not manual or none.
  */
  SCHED_START,  /* SDSSSCR_SCHED_REACQ_GW_FULL_ORIG */
  0,            /* SDSSSCR_SCHED_REACQ_GW_FULL_ORIG_1 */
  SCHED_START,  /* SDSSSCR_SCHED_REACQ_GW_FULL_ORIG_2 */
  0,            /* SDSSSCR_SCHED_REACQ_GW_FULL_ORIG_3 */
  0,            /* SDSSSCR_SCHED_REACQ_GW_FULL_ORIG_4 */
  0,            /* SDSSSCR_SCHED_REACQ_GW_FULL_ORIG_5 */
  1,            /* SDSSSCR_SCHED_REACQ_GW_FULL_ORIG_6 */
  SCHED_LOOP,   /* SDSSSCR_SCHED_REACQ_GW_FULL_ORIG_7 */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SCHED_END,    /* SDSSSCR_SCHED_REACQ_LAST */

  SCHED_END,    /* SDSSSCR_SCHED_AVOID */

  SCHED_END,    /* SDSSSCR_SCHED_AVOID_UNTIL_ACQ_FAIL */

  SCHED_END,    /* SDSSSCR_SCHED_AVOID_UNTIL_ACQ_FAIL_DUR_CALL_ORIG */

  SCHED_END,    /* SDSSSCR_SCHED_AVOID_UNTIL_ACQ_FAIL_DUR_OPTI_REDIAL */

  SCHED_END,    /* SDSSSCR_SCHED_AVOID_MAP_UNTIL_ACC_SUCCESS */

  SCHED_END,    /* SDSSSCR_SCHED_AVOID_CANCEL_ALL */

  SCHED_END,    /* SDSSSCR_SCHED_AVOID_LAST */
};

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

/* Enumeration of schedule actions.
*/
typedef enum {

  SDSS_SCHED_ACT_ACQ,   /* Schedule is calling for acquisition attempt */
  SDSS_SCHED_ACT_WAIT,  /* Schedule is not calling for acquisition attempt */
  SDSS_SCHED_ACT_END,   /* Schedule is exhausted */

  SDSS_SCHED_ACT_MAX
} sdss_sched_act_e_type;
/*lint -esym(749, SDSS_SCHED_ACT_MAX) */ /* Sym not defined */



/* <EJECT> */
/*---------------------------------------------------------------------------
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
------------------------- ACQUISITION STATE MACHINE -------------------------
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
---------------------------------------------------------------------------*/


/* Type for holding all the information that is associated with a acquisition
** state machine. The acquisition state machine carries the acquisition
** process on behalf of the ACQ script construct.
*/
typedef struct {

  /* System selection enum type.
  */
  sd_ss_e_type             ss;

  /* Pointer to associated System Selection information structure.
  */
  sdss_s_type             *ss_ptr;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* The state of the acquisition state machine.
  */
  sdss_acq_stt_e_type     state;

  /* The previous state of the acquisition state machine.
  */
  sdss_acq_stt_e_type     prev_state;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Acquisition list (i.e.m system record list over which acquisition is
  ** attempted).
  */
  sdsr_e_type             acq_lst;

  /* Acquisition list starting position.
  */
  int                     acq_start_pos;

  /* Number of acquisitions left.
  */
  int                     acq_left;

  /* Max uptime for the acquisition attempts.
  */
  dword                   acq_max_uptime;

  /* Acquisition list traversal position.
  */
  int                     acq_pos;

  /* List end reached indicator.
  */
  boolean                 is_acq_lst_end_reached;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Acquisition script construct that is calling for the acquisition
  ** attempt.
  */
  sdssscr_con_e_type      acq_con;

  /* The acquisition type that is being attempted.
  */
  sdssscr_acq_e_type      acq_type;

  /* The acquisition mode that is being attempted.
  */
  sdss_acq_mode_e_type    acq_mode;

  /* Used to maintain acq_mode across scripts, for some GW scan, we need to
  ** use the same acq_mode for continuing the scan
  */
  sdss_acq_mode_e_type    prev_acq_mode;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* The current value of the new-acquisition counter. Only system with
  ** different new-acquisition count are being attempted acquisition.
  **
  ** The new-acquisition counter serves as a mechanism for avoiding
  ** acquisition attempts over systems that were already attempted
  ** acquisition since the last time the NEW_ACQ script constructs was
  ** encountered.
  **
  ** The new-acquisition counter shall be ignored when it is set to 0.
  */
  byte                    new_acq_cnt;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* The measurement value with which systems have to comply in order to be
  ** attempted acquisition. That is, only systems with measurement value >=
  ** than this value are being attempted acquisition.
  */
  int2                    meas_val;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* The measurement category with which systems have to comply in order to be
  ** attempted acquisition above meas_val threshold otherwise threshold will be ignored
  ** for them. That is, meas_cat systems with measurement value >= than meas
  ** value and all others are being attempted acquisition.
  */
  sdsr_cat_e_type         meas_cat;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Indicate whether MS tries to acquire the 2nd strongest AMPS control
  ** channel.
  */
  boolean                 is_amps_2nd_cch;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* The system acquired most recently in the SDSS_ACQ_STT_START state.
  */
  sdsr_e_type             start_sys;

  /* The list that contains all the systems that are more preferred than
  ** start_sys, along with traversal position.
  **
  ** This list is being traversed during the SDSS_ACQ_STT_MORE_PREF state.
  */
  sdsr_e_type             pref_lst;
  int                     pref_pos;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* The system record list that keeps track of all the systems that are on a
  ** reacquisition schedule, as well as, traversal position.
  **
  ** Scheduled reacquisition attempts are given priority over the list that
  ** is being attempted acquisition. Each time before attempting to acquire a
  ** new system out of the acquisition list, this list is being consulted as
  ** to whether the reacquisition schedule of a particular system record is
  ** calling for a reacquisition attempt at the current time, at which case
  ** such a system is being attempted acquisition first.
  */
  sdsr_e_type             sched_lst;
  int                     sched_pos;

  /* Last rtrn action from the ACQ construct.
  */
  sdss_iact_s_type        rtrn_iact;

} sdss_acq_s_type;




/* <EJECT> */
/*---------------------------------------------------------------------------
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
----------------------------- SS-SCRIPT-ENGINE ------------------------------
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------
                         Script Execution Control
---------------------------------------------------------------------------*/

/* Enumeration of SS-Script execution controls.
*/
typedef enum {

  SDSS_SCR_CTRL_RTRN_ACT,   /* Return SS-Action to SS-Client */

  SDSS_SCR_CTRL_NEXT_CONS,  /* Parse the next SS-Script construct */

  SDSS_SCR_CTRL_PREV_SCR,   /* Return to previously active SS-Script and
                            ** continue with that script execution */

  SDSS_SCR_CTRL_ACT_SCR,    /* Activate a new SS-Script (as specified by the
                            ** ACT_SCR's parameters) and continue with that
                            ** script execution */

  SDSS_SCR_CTRL_PROC_EVT,   /* Process an SS-Event (as specified by the
                            ** PROC_EVT's parameters */

  SDSS_SCR_CTRL_MAX
} sdss_scr_ctrl_e_type;


/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


/* Type for parameters that are associated with the SDSS_SCR_CTRL_ACT_SCR
** script execution control.
*/
typedef struct {

  sdssscr_e_type            script;  /* SS-Script which to activate */

} sdss_scr_ctrl_act_scr_s_type;


/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


/* Type for parameters that are associated with the SDSS_SCR_CTRL_PROC_EVT
** script execution control.
*/
typedef struct {

  sdss_evt_e_type           event;   /* SS-Event to process */

} sdss_scr_ctrl_proc_evt_s_type;


/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


/* Types for holding an SS-Script-engine execution control information.
*/
typedef struct {

  /* Execution control.
  */
  sdss_scr_ctrl_e_type                        ctrl;

  /* Execution control associated parameters.
  */
  union {
    sdss_scr_ctrl_act_scr_s_type    act;
    sdss_scr_ctrl_proc_evt_s_type   proc;
  }                                           prm;

} sdss_scr_ctrl_s_type;


/*---------------------------------------------------------------------------
                         Script Engine Information
---------------------------------------------------------------------------*/

/* Type for holding the information that is associated with a single instance
** of a script engine.
*/
typedef struct {

  /* System selection enum type.
  */
  sd_ss_e_type             ss;

  /* Pointer to associated System Selection information structure.
  */
  sdss_s_type             *ss_ptr;

  /* Parser for keeping track of the SS-Scripts that is being parsed.
  */
  sdssscr_parser_s_type   parser;

  /* Keep track of script's event group and table index (for debugging).
  */
  sdss_evt_grp_e_type     scr_evt_grp;
  int                     scr_tbl_idx;

  /* Buffers to hold the SS-Script Construct that is being executed, as well
  ** as, the construct's parameters.
  */
  sdssscr_con_e_type      scr_con;
  sdssscr_prm_type        con_prm1;
  sdssscr_prm_type        con_prm2;
  sdssscr_prm_type        con_prm3;
  sdssscr_prm_type        con_prm4;
  sdssscr_prm_type        con_prm5;
  sdssscr_prm_type        con_prm6;
  sdssscr_prm_type        con_prm7;
  sdssscr_prm_type        con_prm8;


  /* Script control element to control the execution of the SS-Script.
  */
  sdss_scr_ctrl_s_type    scr_ctrl;


  /* Acquisition state machine to handle the acquisition processing.
  */
  sdss_acq_s_type         acq;


  /* The mode of the acquisition being attempted.
  */
  sdss_acq_mode_e_type    acq_mode;


  /* Script timer. This timer is set to the uptime when the script timer
  ** should expire if the timer is currently active. It is set to 0 when the
  ** script timer is disabled.
  */
  dword                   scr_timer;

  /* Event associated with the script
  */
  sdss_evt_e_type         event;

} sdss_eng_s_type;


/*---------------------------------------------------------------------------
                          Script Engine Stack
---------------------------------------------------------------------------*/


/* Type for a stack of script engines.
*/
typedef struct {

  /* Pointer to array of script engines.
  */
  sdss_eng_s_type   **arr_ptr;

  /* Size of the engines array (in elements).
  */
  unsigned int      size;

  /* Number of engines that are pushed on the stack.
  */
  unsigned int      cnt;

} sdss_eng_stack_s_type;


/* SS-Script-engine stack to process SS-Events. The stack has a depth of 12
** to support 12 levels of script nesting.
*/
static sdss_eng_s_type*  sdss_eng_arr[12];
static sdss_eng_stack_s_type  sdss_eng_stack;

#if (defined (FEATURE_HDR_HYBRID) )
static sdss_eng_s_type*  sdss_hybr_1_eng_arr[12];
static sdss_eng_stack_s_type  sdss_hybr_1_eng_stack;
#endif

#if defined FEATURE_MMODE_DUAL_SIM || defined FEATURE_MMODE_SC_SVLTE || defined FEATURE_MMODE_SC_SGLTE
static sdss_eng_s_type* sdss_hybr_2_eng_arr[12];
static sdss_eng_stack_s_type sdss_hybr_2_eng_stack;
#endif

#if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
static sdss_eng_s_type* sdss_hybr_3_eng_arr[12];
static sdss_eng_stack_s_type sdss_hybr_3_eng_stack;
#endif

static sdss_common_s_type sdss_common;

sdss_lbsr_mcc_list_s_type sdss_lbsr_mcc_list;

extern boolean sdmmss_decode_3gpp_bst_tbl(
  byte                  *buf_ptr,
  /* Data to be decoded
  */
  sdmmss_bst_tbl_s_type* bst_ptr 
);

boolean sdss_is_china_emerg_scan_allowed(sd_ss_e_type ss);


/* <EJECT> */
/*===========================================================================
=============================================================================
=============================================================================
================================ GENERAL ====================================
=============================================================================
=============================================================================
===========================================================================*/


/*===========================================================================

FUNCTION sdss_is_featuremode

DESCRIPTION
  Checks if current feature to be enabled is same as one being passed to this
  function. The value of feature-mode is read at powrup from PM.
===========================================================================*/
boolean sdss_is_featuremode( sys_overall_feature_t fmode )
{
  return sdss_common.onebuild_feature == fmode;
}

/*===========================================================================

FUNCTION sdss_is_ofmode_1x_sxlte

DESCRIPTION
  Checks if overall feature mode is srlte/svlte.
===========================================================================*/
boolean sdss_is_ofmode_1x_sxlte(void)
{
  return (sdss_common.onebuild_feature == SYS_OVERALL_FEATURE_MODE_SVLTE ||
         sdss_common.subs_feature[0] == SYS_SUBS_FEATURE_MODE_SVLTE);
}

/*===========================================================================
FUNCTION sdss_is_sfmode_1x_srlte

DESCRIPTION
  Checks if sub feature mode is srlte.
  Note: sub_idx != ss.  
  ie. for srlte/svlte+g, main, hybr hdr and hybr2 map to sub_idx 0.  hybr2 maps to sud_idx 1.
===========================================================================*/
boolean sdss_is_sfmode_1x_srlte(uint8 sub_idx)
{
  if (sub_idx <ARR_SIZE(sdss_common.subs_feature))
  {
    return (sdss_common.subs_feature[sub_idx] == SYS_SUBS_FEATURE_MODE_SRLTE);
  }
  else
  {
    SD_ERR_1("Invalid sub_idx %d - default to 0", sub_idx);
    return (sdss_common.subs_feature[0] == SYS_SUBS_FEATURE_MODE_SRLTE);
  }
}
/*===========================================================================

FUNCTION sdss_is_sfmode_svlte

DESCRIPTION
  Checks if sub feature mode is svlte.
  Note: sub_idx != ss.  
  ie. for svlte+g, main, hybr hdr and hybr2 map to sub_idx 0.  hybr2 maps to sud_idx 1.
===========================================================================*/
boolean sdss_is_sfmode_svlte(uint8 sub_idx)
{
  if (sub_idx < ARR_SIZE(sdss_common.subs_feature))
  {
    return (sdss_common.subs_feature[sub_idx] == SYS_SUBS_FEATURE_MODE_SVLTE);
  }
  else
  {
    SD_ERR_1("Invalid sub_idx %d - default to 0", sub_idx);
    return (sdss_common.subs_feature[0] == SYS_SUBS_FEATURE_MODE_SVLTE);
  }
}

/*===========================================================================

FUNCTION sdss_is_sfmode_1x_sxlte

DESCRIPTION
  Checks if sub feature mode is srlte/svlte.
  Note: sub_idx != ss.  
  ie. for srlte/svlte+g, main, hybr hdr and hybr2 map to sub_idx 0.  hybr2 maps to sud_idx 1.
===========================================================================*/
boolean sdss_is_sfmode_1x_sxlte(uint8 sub_idx)
{
  if (sub_idx < ARR_SIZE(sdss_common.subs_feature))
  {
    return (sdss_common.subs_feature[sub_idx] == SYS_SUBS_FEATURE_MODE_SVLTE ||
           sdss_common.subs_feature[sub_idx] == SYS_SUBS_FEATURE_MODE_SRLTE);
  }
  else
  {
    SD_ERR_1("Invalid sub_idx %d - default to 0", sub_idx);
    return (sdss_common.subs_feature[0] == SYS_SUBS_FEATURE_MODE_SVLTE ||
           sdss_common.subs_feature[0] == SYS_SUBS_FEATURE_MODE_SRLTE);
  }
}

/*===========================================================================

FUNCTION sdss_is_sfmode_sglte

DESCRIPTION
  Checks if sub feature mode is sglte.
===========================================================================*/
boolean sdss_is_sfmode_sglte(uint8 sub_idx)
{
  if (sub_idx <ARR_SIZE(sdss_common.subs_feature))
  {
    return (sdss_common.subs_feature[sub_idx] == SYS_SUBS_FEATURE_MODE_SGLTE);
  }
  else
  {
    SD_ERR_1("Invalid sub_idx %d - default to 0", sub_idx);
    return (sdss_common.subs_feature[sub_idx] == SYS_SUBS_FEATURE_MODE_SGLTE);
  }
}

/*===========================================================================

FUNCTION sdss_is_sglte

DESCRIPTION
  Checks featureMode.
===========================================================================*/
boolean sdss_is_sglte(void)
{
  return (sdss_common.onebuild_feature == SYS_OVERALL_FEATURE_MODE_SGLTE ||
          sdss_common.subs_feature[0] == SYS_SUBS_FEATURE_MODE_SGLTE);
}

/*===========================================================================

FUNCTION sdss_is_1x_sxlte

DESCRIPTION
  Checks overall or sub featureMode is svlte/srlte.
===========================================================================*/
boolean sdss_is_1x_sxlte(void)
{
  return (sdss_common.onebuild_feature == SYS_OVERALL_FEATURE_MODE_SVLTE ||
         sdss_common.subs_feature[0] == SYS_SUBS_FEATURE_MODE_SVLTE ||
         sdss_common.onebuild_feature == SYS_OVERALL_FEATURE_MODE_SRLTE ||
         sdss_common.subs_feature[0] == SYS_SUBS_FEATURE_MODE_SRLTE);
}

/*===========================================================================

FUNCTION mmoc_is_sxlte

DESCRIPTION
  Checks featureMode.
===========================================================================*/
boolean sdss_is_sxlte(void)
{
  return (sdss_common.onebuild_feature == SYS_OVERALL_FEATURE_MODE_MULTISIM &&
          (sdss_common.subs_feature[0] == SYS_SUBS_FEATURE_MODE_SGLTE ||
           sdss_common.subs_feature[0] == SYS_SUBS_FEATURE_MODE_SVLTE ||
           sdss_common.subs_feature[0] == SYS_SUBS_FEATURE_MODE_SRLTE ||
           sdss_is_sub2_map_to_hybr3(SD_SS_MAIN)));
}

/*===========================================================================

FUNCTION sdss_read_policyman_config_per_sub

DESCRIPTION
  Reads policy manager config. This function is blocked until Policy Manager
  is able to return system configuration. While this operation blocks SD task
  its assumed that PM shall return within dog-timeout time for SD task.
===========================================================================*/
void sdss_read_policyman_config_per_sub( 
  sys_modem_as_id_e_type  mcfg_refresh_sub,
    /* MCFG refresh sub
     */
  
   boolean                  is_power_on
    /* Is it power on
    */
  
)
{


  const policyman_item_t *pItem = NULL;
  const policyman_item_id_t id = POLICYMAN_ITEM_DEVICE_CONFIGURATION;
  policyman_item_collection_t const *pCollection;

  if(POLICYMAN_SUCCEEDED(policyman_get_items_block_msim((policyman_item_id_t const *)&id,
                                                     1, &pCollection)))
  {
    pItem = pCollection->pItems[0];
    policyman_device_config_overall_feature( pItem,
                                             &sdss_common.onebuild_feature);
    SD_MSG_HIGH_1("policyman fmode %d", sdss_common.onebuild_feature);
  }


  if ( sdss_common.onebuild_feature == SYS_OVERALL_FEATURE_MODE_MULTISIM )
  {
    uint32 i;
    sys_subs_feature_t pm_sfmode;
    
    for (i=0;i<2;i++) /* Read subs feature mode for two SIM */
    {
      if(POLICYMAN_SUCCEEDED(policyman_device_config_get_subs_feature(pItem,0,i,&pm_sfmode)))
    {
        /* During MCFG refresh update only the sub which got refresh indication
             */
        if (!is_power_on && i != mcfg_refresh_sub)
        {
          SD_MSG_HIGH_2("MCFG refresh on sub %d skip updating feature mode for sub %d", mcfg_refresh_sub, i);
          continue;
        }
        sdss_common.pm_subs_feature[i] = pm_sfmode;
    #ifndef FEATURE_MMODE_SXLTE_G
        SD_MSG_HIGH_2("fmode: changing subs_feature_mode to NORMAL for asubs_id %d, pm %d", i, pm_sfmode);
    sdss_common.subs_feature[i] = SYS_SUBS_FEATURE_MODE_NORMAL;
        #else
        if (pm_sfmode == SYS_SUBS_FEATURE_MODE_DUAL_MULTIMODE)
        {
          if (i == (uint32)SYS_MODEM_AS_ID_1)
            sdss_common.subs_feature[i] = SYS_SUBS_FEATURE_MODE_SRLTE;
          else
            sdss_common.subs_feature[i] = SYS_SUBS_FEATURE_MODE_NORMAL;
        }
        else
        {
          sdss_common.subs_feature[i] = pm_sfmode;
        }      
    #endif
      }
      else
      { 
        sdss_common.subs_feature[i] = SYS_SUBS_FEATURE_MODE_NORMAL;
      }
    }

    if(sdss_common.subs_feature[1] != SYS_SUBS_FEATURE_MODE_NORMAL)
    {
    sdss_common.subs_feature[0] = sdss_common.subs_feature[1];
    sdss_common.subs_feature[1] = SYS_SUBS_FEATURE_MODE_NORMAL;
    }
  }
  else if(sdss_common.onebuild_feature == SYS_OVERALL_FEATURE_MODE_SVLTE)
  {
    sdss_common.subs_feature[0] = SYS_SUBS_FEATURE_MODE_SVLTE;
  }
  else if(sdss_common.onebuild_feature == SYS_OVERALL_FEATURE_MODE_SRLTE)
  {
    sdss_common.subs_feature[0] = SYS_SUBS_FEATURE_MODE_SRLTE;
  }
  else if(sdss_common.onebuild_feature == SYS_OVERALL_FEATURE_MODE_SGLTE)
  {
    sdss_common.subs_feature[0] = SYS_SUBS_FEATURE_MODE_SGLTE;
  }

  policyman_item_collection_release(pCollection);

}

/*===========================================================================

FUNCTION sdss_read_policyman_config

DESCRIPTION
  Reads policy manager config. This function will be called during when sd task is started
===========================================================================*/
void sdss_read_policyman_config( void )
{
  sdss_read_policyman_config_per_sub(SYS_MODEM_AS_ID_MAX, TRUE);
}

/*===========================================================================

FUNCTION sd_misc_sglte_move_to_unrestricted

DESCRIPTION
  Flag to keep track of whether UE transitions from CAMP_ONLY to unrestricted
  mode of operation.

DEPENDENCIES
  none

RETURN VALUE
  Returns the is_ue_unrestrict value

SIDE EFFECTS
  None

===========================================================================*/
boolean *sdss_misc_sglte_move_to_unrestricted()
{
  static boolean is_ue_unrestrict = FALSE;
  return &is_ue_unrestrict;
}

/*===========================================================================

FUNCTION sdss_ptr

DESCRIPTION
  Return the pointer to SS component.


DEPENDENCIES
  None

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
#ifdef FEATURE_NON_DEMAND_PAGED_FUNCTION
#error code not present
#endif
static  sdss_s_type*             sdss_ptr(

        sd_ss_e_type              ss
            /* System selection stack.
            */

)
{

  /* System Selection.
  */
  static sdss_s_type    sdss;

  #if ( defined(FEATURE_HDR_HYBRID))
  static sdss_s_type    sdss_hybr_1;
  #endif

  #if defined FEATURE_MMODE_DUAL_SIM || defined FEATURE_MMODE_SC_SVLTE || defined FEATURE_MMODE_SC_SGLTE
  static sdss_s_type    sdss_main2;
  #endif

  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  static sdss_s_type    sdss_main3;
  #endif

  static sdss_s_type*  sdss_arr[SD_SS_MAX] =
  {
    &sdss,

    #if ( defined(FEATURE_HDR_HYBRID))
    &sdss_hybr_1,
    #else
    &sdss,
    #endif

    #if (defined (FEATURE_MMODE_DUAL_SIM) || defined (FEATURE_MMODE_SC_SVLTE) || defined (FEATURE_MMODE_SC_SGLTE))
    &sdss_main2,
    #else
    &sdss,
    #endif

    #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
    &sdss_main3
    #else
    &sdss
    #endif

  };

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if(ss >= SD_SS_MAX)
  {
    sys_err_fatal_invalid_value_exception((int)ss);
  }

  return sdss_arr[ss];

} /* sdss_ptr() */
#ifdef FEATURE_NON_DEMAND_PAGED_FUNCTION
#error code not present
#endif


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_sr_list_map

DESCRIPTION
  Map list to the appropriate list according to the input system selection
  information structur.

DEPENDENCIES
  None.

RETURN VALUE
  Mapped system record list.

SIDE EFFECTS
  None.

===========================================================================*/
static  sdsr_e_type             sdss_sr_list_map(

        const sdss_s_type       *ss_ptr,
          /* Pointer to system selection information structure.
          */

        sdsr_e_type             list
            /* List for which to check the mode designation.
            */
)
{
  SD_ASSERT( ss_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( list, SDSR_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* For MAIN system selection, there is no need to map list.
  */
  if( ss_ptr == sdss_ptr(SD_SS_MAIN) )
  {
    return list;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  if ( ss_ptr == sdss_ptr(SD_SS_HYBR_2))
  {
    switch( list )
    {
      case SDSR_AVAIL_LST:          return SDSR_HYBR_1_AVAIL_LST;
      case SDSR_ACQ_GEO_LST:        return SDSR_HYBR_1_ACQ_GEO_LST;
      case SDSR_IDL_GEO_LST:        return SDSR_HYBR_1_IDL_GEO_LST;
      case SDSR_SRV_GEO_LST:        return SDSR_HYBR_1_SRV_GEO_LST;
      case SDSR_ACQ_PREF_LST:       return SDSR_HYBR_1_ACQ_PREF_LST;
      case SDSR_IDL_PREF_LST:       return SDSR_HYBR_1_IDL_PREF_LST;
      case SDSR_SRV_PREF_LST:       return SDSR_HYBR_1_SRV_PREF_LST;
      case SDSR_START_PREF_LST:     return SDSR_HYBR_1_START_PREF_LST;
      case SDSR_REDIR_LST:          return SDSR_HYBR_1_REDIR_LST;
      case SDSR_SRCH_LST:           return SDSR_HYBR_1_SRCH_LST;
      case SDSR_SCHED_LST:          return SDSR_HYBR_1_SCHED_LST;
      case SDSR_MEAS_LST:           return SDSR_HYBR_1_MEAS_LST;

      case SDSR_PWR_SAVE_LST:       return SDSR_HYBR_1_PWR_SAVE_LST;
      case SDSR_BACKUP_LST:         return SDSR_HYBR_1_BACKUP_LST;
      case SDSR_ACQ_CHAN_LST:       return SDSR_HYBR_1_ACQ_CHAN_LST;
      case SDSR_OH_CHAN_LST:        return SDSR_HYBR_1_OH_CHAN_LST;
      case SDSR_TEMP_LST:           return SDSR_HYBR_1_TEMP_LST;
      case SDSR_TEMP2_LST:          return SDSR_HYBR_1_TEMP2_LST;

      case SDSR_ACQ_SYS:            return SDSR_HYBR_1_ACQ_SYS;
      case SDSR_ACQ_FULL_SYS:       return SDSR_HYBR_1_ACQ_FULL_SYS;
      case SDSR_ACQ_MINI_SYS:       return SDSR_HYBR_1_ACQ_MINI_SYS;
      case SDSR_ACQ_MICRO_SYS:      return SDSR_HYBR_1_ACQ_MICRO_SYS;
      case SDSR_ACQ_FULL2_SYS:      return SDSR_HYBR_1_ACQ_FULL2_SYS;
      case SDSR_ACQ_MINI2_SYS:      return SDSR_HYBR_1_ACQ_MINI2_SYS;
      case SDSR_ACQ_MICRO2_SYS:     return SDSR_HYBR_1_ACQ_MICRO2_SYS;
      case SDSR_ACQ_DEEP_SYS:       return SDSR_HYBR_1_ACQ_DEEP_SYS;
      case SDSR_ACQ_DEEP2_SYS:      return SDSR_HYBR_1_ACQ_DEEP2_SYS;
      case SDSR_ACQ_SHALLOW_SYS:    return SDSR_HYBR_1_ACQ_SHALLOW_SYS;
      case SDSR_ACQ_SHALLOW2_SYS:   return SDSR_HYBR_1_ACQ_SHALLOW2_SYS;
      case SDSR_START_SYS:          return SDSR_HYBR_1_START_SYS;
      case SDSR_IDL_SYS:            return SDSR_HYBR_1_IDL_SYS;
      case SDSR_SRV_SYS:            return SDSR_HYBR_1_SRV_SYS;
      case SDSR_SI_SYS:             return SDSR_HYBR_1_SI_SYS;
      case SDSR_REDIR_SYS:          return SDSR_HYBR_1_REDIR_SYS;
      case SDSR_CAND_SYS:           return SDSR_HYBR_1_CAND_SYS;
      case SDSR_TEMP_SYS:           return SDSR_HYBR_1_TEMP_SYS;
      case SDSR_CAND_IDL_SYS:       return SDSR_HYBR_1_CAND_IDL_SYS;
      case SDSR_GWL_LAST_FULL_SYS:  return SDSR_HYBR_1_GW_LAST_FULL_SYS;
      case SDSR_GWL_LAST_USER_SYS:  return SDSR_HYBR_1_GW_LAST_USER_SYS;
      case SDSR_GWL_LAST_LTD_SYS:   return SDSR_HYBR_1_GW_LAST_LTD_SYS;
      case SDSR_EMERG_SYS:          return SDSR_HYBR_1_EMERG_SYS;
      case SDSR_MANUAL_LST:         return SDSR_HYBR_1_MANUAL_LST;
      case SDSR_MRU_LST:            return SDSR_HYBR_1_MRU_LST;
      case SDSR_EMERG_LST:          return SDSR_HYBR_1_EMERG_LST;
      case SDSR_REDIAL_LST:         return SDSR_HYBR_1_REDIAL_LST;
      case SDSR_GWL_LTD_LST:
        if(sdss_is_1x_sxlte()) { break; }
        return SDSR_HYBR_1_GW_LTD_LST;
      case SDSR_PRL_LST:
        if(sdss_is_1x_sxlte()) { break; }
        return SDSR_HYBR_1_GW_LST;
      case SDSR_GWL_LST:
        if(sdss_is_1x_sxlte()) { break; }
        return SDSR_HYBR_1_GW_LST;
      case SDSR_ACQED_LST:
        if(sdss_is_1x_sxlte()) { break; }
        return SDSR_HYBR_1_ACQED_LST;

      default:
        break;

    } /* switch */
  }

  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  if ( ss_ptr == sdss_ptr(SD_SS_HYBR_3))
  {
    switch( list )
    {
      case SDSR_AVAIL_LST:          return SDSR_HYBR_3_AVAIL_LST;
      case SDSR_ACQ_GEO_LST:        return SDSR_HYBR_3_ACQ_GEO_LST;
      case SDSR_IDL_GEO_LST:        return SDSR_HYBR_3_IDL_GEO_LST;
      case SDSR_SRV_GEO_LST:        return SDSR_HYBR_3_SRV_GEO_LST;
      case SDSR_ACQ_PREF_LST:       return SDSR_HYBR_3_ACQ_PREF_LST;
      case SDSR_IDL_PREF_LST:       return SDSR_HYBR_3_IDL_PREF_LST;
      case SDSR_SRV_PREF_LST:       return SDSR_HYBR_3_SRV_PREF_LST;
      case SDSR_START_PREF_LST:     return SDSR_HYBR_3_START_PREF_LST;
      case SDSR_REDIR_LST:          return SDSR_HYBR_3_REDIR_LST;
      case SDSR_SRCH_LST:           return SDSR_HYBR_3_SRCH_LST;
      case SDSR_SCHED_LST:          return SDSR_HYBR_3_SCHED_LST;
      case SDSR_MEAS_LST:           return SDSR_HYBR_3_MEAS_LST;

      case SDSR_PWR_SAVE_LST:       return SDSR_HYBR_3_PWR_SAVE_LST;
      case SDSR_BACKUP_LST:         return SDSR_HYBR_3_BACKUP_LST;
      case SDSR_ACQ_CHAN_LST:       return SDSR_HYBR_3_ACQ_CHAN_LST;
      case SDSR_OH_CHAN_LST:        return SDSR_HYBR_3_OH_CHAN_LST;
      case SDSR_TEMP_LST:           return SDSR_HYBR_3_TEMP_LST;
      case SDSR_TEMP2_LST:          return SDSR_HYBR_3_TEMP2_LST;

      case SDSR_ACQ_SYS:            return SDSR_HYBR_3_ACQ_SYS;
      case SDSR_ACQ_FULL_SYS:       return SDSR_HYBR_3_ACQ_FULL_SYS;
      case SDSR_ACQ_MINI_SYS:       return SDSR_HYBR_3_ACQ_MINI_SYS;
      case SDSR_ACQ_MICRO_SYS:      return SDSR_HYBR_3_ACQ_MICRO_SYS;
      case SDSR_ACQ_FULL2_SYS:      return SDSR_HYBR_3_ACQ_FULL2_SYS;
      case SDSR_ACQ_MINI2_SYS:      return SDSR_HYBR_3_ACQ_MINI2_SYS;
      case SDSR_ACQ_MICRO2_SYS:     return SDSR_HYBR_3_ACQ_MICRO2_SYS;
      case SDSR_ACQ_DEEP_SYS:       return SDSR_HYBR_3_ACQ_DEEP_SYS;
      case SDSR_ACQ_DEEP2_SYS:      return SDSR_HYBR_3_ACQ_DEEP2_SYS;
      case SDSR_ACQ_SHALLOW_SYS:    return SDSR_HYBR_3_ACQ_SHALLOW_SYS;
      case SDSR_ACQ_SHALLOW2_SYS:   return SDSR_HYBR_3_ACQ_SHALLOW2_SYS;
      case SDSR_START_SYS:          return SDSR_HYBR_3_START_SYS;
      case SDSR_IDL_SYS:            return SDSR_HYBR_3_IDL_SYS;
      case SDSR_SRV_SYS:            return SDSR_HYBR_3_SRV_SYS;
      case SDSR_SI_SYS:             return SDSR_HYBR_3_SI_SYS;
      case SDSR_REDIR_SYS:          return SDSR_HYBR_3_REDIR_SYS;
      case SDSR_CAND_SYS:           return SDSR_HYBR_3_CAND_SYS;
      case SDSR_TEMP_SYS:           return SDSR_HYBR_3_TEMP_SYS;
      case SDSR_CAND_IDL_SYS:       return SDSR_HYBR_3_CAND_IDL_SYS;
      case SDSR_GWL_LAST_FULL_SYS:  return SDSR_HYBR_3_GW_LAST_FULL_SYS;
      case SDSR_GWL_LAST_USER_SYS:  return SDSR_HYBR_3_GW_LAST_USER_SYS;
      case SDSR_GWL_LAST_LTD_SYS:   return SDSR_HYBR_3_GW_LAST_LTD_SYS;
      case SDSR_EMERG_SYS:          return SDSR_HYBR_3_EMERG_SYS;
      case SDSR_MANUAL_LST:         return SDSR_HYBR_3_MANUAL_LST;
      case SDSR_MRU_LST:            return SDSR_HYBR_3_MRU_LST;
      case SDSR_EMERG_LST:          return SDSR_HYBR_3_EMERG_LST;
      case SDSR_REDIAL_LST:         return SDSR_HYBR_3_REDIAL_LST;
      case SDSR_GWL_LTD_LST:        return SDSR_HYBR_3_GW_LTD_LST;
      case SDSR_PRL_LST:            return SDSR_HYBR_3_GW_LST;
      case SDSR_GWL_LST:            return SDSR_HYBR_3_GW_LST;
      case SDSR_ACQED_LST:          return SDSR_HYBR_3_ACQED_LST;
      case SDSR_MMSS_GWL_LST:       return SDSR_HYBR_3_GW_LST;
      default:
        break;

    } /* switch */
  }

  #endif

  #if defined FEATURE_HDR_HYBRID
  if ( ss_ptr == sdss_ptr(SD_SS_HYBR_HDR) )
  {

    switch( list )
    {
      case SDSR_AVAIL_LST:          return SDSR_HDR_AVAIL_LST;
      case SDSR_ACQ_GEO_LST:        return SDSR_HDR_ACQ_GEO_LST;
      case SDSR_IDL_GEO_LST:        return SDSR_HDR_IDL_GEO_LST;
      case SDSR_SRV_GEO_LST:        return SDSR_HDR_SRV_GEO_LST;
      case SDSR_ACQ_PREF_LST:       return SDSR_HDR_ACQ_PREF_LST;
      case SDSR_IDL_PREF_LST:       return SDSR_HDR_IDL_PREF_LST;
      case SDSR_SRV_PREF_LST:       return SDSR_HDR_SRV_PREF_LST;
      case SDSR_START_PREF_LST:     return SDSR_HDR_START_PREF_LST;
      case SDSR_REDIR_LST:          return SDSR_HDR_REDIR_LST;
      case SDSR_SRCH_LST:           return SDSR_HDR_SRCH_LST;
      case SDSR_SCHED_LST:          return SDSR_HDR_SCHED_LST;
      case SDSR_MEAS_LST:           return SDSR_HDR_MEAS_LST;
      case SDSR_ACQ_COLLOC_LST:     return SDSR_HDR_ACQ_COLLOC_LST;
      case SDSR_SRV_COLLOC_LST:     return SDSR_HDR_SRV_COLLOC_LST;
      case SDSR_MRU_LST:            return SDSR_HDR_MRU_LST;
      case SDSR_PWR_SAVE_LST:       return SDSR_HDR_PWR_SAVE_LST;
      case SDSR_ACQ_CHAN_LST:       return SDSR_HDR_ACQ_CHAN_LST;
      case SDSR_OH_CHAN_LST:        return SDSR_HDR_OH_CHAN_LST;
      case SDSR_BACKUP_LST:         return SDSR_HDR_BACKUP_LST;

      case SDSR_ACQ_SYS:            return SDSR_HDR_ACQ_SYS;
      case SDSR_ACQ_FULL_SYS:       return SDSR_HDR_ACQ_FULL_SYS;
      case SDSR_ACQ_MINI_SYS:       return SDSR_HDR_ACQ_MINI_SYS;
      case SDSR_ACQ_MICRO_SYS:      return SDSR_HDR_ACQ_MICRO_SYS;
      case SDSR_ACQ_FULL2_SYS:      return SDSR_HDR_ACQ_FULL2_SYS;
      case SDSR_ACQ_MINI2_SYS:      return SDSR_HDR_ACQ_MINI2_SYS;
      case SDSR_ACQ_MICRO2_SYS:     return SDSR_HDR_ACQ_MICRO2_SYS;
      case SDSR_ACQ_DEEP_SYS:       return SDSR_HDR_ACQ_DEEP_SYS;
      case SDSR_ACQ_DEEP2_SYS:      return SDSR_HDR_ACQ_DEEP2_SYS;
      case SDSR_ACQ_SHALLOW_SYS:    return SDSR_HDR_ACQ_SHALLOW_SYS;
      case SDSR_ACQ_SHALLOW2_SYS:   return SDSR_HDR_ACQ_SHALLOW2_SYS;
      case SDSR_START_SYS:          return SDSR_HDR_START_SYS;
      case SDSR_IDL_SYS:            return SDSR_HDR_IDL_SYS;
      case SDSR_SRV_SYS:            return SDSR_HDR_SRV_SYS;
      case SDSR_SI_SYS:             return SDSR_HDR_SI_SYS;
      case SDSR_REDIR_SYS:          return SDSR_HDR_REDIR_SYS;
      case SDSR_CAND_SYS:           return SDSR_HDR_CAND_SYS;
      case SDSR_TEMP_SYS:           return SDSR_HDR_TEMP_SYS;
      case SDSR_CAND_IDL_SYS:       return SDSR_HDR_CAND_IDL_SYS;
      case SDSR_TEMP_LST:           return SDSR_HDR_TEMP_LST;
      case SDSR_TEMP2_LST:          return SDSR_HDR_TEMP2_LST;
      case SDSR_REDIAL_LST:         return SDSR_HDR_REDIAL_LST;

      case SDSR_MORE_PREF_SCANNED_LST:
                                    return SDSR_HDR_MORE_PREF_SCANNED_LST;
      default:
        break;

    } /* switch */
  }
  #endif /* FEATURE_HDR_HYBRID */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  return list;

} /* sdss_sr_list_map */
/* <EJECT> */
/*===========================================================================

FUNCTION sdss_check_reset_emerg_rat_pri_list_info

DESCRIPTION
  Set the RAT priority list information for the SS-Core during an emerg call.
  If UE is in an emergency call origination state and the current rat priority
  list is different from the emergency rat priority list, replace current value
  with emergency preferences

DEPENDENCIES
  None.

RETURN VALUE
  None

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                      sdss_check_reset_emerg_rat_pri_list_info(

   sd_ss_e_type     ss

)
{
  sdss_s_type * ss_ptr = sdss_ptr(ss);
  if( (sdss_is_emergency_call_orig(ss) ||
       sdss_get_is_full_srv_req_during_emerg(ss))&&
      memcmp(&ss_ptr->rat_pri_list_info,
             &ss_ptr->emerg_rat_pri_list_info,
             sizeof(sys_rat_pri_list_info_s_type))
     )
   {
      /* Store the previous rat_pri_list_info
      */
      sys_rat_pri_list_info_s_type  *ss_rat_pri_list_info;
      ss_rat_pri_list_info = (sys_rat_pri_list_info_s_type*)modem_mem_alloc(sizeof(sys_rat_pri_list_info_s_type),MODEM_MEM_CLIENT_MMODE);

      if (ss_rat_pri_list_info == NULL)
      {
        SD_ERR_0("Can't allocate ss_rat_pri_list_info");
        return;
      }
      sdss_get_rat_pri_list_info(ss, ss_rat_pri_list_info);
      sdss_update_prev_rat_pri_list_info(ss, ss_rat_pri_list_info);

      modem_mem_free(ss_rat_pri_list_info,MODEM_MEM_CLIENT_MMODE);

      /* copy emerg rat priority info into current rat priority structure.
      */
      *(&(ss_ptr->rat_pri_list_info)) = *(&(ss_ptr->emerg_rat_pri_list_info));
      SD_MSG_HIGH_1("LTE_911:emerg rat pri %d",ss);
   }
}

/*===========================================================================

FUNCTION sdss_check_reset_emerg_rat_pri_list_info_no_emerg_orig

DESCRIPTION
  Set the RAT priority list information for the SS-Core in no sim cases.
  If UE is in an emerg_orig state, but without E911 orig, and the current rat priority
  list is different from the emergency rat priority list, replace current value
  with emergency preferences

DEPENDENCIES
  None.

RETURN VALUE
  None

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                      sdss_check_reset_emerg_rat_pri_list_info_no_emerg_orig(

   sd_ss_e_type     ss

)
{
  sdss_s_type * ss_ptr = sdss_ptr(ss);
  if( memcmp(&ss_ptr->rat_pri_list_info,
             &ss_ptr->emerg_rat_pri_list_info,
             sizeof(sys_rat_pri_list_info_s_type))
     )
   {
      /* Store the previous rat_pri_list_info
      */
      sys_rat_pri_list_info_s_type  *ss_rat_pri_list_info;
      ss_rat_pri_list_info = (sys_rat_pri_list_info_s_type*)modem_mem_alloc(sizeof(sys_rat_pri_list_info_s_type),MODEM_MEM_CLIENT_MMODE);
      if (ss_rat_pri_list_info == NULL)
      {
        SD_ERR_0("Can't allocate ss_rat_pri_list_info");
        return;
      }
      sdss_get_rat_pri_list_info(ss, ss_rat_pri_list_info);
      sdss_update_prev_rat_pri_list_info(ss, ss_rat_pri_list_info);

      modem_mem_free(ss_rat_pri_list_info,MODEM_MEM_CLIENT_MMODE);
      /* copy emerg rat priority info into current rat priority structure.
      */
      *(&(ss_ptr->rat_pri_list_info)) = *(&(ss_ptr->emerg_rat_pri_list_info));
      SD_MSG_HIGH_1("Sim less emerg rat pri %d",ss);
   }
}


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_get_lte_idle_ss

DESCRIPTION
  Returns the ss on which LTE was part of mode pref, prior to emergency call origination.

  Eg:
  1. If prior to 911 orig, UE was in SVLTE mode of operation.
      This api will ss = HYBR2

   2. If prior to 911 orig, UE was in non-SVLTE mode of operation.
      This api will return ss = MAIN

   3. If prior to 911 orig, LTE was not part of mode pref on either MAIN or HYBR2
      This api will return ss = MAX

DEPENDENCIES
  None.

RETURN VALUE
  ss on which LTE could have been acquired, prior to 911 call

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sd_ss_e_type          sdss_get_lte_idle_ss(

)
{
  sdss_s_type      * ss_ptr = sdss_ptr(SD_SS_HYBR_2);
  sd_ss_e_type       lte_ss = SD_SS_MAIN;
  uint32            i       = 0;

  /* Check if HYBR2 stack is processing an emerg call
  */
  if(sdss_is_emergency_call_orig(SD_SS_HYBR_2))
  {
    lte_ss = SD_SS_HYBR_2;
  }

  /* Check if hybr pref on HYBR2 stack has been turned off due to emerg call
  */
  else if( ss_ptr->prev_hybr_pref == SD_SS_HYBR_PREF_CDMA__LTE__HDR &&
           ss_ptr->hybr_pref == SD_SS_HYBR_PREF_NONE &&
           sdss_is_orig_mode(SD_SS_HYBR_2, SD_SS_ORIG_MODE_VAL_EMERG)
          )
  {
     lte_ss = SD_SS_HYBR_2;
  }
  else
  {
     lte_ss = SD_SS_MAIN;
  }

  ss_ptr = sdss_ptr(lte_ss);

  /* check if idle cap contains LTE */
  for( i = 0 ; i < ss_ptr->idle_rat_pri_list_info.num_items; i++)
  {
    if(SD_MODE_LTE == ss_ptr->idle_rat_pri_list_info.priority_list_info[i].acq_sys_mode)
    {
      return lte_ss;
    }
  }

  return SD_SS_MAX;

}

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_update_rat_pri_list_with_idle_cap

DESCRIPTION
  During an emergency call if SD is looking for full service, update the rat priority list
  to use the idle mode rat priority list.

DEPENDENCIES
  None.

RETURN VALUE
  None

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                      sdss_update_rat_pri_list_with_idle_cap(

   sd_ss_e_type     ss

)
{
  sdss_s_type * ss_ptr = sdss_ptr(ss);
  sd_ss_e_type  lte_ss = sdss_get_lte_idle_ss();


  if( lte_ss != SD_SS_MAX &&
      sdss_is_emergency_call_orig(ss) &&
      memcmp(&ss_ptr->rat_pri_list_info,
             &sdss_ptr(lte_ss)->idle_rat_pri_list_info,
             sizeof(sys_rat_pri_list_info_s_type))
     )
   {
      /* Store the previous rat_pri_list_info
      */
      sys_rat_pri_list_info_s_type  *ss_rat_pri_list_info;
      ss_rat_pri_list_info = (sys_rat_pri_list_info_s_type*)modem_mem_alloc(sizeof(sys_rat_pri_list_info_s_type),MODEM_MEM_CLIENT_MMODE);

      if (ss_rat_pri_list_info == NULL)
      {
        SD_ERR_0("Can't allocate ss_rat_pri_list_info");
        return;
      }
      sdss_get_rat_pri_list_info(ss, ss_rat_pri_list_info);
      sdss_update_prev_rat_pri_list_info(ss, ss_rat_pri_list_info);

      modem_mem_free(ss_rat_pri_list_info,MODEM_MEM_CLIENT_MMODE);

      /* copy emerg rat priority info into current rat priority structure.
      */
      *(&(ss_ptr->rat_pri_list_info)) = *(&(sdss_ptr(lte_ss)->idle_rat_pri_list_info));
      SD_MSG_HIGH_2("LTE_911:idle rat pri on %d with %d",ss,lte_ss);
   }
}

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_set_rat_pri_list_info

DESCRIPTION
  Set the RAT priority list information for the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  UE capability

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                          sdss_set_rat_pri_list_info(

        sd_ss_e_type                  ss,
            /* System selection stack
            */

  const sys_rat_pri_list_info_s_type  *rat_pri_list_info
)
{
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  SD_ASSERT( rat_pri_list_info != NULL );

  SD_CRIT_SECT_ENTER();
  *(&(sdss_ptr(ss)->rat_pri_list_info)) = *rat_pri_list_info;
  SD_CRIT_SECT_EXIT();
}

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_get_rat_pri_list_info

DESCRIPTION
  Get the RAT priority list information from the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  UE capability

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                          sdss_get_rat_pri_list_info(

        sd_ss_e_type                  ss,
            /* System selection stack.
            */

        sys_rat_pri_list_info_s_type  *rat_pri_list_info
)
{
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  SD_ASSERT( rat_pri_list_info != NULL );

  SD_CRIT_SECT_ENTER();
  *rat_pri_list_info = *(&(sdss_ptr(ss)->rat_pri_list_info));
  SD_CRIT_SECT_EXIT();
}


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_get_emerg_rat_pri_list_info

DESCRIPTION
  Get the emergency RAT priority list information from the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  UE capability

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                          sdss_get_emerg_rat_pri_list_info(

        sd_ss_e_type                  ss,
            /* System selection stack.
            */

        sys_rat_pri_list_info_s_type  *rat_pri_list_info
)
{
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  SD_ASSERT( rat_pri_list_info != NULL );

  SD_CRIT_SECT_ENTER();
  *rat_pri_list_info = *(&(sdss_ptr(ss)->emerg_rat_pri_list_info));
  SD_CRIT_SECT_EXIT();
}

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_get_prev_rat_pri_list_info

DESCRIPTION
  Get the previous RAT priority list information from the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  UE capability

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                          sdss_get_prev_rat_pri_list_info(

        sd_ss_e_type                  ss,
            /* System selection stack.
            */

        sys_rat_pri_list_info_s_type  *rat_pri_list_info
)
{
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  SD_ASSERT( rat_pri_list_info != NULL );

  SD_CRIT_SECT_ENTER();
  *rat_pri_list_info = *(&(sdss_ptr(ss)->prev_rat_pri_list_info));
  SD_CRIT_SECT_EXIT();
  return;
}

#ifdef FEATURE_EOOS
#error code not present
#endif

/*===========================================================================

FUNCTION sdss_map_event_to_group

DESCRIPTION
  Map SS-Event to SS-Event Group.

DEPENDENCIES
  None.

RETURN VALUE
  SS-Event group that is associated with the input SS-Event.
  SDSS_EVT_GRP_MAX if event is not associated with any event group.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sdss_evt_grp_e_type           sdss_map_event_to_group(

        sdss_evt_e_type               event
            /* SS-Event for which to get event group.
            */
)
{
  SD_ASSERT_ENUM_IS_INRANGE( event, SDSS_EVT_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if( SDSS_EVT_IS_USER(event) ) {
    return SDSS_EVT_GRP_USER;
  }

  else if( SDSS_EVT_IS_MISC(event) ) {
    return SDSS_EVT_GRP_MISC;
  }

  else if( SDSS_EVT_IS_INT(event) ) {
    return SDSS_EVT_GRP_INT;
  }

  else if( SDSS_EVT_IS_CDMA_ACQ(event) ) {
    return SDSS_EVT_GRP_CDMA_ACQ;
  }

  else if( SDSS_EVT_IS_CDMA_OPR(event) ) {
    return SDSS_EVT_GRP_CDMA_OPR;
  }

  else if( SDSS_EVT_IS_AMPS_ACQ(event) ) {
    return SDSS_EVT_GRP_AMPS_ACQ;
  }

  else if( SDSS_EVT_IS_AMPS_OPR(event) ) {
    return SDSS_EVT_GRP_AMPS_OPR;
  }

  else if( SDSS_EVT_IS_HDR_USER(event) ) {
    return SDSS_EVT_GRP_HDR_USER;
  }

  else if( SDSS_EVT_IS_HDR_ACQ(event) ) {
    return SDSS_EVT_GRP_HDR_ACQ;
  }

  else if( SDSS_EVT_IS_HDR_OPR(event) ) {
    return SDSS_EVT_GRP_HDR_OPR;
  }

  else if( SDSS_EVT_IS_GWL_ACQ(event) ) {
    return SDSS_EVT_GRP_GWL_ACQ;
  }

  else if( SDSS_EVT_IS_GWL_OPR(event) ) {
    return SDSS_EVT_GRP_GWL_OPR;
  }

  else if( SDSS_EVT_IS_HYBR_1_USER(event) ) {
    return SDSS_EVT_GRP_HYBR_1_USER;
  }

  else if(SDSS_EVT_IS_HYBR_2_GW_ACQ(event)) {
    return SDSS_EVT_GRP_HYBR_2_GW_ACQ;
  }

  else if(SDSS_EVT_IS_HYBR_2_GW_OPR(event)) {
    return SDSS_EVT_GRP_HYBR_2_GW_OPR;
  }

  else if(SDSS_EVT_IS_HYBR_2_USER(event)) {
    return SDSS_EVT_GRP_HYBR_2_USER;
  }

  else if(SDSS_EVT_IS_HYBR_3_GW_ACQ(event)) {
    return SDSS_EVT_GRP_HYBR_3_GW_ACQ;
  }

  else if(SDSS_EVT_IS_HYBR_3_GW_OPR(event)) {
    return SDSS_EVT_GRP_HYBR_3_GW_OPR;
  }

  else if(SDSS_EVT_IS_HYBR_3_USER(event)) {
    return SDSS_EVT_GRP_HYBR_3_USER;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If we got here, the input SS-Event is out of range - return
  ** SDSS_EVT_GRP_MAX.
  */
  SD_ERR_0( "event");
  return SDSS_EVT_GRP_MAX;

} /* sdss_map_event_to_group */

/*===========================================================================

FUNCTION sdss_set_mode_band_pref

DESCRIPTION
  Update the mode and band preference of the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                          sdss_set_mode_band_pref(

        sd_ss_e_type                  ss,
            /* System selection stack
            */

        sd_ss_mode_pref_e_type        mode_pref,
            /* system mode preference for get network request.
            */

        sd_ss_band_pref_e_type        band_pref,
            /* system band preference for get network request.
            */

        sys_lte_band_mask_e_type      lte_band_pref,
            /* LTE band preference (BC0, BC1, any, etc.)
            */

        sd_ss_band_pref_e_type        tds_band_pref
            /* TD-SCDMA band preference for get network request.
            */

)
{
  sdss_s_type   *ss_ptr   = NULL;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( mode_pref, SD_SS_MODE_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( band_pref, SD_SS_BAND_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_MSG_HIGH_5("SDSS:FRFL: Setting Mode_pref = %d, band_pref 0x%08x %08x tds_band_pref 0x%08x %08x", 
                                                                mode_pref,
                                                                QWORD_HIGH(band_pref),
                                                                QWORD_LOW(band_pref),
                                                                QWORD_HIGH(tds_band_pref),
                                                                QWORD_LOW(tds_band_pref));
  sd_print_lte_band_mask(lte_band_pref);

  SD_CRIT_SECT_ENTER();

  ss_ptr = sdss_ptr(ss);

  /*Check for Mode Pref Change*/
  if( (sdss_get_operator_name ( SYS_MODEM_AS_ID_1 ) == SD_OPERATOR_CT) &&
      (ss == SD_SS_MAIN) && (ss_ptr!=NULL) && (ss_ptr->mode_pref != mode_pref) )
  {
  
    SD_MSG_HIGH_2("SDSS:FRFL: current_mode_pref %d current_op_cap %d",
                  ss_ptr->mode_pref, ss_ptr->operator_capability);

    sdss_set_operator_capability(ss,SD_SS_MODE_PREF_ANY);
  }
  if( ss_ptr != NULL)
  {
  ss_ptr->mode_pref     = mode_pref;
  ss_ptr->band_pref     = band_pref;
  ss_ptr->lte_band_pref = lte_band_pref;
  ss_ptr->tds_band_pref = tds_band_pref;
  }
  SD_CRIT_SECT_EXIT();

} /* sdss_set_mode_band_pref */

/*===========================================================================

FUNCTION sdss_set_operator_capability

DESCRIPTION
  Update the operator capability.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                          sdss_set_operator_capability(

        sd_ss_e_type                  ss,
            /* System selection stack
            */

        sd_ss_mode_pref_e_type        operator_capability
            /* system mode preference for get network request.
            */
)
{
  sdss_s_type   *ss_ptr   = NULL;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( operator_capability, SD_SS_MODE_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_MSG_HIGH_1("SDSS:FRFL: Setting Operator Capability = %d ",
                                 operator_capability);

  SD_CRIT_SECT_ENTER();
  ss_ptr = sdss_ptr(ss);
  ss_ptr->operator_capability = operator_capability;
  SD_CRIT_SECT_EXIT();

} /* sdss_set_mode_band_pref */
/*===========================================================================

FUNCTION sdss_get_user_mode_pref

DESCRIPTION
  Read the user mode pref of the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                          sdss_get_user_mode_pref(

        sd_ss_e_type                  ss,
            /* System selection stack
            */

        sd_ss_mode_pref_e_type        *user_mode_pref,
            /* system user mode pref.
            */
        
       sd_ss_band_pref_e_type        *band_pref,

       sys_lte_band_mask_e_type      *lte_band_pref,
            /* LTE band preference (BC0, BC1, any, etc.)
            */

        sd_ss_band_pref_e_type        *tds_band_pref
            /* TD-SCDMA band preference for get network request.
            */
)
{
  sdss_s_type   *ss_ptr   = NULL;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ss_ptr = sdss_ptr(ss);

  SD_CRIT_SECT_ENTER();

  if( user_mode_pref != NULL )
  {
    *user_mode_pref     = ss_ptr->user_mode_pref;
  }
  
  if(band_pref != NULL )
    {
     *band_pref = ss_ptr->user_band_pref;
      
    }

  
  if( lte_band_pref != NULL )
  {
    *lte_band_pref = ss_ptr->lte_band_pref;
  }
  if( tds_band_pref != NULL )
  {
    *tds_band_pref = ss_ptr->tds_band_pref;
  }
  SD_CRIT_SECT_EXIT();

} /* sdss_get_mode_band_pref */


/*===========================================================================

FUNCTION sdss_get_mode_band_pref

DESCRIPTION
  Read the mode and band preference for get network request of the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                          sdss_get_mode_band_pref(

        sd_ss_e_type                  ss,
            /* System selection stack
            */

        sd_ss_mode_pref_e_type        *mode_pref,
            /* system mode preference for get network request.
            */

        sd_ss_band_pref_e_type        *band_pref,
            /* system band preference for get network request.
            */

        sys_lte_band_mask_e_type      *lte_band_pref,
            /* LTE band preference (BC0, BC1, any, etc.)
            */

        sd_ss_band_pref_e_type        *tds_band_pref
            /* TD-SCDMA band preference for get network request.
            */

)
{
  sdss_s_type   *ss_ptr   = NULL;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ss_ptr = sdss_ptr(ss);

  SD_CRIT_SECT_ENTER();

  if( mode_pref != NULL )
  {
    *mode_pref     = ss_ptr->mode_pref;
  }
  if( band_pref != NULL )
  {
    *band_pref     = ss_ptr->band_pref;
  }
  if( lte_band_pref != NULL )
  {
    *lte_band_pref = ss_ptr->lte_band_pref;
  }
  if( tds_band_pref != NULL )
  {
    *tds_band_pref = ss_ptr->tds_band_pref;
  }

  SD_CRIT_SECT_EXIT();

} /* sdss_get_mode_band_pref */


#ifdef FEATURE_EOOS
#error code not present
#endif

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_set_sd_prl_failed

DESCRIPTION
  set sdss_ptr is_sdprl_failed to is_fail

DEPENDENCIES
  None.

RETURN VALUE
  None

SIDE EFFECTS
  None.

===========================================================================*/
void   sdss_set_is_sdprl_failed(

  sd_ss_e_type ss,
  /* System selection stack
  */

  boolean is_fail
)
{
  sdss_ptr(ss)->is_sdprl_failed = is_fail;
}

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_set_is_pref_update_called

DESCRIPTION
  set sdss_ptr is_pref_update_called to is_called

DEPENDENCIES
  None.

RETURN VALUE
  None

SIDE EFFECTS
  None.

===========================================================================*/
void   sdss_set_is_pref_update_called(

  sd_ss_e_type ss,
  /* System selection stack
  */

  boolean is_called
)
{
  sdss_ptr(ss)->is_pref_update_called = is_called;
}

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_get_handoff

DESCRIPTION
  Returns the current handoff value for the specified ss.

DEPENDENCIES
  None.

RETURN VALUE
  sd_ss_ho_e_type

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sd_ss_ho_e_type               sdss_get_handoff(

        sd_ss_e_type                  ss
         /* System selection stack
         */
)
{
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  return ( sdss_ptr(ss)->handoff );
}
/*===========================================================================

FUNCTION sdss_get_disable_bsr_in_auto_mode_csg_support

DESCRIPTION
  Returns whether to disable bsr when auto mode csg support is enabled.

DEPENDENCIES
  None.

RETURN VALUE
  boolean

SIDE EFFECTS
  None.

===========================================================================*/

EXTERN boolean sdss_get_disable_bsr_in_auto_mode_csg_support(
  sd_ss_e_type                 ss
      /* System selection stack.
      */
)
{
  sd_si_info_s_type     *si_info_ptr = &sd_si_ptr(ss)->si_info;;

   /* If csg cell is selected and bsr should be disabled */
   if((si_info_ptr->csg_info.csg_id != SYS_CSG_ID_INVALID) &&
      (sdefs_csg_auto_mode_bsr_disable()) )
  {
    return TRUE;
  }
  else
  {
    return FALSE;
  }
}

/*===========================================================================

FUNCTION sdss_is_emerg_in_volte_specialization

DESCRIPTION
  Check if UE is with specialized E911 volte setting and normal call mode.

DEPENDENCIES
  None.

RETURN VALUE
  boolean

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean         sdss_is_emerg_in_roam_for_volte_specialization(

  sd_ss_e_type                  ss

)
{

  boolean ret_val = FALSE;

  sdss_s_type         *ss_ptr             = sdss_ptr(SD_SS_MAIN);

  #if defined(SD_GSM_SUPPORTED) || defined(SD_WCDMA_SUPPORTED) || defined( FEATURE_SD_LTE )
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  if((sdss_is_orig_mode0(ss_ptr->orig_mode,SD_SS_ORIG_MODE_VAL_EMERG)) &&\
      sdss_is_pref_reason( ss, SDSSSCR_PREF_REAS_VAL_CALL_ORIG) &&\
       ((sdss_get_special_volte_e911_calls() == SYS_SPECIAL_VOLTE_E911_CALLS) && (sdss_get_call_mode(ss) == SYS_CALL_MODE_NORMAL))\
       )
  {
    SD_MSG_LOW_1("sdss_is_emerg_in_roam_for_volte_specialization returned %d",ret_val);
     ret_val = TRUE;
  }
  #endif

  return ret_val;

} /* sdss_is_emerg_in_roam_for_volte_specialization */

/*===========================================================================

FUNCTION sdss_is_emer_orig_in_volte_only

DESCRIPTION
  Returns TRUE if Emergency call is originated in emerg call mode as Volte Only.

DEPENDENCIES
  None.

RETURN VALUE
  boolean

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean         sdss_is_emer_orig_in_volte_only(

                 sd_ss_e_type                  ss

)
{

  boolean ret_val = FALSE;
  
  sdss_s_type         *ss_ptr             = sdss_ptr(SD_SS_MAIN);

  #if defined(SD_GSM_SUPPORTED) || defined(SD_WCDMA_SUPPORTED) || defined( FEATURE_SD_LTE )
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  if((sdss_is_orig_mode0(ss_ptr->orig_mode,SD_SS_ORIG_MODE_VAL_EMERG)) &&\
      sdss_is_pref_reason( ss, SDSSSCR_PREF_REAS_VAL_CALL_ORIG) &&\
       ((sdss_get_special_volte_e911_calls() == SYS_SPECIAL_VOLTE_E911_CALLS) && (sdss_get_call_mode(ss) == SYS_CALL_MODE_VOLTE_ONLY))\
       )
  {
     ret_val = TRUE;
  }
  #endif
  
  if(ret_val == TRUE)
  {
    SD_MSG_HIGH_1("sdss_is_emer_orig_in_volte_only returned %d",ret_val);
  }

  return ret_val;

} /* sdss_is_emer_orig_in_volte_only */


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_get_opr_mode

DESCRIPTION
  Returns the current operating mode for the specified ss.

DEPENDENCIES
  None.

RETURN VALUE
  sdss_opr_mode_e_type

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sdss_opr_mode_e_type         sdss_get_opr_mode(

        sd_ss_e_type                 ss
            /* System selection stack.
            */
)
{

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Return the operating mode.
  */
  switch(ss)
  {
    case SD_SS_MAIN:
    case SD_SS_HYBR_1:
      return sdss_common.opr_mode_main;

    case SD_SS_HYBR_2:
      return sdss_common.opr_mode_hybr2;

    case SD_SS_HYBR_3:
      return sdss_common.opr_mode_hybr3;

    default:
      SD_MSG_HIGH_1("Invalid SS for opr_mode read: %d",ss);
      return SDSS_OPR_MODE_MAX;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

} /* sdss_get_opr_mode */

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_is_opr_mode

DESCRIPTION
  Check whether a specified operating mode value includes the current
  operating mode.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the specified operating mode value includes the current operating
  mode. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean                       sdss_is_opr_mode(

        sd_ss_e_type                  ss,
            /* System selection stack
            */

        sdssscr_opr_mode_val_e_type   opr_mode_val
            /* Operating mode value.
            */
)
{
  sdss_opr_mode_e_type   opr_mode;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( opr_mode_val, SDSSSCR_OPR_MODE_VAL_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  opr_mode = sdss_get_opr_mode( ss );

  /* If specified operating mode value includes the current operating mode,
  ** return TRUE. Else, return FALSE.
  */
  return(SD_IS_BIT_CONTAIN( opr_mode_val, BM(opr_mode)) );

} /* sdss_is_opr_mode */
/* <EJECT> */
/*===========================================================================

FUNCTION sdss_get_emerg_attached_state

DESCRIPTION
  Returns the current emerg_attached_state of the UE
DEPENDENCIES
  None.

RETURN VALUE
  boolean

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean         sdss_get_emerg_attached_state()
{

  return sdss_common.is_emerg_attached;

} /* sdss_get_emerg_attached_state */

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_set_emerg_attached_state

DESCRIPTION
  This routine sets the emergency attached state of hte UE

DEPENDENCIES
  sdss_common_init() should have been called.

RETURN VALUE

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                          sdss_set_emerg_attached_state(

        boolean                       is_emerg_attached

)
{

  if(sdss_common.is_emerg_attached != is_emerg_attached)
  {
    SD_MSG_HIGH_2("updating emerg attached state: %d -> %d",
                                         sdss_common.is_emerg_attached,
                                         is_emerg_attached);
    sdss_common.is_emerg_attached= is_emerg_attached;
  }

}

/*===========================================================================

FUNCTION sdss_get_emerg_barring_status

DESCRIPTION
  Returns the current emerg_attached_state of the UE
DEPENDENCIES
  None.

RETURN VALUE
  boolean

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean         sdss_get_emerg_barring_status()
{

  return sdss_common.emerg_bar_status;

} /* sdss_get_emerg_barring_status */


/*===========================================================================

FUNCTION sdss_set_emerg_bar_status

DESCRIPTION
  This routine sets the emergency barring status of hte UE

DEPENDENCIES
  sdss_common_init() should have been called.

RETURN VALUE

SIDE EFFECTS
  None.

===========================================================================*/

EXTERN  void                          sdss_set_emerg_bar_status(

        sys_lte_emerg_access_status_e_type   emerg_bar_status

)
{

  if(sdss_common.emerg_bar_status != emerg_bar_status)
  {
    SD_MSG_HIGH_2("updating emerg barring state: %d -> %d",
                                         sdss_common.emerg_bar_status,
                                         emerg_bar_status);
    sdss_common.emerg_bar_status= emerg_bar_status;
  }
}

/*===========================================================================
FUNCTION sdss_is_lte_ims_emerg_allowed

DESCRIPTION
  Return TRUE if LTE support emergency

DEPENDENCIES
  sdss_common_init() should have been called.

RETURN VALUE

SIDE EFFECTS
  None.

===========================================================================*/

EXTERN  boolean                   sdss_is_lte_ims_emerg_allowed
(

)
{
  sd_ss_e_type ss = sdss_get_ss_for_mode(SD_MODE_LTE);
  sd_si_info_s_type     *si_info_ptr = NULL;

  if( ss == SD_SS_MAX )
  {
    SD_MSG_HIGH_0("LTE not supp");
    return FALSE;
  }

  si_info_ptr = &sd_si_ptr(ss)->si_info;

  if( si_info_ptr->lte_ims_emerg_avail == SYS_IMS_LTE_EMERG_SUPP_AVAILABLE &&
        sdss_get_emerg_barring_status() != SYS_LTE_EMERG_ACCESS_BARRED)
   {
     return TRUE;
   }

   return FALSE;
}



/* <EJECT> */
/*===========================================================================

FUNCTION sdss_is_cdma_locked

DESCRIPTION
  Return the value of the CDMA locked indicator.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the CDMA locked indicator is set to TRUE. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean                       sdss_is_cdma_locked(

        sd_ss_e_type                  ss
            /* System selection stack
            */
)
{

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  /* Return the value of the CDMA locked indicator.
  */
  return sdss_ptr(ss)->is_cmda_locked;

} /* sdss_is_cdma_locked */

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_is_lte_active

DESCRIPTION
  This routine gets the lte activity status as per MDM, so that GW acquisitions
  can be skipped.

DEPENDENCIES
  sdss_common_init() should have been called.

RETURN VALUE

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean                       sdss_is_lte_active( void )
{
  return sdss_common.lte_activity_status;
}

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_get_pref_reason

DESCRIPTION
  Retrieve the SS-Preference reason for the specified SS.

DEPENDENCIES
  None.

RETURN VALUE
  SS-Preference reason

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sd_ss_pref_reas_e_type        sdss_get_pref_reason(

        sd_ss_e_type                  ss
            /* System selection stack.
            */
)
{
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  return sdss_ptr(ss)->pref_reason;
}

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_get_true_mode_pref

DESCRIPTION
  Retrieve the SS-Preference reason for the specified SS.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sd_ss_mode_pref_e_type        sdss_get_true_mode_pref(

        sd_ss_e_type                  ss
            /* System selection stack.
            */
)
{
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  return sdss_ptr(ss)->true_mode_pref;
}

/*===========================================================================

FUNCTION sdss_get_lbsr_mcc_item

DESCRIPTION
  Read the EFS value from the specified item index

DEPENDENCIES
  None.

RETURN VALUE
  The value of the EFS item

SIDE EFFECTS
  None.

===========================================================================*/

EXTERN  uint32  sdss_get_lbsr_mcc_item(

   int    item_idx
    /* The  item to read
            */
)
{
  if( item_idx >= SD_NV_ITEM_MCC_LIST_MAX )
  {
    SD_MSG_HIGH_1( "Out of Range efs_item: %d, return 0", item_idx);
    return 0;
  }

  return (sdss_lbsr_mcc_list.mcc_list[item_idx]);
}

/*===========================================================================

FUNCTION sdss_get_lbsr_mcc_item_cnt

DESCRIPTION
  Get the MCC list count

DEPENDENCIES
  None.

RETURN VALUE
Number of valid entries in the MCC_List

SIDE EFFECTS
  None.

===========================================================================*/

EXTERN  uint32  sdss_get_lbsr_mcc_item_cnt(void)
{
    return (sdss_lbsr_mcc_list.count);
}


/*===========================================================================

FUNCTION sdss_get_roam_pref

DESCRIPTION
  Retrieve the Roam Preference for the specified SS.

DEPENDENCIES
  None.

RETURN VALUE
  Roam Preference

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sd_ss_roam_pref_e_type        sdss_get_roam_pref(

        sd_ss_e_type                  ss
            /* System selection stack.
            */
)
{
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  return sdss_ptr(ss)->roam_pref;
}

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_set_pref_reason

DESCRIPTION
  set the SS-Preference reason for the specified SS.

DEPENDENCIES
  None.

RETURN VALUE
  SS-Preference reason

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void        sdss_set_pref_reason(

        sd_ss_e_type                  ss,
            /* System selection stack.
            */

        sd_ss_pref_reas_e_type       pref_reas

)
{
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  sdss_ptr(ss)->pref_reason = pref_reas;

  return;
}

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_get_domain_pref

DESCRIPTION
  Retrieve the Domain Preference for the specified SS.

DEPENDENCIES
  None.

RETURN VALUE
  Domain Preference

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sd_ss_srv_domain_pref_e_type  sdss_get_domain_pref(

        sd_ss_e_type                  ss
            /* System selection stack.
            */
)
{
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  return (sdss_ptr(ss)->domain_pref);
}

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_get_voice_domain_pref

DESCRIPTION
  Retrieve the Voice Domain Preference for the specified SS.

DEPENDENCIES
  None.

RETURN VALUE
  Domain Preference

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sys_voice_domain_pref_e_type  sdss_get_voice_domain_pref(

        sd_ss_e_type                  ss
            /* System selection stack.
            */
)
{
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  return (sdss_ptr(ss)->voice_domain_pref);
}

/*===========================================================================

DESCRIPTION
  Return the avoidance list updated flag

DEPENDENCIES
  None.

RETURN VALUE
  boolean  is_avoid_lst_updated

SIDE EFFECTS
  None.

*===========================================================================*/

EXTERN  boolean     sdss_get_avoid_list_updated_flag( void )
{
  if(sdss_common.is_avoid_lst_updated == TRUE)
  {
    SD_MSG_HIGH_1("SDSS: get avoidance list updated flag %d",
                  sdss_common.is_avoid_lst_updated);
  }

  return ( sdss_common.is_avoid_lst_updated);
}

/*===========================================================================

DESCRIPTION
  SETS  the avoidance list updated flag

DEPENDENCIES
  None.

RETURN VALUE
  NONE

SIDE EFFECTS
  None.

*===========================================================================*/

EXTERN  void     sdss_set_avoid_list_updated_flag( boolean is_avoid_list_updated )
{
  if (sdss_common.is_avoid_lst_updated != is_avoid_list_updated)
  {
    sdss_common.is_avoid_lst_updated = is_avoid_list_updated;
    SD_MSG_HIGH_1("SDSS: avoidance list updated flag set to %d", is_avoid_list_updated);
  }
}

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_get_operator_capability

DESCRIPTION
  Retrieve the Operaotr capability for the specified SS.

DEPENDENCIES
  None.

RETURN VALUE
  Pointer to Operaotr Capability for given stack.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sd_ss_mode_pref_e_type*  sdss_get_operator_capability(

        sd_ss_e_type                  ss
            /* System selection stack.
            */
)
{
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  return (&(sdss_ptr(ss)->operator_capability));
}

/*===========================================================================

FUNCTION sdss_get_acq_order_pref

DESCRIPTION
  Retrieve the Acquisition Order Preference for the specified SS.

DEPENDENCIES
  None.

RETURN VALUE
  Domain Preference

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sd_ss_acq_order_pref_e_type   sdss_get_acq_order_pref(

        sd_ss_e_type                  ss
            /* System selection stack.
            */
)
{
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  return (sdss_ptr(ss)->acq_order_pref);
}

/*===========================================================================

FUNCTION sdss_get_prev_hybr_pref

DESCRIPTION
  Retrieve the Hybrid Preference.

DEPENDENCIES
  None.

RETURN VALUE
  Hybrid Preference

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sd_ss_hybr_pref_e_type        sdss_get_prev_hybr_pref(

        sd_ss_e_type                  ss
            /* System selection stack.
            */
)
{
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  return (sdss_ptr(ss)->prev_hybr_pref);
}

/*===========================================================================

FUNCTION sdss_get_curr_hybr_pref

DESCRIPTION
  Retrieve the Hybrid Preference.

DEPENDENCIES
  None.

RETURN VALUE
  Hybrid Preference

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sd_ss_hybr_pref_e_type        sdss_get_curr_hybr_pref(

        sd_ss_e_type                  ss
            /* System selection stack.
            */
)
{
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  return (sdss_ptr(ss)->hybr_pref);
}

/*===========================================================================

FUNCTION sdss_set_hybr_pref

DESCRIPTION
  Update the Hybrid Preference for the specified SS.

DEPENDENCIES
  None.

RETURN VALUE
  Hybrid Preference

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                          sdss_set_hybr_pref(

        sd_ss_e_type                  ss,
            /* System selection stack.
            */

        sd_ss_hybr_pref_e_type        hybr_pref
)
{
  SD_ASSERT_ENUM_IS_INRANGE( hybr_pref, SD_SS_HYBR_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  SD_CRIT_SECT_ENTER();
  sdss_ptr(ss)->prev_hybr_pref = sdss_ptr(ss)->hybr_pref;
  sdss_ptr(ss)->hybr_pref = hybr_pref;
  SD_CRIT_SECT_EXIT();

  if(sdss_ptr(ss)->hybr_pref != hybr_pref)
  {
    SD_MSG_HIGH_2("Updating Hybr_pref=%d, Prev_Hybr_pref=%d",
                                      hybr_pref,sdss_ptr(ss)->prev_hybr_pref);
  }
}

/*===========================================================================

FUNCTION sdss_get_camp_mode

DESCRIPTION
  Retrieve the CAMPED mode value.

DEPENDENCIES
  None.

RETURN VALUE
  sd_ss_pref_camp_mode_e_type

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sd_ss_pref_camp_mode_e_type   sdss_get_camp_mode( void )
{
  return ( sdss_common.camp_mode );
}

/*===========================================================================

FUNCTION sdss_set_camp_mode

DESCRIPTION
  Update the CAMPED mode value.

DEPENDENCIES
  None.

RETURN VALUE
  None

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                          sdss_set_camp_mode(

        sd_ss_pref_camp_mode_e_type   camp_mode_val
)
{

  SD_ASSERT_ENUM_IS_INRANGE(camp_mode_val, SD_SS_PREF_CAMP_MODE_MAX);

  if( camp_mode_val == SD_SS_PREF_CAMP_MODE_NONE ||
      camp_mode_val == SD_SS_PREF_CAMP_MODE_MAX  ||
      camp_mode_val == SD_SS_PREF_CAMP_MODE_NO_CHANGE)
  {
    return;
  }

  if( camp_mode_val != sdss_common.camp_mode )
  {
    SD_MSG_LOW_2("SGLTE: Update camped mode %d -> %d",sdss_common.camp_mode,
                                                            camp_mode_val);
    sdss_common.camp_mode = camp_mode_val;
  }

}

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_is_pref_reason

DESCRIPTION
  Check whether a specified SS-Preference reason equals the current
  SS-Preference reason.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the specified origination mode value includes the current
  origination mode. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean                       sdss_is_pref_reason(

        sd_ss_e_type                  ss,
            /* System selection stack.
            */

        uint32                        pref_reason
            /* SS-Preference reason combination type.
            */
)
{

  SD_ASSERT_ENUM_IS_INRANGE( (sdssscr_pref_reas_val_e_type)pref_reason, SDSSSCR_PREF_REAS_VAL_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If specified SS-Preference reason equals the current SS-Preference
  ** reason, return TRUE. Else, return FALSE.
  */
  return( SD_IS_BIT_CONTAIN(pref_reason, BM(sdss_get_pref_reason(ss))) );

} /* sdss_is_pref_reason */

/*===========================================================================

FUNCTION sdss_update_hdr_opr_realign_pref_lst

DESCRIPTION
  Update the is_hdr_opr_realign_pref_lst flag

DEPENDENCIES


RETURN VALUE
  NONE

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                            sdss_update_hdr_opr_realign_pref_lst(

        boolean                         is_hdr_opr_realign_pref_lst
           /* Pointer to return the condition true flag.
           */
)
{
  sdss_common.is_hdr_opr_realign_pref_lst = is_hdr_opr_realign_pref_lst;

}/* sdss_update_hdr_opr_realign_pref_lst */
/*===========================================================================

FUNCTION sdss_is_hdr_opr_realign_pref_lst

DESCRIPTION
  Returns value of  is_hdr_opr_realign_pref_lst flag.

DEPENDENCIES


RETURN VALUE
  is_hdr_opr_realign_pref_lst flag

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean                      sdss_is_hdr_opr_realign_pref_lst( void )
{
  return sdss_common.is_hdr_opr_realign_pref_lst ;

}/* sdss_is_hdr_opr_realign_pref_lst */

/*===========================================================================

FUNCTION sdss_update_hdr_realign_colloc_lst

DESCRIPTION
  Update the is_1x_realign_hdr_srv_colloc_lst flag.
  It is set to TRUE whenever MAIN stack is modifying the HDR stack's
  SRV_COLLOC_LST. HDR stack needs to check this flag before attempting
  to do the same.

DEPENDENCIES


RETURN VALUE
  NONE

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                            sdss_update_hdr_realign_colloc_lst(

        boolean                         set_val
           /* value to be updated in is_1x_realign_hdr_srv_colloc_lst
           */
)
{
  sdss_common.is_1x_realign_hdr_srv_colloc_lst = set_val;

}/* sdss_update_hdr_realign_colloc_lst */

/*===========================================================================

FUNCTION sdss_is_hdr_realign_colloc_lst

DESCRIPTION
  Returns value of  is_1x_realign_hdr_srv_colloc_lst flag.

DEPENDENCIES


RETURN VALUE
  is_1x_realign_hdr_srv_colloc_lst

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean                        sdss_is_hdr_realign_colloc_lst( void )
{
  return sdss_common.is_1x_realign_hdr_srv_colloc_lst ;

}/* sdss_is_hdr_realign_colloc_lst */

/*===========================================================================

FUNCTION sdss_update_hybr_hdr_irat_operation

DESCRIPTION
  Update the HYBR_HDR_IRAT operation flag

DEPENDENCIES


RETURN VALUE
  NONE

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                            sdss_update_hybr_hdr_irat_operation(

        boolean                         is_hybr_hdr_irat
           /* Pointer to return the condition true flag.
           */
)
{
  sdss_common.is_hybr_hdr_irat = is_hybr_hdr_irat;

  /* Resetting the LTE scanned flag after LTE to HDR redirection is complete. 
   ** During csfb -> srlte/svlte switch this flag remains TRUE so that LTE is not scanned immediately
   ** after IRAT. 
   ** IRAT flag is truned OFF only after 1x is acquired on MAIN stack and switch is triggered
   ** by CMSOA
   */
  if(is_hybr_hdr_irat == FALSE && sd_si_ptr(SD_SS_MAIN)->si_info.is_lte_scanned)
  {
    SD_MSG_HIGH_2("IRAT:set flag to %d: MAIN: is_lte_scanned %d",is_hybr_hdr_irat,sd_si_ptr(SD_SS_MAIN)->si_info.is_lte_scanned);
    sd_si_ptr(SD_SS_MAIN)->si_info.is_lte_scanned = FALSE;
  }


  return;
}/* sdss_update_hybr_hdr_irat_operation */
/*===========================================================================

FUNCTION sdss_is_hybr_hdr_irat_operation

DESCRIPTION
  Returns HYBR HDR IRAT operation flag.

DEPENDENCIES


RETURN VALUE
  NONE

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean            sdss_is_hybr_hdr_irat_operation( void )
{

  return sdss_common.is_hybr_hdr_irat;

}/* sdss_is_hybr_hdr_irat_operation */

/*===========================================================================

FUNCTION sdss_update_opt_ho_lte_do

DESCRIPTION
  Update the is_opt_ho_lte_do flag

DEPENDENCIES


RETURN VALUE
  NONE

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void            sdss_update_opt_ho_lte_do(

        boolean         is_opt_ho_lte_do
        /* Flag to indicate if opt ho LTE->ehrpd is in progress
             */
)
{
  if (sdss_common.is_opt_ho_lte_do != is_opt_ho_lte_do)
  {
    sdss_common.is_opt_ho_lte_do = is_opt_ho_lte_do;
    SD_MSG_HIGH_1("OPT HO:set flag to %d",is_opt_ho_lte_do);
  }

  return;
}
#if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)

/*===========================================================================

FUNCTION sdss_update_card_imsi

DESCRIPTION
  Update the card_imsi value

DEPENDENCIES


RETURN VALUE
  NONE

SIDE EFFECTS
  None.

===========================================================================*/

EXTERN void sdss_update_card_imsi(

    const byte* card_imsi_val,

    uint32 data_size
)
{
    SD_MSG_HIGH_1("sdss_update_card_imsi - cdma_imsi: data size %d" , data_size);

     if(card_imsi_val == NULL)
     {
         SD_MSG_HIGH_0("sdss_update_card_imsi - null imsi data ");
         return;
     }

     memset(sdss_common.cdma_imsi,0,SD_CT_CDMA_IMSI_LEN);
     memscpy(sdss_common.cdma_imsi,SD_CT_CDMA_IMSI_LEN,card_imsi_val,data_size);

}
/*===========================================================================

FUNCTION sdss_get_card_imsi

DESCRIPTION
  get the card_imsi value

DEPENDENCIES


RETURN VALUE
  NONE

SIDE EFFECTS
  None.

===========================================================================*/

EXTERN void sdss_get_card_imsi(
  byte * card_imsi_val,

  uint8  imsi_len

)
{
    if(card_imsi_val != NULL)
    {
         memscpy(card_imsi_val,imsi_len,sdss_common.cdma_imsi,SD_CT_CDMA_IMSI_LEN);
    }

}
#endif

/*===========================================================================

FUNCTION sdss_is_opt_ho_lte_do

DESCRIPTION
  Returns is_opt_ho_lte_do flag.

DEPENDENCIES


RETURN VALUE
  True if opt ho LTE->ehprd is in progress
  False otherwise

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean            sdss_is_opt_ho_lte_do( void )
{

  return sdss_common.is_opt_ho_lte_do;

}

#ifdef FEATURE_MMODE_DYNAMIC_SV_OPERATION_SWITCH

/*===========================================================================

DESCRIPTION
  Return the SV operation action

DEPENDENCIES
  None.

RETURN VALUE
  sdss_sv_opr_action_e_type

SIDE EFFECTS
  None.

*===========================================================================*/

EXTERN  sdss_sv_opr_action_e_type     sdss_get_sv_opr_act( void )
{
  return ( sdss_common.sv_opr_action );
}

/*===========================================================================

DESCRIPTION
  Set the SV operation action

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

*===========================================================================*/
EXTERN  void                          sdss_set_sv_opr_act(

        sdss_sv_opr_action_e_type     sv_opr_act_val
)
{

  SD_ASSERT_ENUM_IS_INRANGE(sv_opr_act_val, SDSS_SV_OPR_ACT_MAX);

  if( sv_opr_act_val != sdss_common.sv_opr_action  )
  {
    SD_MSG_HIGH_2("CMSOA: Update sv_opr_action mode %d -> %d",
                 sdss_common.sv_opr_action ,
                 sv_opr_act_val);
    sdss_common.sv_opr_action  = sv_opr_act_val;
  }
}


/*===========================================================================

DESCRIPTION
  Return the SV dynamic switch enabled flag

DEPENDENCIES
  None.

RETURN VALUE
  sdss_sv_opr_action_e_type

SIDE EFFECTS
  None.

*===========================================================================*/
EXTERN  boolean              sdss_get_sv_dynamic_switch_enabled( void )
{
  if(sdss_common.is_sv_dynamic_switch_enabled == TRUE)
  {
    SD_MSG_HIGH_1("MMSOA: is dynamic switch enabled = %d",
              sdss_common.is_sv_dynamic_switch_enabled);
  }
  return ( sdss_common.is_sv_dynamic_switch_enabled );
}


/*===========================================================================

DESCRIPTION
  Set the SV dynamic switch enabled flag

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

*===========================================================================*/
EXTERN  void                sdss_set_sv_dynamic_switch_enabled(

        boolean             is_switch_enabled
        /* the input values indicates if dynamic switch feature is enabed */
)
{
  if( is_switch_enabled != sdss_common.is_sv_dynamic_switch_enabled  )
  {
    SD_MSG_LOW_2("MMSOA: Update sv_dyn_switch_enabled %d -> %d",
                 sdss_common.is_sv_dynamic_switch_enabled ,
                 is_switch_enabled);
    sdss_common.is_sv_dynamic_switch_enabled  = is_switch_enabled;
  }
  return;
}


/*===========================================================================

FUNCTION sdss_store_sv_opr_switch_lst

DESCRIPTION
  This function creates the switch_list that will be scanned during the
  process switching from SV to non-SV

DEPENDENCIES


RETURN VALUE
  True if opt ho LTE->ehprd is in progress
  False otherwise

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void               sdss_store_sv_opr_switch_lst( sd_ss_e_type ss )
{

  sdss_s_type   *ss_ptr   = sdss_ptr( ss );

  sdsr_e_type  cand_sys = SDSR_MAX;
    /* This candidate system is used to store the current candidate sys
    ** which can be used for re-acquired after we switch the SV-opr.
    */

  sdsr_s_type  *acq_sys = NULL;
    /* acquisition system pointer
    */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if(ss_ptr == NULL)
  {
    sys_err_fatal_null_ptr_exception();
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  SD_MSG_HIGH_1("MMSOA: Creating opr_switch_list ss=%d",ss);

  acq_sys = sdsr_list_get_ptr( sdss_sr_list_map( ss_ptr, SDSR_ACQ_SYS), 0 );

  if( acq_sys == NULL)
  {
    return;
  }

  if( ss == SD_SS_MAIN )
  {
    /* If mode is GWL, then we will use the candidate list
    */
    if(acq_sys->sys.mode == SD_MODE_GWL)
    {
      if(sdsr_list_cnt(SDSR_GW_CAND_SYS) > 0)
      {
        cand_sys = SDSR_GW_CAND_SYS;
      }
    }
  }

  /* If the candidate sys is not updated yet, then we assigned the
  ** current acquired system to candidate system.
  */
  if(cand_sys == SDSR_MAX)
  {
    cand_sys = sdss_sr_list_map( ss_ptr, SDSR_ACQ_SYS);
  }

  /*if hybrid 2 acquired service before main, don't overwrite switch list. instead append pref list after opr_switch_list
  ** so after switch, srv_sys on hybr_2 should be attempted first*/
  if(ss == SD_SS_MAIN && sd_si_is_srv_on( SD_SS_HYBR_2 ))
  {
    sdsr_list_app(SDSR_SV_OPR_SWITCH_LST, SDSR_START_PREF_LST);
  }
  else
  {
  //First append the more preferred system (PREF_LST)
  sdsr_list_cpy(SDSR_SV_OPR_SWITCH_LST, SDSR_START_PREF_LST);
  }

  //then append the current acquiring system (candidate sys)
  sdsr_list_app(SDSR_SV_OPR_SWITCH_LST, cand_sys);

  return;
}


/*===========================================================================

DESCRIPTION
  Evaluates and tell if limited service to acq_fail mapping is allowed 
  if limited service request is received due to 
    ** acq type reg_best_pref, then skip the logic of is_limited_srv_allowed
    ** this is because in case of reg_best_pref, anyways limited service will be obtained
    ** but in case if acq_stt is reacq_gwl then SD is trying to acquire full service on 
    ** the system for which NAS has send limited servic eearlier. So in second case 
    ** if their is limited service reported in state reacq_gwl, then do not skip this 
    ** limited service not allowed logic.

DEPENDENCIES
  None.

RETURN VALUE
  Boolean.

SIDE EFFECTS
  None.

*===========================================================================*/
EXTERN  boolean                sdss_allow_ltd_acq_fail_mapping(sd_ss_e_type ss)
{
  sdssscr_acq_e_type  acq_type = sdss_eng_stack_get_acq_type(ss);
  sdss_acq_stt_e_type            acq_stt            = sdss_eng_stack_get_state(ss);
  boolean result = FALSE;

  if(sdss_get_sv_dynamic_switch_enabled())
  {
    if(acq_type != SDSSSCR_ACQ_REG_BEST_PREF)
    {
      result = TRUE;
    }
    else if(acq_type == SDSSSCR_ACQ_REG_BEST_PREF && acq_stt == SDSS_ACQ_STT_REACQ_GWL)
    {
      result = TRUE;
    }
  }
  else
  {
    result = TRUE;
  }

  return result;
}




#endif

/*===========================================================================

DESCRIPTION
  Return the FULL SRV REQ in EMERG ORIG flag

DEPENDENCIES
  None.

RETURN VALUE
  boolean 

SIDE EFFECTS
  None.

*===========================================================================*/
EXTERN  boolean              sdss_get_cfg_full_srv_req_in_emerg( sd_ss_e_type ss )
{
  sys_modem_as_id_e_type asubs_id = sdss_map_ss_to_as_id(ss);
  if(!(asubs_id >= SYS_MODEM_AS_ID_1 && asubs_id < MAX_SIMS
    && asubs_id < SYS_MODEM_AS_ID_NO_CHANGE))
  {
    asubs_id = SYS_MODEM_AS_ID_1;
  }

  if(sdss_common.sub_config[asubs_id].cfg_full_srv_req_in_emerg == TRUE)
  {
    SD_MSG_HIGH_1("Is FULL SRV REQ needed in EMERG ORIG= %d",
              sdss_common.sub_config[asubs_id].cfg_full_srv_req_in_emerg );
  }
  return ( sdss_common.sub_config[asubs_id].cfg_full_srv_req_in_emerg );
}

/*===========================================================================
sdss_get_cfg_emerg_call_after_lu_in_lpm()

DESCRIPTION
  Return the cfg_emerg_call_after_lu_in_lpm

DEPENDENCIES
  None.

RETURN VALUE
  boolean

SIDE EFFECTS
  None.

*===========================================================================*/
EXTERN  boolean              sdss_get_cfg_emerg_call_after_lu_in_lpm( void )
{
  SD_MSG_HIGH_1("Is EMERG_CALL send to Network needed = %d",
              sdss_common.cfg_emerg_call_after_lu_in_lpm );
  return ( sdss_common.cfg_emerg_call_after_lu_in_lpm );
}

/*===========================================================================

DESCRIPTION
  Return the efs configuration for roma ind update in l to 1x ho

DEPENDENCIES
  None.

RETURN VALUE
  boolean 

SIDE EFFECTS
  None.

*===========================================================================*/
EXTERN  boolean              sdss_get_cfg_roam_ind_update_in_l_to_1x_ho( void )
{
  if(sdss_common.cfg_roam_ind_update_in_l_to_1x_ho == TRUE)
  {
    SD_MSG_HIGH_1("ROAM IND UPDATE IN L TO 1X HO = %d",
              sdss_common.cfg_roam_ind_update_in_l_to_1x_ho);
  }
  return ( sdss_common.cfg_roam_ind_update_in_l_to_1x_ho );
}

/*===========================================================================

FUNCTION sdss_is_flag_set

DESCRIPTION
  Check whether a specified SS-Preference reason equals the current
  SS-Preference reason.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the specified origination mode value includes the current
  origination mode. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean                       sdss_is_flag_set(

        sd_ss_e_type                  ss,
            /* System selection stack.
            */

        sdss_flag_e_type              flag
            /* SS-Preference reason combination type.
            */
)
{
  const sdss_s_type   *ss_ptr   = sdss_ptr( ss );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( flag, SDSS_FLAG_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  switch( flag )
  {
    case SDSS_FLAG_TRUE_EVENT_PROCESSED:
      return ss_ptr->is_true_event_processed;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    case SDSS_FLAG_SYNC_UP_IN_PROGRESS:
    #ifdef FEATURE_HICPS_STACK_SYNC_UP
      return ss_ptr->is_stack_syncup_in_progress;
    #endif /* FEATURE_HICPS_STACK_SYNC_UP */

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_FLAG_ENG_SCR_TIMER:
      return ss_ptr->is_eng_scr_timer_set;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_FLAG_HYBR_HDR_IRAT:
      return sdss_is_hybr_hdr_irat_operation();

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_FLAG_OPT_HO_LTE_TO_DO:
      return sdss_is_opt_ho_lte_do();

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_FLAG_C2K_ALT_ALGR:
      return sdss_is_c2k_alt_algr_operation();

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_FLAG_EXTEND_1X_BSR:
      return sdss_ptr(ss)->is_extend_1x_bsr_timer;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    case SDSS_FLAG_WCDMA_FREQ_LOCK:
      if(*sdefs_wcdma_freq_lock_ptr(sdss_map_ss_to_as_id(ss)) != 0)
      {
        return TRUE;
      }
      else
      {
        return FALSE;
      }
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    case SDSS_FLAG_MAP_SCAN:
      return ss_ptr->is_map_scan;

    case SDSS_FLAG_HYBR2_BSR:
      return ss_ptr->is_hybr_2_bsr;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
   case SDSS_FLAG_HYBR2_LTE_IRAT_FAIL:
      return ss_ptr->is_hybr2_lte_irat_fail;

   case SDSS_FLAG_IS_IBSR_PWRUP_DONE:
      return ss_ptr->iBSR_pwrup;
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    #ifdef FEATURE_MMSS_3_1
    case SDSS_FLAG_SRV_TYPE_NON_MMSS:
     return ss_ptr->is_non_mmss_type;
    #endif

    case SDSS_FLAG_LOC_BASE_BSR:
      return ss_ptr->is_loc_based_bsr;

    case SDSS_FLAG_MCC_MATCH_FOUND:
      return ss_ptr->is_mcc_match_found;

    case SDSS_FLAG_1XCSFB_ECBM:
      return ss_ptr->is_1xcsfb_ecbm;

    case SDSS_FLAG_HDR_DEACT_BY_HYBR2_BSR:
      return ss_ptr->is_hdr_deact_by_hybr2_bsr;

    case SDSS_FLAG_FULL_SRV_REQ_DURING_EMERG:
      return ss_ptr->is_full_srv_req_during_emerg;

    case SDSS_FLAG_OVERRIDE_E911_ADD_INFO:
      return ss_ptr->is_override_e911_add_info;

    case SDSS_FLAG_CALL_MODE_VOLTE_ONLY:
		{
          if(sdss_get_call_mode(ss) == SYS_CALL_MODE_VOLTE_ONLY)
          {
            return TRUE;
          }
		  else
		  {
		    return FALSE;
		  }
    	}

    case SDSS_FLAG_IS_FORCE_KICK_HYBR2:
        return sdss_common.is_force_kick_hybr2;

    case SDSS_FLAG_SPECIAL_VOLTE_REDIAL:
       return ss_ptr->is_special_volte_redial;
              
    case SDSS_FLAG_NONE:
    case SDSS_FLAG_MAX:
    default:

      return FALSE;
   /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  }

} /* sdss_is_flag_set */

/*===========================================================================

FUNCTION sdss_is_loc_bsr_change

DESCRIPTION
  Check whether immediate BSR should be performed when DO area is changed.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if move out of long BSR DO
  FALSE if move in long BSR DO since we can wait for current short BSR timer expire then do LTE scan

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean                       sdss_is_loc_bsr_change(

        sd_ss_e_type                  ss
            /* System selection stack
            */
)
{
  const sdss_s_type   *ss_ptr   = sdss_ptr( ss );

  return ss_ptr->is_loc_chg_move_out;
}
/*===========================================================================

FUNCTION sdss_set_loc_change

DESCRIPTION
  set location change flag.

DEPENDENCIES
  None.

RETURN VALUE
  None

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                       sdss_set_loc_change(

        sd_ss_e_type                  ss,
            /* System selection stack
            */
        boolean                  val
)
{
  sdss_s_type   *ss_ptr   = sdss_ptr( ss );

  ss_ptr->is_loc_chg_move_out = val;
}

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_is_orig_mode0

DESCRIPTION
  Check whether a specified origination mode value includes the specified
  origination mode.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the specified origination mode value includes the specified
  origination mode. FALSE otherwise.

SIDE EFFECTS
  None.


===========================================================================*/
EXTERN  boolean                    sdss_is_orig_mode0(

        sd_ss_orig_mode_e_type     orig_mode,
        /* Specified Origination mode enumeration type.
        */

        sd_ss_orig_mode_val_e_type orig_mode_val
        /* Origination mode value.
        */
)
{
  SD_ASSERT_ENUM_IS_INRANGE( orig_mode, SD_SS_ORIG_MODE_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( orig_mode_val, SD_SS_ORIG_MODE_VAL_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* If specified origination mode value includes the current origination
  ** mode, return TRUE. Else, return FALSE.
  */
  return( SD_IS_BIT_CONTAIN(orig_mode_val, BM(orig_mode)) );

}/* sd_is_orig_mode */


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_is_emergency_call_orig

DESCRIPTION
  Check whether the current stack is attempting to place an emergency call or
  is in emergency callback mode

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the the current stack is attempting to place an emergency call.
  FALSE otherwise.

SIDE EFFECTS
  None.


===========================================================================*/
EXTERN  boolean                    sdss_is_emergency_call_orig(

        sd_ss_e_type     ss
        /* Stack that is being checked
        */

)
{
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* If the the current stack is attempting to place an emergency call and
  ** the mode preference on the stack is not none return TRUE. Else, return FALSE.
  */
  if( (sdss_get_orig_mode(ss)  == SD_SS_ORIG_MODE_EMERG_ORIG ||
       sdss_get_orig_mode(ss)  == SD_SS_ORIG_MODE_EMERG_CB ) &&
      sdss_is_pref_reason( ss, SDSSSCR_PREF_REAS_VAL_CALL_ORIG) )
  {
    sd_ss_mode_pref_e_type  mode_pref;
    sdss_get_mode_band_pref( ss,
                             &mode_pref,
                             NULL,
                             NULL,
                             NULL );
    if (mode_pref != SD_SS_MODE_PREF_NONE)
    {
      return TRUE;
    }
  }
  return FALSE;

}/* sdss_is_emergency_call_orig */

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_is_orig_mode

DESCRIPTION
  Check whether a specified origination mode value includes the current
  origination mode.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the specified origination mode value includes the current
  origination mode. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean                       sdss_is_orig_mode(

        sd_ss_e_type                  ss,
            /* System selection stack.
            */

        sd_ss_orig_mode_val_e_type    orig_mode_val
            /* Origination mode value.
            */
)
{

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( orig_mode_val, SD_SS_ORIG_MODE_VAL_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return( sdss_is_orig_mode0( sdss_get_orig_mode(ss), orig_mode_val ) );

} /* sdss_is_orig_mode */


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_is_prev_orig_mode

DESCRIPTION
  Check whether a specified origination mode value includes the current
  origination mode.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the specified origination mode value includes the current
  origination mode. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean                       sdss_is_prev_orig_mode(

        sd_ss_e_type                  ss,
            /* System selection stack.
            */

        sd_ss_orig_mode_val_e_type    orig_mode_val
            /* Origination mode value.
            */
)
{

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( orig_mode_val, SD_SS_ORIG_MODE_VAL_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return( sdss_is_orig_mode0( sdss_ptr( ss )->orig_mode_prev, orig_mode_val ) );

} /* sdss_is_orig_mode */


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_is_hybr_pref

DESCRIPTION
  Check whether a specified hybrid preference equals the current hybrid
  preference.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the specified hybrid preference equals the current hybrid
  preference. FALSE otherwise

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean                       sdss_is_hybr_pref(

        sd_ss_e_type                  ss,
            /* System selection stack.
            */

        sd_ss_hybr_pref_e_type        hybr_pref
            /* Hybrid preference.
            */
)
{

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX )
  SD_ASSERT_ENUM_IS_INRANGE( hybr_pref, SD_SS_HYBR_PREF_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If specified hybrid preference equals the current hybrid preference,
  ** return TRUE. Else, return FALSE.
  */
  return( sdss_get_curr_hybr_pref( ss ) == hybr_pref );

} /* sdss_is_hybr_pref */


/*===========================================================================

FUNCTION sdss_is_hybr_pref

DESCRIPTION
  Check whether a specified hybrid preference equals the current hybrid
  preference.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the specified hybrid preference equals the current hybrid
  preference. FALSE otherwise

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean                       sdss_is_hybr_pref_chgd(

        sd_ss_e_type                  ss
          /* System selection stack.
          */
)
{
  sd_ss_hybr_pref_e_type hybr_pref      = SD_SS_HYBR_PREF_NONE;
  sd_ss_hybr_pref_e_type prev_hybr_pref = SD_SS_HYBR_PREF_NONE;

  SD_ASSERT_ENUM_IS_INRANGE(ss, SD_SS_MAX );

  SD_CRIT_SECT_ENTER();
  hybr_pref = sdss_get_curr_hybr_pref(ss);
  prev_hybr_pref = sdss_get_prev_hybr_pref(ss);
  SD_CRIT_SECT_EXIT();

  /* TRUE - hybr pref has changed
  ** FALSE - hybr pref is same as previous
  */
  return( hybr_pref != prev_hybr_pref );
}


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_is_band_pref

DESCRIPTION
  Check whether a specified band preference equals the current band
  preference.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the specified band preference equals the current band preference
  type FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean                       sdss_is_band_pref(

        sd_ss_e_type                  ss,
            /* System selection stack
            */

        sd_ss_band_pref_e_type        band_pref
            /* Band preference.
            */
)
{
  sd_ss_band_pref_e_type     ss_band_pref     = SD_SS_BAND_PREF_NONE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( band_pref, SD_SS_BAND_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  sdss_get_mode_band_pref( ss,
                           NULL,
                           &ss_band_pref,
                           NULL,
                           NULL );
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If specified band preference equals the current band preference, return
  ** TRUE. Else, return FALSE.
  */
  if( band_pref == ss_band_pref )
  {
    return TRUE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return FALSE;

} /* sdss_is_band_pref */




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_is_acq_specific_sid

DESCRIPTION
  Indicate whether last acquisition is for a specific SID.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if last acquisition is for a specific SID. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean                     sdss_is_acq_specific_sid(

        sd_ss_e_type                ss
            /* System selection stack
            */
)
{
  const sdss_s_type   *ss_ptr   = sdss_ptr( ss );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If acquisition is of type specific, return TRUE.
  */
  if( ss_ptr->acq_type == SDSSSCR_ACQ_SPECIFIC ||
      ss_ptr->acq_type == SDSSSCR_ACQ_SPECIFIC_PRL ||
      ss_ptr->acq_type == SDSSSCR_ACQ_SPECIFIC_PREF )
  {
    return TRUE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Else return FALSE.
  */
  return FALSE;

} /* sdss_is_acq_specific_sid */



/* <EJECT> */
/*===========================================================================

FUNCTION sdss_del_acq_sys_from_pref_list

DESCRIPTION
  This function delete the acq_sys record if it presents in the PREF_LIST.
  There are cases where we do not want to delete this record.

  Case 1: If the acq_sys is a GWL system, which we issued LIMITED SRV_REQ.
  Explaination: We only remove the system when we have fully scanned all
  the bands/channels on that records. With type LIMITED, we only looks for
  whatever available first. Hence, we should not remove it out of the pref
  list so that we could re-acquire other bands/channels in this record.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                        sdss_del_acq_sys_from_pref_list(

        sd_ss_e_type                ss,
            /* System selection - MAIN or HDR.
            */

        sdsr_e_type                 list,
            /* List for which to add the system record.
            */

        sdsr_ref_type               sr_ref,
            /* System record reference to be deleted.
            */

        const sdsr_s_type          *sr_ptr
            /* System record pointer to be deleted.
            */
)
{

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* For now, we only taking care of the pref_lst on MAIN stack.
  ** For other stacks, we don't support LTE together with LIMITED SRV_REQ
  */
  if ( ss != SD_SS_MAIN )
  {
    (void) sdsr_list_del_ref( list, sr_ref );
  }
  else
  {
    /* variable store the net_sel_type of last act
    */
    sys_network_selection_mode_e_type net_sel_type;

    net_sel_type = sd_misc_get_act_net_sel(ss);

    /*
    ** For 3GPP: During Limited acquisitions, we only looks for the 1st plmn
    ** available on the GEO. Hence, we don't want to remove the whole system
    ** record, which could potentially contains more available systems.
    */
    if(!((sr_ptr->sys.mode == SD_MODE_GWL) &&

          sdss_is_mmss_operation(SD_SS_MAIN) &&

         (net_sel_type == SYS_NETWORK_SELECTION_MODE_LIMITED))
      )
    {
      (void) sdsr_list_del_ref( list, sr_ref );
    }

  }

  return;

} /* sdss_is_acq_type */


/*===========================================================================

@FUNCTION sdss_is_gprs_anite_gcf

@DESCRIPTION
  Indicates if a SS in underdoing GCF tests.

@DEPENDENCIES
  None.

@RETURNS
  TRUE if this SS is underdoing GCF tests.
  FALSE otherwise.

@SIDE_EFFECT
  None.

@x
===========================================================================*/
EXTERN boolean                        sdss_is_gprs_anite_gcf(

       sd_ss_e_type                   ss
       /**< System selection stack.
       */

)
{
  sdss_s_type   *ss_ptr       = sdss_ptr(ss);

  SD_ASSERT(ss_ptr != NULL);

  SD_MSG_HIGH_2("sdss_is_gprs_anite_gcf()-ss:%d,gcf:%d",ss,
                ss_ptr->gprs_anite_gcf);

  return SD_BOOLEAN(ss_ptr->gprs_anite_gcf);
}


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_get_ss_sys_lost

DESCRIPTION
 Gets the sys lost value for the ss

DEPENDENCIES
  None.

RETURN VALUE
sys_lost value for the ss
SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sd_ss_sys_lost_e_type sdss_get_ss_sys_lost(

              sd_ss_e_type                   ss
       /**< System selection stack.
       */
)
{
   sdss_s_type   *ss_ptr       = sdss_ptr(ss);

  SD_ASSERT(ss_ptr != NULL);

  return ss_ptr->sys_lost;
} /* sdss_get_ss_sys_lost */

/*===========================================================================

FUNCTION sdss_is_sub2_map_to_hybr3

DESCRIPTION
  Check the value of is_sub2_map_to_hybr3.

DEPENDENCIES
  none

RETURN VALUE
  Boolean

SIDE EFFECTS
  none

===========================================================================*/
boolean  sdss_is_sub2_map_to_hybr3(
  sd_ss_e_type                  ss
)
{
  return sdss_ptr(ss)->is_sub2_map_to_hybr3;
}

/*===========================================================================

FUNCTION sdss_set_is_sub2_map_to_hybr3

DESCRIPTION
  Set is_sub2_map_to_hybr3.

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void sdss_set_is_sub2_map_to_hybr3(  
  sd_ss_e_type                  ss
)
{
  sdss_s_type *ss_ptr           = sdss_ptr(ss);

  /* Set it to FALSE for single sim config */
  if (sdss_common.onebuild_feature != SYS_OVERALL_FEATURE_MODE_MULTISIM)
  {
    ss_ptr->is_sub2_map_to_hybr3 = FALSE;
    return;
  }
  else 
  {
    const policyman_item_t *pItem = NULL;
    uint32 max_mode_capability_1 = SYS_SYS_MODE_MASK_GSM;
    uint32 max_mode_capability_2 = SYS_SYS_MODE_MASK_GSM;
  
    const policyman_item_id_t id = POLICYMAN_ITEM_DEVICE_CONFIGURATION;
    policyman_item_collection_t const *pCollection;

  if (POLICYMAN_SUCCEEDED(policyman_get_items_block_msim((policyman_item_id_t const *)&id,
                                                     1, &pCollection)))
  {
    pItem = pCollection->pItems[0];

    if(!POLICYMAN_SUCCEEDED(
       policyman_device_config_get_current_subphone_capability(pItem, 
       0, &(max_mode_capability_1))))
    {
      SD_MSG_HIGH_1("MaxCap read error sim %d",0);
    }
  
    if(!POLICYMAN_SUCCEEDED(
        policyman_device_config_get_current_subphone_capability(pItem, 
        1, &(max_mode_capability_2))))
    {
      SD_MSG_HIGH_1("MaxCap read error sim %d",1);
    }
  }

    policyman_item_collection_release(pCollection);
    
  /* Set it to TRUE for SXLTE+G */
  if (sdss_is_1x_sxlte() || sdss_is_sglte())
  {
    ss_ptr->is_sub2_map_to_hybr3 = TRUE;
  }

  /* For normal+normal, if max allowed cap is not any+G */
  else if (max_mode_capability_1 != SYS_SYS_MODE_MASK_GSM &&
         max_mode_capability_2 != SYS_SYS_MODE_MASK_GSM)
  {
    ss_ptr->is_sub2_map_to_hybr3 = TRUE;
  }
  
  else
  {
    ss_ptr->is_sub2_map_to_hybr3 = FALSE;
  }

  SD_MSG_HIGH_1("sdss_set_is_sub2_map_to_hybr3()-set to %d", ss_ptr->is_sub2_map_to_hybr3);
  }
}

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_get_ss_for_mode

DESCRIPTION
 Gets the SS for the Mode

DEPENDENCIES
  None.

RETURN VALUE
  The ss for the mode, if valid
  SD_SS_MAX otherwise

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sd_ss_e_type                  sdss_get_ss_for_mode(

        sd_mode_e_type                mode_pref
            /* Mode preference.
            */
)
{
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( mode_pref, SYS_SYS_MODE_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  switch( mode_pref )
  {
    case SD_MODE_GPS:
    case SD_MODE_AMPS:
    case SD_MODE_CDMA:
    case SD_MODE_GSM:
    case SD_MODE_WCDMA:
    case SD_MODE_GW:
    case SD_MODE_LTE:
    case SD_MODE_GWL:
    case SD_MODE_TDS:
      {
        sd_ss_mode_pref_e_type  mode_pref_main   = SD_SS_MODE_PREF_NONE;
        sd_ss_mode_pref_e_type  mode_capability  = SD_SS_MODE_PREF_NONE;
        sd_ss_mode_pref_e_type  mode_pref_hybr_2 = SD_SS_MODE_PREF_NONE;
        sd_ss_mode_pref_e_type  mode_pref_hybr_3 = SD_SS_MODE_PREF_NONE;

        /* Check MAIN mode pref */
        sdss_get_mode_band_pref( SD_SS_MAIN,
                                 &mode_pref_main,
                                 NULL,
                                 NULL,
                                 NULL );

        if( SD_MODE_CONTAIN( mode_pref_main,
                             sdss_map_mode_to_mode_pref(mode_pref)) )
        {
          return SD_SS_MAIN;
        }

        /* Check HYBR2 mode pref */
        if(sdss_is_1x_sxlte())
        {
          sdss_get_mode_band_pref( SD_SS_HYBR_2,
                                   &mode_pref_hybr_2,
                                   NULL,
                                   NULL,
                                   NULL );

          if(  sdss_get_opr_mode(SD_SS_HYBR_2) == SDSS_OPR_MODE_ONLINE  &&
               SD_MODE_CONTAIN( mode_pref_hybr_2,
                                sdss_map_mode_to_mode_pref(mode_pref))
             )
          {
            return SD_SS_HYBR_2;
          }
        }

        /* Check HYBR3 mode pref */
        sdss_get_mode_band_pref( SD_SS_HYBR_3,
                                 &mode_pref_hybr_3,
                                 NULL,
                                 NULL,
                                 NULL );

        if( sdss_is_featuremode(SYS_OVERALL_FEATURE_MODE_MULTISIM) &&
            sdss_get_opr_mode(SD_SS_HYBR_3) == SDSS_OPR_MODE_ONLINE &&
            SD_MODE_CONTAIN( mode_pref_hybr_3,
                             sdss_map_mode_to_mode_pref(mode_pref)) )
        {
          return SD_SS_HYBR_3;
        }

        /* Check true MAIN mode pref */
        sdss_get_mode_band_capability_mmode( &mode_capability,
                                              NULL,
                                              NULL,
                                              NULL );

        if( SD_MODE_CONTAIN( mode_capability,
                             sdss_map_mode_to_mode_pref(mode_pref))
            &&
            SD_MODE_CONTAIN( sdss_get_true_mode_pref( SD_SS_MAIN ),
                             sdss_map_mode_to_mode_pref(mode_pref)) )
        {
          return SD_SS_MAIN;
        }

        /* Check true HYBR2 mode pref */
        if(sdss_is_1x_sxlte())
        {
          if(  sdss_get_opr_mode(SD_SS_HYBR_2) == SDSS_OPR_MODE_ONLINE
               &&
               SD_MODE_CONTAIN( mode_capability,
                                sdss_map_mode_to_mode_pref(mode_pref))
               &&
               SD_MODE_CONTAIN( sdss_get_true_mode_pref( SD_SS_HYBR_2 ),
                                sdss_map_mode_to_mode_pref(mode_pref)) )
          {
            return SD_SS_HYBR_2;
          }
        }

        /* Check true HYBR3 mode pref */
        if( sdss_get_opr_mode(SD_SS_HYBR_3) == SDSS_OPR_MODE_ONLINE &&
            SD_MODE_CONTAIN( mode_capability,
                             sdss_map_mode_to_mode_pref(mode_pref))
            &&
            SD_MODE_CONTAIN( sdss_get_true_mode_pref( SD_SS_HYBR_3 ),
                             sdss_map_mode_to_mode_pref(mode_pref)) )
        {
          return SD_SS_HYBR_3;
        }
        
        return SD_SS_MAX;
      }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SD_MODE_HDR:
      {
        sd_ss_mode_pref_e_type  mode_pref_main   = SD_SS_MODE_PREF_NONE;
        #ifdef FEATURE_HDR_HYBRID
        sd_ss_mode_pref_e_type  mode_pref_hybr_1 = SD_SS_MODE_PREF_NONE;
        sd_ss_band_pref_e_type  band_pref_hybr_1 = SD_SS_BAND_PREF_ANY;
        sd_ss_mode_pref_e_type  new_supp_mode_pref = SD_SS_MODE_PREF_ANY;
          sd_ss_band_pref_e_type  new_supp_band_pref = SD_SS_BAND_PREF_ANY;
        #endif

        sdss_get_mode_band_pref( SD_SS_MAIN,
                                 &mode_pref_main,
                                 NULL,
                                 NULL,
                                 NULL );

        if( SD_MODE_CONTAIN( mode_pref_main,
                             sdss_map_mode_to_mode_pref(mode_pref))
            &&
            sdss_is_hybr_pref( SD_SS_MAIN, SD_SS_HYBR_PREF_NONE ) )
        {
          return SD_SS_MAIN;
        }
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        #ifdef FEATURE_HDR_HYBRID
        if(  !sdss_is_hybr_pref( SD_SS_MAIN, SD_SS_HYBR_PREF_NONE ) )
        {
          sdss_get_mode_band_pref( SD_SS_HYBR_1,
                                   &mode_pref_hybr_1,
                                   &band_pref_hybr_1,
                                   NULL,
                                   NULL );

          sd_misc_get_band_mode( &new_supp_mode_pref, &new_supp_band_pref,
                                 mode_pref_hybr_1, band_pref_hybr_1
                             );
          /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

          if( SD_MODE_CONTAIN( new_supp_mode_pref,
                               sdss_map_mode_to_mode_pref(mode_pref)))
          {
            //PRL should also have HDR systems
            if (sd_misc_is_supp_pref(new_supp_mode_pref,new_supp_band_pref))
            {
            return SD_SS_HYBR_1;
            }
          }
        }
        #endif

        return SD_SS_MAX;
      }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SD_MODE_NONE:
    case SD_MODE_INACT:
    case SD_MODE_MAX:
    default:
      SD_ERR_1( "mode_pref %d",mode_pref);
      return SD_SS_MAX;
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  }

} /* sdss_get_ss_for_mode */

#ifdef FEATURE_NON_DEMAND_PAGED_FUNCTION
#error code not present
#endif




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_get_orig_mode

DESCRIPTION
   Fetches the origination mode preferences from SD System selection core.

DEPENDENCIES
  None.

RETURN VALUE
  Origination mode.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sd_ss_orig_mode_e_type     sdss_get_orig_mode(

        sd_ss_e_type               ss
            /* System selection stack.
            */

)
{
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return ( sdss_ptr( ss )->orig_mode );


} /* sdss_get_orig_mode */

/*===========================================================================

FUNCTION sdss_reset_is_dds_switchback_from_temp

DESCRIPTION
   Resets the boolean is_dds_switchback_from_temp after event
   processing.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void     sdss_reset_is_dds_switchback_from_temp(

        sd_ss_e_type               ss
            /* System selection stack.
            */

)
{
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if(sdss_ptr(ss)->is_dds_switchback_from_temp == TRUE)
  {
    SD_MSG_HIGH_0("is_dds_switchback_from_temp was TRUE, resetting to FALSE");
  }
  sdss_ptr(ss)->is_dds_switchback_from_temp = FALSE;
  
} /* sdss_reset_is_dds_switchback_from_temp */

/*===========================================================================

FUNCTION sdss_is_trm_unlock_in_progress

DESCRIPTION
  Return the value for is_trm_unlock_in_progress.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if is_trm_unlock_in_progress = 1
  FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
static boolean  sdss_is_trm_unlock_in_progress(

    sd_ss_e_type          ss
    /* The System selection stack
    */
)
{
  return sdss_ptr(ss)->is_trm_unlock_in_progress;
}

/*===========================================================================

FUNCTION sdss_is_trm_available

DESCRIPTION
  TRM is not available if all the folloiwng conditions are met:
  1. acq_status is no resource. 
    (LTE service lost TRM is allocated to other tech for voice call)
  2. pref_update_reason is not TRM. 
  3. TRM unlock is not in progress.
  Otherwise, TRM is considered as available.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if update reason is TRM unlock or TRM unlock is in progress
  FALSE otherwise

SIDE EFFECTS
  None.

===========================================================================*/
boolean sdss_is_trm_available(

  sd_ss_e_type          ss
  /* The System selection stack
  */
)
{
  boolean result = TRUE;
  sys_acq_status_e_type acq_status = sdss_get_acq_status_only(ss);
  
  if(acq_status == SYS_ACQ_STATUS_NO_RESOURCE)
  {
    boolean is_pref_update_reason_trm_unlock 
      = sdss_is_pref_update_reas(ss, SD_SS_PREF_UPDATE_REASON_TRM_UNLOCK);
    boolean is_trm_unlock_in_progress = sdss_is_trm_unlock_in_progress(ss);

    SD_MSG_HIGH_2("COND_TRM_AVAIL: is_pref_update_reason_trm_unlock %d, is_trm_unlock_in_progress %d",
                    is_pref_update_reason_trm_unlock,
                    is_trm_unlock_in_progress
                   );
  
    if(is_pref_update_reason_trm_unlock || is_trm_unlock_in_progress)
    {
      result = TRUE;
    }
    else
    {
      result = FALSE;
    }
  }
  return result;
}

/*===========================================================================

FUNCTION sdss_update_is_trm_unlock_in_progress

DESCRIPTION
Update is_trm_unlock_in_progress of the ss core.
  - Set is_trm_unlock_in_progress =1 upon receiving pref_update reason 
    = SD_SS_PREF_UPDATE_REASON_TRM_UNLOCK and acq_status = no resource.
  - Reset is_trm_unlock_in_progress = 0 when acq_status is updated upon 
    receiving service cnf from NAS.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static void   sdss_update_is_trm_unlock_in_progress(
              sd_ss_e_type            ss,
              /* System selection stack
              */
              boolean                 is_trm_unlock_in_progress
)
{
  sdss_s_type   *ss_ptr   = sdss_ptr(ss);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( ss_ptr != NULL );
  if(ss_ptr->is_trm_unlock_in_progress != is_trm_unlock_in_progress)
  {
    SD_MSG_HIGH_2("Update ss= %d, is_trm_unlock_in_progress =%d",
                    ss,is_trm_unlock_in_progress);
    ss_ptr->is_trm_unlock_in_progress = is_trm_unlock_in_progress;
  }
}

/*===========================================================================

FUNCTION sdss_get_prev_sys_info

DESCRIPTION
   Fetches the previous association tag from SD System selection core.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sdss_sys_addn_info_s_type*     sdss_get_prev_sys_info(

        sd_ss_e_type                  ss
            /* System selection stack.
            */

)
{
  sdss_s_type   *ss_ptr   = sdss_ptr( ss );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT(ss != SD_SS_MAX);
  SD_ASSERT(ss_ptr != NULL);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return ( &(ss_ptr->prev_sys_info) );


} /* sdss_get_prev_sys_info */

/*===========================================================================

FUNCTION sdss_addn_sys_info_init

DESCRIPTION
   Initialize the aditional sys info structure..

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                          sdss_addn_sys_info_init(

        sdss_sys_addn_info_s_type*    sys_info
            /* aditional sys info pointer.
            */

)
{

  SD_ASSERT(sys_info != NULL);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  sys_info->assn_tag   = SDSS_ASSN_TAG_NONE;
  sys_info->geo_offset = SDSS_GEO_OFFSET_NONE;
  sys_info->geo_count  = SDSS_GEO_COUNT_NONE;

} /* sdss_addn_sys_info_init */

/*===========================================================================

FUNCTION sdss_set_prev_sys_info

DESCRIPTION
   Sets the previous association tag from SD System selection core.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                       sdss_set_prev_sys_info(

        sd_ss_e_type               ss,
            /* System selection stack.
            */

        const byte                 assn_tag,
           /* The Association Tag value.
           */
        const int                  geo_offset,
            /* Pointer to system record's geo.
            */
        const int                  multi_geo_count
            /* Pointer to the counter, for counting geo's
            ** in a multi-geo scenario.
            */

)
{
  sdss_s_type   *ss_ptr   = sdss_ptr( ss );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT(ss != SD_SS_MAX);
  SD_ASSERT(ss_ptr != NULL);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Set the Association tag in the SS State.
  */
  ss_ptr->prev_sys_info.assn_tag = assn_tag;
  ss_ptr->prev_sys_info.geo_offset = geo_offset;
  ss_ptr->prev_sys_info.geo_count = multi_geo_count;

} /* sdss_set_prev_sys_info */



/* <EJECT> */
/*===========================================================================

FUNCTION sdss_update_is_mmss_operation

DESCRIPTION
  Update the MMSS operation flag , based on whether the equivalent PRL
  was generated successfully or not

DEPENDENCIES


RETURN VALUE
  NONE

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                            sdss_update_is_mmss_operation(

        sd_ss_e_type                     ss,
            /* System selection stack.
            */

        boolean                         is_mmss_operation
           /* Pointer to return the condition true flag.
           */
)
{

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  sdss_ptr(ss)->is_mmss_operation = is_mmss_operation;
  SD_MSG_HIGH_2("MMSS: ss %d op state %d", ss, is_mmss_operation);
  return;

}/* sdss_update_is_mmss_operation */



/* <EJECT> */
/*===========================================================================

FUNCTION sdss_is_mmss_operation

DESCRIPTION
  Returns MMSS operation flag , based on whether the equivalent PRL
  was generated successfully or not

DEPENDENCIES


RETURN VALUE
  NONE

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean                       sdss_is_mmss_operation(

        sd_ss_e_type                  ss
            /* System selection stack
            */
)
{

  return sdss_ptr(ss)->is_mmss_operation;

}/* sdss_is_mmss_operation */


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_update_c2k_alt_algr_operation

DESCRIPTION
  Update the C2K ALT ALGR operation flag , based on whether the NV item
  is set of not

DEPENDENCIES


RETURN VALUE
  NONE

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                            sdss_update_c2k_alt_algr_operation(

        boolean                         is_c2k_alt_algr
           /* Pointer to return the condition true flag.
           */
)
{

  sdss_common.is_c2k_alt_algr = is_c2k_alt_algr;
  SD_MSG_HIGH_1("C2K ALT ALGR: op state %d",is_c2k_alt_algr);

  return;

}/* sdss_update_c2k_alt_algr_operation */


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_is_c2k_alt_algr_operation

DESCRIPTION
  Returns C2K ALT ALGR operation flag , based on whether the NV Item is set
  ot not

DEPENDENCIES


RETURN VALUE
  NONE

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean            sdss_is_c2k_alt_algr_operation( void )
{

  return sdss_common.is_c2k_alt_algr;

}/* sdss_is_c2k_alt_algr_operation */


/* <EJECT> */
/*===========================================================================

FUNCTION  sdss_get_rat_acq_order

DESCRIPTION
   Fetch the current rat acq order from the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sd_rat_acq_order_s_type       sdss_get_rat_acq_order(

        sd_ss_e_type                  ss
            /* System selection stack
            */
)
{
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  return  sdss_ptr(ss )->rat_acq_order;
} /* sdss_get_rat_acq_order */


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_get_acc_prm

DESCRIPTION
   Fetch the current access related parameters from the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                        sdss_get_acc_prm(

        sd_ss_e_type                ss,
            /* System selection stack.
            */
        byte                       *rtrn_acc_reas_ptr,
            /* Pointer to a buffer where to deposit the access reason.
            */

        byte                       *rtrn_acc_term_ptr
            /* Pointer to a buffer where to deposit the access termination.
            */
)
{
  const sdss_s_type   *ss_ptr   = sdss_ptr( ss );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  SD_ASSERT( rtrn_acc_reas_ptr != NULL );
  SD_ASSERT( rtrn_acc_term_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Copy over the access reason and termination.
  */
  *rtrn_acc_reas_ptr = (byte)ss_ptr->acc_reas;
  *rtrn_acc_term_ptr = (byte)ss_ptr->acc_term;

} /* sdss_get_acc_prm */


/*===========================================================================
FUNCTION sdss_get_srv_req_type

DESCRIPTION
  Get the service request type in SS as indicated.

DEPENDENCIES
  None.

RETURN VALUE
  None

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sd_ss_srv_req_type_e_type     sdss_get_srv_req_type (

        sd_ss_e_type                  ss
          /* System selection stack
          */
)
{
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  return sdss_ptr(ss)->srv_req_type;
}

/*===========================================================================
FUNCTION sdss_set_srv_req_type

DESCRIPTION
  Set the service request type in SS as indicated.

DEPENDENCIES
  None.

RETURN VALUE
  None

SIDE EFFECTS
  None.

===========================================================================*/
/*lint --e{528} suppress sdss_set_srv_req_type not referenced
** warning
*/
EXTERN  void                          sdss_set_srv_req_type (

        sd_ss_e_type                  ss,
          /* System selection stack
          */

        sd_ss_srv_req_type_e_type     req_type
)
/*lint -esym(715,ss_ptr) */
/*lint -esym(818,ss_ptr) */
/*lint -esym(715,req_type) */
{
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( req_type, SD_SS_SRV_REQ_TYPE_MAX );

  SD_MSG_HIGH_2("SDSS:FRFL: Updating ss= %d srv_req_type= %d",ss,req_type);
  sdss_ptr(ss)->srv_req_type = req_type;
  return;
}
/*lint +esym(715,ss_ptr) */
/*lint +esym(818,ss_ptr) */
/*lint +esym(715,req_type) */
/*lint +esym(528,sdss_set_srv_req_type) */
#if defined(SD_GSM_SUPPORTED) || defined(SD_WCDMA_SUPPORTED) || defined( FEATURE_SD_LTE )
/* <EJECT> */
/*===========================================================================

FUNCTION sdss_get_sim_state

DESCRIPTION
   Fetches the current sim state from SD System selection core.

DEPENDENCIES
  None.

RETURN VALUE
  Current sim state.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sys_sim_state_e_type    sdss_get_sim_state(

        sd_ss_e_type            ss
          /* System selection stack
          */
)
{

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return (sdss_ptr(ss)->sim_state);

} /* sdss_get_sim_state */




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_update_sim_state

DESCRIPTION
   Updates the current SIM state of the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                          sdss_update_sim_state(

        sys_sim_state_e_type          sim_state,
           /* New SIM state reported from REG.
           */

        sd_ss_e_type                  ss
          /* System selection stack
          */
)
{
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( sim_state, SYS_SIM_STATE_MAX );
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_MSG_HIGH_2("SDSS:FRFL: Updating ss= %d sim_state = %d",ss,sim_state);
  sdss_ptr(ss)->sim_state = sim_state;

} /* sdss_update_sim_state */

/*===========================================================================

FUNCTION sdss_adjust_sim_state_pwr_down

  Adjusts sim state based on GWL subscriptions on LPM.
  incase SIM state was marked as CS/PS invalid due to network reject.

===========================================================================*/
static void sdss_adjust_sim_state_pwr_down
(
  sd_ss_e_type ss
)
{
  boolean is_gwl_subsc_avail = FALSE;
  sdss_s_type *ss_ptr = sdss_ptr(ss);

  if(ss == SD_SS_MAIN)
  {
    is_gwl_subsc_avail = ss_ptr->is_gw_subsc_avail;
  }
  else if(ss == SD_SS_HYBR_2 &&
          sdss_is_featuremode(SYS_OVERALL_FEATURE_MODE_MULTISIM))
  {
    is_gwl_subsc_avail = ss_ptr->is_gw2_subsc_avail;
  }
  else if(ss == SD_SS_HYBR_3 &&
          sdss_is_featuremode(SYS_OVERALL_FEATURE_MODE_MULTISIM))
  {
    is_gwl_subsc_avail = ss_ptr->is_gw3_subsc_avail;
  }

  if( is_gwl_subsc_avail &&
      ( ( sdss_get_sim_state(ss)== SYS_SIM_STATE_PS_INVALID ) ||
        ( sdss_get_sim_state(ss)== SYS_SIM_STATE_CS_INVALID ) ) )
  {
    if(sdss_is_1x_sxlte()  && ss != SD_SS_HYBR_3)
    {
      sd_si_update_sim_state( SYS_SIM_STATE_AVAILABLE, SD_SS_MAIN );
      sd_si_update_sim_state( SYS_SIM_STATE_AVAILABLE, SD_SS_HYBR_2 );
    }
    else
    {
      sd_si_update_sim_state( SYS_SIM_STATE_AVAILABLE, ss );
    }
  }
}

/*===========================================================================

FUNCTION sdss_update_acq_status

DESCRIPTION
Update acq_status of the ss core.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void sdss_update_acq_status(
              sd_ss_e_type            ss,
          /* System selection stack
          */
              sys_acq_status_e_type  acq_status
)
{
  sdss_s_type   *ss_ptr   = sdss_ptr(ss);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( ss_ptr != NULL );

  /* Reset is_trm_unlock_in_progress flag upon receiving the new acq status */
  if(ss_ptr->is_trm_unlock_in_progress)
  {
    sdss_update_is_trm_unlock_in_progress(ss, FALSE);
  }
  
  if(ss_ptr->acq_status != acq_status)
  {
    SD_MSG_HIGH_2("Update ss= %d, acq_status =%d",ss,acq_status);
    ss_ptr->acq_status = acq_status;
  }
}

/*===========================================================================

FUNCTION sdss_update_gwl_scan_status

DESCRIPTION
   Updates the GWL scan status of the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                  sdss_update_gwl_scan_status(

        sd_ss_e_type  ss,
           /*  System selection stack
           */

        sd_ss_gwl_scan_status_e_type    scan_status
           /* Scan status, did the scan complete or it was aborted due to
           ** timer expiry
           */
)
/*lint -esym(715,ss) */
{

  #if defined(FEATURE_EOOS_UMTS) || defined(FEATURE_MMODE_SXLTE_G)
  sdss_s_type   *ss_ptr   = sdss_ptr(ss);
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  #ifdef FEATURE_EOOS_UMTS
  if( !ss_ptr->acq_gwl_use_timer )
  {
    ss_ptr->acq_gwl_scan_status = SD_SS_GWL_SCAN_STATUS_NONE;
    ss_ptr->acq_gwl_new_acq     = TRUE;
    return;
  }
  #endif
  
  /* if feature mode is SXLTE+G (multi-sim)
     and subfeature mode is SVLTE or EOOS is defined,
     update acq_gwl_scan_status
  */
  #ifdef FEATURE_MMODE_SXLTE_G
  if(sdss_is_sfmode_svlte(0) && 
    sdss_is_featuremode(SYS_OVERALL_FEATURE_MODE_MULTISIM) && 
    ss == SD_SS_HYBR_2)
  {
    ss_ptr->acq_gwl_scan_status = scan_status;
  }
  #endif
  
  #ifdef FEATURE_EOOS_UMTS
  ss_ptr->acq_gwl_scan_status = scan_status;
  if( ss_ptr->acq_gwl_scan_status != SD_SS_GWL_SCAN_STATUS_ABORTED )
  {
    ss_ptr->acq_gwl_new_acq = TRUE;
  }
  else
  {
    ss_ptr->acq_gwl_new_acq = FALSE;
  }
  #endif
  return;
}
/*lint +esym(715,ss) */



#endif /* SD_GSM_SUPPORTED || SD_WCDMA_SUPPORTED */

/*===========================================================================

FUNCTION sdss_get_session_info

DESCRIPTION
   Updates the current MMGSDI session info to  the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  mmgsdi_app_enum_type          sdss_get_session_info (

        sd_ss_e_type                  ss
            /* System selection stack.
            */
)
{

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX);
  return sdss_ptr(ss)->gwl_app_type;

} /* sdss_get_session_info */

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_misc_update_session_info

DESCRIPTION
   Updates the current MMGSDI session info to  the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                          sdss_misc_update_session_info (

        sd_ss_e_type                  ss,
            /* System selection stack.
            */

        mmgsdi_app_enum_type          app_type
          /* MMGSDI app type */
)
{

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX);
  /* If APP type is SIM or USIM or NONE, update the  gwl_app_type
  ** In other cases (CSIM/RUIM) no need of updating gwl_app_type
  */
  if( app_type == MMGSDI_APP_NONE ||
      app_type == MMGSDI_APP_SIM  ||
      app_type == MMGSDI_APP_USIM
    )
  {
    SD_MSG_HIGH_2("SDSS:FRFL: Updating  ss= %d, GWL app_type =%d ",ss,app_type);
    sdss_ptr(ss)->gwl_app_type = app_type;
  }

} /* sdss_misc_update_session_info */

#ifdef FEATURE_EOOS
#error code not present
#endif

/*===========================================================================

FUNCTION sdss_update_srv_status

DESCRIPTION
   Updates the current service status of the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                  sdss_update_srv_status(

        sd_ss_e_type          ss,
            /* System selection stack.
            */

        sys_srv_status_e_type srv_status,
            /* New service status.
            */

        sys_srv_domain_e_type srv_domain
            /* New srv domain.
            */
)
{
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( srv_status, SYS_SRV_STATUS_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( srv_domain, SYS_SRV_DOMAIN_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_CRIT_SECT_ENTER();
  sdss_ptr( ss )->srv_status = srv_status;
  sdss_ptr( ss )->srv_domain = srv_domain;
  SD_CRIT_SECT_EXIT();

} /* sdss_update_srv_status */

/*===========================================================================

FUNCTION sdss_read_srv_status

DESCRIPTION
   Reads the current service status of the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                  sdss_read_srv_status(

        sd_ss_e_type          ss,
            /* System selection stack.
            */

        sys_srv_status_e_type *srv_status,
            /* New service status.
            */

        sys_srv_domain_e_type *srv_domain
            /* New srv domain.
            */
)
{
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_CRIT_SECT_ENTER();
  if( srv_status != NULL )
  {
    *srv_status = sdss_ptr( ss )->srv_status ;
  }
  if( srv_domain != NULL )
  {
    *srv_domain = sdss_ptr( ss )->srv_domain ;
  }
  SD_CRIT_SECT_EXIT();

} /* sdss_read_srv_status */


/*===========================================================================

FUNCTION sdss_update_nas_addl_info

DESCRIPTION
   Updates the lte_cs_capability of the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void             sdss_update_nas_addl_info(

        sd_ss_e_type     ss,
        /* System selection stack.*/

        sys_lte_cs_capability_e_type lte_cs_capability,
        /* LTE CS capability */

        sys_extend_srv_info_e_type ext_srv_info
        /* Extended service info */
)
{
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_MSG_HIGH_3("SDSS:FRFL: Updating core ss= %d, lte_cs_cap= %d ext_srv_info =%d",
             ss,lte_cs_capability,ext_srv_info);

  SD_CRIT_SECT_ENTER();
  if( lte_cs_capability == SYS_LTE_CS_CAPABILITY_NONE )
  {  
     sdss_ptr( ss )->lte_cs_capability = sdss_get_lte_cs_cap();
  }
  else 
  {
	/*Global CS cap will later be updated in sd_si_update to ensure
	  changed fields are sent to CM callback */
	 sdss_ptr( ss )->lte_cs_capability = lte_cs_capability;
  }
  sdss_ptr( ss )->ext_srv_info      = ext_srv_info;
  SD_CRIT_SECT_EXIT();

} /* sdss_update_nas_addl_info */


/**===========================================================================

@FUNCTION sdss_reset_nas_addl_info

@DESCRIPTION
 Reset the lte cs capbility of the SS-Core.
@DEPENDENCIES
  None.
@RETURN VALUE
  None.

@SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void  sdss_reset_nas_addl_info(

       sd_ss_e_type     ss
       /* System selection stack.
       */
)
{
  sdss_s_type   *ss_ptr   = sdss_ptr( ss );
  SD_MSG_HIGH_1(" reset SS lte cs cap %d",ss);

  SD_CRIT_SECT_ENTER();
  ss_ptr->lte_cs_capability = SYS_LTE_CS_CAPABILITY_NONE;
  ss_ptr->ext_srv_info      = SYS_EXTEND_SRV_INFO_NONE;
  SD_CRIT_SECT_EXIT();
}

/*===========================================================================

@FUNCTION sdss_reset_loc_bsr

@DESCRIPTION
 Reset the location based BSR flag upon LPM/RESET/PWROFF.
@DEPENDENCIES
  None.
@RETURN VALUE
  None.

@SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void  sdss_reset_loc_bsr(void)
{
  sdss_s_type   *ss_ptr ;
  sd_ss_e_type  lte_ss = sd_misc_get_ss_for_mode(SYS_SYS_MODE_LTE);

  if(lte_ss != SD_SS_MAX)
  {
    ss_ptr = sdss_ptr( lte_ss );
	
    SD_MSG_HIGH_1("reset loc bsr on ss=%d",lte_ss);
    ss_ptr->is_loc_based_bsr = FALSE;
    ss_ptr->is_loc_chg_move_out = FALSE;
  }
}

/**===========================================================================
@FUNCTION sdss_get_lte_cs_capability

@DESCRIPTION
Returns the lte_cs_capability of the SS-Core.

@DEPENDENCIES
  None.

@RETURN VALUE
  None.

@SIDE EFFECTS
  None.
===========================================================================*/
EXTERN void  sdss_get_nas_addl_info(

       sd_ss_e_type     ss,
       /* System selection stack.
       */

       sys_lte_cs_capability_e_type *lte_cs_capability,
       /* LTE CS capability */

       sys_extend_srv_info_e_type *ext_srv_info
       /* extended service info */

)
{
  sdss_s_type   *ss_ptr   = sdss_ptr( ss );

  *lte_cs_capability = ss_ptr->lte_cs_capability;

  *ext_srv_info      = ss_ptr->ext_srv_info;
}

/*===========================================================================

FUNCTION sdss_reset_attach_pending

DESCRIPTION
   Reset the ext_srv_info of the SS-Core if it is pending on attach complete ack.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void             sdss_reset_attach_pending(

        sd_ss_e_type     ss
        /* System selection stack.*/
)
{
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_MSG_HIGH_2("SDSS: reset attach pending, ss=%d, current extend_srv_info=%d", 
                   ss, sdss_ptr( ss )->ext_srv_info);

  SD_CRIT_SECT_ENTER();
  if( sdss_ptr( ss )->ext_srv_info == SYS_EXTEND_SRV_INFO_REG_COMP_ACK_PENDING )
  {
    sdss_ptr( ss )->ext_srv_info = SYS_EXTEND_SRV_INFO_NONE;
  }
  SD_CRIT_SECT_EXIT();

} /* sdss_update_nas_addl_info */

/*===========================================================================

FUNCTION sdss_update_lte_connected_mode

DESCRIPTION
   Update the LTE Connected mode in a secure manner in critical section.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void             sdss_update_lte_connected_mode(

       sd_ss_e_type     ss,
        /* System selection stack.
        */

       dword            lte_conn_mode_uptime,

       boolean          lte_in_conn_mode
)
{
  sdss_s_type   *ss_ptr   = NULL;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  ss_ptr = sdss_ptr(ss);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_MSG_HIGH_3("SDSS:FRFL: Updating ss= %d, conn_mode= %d, uptime= %d",ss,
                                     lte_in_conn_mode,lte_conn_mode_uptime);
  #ifdef LTE_CONN_MODE_OPT
  ss_ptr->lte_conn_mode_uptime = lte_conn_mode_uptime;
  ss_ptr->lte_in_conn_mode     = lte_in_conn_mode;
  #else
  ss_ptr->lte_in_conn_mode     = lte_in_conn_mode;
  SYS_ARG_NOT_USED( lte_conn_mode_uptime );
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
}

/*===========================================================================

FUNCTION sdss_read_lte_connected_mode

DESCRIPTION
   Retrieve the LTE Connected mode in a secure manner in critical section.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void             sdss_read_lte_connected_mode(

       sd_ss_e_type     ss,
       /* System selection stack.*/

 const dword            *lte_conn_mode_uptime,

       boolean          *lte_in_conn_mode
)
{
  sdss_s_type   *ss_ptr   = NULL;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  ss_ptr = sdss_ptr(ss);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #ifdef LTE_CONN_MODE_OPT
  *lte_conn_mode_uptime = ss_ptr->lte_conn_mode_uptime;
  *lte_in_conn_mode     = ss_ptr->lte_in_conn_mode;
  #else
  *lte_in_conn_mode     = ss_ptr->lte_in_conn_mode;
  SYS_ARG_NOT_USED( lte_conn_mode_uptime );
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
}


/*===========================================================================

FUNCTION sdss_read_wcdma_connected_mode

DESCRIPTION
   Retrieve the WCDMA Connected mode in a secure manner in critical section.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void             sdss_read_wcdma_connected_mode(

       sd_ss_e_type     ss,
       /* System selection stack.*/

       dword            *wcdma_conn_mode_uptime,

       boolean          *wcdma_in_conn_mode
)
{
  #if defined ( FEATURE_WRLF_SYSTEM_SEL)

  sdss_s_type   *ss_ptr   = NULL;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  ss_ptr = sdss_ptr(ss);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  *wcdma_conn_mode_uptime = ss_ptr->wcdma_suitable_search_time;
  *wcdma_in_conn_mode     = ss_ptr->wcdma_in_conn_mode;
  
  #endif
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
}

/*===========================================================================

FUNCTION sdss_update_is_full_srv_req_during_emerg

DESCRIPTION
   Update the is_full_srv_req_during_emerg flag

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void             sdss_update_is_full_srv_req_during_emerg(

       sd_ss_e_type     ss,
        /* System selection stack.
        */

       boolean          is_full_srv_req_during_emerg
)
{
  sdss_s_type   *ss_ptr   = NULL;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  ss_ptr = sdss_ptr(ss);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_MSG_HIGH_2("SDSS: Updating ss= %d, is_full_srv_req_during_emerg= %d",ss,
                                     is_full_srv_req_during_emerg);
  ss_ptr->is_full_srv_req_during_emerg = is_full_srv_req_during_emerg;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
}

/*===========================================================================

FUNCTION sdss_get_is_full_srv_req_during_emerg

DESCRIPTION
   Get the is_full_srv_req_during_emerg flag

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN boolean            sdss_get_is_full_srv_req_during_emerg(

       sd_ss_e_type     ss
        /* System selection stack.
        */
)
{
  sdss_s_type   *ss_ptr   = NULL;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  ss_ptr = sdss_ptr(ss);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  return ss_ptr->is_full_srv_req_during_emerg;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
}

/*===========================================================================

FUNCTION sdss_is_normal_emerg_orig

DESCRIPTION
   returns whether it is normal emergency origination or not.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN boolean             sdss_is_non_csfb_emerg_orig(

       sd_ss_e_type     ss
        /* System selection stack.
        */

)
{
  sdss_s_type   *ss_ptr   = NULL;
  sd_ss_mode_pref_e_type  mode_pref;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  ss_ptr = sdss_ptr(ss);

  sdss_get_mode_band_pref( ss,
                           &mode_pref,
                           NULL,
                           NULL,
                           NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  if ((ss_ptr->orig_mode == SD_SS_ORIG_MODE_EMERG_ORIG) &&
      !(SD_IS_BIT_CONTAIN (mode_pref ,SD_SS_MODE_PREF_LTE)) &&
      (ss_ptr->pref_reason == SD_SS_PREF_REAS_ORIG_START_CS))
  {
    SD_MSG_HIGH_0("Regular emergency call origination");
    return TRUE;
  }

  if ((ss_ptr->orig_mode == SD_SS_ORIG_MODE_EMERG_ORIG) &&
      (SD_IS_BIT_CONTAIN (mode_pref ,SD_SS_MODE_PREF_LTE)) &&
      (ss_ptr->pref_reason == SD_SS_PREF_REAS_ORIG_START_CS))
  {
    SD_MSG_HIGH_0("VOLTE emergency call origination");
    return TRUE;
  }

  return FALSE;
}

/*===========================================================================

FUNCTION sdss_is_ppcsfb_emerg_orig

DESCRIPTION
   Returns whether it is 3GPPCSFB  emergency origination or not.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN boolean            sdss_is_ppcsfb_emerg_orig(

       sd_ss_e_type     ss
        /* System selection stack.
        */

)
{
  sdss_s_type   *ss_ptr   = NULL;
  sd_ss_mode_pref_e_type  mode_pref;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  ss_ptr = sdss_ptr(ss);

  sdss_get_mode_band_pref( ss,
                           &mode_pref,
                           NULL,
                           NULL,
                           NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  if ((ss_ptr->orig_mode == SD_SS_ORIG_MODE_PPCSFB_EMERG_ORIG) &&
      (SD_IS_BIT_CONTAIN (mode_pref ,SD_SS_MODE_PREF_LTE)) &&
      (ss_ptr->pref_reason == SD_SS_PREF_REAS_ORIG_START_CS))
  {
    SD_MSG_HIGH_0("PPCSFB emergency call origination");
    return TRUE;
  }

  return FALSE;
}

/*===========================================================================

FUNCTION sdss_is_full_srv_req_for_emerg_orig()

DESCRIPTION
  Indicates whether FULL srv is required for emergency origination if
  1. Emergency call is in orig state 
  2. Target capability is 3gpp only and
  3. NV full_srv_req_in_emerg is set and
  4. When 3gpp sim state in available and 
  5. UE is not in LTE only mode of operation before 911 call orig

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN boolean   sdss_is_full_srv_req_for_emerg_orig(

       sd_ss_e_type     ss
        /* System selection stack.
        */

)
{
  sdss_s_type   *ss_ptr   = sdss_ptr(ss);
  boolean       is_lte_in_idl_rat_pri_list = FALSE;
  uint8         i;
  boolean ret_val = FALSE;
  sys_srv_status_e_type    ss_srv_status     = SYS_SRV_STATUS_NONE;

  if(sdss_ptr(ss)->idle_rat_pri_list_info.num_items == 1)
  {
    for(i =0; i < sdss_ptr(ss)->idle_rat_pri_list_info.num_items; ++i)
    {
      if(sdss_ptr(ss)->idle_rat_pri_list_info.priority_list_info[i].acq_sys_mode == SYS_SYS_MODE_LTE)
      {
        is_lte_in_idl_rat_pri_list = TRUE;
        break;
      }
      
    }
  }
  

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* 1.  Emergency call is in orig state 
   ** 2. 3gpp only target and
   ** 3. when full_srv_req_in_emerg NV is set
   ** 4. 3gpp sim state is valid allow full service for NAS to perform RAU on PS service. 
   */
  if ((sdss_is_ppcsfb_emerg_orig(ss) ||
       sdss_is_non_csfb_emerg_orig(ss)) &&
       sdss_is_target_cap_3gpp_only(ss) &&
       (sdss_get_cfg_full_srv_req_in_emerg(ss)||
       sdss_get_cfg_emerg_call_after_lu_in_lpm()))
  {
    if ( ss_ptr->sim_state != SYS_SIM_STATE_NOT_AVAILABLE &&
         ss_ptr->sim_state != SYS_SIM_STATE_CS_PS_INVALID )
    {
   /* 5. If LTE is not part of emergencyr RAT pri list and idle mode had LTE only do pure limited service request
     ** on G/W/T. Full service is not required here as UE is in LTE only mode. This is to be bypassed for wifi_e911_wwan_full_srv 
     */
      if ( !SD_MODE_CONTAIN(SD_SS_MODE_PREF_LTE, ss_ptr->mode_pref) && is_lte_in_idl_rat_pri_list && !sdss_is_wifi_e911_wwan_full_srv(ss) )
  {
        SD_MSG_HIGH_0("UE in LTE only mode during e911 orig");
        ret_val = FALSE;
      }
      else
      {
        ret_val = TRUE;
      }
  }
  }

  /* if wifi_e911_wwan_full_srv is enabled, and UE is camped on limited service then do not set full srv req flag as TRUE 
  ** as in this case, call has to be placed over limited service */
  
  sdss_read_srv_status( ss, &ss_srv_status, NULL );
  if(sdss_is_wifi_e911_wwan_full_srv(ss) && sys_srv_status_is_lmtd_srv(ss_srv_status))
  {
    ret_val = FALSE;
  }

  return ret_val;
}

/*===========================================================================

FUNCTION sdss_update_RLF_during_emerg

DESCRIPTION
   Update the is_RLF_during_emerg flag

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void             sdss_update_is_RLF_during_emerg(

       sd_ss_e_type     ss,
        /* System selection stack.
        */

       boolean          is_RLF_during_emerg
)
{
  sdss_s_type   *ss_ptr   = NULL;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  ss_ptr = sdss_ptr(ss);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_MSG_HIGH_2("SDSS: Updating ss= %d, is_RLF_during_emerg= %d",ss,
                                     is_RLF_during_emerg);
  ss_ptr->is_RLF_during_emerg = is_RLF_during_emerg;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
}

/*===========================================================================

FUNCTION sdss_get_is_RLF_during_emerg

DESCRIPTION
   Retrieve the is_RLF_during_emerg flag

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN boolean             sdss_get_is_RLF_during_emerg(

       sd_ss_e_type     ss
)
{
  sdss_s_type   *ss_ptr   = NULL;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  ss_ptr = sdss_ptr(ss);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


  return  ss_ptr->is_RLF_during_emerg;


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
}

/*===========================================================================

FUNCTION sdss_reset_lte_connected_mode

DESCRIPTION
   Resets the LTE Connected mode

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void             sdss_reset_lte_connected_mode(

       sd_ss_e_type     ss
         /* System selection stack.*/
)
{
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  sdss_update_lte_connected_mode(ss,0, FALSE);
  sdss_update_is_RLF_during_emerg( ss,FALSE);
  sdss_check_reset_emerg_rat_pri_list_info(ss);
}

/*===========================================================================

FUNCTION sdss_set_lte_connected_mode

DESCRIPTION
   Updates the settings related to the LTE Connected mode

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void                           sdss_set_lte_connected_mode(

        sd_ss_e_type                  ss,
           /*  System selection stack
           */

        dword                         connected_time
            /* T311 timer passed in from the network to indicate the duration
               of the connected mode.
            */
)
{
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  /* Range checking on the time out value. This boundary has been chosen
  ** arbitrarily
  */
  SD_MSG_HIGH_1("SDSS:FRFL: Update lte conn uptime = %d",connected_time);

  if (connected_time > 30000 || connected_time == 0)
  {
    sdss_reset_lte_connected_mode(ss);
  }
  else
  {
    sdss_update_lte_connected_mode( ss,
                                    connected_time + time_get_uptime_secs(),
                                    TRUE );
  }

}

/*===========================================================================

FUNCTION sdss_is_in_connected_mode

DESCRIPTION
Updates whether SD is involved in SD connected mode recovery or not

DEPENDENCIES
  None.

RETURN VALUE
 TRUE/FALSE

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN boolean sdss_is_in_connected_mode (sd_ss_e_type ss)
{

  boolean   in_conn_mode = FALSE;

  #if defined(FEATURE_CM_LTE)
  in_conn_mode = sdss_is_lte_connected_mode(ss);
  #endif

  #if defined(FEATURE_WRLF_SYSTEM_SEL)
  in_conn_mode |= sdss_is_wcdma_connected_mode(ss);
  #endif

  SYS_ARG_NOT_USED(ss)

  return in_conn_mode;
}

/*===========================================================================

FUNCTION sdss_is_lte_connected_mode

DESCRIPTION
   Updates the settings related to the connected mode

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN boolean                        sdss_is_lte_connected_mode (

       sd_ss_e_type                   ss
          /* System selection stack
          */
)
{

  dword     lte_conn_mode_uptime = 0;
  boolean   lte_in_conn_mode     = FALSE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* The NAS always sends a timer T311 when the LTE connected mode begins.
  ** The connected mode ends when NAS sends a dedicated report. An internal
  ** timer may be used if the report does not arrive at all.
  */
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  sdss_read_lte_connected_mode( ss, &lte_conn_mode_uptime, &lte_in_conn_mode);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #ifndef LTE_CONN_MODE_OPT
  return lte_in_conn_mode;
  #else /* LTE_CONN_MODE_OPT */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Future enhancements */
  if (lte_in_conn_mode)
  {
    sdss_get_current_time (timer);
    /* Check the T311 timer as well
    **
    */
    if (timer < lte_conn_mode_uptime)
    {
      /* We are still below the T311 expiry
      **
      */
      return TRUE;
    }
    else
    {
      /* The timer has expired, reset the related fields
      */
      sdss_reset_lte_connected_mode(ss);
      SD_MSG_HIGH_1( "LTE no longer in Conn Mode: int timer %d",timer);
    }
  }
  return FALSE;
  #endif /* LTE_CONN_MODE_OPT */
}

#if defined ( FEATURE_WRLF_SYSTEM_SEL)

/*===========================================================================

FUNCTION sdss_reset_wcdma_connected_mode

DESCRIPTION
   Resets the LTE Connected mode

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void             sdss_reset_wcdma_connected_mode(sd_ss_e_type ss)
{
  sdss_s_type   *ss_ptr   = sdss_ptr( ss );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  SD_ASSERT (ss_ptr);


  ss_ptr->wcdma_suitable_search_time = 0;

  ss_ptr->wcdma_in_conn_mode = FALSE;

}


/*===========================================================================

FUNCTION sdss_reset_wcdma_suitable_search_time

DESCRIPTION
   Resets the LTE Connected mode

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void             sdss_reset_wcdma_suitable_search_time(sd_ss_e_type ss)
{
  sdss_s_type   *ss_ptr   = sdss_ptr( ss );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  SD_ASSERT (ss_ptr);

  ss_ptr->wcdma_suitable_search_time = 0;

}


/*===========================================================================

FUNCTION sdss_set_wcdma_connected_mode

DESCRIPTION
   Updates the settings related to the WCDMA Connected mode

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void             sdss_set_wcdma_connected_mode(

        dword   connected_time,
            /* T311 : time out passed in from the network to indicate
               the duration of the connected mode. Note that value
               of 0 indicates that the UE is no longer in LTE connected
               state.
            */

        sd_ss_e_type ss
            /* System selection stack
            */
)
{
  sdss_s_type   *ss_ptr   = sdss_ptr( ss );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  SD_ASSERT (ss_ptr);

  /* Range checking on the time out value. This boundary has been chosen
  ** arbitrarily
  */
  if (connected_time > 30000 || connected_time == 0)
  {
     ss_ptr->wcdma_suitable_search_time = 0;
     ss_ptr->wcdma_in_conn_mode = FALSE;
  }
  else
  {
     ss_ptr->wcdma_suitable_search_time = connected_time + time_get_uptime_secs()*1000;
     ss_ptr->wcdma_in_conn_mode = TRUE;
     SD_MSG_HIGH_1( "WRLF: Setting suitable search time = %d ",connected_time);
  }

}
/*===========================================================================

FUNCTION sdss_is_wcdma_suitable_search

DESCRIPTION
   Updates the settings related to the connected mode

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN boolean sdss_is_wcdma_suitable_search(sd_ss_e_type ss)
{

   sdss_s_type   *ss_ptr   = sdss_ptr( ss );
   dword timer;

  /* The NAS always sends a timer suitable seach time when the WCDMA connected mode begins.
  ** The connected mode ends when NAS sends a dedicated report. An internal
  ** timer may be used if the report does not arrive at all.
  */

  SD_ASSERT (ss_ptr);

  if (ss_ptr->wcdma_in_conn_mode)
  {
     timer = time_get_uptime_secs ()* 1000;

     /* Check the suitable search timer as well
     **
     */
     if (timer < ss_ptr->wcdma_suitable_search_time)
     {
        /* We are still below the suitable seach timer expiry
        **
        */
        SD_MSG_HIGH_0( "Still in WCDMA suitable search period ");
        return TRUE;
     }
     else
     {
        /* The timer has expired, reset the related fields
        */
        ss_ptr->wcdma_suitable_search_time = 0;
        SD_MSG_HIGH_1( "WCDMA no longer in suitable search: int timer %d",timer);
     }
  }


  return FALSE;
}

/*===========================================================================

FUNCTION sdss_is_wcdma_connected_mode

DESCRIPTION
  Returns  the connected mode status

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN boolean sdss_is_wcdma_connected_mode(sd_ss_e_type ss)
{

  sdss_s_type   *ss_ptr   = sdss_ptr( ss );


  SD_ASSERT (ss_ptr);

  return (ss_ptr->wcdma_in_conn_mode);

}
#endif

/*===========================================================================

FUNCTION sdss_set_simultaneous_mode

DESCRIPTION
   Set the simultaneous mode of the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                          sdss_set_simultaneous_mode(

        sys_simultaneous_mode_e_type  simultaneous_mode
)
{
  SYS_ARG_NOT_USED( simultaneous_mode );
}

/*===========================================================================

FUNCTION sdss_get_simultaneous_mode

DESCRIPTION
   Get the simultaneous mode of the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  Return the simultaneous mode of the SS-Core.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sys_simultaneous_mode_e_type  sdss_get_simultaneous_mode( void )
{
  return SYS_SIMULTANEOUS_MODE_NON_WX;
}

/*===========================================================================

FUNCTION sdss_get_pref_update_reason

DESCRIPTION
   Get the pref update reason of the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  Return the pref update reason of the SS-Core.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sdss_pref_updated_e_type  sdss_get_pref_update_reason(

        sd_ss_e_type                  ss
            /* System selection stack.
            */
)
{
  return  sdss_ptr( ss )->ss_pref_updated_status;
}

/*===========================================================================

FUNCTION sdss_set_pref_update_reason

DESCRIPTION
   set the pref update reason of the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  NOne

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void  sdss_set_pref_update_reason(

        sd_ss_e_type                  ss,
            /* System selection stack.
            */

       sdss_pref_updated_e_type    ss_pref_updated_status
)
{

  sdss_s_type   *ss_ptr   = sdss_ptr( ss );

  SD_CRIT_SECT_ENTER();
  ss_ptr->ss_pref_updated_status = ss_pref_updated_status;
  SD_CRIT_SECT_EXIT();

  return;
}

/*===========================================================================

FUNCTION sdss_is_redir

DESCRIPTION
  Check whether a specified redirection value includes the current
  redirection type.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the specified redirection value includes the current redirection
  type FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean                       sdss_is_redir_internal(

        sd_ss_e_type                  ss,
            /* System selection stack.
            */

        sdss_redir_val_e_type         redir_val
            /* Redirection value.
            */
)
{
  const sdss_s_type   *ss_ptr   = sdss_ptr( ss );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( redir_val, SDSS_REDIR_VAL_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* If specified redirection value includes the current redirection type,
  ** return TRUE. Else, return FALSE.
  */
  return( SD_IS_BIT_CONTAIN(redir_val, BM(ss_ptr->redir)) );

} /* sdss_is_redir */

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_is_redir

DESCRIPTION
  Check whether a specified redirection value includes the current
  redirection type.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the specified redirection value includes the current redirection
  type FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean                       sdss_is_redir(

        sd_ss_e_type                  ss,
            /* System selection stack.
            */

        sdss_redir_val_e_type         redir_val
            /* Redirection value.
            */
)
{
  const sdss_s_type   *ss_ptr   = sdss_ptr( ss );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  SD_MSG_LOW_2("is_redir: redir_val=%d, ss_ptr->redir=%d",redir_val, ss_ptr->redir);

  /* If specified redirection value includes the current redirection type,
  ** return TRUE. Else, return FALSE.
  */
  return( sdss_is_redir_internal(ss, redir_val));

} /* sdss_is_redir */




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_is_handoff

DESCRIPTION
  Check whether a specified handoff value includes the current handoff type.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the specified handoff value includes the current handoff type FALSE
  otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean                       sdss_is_handoff(

        sd_ss_e_type                  ss,
            /* System selection stack.
            */

        sdss_ho_val_e_type            handoff_val
            /* Handoff value.
            */
)
{
  SD_ASSERT_ENUM_IS_INRANGE( handoff_val, SDSS_HO_VAL_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If specified handoff value includes the current handoff type, return
  ** TRUE. Else, return FALSE.
  */
  return( SD_IS_BIT_CONTAIN(handoff_val,BM(sdss_get_handoff(ss))) );

} /* sdss_is_handoff */

/*===========================================================================

FUNCTION sdss_misc_is_handoff

DESCRIPTION
  Check whether a specified handoff value includes the current handoff type.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the specified handoff value includes the current handoff type FALSE
  otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean                       sdss_misc_is_handoff(

        sd_ss_e_type                  ss,
            /* System selection stack.
            */

        sd_ss_ho_e_type               handoff_val
            /* Handoff value.
            */
)
{
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( handoff_val, SD_SS_HO_MAX );
  return ( sdss_is_handoff( ss, (sdss_ho_val_e_type)BM(handoff_val) ));
}

/*===========================================================================

FUNCTION sdss_is_resel_state1

DESCRIPTION
  Check whether a specified reselection value equals the current reselection
  state.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the specified reselection value equal the current reselection
  state. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean                   sdss_is_resel_state1(

        sd_ss_e_type              ss,
            /* System selection stack.
            */

        sdssscr_resel_stt_val_e_type     resel_state
            /* Reselection state value.
            */
)
{

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( resel_state, SDSSSCR_RESEL_STT_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return( SD_IS_BIT_CONTAIN(resel_state,BM(sdss_ptr( ss )->resel_state)) );

} /* sdss_is_resel_state1 */


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_is_resel_state

DESCRIPTION
  Check whether a specified reselection value equals the current reselection
  state.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the specified reselection value equal the current reselection
  state. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean                   sdss_is_resel_state(

        sd_ss_e_type              ss,
            /* System selection stack.
            */

        sdss_resel_stt_e_type     resel_state
            /* Reselection state value.
            */
)
{
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( resel_state, SDSS_RESEL_STT_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return sdss_is_resel_state1(ss, (sdssscr_resel_stt_val_e_type)BM(resel_state));

} /* sdss_is_resel_state */

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_is_resel_mode_full

DESCRIPTION
  Check whether resel mode is FULL
DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the reselection mode is FULL. 
  FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean                       sdss_is_resel_mode_full(

        sd_ss_e_type                  ss
            /* System selection stack.
            */
)
{

    return(( sdss_ptr( ss )->resel_mode >= SDSS_RESEL_MODE_FULL_SRV &&
              sdss_ptr( ss )->resel_mode < SDSS_RESEL_MODE_FULL_SRV_MAX));

}

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_reset_resel_mode_if_full

DESCRIPTION
  Check whether resel mode is FULL and reset it to default value.
  For e.g when DUT comes out of Limited to FULL reselection mode on 
          getting FULL Service on 3GPP or 3GPP2 system.
DEPENDENCIES
  None.

RETURN VALUE
  void

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                       sdss_reset_resel_mode_if_full(

        sd_ss_e_type                  ss
            /* System selection stack.
            */
)
{

    if( sdss_ptr( ss )->resel_mode >= SDSS_RESEL_MODE_FULL_SRV &&
              sdss_ptr( ss )->resel_mode < SDSS_RESEL_MODE_FULL_SRV_MAX)
    {
        sdss_ptr( ss )->resel_mode = SDSS_RESEL_MODE_INIT;
    }

}

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_is_acc_reas

DESCRIPTION
  Check whether a specified access reason value equals the most recent
  access reason.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the specified access reason value equals the most recent access
  termination reason. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean                       sdss_is_acc_reas(

        const sdss_s_type             *ss_ptr,
            /* Pointer to a System Selection information structure.
            */

        sd_ss_acc_reas_e_type         acc_reas
            /* Access reason.
            */
)
{
  SD_ASSERT( ss_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( acc_reas, SD_SS_ACC_REAS_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If specified access reason equals the most recent access reason, return
  ** TRUE. Else, return FALSE.
  */
  if( acc_reas == ss_ptr->acc_reas )
  {
    return TRUE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return FALSE;

} /* sdss_is_acc_reas */




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_is_acc_term

DESCRIPTION
  Check whether a specified access termination reason equals the most recent
  access termination reason.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the specified access termination reason equals the most recent
  access termination reason. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean                       sdss_is_acc_term(

        const sdss_s_type             *ss_ptr,
            /* Pointer to a System Selection information structure.
            */

        sd_ss_acc_term_e_type         acc_term_val
            /* Access termination value.
            */
)
{
  SD_ASSERT( ss_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( acc_term_val, SD_SS_ACC_TERM_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If specified access termination value includes the current access
  ** termination reason, return TRUE. Else, return FALSE.
  */
  if( acc_term_val == ss_ptr->acc_term )
  {
    return TRUE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return FALSE;

} /* sdss_is_acc_term */




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_is_acc_fail

DESCRIPTION
  Check whether registration access has failed at least cnt times and time
  minutes.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if registration access has failed at least cnt times and time minutes.
  FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean                       sdss_is_acc_fail(

        const sdss_s_type             *ss_ptr,
            /* Pointer to a System Selection information structure.
            */

        int                           cnt,
            /* Number of times registration access has failed.
            */

        word                          time
            /* Time (in minutes) over which registration access has failed.
            */
)
{
  SD_ASSERT( ss_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if( ss_ptr->acc_fail_cnt >= cnt &&
      time_get_uptime_secs() >= ss_ptr->acc_fail_start_time &&
      (word)(time_get_uptime_secs() - ss_ptr->acc_fail_start_time) >= time * 60 )
  {
    return TRUE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return FALSE;

} /* sdss_is_acc_fail */


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_is_event_cnt

DESCRIPTION
  Check whether the event has occurred CNT times within TIME minutes.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE   if event has occurred CNT times within TIME minutes.
  FALSE  otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean                       sdss_is_event_cnt (

        const sdss_s_type             *ss_ptr,
            /* Pointer to a System Selection information structure.
            */

        sdss_cnted_evt_e_type         event,
            /* Event index in the counter/time array.
            */

        int                           cnt,
            /* Number of events.
            */

        word                          time
            /* Time (in minutes) over which event has occurred.
            */
)
{
  SD_ASSERT( ss_ptr != NULL );
  if(event <= SDSS_CNTED_EVT_NONE)
  {
    return FALSE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( event, SDSS_CNTED_EVT_MAX );

  if( ss_ptr->event_cnt[event] >= cnt &&
      time_get_uptime_secs() >= ss_ptr->event_uptime[event] &&
      (word)(time_get_uptime_secs() - ss_ptr->event_uptime[event]) >= time*60 )
  {
    return TRUE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return FALSE;

} /* sdss_is_event_cnt */



/* <EJECT> */
/*===========================================================================

FUNCTION sdss_is_prl_pref_chgd

DESCRIPTION
  Check whether the PRL preference was changed the last time.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if changed.
  FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean                       sdss_is_prl_pref_chgd(

        sd_ss_e_type                  ss
          /* System selection stack.
          */
)
{

  sdss_s_type   *ss_ptr = NULL;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  ss_ptr = sdss_ptr( ss );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Check if it changed.
  */
  if( ss_ptr->prl_pref != ss_ptr->prev_prl_pref )
  {
    return TRUE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return FALSE;

} /* sdss_is_prl_pref_chgd */


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_is_time_gr

DESCRIPTION
  Check whether the instance has acquired service more than time seconds ago

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if passed.
  FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/

static boolean sdss_is_time_gr(
  sd_ss_e_type ss,
  /* System selection stack
  */

  sdssscr_srv_status_val_e_type srv_status,
  /* The srv_status to check for
  */

  byte time
  /* The time how long srv_status must have been achieved
  */
)
{
  sd_si_info_s_type    *si_info_ptr = &sd_si_ptr(ss)->si_info;
  boolean cond_is_true = FALSE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if( ss != SD_SS_MAIN )
  {
    SD_ERR_1( " Invalid ss %d in sdss_is_time_gr",ss);
    SD_ASSERT(FALSE);
    /* Default return to FALSE
    */
    return FALSE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  switch ( srv_status )
  {
    case SDSSSCR_SRV_STATUS_VAL_SRV:
    case SDSSSCR_SRV_STATUS_VAL_SRV_ANY:

      /* Verify if we have acquired service
      */
      cond_is_true = SD_IS_BIT_CONTAIN( BM(si_info_ptr->srv_status), srv_status );

      /* If we are required to check the time, check it now
      */
      if( cond_is_true && time != 0 && si_info_ptr->srv_acq_time != 0 )
      {
        cond_is_true = ( (time_get_uptime_secs() > si_info_ptr->srv_acq_time + time) ?
                       TRUE : FALSE );
      }

      return cond_is_true;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    case SDSSSCR_SRV_STATUS_VAL_NO_SRV:

      /* Verify if we have acquired service
      */
      cond_is_true = SD_IS_BIT_CONTAIN( BM(si_info_ptr->srv_status), srv_status );

      /* If we are required to check the time, check it now
      */
      if( cond_is_true && time != 0 && si_info_ptr->srv_lost_time != 0 )
      {
        cond_is_true = ( (time_get_uptime_secs() > si_info_ptr->srv_lost_time + time) ?
                       TRUE : FALSE );
      }

      return cond_is_true;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_SRV_STATUS_VAL_PWR_SAVE:
    case SDSSSCR_SRV_STATUS_VAL_NO_SRV_ANY:
    case SDSSSCR_SRV_STATUS_VAL_LIMITED:
    case SDSSSCR_SRV_STATUS_VAL_LIMITED_REG:
    case SDSSSCR_SRV_STATUS_VAL_LIMITED_ANY:
    case SDSSSCR_SRV_STATUS_VAL_MAX:
    default:
      return FALSE;
  } /* switch */

} /* sdss_is_time_gr */

/*===========================================================================

FUNCTION sdss_is_srv_status2

DESCRIPTION
  Check whether the srv status for ss instance is srv_status
DEPENDENCIES
  None.

RETURN VALUE
  TRUE if passed.
  FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean                       sdss_is_srv_status2(

        sd_ss_e_type                  ss,
            /* System selection stack
            */

        sdssscr_srv_status_val_e_type srv_status
            /* The srv_status to check for
            */
)
{


  sd_si_info_s_type    *si_info_ptr = &sd_si_ptr(ss)->si_info;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  switch( ss )
  {
    case SD_SS_MAIN:
      break;

    case SD_SS_HYBR_HDR:

      #ifndef FEATURE_HDR
      SD_ERR_1(" ss %d", ss);
      return FALSE;
      #else
      break;
      #endif

    case SD_SS_HYBR_2:
     if(!sdss_is_featuremode(SYS_OVERALL_FEATURE_MODE_NORMAL))
     {
       break;
     }
      /* Deliberate fall down to the default is FEATURE_HDR is not defined
      */
    case SD_SS_HYBR_3:

    #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
      break;
      #endif
      /* Deliberate fall down to the default case
      */

    case SD_SS_MAX:
    default:
      SD_MSG_MED_1(" ss %d", ss);
      return FALSE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return( SD_IS_BIT_CONTAIN( BM(si_info_ptr->srv_status), srv_status ) );
}

/*===========================================================================

FUNCTION sdss_get_curr_srv_mode

DESCRIPTION
 get the current mode on which service is available
DEPENDENCIES
  None.

RETURN VALUE
  TRUE if passed.
  FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
static  sd_mode_e_type      sdss_get_curr_srv_mode  ( sd_ss_e_type ss )
{
  sd_si_info_s_type    *si_info_ptr = &sd_si_ptr(ss)->si_info;

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  return (si_info_ptr->mode);
}


/*===========================================================================

FUNCTION sdss_is_sys_lost

DESCRIPTION
  Check whether a specified system lost reason equals the most recent system
  lost reason.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the specified system lost reason equals the most recent system lost
  reason. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean                       sdss_is_sys_lost(

        const sdss_s_type             *ss_ptr,
            /* Pointer to a System Selection information structure.
            */

        sd_ss_sys_lost_e_type         sys_lost
            /* System lost reason.
            */
)
{
  SD_ASSERT( ss_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( sys_lost, SD_SS_SYS_LOST_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If specified system lost reason equals the current system lost reason,
  ** return TRUE. Else, return FALSE.
  */
  if( sys_lost == ss_ptr->sys_lost )
  {
      return TRUE;
    }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return FALSE;

} /* sdss_is_sys_lost */

/*===========================================================================

FUNCTION sdss_set_handoff

DESCRIPTION
  Returns the current handoff for the specified ss.

DEPENDENCIES
  None.

RETURN VALUE
  sdss_opr_mode_e_type

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void                           sdss_set_handoff(

       sd_ss_e_type                   ss,
           /* System selection stack
           */

       sd_ss_ho_e_type                handoff

)
{
  SD_ASSERT_ENUM_IS_INRANGE(ss, SD_SS_MAX);
  SD_ASSERT_ENUM_IS_INRANGE( handoff, SD_SS_HO_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if(sdss_ptr(ss)->handoff != handoff)
  {
    SD_MSG_HIGH_2("SDSS:FRFL: Updating ss= %d, handoff=%d",ss,handoff);
    sdss_ptr(ss)->handoff = handoff;
  }
}

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_update_rat_acq_order

DESCRIPTION
  Update the rat acqusition order from input ptr to output ptr.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE - rat_acq_order is updated.
  FALSE - rat_acq_order is not updated.

SIDE EFFECTS
  None.

===========================================================================*/
static boolean sdss_update_rat_acq_order(
  const sd_rat_acq_order_s_type *rat_acq_order_in_ptr,
  sd_rat_acq_order_s_type       *rat_acq_order_out_ptr
)
{
  boolean is_updated = FALSE;

  if(rat_acq_order_in_ptr != NULL &&
     rat_acq_order_out_ptr != NULL)
  {
    uint8 i=0;
    uint16 num_rat = \
      MIN(SYS_MAX_ACQ_PREF_RAT_LIST_NUM, rat_acq_order_in_ptr->num_rat);

    /* Only update the rat_acq_order if there are any changes
    */
    for(i=0; i< num_rat; i++)
    {
      if(rat_acq_order_in_ptr->acq_sys_mode[i] !=
         rat_acq_order_out_ptr->acq_sys_mode[i])
      {
        is_updated = TRUE;
        break;
      }
    }

    if(is_updated)
    {
      SD_MSG_HIGH_0("Original rat_acq_order: ");
      sdss_print_rat_acq_order(rat_acq_order_out_ptr);

      /* Update rat_acq_order
      */
      rat_acq_order_out_ptr->num_rat = rat_acq_order_in_ptr->num_rat;
      rat_acq_order_out_ptr->version = rat_acq_order_in_ptr->version;
      for(i=0; i< SYS_MAX_ACQ_PREF_RAT_LIST_NUM; i++)
      {
        if(i < rat_acq_order_in_ptr->num_rat)
        {
          rat_acq_order_out_ptr->acq_sys_mode[i] =
            rat_acq_order_in_ptr->acq_sys_mode[i];
        }
        else
        {
          rat_acq_order_out_ptr->acq_sys_mode[i] = SYS_SYS_MODE_NONE;
        }
      }

      SD_MSG_HIGH_0("Updated rat_acq_order: ");
      sdss_print_rat_acq_order(rat_acq_order_out_ptr);
    }
  }

  return is_updated;
}
/*===========================================================================

FUNCTION sdss_reset_sys_lost

DESCRIPTION
  Update the sdss_sys_lost_update of the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                          sdss_reset_sys_lost(
                void

)
{
    sdss_s_type   *ss_ptr   = sdss_ptr(SD_SS_MAIN);
        SD_ASSERT(ss_ptr != NULL);
    ss_ptr->sys_lost = SD_SS_SYS_LOST_NONE;

}

/*===========================================================================

FUNCTION sdss_is_all_sys_perm_avoid_in_lst

DESCRIPTION
Check whether systems present in list passed are all permanent avoided.

DEPENDENCIES
None.

RETURN VALUE
TRUE if systems present in list passed are all permanent avoided. FALSE otherwise.

SIDE EFFECTS
None.

===========================================================================*/
EXTERN boolean sdss_is_all_sys_perm_avoid_in_lst(

  sdsr_e_type  list_to_check
  /* List that need to be scanned for permanent avoidance check.
  */
  )
{

  int                 i;
  sdsr_s_type         *sr_ptr;
  boolean result = FALSE;

  SD_ASSERT_ENUM_IS_INRANGE( list_to_check, SDSR_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* scan list_to_check and check if the all systems are under permanent
  ** avoidance, return TRUE. Else, return FALSE.
  */
  for( i=0; (sr_ptr=sdsr_list_get_ptr(list_to_check, i)) != NULL; i++ )
  {

    /* cond 1 : system avoided due to MAPE.
    current uptime is less than the avoid time of system.
    N_MAP_RETRY attmpts have already been made */
    if(sr_ptr->sched == SDSSSCR_SCHED_AVOID_MAP_UNTIL_ACC_SUCCESS &&
      time_get_uptime_secs() < sr_ptr->sched_prm.avoid_time &&
      sr_ptr->max_access_prob.absr_cnt == 0)
    {
      result = TRUE;
      continue; /* Sys is permanent avoided, so move to next system */
    }
    /* cond 2 : System is under avoidance, but not due to MAPE.
    and current uptime is still lesser than scheduled avoid time */
    else if( SDSSSCR_SCHED_IS_AVOID( sr_ptr->sched ) &&
      time_get_uptime_secs() < sr_ptr->sched_prm.avoid_time )
    {
      /* These systems will not be considered as permanent Mapped.
      Reference Function sdss_sr_is_absr */
      result = FALSE;
      break;
    }
    else if( time_get_uptime_secs()  < sr_ptr->max_access_prob.avoid_time &&
      sr_ptr->max_access_prob.absr_cnt == 0 )
    {
      /* avoidance type is other than MAP_UNITL_ACCESS,
      but N_MAP_RETRY attempts have expired
      and avoidance timer is still running,
      so system is considered as permanent MAPPED */
      result = TRUE;
      continue;
    }
    else
    {
      /* found one system which is not permanently being avoided,
       it is either under temp avoidance or not under avoidance at all*/
      result = FALSE;
      break;
    }
  }
  SD_MSG_HIGH_2("GSRDM: is_all_sys_perm_map  list= %d, result=%d",list_to_check, result);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return result;

} /* sdss_is_all_sys_perm_avoid_in_lst */




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_opr_mode_update

DESCRIPTION
  Update the operating mode status of the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                          sdss_opr_mode_update(

        sd_ss_e_type                  ss,
            /* System selection stack
            */

        sdss_opr_mode_e_type          opr_mode
            /* New operating mode.
            */
)
{
  SD_ASSERT_ENUM_IS_INRANGE( opr_mode, SDSS_OPR_MODE_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  switch(ss)
  {
    case SD_SS_MAIN:
      sdss_common.opr_mode_main = opr_mode;
      break;

    case SD_SS_HYBR_1:
      /* No initialization needed for HYBR1 stack for now */
      break;

    case SD_SS_HYBR_2:
      sdss_common.opr_mode_hybr2 = opr_mode;
      break;

    case SD_SS_HYBR_3:
      sdss_common.opr_mode_hybr3 = opr_mode;
      break;

    default:
      break;
  }

} /* sdss_opr_mode_update */


#if defined(SD_GSM_SUPPORTED) || defined(SD_WCDMA_SUPPORTED)
/* <EJECT> */
/*===========================================================================

FUNCTION sdss_get_network_pref_update

DESCRIPTION
  Update the mode and band preference for get network request of the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                          sdss_get_network_pref_update(

        sd_ss_e_type                  ss,
            /* System selection stack
            */

        sd_ss_mode_pref_e_type        mode_pref,
            /* system mode preference for get network request.
            */

        sd_ss_band_pref_e_type        band_pref,
            /* system band preference for get network request.
            */

        sys_lte_band_mask_e_type      band_pref_lte,
            /* LTE band preference (BC0, BC1, any, etc.)
            */

        sd_ss_band_pref_e_type        band_pref_tds,
            /* TD-SCDMA band preference for get network request.
            */

        sd_network_list_type_e_type  list_type
           /* Network List type for Get Net request
           */

)
{
  sdss_s_type   *ss_ptr   = NULL;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( mode_pref, SD_SS_MODE_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( band_pref, SD_SS_BAND_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_MSG_HIGH_6("SDSS:FRFL: Setting Net Mode_pref = %d, band_pref 0x%08x %08x, tds_band_pref 0x%08x %08x, net_list_type %d", mode_pref,
                                                                QWORD_HIGH(band_pref),
                                                                QWORD_LOW(band_pref),
                                                                QWORD_HIGH(band_pref_tds),
                                                                QWORD_LOW(band_pref_tds),
                                                                list_type);
  sd_print_lte_band_mask(band_pref_lte);

  SD_CRIT_SECT_ENTER();
  ss_ptr = sdss_ptr(ss);
  ss_ptr->get_net_mode_pref     = mode_pref;
  ss_ptr->get_net_band_pref     = band_pref;
  ss_ptr->get_net_band_pref_lte = band_pref_lte;
  ss_ptr->get_net_band_pref_tds = band_pref_tds;
  ss_ptr->get_net_list_type     = list_type;
  SD_CRIT_SECT_EXIT();

} /* sdss_get_network_pref_update */

/*===========================================================================

FUNCTION sdss_get_network_pref_read

DESCRIPTION
  Read the mode and band preference for get network request of the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                          sdss_get_network_pref_read(

        sd_ss_e_type                  ss,
            /* System selection stack
            */

        sd_ss_mode_pref_e_type        *mode_pref,
            /* system mode preference for get network request.
            */

        sd_ss_band_pref_e_type        *band_pref,
            /* system band preference for get network request.
            */

        sys_lte_band_mask_e_type      *band_pref_lte,
            /* LTE band preference (BC0, BC1, any, etc.)
            */

        sd_ss_band_pref_e_type        *band_pref_tds
            /* TD-SCDMA band preference for get network request.
            */

)
{
  sdss_s_type   *ss_ptr   = NULL;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_CRIT_SECT_ENTER();
  ss_ptr = sdss_ptr(ss);
  if( mode_pref != NULL )
  {
    *mode_pref     = ss_ptr->get_net_mode_pref;
  }
  if( band_pref != NULL )
  {
    *band_pref     = ss_ptr->get_net_band_pref;
  }
  if( band_pref_lte != NULL )
  {
    *band_pref_lte = ss_ptr->get_net_band_pref_lte;
  }
  if( band_pref_tds != NULL )
  {
    *band_pref_tds = ss_ptr->get_net_band_pref_tds;
  }
  SD_CRIT_SECT_EXIT();

} /* sdss_get_network_pref_update */

#endif /* (SD_GSM_SUPPORTED) || (SD_WCDMA_SUPPORTED) */

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_subsc_avail_update

DESCRIPTION
  Update the Subscription availability status in the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                          sdss_subsc_avail_update(

        sd_ss_e_type                  ss,
            /* System selection stack
            */

        boolean                       is_gw_subsc_avail,
           /* Indicates if subscription is available for providing service on
           ** GSM/UMTS network.
           */

        boolean                       is_1x_subsc_avail,
           /* Indicates if subscription is available for providing service on
           ** CDMA/AMPS/HDR network.
           */

        boolean                       is_gw2_subsc_avail
           /* Indicates if subscription is available for providing service on
           ** second GSM/UMTS network (Dual Standby).
           */
)
{
  sdss_subsc_avail_update2(
        ss,
        is_gw_subsc_avail,
        is_1x_subsc_avail,
        is_gw2_subsc_avail,
        0);


} /* sdss_subsc_avail_update */

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_subsc_avail_update2

DESCRIPTION
  Update the Subscription availability status in the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                          sdss_subsc_avail_update2(

        sd_ss_e_type                  ss,
            /* System selection stack
            */

        boolean                       is_gw_subsc_avail,
           /* Indicates if subscription is available for providing service on
           ** GSM/UMTS network.
           */

        boolean                       is_1x_subsc_avail,
           /* Indicates if subscription is available for providing service on
           ** CDMA/AMPS/HDR network.
           */

        boolean                       is_gw2_subsc_avail,
           /* Indicates if subscription is available for providing service on
           ** second GSM/UMTS network (Dual Standby).
           */

        boolean                       is_gw3_subsc_avail
           /* Indicates if subscription is available for providing service on
           ** second GSM/UMTS network (Dual Standby).
           */

)
{
  sdss_s_type   *ss_ptr = sdss_ptr( ss );


  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Update the subscription availability information on SS-Main.
  */
  ss_ptr->is_gw_subsc_avail = is_gw_subsc_avail;
  ss_ptr->is_1x_subsc_avail = is_1x_subsc_avail;
  ss_ptr->is_gw2_subsc_avail = is_gw2_subsc_avail;
  ss_ptr->is_gw3_subsc_avail = is_gw3_subsc_avail;

  /* Reset SDSS_FLAG_HDR_DEACT_BY_HYBR2_BSR to FALSE if either 1x or GW 
  ** subs becomes unavailable on sub1
  */
  if ( ss == SD_SS_MAIN && (!ss_ptr->is_gw_subsc_avail || !ss_ptr->is_1x_subsc_avail))
  {
    SD_MSG_MED_0("Reset hdr_deact_by_hybr2_bsr on subs unavail");
    sdss_set_flag(SD_SS_HYBR_2,SDSS_FLAG_HDR_DEACT_BY_HYBR2_BSR, FALSE);
  }
  /* Currently camp_mode is being updated only for sub 1 changes in-spite of
  ** if being part of sdss_common. So only checking the sub1 subscriptions.
  */
  if (!ss_ptr->is_gw_subsc_avail && !ss_ptr->is_1x_subsc_avail)
  {
    SD_MSG_LOW_0("Subs lost on Sub1. Set camp_mode OFF");
    sdss_set_camp_mode(SD_SS_PREF_CAMP_MODE_OFF);
  }
} /* sdss_subsc_avail_update2 */


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_get_subsc_type

DESCRIPTION
  Get the subscription type from the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  Enumeration type of subscription

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sdss_subsc_e_type             sdss_get_subsc_type(

        sd_ss_e_type                  ss
            /* System selection stack.
            */
)
{
  sdss_s_type                         *ss_ptr = sdss_ptr( ss );
                                           /**/

  sdss_subsc_e_type                   subsc = SDSS_SUBSC_NONE;
                                          /* the subscription type */

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if((ss == SD_SS_HYBR_2) && !sdss_is_1x_sxlte() && !sdss_is_sglte())
  {
    subsc = (ss_ptr->is_gw2_subsc_avail)?SDSS_SUBSC_GW:SDSS_SUBSC_NONE;
    return subsc;
  }

  if(ss == SD_SS_HYBR_3)
  {
    subsc = (ss_ptr->is_gw3_subsc_avail)?SDSS_SUBSC_GW:SDSS_SUBSC_NONE;
    return subsc;
  }

  if ( ss_ptr->is_1x_subsc_avail )
  {
    subsc = SDSS_SUBSC_ADD( subsc, SDSS_SUBSC_1X );
  }

  if( ss_ptr->is_gw_subsc_avail )
  {
    subsc = SDSS_SUBSC_ADD( subsc, SDSS_SUBSC_GW );
  }

  return subsc;

}


/*===========================================================================

FUNCTION sdss_order_pri_list_per_emerg_rat_acq_order

DESCRIPTION
  Orders the passed rat priority list per emergency rat acq order

DEPENDENCIES
  Should be called only if sdss_is_ral_stored_in_efs is true.

RETURN VALUE
  None

SIDE EFFECTS
  None.

===========================================================================*/
static void sdss_order_pri_list_per_emerg_rat_acq_order(sys_rat_pri_list_info_s_type *rat_pri_list, sd_ss_e_type ss)
{
  sdss_s_type *ss_ptr = sdss_ptr(ss);
  sd_rat_acq_order_s_type *emerg_rat_acq_order_ptr;
  sys_rat_pri_list_info_s_type *temp_rat_pri_list_ptr;
  uint8 i,j,cnt=0;

  SD_ASSERT(rat_pri_list != NULL);
  emerg_rat_acq_order_ptr = &(ss_ptr->emerg_rat_acq_order);
  temp_rat_pri_list_ptr = modem_mem_alloc( sizeof(sys_rat_pri_list_info_s_type), MODEM_MEM_CLIENT_MMODE );
  if(temp_rat_pri_list_ptr != NULL)
  {
    memset(temp_rat_pri_list_ptr, 0, sizeof(sys_rat_pri_list_info_s_type));
    for(i=0; i < emerg_rat_acq_order_ptr->num_rat; i++)
    {
      /* iterate through emerg-rat_acq_order to sort rat_pri_list passed */
      for(j=0; j < rat_pri_list->num_items; j++)
      {
        if(emerg_rat_acq_order_ptr->acq_sys_mode[i] == rat_pri_list->priority_list_info[j].acq_sys_mode)
        { 
          /* insert entry into temp rat-pri_list object */
          memscpy( &temp_rat_pri_list_ptr->priority_list_info[cnt], sizeof(sys_priority_list_info_s_type), &rat_pri_list->priority_list_info[j], sizeof(sys_priority_list_info_s_type) );
          cnt++;
          break; /* break inner loop */
        }
      }
    }
    /* to confirm that all RATs from pri list has been added or not  */
	 
    SD_MSG_HIGH_2("All modes in rat_pri_list are sorted as per emerg_rat_acq_order if cnt:%d == num_items:%d", 
                   cnt,rat_pri_list->num_items);

    /* Copy back temp pri_list_info into rat_pri-list-info */
    memscpy(rat_pri_list->priority_list_info, sizeof(rat_pri_list->priority_list_info), temp_rat_pri_list_ptr->priority_list_info, sizeof(temp_rat_pri_list_ptr->priority_list_info) );

    modem_mem_free( temp_rat_pri_list_ptr, MODEM_MEM_CLIENT_MMODE );
  }
  else
  {
    SD_MSG_HIGH_0("temp_rat_pri_list_ptr memory allocation failed");
  }

  /* print rat priority list */
  for(j=0; j < rat_pri_list->num_items; j++)
  {
    SD_MSG_HIGH_2("modified rat pri list idx=%d, mode=%d",j,rat_pri_list->priority_list_info[j].acq_sys_mode);
  }
}


/*===========================================================================

FUNCTION sdss_pref_update

DESCRIPTION
  Update the SS-Preference setting of the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if any of the new preferences is different than the existing
  preferences. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sdss_pref_updated_e_type      sdss_pref_update(

        sd_ss_pref_reas_e_type        pref_reason,
            /* Reason for changing the SS-Preference.
            */

        sd_ss_orig_mode_e_type        orig_mode,
            /* New origination mode (normal, OTASP, emergency, other, etc.).
            */

        sd_ss_mode_pref_e_type        mode_pref,
            /* New mode preference (AMPS, CDMA, any, etc.) - ignored when
            ** orig_mode = OTASP or emergency.
            */

        sd_ss_band_pref_e_type        band_pref,
            /* New band preference (BC0, BC1, any, etc.) - ignored when
            ** orig_mode = OTASP or emergency..
            */

        sys_lte_band_mask_e_type      lte_band_pref,
           /* Band preference for LTE - ignored when
            ** orig_mode = OTASP or emergency */

        sd_ss_band_pref_e_type        tds_band_pref,
           /* Band preference for TD-SCDMA - ignored when
            ** orig_mode = OTASP or emergency TODO: TDS Is this applicable for TDS? */


        sd_ss_prl_pref_e_type         prl_pref,
            /* New prl system preference (Available BC0A, available BC0B, etc.)
            */

        sd_ss_roam_pref_e_type        roam_pref,
            /* New roam preference (any, home, affiliated, etc.) - ignored
            ** when orig_mode = OTASP or emergency..
            */

        sd_ss_hybr_pref_e_type        hybr_pref,
            /* New hybrid preference (none, CDMA/HDR).
            */

        sd_band_e_type                otasp_band,
            /* The band-class that is associated with OTASP origination mode.
            ** Note that this parameter is ignored if orig_mode != OTASP.
            */

        sd_blksys_e_type              otasp_blksys,
            /* The PCS frequency block/Cellular system that is associated
            ** with OTASP origination mode. Note that this parameter is
            ** ignored if orig_mode != OTASP.
            */


        sd_ss_srv_domain_pref_e_type   domain_pref,
            /* Service domain preference that is associated with the selected
            ** NAM.
            ** Applies only for GSM/WCDMA modes.
            */

        sd_ss_acq_order_pref_e_type    acq_order_pref,
            /* Preference for the order of acquisition ( WCDMA before GSM,
            ** GSM before WCDMA etc).
            */

        sd_ss_pref_update_reason_e_type   pref_update_reason,
          /* Preference change reason
          */

        sd_ss_mode_pref_e_type             user_mode_pref,
          /**< The user/phone mode preference
          */

        const sd_rat_acq_order_s_type      *rat_acq_order_ptr,
           /**< Rat acquisition order including LTE.
           */

        sd_ss_pref_camp_mode_e_type        camp_mode,
            /* Indicates whether the UE is allowed to register with the
            ** network or only camp on it without registering.
            */

        sys_voice_domain_pref_e_type       voice_domain_pref
           /**< Voice domain pref
           */
)
{
  sdss_s_type             *ss_ptr           = sdss_ptr(SD_SS_MAIN);
  boolean                 otasp_is_changed  = FALSE;
  sd_ss_mode_pref_e_type  new_supp_mode_pref;
  sd_ss_mode_pref_e_type  curr_supp_mode_pref;
  sd_ss_band_pref_e_type  new_supp_band_pref;
  sd_ss_band_pref_e_type  curr_supp_band_pref;
  sys_lte_band_mask_e_type  new_supp_band_pref_lte;
  sys_lte_band_mask_e_type  curr_supp_band_pref_lte = SYS_LTE_BAND_MASK_CONST_ANY;
  sd_ss_band_pref_e_type  new_supp_band_pref_tds;
  sd_ss_band_pref_e_type  curr_supp_band_pref_tds;

  sd_ss_mode_pref_e_type  ss_mode_pref      = SD_SS_MODE_PREF_NONE;
  sd_ss_band_pref_e_type  ss_band_pref      = SD_SS_BAND_PREF_NONE;
  sys_lte_band_mask_e_type  ss_lte_band_pref  = SYS_LTE_BAND_MASK_CONST_NONE;
  sd_ss_band_pref_e_type  ss_tds_band_pref  = SD_SS_BAND_PREF_NONE;

  sys_rat_pri_list_info_s_type  *ss_rat_pri_list_info = NULL;
  sd_ss_mode_pref_e_type  rat_order_mode_pref      = SD_SS_MODE_PREF_NONE;

  #ifndef FEATURE_EOOS
  sys_priority_list_info_s_type * rat_info;
  uint32                          j;
  sd_ss_mode_pref_e_type          acq_sys_mode_pref;
  sys_sys_mode_e_type             acq_sys_mode;
  #endif
  int                             i;
  boolean                         rat_acq_order_changed = FALSE;
  boolean                        is_mode_band_changed = FALSE;

  #ifdef FEATURE_EOOS
  #error code not present
#endif

  #if defined(FEATURE_SD_LTE)
  mmgsdi_app_enum_type            ss_gwl_app_type = sdss_get_session_info(SD_SS_MAIN);
  #endif
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( pref_reason, SD_SS_PREF_REAS_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( orig_mode, SD_SS_ORIG_MODE_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( mode_pref, SD_SS_MODE_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( user_mode_pref, SD_SS_MODE_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( band_pref, SD_SS_BAND_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( tds_band_pref, SD_SS_BAND_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( prl_pref,  SD_SS_PRL_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( roam_pref, SD_SS_ROAM_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( hybr_pref, SD_SS_HYBR_PREF_MAX );
  SD_ASSERT( INRANGE(domain_pref, SD_SS_SRV_DOMAIN_PREF_NONE,
                     (SD_SS_SRV_DOMAIN_PREF_MAX-1)) );
  SD_ASSERT_ENUM_IS_INRANGE( acq_order_pref, SD_SS_ACQ_ORDER_PREF_MAX );

  SD_ASSERT_ENUM_IS_INRANGE_INC( otasp_band, SD_BAND_MAX );
  SD_ASSERT_ENUM_IS_INRANGE_INC( otasp_blksys, SD_BLKSYS_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( camp_mode, SD_SS_PREF_CAMP_MODE_MAX );

  /* Update global mode pref across both HYBR and MAIN stacks before its
  ** changed based other parameters. Added for FEATURE_MMODE_MDM_HYBR_BSR */

  if(pref_reason == SD_SS_PREF_REAS_USER ||
     pref_reason == SD_SS_PREF_REAS_MULTIMODE_SCAN ||
     pref_reason == SD_SS_PREF_REAS_USER_RESEL ||
     pref_reason == SD_SS_PREF_REAS_RESTORE)
  {
    ss_ptr->user_global_mode_pref = mode_pref;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Orig mode is Manual GW, Set mode pref to GW.
  ** This will change ORIG mode to EMERG_ORIG when GW subs is
  ** not avail in Manual mode
  */
  if(sdss_is_orig_mode0( orig_mode, SD_SS_ORIG_MODE_VAL_MANUAL ))
  {
    mode_pref = SD_GET_COMMON_MODE(mode_pref, SD_SS_MODE_PREF_TDS_GSM_WCDMA_LTE);
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If the service domain is NONE, remove GW components from the mode_pref.
  ** Service domain doesn't affect non-GW systems.
  */
  if(domain_pref == SD_SS_SRV_DOMAIN_PREF_NONE)
  {
     mode_pref = SD_MODE_DELETE(mode_pref, SD_SS_MODE_PREF_TDS_GSM_WCDMA_LTE);
  }

  #if defined(FEATURE_SD_LTE)

  if(user_mode_pref & SD_SS_MODE_PREF_LTE)
  {
  if ( ss_gwl_app_type ==  MMGSDI_APP_SIM 
#ifdef FEATURE_ECALL_IVS
      || (ecall_get_ecall_operating_mode() ==  ECALL_MODE_ECALL_ONLY)
#endif
     )
  {
    /* SIM card type is 2G , remove LTE component from the mode_pref.
    */
    if( SD_MODE_CONTAIN( user_mode_pref, SD_SS_MODE_PREF_CDMA_HDR_GW_TDS)&&
        SD_MODE_CONTAIN( user_mode_pref, SD_SS_MODE_PREF_GWL_LTE) &&
        (sdss_is_supp_mode_band_pref(SD_SS_MODE_PREF_CDMA_HDR_GW, band_pref ) ||
        sdss_is_supp_mode_band_pref_tds(SD_SS_MODE_PREF_TDS, tds_band_pref))
      )
    {
      SD_MSG_HIGH_1(" Main: Removing LTE as gwl_app_type received =%d or in ECALL only Mode",
                                                      ss_gwl_app_type);
      mode_pref = SD_MODE_DELETE(mode_pref, SD_SS_MODE_PREF_GWL_LTE);
      user_mode_pref = SD_MODE_DELETE(user_mode_pref, SD_SS_MODE_PREF_GWL_LTE);
    }
  }

  if ( ( ( ss_gwl_app_type ==  MMGSDI_APP_SIM )||
         ( (sdss_get_operator_name ( SYS_MODEM_AS_ID_1 ) == SD_OPERATOR_CT ) && 
         !sdss_is_mmss_operation(SD_SS_MAIN) && !(ss_ptr->gprs_anite_gcf) ) )&&
       ( (hybr_pref == SD_SS_HYBR_PREF_CDMA__LTE__HDR)||
          sdss_is_1x_sxlte())
     )
  {
    /* Operator CT in Non MMSS, remove LTE component from the mode_pref.
    */
    SD_MSG_HIGH_3( "Removing LTE as gwl_app_type received =%d,is_mmss:%d,hybr_pref:%d",
                   ss_gwl_app_type,sdss_is_mmss_operation(SD_SS_MAIN),hybr_pref);
 
    mode_pref = SD_MODE_DELETE( mode_pref, SD_SS_MODE_PREF_GWL_LTE );
    user_mode_pref = SD_MODE_DELETE( user_mode_pref, SD_SS_MODE_PREF_GWL_LTE );
  }

  /* Domain_pref is CS_ONLY, remove LTE component from the mode_pref.
  */
  if(domain_pref == SD_SS_SRV_DOMAIN_PREF_CS_ONLY &&
    orig_mode == SD_SS_ORIG_MODE_NONE &&
    ss_ptr->csg_id == SYS_CSG_ID_INVALID &&
    ss_ptr->csg_rat == SYS_RAT_NONE
    )
  {
    SD_MSG_HIGH_2("Removing LTE as DOMAIN_PREF is CS_ONLY, mode_pref = %d, user_mode_pref = %d",
                   mode_pref, user_mode_pref);

    mode_pref = SD_MODE_DELETE( mode_pref, SD_SS_MODE_PREF_GWL_LTE );
    user_mode_pref = SD_MODE_DELETE( user_mode_pref, SD_SS_MODE_PREF_GWL_LTE );
  }
  }
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initial ss_pref_updated_status to NONE.
  */
  ss_ptr->ss_pref_updated_status =  SDSS_PREF_UPDATED_NONE;

  ss_ptr->pref_update_reas = pref_update_reason;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Return TRUE if the command was to avoid the system.
  */
  if (pref_reason == SD_SS_PREF_REAS_AVOID_SYS )
  {
    ss_ptr->pref_reason            = pref_reason;
    ss_ptr->ss_pref_updated_status = SDSS_PREF_UPDATED_PREF_REAS;

    return ss_ptr->ss_pref_updated_status;
  }


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If origination mode is OTASP and the OTASP band/blksys has changed or
  ** origination mode is ORIG_START indicate that OTASP parameters have
  ** changed.
  */
  if(( ss_ptr->otasp_band   != otasp_band ||
        ss_ptr->otasp_blksys != otasp_blksys ||
        pref_reason == SD_SS_PREF_REAS_ORIG_START_CS )&&
        orig_mode == SD_SS_ORIG_MODE_OTASP )
    {

      otasp_is_changed = TRUE;
  } else
  {
    otasp_is_changed = FALSE;
  }


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Update rat_acq_order from preference passed in
  */
  if((rat_acq_order_ptr != NULL) &&
     (rat_acq_order_ptr->num_rat != 0) &&
     (rat_acq_order_ptr->acq_sys_mode[0] != SYS_SYS_MODE_NONE))
  {
    /* Update rat_acq_order if it's not same as before
    */
    if(sdss_update_rat_acq_order(rat_acq_order_ptr,
                              &ss_ptr->rat_acq_order))
    {
      rat_acq_order_changed = TRUE;

      #ifdef FEATURE_MMSS_3_1
      if(sdss_is_mmss_operation(SD_SS_MAIN))
      {
        /* Reorder TOT list based on rat_acq_order */
        sdprl_update_tot_list(SD_SS_MAIN);
      }
      #endif
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  ss_rat_pri_list_info = (sys_rat_pri_list_info_s_type *)modem_mem_alloc
                        (sizeof(sys_rat_pri_list_info_s_type), MODEM_MEM_CLIENT_MMODE);
  if (ss_rat_pri_list_info != NULL)
  {
    memset(ss_rat_pri_list_info, 0, sizeof(sys_rat_pri_list_info_s_type));
  }
  else
  {
    sys_err_fatal_null_ptr_exception();
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  #ifndef FEATURE_EOOS

  new_supp_mode_pref      = user_mode_pref;
  new_supp_band_pref      = band_pref;
  new_supp_band_pref_lte  = lte_band_pref;
  new_supp_band_pref_tds  = tds_band_pref;

  sd_misc_get_band_mode_mmode( &new_supp_mode_pref,
                               &new_supp_band_pref,
                               &new_supp_band_pref_lte,
                               &new_supp_band_pref_tds,
                               user_mode_pref,
                               band_pref,
                               lte_band_pref,
                               tds_band_pref);

  mode_pref = SD_GET_COMMON_MODE(new_supp_mode_pref, mode_pref);

  /* Store the true mode pref unadjusted based on subscription.
  */
  ss_ptr->true_mode_pref = mode_pref;

  /* Remove only 1x HDR modes based on subscription unavailability
  ** GWL is retained for Limited service request is sent even when GWL Subsc is
  ** not available
  */
  /* Check if 1x subscription is available?
  */
  if ( !ss_ptr->is_1x_subsc_avail )
  {
     /* 1x subscription is not available, reset CDMA, AMPS & HDR modes.
     */
     new_supp_mode_pref = SD_MODE_DELETE( user_mode_pref, SD_SS_MODE_PREF_CDMA_AMPS );
     new_supp_mode_pref = SD_MODE_DELETE( new_supp_mode_pref, SD_SS_MODE_PREF_HDR);

  } /*  if ( !ss_ptr->is_1x_subsc_avail ) */

  #ifdef FEATURE_TDSCDMA
  sd_misc_get_band_mode_mmode( &new_supp_mode_pref,
                             &new_supp_band_pref,
                             &new_supp_band_pref_lte,
                             &new_supp_band_pref_tds,
                             user_mode_pref,
                             SD_SS_BAND_PREF_ANY,
                             SYS_LTE_BAND_MASK_CONST_ANY,
                             SD_SS_BAND_PREF_TDS_ANY);

  #else
  sd_misc_get_band_mode_mmode( &new_supp_mode_pref,
                             &new_supp_band_pref,
                             &new_supp_band_pref_lte,
                             &new_supp_band_pref_tds,
                             SD_SS_MODE_PREF_ANY,
                             SD_SS_BAND_PREF_ANY,
                             SYS_LTE_BAND_MASK_CONST_ANY,
                             SD_SS_BAND_PREF_TDS_ANY);
  #endif /* FEATURE_TDSCDMA */
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* update previous rat_pri_list_info
  */

  /* If UE is in full service at the time of emergency call end , update prev
  ** rat priority info with idle rat priority info ( preferences prior to emergency call orig).
  ** This will ensure that if the UE is being restored to the same preferences( prior to emergency call)
  ** no new service request is issued to NAS
  */
  if ( sdss_is_orig_mode0(ss_ptr->orig_mode ,SD_SS_ORIG_MODE_VAL_EMERG)&&
       !sdss_is_orig_mode0(orig_mode ,SD_SS_ORIG_MODE_VAL_EMERG) &&
       sdss_get_ss_state(SD_SS_MAIN) == SDSS_STATE_OPR &&
       sdss_is_srv_status2(SD_SS_MAIN, SDSSSCR_SRV_STATUS_VAL_SRV)
     )
  {
    SD_MSG_HIGH_0("LTE_911:update prev_rat_pri with idle");
    sdss_update_prev_rat_pri_list_info(SD_SS_MAIN, &ss_ptr->idle_rat_pri_list_info);
  }
  else
  {
    /* Store the last rat_pri_list_info
    */
    sdss_get_rat_pri_list_info(SD_SS_MAIN, ss_rat_pri_list_info);
    sdss_update_prev_rat_pri_list_info(SD_SS_MAIN, ss_rat_pri_list_info);
  }
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Set RAT priority list for 3G and LTE
  */
  memset(ss_rat_pri_list_info,
           0,
           sizeof(sys_rat_pri_list_info_s_type));

  /* perform error check for num of items in rat acq order
  */
  ss_rat_pri_list_info->num_items = ss_ptr->rat_acq_order.num_rat;

  if( ss_rat_pri_list_info->num_items > SYS_MAX_ACQ_PREF_RAT_LIST_NUM )
  {
    ss_rat_pri_list_info->num_items = SYS_MAX_ACQ_PREF_RAT_LIST_NUM;
  }


  for( i=0, j=0; i < (int)ss_rat_pri_list_info->num_items; i++ )
  {
    acq_sys_mode      = ss_ptr->rat_acq_order.acq_sys_mode[i];
    acq_sys_mode_pref = sdss_map_mode_to_mode_pref(acq_sys_mode);
    if( SD_MODE_CONTAIN(new_supp_mode_pref, acq_sys_mode_pref) &&
        sdss_is_supp_mode_band(acq_sys_mode,
                                 new_supp_band_pref,
                                 new_supp_band_pref_lte,
                                 new_supp_band_pref_tds)
      )
    {
      rat_info = &(ss_rat_pri_list_info->priority_list_info[j]);

      /* Hardcoded to MAX value for phase 2.0
      */
      rat_info->acq_sys_time_interval = SYS_ACQ_SYS_TIME_INTERVAL_MAX;
      /* set the sys mode per the supported mode from the TOT table
      */
      rat_info->acq_sys_mode =  acq_sys_mode;

      rat_order_mode_pref = SD_MODE_ADD(rat_order_mode_pref, acq_sys_mode);

      /* set the band capability based on the RAT
      */
      if ( acq_sys_mode == SYS_SYS_MODE_LTE )
      {
        rat_info->band_cap.lte_band_cap = new_supp_band_pref_lte;
      }
      else if ( acq_sys_mode == SYS_SYS_MODE_TDS )
      {
        rat_info->band_cap.chgwt_band_cap = new_supp_band_pref_tds;
      }
      else
      {
        rat_info->band_cap.chgwt_band_cap = new_supp_band_pref;
      }

      /* Initialize bst_rat_acq_required to TRUE by default and set the
      ** bst_band_cap to be equal to the band_cap. This can be
      ** reset at the time of sending service request to NAS.
      */
      rat_info->bst_rat_acq_required = TRUE;
      rat_info->bst_band_cap = rat_info->band_cap;
      j++;
    }
  }

  SD_MSG_HIGH_4(" ss_ptr->rat_pri_list_info.num_items = %d new_supp_mode_pref %d, rat_acq_order_changed %d, rat_order_mode_pref %d",
                      ss_rat_pri_list_info->num_items, new_supp_mode_pref,rat_acq_order_changed, rat_order_mode_pref);

  ss_rat_pri_list_info->num_items = j;

  #else
#error code not present
#endif /* !EOOS */
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Stop LTE connected mode operation as soon as device moved to CS only mode.
  */
  if (ss_rat_pri_list_info->num_items == 1 &&
      ss_rat_pri_list_info->priority_list_info[0].acq_sys_mode == SD_MODE_LTE && 
      domain_pref == SD_SS_SRV_DOMAIN_PREF_CS_ONLY) 
  {
    SD_MSG_HIGH_0("LTE moved to CS only mode, Reset RLF on main");
    sdss_reset_lte_connected_mode (SD_SS_MAIN);
  }

  /* Adjust the mode_pref based on the subscription availability, only if
  ** it is not emergency origination.
  */
  if ( orig_mode != SD_SS_ORIG_MODE_EMERG_ORIG &&
       orig_mode != SD_SS_ORIG_MODE_EMERG_CB )
  {

    sd_ss_mode_pref_e_type supp_mode_pref =
                              sdss_get_supp_mode_pref_mmode( mode_pref, band_pref,
                              lte_band_pref, tds_band_pref);

    /* Check if 1x subscription is available?
    */
    if ( !ss_ptr->is_1x_subsc_avail )
    {
       /* 1x subscription is not available, reset CDMA, AMPS & HDR modes.
       */
       mode_pref = SD_MODE_DELETE( mode_pref, SD_SS_MODE_PREF_CDMA_AMPS );
       mode_pref = SD_MODE_DELETE( mode_pref, SD_SS_MODE_PREF_HDR);
       ss_ptr->true_mode_pref = SD_MODE_DELETE( ss_ptr->true_mode_pref, SD_SS_MODE_PREF_CDMA_AMPS );
       ss_ptr->true_mode_pref = SD_MODE_DELETE( ss_ptr->true_mode_pref, SD_SS_MODE_PREF_HDR);

       supp_mode_pref = mode_pref;

    } /*  if ( !ss_ptr->is_1x_subsc_avail ) */

    /* Check if GW subscription is available.
    */

    supp_mode_pref = mode_pref;

    if ( !ss_ptr->is_gw_subsc_avail )
    {

      /* Check if it is 3GPP only mode_pref.
          */
      if ( !SD_MODE_CONTAIN(supp_mode_pref, SD_SS_MODE_PREF_CDMA_HDR )
           && SD_MODE_CONTAIN(supp_mode_pref,SD_SS_MODE_PREF_TDS_GSM_WCDMA_LTE)
         )
      {
        if(sdss_is_featuremode(SYS_OVERALL_FEATURE_MODE_MULTISIM) &&
           (ss_ptr->is_gw2_subsc_avail
          #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
          || ss_ptr->is_gw3_subsc_avail
          #endif
          ))
        {
          mode_pref = SD_MODE_DELETE( mode_pref, SD_SS_MODE_PREF_GWL );
          ss_ptr->true_mode_pref = mode_pref;
        }
        else
        {
          /* GW subscription is not available and GW only mode_pref.
          */
          orig_mode = SD_SS_ORIG_MODE_EMERG_ORIG;
        }
      }
      else
      {
       /* gw subscription is not available, reset GSM & WCDMA & LTE modes.
       */
       mode_pref = SD_MODE_DELETE( mode_pref, SD_SS_MODE_PREF_TDS_GSM_WCDMA_LTE );

      }

    } /* if ( !ss_ptr->is_gw_subsc_avail ) */
    #if defined(FEATURE_SD_LTE)
    else if( ss_rat_pri_list_info->num_items == 1 &&
    ss_rat_pri_list_info->priority_list_info[0].acq_sys_mode ==  SYS_SYS_MODE_LTE &&
    ss_gwl_app_type ==  MMGSDI_APP_SIM )
    {
      /* GW subscription available and card type is SIM (2G), but mode_pref is LTE  only.
      ** So keep in emergency mode.
      */
      orig_mode = SD_SS_ORIG_MODE_EMERG_ORIG;
      SD_MSG_HIGH_1(" Put emergency mode as UE is in LTE only mode and gwl_app_type =%d ",\
                  ss_gwl_app_type );
    }
    #endif

  } /* if ( orig_mode != SD_SS_ORIG_MODE_EMERG_ORIG ... ) */


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  SD_MSG_HIGH_1("mode pref: %d", mode_pref);

  #ifdef FEATURE_HDR_HYBRID

  /* If doing CDMA/HDR hybrid operation, elimnate HDR mode preference from
  ** the main system selection.
  */
  if( hybr_pref != SD_SS_HYBR_PREF_NONE )
  {
    mode_pref = SD_MODE_DELETE( mode_pref, SD_SS_MODE_PREF_HDR);
    ss_ptr->true_mode_pref = SD_MODE_DELETE( ss_ptr->true_mode_pref, SD_SS_MODE_PREF_HDR);

  }

  #endif /* FEATURE_HDR_HYBRID */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Record the current origination mode and update the reson for this
  ** SS-Preference update.
  */
  ss_ptr->orig_mode_prev = ss_ptr->orig_mode;
  if ( ss_ptr->pref_reason != pref_reason )
  {
    ss_ptr->pref_reason    = pref_reason;
    ss_ptr->ss_pref_updated_status = SDSS_PREF_UPDATED_PREF_REAS;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  #if defined (FEATURE_EOOS)
  #error code not present
#endif
  #if defined(FEATURE_LTE_TO_1X)
  if( ss_ptr->ss_pref_updated_status == SDSS_PREF_UPDATED_PREF_REAS &&
      (pref_reason                    == SD_SS_PREF_REAS_ORIG_END ||
       pref_reason                    == SD_SS_PREF_REAS_ORIG_START_PS) &&
      (ss_ptr->orig_mode_prev         == SD_SS_ORIG_MODE_1XCSFB_EMERG_ORIG ||
      ss_ptr->orig_mode_prev         == SD_SS_ORIG_MODE_1XCSFB_NORMAL_ORIG )
    )
  {
    /* Update if 1XCSFB call is being ended */
    ss_ptr->ss_pref_updated_status = SDSS_PREF_UPDATED_1XCSFB_ORIG_END;
  }
  #endif
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Get current/new supported mode/band pref.
  */
  sdss_get_mode_band_pref( SD_SS_MAIN,
                           &ss_mode_pref,
                           &ss_band_pref,
                           &ss_lte_band_pref,
                           &ss_tds_band_pref );

  curr_supp_mode_pref      = ss_mode_pref;
  curr_supp_band_pref      = ss_band_pref;
  curr_supp_band_pref_lte  = ss_lte_band_pref;
  curr_supp_band_pref_tds  = ss_tds_band_pref;

#ifdef FEATURE_TDSCDMA
  sd_misc_get_band_mode_mmode( &curr_supp_mode_pref,
                               &curr_supp_band_pref,
                               &curr_supp_band_pref_lte,
                               &curr_supp_band_pref_tds,
                               ss_mode_pref,
                               SD_SS_BAND_PREF_ANY,
                               SYS_LTE_BAND_MASK_CONST_ANY,
                               SD_SS_BAND_PREF_TDS_ANY );
#else
  sd_misc_get_band_mode_mmode( &curr_supp_mode_pref,
                               &curr_supp_band_pref,
                               &curr_supp_band_pref_lte,
                               &curr_supp_band_pref_tds,
                               SD_SS_MODE_PREF_ANY,
                               SD_SS_BAND_PREF_ANY,
                               SYS_LTE_BAND_MASK_CONST_ANY,
                               SD_SS_BAND_PREF_TDS_ANY);

#endif /* FEATURE_TDSCDMA */

  new_supp_mode_pref      = mode_pref;
  new_supp_band_pref      = band_pref;
  new_supp_band_pref_lte  = lte_band_pref;
  new_supp_band_pref_tds  = tds_band_pref;

#ifdef FEATURE_TDSCDMA
  sd_misc_get_band_mode_mmode( &new_supp_mode_pref,
                               &new_supp_band_pref,
                               &new_supp_band_pref_lte,
                               &new_supp_band_pref_tds,
                               mode_pref,
                               SD_SS_BAND_PREF_ANY,
                               SYS_LTE_BAND_MASK_CONST_ANY,
                               SD_SS_BAND_PREF_TDS_ANY );
#else
  sd_misc_get_band_mode_mmode( &new_supp_mode_pref,
                               &new_supp_band_pref,
                               &new_supp_band_pref_lte,
                               &new_supp_band_pref_tds,
                               SD_SS_MODE_PREF_ANY,
                               SD_SS_BAND_PREF_ANY,
                               SYS_LTE_BAND_MASK_CONST_ANY,
                               SD_SS_BAND_PREF_TDS_ANY );
#endif /*FEATURE_TDSCDMA */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Update the previous preferences fields.
  */
  ss_ptr->prev_mode_pref       = ss_mode_pref;
  ss_ptr->prev_band_pref       = ss_band_pref;
  ss_ptr->lte_prev_band_pref   = ss_lte_band_pref;
  ss_ptr->tds_prev_band_pref   = ss_tds_band_pref;
  ss_ptr->prev_prl_pref        = ss_ptr->prl_pref;
  ss_ptr->prev_roam_pref       = ss_ptr->roam_pref;
  ss_ptr->prev_domain_pref     = ss_ptr->domain_pref;
  ss_ptr->prev_acq_order_pref  = ss_ptr->acq_order_pref;
  ss_ptr->prev_voice_domain_pref = ss_ptr->voice_domain_pref;

  /* update PRL Support HDR Indication
  */
  ss_ptr->is_prl_support_hdr = sdprl_is_supp_mode_band_pref(SD_SS_MODE_PREF_HDR,
                                                            band_pref,
                                                            SYS_LTE_BAND_MASK_CONST_NONE,
                                                            SD_SS_BAND_PREF_NONE);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Update the user_mode_preference
  */
  if(ss_ptr->pref_reason == SD_SS_PREF_REAS_USER ||
     ss_ptr->pref_reason == SD_SS_PREF_REAS_MULTIMODE_SCAN ||
     ss_ptr->pref_reason == SD_SS_PREF_REAS_USER_RESEL ||
     ss_ptr->pref_reason == SD_SS_PREF_REAS_RESTORE)
  {
     /* If the mode has changed from AUTO <-> MANUAL,
     ** change the service_req_type as USER_SELECTION.
     ** Else there is some system parameter like band or mode pref
     ** change. Assign srv_req_type to SYSTEM_CHANGE.
     */

    if( ss_ptr->pref_reason == SD_SS_PREF_REAS_USER_RESEL )
    {
      sdss_set_srv_req_type( SD_SS_MAIN, SD_SS_SRV_REQ_TYPE_USER_SELECTION );
    }
    else
    {
      sdss_set_srv_req_type( SD_SS_MAIN, SD_SS_SRV_REQ_TYPE_SYSTEM_CHANGE );
    }
  }
  /*
  **  after manual plmn selection, if a call originated before service confirmation from NAS
  **  service request shouldnot be of type USER SELECTION. Hence changing to NORMAL
  **  CR490242 USER SELECTION will  reset the LU counter if Managed roaming feature is
  **  enabled which is a spec violation.
  */
  else if( (ss_ptr->pref_reason == SD_SS_PREF_REAS_ORIG_RESUME ||
            ss_ptr->pref_reason == SD_SS_PREF_REAS_ORIG_START_CS ||
            ss_ptr->pref_reason == SD_SS_PREF_REAS_ORIG_START_PS    ) &&
           ((sdss_is_orig_mode( SD_SS_MAIN, SD_SS_ORIG_MODE_VAL_MANUAL ) &&
            (sdss_ptr(SD_SS_MAIN)->srv_req_type == SD_SS_SRV_REQ_TYPE_USER_SELECTION)) ||
            (sdss_ptr(SD_SS_MAIN)->srv_req_type == SD_SS_SRV_REQ_TYPE_BSR))
         )
  {
    sdss_set_srv_req_type( SD_SS_MAIN, SD_SS_SRV_REQ_TYPE_NORMAL );
  }

  if ( pref_update_reason == SD_SS_PREF_UPDATE_REASON_EF_RAT_MODE_CHG )
  {
    sdss_set_srv_req_type( SD_SS_MAIN, SD_SS_SRV_REQ_TYPE_EF_RAT_REFRESH );
  }
  #ifdef FEATURE_MMODE_DYNAMIC_SV_OPERATION_SWITCH
  else if( pref_update_reason == SD_SS_PREF_UPDATE_REASON_SWITCH_SVLTE )
  {
    sdss_set_sv_opr_act( SDSS_SV_OPR_ACT_SWITCH_SVLTE );
  }
  else if ( pref_update_reason == SD_SS_PREF_UPDATE_REASON_SWITCH_CSFB )
  {
    sdss_set_sv_opr_act( SDSS_SV_OPR_ACT_SWITCH_CSFB );
  }
  #endif
  else if(pref_update_reason == SD_SS_PREF_UPDATE_REASON_DDS_SWITCHBACK_FROM_TEMP)
  {
    ss_ptr->is_dds_switchback_from_temp = TRUE;
    SD_MSG_HIGH_0("Set is_dds_switchback_from_temp to TRUE");
  }

  /* If the camp_mode is set to NO_CHANGE, continue using the current stored
  ** value of camp_mode for further processing.
  */
  if( camp_mode == SD_SS_PREF_CAMP_MODE_NO_CHANGE )
  {
    camp_mode = sdss_get_camp_mode();
  }

  if ( !ss_ptr->is_gw_subsc_avail )
  {
      if(   (ss_ptr->prev_mode_pref       != mode_pref )||
            (ss_ptr->prev_band_pref       != band_pref) ||
            !SYS_LTE_BAND_MASK_CHK_IF_EQUAL(&(ss_ptr->lte_prev_band_pref),&lte_band_pref)||
            (ss_ptr->tds_prev_band_pref   != tds_band_pref))
     {
       is_mode_band_changed=TRUE;
      SD_MSG_HIGH_0("mode/ band changed: when GW subscription is not available");
      }
  }

  /* If none of the new preferences is different than the existing
  ** preferences, return FALSE.
  */
  if( ss_ptr->orig_mode == orig_mode &&
      curr_supp_mode_pref == new_supp_mode_pref &&
      curr_supp_band_pref == new_supp_band_pref &&
      SYS_LTE_BAND_MASK_CHK_IF_EQUAL(&curr_supp_band_pref_lte, &new_supp_band_pref_lte) &&
      curr_supp_band_pref_tds == new_supp_band_pref_tds &&
      ss_ptr->prl_pref == prl_pref &&
      ss_ptr->roam_pref == roam_pref &&
      sdss_is_hybr_pref( SD_SS_MAIN,  hybr_pref )       &&
      ss_ptr->acq_order_pref == acq_order_pref &&
      ss_ptr->domain_pref == domain_pref &&
      ! otasp_is_changed &&
      ! rat_acq_order_changed                           &&
      ! is_mode_band_changed                           &&
      (ss_ptr->voice_domain_pref == voice_domain_pref ||
      voice_domain_pref == SYS_VOICE_DOMAIN_PREF_NO_CHANGE) &&
      camp_mode               == sdss_get_camp_mode())
  {
    /* Check user_mode_pref change as well for reasons for which 
    ** user_mode_pref is updated*/
    if(!(ss_ptr->pref_reason == SD_SS_PREF_REAS_USER ||
         ss_ptr->pref_reason == SD_SS_PREF_REAS_MULTIMODE_SCAN ||
         ss_ptr->pref_reason == SD_SS_PREF_REAS_USER_RESEL ||
         ss_ptr->pref_reason == SD_SS_PREF_REAS_RESTORE)
         ||
         ss_ptr->user_mode_pref == user_mode_pref
       )
     {
       modem_mem_free(ss_rat_pri_list_info,MODEM_MEM_CLIENT_MMODE);
       return ss_ptr->ss_pref_updated_status;
     }
  }

  /* gw subs avail, mode pref does not have LTE,
  ** true mode pref has LTE and band pref has LTE
  ** error fatal since this is incorrect state
  */
  if(sdss_is_featuremode(SYS_OVERALL_FEATURE_MODE_SRLTE)
    && ss_ptr->is_gw_subsc_avail
    && SD_MODE_CONTAIN(user_mode_pref, SD_SS_MODE_PREF_LTE)
    && SD_MODE_CONTAIN(ss_ptr->true_mode_pref, SD_SS_MODE_PREF_LTE)
    && SYS_LTE_BAND_MASK_CHK_IF_OVERLAP(&lte_band_pref, &sdss_common.lte_band_capability)
    && !SD_MODE_CONTAIN(mode_pref, SD_SS_MODE_PREF_LTE)
    && pref_reason == SD_SS_PREF_REAS_USER
    && orig_mode == SD_SS_ORIG_MODE_NONE)
  {
    sd_print_lte_band_mask(lte_band_pref);
    SD_ERR_FATAL_1("mode pref: %d, does not have LTE, true mode pref has LTE when gw subs avail",
                     mode_pref );
  }

   /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


  /* Update the current preferences.
  */
  sdss_set_mode_band_pref( SD_SS_MAIN,
                           mode_pref,
                           band_pref,
                           lte_band_pref,
                           tds_band_pref);

  sdss_set_hybr_pref( SD_SS_MAIN, hybr_pref );

  ss_ptr->orig_mode     = orig_mode;
  ss_ptr->prl_pref      = prl_pref;
  ss_ptr->roam_pref     = roam_pref;

  ss_ptr->otasp_band    = otasp_band;
  ss_ptr->otasp_blksys  = otasp_blksys;

  ss_ptr->acq_order_pref= acq_order_pref;
  ss_ptr->domain_pref   = domain_pref;
  if(voice_domain_pref != SYS_VOICE_DOMAIN_PREF_NO_CHANGE)
  ss_ptr->voice_domain_pref = voice_domain_pref;

  /* If current camp_mode is ON and the incoming value is OFF, set the flag.
  */
  if( sdss_get_camp_mode()== SD_SS_PREF_CAMP_MODE_ON &&
      camp_mode == SD_SS_PREF_CAMP_MODE_OFF
    )
  {
    *sdss_misc_sglte_move_to_unrestricted()=TRUE;
  }

  sdss_set_camp_mode( camp_mode );


  if (sdss_is_full_srv_req_for_emerg_orig(SD_SS_MAIN))
  {
    sdss_update_is_full_srv_req_during_emerg( SD_SS_MAIN, TRUE );
  }
  
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* do not update the rat priority list in SD core if UE is currently in
  ** RLF recovery during an emergency call / callback mode.
  ** Do not update RAT PRI LIST if FULL SRV is needed for emergency call.
  */
  if(! ((sdss_is_orig_mode0(orig_mode,SD_SS_ORIG_MODE_VAL_EMERG)  &&
         sdss_get_is_RLF_during_emerg(SD_SS_MAIN)) ||
         sdss_get_is_full_srv_req_during_emerg(SD_SS_MAIN)))
  {
    sdss_set_rat_pri_list_info(SD_SS_MAIN, ss_rat_pri_list_info);
  }
  
  SD_MSG_HIGH_2("RAT PRI LIST prev_mode_pref %d curr mode_pref %d",\
              ss_ptr->prev_mode_pref, ss_ptr->mode_pref);
  /* the following information - idle_rat_pri_list_info and idle_orig_mode
  ** is required for the purpose of emergency call origination over LTE
  */
  /* update the idle rat priority list information and orig mode
  */
  if( orig_mode == SD_SS_ORIG_MODE_NONE ||
      orig_mode == SD_SS_ORIG_MODE_MANUAL_IDLE  )
  {
    ss_ptr->idle_orig_mode = orig_mode;

    /* update idle mode rat priority list */
    *(&(ss_ptr->idle_rat_pri_list_info)) = *ss_rat_pri_list_info;
  }

  /* update the emergency mode rat priority list
  */
  if( orig_mode == SD_SS_ORIG_MODE_EMERG_ORIG ||
      orig_mode == SD_SS_ORIG_MODE_EMERG_CB ||
      ((orig_mode == SD_SS_ORIG_MODE_PPCSFB_EMERG_ORIG) &&
       sdss_get_is_full_srv_req_during_emerg(SD_SS_MAIN)))
  {
    *(&(ss_ptr->emerg_rat_pri_list_info)) = *ss_rat_pri_list_info;
  }

  if( ( orig_mode == SD_SS_ORIG_MODE_EMERG_ORIG ||
      orig_mode == SD_SS_ORIG_MODE_EMERG_CB ) &&
      sdss_is_ral_stored_in_efs(SD_SS_MAIN))
  {
    *(&(ss_ptr->emerg_rat_pri_list_info)) = *ss_rat_pri_list_info;
    /* in case if store_ral_in_efs is set then we need to 
         order emerg_rat_pri_list_info by emergency rat acq order */
    sdss_order_pri_list_per_emerg_rat_acq_order(&ss_ptr->emerg_rat_pri_list_info, SD_SS_MAIN);
  }


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Update the user_mode_preference
  */
  if(ss_ptr->pref_reason == SD_SS_PREF_REAS_USER ||
     ss_ptr->pref_reason == SD_SS_PREF_REAS_MULTIMODE_SCAN ||
     ss_ptr->pref_reason == SD_SS_PREF_REAS_USER_RESEL ||
     ss_ptr->pref_reason == SD_SS_PREF_REAS_RESTORE)
  {
    ss_ptr->user_mode_pref = user_mode_pref;
    ss_ptr->user_true_mode_pref = ss_ptr->true_mode_pref;
    ss_ptr->user_band_pref = band_pref;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Update the handoff state if the reason is for a handoff
  */
  if( pref_reason == SD_SS_PREF_REAS_HDR_CDMA_HO )
  {
    /* Update the SS-Core with the handoff type.
    */
    sdss_ho_update( SD_SS_MAIN, SD_SS_HO_HDR_TO_CDMA );
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Overwrite the ss_pref_updated_status.
  **
  ** Regardless if orig mode or pref reason is changed or not,
  ** if only service domain is changed and all other preferences remains same,
  ** overwrite with SDSS_PREF_UPDATED_SRV_DOMAIN.
  **
  ** Otherwise overwrite with SDSS_PREF_UPDATED_TRUE_PREF.
  */
  if( curr_supp_mode_pref         == new_supp_mode_pref     &&
      curr_supp_band_pref         == new_supp_band_pref     &&
      SYS_LTE_BAND_MASK_CHK_IF_EQUAL(&curr_supp_band_pref_lte,&new_supp_band_pref_lte) &&
      curr_supp_band_pref_tds     == new_supp_band_pref_tds &&
      ss_ptr->prev_prl_pref       == ss_ptr->prl_pref       &&
      ss_ptr->prev_roam_pref      == ss_ptr->roam_pref      &&
      !sdss_is_hybr_pref_chgd( SD_SS_MAIN )                 &&
      ss_ptr->prev_acq_order_pref == ss_ptr->acq_order_pref &&
      ss_ptr->prev_domain_pref    != ss_ptr->domain_pref    &&
      ! otasp_is_changed                                    &&
      ! rat_acq_order_changed)
  {
    ss_ptr->ss_pref_updated_status = SDSS_PREF_UPDATED_SRV_DOMAIN;
  }
  else if ( curr_supp_mode_pref         == new_supp_mode_pref     &&
      curr_supp_band_pref         == new_supp_band_pref     &&
      SYS_LTE_BAND_MASK_CHK_IF_EQUAL(&curr_supp_band_pref_lte,&new_supp_band_pref_lte) &&
      curr_supp_band_pref_tds     == new_supp_band_pref_tds &&
      ss_ptr->prev_prl_pref       == ss_ptr->prl_pref       &&
      ss_ptr->prev_roam_pref      == ss_ptr->roam_pref      &&
      !sdss_is_hybr_pref_chgd( SD_SS_MAIN )                 &&
      ss_ptr->prev_acq_order_pref == ss_ptr->acq_order_pref &&
      ss_ptr->prev_domain_pref    == ss_ptr->domain_pref    &&
      ss_ptr->prev_voice_domain_pref != ss_ptr->voice_domain_pref &&
      ! otasp_is_changed                                    &&
      ! rat_acq_order_changed)
  {
    ss_ptr->ss_pref_updated_status = SDSS_PREF_UPDATED_UE_CAPABILITY_CHG;
  }
  else
  {
    #if defined (FEATURE_EOOS)
    #error code not present
#elif defined(FEATURE_LTE_TO_1X)
    if (ss_ptr->ss_pref_updated_status != SDSS_PREF_UPDATED_1XCSFB_ORIG_END)
           {
      ss_ptr->ss_pref_updated_status = SDSS_PREF_UPDATED_TRUE_PREF;
        }
    #else
    ss_ptr->ss_pref_updated_status = SDSS_PREF_UPDATED_TRUE_PREF;
    #endif

  }

  /* Return pref updated status.
  */
  modem_mem_free(ss_rat_pri_list_info,MODEM_MEM_CLIENT_MMODE);
  return(  ss_ptr->ss_pref_updated_status );

} /* sdss_pref_update */

#ifdef FEATURE_HDR_HYBRID
/* <EJECT> */
/*===========================================================================

FUNCTION sdss_hdr_pref_update

DESCRIPTION
  Update the HDR SS-Preference setting of the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if any of the new preferences is different than the existing
  preferences. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sdss_pref_updated_e_type      sdss_hdr_pref_update(

        sd_ss_pref_reas_e_type        pref_reason,
            /* Reason for changing the SS-Preference.
            */

        sd_ss_orig_mode_e_type        orig_mode,
            /* New origination mode (normal, OTASP, emergency, other, etc.).
            */

        sd_ss_mode_pref_e_type        mode_pref,
            /* New mode preference (AMPS, CDMA, any, etc.) - ignored when
            ** orig_mode = OTASP or emergency.
            */

        sd_ss_band_pref_e_type        band_pref,
            /* New band preference (BC0, BC1, any, etc.) - ignored when
            ** orig_mode = OTASP or emergency..
            */

        sd_ss_prl_pref_e_type         prl_pref,
            /* New prl system preference (Available BC0A, available BC0B, etc.)
            */

        sd_ss_roam_pref_e_type        roam_pref,
            /* New roam preference (any, home, affiliated, etc.) - ignored
            ** when orig_mode = OTASP or emergency..
            */

        sd_ss_hybr_pref_e_type        hybr_pref,
            /* New hybrid preference (none, CDMA/HDR).
            */

        sd_ss_srv_domain_pref_e_type   domain_pref,
            /* Service domain preference that is associated with the selected
            ** NAM.
            ** Applies only for GSM/WCDMA modes.
            */

        sd_ss_acq_order_pref_e_type    acq_order_pref
            /* Preference for the order of acquisition ( WCDMA before GSM,
            ** GSM before WCDMA etc).
            */

)
{

  sdss_s_type             *ss_ptr           = sdss_ptr(SD_SS_HYBR_1);
  sd_ss_mode_pref_e_type  new_supp_mode_pref;
  sd_ss_mode_pref_e_type  curr_supp_mode_pref;
  sd_ss_band_pref_e_type  new_supp_band_pref;
  sd_ss_band_pref_e_type  curr_supp_band_pref;

  sd_ss_mode_pref_e_type  ss_mode_pref      = SD_SS_MODE_PREF_NONE;
  sd_ss_band_pref_e_type  ss_band_pref      = SD_SS_BAND_PREF_NONE;
  sys_lte_band_mask_e_type  ss_lte_band_pref= SYS_LTE_BAND_MASK_CONST_NONE;
  sd_ss_band_pref_e_type  ss_tds_band_pref  = SD_SS_BAND_PREF_NONE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( pref_reason, SD_SS_PREF_REAS_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( orig_mode, SD_SS_ORIG_MODE_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( mode_pref, SD_SS_MODE_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( band_pref, SD_SS_BAND_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( prl_pref,  SD_SS_PRL_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( roam_pref, SD_SS_ROAM_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( hybr_pref, SD_SS_HYBR_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( domain_pref, SD_SS_SRV_DOMAIN_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( acq_order_pref, SD_SS_ACQ_ORDER_PREF_MAX );


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Initialize to SDSS_PREF_UPDATED_NONE
  */
  ss_ptr->ss_pref_updated_status = SDSS_PREF_UPDATED_NONE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Isolate the HDR mode pref.
  */
  mode_pref = SD_GET_COMMON_MODE( mode_pref, SD_SS_MODE_PREF_HDR);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If not doing hybrid operation, set mode preference to NONE.
  */
  if( hybr_pref == SD_SS_HYBR_PREF_NONE )
  {
    mode_pref = SD_SS_MODE_PREF_NONE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #ifdef FEATURE_HICPS_STACK_SYNC_UP
  /* If we are forcing the preferences to HDR because of Stack Sync-Up
  ** then filter the event (dont update anything) If a call origination
  ** is happening on HDR
  */
  if( pref_reason == SD_SS_PREF_REAS_STACK_SYNC_UP &&
      SD_IS_BIT_CONTAIN( SDSSSCR_PREF_REAS_VAL_CALL_ORIG,
                         BM(ss_ptr->pref_reason))
     )
  {
      return ss_ptr->ss_pref_updated_status;
  }
  #endif /* FEATURE_HICPS_STACK_SYNC_UP */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Record the current origination mode and update the reson for this
  ** SS-Preference update.
  */
  ss_ptr->orig_mode_prev = ss_ptr->orig_mode;
  if ( ss_ptr->pref_reason != pref_reason )
  {
    ss_ptr->pref_reason    = pref_reason;
    ss_ptr->ss_pref_updated_status = SDSS_PREF_UPDATED_PREF_REAS;
  }


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Adjust the mode_pref based on the subscription availability, only if
  ** it is not emergency origination.
  */
  if ( orig_mode != SD_SS_ORIG_MODE_EMERG_ORIG &&
       orig_mode != SD_SS_ORIG_MODE_EMERG_CB )
  {

    /* Check if 1x subscription is available?
    */
    if ( !ss_ptr->is_1x_subsc_avail )
    {
       /* 1x subscription is not available, reset CDMA, AMPS & HDR modes.
       */
       mode_pref = SD_MODE_DELETE( mode_pref, SD_SS_MODE_PREF_CDMA_AMPS );
       mode_pref = SD_MODE_DELETE( mode_pref, SD_SS_MODE_PREF_HDR);

    } /*  if ( !ss_ptr->is_1x_subsc_avail ) */

    /* Check if GW subscription is available.
    */
    if ( !ss_ptr->is_gw_subsc_avail )
    {
      /* gw subscription is not available, reset GSM & WCDMA modes.
      */
      mode_pref = SD_MODE_DELETE( mode_pref, SD_SS_MODE_PREF_TDS_GSM_WCDMA_LTE);

    } /* if ( !ss_ptr->is_gw_subsc_avail ) */


  } /* if ( orig_mode != SD_SS_ORIG_MODE_EMERG_ORIG ... ) */



  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Get current/new supported mode/band pref.
  */

  sdss_get_mode_band_pref( SD_SS_HYBR_1,
                           &ss_mode_pref,
                           &ss_band_pref,
                           &ss_lte_band_pref,
                           &ss_tds_band_pref );

  curr_supp_mode_pref  = ss_mode_pref;
  curr_supp_band_pref  = ss_band_pref;

  sd_misc_get_band_mode( &curr_supp_mode_pref, &curr_supp_band_pref,
                         SD_SS_MODE_PREF_ANY, SD_SS_BAND_PREF_ANY
                       );

  new_supp_mode_pref  = mode_pref;
  new_supp_band_pref  = band_pref;
  sd_misc_get_band_mode( &new_supp_mode_pref, &new_supp_band_pref,
                         SD_SS_MODE_PREF_ANY, SD_SS_BAND_PREF_ANY
                       );


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Update the previous preferences fields.
  */
  ss_ptr->prev_mode_pref       = ss_mode_pref;
  ss_ptr->prev_band_pref       = ss_band_pref;
  ss_ptr->lte_prev_band_pref   = ss_lte_band_pref;
  ss_ptr->tds_prev_band_pref   = ss_tds_band_pref;

  ss_ptr->prev_prl_pref        = ss_ptr->prl_pref;
  ss_ptr->prev_roam_pref       = ss_ptr->roam_pref;
  ss_ptr->prev_domain_pref     = ss_ptr->domain_pref;
  ss_ptr->prev_acq_order_pref  = ss_ptr->acq_order_pref;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If none of the new preferences is different than the existing
  ** preferences, return FALSE.
  */
  if( ss_ptr->orig_mode      == orig_mode          &&
      curr_supp_mode_pref    == new_supp_mode_pref &&
      curr_supp_band_pref    == new_supp_band_pref &&
      ss_ptr->roam_pref      == roam_pref          &&
      ss_ptr->prl_pref       == prl_pref           &&
      sdss_is_hybr_pref( SD_SS_HYBR_1, hybr_pref ) &&
      ss_ptr->acq_order_pref == acq_order_pref     &&
      ss_ptr->domain_pref    == domain_pref
    )
  {
    return ss_ptr->ss_pref_updated_status;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Update the existing preferences.

  ss_ptr->mode_pref     = mode_pref;
  ss_ptr->band_pref     = band_pref;*/
  sdss_set_mode_band_pref( SD_SS_HYBR_1,
                           mode_pref,
                           band_pref,
                           ss_lte_band_pref,
                           ss_tds_band_pref );

  sdss_set_hybr_pref( SD_SS_HYBR_1, hybr_pref );

  ss_ptr->orig_mode     = orig_mode;
  ss_ptr->prl_pref      = prl_pref;
  ss_ptr->roam_pref     = roam_pref;
  ss_ptr->acq_order_pref= acq_order_pref;
  ss_ptr->domain_pref   = domain_pref;
  ss_ptr->ss_pref_updated_status = SDSS_PREF_UPDATED_TRUE_PREF;

  /* update PRL Support HDR Indication
  */
  ss_ptr->is_prl_support_hdr =  sdprl_is_supp_mode_band_pref(
                                                     SD_SS_MODE_PREF_HDR,
                                                     band_pref,
                                                     SYS_LTE_BAND_MASK_CONST_NONE,
                                                     SD_SS_BAND_PREF_NONE);
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Return TRUE.
  */
  return ss_ptr->ss_pref_updated_status;

} /* sdss_hdr_pref_update */
#endif /* FEATURE_HDR_HYBRID */

/*===========================================================================

FUNCTION sdss_hybr_2_pref_update

DESCRIPTION
  Update the SS-Preference setting of the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if any of the new preferences is different than the existing
  preferences. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sdss_pref_updated_e_type      sdss_hybr_2_pref_update(

        sd_ss_pref_reas_e_type        pref_reason,
            /* Reason for changing the SS-Preference.
            */

        sd_ss_orig_mode_e_type        orig_mode,
            /* New origination mode (normal, OTASP, emergency, other, etc.).
            */

        sd_ss_mode_pref_e_type        mode_pref,
            /* New mode preference (AMPS, CDMA, any, etc.) - ignored when
            ** orig_mode = OTASP or emergency.
            */

        sd_ss_band_pref_e_type        band_pref,
            /* New band preference (BC0, BC1, any, etc.) - ignored when
            ** orig_mode = OTASP or emergency..
            */

        sys_lte_band_mask_e_type      lte_band_pref,
            /* New LTE band preference
            */

        sd_ss_band_pref_e_type        tds_band_pref,
            /* New TDS band preference
            */

        sd_ss_prl_pref_e_type         prl_pref,
            /* New prl system preference (Available BC0A, available BC0B, etc.)
            */

        sd_ss_roam_pref_e_type        roam_pref,
            /* New roam preference (any, home, affiliated, etc.) - ignored
            ** when orig_mode = OTASP or emergency..
            */

        sd_ss_hybr_pref_e_type        hybr_pref,
            /* New hybrid preference (none, CDMA/HDR).
            */

        sd_band_e_type                otasp_band,
            /* The band-class that is associated with OTASP origination mode.
            ** Note that this parameter is ignored if orig_mode != OTASP.
            */

        sd_blksys_e_type              otasp_blksys,
            /* The PCS frequency block/Cellular system that is associated
            ** with OTASP origination mode. Note that this parameter is
            ** ignored if orig_mode != OTASP.
            */


        sd_ss_srv_domain_pref_e_type   domain_pref,
            /* Service domain preference that is associated with the selected
            ** NAM.
            ** Applies only for GSM/WCDMA modes.
            */

        sd_ss_acq_order_pref_e_type    acq_order_pref,
            /* Preference for the order of acquisition ( WCDMA before GSM,
            ** GSM before WCDMA etc).
            */

        sd_ss_pref_update_reason_e_type     pref_update_reason,
            /**Prefernce change reason
            */

        sd_ss_mode_pref_e_type        user_mode_pref,
            /* New mode preference (AMPS, CDMA, any, etc.) - ignored when
            ** orig_mode = OTASP or emergency.
            */

        sys_voice_domain_pref_e_type   voice_domain_pref,
           /**Voice domain pref
           */

        const sd_rat_acq_order_s_type      *rat_acq_order_ptr
           /**< Rat acquisition order including LTE.
           */

)
{

  sdss_s_type             *ss_ptr           = sdss_ptr(SD_SS_HYBR_2);
  sd_ss_mode_pref_e_type  new_supp_mode_pref;
  sd_ss_mode_pref_e_type  curr_supp_mode_pref;
  sd_ss_band_pref_e_type  new_supp_band_pref;
  sd_ss_band_pref_e_type  curr_supp_band_pref;
  sys_lte_band_mask_e_type  curr_supp_lte_band_pref = SYS_LTE_BAND_MASK_CONST_ANY;
  sys_lte_band_mask_e_type  new_supp_lte_band_pref;
  sd_ss_band_pref_e_type  curr_supp_tds_band_pref;
  sd_ss_band_pref_e_type  new_supp_tds_band_pref;

  sd_ss_mode_pref_e_type  ss_mode_pref      = SD_SS_MODE_PREF_NONE;
  sd_ss_band_pref_e_type  ss_band_pref      = SD_SS_BAND_PREF_NONE;
  sys_lte_band_mask_e_type  ss_lte_band_pref  = SYS_LTE_BAND_MASK_CONST_NONE;
  sd_ss_band_pref_e_type  ss_tds_band_pref  = SD_SS_BAND_PREF_NONE;
  boolean                        is_mode_band_changed = FALSE;
  boolean                        rat_acq_order_changed = FALSE;

  #if defined(FEATURE_MMODE_SC_SVLTE) || defined (FEATURE_MMODE_DUAL_SIM) || defined FEATURE_MMODE_SC_SGLTE
  sd_ss_mode_pref_e_type          acq_sys_mode_pref;
  sys_sys_mode_e_type             acq_sys_mode;
  uint16                          i;
  uint16                          j;
  sys_priority_list_info_s_type   *rat_info;
  sys_rat_pri_list_info_s_type    ss_rat_pri_list_info;
  sd_ss_mode_pref_e_type filtr_mode_pref;
  #endif //FEATURE_MMODE_SC_SVLTE

  #if defined(FEATURE_SD_LTE)
  mmgsdi_app_enum_type            ss_gwl_app_type = sdss_get_session_info(SD_SS_HYBR_2);
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( pref_reason, SD_SS_PREF_REAS_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( orig_mode, SD_SS_ORIG_MODE_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( mode_pref, SD_SS_MODE_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( user_mode_pref, SD_SS_MODE_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( band_pref, SD_SS_BAND_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( tds_band_pref, SD_SS_BAND_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( prl_pref,  SD_SS_PRL_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( roam_pref, SD_SS_ROAM_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( hybr_pref, SD_SS_HYBR_PREF_MAX );
  SD_ASSERT( INRANGE(domain_pref, SD_SS_SRV_DOMAIN_PREF_NONE,
                     (SD_SS_SRV_DOMAIN_PREF_MAX-1)) );
  SD_ASSERT_ENUM_IS_INRANGE( acq_order_pref, SD_SS_ACQ_ORDER_PREF_MAX );

  SD_ASSERT_ENUM_IS_INRANGE_INC( otasp_band, SD_BAND_MAX );
  SD_ASSERT_ENUM_IS_INRANGE_INC( otasp_blksys, SD_BLKSYS_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  //How about iSGLTE?

  /* Only GWT permitted on HYBR_2 stack
  */
  if(sdss_is_featuremode(SYS_OVERALL_FEATURE_MODE_MULTISIM))
  {
    mode_pref = SD_GET_COMMON_MODE( mode_pref, SD_SS_MODE_PREF_TDS_GSM_WCDMA_LTE);
    SD_MSG_HIGH_1("mode_pref %d",mode_pref);
  }

  /* If the service domain is NONE, remove GW components from the mode_pref.
  ** Service domain doesn't affect non-GW systems.
  */
  if(domain_pref == SD_SS_SRV_DOMAIN_PREF_NONE)
  {
    mode_pref = SD_MODE_DELETE(mode_pref, SD_SS_MODE_PREF_TDS_GSM_WCDMA_LTE);
  }

 #if defined(FEATURE_SD_LTE)
   if ( ss_gwl_app_type ==  MMGSDI_APP_SIM 
#ifdef FEATURE_ECALL_IVS
      || (ecall_get_ecall_operating_mode() ==  ECALL_MODE_ECALL_ONLY)
#endif
     )
 {
   /* SIM card type is 2G , remove LTE component from the mode_pref.
   */
   if( SD_MODE_CONTAIN( user_mode_pref, SD_SS_MODE_PREF_TDS_GSM_WCDMA ) &&
       SD_MODE_CONTAIN( user_mode_pref, SD_SS_MODE_PREF_GWL_LTE ) &&
       ( sdss_is_supp_mode_band_pref(SD_SS_MODE_PREF_GW, band_pref ) ||
         sdss_is_supp_mode_band_pref_tds(SD_SS_MODE_PREF_TDS, tds_band_pref ) )
     )
   {
     SD_MSG_HIGH_1( "HYBR2: Removing LTE as gwl_app_type received =%d or in ECALL only mode",
                  ss_gwl_app_type);

     mode_pref = SD_MODE_DELETE( mode_pref, SD_SS_MODE_PREF_GWL_LTE );
     user_mode_pref = SD_MODE_DELETE( user_mode_pref, SD_SS_MODE_PREF_GWL_LTE );
   }
 }

 if ( ( ( ss_gwl_app_type ==  MMGSDI_APP_SIM )||
        ( (sdss_get_operator_name ( SYS_MODEM_AS_ID_1 ) == SD_OPERATOR_CT ) && 
            !sdss_is_mmss_operation(SD_SS_MAIN) && !(ss_ptr->gprs_anite_gcf) ) )&&
      ( (hybr_pref == SD_SS_HYBR_PREF_CDMA__LTE__HDR)||
         sdss_is_1x_sxlte())
    )
 {
   /* Operator CT in Non MMSS, remove LTE component from the mode_pref.
   */
   SD_MSG_HIGH_3( "Removing LTE as gwl_app_type received =%d,is_mmss:%d,hybr_pref:%d",
                  ss_gwl_app_type,sdss_is_mmss_operation(SD_SS_MAIN),hybr_pref);

   mode_pref = SD_MODE_DELETE( mode_pref, SD_SS_MODE_PREF_GWL_LTE );
   user_mode_pref = SD_MODE_DELETE( user_mode_pref, SD_SS_MODE_PREF_GWL_LTE );
 }

  /* Domain_pref is CS_ONLY, remove LTE component from the mode_pref.
  */
  if(domain_pref == SD_SS_SRV_DOMAIN_PREF_CS_ONLY &&
    orig_mode == SD_SS_ORIG_MODE_NONE &&
    ss_ptr->csg_id == SYS_CSG_ID_INVALID &&
    ss_ptr->csg_rat == SYS_RAT_NONE
    )
  {
    SD_MSG_HIGH_2("HYBR2: Removing LTE as DOMAIN_PREF is CS_ONLY, mode_pref = %d, user_mode_pref = %d",
                   mode_pref, user_mode_pref);

    mode_pref = SD_MODE_DELETE( mode_pref, SD_SS_MODE_PREF_GWL_LTE );
    user_mode_pref = SD_MODE_DELETE( user_mode_pref, SD_SS_MODE_PREF_GWL_LTE );
  }
 #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  ss_ptr->pref_update_reas = pref_update_reason;

  /* Initial ss_pref_updated_status to NONE.
  */
  ss_ptr->ss_pref_updated_status =  SDSS_PREF_UPDATED_NONE;


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Return TRUE if the command was to avoid the system.
  */
  if (pref_reason == SD_SS_PREF_REAS_AVOID_SYS )
  {
    ss_ptr->pref_reason            = pref_reason;
    ss_ptr->ss_pref_updated_status = SDSS_PREF_UPDATED_PREF_REAS;

    return ss_ptr->ss_pref_updated_status;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* CM indicates that the activity is ended on the other sub, set the flag so that
  ** acquisition can be attempted even in case of no TRM resource.
  */
  if (ss_ptr->pref_update_reas == SD_SS_PREF_UPDATE_REASON_TRM_UNLOCK &&
    sdss_get_acq_status_only(SD_SS_HYBR_2) == SYS_ACQ_STATUS_NO_RESOURCE 
  )
  {
    sdss_update_is_trm_unlock_in_progress(SD_SS_HYBR_2, TRUE);
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Store the true mode pref unadjusted based on subscription.
  */
  ss_ptr->true_mode_pref = mode_pref;

  /* Update rat_acq_order from preference passed in
  */
  if((rat_acq_order_ptr != NULL) &&
     (rat_acq_order_ptr->num_rat != 0) &&
     (rat_acq_order_ptr->acq_sys_mode[0] != SYS_SYS_MODE_NONE))
  {
    /* Update rat_acq_order if it's not same as before
    */
    if(sdss_update_rat_acq_order(rat_acq_order_ptr,
                              &ss_ptr->rat_acq_order))
    {
      rat_acq_order_changed = TRUE;
    }
}


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    SD_MSG_HIGH_2( "hybr2, rat_acq_order updated: %d sdss_hybr_2_pref_update(): Using user_mode_pref = %d for updating RAT priority list",
              rat_acq_order_changed,user_mode_pref);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Update the Rat priority list
  */
  #if defined(FEATURE_MMODE_SC_SVLTE) || defined (FEATURE_MMODE_DUAL_SIM) || defined FEATURE_MMODE_SC_SGLTE
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* update previous rat_pri_list_info
  */

  /* If UE is in full service at the time of emergency call end , update prev
  ** rat priority info with idle rat priority info ( preferences prior to emergency call orig).
  ** This will ensure that if the UE is being restored to the same preferences( prior to emergency call)
  ** no new service request is issued to NAS
  */
  if ( sdss_is_orig_mode0(ss_ptr->orig_mode ,SD_SS_ORIG_MODE_VAL_EMERG)&&
       !sdss_is_orig_mode0(orig_mode ,SD_SS_ORIG_MODE_VAL_EMERG) &&
       sdss_get_ss_state(SD_SS_HYBR_2) == SDSS_STATE_OPR &&
       sdss_is_srv_status2(SD_SS_HYBR_2, SDSSSCR_SRV_STATUS_VAL_SRV)
     )
  {
    SD_MSG_HIGH_0("LTE_911:update prev_rat_pri with idle");
    sdss_update_prev_rat_pri_list_info(SD_SS_HYBR_2, &ss_ptr->idle_rat_pri_list_info);
  }
  else
  {
    /* Store the last rat_pri_list_info
    */
    sdss_get_rat_pri_list_info(SD_SS_HYBR_2, &ss_rat_pri_list_info);
    sdss_update_prev_rat_pri_list_info(SD_SS_HYBR_2, &ss_rat_pri_list_info);
  }
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if(sdss_is_1x_sxlte())
  {
    /* consider the mode pref on both HYBR1 and HYBR2
    */
    sdss_get_mode_band_pref( SD_SS_HYBR_1,
                             &ss_mode_pref,
                             &ss_band_pref,
                             &ss_lte_band_pref,
                             &ss_tds_band_pref );

    new_supp_mode_pref      = SD_MODE_ADD(user_mode_pref, ss_mode_pref);

    /* If Hybr_1 has no HDR, If 1x subsc is available and
       user mode pref has HDR, add HDR */
    if(!sd_misc_is_mode_pref(new_supp_mode_pref, SD_SS_MODE_PREF_HDR))
    {
      if(SD_BIT_COMMON(sdss_get_subsc_type(SD_SS_MAIN), SDSS_SUBSC_1X))
      {
        SD_MSG_HIGH_0("Nikel:HYBR_1 has no HDR, check main.");

        if(sd_misc_is_mode_pref(ss_ptr->user_mode_pref, SD_SS_MODE_PREF_HDR))
        {
          new_supp_mode_pref = SD_MODE_ADD(new_supp_mode_pref,
                                           SD_SS_MODE_PREF_HDR);
        }
      }
    }
  }
  else
  {
    new_supp_mode_pref = user_mode_pref;
  }
  new_supp_band_pref      = band_pref;
  new_supp_lte_band_pref  = lte_band_pref;
  new_supp_tds_band_pref  = tds_band_pref;

  /* Reset rat pri list info */
  memset(&(ss_rat_pri_list_info),
         0,
         sizeof(sys_rat_pri_list_info_s_type));

  /* Filter out all modes except for HDR and LTE
  ** Filter out modes and bands not supported by the target cap /user setting
  */
  if(sdss_is_1x_sxlte())
  {
    filtr_mode_pref = SD_SS_MODE_PREF_CDMA_HDR_LTE;
  }
  else
  {
    filtr_mode_pref = SD_SS_MODE_PREF_ANY;
  }

  sd_misc_get_band_mode_mmode( &new_supp_mode_pref,
                               &new_supp_band_pref,
                               &new_supp_lte_band_pref,
                               &new_supp_tds_band_pref,
                               filtr_mode_pref,
                               SD_SS_BAND_PREF_ANY,
                               SYS_LTE_BAND_MASK_CONST_ANY,
                               SD_SS_BAND_PREF_TDS_ANY );

  for( i=0, j=0; i < ss_ptr->rat_acq_order.num_rat; i++ )
  {
    acq_sys_mode      = ss_ptr->rat_acq_order.acq_sys_mode[i];
    acq_sys_mode_pref = sdss_map_mode_to_mode_pref(acq_sys_mode);
    if( SD_MODE_CONTAIN(new_supp_mode_pref, acq_sys_mode_pref) )
    {
      rat_info = &(ss_rat_pri_list_info.priority_list_info[j]);

      rat_info->acq_sys_mode         =  acq_sys_mode;

      SD_MSG_HIGH_1( "hybr_2_pref_update: Adding RAT acq_sys_mode = %d ", acq_sys_mode);

      /* Set band capability based on RAT */
      if ( acq_sys_mode == SYS_SYS_MODE_LTE )
      {
        rat_info->band_cap.lte_band_cap = new_supp_lte_band_pref;
      }
      else if ( acq_sys_mode == SYS_SYS_MODE_TDS )
      {
        rat_info->band_cap.chgwt_band_cap = new_supp_tds_band_pref;
      }
      else
      {
        rat_info->band_cap.chgwt_band_cap = new_supp_band_pref;
      }

      /* Initialize bst_rat_acq_required to TRUE by default and set the
      ** bst_band_cap to be equal to the band_cap. This can be
      ** reset at the time of sending service request to NAS.
      */
      rat_info->bst_rat_acq_required = TRUE;
      rat_info->bst_band_cap         = rat_info->band_cap;
      j++;
    }
  }

  ss_rat_pri_list_info.num_items = j;

  /* do not update the rat priority list in SD core if UE is currently in
  ** RLF recovery during an emergency call / callback mode
  */
  if(! (sdss_is_orig_mode0(orig_mode,SD_SS_ORIG_MODE_VAL_EMERG)  &&
         sdss_get_is_RLF_during_emerg(SD_SS_HYBR_2) ))
  {
  sdss_set_rat_pri_list_info( SD_SS_HYBR_2, &ss_rat_pri_list_info);
  }

  /* Stop LTE connected mode operation as soon as device moved to CS only mode.
  */
  if (ss_rat_pri_list_info.num_items == 1 &&
      ss_rat_pri_list_info.priority_list_info[0].acq_sys_mode == SD_MODE_LTE && 
      domain_pref == SD_SS_SRV_DOMAIN_PREF_CS_ONLY) 
  {
    SD_MSG_HIGH_0("LTE moved to CS only mode, Reset RLF on hybr2");
    sdss_reset_lte_connected_mode (SD_SS_HYBR_2);
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* the following information - idle_rat_pri_list_info and idle_orig_mode
  ** is required for the purpose of emergency call origination over LTE
  */
  /* update the idle rat priority list information and orig mode
  */
  if( orig_mode == SD_SS_ORIG_MODE_NONE ||
      orig_mode == SD_SS_ORIG_MODE_MANUAL_IDLE  )
  {
    ss_ptr->idle_orig_mode = orig_mode;

    /* update idle mode rat priority list */
    ss_ptr->idle_rat_pri_list_info = ss_rat_pri_list_info;
  }

  /* update the emergency mode rat priority list
  */
  if( orig_mode == SD_SS_ORIG_MODE_EMERG_ORIG ||
      orig_mode == SD_SS_ORIG_MODE_EMERG_CB )
  {
    ss_ptr->emerg_rat_pri_list_info = ss_rat_pri_list_info;
  }


  #endif //FEATURE_MMODE_SC_SVLTE


  SD_MSG_HIGH_1 ("pref_update_reason: %d",
               pref_update_reason);

  #ifdef FEATURE_MMODE_DYNAMIC_SV_OPERATION_SWITCH
  if( pref_update_reason == SD_SS_PREF_UPDATE_REASON_SWITCH_SVLTE )
  {
    sdss_set_sv_opr_act( SDSS_SV_OPR_ACT_SWITCH_SVLTE );
  }
  else if ( pref_update_reason == SD_SS_PREF_UPDATE_REASON_SWITCH_CSFB )
  {
    sdss_set_sv_opr_act( SDSS_SV_OPR_ACT_SWITCH_CSFB );
  }
  else
  #endif /* FEATURE_MMODE_DYNAMIC_SV_OPERATION_SWITCH */
  if(pref_update_reason == SD_SS_PREF_UPDATE_REASON_DDS_SWITCHBACK_FROM_TEMP)
  {
    ss_ptr->is_dds_switchback_from_temp = TRUE;
    SD_MSG_HIGH_0("Set is_dds_switchback_from_temp to TRUE");
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Adjust the mode_pref based on the subscription availability, only if
  ** it is not emergency origination.
  */
  if ( orig_mode != SD_SS_ORIG_MODE_EMERG_ORIG &&
       orig_mode != SD_SS_ORIG_MODE_EMERG_CB )
  {

    if( (!sdss_is_featuremode(SYS_OVERALL_FEATURE_MODE_MULTISIM) ||
          (sdss_is_1x_sxlte() || sdss_is_sglte()))&&
          !ss_ptr->is_gw_subsc_avail  )
    {
         if(   (ss_ptr->prev_mode_pref       != mode_pref )||
               (ss_ptr->prev_band_pref       != band_pref) ||
               (!SYS_LTE_BAND_MASK_CHK_IF_EQUAL(&ss_ptr->lte_prev_band_pref,&lte_band_pref))
           )
        {
            is_mode_band_changed=TRUE;
           SD_MSG_HIGH_0("mode/ band changed: when GW subscription is not available");

        }
       /* gw subscription is not available, reset GWL modes.
       */
       mode_pref = SD_MODE_DELETE( mode_pref, SD_SS_MODE_PREF_TDS_GSM_WCDMA_LTE);
       ss_ptr->true_mode_pref = mode_pref;

    } /* if ( !ss_ptr->is_gw_subsc_avail ) */

    if ( sdss_is_featuremode(SYS_OVERALL_FEATURE_MODE_MULTISIM) &&
        !sdss_is_1x_sxlte() && !sdss_is_sglte() &&
         !ss_ptr->is_gw2_subsc_avail )
    {
      orig_mode = SD_SS_ORIG_MODE_EMERG_ORIG;
    }

    #if defined (FEATURE_MMODE_DUAL_SIM) && defined(FEATURE_SD_LTE)
    if( sdss_is_featuremode(SYS_OVERALL_FEATURE_MODE_MULTISIM) &&
        ss_rat_pri_list_info.num_items == 1 &&
        ss_rat_pri_list_info.priority_list_info[0].acq_sys_mode ==  SYS_SYS_MODE_LTE &&
        ss_gwl_app_type ==  MMGSDI_APP_SIM )
    {
      /* GW subscription available and card type is SIM (2G), but mode_pref is LTE  only.
      ** So keep in emergency mode.
      */
      orig_mode = SD_SS_ORIG_MODE_EMERG_ORIG;
      SD_MSG_HIGH_1(" Put emergency mode as UE is in LTE only mode and gwl_app_type =%d ",\
                  ss_gwl_app_type );
    }
    #endif

  } /* if ( orig_mode != SD_SS_ORIG_MODE_EMERG_ORIG ... ) */

#if defined(FEATURE_MMODE_SC_SVLTE) || defined (FEATURE_MMODE_DUAL_SIM) || defined FEATURE_MMODE_SC_SGLTE
  if( ( orig_mode == SD_SS_ORIG_MODE_EMERG_ORIG ||
      orig_mode == SD_SS_ORIG_MODE_EMERG_CB ) &&
      sdss_is_ral_stored_in_efs(SD_SS_HYBR_2))
  {
    ss_ptr->emerg_rat_pri_list_info = ss_rat_pri_list_info;
    /* in case if store_ral_in_efs is set then we need to 
         order emerg_rat_pri_list_info by emergency rat acq order */
    sdss_order_pri_list_per_emerg_rat_acq_order(&ss_ptr->emerg_rat_pri_list_info, SD_SS_HYBR_2);
  }
#endif

  SD_MSG_HIGH_1("mode pref: %d", mode_pref);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Record the current origination mode and update the reson for this
  ** SS-Preference update.
  */
  ss_ptr->orig_mode_prev = ss_ptr->orig_mode;
  if ( ss_ptr->pref_reason != pref_reason )
  {
    ss_ptr->pref_reason    = pref_reason;
    ss_ptr->ss_pref_updated_status = SDSS_PREF_UPDATED_PREF_REAS;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #if ( defined(FEATURE_UMTS_UNIFORM_OOS_HANDLING) )
  if( ss_ptr->ss_pref_updated_status == SDSS_PREF_UPDATED_PREF_REAS &&
      pref_reason                    == SD_SS_PREF_REAS_ORIG_END &&
      ss_ptr->orig_mode_prev         == SD_SS_ORIG_MODE_EMERG_ORIG )
  {
     ss_ptr->ss_pref_updated_status = SDSS_PREF_UPDATED_EMERG_ORIG_END;
  }
  #endif

  if(sdss_is_1x_sxlte() &&
    pref_update_reason == SD_SS_PREF_UPDATE_REASON_HYBR_BSR_TO_HDR_END_SUCCESS)
  {
    SD_MSG_HIGH_0("LTE_TO_HDR: Pref update HYBR_BSR_TO_HDR_END Success");
    ss_ptr->ss_pref_updated_status = SDSS_PREF_UPDATED_HYBR_BSR_TO_HDR_END;

  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Get current/new supported mode/band pref.
  */
  sdss_get_mode_band_pref( SD_SS_HYBR_2,
                           &ss_mode_pref,
                           &ss_band_pref,
                           &ss_lte_band_pref,
                           &ss_tds_band_pref );

  curr_supp_mode_pref     = ss_mode_pref;
  curr_supp_band_pref     = ss_band_pref;
  curr_supp_lte_band_pref = ss_lte_band_pref;
  curr_supp_tds_band_pref = ss_tds_band_pref;

  sd_misc_get_band_mode_mmode( &curr_supp_mode_pref,
                               &curr_supp_band_pref,
                               &curr_supp_lte_band_pref,
                               &curr_supp_tds_band_pref,
                               SD_SS_MODE_PREF_ANY,
                               SD_SS_BAND_PREF_ANY,
                               SYS_LTE_BAND_MASK_CONST_ANY,
                               SD_SS_BAND_PREF_TDS_ANY );

  new_supp_mode_pref      = mode_pref;
  new_supp_band_pref      = band_pref;
  new_supp_lte_band_pref  = lte_band_pref;
  new_supp_tds_band_pref  = tds_band_pref;

  sd_misc_get_band_mode_mmode( &new_supp_mode_pref,
                               &new_supp_band_pref,
                               &new_supp_lte_band_pref,
                               &new_supp_tds_band_pref,
                               SD_SS_MODE_PREF_ANY,
                               SD_SS_BAND_PREF_ANY,
                               SYS_LTE_BAND_MASK_CONST_ANY,
                               SD_SS_BAND_PREF_TDS_ANY );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Update the previous preferences fields.
  */
  ss_ptr->prev_mode_pref       = ss_mode_pref;
  ss_ptr->prev_band_pref       = ss_band_pref;
  ss_ptr->lte_prev_band_pref   = ss_lte_band_pref;
  ss_ptr->tds_prev_band_pref   = ss_tds_band_pref;

  ss_ptr->prev_prl_pref        = ss_ptr->prl_pref;
  ss_ptr->prev_roam_pref       = ss_ptr->roam_pref;
  ss_ptr->prev_domain_pref     = ss_ptr->domain_pref;
  ss_ptr->prev_acq_order_pref  = ss_ptr->acq_order_pref;
  ss_ptr->prev_voice_domain_pref = ss_ptr->voice_domain_pref;
  /* update PRL Support HDR Indication
  */
    ss_ptr->is_prl_support_hdr =
     sdprl_is_supp_mode_band_pref(SD_SS_MODE_PREF_HDR, band_pref,
                                  SYS_LTE_BAND_MASK_CONST_NONE, SD_SS_BAND_PREF_NONE);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Update the user_mode_preference
  */
  if(ss_ptr->pref_reason == SD_SS_PREF_REAS_USER ||
     ss_ptr->pref_reason == SD_SS_PREF_REAS_MULTIMODE_SCAN ||
     ss_ptr->pref_reason == SD_SS_PREF_REAS_USER_RESEL ||
     ss_ptr->pref_reason == SD_SS_PREF_REAS_RESTORE)
  {
     /* If the mode has changed from AUTO <-> MANUAL,
     ** change the service_req_type as USER_SELECTION.
     ** Else there is some system parameter like band or mode pref
     ** change. Assign srv_req_type to SYSTEM_CHANGE.
     */

    if( ss_ptr->pref_reason == SD_SS_PREF_REAS_USER_RESEL )
    {
      sdss_set_srv_req_type( SD_SS_HYBR_2, SD_SS_SRV_REQ_TYPE_USER_SELECTION );
    }
    else
    {
      sdss_set_srv_req_type( SD_SS_HYBR_2, SD_SS_SRV_REQ_TYPE_SYSTEM_CHANGE );
    }
  }

  /* lint -save -e831*/
  /* If none of the new preferences is different than the existing
  ** preferences, return FALSE.
  */
  if( ss_ptr->orig_mode       == orig_mode              &&
      curr_supp_mode_pref     == new_supp_mode_pref     &&
      curr_supp_band_pref     == new_supp_band_pref     &&
      SYS_LTE_BAND_MASK_CHK_IF_EQUAL(&curr_supp_lte_band_pref,&new_supp_lte_band_pref) &&
      curr_supp_tds_band_pref == new_supp_tds_band_pref &&
      ss_ptr->prl_pref        == prl_pref               &&
      ss_ptr->roam_pref       == roam_pref              &&
      sdss_is_hybr_pref( SD_SS_HYBR_2, hybr_pref )      &&
      ss_ptr->acq_order_pref  == acq_order_pref         &&
      ! is_mode_band_changed                &&
      ! rat_acq_order_changed                      &&
      ss_ptr->domain_pref     == domain_pref &&
      ss_ptr->voice_domain_pref == voice_domain_pref)
  {
    /* Check user_mode_pref change as well for reasons for which 
    ** user_mode_pref is updated*/
    if(!(ss_ptr->pref_reason == SD_SS_PREF_REAS_USER ||
         ss_ptr->pref_reason == SD_SS_PREF_REAS_MULTIMODE_SCAN ||
         ss_ptr->pref_reason == SD_SS_PREF_REAS_USER_RESEL ||
         ss_ptr->pref_reason == SD_SS_PREF_REAS_RESTORE)
         ||
         ss_ptr->user_mode_pref == user_mode_pref
       )
     {
       return ss_ptr->ss_pref_updated_status;
     }
  }
  /* lint -restore*/


   /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


  /* Update the current preferences.
  */

  sdss_set_mode_band_pref( SD_SS_HYBR_2,
                           mode_pref,
                           band_pref,
                           lte_band_pref,
                           tds_band_pref );

  sdss_set_hybr_pref( SD_SS_HYBR_2, hybr_pref );

  ss_ptr->orig_mode     = orig_mode;
  ss_ptr->prl_pref      = prl_pref;
  ss_ptr->roam_pref     = roam_pref;

  ss_ptr->otasp_band    = otasp_band;
  ss_ptr->otasp_blksys  = otasp_blksys;

  ss_ptr->acq_order_pref= acq_order_pref;
  ss_ptr->domain_pref   = domain_pref;
  ss_ptr->voice_domain_pref = voice_domain_pref;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Update the user_mode_preference
  */
  if(ss_ptr->pref_reason == SD_SS_PREF_REAS_USER ||
     ss_ptr->pref_reason == SD_SS_PREF_REAS_USER_RESEL ||
     ss_ptr->pref_reason == SD_SS_PREF_REAS_MULTIMODE_SCAN ||
     ss_ptr->pref_reason == SD_SS_PREF_REAS_RESTORE)
  {
    ss_ptr->user_mode_pref      = user_mode_pref;
    ss_ptr->user_true_mode_pref = ss_ptr->true_mode_pref;
    ss_ptr->user_band_pref      = band_pref;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Overwrite the ss_pref_updated_status.
  **
  ** Regardless if orig mode or pref reason is changed or not,
  ** if only service domain is changed and all other preferences remains same,
  ** overwrite with SDSS_PREF_UPDATED_SRV_DOMAIN.
  **
  ** Otherwise overwrite with SDSS_PREF_UPDATED_TRUE_PREF.
  */
  /* lint -save -e831*/

  if (  ss_ptr->ss_pref_updated_status != SDSS_PREF_UPDATED_HYBR_BSR_TO_HDR_END)
  {
  if( curr_supp_mode_pref         == new_supp_mode_pref     &&
      curr_supp_band_pref         == new_supp_band_pref     &&
      SYS_LTE_BAND_MASK_CHK_IF_EQUAL(&curr_supp_lte_band_pref,&new_supp_lte_band_pref) &&
      curr_supp_tds_band_pref     == new_supp_tds_band_pref &&
      ss_ptr->prev_prl_pref       == ss_ptr->prl_pref       &&
      ss_ptr->prev_roam_pref      == ss_ptr->roam_pref      &&
      !sdss_is_hybr_pref_chgd( SD_SS_HYBR_2 )               &&
      ss_ptr->prev_acq_order_pref == ss_ptr->acq_order_pref &&
      ss_ptr->prev_domain_pref    != ss_ptr->domain_pref &&
     ! rat_acq_order_changed
    )
  {
    ss_ptr->ss_pref_updated_status = SDSS_PREF_UPDATED_SRV_DOMAIN;
  }
  else if( curr_supp_mode_pref    == new_supp_mode_pref     &&
      curr_supp_band_pref         == new_supp_band_pref     &&
      SYS_LTE_BAND_MASK_CHK_IF_EQUAL(&curr_supp_lte_band_pref,&new_supp_lte_band_pref) &&
      curr_supp_tds_band_pref     == new_supp_tds_band_pref &&
      ss_ptr->prev_prl_pref       == ss_ptr->prl_pref       &&
      ss_ptr->prev_roam_pref      == ss_ptr->roam_pref      &&
      !sdss_is_hybr_pref_chgd( SD_SS_HYBR_2 )               &&
      ss_ptr->prev_acq_order_pref == ss_ptr->acq_order_pref &&
      ss_ptr->prev_domain_pref    == ss_ptr->domain_pref    &&
      ss_ptr->prev_voice_domain_pref != ss_ptr->voice_domain_pref &&
      ! rat_acq_order_changed
     )
  {
    ss_ptr->ss_pref_updated_status = SDSS_PREF_UPDATED_UE_CAPABILITY_CHG;
  }
  else
  {
      ss_ptr->ss_pref_updated_status = SDSS_PREF_UPDATED_TRUE_PREF;
    }
  }
  /* lint -restore*/

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Return pref updated status.
  */
  return(  ss_ptr->ss_pref_updated_status );

} /* sdss_hybr_2_pref_update */

/*===========================================================================

FUNCTION sdss_hybr_3_pref_update

DESCRIPTION
  Update the SS-Preference setting of the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if any of the new preferences is different than the existing
  preferences. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sdss_pref_updated_e_type      sdss_hybr_3_pref_update(

        sd_ss_pref_reas_e_type        pref_reason,
            /* Reason for changing the SS-Preference.
            */

        sd_ss_orig_mode_e_type        orig_mode,
            /* New origination mode (normal, OTASP, emergency, other, etc.).
            */

        sd_ss_mode_pref_e_type        mode_pref,
            /* New mode preference (AMPS, CDMA, any, etc.) - ignored when
            ** orig_mode = OTASP or emergency.
            */

        sd_ss_band_pref_e_type        band_pref,
            /* New band preference (BC0, BC1, any, etc.) - ignored when
            ** orig_mode = OTASP or emergency..
            */

        sys_lte_band_mask_e_type      lte_band_pref,
            /* New LTE band preference
            */

        sd_ss_band_pref_e_type        tds_band_pref,
            /* New TDS band preference
            */

        sd_ss_prl_pref_e_type         prl_pref,
            /* New prl system preference (Available BC0A, available BC0B, etc.)
            */

        sd_ss_roam_pref_e_type        roam_pref,
            /* New roam preference (any, home, affiliated, etc.) - ignored
            ** when orig_mode = OTASP or emergency..
            */

        sd_ss_hybr_pref_e_type        hybr_pref,
            /* New hybrid preference (none, CDMA/HDR).
            */

        sd_band_e_type                otasp_band,
            /* The band-class that is associated with OTASP origination mode.
            ** Note that this parameter is ignored if orig_mode != OTASP.
            */

        sd_blksys_e_type              otasp_blksys,
            /* The PCS frequency block/Cellular system that is associated
            ** with OTASP origination mode. Note that this parameter is
            ** ignored if orig_mode != OTASP.
            */


        sd_ss_srv_domain_pref_e_type   domain_pref,
            /* Service domain preference that is associated with the selected
            ** NAM.
            ** Applies only for GSM/WCDMA modes.
            */

        sd_ss_acq_order_pref_e_type    acq_order_pref,
            /* Preference for the order of acquisition ( WCDMA before GSM,
            ** GSM before WCDMA etc).
            */

        sd_ss_pref_update_reason_e_type     pref_update_reason,
            /**Prefernce change reason
            */

        sd_ss_mode_pref_e_type        user_mode_pref,
            /* New mode preference (AMPS, CDMA, any, etc.) - ignored when
            ** orig_mode = OTASP or emergency.
            */

        sys_voice_domain_pref_e_type   voice_domain_pref,
           /**Voice domain pref
           */

        const sd_rat_acq_order_s_type      *rat_acq_order_ptr
           /**< Rat acquisition order including LTE.
           */

)
{

  sdss_s_type             *ss_ptr           = sdss_ptr(SD_SS_HYBR_3);
  sd_ss_mode_pref_e_type  new_supp_mode_pref;
  sd_ss_mode_pref_e_type  curr_supp_mode_pref;
  sd_ss_band_pref_e_type  new_supp_band_pref;
  sd_ss_band_pref_e_type  curr_supp_band_pref;
  sys_lte_band_mask_e_type  curr_supp_lte_band_pref = SYS_LTE_BAND_MASK_CONST_ANY;
  sys_lte_band_mask_e_type  new_supp_lte_band_pref;
  sd_ss_band_pref_e_type  curr_supp_tds_band_pref;
  sd_ss_band_pref_e_type  new_supp_tds_band_pref;

  sd_ss_mode_pref_e_type  ss_mode_pref      = SD_SS_MODE_PREF_NONE;
  sd_ss_band_pref_e_type  ss_band_pref      = SD_SS_BAND_PREF_NONE;
  sys_lte_band_mask_e_type  ss_lte_band_pref  = SYS_LTE_BAND_MASK_CONST_NONE;
  sd_ss_band_pref_e_type  ss_tds_band_pref  = SD_SS_BAND_PREF_NONE;
  boolean                        is_mode_band_changed = FALSE;

  sd_ss_mode_pref_e_type          acq_sys_mode_pref;
  sys_sys_mode_e_type             acq_sys_mode;
  uint16                          i;
  uint16                          j;
  sys_priority_list_info_s_type   *rat_info;
  sys_rat_pri_list_info_s_type    ss_rat_pri_list_info;
  sd_ss_mode_pref_e_type filtr_mode_pref;
  boolean                        rat_acq_order_changed = FALSE;

  #if defined(FEATURE_SD_LTE)
  mmgsdi_app_enum_type            ss_gwl_app_type = sdss_get_session_info(SD_SS_HYBR_3);
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( pref_reason, SD_SS_PREF_REAS_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( orig_mode, SD_SS_ORIG_MODE_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( mode_pref, SD_SS_MODE_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( user_mode_pref, SD_SS_MODE_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( band_pref, SD_SS_BAND_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( tds_band_pref, SD_SS_BAND_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( prl_pref,  SD_SS_PRL_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( roam_pref, SD_SS_ROAM_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( hybr_pref, SD_SS_HYBR_PREF_MAX );
  SD_ASSERT( INRANGE(domain_pref, SD_SS_SRV_DOMAIN_PREF_NONE,
                     (SD_SS_SRV_DOMAIN_PREF_MAX-1)) );
  SD_ASSERT_ENUM_IS_INRANGE( acq_order_pref, SD_SS_ACQ_ORDER_PREF_MAX );

  SD_ASSERT_ENUM_IS_INRANGE_INC( otasp_band, SD_BAND_MAX );
  SD_ASSERT_ENUM_IS_INRANGE_INC( otasp_blksys, SD_BLKSYS_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Print feature mode / subs feature mode in SD */
  SD_MSG_HIGH_3("fmode: %d, sfmode1: %d, sfmode2: %d",
        sdss_common.onebuild_feature,
        sdss_common.subs_feature[SD_SS_MAIN],
        sdss_common.subs_feature[SD_SS_HYBR_3]);

  /* Only GWLT permitted on HYBR_3 stack
  */
  if(sdss_is_featuremode(SYS_OVERALL_FEATURE_MODE_MULTISIM))
  {
    mode_pref = SD_GET_COMMON_MODE( mode_pref, SD_SS_MODE_PREF_TDS_GSM_WCDMA_LTE);
    SD_MSG_HIGH_1("mode_pref %d",mode_pref);
  }

  /* If the service domain is NONE, remove GW components from the mode_pref.
  ** Service domain doesn't affect non-GW systems.
  */
  if(domain_pref == SD_SS_SRV_DOMAIN_PREF_NONE)
  {
    mode_pref = SD_MODE_DELETE(mode_pref, SD_SS_MODE_PREF_TDS_GSM_WCDMA_LTE);
  }

 #if defined(FEATURE_SD_LTE)
   if ( ss_gwl_app_type ==  MMGSDI_APP_SIM 
#ifdef FEATURE_ECALL_IVS
      || (ecall_get_ecall_operating_mode() ==  ECALL_MODE_ECALL_ONLY)
#endif
     )
 {
   /* SIM card type is 2G , remove LTE component from the mode_pref.
   */
   if( SD_MODE_CONTAIN( user_mode_pref, SD_SS_MODE_PREF_TDS_GSM_WCDMA ) &&
       SD_MODE_CONTAIN( user_mode_pref, SD_SS_MODE_PREF_GWL_LTE ) &&
       ( sdss_is_supp_mode_band_pref(SD_SS_MODE_PREF_GW, band_pref ) ||
         sdss_is_supp_mode_band_pref_tds(SD_SS_MODE_PREF_TDS, tds_band_pref ) )
     )
   {
     SD_MSG_HIGH_1( "HYBR3: Removing LTE as gwl_app_type received =%d or in ECALL only mode",
                  ss_gwl_app_type);

     mode_pref = SD_MODE_DELETE( mode_pref, SD_SS_MODE_PREF_GWL_LTE );
     user_mode_pref = SD_MODE_DELETE( user_mode_pref, SD_SS_MODE_PREF_GWL_LTE );
   }
 }
 #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  ss_ptr->pref_update_reas = pref_update_reason;

  /* Initial ss_pref_updated_status to NONE.
  */
  ss_ptr->ss_pref_updated_status =  SDSS_PREF_UPDATED_NONE;


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Return TRUE if the command was to avoid the system.
  */
  if (pref_reason == SD_SS_PREF_REAS_AVOID_SYS )
  {
    ss_ptr->pref_reason            = pref_reason;
    ss_ptr->ss_pref_updated_status = SDSS_PREF_UPDATED_PREF_REAS;

    return ss_ptr->ss_pref_updated_status;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Store the true mode pref unadjusted based on subscription.
  */
  ss_ptr->true_mode_pref = mode_pref;

  /* Update rat_acq_order from preference passed in
  */
  if((rat_acq_order_ptr != NULL) &&
     (rat_acq_order_ptr->num_rat != 0) &&
     (rat_acq_order_ptr->acq_sys_mode[0] != SYS_SYS_MODE_NONE))
  {
    /* Update rat_acq_order if it's not same as before
    */
    if(sdss_update_rat_acq_order(rat_acq_order_ptr,
                              &ss_ptr->rat_acq_order))
    {
      rat_acq_order_changed = TRUE;
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    SD_MSG_HIGH_2( "hybr3, rat_acq_order updated: %d DS: SUB 2 sdss_hybr_3_pref_update(): Using user_mode_pref = %d for updating RAT priority list",
              rat_acq_order_changed,user_mode_pref);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Update the Rat priority list
  */
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* update previous rat_pri_list_info
  */

  /* If UE is in full service at the time of emergency call end , update prev
  ** rat priority info with idle rat priority info ( preferences prior to emergency call orig).
  ** This will ensure that if the UE is being restored to the same preferences( prior to emergency call)
  ** no new service request is issued to NAS
  */
  if ( sdss_is_orig_mode0(ss_ptr->orig_mode ,SD_SS_ORIG_MODE_VAL_EMERG)&&
       !sdss_is_orig_mode0(orig_mode ,SD_SS_ORIG_MODE_VAL_EMERG) &&
       sdss_get_ss_state(SD_SS_HYBR_3) == SDSS_STATE_OPR &&
       sdss_is_srv_status2(SD_SS_HYBR_3, SDSSSCR_SRV_STATUS_VAL_SRV)
     )
  {
    SD_MSG_HIGH_0("LTE_911:update prev_rat_pri with idle");
    sdss_update_prev_rat_pri_list_info(SD_SS_HYBR_3, &ss_ptr->idle_rat_pri_list_info);
  }
  else
  {
    /* Store the last rat_pri_list_info
    */
    sdss_get_rat_pri_list_info(SD_SS_HYBR_3, &ss_rat_pri_list_info);
    sdss_update_prev_rat_pri_list_info(SD_SS_HYBR_3, &ss_rat_pri_list_info);
  }
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    new_supp_mode_pref = user_mode_pref;

  new_supp_band_pref      = band_pref;
  new_supp_lte_band_pref  = lte_band_pref;
  new_supp_tds_band_pref  = tds_band_pref;

  /* Reset rat pri list info */
  memset(&(ss_rat_pri_list_info),
         0,
         sizeof(sys_rat_pri_list_info_s_type));

  /* Filter out all modes except for HDR and LTE
  ** Filter out modes and bands not supported by the target cap /user setting
  */

  filtr_mode_pref = SD_SS_MODE_PREF_ANY;

  sd_misc_get_band_mode_mmode( &new_supp_mode_pref,
                               &new_supp_band_pref,
                               &new_supp_lte_band_pref,
                               &new_supp_tds_band_pref,
                               filtr_mode_pref,
                               SD_SS_BAND_PREF_ANY,
                               SYS_LTE_BAND_MASK_CONST_ANY,
                               SD_SS_BAND_PREF_TDS_ANY );

  for( i=0, j=0; i < ss_ptr->rat_acq_order.num_rat; i++ )
  {
    acq_sys_mode      = ss_ptr->rat_acq_order.acq_sys_mode[i];
    acq_sys_mode_pref = sdss_map_mode_to_mode_pref(acq_sys_mode);
    if( SD_MODE_CONTAIN(new_supp_mode_pref, acq_sys_mode_pref) )
    {
      rat_info = &(ss_rat_pri_list_info.priority_list_info[j]);

      rat_info->acq_sys_mode         =  acq_sys_mode;

      SD_MSG_HIGH_1( "hybr_3_pref_update: Adding RAT acq_sys_mode = %d ", acq_sys_mode);

      /* Set band capability based on RAT */
      if ( acq_sys_mode == SYS_SYS_MODE_LTE )
      {
        rat_info->band_cap.lte_band_cap = new_supp_lte_band_pref;
      }
      else if ( acq_sys_mode == SYS_SYS_MODE_TDS )
      {
        rat_info->band_cap.chgwt_band_cap = new_supp_tds_band_pref;
      }
      else
      {
        rat_info->band_cap.chgwt_band_cap = new_supp_band_pref;
      }

      /* Initialize bst_rat_acq_required to TRUE by default and set the
      ** bst_band_cap to be equal to the band_cap. This can be
      ** reset at the time of sending service request to NAS.
      */
      rat_info->bst_rat_acq_required = TRUE;
      rat_info->bst_band_cap         = rat_info->band_cap;
      j++;
    }
  }

  ss_rat_pri_list_info.num_items = j;

  /* do not update the rat priority list in SD core if UE is currently in
  ** RLF recovery during an emergency call / callback mode
  */
  if(! (sdss_is_orig_mode0(orig_mode,SD_SS_ORIG_MODE_VAL_EMERG)  &&
         sdss_get_is_RLF_during_emerg(SD_SS_HYBR_3) ))
  {
  sdss_set_rat_pri_list_info( SD_SS_HYBR_3, &ss_rat_pri_list_info);
  }

  /* Stop LTE connected mode operation as soon as device moved to CS only mode.
  */
  if (ss_rat_pri_list_info.num_items == 1 &&
      ss_rat_pri_list_info.priority_list_info[0].acq_sys_mode == SD_MODE_LTE && 
      domain_pref == SD_SS_SRV_DOMAIN_PREF_CS_ONLY) 
  {
    SD_MSG_HIGH_0("LTE moved to CS only mode, Reset RLF on hybr3");
    sdss_reset_lte_connected_mode (SD_SS_HYBR_3);
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* the following information - idle_rat_pri_list_info and idle_orig_mode
  ** is required for the purpose of emergency call origination over LTE
  */
  /* update the idle rat priority list information and orig mode
  */
  if( orig_mode == SD_SS_ORIG_MODE_NONE ||
      orig_mode == SD_SS_ORIG_MODE_MANUAL_IDLE  )
  {
    ss_ptr->idle_orig_mode = orig_mode;

    /* update idle mode rat priority list */
    ss_ptr->idle_rat_pri_list_info = ss_rat_pri_list_info;
  }

  /* update the emergency mode rat priority list
  */
  if( orig_mode == SD_SS_ORIG_MODE_EMERG_ORIG ||
      orig_mode == SD_SS_ORIG_MODE_EMERG_CB )
  {
    ss_ptr->emerg_rat_pri_list_info = ss_rat_pri_list_info;
  }




  SD_MSG_HIGH_1 ("pref_update_reason: %d",
               pref_update_reason);

  #ifdef FEATURE_MMODE_DYNAMIC_SV_OPERATION_SWITCH
  if( pref_update_reason == SD_SS_PREF_UPDATE_REASON_SWITCH_SVLTE )
  {
    sdss_set_sv_opr_act( SDSS_SV_OPR_ACT_SWITCH_SVLTE );
  }
  else if ( pref_update_reason == SD_SS_PREF_UPDATE_REASON_SWITCH_CSFB )
  {
    sdss_set_sv_opr_act( SDSS_SV_OPR_ACT_SWITCH_CSFB );
  }
  else
  #endif /* FEATURE_MMODE_DYNAMIC_SV_OPERATION_SWITCH */
  if(pref_update_reason == SD_SS_PREF_UPDATE_REASON_DDS_SWITCHBACK_FROM_TEMP)
  {
    ss_ptr->is_dds_switchback_from_temp = TRUE;
    SD_MSG_HIGH_0("Set is_dds_switchback_from_temp to TRUE");
  }

  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  if ( !ss_ptr->is_gw3_subsc_avail )
  {
    orig_mode = SD_SS_ORIG_MODE_EMERG_ORIG;
  }
  #endif
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Adjust the mode_pref based on the subscription availability, only if
  ** it is not emergency origination.
  */
  if ( orig_mode != SD_SS_ORIG_MODE_EMERG_ORIG &&
       orig_mode != SD_SS_ORIG_MODE_EMERG_CB )
  {

    if(!ss_ptr->is_gw3_subsc_avail)
    {
         if(   (ss_ptr->prev_mode_pref       != mode_pref )||
               (ss_ptr->prev_band_pref       != band_pref) ||
               !SYS_LTE_BAND_MASK_CHK_IF_EQUAL(&ss_ptr->lte_prev_band_pref,&lte_band_pref)
           )
        {
            is_mode_band_changed=TRUE;
           SD_MSG_HIGH_0("mode/ band changed: when GW subscription is not available");

        }
       /* gw subscription is not available, reset GWL modes.
       */
       mode_pref = SD_MODE_DELETE( mode_pref, SD_SS_MODE_PREF_TDS_GSM_WCDMA_LTE);
       ss_ptr->true_mode_pref = mode_pref;

    } /* if ( !ss_ptr->is_gw_subsc_avail ) */

    #if defined (FEATURE_MMODE_DUAL_SIM) && defined(FEATURE_SD_LTE)
    if( sdss_is_featuremode(SYS_OVERALL_FEATURE_MODE_MULTISIM) &&
        ss_rat_pri_list_info.num_items == 1 &&
        ss_rat_pri_list_info.priority_list_info[0].acq_sys_mode ==  SYS_SYS_MODE_LTE &&
        ss_gwl_app_type ==  MMGSDI_APP_SIM )
    {
      /* GW subscription available and card type is SIM (2G), but mode_pref is LTE  only.
      ** So keep in emergency mode.
      */
      orig_mode = SD_SS_ORIG_MODE_EMERG_ORIG;
      SD_MSG_HIGH_1(" Put emergency mode as UE is in LTE only mode and gwl_app_type =%d ",\
                  ss_gwl_app_type );
    }
    #endif

  } /* if ( orig_mode != SD_SS_ORIG_MODE_EMERG_ORIG ... ) */

  if( ( orig_mode == SD_SS_ORIG_MODE_EMERG_ORIG ||
      orig_mode == SD_SS_ORIG_MODE_EMERG_CB ) &&
      sdss_is_ral_stored_in_efs(SD_SS_HYBR_3))
  {
    *(&(ss_ptr->emerg_rat_pri_list_info)) = ss_rat_pri_list_info;
    /* in case if store_ral_in_efs is set then we need to 
         order emerg_rat_pri_list_info by emergency rat acq order */
    sdss_order_pri_list_per_emerg_rat_acq_order(&ss_ptr->emerg_rat_pri_list_info, SD_SS_HYBR_3);
  }

  SD_MSG_HIGH_1("mode pref: %d", mode_pref);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Record the current origination mode and update the reson for this
  ** SS-Preference update.
  */
  ss_ptr->orig_mode_prev = ss_ptr->orig_mode;
  if ( ss_ptr->pref_reason != pref_reason )
  {
    ss_ptr->pref_reason    = pref_reason;
    ss_ptr->ss_pref_updated_status = SDSS_PREF_UPDATED_PREF_REAS;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #if ( defined(FEATURE_UMTS_UNIFORM_OOS_HANDLING) )
  if( ss_ptr->ss_pref_updated_status == SDSS_PREF_UPDATED_PREF_REAS &&
      pref_reason                    == SD_SS_PREF_REAS_ORIG_END &&
      ss_ptr->orig_mode_prev         == SD_SS_ORIG_MODE_EMERG_ORIG )
  {
     ss_ptr->ss_pref_updated_status = SDSS_PREF_UPDATED_EMERG_ORIG_END;
  }
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Get current/new supported mode/band pref.
  */
  sdss_get_mode_band_pref( SD_SS_HYBR_3,
                           &ss_mode_pref,
                           &ss_band_pref,
                           &ss_lte_band_pref,
                           &ss_tds_band_pref );

  curr_supp_mode_pref     = ss_mode_pref;
  curr_supp_band_pref     = ss_band_pref;
  curr_supp_lte_band_pref = ss_lte_band_pref;
  curr_supp_tds_band_pref = ss_tds_band_pref;

  sd_misc_get_band_mode_mmode( &curr_supp_mode_pref,
                               &curr_supp_band_pref,
                               &curr_supp_lte_band_pref,
                               &curr_supp_tds_band_pref,
                               SD_SS_MODE_PREF_ANY,
                               SD_SS_BAND_PREF_ANY,
                               SYS_LTE_BAND_MASK_CONST_ANY,
                               SD_SS_BAND_PREF_TDS_ANY );

  new_supp_mode_pref      = mode_pref;
  new_supp_band_pref      = band_pref;
  new_supp_lte_band_pref  = lte_band_pref;
  new_supp_tds_band_pref  = tds_band_pref;

  sd_misc_get_band_mode_mmode( &new_supp_mode_pref,
                               &new_supp_band_pref,
                               &new_supp_lte_band_pref,
                               &new_supp_tds_band_pref,
                               SD_SS_MODE_PREF_ANY,
                               SD_SS_BAND_PREF_ANY,
                               SYS_LTE_BAND_MASK_CONST_ANY,
                               SD_SS_BAND_PREF_TDS_ANY );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Update the previous preferences fields.
  */
  ss_ptr->prev_mode_pref       = ss_mode_pref;
  ss_ptr->prev_band_pref       = ss_band_pref;
  ss_ptr->lte_prev_band_pref   = ss_lte_band_pref;
  ss_ptr->tds_prev_band_pref   = ss_tds_band_pref;

  ss_ptr->prev_prl_pref        = ss_ptr->prl_pref;
  ss_ptr->prev_roam_pref       = ss_ptr->roam_pref;
  ss_ptr->prev_domain_pref     = ss_ptr->domain_pref;
  ss_ptr->prev_acq_order_pref  = ss_ptr->acq_order_pref;
  ss_ptr->prev_voice_domain_pref = ss_ptr->voice_domain_pref;
  /* update PRL Support HDR Indication
  */
    ss_ptr->is_prl_support_hdr =
     sdprl_is_supp_mode_band_pref(SD_SS_MODE_PREF_HDR, band_pref,
                                  SYS_LTE_BAND_MASK_CONST_NONE, SD_SS_BAND_PREF_NONE);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Update the user_mode_preference
  */
  if(ss_ptr->pref_reason == SD_SS_PREF_REAS_USER ||
     ss_ptr->pref_reason == SD_SS_PREF_REAS_MULTIMODE_SCAN ||
     ss_ptr->pref_reason == SD_SS_PREF_REAS_USER_RESEL ||
     ss_ptr->pref_reason == SD_SS_PREF_REAS_RESTORE)
  {
     /* If the mode has changed from AUTO <-> MANUAL,
     ** change the service_req_type as USER_SELECTION.
     ** Else there is some system parameter like band or mode pref
     ** change. Assign srv_req_type to SYSTEM_CHANGE.
     */

    if( ss_ptr->pref_reason == SD_SS_PREF_REAS_USER_RESEL )
    {
      sdss_set_srv_req_type( SD_SS_HYBR_3, SD_SS_SRV_REQ_TYPE_USER_SELECTION );
    }
    else
    {
      sdss_set_srv_req_type( SD_SS_HYBR_3, SD_SS_SRV_REQ_TYPE_SYSTEM_CHANGE );
    }
  }

  /* lint -save -e831*/
  /* If none of the new preferences is different than the existing
  ** preferences, return FALSE.
  */
  if( ss_ptr->orig_mode       == orig_mode              &&
      curr_supp_mode_pref     == new_supp_mode_pref     &&
      curr_supp_band_pref     == new_supp_band_pref     &&
      SYS_LTE_BAND_MASK_CHK_IF_EQUAL(&curr_supp_lte_band_pref,&new_supp_lte_band_pref) &&
      curr_supp_tds_band_pref == new_supp_tds_band_pref &&
      ss_ptr->prl_pref        == prl_pref               &&
      ss_ptr->roam_pref       == roam_pref              &&
      sdss_is_hybr_pref( SD_SS_HYBR_3, hybr_pref )      &&
      ss_ptr->acq_order_pref  == acq_order_pref         &&
      ! is_mode_band_changed                &&
      ! rat_acq_order_changed                      &&
      ss_ptr->domain_pref     == domain_pref &&
      ss_ptr->voice_domain_pref == voice_domain_pref)
  {
    /* Check user_mode_pref change as well for reasons for which 
    ** user_mode_pref is updated*/
    if(!(ss_ptr->pref_reason == SD_SS_PREF_REAS_USER ||
         ss_ptr->pref_reason == SD_SS_PREF_REAS_MULTIMODE_SCAN ||
         ss_ptr->pref_reason == SD_SS_PREF_REAS_USER_RESEL ||
         ss_ptr->pref_reason == SD_SS_PREF_REAS_RESTORE)
         ||
         ss_ptr->user_mode_pref == user_mode_pref
       )
     {
       return ss_ptr->ss_pref_updated_status;
     }
  }
  /* lint -restore*/


   /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


  /* Update the current preferences.
  */

  sdss_set_mode_band_pref( SD_SS_HYBR_3,
                           mode_pref,
                           band_pref,
                           lte_band_pref,
                           tds_band_pref );

  sdss_set_hybr_pref( SD_SS_HYBR_3, hybr_pref );

  ss_ptr->orig_mode     = orig_mode;
  ss_ptr->prl_pref      = prl_pref;
  ss_ptr->roam_pref     = roam_pref;

  ss_ptr->otasp_band    = otasp_band;
  ss_ptr->otasp_blksys  = otasp_blksys;

  ss_ptr->acq_order_pref= acq_order_pref;
  ss_ptr->domain_pref   = domain_pref;
  ss_ptr->voice_domain_pref = voice_domain_pref;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Update the user_mode_preference
  */
  if(ss_ptr->pref_reason == SD_SS_PREF_REAS_USER ||
     ss_ptr->pref_reason == SD_SS_PREF_REAS_USER_RESEL ||
     ss_ptr->pref_reason == SD_SS_PREF_REAS_MULTIMODE_SCAN ||
     ss_ptr->pref_reason == SD_SS_PREF_REAS_RESTORE)
  {
    ss_ptr->user_mode_pref      = user_mode_pref;
    ss_ptr->user_true_mode_pref = ss_ptr->true_mode_pref;
    ss_ptr->user_band_pref      = band_pref;
    ss_ptr->voice_domain_pref = voice_domain_pref;

  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Overwrite the ss_pref_updated_status.
  **
  ** Regardless if orig mode or pref reason is changed or not,
  ** if only service domain is changed and all other preferences remains same,
  ** overwrite with SDSS_PREF_UPDATED_SRV_DOMAIN.
  **
  ** Otherwise overwrite with SDSS_PREF_UPDATED_TRUE_PREF.
  */
  /* lint -save -e831*/
  if( curr_supp_mode_pref         == new_supp_mode_pref     &&
      curr_supp_band_pref         == new_supp_band_pref     &&
      SYS_LTE_BAND_MASK_CHK_IF_EQUAL(&curr_supp_lte_band_pref, &new_supp_lte_band_pref) &&
      curr_supp_tds_band_pref     == new_supp_tds_band_pref &&
      ss_ptr->prev_prl_pref       == ss_ptr->prl_pref       &&
      ss_ptr->prev_roam_pref      == ss_ptr->roam_pref      &&
      !sdss_is_hybr_pref_chgd( SD_SS_HYBR_3 )               &&
      ss_ptr->prev_acq_order_pref == ss_ptr->acq_order_pref &&
      ss_ptr->prev_domain_pref    != ss_ptr->domain_pref  &&
     ! rat_acq_order_changed )
  {
    ss_ptr->ss_pref_updated_status = SDSS_PREF_UPDATED_SRV_DOMAIN;
  }
  else if( curr_supp_mode_pref    == new_supp_mode_pref     &&
      curr_supp_band_pref         == new_supp_band_pref     &&
      SYS_LTE_BAND_MASK_CHK_IF_EQUAL(&curr_supp_lte_band_pref,&new_supp_lte_band_pref) &&
      curr_supp_tds_band_pref     == new_supp_tds_band_pref &&
      ss_ptr->prev_prl_pref       == ss_ptr->prl_pref       &&
      ss_ptr->prev_roam_pref      == ss_ptr->roam_pref      &&
      !sdss_is_hybr_pref_chgd( SD_SS_HYBR_3 )               &&
      ss_ptr->prev_acq_order_pref == ss_ptr->acq_order_pref &&
      ss_ptr->prev_domain_pref    == ss_ptr->domain_pref    &&
      ss_ptr->prev_voice_domain_pref != ss_ptr->voice_domain_pref &&
     ! rat_acq_order_changed )
  {
    ss_ptr->ss_pref_updated_status = SDSS_PREF_UPDATED_UE_CAPABILITY_CHG;
  }
  else
  {
      ss_ptr->ss_pref_updated_status = SDSS_PREF_UPDATED_TRUE_PREF;
    }
  /* lint -restore*/

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Return pref updated status.
  */
  return(  ss_ptr->ss_pref_updated_status );

} /* sdss_hybr_3_pref_update */
/*===========================================================================

FUNCTION sdss_update_plmn_status

DESCRIPTION
  Update the plmn_status.
  SS-Main/HDR.

DEPENDENCIES
  sd_init() must have already been called to initialize SD.

RETURN VALUE
  void

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                          sdss_update_plmn_status (

        sd_ss_e_type                  ss,
          /* System selection stack
          */
        sys_plmn_list_status_e_type   plmn_list_status,

        uint32                        plmn_list_length

)
{
  sdss_s_type           *ss_ptr     = sdss_ptr( ss );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ss_ptr->plmn_list_status = plmn_list_status;
  ss_ptr->plmn_list_length = plmn_list_length;

} /* sdss_update_plmn_status */

/*===========================================================================

FUNCTION sdss_update_get_network_type

DESCRIPTION
  Update the get network type
  SS-Main/hybrid2/HDR.

DEPENDENCIES
  sd_init() must have already been called to initialize SD.

RETURN VALUE
  void

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                          sdss_update_get_network_type (

        sd_ss_e_type                  ss,
          /* System selection stack
          */

sd_network_list_type_e_type          network_list_type


)
{
  sdss_s_type           *ss_ptr     = sdss_ptr( ss );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ss_ptr->get_net_list_type = network_list_type;

} /* sdss_update_get_network_type */

/*===========================================================================

FUNCTION sdss_redir_update0

DESCRIPTION
  Update the redirection status of the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static  void                          sdss_redir_update0(

        sdss_s_type                   *ss_ptr,
            /* Pointer to a System Selection information structure.
            */

        sd_ss_redir_e_type            redir_type,
            /* Redirection type - GSRDM, SRDM, NDSS.
            */

        boolean                       is_valid,
            /* Indicate whether redirection is valid for this target.
            */

        word                          expected_sid,
            /* Expected SID. If the MS is being redirected to a specific
            ** system, indicate the SID of that system; otherwise, should be
            ** set to SD_WILDCARD_SID.
            */

        word                          expected_nid,
            /* Expected NID. If the MS is being redirected to a specific
            ** network, indicate the NID of that network; otherwise, should
            ** be set to SD_WILDCARD_NID.
            */

        boolean                       is_rif,
            /* Return if fail indicator.  Indicates whether the MS is
            ** required to return to the system from which it is being
            ** redirected upon failure to obtain service using the
            ** redirection criteria specified by this function call.
            */

        boolean                       is_ignore_cdma,
            /* IGNORE_CDMA indicator. Indicates whether the MS is to ignore
            ** the CDMA Capability Message on the analog system to which it
            ** is being redirected.
            */

        word                          max_redirect_delay
            /* Maximum delay upon redirection. Indicate the maximum delay
            ** time, in units of 8 second increments, to be used by MS in the
            ** event of a global redirection (GSRDM) to analog mode in order
            ** to avoid overloading an underlying analog cell's reverse
            ** control channel.
            **
            ** Note that a value of SD_SS_MAX_REDIR_DELAY_NONE indicate that
            ** this variable should not be used by AMPS CP to determine the
            ** registration time.
            */
)
{
  SD_ASSERT( ss_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( redir_type, SD_SS_REDIR_MAX );


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If redirection type is none, indicate that redirection is invalid.
  */
  if( redir_type == SD_SS_REDIR_NONE )
  {
    is_valid = FALSE;

    /* Reset delete_tmsi bit mask of the system in the redirection list.
    */
    sdsr_list_reset_status_mask( sdss_sr_list_map(ss_ptr,SDSR_REDIR_LST),
                                 SDSR_STATUS_MASK_DEL_TMSI);
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ss_ptr->redir                     = redir_type;
  ss_ptr->redir_is_valid            = is_valid;
  ss_ptr->redir_expected_sid        = expected_sid;
  ss_ptr->redir_expected_nid        = expected_nid;
  ss_ptr->redir_is_rif              = is_rif;
  ss_ptr->redir_is_ignore_cdma      = is_ignore_cdma;
  ss_ptr->redir_max_redirect_delay  = max_redirect_delay;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If redirection is not none, update the redirection uptime per the
  ** current uptime.
  */
  if( ss_ptr->redir != SD_SS_REDIR_NONE )
  {
    ss_ptr->redir_uptime = time_get_uptime_secs();
  SD_MSG_LOW_2("redir_upate: type=%d, uptime=%d",ss_ptr->redir, ss_ptr->redir_uptime);
  }

} /* sdss_redir_update0 */




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_redir_update

DESCRIPTION
  Update the redirection status of the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                          sdss_redir_update(

        sd_ss_e_type                  ss,
          /* System selection stack.
          */

        sd_ss_redir_e_type            redir_type,
            /* Redirection type - GSRDM, SRDM, NDSS.
            */

        boolean                       is_valid,
            /* Indicate whether redirection is valid for this target.
            */

        word                          expected_sid,
            /* Expected SID. If the MS is being redirected to a specific
            ** system, indicate the SID of that system; otherwise, should be
            ** set to SD_WILDCARD_SID.
            */

        word                          expected_nid,
            /* Expected NID. If the MS is being redirected to a specific
            ** network, indicate the NID of that network; otherwise, should
            ** be set to SD_WILDCARD_NID.
            */

        boolean                       is_rif,
            /* Return if fail indicator.  Indicates whether the MS is
            ** required to return to the system from which it is being
            ** redirected upon failure to obtain service using the
            ** redirection criteria specified by this function call.
            */

        boolean                       is_ignore_cdma,
            /* IGNORE_CDMA indicator. Indicates whether the MS is to ignore
            ** the CDMA Capability Message on the analog system to which it
            ** is being redirected.
            */

        word                          max_redirect_delay
            /* Maximum delay upon redirection. Indicate the maximum delay
            ** time, in units of 8 second increments, to be used by MS in the
            ** event of a global redirection (GSRDM) to analog mode in order
            ** to avoid overloading an underlying analog cell's reverse
            ** control channel.
            **
            ** Note that a value of SD_SS_MAX_REDIR_DELAY_NONE indicate that
            ** this variable should not be used by AMPS CP to determine the
            ** registration time.
            */
)
{
  sdss_s_type   *ss_ptr = sdss_ptr( ss );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  sdss_redir_update0( ss_ptr,
                      redir_type,
                      is_valid,
                      expected_sid,
                      expected_nid,
                      is_rif,
                      is_ignore_cdma,
                      max_redirect_delay );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If this is opt HO LTE->ehrpd, set the flag is_opt_ho_lte_do to true.
   */
  if (redir_type == SD_SS_REDIR_NONE &&
           ss == SD_SS_HYBR_1)
  {
    sdss_update_opt_ho_lte_do(FALSE);
  }
}




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_redir_update2

DESCRIPTION
  Update the redirection status of the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                          sdss_redir_update2(

        sd_ss_e_type                  ss,
          /* System selection stack.
          */

        sd_ss_redir_e_type            redir_type,
            /* Redirection type - GSRDM, SRDM, NDSS.
            */

        boolean                       is_valid,
            /* Indicate whether redirection is valid for this target.
            */

        boolean                       is_rif,
            /* Return if fail indicator.  Indicates whether the MS is
            ** required to return to the system from which it is being
            ** redirected upon failure to obtain service using the
            ** redirection criteria specified by this function call.
            */

        const sd_redir_rec_s_type *rec_list_ptr
            /* Pointer to a list of redirection records to which the MS is
            ** being redirected.
            **
            ** The list contains one or more redirection record. Each
            ** redirection record specifies the redirection system that is
            ** either CDMA or AMPS system.
            */

)
{
  word          expected_sid;
  word          expected_nid;
  boolean       is_ignore_cdma;
  word          max_redirect_delay;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Set default value for expected_sid, expected_nid, is_ignore_cdma and
  ** max_redirect_delay.
  */
  expected_sid = SD_WILDCARD_SID;
  expected_nid = SD_WILDCARD_NID;
  is_ignore_cdma = FALSE;
  max_redirect_delay = SD_SS_MAX_REDIR_DELAY_NONE;

  /* Set the expected_sid, is_ignore_cdma and max_redirect_delay per first
  ** redirection record.
  */

  if( rec_list_ptr != NULL )
  {
    if( rec_list_ptr->record_type == SD_REDIR_REC_CDMA )
    {
      expected_sid = rec_list_ptr->rec.cdma_rec.expected_sid;
      expected_nid = rec_list_ptr->rec.cdma_rec.expected_nid;
    }


    if( rec_list_ptr->record_type == SD_REDIR_REC_AMPS )
    {
      expected_sid = rec_list_ptr->rec.amps_rec.expected_sid;
      is_ignore_cdma = rec_list_ptr->rec.amps_rec.is_ignore_cdma;
      max_redirect_delay = rec_list_ptr->rec.amps_rec.max_redirect_delay;
    }
  }

  /* Update the SS-Core with the redirection type.
  */
  sdss_redir_update( ss,                  /* system selection */
                     redir_type,          /* Redirection type */
                     is_valid,            /* Valid redirection indicator */
                     expected_sid,        /* Expected SID */
                     expected_nid,        /* Expected NID */
                     is_rif,              /* RETURN_IF_FAIL indicator */
                     is_ignore_cdma,      /* IGNORE_CDMA indicator */
                     max_redirect_delay); /* MAX_REDIRECT_DELAY value */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return;

}/* sdss_redir_update2 */

#ifdef FEATURE_EOOS_UMTS
/*===========================================================================

FUNCTION sdss_update_eoos_scan_time

DESCRIPTION
  Update the EOOS Scan Time

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static void                    sdss_update_eoos_scan_time(

        sd_ss_e_type           ss
        /* System selection stack
        */

)
{

  sdss_s_type *ss_ptr = sdss_ptr(ss);

  SD_ASSERT(ss_ptr != NULL);

  /* Compute EOOS Parameters
  */
   sdss_compute_gwl_eoos_params( ss,
                         &ss_ptr->acq_gwl_wcdma_scan_time,
                        &ss_ptr->acq_gwl_gsm_scan_time,
                         NULL,
                         NULL );

} /* sdss_update_eoos_scan_time */

#endif

/*===========================================================================

FUNCTION sdss_cdma_lock_update

DESCRIPTION
  Update the CDMA lock status of the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void                          sdss_cdma_lock_update(

       sd_ss_e_type                  ss,
         /* System selection stack.
         */

       boolean                       is_cdma_locked
         /* Indicate whether MS is CDMA locked until power-cycle.
         */
)
{

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_MSG_HIGH_2("SDSS:FRFL: Updating ss=%d, cdma_locked=%d",ss,is_cdma_locked);
  sdss_ptr(ss)->is_cmda_locked = is_cdma_locked;

} /* sdss_cdma_lock_update */

/*===========================================================================
FUNCTION sdss_avoid_log_get_avoid_type


DESCRIPTION
  Maps selected enums from sdssscr_sched_e_type to sdlog_avoid_type_e_type

DEPENDENCIES
  None.

RETURN VALUE
  Returns a mapped type in sdlog_avoid_type_e_type

SIDE EFFECTS
  None.

===========================================================================*/
static sdlog_avoid_type_e_type        sdss_avoid_log_get_avoid_type(

       sdssscr_sched_e_type           sched,
          /* Sched type to be mapped
          */
       dword                          avoid_time
          /* Time during which system is avoided in case begin avoidance
          */
)
{
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if( sched == SDSSSCR_SCHED_AVOID )
  {
    if( avoid_time == SDSSSCR_AVOID_UNTIL_NEW_ACQ )
    {
      return SDLOG_AVOID_TYPE_UNTIL_NEW_ACQ;
    }
    return SDLOG_AVOID_TYPE_TIMED;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if( sched == SDSSSCR_SCHED_AVOID_UNTIL_ACQ_FAIL )
  {
    return SDLOG_AVOID_TYPE_UNTIL_ACQ_FAIL;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if( sched == SDSSSCR_SCHED_AVOID_UNTIL_ACQ_FAIL_DUR_CALL_ORIG )
  {
    return SDLOG_AVOID_TYPE_UNTIL_ACQ_FAIL_DUR_CALL_ORIG;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if( sched == SDSSSCR_SCHED_AVOID_MAP_UNTIL_ACC_SUCCESS )
  {
    return SDLOG_AVOID_TYPE_MAP_UNTIL_ACC_SUCCESS;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if( sched == SDSSSCR_SCHED_AVOID_UNTIL_ACQ_FAIL_DUR_OPTI_REDIAL )
  {
    return SDLOG_AVOID_TYPE_UNTIL_ACQ_FAIL_DUR_OPTI_REDIAL;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if( sched == SDSSSCR_SCHED_AVOID_CANCEL_ALL )
  {
    return SDLOG_AVOID_TYPE_CANCEL_ALL;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return SDLOG_AVOID_TYPE_MAX;

} /* sdss_avoid_log_get_avoid_type */


/*===========================================================================

FUNCTION sdss_avoidance_log_rprt

DESCRIPTION
  Reports events when SS: 1. Avoids a system
                          2. Stays on an avoided system
                          3. Attempts avoided systems between BSR intervals
                          4. Receives reg status update for any system.

DEPENDENCIES
  None.

RETURN VALUE
  None

SIDE EFFECTS
  None.

===========================================================================*/
static  void                          sdss_avoid_log_rprt(

        sdlog_avoid_report_e_type     avoid_report,
            /* The avoidance logging state
            */

        sd_ss_e_type                  ss,
            /* System selection stack.
            */

        const sdsr_s_type*            sr_ptr,
            /* System record of avoiding system
            */

        dword                         avoid_uptime,
            /* Avoid uptime
            */

        sdssscr_sched_e_type          sched,
            /* Type of reacquisition
            */

        sys_reg_status_e_type         reg_status
            /* Reg status for the system
            */
)
{
  sdlog_avoid_event_s_type avoid_evt   = {0};

  sdss_s_type*             ss_ptr      = NULL;

  SD_ASSERT(sr_ptr != NULL);
  SD_ASSERT_ENUM_IS_INRANGE( avoid_report, SDLOG_AVOID_REPORT_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( reg_status, SYS_REG_STATUS_MAX );


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  avoid_evt.ss_type = (byte)ss;
  avoid_evt.avoid_report = (byte)avoid_report;
  avoid_evt.mode = (byte)sr_ptr->sys.mode;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if(sr_ptr->sys.mode == SYS_SYS_MODE_CDMA)
  {
    avoid_evt.rec.cdma_rec.chan = sr_ptr->sys.chan;
    avoid_evt.rec.cdma_rec.band =
                        (byte)sdss_map_band_pref_to_band( sr_ptr->sys.band );
  }
  else if(sr_ptr->sys.mode == SYS_SYS_MODE_HDR)
  {
    avoid_evt.rec.hdr_rec.chan = sr_ptr->sys.chan;
    avoid_evt.rec.hdr_rec.band =
                        (byte)sdss_map_band_pref_to_band( sr_ptr->sys.band );
  }
  else
  {
    SD_MSG_MED_1("avoid log Unknown mode=%d, undefined system_rec",
               avoid_evt.mode);
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  avoid_evt.avoid_type =
                  (byte)sdss_avoid_log_get_avoid_type( sched, avoid_uptime );
  if(avoid_uptime == SDSSSCR_AVOID_UNTIL_NEW_ACQ)
  {
    ss_ptr = sdss_ptr(ss);

    avoid_evt.exp_uptime = SDLOG_INVALID_TIME;
    avoid_evt.new_acq_cnt = (uint2)ss_ptr->new_acq_cnt;
  }
  else
  {
    avoid_evt.exp_uptime = avoid_uptime;
    avoid_evt.new_acq_cnt = SDLOG_INVALID_COUNT;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  avoid_evt.reg_status = (byte)reg_status;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  avoid_evt.cur_count = sr_ptr->max_access_prob.absr_cnt;

  avoid_evt.absr_count =
      (byte)sdssscr_nv_item_get(SDSSSCR_NV_ITEM_TMR_CDMA_NUM_ABSR_PER_BSR);

  if(avoid_evt.absr_count == 0)
  {
     SD_MSG_HIGH_0( "absr_count read is 0");
     avoid_evt.absr_interval = SDLOG_INVALID_TIME;
  }
  else
  {
   avoid_evt.absr_interval =
     (byte)sdssscr_nv_item_get(SDSSSCR_NV_ITEM_TMR_CDMA_RESEL)/
       avoid_evt.absr_count;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  event_report_payload(EVENT_SD_AVOIDANCE_LOG,
                       sizeof(sdlog_avoid_event_s_type),
                       &avoid_evt );

} /* sdss_avoidance_log_rprt */


/*===========================================================================

FUNCTION sdss_ss_timer_log_rprt

DESCRIPTION
  Reports events when SS timer started/expired/altered.

DEPENDENCIES
  None.

RETURN VALUE
  None

SIDE EFFECTS
  None.

===========================================================================*/
static  void                          sdss_ss_timer_log_rprt(

        const sdss_eng_s_type               *eng_ptr,
          /* Pointer to the SS-script-engine that is associated with the
          ** SS-Script that is being executed.
          */

        sdlog_ss_timer_status_e_type        timer_status
          /* Status of the ss-timer: started/expired */
)
{
  sdog_ss_timer_reason_e_type start_reason = SDLOG_SS_TIMER_REASON_INVALID;
  sdlog_ss_timer_event_s_type timer_evt = {0};

  timer_evt.exp_uptime = eng_ptr->scr_timer;
  timer_evt.ss_type = (byte)eng_ptr->ss;
  timer_evt.timer_status = (byte)timer_status;
  timer_evt.cur_uptime = time_get_uptime_secs();

  switch(eng_ptr->scr_con)
  {
    case SDSSSCR_CON_CONT:
    case SDSSSCR_CON_CONT2:
    case SDSSSCR_CON_CONT3:
      start_reason = SDLOG_SS_TIMER_REASON_WAIT_TIME;
      break;

    case SDSSSCR_CON_CONT_REDIR:
    case SDSSSCR_CON_CONT2_REDIR:
      start_reason = SDLOG_SS_TIMER_REASON_WAIT_REDIR;
      break;

    case SDSSSCR_CON_CONT_EOOS_SLEEP:
      start_reason = SDLOG_SS_TIMER_REASON_EOOS_SLEEP;
      break;

    case SDSSSCR_CON_CONT2_WAIT:
    case SDSSSCR_CON_CONT3_WAIT:
      start_reason = SDLOG_SS_TIMER_REASON_WAIT_COND;
      break;

    case SDSSSCR_CON_CONT_ABSR:
      start_reason = SDLOG_SS_TIMER_REASON_ABSR;
      break;

    case SDSSSCR_CON_CONT_BSR:
    case SDSSSCR_CON_CONT2_BSR:
    case SDSSSCR_CON_CONT3_BSR:
    case SDSSSCR_CON_CONT_TELE_BSR:
    case SDSSSCR_CON_CONT_LONG_BSR:
      start_reason = SDLOG_SS_TIMER_REASON_BSR;
      break;

    default:
      SD_MSG_HIGH_1("CONT const %d isn't identified", eng_ptr->scr_con);
      start_reason = SDLOG_SS_TIMER_REASON_INVALID;
  }

  timer_evt.start_reason = (byte) start_reason;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  event_report_payload(EVENT_SD_SS_TIMER_LOG,
                       sizeof(sdlog_ss_timer_event_s_type),
                       &timer_evt);

} /* sdss_ss_timer_log_rprt */

/*===========================================================================

FUNCTION sdss_bsr_log_rpt

DESCRIPTION
  Reports events when BSR start/end.

DEPENDENCIES
  None.

RETURN VALUE
  None

SIDE EFFECTS
  None.

===========================================================================*/

static void sdss_bsr_log_rpt(
        sdss_bsr_log_event_e_type        event_type
          /* BSR start/end */ )
{
  sdlog_bsr_start_info_s_type start_info;
  sdlog_bsr_end_info_s_type   end_info;
  sd_si_info_s_type           *main_si_info_ptr   = &sd_si_ptr(SD_SS_MAIN)->si_info;
  sd_si_info_s_type           *hybr_1_si_info_ptr = &sd_si_ptr(SD_SS_HYBR_1)->si_info;
  sd_si_info_s_type           *hybr_2_si_info_ptr = &sd_si_ptr(SD_SS_HYBR_2)->si_info;


    SD_MSG_HIGH_1("BSR_EVENT Value %d",event_type);
    if(event_type == SDSS_BSR_LOG_EVENT_START)
    {
      start_info.main_sys_mode = main_si_info_ptr->mode;
      start_info.main_srv_status =
          sys_intl_srv_status_to_actl_srv_status(main_si_info_ptr->srv_status);

      start_info.hybr1_srv_status =
          sys_intl_srv_status_to_actl_srv_status(hybr_1_si_info_ptr->srv_status);

      start_info.hybr2_srv_status =
          sys_intl_srv_status_to_actl_srv_status(hybr_2_si_info_ptr->srv_status);

      event_report_payload(EVENT_SD_HYBR2_BSR_START,
                   sizeof(sdlog_bsr_start_info_s_type),
                   &start_info );
    }
    else if(event_type == SDSS_BSR_LOG_EVENT_END)
    {
      end_info.bsr_status = 0; /* Failure */
      event_report_payload(EVENT_SD_HYBR2_BSR_END,
                   sizeof(sdlog_bsr_end_info_s_type),
                   &end_info );
    }
} /* sdss_bsr_log_rpt */

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_cdma_reg_status_update

DESCRIPTION
  Update the CDMA registration status of the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                          sdss_cdma_reg_status_update(

        sd_ss_e_type                  ss,
          /* System selection stack.
          */

        sys_reg_status_e_type         reg_status,
          /* Registration status.
          */

        const sdsr_s_type*            srv_sys_ptr
          /* Record of the system whose reg state being updated
          */

)
{

  sdss_s_type   *ss_ptr   = sdss_ptr( ss );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ss_ptr->cdma_reg_status = reg_status;

  if( sdss_sr_is_avoid( ss, srv_sys_ptr ) )
  {
    sdss_avoid_log_rprt( SDLOG_AVOID_REPORT_REG,
                         ss,
                         srv_sys_ptr,
                         0,
                         SDSSSCR_SCHED_MAX,
                         reg_status );
  }

  return;

}/* sdss_cdma_reg_status_update() */




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_acc_update

DESCRIPTION
  Update the access related parameters of the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                          sdss_acc_update(

        sd_ss_e_type                  ss,
          /* System selection stack.
          */

        sd_ss_acc_reas_e_type         acc_reas,
            /* Access termination reason.
            */

        sd_ss_acc_term_e_type         acc_term
            /* Access termination reason.
            */
)
{
  sdss_s_type   *ss_ptr   = sdss_ptr( ss );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( acc_reas, SD_SS_ACC_REAS_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( acc_term, SD_SS_ACC_TERM_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ss_ptr->acc_reas = acc_reas;
  ss_ptr->acc_term = acc_term;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If access reason is successful, reset the registration access fail count
  ** and start time.
  */
  if(( acc_term == SD_SS_ACC_TERM_NORMAL )||
     ( acc_term == SD_SS_ACC_TERM_ACC_SUCCESS ))
  {
    ss_ptr->acc_fail_cnt = 0;
    ss_ptr->acc_fail_start_time = ~0;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Else (access is not successful) if access reason is registration,
  ** increment the registration access fail count and set the registration
  ** access fail start time, as needed.
  */
  else if( acc_reas == SD_SS_ACC_REAS_REG ||
           acc_reas == SD_SS_ACC_REAS_OTHER )
  {
    dword  uptime = time_get_uptime_secs();
    /* acc_fail_cnt is used specifically for JCDMA scripts.
    */
    ss_ptr->acc_fail_cnt++;
    ss_ptr->acc_fail_start_time = MIN( ss_ptr->acc_fail_start_time, uptime );

    SD_MSG_LOW_2( "acc_fail_start_time=%d, uptime=%d",
                 ss_ptr->acc_fail_start_time, uptime);
  }

  /* If the access termination reason is acc_fail, update the event count.
  */
  if( acc_reas == SD_SS_ACC_REAS_REG &&
      acc_term == SD_SS_ACC_TERM_ACC_FAIL )
  {
    sdss_event_cnt_update( ss, SDSS_EVT_CNT_UPDT_REAS_ACC_FAIL );
  }
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

} /* sdss_acc_update */



/* <EJECT> */
/*===========================================================================

FUNCTION sdss_event_cnt_update

DESCRIPTION
  Update the event counters/timers of the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                           sdss_event_cnt_update(

        sd_ss_e_type                   ss,
          /* System selection stack.
          */

        sdss_evt_cnt_updt_reas_e_type  evt_cnt_updt_reas
          /* Access termination reason.
          */

)
{
  sdss_s_type               *ss_ptr   = sdss_ptr( ss );
  sdss_cnted_evt_e_type     idx       = SDSS_CNTED_EVT_NONE;
  boolean                   reset     = FALSE;
  int                       i;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( evt_cnt_updt_reas, SDSS_EVT_CNT_UPDT_REAS_MAX );

  SD_MSG_HIGH_2("evt_cnt_update: ss=%d, evt_cnt_updt_reas:%d", ss, evt_cnt_updt_reas);

  if( (evt_cnt_updt_reas == SDSS_EVT_CNT_UPDT_REAS_SID_CHANGED) ||
      (evt_cnt_updt_reas == SDSS_EVT_CNT_UPDT_REAS_ACC_SUCCESS)
    )
  {
    if(ss_ptr->event_cnt[SDSS_CNTED_EVT_ACC_FAIL] == 5)
    {
      /* Clear the system avoid list */
      sdss_sr_avoid_list_clear(SD_SS_MAIN, SDSR_TBL_LST);
    }
  }
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If the SID/NID is changed, reset the counted event count and start time.
  */

  if( evt_cnt_updt_reas == SDSS_EVT_CNT_UPDT_REAS_SID_CHANGED )
  {
    for( i=0; i < (int) SDSS_CNTED_EVT_MAX; i++ )
    {
      ss_ptr->event_cnt[i] = 0;
      ss_ptr->event_uptime[i] = ~0;
    }

    return;
  }

  if( evt_cnt_updt_reas == SDSS_EVT_CNT_UPDT_REAS_HDR_ENTER_TRAFFIC )
  {
    ss_ptr->event_cnt[SDSS_CNTED_EVT_ACC_TIMEOUT] = 0;
    ss_ptr->event_uptime[SDSS_CNTED_EVT_ACC_TIMEOUT] = ~0;

    ss_ptr->event_cnt[SDSS_CNTED_EVT_CON_DENY] = 0;
    ss_ptr->event_uptime[SDSS_CNTED_EVT_CON_DENY] = ~0;

    ss_ptr->event_cnt[SDSS_CNTED_EVT_NET_BUSY] = 0;
    ss_ptr->event_uptime[SDSS_CNTED_EVT_NET_BUSY] = ~0;

    ss_ptr->event_cnt[SDSS_CNTED_EVT_MAP] = 0;
    ss_ptr->event_uptime[SDSS_CNTED_EVT_MAP] = ~0;

    return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Get the reset action and the index of the counted event arry based on the
  ** event count updated reason.
  */

  switch( evt_cnt_updt_reas )
  {
    case SDSS_EVT_CNT_UPDT_REAS_SES_OPENED:
      reset = TRUE;
      idx = SDSS_CNTED_EVT_SES_NEGO_TIMEOUT;
      break;

    case SDSS_EVT_CNT_UPDT_REAS_SES_NEGO_TIMEOUT:
      reset = FALSE;
      idx = SDSS_CNTED_EVT_SES_NEGO_TIMEOUT;
      break;

    case SDSS_EVT_CNT_UPDT_REAS_ACC_TIMEOUT:
      reset = FALSE;
      idx = SDSS_CNTED_EVT_ACC_TIMEOUT;
      break;

    case SDSS_EVT_CNT_UPDT_REAS_CON_DENY:
      reset = FALSE;
      idx = SDSS_CNTED_EVT_CON_DENY;
      break;

    case SDSS_EVT_CNT_UPDT_REAS_NET_BUSY:
      reset = FALSE;
      idx = SDSS_CNTED_EVT_NET_BUSY;
      break;

    case SDSS_EVT_CNT_UPDT_REAS_MAP:
      reset = FALSE;
      idx = SDSS_CNTED_EVT_MAP;
      break;

    case SDSS_EVT_CNT_UPDT_REAS_ACC_NORMAL:
      reset = TRUE;
      idx = SDSS_CNTED_EVT_MAP;
      break;

    case SDSS_EVT_CNT_UPDT_REAS_ACC_FAIL:
      reset = FALSE;
      idx = SDSS_CNTED_EVT_ACC_FAIL;
      if(ss_ptr->event_cnt[SDSS_CNTED_EVT_ACC_FAIL] == 5)
      {
        ss_ptr->event_cnt[idx] = 0;
        ss_ptr->event_uptime[idx] = ~0;
      }
      break;

    case SDSS_EVT_CNT_UPDT_REAS_ACC_SUCCESS:
      reset = TRUE;
      idx = SDSS_CNTED_EVT_ACC_FAIL;
      break;
    case SDSS_EVT_CNT_UPDT_REAS_SID_CHANGED:
      /* It has been processed and returned above.
      */
    case SDSS_EVT_CNT_UPDT_REAS_HDR_ENTER_TRAFFIC:
      /* It has been processed and returned above.
      */
    case SDSS_EVT_CNT_UPDT_REAS_MAX:
    default:
      /* If there is no match of the updt reason, return now.
      */
      SD_ERR_0 ("Invalid updt reason");

      return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If the index is invalid, return now.
  */
  if( idx == SDSS_CNTED_EVT_NONE )
  {
     return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If the action is reset, reset the counter and start time.
  */
  if( reset )
  {
    ss_ptr->event_cnt[idx] = 0;
    ss_ptr->event_uptime[idx] = ~0;
  }
  else
  {
    /* Else update the counter and start time.
    */
    dword  uptime = time_get_uptime_secs();
    ss_ptr->event_cnt[idx]++;
    ss_ptr->event_uptime[idx] = MIN( ss_ptr->event_uptime[idx],
                                         uptime );
  }

  SD_MSG_HIGH_3("evt_cnt_updt: evt=%d cnt=%d time=%d", idx,
                                          ss_ptr->event_cnt[idx],
                                          ss_ptr->event_uptime[idx]);

} /* sdss_event_cnt_update */


#if defined(FEATURE_HDR)
/* <EJECT> */
/*===========================================================================

FUNCTION sdss_event_sid_update

DESCRIPTION
  Update the event SID of the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                           sdss_event_sid_update(

        sd_ss_e_type                   ss,
          /* System selection stack.
          */

        const sd_sid2_u_type           *sid_ptr
            /* Pointer to system SID.
            */
)
{

  sdss_s_type               *ss_ptr   = sdss_ptr( ss );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( sid_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_MSG_HIGH_1( "evt_sid_update ss=%d", ss);

  ss_ptr->event_sid =*sid_ptr;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return;

}/* sdss_event_sid_update */


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_event_is_same_is856_sid

DESCRIPTION
  Check whether a system ID that is matching the specified
  IS-856 Sector ID.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the system ID match the specified IS-856 Sector ID. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean                   sdss_event_is_same_is856_sid(

        sd_ss_e_type              ss,
            /* System selection stack
            */

        const byte                sid_ptr[16],
            /* Pointer to array of 16 byte Sector ID.
            */

        int                       len
            /* Length to match.
            */
)
{

 sdsr_s_type                      sr;
      /* Pointer to a system ID to be checked for SID matching.
      */

  sdss_s_type                     *ss_ptr;
      /* Pointer to a system record to be checked for SID matching.
      */

  boolean                         is_same;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  SD_ASSERT( sid_ptr != 0 );
  SD_ASSERT( len <= 128 );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Point to system sel pointer.
  */
  ss_ptr = sdss_ptr( ss );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Set the mode to HDR.
  */
  sr.sys.mode = SD_MODE_HDR;

  /* Copy system ID to system record.
  */
  sr.sid = ss_ptr->event_sid;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  is_same = sdsr_is_same_is856_sid( &sr, sid_ptr, len );

  if(!is_same)
  {
    SD_MSG_HIGH_2( "evt_is_same_is856_sid=%d, ss=%d",is_same, ss);
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return is_same;


}


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_event_is856_sid_update

DESCRIPTION
  Update the event SID of the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                           sdss_event_is856_sid_update(

        sd_ss_e_type                   ss,
          /* System selection stack.
          */

        const byte                     sid_ptr[16]
            /* Pointer to system SID.
            */
)
{

  sd_sid2_u_type                       sid;
    /* System ID */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( sid_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  memscpy( sid.is856.sector_id, sizeof(sid.is856.sector_id), sid_ptr, sizeof(sid.is856.sector_id) );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  sdss_event_sid_update( ss, &sid );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return;

}/* sdss_event_is856_sid_update */
#endif /* (FEATURE_HDR) */



/* <EJECT> */

#ifdef FEATURE_HDR
/* <EJECT> */
/*===========================================================================

FUNCTION sdss_hdr_ses_close_update

DESCRIPTION
  Update the HDR session close status of the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                          sdss_hdr_ses_close_update(

        sd_ss_e_type                  ss,
            /* System selection stack.
            */

        sd_ss_ses_close_e_type        ses_close
            /* Session close reason.
            */
)
{
  sdss_s_type   *ss_ptr   = sdss_ptr( ss );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( ses_close, SD_SS_SES_CLOSE_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ss_ptr->ses_close = ses_close;

} /* sdss_hdr_ses_close_update */
#endif /* FEATURE_HDR */




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_ho_update

DESCRIPTION
  Update the handoff status of the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  Update the origination mode from emergency-orig to emergency-callback, as
  necessary.

===========================================================================*/
EXTERN  void                          sdss_ho_update(

        sd_ss_e_type                  ss,
            /* System selection stack
            */

        sd_ss_ho_e_type               handoff
            /* Handoff type.
            */
)
{
  sdss_s_type   *ss_ptr   = NULL;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( handoff, SD_SS_HO_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ss_ptr = sdss_ptr(ss);

  /* If handoff it other than AMPS->AMPS, update the handoff status of the
  ** SS-Core.
  */
  if( handoff != SD_SS_HO_AMPS_CAM_TO_AMPS_VOICE )
  {
    sdss_set_handoff( ss, handoff );
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If handoff is other than none, reset the registration access fail count
  ** and start time (as we successfully accessed the system).
  */
  if( handoff != SD_SS_HO_NONE )
  {
    ss_ptr->acc_fail_cnt = 0;
    ss_ptr->acc_fail_start_time = ~0;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

} /* sdss_ho_update */




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_orig_success_update

DESCRIPTION
  Update the orig-success status of the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                          sdss_orig_success_update(

        sd_ss_e_type                  ss
          /* System selection stack
          */

)
{
  sdss_s_type   *ss_ptr   = NULL;

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  ss_ptr = sdss_ptr(ss);

  /* Reading and storing NV item value 1xcsfb_ecbm for SD_SS_MAIN only */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If origination mode is emergency origination, change the origination
  ** mode to emergency callback and inform the registered client (typically
  ** CM) that SD entered emergency callback mode of operation.
  */

  if(ss_ptr->orig_mode == SD_SS_ORIG_MODE_1XCSFB_EMERG_ORIG && ss_ptr->is_1xcsfb_ecbm_supp)
  {
    ss_ptr->is_1xcsfb_ecbm = TRUE;
  /* Setting the ECBM support when ORIG_MODE is 1XCSFB_EMERG_ORIG
       and Feature is supported in NV */
    SD_MSG_HIGH_2("1XCSFB_ECBM: Value of is_1xcsfb_ecbm %d , is_1xcsfb_ecbm_supp %d \n:",ss_ptr->is_1xcsfb_ecbm, ss_ptr->is_1xcsfb_ecbm_supp);
  }

  if(( ss_ptr->orig_mode == SD_SS_ORIG_MODE_EMERG_ORIG ) ||
     (( ss_ptr->orig_mode == SD_SS_ORIG_MODE_1XCSFB_EMERG_ORIG) &&
      ss_ptr->is_1xcsfb_ecbm == TRUE))
  {
    ss_ptr->orig_mode = SD_SS_ORIG_MODE_EMERG_CB;
    sd_si_emerg_cb_mode(SD_EMERG_CB_MODE_MAIN_ENTER);
  }

} /* sdss_orig_success_update */




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_acq_type_update

DESCRIPTION
  Update the acquisition type of the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static  void                          sdss_acq_type_update(

        sdss_s_type                   *ss_ptr,
            /* Pointer to a System Selection information structure.
            */

        sdssscr_acq_e_type            acq_type
            /* Acquisition type.
            */
)
{
  SD_ASSERT( ss_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( acq_type, SDSSSCR_ACQ_MAX );
  SD_ASSERT( acq_type != SDSSSCR_ACQ_SAME_AS_LAST );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ss_ptr->acq_type = acq_type;

} /* sdss_acq_type_update */


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_update_avail_sys_status

DESCRIPTION
  Goes throught the entire system table and updates the AVAIL/UNAVAUL
  prl flag based on the prl_pref.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                      sdss_update_avail_sys_status
(

        sd_ss_e_type              ss,
            /* System selection stack.
            */

        sdsr_e_type               list
            /* List for which to update the avail status.
            */
)
{

  sdsr_s_type   *sr_ptr   = NULL;
  int i = 0;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Traverse the entire system record table.
  */
  while ( (sr_ptr = sdsr_list_get_ptr( list, i )) != NULL )
  {

    /* Check if the system is marked as avail or unavail.
    */
    if ( sr_ptr->prl == (byte)SDSS_PRL_AVAIL ||
         sr_ptr->prl == (byte)SDSS_PRL_UNAVAIL
       )
    {
      sr_ptr->prl = (byte)SDSS_PRL_AVAIL;
      if ( sdss_sr_is_pref_conf( ss, sr_ptr, SDSS_PREF_CONF_PRL ))
      {
        sr_ptr->prl = (byte)SDSS_PRL_UNAVAIL;
      }
    }
    i++;
  } /* while () */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

} /* sdss_update_avail_sys_status */




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_is_pref_chgd

DESCRIPTION
  Check whether preference specified in the parameter changed during the last
  preferred system changed command.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if preference changed.

SIDE EFFECTS
  None.

===========================================================================*/
boolean                   sdss_is_pref_chgd(

        sd_ss_e_type              ss,
            /* System selection stack.
            */

        sdss_pref_chgd_e_type     pref_chgd
            /* SS-Preference changed to be evaluated.
            */
)
{
  sdss_s_type            *ss_ptr            = sdss_ptr( ss );
  boolean                 is_pref_chgd      = FALSE;

  sd_ss_mode_pref_e_type  prev_supp_mode_pref;
  sd_ss_mode_pref_e_type  curr_supp_mode_pref;
  sd_ss_band_pref_e_type  prev_supp_band_pref;
  sd_ss_band_pref_e_type  curr_supp_band_pref;
  sys_lte_band_mask_e_type  prev_supp_band_pref_lte;
  sys_lte_band_mask_e_type  curr_supp_band_pref_lte;
  sd_ss_band_pref_e_type  prev_supp_band_pref_tds;
  sd_ss_band_pref_e_type  curr_supp_band_pref_tds;

  sd_ss_mode_pref_e_type  ss_mode_pref      = SD_SS_MODE_PREF_NONE;
  sd_ss_band_pref_e_type  ss_band_pref      = SD_SS_BAND_PREF_NONE;
  sys_lte_band_mask_e_type  ss_lte_band_pref  = SYS_LTE_BAND_MASK_CONST_NONE;
  sd_ss_band_pref_e_type  ss_tds_band_pref  = SD_SS_BAND_PREF_NONE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( ss_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( pref_chgd, SDSS_PREF_CHGD_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Get supported mode and band pref.
  */
  sdss_get_mode_band_pref( ss,
                           &ss_mode_pref,
                           &ss_band_pref,
                           &ss_lte_band_pref,
                           &ss_tds_band_pref );

  curr_supp_mode_pref     = ss_mode_pref;
  curr_supp_band_pref     = ss_band_pref;
  curr_supp_band_pref_lte = ss_lte_band_pref;
  curr_supp_band_pref_tds = ss_tds_band_pref;

#ifdef FEATURE_TDSCDMA
  sd_misc_get_band_mode_mmode( &curr_supp_mode_pref, &curr_supp_band_pref,
                             &curr_supp_band_pref_lte, &curr_supp_band_pref_tds,
                             ss_mode_pref, SD_SS_BAND_PREF_ANY,
                             SYS_LTE_BAND_MASK_CONST_ANY, SD_SS_BAND_PREF_TDS_ANY);
#else
  sd_misc_get_band_mode_mmode( &curr_supp_mode_pref, &curr_supp_band_pref,
                             &curr_supp_band_pref_lte, &curr_supp_band_pref_tds,
                             SD_SS_MODE_PREF_ANY, SD_SS_BAND_PREF_ANY,
                             SYS_LTE_BAND_MASK_CONST_ANY, SD_SS_BAND_PREF_TDS_ANY);
#endif /* FEATURE_TDSCDMA */

  prev_supp_mode_pref      = ss_ptr->prev_mode_pref;
  prev_supp_band_pref      = ss_ptr->prev_band_pref;
  prev_supp_band_pref_lte  = ss_ptr->lte_prev_band_pref;
  prev_supp_band_pref_tds  = ss_ptr->tds_prev_band_pref;

#ifdef FEATURE_TDSCDMA
  sd_misc_get_band_mode_mmode( &prev_supp_mode_pref, &prev_supp_band_pref,
                             &prev_supp_band_pref_lte, &prev_supp_band_pref_tds,
                             ss_ptr->prev_mode_pref, SD_SS_BAND_PREF_ANY,
                             SYS_LTE_BAND_MASK_CONST_ANY, SD_SS_BAND_PREF_TDS_ANY);
#else
  sd_misc_get_band_mode_mmode( &prev_supp_mode_pref, &prev_supp_band_pref,
                             &prev_supp_band_pref_lte, &prev_supp_band_pref_tds,
                             SD_SS_MODE_PREF_ANY, SD_SS_BAND_PREF_ANY,
                             SYS_LTE_BAND_MASK_CONST_ANY, SD_SS_BAND_PREF_TDS_ANY);
#endif /* FEATURE_TDSCDMA */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If requested, check for mode preference changes.
  */
  if( SDSS_PREF_CONTAIN( pref_chgd, SDSS_PREF_CHGD_MODE ))
  {
    if( curr_supp_mode_pref != prev_supp_mode_pref )
    {
      is_pref_chgd = TRUE;
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If requested, check for band preference changes.
  */
  if( SDSS_PREF_CONTAIN( pref_chgd, SDSS_PREF_CHGD_BAND ) )
  {
    if (( curr_supp_band_pref != prev_supp_band_pref ) ||
         !SYS_LTE_BAND_MASK_CHK_IF_EQUAL(&curr_supp_band_pref_lte,&prev_supp_band_pref_lte ))
    {
      is_pref_chgd = TRUE;
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If requested, check for roam preference changes.
  */
  if( SDSS_PREF_CONTAIN( pref_chgd, SDSS_PREF_CHGD_ROAM ) )
  {
    if( ss_ptr->roam_pref != ss_ptr->prev_roam_pref )
    {
      is_pref_chgd = TRUE;
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If requested, check for hybrid preference changes.
  */
  if( SDSS_PREF_CONTAIN( pref_chgd, SDSS_PREF_CHGD_HYBR ) )
  {
    if( sdss_is_hybr_pref_chgd(ss) )
    {
      is_pref_chgd = TRUE;
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If requested, check for domain preference changes.
  */
  if( SDSS_PREF_CONTAIN( pref_chgd, SDSS_PREF_CHGD_DOMAIN ) )
  {
    if( ss_ptr->domain_pref != ss_ptr->prev_domain_pref )
    {
      SD_MSG_HIGH_0( "Srv Domain Chgd, Return TRUE" );
      is_pref_chgd = TRUE;
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If requested, check for acq. order preference changes.
  */
  if( SDSS_PREF_CONTAIN( pref_chgd, SDSS_PREF_CHGD_ACQ_ORDER ) )
  {
    if( ss_ptr->acq_order_pref != ss_ptr->prev_acq_order_pref )
    {
      is_pref_chgd = TRUE;
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* If requested, check for RAT priority list changes.
  */
  if (SDSS_PREF_CONTAIN( pref_chgd, SDSS_PREF_CHGD_RAT_PRI_LST))
  {
    if(sdss_is_rat_pri_lst_chgd(ss))
    {
      is_pref_chgd = TRUE;
    }
  }
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If the pref_conf category is CONF_NONE negate the return value;
  */
  if( pref_chgd == SDSS_PREF_CHGD_NONE )
  {
    is_pref_chgd = !is_pref_chgd;
  }

  return SD_BOOLEAN( is_pref_chgd );

} /* sdss_is_pref_chgd */

/*===========================================================================

FUNCTION sdss_is_band_pref_chgd

DESCRIPTION
  Check whether preference specified in the parameter changed during the last
  preferred system changed command.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if preference changed.

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean                   sdss_is_band_pref_chgd(

        sd_ss_e_type              ss,
            /* System selection stack.
            */

        sd_ss_mode_pref_e_type    mode
            /* mode of bands to be evaluated.
            */
)
{
  sdss_s_type            *ss_ptr            = sdss_ptr( ss );
  sd_ss_mode_pref_e_type  prev_supp_mode_pref;
  sd_ss_mode_pref_e_type  curr_supp_mode_pref;
  sd_ss_band_pref_e_type  prev_supp_band_pref;
  sd_ss_band_pref_e_type  curr_supp_band_pref;
  sys_lte_band_mask_e_type  prev_supp_band_pref_lte;
  sys_lte_band_mask_e_type  curr_supp_band_pref_lte;
  sd_ss_band_pref_e_type  prev_supp_band_pref_tds;
  sd_ss_band_pref_e_type  curr_supp_band_pref_tds;

  sd_ss_mode_pref_e_type  ss_mode_pref      = SD_SS_MODE_PREF_NONE;
  sd_ss_band_pref_e_type  ss_band_pref      = SD_SS_BAND_PREF_NONE;
  sys_lte_band_mask_e_type  ss_lte_band_pref  = SYS_LTE_BAND_MASK_CONST_NONE;
  sd_ss_band_pref_e_type  ss_tds_band_pref  = SD_SS_BAND_PREF_NONE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  SD_ASSERT( ss_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Get supported mode and band pref.
  */
  sdss_get_mode_band_pref( ss,
                           &ss_mode_pref,
                           &ss_band_pref,
                           &ss_lte_band_pref,
                           &ss_tds_band_pref );

  curr_supp_mode_pref      = ss_mode_pref;
  curr_supp_band_pref      = ss_band_pref;
  curr_supp_band_pref_lte  = ss_lte_band_pref;
  curr_supp_band_pref_tds  = ss_tds_band_pref;

  sd_misc_get_band_mode_mmode( &curr_supp_mode_pref, &curr_supp_band_pref,
                             &curr_supp_band_pref_lte, &curr_supp_band_pref_tds,
                             mode, SD_SS_BAND_PREF_ANY, SYS_LTE_BAND_MASK_CONST_ANY,
                             SD_SS_BAND_PREF_TDS_ANY
                       );

  prev_supp_mode_pref      = ss_ptr->prev_mode_pref;
  prev_supp_band_pref      = ss_ptr->prev_band_pref;
  prev_supp_band_pref_lte  = ss_ptr->lte_prev_band_pref;
  prev_supp_band_pref_tds  = ss_ptr->tds_prev_band_pref;

  sd_misc_get_band_mode_mmode( &prev_supp_mode_pref, &prev_supp_band_pref,
                         &prev_supp_band_pref_lte, &prev_supp_band_pref_tds,
                         mode, SD_SS_BAND_PREF_ANY, SYS_LTE_BAND_MASK_CONST_ANY,
                         SD_SS_BAND_PREF_ANY
                       );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


  /* Check for band preference changes.
  */
  return SD_BOOLEAN(    ( curr_supp_band_pref     != prev_supp_band_pref )
                    ||  !SYS_LTE_BAND_MASK_CHK_IF_EQUAL(&curr_supp_band_pref_lte,&prev_supp_band_pref_lte)
                    ||  ( curr_supp_band_pref_tds != prev_supp_band_pref_tds )
                   );

} /* sdss_is_band_pref_chgd */


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_is_pref_updated

DESCRIPTION
  Check whether preference specified in the parameter changed during the last
  preferred system changed command.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if preference changed.

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean                   sdss_is_pref_update(

        sd_ss_e_type              ss,
            /* System selection stack.
            */

        sdss_pref_updated_e_type     pref_update
            /* SS-Preference changed to be evaluated.
            */
)
{
  sdss_s_type   *ss_ptr = sdss_ptr( ss );

  SD_ASSERT( ss_ptr != NULL )
  SD_ASSERT_ENUM_IS_INRANGE( pref_update, SDSS_PREF_UPDATE_MAX );

  return ( SD_BOOLEAN( ss_ptr->ss_pref_updated_status == pref_update ));

} /* sdss_is_pref_updated */

/*===========================================================================

FUNCTION sdss_is_pref_update_reas

DESCRIPTION
  Check whether pref  update reason specified in the parameter changed
  equals the pref update reason of the last preferred system changed command.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if preference changed.

SIDE EFFECTS
  None.

===========================================================================*/
boolean   sdss_is_pref_update_reas(
        sd_ss_e_type              ss,
            /* System selection stack.
            */

        sd_ss_pref_update_reason_e_type    pref_update_reas
            /* SS-Preference changed to be evaluated.
            */
)
{
  sdss_s_type   *ss_ptr = sdss_ptr( ss );

  SD_ASSERT( ss_ptr != NULL )
  SD_ASSERT_ENUM_IS_INRANGE( pref_update_reas, SD_SS_PREF_UPDATE_REASON_MAX );

  if(ss_ptr->pref_update_reas == pref_update_reas)
  {
    SD_MSG_HIGH_2("pref upd reason:%d, cmp val:%d",
                  ss_ptr->pref_update_reas,
                  pref_update_reas);
  }

  return ( SD_BOOLEAN( ss_ptr->pref_update_reas == pref_update_reas ));

} /* sdss_is_pref_update_reas */

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_is_stay_current_state

DESCRIPTION
  Decide on if ss should stay on the current state.

DEPENDENCIES
  sdss_init() must have already been called to initialize the System
  Selection Core (SS-Core).

RETURN VALUE
  The next System Selection state.

SIDE EFFECTS
  None.

===========================================================================*/
//static boolean                  sdss_is_stay_current_state(

//       sd_ss_e_type             ss,
//         /* The ss for the event
//         */

//       sdss_evt_e_type          event,
//          /* SS-Event that was process.
//          */

//       sdss_pref_updated_e_type pref_updated_status,
//          /* Enumeration of preference updated type.
//          */
//
//       const sdss_iact_s_type   *rtrn_iact_ptr
//        /* Pointer to a buffer where returned internal action is placed.
//          */
//)
//{
//
//  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

//  SD_ASSERT_ENUM_IS_INRANGE( event, SDSS_EVT_MAX );
//  SD_ASSERT_ENUM_IS_INRANGE( pref_updated_status, SDSS_PREF_UPDATE_MAX );
//  SD_ASSERT( rtrn_iact_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If event is not user ss pref change, return now.
  */
//  if( event != SDSS_EVT_USER_SS_PREF )
//  {
//    return FALSE;
//  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If the ss pref change is not SDSS_PREF_UPDATED_SRV_DOMAIN, return now.
  */
//  if(  pref_updated_status != SDSS_PREF_UPDATED_SRV_DOMAIN )
//  {
//    return FALSE;
//  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If the action is not acquisition, return now.
  */
//  if( rtrn_iact_ptr->act != SDSS_IACT_ACQUIRE )
//  {
//    return FALSE;
//  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If  both mode of idle system and attempt system are GW.
  ** decide to stay on the current state.
  */

//  if( sdsr_is_sys( SD_MODE_GW, sdss_sr_list_map2( ss,SDSR_IDL_SYS), 0 ) &&
//     sdsr_is_sys( SD_MODE_GW, rtrn_iact_ptr->prm.acq.list, rtrn_iact_ptr->prm.acq.pos )
//    )
//  {
//    SD_MSG_HIGH_1("Stay on current state, event=%d", event);

//    return TRUE;
//  }

//  return FALSE;

// }/* sdss_is_stay_current_state */


/*===========================================================================

FUNCTION sdss_get_ss_state

DESCRIPTION
  Retrieve the current System Selection state.

DEPENDENCIES
  sdss_init() must have already been called to initialize the System
  Selection Core (SS-Core).

RETURN VALUE
  The current System Selection state.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sdss_state_e_type             sdss_get_ss_state(

        sd_ss_e_type                  ss
            /* System selection stack.
            */
)
{
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  return sdss_ptr(ss)->ss_state;
}

/*===========================================================================

FUNCTION sdss_set_ss_state

DESCRIPTION
  Update the current System Selection state.

DEPENDENCIES
  sdss_init() must have already been called to initialize the System
  Selection Core (SS-Core).

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
void                          sdss_set_ss_state(

        sd_ss_e_type                  ss,
            /* System selection stack.
            */

        sdss_state_e_type             ss_state
)
{
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  sdss_ptr(ss)->ss_state = ss_state;
}

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_state_next

DESCRIPTION
  Decide on the next System Selection state.

DEPENDENCIES
  sdss_init() must have already been called to initialize the System
  Selection Core (SS-Core).

RETURN VALUE
  The next System Selection state.

SIDE EFFECTS
  None.

===========================================================================*/
static  void                  sdss_state_next(
        /*lint -esym(715, ss) */ /* not referenced */
        sd_ss_e_type          ss,
            /* System selection stack.
            */

        sdss_evt_e_type       event,
            /* SS-Event that was process.
            */

        sdss_iact_s_type      *rtrn_iact_ptr
            /* Pointer to a buffer where returned internal action is placed.
            */
)
{
  sdss_iact_e_type        act;
  boolean                 is_dedicated_meas_mode;
  sdss_state_e_type       prev_ss_state;
  sdss_state_e_type       ss_state;
  sys_srv_status_e_type   ss_srv_status     = SYS_SRV_STATUS_NONE;

                      /*lint -esym(550, prev_ss_state) */ /* not accessed */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( event, SDSS_EVT_MAX );
  SD_ASSERT( rtrn_iact_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Get the action and dedicated measurement mode indication.
  */
  act                     = rtrn_iact_ptr->act;
  is_dedicated_meas_mode  = SD_BOOLEAN( rtrn_iact_ptr->prm.meas.mode ==
                                     SDSS_MEAS_MODE_DED );
  ss_state                = sdss_get_ss_state(ss);
  prev_ss_state           = ss_state;
  sdss_read_srv_status( ss, &ss_srv_status, NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If action is acquire or perform measurement in dedicated mode, change
  ** the SS-State to acquisition.
  */
  if( act == SDSS_IACT_ACQUIRE  ||
      act == SDSS_IACT_PWR_SAVE ||
      (act == SDSS_IACT_MEAS && is_dedicated_meas_mode) )
  {
    ss_state = SDSS_STATE_ACQ;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Else, if event is CDMA SCHM, AMPS control channel SID or HDR
  ** acquisition SID and action is continue, change the SS-State to
  ** verification.
  */
  else if( event == SDSS_EVT_CDMA_ACQ_SCHM              ||
           event == SDSS_EVT_AMPS_ACQ_CCH_SID           ||
           event == SDSS_EVT_HDR_ACQ_SID                ||
           event == SDSS_EVT_HYBR_2_GW_ACQ_PLMN_SUCCESS ||
           event == SDSS_EVT_HYBR_3_GW_ACQ_PLMN_SUCCESS ||
           event == SDSS_EVT_GWL_ACQ_PLMN_SUCCESS
         )
  {
    if( act == SDSS_IACT_CONTINUE )
    {
      ss_state = SDSS_STATE_VRFY;
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Else, if event is CDMA overhead info, AMPS paging channel SID or HDR or
  ** GSM/UMTS/LTE overhead info and action is continue or measurement in
  ** background mode, change the SS-State to operation.
  */
  else if( event == SDSS_EVT_CDMA_OPR_OH_SID  ||
           event == SDSS_EVT_CDMA_OPR_OH_CHAN ||
           event == SDSS_EVT_AMPS_OPR_PCH_SID ||
           event == SDSS_EVT_HDR_OPR_OH_SID   ||
           event == SDSS_EVT_HDR_OPR_OH_CHAN  ||
           event == SDSS_EVT_GWL_OPR_SRV_INFO ||
           event == SDSS_EVT_HYBR_3_GW_OPR_SRV_INFO ||
           event == SDSS_EVT_HYBR_2_GW_OPR_SRV_INFO
         )
  {

    if( (act == SDSS_IACT_CONTINUE && ss_srv_status != SYS_SRV_STATUS_LIMITED_REGIONAL) ||
        (act == SDSS_IACT_MEAS && !is_dedicated_meas_mode) )
    {
      ss_state = SDSS_STATE_OPR;
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Else if event is power save, enter the acq state is PWR save
  */

  else if( event == SDSS_EVT_MISC_PWR_SAVE_ENTER &&
           act == SDSS_IACT_CONTINUE )
  {
    ss_state = SDSS_STATE_PWR_SAVE;
  }
  else if( event == SDSS_EVT_CDMA_ACQ_HO_FAIL )
  {
    ss_state = SDSS_STATE_VRFY;
  }

  /* Inform the SS-Front end of the SS-State.
  */
  SD_MSG_HIGH_5("Ltd_reg: ss_state_update act = %d, srv_status = %d, ss state = %d -> %d, event = %d",
                act, sdss_ptr(ss)->srv_status,
              prev_ss_state, ss_state, event);

  rtrn_iact_ptr->ss_state = ss_state;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if( prev_ss_state != ss_state )
  {
    sdss_set_ss_state(ss,ss_state);
  }

} /* sdss_state_next *//*lint +esym(550, prev_state) */ /* not accessed */
                       /*lint +esym(715, ss) */ /* not referenced */



/* <EJECT> */
/*===========================================================================

FUNCTION sdss_update_absr

DESCRIPTION
  Update the ABSR field based on the reselection state.

DEPENDENCIES
  sdss_init() must have already been called to initialize the System
  Selection Core (SS-Core).

RETURN VALUE
  NONE

SIDE EFFECTS
  None.

===========================================================================*/
static  void                            sdss_update_absr(

        sdss_s_type                     *ss_ptr,
            /* Pointer to a System Selection information structure.
            */

        const sdss_resel_stt_e_type     *resel_state_ptr,
            /* Pointer to the reselection state.
            */

        const sdssscr_prm_type          *con_prm_ptr,
            /* Pointer to the construct parameter.
            */

        boolean                         *is_cond_true_ptr
           /* Pointer to return the condition true flag.
           */
)
{

  sdss_resel_stt_e_type   resel_state = SDSS_RESEL_STT_MAX;
  sdssscr_absr_cnt_e_type con_prm = SDSSSCR_ABSR_CNT_NONE;
  sdss_absr_s_type        prev_absr;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( ss_ptr != NULL );

  if ( resel_state_ptr !=NULL )
  {
    SD_ASSERT_ENUM_IS_INRANGE_INC( *resel_state_ptr, SDSS_RESEL_STT_MAX );

    resel_state = *resel_state_ptr;
  }

  if( con_prm_ptr != NULL )
  {
    con_prm = (sdssscr_absr_cnt_e_type)(*con_prm_ptr);

    SD_ASSERT_ENUM_IS_INRANGE( *con_prm_ptr, SDSSSCR_ABSR_CNT_MAX );

    SD_ASSERT( is_cond_true_ptr != NULL );

    /* Reset the condition to FALSE;
    */
    *is_cond_true_ptr = FALSE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Store the previous value.
  */
  prev_absr.cnt = ss_ptr->absr.cnt;
  prev_absr.is_activated = ss_ptr->absr.is_activated;
  prev_absr.num_per_bsr = ss_ptr->absr.num_per_bsr;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Reset ABSR CNT if Reselection state is none.
  */

  if( resel_state == SDSS_RESEL_STT_NONE &&
      ss_ptr->absr.is_activated == TRUE )
  {
    ss_ptr->absr.is_activated = FALSE;
  }

  /* Activate the ABSR if ABSR is first started.
  */

  if( resel_state == SDSS_RESEL_STT_ABSR &&
      ss_ptr->absr.is_activated == FALSE )
  {
    ss_ptr->absr.is_activated = TRUE;
    ss_ptr->absr.cnt = 1;
    ss_ptr->absr.num_per_bsr =
              sdssscr_nv_item_get(SDSSSCR_NV_ITEM_TMR_CDMA_NUM_ABSR_PER_BSR);
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Validate the condition of the ABSR CNT.
  */

  switch ( con_prm )
  {

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_ABSR_CNT_LESS_THAN_NUM_ABSR_PER_BSR:

      if( ss_ptr->absr.is_activated &&
          ss_ptr->absr.cnt < ss_ptr->absr.num_per_bsr )
      {
        *is_cond_true_ptr =  TRUE;
        /* Increment the ABSR counter
        */
        ss_ptr->absr.cnt ++;
      }

      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_ABSR_CNT_SAME_AS_NUM_ABSR_PER_BSR:

      if( ss_ptr->absr.is_activated &&
          ss_ptr->absr.cnt >= ss_ptr->absr.num_per_bsr )
      {

        *is_cond_true_ptr =  TRUE;
        /* Reset the activation flag.
        */
        ss_ptr->absr.is_activated = FALSE;

      }

      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_ABSR_CNT_NONE:
    case SDSSSCR_ABSR_CNT_MAX:

    default:

      break;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Print out the value if there is a change.
  */

  if( prev_absr.cnt != ss_ptr->absr.cnt ||
      prev_absr.is_activated != ss_ptr->absr.is_activated ||
      prev_absr.num_per_bsr != ss_ptr->absr.num_per_bsr )
  {

    SD_MSG_HIGH_6( "Prev ABSR activat=%d, cnt =%d, num per bsr=%d Curr ABSR activat=%d, cnt =%d, num per bsr=%d",
                  prev_absr.is_activated,
                  prev_absr.cnt,
                  prev_absr.num_per_bsr,
                  ss_ptr->absr.is_activated,
                  ss_ptr->absr.cnt,
                  ss_ptr->absr.num_per_bsr 
                  );
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return;


}/* sdss_update_absr */

/*===========================================================================

FUNCTION sdss_cdma_bsr_in_progress

DESCRIPTION
  Call the SD callback based on BSR start/end while camped on a 1X system

DEPENDENCIES
  sdss_init() must have already been called to initialize the System
  Selection Core (SS-Core).

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/

void sdss_cdma_bsr_in_progress(
        sd_ss_e_type              ss,
        /* System selection stack.
        */

        sdss_resel_stt_e_type     resel_state
        /* New reselection state.
        */
)
{
  sd_si_info_s_type     *si_info_ptr = &sd_si_ptr(ss)->si_info;;


  SD_MSG_HIGH_3("Resel state: %d, mode: %d, Acq pref list cnt: %d",
               resel_state,si_info_ptr->mode,sdsr_list_cnt(SDSR_ACQ_PREF_LST));

  if( (ss == SD_SS_MAIN) &&
      (si_info_ptr->mode == SD_MODE_CDMA) &&
      (resel_state == SDSS_RESEL_STT_SRCH) 
    )
  {	  
    //Once BSR is started, call the callback with BSR status TRUE
    sdcmd_cdma_bsr_in_progress_cb(TRUE);
  }
  else if(resel_state == SDSS_RESEL_STT_NONE ||
  	 resel_state == SDSS_RESEL_STT_REACQ)
  {
    //Once BSR is ended, call the callback with BSR status FALSE
    sdcmd_cdma_bsr_in_progress_cb(FALSE);
  }

}

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_resel_state_update

DESCRIPTION
  Update the reselection state variable.

DEPENDENCIES
  sdss_init() must have already been called to initialize the System
  Selection Core (SS-Core).

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static  void                      sdss_resel_state_update(

        sd_ss_e_type              ss,
            /* System selection stack.
            */

        sdss_s_type               *ss_ptr,
            /* Pointer to a System Selection information structure.
            */

        sdss_resel_stt_e_type     resel_state
            /* New reselection state.
            */
)
{
  SD_ASSERT( ss_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( resel_state, SDSS_RESEL_STT_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ss_ptr->resel_state = resel_state;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  sdss_update_absr(ss_ptr, &resel_state, NULL, NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Update the HYBR BSR flag.
  */
  if(resel_state == SDSS_RESEL_STT_HYBR_BSR)
  {
    sd_si_resel_hybr_bsr_state_update(ss, TRUE);
  }
  else
  {
    sd_si_resel_hybr_bsr_state_update(ss, FALSE);
  }

} /* sdss_resel_state_update */




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_resel_mode_update

DESCRIPTION
  Update the reselection mode variable.

DEPENDENCIES
  sdss_init() must have already been called to initialize the System
  Selection Core (SS-Core).

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static  void                      sdss_resel_mode_update(

        sdss_s_type               *ss_ptr,
            /* Pointer to a System Selection information structure.
            */

        sdss_resel_mode_e_type    resel_mode
            /* New reselection mode.
            */
)
{
  SD_ASSERT( ss_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( resel_mode, SDSS_RESEL_MODE_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_MSG_HIGH_1("Set Resel Mode :: %d",resel_mode);
  ss_ptr->resel_mode = resel_mode;

} /* sdss_resel_mode_update */


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_set_flag

DESCRIPTION
  Set the flag to val.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                          sdss_set_flag(

        sd_ss_e_type                  ss,
            /* System selection stack.
            */

        sdss_flag_e_type              flag,
            /* The flag to set
            */

        boolean                       val
            /* The value the flag is supposed to be set to
            */
)
{
  boolean  *flag_ptr = NULL;

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( flag, SDSS_FLAG_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  switch( flag )
  {
    case SDSS_FLAG_TRUE_EVENT_PROCESSED:
      flag_ptr = &sdss_ptr( ss )->is_true_event_processed;
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    case SDSS_FLAG_SYNC_UP_IN_PROGRESS:
      #ifdef FEATURE_HICPS_STACK_SYNC_UP
      flag_ptr = &sdss_ptr( ss )->is_stack_syncup_in_progress;
      #endif /* FEATURE_HICPS_STACK_SYNC_UP */
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_FLAG_ENG_SCR_TIMER:
      flag_ptr = &sdss_ptr( ss )->is_eng_scr_timer_set;
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_FLAG_HYBR_HDR_IRAT:
      sdss_update_hybr_hdr_irat_operation( val );
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    case SDSS_FLAG_MAP_SCAN:
      flag_ptr = &sdss_ptr( ss )->is_map_scan;
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_FLAG_HYBR2_BSR:
      flag_ptr = &sdss_ptr( ss )->is_hybr_2_bsr;
      break;

    case SDSS_FLAG_SRV_TYPE_NON_MMSS:
     #ifdef FEATURE_MMSS_3_1
     flag_ptr = &sdss_ptr( ss )->is_non_mmss_type;
     #endif
     break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_FLAG_HYBR2_LTE_IRAT_FAIL:
      flag_ptr = &sdss_ptr( ss )->is_hybr2_lte_irat_fail;
      break;

    case SDSS_FLAG_IS_IBSR_PWRUP_DONE:
      flag_ptr = &sdss_ptr( ss )->iBSR_pwrup;
      break;

     case SDSS_FLAG_LOC_BASE_BSR:
      if(sdss_ptr( ss )->is_loc_based_bsr && !val)
      {
        sdss_ptr( ss )->is_loc_chg_move_out = TRUE;
      }
      else if(val)
      {
        sdss_ptr( ss )->is_loc_chg_move_out = FALSE;
      }
      sdss_ptr( ss )->is_loc_based_bsr = val;
      SD_MSG_HIGH_2("loc_bsr: set flag to %d, is_chg=%d",val,sdss_ptr( ss )->is_loc_chg_move_out);

      break;

   case SDSS_FLAG_MCC_MATCH_FOUND:
      flag_ptr = &sdss_ptr( ss )->is_mcc_match_found;
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

   case SDSS_FLAG_1XCSFB_ECBM:
      flag_ptr = &sdss_ptr( ss )->is_1xcsfb_ecbm;
      break;

    case SDSS_FLAG_FULL_SRV_REQ_DURING_EMERG:
       flag_ptr = &sdss_ptr( ss )->is_full_srv_req_during_emerg;
       break;


    case SDSS_FLAG_HDR_DEACT_BY_HYBR2_BSR:
       flag_ptr = &sdss_ptr( ss )->is_hdr_deact_by_hybr2_bsr;
       break;

    case SDSS_FLAG_OVERRIDE_E911_ADD_INFO:
      flag_ptr = &sdss_ptr( ss )->is_override_e911_add_info;
      break;

    case SDSS_FLAG_IS_FORCE_KICK_HYBR2:
      flag_ptr = &sdss_common.is_force_kick_hybr2;
      break;
      
    case SDSS_FLAG_EMERG_ROAM:
      sdss_set_e911_in_roam(ss,val);
      break;

    case SDSS_FLAG_PSEUDO:
      val = val;
      break;

    case SDSS_FLAG_SPECIAL_VOLTE_REDIAL:
      flag_ptr = &sdss_ptr( ss )->is_special_volte_redial;
      break;

    case SDSS_FLAG_C2K_ALT_ALGR:
    case SDSS_FLAG_NONE:
    case SDSS_FLAG_WCDMA_FREQ_LOCK:
    case SDSS_FLAG_MAX:
    default:

      SD_ERR_1(" Invalid flag %d", flag);
      break;
   /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  }

  if(flag_ptr != NULL)
  {
     SD_MSG_HIGH_3("Set ss=%d FLAG=%d to val=%d",ss, flag, val);
    *flag_ptr = val;
  }
} /* sdss_set_flag */


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_get_cdma_request_mode

DESCRIPTION
  If FEATURE_MMODE_REMOVE_1X is not supported, return 0.

  Get the CDMA request_mode to be used in CDMA origination and page-response
  messages.

  The CDMA request mode is determined according to the current mode and
  band preferences.

DEPENDENCIES
  None.

RETURN VALUE
  CDMA request_mode as defined in ANSI J-STD-008 Table 2.7.1.3.2.4-1 and
  cai.h.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  byte                  sdss_get_cdma_request_mode( void )
{

  /* If this target has AMPS support, do the following:
  */
  #if (defined(FEATURE_ACP) && !defined(FEATURE_MMODE_REMOVE_1X))

  sd_ss_mode_pref_e_type  ss_mode_pref    = SD_SS_MODE_PREF_NONE;
  sd_ss_e_type            ss = sdss_get_ss_for_mode(SD_MODE_CDMA);
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if( ss == SD_SS_MAX )
  {
    SD_MSG_HIGH_0("CDMA not supported on any stack");
    return CAI_CDMA_OR_ANALOG;
  }

  sdss_get_mode_band_pref( ss,
                           &ss_mode_pref,
                           NULL,
                           NULL,
                           NULL );

  /*lint -e788 */
  switch( ss_mode_pref )
  {
    case SD_SS_MODE_PREF_CDMA:
    case SD_SS_MODE_PREF_DIGITAL:
      return CAI_CDMA_ONLY;

    case SD_SS_MODE_PREF_CDMA_AMPS:
    case SD_SS_MODE_PREF_ANY:
      return CAI_CDMA_OR_ANALOG;

    case SD_SS_MODE_PREF_AMPS:
    case SD_SS_MODE_PREF_HDR:
      return CAI_CDMA_OR_ANALOG;

    case SD_SS_MODE_PREF_NONE:
    case SD_SS_MODE_PREF_GPS:
    case SD_SS_MODE_PREF_GSM:
    case SD_SS_MODE_PREF_WCDMA:
    case SD_SS_MODE_PREF_GW:
    case SD_SS_MODE_PREF_MAX:
    case SD_SS_MODE_PREF_CDMA_AMPS_HDR:
    case SD_SS_MODE_PREF_CDMA_HDR:
    case SD_SS_MODE_PREF_HDR_WCDMA:
    case SD_SS_MODE_PREF_HDR_GW:
    case SD_SS_MODE_PREF_DIGITAL_LESS_HDR:
    case SD_SS_MODE_PREF_ANY_BUT_HDR:
    case SD_SS_MODE_PREF_ANY_BUT_HDR_LTE:
    case SD_SS_MODE_PREF_ALL_MODES:
    case SD_SS_MODE_PREF_LTE:
    case SD_SS_MODE_PREF_GWL:
    case SD_SS_MODE_PREF_GWL_LTE:
    case SD_SS_MODE_PREF_CDMA_HDR_GW:
    case SD_SS_MODE_PREF_CDMA_HDR_GW_TDS:
    case SD_SS_MODE_PREF_CDMA_GW:
    case SD_SS_MODE_PREF_CDMA_GW_TDS:
    case SD_SS_MODE_PREF_HDR_LTE:
    case SD_SS_MODE_PREF_CDMA_HDR_LTE:
    case SD_SS_MODE_PREF_CDMA_LTE:
    case SD_SS_MODE_PREF_ANY_BUT_LTE:
    case SD_SS_MODE_PREF_GSM_LTE:
    case SD_SS_MODE_PREF_CDMA_GSM_LTE:
    case SD_SS_MODE_PREF_HDR_GSM_LTE:
    case SD_SS_MODE_PREF_WCDMA_LTE:
    case SD_SS_MODE_PREF_CDMA_WCDMA_LTE:
    case SD_SS_MODE_PREF_HDR_WCDMA_LTE:
    case SD_SS_MODE_PREF_CDMA_HDR_GSM:
    case SD_SS_MODE_PREF_CDMA_GSM:
    case SD_SS_MODE_PREF_CDMA_HDR_GSM_WCDMA_LTE:
    case SD_SS_MODE_PREF_CDMA_GSM_WCDMA_LTE:
    default:
      return CAI_CDMA_OR_ANALOG;

  } /* switch */
  /*lint +e788 */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If this target does not have AMPS support, do the following:
  */
  #elif (defined(SD_USES_CAI) && !defined(FEATURE_MMODE_REMOVE_1X))

  return CAI_CDMA_ONLY;

  #else

  return 0;

  #endif

} /* sdss_get_cdma_request_mode */


/*===========================================================================

FUNCTION sdss_get_loc_base_bsr_flag

DESCRIPTION

  Get  value set to SDSS_FLAG_LOC_BASE_BSR in SD_SS_HYBR_2

DEPENDENCIES
  NV task has started

RETURN VALUE
  boolean

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean    sdss_get_loc_base_bsr_flag( void )
{
  sd_ss_e_type  lte_ss   = sd_misc_get_ss_for_mode(SYS_SYS_MODE_LTE);
  sdss_s_type  *ss_ptr = NULL;

  if(lte_ss >= SD_SS_MAX)
  {
    return FALSE;
  }
  ss_ptr = sdss_ptr(lte_ss);

  return (ss_ptr->is_loc_based_bsr);
}


/*===========================================================================

FUNCTION sdss_is_rat_pri_lst_chgd

DESCRIPTION
  Checks whether mode/band pref being sent to NAS differs from
  current mode/band pref

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if preference changed.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean                   sdss_is_rat_pri_lst_chgd(

        sd_ss_e_type              ss
            /* System selection - MAIN or HDR.
            */
)
{

  sys_rat_pri_list_info_s_type  ss_rat_pri_list_info;
  sys_rat_pri_list_info_s_type  ss_prev_rat_pri_list_info;


  sdss_get_rat_pri_list_info(ss, &ss_rat_pri_list_info);
  sdss_get_prev_rat_pri_list_info(ss, &ss_prev_rat_pri_list_info);

  /* Compare if the 2 rat pri list info are same
  */
  if( memcmp(&ss_rat_pri_list_info,
             &ss_prev_rat_pri_list_info,
             sizeof(sys_rat_pri_list_info_s_type) ))
  {
    /* The list is changed */
    SD_MSG_HIGH_0("RAT PRI LIST INFO changed");
    return TRUE;
  }

  return FALSE;
}

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_get_supp_amps_band_pref

DESCRIPTION
  Return a band preference mask that corresponds to all the supported AMPS
  bands out of the input band preference.

DEPENDENCIES
  None.

RETURN VALUE
  Band preference mask that corresponds to all the supported AMPS bands out
  of the input band preference.

SIDE EFFECTS
  None.

===========================================================================*/
#ifdef FEATURE_NON_DEMAND_PAGED_FUNCTION
#error code not present
#endif
static  sd_ss_band_pref_e_type    sdss_get_supp_amps_band_pref(

        sd_ss_band_pref_e_type    band_pref
            /* Band preference out of which to extract supported AMPS bands.
            */
)
{
  #if( defined(FEATURE_ACP) )
  sd_ss_mode_pref_e_type mode_capability = SD_SS_MODE_PREF_NONE;
  #endif
  sd_ss_band_pref_e_type band_capability = SD_SS_BAND_PREF_NONE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

   #if( defined(FEATURE_ACP) )
   {
     sdss_get_mode_band_capability_mmode(&mode_capability,
                                         &band_capability,
                                         NULL,
                                         NULL);
   }
   if ( !SD_MODE_CONTAIN( mode_capability, SD_SS_MODE_PREF_AMPS) )
   {
     return SD_SS_BAND_PREF_NONE;
   }
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


   return (band_pref &
            band_capability &
            SD_SS_BAND_PREF_BC0);


} /* sdss_get_supp_amps_band_pref */
#ifdef FEATURE_NON_DEMAND_PAGED_FUNCTION
#error code not present
#endif




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_get_supp_cdma_band_pref

DESCRIPTION
  Return a band preference mask that corresponds to all the supported CDMA
  bands out of the input band preference.

DEPENDENCIES
  None.

RETURN VALUE
  Band preference mask that corresponds to all the supported CDMA bands out
  of the input band preference.

SIDE EFFECTS
  None.

===========================================================================*/
#ifdef FEATURE_NON_DEMAND_PAGED_FUNCTION
#error code not present
#endif
static  sd_ss_band_pref_e_type    sdss_get_supp_cdma_band_pref(

        sd_ss_band_pref_e_type    band_pref
            /* Band preference out of which to extract supported CDMA bands.
            */
)
{
  sd_ss_mode_pref_e_type mode_capability = SD_SS_MODE_PREF_NONE;
  sd_ss_band_pref_e_type band_capability = SD_SS_BAND_PREF_NONE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* If mode capability doesn't contains 1X, return invalid support bands
  */
  sdss_get_mode_band_capability_mmode(&mode_capability,
                                      &band_capability,
                                      NULL,
                                      NULL);

  if ( !SD_MODE_CONTAIN( mode_capability, SD_SS_MODE_PREF_CDMA) )
  {
    return SD_SS_BAND_PREF_NONE;
  }
  else
  {

    /*lint -e655 */ /* bit-wise operation uses enum */
    return ( band_pref &
             band_capability
         &
         #if (defined(FEATURE_MMODE_CDMA ) || defined(FEATURE_HDR) || defined(FEATURE_JCDMA))
             ( SD_SS_BAND_PREF_BC0 |
               SD_SS_BAND_PREF_BC1  |
               SD_SS_BAND_PREF_BC3  |
               SD_SS_BAND_PREF_BC4  |
               SD_SS_BAND_PREF_BC5  |
               SD_SS_BAND_PREF_BC6  |
               SD_SS_BAND_PREF_BC7  |
               SD_SS_BAND_PREF_BC8  |
               SD_SS_BAND_PREF_BC9  |
               SD_SS_BAND_PREF_BC10 |
               SD_SS_BAND_PREF_BC11 |
               SD_SS_BAND_PREF_BC12 |
               SD_SS_BAND_PREF_BC14 |
               SD_SS_BAND_PREF_BC15 |
               SD_SS_BAND_PREF_BC16 |
               SD_SS_BAND_PREF_BC17 |
               SD_SS_BAND_PREF_BC18 |
               SD_SS_BAND_PREF_BC19 )
               #else
               SD_SS_BAND_PREF_NONE
               #endif
             ); /*lint +e655 */
  }
} /* sdss_get_supp_cdma_band_pref */
#ifdef FEATURE_NON_DEMAND_PAGED_FUNCTION
#error code not present
#endif




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_get_supp_hdr_band_pref

DESCRIPTION
  Return a band preference mask that corresponds to all the supported HDR
  bands out of the input band preference.

DEPENDENCIES
  None.

RETURN VALUE
  Band preference mask that corresponds to all the supported HDR bands out
  of the input band preference.

SIDE EFFECTS
  None.

===========================================================================*/
#ifdef FEATURE_NON_DEMAND_PAGED_FUNCTION
#error code not present
#endif
static  sd_ss_band_pref_e_type    sdss_get_supp_hdr_band_pref(

        sd_ss_band_pref_e_type    band_pref
            /* Band preference out of which to extract supported HDR bands.
            *//*lint -esym(715, band_pref) */ /* not referenced */

)
{
  #ifdef FEATURE_HDR
  sd_ss_mode_pref_e_type mode_capability = SD_SS_MODE_PREF_NONE;
  sd_ss_band_pref_e_type band_capability = SD_SS_BAND_PREF_NONE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* If mode capability doesn't contains HDR, return invalid support bands
  */
  sdss_get_mode_band_capability_mmode(&mode_capability,
                                      &band_capability,
                                      NULL,
                                      NULL);

  if ( !SD_MODE_CONTAIN(mode_capability, SD_SS_MODE_PREF_HDR) )
  {
    return SD_SS_BAND_PREF_NONE;
  }
  else
  {
    /*lint -e655 */ /* bit-wise operation uses enum */
    return ( band_pref &
             band_capability
         &
         #if (defined(FEATURE_MMODE_CDMA ) || defined(FEATURE_HDR) || defined(FEATURE_JCDMA))
             ( SD_SS_BAND_PREF_BC0 |
               SD_SS_BAND_PREF_BC1  |
               SD_SS_BAND_PREF_BC3  |
               SD_SS_BAND_PREF_BC4  |
               SD_SS_BAND_PREF_BC5  |
               SD_SS_BAND_PREF_BC6  |
               SD_SS_BAND_PREF_BC7  |
               SD_SS_BAND_PREF_BC8  |
               SD_SS_BAND_PREF_BC9  |
               SD_SS_BAND_PREF_BC10 |
               SD_SS_BAND_PREF_BC11 |
               SD_SS_BAND_PREF_BC12 |
               SD_SS_BAND_PREF_BC14 |
               SD_SS_BAND_PREF_BC15 |
               SD_SS_BAND_PREF_BC16 |
               SD_SS_BAND_PREF_BC17 |
               SD_SS_BAND_PREF_BC18 |
               SD_SS_BAND_PREF_BC19 )
               #else
               SD_SS_BAND_PREF_NONE
               #endif
             ); /*lint +e655 */
  }
  #else
  return SD_SS_BAND_PREF_NONE;
  #endif
} /* sdss_get_supp_hdr_band_pref *//*lint +esym(715, band_pref) */
#ifdef FEATURE_NON_DEMAND_PAGED_FUNCTION
#error code not present
#endif




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_get_supp_gsm_band_pref

DESCRIPTION
  Return a band preference mask that corresponds to all the supported GSM
  bands out of the input band preference.

DEPENDENCIES
  None.

RETURN VALUE
  Band preference mask that corresponds to all the supported GSM bands out
  of the input band preference.

SIDE EFFECTS
  None.

===========================================================================*/
#ifdef FEATURE_NON_DEMAND_PAGED_FUNCTION
#error code not present
#endif
EXTERN  sd_ss_band_pref_e_type    sdss_get_supp_gsm_band_pref(

        sd_ss_band_pref_e_type    band_pref
            /* Band preference out of which to extract supported AMPS bands.
            */
)
{
  sd_ss_mode_pref_e_type mode_capability = SD_SS_MODE_PREF_NONE;
  sd_ss_band_pref_e_type band_capability = SD_SS_BAND_PREF_NONE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  sdss_get_mode_band_capability_mmode(&mode_capability,
                                      &band_capability,
                                      NULL,
                                      NULL);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* If mode capability doesn't contains GSM, return invalid support bands
  */
  if ( !SD_MODE_CONTAIN(mode_capability, SD_SS_MODE_PREF_GSM) )
  {
    return SD_SS_BAND_PREF_NONE;
  }
  else
  {
    /*lint -e655 */ /* bit-wise operation uses enum */
    return ( band_pref &
             band_capability &
             ( SD_SS_BAND_PREF_GSM_450 |
               SD_SS_BAND_PREF_GSM_480 |
               SD_SS_BAND_PREF_GSM_750 |
               SD_SS_BAND_PREF_GSM_850 |
               SD_SS_BAND_PREF_GSM_EGSM_900 |
               SD_SS_BAND_PREF_GSM_PGSM_900 |
               SD_SS_BAND_PREF_GSM_RGSM_900 |
               SD_SS_BAND_PREF_GSM_DCS_1800 |
               SD_SS_BAND_PREF_GSM_PCS_1900)); /*lint +e655 */
  }

} /* sdss_get_supp_gsm_band_pref */
#ifdef FEATURE_NON_DEMAND_PAGED_FUNCTION
#error code not present
#endif




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_get_supp_wcdma_band_pref

DESCRIPTION
  Return a band preference mask that corresponds to all the supported WCDMA
  bands out of the input band preference.

DEPENDENCIES
  None.

RETURN VALUE
  Band preference mask that corresponds to all the supported WCDMA bands out
  of the input band preference.

SIDE EFFECTS
  None.

===========================================================================*/
#ifdef FEATURE_NON_DEMAND_PAGED_FUNCTION
#error code not present
#endif
EXTERN  sd_ss_band_pref_e_type    sdss_get_supp_wcdma_band_pref(

        sd_ss_band_pref_e_type    band_pref
            /* Band preference out of which to extract supported AMPS bands.
            */
)
{
  sd_ss_mode_pref_e_type mode_capability = SD_SS_MODE_PREF_NONE;
  sd_ss_band_pref_e_type band_capability = SD_SS_BAND_PREF_NONE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  sdss_get_mode_band_capability_mmode(&mode_capability,
                                      &band_capability,
                                      NULL,
                                      NULL);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* If mode capability doesn't contains WCDMA, return invalid support bands
  */
  if ( !SD_MODE_CONTAIN(mode_capability, SD_SS_MODE_PREF_WCDMA) )
  {
    return SD_SS_BAND_PREF_NONE;
  }
  else
  {
    return ( band_pref &
             band_capability &
             ( SD_SS_BAND_PREF_WCDMA_I_IMT_2000  |
               SD_SS_BAND_PREF_WCDMA_II_PCS_1900 |
               SD_SS_BAND_PREF_WCDMA_III_1700    |
               SD_SS_BAND_PREF_WCDMA_IV_1700     |
               SD_SS_BAND_PREF_WCDMA_V_850       |
               SD_SS_BAND_PREF_WCDMA_VI_800      |
               SD_SS_BAND_PREF_WCDMA_VII_2600    |
               SD_SS_BAND_PREF_WCDMA_IX_1700     |
               SD_SS_BAND_PREF_WCDMA_XI_1500     |
               SD_SS_BAND_PREF_WCDMA_XIX_850     |
               SD_SS_BAND_PREF_WCDMA_VIII_900 ));
  }
} /* sdss_get_supp_wcdma_band_pref */
#ifdef FEATURE_NON_DEMAND_PAGED_FUNCTION
#error code not present
#endif
/*lint -restore */

/*===========================================================================

FUNCTION sdss_get_supp_lte_band_pref

DESCRIPTION
  Return a band preference mask that corresponds to all the supported LTE
  bands out of the input band preference.

DEPENDENCIES
  None.

RETURN VALUE
  Band preference mask that corresponds to all the supported LTE bands out
  of the input band preference.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sys_lte_band_mask_e_type    sdss_get_supp_lte_band_pref(

        sys_lte_band_mask_e_type    band_pref
            /* Band preference out of which to extract supported LTE bands.
            */
)
{
  sd_ss_mode_pref_e_type mode_capability = SD_SS_MODE_PREF_NONE;
  sys_lte_band_mask_e_type lte_band_capability = SYS_LTE_BAND_MASK_CONST_NONE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  sdss_get_mode_band_capability_mmode(&mode_capability,
                                      NULL,
                                      &lte_band_capability,
                                      NULL);


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If mode capability doesn't contains WCDMA, return invalid support bands
  */
  if ( !SD_MODE_CONTAIN(mode_capability, SD_SS_MODE_PREF_LTE) )
  {
    return SYS_LTE_BAND_MASK_CONST_NONE;
  }
  else
  {
    return ( SYS_LTE_BAND_MASK_COMMON(&band_pref, &lte_band_capability));
  }
} /* sdss_get_supp_lte_band_pref */

/*===========================================================================

FUNCTION sdss_get_supp_tds_band_pref

DESCRIPTION
  Return a band preference mask that corresponds to all the supported TD-SCDMA
  bands out of the input band preference.

DEPENDENCIES
  None.

RETURN VALUE
  Band preference mask that corresponds to all the supported TD-SCDMA bands out
  of the input band preference.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sd_ss_band_pref_e_type    sdss_get_supp_tds_band_pref(

        sd_ss_band_pref_e_type    band_pref
            /* Band preference out of which to extract supported TD-SCDMA bands.
            */
)
{
  sd_ss_mode_pref_e_type mode_capability = SD_SS_MODE_PREF_NONE;
  sd_ss_band_pref_e_type tds_band_capability = SD_SS_BAND_PREF_NONE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  sdss_get_mode_band_capability_mmode(&mode_capability,
                                      NULL,
                                      NULL,
                                      &tds_band_capability);


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If mode capability doesn't contains TDS, return invalid support bands
  */
  if ( !SD_MODE_CONTAIN(mode_capability, SD_SS_MODE_PREF_TDS) )
  {
    return SD_SS_BAND_PREF_NONE;
  }
  else
  {
    return ( band_pref &
             tds_band_capability &
             ( SD_SS_BAND_PREF_TDS_ANY ));
  }
} /* sdss_get_supp_tds_band_pref */

/*===========================================================================

FUNCTION sdss_is_target_cap_3gpp_only

DESCRIPTION
  Check the mode preference and band capability on all the stacks if it is
  3GPP only capable - GSM, WCDMA,TDS or LTE

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if target capability is only 3GPP.
  FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN boolean                    sdss_is_target_cap_3gpp_only (
       sd_ss_e_type               ss
       /* System selection stack */
)
{
   sd_ss_mode_pref_e_type   ss_mode_pref      = SD_SS_MODE_PREF_NONE;
   sd_ss_band_pref_e_type   ss_band_pref      = SD_SS_BAND_PREF_NONE;
   sys_lte_band_mask_e_type   ss_lte_band_pref  = SYS_LTE_BAND_MASK_CONST_NONE;
   sd_ss_band_pref_e_type   ss_tds_band_pref  = SD_SS_BAND_PREF_NONE;
   sd_ss_mode_pref_e_type   mode_pref         = SD_SS_MODE_PREF_NONE;

   /* Get the intersection of the current mode preference, band preference
   ** and the band capability
   ** mode_pref_temp = main_stack_mode_pref + hybr_stack_mode_pref
   ** mode_pref = user settings ^ phone capability
   */

   sd_ss_mode_pref_e_type  mode_pref_temp    = SD_SS_MODE_PREF_NONE;
   sd_ss_mode_pref_e_type  mode_pref_ss      = SD_SS_MODE_PREF_NONE;


   sdss_get_mode_band_pref( ss,
                            &ss_mode_pref,
                            &ss_band_pref,
                            &ss_lte_band_pref,
                            &ss_tds_band_pref );

   if(  !sdss_is_hybr_pref( ss, SD_SS_HYBR_PREF_NONE ))
   {
     sdss_get_mode_band_pref( SD_SS_MAIN,
                              &mode_pref_ss,
                              NULL,
                              NULL,
                              NULL );

     mode_pref_temp = SD_MODE_ADD( mode_pref_temp, mode_pref_ss );

     sdss_get_mode_band_pref( SD_SS_HYBR_1,
                              &mode_pref_ss,
                              NULL,
                              NULL,
                              NULL );

     mode_pref_temp = SD_MODE_ADD( mode_pref_temp, mode_pref_ss );

     if(sdss_is_1x_sxlte())
     {
       sdss_get_mode_band_pref( SD_SS_HYBR_2,
                              &mode_pref_ss,
                              NULL,
                              NULL,
                              NULL );

       mode_pref_temp = SD_MODE_ADD( mode_pref_temp, mode_pref_ss );
     }

   }
   else
   {
     mode_pref_temp = ss_mode_pref;
   }
   mode_pref =  sdss_get_supp_mode_pref_mmode( mode_pref_temp,
                                               ss_band_pref,
                                               ss_lte_band_pref,
                                               ss_tds_band_pref);

   /* Check if the mode_pref has any modes other than TGWL
   ** If mode_pref has any non TGWL modes then fail the check or else return
   ** TRUE.
   */
   if ( mode_pref != SD_SS_MODE_PREF_NONE &&
        !(SD_MODE_CONTAIN(mode_pref,~(word)SD_SS_MODE_PREF_TDS_GSM_WCDMA_LTE))
      )
   {
     return TRUE;
   }

   return FALSE;
}

/*===========================================================================

FUNCTION sdss_is_cap_3gpp_only

DESCRIPTION
  Check whether the current system preference and band capablity only supports 3GPP.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if system preference capability is only 3GPP.
  FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN boolean                    sdss_is_cap_3gpp_only (
       sd_ss_e_type               ss
       /* System selection stack */
)
{
   sd_ss_mode_pref_e_type  mode_pref;
   sd_ss_mode_pref_e_type  ss_mode_pref      = SD_SS_MODE_PREF_NONE;
   sd_ss_band_pref_e_type  ss_band_pref      = SD_SS_BAND_PREF_NONE;
   sys_lte_band_mask_e_type  ss_lte_band_pref  = SYS_LTE_BAND_MASK_CONST_NONE;
   sd_ss_band_pref_e_type  ss_tds_band_pref  = SD_SS_BAND_PREF_NONE;

   /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

   SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

   /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

   /* Get current system preference
    */
   sdss_get_mode_band_pref( ss,
                            &ss_mode_pref,
                            &ss_band_pref,
                            &ss_lte_band_pref,
                            &ss_tds_band_pref );

   /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

   /* Get the intersection of the current mode preference, band preference
    ** and the band capability
    ** mode_pref = user settings & phone capability
    */
   mode_pref =  sdss_get_supp_mode_pref_mmode(ss_mode_pref,
                                              ss_band_pref,
                                              ss_lte_band_pref,
                                              ss_tds_band_pref);

   /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

   /* Check if the mode_pref has any modes other than TGWL
    */
   if ( mode_pref != SD_SS_MODE_PREF_NONE &&
        !(SD_MODE_CONTAIN(mode_pref,~(word)SD_SS_MODE_PREF_TDS_GSM_WCDMA_LTE))
      )
   {
     SD_MSG_LOW_0("3gpp_only_cap");
     return TRUE;
   }

   return FALSE;
}

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_get_mode_band_capability_mmode

DESCRIPTION
  Fill in the modes and bands supported by the target. Based off
  sdss_get_mode_band_capability(), extended to support LTE.
  Note that neither this function nor its parent is used.
DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                   sdss_get_mode_band_capability_mmode(

        sd_ss_mode_pref_e_type    *mode_pref_ptr,
            /* Mode preferences to be filled in.
            */

        sd_ss_band_pref_e_type    *band_pref_ptr,
            /* Band preferences to be filled in.
            */
        sys_lte_band_mask_e_type  *band_pref_ptr_lte,
            /* LTE band preferences to be filled in.
            */

        sd_ss_band_pref_e_type    *band_pref_ptr_tds
            /* TD-SCDMA band preferences to be filled in.
            */
)
{
  if(mode_pref_ptr != NULL)
  {
    *mode_pref_ptr     = sdss_common.mode_capability;
  }
  if(band_pref_ptr != NULL)
  {
    *band_pref_ptr     = sdss_common.band_capability;
  }
  if(band_pref_ptr_lte != NULL)
  {
    *band_pref_ptr_lte = sdss_common.lte_band_capability;
  }
  if(band_pref_ptr_tds != NULL)
  {
    *band_pref_ptr_tds = sdss_common.tds_band_capability;
  }

} /* sd_misc_get_mode_band_capability_mmode */
/* <EJECT> */
/*===========================================================================

FUNCTION sdss_get_supp_mode_pref

DESCRIPTION
  Return a mode preference that corresponds to all the supported modes
  preferences out of the input mode preference.

DEPENDENCIES
  None.

RETURN VALUE
  Return a mode preference that corresponds to all the supported modes
  preferences out of the input mode preference.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sd_ss_mode_pref_e_type    sdss_get_supp_mode_pref(

        sd_ss_mode_pref_e_type    mode_pref,
            /* Mode preference from which to extract supported modes.
            */

        sd_ss_band_pref_e_type    band_pref
            /* band preference from which to extract supported modes.
            */
)
{
  sd_ss_mode_pref_e_type    mode_supp       = SD_SS_MODE_PREF_NONE;
  sd_ss_mode_pref_e_type    mode_capability = SD_SS_MODE_PREF_NONE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Read the mode capaility as received from Policy Manager. */
  sdss_get_mode_band_capability_mmode(&mode_capability,
                                      NULL,
                                      NULL,
                                      NULL);

  /* Add AMPS mode preference if supported.
  */
  if( sdss_get_supp_amps_band_pref(band_pref) != SD_SS_BAND_PREF_NONE )
  {
    mode_supp = SD_MODE_ADD( mode_supp, SD_SS_MODE_PREF_AMPS );
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Add CDMA mode preference if supported.
  */
  if( sdss_get_supp_cdma_band_pref(band_pref) != SD_SS_BAND_PREF_NONE )
  {
    mode_supp = SD_MODE_ADD( mode_supp, SD_SS_MODE_PREF_CDMA );
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Add HDR mode preference if supported.
  */
  if( sdss_get_supp_hdr_band_pref(band_pref) != SD_SS_BAND_PREF_NONE )
  {
    mode_supp = SD_MODE_ADD( mode_supp, SD_SS_MODE_PREF_HDR);
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #ifdef FEATURE_GPSONE_MSBASED

  /* Add GPS mode if GPS feature is defined.
  */
  mode_supp = SD_MODE_ADD( mode_supp, SD_SS_MODE_PREF_GPS);

  #endif /* FEATURE_GPSONE_MSBASED */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Add GSM mode preference if supported.
  */
  if( sdss_get_supp_gsm_band_pref(band_pref) != SD_SS_BAND_PREF_NONE )
  {
    mode_supp = SD_MODE_ADD( mode_supp, SD_SS_MODE_PREF_GSM );
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Add WCDMA mode preference if supported.
  */
  if( sdss_get_supp_wcdma_band_pref(band_pref) != SD_SS_BAND_PREF_NONE )
  {
    mode_supp = SD_MODE_ADD( mode_supp, SD_SS_MODE_PREF_WCDMA );
  }

  /*check if we have WCDMA and GSW and then add GW*/
  if(SD_MODE_CONTAIN(mode_supp,SD_SS_MODE_PREF_GSM) && SD_MODE_CONTAIN(mode_supp,SD_SS_MODE_PREF_WCDMA))
  {
    mode_supp = SD_MODE_ADD(mode_supp, SD_SS_MODE_PREF_GW);
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* EFUSE now already in mode capability from policy manager */
  mode_supp = SD_GET_COMMON_MODE( mode_capability, mode_supp);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Return all supported modes out of input mode preference.
  */
  return ( SD_GET_COMMON_MODE( mode_pref, mode_supp) );

} /* sdss_get_supp_mode_pref */


/*===========================================================================

FUNCTION sdss_get_supp_mode_pref_mmode

DESCRIPTION
  Return a mode preference that corresponds to all the supported modes
  preferences out of the input mode preference. Based off
  dss_get_supp_mode_pref() , extended to support LTE.
  This function will replace sdss_get_supp_mode_pref().

DEPENDENCIES
  None.

RETURN VALUE
  Return a mode preference that corresponds to all the supported modes
  preferences out of the input mode preference.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sd_ss_mode_pref_e_type    sdss_get_supp_mode_pref_mmode(

        sd_ss_mode_pref_e_type    mode_pref,
            /* Mode preference from which to extract supported modes.
            */

        sd_ss_band_pref_e_type    band_pref,
            /* band preference from which to extract supported modes.
            */

        sys_lte_band_mask_e_type  band_pref_lte,
            /* LTE band preference from which to extract supported modes.
            */

        sd_ss_band_pref_e_type    band_pref_tds
            /* TD-SCDMA band preference from which to extract supported modes.
            */

)
{
  sd_ss_mode_pref_e_type    mode_supp       = SD_SS_MODE_PREF_NONE;
  sd_ss_mode_pref_e_type    mode_capability = SD_SS_MODE_PREF_NONE;
  #ifdef FEATURE_LTE
  sys_lte_band_mask_e_type  supp_lte_band_pref;
  #endif
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Read the mode capaility as received from Policy Manager. */
  sdss_get_mode_band_capability_mmode(&mode_capability,
                                      NULL,
                                      NULL,
                                      NULL);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  #ifdef FEATURE_LTE
  /* Add LTE mode preference if supported.
  */
  supp_lte_band_pref = sdss_get_supp_mode_band_pref_lte( mode_pref, band_pref_lte );
  if( !SYS_LTE_BAND_MASK_CHK_IF_EMPTY(&supp_lte_band_pref) )
  {
    mode_supp = SD_MODE_ADD( mode_supp, SD_SS_MODE_PREF_LTE);
  }
  #endif
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #ifdef FEATURE_TDSCDMA
  /* Add TD-SCMDA mode preference if supported.
  */
  if( sdss_get_supp_mode_band_pref_tds( mode_pref, band_pref_tds ) )
  {
    mode_supp = SD_MODE_ADD( mode_supp, SD_SS_MODE_PREF_TDS);
  }
  #endif
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Add AMPS mode preference if supported.
  */
  if( sdss_get_supp_amps_band_pref(band_pref) != SD_SS_BAND_PREF_NONE )
  {
    mode_supp = SD_MODE_ADD( mode_supp, SD_SS_MODE_PREF_AMPS );
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  #if defined FEATURE_CDMA_800 || defined FEATURE_CDMA_1900
  /* Add CDMA mode preference if supported.
  */
  if( sdss_get_supp_cdma_band_pref(band_pref) != SD_SS_BAND_PREF_NONE )
  {
    mode_supp = SD_MODE_ADD( mode_supp, SD_SS_MODE_PREF_CDMA );
  }
  #endif
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #ifdef FEATURE_HDR
  /* Add HDR mode preference if supported.
  */
  if( sdss_get_supp_hdr_band_pref(band_pref) != SD_SS_BAND_PREF_NONE )
  {
    mode_supp = SD_MODE_ADD( mode_supp, SD_SS_MODE_PREF_HDR);
  }
  #endif
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #ifdef FEATURE_GPSONE_MSBASED

  /* Add GPS mode if GPS feature is defined.
  */
  mode_supp = SD_MODE_ADD( mode_supp, SD_SS_MODE_PREF_GPS);

  #endif /* FEATURE_GPSONE_MSBASED */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #ifdef FEATURE_GSM
  /* Add GSM mode preference if supported.
  */
  if( sdss_get_supp_gsm_band_pref(band_pref) != SD_SS_BAND_PREF_NONE )
  {
    mode_supp = SD_MODE_ADD( mode_supp, SD_SS_MODE_PREF_GSM );
  }
  #endif
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #ifdef FEATURE_WCDMA
  /* Add WCDMA mode preference if supported.
  */
  if( sdss_get_supp_wcdma_band_pref(band_pref) != SD_SS_BAND_PREF_NONE )
  {
    mode_supp = SD_MODE_ADD( mode_supp, SD_SS_MODE_PREF_WCDMA );
  }
  #endif
  
  /*check if we have WCDMA and GSW and then add GW*/
  if(SD_MODE_CONTAIN(mode_supp,SD_SS_MODE_PREF_GSM) &&
     SD_MODE_CONTAIN(mode_supp,SD_SS_MODE_PREF_WCDMA))
  {
    mode_supp = SD_MODE_ADD(mode_supp, SD_SS_MODE_PREF_GW);
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  if(SD_MODE_CONTAIN(mode_supp,SD_SS_MODE_PREF_GSM) &&
     SD_MODE_CONTAIN(mode_supp,SD_SS_MODE_PREF_WCDMA) &&
     SD_MODE_CONTAIN(mode_supp,SD_SS_MODE_PREF_LTE))
  {
    mode_supp = SD_MODE_ADD(mode_supp, SD_SS_MODE_PREF_GWL);
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Reading EFUSE and disable mode if it's not supported */
  mode_supp = SD_GET_COMMON_MODE( mode_capability , mode_supp);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Return all supported modes out of input mode preference.
  */
  return ( SD_GET_COMMON_MODE( mode_pref, mode_supp) );

} /* sdss_get_supp_mode_pref */

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_get_supp_band_pref

DESCRIPTION
  Return a band preference that corresponds to all the supported band
  preferences out of the input band preference.

DEPENDENCIES
  None.

RETURN VALUE
  Return a band preference that corresponds to all the supported band
  preferences out of the input band preference.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sd_ss_band_pref_e_type    sdss_get_supp_band_pref(

        sd_ss_band_pref_e_type    band_pref
            /* Band preference which to check for support.
            */
)
{ /*lint -e655 */ /* bit-wise operation uses (compatible) enum's */
  return ( sdss_get_supp_amps_band_pref( band_pref )  |
           sdss_get_supp_cdma_band_pref( band_pref )  |
           sdss_get_supp_hdr_band_pref( band_pref )   |
           sdss_get_supp_gsm_band_pref( band_pref)    |
           sdss_get_supp_wcdma_band_pref( band_pref )
           ); /*lint +e655 */

} /* sdss_get_supp_band_pref */


/*===========================================================================

 FUNCTION sdss_get_curr_lte_band_pref

 DESCRIPTION
   Return LTE band preference that is supported by both UE and target configuration.

 DEPENDENCIES
   None.

 RETURN VALUE
   Return LTE band preference that is supported by both UE and target configuration.

  SIDE EFFECTS
   None.

===========================================================================*/
EXTERN  sys_lte_band_mask_e_type    sdss_get_curr_lte_band_pref(

        sd_ss_e_type              ss
          /* System selection stack
          */
)
{
  sys_lte_band_mask_e_type     ss_band_pref = SYS_LTE_BAND_MASK_CONST_NONE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  sdss_get_mode_band_pref( ss,
                     NULL,
                     NULL,
                     &ss_band_pref,
                     NULL );
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return( sdss_get_supp_lte_band_pref( ss_band_pref ));

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
} /* sdss_get_supp_band_pref_lte */

/*===========================================================================

FUNCTION sdss_get_supp_band_pref_tds

DESCRIPTION
  Return a band preference for TD-SCDMA that corresponds to the supported
  TD-SCDMA band preference out of the input band preference.

DEPENDENCIES
  None.

RETURN VALUE
  Return a band preference that corresponds to all the supported band
  preferences out of the input band preference.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sd_ss_band_pref_e_type    sdss_get_supp_band_pref_tds(

        sd_ss_band_pref_e_type    band_pref_tds
            /* Band preference which to check for support.
            */
)
{
  return ( sdss_get_supp_tds_band_pref( band_pref_tds ));

} /* sdss_get_supp_band_pref_tds */


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_get_supp_mode_band_pref

DESCRIPTION
  Return a band preference that corresponds to all the supported band
  preferences out of the input band preference and the specific mode.
  Does not support LTE.

DEPENDENCIES
  None.

RETURN VALUE
  Return a band preference that corresponds to all the supported band
  preferences out of the input band preference and the specific mode.

SIDE EFFECTS
  None.

===========================================================================*/
#ifdef FEATURE_NON_DEMAND_PAGED_FUNCTION
#error code not present
#endif
EXTERN  sd_ss_band_pref_e_type    sdss_get_supp_mode_band_pref(

        sd_ss_mode_pref_e_type    mode_pref,
            /* Mode preference which to check for support.
            */

        sd_ss_band_pref_e_type    band_pref
            /* Band preference which to check for support.
            */
)
{

  sd_ss_band_pref_e_type band_supp = SD_SS_BAND_PREF_NONE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If specified mode preference includes AMPS, keep AMP related band
  ** preference out of the input band preference.
  */
  if( SD_MODE_CONTAIN( mode_pref, SD_SS_MODE_PREF_AMPS ) )
  {
    band_supp = sdss_get_supp_amps_band_pref(band_pref);
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If specified mode preference includes CDMA, keep CDMA related band
  ** preference out of the input band preference.
  */
  if( SD_MODE_CONTAIN( mode_pref, SD_SS_MODE_PREF_CDMA ) )
  {
    band_supp = SD_BAND_ADD( band_supp,
                             sdss_get_supp_cdma_band_pref(band_pref) );
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If specified mode preference includes HDR, keep HDR related band
  ** preference out of the input band preference.
  */
  if( SD_MODE_CONTAIN( mode_pref, SD_SS_MODE_PREF_HDR ) )
  {
    band_supp = SD_BAND_ADD( band_supp,
                             sdss_get_supp_hdr_band_pref(band_pref) );
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #ifdef SD_GSM_SUPPORTED
  /* If specified mode preference includes GSM, keep GSM related band
  ** preference out of the input band preference.
  */
  if( SD_MODE_CONTAIN( mode_pref, SD_SS_MODE_PREF_GSM ) )
  {
    band_supp = SD_BAND_ADD( band_supp,
                             sdss_get_supp_gsm_band_pref(band_pref) );
  }
  #endif /* SD_GSM_SUPPORTED */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #ifdef SD_WCDMA_SUPPORTED
  /* If specified mode preference includes WCDMA, keep WCDMA related band
  ** preference out of the input band preference.
  */
  if( SD_MODE_CONTAIN( mode_pref, SD_SS_MODE_PREF_WCDMA ) )
  {
    band_supp = SD_BAND_ADD( band_supp,
                             sdss_get_supp_wcdma_band_pref(band_pref));
  }
  #endif /* SD_WCDMA_SUPPORTED */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #ifdef FEATURE_GPSONE_MSBASED
  /* If specified mode preference is GPS only, set with the input band
  ** preference. Otherwise use the accumulated band preference.
  */
  if( SD_MODE_CONTAIN( mode_pref, SD_SS_MODE_PREF_GPS ) )
  {
    if ( band_supp == SD_SS_BAND_PREF_NONE )
    {
      band_supp = band_pref;
    }
  }
  #endif /* FEATURE_GPSONE_MSBASED */


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return band_supp;

} /* sdss_get_supp_mode_band_pref */
#ifdef FEATURE_NON_DEMAND_PAGED_FUNCTION
#error code not present
#endif

/*===========================================================================

FUNCTION sdss_get_supp_mode_band_pref_lte

DESCRIPTION
  Return a band preference that corresponds to all the supported band
  preferences out of the input band preference and the specific mode.

DEPENDENCIES
  None.

RETURN VALUE
  Return a band preference that corresponds to all the supported band
  preferences out of the input band preference and the specific mode.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sys_lte_band_mask_e_type  sdss_get_supp_mode_band_pref_lte(

        sd_ss_mode_pref_e_type    mode_pref,
            /* Mode preference which to check for support.
            */

        sys_lte_band_mask_e_type  band_pref
            /* LTE band preference which to check for support.
            */
)
{

  sys_lte_band_mask_e_type band_supp = SYS_LTE_BAND_MASK_CONST_NONE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if ( SD_MODE_CONTAIN( mode_pref, SD_SS_MODE_PREF_LTE))
  {
      band_supp = sdss_get_supp_lte_band_pref(band_pref);
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return band_supp;

} /* sdss_get_supp_mode_band_pref_lte */


/*===========================================================================

FUNCTION sdss_get_pwr_save_reason

DESCRIPTION
  This function returns reason why SD is sending PWR_SAVE to a protocol.
  It decides based on SD system selection state.

DEPENDENCIES
  None.

RETURN VALUE
  Valid: Power save reason
  Invalid: SD_SS_PWR_SAVE_REAS_MAX

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sd_ss_pwr_save_reas_e_type sdss_get_pwr_save_reason(

        sd_ss_e_type ss
          /* System selection stack
          */
)
{
  sd_ss_pwr_save_reas_e_type reason            = SD_SS_PWR_SAVE_REAS_MAX;
  sd_ss_mode_pref_e_type     ss_mode_pref      = SD_SS_MODE_PREF_NONE;
  sd_ss_band_pref_e_type     ss_band_pref      = SD_SS_BAND_PREF_NONE;
  sys_lte_band_mask_e_type   ss_lte_band_pref  = SYS_LTE_BAND_MASK_CONST_NONE;
  sd_ss_band_pref_e_type     ss_tds_band_pref  = SD_SS_BAND_PREF_NONE;

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  sdss_get_mode_band_pref( ss,
                     &ss_mode_pref,
                     &ss_band_pref,
                     &ss_lte_band_pref,
                     &ss_tds_band_pref );

  if(sdss_is_resel_state(ss, SDSS_RESEL_STT_HYBR_BSR))
  {
    /* If SD is doing LTE to HDR reselection, then send this to protocol */
    reason = SD_SS_PWR_SAVE_REAS_HYBR_BSR;
  }
  else if(!sdss_is_supp_mode_band_pref(ss_mode_pref, ss_band_pref) &&
          !sdss_is_supp_mode_band_pref_lte(ss_mode_pref,ss_lte_band_pref) &&
          !sdss_is_supp_mode_band_pref_tds(ss_mode_pref,ss_tds_band_pref))
  {
    /* No modes available to acquire.
    */
    reason = SD_SS_PWR_SAVE_REAS_NO_SYS;
  }
  else
  {
    /*  Populate the pwr save parameters, default is due to no_srv.
    **  check if there are modes available to acquire.
    */
    reason = SD_SS_PWR_SAVE_REAS_NO_SRV;
  }

  return reason;
}

/*===========================================================================

FUNCTION sdss_get_supp_band_pref_tds

DESCRIPTION
  Return TD-SCDMA band preference that corresponds to all the supported band
  preferences out of the input band preference and the specific mode.

DEPENDENCIES
  None.

RETURN VALUE
  Return a band preference that corresponds to all the supported band
  preferences out of the input band preference and the specific mode.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN sd_ss_band_pref_e_type    sdss_get_supp_mode_band_pref_tds(

        sd_ss_mode_pref_e_type    mode_pref,
            /* Mode preference which to check for support.
            */

        sd_ss_band_pref_e_type    band_pref
            /* TD-SCDMA band preference which to check for support.
            */
)
{
  sd_ss_band_pref_e_type band_supp = SD_SS_BAND_PREF_NONE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if ( SD_MODE_CONTAIN( mode_pref, SD_SS_MODE_PREF_TDS))
  {
      band_supp = sdss_get_supp_band_pref_tds(band_pref);
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return band_supp;
}


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_is_supp_mode_band_pref

DESCRIPTION
  Check whether a specified combination of mode and band preference is
  supported by the current target.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the specified combination of mode and band preference is supported
  by the current target. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean                   sdss_is_supp_mode_band_pref(

        sd_ss_mode_pref_e_type    mode_pref,
            /* Mode preference which to check for support.
            */

        sd_ss_band_pref_e_type    band_pref
            /* Band preference which to check for support.
            */
)
{

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If specified mode preference includes AMPS and AMPS is supported over
  ** specified band preference, return TRUE.
  */
  if( SD_MODE_CONTAIN( mode_pref, SD_SS_MODE_PREF_AMPS ) )
  {
    if( sdss_get_supp_amps_band_pref(band_pref) != SD_SS_BAND_PREF_NONE )
    {
      return TRUE;
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If specified mode preference includes CDMA and CDMA is supported over
  ** specified band preference, return TRUE.
  */
  if( SD_MODE_CONTAIN( mode_pref, SD_SS_MODE_PREF_CDMA ) )
  {
    if( sdss_get_supp_cdma_band_pref(band_pref) != SD_SS_BAND_PREF_NONE )
    {
      return TRUE;
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If specified mode preference includes HDR and HDR is supported over
  ** specified band preference, return TRUE.
  */
  if( SD_MODE_CONTAIN( mode_pref, SD_SS_MODE_PREF_HDR ) )
  {
    if( sdss_get_supp_hdr_band_pref(band_pref) != SD_SS_BAND_PREF_NONE )
    {
      return TRUE;
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #ifdef FEATURE_GPSONE_MSBASED
  /* If specified mode preference includes GPS and GPS is supported, return
  ** TRUE.
  */
  if( SD_MODE_CONTAIN( mode_pref, SD_SS_MODE_PREF_GPS ) )
  {
    return TRUE;
  }
  #endif /* FEATURE_GPSONE_MSBASED */


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #ifdef SD_GSM_SUPPORTED
  /* If specified mode preference includes GSM and GSM is supported, return
  ** TRUE.
  */
  if( SD_MODE_CONTAIN( mode_pref, SD_SS_MODE_PREF_GSM ) )
  {
    if( sdss_get_supp_gsm_band_pref(band_pref) != SD_SS_BAND_PREF_NONE )
    {
      return TRUE;
    }
  }
  #endif /* SD_GSM_SUPPORTED */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #ifdef SD_WCDMA_SUPPORTED
  /* If specified mode preference includes WCDMA and WCDMA is supported,
  ** return TRUE.
  */
  if( SD_MODE_CONTAIN( mode_pref, SD_SS_MODE_PREF_WCDMA ) )
  {
    if( sdss_get_supp_wcdma_band_pref(band_pref) != SD_SS_BAND_PREF_NONE )
    {
      return TRUE;
    }
  }
  #endif /* SD_WCDMA_SUPPORTED */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* If we got here, the specified combination of mode and band preference is
  ** not supported by the current target - return FALSE.
  */
  return FALSE;

} /* sdss_is_supp_mode_band_pref */

/*===========================================================================

FUNCTION sdss_is_supp_mode_band_pref_lte

DESCRIPTION
  Check whether a specified combination of mode and LTE band preference is
  supported by the current target.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the specified combination of mode and band preference is supported
  by the current target. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean                   sdss_is_supp_mode_band_pref_lte(

        sd_ss_mode_pref_e_type    mode_pref,
            /* Mode preference which to check for support.
            */

        sys_lte_band_mask_e_type    band_pref_lte
            /* LTE band preference which to check for support.
            */
)
{

  /* If specified mode preference includes GWL and GWL is supported,
  ** return TRUE.
  */
  if( SD_MODE_CONTAIN( mode_pref, SD_SS_MODE_PREF_LTE ) )
  {
    sys_lte_band_mask_e_type supp_lte_band_pref = sdss_get_supp_lte_band_pref(band_pref_lte);
    if( !SYS_LTE_BAND_MASK_CHK_IF_EMPTY( &supp_lte_band_pref ))
    {
      return TRUE;
    }
  }

  /*-----------------------------------------------------------------------*/
  /* If we got here, the specified combination of mode and band preference is
  ** not supported by the current target - return FALSE.
  */
  return FALSE;

} /* sdss_is_supp_mode_band_pref_lte */


/*===========================================================================

FUNCTION sdss_is_supp_mode_band_pref_tds

DESCRIPTION
  Check whether a specified combination of mode and TD-SCDMA band preference
  is supported by the current target.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the specified combination of mode and band preference is supported
  by the current target. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean                   sdss_is_supp_mode_band_pref_tds(

        sd_ss_mode_pref_e_type    mode_pref,
            /* Mode preference which to check for support.
            */

        sd_ss_band_pref_e_type    band_pref_tds
            /* TD-SCDMA band preference which to check for support.
            */
)
{

  /* If specified mode preference includes TDS and TDS bands are
  ** supported, return TRUE.
  */
  return SD_MODE_CONTAIN( mode_pref, SD_SS_MODE_PREF_TDS ) &&
         (sdss_get_supp_tds_band_pref(band_pref_tds) != SD_SS_BAND_PREF_NONE );

} /* sdss_is_supp_mode_band_pref_tds */


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_is_supp_mode_band

DESCRIPTION
  Check whether a specified combination of mode and band is supported by the
  current target.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the specified combination of mode and band is supported by the
  current target. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean                   sdss_is_supp_mode_band(

        sd_mode_e_type            mode,
            /* Mode which to check for support.
            */

        sd_ss_band_pref_e_type    band_pref,
            /* Band preference which to check for support.
            */

        sys_lte_band_mask_e_type  band_pref_lte,
            /* LTE band preference which to check for support.
            */

        sd_ss_band_pref_e_type    band_pref_tds
            /* TD-SCDMA band preference which to check for support.
            */

)
{
  sd_ss_mode_pref_e_type          mode_pref = SD_SS_MODE_PREF_NONE;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Return a boolean indicating whether the mapped band and mode preference
  ** combination is supported.
  */
  mode_pref = sdss_map_mode_to_mode_pref(mode);

  /* If the mode pref is NONE, no need to perform band check
  */
  if(mode_pref == SD_SS_MODE_PREF_NONE)
  {
    return FALSE;
  }

  /* If the mode pref contains LTE, check if LTE bands are supported
  */
  if( sdss_is_supp_mode_band_pref_lte( mode_pref, band_pref_lte))
  {
     return TRUE;
  }

  /* Check whether bands are supported for TD-SCDMA modes.
  */
  if (sdss_is_supp_mode_band_pref_tds( mode_pref, band_pref_tds))
  {
     return TRUE;
  }

  /* Check whether bands are supported for remaining non LTE modes.
  */
  if (sdss_is_supp_mode_band_pref( mode_pref, band_pref))
  {
     return TRUE;
  }


  /* If we got here, this mode band combination is not supported
  */
  return FALSE;

} /* sdss_is_supp_mode_band */



/* <EJECT> */
/*===========================================================================

FUNCTION sdss_map_mode_to_mode_pref

DESCRIPTION
  Map mode to mode preference.

DEPENDENCIES
  None.

RETURN VALUE
  Band perference.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sd_ss_mode_pref_e_type    sdss_map_mode_to_mode_pref(

        sd_mode_e_type            mode
          /* Mode mapped to mode pref.
          */
)
{
  sd_ss_mode_pref_e_type    mode_pref;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Map the specified mode to its corresponding mode preferences.
  */
  switch( mode )
  {
    case SD_MODE_AMPS:
      mode_pref = SD_SS_MODE_PREF_AMPS;
      break;

    case SD_MODE_CDMA:
      mode_pref = SD_SS_MODE_PREF_CDMA;
      break;

    case SD_MODE_HDR:
      mode_pref = SD_SS_MODE_PREF_HDR;
      break;

    case SD_MODE_GPS:
      mode_pref = SD_SS_MODE_PREF_GPS;
      break;

    case SD_MODE_GSM:
      mode_pref = SD_SS_MODE_PREF_GSM;
      break;

    case SD_MODE_WCDMA:
      mode_pref = SD_SS_MODE_PREF_WCDMA;
      break;

    case SD_MODE_GW:

      #ifdef FEATURE_TDSCDMA
      mode_pref = SD_SS_MODE_PREF_TDS_GSM_WCDMA;
      #else
      mode_pref = SD_SS_MODE_PREF_GW;
      #endif
      break;

    case SD_MODE_LTE:
      mode_pref = SD_SS_MODE_PREF_LTE;
      break;

    case SD_MODE_TDS:
      mode_pref = SD_SS_MODE_PREF_TDS;
      break;

    case SD_MODE_GWL:

    #ifdef FEATURE_TDSCDMA
    mode_pref = SD_SS_MODE_PREF_TDS_GSM_WCDMA_LTE;
    #else
      mode_pref = SD_SS_MODE_PREF_GWL;
    #endif

      break;
    case SD_MODE_NONE:
    case SD_MODE_INACT:
    case SD_MODE_MAX:
    default:
      mode_pref = SD_SS_MODE_PREF_NONE;
      break;

  } /* switch */

  return mode_pref;
}


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_map_mode_pref_to_mode

DESCRIPTION
  Map mode preference to mode.

DEPENDENCIES
  None.

RETURN VALUE
  Band perference.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sd_mode_e_type    sdss_map_mode_pref_to_mode(

        sd_ss_mode_pref_e_type        mode_pref
          /* Mode pref mapped to mode.
          */
)
{

  SD_ASSERT (BETWEEN(mode_pref, SD_SS_MODE_PREF_NONE, SD_SS_MODE_PREF_MAX));

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if( SD_MODE_CONTAIN( mode_pref, SD_SS_MODE_PREF_AMPS ) )
  {
    return SD_MODE_AMPS;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if( SD_MODE_CONTAIN( mode_pref, SD_SS_MODE_PREF_CDMA ) )
  {
    return SD_MODE_CDMA;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if( SD_MODE_CONTAIN( mode_pref, SD_SS_MODE_PREF_HDR ) )
  {
    return SD_MODE_HDR;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if( SD_MODE_CONTAIN( mode_pref, SD_SS_MODE_PREF_GPS ) )
  {
    return SD_MODE_GPS;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if( SD_MODE_CONTAIN( mode_pref, SD_SS_MODE_PREF_GSM ) )
  {
    return SD_MODE_GSM;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if( SD_MODE_CONTAIN( mode_pref, SD_SS_MODE_PREF_WCDMA ) )
  {
    return SD_MODE_WCDMA;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if( SD_MODE_CONTAIN( mode_pref, SD_SS_MODE_PREF_GW ) )
  {
    return SD_MODE_GW;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if( SD_MODE_CONTAIN( mode_pref, SD_SS_MODE_PREF_GW ) &&
      SD_MODE_CONTAIN( mode_pref, SD_SS_MODE_PREF_LTE ))
  {
    return SD_MODE_GWL;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if( SD_MODE_CONTAIN( mode_pref, SD_SS_MODE_PREF_TDS ) )
  {
    return SD_MODE_TDS;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  SD_ERR_1 ("mode_pref %d mapping to mode failed", mode_pref);

  return SD_MODE_MAX;

} /* sdss_map_mode_pref_to_mode */



/* <EJECT> */
/*===========================================================================

FUNCTION sd_map_band_to_band_pref

DESCRIPTION
  Map band to band preference.

DEPENDENCIES
  None.

RETURN VALUE
  Band perference.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sd_ss_band_pref_e_type    sd_map_band_to_band_pref(

        sd_band_e_type            band
          /* Band mapped to band pref.
          */
)
{
  sd_ss_band_pref_e_type band_pref;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Map the specified band to its corresponding band preferences.
  */
  switch( band ){

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -- -*/

    case SD_BAND_BC0:
      band_pref = SD_SS_BAND_PREF_BC0;
      break;

    case SD_BAND_BC1:
      band_pref = SD_SS_BAND_PREF_BC1;
      break;

    case SD_BAND_BC3:
      band_pref = SD_SS_BAND_PREF_BC3;
      break;

    case SD_BAND_BC4:
      band_pref = SD_SS_BAND_PREF_BC4;
      break;

    case SD_BAND_BC5:
      band_pref = SD_SS_BAND_PREF_BC5;
      break;

    case SD_BAND_BC6:
      band_pref = SD_SS_BAND_PREF_BC6;
      break;

    case SD_BAND_BC7:
      band_pref = SD_SS_BAND_PREF_BC7;
      break;

    case SD_BAND_BC8:
      band_pref = SD_SS_BAND_PREF_BC8;
      break;

    case SD_BAND_BC9:
      band_pref = SD_SS_BAND_PREF_BC9;
      break;

    case SD_BAND_BC10:
      band_pref = SD_SS_BAND_PREF_BC10;
      break;

    case SD_BAND_BC11:
      band_pref = SD_SS_BAND_PREF_BC11;
      break;

    case SD_BAND_BC12:
      band_pref = SD_SS_BAND_PREF_BC12;
      break;

    case SD_BAND_BC14:
      band_pref = SD_SS_BAND_PREF_BC14;
      break;

    case SD_BAND_BC15:
      band_pref = SD_SS_BAND_PREF_BC15;
      break;

    case SD_BAND_BC16:
      band_pref = SD_SS_BAND_PREF_BC16;
      break;

    case SD_BAND_BC17:
      band_pref = SD_SS_BAND_PREF_BC17;
      break;

    case SD_BAND_BC18:
      band_pref = SD_SS_BAND_PREF_BC18;
      break;

    case SD_BAND_BC19:
      band_pref = SD_SS_BAND_PREF_BC19;
      break;

     /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -- -*/

    case SD_BAND_GSM_DCS_1800:
      band_pref = SD_SS_BAND_PREF_GSM_DCS_1800;
      break;

    case SD_BAND_GSM_EGSM_900:
      band_pref = SD_SS_BAND_PREF_GSM_EGSM_900;
      break;

    case SD_BAND_GSM_PGSM_900:
      band_pref = SD_SS_BAND_PREF_GSM_PGSM_900;
      break;

   case SD_BAND_GSM_450:
      band_pref = SD_SS_BAND_PREF_GSM_450;
      break;

    case SD_BAND_GSM_480:
      band_pref = SD_SS_BAND_PREF_GSM_480;
      break;

    case SD_BAND_GSM_RGSM_900:
      band_pref = SD_SS_BAND_PREF_GSM_RGSM_900;
      break;

    case SD_BAND_GSM_PCS_1900:
      band_pref = SD_SS_BAND_PREF_GSM_PCS_1900;
      break;

    case SD_BAND_GSM_850:
      band_pref = SD_SS_BAND_PREF_GSM_850;
      break;

    case SD_BAND_GSM_750:
      band_pref = SD_SS_BAND_PREF_GSM_750;
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -- -*/

    case SD_BAND_WCDMA_I_IMT_2000:
      band_pref = SD_SS_BAND_PREF_WCDMA_I_IMT_2000;
      break;

    case SD_BAND_WCDMA_II_PCS_1900:
      band_pref = SD_SS_BAND_PREF_WCDMA_II_PCS_1900;
      break;

    case SD_BAND_WCDMA_III_1700:
      band_pref = SD_SS_BAND_PREF_WCDMA_III_1700;
      break;

    case SD_BAND_WCDMA_IV_1700:
      band_pref = SD_SS_BAND_PREF_WCDMA_IV_1700;
      break;

    case SD_BAND_WCDMA_V_850:
      band_pref = SD_SS_BAND_PREF_WCDMA_V_850;
      break;

    case SD_BAND_WCDMA_VI_800:
      band_pref = SD_SS_BAND_PREF_WCDMA_VI_800;
      break;

    case SD_BAND_WCDMA_VII_2600:
      band_pref = SD_SS_BAND_PREF_WCDMA_VII_2600;
      break;

    case SD_BAND_WCDMA_VIII_900:
      band_pref = SD_SS_BAND_PREF_WCDMA_VIII_900;
      break;

    case SD_BAND_WCDMA_IX_1700:
      band_pref = SD_SS_BAND_PREF_WCDMA_IX_1700;
      break;

    case SD_BAND_WCDMA_XI_1500:
      band_pref = SD_SS_BAND_PREF_WCDMA_XI_1500;
      break;

    case SD_BAND_WCDMA_XIX_850:
      band_pref = SD_SS_BAND_PREF_WCDMA_XIX_850;
      break;

    case SD_BAND_NONE:
    case SD_BAND_MAX:
    case SD_BAND_BC13:
    case SD_BAND_BC_MAX:
    default:
      band_pref = SD_SS_BAND_PREF_NONE;
      break;

  } /* switch */
  return band_pref;
} /* sd_map_band_to_band_pref */




/* <EJECT> */
/*===========================================================================

FUNCTION sd_map_band_to_band_pref_lte

DESCRIPTION
  Map LTE band to LTE band preference.

DEPENDENCIES
  None.

RETURN VALUE
  Band perference.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sys_lte_band_mask_e_type    sd_map_band_to_band_pref_lte(

        sd_band_e_type            lte_band
          /* LTE band mapped to band pref.
          */
)
{
  sys_lte_band_mask_e_type lte_band_pref;

  SYS_LTE_BAND_MASK_CLR_ALL_BANDS(&lte_band_pref);
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Map the specified band to its corresponding band preferences.
  */
  switch( lte_band )
  {
    case SD_BAND_LTE_EUTRAN_BAND1:
    case SD_BAND_LTE_EUTRAN_BAND2:
    case SD_BAND_LTE_EUTRAN_BAND3:
    case SD_BAND_LTE_EUTRAN_BAND4:
    case SD_BAND_LTE_EUTRAN_BAND5:
    case SD_BAND_LTE_EUTRAN_BAND6:
    case SD_BAND_LTE_EUTRAN_BAND7:
    case SD_BAND_LTE_EUTRAN_BAND8:
    case SD_BAND_LTE_EUTRAN_BAND9:
    case SD_BAND_LTE_EUTRAN_BAND10:
    case SD_BAND_LTE_EUTRAN_BAND11:
    case SD_BAND_LTE_EUTRAN_BAND12:
    case SD_BAND_LTE_EUTRAN_BAND13:
    case SD_BAND_LTE_EUTRAN_BAND14:
    case SD_BAND_LTE_EUTRAN_BAND17:
    case SD_BAND_LTE_EUTRAN_BAND18:
    case SD_BAND_LTE_EUTRAN_BAND19:
    case SD_BAND_LTE_EUTRAN_BAND20:
    case SD_BAND_LTE_EUTRAN_BAND21:
    case SD_BAND_LTE_EUTRAN_BAND23:
    case SD_BAND_LTE_EUTRAN_BAND24:
    case SD_BAND_LTE_EUTRAN_BAND25:
    case SD_BAND_LTE_EUTRAN_BAND26:
   case SD_BAND_LTE_EUTRAN_BAND27:
    case SD_BAND_LTE_EUTRAN_BAND28:
    case SD_BAND_LTE_EUTRAN_BAND29:
  case SD_BAND_LTE_EUTRAN_BAND30:
    case SD_BAND_LTE_EUTRAN_BAND31:
    case SD_BAND_LTE_EUTRAN_BAND32:
    case SD_BAND_LTE_EUTRAN_BAND33:
    case SD_BAND_LTE_EUTRAN_BAND34:
    case SD_BAND_LTE_EUTRAN_BAND35:
    case SD_BAND_LTE_EUTRAN_BAND36:
    case SD_BAND_LTE_EUTRAN_BAND37:
    case SD_BAND_LTE_EUTRAN_BAND38:
    case SD_BAND_LTE_EUTRAN_BAND39:
    case SD_BAND_LTE_EUTRAN_BAND40:
    case SD_BAND_LTE_EUTRAN_BAND41:
    case SD_BAND_LTE_EUTRAN_BAND42:
    case SD_BAND_LTE_EUTRAN_BAND43:
    case SD_BAND_LTE_EUTRAN_BAND66:
    case SD_BAND_LTE_EUTRAN_BAND252:
    case SD_BAND_LTE_EUTRAN_BAND255:
      SYS_LTE_BAND_MASK_ADD_BAND(&lte_band_pref,sys_map_lte_band_to_sband(lte_band));
      break;

    default:
      lte_band_pref = SYS_LTE_BAND_MASK_CONST_NONE;
      break;

  } /* switch */

  return lte_band_pref;
} /* sd_map_band_to_band_pref_lte */




/* <EJECT> */
/*===========================================================================

FUNCTION sd_map_band_to_band_pref_tds

DESCRIPTION
  Map SD TDS band to TDS band preference.

DEPENDENCIES
  None.

RETURN VALUE
  Band perference.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sd_ss_band_pref_e_type    sd_map_band_to_band_pref_tds(

        sd_band_e_type            tds_band
          /* TDS band mapped to band pref.
          */
)
{
  sd_ss_band_pref_e_type tds_band_pref;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Map the specified band to its corresponding band preferences.
  */
  switch( tds_band )
  {
    case SD_BAND_TDS_BANDA:
      tds_band_pref = SD_SS_BAND_PREF_TDS_BANDA;
    break;

    case SD_BAND_TDS_BANDB:
      tds_band_pref = SD_SS_BAND_PREF_TDS_BANDB;
    break;

    case SD_BAND_TDS_BANDC:
      tds_band_pref = SD_SS_BAND_PREF_TDS_BANDC;
    break;

    case SD_BAND_TDS_BANDD:
      tds_band_pref = SD_SS_BAND_PREF_TDS_BANDD;
    break;

    case SD_BAND_TDS_BANDE:
      tds_band_pref = SD_SS_BAND_PREF_TDS_BANDE;
    break;

    case SD_BAND_TDS_BANDF:
      tds_band_pref = SD_SS_BAND_PREF_TDS_BANDF;
    break;


    default:
      tds_band_pref = SD_SS_BAND_PREF_NONE;
      break;

  } /* switch */

  return tds_band_pref;
} /* sd_map_band_to_band_pref_tds */



/* <EJECT> */
/*===========================================================================

FUNCTION sdss_map_band_pref_to_band

DESCRIPTION
  Map band to band preference.

DEPENDENCIES
  None.

RETURN VALUE
  Band.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sd_band_e_type            sdss_map_band_pref_to_band(

        sd_ss_band_pref_e_type    band_pref
          /* Band mapped to band pref.
          */
)
{
  static const sd_sband_e_type band_pref_bit_tbl[] =
  {
    SD_SBAND_BC1,
    SD_SBAND_BC3,
    SD_SBAND_BC4,
    SD_SBAND_BC5,
    SD_SBAND_BC6,
    SD_SBAND_BC7,
    SD_SBAND_BC10,
    SD_SBAND_BC11,
    SD_SBAND_BC12,
    SD_SBAND_BC14,
    SD_SBAND_BC15,
    SD_SBAND_BC16,
    SD_SBAND_BC17,
    SD_SBAND_BC18,
    SD_SBAND_BC19,
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    SD_SBAND_GSM_450,
    SD_SBAND_GSM_480,
    SD_SBAND_GSM_DCS_1800,
    SD_SBAND_GSM_EGSM_900,
    SD_SBAND_GSM_PGSM_900,
    SD_SBAND_GSM_RGSM_900,
    SD_SBAND_GSM_PCS_1900,
    SD_SBAND_GSM_850,
    SD_SBAND_GSM_750,

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    SD_SBAND_WCDMA_I_IMT_2000,
    SD_SBAND_WCDMA_II_PCS_1900,
    SD_SBAND_WCDMA_III_1700,
    SD_SBAND_WCDMA_IV_1700,
    SD_SBAND_WCDMA_V_850,
    SD_SBAND_WCDMA_VI_800,
    SD_SBAND_WCDMA_VII_2600,
    SD_SBAND_WCDMA_VIII_900,
    SD_SBAND_WCDMA_IX_1700,
    SD_SBAND_WCDMA_XI_1500,
    SD_SBAND_WCDMA_XIX_850
  };

  /* KW: This is an initialization, so array size should be equal to no. of
  ** entries in the initializer
  */
  static const sd_band_e_type band_val[] =
  {
    SD_BAND_BC1,
    SD_BAND_BC3,
    SD_BAND_BC4,
    SD_BAND_BC5,
    SD_BAND_BC6,
    SD_BAND_BC7,
    SD_BAND_BC10,
    SD_BAND_BC11,
    SD_BAND_BC12,
    SD_BAND_BC14,
    SD_BAND_BC15,
    SD_BAND_BC16,
    SD_BAND_BC17,
    SD_BAND_BC18,
    SD_BAND_BC19,

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    SD_BAND_GSM_450,
    SD_BAND_GSM_480,
    SD_BAND_GSM_DCS_1800,
    SD_BAND_GSM_EGSM_900,
    SD_BAND_GSM_PGSM_900,
    SD_BAND_GSM_RGSM_900,
    SD_BAND_GSM_PCS_1900,
    SD_BAND_GSM_850,
    SD_BAND_GSM_750,

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    SD_BAND_WCDMA_I_IMT_2000,
    SD_BAND_WCDMA_II_PCS_1900,
    SD_BAND_WCDMA_III_1700,
    SD_BAND_WCDMA_IV_1700,
    SD_BAND_WCDMA_V_850,
    SD_BAND_WCDMA_VI_800,
    SD_BAND_WCDMA_VII_2600,
    SD_BAND_WCDMA_VIII_900,
    SD_BAND_WCDMA_IX_1700,
    SD_BAND_WCDMA_XI_1500,
    SD_BAND_WCDMA_XIX_850
  };

  word i;

  SD_ASSERT( ARR_SIZE(band_pref_bit_tbl) == ARR_SIZE(band_val) );

  /* Map the specified band preferences to its corresponding band.
  */
  if( SD_BAND_CONTAIN( band_pref, SD_SS_BAND_PREF_BC0 ) )
    return SD_BAND_BC0;

  for(i=0; i<ARR_SIZE(band_pref_bit_tbl); i++)
  {
    if( SD_BAND_CONTAIN( band_pref, SYS_BM_64BIT(band_pref_bit_tbl[i]) ) )
    {
      return band_val[i];
    }
  }

  return SD_BAND_MAX;

} /* sd_map_band_to_band_pref */


/*===========================================================================

FUNCTION sdss_map_band_pref_to_band_lte

DESCRIPTION
  Map band to band_lte preference, designed for LTE.

DEPENDENCIES
  None.

RETURN VALUE
  Band.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sd_band_e_type            sdss_map_band_pref_to_band_lte(

        sys_lte_band_mask_e_type  band_pref
        )
{
    unsigned int i, size;
    /* This array is used for bitmasks only */
    static const sd_band_lte_e_type band_tbl[] =
    {
            SD_SBAND_LTE_EUTRAN_BAND1,
            SD_SBAND_LTE_EUTRAN_BAND2,
            SD_SBAND_LTE_EUTRAN_BAND3,
            SD_SBAND_LTE_EUTRAN_BAND4,
            SD_SBAND_LTE_EUTRAN_BAND5,
            SD_SBAND_LTE_EUTRAN_BAND6,
            SD_SBAND_LTE_EUTRAN_BAND7,
            SD_SBAND_LTE_EUTRAN_BAND8,
            SD_SBAND_LTE_EUTRAN_BAND9,
            SD_SBAND_LTE_EUTRAN_BAND10,
            SD_SBAND_LTE_EUTRAN_BAND11,
            SD_SBAND_LTE_EUTRAN_BAND12,
            SD_SBAND_LTE_EUTRAN_BAND13,
            SD_SBAND_LTE_EUTRAN_BAND14,
            SD_SBAND_LTE_EUTRAN_BAND17,
            SD_SBAND_LTE_EUTRAN_BAND18,
            SD_SBAND_LTE_EUTRAN_BAND19,
            SD_SBAND_LTE_EUTRAN_BAND20,
            SD_SBAND_LTE_EUTRAN_BAND21,
            SD_SBAND_LTE_EUTRAN_BAND23,
            SD_SBAND_LTE_EUTRAN_BAND24,
            SD_SBAND_LTE_EUTRAN_BAND25,
            SD_SBAND_LTE_EUTRAN_BAND26,
            SD_SBAND_LTE_EUTRAN_BAND27,
            SD_SBAND_LTE_EUTRAN_BAND28,
            SD_SBAND_LTE_EUTRAN_BAND29,
            SD_SBAND_LTE_EUTRAN_BAND30,
            SD_SBAND_LTE_EUTRAN_BAND31,
            SD_SBAND_LTE_EUTRAN_BAND32,
            SD_SBAND_LTE_EUTRAN_BAND33,
            SD_SBAND_LTE_EUTRAN_BAND34,
            SD_SBAND_LTE_EUTRAN_BAND35,
            SD_SBAND_LTE_EUTRAN_BAND36,
            SD_SBAND_LTE_EUTRAN_BAND37,
            SD_SBAND_LTE_EUTRAN_BAND38,
            SD_SBAND_LTE_EUTRAN_BAND39,
            SD_SBAND_LTE_EUTRAN_BAND40,
            SD_SBAND_LTE_EUTRAN_BAND41,
            SD_SBAND_LTE_EUTRAN_BAND42,
            SD_SBAND_LTE_EUTRAN_BAND43,
            SD_SBAND_LTE_EUTRAN_BAND66
    };

    /* This array contains the relevant enums mapped to the bitmask */

    /* KW: This is an initialization, so array size should be equal to no. of
    ** entries in the initializer
    */
    static const sd_band_e_type band_tbl_e[] =
    {
            SD_BAND_LTE_EUTRAN_BAND1,
            SD_BAND_LTE_EUTRAN_BAND2,
            SD_BAND_LTE_EUTRAN_BAND3,
            SD_BAND_LTE_EUTRAN_BAND4,
            SD_BAND_LTE_EUTRAN_BAND5,
            SD_BAND_LTE_EUTRAN_BAND6,
            SD_BAND_LTE_EUTRAN_BAND7,
            SD_BAND_LTE_EUTRAN_BAND8,
            SD_BAND_LTE_EUTRAN_BAND9,
            SD_BAND_LTE_EUTRAN_BAND10,
            SD_BAND_LTE_EUTRAN_BAND11,
            SD_BAND_LTE_EUTRAN_BAND12,
            SD_BAND_LTE_EUTRAN_BAND13,
            SD_BAND_LTE_EUTRAN_BAND14,
            SD_BAND_LTE_EUTRAN_BAND17,
            SD_BAND_LTE_EUTRAN_BAND18,
            SD_BAND_LTE_EUTRAN_BAND19,
            SD_BAND_LTE_EUTRAN_BAND20,
            SD_BAND_LTE_EUTRAN_BAND21,
            SD_BAND_LTE_EUTRAN_BAND23,
            SD_BAND_LTE_EUTRAN_BAND24,
            SD_BAND_LTE_EUTRAN_BAND25,
            SD_BAND_LTE_EUTRAN_BAND26,
            SD_BAND_LTE_EUTRAN_BAND27,
            SD_BAND_LTE_EUTRAN_BAND28,
            SD_BAND_LTE_EUTRAN_BAND29,
            SD_BAND_LTE_EUTRAN_BAND30,
            SD_BAND_LTE_EUTRAN_BAND31,
            SD_BAND_LTE_EUTRAN_BAND32,
            SD_BAND_LTE_EUTRAN_BAND33,
            SD_BAND_LTE_EUTRAN_BAND34,
            SD_BAND_LTE_EUTRAN_BAND35,
            SD_BAND_LTE_EUTRAN_BAND36,
            SD_BAND_LTE_EUTRAN_BAND37,
            SD_BAND_LTE_EUTRAN_BAND38,
            SD_BAND_LTE_EUTRAN_BAND39,
            SD_BAND_LTE_EUTRAN_BAND40,
            SD_BAND_LTE_EUTRAN_BAND41,
            SD_BAND_LTE_EUTRAN_BAND42,
            SD_BAND_LTE_EUTRAN_BAND43,
            SD_BAND_LTE_EUTRAN_BAND66
    };
    size = ARR_SIZE(band_tbl);
    SD_ASSERT( size == ARR_SIZE(band_tbl_e) );
    for(i=0; i<size; i++)
    {
        /* Need to return type sys_band_class_e_type */
      if( SYS_LTE_BAND_MASK_IS_BAND_PRESENT( &band_pref, band_tbl[i] ) )
        {
            return band_tbl_e[i];
        }
    }
    return SD_BAND_MAX;
}

/*===========================================================================

FUNCTION sdss_map_band_pref_to_band_tds

DESCRIPTION
  Map band to band_tds preference, designed for TD-SCDMA

DEPENDENCIES
  None.

RETURN VALUE
  Band.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sd_band_e_type            sdss_map_band_pref_to_band_tds(
        sd_ss_band_pref_e_type    band_pref
        )
{
    unsigned int i, size;
    /* This array is used for bitmasks only */
    static const sd_band_tds_e_type band_tbl[] =
    {
       SD_SBAND_TDS_BANDA,    /* TDS Band A 1900-1920 MHz, 2010-2020 MHz */
       SD_SBAND_TDS_BANDB,    /* TDS Band B 1850-1910 MHz, 1930-1990 MHz */
       SD_SBAND_TDS_BANDC,    /* TDS Band C 1910-1930 MHz */
       SD_SBAND_TDS_BANDD,    /* TDS Band D 2570-2620 MHz */
       SD_SBAND_TDS_BANDE,    /* TDS Band E 2300-2400 MHz */
       SD_SBAND_TDS_BANDF     /* TDS Band F 1880-1920 MHz */
    };

    /* This array contains the relevant enums mapped to the bitmask */

    /* KW: This is an initialization, so array size should be equal to no. of
    ** entries in the initializer
    */
    static const sd_band_e_type band_tbl_e[] =
    {
       SD_BAND_TDS_BANDA,
       SD_BAND_TDS_BANDB,
       SD_BAND_TDS_BANDC,
       SD_BAND_TDS_BANDD,
       SD_BAND_TDS_BANDE,
       SD_BAND_TDS_BANDF
    };

    size = ARR_SIZE(band_tbl);
    SD_ASSERT( size == ARR_SIZE(band_tbl_e) );
    for(i=0; i<size; i++)
    {
        /* Need to return type sys_band_class_e_type */
        if( SD_BAND_CONTAIN( band_pref, SYS_BM_64BIT(band_tbl[i]) ) )
        {
            return band_tbl_e[i];
        }
    }
    return SD_BAND_MAX;
}

/*===========================================================================

FUNCTION sdss_is_supp_sys

DESCRIPTION
  Check whether a specified system (i.e., a combination of mode, band and
  CDMA channel/AMPS system) is supported by the current target.
  only applicable for 3gpp2 systems.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the specified system is supported by the current target. FALSE
  otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean                   sdss_is_supp_sys(

        sd_mode_e_type            mode,
            /* Mode which to check for support.
            */

        sd_ss_band_pref_e_type    band_pref,
            /* Band which to check for support.
            */

        sd_chan_type              chan
            /* Channel which to check for support.
            */
)
{
  SD_ASSERT_ENUM_IS_INRANGE( mode, SD_MODE_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( band_pref, SD_SS_BAND_PREF_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If the specified mode and band combination is NOT supported by the
  ** current target, return FALSE.
  */
  if( ! sdss_is_supp_mode_band(mode, band_pref, SYS_LTE_BAND_MASK_CONST_NONE, SD_SS_BAND_PREF_NONE) )
  {
    return FALSE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If the specified channel is invalid, return FALSE.
  */
  if( sd_map_chan_to_blksys(mode,
    sdss_map_band_pref_to_band(band_pref), chan) == SD_BLKSYS_MAX )
  {
    return FALSE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If we got here, the specified mode, band and channel combination is
  ** supported - return TRUE.
  */
  return TRUE;

} /* sdss_is_supp_sys */

/*===========================================================================

FUNCTION sdss_is_ue_supp_band_pref

DESCRIPTION
  Check whether the specified  band preferance is supported by the current UE
  configuration or not.Only applicable for 3gpp2 systems.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the specified system is supported by the current UE configuration. FALSE
  otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN boolean sdss_is_ue_supp_band_pref (

       sd_ss_band_pref_e_type    band_pref

)
{
  sd_ss_band_pref_e_type     ss_band_pref     = SD_SS_BAND_PREF_NONE;

  sdss_get_mode_band_pref( SD_SS_MAIN,
                           NULL,
                           &ss_band_pref,
                           NULL,
                           NULL );

  if (ss_band_pref & band_pref)
  {
    return TRUE;
  }

  return FALSE;
}


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_event_group_print

DESCRIPTION
  Print an SS-Event group to which the input SS-Event belongs.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                  sdss_event_group_print(

        sdss_evt_e_type       event
            /* SS-Event for which to print the event group.
            */
)
{
  sdss_evt_grp_e_type   event_group;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( event, SDSS_EVT_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  event_group = sdss_map_event_to_group( event );
  switch( event_group )
  {
    case SDSS_EVT_GRP_USER:
      SD_MSG_HIGH_1( ">>>> Proc user event=%d >>>>",event);
      break;

    case SDSS_EVT_GRP_MISC:
      SD_MSG_HIGH_1( ">>>> Proc misc event=%d >>>>",event);
      break;

    case SDSS_EVT_GRP_CDMA_ACQ:
      SD_MSG_HIGH_1( ">>>> Proc CDMA acq event=%d >>>>",event);
      break;

    case SDSS_EVT_GRP_CDMA_OPR:
      SD_MSG_HIGH_1( ">>>> Proc CDMA opr event=%d >>>>",event);
      break;

    case SDSS_EVT_GRP_AMPS_ACQ:
      //SD_MSG_HIGH_1( ">>>> Proc AMPS acq event=%d >>>>",event);
      break;

    case SDSS_EVT_GRP_AMPS_OPR:
      //SD_MSG_HIGH_1( ">>>> Proc AMPS opr event=%d >>>>",event);
      break;

    case SDSS_EVT_GRP_HDR_USER:
      SD_MSG_HIGH_1( ">>>> Proc HDR user event=%d >>>>",event);
      break;

    case SDSS_EVT_GRP_HDR_ACQ:
      SD_MSG_HIGH_1( ">>>> Proc HDR acq event=%d >>>>",event);
      break;

    case SDSS_EVT_GRP_HDR_OPR:
      SD_MSG_HIGH_1( ">>>> Proc HDR opr event=%d >>>>",event);
      break;

    case SDSS_EVT_GRP_GWL_ACQ:
      SD_MSG_HIGH_1( ">>>> Proc GWL acq event=%d >>>>",event);
      break;

    case SDSS_EVT_GRP_GWL_OPR:
      SD_MSG_HIGH_1( ">>>> Proc GWL opr event=%d >>>>",event);
      break;

    case SDSS_EVT_GRP_INT:
      SD_MSG_HIGH_1( ">>>> Proc INT event=%d >>>>",event);
      break;

    case SDSS_EVT_GRP_HYBR_1_USER:
      SD_MSG_HIGH_1( ">>>> Proc HYBR_1 user event=%d >>>>",event);
      break;

    case SDSS_EVT_GRP_HYBR_2_USER:
      SD_MSG_HIGH_1( ">>>> Proc HYBR_2 user event=%d >>>>",event);
      break;

    case SDSS_EVT_GRP_HYBR_2_GW_OPR:
      SD_MSG_HIGH_1( ">>>> Proc HYBR_2 GW opr event=%d >>>>",event);
      break;

    case SDSS_EVT_GRP_HYBR_2_GW_ACQ:
      SD_MSG_HIGH_1( ">>>> Proc HYBR_2 GW acq event=%d >>>>",event);
      break;

    case SDSS_EVT_GRP_HYBR_3_USER:
      SD_MSG_HIGH_1( ">>>> Proc HYBR_3 user event=%d >>>>",event);
      break;

    case SDSS_EVT_GRP_HYBR_3_GW_OPR:
      SD_MSG_HIGH_1( ">>>> Proc HYBR_3 GW opr event=%d >>>>",event);
      break;

    case SDSS_EVT_GRP_HYBR_3_GW_ACQ:
      SD_MSG_HIGH_1( ">>>> Proc HYBR_3 GW acq event=%d >>>>",event);
      break;

    case SDSS_EVT_GRP_CALLED:
    case SDSS_EVT_GRP_MAX:
    default:
      SD_ERR_0( "event_group");
      break;

  } /* switch */

} /* sdss_event_group_print */




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_act_print

DESCRIPTION
  Print an SS-Action.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                        sdss_act_print(

        const sd_ss_act_s_type      *act_ptr
            /* Pointer to an SS-Action which to print.
            */
)
{
  SD_ASSERT( act_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  switch( act_ptr->act )
  {

    case SD_SS_ACT_ACQ_CDMA:
      SD_MSG_HIGH_3( "ACQ_CDMA, band=%d, chan=%d, blksys=%d",
                   act_ptr->prm.acq_cdma.band,
                   act_ptr->prm.acq_cdma.chan,
                   act_ptr->prm.acq_cdma.blksys );
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SD_SS_ACT_ACQ_AMPS:
      SD_MSG_HIGH_3( "ACQ_AMPS, band=%d, sys=%d, delay=%d",
                   act_ptr->prm.acq_amps.band,
                   act_ptr->prm.acq_amps.sys,
                   act_ptr->prm.acq_amps.max_redirect_delay );
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SD_SS_ACT_ACQ_HDR:
      SD_MSG_HIGH_3( "ACQ_HDR, band=%d, chan=%d acq_mode=%d",
                   act_ptr->prm.acq_hdr.band,
                   act_ptr->prm.acq_hdr.chan,
                   act_ptr->prm.acq_hdr.acq_mode );
      break;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SD_SS_ACT_ACQ_GW:
    #if defined(SD_GSM_SUPPORTED) || defined(SD_WCDMA_SUPPORTED)
      SD_MSG_HIGH_6( "ACQ_GW, mode_pref=0x%x, band_pref=0x%x 0x%x sel_type=%d domain=%d srv_req_type=%d",
                    act_ptr->prm.acq_gwl.gwl_mode_pref,
                    QWORD_HIGH(act_ptr->prm.acq_gwl.gw_band_pref),
                    QWORD_LOW(act_ptr->prm.acq_gwl.gw_band_pref),
                   act_ptr->prm.acq_gwl.net_sel_type,
                   act_ptr->prm.acq_gwl.srv_domain_pref,
                   act_ptr->prm.acq_gwl.srv_req_type);

     
    #endif /* SD_GSM_SUPPORTED || SD_WCDMA_SUPPORTED */

      break;


    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SD_SS_ACT_ACQ_GWL:
    #if defined(SD_GSM_SUPPORTED) || defined(SD_WCDMA_SUPPORTED) || defined(FEATURE_SD_LTE)
      #ifndef FEATURE_RAT_PRIORITY_LIST
      SD_MSG_HIGH_5( "ACQ_GWL, mode_pref=0x%x, gw_band_pref=0x%x 0x%x tds_band_pref=0x%x 0x%x",
                   act_ptr->prm.acq_gwl.gwl_mode_pref,
                   QWORD_HIGH(act_ptr->prm.acq_gwl.gw_band_pref),
                   QWORD_LOW(act_ptr->prm.acq_gwl.gw_band_pref),
                   QWORD_HIGH(act_ptr->prm.acq_gwl.tds_band_pref),
                   QWORD_LOW(act_ptr->prm.acq_gwl.tds_band_pref) );
     sd_print_lte_band_mask(act_ptr->prm.acq_gwl.lte_band_pref);
  
      #else
      {
        const sys_rat_pri_list_info_s_type   *rat_pri_ptr;
        uint32 i;
        rat_pri_ptr = &(act_ptr->prm.acq_gwl.rat_pri_list_info);
        for(i = 0; i < act_ptr->prm.acq_gwl.rat_pri_list_info.num_items; i++ )
        {
          SD_MSG_HIGH_2("ACQ_GWL:sys_mode = %d, acq_reqd = %d",
               rat_pri_ptr->priority_list_info[i].acq_sys_mode,
                        rat_pri_ptr->priority_list_info[i].bst_rat_acq_required);

          if( rat_pri_ptr->priority_list_info[i].acq_sys_mode != SYS_SYS_MODE_LTE )
          {
            SD_MSG_HIGH_4("ACQ_GWL:bst_band_cap = 0x%08x %08x band_cap = 0x%08x %08x",
                  QWORD_HIGH(rat_pri_ptr->priority_list_info[i].bst_band_cap.chgwt_band_cap),
                  QWORD_LOW(rat_pri_ptr->priority_list_info[i].bst_band_cap.chgwt_band_cap),
                  QWORD_HIGH(rat_pri_ptr->priority_list_info[i].band_cap.chgwt_band_cap),
                  QWORD_LOW(rat_pri_ptr->priority_list_info[i].band_cap.chgwt_band_cap));

          }
          else
          {
            SD_MSG_HIGH_0("ACQ_GWL: bst_band_cap");
            sd_print_lte_band_mask(rat_pri_ptr->priority_list_info[i].bst_band_cap.lte_band_cap);
            SD_MSG_HIGH_0("ACQ_GWL: band_cap");
            sd_print_lte_band_mask(rat_pri_ptr->priority_list_info[i].band_cap.lte_band_cap);
          }
        }
        SYS_ARG_NOT_USED(rat_pri_ptr);
      }
      #endif // FEATURE_RAT_PRIORITY_LIST
      SD_MSG_HIGH_3( "ACQ_GWL, sel_type=%d domain=%d srv_req_type=%d",
                   act_ptr->prm.acq_gwl.net_sel_type,
                   act_ptr->prm.acq_gwl.srv_domain_pref,
                   act_ptr->prm.acq_gwl.srv_req_type );

    #endif /* SD_GSM_SUPPORTED || SD_WCDMA_SUPPORTED || defined(FEATURE_SD_LTE) */

      break;


    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SD_SS_ACT_GET_NET_GW:
    #if defined(SD_GSM_SUPPORTED) || defined(SD_WCDMA_SUPPORTED) || defined FEATURE_SD_LTE
      #ifndef FEATURE_RAT_PRIORITY_LIST
      SD_MSG_HIGH_3( "GET_NET_GWL, requested mode_pref=0x%x,band_pref=0x%llx domain=%d ",
                   act_ptr->prm.get_net_gw.gw_mode_pref,
                   act_ptr->prm.get_net_gw.gw_band_pref,
                   act_ptr->prm.get_net_gw.srv_domain_pref
                   );
      
      #else
      {
        const sys_rat_pri_list_info_s_type   *rat_pri_ptr;
        uint32 i;
        rat_pri_ptr = &(act_ptr->prm.get_net_gw.rat_pri_list_info);
        for(i = 0; i < act_ptr->prm.get_net_gw.rat_pri_list_info.num_items; i++ )
        {
          if( rat_pri_ptr->priority_list_info[i].acq_sys_mode != SYS_SYS_MODE_LTE )
          {
            SD_MSG_HIGH_6("GET_NET_GWL:sys_mode = %d acq_reqd = %d band_cap = 0x%08x %08x bst_band_cap = 0x%08x %08x",
               rat_pri_ptr->priority_list_info[i].acq_sys_mode,
               rat_pri_ptr->priority_list_info[i].bst_rat_acq_required,
                 QWORD_HIGH(rat_pri_ptr->priority_list_info[i].band_cap.chgwt_band_cap),
                 QWORD_LOW(rat_pri_ptr->priority_list_info[i].band_cap.chgwt_band_cap),
                 QWORD_HIGH(rat_pri_ptr->priority_list_info[i].bst_band_cap.chgwt_band_cap),
                 QWORD_LOW(rat_pri_ptr->priority_list_info[i].bst_band_cap.chgwt_band_cap));

          }
          else
          {
            SD_MSG_HIGH_1("GET_NET_GWL:sys_mode = LTE, acq_reqd = %d",rat_pri_ptr->priority_list_info[i].bst_rat_acq_required);
            SD_MSG_HIGH_0("GET_NET_GWL: bst_band_cap");
            sd_print_lte_band_mask(rat_pri_ptr->priority_list_info[i].bst_band_cap.lte_band_cap);
            SD_MSG_HIGH_0("GET_NET_GWL: band_cap");
            sd_print_lte_band_mask(rat_pri_ptr->priority_list_info[i].band_cap.lte_band_cap);
          }
        }
        SYS_ARG_NOT_USED(rat_pri_ptr);
      }
      #endif //FEATURE_RAT_PRIORITY_LIST
    #endif /* SD_GSM_SUPPORTED || SD_WCDMA_SUPPORTED || FEATURE_SD_LTE */

      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SD_SS_ACT_MEAS_DED:
      SD_MSG_HIGH_2( "MEAS_DED, type=%d, ID=%d",
                   act_ptr->prm.meas.type,
                   act_ptr->prm.meas.id);

      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SD_SS_ACT_MEAS_BACK:
      SD_MSG_HIGH_2( "MEAS_BACK, type=%d, ID=%d",
                   act_ptr->prm.meas.type,
                   act_ptr->prm.meas.id);
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
	
    case SD_SS_ACT_CONTINUE:
    case SD_SS_ACT_ACQ_GPS:		
    case SD_SS_ACT_PWR_SAVE:
    case SD_SS_ACT_ACCEPT:
    case SD_SS_ACT_REJECT:
    case SD_SS_ACT_RELEASE:
    case SD_SS_ACT_MAX:		
    default:
      break;
	  
  }

} /* sdss_act_print */




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_iact_print

DESCRIPTION
  Print an SS-Internal-action.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                        sdss_iact_print(

        const sdss_iact_s_type      *iact_ptr
            /* Pointer to an SS-Action which to print.
            */
)
{
  SD_ASSERT( iact_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  switch( iact_ptr->act )
  {

    case SDSS_IACT_ACQUIRE:
      SD_MSG_HIGH_3( "ACQUIRE, list=%d, pos=%d, mode=%d",
                   iact_ptr->prm.acq.list,
                   iact_ptr->prm.acq.pos,
                   iact_ptr->prm.acq.mode );
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_IACT_MEAS:
      SD_MSG_HIGH_3( "MEAS, list=%d, mode=%d, type=%d",
                   iact_ptr->prm.meas.list,
                   iact_ptr->prm.meas.mode,
                   iact_ptr->prm.meas.type );
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_IACT_CONTINUE:
    case SDSS_IACT_PWR_SAVE:
    case SDSS_IACT_ACCEPT:
    case SDSS_IACT_REJECT:
    case SDSS_IACT_RELEASE:
    case SDSS_IACT_GET_NET_GWL:
    case SDSS_IACT_MAX:
    default:
	  break;
	  
  }

} /* sdss_iact_print */


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_script_name_print

DESCRIPTION
  Prints event group and its index/name of the script being (re)activated.

DEPENDENCIES
  Prints script name if FEATURE_SD_ENHANCED_DEBUG_MSG defined.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static void                 sdss_script_name_print(

        sdss_evt_grp_e_type event_group,
            /* Event group of the script
            */
        int                 scr_index
            /* Index of the script within event group
            */
)
{
  #ifndef FEATURE_SD_ENHANCED_DEBUG_MSG
  switch( event_group )
  {
    case SDSS_EVT_GRP_USER:
      SD_MSG_HIGH_1( "** Activate user script=%d **",scr_index);
      break;

    case SDSS_EVT_GRP_MISC:
      SD_MSG_HIGH_1( "** Activate misc script=%d **",scr_index);
      break;

    case SDSS_EVT_GRP_INT:
      SD_MSG_HIGH_1( "** Activate internal script=%d **",scr_index);
      break;

    case SDSS_EVT_GRP_CDMA_ACQ:
      SD_MSG_HIGH_1( "** Activate CDMA acq script=%d **",scr_index);
      break;

    case SDSS_EVT_GRP_CDMA_OPR:
      SD_MSG_HIGH_1( "** Activate CDMA opr script=%d **",scr_index);
      break;

    case SDSS_EVT_GRP_AMPS_ACQ:
      SD_MSG_HIGH_1( "** Activate AMPS acq script=%d **",scr_index);
      break;

    case SDSS_EVT_GRP_AMPS_OPR:
      SD_MSG_HIGH_1( "** Activate AMPS opr script=%d **",scr_index);
      break;

    case SDSS_EVT_GRP_HDR_USER:
      SD_MSG_HIGH_1( "** Activate HDR user script=%d **",scr_index);
      break;

    case SDSS_EVT_GRP_HDR_ACQ:
      SD_MSG_HIGH_1( "** Activate HDR acq script=%d **",scr_index);
      break;

    case SDSS_EVT_GRP_HDR_OPR:
      SD_MSG_HIGH_1( "** Activate HDR opr script=%d **",scr_index);
      break;

    case SDSS_EVT_GRP_GWL_ACQ:
      SD_MSG_HIGH_1( "** Activate GWL acq script=%d **",scr_index);
      break;

    case SDSS_EVT_GRP_GWL_OPR:
      SD_MSG_HIGH_1( "** Activate GWL opr script=%d **",scr_index);
      break;

    case SDSS_EVT_GRP_HYBR_1_USER:
      SD_MSG_HIGH_1( "** Activate HYBR_1 user script=%d **",scr_index);
      break;

    case   SDSS_EVT_GRP_HYBR_2_USER:
      SD_MSG_HIGH_1( "** Activate HYBR_2 user script=%d **",scr_index);
      break;

    case SDSS_EVT_GRP_HYBR_2_GW_ACQ:
      SD_MSG_HIGH_1( "** Activate HYBR_2 acq script=%d **",scr_index);
      break;

    case SDSS_EVT_GRP_HYBR_2_GW_OPR:
      SD_MSG_HIGH_1( "** Activate HYBR_2 opr script=%d **",scr_index);
      break;

    case   SDSS_EVT_GRP_HYBR_3_USER:
      SD_MSG_HIGH_1( "** Activate HYBR_3 user script=%d **",scr_index);
      break;

    case SDSS_EVT_GRP_HYBR_3_GW_ACQ:
      SD_MSG_HIGH_1( "** Activate HYBR_3 acq script=%d **",scr_index);
      break;

    case SDSS_EVT_GRP_HYBR_3_GW_OPR:
      SD_MSG_HIGH_1( "** Activate HYBR_3 opr script=%d **",scr_index);
      break;

    case SDSS_EVT_GRP_CALLED:
    case SDSS_EVT_GRP_MAX:
    default:
      SD_ERR_0( "event_group");

  } /* switch */

  #else /* FEATURE_SD_ENHANCED_DEBUG_MSG */
  switch( event_group )
  {
    case SDSS_EVT_GRP_USER:
    case SDSS_EVT_GRP_HYBR_2_USER:
    case SDSS_EVT_GRP_HYBR_3_USER:
      if( scr_index < (int) ARR_SIZE(dsssscr_user_event_tbl_string_map) )
      {
        SD_MSG_SCRIPT( "** Activate user script = ",
                       dsssscr_user_event_tbl_string_map[scr_index]);
      }
      else
      {
        SD_MSG_HIGH_1( "** Activate user script=%d **",scr_index);
      }
      break;

    case SDSS_EVT_GRP_MISC:
      if( scr_index < (int) ARR_SIZE(dsssscr_misc_event_tbl_string_map) )
      {
        SD_MSG_SCRIPT( "** Activate misc script = ",
                         dsssscr_misc_event_tbl_string_map[scr_index]);
      }
      else
      {
        SD_MSG_HIGH_1( "** Activate misc script=%d **",scr_index);
      }
      break;

    case SDSS_EVT_GRP_INT:
      if( scr_index < (int) ARR_SIZE(dsssscr_int_event_tbl_string_map) )
      {
        SD_MSG_SCRIPT( "** Activate internal script = ",
                         dsssscr_int_event_tbl_string_map[scr_index]);
      }
      else
      {
        SD_MSG_HIGH_1( "** Activate internal script=%d **",scr_index);
      }
      break;

  #if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)
    case SDSS_EVT_GRP_CDMA_ACQ:
      if( scr_index < (int) ARR_SIZE(dsssscr_cdma_acq_event_tbl_string_map) )
      {
        SD_MSG_SCRIPT( "** Activate CDMA acq script = ",
                       dsssscr_cdma_acq_event_tbl_string_map[scr_index]);
      }
      else
      {
        SD_MSG_HIGH_1( "** Activate CDMA acq script=%d **",scr_index);
      }
      break;

    case SDSS_EVT_GRP_CDMA_OPR:
      if( scr_index < (int) ARR_SIZE(dsssscr_cdma_opr_event_tbl_string_map) )
      {
        SD_MSG_SCRIPT( "** Activate CDMA opr script = ",
                       dsssscr_cdma_opr_event_tbl_string_map[scr_index]);
      }
      else
      {
        SD_MSG_HIGH_1( "** Activate CDMA opr script=%d **",scr_index);
      }
      break;
  #endif /* FEATURE_MMODE_CDMA_800 || FEATURE_MMODE_CDMA_1900 */

  #ifdef FEATURE_ACP
    case SDSS_EVT_GRP_AMPS_ACQ:
      if( scr_index < (int) ARR_SIZE(dsssscr_amps_acq_event_tbl_string_map) )
      {
        SD_MSG_SCRIPT( "** Activate AMPS acq script = ",
                       dsssscr_amps_acq_event_tbl_string_map[scr_index]);
      }
      else
      {
        SD_MSG_HIGH_1( "** Activate AMPS acq script=%d **",scr_index);
      }
      break;

    case SDSS_EVT_GRP_AMPS_OPR:
      if( scr_index < (int) ARR_SIZE(dsssscr_amps_opr_event_tbl_string_map) )
      {
        SD_MSG_SCRIPT( "** Activate AMPS opr script = ",
                       dsssscr_amps_opr_event_tbl_string_map[scr_index]);
      }
      else
      {
        SD_MSG_HIGH_1( "** Activate AMPS opr script=%d **",scr_index);
      }
      break;
  #endif /* FEATURE_ACP */

  #ifdef FEATURE_HDR
    case SDSS_EVT_GRP_HDR_USER:
      if( scr_index < (int) ARR_SIZE(dsssscr_hdr_user_event_tbl_string_map) )
      {
        SD_MSG_SCRIPT( "** Activate HDR user script = ",
                       dsssscr_hdr_user_event_tbl_string_map[scr_index]);
      }
      else
      {
        SD_MSG_HIGH_1( "** Activate HDR user script=%d **",scr_index);
      }
      break;

    case SDSS_EVT_GRP_HDR_ACQ:
      if( scr_index < (int) ARR_SIZE(dsssscr_hdr_acq_event_tbl_string_map) )
      {
        SD_MSG_SCRIPT( "** Activate HDR acq script = ",
                       dsssscr_hdr_acq_event_tbl_string_map[scr_index]);
      }
      else
      {
        SD_MSG_HIGH_1( "** Activate HDR acq script=%d **",scr_index);
      }
      break;

    case SDSS_EVT_GRP_HDR_OPR:
      if( scr_index < (int) ARR_SIZE(dsssscr_hdr_opr_event_tbl_string_map) )
      {
        SD_MSG_SCRIPT( "** Activate HDR opr script = ",
                       dsssscr_hdr_opr_event_tbl_string_map[scr_index]);
      }
      else
      {
        SD_MSG_HIGH_1( "** Activate HDR opr script=%d **",scr_index);
      }
      break;
  #endif /* FEATURE_HDR */

    case SDSS_EVT_GRP_GWL_ACQ:
    case SDSS_EVT_GRP_HYBR_2_GW_ACQ:
    case SDSS_EVT_GRP_HYBR_3_GW_ACQ:
      /* there is no string map tbl for this */
      SD_MSG_HIGH_1( "** Activate GWL acq script=%d **",scr_index);
      break;

  #if (defined(SD_GSM_SUPPORTED) || defined(SD_WCDMA_SUPPORTED) || defined(FEATURE_SD_LTE))
    case SDSS_EVT_GRP_GWL_OPR:
    case SDSS_EVT_GRP_HYBR_2_GW_OPR:
    case SDSS_EVT_GRP_HYBR_3_GW_OPR:
      if( scr_index < (int) ARR_SIZE(dsssscr_gw_opr_event_tbl_string_map) )
      {
        SD_MSG_SCRIPT( "** Activate GWL opr script = ",
                       dsssscr_gw_opr_event_tbl_string_map[scr_index]);
      }
      else
      {
        SD_MSG_HIGH_1( "** Activate GWL opr script=%d **",scr_index);
      }
      break;
  #endif /* SD_GSM_SUPPORTED || SD_WCDMA_SUPPORTED || FEATURE_SD_LTE */

    case SDSS_EVT_GRP_HYBR_1_USER:
      SD_MSG_HIGH_1( "** Activate HYBR_1 user script=%d **",scr_index);
      break;

    case SDSS_EVT_GRP_CALLED:
    case SDSS_EVT_GRP_MAX:
    default:
      SD_ERR_0( "event_group");
  }
  #endif /* FEATURE_SD_ENHANCED_DEBUG_MSG */

  SYS_ARG_NOT_USED(scr_index);

} /* sdss_script_name_print */


/*===========================================================================

FUNCTION sdss_is_mode_comply_meas_cat

DESCRIPTION

  Return the indication whether current sys mode is part of given
  measurement category

  MODE
DEPENDENCIES
  None

RETURN VALUE
  TRUE/FALSE.

SIDE EFFECTS
  None.

===========================================================================*/
static boolean sdss_is_mode_comply_meas_cat(

        const sd_mode_e_type         mode,
            /* Pointer to a system record which to check for mode preference
            ** compliance.
            */

        const sdsr_cat_e_type        meas_cat
            /* Measurement category.
            */
)
{
  boolean return_val = FALSE;

  switch (meas_cat)
  {
    case SDSR_CAT_NON_AMPS:    /* Non AMPS systems */
      if(mode != SYS_SYS_MODE_AMPS)
      {
        return_val = TRUE;
      }
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSR_CAT_NON_CDMA:    /* Non CDMA systems */
      if(mode != SYS_SYS_MODE_CDMA)
      {
        return_val = TRUE;
      }
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSR_CAT_NON_HDR:     /* Non HDR systems */
      if(mode != SYS_SYS_MODE_HDR)
      {
        return_val = TRUE;
      }
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSR_CAT_NON_GW:      /* Non GW systems */
      if(mode != SYS_SYS_MODE_GSM &&
         mode != SYS_SYS_MODE_WCDMA &&
         mode != SYS_SYS_MODE_GW)
      {
        return_val = TRUE;
      }
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSR_CAT_NON_GWL:     /* Non-GWL systems */
      if(!SD_MODE_CONTAIN(SD_SS_MODE_PREF_TDS_GSM_WCDMA_LTE,
                            sdss_map_mode_to_mode_pref(mode)))
      {
        return_val = TRUE;
      }
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSR_CAT_GWL_SYS:      /* 3GPP system */
      if(SD_MODE_CONTAIN(SD_SS_MODE_PREF_TDS_GSM_WCDMA_LTE,
                         sdss_map_mode_to_mode_pref(mode)))
      {
        return_val = TRUE;
      }
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSR_CAT_HDR:         /* HDR systems*/
      if(mode == SYS_SYS_MODE_HDR)
      {
        return_val = TRUE;
      }
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSR_CAT_ALL:
      return_val = TRUE;
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    case SDSR_CAT_NON_GSM:
    case SDSR_CAT_NON_WCDMA:
    case SDSR_CAT_NON_LTE:
    case SDSR_CAT_NON_CELL:
    case SDSR_CAT_NON_COMPLY:
    case SDSR_CAT_NON_MAP:
    case SDSR_CAT_AVOIDED_SYS:
    case SDSR_CAT_MAX:
    default:
      SD_MSG_HIGH_1( "Meas_cat %d invalid for this function", meas_cat);
      return_val = FALSE;
  }

  return return_val;
}

/* <EJECT> */
/*===========================================================================
=============================================================================
=============================================================================
=========================== SYSTEM RECORD SUPPORT ===========================
=============================================================================
=============================================================================
===========================================================================*/


/*===========================================================================

FUNCTION sdss_sr_is_sid_match_exp_sid

DESCRIPTION
  Check whether the SID/NID that was obtained during the acquisition matches
  the expected SID/NID.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if SID/NID that was obtained during the acquisition matches the
  expected SID/NID. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean                   sdss_sr_is_sid_match_exp_sid(

        const sdsr_s_type         *sr_ptr
            /* Pointer to a system record for which to check the expected
            ** SID/NID.
            */
)
{

  SD_ASSERT( sr_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* For an HDR system check whether the system record matches its expected
  ** PRL's system table index.
  */
  if( sr_ptr->sys.mode == SD_MODE_HDR )
  {
    if( sdsr_is_same_is856_sid(sr_ptr, sr_ptr->sid_expected.prm.is856.sector_id,
                           sr_ptr->sid_expected.prm.is856.subnet_mask_len) )
    {
      return TRUE;
    }

    return FALSE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* For GSM/WCDMA systems do the following.
  */
  if( sr_ptr->sys.mode == SD_MODE_GSM   ||
      sr_ptr->sys.mode == SD_MODE_WCDMA ||
      sr_ptr->sys.mode == SD_MODE_GW )
  {

    switch ( sr_ptr->sid_expected.net_select_mode )
    {
      case SD_NET_SELECT_MODE_LIMITED:
      case SD_NET_SELECT_MODE_AUTO:
      case SD_NET_SELECT_MODE_HPLMN:
        return TRUE;

      case SD_NET_SELECT_MODE_PRL_SYS:
      case SD_NET_SELECT_MODE_MANUAL_SYS:
      case SD_NET_SELECT_MODE_PRIV_SYS:
        if ( sys_plmn_id_is_undefined( sr_ptr->sid_expected.prm.gwl.plmn.plmn_id ))
        {
          /* Expected SID is wildcard.
          */
          return TRUE;
        }

        /* Expected SID is not wildcard, compare the PLMNs.
        */
        return sys_plmn_match( sr_ptr->sid.plmn.plmn_id,
                               sr_ptr->sid_expected.prm.gwl.plmn.plmn_id
                         );

      case SD_NET_SELECT_MODE_MANUAL_BSSID:
      case SD_NET_SELECT_MODE_MAX:
      default:
        return TRUE;

    } /* switch () */

  } /* if ( sr_ptr->sys.mode == SD_MODE_GSM .. */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If expected SID is equal to SD_WILDCARD_SID or to obtained SID, and
  ** expected NID is equal to SD_WILDCARD_NID or to obtained NID, return
  ** TRUE. Else, return FALSE.
  */
  if( ((sr_ptr->sid_expected.prm.is95.sid == SD_WILDCARD_SID) ||
     (sr_ptr->sid.is95.sid == sr_ptr->sid_expected.prm.is95.sid))
                    &&
    ((sr_ptr->sid_expected.prm.is95.nid == SD_WILDCARD_NID) ||
    (sr_ptr->sid.is95.nid  == sr_ptr->sid_expected.prm.is95.nid))
  )
  {
    return TRUE;
  }


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return FALSE;

} /* sdss_sr_is_sid_match_exp_sid */



/*===========================================================================

FUNCTION sdss_sr_is_sid_match_exp_sid_bid

DESCRIPTION
  Check whether the SID/NID that was obtained during the acquisition matches
  the expected SID/NID.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if SID/NID that was obtained during the acquisition matches the
  expected SID/NID. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean                   sdss_sr_is_sid_match_exp_sid_bid(

        const sdsr_s_type         *sr_ptr
            /* Pointer to a system record for which to check the expected
            ** SID/NID.
            */
)
{

  SD_ASSERT( sr_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If expected SID is equal to SD_WILDCARD_SID or to obtained SID, and
  ** expected NID is equal to SD_WILDCARD_NID or to obtained NID, return
  ** TRUE. Else, return FALSE.
  */
  if(sdss_is_c2k_alt_algr_operation())
  {
    if( ((sr_ptr->sid_expected.prm.is95.sid == SD_WILDCARD_SID) ||
       (sr_ptr->sid.is95.sid == sr_ptr->sid_expected.prm.is95.sid))
                        &&
        ((sr_ptr->sid_expected.prm.is95.nid == SD_WILDCARD_NID) ||
        (sr_ptr->sid.is95.nid  == sr_ptr->sid_expected.prm.is95.nid))
                        &&
        ((!sdss_ptr(SD_SS_MAIN)->is_bid_change) ||
         (!sdss_ptr(SD_SS_MAIN)->is_pref_lte_change ))
    )
    {
      return TRUE;
    }
  }
  else if( ((sr_ptr->sid_expected.prm.is95.sid == SD_WILDCARD_SID) ||
     (sr_ptr->sid.is95.sid == sr_ptr->sid_expected.prm.is95.sid))
                    &&
    ((sr_ptr->sid_expected.prm.is95.nid == SD_WILDCARD_NID) ||
    (sr_ptr->sid.is95.nid  == sr_ptr->sid_expected.prm.is95.nid))
  )
  {
    return TRUE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return FALSE;

} /* sdss_sr_is_sid_match_exp_sid_bid */



/* <EJECT> */
/*===========================================================================

FUNCTION sdss_sr_is_avoid

DESCRIPTION
  Check whether a specified system is to be avoided from acquisition attempts
  at the current time.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the specified system is to be avoided from acquisition attempts
  at or before the current time. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean                   sdss_sr_is_avoid(

        sd_ss_e_type              ss,
            /* System selection stack.
            **
            */
        const sdsr_s_type         *sr_ptr
            /* Pointer to a system record for which to check the avoid
            ** from acquisition attempts status.
            */
)
{

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  SD_ASSERT( sr_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If  the current ss is different from the ss of the avoid.
  ** return FALSE.
  */
  if( sr_ptr->sched_ss != ss )
  {
    return FALSE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If the system is marked avoid from acquisition attempts and the avoid
  ** period did not expired yet, return TRUE. Else, return FALSE.
  */
  if( SDSSSCR_SCHED_IS_AVOID( sr_ptr->sched ) &&
      time_get_uptime_secs() < sr_ptr->sched_prm.avoid_time )
  {
    return TRUE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* As MAP avoidance is taking separate from the other avoidance,
  ** check MAP avoidance as well.
  */
  if( time_get_uptime_secs()  < sr_ptr->max_access_prob.avoid_time )
  {
    return TRUE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return FALSE;

} /* sdss_sr_is_avoid */




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_sr_is_absr

DESCRIPTION
  Check whether a ABSR shall be allowed.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the specified system is to be avoided from acquisition attempts
  at or before the current time. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean                   sdss_sr_is_absr(

        sd_ss_e_type              ss,
            /* System selection stack.
            **
            */
        const sdsr_s_type         *sr_ptr
            /* Pointer to a system record for which to check the avoid
            ** from acquisition attempts status.
            */
)
{

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  SD_ASSERT( sr_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If  the current ss is different from the ss of the avoid.
  ** return FALSE.
  */
  if( sr_ptr->sched_ss != ss )
  {
    return FALSE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If the system is first avoided from acquistion attempts due to MAP and
  ** the avoid period did not expired yet, return TRUE.
  */
  if( sr_ptr->sched ==SDSSSCR_SCHED_AVOID_MAP_UNTIL_ACC_SUCCESS &&
      time_get_uptime_secs() < sr_ptr->sched_prm.avoid_time           &&
      sr_ptr->max_access_prob.absr_cnt > 0 )
  {

    return TRUE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If there is other avoidance and it is till valid, no ABSR is allowed.
  */
  if( SDSSSCR_SCHED_IS_AVOID( sr_ptr->sched ) &&
      time_get_uptime_secs() < sr_ptr->sched_prm.avoid_time )
  {
    return FALSE;
  }


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Otherwise ABSR is allowed.
  */
  if( time_get_uptime_secs()  < sr_ptr->max_access_prob.avoid_time &&
      sr_ptr->max_access_prob.absr_cnt > 0 )
  {
    return TRUE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return FALSE;

} /* sdss_sr_is_absr */




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_sr_is_mode_pref

DESCRIPTION
  Check whether a specified system complies with a specified mode preference.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if system complies with the specified mode preference. FALSE
  otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean                   sdss_sr_is_mode_pref(

        const sdsr_s_type         *sr_ptr,
            /* Pointer to a system record which to check for mode preference
            ** compliance.
            */

        sd_ss_mode_pref_e_type    mode_pref
            /* Mode preference against which to check the system.
            */
)
{
  sd_ss_mode_pref_e_type    mode_mask;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( sr_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( mode_pref, SD_SS_MODE_PREF_MAX );

  if( sr_ptr == NULL )
  {
    sys_err_fatal_null_ptr_exception();
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if( sr_ptr->sys.mode == SD_MODE_GWL )
  {
    #ifdef FEATURE_TDSCDMA
    mode_mask = SD_SS_MODE_PREF_TDS_GSM_WCDMA_LTE;
    #else
    mode_mask = SD_SS_MODE_PREF_GWL;
    #endif
  }
  else if( sr_ptr->sys.mode == SD_MODE_GW )
  {
    #ifdef FEATURE_TDSCDMA
    mode_mask = SD_SS_MODE_PREF_TDS_GSM_WCDMA;
    #else
    mode_mask = SD_SS_MODE_PREF_GW;
    #endif
  }
  else
  {
    mode_mask = (sd_ss_mode_pref_e_type)BM( sr_ptr->sys.mode );
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if( SD_GET_COMMON_MODE(mode_pref, mode_mask ) )
  {
    return TRUE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return FALSE;

} /* sdss_sr_is_mode_pref */



/* <EJECT> */
/*===========================================================================

FUNCTION sdss_sr_is_band_pref

DESCRIPTION
  Check whether a specified system complies with a specified band preference.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if system complies with the specified band preference. FALSE
  otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean                   sdss_sr_is_band_pref(

        const sdsr_s_type         *sr_ptr,
            /* Pointer to a system record which to check for mode preference
            ** compliance.
            */

        sd_ss_band_pref_e_type    band_pref,
            /* Band preference against which to check the system.
            */

        sys_lte_band_mask_e_type    lte_band_pref,
            /* LTE Band preference against which to check the system.
            */

        sd_ss_band_pref_e_type    tds_band_pref, 
            /* TD-SCDMA Band preference against which to check the system.
            */

        sd_ss_e_type              ss
)
{

   SD_ASSERT( sr_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Band not valid for GPS.
  */
  if ( sr_ptr->sys.mode  == SD_MODE_GPS )
  {
    /*
    */
    return TRUE;
  }
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* If MMSS is enabled, ignore TDS band preference
  */
  if (sdss_is_mmss_operation(ss))
  {
    tds_band_pref = SD_SS_BAND_PREF_NONE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* For GW systems, check the band, tds_band
  */
  if (sr_ptr->sys.mode  == SD_MODE_GW)
  {
    if( SD_BAND_CONTAIN( band_pref, sr_ptr->sys.band )
        #ifdef FEATURE_TDSCDMA
        || SD_BAND_CONTAIN( tds_band_pref, sr_ptr->sys.tds_band )
        #endif
       )
    {
        return TRUE;
    }
    return FALSE;
  }

  /* For GWL systems, check the band, lte_band
  */
  if (sr_ptr->sys.mode  == SD_MODE_GWL)
  {
    sys_lte_band_mask_e_type lte_and_pref_local1 = sdsr_map_sys_rec_lte_band_to_lte_band_pref( sr_ptr->sys.lte_band );
    sys_lte_band_mask_e_type lte_and_pref_local2 = SYS_LTE_BAND_MASK_COMMON( &lte_band_pref, &lte_and_pref_local1);

    if(  !SYS_LTE_BAND_MASK_CHK_IF_EMPTY(&lte_and_pref_local2) ||
        #ifdef FEATURE_TDSCDMA
        SD_BAND_CONTAIN( tds_band_pref, sr_ptr->sys.tds_band ) ||
        #endif
        SD_BAND_CONTAIN( band_pref,     sr_ptr->sys.band )
       )
    {
        return TRUE;
    }
    return FALSE;
  }

  /* For TD-SCDMA systems , check the tds_band_pref
  */
  if (sr_ptr->sys.mode  == SD_MODE_TDS)
  {
    if( SD_BAND_CONTAIN( tds_band_pref, sr_ptr->sys.tds_band )  )
    {
        return TRUE;
    }
    return FALSE;
  }

  /* For non GWL systems just check the band_pref
  */
  if( SD_BAND_CONTAIN( band_pref, sr_ptr->sys.band ) )
  {
    return TRUE;
  }
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  return FALSE;

} /* sdss_sr_is_band_pref */

/*===========================================================================

FUNCTION sdss_sr_is_pref_conf0

DESCRIPTION
  Check whether a specified system conflicts with the current system
  selection preference (i.e., mode, band and roam preference).

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if system conflicts with the current system selection preference (as
  per the pref_conf category parameter). FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
boolean                   sdss_sr_is_pref_conf0(

        const sd_ss_e_type        ss,
            /* System selection stack.
            */

        const sdsr_s_type         *sr_ptr,
            /* Pointer to a system record for which to check SS-Preference
            ** conflict.
            */

        sdss_pref_conf_e_type     pref_conf,
            /* SS-Preference conflict category to be evaluated.
            */

        boolean                  debug_needed
)
{
  boolean                 is_pref_conflict  = FALSE;
  sd_ss_mode_pref_e_type  mode_pref         = SD_SS_MODE_PREF_NONE;
  sd_ss_band_pref_e_type  band_pref         = SD_SS_BAND_PREF_NONE;
  sys_lte_band_mask_e_type  lte_band_pref   = SYS_LTE_BAND_MASK_CONST_NONE;
  sd_ss_band_pref_e_type  tds_band_pref     = SD_SS_BAND_PREF_NONE;

  sd_ss_mode_pref_e_type  ss_mode_pref      = SD_SS_MODE_PREF_NONE;
  sd_ss_band_pref_e_type  ss_band_pref      = SD_SS_BAND_PREF_NONE;
  sys_lte_band_mask_e_type  ss_lte_band_pref= SYS_LTE_BAND_MASK_CONST_NONE;
  sd_ss_band_pref_e_type  ss_tds_band_pref  = SD_SS_BAND_PREF_NONE;

  sdss_s_type             *ss_ptr           = sdss_ptr(ss);
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( ss_ptr != NULL );
  SD_ASSERT( sr_ptr != NULL );

  if( sr_ptr == NULL )
  {
    SD_ERR_0("sr_ptr is null");
    return FALSE;
  }
  SD_ASSERT_ENUM_IS_INRANGE( pref_conf, SDSS_PREF_CONF_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  sdss_get_mode_band_pref( ss,
                           &ss_mode_pref,
                           &ss_band_pref,
                           &ss_lte_band_pref,
                           &ss_tds_band_pref );

  band_pref      = ss_band_pref;
  lte_band_pref  = ss_lte_band_pref;
  tds_band_pref  = ss_tds_band_pref;

  /* If requested, check for mode preference conflict.
  */
  if( SDSS_PREF_CONTAIN( pref_conf, SDSS_PREF_CONF_MODE ) )
  {

    if (sdsr_list_find( SDSR_GWL_LTD_LST, sr_ptr ) == SDSR_POS_NULL )
    {
      mode_pref = ss_mode_pref;
    }
    else
    {
      /* System record is part of SDSR_GW_LTD_LST that means SIM status
      ** is not available .So take true_mode_pref into consideration.
      */
       mode_pref = sdss_get_true_mode_pref(ss);
    }

    if( ! sdss_sr_is_mode_pref( sr_ptr, mode_pref ) )
    {
      if(debug_needed)
      {
        SD_MSG_HIGH_2("Sr conflicts mode pref=%d, mode=%d",
                  ss_mode_pref, sr_ptr->sys.mode);
      }
      is_pref_conflict = TRUE;
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If requested, check for band preference conflict.
  */
  if( !is_pref_conflict &&
    SDSS_PREF_CONTAIN( pref_conf, SDSS_PREF_CONF_BAND ) )
  {
    if( ! (sdss_sr_is_band_pref(sr_ptr,
                                ss_band_pref,
                                ss_lte_band_pref,
                                ss_tds_band_pref,
                                ss) )
      )
    {
      if(debug_needed)
      {
        SD_MSG_HIGH_4("Sr conflicts band pref=0x%lx, tds_band_pref=0x%lx, band=%d,TDS_bands = %d",
                  ss_band_pref, ss_tds_band_pref,sr_ptr->sys.band,sr_ptr->sys.tds_band );
        sd_print_lte_band_mask(ss_lte_band_pref);
        sd_print_lte_band_mask(sdsr_map_sys_rec_lte_band_to_lte_band_pref(sr_ptr->sys.lte_band));

      }
      /*lint !e559 */
      is_pref_conflict = TRUE;
    }
  }
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if( !is_pref_conflict &&
    SDSS_PREF_CONTAIN( pref_conf, SDSS_PREF_CONF_MODE_OR_BAND ) )
  {

    /* Filters the system band within the mode preference.
    */
    band_pref = sdss_get_supp_mode_band_pref(mode_pref,sr_ptr->sys.band);

    lte_band_pref = sdss_get_supp_mode_band_pref_lte(mode_pref,
                      sdsr_map_sys_rec_lte_band_to_lte_band_pref(sr_ptr->sys.lte_band));

    tds_band_pref = sdss_get_supp_mode_band_pref_tds(mode_pref,sr_ptr->sys.tds_band);

    if(band_pref     == SD_SS_BAND_PREF_NONE &&
       SYS_LTE_BAND_MASK_CHK_IF_EMPTY(&lte_band_pref) &&
       tds_band_pref == SD_SS_BAND_PREF_NONE)
    {
      is_pref_conflict = TRUE;
      if(debug_needed)
      {
        SD_MSG_HIGH_5("Sr conflicts mode %d band pref=0x%lx, band=%d, TDS band pref=0x%lx, band=%d LTE BAND PREF:",
                   ss_mode_pref, ss_band_pref, sr_ptr->sys.band,
                   ss_tds_band_pref, sr_ptr->sys.tds_band);
        sd_print_lte_band_mask(sdsr_map_sys_rec_lte_band_to_lte_band_pref(sr_ptr->sys.lte_band));
        sd_print_lte_band_mask(ss_lte_band_pref);


      }
    }
  }


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If requested, check for roam preference conflict.
  ** But if the mode of acquired system is GSM/WCDMA/WLAN, ignore the roam
  ** preference.
  */
  if( !is_pref_conflict                                   &&
      SDSS_PREF_CONTAIN( pref_conf, SDSS_PREF_CONF_ROAM ) &&
      !SD_IS_BIT_CONTAIN(sdss_map_mode_to_mode_pref(sr_ptr->sys.mode),
                            SD_SS_MODE_PREF_TDS_GSM_WCDMA_LTE))
  {
    switch (ss_ptr->roam_pref)
    {
      case SD_SS_ROAM_PREF_ANY:
        break;

      case SD_SS_ROAM_PREF_ROAM_ONLY:
        if (sdprl_roam_ind_map_custom_home_to_home(sr_ptr->roam) ==
          SYS_ROAM_STATUS_OFF)
        {
          is_pref_conflict = TRUE;
        }
        break;

      case SD_SS_ROAM_PREF_HOME:
      case SD_SS_ROAM_PREF_AFFIL:
        /*lint -e701 shift left  of signed quantity  */
        if (! SD_IS_BIT_CONTAIN( ss_ptr->roam_pref,
            BM(sdprl_roam_ind_map_custom_home_to_home(sr_ptr->roam))))/*lint -e701 shift left  of signed quantity  */
        {
          is_pref_conflict = TRUE;
        }
        break;

      case SD_SS_ROAM_PREF_MAX:
      default:
        SD_ERR_0 ("Invalid roam pref");
        break;
    }

    if(is_pref_conflict && debug_needed)
    {
      SD_MSG_HIGH_3("Sr conflicts roam pref=%d, roam=%d, is_pref_conflict=%d",
        ss_ptr->roam_pref, sr_ptr->roam,is_pref_conflict);
    }


  }


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If requested, check for prl preference conflict.
  */

    if( !is_pref_conflict &&
      SDSS_PREF_CONTAIN( pref_conf, SDSS_PREF_CONF_PRL ) &&
      sr_ptr->sys.mode != SD_MODE_GWL )
    {
      sd_blksys_e_type     blksys;
      blksys = sd_map_chan_to_blksys( sr_ptr->sys.mode,
                                         sdss_map_band_pref_to_band(sr_ptr->sys.band),
                                         sr_ptr->sys.chan
                                       );
      switch ( ss_ptr->prl_pref )
      {
        case SD_SS_PRL_PREF_AVAIL_BC0_A:
          if( blksys != SD_BLKSYS_CELL_A )
          {
            is_pref_conflict = TRUE;
          }
          break;

        case SD_SS_PRL_PREF_AVAIL_BC0_B:
          if( blksys != SD_BLKSYS_CELL_B )
          {
            is_pref_conflict = TRUE;
          }
          break;

        case SD_SS_PRL_PREF_NONE:
        case SD_SS_PRL_PREF_ANY:
        case SD_SS_PRL_PREF_MAX:
        default:
          break;
      }

      if(is_pref_conflict && debug_needed)
      {
        SD_MSG_HIGH_3("Sr conflicts prl pref=%d, blksys=%d is_pref_conflict%d",
                      ss_ptr->prl_pref, blksys,is_pref_conflict);
      }

    }


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If the pref_conf category is CONF_NONE negate the return value;
  */
  if( pref_conf == SDSS_PREF_CONF_NONE )
  {
    is_pref_conflict = !is_pref_conflict;
  }

  return SD_BOOLEAN( is_pref_conflict );

} /* sdss_sr_is_pref_conf0 */




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_sr_is_pref_conf

DESCRIPTION
  Check whether a specified system conflicts with the current system
  selection preference (i.e., mode, band and roam preference).

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if system conflicts with the current system selection preference (as
  per the pref_conf category parameter). FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean                   sdss_sr_is_pref_conf(

        sd_ss_e_type              ss,
            /* System selection stack.
            */

        const sdsr_s_type         *sr_ptr,
            /* Pointer to a system record for which to check SS-Preference
            ** conflict.
            */

        sdss_pref_conf_e_type     pref_conf
            /* SS-Preference conflict category to be evaluated.
            */
)
{

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  SD_ASSERT( sr_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( pref_conf, SDSS_PREF_CONF_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return sdss_sr_is_pref_conf0( ss, sr_ptr, pref_conf , TRUE);

} /* sdss_sr_is_pref_conf */




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_sr_is_prl

DESCRIPTION
  Check whether a system complies with a specific PRL designation value.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the system complies with the PRL specified designation value.
  FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean                   sdss_sr_is_prl(

        const sdsr_s_type         *sr_ptr,
            /* Pointer to a system record for which to check PRL designation.
            */

        sdss_prl_val_e_type       prl_desig_val
            /* PRL designation value against which to checked.
            */
)
{

  SD_ASSERT( sr_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( prl_desig_val, SDSS_PRL_VAL_MAX );


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If the system complies with the PRL designation category, return TRUE.
  ** Else, return FALSE.
  */
  if( SD_IS_BIT_CONTAIN(prl_desig_val,BM(sr_ptr->prl)) )
  {
    return TRUE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_MSG_HIGH_3( "Sr conflicts prl desig=%d, prl=%d, sr mode=%d ",
                prl_desig_val, BM(sr_ptr->prl), sr_ptr->sys.mode);

  return FALSE;

} /* sdss_sr_is_prl */


/*===========================================================================

FUNCTION sdss_is_sr_associated

DESCRIPTION
  Check if system record in first parameter is associated with any other PRL
  system. Usually HDR systems are associated with a CDMA system.
  If association tag is YES, then proceed to check if system record is
  associated with CDMA system.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if sr_ptr is associated with valid CDMA sys.
  FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
boolean                   sdss_is_sr_associated(

        const sdsr_s_type         *sr_ptr,
            /* Pointer to a system record for which to check PRL association.
            */

        const sdsr_s_type         *cdma_sr_ptr
            /* CDMA system record with which association needs to be checked.
            */
)
{

  SD_ASSERT( sr_ptr != NULL );

  if(!SDSR_PRL_ASSN_GET(sr_ptr->prl_assn, SDSR_PRL_ASSN_TAG))
  {
    /* If a HDR record has association tag set to "No". This means it is
       not associated with any other 1x systems. So even when there is
       no 1x service, as long as orig mode is collocated, then
       non-associated systems are not fit to provide srv. */
    return FALSE;
  }

  if(cdma_sr_ptr == NULL)
  {
    /* If No CDMA system is acquired, then by default sr_ptr is associated.
    */
    return TRUE;
  }

  /* Check if both system records are associated */
  return sdprl_is_associated(sr_ptr, cdma_sr_ptr);

}/* sdss_is_sr_associated */

/* <EJECT> */
/*===========================================================================
=============================================================================
=============================================================================
======================== SYSTEM RECORD LIST SUPPORT =========================
=============================================================================
=============================================================================
===========================================================================*/


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_sr_list_map2

DESCRIPTION
  Map list to the appropriate list according to the input system selection.

DEPENDENCIES
  None.

RETURN VALUE
  Mapped system record list.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sdsr_e_type             sdss_sr_list_map2(

        sd_ss_e_type            ss,
          /* System selection stack.
          */

        sdsr_e_type             list
            /* List for which to check the mode designation.
            */
)
{
  return sdss_sr_list_map( sdss_ptr(ss), list );
}




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_event_map

DESCRIPTION
  Map event to the appropriate event according to the input event and stack id

DEPENDENCIES
  None.

RETURN VALUE
  Mapped system record list.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sdss_evt_e_type             sdss_event_map(

        const sd_ss_e_type       ss,
          /* System selection stack.
          */

        sdss_evt_e_type       event
            /* SS-Event to map */
)
{
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( event, SDSS_EVT_MAX);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* For MAIN system selection, there is no need to map list.
  */
  if( ss != SD_SS_HYBR_2 && ss != SD_SS_HYBR_3)
  {
    return event;
  }
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  if (ss == SD_SS_HYBR_2)
  {
  if(!sdss_is_featuremode(SYS_OVERALL_FEATURE_MODE_NORMAL))
  {
    switch(event)
    {
      case SDSS_EVT_USER_PWR_UP:
        return SDSS_EVT_HYBR_2_USER_PWR_UP;
      case SDSS_EVT_USER_OFFLINE_CDMA:
        return SDSS_EVT_HYBR_2_USER_OFFLINE_CDMA;
      case SDSS_EVT_USER_PWR_SAVE_EXIT:
        return SDSS_EVT_HYBR_2_USER_PWR_SAVE_EXIT;
      case SDSS_EVT_USER_SS_PREF:
        return SDSS_EVT_HYBR_2_USER_SS_PREF;
      case SDSS_EVT_USER_NAM_SEL:
        return SDSS_EVT_HYBR_2_USER_SS_PREF;
      case SDSS_EVT_USER_PWR_DOWN:
        return SDSS_EVT_HYBR_2_USER_PWR_DOWN;
      case SDSS_EVT_USER_GET_NET_GW:
        return SDSS_EVT_HYBR_2_USER_GET_NET_GW;
      case SDSS_EVT_USER_TERM_GET_NET_GW:
        return SDSS_EVT_HYBR_2_USER_TERM_GET_NET_GW;
      case SDSS_EVT_USER_PROT_DEACTIVATE:
        return SDSS_EVT_HYBR_2_USER_PROT_DEACTIVATE;

      case SDSS_EVT_GWL_ACQ_PLMN_FAILED:
        return SDSS_EVT_HYBR_2_GW_ACQ_PLMN_FAILED;
      case SDSS_EVT_GWL_ACQ_PLMN_SUCCESS:
        return SDSS_EVT_HYBR_2_GW_ACQ_PLMN_SUCCESS;
      case SDSS_EVT_GWL_OPR_SYS_LOST:
        return SDSS_EVT_HYBR_2_GW_OPR_SYS_LOST;
      case SDSS_EVT_GWL_OPR_SRV_INFO:
        return SDSS_EVT_HYBR_2_GW_OPR_SRV_INFO;
      case SDSS_EVT_GWL_OPR_ACC_DONE:
        return SDSS_EVT_HYBR_2_GW_OPR_ACC_DONE;

      default:
        break;
    }
  }
  }
  else if (ss == SD_SS_HYBR_3)
  {

    #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
    switch(event)
    {
      case SDSS_EVT_USER_PWR_UP:     return SDSS_EVT_HYBR_3_USER_PWR_UP;
      case SDSS_EVT_USER_OFFLINE_CDMA: return SDSS_EVT_HYBR_3_USER_OFFLINE_CDMA;
      case SDSS_EVT_USER_PWR_SAVE_EXIT: return SDSS_EVT_HYBR_3_USER_PWR_SAVE_EXIT;
      case SDSS_EVT_USER_SS_PREF: return SDSS_EVT_HYBR_3_USER_SS_PREF;
      case SDSS_EVT_USER_NAM_SEL: return SDSS_EVT_HYBR_3_USER_SS_PREF;
      case SDSS_EVT_USER_PWR_DOWN: return SDSS_EVT_HYBR_3_USER_PWR_DOWN;
      case SDSS_EVT_USER_GET_NET_GW: return SDSS_EVT_HYBR_3_USER_GET_NET_GW;
      case SDSS_EVT_USER_TERM_GET_NET_GW: return SDSS_EVT_HYBR_3_USER_TERM_GET_NET_GW;
      case SDSS_EVT_USER_PROT_DEACTIVATE: return SDSS_EVT_HYBR_3_USER_PROT_DEACTIVATE;

      case SDSS_EVT_GWL_ACQ_PLMN_FAILED: return SDSS_EVT_HYBR_3_GW_ACQ_PLMN_FAILED;
      case SDSS_EVT_GWL_ACQ_PLMN_SUCCESS: return SDSS_EVT_HYBR_3_GW_ACQ_PLMN_SUCCESS;
      case SDSS_EVT_GWL_OPR_SYS_LOST: return SDSS_EVT_HYBR_3_GW_OPR_SYS_LOST;
      case SDSS_EVT_GWL_OPR_SRV_INFO: return SDSS_EVT_HYBR_3_GW_OPR_SRV_INFO;
      case SDSS_EVT_GWL_OPR_ACC_DONE: return SDSS_EVT_HYBR_3_GW_OPR_ACC_DONE;

      default:
        break;
    }
    #endif
  }
  return event;
}//sdss_event_map
/*lint +esym(550, ss_ptr) */


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_sr_list_is_mode

DESCRIPTION
  Check whether a specified mode value includes the mode designation of at
  least one of the systems that are referenced by a specified list.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the specified mode value includes the mode designation of at least
  one of the systems that are referenced by the specified list. FALSE
  otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean                       sdss_sr_list_is_mode(

        sdsr_e_type                   list,
            /* List for which to check the mode designation.
            */

        sd_mode_e_type                mode_val
            /* Mode value against which to compare.
            */
)
{
  int                 i;
  sdsr_s_type         *sr_ptr;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( list, SDSR_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( mode_val, SD_MODE_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Step through the list and return TRUE if the specified mode value
  ** includes the mode designation of any of the systems that are referenced
  ** by this list. Else, return FALSE.
  */
  for( i=0; (sr_ptr=sdsr_list_get_ptr(list, i)) != NULL; i++ )
  {
    if( mode_val == sr_ptr->sys.mode )
    {
      return TRUE;
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return FALSE;

} /* sdss_sr_list_is_mode */



/*===========================================================================

FUNCTION sdss_sr_list_is_mode_pref

DESCRIPTION
  Check whether a specified mode value includes the mode designation of at
  least one of the systems that are referenced by a specified list.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the specified mode value includes the mode designation of at least
  one of the systems that are referenced by the specified list. FALSE
  otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean                       sdss_sr_list_is_mode_pref(

        sdsr_e_type                   list,
            /* List for which to check the mode designation.
            */

        sd_ss_mode_pref_e_type        mode_pref
            /* Mode value against which to compare.
            */
)
{
  int                 i;
  sdsr_s_type         *sr_ptr;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( list, SDSR_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( mode_pref, SD_SS_MODE_PREF_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Step through the list and return TRUE if the specified mode value
  ** includes the mode designation of any of the systems that are referenced
  ** by this list. Else, return FALSE.
  */
  for( i=0; (sr_ptr=sdsr_list_get_ptr(list, i)) != NULL; i++ )
  {
    if( sdss_sr_is_mode_pref(sr_ptr,mode_pref))
    {
      return TRUE;
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return FALSE;

} /* sdss_sr_list_is_mode */


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_sr_list_is_band

DESCRIPTION
  Check whether a specified band value includes the band designation of at
  least one of the systems that are referenced by a specified list.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the specified band value includes the band designation of at least
  one of the systems that are referenced by the  specified list. FALSE
  otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean                       sdss_sr_list_is_band(

        sdsr_e_type                   list,
            /* List for which to check the band designation.
            */

        sd_band_e_type                band_val
            /* Band value against which to compare.
            */
)
{
  int                                 i;
  sdsr_s_type                         *sr_ptr;
  sd_ss_band_pref_e_type              band_pref;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( list, SDSR_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( band_val, SD_BAND_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Step through the list and return TRUE if the specified band value
  ** includes the band designation of any of the systems that are referenced
  ** by this list. Else, return FALSE.
  */
  band_pref = sd_map_band_to_band_pref(band_val);

  for( i=0; (sr_ptr=sdsr_list_get_ptr(list, i)) != NULL; i++ )
  {
    if( sr_ptr->sys.band == band_pref )
    {
      return TRUE;
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return FALSE;

} /* sdss_sr_list_is_band */




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_sr_list_is_prl

DESCRIPTION
  Check whether a specified PRL value includes the PRL designation of at
  least one of the systems that are referenced by a specified list.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the specified PRL value includes the PRL designation of at least
  one of the systems that are referenced by the specified list. FALSE
  otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean                       sdss_sr_list_is_prl(

        sdsr_e_type                   list,
            /* List for which to check the PRL designation.
            */

        sdss_prl_val_e_type           prl_val
            /* PRL value against which to compare.
            */
)
{
  int                 i;
  sdsr_s_type         *sr_ptr;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( list, SDSR_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( prl_val, SDSS_PRL_VAL_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Step through the list and return TRUE if the specified PRL value
  ** includes the PRL designation of any of the systems that are referenced
  ** by this list. Else, return FALSE.
  */
  for( i=0; (sr_ptr=sdsr_list_get_ptr(list, i)) != NULL; i++ )
  {
    if( sdss_sr_is_prl(sr_ptr, prl_val) )
    {
      return TRUE;
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return FALSE;

} /* sdss_sr_list_is_prl */




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_sr_list_is_net_sel

DESCRIPTION
  Check whether a specified network selection mode value equals the network
  selection mode of at least one of the systems that are referenced by a
  specified list.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the specified network selection mode value equals the network
  selection mode of at least one of the systems that are referenced by the
  specified list. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean                       sdss_sr_list_is_net_sel(

        sdsr_e_type                   list,
            /* List for which to check the network selection mode.
            */

        sd_net_select_mode_e_type     net_sel
            /* Network selection mode against which to compare.
            */
)
{
  int                 i;
  sdsr_s_type         *sr_ptr;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( list, SDSR_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( net_sel, SD_NET_SELECT_MODE_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Step through the list and return TRUE if the specified network selection
  ** mode equals the network selection mode of any of the systems that are
  ** referenced by this list. Else, return FALSE.
  */
  for( i=0; (sr_ptr=sdsr_list_get_ptr(list, i)) != NULL; i++ )
  {
    if( sr_ptr->sid_expected.net_select_mode == net_sel )
    {
      return TRUE;
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return FALSE;

} /* sdss_sr_list_is_net_sel */


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_sr_list_is_last_act_net_sel

DESCRIPTION
  Check whether a specified network selection mode value equals the network
  selection mode sent to NAS

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the specified network selection mode value equals the network
  selection mode of at least one of the systems that are referenced by the
  specified list. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean                       sdss_sr_list_is_last_act_net_sel(

        sys_network_selection_mode_e_type     net_sel,
            /* Network selection mode against which to compare.
            */

        sd_ss_e_type                          ss
            /* return the last net_sel_mode acquisition
            */
)
{
  return sd_misc_get_act_net_sel(ss) == net_sel;
} /* sdss_sr_list_is_net_sel */


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_sr_list_is_pref_conf

DESCRIPTION
  Check whether a any of the systems that are referenced by the specified
  list conflicts with the current system selection preference (i.e., mode,
  band and roam preference).

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if any of the systems that are referenced by the specified list
  conflicts (as per the pref_conf_val parameter) with the current system
  selection preference.

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean                       sdss_sr_list_is_pref_conf(

        sd_ss_e_type                  ss,
          /* System selection stack.
          */

        sdsr_e_type                   list,
            /* List for which to check the SS-Preference conflict
            */

        sdss_pref_conf_e_type         pref_conf_val
            /* SS-Prereference conflict value against which to compare.
            */
)
{
  int                 i;
  sdsr_s_type         *sr_ptr;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( list, SDSR_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( pref_conf_val, SDSS_PREF_CONF_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If the pref_conf category is CONF_NONE negate the return value;
  */
  if( pref_conf_val == SDSS_PREF_CONF_NONE )
  {
    /* Step through the list and return FALSE if the specified SS-Preference
    ** conflicts with any of the systems that are referenced by this list.
    ** Else, return TRUE.
    */
    for( i=0; (sr_ptr=sdsr_list_get_ptr(list, i)) != NULL; i++ )
    {
      if( sdss_sr_is_pref_conf(ss, sr_ptr, SDSS_PREF_CONF_ANY) )
      {
        return FALSE;
      }
    }

    return TRUE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Step through the list and return TRUE if any of the systems that are
  ** referenced by this list conflicts with the SS-Preference as per the
  ** specified pref_conf_val. Else, return FALSE.
  */
  for( i=0; (sr_ptr=sdsr_list_get_ptr(list, i)) != NULL; i++ )
  {
    if( sdss_sr_is_pref_conf(ss, sr_ptr, pref_conf_val) )
    {
      return TRUE;
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return FALSE;

} /* sdss_sr_list_is_pref_conf */

/*===========================================================================

FUNCTION sdss_srv_sys_is_pref_conf

DESCRIPTION
  Check whether the current serving system conflicts with system preferences

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if there is a pref conflict
 
SIDE EFFECTS
  None.
 
 ===========================================================================*/
EXTERN  boolean                   sdss_srv_sys_is_pref_conf(

        const sd_ss_e_type        ss
            /* System selection stack.
            */

)
{
  sd_si_info_s_type       *si_info_ptr     = &sd_si_ptr(ss)->si_info;
  sd_sid_plmn_s_type      sid_exp;
  sdsr_e_type             list;
  sd_ss_band_pref_e_type  band_pref        = SD_SS_BAND_PREF_NONE;
  sys_lte_band_mask_e_type  lte_band_pref  = SYS_LTE_BAND_MASK_CONST_NONE;
  sd_ss_band_pref_e_type  tds_band_pref    = SD_SS_BAND_PREF_NONE;
  sdss_s_type *           ss_ptr           = sdss_ptr(ss);


  SD_MSG_HIGH_3("PREF_CONF: srv_status=%d, mode_pref=%d, mode=%d",
                si_info_ptr->srv_status,
                ss_ptr->mode_pref,
                si_info_ptr->mode);

  /* If there is no service or if the current srv mode is not part of
  ** new ss_ptr mode pref , do not check if serving system is in
  ** conflict ( since SRV SYS is not valid).
  */
  if ( !sys_srv_status_is_srv(si_info_ptr->srv_status ) ||
       !(SD_IS_BIT_CONTAIN (ss_ptr->mode_pref ,sdss_map_mode_to_mode_pref(si_info_ptr->mode))))
  {
    SD_MSG_HIGH_0("no srv or mode pref conflict with srv_mode");
    return TRUE;
  }

  /* if there is 3GPP service, check the currently acquired mode and band
  ** instead of all the serving system bands and modes.
  ** to see if the mode/band conflicts with preferences
  */

  switch (si_info_ptr->mode)
  {
     case SD_MODE_CDMA:
     case SD_MODE_HDR:
       list = sdss_sr_list_map2(ss, SDSR_SRV_SYS) ;
       break;
     default:
       list = sdss_sr_list_map2(ss, SDSR_BACKUP_LST) ;
       memset(&sid_exp,0, sizeof(sid_exp));
       sid_exp.net_select_mode = SD_NET_SELECT_MODE_AUTO;
       sid_exp.prm.gwl.plmn.lac = PRL_WILDCARD_LAC;
       sys_plmn_undefine_plmn_id(&(sid_exp.prm.gwl.plmn.plmn_id));
       sid_exp.prm.gwl.num_rats = 1;
       sid_exp.prm.gwl.gwl_pri_lst[0] = si_info_ptr->mode;
       sdsr_list_clr( list );
       switch(si_info_ptr->mode)
       {
          case SD_MODE_TDS:
            tds_band_pref = sd_map_band_to_band_pref_tds(si_info_ptr->band);
            break;
          case SD_MODE_LTE:
            lte_band_pref = sd_map_band_to_band_pref_lte(si_info_ptr->band);
            break;
          default:
            band_pref = sd_map_band_to_band_pref(si_info_ptr->band);
            break;
       }


       sdsr_list_store_and_app3( list,
                             SDSR_MAX,
                             SDSR_MAX,
                             SD_MODE_GWL,
                             band_pref,
                             sdsr_map_lte_band_pref_to_sys_rec_lte_band(lte_band_pref),
                             tds_band_pref,
                             0,
                             &sid_exp,
                             SD_NO_CHANGE_SYS_IDX );
       break;

  } //switch( si_info_ptr->mode)

  /* Check if SRV SYS ( in case of 3GPP2) or  currently acquired 3GPP mode/band
  ** is in conflict with SS preferences
  */
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  if( sdss_sr_list_is_pref_conf(
                        ss,
                        list,
                        SDSS_PREF_CONF_ANY) ) 
  {
    return TRUE;
  }

  return FALSE;
}


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_sr_list_is_sid

DESCRIPTION
  Check whether at least one of the systems that are referenced by the
  specified system record match the input sid condition.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if at least one of the systems that are referenced by the specified
  system record list match the input sid condition. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean                       sdss_sr_list_is_sid(

        sdsr_e_type                   list,
            /* System record list for which to check sid condition.
            */

        sdssscr_sid_cond_e_type       sid_cond
            /* SID condition to be checked.
            */
)
{
  int                 i;
  sdsr_s_type         *sr_ptr;
  sdsr_s_type         *cdma_idl_sys_ptr =
                                  sdsr_list_get_ptr( SDSR_CDMA_IDL_SYS, 0 );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( list, SDSR_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( sid_cond, SDSSSCR_SID_COND_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Step through the list and return TRUE if at least one of the systems
  ** match the input SID condition.
  */
  for( i=0; (sr_ptr=sdsr_list_get_ptr(list, i)) != NULL; i++ )
  {
    switch( sid_cond )
    {
      case SDSSSCR_SID_COND_EXPECTED:
        if( sdss_sr_is_sid_match_exp_sid(sr_ptr) )
        {
          return TRUE;
        }
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_SID_COND_NOT_EXPECTED:
        if( !sdss_sr_is_sid_match_exp_sid(sr_ptr) )
        {
          return TRUE;
        }
        break;

      case SDSSSCR_SID_COND_NOT_EXPECTED_WITH_BID:
        if( !sdss_sr_is_sid_match_exp_sid_bid(sr_ptr) )
        {
          return TRUE;
        }
       break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_SID_COND_COLLOC_IDL_SYS:

        if( sdss_is_sr_associated(sr_ptr, cdma_idl_sys_ptr))
        {
          return TRUE;
        }
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_SID_COND_MAX:
      default:
        SD_ERR_0( "sid_cond");
        break;

    } /* switch */

  } /* for */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If we got here, SID condition did not match with any of the systems in
  ** the list - return FALSE.
  */
  return FALSE;

} /* sdss_sr_list_is_sid */




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_sr_list_is_cnt

DESCRIPTION
  Check whether a specified list contains CNT or more/less/exactly systems
  that comply with the cnt_inc count inclusion criteria.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the specified list contains CNT or more/less/exactly elements that
  are currently available for acquisition attempts. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean                       sdss_sr_list_is_cnt(

       sd_ss_e_type                   ss,
          /* System selection stack.
          */

        sdsr_e_type                   list,
            /* List for which to check the CNT.
            */

        int                           cnt_val,
            /* CNT value against which to compare.
            */

        sdssscr_cnt_cond_e_type       cnt_cond,
            /* CNT condition to be used in the comparison.
            */

        sdssscr_cnt_inc_e_type        cnt_inc
            /* CNT inclusion to be used in the comparison.
            */
)
{
  int                 i;
  sdsr_s_type         *sr_ptr;
  int                 cnt           = 0;
  byte                new_acq_cnt;
  sdss_s_type         *ss_ptr;
  sdsr_s_type              sr;
  sd_ss_mode_pref_e_type   ss_mode_pref      = SD_SS_MODE_PREF_NONE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( list, SDSR_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( cnt_cond, SDSSSCR_CNT_COND_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( cnt_inc, SDSSSCR_CNT_INC_MAX );

  ss_ptr = sdss_ptr( ss );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  new_acq_cnt = ss_ptr->new_acq_cnt;

  sdss_get_mode_band_pref( ss,
                          &ss_mode_pref,
                           NULL,
                           NULL,
                           NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Step through the list and count the number of systems that complies
  ** with the specified count inclusion criteria, cnt_inc.
  */
  for( i=0; (sr_ptr=sdsr_list_get_ptr(list, i)) != NULL; i++ )
  {
    switch( cnt_inc )
    {
      case SDSSSCR_CNT_INC_ALL:
        cnt++;
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CNT_INC_COMPLY:
        sr.sys = sr_ptr->sys;
        sdss_filter_sr_with_supported_band_mode(&sr, ss_mode_pref);

        if( sdss_is_supp_mode_band(sr_ptr->sys.mode,
                                   sr_ptr->sys.band,
                                   sdsr_map_sys_rec_lte_band_to_lte_band_pref(sr_ptr->sys.lte_band),
                                   sr_ptr->sys.tds_band) &&
            !sdss_sr_is_pref_conf0(ss,
                                   &sr,
                                   SDSS_PREF_CONF_MODE_OR_BAND,
                                   FALSE) )
        {
          cnt++;
        }
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CNT_INC_AVAIL:
        if( sdss_is_supp_mode_band(sr_ptr->sys.mode,
                                   sr_ptr->sys.band,
                                   sdsr_map_sys_rec_lte_band_to_lte_band_pref(sr_ptr->sys.lte_band),
                                   sr_ptr->sys.tds_band) &&
            !sdss_sr_is_pref_conf0(ss,
                                   sr_ptr,
                                   SDSS_PREF_CONF_MODE_OR_BAND,
                                   FALSE) &&
            !sdss_sr_is_avoid( ss, sr_ptr ))
        {
          cnt++;
        }
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CNT_INC_NEW:
      {
        sr.sys = sr_ptr->sys;
        sdss_filter_sr_with_supported_band_mode(&sr, ss_mode_pref);

        if( sdss_is_supp_mode_band(sr_ptr->sys.mode,
                                   sr_ptr->sys.band,
                                   sdsr_map_sys_rec_lte_band_to_lte_band_pref(sr_ptr->sys.lte_band),
                                   sr_ptr->sys.tds_band) &&
            !sdss_sr_is_pref_conf0(ss,
                                   &sr,
                                   SDSS_PREF_CONF_MODE_OR_BAND,
                                   FALSE) &&
            !sdss_sr_is_avoid(ss, sr_ptr) &&
            sr_ptr->new_acq_cnt != new_acq_cnt )
        {
          cnt++;
        }
        break;
      }
      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CNT_INC_ABSR:
        if( sdss_sr_is_avoid(ss, sr_ptr) &&
            sr_ptr->sched == SDSSSCR_SCHED_AVOID_MAP_UNTIL_ACC_SUCCESS &&
            sr_ptr->max_access_prob.absr_cnt > 0 )
        {
          cnt++;
        }
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CNT_INC_MAX:
      default:
        SD_ERR_0( "cnt_inc");
        break;

    } /* switch */

  } /* for */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If cnt is within the range that is specified by cnt_cond and cnt_val,
  ** return TRUE. Else, return FALSE.
  */
  if( (cnt_cond == SDSSSCR_CNT_COND_EXACTLY && cnt == cnt_val) ||
      (cnt_cond == SDSSSCR_CNT_COND_OR_MORE && cnt >= cnt_val) ||
      (cnt_cond == SDSSSCR_CNT_COND_OR_LESS && cnt <= cnt_val) )
  {
    return TRUE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return FALSE;

} /* sdss_sr_list_is_cnt */
/*===========================================================================

FUNCTION sdss_is_list_scanned

DESCRIPTION
  Check if there are systems available for acquistion attempts based on it new acq cnt

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if all the systems in the list are scanned
  False if if list is not scanned

SIDE EFFECTS
  None.

===========================================================================*/

boolean   sdss_is_list_scanned(sd_ss_e_type                   ss,sdsr_e_type                   list)
{

  return sdss_sr_list_is_cnt(ss,list,0,SDSSSCR_CNT_COND_EXACTLY, SDSSSCR_CNT_INC_NEW);
}
/*===========================================================================

FUNCTION sdss_sr_list_is_comply

DESCRIPTION
  Check whether a specified list contains 1 or more systems that are
  compliant with the SS preference.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the specified list contains 1 or more systems that
  are currently available for acquisition attempts.
  FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean                       sdss_sr_list_is_comply(

       sd_ss_e_type                   ss,
          /* System selection stack.
          */

        sdsr_e_type                   list
            /* List for which to check.
            */

)
{

  return sdss_sr_list_is_cnt( ss, list, 1, SDSSSCR_CNT_COND_OR_MORE,
                              SDSSSCR_CNT_INC_COMPLY );

}




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_sr_list_avoid

DESCRIPTION
  Mark the system records that are referenced by the list parameter to be
  avoided from any acquisition attempts for the number of seconds that is
  indicated by the time parameter.

  Note that marking a system to be avoided from acquisition attempts
  overwrites any reacquisition attempts that are scheduled for that system.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static  void                      sdss_sr_list_avoid(

        sd_ss_e_type              ss,
            /* System selection stack.
            */

        sdsr_e_type               list,
            /* List to be avoided from acquisition attempts.
            */

        dword                     avoid_time,
            /* The time period in seconds during which acquisition attempts
            ** should be avoided.
            */

        sdssscr_sched_e_type      sched
            /* The avoidance schedule type.
            */

)
{
  int i;
  sdsr_s_type         *sr_ptr;
  dword               uptime      = time_get_uptime_secs();
  sdss_s_type         *ss_ptr;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( list, SDSR_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( sched,SDSSSCR_SCHED_MAX );

  ss_ptr = sdss_ptr( ss );

  SD_MSG_HIGH_3( "Avoid list=%d, Schedule=%d, ss=%d",
              list, sched, ss );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Step through the list and mark systems to be avoided from acquisitions.
  */
  for( i=0; (sr_ptr=sdsr_list_get_ptr(list, i)) != NULL; i++ )
  {
    /* If avoid time equal 0, reset the avoid_time which is set on the same
    ** system selection item based on the following conditions.
    **
    ** 1.If condition is SDSSSCR_SCHED_AVOID_CANCEL_ALL, cancel all avoidance
    ** of which sched is AVOID or UNTIL_ACQ_FAIL.
    **
    ** 2. Cancel SDSSSCR_SCHED_AVOID_UNTIL_ACQ_FAIL_DUR_CALL_ORIG
    ** only when there is a call origination.
    **
    ** 3. Cancel SDSSSCR_SCHED_AVOID_UNTIL_ACQ_FAIL_DUR_OPTI_REDIAL
    ** only when there is optimized silent redial
    **
    ** 4. Otherwise only cancel the avoidance of which sched field is
    ** specified.
    **
    ** 5.For MAP faiure, also clear the MAP fields.
    */

    if(sr_ptr->sys.mode == SD_MODE_HDR ||sr_ptr->sys.mode == SD_MODE_CDMA)
    {
      /*set the avoid list updated pointer */
      sdss_set_avoid_list_updated_flag(TRUE);
    }

    if( avoid_time == 0 )
    {
      if( sdss_sr_is_avoid( ss, sr_ptr ) &&
          ( sched == SDSSSCR_SCHED_AVOID_CANCEL_ALL ||
            sr_ptr->sched == sched ))
      {

        /* Bail out if cancellation is triggered outside of a call
        ** origination.
        */
        if( sched == SDSSSCR_SCHED_AVOID_UNTIL_ACQ_FAIL_DUR_CALL_ORIG &&
            !sdss_is_orig_mode( ss, SD_SS_ORIG_MODE_VAL_ORIG ) )
        {
          SD_MSG_HIGH_3( "Still Avoid mode=%d, band=%d, chan=%d",
                      sr_ptr->sys.mode,
                      sdss_map_band_pref_to_band(sr_ptr->sys.band),
                      sr_ptr->sys.chan);
          continue;
        }
        /* Bail out if cancellation is triggered outside of
        ** optimized silent redial
        */
        if( sched == SDSSSCR_SCHED_AVOID_UNTIL_ACQ_FAIL_DUR_OPTI_REDIAL &&
            !( sdss_is_orig_mode( ss, SD_SS_ORIG_MODE_VAL_ORIG ) &&
               sdss_is_pref_reason(ss,SDSSSCR_PREF_REAS_VAL_REDIAL_OPTI )
             )
          )
        {
          SD_MSG_HIGH_3( "OSR:Still Avoid mode=%d, band=%d, chan=%d",
                      sr_ptr->sys.mode,
                      sdss_map_band_pref_to_band(sr_ptr->sys.band),
                      sr_ptr->sys.chan);
          continue;
        }
        sr_ptr->sched_prm.avoid_time = 0;

        /* As MAP avoidance is taking separate from the other avoidance,
        ** check MAP avoidance as well.
        */
        if( time_get_uptime_secs()  < sr_ptr->max_access_prob.avoid_time )
        {
          sr_ptr->max_access_prob.absr_cnt = 0;
          sr_ptr->max_access_prob.avoid_time = 0;
        }

        SD_MSG_HIGH_3( "Cancel Avoid mode=%d, band=%d, chan=%d",
                    sr_ptr->sys.mode,
                    sdss_map_band_pref_to_band(sr_ptr->sys.band),
                    sr_ptr->sys.chan);

        sdss_avoid_log_rprt( SDLOG_AVOID_REPORT_EXIT,
                             ss,
                             sr_ptr,
                             0,
                             sched,
                             SYS_REG_STATUS_UNKNOWN);

      }
    }
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    /* Update SDSR table with the specified system avoidance condition and
    ** timer.
    */
    else
    {

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      /* If avoid time equal the magic value AVOID_UNTIL_NEW_ACQ, only
      ** set the new_acq_cnt field per the current new acquisition counter
      ** value.
      */
      SD_MSG_HIGH_3( "Avoid mode=%d, band= %d, chan=%d ",
                  sr_ptr->sys.mode,
                  sdss_map_band_pref_to_band(sr_ptr->sys.band),
                  sr_ptr->sys.chan);

      if( avoid_time == SDSSSCR_AVOID_UNTIL_NEW_ACQ )

      {
        sr_ptr->new_acq_cnt = ss_ptr->new_acq_cnt;
        sr_ptr->last_acq_ss = ss;

        SD_MSG_HIGH_1( "Avoid Until_NEW_ACQ, new acq_cnt: %d", ss_ptr->new_acq_cnt);
      }

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      /* Else, set the schedule field per the avoid time.
      **
      ** If the failure is MAP, update the MAP field with the avoidance
      ** expiration uptime, set the ABSR counter per NV NV_SD_CFG_ITEMS_I
      ** with index SDSSSCR_NV_ITEM_TMR_CDMA_ABSR_COUNT.
      */
      else
      {
        sr_ptr->sched                 = (word) sched;
        sr_ptr->sched_prm.avoid_time  = uptime + avoid_time;
        sr_ptr->sched_ss              = ss;


        if( sched == SDSSSCR_SCHED_AVOID_MAP_UNTIL_ACC_SUCCESS )
        {
          sr_ptr->max_access_prob.avoid_time = uptime + avoid_time;
          sr_ptr->max_access_prob.absr_cnt = (byte)
                    sdssscr_nv_item_get(SDSSSCR_NV_ITEM_TMR_CDMA_ABSR_COUNT);
        }

        SD_MSG_HIGH_3( "Avoid duration = %d, uptime=%d, until=%d",
                    avoid_time, uptime, sr_ptr->sched_prm.avoid_time);

      }
      sdss_avoid_log_rprt( SDLOG_AVOID_REPORT_ENTER,
                           ss,
                           sr_ptr,
                           avoid_time,
                           sched,
                           SYS_REG_STATUS_UNKNOWN);

    }
  }

} /* sdss_sr_list_avoid */


/* <EJECT> */

/*===========================================================================

FUNCTION sdss_sr_set_mape

DESCRIPTION
Sets mape flag on a sys record

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static  void                      sdss_sr_set_mape(

  

        sdsr_e_type               list,
         

        boolean                     is_map
            /* set mape sys in sr 
            */

)
{
  int i;
  sdsr_s_type         *sr_ptr;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( list, SDSR_MAX );


  SD_MSG_HIGH_2( "Avoid list=%d,is_map = %d ",
              list, is_map);

  for( i=0; (sr_ptr=sdsr_list_get_ptr(list, i)) != NULL; i++ )
  {
	  sr_ptr->is_mape = is_map;
  }

} /* sdss_sr_set_map*/


/* <EJECT> */

/*===========================================================================

FUNCTION sdss_sr_list_avoid2

DESCRIPTION
  Mark the system records that are referenced by the list parameter to be
  avoided from any acquisition attempts for the number of seconds that is
  indicated by the time parameter.

  Note that marking a system to be avoided from acquisition attempts
  overwrites any reacquisition attempts that are scheduled for that system.

  Takes enum sd_ss_e_type instead of sdss_s_type*

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                      sdss_sr_list_avoid2(

        const sd_ss_e_type        ss,
           /* System selection stack.
           */

        sdsr_e_type               list,
           /* List to be avoided from acquisition attempts.
           */

        dword                      avoid_time
           /* The time period in seconds during which acquisition attempts
           ** should be avoided.
           */
)
{
  sdss_sr_list_avoid(ss, list, avoid_time, SDSSSCR_SCHED_AVOID);
  return;

} /* sdss_sr_list_avoid2 */


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_sr_avoid_list_clear

DESCRIPTION
  Clear the avoidence Mark in th the system records that are referenced by the
  list parameter.

  Takes enum sd_ss_e_type instead of sdss_s_type*

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                      sdss_sr_avoid_list_clear(

        const sd_ss_e_type        ss,
           /* System selection - MAIN or HDR.
           */

        sdsr_e_type               list
           /* List to be clear the avoidence.
           */
)
{
  sdss_sr_list_avoid(ss, list, 0, SDSSSCR_SCHED_AVOID_CANCEL_ALL);
  return;

} /* sdss_sr_avoid_list_clear */


#if ( defined(FEATURE_GSM) || defined(FEATURE_WCDMA) || defined(FEATURE_TDSCDMA) || defined(FEATURE_SD_LTE) )
/*===========================================================================

FUNCTION sdss_verify_rat_pri_list_info

DESCRIPTION
  This function checks that atleast one system in the rat pri list of the
  system has bst_rat_acq_required set to TRUE. This is done in order to prevent
  sending a NULL rat pri list to NAS which will cause NAS to crash.

DEPENDENCIES
  None.

RETURN VALUE
  FALSE: If all systems have bst_rat_acq_required is FALSE
  TRUE: Otherwise

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean                       sdss_verify_rat_pri_list_info(

       sys_rat_pri_list_info_s_type    *rat_pri_list

)
{
  uint32 i;
  sys_priority_list_info_s_type *rat_info;

  if ( rat_pri_list == NULL )
  {
    sys_err_fatal_null_ptr_exception();
  }

  for( i = 0; i < rat_pri_list->num_items; i++ )
  {
     /* Verify that index is less than the rat pri array size */
     SD_ASSERT( i < ARR_SIZE( rat_pri_list->priority_list_info ) );

     rat_info = &rat_pri_list->priority_list_info[i];
     if( rat_info->bst_rat_acq_required
         &&
         ((rat_info->acq_sys_mode == SYS_SYS_MODE_LTE &&
           !SYS_LTE_BAND_MASK_CHK_IF_EMPTY(&rat_info->bst_band_cap.lte_band_cap ))
           ||
          (rat_info->acq_sys_mode != SYS_SYS_MODE_LTE &&
           rat_info->bst_band_cap.chgwt_band_cap != 0)
         )
       )
     {
       return TRUE;
     }
  }

  return FALSE;
} /* sdss_verify_rat_pri_list_info */

/*===========================================================================

FUNCTION sdss_copy_system_record

DESCRIPTION
  This function performs a deep copy of one system record to another.

DEPENDENCIES
  None.

RETURN VALUE
  FALSE: If all systems have bst_rat_acq_required is FALSE
  TRUE: Otherwise

SIDE EFFECTS
  None.

===========================================================================*/
static  void                       sdss_copy_system_record(

       sdsr_s_type                   *dst_sr_ptr,

       sdsr_s_type                   *src_sr_ptr
)
{
  if ( dst_sr_ptr == NULL || src_sr_ptr == NULL )
  {
    sys_err_fatal_null_ptr_exception();
  }

  /* Copy system records */
  dst_sr_ptr->sys = src_sr_ptr->sys;

  dst_sr_ptr->prl = src_sr_ptr->prl;

  dst_sr_ptr->match_lvl = src_sr_ptr->match_lvl;

  dst_sr_ptr->new_acq_cnt = src_sr_ptr->new_acq_cnt;

  dst_sr_ptr->last_acq_ss = src_sr_ptr->last_acq_ss;

  dst_sr_ptr->list_pos = src_sr_ptr->list_pos;

  dst_sr_ptr->sid = src_sr_ptr->sid;

  dst_sr_ptr->event_time = src_sr_ptr->event_time;

  dst_sr_ptr->event = src_sr_ptr->event;

  dst_sr_ptr->roam = src_sr_ptr->roam;

  dst_sr_ptr->meas_val = src_sr_ptr->meas_val;

  dst_sr_ptr->sched = src_sr_ptr->sched;

  dst_sr_ptr->sched_prm = src_sr_ptr->sched_prm;

  dst_sr_ptr->sched_ss = src_sr_ptr->sched_ss;

  dst_sr_ptr->status_mask = src_sr_ptr->status_mask;

  dst_sr_ptr->prl_assn = src_sr_ptr->prl_assn;

  dst_sr_ptr->uptime_fade = src_sr_ptr->uptime_fade;

  dst_sr_ptr->num_fade = src_sr_ptr->num_fade;

  dst_sr_ptr->srv_cap = src_sr_ptr->srv_cap;

  dst_sr_ptr->idx_expected = src_sr_ptr->idx_expected;

  dst_sr_ptr->sid_expected = src_sr_ptr->sid_expected;

  dst_sr_ptr->max_access_prob = src_sr_ptr->max_access_prob;

  dst_sr_ptr->sdsr_rec_type = src_sr_ptr->sdsr_rec_type;

  dst_sr_ptr->is_multi_geo_match = src_sr_ptr->is_multi_geo_match;
} /* sdss_copy_system_record */

/*============================================================================

FUNCTION sdss_validate_sys_rat_pri_list

DESCRIPTION
  This function creates a rat_pri_list for each system record and verifies that
  atleast one system in the system record has bst_rat_acq_required set to TRUE

DEPENDENCIES
  None.

RETURN VALUE
  FALSE: If all systems have bst_rat_acq_required is FALSE
  TRUE:  Otherwise

SIDE EFFECTS
  None.

============================================================================*/
static boolean sdss_validate_sys_rat_pri_list( sdsr_s_type              *sr_ptr,
                                                 /* System Record Pointer
                                                 */

                                               sdsr_s_type              *sr,
                                                 /* Updated Sys record for the SR
                                                 */

                                               sd_ss_e_type              ss
                                                 /* System Selection Stack
                                                 */
                                             )
{
  sys_rat_pri_list_info_s_type  *temp_rat_pri_ptr = NULL;
  sdsr_s_type                   *temp_sr_ptr      = NULL;
  boolean                       is_bst_rat_req_set = FALSE;

  temp_rat_pri_ptr = modem_mem_alloc( sizeof(sys_rat_pri_list_info_s_type), MODEM_MEM_CLIENT_MMODE );
  temp_sr_ptr      = modem_mem_alloc( sizeof(sdsr_s_type), MODEM_MEM_CLIENT_MMODE );

  if ( temp_rat_pri_ptr == NULL ||
        temp_sr_ptr == NULL)
  {
    sys_err_fatal_null_ptr_exception();
  }

  /* Initialize the temp rat pri list to ZERO */
  memset( temp_rat_pri_ptr, 0, sizeof(sys_rat_pri_list_info_s_type) );

  /* Make a copy of sr so that the original one is not overwritten */
  sdss_copy_system_record( temp_sr_ptr, sr_ptr );

  /* Update the System info with the latest sys info */
  temp_sr_ptr->sys = sr->sys;

  /* Generate the rat pri list for each system and verify that
  ** bst_rat_acq_required is set TRUE for atleast one system
  */
  sd_update_rat_pri_list( temp_rat_pri_ptr, temp_sr_ptr, ss,SDSS_EVT_MISC_FILLER );
  is_bst_rat_req_set = sdss_verify_rat_pri_list_info( temp_rat_pri_ptr );

  /* Free the memory allocated for the temp rat pri list and temp sr */
  modem_mem_free( temp_rat_pri_ptr, MODEM_MEM_CLIENT_MMODE );
  modem_mem_free( temp_sr_ptr, MODEM_MEM_CLIENT_MMODE );

  return is_bst_rat_req_set;

} /* sdss_validate_sys_rat_pri_list */
#endif

/*===========================================================================

FUNCTION sdss_sr_list_is_skipped_system_common_causes

DESCRIPTION
  This function check if the acquisition should be skipped due to common
  reasons which could making the system become not available for acquisition.

  A system that is available for acquisition attempt is a system that:

    1. Complies with the target capabilities.
    2. Complies with the specified mode preferences.
    3. Complies with the specified band preferences.
    4. Complies with the specified measurement value.
    5. Currently is not marked to be avoided from acquisition attempts.
    6. Has a new-acquisition count that is different than the specified
       new-acquisition count or the specified new-acquisition count is 0.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
boolean sdss_sr_list_is_skipped_system_common_causes(
   /* For debugging purpose */
        sdsr_e_type               list,
        int                       i,

        sd_ss_e_type              ss,
            /* Stack of acquisition */

        byte                      new_acq_cnt,
            /* The new-acquisition counter value with which system should
            ** comply (ignored if set to 0).
            */

        int2                      meas_val,
            /* Measurement value with which system should comply.
            */

       sdsr_cat_e_type            meas_cat,
            /* Systems which should comply meas_val
            */

        sd_ss_mode_pref_e_type    mode_pref,
            /* Mode preference with which system should comply.
            */

        sd_ss_band_pref_e_type    band_pref,
            /* 3G band preference with which system should comply.
            */

        sys_lte_band_mask_e_type  lte_band_pref,
            /* lte band preference with which system should comply
            */

        sd_ss_band_pref_e_type    tds_band_pref,
            /* TD-SCDMA band preference with which system should comply
            */

        sdsr_s_type              *sr_ptr,
            /* The system which we want to check for validity
            */

        void                     *acq_con_ptr
            /* Pointer to the Acquisition Construct
            */
)
{
  /* Local copy of the system pointed by sr_ptr. This ensure we could modify
  ** the mode/band of this system based on our filter without alter the orignal. */
  sdsr_s_type                   sr;
  sys_gw_conn_status_e_type     conn_status;
  sys_srv_domain_e_type         ss_srv_domain = SYS_SRV_DOMAIN_NONE;
  #ifdef FEATURE_AVOID_DUP_BAND_SCAN
  sdss_band_s_type tmp_band;
  #endif
  sd_si_info_s_type         *main_si_info_ptr = &sd_si_ptr(SD_SS_MAIN)->si_info;

  boolean                   is_acq_con_get_net_or_meas = FALSE;
  boolean                   is_acq_con_get_net         = FALSE;
  sdssscr_con_e_type        *acq_con = (sdssscr_con_e_type*) acq_con_ptr;

  #if ( defined(FEATURE_GSM) || defined(FEATURE_WCDMA) || defined(FEATURE_TDSCDMA) || defined(FEATURE_SD_LTE) )
  boolean                   is_bst_rat_req_set;
  #endif

  /* Get if svdo is supported */
  boolean is_svdo_supported 
    = SYS_IS_BIT_CONTAIN(TRM_SVDO_IS_ENABLED,sdss_common.trm_cap);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( list, SDSR_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( mode_pref, SD_SS_MODE_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( band_pref, SD_SS_BAND_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( tds_band_pref, SD_SS_BAND_PREF_MAX );

  if(sdss_is_1x_sxlte())
  {
    sdss_read_srv_status( SD_SS_HYBR_2, NULL, &ss_srv_domain );
  }

  /* Set the boolean flag is acquisition construct is a get networks or measurement
  ** request */

  if( acq_con != NULL && ( *acq_con == SDSSSCR_CON_GET_NET || *acq_con == SDSSSCR_CON_MEAS ) )
  {
    is_acq_con_get_net_or_meas = TRUE;
    if( *acq_con == SDSSSCR_CON_GET_NET )
    {
      is_acq_con_get_net = TRUE;
    }
  }

  if(sr_ptr == NULL)
    sys_err_fatal_null_ptr_exception();


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* if mode & band not supported */
  if( ! sdss_is_supp_mode_band(sr_ptr->sys.mode,
                               sr_ptr->sys.band,
                                sdsr_map_sys_rec_lte_band_to_lte_band_pref(sr_ptr->sys.lte_band),
                               sr_ptr->sys.tds_band) ) {
    SD_MSG_HIGH_2( "Skip list=%-3d, pos=%-3d - target-cap", list, i);
    return TRUE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if( ! sdss_sr_is_mode_pref(sr_ptr, mode_pref)  ) {
    SD_MSG_HIGH_3( "Skip list=%-3d, pos=%-3d - sd mode-pref = %x", list, i, mode_pref );
    return TRUE;
  }

  sr.sys = sr_ptr->sys;
  /* Filters the system band within the target capability & pref. */
  sdss_filter_sr_with_supported_band_mode(&sr, mode_pref);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Skip if the filtered band and lte_band are none.
  */
  #ifdef FEATURE_SD_LTE
  if (   sr.sys.band == SD_SS_BAND_PREF_NONE
      && sdsr_chk_sys_rec_lte_band_equal(sr.sys.lte_band,sdsr_map_lte_band_pref_to_sys_rec_lte_band(SYS_LTE_BAND_MASK_CONST_NONE))
      && sr.sys.tds_band == SD_SS_BAND_PREF_NONE
     )

  {
    SD_MSG_HIGH_2( "Skip list=%-3d, pos=%-3d - target-cap, GWL bands NONE",
                 list, i);
    return TRUE;
  }
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Filter out 3gpp duplicate bands which have been scanned previously.
  ** Duplicate bands are removed only if avoid_state = active.
  */
  #ifdef FEATURE_AVOID_DUP_BAND_SCAN
  if( (!(sdss_is_e911_alternate_redial_algorithm(ss)
       && sdss_get_is_RLF_during_emerg(ss) == TRUE))
    )
  {

    tmp_band.band = sr.sys.band;
    #ifdef FEATURE_SD_LTE
    tmp_band.lte_band = sr.sys.lte_band;
    tmp_band.tds_band = sr.sys.tds_band;
    #endif
    tmp_band.band = sd_filter_out_overlap_band(SD_GET_COMMON_BAND ( tmp_band.band, band_pref));

    /* tmp_band will be the band mask after filtering */
    sdss_filter_out_dup_band(ss, sr.sys.mode, &tmp_band);

    /* Go to next record if band is none */
    if (sdss_is_band_none_per_mode(sr.sys.mode, &tmp_band)== TRUE)
    {
      SD_MSG_HIGH_2( "Skip list=%-3d, pos=%-3d - 3GPP dup band", list, i);
      return TRUE;
    }

    sr.sys.band = tmp_band.band;
    #ifdef FEATURE_SD_LTE
    sr.sys.lte_band = tmp_band.lte_band;
    sr.sys.tds_band = tmp_band.tds_band;
    #endif /* FEATURE_SD_LTE */
  }
  #endif /* FEATURE_AVOID_DUP_BAND_SCAN */

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #ifdef FEATURE_SD_LTE
  /* Skip LTE only record when in CS only mode  */
  if ((sdss_get_domain_pref(ss) == SD_SS_SRV_DOMAIN_PREF_CS_ONLY ) &&
        sr.sys.band == SD_SS_BAND_PREF_NONE &&
      !sdsr_chk_sys_rec_lte_band_equal(sr.sys.lte_band,sdsr_map_lte_band_pref_to_sys_rec_lte_band(SYS_LTE_BAND_MASK_CONST_NONE))&&
      sr.sys.tds_band == SD_SS_BAND_PREF_NONE )
    {
      SD_MSG_HIGH_2( "Skip list=%-3d, pos=%-3d - GW bands NONE  & CS only ",
                   list, i);
      return TRUE;
    }

  /* Skip LTE only record when sim is invalid PS or CS_PS invalid and
  *  UE is not attempting an emergency call
  */
  if (( sdss_get_sim_state(ss) == SYS_SIM_STATE_PS_INVALID ||
          sdss_get_sim_state(ss) == SYS_SIM_STATE_CS_PS_INVALID ) &&
          sr.sys.band == SD_SS_BAND_PREF_NONE &&
          !sdsr_chk_sys_rec_lte_band_equal(sr.sys.lte_band,sdsr_map_lte_band_pref_to_sys_rec_lte_band(SYS_LTE_BAND_MASK_CONST_NONE))&&
          sr.sys.tds_band == SD_SS_BAND_PREF_NONE &&
          !sdss_is_emergency_call_orig(ss) &&
          is_acq_con_get_net == FALSE )
    {
      SD_MSG_HIGH_2( "Skip list=%-3d, pos=%-3d - ps invalid ",
                   list, i);
      return TRUE;
    }
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Skip HDR record if there is an existing CSFB call */
  if (((sdss_ptr(SD_SS_MAIN)->orig_mode == SD_SS_ORIG_MODE_1XCSFB_EMERG_ORIG) ||
       (sdss_ptr(SD_SS_MAIN)->orig_mode == SD_SS_ORIG_MODE_1XCSFB_NORMAL_ORIG)) &&
       (!is_svdo_supported) &&
       (main_si_info_ptr->mode == SYS_SYS_MODE_CDMA) &&
       (sr.sys.mode == SYS_SYS_MODE_HDR) && (ss == SD_SS_HYBR_1))
  {


    SD_MSG_HIGH_5( "skip list=%-3d, pos=%-3d - . Skip due to CSFB call orig_mode %d svdo %d mode %d",
                    list, i, sdss_ptr(SD_SS_MAIN)->orig_mode, is_svdo_supported, main_si_info_ptr->mode);
    return TRUE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #if defined (FEATURE_3GPP_CSFB) || defined (FEATURE_LTE_TO_1X)
  /* Skip LTE only record when in CSFB call - this should happens only when LTE is
  ** on MAIN stack. Case LTE on HYBR-2 during CSFB call shouldn't happen.
  */
  if ( sr.sys.band == SD_SS_BAND_PREF_NONE &&
       !sdsr_chk_sys_rec_lte_band_equal(sr.sys.lte_band,sdsr_map_lte_band_pref_to_sys_rec_lte_band(SYS_LTE_BAND_MASK_CONST_NONE))&&
      sr.sys.tds_band == SD_SS_BAND_PREF_NONE)
  {
    if (!sdss_is_lte_supp_for_csfb_call( ss ))
    {
       SD_MSG_HIGH_2( "Skip list=%-3d, pos=%-3d - LTE not supp. in CSFB call",
                     list, i);
       return TRUE;
    }
  }
  #endif /*#if defined (FEATURE_3GPP_CSFB) || defined (FEATURE_LTE_TO_1X)*/

  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  
  if(sdss_common.subs_feature[SYS_MODEM_AS_ID_1] == SYS_SUBS_FEATURE_MODE_SGLTE &&
         ss == SD_SS_HYBR_2)
  {  
    conn_status = mm_per_stacks_get_connection_status(SYS_MODEM_AS_ID_1,
													SYS_MODEM_STACK_ID_2);	
  }
  else 
  {
    conn_status = mm_per_stacks_get_connection_status(SYS_MODEM_AS_ID_1,
 													SYS_MODEM_STACK_ID_1);	 
  }

  /* Filters the system band within the band preference.
  */
  if( ! sdss_sr_is_band_pref(&sr, band_pref, lte_band_pref, tds_band_pref, ss)  ) {
      SD_MSG_HIGH_2( "Skip list=%-3d, pos=%-3d - band-pref", list, i);
      return TRUE;
  }
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  else if( (sr_ptr->meas_val < meas_val) &&
           (sdss_is_mode_comply_meas_cat( sr_ptr->sys.mode, meas_cat)) ) {
    SD_MSG_HIGH_2( "Skip list=%-3d, pos=%-3d - meas_val", list, i);
    return TRUE;
  }
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  else if( new_acq_cnt != 0 && ss == sr_ptr->last_acq_ss
         && new_acq_cnt == sr_ptr->new_acq_cnt ) {
    SD_MSG_HIGH_2( "Skip list=%-3d, pos=%-3d - new_acq_cnt", list, i);
    return TRUE;
  }
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #if defined FEATURE_SD_LTE
  else if( sdss_ptr(ss)->acq_thrttl.is_thrttl_on  &&
           SD_MODE_CONTAIN(sdss_map_mode_to_mode_pref(sr_ptr->sys.mode),
                             (word)SD_SS_MODE_PREF_GWL)
         )
  {
    SD_MSG_HIGH_2( "Skip list=%-3d, pos=%-3d - HDR in traffic", list, i);
    return TRUE;
  }
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* If LTE NAS is not in IDLE state on HYBR2 Stack,  skip GWL acq on MAIN.
  ** (note: If GW is active , LTE acqs on HYBR2 are blocked in MMOC )
  */
  /* skip GW acquisitions on MAIN stack if -
  ** 1. LTE is on HYBR2 stack
  ** 2. NAS is in connected state
  ** 3. Either in LTE service or in connected mode due to LTE RLF
  */
  else if( ss == SD_SS_MAIN && sdss_is_1x_sxlte() &&
           (SD_MODE_CONTAIN(sdss_map_mode_to_mode_pref(sr_ptr->sys.mode),
                             (word)SD_SS_MODE_PREF_GWL)) &&
           sdss_get_ss_for_mode(SD_MODE_LTE) == SD_SS_HYBR_2 &&
           ( conn_status  != SYS_GW_CONN_STATUS_IDLE ) &&
           (  conn_status != SYS_GW_CONN_STATUS_NONE ) &&
           ( sdss_is_srv_status2(SD_SS_HYBR_2, SDSSSCR_SRV_STATUS_VAL_SRV_ANY) ||
             sdss_is_lte_connected_mode(ss)
           )
         )
  {
    SD_MSG_HIGH_3( "Skip list=%-3d, pos=%-3d - NAS conn state = %d",
                                                 list,i, conn_status );
    return TRUE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  else if( ss == SD_SS_MAIN && sdss_is_1x_sxlte() &&
           (SD_MODE_CONTAIN(sdss_map_mode_to_mode_pref(sr_ptr->sys.mode),
                             (word)SD_SS_MODE_PREF_GWL)) &&
           sdss_get_ss_for_mode(SD_MODE_LTE) == SD_SS_HYBR_2 &&
           sdss_is_srv_status2(SD_SS_HYBR_2, SDSSSCR_SRV_STATUS_VAL_SRV_ANY)&&
           ss_srv_domain == SYS_SRV_DOMAIN_CAMPED
         )
  {
    SD_MSG_HIGH_2( "Skip list=%-3d, pos=%-3d - LTE srv_domain camped", list, i);
    return TRUE;
  }
  /* skip GW acquisitions on MAIN stack if emerg call is on hybrid 2
  */
  else if( ss == SD_SS_MAIN && sdss_is_1x_sxlte() &&
           (SD_MODE_CONTAIN(sdss_map_mode_to_mode_pref(sr_ptr->sys.mode),
                             (word)SD_SS_MODE_PREF_GWL)) &&
           sdss_get_ss_for_mode(SD_MODE_LTE) == SD_SS_HYBR_2 &&
           sdss_is_emergency_call_orig(SD_SS_HYBR_2)
        )
  {

    SD_MSG_HIGH_2( "Skip list=%-3d, pos=%-3d - throttle GW when emg call on hybr_2", list, i);
    return TRUE;
  }
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  else if(!sdss_sr_is_mode_pref(sr_ptr, sdss_ptr(ss)->operator_capability))
  {
    SD_MSG_HIGH_2( "Skip list=%-3d, pos=%-3d - operator capability", list, i);
    return TRUE;
  }
  
  #ifdef FEATURE_MMODE_DUAL_SIM
    /* If other sub is having any service and current SS can acquire 
  ** only limited service, then skip all GWL system records
  */
  if(sdss_is_featuremode(SYS_OVERALL_FEATURE_MODE_MULTISIM) &&
      !sdss_gw_sim_domain_valid(ss)&&
      (SD_MODE_CONTAIN(sdss_map_mode_to_mode_pref(sr_ptr->sys.mode),
                        (word)SD_SS_MODE_PREF_TDS_GSM_WCDMA_LTE))&&
     (((sdss_is_other_ss_in_srv(ss))!= SD_SS_MAX) &&       
        (sdss_get_orig_mode(ss)  == SD_SS_ORIG_MODE_NONE || 
         sdss_get_orig_mode(ss)  == SD_SS_ORIG_MODE_MANUAL_IDLE)) &&
         is_acq_con_get_net == FALSE )
  {
    SD_MSG_HIGH_2( "Skip list=%-3d, pos=%-3d - Limited srv not allowed", list, i);
    return TRUE;
  }
  #endif

  
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* In MMSS operation if the non-TDS RATs in the system do not have valid
  ** bands, the resultant service request will be invalid. So skip the
  ** system.
  */
  else if( sdss_is_mmss_operation(ss)        &&
           sd_misc_is_mode_3gpp(sr.sys.mode) &&
           !sdss_sr_is_band_pref( &sr,
                                   band_pref,
                                   #ifdef FEATURE_SD_LTE
                                   lte_band_pref,
                                   #else
                                   SYS_LTE_BAND_MASK_CONST_NONE,
                                   #endif
                                   SD_SS_BAND_PREF_NONE,
                                   ss)
           )
  {
    SD_MSG_HIGH_2( "Skip list=%-3d, pos=%-3d - non-TDS portion of record not supported", list, i);
    return TRUE;
  }
  /* Skip System if bst_rat_acq_required for all systems is FALSE
  ** to avoid sending empty rat pri lst
  */
  #if ( defined(FEATURE_GSM) || defined(FEATURE_WCDMA) || defined(FEATURE_TDSCDMA) || defined(FEATURE_SD_LTE) )
  if( !is_acq_con_get_net_or_meas &&
      sd_misc_is_mode_3gpp( sr_ptr->sys.mode ) )
  {
    is_bst_rat_req_set = sdss_validate_sys_rat_pri_list( sr_ptr, &sr, ss );

    if( !is_bst_rat_req_set )
    {
      SD_MSG_HIGH_2( "Skip list=%-3d, pos=%-3d - bst_rat_acq_required FALSE", list, i);
      return TRUE;
    }
  }
  #endif

  #ifdef FEATURE_SD_LTE
  /* if skip GWT scan during RLF is enabled and GWT is marked as skipped, and LTE is not part of system record
    then skip the record */
  if ( !cmsds_is_gwt_scan_allowed(ss) &&
       ( (!SD_MODE_CONTAIN(sdss_map_mode_to_mode_pref(sr_ptr->sys.mode),
                             (word)SD_SS_MODE_PREF_LTE)) || 
          (sr_ptr->sys.mode == SD_MODE_GWL &&
           sdsr_chk_sys_rec_lte_band_equal(sr.sys.lte_band,sdsr_map_lte_band_pref_to_sys_rec_lte_band(SYS_LTE_BAND_MASK_CONST_NONE)))
       )
    )
  {
    SD_MSG_HIGH_2( "Skip list=%-3d, pos=%-3d - GWT scan not allowed and L not present", list, i);
    return TRUE;
  }
  #endif
  
  return FALSE;
} /* sdss_sr_list_is_skipped_system_common_causes */

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_sr_list_find_next

DESCRIPTION
  Given a list and list position, this function finds the next system
  (starting with the list position) that is available for acquisition
  attempt.

DEPENDENCIES
  None.

RETURN VALUE
  The position of the next system that is available for an acquisition
  attempt if such a system is found. SDSR_POS_NULL otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
static  int                       sdss_sr_list_find_next(

        sd_ss_e_type              ss,
            /* System selection stack.
            */

        sdssscr_con_e_type        acq_con,
            /* Acquisition construct.
            */

        sdss_acq_mode_e_type      acq_mode,
            /* Acq mode for avoided system
            */

        sdsr_e_type               list,
            /* List over which to find the next system.
            */

        int                       pos,
            /* List position from which to start searching for next system.
            */

        byte                      new_acq_cnt,
            /* The new-acquisition counter value with which system should
            ** comply (ignored if set to 0).
            */

        int2                      meas_val,
            /* Measurement value with which system should comply.
            */

        sd_ss_mode_pref_e_type    mode_pref,
            /* Mode preference with which system should comply.
            */

        sd_ss_band_pref_e_type    band_pref,
            /* 3G band preference with which system should comply.
            */

        sys_lte_band_mask_e_type  lte_band_pref,
        /* lte band preference with which system should comply
        */

        sd_ss_band_pref_e_type    tds_band_pref,
        /* TD-SCDMA band preference with which system should comply
        */

        sdsr_cat_e_type           meas_cat
           /* Systems which should comply meas_val
           */
)
{

  int                       i;
  sdsr_s_type              *sr_ptr;
  boolean                   is_attempt_avoid = FALSE;
  boolean                   is_attempt_absr = FALSE;
  sdsr_e_type               more_pref_scanned_list = SDSR_MAX_LST;
  void                      *acq_con_ptr           = &acq_con;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( acq_con, SDSSSCR_CON_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( list, SDSR_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( mode_pref, SD_SS_MODE_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( band_pref, SD_SS_BAND_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( tds_band_pref, SD_SS_BAND_PREF_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  more_pref_scanned_list = sdss_sr_list_map2(ss,SDSR_MORE_PREF_SCANNED_LST);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Starting from the specified list position, step through the list and
  ** return the position of the next system that is available for an
  ** acquisition attempt. If such a system is not found, return
  ** SDSR_POS_NULL.
  **
  ** A system that is available for acquisition attempt is a system that:
  **
  **   1. Complies with the target capabilities.
  **   2. Complies with the specified mode preferences.
  **   3. Filters band within the target capability, system mode, band pref
  **      and mode pref.
  **   4. Complies with the specified band preferences.
  **   5. Complies with the specified measurement value.
  **   6. Currently is not marked to be avoided from acquisition attempts.
  **   7. Has a new-acquisition count that is different than the specified
  **      new-acquisition count or the specified new-acquisition count is 0.
  */
  #if !defined(FEATURE_SD_LTE)
  /*---------------------------------------------------------------------*/
  /* Suppress Lint and compiler warnings
  */
  lte_band_pref = SYS_LTE_BAND_MASK_CONST_NONE;
  /*---------------------------------------------------------------------*/


  for( i=pos; (sr_ptr=sdsr_list_get_ptr(list, i)) != NULL; i++ )
  {

    if(sdss_sr_list_is_skipped_system_common_causes(
                                                   list, i, ss,
                                                   new_acq_cnt,
                                                   meas_val,
                                                   meas_cat,
                                                   mode_pref,
                                                   band_pref,
                                                   lte_band_pref,
                                                   tds_band_pref,
                                                   sr_ptr,
                                                   acq_con_ptr )
      )
    {
      continue;
    }
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /* Skip the avoid system.
    */
    if( acq_con == SDSSSCR_CON_ACQ_AVOID_CNT &&
        sdss_sr_is_avoid(ss, sr_ptr) )
    {
      is_attempt_avoid = TRUE;
    }
    /* Evaluate if MS shall attempt the MAP system & Decrement the ABSR CNT
    */
    if( acq_con == SDSSSCR_CON_ACQ_ABSR_CNT &&
        sdss_sr_is_absr(ss, sr_ptr) )
    {
      is_attempt_absr = TRUE;
    }
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    if( !( is_attempt_avoid || is_attempt_absr ) &&
               sdss_sr_is_avoid(ss, sr_ptr) )
    {
      SD_MSG_HIGH_2( "Skip list=%-3d, pos=%-3d - avoid-time", list, i);
    }
    /* Recursive BSR: if we have already scanned during the recursive phase */
    else if ((ss == SD_SS_MAIN || ss == SD_SS_HYBR_1) &&
              sdsr_list_find(more_pref_scanned_list,sr_ptr) != SDSR_POS_NULL)
    {
      //debug: sdsr_list_print(more_pref_scanned_list, FALSE);
      SD_MSG_HIGH_2("Skip list=%-3d, pos=%-3d - already scanned in BSR",list,i);
    }
    else
    {
      /* If we got here, the system is available for acquisition - return its
      ** list position.
      */

      /* If is_skip_absr flag is set, perfrom ABSR
      ** - decrement the ABSR counter
      ** - attempt the avoided system.
      */
      if( is_attempt_absr )
      {
        SD_MSG_HIGH_3( "Attempt ABSR list=%d, pos=%d, cnt=%d",
                     list, i, sr_ptr->max_access_prob.absr_cnt );

        if ( sr_ptr->max_access_prob.absr_cnt > 0)
        {
          sr_ptr->max_access_prob.absr_cnt --;
        }
        else
        {
          sr_ptr->max_access_prob.absr_cnt = 0;
        }
        /* update uptime for the last attempt on avoided system */
        sr_ptr->max_access_prob.last_attempt_uptime = time_get_uptime_secs();
    SD_MSG_HIGH_3( "Attempt ABSR list=%d, pos=%d, last_attempt_uptime=%d",
          list, i, sr_ptr->max_access_prob.last_attempt_uptime );
        sdss_avoid_log_rprt( SDLOG_AVOID_REPORT_ABSR_ATTEMPT,
                             ss,
                             sr_ptr,
                             0,
                             SDSSSCR_SCHED_MAX,
                             SYS_REG_STATUS_UNKNOWN);
      }

      /* If is_skip_avoid flag is set, attempt the avoided system.
      */
      if( is_attempt_avoid )
      {
        SD_MSG_HIGH_2( "Attempt avoid list=%d, pos=%d", list, i);

        {
          /* Map report type of the event to type of attempt for avoided
          ** channel.
          */
          sdlog_avoid_report_e_type report = SDLOG_AVOID_REPORT_OSR_ATTEMPT;
          if( acq_mode == SDSS_ACQ_MODE_FULL_AOOS )
          {
            report = SDLOG_AVOID_REPORT_AOOS_ATTEMPT;
          }
          sdss_avoid_log_rprt( report,
                               ss,
                               sr_ptr,
                               0,
                               SDSSSCR_SCHED_MAX,
                               SYS_REG_STATUS_UNKNOWN);
        }

      }

      return i;
    }

  } /* for */

  #else // #if ( !defined(FEATURE_SD_LTE) )
  for( i=pos; (sr_ptr=sdsr_list_get_ptr(list, i)) != NULL; i++ )
  {
    if(sdss_sr_list_is_skipped_system_common_causes(
                                                   list, i, ss,
                                                   new_acq_cnt,
                                                   meas_val,
                                                   meas_cat,
                                                   mode_pref,
                                                   band_pref,
                                                   lte_band_pref,
                                                   tds_band_pref,
                                                   sr_ptr,
                                                   acq_con_ptr )
      )
    {
      continue;
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    /* Skip the avoid system.
    */
    if( acq_con == SDSSSCR_CON_ACQ_AVOID_CNT &&
        sdss_sr_is_avoid(ss, sr_ptr) )
    {
      is_attempt_avoid = TRUE;
    }

    /* Evaluate if MS shall attempt the MAP system & Decrement the ABSR CNT
    */
    if( acq_con == SDSSSCR_CON_ACQ_ABSR_CNT &&
        sdss_sr_is_absr(ss, sr_ptr) )
    {
      is_attempt_absr = TRUE;
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    if( !( is_attempt_avoid || is_attempt_absr ) &&
             sdss_sr_is_avoid(ss, sr_ptr) )
    {
      SD_MSG_HIGH_2( "Skip list=%-3d, pos=%-3d - avoid-time", list, i);
    }
    /* Recursive BSR: if we have already scanned during the recursive phase */
    else if ((ss == SD_SS_MAIN || ss == SD_SS_HYBR_1 ) &&
              sdsr_list_find(more_pref_scanned_list,sr_ptr) != SDSR_POS_NULL)
    {
      //debug: sdsr_list_print(more_pref_scanned_list, FALSE);
      SD_MSG_HIGH_2("Skip list=%-3d, pos=%-3d - already scanned in BSR",list,i);
    }
    /* non-SVLTE LTE tele bsr operation
    ** skip scan If 1x or LTE scan marked to be skipped
    */
    else if(sdss_is_c2k_alt_algr_operation() &&
           ss == SD_SS_MAIN &&
           sdss_is_resel_state(ss,SDSS_RESEL_STT_SRCH) &&
           sdss_get_ss_for_mode(SD_MODE_LTE) == SD_SS_MAIN &&
           ((sdss_ptr(ss)->is_skip_1x_pref_scan &&
             sr_ptr->sys.mode == SD_MODE_CDMA) ||
            (sdss_ptr(ss)->is_skip_lte_pref_scan &&
             SD_MODE_CONTAIN(mode_pref, (word)SD_SS_MODE_PREF_LTE) &&
                !sdsr_chk_sys_rec_lte_band_equal(sr_ptr->sys.lte_band,sdsr_map_lte_band_pref_to_sys_rec_lte_band(SYS_LTE_BAND_MASK_CONST_NONE))
              )
             )
           )
    {

        SD_MSG_HIGH_2( "Skip list=%-3d, pos=%-3d - LTE or 1X pref scan skipped ", list, i);

    }
    else if( sdss_is_splmn_support_enabled() &&
             (sdss_is_resel_state(ss,SDSS_RESEL_STT_SRCH) ||
             sdss_eng_stack_get_state(ss) == SDSS_ACQ_STT_MORE_PREF) &&
             SD_MODE_CONTAIN(mode_pref, (word)SD_SS_MODE_PREF_LTE)&&
             !sdsr_chk_sys_rec_lte_band_equal(sr_ptr->sys.lte_band,sdsr_map_lte_band_pref_to_sys_rec_lte_band(SYS_LTE_BAND_MASK_CONST_NONE))   &&
             SDSR_POS_NULL != sdsr_list_find_ref(SDSR_SPLMN_MORE_PREF_LST,sdsr_list_get_ref(list,i))
           )
    {
      SD_MSG_HIGH_2( "C2k_resel_splmn: Skip list=%-3d, pos=%-3d - LTE sys is present in splmn", list, i );
    }
    else
    {
      /* If we got here, the system is available for acquisition - return its
      ** list position.
      */
      /* If is_skip_absr flag is set, perfrom ABSR
      ** - decrement the ABSR counter
      ** - attempt the avoided system.
      */
      if( is_attempt_absr )
      {
        SD_MSG_HIGH_3( "Attempt ABSR list=%d, pos=%d, cnt=%d",
                     list, i, sr_ptr->max_access_prob.absr_cnt );

        if ( sr_ptr->max_access_prob.absr_cnt > 0)
        {
          sr_ptr->max_access_prob.absr_cnt --;
        }
        else
        {
          sr_ptr->max_access_prob.absr_cnt = 0;
        }
        /* update uptime for the last attempt on avoided system */
        sr_ptr->max_access_prob.last_attempt_uptime = time_get_uptime_secs();
    SD_MSG_HIGH_3( "Attempt ABSR list=%d, pos=%d, last_attempt_uptime=%d",
          list, i, sr_ptr->max_access_prob.last_attempt_uptime );
        sdss_avoid_log_rprt( SDLOG_AVOID_REPORT_ABSR_ATTEMPT,
                             ss,
                             sr_ptr,
                             0,
                             SDSSSCR_SCHED_MAX,
                             SYS_REG_STATUS_UNKNOWN);
      }

      /* If is_skip_avoid flag is set, attempt the avoided system.
      */
      if( is_attempt_avoid )
      {
        SD_MSG_HIGH_2( "Attempt avoid list=%d, pos=%d", list, i);

        {
          /* Map report type of the event to type of attempt for avoided
          ** channel.
          */
          sdlog_avoid_report_e_type report = SDLOG_AVOID_REPORT_OSR_ATTEMPT;
          if( acq_mode == SDSS_ACQ_MODE_FULL_AOOS )
          {
            report = SDLOG_AVOID_REPORT_AOOS_ATTEMPT;
          }
          sdss_avoid_log_rprt( report,
                               ss,
                               sr_ptr,
                               SDLOG_INVALID_TIME,
                               SDSSSCR_SCHED_MAX,
                               SYS_REG_STATUS_UNKNOWN);
        }

      }
      /* update tele bsr loop count */
      if(sdss_is_c2k_alt_algr_operation() &&
           ss == SD_SS_MAIN &&
           sdss_get_ss_for_mode(SD_MODE_LTE) == SD_SS_MAIN)
      {
        sdss_s_type *ss_ptr = sdss_ptr(SD_SS_MAIN);
        SD_MSG_HIGH_1("TELE_BSR: list_find, uptime=%d",time_get_uptime_secs());

        if(ss_ptr->is_lte_tele_bsr_timer &&
          time_get_uptime_secs() >= ss_ptr->bsr_uptime_lte &&
          ss_ptr->bsr_uptime_lte != BSR_UPTIME_NONE
          )
        {
          if(SD_MODE_CONTAIN(sdss_map_mode_to_mode_pref(sr_ptr->sys.mode),(word)SD_SS_MODE_PREF_LTE) &&
            (!ss_ptr->is_lte_long_bsr))
          {
            ss_ptr->telescope_bsr_current_loop_lte++;
            SD_MSG_HIGH_1("TELE_BSR, current_lte_loop=%d",ss_ptr->telescope_bsr_current_loop_lte);
            ss_ptr->is_lte_tele_bsr_timer = FALSE;
           }

        }

        if(ss_ptr->is_1x_bsr_timer &&
          time_get_uptime_secs() >= ss_ptr->bsr_uptime_1x &&
          ss_ptr->bsr_uptime_1x != BSR_UPTIME_NONE
          )
        {
          if(sr_ptr->sys.mode == SD_MODE_CDMA)
          {
            ss_ptr->telescope_bsr_current_loop_1x++;
            SD_MSG_HIGH_1("TELE_BSR, current_1x_loop=%d",ss_ptr->telescope_bsr_current_loop_1x);
            ss_ptr->is_1x_bsr_timer = FALSE;
          }

        }
      }
      return i;
    }

  } /* for */

  #endif // #if (!defined(FEATURE_SD_LTE))

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If we got here, no system that is available for acquisition is found -
  ** return SDSR_POS_NULL.
  */
  return SDSR_POS_NULL;

} /* sdss_sr_list_find_next */ /*lint +esym(715, bss_type_pref) */




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_sr_list_find_acq_start_pos

DESCRIPTION
  Decide on the acquisition starting point for the ACQ_CNT() and ACQ_TIME()
  acquisition constructs.

DEPENDENCIES
  None.

RETURN VALUE
  The acquisition start position to be used for the ACQ_CNT() and ACQ_TIME()
  acquisition constructs.

SIDE EFFECTS
  None.

===========================================================================*/
static  int                       sdss_sr_list_find_acq_start_pos(

        const sdss_s_type         *ss_ptr,
            /* Pointer to a System Selection information structure.
            */

        sdsr_e_type               acq_list,
            /* Acquisition list.
            */

        sdssscr_prm_type          start_pos
            /* Start position parameter from which to conclude the actual
            ** acquisition starting position.
            */
)
{
  int               pos;
  sdsr_ref_type     sr_ref  = SDSR_REF_NULL;
  sdsr_e_type       list    = SDSR_MAX;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( ss_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( acq_list, SDSR_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If start position is one of the magic values, set sr_ref variable
  ** accordingly.
  */
  switch( start_pos )
  {
    case SDSSSCR_FULL_SYS:
      list = sdss_sr_list_map( ss_ptr, SDSR_ACQ_FULL_SYS );
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_MINI_SYS:
      list = sdss_sr_list_map( ss_ptr, SDSR_ACQ_MINI_SYS );
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_MICRO_SYS:
      list = sdss_sr_list_map( ss_ptr, SDSR_ACQ_MICRO_SYS );
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_FULL2_SYS:
      list = sdss_sr_list_map( ss_ptr, SDSR_ACQ_FULL2_SYS );
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_MINI2_SYS:
      list = sdss_sr_list_map( ss_ptr, SDSR_ACQ_MINI2_SYS );
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_MICRO2_SYS:
      list = sdss_sr_list_map( ss_ptr, SDSR_ACQ_MICRO2_SYS );
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_DEEP_SYS:
      list = sdss_sr_list_map( ss_ptr, SDSR_ACQ_DEEP_SYS );
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_DEEP2_SYS:
      list = sdss_sr_list_map( ss_ptr, SDSR_ACQ_DEEP2_SYS );
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_SHALLOW_SYS:
      list = sdss_sr_list_map( ss_ptr, SDSR_ACQ_SHALLOW_SYS );
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_SHALLOW2_SYS:
      list = sdss_sr_list_map( ss_ptr, SDSR_ACQ_SHALLOW2_SYS );
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_EMERG_SYS:
      list = sdss_sr_list_map( ss_ptr, SDSR_EMERG_SYS );
      break;


    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_FULL_AOOS_SYS:
      list = sdss_sr_list_map( ss_ptr, SDSR_ACQ_FULL_AOOS_SYS );
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_FULL_OSR_SYS:
      list = sdss_sr_list_map( ss_ptr, SDSR_ACQ_FULL_OSR_SYS );
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_MICRO_ABSR_SYS:
      list = sdss_sr_list_map( ss_ptr, SDSR_ACQ_MICRO_ABSR_SYS );
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    default:
      break;

  } /* switch */

  if( list != SDSR_MAX ) {
    sr_ref = sdsr_list_get_ref( list, 0 );
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If start position is one of the magic values, and the corresponding
  ** system record reference is found on the acquisition list, set the
  ** acquisition start position to 1 over the matching position.
  */
  if( sr_ref != SDSR_REF_NULL &&
      (pos = sdsr_list_find_ref(acq_list, sr_ref)) != SDSR_POS_NULL )
  {
    start_pos = (word) pos + 1;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return start_pos;

} /* sdss_sr_list_find_acq_start_pos */




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_sr_list_set_acq_end_pos

DESCRIPTION
  Set the acquisition end position to one before the acquisition start
  position ( on behalf of the ACQ_XXX() acquisition constructs).
  constructs.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static  void                      sdss_sr_list_set_acq_end_pos(

        const sdss_s_type         *ss_ptr,
            /* Pointer to a System Selection information structure.
            */

        sdsr_e_type               acq_list,
            /* Acquisition list.
            */

        sdss_acq_mode_e_type      acq_mode,
            /* Acquisition mode.
            */

        int                       start_pos
            /* Acquisition start position.
            */
)
{
  sdsr_ref_type     sr_ref;
  int               end_pos;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( acq_list, SDSR_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( acq_mode, SDSS_ACQ_MODE_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If list is empty, return now.
  */
  if( sdsr_list_cnt(acq_list) <= 0 )
  {
    return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Set the acquisition end position to one before the acquisition start
  ** position.
  */
  if( start_pos == 0 )
  {
    end_pos = sdsr_list_cnt( acq_list ) - 1;
  }
  else
  {
    end_pos = start_pos - 1;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Get a reference to the acquisition end position.
  */
  sr_ref = sdsr_list_get_ref( acq_list, end_pos );
  SD_ASSERT( sr_ref != SDSR_REF_NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Depending on the acquistion mode, set the appropriate SDSR_ACQ_xxx_SYS.
  */
  switch( acq_mode )
  {
    case SDSS_ACQ_MODE_HO:
    case SDSS_ACQ_MODE_FULL:
      sdsr_list_put_ref( sdss_sr_list_map( ss_ptr, SDSR_ACQ_FULL_SYS ), sr_ref );
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_ACQ_MODE_MINI:
      sdsr_list_put_ref(sdss_sr_list_map( ss_ptr, SDSR_ACQ_MINI_SYS ), sr_ref );
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_ACQ_MODE_MICRO:
      sdsr_list_put_ref( sdss_sr_list_map( ss_ptr, SDSR_ACQ_MICRO_SYS ), sr_ref );
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_ACQ_MODE_FULL2:
      sdsr_list_put_ref( sdss_sr_list_map( ss_ptr, SDSR_ACQ_FULL2_SYS ), sr_ref );
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_ACQ_MODE_MINI2:
      sdsr_list_put_ref( sdss_sr_list_map( ss_ptr, SDSR_ACQ_MINI2_SYS ), sr_ref );
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_ACQ_MODE_MICRO2:
      sdsr_list_put_ref( sdss_sr_list_map( ss_ptr, SDSR_ACQ_MICRO2_SYS ), sr_ref );
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_ACQ_MODE_DEEP:
      sdsr_list_put_ref( sdss_sr_list_map( ss_ptr, SDSR_ACQ_DEEP_SYS ), sr_ref );
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_ACQ_MODE_DEEP2:
      sdsr_list_put_ref( sdss_sr_list_map( ss_ptr, SDSR_ACQ_DEEP2_SYS ),sr_ref );
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_ACQ_MODE_SHALLOW:
      sdsr_list_put_ref( sdss_sr_list_map( ss_ptr, SDSR_ACQ_SHALLOW_SYS ), sr_ref );
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_ACQ_MODE_SHALLOW2:
      sdsr_list_put_ref( sdss_sr_list_map( ss_ptr, SDSR_ACQ_SHALLOW2_SYS ), sr_ref );
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_ACQ_MODE_FULL_AOOS:
      sdsr_list_put_ref( sdss_sr_list_map( ss_ptr, SDSR_ACQ_FULL_AOOS_SYS ), sr_ref );
      break;

    case SDSS_ACQ_MODE_MICRO_ABSR:
      sdsr_list_put_ref( sdss_sr_list_map( ss_ptr, SDSR_ACQ_MICRO_ABSR_SYS ), sr_ref );
      break;

    case SDSS_ACQ_MODE_FULL_OSR:
      sdsr_list_put_ref( sdss_sr_list_map( ss_ptr, SDSR_ACQ_FULL_OSR_SYS ), sr_ref );
      break;

    case SDSS_ACQ_MODE_EOOS_FULL_RTN:
    #ifdef FEATURE_EOOS
      #error code not present
#else
      SD_ERR_0( "acq_mode");
      break;
    #endif
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    case SDSS_ACQ_MODE_EOOS_FULL2:
    case SDSS_ACQ_MODE_EOOS_FULL:
    case SDSS_ACQ_MODE_EOOS_FULL_RTN2:
    case SDSS_ACQ_MODE_PREV:
    case SDSS_ACQ_MODE_MAX:
    default:
      SD_ERR_0( "acq_mode");
      break;

  } /* switch */

} /* sdss_sr_list_set_acq_end_pos */




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_sr_list_create

DESCRIPTION
  Create a couterpart of limited system records based on the reference
  list/item. And update the reference list with the GW LTD list.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static  void                      sdss_sr_list_create(

        sd_ss_e_type              ss,
            /* System selection stack
            */

        sdsr_e_type               list
            /* System list/item refered to create the couterpart of limited
            ** systems.
            */

)
{
  int i;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( list, SDSR_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_MSG_HIGH_2( "Create GW LTD system, ss=%d reference list=%d", ss, list);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Populate the limited system from input list in reverse order as it
  ** is inserted to the GW LTD LIST. */
  for( i = sdsr_list_cnt( list ) - 1; i>=0;  i-- )
  {
    sdsr_list_update_gw_sys( ss,
                             sdsr_list_get_ref(list, i),
                             TRUE,
                             FALSE,
                             FALSE );
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Copy the limited system to list.*/
  sdsr_list_cpy( list, sdss_sr_list_map2( ss, SDSR_GWL_LAST_LTD_SYS) );

}




/* <EJECT> */
/*===========================================================================
=============================================================================
=============================================================================
================================ SCHEDULING =================================
=============================================================================
=============================================================================
===========================================================================*/


/*===========================================================================

FUNCTION sdss_sr_sched_inc

DESCRIPTION
  Increment the schedule field of the system record list.

  If we need to loop back to the beginning of the schedule, do so and also
  reset the schedule start time to the current uptime.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static  void                      sdss_sr_sched_inc(

        sdsr_s_type               *sr_ptr
            /* Pointer to a system record for which to increment the
            ** reacquisition schedule.
            */
)
{
  SD_ASSERT( sr_ptr != NULL );
  SD_ASSERT( INRANGE(sr_ptr->sched, 0, (ARR_SIZE(sdss_sched_arr)-2)) );
  SD_ASSERT( sdss_sched_arr[sr_ptr->sched] != SCHED_END );
  SD_ASSERT( sdss_sched_arr[sr_ptr->sched] != SCHED_LOOP );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Increment the schedule.
  */
  sr_ptr->sched++;

  if (sr_ptr->sched >= (ARR_SIZE(sdss_sched_arr)))
  {
    SD_ERR_1("sr_ptr->sched = %d, out of boundary",sr_ptr->sched);
    return;
  }
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If we need to loop back to the beginning of the schedule, do so.
  */
  if( sdss_sched_arr[sr_ptr->sched] == SCHED_LOOP )
  {
    while( sdss_sched_arr[sr_ptr->sched] != SCHED_START )
    {
      sr_ptr->sched--;
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If we are starting a schedule, increment the schedule counter to point
  ** at the first schedule element.
  */
  if( sdss_sched_arr[sr_ptr->sched] == SCHED_START )
  {
    sr_ptr->sched++;
  }

  if (sr_ptr->sched >= (ARR_SIZE(sdss_sched_arr)))
  {
    SD_ERR_1("sr_ptr->sched = %d, out of boundary",sr_ptr->sched);
    return;
  }
  SD_ASSERT( sdss_sched_arr[sr_ptr->sched] != SCHED_START );
  SD_ASSERT( sdss_sched_arr[sr_ptr->sched] != SCHED_LOOP );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If we did not reach the end of the schedule, set the reacquisition
  ** time_count field according to the schedule.
  */
  if( sdss_sched_arr[sr_ptr->sched] != SCHED_END )
  {
    sr_ptr->sched_prm.acq.time_cnt = sdss_sched_arr[sr_ptr->sched];
  }

} /* sdss_sr_sched_inc */




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_sr_sched_get_act

DESCRIPTION
  Return the action that is called for by the reacquisition schedule of a
  specified system record.

DEPENDENCIES
  None.

RETURN VALUE
  Action called for by the reacquisition schedule, as defined by
  sdss_sched_act_e_type.

SIDE EFFECTS
  None.

===========================================================================*/
static  sdss_sched_act_e_type     sdss_sr_sched_get_act(

        const sdsr_s_type         *sr_ptr
            /* Pointer to a system record for which to get the action called
            ** for by the reacquisition schedule.
            */
)
{
  byte              sched_time;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( sr_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If the schedule field is not set for reacquisitions, inform caller that
  ** schedule is ended.
  */
  if( sr_ptr->sched >= ARR_SIZE(sdss_sched_arr) )
  {
    return SDSS_SCHED_ACT_END;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If the reacquisition schedule is exhausted, inform caller that schedule
  ** is ended.
  */
  sched_time = sdss_sched_arr[sr_ptr->sched];

  SD_ASSERT( sched_time != SCHED_START &&
             sched_time != SCHED_LOOP )

  if( sched_time == SCHED_END )
  {
    return SDSS_SCHED_ACT_END;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If we got here, we have an active reacquisition schedule. If schedule is
  ** time based, check the time_cnt field against the current uptime to see
  ** whether the schedule is calling for a reacquisition attempt at or before
  ** the current time, return SDSS_SCHED_ACT_ACQ. Else, return
  ** SDSS_SCHED_ACT_WAIT.
  */
  if( SDSSSCR_SCHED_IS_TIME(sr_ptr->sched) )
  {
    if( time_get_uptime_secs() >= sr_ptr->event_time + sr_ptr->sched_prm.acq.time_cnt )
    {
      return SDSS_SCHED_ACT_ACQ;
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Else if schedule is count based, check the time_cnt field against the
  ** current acquisition counter.
  */
  else if( SDSSSCR_SCHED_IS_CNT(sr_ptr->sched) )
  {
    if( sr_ptr->sched_prm.acq.time_cnt == 0 )
    {
      return SDSS_SCHED_ACT_ACQ;
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Else, schedule is out of range - indicate that schedule is over.
  */
  else
  {
    return SDSS_SCHED_ACT_END;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return SDSS_SCHED_ACT_WAIT;

} /* sdss_sr_sched_get_act */




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_sr_is_sched

DESCRIPTION
  Check whether a system complies with a specific PRL designation value.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the system complies with the PRL specified designation value.
  FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean                   sdss_sr_is_sched(

        const sdsr_s_type         *sr_ptr,
            /* Pointer to a system record for which to check the schedule.
            */

        sdssscr_sched_e_type      sched
            /* Schedule against which to check.
            */
)
{
  int    i;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( sr_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( sched, SDSSSCR_SCHED_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Step backward to the beginning of the schedule. If a match is found
  ** before stepping into the previous schedule, return TRUE. Else, return
  ** FALSE.
  */
  for( i = (int) sr_ptr->sched;

       INRANGE(i, 0, (SDSSSCR_SCHED_MAX-1)) &&
       sdss_sched_arr[i] != SCHED_LOOP &&
       sdss_sched_arr[i] != SCHED_END;

       i-- )
  {
    if( i == (int) sched )
    {
      return TRUE;
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return FALSE;

} /* sdss_sr_is_sched */




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_sr_list_is_sched

DESCRIPTION
  Check whether a specified reacquisition schedule includes the reacquisition
  schedule of at least one of the systems that are referenced by a specified
  list.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the specified reacquisition schedule includes the reacquisition
  schedule of at least one of the systems that are referenced by a specified
  list. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean                       sdss_sr_list_is_sched(

        sd_ss_e_type                  ss,
            /* System selection stack.
            */

        sdsr_e_type                   list,
            /* List for which to check the reacquisition schedule.
            */

        sdsr_e_type                   sched_list,
            /* Schedule list.
            */

        sdssscr_sched_e_type          sched
            /* Schedule against which to check.
            */
)
{
  int                 i;
  sdsr_s_type         *sr_ptr;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( list, SDSR_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( sched_list, SDSR_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( sched, SDSSSCR_SCHED_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Step through the list and return TRUE
  ** if any of the systems that are referenced by this list is on the SCHED
  ** list and its reacquisition schedule is equals the specified
  ** reacquisition schedule value.
  **
  ** or if the system is avoided as specified.
  */
  for( i=0; (sr_ptr=sdsr_list_get_ptr(list, i)) != NULL; i++ )
  {
    if( sdsr_list_find(sched_list, sr_ptr) != SDSR_POS_NULL &&
        sdss_sr_is_sched(sr_ptr, sched) )
    {
      return TRUE;
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if( SDSSSCR_SCHED_IS_AVOID(sched))
  {
    for( i=0; (sr_ptr=sdsr_list_get_ptr(sched_list, i)) != NULL; i++ )
    {
      if( sdss_sr_is_avoid( ss,sr_ptr ) &&
          sr_ptr->sched == sched)
      {
        return TRUE;
      }

    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return FALSE;

} /* sdss_sr_list_is_sched */




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_sr_list_sched

DESCRIPTION
  Set the schedule field of the system records that are referenced by the
  list parameter as per the reacquisition schedule that is indicated by the
  acq_type, acq_mode and sched parameters.

  Insert the system records that are referenced by the list parameter at the
  beginning of the SDSR_SCHED_LST.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static  void                      sdss_sr_list_sched(

        sdsr_e_type               list,
            /* System record list for which to set the schedule for
            ** reacquisition attempts.
            */

        sdsr_e_type               sched_list,
            /* Schedule list.
            */

        sdssscr_sched_e_type      sched,
            /* Reacquisition schedule as defined by sdssscr_sched_e_type.
            */

        sdssscr_acq_e_type        acq_type,
            /* Reacquisition type to be attempted as defined by
            */

        sdss_acq_mode_e_type      acq_mode,
            /* Mode of reacquisition attempt.
            */

        sdsssr_sched_cond_e_type  sched_cond
            /* Indicate whether systems should be conditionally schedule
            ** depending whether they are not already on equal or higher
            ** priority reacquisition schedule.
            */
)
{
  int i;
  int cnt;
  int ins_pos = 0;
  sdsr_s_type       *sr_ptr;
  sdsr_ref_type     sr_ref;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( list, SDSR_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( sched_list, SDSR_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_MSG_HIGH_3( "Sched acq, list=%d, sched=%d time=%d",
               list, sched, time_get_uptime_secs() );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Step through the list and set the schedule, its start time and its
  ** reacquisition type for each system. Also insert the system into the
  ** specified schedule list.
  */
  cnt = sdsr_list_cnt(list);
  for( i=0; i<cnt ; i++ )
  {
    sr_ref = sdsr_list_get_ref(list, i);
    sr_ptr = sdsr_tbl_get_ptr(sr_ref);
    if (NULL == sr_ptr)
    {
      break;
    }

    /* If only systems that are not on equal or higher priority reacquisition
    ** schedule should be scheduled and the system is already on an equal or
    ** higher priority schedule, continue.
    */
    switch( sched_cond )
    {
      case SDSSSR_SCHED_COND_NOT_ON_HIGH_SCHED:

        if( sdsr_list_find(sched_list, sr_ptr) != SDSR_POS_NULL
            &&
            ( SDSSSCR_SCHED_IS_HIGH(sr_ptr->sched) ||
              SDSSSCR_SCHED_IS_LOW(sched) ))
        {
          continue;
        }
        break;

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSR_SCHED_COND_NOT_ON_SAME_SCHED:

        if( sdsr_list_find(sched_list, sr_ptr) != SDSR_POS_NULL &&
            sdss_sr_is_sched(sr_ptr, sched) )
        {
          continue;
        }
        break;

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSR_SCHED_COND_NOT_ON_EQUAL_OR_HIGHER_PRIORITY_SCHED_OR_AVOID:

        if( ( sdsr_list_find(sched_list, sr_ptr) != SDSR_POS_NULL &&
              sr_ptr->sched >= sched )
              ||
              SDSSSCR_SCHED_IS_AVOID( sr_ptr->sched ) )
        {
          continue;
        }
        break;

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSR_SCHED_COND_NOT_ON_EQUAL_OR_HIGHER_PRIORITY_SCHED_OR_AVOID_OR_FORBID:

        if( ( sdsr_list_find(sched_list, sr_ptr) != SDSR_POS_NULL &&
              sr_ptr->sched >= sched )
              ||
              SDSSSCR_SCHED_IS_AVOID( sr_ptr->sched )
              ||
              sdss_sr_is_prl(sr_ptr, SDSS_PRL_VAL_FORBID) )
        {
          continue;
        }
        break;

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSR_SCHED_COND_UNCONDITIONAL:
      case SDSSSR_SCHED_COND_NONE:
      case SDSSSR_SCHED_COND_MAX:
      default:
        break;
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    sr_ptr->sched               = (word)sched;
    sr_ptr->sched_prm.acq.type  = (byte)acq_type;
    sr_ptr->sched_prm.acq.mode  = (byte)acq_mode;
    sr_ptr->event_time          = time_get_uptime_secs();

    sdsr_print( sr_ptr, FALSE, sr_ref );

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /* Kick-start the reacquisition schedule.
    */
    sdss_sr_sched_inc( sr_ptr );

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /* Insert system into the specified schedule_list.
    */
    sr_ref = sdsr_list_get_ref( list, i );
    SD_ASSERT( sr_ref != SDSR_REF_NULL );
    sdsr_list_insert_ref( sched_list, ins_pos, sr_ref, TRUE );
    ins_pos++;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_MSG_HIGH_1( "  Sechule list count=%d",sdsr_list_cnt(sched_list));

} /* sdss_sr_list_sched */


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_sr_list_sched_proc

DESCRIPTION
  Given a list, do necessary scheduling related processing on this list.

DEPENDENCIES
  None.

RETURN VALUE
  The position of the first system record on the specified list that complies
  with the specified mode and band preference and for which the system
  record's schedule is calling for a reacquisition attempt at the current
  time if such a system record is found. SDSR_POS_NULL, otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
static  int                       sdss_sr_list_sched_proc(

        sd_ss_e_type              ss,
            /* system selection item.
             */

        sdsr_e_type               list,
            /* List over which to check the schedule.
            */

        sd_ss_mode_pref_e_type    mode_pref,
            /* Mode preference with which system should comply.
            */

        sd_ss_band_pref_e_type    band_pref,
            /* 3GPP band preference with which system should comply.
            */

        sys_lte_band_mask_e_type  lte_band_pref,
            /* LTE band preference with which system should comply.
            */

        sd_ss_band_pref_e_type    tds_band_pref
            /* TD-SCDMA band preference with which system should comply.
            */
)
{
  int i;
  sdsr_s_type       *sr_ptr;

  sd_ss_mode_pref_e_type    acq_mode_pref;
  sd_ss_band_pref_e_type    acq_band_pref;
  sys_lte_band_mask_e_type  acq_band_pref_lte;
  sd_ss_band_pref_e_type    acq_band_pref_tds;
  /*lint -esym(550, acq_bss_type_pref) */ /* not accessed */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( list, SDSR_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( mode_pref, SD_SS_MODE_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( band_pref, SD_SS_BAND_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( tds_band_pref, SD_SS_BAND_PREF_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Step through the list and increment the schedules of systems for which
  ** their schedule is calling for acquisition attempt at the current time,
  ** but are not available for acquisition attempt. A system is not available
  ** for acquisition attempt if one of the following is true:
  **
  ** 1. The system's mode/band combination is not supported by this target.
  ** 2. The system does not comply with the specified mode preferences.
  ** 3. The system does not comply with the specified band preferences.
  ** 4. Filtered band within the target capability,system mode, mode pref and
  **    band pref.
  ** 5. The system does not comply with the specified bss type preferences.
  ** 6. Other invalidity (checked by common-caused)
  */
  for( i=0; (sr_ptr=sdsr_list_get_ptr(list, i)) != NULL; i++ )
  {
    if( sdss_sr_sched_get_act(sr_ptr) == SDSS_SCHED_ACT_ACQ )
    {
      /* If the system under consideration has a SPECIFIC acquisition type,
      ** ignore the current mode and band preference.
      */
      if( sr_ptr->sched_prm.acq.type == SDSSSCR_ACQ_SPECIFIC ||
          sr_ptr->sched_prm.acq.type == SDSSSCR_ACQ_SPECIFIC_PRL )
      {
        acq_mode_pref     = SD_SS_MODE_PREF_ANY;
        acq_band_pref     = SD_SS_BAND_PREF_ANY;
        acq_band_pref_lte = SYS_LTE_BAND_MASK_CONST_ANY;
        acq_band_pref_tds = SD_SS_BAND_PREF_ANY;
      }
      else
      {
        acq_mode_pref     = mode_pref;
        acq_band_pref     = band_pref;
        acq_band_pref_lte = lte_band_pref;
        acq_band_pref_tds = tds_band_pref;
      }

      if(sdss_sr_list_is_skipped_system_common_causes( list,
                                                       i,
                                                       ss,
                                                       sr_ptr->is_mape? sdss_ptr(ss)->new_acq_cnt:0, //sched lst: new_acq_cnt not taking effect.
                                                       0, //unknown meas
                                                       SDSR_CAT_NON_COMPLY,
                                                       acq_mode_pref,
                                                       acq_band_pref,
                                                       acq_band_pref_lte,
                                                       acq_band_pref_tds,
                                                       sr_ptr,
                                                       NULL )
      )
      {
        /* System is not available for scan - increase schedule */
        sdss_sr_sched_inc( sr_ptr );
      }
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Step through the list and delete systems for which their schedules is
  ** exhausted.
  */
  for( i=0; (sr_ptr=sdsr_list_get_ptr(list, i)) != NULL; i++ )
  {
    if( sdss_sr_sched_get_act(sr_ptr) == SDSS_SCHED_ACT_END )
    {
      sdsr_list_del_pos( list, i );
      i--;
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Step through the list and look for first system for which its schedule
  ** is calling for acquisition attempt at the current time and is available
  ** for acquisition attempt. A system is available for acquisition attempt
  ** if all of the following are true:
  **
  ** 1. The system's mode and band combination is supported by this target.
  ** 2. The system complies with the specified mode preferences.
  ** 3. The system complies with the specified band preferences.
  ** 4. Filtered band within the target capability,system mode, mode pref and
  **    band pref
  **
  ** If such a system is found, return its position. Else, return
  ** SDSR_POS_NULL.
  */
  for( i=0; (sr_ptr=sdsr_list_get_ptr(list, i)) != NULL; i++ )
  {
    if(sdss_sr_sched_get_act(sr_ptr) == SDSS_SCHED_ACT_ACQ)
    {
      /* If the system under consideration has a SPECIFIC acquisition type,
      ** ignore the current mode and band preference.
      */
      if( sr_ptr->sched_prm.acq.type == SDSSSCR_ACQ_SPECIFIC ||
          sr_ptr->sched_prm.acq.type == SDSSSCR_ACQ_SPECIFIC_PRL )
      {
        acq_mode_pref = SD_SS_MODE_PREF_ANY;
        acq_band_pref = SD_SS_BAND_PREF_ANY;
        acq_band_pref_lte = SYS_LTE_BAND_MASK_CONST_ANY;
        acq_band_pref_tds = SD_SS_BAND_PREF_TDS_ANY;
      }
      else
      {
        acq_mode_pref = mode_pref;
        acq_band_pref = band_pref;
        acq_band_pref_lte = lte_band_pref;
        acq_band_pref_tds = tds_band_pref;
      }
      if(sdss_sr_list_is_skipped_system_common_causes( list,
                                                       i,
                                                       ss,
                                                       0, //sched lst: new_acq_cnt not taking effect.
                                                       0, //unknown meas
                                                       SDSR_CAT_NON_COMPLY,
                                                       acq_mode_pref,
                                                       acq_band_pref,
                                                       acq_band_pref_lte,
                                                       acq_band_pref_tds,
                                                       sr_ptr,
                                                       NULL )
      )
      {
        //scheduled system is not available for acquisition
        continue;
      }

      //scheduled system is available for acquisition
      return i;
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return SDSR_POS_NULL;

} /* sdss_sr_list_sched_proc */ /*lint +esym(550, acq_bss_type_pref) */

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_sr_list_sched_srv

DESCRIPTION
  Given a list, do necessary scheduling related servicing on this list.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static  void                      sdss_sr_list_sched_srv(

        sdsr_e_type               list,
            /* List over which to service the schedule.
            */

        sd_ss_mode_pref_e_type    mode_pref,
            /* Service only systems that complies with this mode preference.
            */

        sdsr_e_type               acq_list,
        int                       acq_pos
            /* List and position of the system record that is attempted
            ** acquisition.
            */
)
{
  int i;
  sdsr_s_type       *sr_ptr;
  sdsr_s_type       *acq_ptr;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( list, SDSR_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( mode_pref, SD_SS_MODE_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( acq_list, SDSR_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Point at system record that is attempted acquisition.
  */
  acq_ptr = sdsr_list_get_ptr( acq_list, acq_pos );
  SD_ASSERT( acq_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


  /* If the last system attempted acquisition is from the list over which
  ** schedule is being serviced (SCHED_LST), increment the systems schedule.
  */
  /*lint -save -e774 *//* Boolean within 'right side of && within if'
                           always evaluates to True*/
  if( ( acq_list == list ) && (acq_ptr != NULL) )/*lint -restore */
  {
    sdss_sr_sched_inc( acq_ptr );
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Step through the list and service the schedule of systems that are
  ** on count based reacquisition schedules as follows:
  **
  ** 1. Decrement the time_cnt filed of a system record that is on a count
  **    based reacquisition schedule and is currently NOT attempted
  **    acquisition.
  */
  for( i=0; (sr_ptr=sdsr_list_get_ptr(list, i)) != NULL; i++ )
  {
    /* If system does not complies with the designated mode preference,
    ** continue.
    */
    if( ! sdss_sr_is_mode_pref(sr_ptr, mode_pref) )
    {
      continue;
    }

    if( sr_ptr != acq_ptr &&
             SDSSSCR_SCHED_IS_CNT(sr_ptr->sched) &&
             sr_ptr->sched_prm.acq.time_cnt > 0 )
    {
      sr_ptr->sched_prm.acq.time_cnt--;
    }
  }

} /* sdss_sr_list_sched_srv */


/*===========================================================================

FUNCTION sdss_calc_max_temp_avoid_timer_from_list

DESCRIPTION
Given a list, calculate max of "(last_attempt_time + timer_val (i.e. T_MAP_RETRY)) - current uptime" .


DEPENDENCIES
This construct should be caled for lists containing only CDMA and MAPE systems.
Passed list should not have any non cdma and non mape systems.
It is assumed that the systems passed are all under avoidance and avoidance timer is still running.

RETURN VALUE
timer value.

SIDE EFFECTS
None.

===========================================================================*/
EXTERN dword sdss_calc_max_temp_avoid_timer_from_list(sdsr_e_type list, dword timer_val, sd_ss_e_type ss)
{

  int         i;
  sdsr_s_type     *sr_ptr;
  dword max_timer_i = 0;
  dword max_timer = 0;
  dword curr_uptime = time_get_uptime_secs();
  sdsr_e_type list_act;

  SD_ASSERT_ENUM_IS_INRANGE( list, SDSR_MAX );

  list_act = sdss_sr_list_map2(ss, list);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  if(sdsr_list_cnt(list_act) == 0)
  {
    SD_MSG_MED_1("sdss_calc_max_temp_avoid_timer_from_list: return as the list passed =%d was empty",list_act);
    max_timer = 0;
  }
  else
  {

    for( i=0; (sr_ptr=sdsr_list_get_ptr(list_act, i)) != NULL; i++ )
    {

      /* need to check if system is temp avoided and can be attempted via ACQ_ABSR_CNT */
      if(sdss_sr_is_absr(ss, sr_ptr))
      {
        if(sr_ptr->max_access_prob.absr_cnt == (byte)sdssscr_nv_item_get(SDSSSCR_NV_ITEM_TMR_CDMA_ABSR_COUNT))
        {
          /* since no attempt has been made on this system since it was put under avoidance, no neeed to consider it for timer value
          it can be attempted straight away, so skip this system record for calculating the max timer*/
          SD_MSG_HIGH_0("sdss_calc_max_temp_avoid_timer_from_list: cont as absr_cnt is still max");
          continue;
        }
      SD_MSG_MED_3("sdss_calc_max_temp_avoid_timer_from_list: curr_uptime = %d, last_attempt_uptime = %d, timer_val = %d",curr_uptime,sr_ptr->max_access_prob.last_attempt_uptime,timer_val);
      if((sr_ptr->max_access_prob.last_attempt_uptime + timer_val) > curr_uptime)
      {
        max_timer_i = sr_ptr->max_access_prob.last_attempt_uptime + timer_val - curr_uptime;
      }
      else
      {
        continue;
      }

        if(max_timer_i > max_timer)
        {
          max_timer = max_timer_i;
      SD_MSG_MED_1("sdss_calc_max_temp_avoid_timer_from_list: max_timer modified to %d",max_timer);
        }
      }
      else
      {
        SD_MSG_HIGH_0("sdss_calc_max_temp_avoid_timer_from_list: cont as sr_ptr is not under absr");
        continue; /* move to next system, as timers for permanent avoided systems are not to be started */
      }
    }
    }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  SD_MSG_HIGH_1("GSRDM: sdss_calc_max_temp_avoid_timer_from_list: return max_timer = %d",max_timer);
  return max_timer;
}

/*===========================================================================

FUNCTION sdss_update_hdr_activity

DESCRIPTION
  This routine sets is_hdr_activity.


DEPENDENCIES
  None.

RETURN VALUE

SIDE EFFECTS
  None.

===========================================================================*/
void                           sdss_update_hdr_activity(

        sd_ss_e_type                   ss,
          /* System selection stack
          */
       
        boolean                        is_hdr_activity

)
{

  sdss_s_type   *ss_ptr = NULL;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  ss_ptr = sdss_ptr( ss );
  SD_ASSERT(ss_ptr != NULL);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  
  /* Set hdr activity flag to true */
  ss_ptr->is_hdr_activity = is_hdr_activity;
}


/* <EJECT> */
/*===========================================================================
=============================================================================
=============================================================================
==================== ROUTINES FOR ACQUISITION THROTTLING ====================
=============================================================================
=============================================================================
===========================================================================*/


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_thrttl_update_state

DESCRIPTION
  Helper function which updates the state of throttling mechanism.


DEPENDENCIES
  This function must be called before any other sdss_xxx is called.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static  void                    sdss_thrttl_update_state(

        sdss_acq_thrttl_s_type  *acq_thrttl_ptr,
            /* Pointer to a acq. throttle information structure.
            */

        sdss_thrttl_state_e_type new_state
            /* New state of thrttl engine.
          */
)
{

  /* Update the state.
  */
  SD_ASSERT_ENUM_IS_INRANGE( new_state, SDSS_THRTTL_STATE_MAX );
  SD_ASSERT( acq_thrttl_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if(acq_thrttl_ptr->state != new_state)
  {
    SD_MSG_HIGH_2("Update thrttl state %d %d",
            new_state, acq_thrttl_ptr->state);
    acq_thrttl_ptr->state = new_state;

    /* Reinit if going back to INACT state.
    */
    if ( new_state == SDSS_THRTTL_STATE_INACT )
    {
      acq_thrttl_ptr->curr_stage = 0;
      acq_thrttl_ptr->acq_count  = 0;
    }

  }

} /* sdss_thrttl_update_state() */



/* <EJECT> */
/*===========================================================================

FUNCTION sdss_thrttl_inc_acq_count

DESCRIPTION
  Helper function which increments the acquisition count in the state.


DEPENDENCIES
  This function must be called before any other sdss_xxx is called.

RETURN VALUE
  TRUE - if all acquisitions are done in current stage.
  FALSE - not all acquisitions are done.

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean                    sdss_thrttl_inc_acq_count(

        sdss_acq_thrttl_s_type     *acq_thrttl_ptr
            /* Pointer to a acq. throttle information structure.
            */
)
{

  /* Local pointer to throttle backoff alogorithm table.
  */
  sdss_thrttl_stage_param_s_type *thrttl_tbl_ptr;


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT(acq_thrttl_ptr != NULL );
  thrttl_tbl_ptr =    acq_thrttl_ptr->thrttl_tbl_ptr;
  SD_ASSERT( thrttl_tbl_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( acq_thrttl_ptr->state, SDSS_THRTTL_STATE_MAX );
  SD_ASSERT( acq_thrttl_ptr->curr_stage < acq_thrttl_ptr->num_stages );


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_MSG_HIGH_3("Increment thrttl acq count %d %d %d",
              acq_thrttl_ptr->state,
              acq_thrttl_ptr->curr_stage,
              acq_thrttl_ptr->acq_count);


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Increment the count and set it to MAX.
  */
  if ( acq_thrttl_ptr->acq_count <
         thrttl_tbl_ptr[acq_thrttl_ptr->curr_stage].num_acq
     )
  {
    /* All acquisitions in this stage are not completed.
    */
    ++acq_thrttl_ptr->acq_count;
    return FALSE;

  }

  /* Done all acquisitions in this stage.
  */
  return TRUE;

} /* sdss_thrttl_inc_acq_count() */


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_thrttl_inc_curr_stage

DESCRIPTION
  Helper function which increments the current stage of throttling.


DEPENDENCIES
  This function must be called before any other sdss_xxx is called.

RETURN VALUE
  TRUE - reached the final stage.
  FALSE - not reached the final stage.

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean                    sdss_thrttl_inc_curr_stage(

        sdss_acq_thrttl_s_type     *acq_thrttl_ptr
            /* Pointer to a acq. throttle information structure.
            */
)
{

  /* Local pointer to throttle backoff alogorithm table.
  */
  sdss_thrttl_stage_param_s_type *thrttl_tbl_ptr;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT(acq_thrttl_ptr != NULL );
  thrttl_tbl_ptr =    acq_thrttl_ptr->thrttl_tbl_ptr;
  SD_ASSERT( thrttl_tbl_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( acq_thrttl_ptr->state, SDSS_THRTTL_STATE_MAX );
  SD_ASSERT( acq_thrttl_ptr->curr_stage < acq_thrttl_ptr->num_stages );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Suppress Lint and compiler warnings
  */
  SYS_ARG_NOT_USED(thrttl_tbl_ptr);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_MSG_HIGH_3("Increment thrttl curr stage %d %d %d",
              acq_thrttl_ptr->state,
              acq_thrttl_ptr->curr_stage,
              acq_thrttl_ptr->acq_count);


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Reset the acq_count.
  */
  acq_thrttl_ptr->acq_count = 0;


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Increment the count and set it to MAX.
  */
  if ( acq_thrttl_ptr->curr_stage < acq_thrttl_ptr->num_stages - 1)
  {
    /* Not reached the final stage.
    */
    ++acq_thrttl_ptr->curr_stage;
    return FALSE;

  }

  /* Reached the final stage.
  */
  return TRUE;

} /* sdss_thrttl_inc_curr_stage() */


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_thrttl_acq_init

DESCRIPTION
  Initializes the acquisition throttle mechanism.


DEPENDENCIES
  This function must be called before any other sdss_xxx is called.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static  void                    sdss_thrttl_acq_init(

        sdss_acq_thrttl_s_type  *acq_thrttl_ptr
            /* Pointer to a acq. throttle information structure.
            */
)
{
  SD_ASSERT( acq_thrttl_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  acq_thrttl_ptr->state          = SDSS_THRTTL_STATE_INACT;
  acq_thrttl_ptr->is_thrttl_on   = FALSE;
  acq_thrttl_ptr->thrttl_tbl_ptr = dflt_thrttl_tbl;
  acq_thrttl_ptr->num_stages     = ARR_SIZE(dflt_thrttl_tbl);
  sdss_thrttl_update_state ( acq_thrttl_ptr, SDSS_THRTTL_STATE_INACT );

} /* sdss_thrttl_acq_init() */


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_thrttl_acq_init

DESCRIPTION
  Initializes the acquisition throttle mechanism.


DEPENDENCIES
  This function must be called before any other sdss_xxx is called.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
void sdss_thrttl_init( void )
{
  sdss_s_type             *ss_ptr;

  ss_ptr = sdss_ptr(SD_SS_MAIN);
  sdss_thrttl_acq_init( &ss_ptr->acq_thrttl );
}


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_thrttl_enter_pwr_save

DESCRIPTION
  This routine preprocesses the PWR_SAVE_ENTER event pertaining to
  acquisition throttling engine.


DEPENDENCIES
  This function must be called before any other sdss_xxx is called.

RETURN VALUE
  sdss_thrttl_evt_status_e_type

SIDE EFFECTS
  None.

===========================================================================*/
static  sdss_thrttl_evt_status_e_type   sdss_thrttl_enter_pwr_save(

        sdss_acq_thrttl_s_type          *acq_thrttl_ptr,
            /* Pointer to a acq. throttle information structure.
            */

        dword                           *scr_timer_ptr,
          /* Pointer to the SS-script-engine's timer to be populated.
          */

        sdss_iact_s_type                *rtrn_iact_ptr
            /* Pointer to the return internal action.
            */

)
{

  /* Local pointer to throttle backoff alogorithm table.
  */
  sdss_thrttl_stage_param_s_type *thrttl_tbl_ptr;
  sdss_thrttl_evt_status_e_type  thrttl_evt_status =
                                         SDSS_THRTTL_EVT_STATUS_NOT_CONSUMED;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( acq_thrttl_ptr != NULL );
  thrttl_tbl_ptr =    acq_thrttl_ptr->thrttl_tbl_ptr;
  SD_ASSERT( thrttl_tbl_ptr != NULL );
  SD_ASSERT( rtrn_iact_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( acq_thrttl_ptr->state, SDSS_THRTTL_STATE_MAX );
  SD_ASSERT( acq_thrttl_ptr->curr_stage < acq_thrttl_ptr->num_stages );
  SD_ASSERT( scr_timer_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Process acquire action based on state.
  */
  switch ( acq_thrttl_ptr->state )
  {
    case SDSS_THRTTL_STATE_ENTER_PWR_SAVE:
      /* Ignore whether throttling is still enabled or not.
      */
      *scr_timer_ptr = time_get_uptime_secs() +
                          thrttl_tbl_ptr[acq_thrttl_ptr->curr_stage].delay;
      rtrn_iact_ptr->act = SDSS_IACT_CONTINUE;
      sdss_thrttl_update_state( acq_thrttl_ptr, SDSS_THRTTL_STATE_PWR_SAVE );
      thrttl_evt_status = SDSS_THRTTL_EVT_STATUS_CONSUMED;
      break;


    case SDSS_THRTTL_STATE_INACT:
    case SDSS_THRTTL_STATE_ACQ:
    case SDSS_THRTTL_STATE_PWR_SAVE:
      SD_MSG_HIGH_3("Ignore pwr_save enter thrttl state %d %d %d",
                  acq_thrttl_ptr->state,
                  acq_thrttl_ptr->curr_stage,
                  acq_thrttl_ptr->acq_count);
      break;


    case SDSS_THRTTL_STATE_MAX:
    default:
      sys_err_fatal_invalid_value_exception((int)acq_thrttl_ptr->state);
      break;

  }/* switch ( acq_thrttl_ptr->state ) */

  return thrttl_evt_status;

} /*  sdss_thrttl_enter_pwr_save */



/* <EJECT> */
/*===========================================================================

FUNCTION sdss_thrttl_pwr_save_timeout

DESCRIPTION
  This routine preprocesses the power save timeout event pertaining to
  acquisition throttling engine.


DEPENDENCIES
  This function must be called before any other sdss_xxx is called.

RETURN VALUE
  sdss_thrttl_evt_status_e_type

SIDE EFFECTS
  None.

===========================================================================*/
static  sdss_thrttl_evt_status_e_type  sdss_thrttl_pwr_save_timeout(

        sdss_acq_thrttl_s_type         *acq_thrttl_ptr,
            /* Pointer to a acq. throttle information structure.
            */

        dword                          *scr_timer_ptr,
          /* Pointer to the SS-script-engine's timer to be populated.
          */

        sdss_iact_s_type               *rtrn_iact_ptr
            /* Pointer to the return internal action.
            */

)
{

  /* Local pointer to throttle backoff alogorithm table.
  */
  sdss_thrttl_stage_param_s_type *thrttl_tbl_ptr;

  sdss_thrttl_evt_status_e_type  thrttl_evt_status = \
                                         SDSS_THRTTL_EVT_STATUS_NOT_CONSUMED;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( acq_thrttl_ptr != NULL );
  thrttl_tbl_ptr =    acq_thrttl_ptr->thrttl_tbl_ptr;
  SD_ASSERT( thrttl_tbl_ptr != NULL );
  SD_ASSERT( rtrn_iact_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( acq_thrttl_ptr->state, SDSS_THRTTL_STATE_MAX );
  SD_ASSERT( acq_thrttl_ptr->curr_stage < acq_thrttl_ptr->num_stages );
  SD_ASSERT( scr_timer_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Suppress Lint and compiler warnings
  */
  SYS_ARG_NOT_USED(thrttl_tbl_ptr);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Process acquire action based on state.
  */
  switch ( acq_thrttl_ptr->state )
  {
    case SDSS_THRTTL_STATE_PWR_SAVE:

      *scr_timer_ptr = 0;
      *rtrn_iact_ptr = acq_thrttl_ptr->last_acq_iact;
      thrttl_evt_status = SDSS_THRTTL_EVT_STATUS_CONSUMED;

      /* Check if throttling was disabled in the middle.
      */
      if ( !acq_thrttl_ptr->is_thrttl_on )
      {
        /* Throttling is disabled, move to STATE_INACT.
        */
        sdss_thrttl_update_state( acq_thrttl_ptr, SDSS_THRTTL_STATE_INACT );
      }
      else
      {
        /* Throttling is enabled.
        */
        sdss_thrttl_update_state( acq_thrttl_ptr, SDSS_THRTTL_STATE_ACQ );
        (void)sdss_thrttl_inc_curr_stage( acq_thrttl_ptr );
        (void)sdss_thrttl_inc_acq_count( acq_thrttl_ptr );
      }
      break;


    case SDSS_THRTTL_STATE_INACT:
    case SDSS_THRTTL_STATE_ACQ:
    case SDSS_THRTTL_STATE_ENTER_PWR_SAVE:
      SD_MSG_HIGH_3("Ignore pwr_save timeout thrttl state %d %d %d",
                    acq_thrttl_ptr->state,
                    acq_thrttl_ptr->curr_stage,
                    acq_thrttl_ptr->acq_count);
      break;


    case SDSS_THRTTL_STATE_MAX:
    default:
      sys_err_fatal_invalid_value_exception((int)acq_thrttl_ptr->state);
      break;

  }/* switch ( acq_thrttl_ptr->state ) */

  return thrttl_evt_status;

} /*  sdss_thrttl_pwr_save_timeout */


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_thrttl_iact_acq

DESCRIPTION
  This routine preprocesses the internal acquisition action.


DEPENDENCIES
  This function must be called before any other sdss_xxx is called.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static  void                           sdss_thrttl_iact_acq(

        sdss_acq_thrttl_s_type         *acq_thrttl_ptr,
            /* Pointer to a acq. throttle information structure.
            */

        sdss_iact_s_type               *rtrn_iact_ptr
            /* Pointer to the return internal action.
            */

)
{
  /* Local pointer to throttle backoff alogorithm table.
  */
  sdss_thrttl_stage_param_s_type *thrttl_tbl_ptr;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( acq_thrttl_ptr != NULL );
  thrttl_tbl_ptr =    acq_thrttl_ptr->thrttl_tbl_ptr;
  SD_ASSERT( thrttl_tbl_ptr != NULL );
  SD_ASSERT( rtrn_iact_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( acq_thrttl_ptr->state, SDSS_THRTTL_STATE_MAX );
  SD_ASSERT( acq_thrttl_ptr->curr_stage < acq_thrttl_ptr->num_stages );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Suppress Lint and compiler warnings
  */
  SYS_ARG_NOT_USED(thrttl_tbl_ptr);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Check if the return action is acq.
  */
  if ( rtrn_iact_ptr->act != SDSS_IACT_ACQUIRE )
  {
    /* It is not acquire action, so just return.
    */
    SD_MSG_HIGH_1(" thrttl act not acquire %d", rtrn_iact_ptr->act);
    return;
  }


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Check if throttling was disabled in the middle.
  */
  if ( !acq_thrttl_ptr->is_thrttl_on )
  {
    /* Throttling is disabled.
    */
    sdss_thrttl_update_state( acq_thrttl_ptr, SDSS_THRTTL_STATE_INACT );
    return;
  }


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If this is a handoff acquisition, don't throttle the acquisition
  */
  if( rtrn_iact_ptr->prm.acq.is_handoff_acq )
  {
    SD_MSG_HIGH_2("Handoff acq, ignore acq thrttl %d %d", rtrn_iact_ptr->act,
                                rtrn_iact_ptr->prm.acq.is_handoff_acq );
    return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Process acquire action based on state.
  */
  switch ( acq_thrttl_ptr->state )
  {
    case SDSS_THRTTL_STATE_INACT:
    case SDSS_THRTTL_STATE_ACQ:
      if ( sdss_thrttl_inc_acq_count( acq_thrttl_ptr ) )
      {
        /* All acquisitions in this stage are completed, do pwr save.
        */
        acq_thrttl_ptr->last_acq_iact = *rtrn_iact_ptr;
        rtrn_iact_ptr->act = SDSS_IACT_PWR_SAVE;
        sdss_thrttl_update_state( acq_thrttl_ptr, SDSS_THRTTL_STATE_ENTER_PWR_SAVE );
      }
      else
      {
        sdss_thrttl_update_state( acq_thrttl_ptr, SDSS_THRTTL_STATE_ACQ );
      }
      break;

    case SDSS_THRTTL_STATE_PWR_SAVE:
    case SDSS_THRTTL_STATE_ENTER_PWR_SAVE:
      sdss_thrttl_update_state( acq_thrttl_ptr, SDSS_THRTTL_STATE_ACQ );
      break;

    case SDSS_THRTTL_STATE_MAX:
    default:
      sys_err_fatal_invalid_value_exception((int)acq_thrttl_ptr->state);
      break;

  }/* switch ( acq_thrttl_ptr->state ) */


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return;

} /* sdss_thrttl_iact_acq() */

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_throttle_reset_cntrs

DESCRIPTION
  This function resets the throttling counters.Called when SD determines to
  idle on the acquired system.

DEPENDENCIES
  This function must be called before any other sdss_xxx is called.

RETURN VALUE

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                           sdss_throttle_reset_cntrs(

        sd_ss_e_type                   ss
          /* System selection stack.
          */

)
{

  sdss_s_type   *ss_ptr   = sdss_ptr( ss );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Check if throttle is disabled.
  */
  if ( !ss_ptr->acq_thrttl.is_thrttl_on )
  {
    /* It is disabled.
    */
    return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Reset the throttle counters.
  */
  SD_MSG_HIGH_2("Reset thrttl cntrs for ss=%d state=%d",
              ss,
              ss_ptr->acq_thrttl.state);
  ss_ptr->acq_thrttl.acq_count = 0;
  ss_ptr->acq_thrttl.curr_stage = 0;

} /* sdss_throttle_reset_cntrs() */



/* <EJECT> */
/*===========================================================================

FUNCTION sdss_hdr_bcmcs_start_uptime_update

DESCRIPTION
  This function indicate the HDR BCMCS flow monitoring is started. It updates
  the start time with the uptime.

DEPENDENCIES
  This function must be called before any other sdss_xxx is called.

RETURN VALUE

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                           sdss_hdr_bcmcs_start_uptime_update(

        sd_ss_e_type                   ss
          /* System selection stack.
          */
)
{

  dword               uptime = time_get_uptime_secs();

  sdss_s_type   *ss_ptr   = sdss_ptr( ss );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ss_ptr->hdr_bcmcs_start_uptime = uptime;

  return;

}/* sdss_hdr_bcmcs_start_uptime_update */



/* <EJECT> */
/*===========================================================================

FUNCTION sdss_hdr_bcmcs_stop_uptime_update

DESCRIPTION
  This function indicate the HDR BCMCS flow monitoring is stopped. It updates
  the stop time with the uptime.

DEPENDENCIES
  This function must be called before any other sdss_xxx is called.

RETURN VALUE

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                           sdss_hdr_bcmcs_stop_uptime_update(

        sd_ss_e_type                   ss
          /* System selection stack.
          */
)
{

  dword               uptime = time_get_uptime_secs();

  sdss_s_type   *ss_ptr   = sdss_ptr( ss );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ss_ptr->hdr_bcmcs_stop_uptime = uptime;

  return;

}/* sdss_hdr_bcmcs_start_uptime_update */




/* <EJECT> */
/*===========================================================================
=============================================================================
=============================================================================
========================= ACQUISITION STATE MACHINE =========================
=============================================================================
=============================================================================
===========================================================================*/

/* Macro to map a list into a system record list in the context of an
** acquisition state machine.
*/
#define ACQ_LIST( list )        sdss_sr_list_map( acq_ptr->ss_ptr, list )


/*===========================================================================

FUNCTION sdss_acq_init

DESCRIPTION
  Initialized an acquisition state machine with a specific system record list
  and acquisition type.

  NOTE! this function must be called before any other sdss_acq_xxx is called.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static  void                    sdss_acq_init(

        sdss_acq_s_type         *acq_ptr,
            /* Pointer an acquisition state machine to be initialized.
            */

        sdss_s_type             *ss_ptr,
            /* Pointer to a System Selection information structure.
            */

        sdsr_e_type             list,
            /* System record list over which acquisition is to be attempted.
            */

        int                     start_pos,
            /* Position from which list traversal should start.
            */

        int                     max_num,
            /* Limit for the number of acquisitions to be attempted.
            */

        dword                   max_uptime,
            /* Limit for the duration over which to attempt acquisitions.
            */

        sdssscr_con_e_type      acq_con,
            /* Acquisition script construct that is calling for the
            ** acquisition attempt.
            */

        sdssscr_acq_e_type      acq_type,
            /* Acquisition type that is being attempted.
            */

        sdss_acq_mode_e_type    acq_mode,
            /* Mode of acquisition that is being attempted.
            */

        byte                    new_acq_cnt,
            /* The current value of the new-acquisition counter - only
            ** systems with different new-acquisition count should be
            ** attempted acquisition.
            */

        int2                    meas_val,
            /* The measurement value with which system should comply.
            */

       sdsr_cat_e_type          meas_cat
           /* The category for which measurement value should apply
           */
)
{
  int   list_cnt;
  sd_ss_e_type      ss                = SD_SS_MAIN;


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( acq_ptr != NULL );
  SD_ASSERT( ss_ptr != NULL );

  SD_ASSERT_ENUM_IS_INRANGE( list, SDSR_MAX );
  SD_ASSERT( start_pos >= 0 );

  SD_ASSERT( INRANGE(acq_con, SDSSSCR_CON_ACQ, SDSSSCR_CON_ACQ_NETLIST) );
  SD_ASSERT_ENUM_IS_INRANGE( acq_type, SDSSSCR_ACQ_MAX );
  SD_ASSERT( acq_type != SDSSSCR_ACQ_SAME_AS_LAST );
  SD_ASSERT_ENUM_IS_INRANGE( acq_mode, SDSS_ACQ_MODE_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  #if ( defined(FEATURE_HDR_HYBRID))
  if( ss_ptr == sdss_ptr(SD_SS_HYBR_1) )
  {
    ss = SD_SS_HYBR_1;
  }
  #endif /* FEATURE_HDR_HYBRID */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if(!sdss_is_featuremode(SYS_OVERALL_FEATURE_MODE_NORMAL))
  {
    if(ss_ptr == sdss_ptr(SD_SS_HYBR_2))
    {
      ss = SD_SS_HYBR_2;
    }
  }

  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  if(ss_ptr == sdss_ptr(SD_SS_HYBR_3))
  {
    ss = SD_SS_HYBR_3;
  }
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_MSG_HIGH_3( "Acq start, list=%d,type=%d,mode=%d",
                list, acq_type, acq_mode );

  sdsr_list_print( list, FALSE );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Set the ss to point at the associated system selection enum type
  */
  acq_ptr->ss             = ss;


  /* Point at associated system selection information structure.
  */
  acq_ptr->ss_ptr         = ss_ptr;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Set the ACQ-State to start.
  */
  acq_ptr->state          = SDSS_ACQ_STT_START;
  acq_ptr->prev_state     = SDSS_ACQ_STT_START;

  /* If we started new acquisition, we could be interrupted while in recursive
  ** BSR phase so we need to clear the recursive tracking list (MORE_PREF_SCANNED).
  */
  if (ss == SD_SS_MAIN || ss == SD_SS_HYBR_1)
  {
    sdsr_list_clr( ACQ_LIST(SDSR_MORE_PREF_SCANNED_LST) );
    sdss_set_remove_gwl_on_bsr(ss,FALSE);
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Set the system record list to be traversed during the SDSS_ACQ_STT_START
  ** state.
  */
  acq_ptr->acq_lst = list;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Remember the list count.
  */
  list_cnt = sdsr_list_cnt( list );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Set the position from which list traversal should start.
  */
  if( start_pos >= list_cnt )
  {
    acq_ptr->acq_start_pos = 0;
  }
  else
  {
    acq_ptr->acq_start_pos = start_pos;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Set the number of list elements left to be traversed.
  */
  acq_ptr->acq_left       = max_num;

  /* Set the time limit for the acquisition attempts.
  */
  acq_ptr->acq_max_uptime = max_uptime;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Set the acquisition traversal position to none and indicate that list
  ** end was not reached.
  */
  acq_ptr->acq_pos                = SDSR_POS_NULL;
  acq_ptr->is_acq_lst_end_reached = FALSE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Record the acquisition script construct that is calling for this
  ** acquisition attempt.
  */
  acq_ptr->acq_con        = acq_con;

  /* Set the type and mode of the acquisition attempt.
  */
  acq_ptr->acq_type       = acq_type;
  acq_ptr->prev_acq_mode  = acq_ptr->acq_mode;
  acq_ptr->acq_mode       = acq_mode;

  /* Set the value of the new-acquisition counter.
  */
  acq_ptr->new_acq_cnt    = new_acq_cnt;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Set the measurement value with which system should comply.
  */
  acq_ptr->meas_val       = meas_val;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Set the measurement system category in which meas_val should comply.
  */
  acq_ptr->meas_cat       = meas_cat;


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Set the AMPS 2nd strongest control channel indication to FALSE.
  */
  acq_ptr->is_amps_2nd_cch = FALSE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Set the system record list to be traversed during the
  ** SDSS_ACQ_STT_MORE_PREF state, set the list traversal position to
  ** NULL and clear the list.
  */
  acq_ptr->start_sys      = ACQ_LIST( SDSR_START_SYS );
  acq_ptr->pref_lst       = ACQ_LIST( SDSR_START_PREF_LST );
  acq_ptr->pref_pos       = SDSR_POS_NULL;
  sdsr_list_clr( acq_ptr->pref_lst );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Set the system record list to be attempted acquisition when a
  ** the reacquisition schedule of a particular system is calling for a
  ** reacquisition attempt.
  */
  acq_ptr->sched_lst      = ACQ_LIST( SDSR_SCHED_LST );
  acq_ptr->sched_pos      = SDSR_POS_NULL;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initialize the rtrn act to MAX.
  */
  acq_ptr->rtrn_iact.act  = SDSS_IACT_MAX;

} /* sdss_acq_init */



/* <EJECT> */
/*===========================================================================

FUNCTION sdss_acq_is_amps_2nd_cch

DESCRIPTION
  Check whether 2nd strongest AMPS control channel needs to be attempted
  acquisition.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if 2nd strongest AMPS control channel needs to be attempted
  acquisition. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean                 sdss_acq_is_amps_2nd_cch(


        sdss_acq_s_type         *acq_ptr,
            /* Pointer an acquisition state machine in question.
            */

        sdsr_e_type             list,
            /* List for which to check AMPS 2nd strongest condition.
            */

        int                     pos,
            /* List position for which to check AMPS 2nd strongest condition.
            */

        sdssscr_acq_e_type      acq_type,
            /* Acquistion type that is attempted.
            */

        sdss_iact_s_type        *rtrn_iact_ptr
            /* Pointer to a buffer where to place returned internal action.
            */
)
{
  sdsr_s_type       *sr_ptr;
  boolean           is_sys_conf = FALSE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( acq_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( list, SDSR_MAX );
  SD_ASSERT( pos != SDSR_POS_NULL );
  SD_ASSERT_ENUM_IS_INRANGE( acq_type, SDSSSCR_ACQ_MAX );
  SD_ASSERT( rtrn_iact_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Point at the system in question.
  */
  sr_ptr = sdsr_list_get_ptr( list, pos );
  SD_ASSERT( sr_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Assume 2nd strongest AMPS control channel does not need to be attempted
  ** acquisition.
  */
  rtrn_iact_ptr->prm.acq.is_amps_2nd_cch = FALSE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If the mode of the system in question is other than AMPS, return FALSE.
  *//*lint -e774 *//* Suppress the if statement is always true */
  if( sr_ptr == NULL ||
      sr_ptr->sys.mode != SD_MODE_AMPS )/*lint +e774 */
  {
    return FALSE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If 2nd strongest AMPS control channel was already attempted acquisition,
  ** return FALSE.
  */
  if( acq_ptr->is_amps_2nd_cch )
  {
    return FALSE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Decide whether the system conflicts with the specified acquisition type.
  */
  switch( acq_type )
  {
    case SDSSSCR_ACQ_SPECIFIC:

      /* If acquisition type is SPECIFIC, indicate whether the SID/NID that
      ** was obtained during acquisition conflicts the expected SID/NID.
      */
      if( ! sdss_sr_is_sid_match_exp_sid(sr_ptr) )
      {
        is_sys_conf = TRUE;
        SD_MSG_HIGH_0( "SID/PLMN mismatched for specific acq");
      }
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_ACQ_SPECIFIC_PRL:

      /* If acquisition type is SPECIFIC_PRL, indicate whether the SID/NID
      ** that was obtained during acquisition conflicts the expected SID/NID
      ** or is forbidden by the PRL.
      */
      if( ! sdss_sr_is_sid_match_exp_sid(sr_ptr) ||
          sdss_sr_is_prl(sr_ptr, SDSS_PRL_VAL_FORBID) )
      {
        is_sys_conf = TRUE;
      }
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_ACQ_SPECIFIC_PREF:

      /* If acquisition type is SPECIFIC_PREF, indicate whether the SID that
      ** was obtained during acquisition conflicts the expected SID,
      ** conflicts with the SS-Preference or is forbidden by the PRL.
      */
      if( ! sdss_sr_is_sid_match_exp_sid(sr_ptr)
                          ||
          sdss_sr_is_pref_conf0(acq_ptr->ss,
                                sr_ptr,
                                SDSS_PREF_CONF_ANY,
                                FALSE)
                          ||
          sdss_sr_is_prl(sr_ptr, SDSS_PRL_VAL_FORBID) )
      {
        is_sys_conf = TRUE;
      }
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_ACQ_COLLOC_PREF:
    case SDSSSCR_ACQ_COLLOC_MORE_PREF:
    case SDSSSCR_ACQ_COLLOC_BEST_PREF:
    case SDSSSCR_ACQ_ANY:
    case SDSSSCR_ACQ_ALLOWED:
    case SDSSSCR_ACQ_PREFERRED:
    case SDSSSCR_ACQ_BEST_PREF:
    case SDSSSCR_ACQ_REG_BEST_PREF:
    case SDSSSCR_ACQ_MORE_PREF:
    case SDSSSCR_ACQ_MORE_PREF_THAN_SRV_SYS:
    case SDSSSCR_ACQ_NOT_LESS_PREF:
    case SDSSSCR_ACQ_NOT_LESS_PREF_OR_HOME:
    case SDSSSCR_ACQ_SAME_AS_LAST:
    case SDSSSCR_ACQ_MAX:
    default:

      /* For all other acquisition types indicate whether the acquired system
      ** conflicts with the SS-Preference or is forbidden by the PRL.
      */
      if( sdss_sr_is_pref_conf0(acq_ptr->ss,
                                sr_ptr,
                                SDSS_PREF_CONF_ANY,
                                FALSE)
                            ||
          sdss_sr_is_prl(sr_ptr, SDSS_PRL_VAL_FORBID) )
      {
        is_sys_conf = TRUE;
      }
      break;

  } /* switch */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If acquired system does conflicts with the acquisition type, return
  ** FALSE.
  */
  if( ! is_sys_conf )
  {
    return FALSE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If we got here, instruct SS-Client to attempt 2nd strongest AMPS control
  ** channel.
  */
  acq_ptr->is_amps_2nd_cch                = TRUE;

  rtrn_iact_ptr->act                      = SDSS_IACT_ACQUIRE;
  rtrn_iact_ptr->prm.acq.list             = list;
  rtrn_iact_ptr->prm.acq.pos              = pos;
  rtrn_iact_ptr->prm.acq.is_amps_2nd_cch  = TRUE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return TRUE;

} /* sdss_acq_is_amps_2nd_cch */

/*===========================================================================

FUNCTION sdss_acq_ltd_reg_opti

DESCRIPTION
  Select the next system to be attempted acquisition in the context of the
  SDSS_ACQ_STT_START state and instruct the caller of the next
  SS-Internal-Action to take.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the entire list that is currently being associated with the
  acquisition state machine is exhausted. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean                 sdss_acq_ltd_reg_opti(

        sd_ss_e_type            ss
)
{
  sys_srv_status_e_type    ss_srv_status     = SYS_SRV_STATUS_NONE;

  SD_ASSERT_ENUM_IS_INRANGE(ss,SD_SS_MAX);

  if( ss == SD_SS_MAX )
  {
    return FALSE;
  }

  sdss_read_srv_status( ss, &ss_srv_status, NULL );

  return ( ss_srv_status == SYS_SRV_STATUS_LIMITED_REGIONAL
           &&
           !sdss_is_target_cap_3gpp_only(ss) );

}

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_acq_next

DESCRIPTION
  Select the next system to be attempted acquisition in the context of the
  SDSS_ACQ_STT_START state and instruct the caller of the next
  SS-Internal-Action to take.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the entire list that is currently being associated with the
  acquisition state machine is exhausted. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean                 sdss_acq_next(

        sdss_acq_s_type         *acq_ptr,
            /* Pointer an acquisition state machine to process the SS-Event.
            */

        sdss_acq_mode_e_type    acq_mode,
            /* Acq mode for avoided system
            */

        sd_ss_mode_pref_e_type  mode_pref,
            /* Current mode preference.
            */

        sd_ss_band_pref_e_type  band_pref,
            /* Current band preference (3G)
            */

        sys_lte_band_mask_e_type  lte_band_pref,

        sd_ss_band_pref_e_type  tds_band_pref,
            /* Current band preference (TD-SCDMA)
            */

        sdss_iact_s_type        *rtrn_iact_ptr
            /* Pointer to a buffer where to place returned internal action.
            */
)
{
  boolean           list_is_exhausted = FALSE;
  byte              new_acq_cnt;
  sdsr_s_type       *sr_ptr           = NULL;
  int               next_pos;
  #if defined(FEATURE_SD_LTE) && defined( SD_DEBUG )
  #error code not present
#endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( acq_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( mode_pref, SD_SS_MODE_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( band_pref, SD_SS_BAND_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( tds_band_pref, SD_SS_BAND_PREF_MAX );
  #if defined(FEATURE_SD_LTE)&& defined( SD_DEBUG )
  #error code not present
#endif
  SD_ASSERT( rtrn_iact_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  new_acq_cnt = acq_ptr->new_acq_cnt;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If acquisition time is expired, indicate that acquisition list traversal
  ** is over.
  */
   {
     qword time_now = { 0 };
     dword uptime = time_get_uptime_secs();

     /* Read the current time
     */
     time_get_uptime_ms( time_now );

     /* Lint complains about suspicious cast, time_now is of type qword and
     ** we are casting it to uint64 and then taking the modulus of the
     ** resulting number
     */
     /*lint -e740 */
     if( (QW_CVT_Q2N(time_now) % 1000 ) >= 500 )
     /*lint +e740 */
     {
       uptime++;
     }

    if( uptime > acq_ptr->acq_max_uptime )
    {
      SD_MSG_HIGH_0("uptime exceeded max uptime for scan");
      list_is_exhausted = TRUE;
      return list_is_exhausted;
    }
   }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Check whether the schedule of any of the systems that are on a
  ** reacquisition schedule (i.e. on the sched list) is calling for
  ** reacquisition attempt at the current time. If so, attempt to acquire
  ** such a system.
  */
  acq_ptr->sched_pos = sdss_sr_list_sched_proc( acq_ptr->ss,
                                                acq_ptr->sched_lst,
                                                mode_pref,
                                                band_pref,
                                                lte_band_pref,
                                                tds_band_pref);

  /* If the count or time has expired, return list is exhausted
  */

  if( acq_ptr->sched_pos != SDSR_POS_NULL )
  {

    rtrn_iact_ptr->act           = SDSS_IACT_ACQUIRE;
    rtrn_iact_ptr->prm.acq.list  = acq_ptr->sched_lst;
    rtrn_iact_ptr->prm.acq.pos   = acq_ptr->sched_pos;

    SD_MSG_HIGH_2(" list %d, pos %d",acq_ptr->sched_lst, acq_ptr->sched_pos);

    /* Get the mode of the scheduled acquisition.
    */
    sr_ptr = sdsr_list_get_ptr( acq_ptr->sched_lst, acq_ptr->sched_pos );
    if( sr_ptr == NULL )
    {
      SD_ERR_0("sr_ptr NULL");
      return list_is_exhausted;
    }
    rtrn_iact_ptr->prm.acq.mode  = (sdss_acq_mode_e_type)
                                                  sr_ptr->sched_prm.acq.mode;

    ///* Set the new acquisition counter of the system that is attempted
    //** acquisition per the current value of the acquisition counter.
    //*/
    //sr_ptr->new_acq_cnt = acq_ptr->new_acq_cnt;

    return list_is_exhausted;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If we got here, no schedule is calling for reacquisition attempt at
  ** the current time, so check whether acquisition list traversal should
  ** continue.
  */

  /* Decrement the number of acquisitions left - if it is < 0, indicate that
  ** acquisition list traversal is over.
  */
  acq_ptr->acq_left--;
  if( acq_ptr->acq_left < 0 )
  {
    list_is_exhausted = TRUE;

    return list_is_exhausted;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If we got here, acquisition list traversal should continue.
  */

  /* If acquisition construct is ACQ_ALL, ignore the new_acq_count by
  ** setting it to 0.
  */
  if( acq_ptr->acq_con == SDSSSCR_CON_ACQ_ALL )
  {
    new_acq_cnt = 0;
  }

  /* If acquisition type is SPECIFIC, get next system regardless of the
  ** current mode and band preference.
  */
  if( acq_ptr->acq_type == SDSSSCR_ACQ_SPECIFIC ||
      acq_ptr->acq_type == SDSSSCR_ACQ_SPECIFIC_PRL )
  {
    mode_pref = SD_SS_MODE_PREF_ANY;
    band_pref = SD_SS_BAND_PREF_ANY;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Find next system on the acquisition list that complies with the current
  ** mode and band preference.
  */
  next_pos = sdss_sr_list_find_next( acq_ptr->ss,
                                     acq_ptr->acq_con,
                                     acq_mode,
                                     acq_ptr->acq_lst,
                                     acq_ptr->acq_pos+1,
                                     new_acq_cnt,
                                     acq_ptr->meas_val,
                                     mode_pref,
                                     band_pref,
                                     lte_band_pref,
                                     tds_band_pref,
                                     acq_ptr->meas_cat );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If acquisition start position != 0 and list traversal reached the end of
  ** the list, loop back to start of list.
  */
  if( acq_ptr->acq_start_pos != 0 &&
      next_pos == SDSR_POS_NULL &&
      ! acq_ptr->is_acq_lst_end_reached )
  {
    acq_ptr->is_acq_lst_end_reached = TRUE;

    next_pos = sdss_sr_list_find_next( acq_ptr->ss,
                                       acq_ptr->acq_con,
                                       acq_mode,
                                       acq_ptr->acq_lst,
                                       0,
                                       new_acq_cnt,
                                       acq_ptr->meas_val,
                                       mode_pref,
                                       band_pref,
                                       lte_band_pref,
                                       tds_band_pref,
                                       acq_ptr->meas_cat );
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If list is exhausted, indicate so.
  */
  if( next_pos == SDSR_POS_NULL
                     ||
      (acq_ptr->is_acq_lst_end_reached &&
       next_pos >= acq_ptr->acq_start_pos) )
  {
    list_is_exhausted = TRUE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If list is not exhausted, attempt to acquire the next system. Else set
  ** the acquisition end position to one before the acquisition start
  ** position.
  */
  if( ! list_is_exhausted )
  {
    acq_ptr->acq_pos              = next_pos;

    rtrn_iact_ptr->act            = SDSS_IACT_ACQUIRE;
    rtrn_iact_ptr->prm.acq.list   = acq_ptr->acq_lst;
    rtrn_iact_ptr->prm.acq.pos    = acq_ptr->acq_pos;

    if( acq_ptr->acq_type == SDSSSCR_ACQ_REG_BEST_PREF &&
        sdss_is_mmss_operation(acq_ptr->ss))
    {
      switch(acq_ptr->state)
      {
        case SDSS_ACQ_STT_START:
          rtrn_iact_ptr->prm.acq.gwl_acq_type.acq_type = SDSS_GWL_ACQ_FIRST_PLMN;
          break;
        case SDSS_ACQ_STT_MORE_PREF:
          rtrn_iact_ptr->prm.acq.gwl_acq_type.acq_type = SDSS_GWL_ACQ_BEST_PLMN;
          break;
        case SDSS_ACQ_STT_REACQ_GWL:
          rtrn_iact_ptr->prm.acq.gwl_acq_type.acq_type = SDSS_GWL_ACQ_REG_GIVEN_PLMN;
          break;
        case SDSS_ACQ_STT_NONE:
        case SDSS_ACQ_STT_DONE:
        case SDSS_ACQ_STT_REACQ:
        case SDSS_ACQ_STT_REACQ_FULL_SRV:
        case SDSS_ACQ_STT_SUSPEND:
        case SDSS_ACQ_STT_PWR_SAVE:
        case SDSS_ACQ_STT_PWR_SAVE_ENTER:
        case SDSS_ACQ_STT_SCAN_CONT:
        case SDSS_ACQ_STT_MAX:
        default:
          rtrn_iact_ptr->prm.acq.gwl_acq_type.acq_type = SDSS_GWL_ACQ_NONE;
          break;
      }
      SD_MSG_HIGH_2("MMSS:gwl acq type %d state %d",
                                rtrn_iact_ptr->prm.acq.gwl_acq_type.acq_type,
                                acq_ptr->state);
    }

    if( acq_ptr->acq_mode == SDSS_ACQ_MODE_HO )
    {
      rtrn_iact_ptr->prm.acq.mode           = SDSS_ACQ_MODE_FULL;
      rtrn_iact_ptr->prm.acq.is_handoff_acq = TRUE;
    }
    else
    {
      rtrn_iact_ptr->prm.acq.mode           = acq_ptr->acq_mode;
      rtrn_iact_ptr->prm.acq.is_handoff_acq = FALSE;
    }

    ///* Set the new acquisition counter of the system that is attempted
    //** acquisition per the current value of the acquisition counter.
    //*/
    //sr_ptr = sdsr_list_get_ptr( acq_ptr->acq_lst, acq_ptr->acq_pos );
    //SD_ASSERT( sr_ptr != NULL );
    //sr_ptr->new_acq_cnt = acq_ptr->new_acq_cnt;
  }
  else
  {
    sdss_sr_list_set_acq_end_pos( acq_ptr->ss_ptr,
                                  acq_ptr->acq_lst,
                                  acq_ptr->acq_mode,
                                  acq_ptr->acq_start_pos );
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Instruct the caller whether the entire acquisition list is exhausted.
  */
  return list_is_exhausted;

} /* sdss_acq_next */

/*===========================================================================

FUNCTION sdss_eng_scr_con_acq_fail

DESCRIPTION
  Indicate that acquisition over all systems has failed.

DEPENDENCIES
  None.

RETURN VALUE
  None

SIDE EFFECTS
  None.

===========================================================================*/
static  void                    sdss_eng_scr_con_acq_fail(

        sd_ss_e_type              ss
            /* System selection stack.
            */
)
{
  /* ACQ_FAIL - Indicate that acquisition over all systems has failed.
  */
  sd_si_acq_fail( ss );

  /* Cancel the avoidance of which schedule is set to
  ** SDSSSCR_SCHED_AVOID_UNTIL_ACQ_FAIL.
  */
  sdss_sr_list_avoid( ss,
                      SDSR_TBL_LST,
                      0,
                      SDSSSCR_SCHED_AVOID_UNTIL_ACQ_FAIL );

  /* Cancel the avoidance of which schedule is set to
  ** SDSSSCR_SCHED_AVOID_UNTIL_ACQ_FAIL_DUR_CALL_ORIG.
  */
  sdss_sr_list_avoid( ss,
                      SDSR_TBL_LST,
                      0,
                      SDSSSCR_SCHED_AVOID_UNTIL_ACQ_FAIL_DUR_CALL_ORIG );

  /* Cancel the avoidance of which schedule is set to
  ** SDSSSCR_SCHED_AVOID_UNTIL_ACQ_FAIL_DUR_OPTI_REDIAL.
  */
  sdss_sr_list_avoid( ss,
                      SDSR_TBL_LST,
                      0,
                      SDSSSCR_SCHED_AVOID_UNTIL_ACQ_FAIL_DUR_OPTI_REDIAL );
}

/*===========================================================================

FUNCTION sdss_eng_scr_con_hybr_bsr_to_hdr

DESCRIPTION
  Notify the CM to start/end lte to HDR hybrid bsr.

DEPENDENCIES
  None.

RETURN VALUE
  None

SIDE EFFECTS
  None.

===========================================================================*/
static  void                    sdss_eng_scr_con_hybr_bsr_to_hdr(
    sd_ss_e_type              ss,

      sdss_bsr_to_hdr_e_type hybr_bsr_to_hdr)
{
  /* HYBR_BSR_TO_HDR -   Notify the CM to start lte to do hybrid bsr.
  */
  if (hybr_bsr_to_hdr== SDSS_BSR_TO_HDR_START )
  {
    sd_si_hybr_bsr_to_hdr(ss, SD_HYBR_BSR_TO_HDR_START);
  }
  else if(hybr_bsr_to_hdr == SDSS_BSR_TO_HDR_END_FAIL )
  {
    sd_si_hybr_bsr_to_hdr(ss, SD_HYBR_BSR_TO_HDR_END_FAIL);
  }
}

/*===========================================================================

FUNCTION sdss_eng_scr_con_cs_emerg_fail

DESCRIPTION
  Inform one round of CS service scan fail

DEPENDENCIES
  None.

RETURN VALUE
  None

SIDE EFFECTS
  None.

===========================================================================*/
static  void                    sdss_eng_scr_con_cs_emerg_fail(

        sd_ss_e_type              ss
            /* System selection stack.
            */
)
{
 
  sd_si_s_type                *si_ptr     = sd_si_ptr( ss );
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if( si_ptr->acq_fail_cb_func != NULL )
  {
    SD_MSG_HIGH_1( "CS Emerg srv req failed ss=%d",ss);
    
    si_ptr->cs_emerg_scan_fail_cb_func( ss);
  }

}/* sdss_eng_scr_con_cs_emerg_fail */

/*===========================================================================

FUNCTION sdss_eng_scr_con_kick_hybr2

DESCRIPTION
  Notify the CM to kick hybr2 stack.

DEPENDENCIES
  None.

RETURN VALUE
  None

SIDE EFFECTS
  None.

===========================================================================*/
static  void                    sdss_eng_scr_con_kick_hybr2(
    sd_ss_e_type              ss
)
{
  if(sdss_is_ofmode_1x_sxlte() && 
    (ss == SD_SS_MAIN) && 
    (sdss_ptr(ss)->ss_state == SDSS_STATE_ACQ) )
  {
    sd_si_kick_hybr2(ss);
  }
}
/* <EJECT> */
/*===========================================================================

FUNCTION sdss_acq_reacq_event_proc

DESCRIPTION
  Process SS-Event in the context of an SDSS_ACQ_STT_REACQ state and instruct
  the caller of the next SS-Internal-Action to take.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the entire list that is currently being associated with the
  acquisition state machine is exhausted. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean                 sdss_acq_reacq_event_proc(

        sdss_acq_s_type         *acq_ptr,
            /* Pointer an acquisition state machine to process the SS-Event.
            */

        sdss_acq_mode_e_type    acq_mode,
            /* Acq mode for avoided system
            */

        sdss_evt_e_type         event,
            /* SS-Event to process.
            */

        sd_ss_mode_pref_e_type  mode_pref,
            /* Current mode preference.
            */

        sd_ss_band_pref_e_type  band_pref,
            /* Current 3G band preference.
            */


         sys_lte_band_mask_e_type    lte_band_pref,
           /* LTE band preference */

        sd_ss_band_pref_e_type    tds_band_pref,
           /* TD-SCDMA band preference */

        sd_ss_roam_pref_e_type  roam_pref,
            /* Current roam preference.
            *//*lint -esym(715, roam_pref) */ /* not referenced */

        sdss_iact_s_type        *rtrn_iact_ptr
            /* Pointer to a buffer where to place returned internal action.
            */
)
{

  sdsr_s_type       *acq_sys_ptr;
  sdsr_s_type       *cdma_srv_sys_ptr;
  boolean           list_is_exhausted = FALSE;
  sd_ss_e_type      ss = SD_SS_MAIN;

  #ifdef FEATURE_AVOID_DUP_BAND_SCAN
  sdss_acq_stt_e_type from_acq_state ;
  sdss_band_s_type band_scanned;
  #endif
  if(acq_ptr==NULL)// to acquisition state machine
  {
    sys_err_fatal_null_ptr_exception();
  }
  ss = acq_ptr->ss;

  #ifdef FEATURE_AVOID_DUP_BAND_SCAN
  from_acq_state = acq_ptr->state;
  SD_ASSERT_ENUM_IS_INRANGE( from_acq_state, SDSS_ACQ_STT_MAX );
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( acq_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( event, SDSS_EVT_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( mode_pref, SD_SS_MODE_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( band_pref, SD_SS_BAND_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( roam_pref, SD_SS_ROAM_PREF_MAX );
  SD_ASSERT( rtrn_iact_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #if (defined(FEATURE_HDR_HYBRID))
  /* Work with HYBR_1 system selection, if specified so.
  */
  if( acq_ptr->ss_ptr == sdss_ptr(SD_SS_HYBR_1) )
  {
    ss = SD_SS_HYBR_1;
  }
  #endif /* FEATURE_HDR_HYBRID */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if(!sdss_is_featuremode(SYS_OVERALL_FEATURE_MODE_NORMAL))
  {
    if(acq_ptr->ss_ptr == sdss_ptr(SD_SS_HYBR_2) )
    {
      ss = SD_SS_HYBR_2;
    }
  }
  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  if(acq_ptr->ss_ptr == sdss_ptr(SD_SS_HYBR_3) )
  {
    ss = SD_SS_HYBR_3;
  }
  #endif
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* First get the information of the system being attempted acquisition in
  ** this state.
  */
  acq_sys_ptr = sdsr_list_get_ptr( ACQ_LIST(SDSR_ACQ_SYS), 0 );

  if( acq_sys_ptr == NULL )
  {
    sys_err_fatal_null_ptr_exception();
  }

  cdma_srv_sys_ptr = sdsr_list_get_ptr( SDSR_CDMA_IDL_SYS, 0 );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  switch( event )
  {
    case SDSS_EVT_CDMA_ACQ_FAILED_PILOT:
    case SDSS_EVT_CDMA_ACQ_FAILED_SYNC:
    case SDSS_EVT_CDMA_ACQ_PROT_MIS:

    case SDSS_EVT_AMPS_ACQ_FAILED_CCH:

    case SDSS_EVT_HDR_ACQ_FAILED_PILOT:
    case SDSS_EVT_HDR_ACQ_FAILED_SYNC:
    case SDSS_EVT_HDR_ACQ_PROT_MIS:
    case SDSS_EVT_HDR_ACQ_BAD_SYS:
    case SDSS_EVT_GWL_ACQ_PLMN_FAILED:
    case SDSS_EVT_HYBR_2_GW_ACQ_PLMN_FAILED:
    case SDSS_EVT_HYBR_3_GW_ACQ_PLMN_FAILED:
      /* Reacquisition attempt failed, go back to the start state to continue
      ** traversing the list that is being attempted acquisition.
      */
      acq_ptr->state = SDSS_ACQ_STT_START;
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_EVT_CDMA_ACQ_SCHM:
    case SDSS_EVT_AMPS_ACQ_CCH_SID:
    case SDSS_EVT_HDR_ACQ_SID:
    case SDSS_EVT_GWL_ACQ_PLMN_SUCCESS:
    case SDSS_EVT_HYBR_2_GW_ACQ_PLMN_SUCCESS:
    case SDSS_EVT_HYBR_3_GW_ACQ_PLMN_SUCCESS:
      /* Reacquisition attempt is successful. If this system is a preferred
      ** system that complies with the current SS-Preference, and is
      ** collocated with the SDSR_CDMA_IDL_SYS system, stay and
      ** provide service on this system.
      */
      if( sdss_sr_is_prl(acq_sys_ptr, SDSS_PRL_VAL_ANY_PREF)
                          &&
          sdss_sr_is_pref_conf0(acq_ptr->ss,
                                acq_sys_ptr,
                                SDSS_PREF_CONF_NONE,
                                TRUE)
                          &&
        (acq_ptr->acq_type != SDSSSCR_ACQ_COLLOC_BEST_PREF ||
         sdss_is_sr_associated(acq_sys_ptr, cdma_srv_sys_ptr)))
      {
        if( sdss_acq_ltd_reg_opti(ss) )
        {
          acq_ptr->state = SDSS_ACQ_STT_SUSPEND;
        }
        else
        {
          acq_ptr->state = SDSS_ACQ_STT_DONE;
        }
      }

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      /* Else if AMPS 2nd strongest control channel needs to be attempted
      ** acquisition, return now.
      */
      else if( sdss_acq_is_amps_2nd_cch( acq_ptr,
                                         ACQ_LIST(SDSR_ACQ_SYS),
                                         0,
                                         SDSSSCR_ACQ_BEST_PREF,
                                         rtrn_iact_ptr) )
      {
          return list_is_exhausted;
      }

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      /* Else, go back to the start state to continue traversing the list
      ** that is being attempted acquisition.
      */
      else
      {
        acq_ptr->state = SDSS_ACQ_STT_START;
      }
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    default:

      /* If we got here, this event has no impact on the acquisition
      ** processing, so just continue.
      */
      rtrn_iact_ptr->act = SDSS_IACT_CONTINUE;
      SD_MSG_HIGH_1( "Ignoring event=%d",event);

      return list_is_exhausted;

  } /* switch( event ) */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Indicate that AMPS 2nd strongest control channel is not attempted
  ** acquisition.
  */
  acq_ptr->is_amps_2nd_cch                = FALSE;
  rtrn_iact_ptr->prm.acq.is_amps_2nd_cch  = FALSE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Based on state change, do proc avoid_dup_scan - If PLMN_acq_success,
   ** but Acq state is changing from more_preferred/reacq -> start,
   ** then remove the band which acquired PLMN successfully.
   */
  #ifdef FEATURE_AVOID_DUP_BAND_SCAN
 
  band_scanned.band = acq_sys_ptr->sys.band;
  band_scanned.lte_band = acq_sys_ptr->sys.lte_band;
  band_scanned.tds_band = acq_sys_ptr->sys.tds_band;

 (void)sdss_proc_avoid_dup_scan_per_acq_state_chg( ss, event,
                                                   &band_scanned,
                                                   from_acq_state,
                                                   acq_ptr->state);

  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Based on the next state, adjust the acquisition position and build the
  ** return action.
  */
  switch( acq_ptr->state )
  {
    case SDSS_ACQ_STT_START:

      /* Reacquisition attempt failed - set the service-indication to OFF
      ** and select the next system to be attempted acquisition.
      */
      sd_si_srv_off( ss, FALSE );
      list_is_exhausted = sdss_acq_next( acq_ptr,
                                         acq_mode,
                                         mode_pref,
                                         band_pref,
                                         lte_band_pref,
                                         tds_band_pref,
                                         rtrn_iact_ptr);

      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_ACQ_STT_DONE:
    case SDSS_ACQ_STT_SUSPEND:
      /* Stay on the acquired system.
      */
      rtrn_iact_ptr->act             = SDSS_IACT_CONTINUE;
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_ACQ_STT_MORE_PREF:
    case SDSS_ACQ_STT_REACQ:
    case SDSS_ACQ_STT_REACQ_GWL:
    case SDSS_ACQ_STT_REACQ_FULL_SRV:
    case SDSS_ACQ_STT_PWR_SAVE_ENTER:
    case SDSS_ACQ_STT_PWR_SAVE:
    case SDSS_ACQ_STT_SCAN_CONT:
    case SDSS_ACQ_STT_MAX:
    case SDSS_ACQ_STT_NONE:
    default:
      SD_ERR_0( "state");
      break;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #ifdef FEATURE_AVOID_DUP_BAND_SCAN
  /* SDSS_ACQ_STT_REACQ/REACQ_GWL: Suspend avoid_dup_scan.
  ** SDSS_ACQ_STT_DONE: Reset band_to_avoid and avoid_state.
  */
  
  sdss_proc_avoid_dup_scan_acq_state_reacq_or_done(ss, acq_ptr->state);
  
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return list_is_exhausted;

} /* sdss_acq_reacq_event_proc *//*lint +esym(715, roam_pref) */




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_acq_reacq_gwl_event_proc

DESCRIPTION
  Process SS-Event in the context of an SDSS_ACQ_STT_REACQ_GWL state and instruct
  the caller of the next SS-Internal-Action to take.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the entire list that is currently being associated with the
  acquisition state machine is exhausted. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean                 sdss_acq_reacq_gwl_event_proc(

        sdss_acq_s_type         *acq_ptr,
            /* Pointer an acquisition state machine to process the SS-Event.
            */

        sdss_acq_mode_e_type    acq_mode,
            /* Acq mode for avoided system
            */

        sdss_evt_e_type         event,
            /* SS-Event to process.
            */

        sd_ss_mode_pref_e_type  mode_pref,
            /* Current mode preference.
            */

        sd_ss_band_pref_e_type  band_pref,
            /* Current 3G band preference.
            */


        sys_lte_band_mask_e_type  lte_band_pref,
           /* LTE band preference */

        sd_ss_band_pref_e_type  tds_band_pref,
           /* TD-SCDMA band preference */

        sd_ss_roam_pref_e_type  roam_pref,
            /* Current roam preference.
            *//*lint -esym(715, roam_pref) */ /* not referenced */

        sdss_iact_s_type        *rtrn_iact_ptr
            /* Pointer to a buffer where to place returned internal action.
            */
)
{

  sdsr_s_type       *acq_sys_ptr;
  boolean           list_is_exhausted = FALSE;
  sd_ss_e_type      ss = SD_SS_MAIN;

  #ifdef FEATURE_AVOID_DUP_BAND_SCAN
  sdss_acq_stt_e_type   from_acq_state;
  sdss_band_s_type band_scanned;
  #endif

  if(acq_ptr==NULL)
  {
    sys_err_fatal_null_ptr_exception();
  }
  ss = acq_ptr->ss;

  #ifdef FEATURE_AVOID_DUP_BAND_SCAN
  from_acq_state = acq_ptr->state;
  SD_ASSERT_ENUM_IS_INRANGE( from_acq_state, SDSS_ACQ_STT_MAX );
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( acq_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( event, SDSS_EVT_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( mode_pref, SD_SS_MODE_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( band_pref, SD_SS_BAND_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( roam_pref, SD_SS_ROAM_PREF_MAX );
  SD_ASSERT( rtrn_iact_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #if (defined(FEATURE_HDR_HYBRID))
  /* Work with HYBR_1 system selection, if specified so.
  */
  if( acq_ptr->ss_ptr == sdss_ptr(SD_SS_HYBR_1) )
  {
    ss = SD_SS_HYBR_1;
  }
  #endif /* FEATURE_HDR_HYBRID */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if(!sdss_is_featuremode(SYS_OVERALL_FEATURE_MODE_NORMAL))
  {
    if(acq_ptr->ss_ptr == sdss_ptr(SD_SS_HYBR_2) )
    {
      ss = SD_SS_HYBR_2;
    }
  }

  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  if(acq_ptr->ss_ptr == sdss_ptr(SD_SS_HYBR_3) )
  {
    ss = SD_SS_HYBR_3;
  }
  #endif
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* First get the information of the system being attempted acquisition in
  ** this state.
  */
  acq_sys_ptr = sdsr_list_get_ptr( ACQ_LIST(SDSR_ACQ_SYS), 0 );

  if( acq_sys_ptr == NULL )
  {
    sys_err_fatal_null_ptr_exception();
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  switch( event )
  {
    case SDSS_EVT_CDMA_ACQ_FAILED_PILOT:
    case SDSS_EVT_CDMA_ACQ_FAILED_SYNC:
    case SDSS_EVT_CDMA_ACQ_PROT_MIS:
    case SDSS_EVT_AMPS_ACQ_FAILED_CCH:
    case SDSS_EVT_HDR_ACQ_FAILED_PILOT:
    case SDSS_EVT_HDR_ACQ_FAILED_SYNC:
    case SDSS_EVT_HDR_ACQ_PROT_MIS:
    case SDSS_EVT_HDR_ACQ_BAD_SYS:
    case SDSS_EVT_GWL_ACQ_PLMN_FAILED:
    case SDSS_EVT_HYBR_2_GW_ACQ_PLMN_FAILED:
    case SDSS_EVT_HYBR_3_GW_ACQ_PLMN_FAILED:
    case SDSS_EVT_CDMA_ACQ_SCHM:
    case SDSS_EVT_AMPS_ACQ_CCH_SID:
    case SDSS_EVT_HDR_ACQ_SID:

      /* Reacquisition attempt failed, go back to the start state to continue
      ** traversing the list that is being attempted acquisition.
      */
      acq_ptr->state = SDSS_ACQ_STT_START;
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


    case SDSS_EVT_GWL_ACQ_PLMN_SUCCESS:
    case SDSS_EVT_HYBR_2_GW_ACQ_PLMN_SUCCESS:
    case SDSS_EVT_HYBR_3_GW_ACQ_PLMN_SUCCESS:
      /* Reacquisition attempt is successful. If this system is a preferred
      ** system that complies with the current SS-Preference
      ** stay and provide service on this system.
      */

      if( acq_ptr->rtrn_iact.prm.acq.gwl_acq_type.acq_type == SDSS_GWL_ACQ_REG_GIVEN_PLMN
                        &&
          sdss_sr_is_prl(acq_sys_ptr,SDSS_PRL_VAL_ANY_PREF)
                                    &&
          sdss_sr_is_pref_conf0(acq_ptr->ss,
                                acq_sys_ptr,
                                SDSS_PREF_CONF_NONE,
                                TRUE)
         )
      {
        if( sdss_acq_ltd_reg_opti(ss) )
        {
          acq_ptr->state = SDSS_ACQ_STT_SUSPEND;
        }
        else
        {
          SD_MSG_HIGH_0("MMSS: reacq success");
          acq_ptr->state = SDSS_ACQ_STT_DONE;
        }
      }
      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      /* Else, go back to the start state to continue traversing the list
      ** that is being attempted acquisition.
      */
      else
      {
        SD_MSG_HIGH_0("MMSS: reacq failure");
        acq_ptr->state = SDSS_ACQ_STT_START;
      }
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    default:

      /* If we got here, this event has no impact on the acquisition
      ** processing, so just continue.
      */
      rtrn_iact_ptr->act = SDSS_IACT_CONTINUE;
      SD_MSG_HIGH_1( "Reacq_gwl:Ignoring event=%d",event);

      return list_is_exhausted;

  } /* switch( event ) */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Indicate that AMPS 2nd strongest control channel is not attempted
  ** acquisition.
  */
  acq_ptr->is_amps_2nd_cch                = FALSE;
  rtrn_iact_ptr->prm.acq.is_amps_2nd_cch  = FALSE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Based on state change, do proc avoid_dup_scan - If PLMN_acq_success,
   ** but Acq state is changing from more_preferred/reacq -> start,
   ** then remove the band which acquired PLMN successfully.
   */
  #ifdef FEATURE_AVOID_DUP_BAND_SCAN
  
    band_scanned.band = acq_sys_ptr->sys.band;
    band_scanned.lte_band = acq_sys_ptr->sys.lte_band;
    band_scanned.tds_band = acq_sys_ptr->sys.tds_band;

    (void)sdss_proc_avoid_dup_scan_per_acq_state_chg( ss, event,
                                                      &band_scanned,
                                                      from_acq_state,
                                                      acq_ptr->state);
  
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Based on the next state, adjust the acquisition position and build the
  ** return action.
  */
  switch( acq_ptr->state )
  {
    case SDSS_ACQ_STT_START:

      /* Reacquisition attempt failed - set the service-indication to OFF
      ** and select the next system to be attempted acquisition.
      */
      sd_si_srv_off( ss, FALSE );
      list_is_exhausted = sdss_acq_next( acq_ptr,
                                         acq_mode,
                                         mode_pref,
                                         band_pref,
                                         lte_band_pref,
                                         tds_band_pref,
                                         rtrn_iact_ptr);

      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_ACQ_STT_DONE:
    case SDSS_ACQ_STT_SUSPEND:
      /* Stay on the acquired system.
      */
      rtrn_iact_ptr->act             = SDSS_IACT_CONTINUE;
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_ACQ_STT_MORE_PREF:
    case SDSS_ACQ_STT_REACQ:
    case SDSS_ACQ_STT_REACQ_GWL:
    case SDSS_ACQ_STT_PWR_SAVE_ENTER:
    case SDSS_ACQ_STT_PWR_SAVE:
    case SDSS_ACQ_STT_SCAN_CONT:
    case SDSS_ACQ_STT_MAX:
    case SDSS_ACQ_STT_NONE:
    default:
      SD_ERR_0( "state");
      break;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #ifdef FEATURE_AVOID_DUP_BAND_SCAN
  /* SDSS_ACQ_STT_REACQ/REACQ_GWL: Suspend avoid_dup_scan.
  ** SDSS_ACQ_STT_DONE: Reset band_to_avoid and avoid_state.
  */

  sdss_proc_avoid_dup_scan_acq_state_reacq_or_done(ss, acq_ptr->state);

  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return list_is_exhausted;

} /* sdss_acq_reacq_gwl_event_proc *//*lint +esym(715, roam_pref) */



/* <EJECT> */
/*===========================================================================

FUNCTION sdss_acq_reacq_full_srv_event_proc

DESCRIPTION
  Process SS-Event in the context of an SDSS_ACQ_STT_REACQ_FULL_SRV state and instruct
  the caller of the next SS-Internal-Action to take.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the entire list that is currently being associated with the
  acquisition state machine is exhausted. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean                 sdss_acq_reacq_full_srv_event_proc(

        sdss_acq_s_type         *acq_ptr,
            /* Pointer an acquisition state machine to process the SS-Event.
            */

        sdss_acq_mode_e_type    acq_mode,
            /* Acq mode for avoided system
            */

        sdss_evt_e_type         event,
            /* SS-Event to process.
            */

        sd_ss_mode_pref_e_type  mode_pref,
            /* Current mode preference.
            */

        sd_ss_band_pref_e_type  band_pref,
            /* Current 3G band preference.
            */


        sys_lte_band_mask_e_type  lte_band_pref,
           /* LTE band preference */

        sd_ss_band_pref_e_type  tds_band_pref,
           /* TD-SCDMA band preference */

        sd_ss_roam_pref_e_type  roam_pref,
            /* Current roam preference.
            *//*lint -esym(715, roam_pref) */ /* not referenced */

        sdss_iact_s_type        *rtrn_iact_ptr
            /* Pointer to a buffer where to place returned internal action.
            */
)
{

  sdsr_s_type             *acq_sys_ptr;
  boolean                  list_is_exhausted = FALSE;
  sd_ss_e_type             ss;
  sys_srv_status_e_type    ss_srv_status     = SYS_SRV_STATUS_NONE;
  #ifdef FEATURE_AVOID_DUP_BAND_SCAN
  sdss_acq_stt_e_type      from_acq_state;
  sdss_band_s_type         band_scanned;
  #endif

  if(acq_ptr==NULL)
  {
    sys_err_fatal_null_ptr_exception();
  }
  ss = acq_ptr->ss;

  #ifdef FEATURE_AVOID_DUP_BAND_SCAN
  from_acq_state = acq_ptr->state;
  SD_ASSERT_ENUM_IS_INRANGE( from_acq_state, SDSS_ACQ_STT_MAX );
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( acq_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( event, SDSS_EVT_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( mode_pref, SD_SS_MODE_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( band_pref, SD_SS_BAND_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( roam_pref, SD_SS_ROAM_PREF_MAX );
  SD_ASSERT( rtrn_iact_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #if (defined(FEATURE_HDR_HYBRID))
  /* Work with HYBR_1 system selection, if specified so.
  */
  if( acq_ptr->ss_ptr == sdss_ptr(SD_SS_HYBR_1) )
  {
    ss = SD_SS_HYBR_1;
  }
  #endif /* FEATURE_HDR_HYBRID */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if(!sdss_is_featuremode(SYS_OVERALL_FEATURE_MODE_NORMAL))
  {
    if(acq_ptr->ss_ptr == sdss_ptr(SD_SS_HYBR_2) )
    {
      ss = SD_SS_HYBR_2;
    }
  }
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* First get the information of the system being attempted acquisition in
  ** this state.
  */
  acq_sys_ptr = sdsr_list_get_ptr( ACQ_LIST(SDSR_ACQ_SYS), 0 );

  if( acq_sys_ptr == NULL )
  {
    sys_err_fatal_null_ptr_exception();
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  switch( event )
  {
    case SDSS_EVT_CDMA_ACQ_FAILED_PILOT:
    case SDSS_EVT_CDMA_ACQ_FAILED_SYNC:
    case SDSS_EVT_CDMA_ACQ_PROT_MIS:
    case SDSS_EVT_AMPS_ACQ_FAILED_CCH:
    case SDSS_EVT_HDR_ACQ_FAILED_PILOT:
    case SDSS_EVT_HDR_ACQ_FAILED_SYNC:
    case SDSS_EVT_HDR_ACQ_PROT_MIS:
    case SDSS_EVT_HDR_ACQ_BAD_SYS:
    case SDSS_EVT_GWL_ACQ_PLMN_FAILED:
    case SDSS_EVT_HYBR_2_GW_ACQ_PLMN_FAILED:
    case SDSS_EVT_HYBR_3_GW_ACQ_PLMN_FAILED:
    case SDSS_EVT_CDMA_ACQ_SCHM:
    case SDSS_EVT_AMPS_ACQ_CCH_SID:
    case SDSS_EVT_HDR_ACQ_SID:

      /* Reacquisition attempt failed, go back to the start state to continue
      ** traversing the list that is being attempted acquisition.
      */
      acq_ptr->state = SDSS_ACQ_STT_START;
      sdss_check_reset_emerg_rat_pri_list_info(ss);
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


    case SDSS_EVT_GWL_ACQ_PLMN_SUCCESS:
    case SDSS_EVT_HYBR_2_GW_ACQ_PLMN_SUCCESS:
    case SDSS_EVT_HYBR_3_GW_ACQ_PLMN_SUCCESS:
      /* Reacquisition attempt results in finding service that supports emergency.
      ** If service is limited regional - go to SUSPEND state .
      ** For any service send ok to orig to CM and continue on current system.
      ** If this is not full service restore UE cap to emergency preferences
      */
      if( sdss_acq_ltd_reg_opti(ss) )
      {
        acq_ptr->state = SDSS_ACQ_STT_SUSPEND;
      }
      else
      {
        acq_ptr->state = SDSS_ACQ_STT_DONE;
      }

      sdss_read_srv_status( ss, &ss_srv_status, NULL );

      if( ss_srv_status == SYS_SRV_STATUS_SRV)
      {
        SD_MSG_HIGH_0("LTE_911:reacq success");
      }
      else
      {
        /* restore UE cap to emerg cap
        */
        SD_MSG_HIGH_0("LTE_911: reacq not success");
        sdss_check_reset_emerg_rat_pri_list_info(ss);
      }

      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    default:

      /* If we got here, this event has no impact on the acquisition
      ** processing, so just continue.
      */
      rtrn_iact_ptr->act = SDSS_IACT_CONTINUE;
      SD_MSG_HIGH_1( "Reacq_full_srv:Ignoring event=%d",event);

      return list_is_exhausted;

  } /* switch( event ) */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Indicate that AMPS 2nd strongest control channel is not attempted
  ** acquisition.
  */
  acq_ptr->is_amps_2nd_cch                = FALSE;
  rtrn_iact_ptr->prm.acq.is_amps_2nd_cch  = FALSE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Based on state change, do proc avoid_dup_scan - If PLMN_acq_success,
   ** but Acq state is changing from more_preferred/reacq -> start,
   ** then remove the band which acquired PLMN successfully.
   */
  #ifdef FEATURE_AVOID_DUP_BAND_SCAN

    band_scanned.band = acq_sys_ptr->sys.band;
    band_scanned.lte_band = acq_sys_ptr->sys.lte_band;
    band_scanned.tds_band = acq_sys_ptr->sys.tds_band;

    (void)sdss_proc_avoid_dup_scan_per_acq_state_chg( ss,
                                                      event,
                                                      &band_scanned,
                                                      from_acq_state,
                                                      acq_ptr->state);
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Based on the next state, adjust the acquisition position and build the
  ** return action.
  */
  switch( acq_ptr->state )
  {
    case SDSS_ACQ_STT_START:

      /* Reacquisition attempt failed - set the service-indication to OFF
      ** and select the next system to be attempted acquisition.
      */
      sd_si_srv_off( ss, FALSE );
      list_is_exhausted = sdss_acq_next( acq_ptr,
                                         acq_mode,
                                         mode_pref,
                                         band_pref,
                                         lte_band_pref,
                                         tds_band_pref,
                                         rtrn_iact_ptr);

      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    case SDSS_ACQ_STT_SUSPEND:
    case SDSS_ACQ_STT_DONE:
      /* Stay on the acquired system.
      */
      rtrn_iact_ptr->act             = SDSS_IACT_CONTINUE;
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_ACQ_STT_MORE_PREF:
    case SDSS_ACQ_STT_REACQ:
    case SDSS_ACQ_STT_REACQ_GWL:
    case SDSS_ACQ_STT_REACQ_FULL_SRV:
    case SDSS_ACQ_STT_PWR_SAVE_ENTER:
    case SDSS_ACQ_STT_PWR_SAVE:
    case SDSS_ACQ_STT_SCAN_CONT:
    case SDSS_ACQ_STT_MAX:
    case SDSS_ACQ_STT_NONE:
    default:
      SD_ERR_0( "state");
      break;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #ifdef FEATURE_AVOID_DUP_BAND_SCAN
  /* SDSS_ACQ_STT_REACQ/REACQ_GWL/REACQ_FULL_SRV: Suspend avoid_dup_scan.
  ** SDSS_ACQ_STT_DONE: Reset band_to_avoid and avoid_state.
  */
  sdss_proc_avoid_dup_scan_acq_state_reacq_or_done(ss, acq_ptr->state);
 
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return list_is_exhausted;

} /* sdss_acq_reacq_full_srv_event_proc *//*lint +esym(715, roam_pref) */

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_acq_start_event_proc

DESCRIPTION
  Process SS-Event in the context of an SDSS_ACQ_STT_START state and instruct
  the caller of the next SS-Internal-Action to take.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the entire list that is currently being associated with the
  acquisition state machine is exhausted. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean                 sdss_acq_start_event_proc(

        sdss_acq_s_type         *acq_ptr,
            /* Pointer an acquisition state machine to process the SS-Event.
            */

        sdss_acq_mode_e_type    acq_mode,
            /* Acq mode for avoided system
            */

        dword                   *scr_timer_ptr,
            /* Script timer
            */

        sdss_evt_e_type         event,
            /* SS-Event to process.
            */

        sd_ss_mode_pref_e_type  mode_pref,
            /* Current mode preference.
            */

        sd_ss_band_pref_e_type  band_pref,
            /* Current band preference (3G)
            */

        sys_lte_band_mask_e_type  lte_band_pref,
           /* LTE band preference */

        sd_ss_band_pref_e_type  tds_band_pref,
           /* TD-SCDMA band preference */

        sd_ss_roam_pref_e_type  roam_pref,
            /* Current roam preference.
            */

        sdss_iact_s_type        *rtrn_iact_ptr
            /* Pointer to a buffer where to place returned internal action.
            */
)
/*lint -esym(715, roam_pref, scr_timer_ptr) */ /* not referenced */
/*lint -esym(818, scr_timer_ptr) */ /* Could be declared as pointing to const
                                    */
{
  sdsr_s_type           *acq_sys_ptr;
  sdsr_s_type           *srv_sys_ptr;
  sdsr_s_type           *cdma_srv_sys_ptr;
  sdsr_s_type           *colloc_srv_sys_ptr;
  sdsr_s_type           *hybr2_srv_sys_ptr = NULL;
  sdsr_s_type           *reacq_sys_ptr;
  sdssscr_acq_e_type    acq_type;
  sd_ss_e_type          ss;

  boolean               is_no_pref_conf;
  boolean               list_is_exhausted       = FALSE;
  boolean               is_cand_sys_empty       = FALSE;
  int                   pref_pos                = SDSR_POS_NULL;
  boolean               is_acq_more_pref        = FALSE;
  boolean               is_hdr_colloc           = FALSE;
  sys_srv_status_e_type ss_srv_status           = SYS_SRV_STATUS_NONE;
  #ifdef FEATURE_SD_LTE
  sys_extend_srv_info_e_type   ext_srv_info      = SYS_EXTEND_SRV_INFO_NONE;
  sys_lte_cs_capability_e_type lte_cs_capability = SYS_LTE_CS_CAPABILITY_MAX;
  #endif

  /* Saving previous start system */
  sd_mode_e_type         base_start_sys_mode     = SD_MODE_NONE;
  sdsr_s_type            *start_sr_ptr           = NULL;

  #ifdef FEATURE_AVOID_DUP_BAND_SCAN
  sdss_acq_stt_e_type   from_acq_state;
  sdss_band_s_type band_scanned;

  /* Indicate if band mask is updated based on the acq_plmn_succ evt.
  ** If it is TRUE, then we need to perform another finding next sr.
  ** This is to prevent none band while returning sd action.
  */
  boolean is_band_updated = FALSE;

  /* Indicate if find next sr is processed - valid only for the following 2 evts
   ** SDSS_EVT_HYBR_2_GW_ACQ_PLMN_SUCCESS:
   ** SDSS_EVT_GWL_ACQ_PLMN_SUCCESS:
   */
  boolean is_find_next_processed = FALSE;

  /* Track the loop count - It should not more than 2 */
  int loop_cnt = 0;

  sd_si_info_s_type    si_info;
  
  #endif
  if(acq_ptr==NULL)
  {
    sys_err_fatal_null_ptr_exception();
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( acq_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( event, SDSS_EVT_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( mode_pref, SD_SS_MODE_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( band_pref, SD_SS_BAND_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( roam_pref, SD_SS_ROAM_PREF_MAX );
  SD_ASSERT( rtrn_iact_ptr != NULL );
  SD_ASSERT( acq_ptr->ss_ptr != NULL );

  ss = acq_ptr->ss;
  #ifdef FEATURE_AVOID_DUP_BAND_SCAN
  from_acq_state = acq_ptr->state;
  SD_ASSERT_ENUM_IS_INRANGE( from_acq_state, SDSS_ACQ_STT_MAX );
  #endif

  start_sr_ptr = sdsr_list_get_ptr(acq_ptr->start_sys,0);
  if (start_sr_ptr != NULL)
  {
    base_start_sys_mode = start_sr_ptr->sys.mode;
  }
  sdss_set_remove_gwl_on_bsr(ss, FALSE);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* First try to get the information of the system that is being attempted
  ** acquisition in this state.
  */
  acq_sys_ptr = sdsr_list_get_ptr( ACQ_LIST(SDSR_ACQ_SYS), 0 );
  if( acq_sys_ptr == NULL )
  {
    sys_err_fatal_null_ptr_exception();
    return FALSE;/*lint +e527 */ /* Unreachable */
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If sched position is not SDSR_POS_NULL (i.e., we try acquiring a system
  ** from the sched_lst), set the acquisition type per the reacquisition
  ** schedule. Else, set the acquisition type per the list that is attempted
  ** acquisition.
  */
  if( acq_ptr->sched_pos != SDSR_POS_NULL )
  {
    acq_type = (sdssscr_acq_e_type)   acq_sys_ptr->sched_prm.acq.type;
  }
  else
  {
    acq_type = acq_ptr->acq_type;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Only go through the loop once if avoid_dup_scan feature is off
  ** If avoid_dup_scan is enabled, then go through the loop 1 or 2 times depending
  ** on if band mask is update and if find next sr is processed.
  */
  #ifdef FEATURE_AVOID_DUP_BAND_SCAN
  do
  {
  #endif

  /* Do acquisition processing in accordance with the requested acquisition
  ** type and SS-Event.
  */
  switch( event )
  {

    case SDSS_EVT_AMPS_ACQ_FAILED_CCH:

      /* AMPS acquisition attempt failed.
      */

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      /* If MS failed to acquire 2nd strongest control channel and
      ** acquisition type is BEST_PREF and the SID that was obtained from the
      ** strongest control channel is listed in the PRL, check whether there
      ** are more preferred systems in the same GEO.
      */
      if( acq_ptr->is_amps_2nd_cch &&
          acq_type == SDSSSCR_ACQ_BEST_PREF &&
          sdss_sr_is_prl(acq_sys_ptr, SDSS_PRL_VAL_LISTED) )
      {
        /* Search for a more preferred system that complies with the
        ** current mode and band preference.
        */
        acq_ptr->pref_pos = sdss_sr_list_find_next( acq_ptr->ss,
                                                    acq_ptr->acq_con,
                                                    acq_mode,
                                                    acq_ptr->pref_lst,
                                                    0,
                                                    0,
                                                    -10000,
                                                    mode_pref,
                                                    band_pref,
                                                    lte_band_pref,
                                                    tds_band_pref,
                                                    acq_ptr->meas_cat );

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        /* If a more preferred system is found, go to the MORE_PREF
        ** state to try acquiring the more preferred system.
        */
        if( acq_ptr->pref_pos != SDSR_POS_NULL )
        {
          acq_ptr->state = SDSS_ACQ_STT_MORE_PREF;
        }
      }

      /* Acquisition attempt failed, try acquiring the next system that
      ** complies with the current mode and band preference from the list .
      */
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    case SDSS_EVT_MISC_GW_NET_LIST:
      /* Continue with the same system and reacquire it.
      */
      if(acq_ptr->acq_pos >= 0)
      {
        acq_ptr->acq_pos--;
      }
      acq_sys_ptr->new_acq_cnt--;

      SD_MSG_HIGH_3(" GET NET:acq_ptr->acq_lst %d,acq_ptr->acq_pos %d, acq_sys_ptr->new_acq_cnt %d",
         acq_ptr->acq_lst,acq_ptr->acq_pos,acq_sys_ptr->new_acq_cnt );
     break;
    case SDSS_EVT_CDMA_ACQ_FAILED_PILOT:
    case SDSS_EVT_CDMA_ACQ_FAILED_SYNC:
    case SDSS_EVT_CDMA_ACQ_PROT_MIS:
    case SDSS_EVT_CDMA_OPR_SYS_LOST:
    case SDSS_EVT_HDR_ACQ_FAILED_PILOT:
    case SDSS_EVT_HDR_ACQ_FAILED_SYNC:
    case SDSS_EVT_HDR_ACQ_PROT_MIS:
    case SDSS_EVT_HDR_ACQ_BAD_SYS:

      /* Acquisition attempt failed.
      */

      /* Try acquiring the next system that complies with the current mode
      ** and band preference from the list .
      */

      break;


    case SDSS_EVT_CDMA_ACQ_REDIR_ABORT:

      /* Redirection aborted
      */
      SD_MSG_HIGH_0( "1X Redir aborted");

      /* Clear the redirection context
      */
      sdss_redir_update(
          ss,
          SD_SS_REDIR_NONE,             /* Set redirection to none */
          FALSE,                        /* Set valid redirection to FALSE*/
          SD_WILDCARD_SID,              /* Set expected SID to wildcard */
          SD_WILDCARD_NID,              /* Set expected NID to wildcard */
          FALSE,                        /* Set RETURN_IF_FAIL to FALSE */
          FALSE,                        /* Set IGNORE_CDMA to FALSE */
          SD_SS_MAX_REDIR_DELAY_NONE ); /* Set max redirect delay to none*/

      list_is_exhausted = TRUE;
      rtrn_iact_ptr->act = SDSS_IACT_PWR_SAVE;

      return list_is_exhausted;

    case SDSS_EVT_HDR_ACQ_REDIR_ABORT:

      /* Redirection aborted
      */
      SD_MSG_HIGH_0( "HDR Redir aborted");

      /* Clear the redirection context
      */
      sdss_redir_update(
          ss,
          SD_SS_REDIR_NONE,             /* Set redirection to none */
          FALSE,                        /* Set valid redirection to FALSE*/
          SD_WILDCARD_SID,              /* Set expected SID to wildcard */
          SD_WILDCARD_NID,              /* Set expected NID to wildcard */
          FALSE,                        /* Set RETURN_IF_FAIL to FALSE */
          FALSE,                        /* Set IGNORE_CDMA to FALSE */
          SD_SS_MAX_REDIR_DELAY_NONE ); /* Set max redirect delay to none*/


      list_is_exhausted = TRUE;
      rtrn_iact_ptr->act = SDSS_IACT_PWR_SAVE;

      return list_is_exhausted;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_EVT_GWL_ACQ_PLMN_FAILED:
    case SDSS_EVT_HYBR_2_GW_ACQ_PLMN_FAILED:
    case SDSS_EVT_HYBR_3_GW_ACQ_PLMN_FAILED:
    /*lint -esym(529, ss_ptr) */ /* not referenced */
      {
        /* ACQ_PLMN failed. So set the default srv_req_type to NORMAL.
           This is to distinguish between any existing request with
           same parameters.
        */
        sdss_set_srv_req_type( acq_ptr->ss, SD_SS_SRV_REQ_TYPE_NORMAL );

        if(sdss_ptr(ss)->is_non_rplmn_csg_selection == TRUE )
        {
          sdss_set_srv_req_type( acq_ptr->ss, SD_SS_SRV_REQ_TYPE_NORMAL_RPLMN );
          SD_MSG_HIGH_0("set srv req type as NORMAL_RPLMN");
          sdss_ptr(ss)->is_non_rplmn_csg_selection = FALSE;
          acq_ptr->state = SDSS_ACQ_STT_SCAN_CONT;
        }

      #ifdef FEATURE_EOOS_UMTS
      /* For EOOS, check if we need to confinue with the scan due to timer
      ** expiry
      */
        if( acq_ptr->acq_mode != SDSS_ACQ_MODE_EOOS_FULL_RTN &&
            acq_ptr->acq_mode != SDSS_ACQ_MODE_EOOS_FULL_RTN2 &&
            (acq_ptr->ss_ptr)->acq_gwl_scan_status == SD_SS_GWL_SCAN_STATUS_ABORTED )
        {
          if( !(acq_ptr->ss_ptr)->gprs_anite_gcf )
          {

              dword  temp_sleep_time;
              sdss_get_eoos_sleep_time (&temp_sleep_time,
                                SDSSSCR_CONT_RAT_GW_SLEEP_TYPE,
                                acq_ptr->ss);

              /* Send an acq fail */
              sdss_eng_scr_con_acq_fail(ss);
              if (temp_sleep_time == 0)
              {
                  acq_ptr->state = SDSS_ACQ_STT_SCAN_CONT;
              }
              else
              {
                  acq_ptr->state = SDSS_ACQ_STT_PWR_SAVE_ENTER;
              }
          }
          else
          {
            acq_ptr->state = SDSS_ACQ_STT_SCAN_CONT;
          }
        }
       #endif
      }
      /*lint +esym(529, ss_ptr) */
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_EVT_CDMA_ACQ_SCHM:
    case SDSS_EVT_AMPS_ACQ_CCH_SID:
    case SDSS_EVT_HDR_ACQ_SID:
    case SDSS_EVT_HYBR_2_GW_ACQ_PLMN_SUCCESS:
    case SDSS_EVT_HYBR_3_GW_ACQ_PLMN_SUCCESS:
    case SDSS_EVT_GWL_ACQ_PLMN_SUCCESS:
    case SDSS_EVT_GWL_ACQ_PLMN_SUCCESS_LESS_PREF:
      /* Acquisition attempt succeeded.
      */

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      /* ACQ_PLMN Success. So set the default srv_req_type back to NORMAL.
         This is to distinguish between any existing request with
         same parameters.
      */
      sdss_set_srv_req_type( acq_ptr->ss,  SD_SS_SRV_REQ_TYPE_NORMAL );

      sdss_read_srv_status( ss, &ss_srv_status, NULL );

      if( ss_srv_status == SYS_SRV_STATUS_SRV )
      {
        sdss_set_scan_scope_type(acq_ptr->ss, SYS_SCAN_SCOPE_FULL_BAND);
      }

      /* Copy the acquired system and its more preferred list into start_sys
      ** and pref_lst, respectively.
      ** This is only applicable on MAIN. On HYBR-2, there's only LTE system
      ** Hence we don't need to reacquire the system which is on PRL because
      ** we only can acquire LTE.
      */
      if (ss == SD_SS_MAIN &&
          sdsr_list_get_ptr(SDSR_GW_CAND_SYS,0) != NULL &&
          event == SDSS_EVT_GWL_ACQ_PLMN_SUCCESS &&
          sdss_is_mmss_operation(SD_SS_MAIN))
      {
        sdsr_s_type *gw_cand_sys = sdsr_list_get_ptr(SDSR_GW_CAND_SYS,0);
        sdsr_s_type *acq_sys     = sdsr_list_get_ptr(SDSR_ACQ_SYS,0);

        sdsr_list_cpy( acq_ptr->start_sys, ACQ_LIST(SDSR_GW_CAND_SYS) );

        /* The type GWL systems could be tricky in term of multi-GEO match.
        ** For example, we have 2 records: R1 and R2 as below.
        ** R1 contains: GWL bands which is only found in GEO1. MCC=210, MNC=FFF
        ** R2 contains: G bands which is found in GEO2 and GEO3. MCC=210, MNC=FFF
        **
        ** Case 1) If UE is scanning for G bands, it will have multi-GEO matches
        ** in all GEO1, GEO2 and GEO3.
        **
        ** Case 2) If UE is scanning for L bands, it will only matches with R1 in GEO1.
        */

        /* So the multi-GEO matches characteristic of start_sys has to be
        ** based on the ACQ_SYS, not based on the GW_CAND_SYS, even though we copy
        ** the CAND_SYS over
        */
        if ((gw_cand_sys != NULL) && (acq_sys != NULL))
        {
          gw_cand_sys->is_multi_geo_match = acq_sys->is_multi_geo_match;
        }
      }
      else
      {
        sdsr_list_cpy( acq_ptr->start_sys, ACQ_LIST(SDSR_ACQ_SYS) );
      }

      sdsr_list_cpy( acq_ptr->pref_lst, ACQ_LIST(SDSR_ACQ_PREF_LST) );

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      /* Find out whether the acquired system conflicts with any of the
      ** system selection preferences.
      */
      is_no_pref_conf = sdss_sr_is_pref_conf0( acq_ptr->ss,
                                               acq_sys_ptr,
                                               SDSS_PREF_CONF_NONE,
                                               TRUE);

      SD_MSG_HIGH_1("is_no_pref_conf=%d", is_no_pref_conf);

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      /* Decide on the next state according to the requested acquisition
      ** type, PRL designation and SS-preference conflict.
      */
      switch( acq_type )
      {
        case SDSSSCR_ACQ_ANY:

          /* If acquired system does not conflict with the SS-Preference,
          ** stay on the acquired system.
          */
          if( is_no_pref_conf )
          {
            acq_ptr->state = SDSS_ACQ_STT_DONE;
          }
          break;

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSSSCR_ACQ_ALLOWED:

          /* If acquired system does not conflict with the current
          ** SS-Preferences and it satisfies the ALLOWED acquisition type,
          ** stay on the acquired system.
          */

            if( is_no_pref_conf &&
                sdss_sr_is_prl(acq_sys_ptr, SDSS_PRL_VAL_ALLOWED) )
            {
              acq_ptr->state = SDSS_ACQ_STT_DONE;
            }
          break;

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSSSCR_ACQ_PREFERRED:

          /* If acquired system does not conflict with the current
          ** SS-Preference and is listed as preferred system in the PRL,
          ** stay on the acquired system.
          */
          if( is_no_pref_conf &&
              sdss_sr_is_prl(acq_sys_ptr, SDSS_PRL_VAL_ANY_PREF) )
          {
            acq_ptr->state = SDSS_ACQ_STT_DONE;
          }
          /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
          break;

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSSSCR_ACQ_BEST_PREF:

          /* If acquired system does not conflict with the current
          ** SS-Preference and it is the most preferred in its GEO,
          ** stay on the acquired system.
          */
          if( is_no_pref_conf &&
              sdss_sr_is_prl(acq_sys_ptr, SDSS_PRL_VAL_MOST_PREF) )
          {
            acq_ptr->state = SDSS_ACQ_STT_DONE;
          }

          /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

          /* Else if AMPS 2nd strongest control channel needs to be attempted
          ** acquisition, return now.
          */
          else if( sdss_acq_is_amps_2nd_cch(acq_ptr,
                                            ACQ_LIST(SDSR_ACQ_SYS),
                                            0,
                                            acq_type,
                                            rtrn_iact_ptr) )
          {
            return list_is_exhausted;
          }

          /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

          /* Else, if the acquired system is a PRL listed system, check
          ** whether there are more preferred systems in the same GEO.
          */
          else if( sdss_sr_is_prl(acq_sys_ptr, SDSS_PRL_VAL_LISTED) )
          {
            #ifdef FEATURE_AVOID_DUP_BAND_SCAN
            /* Suspend filtering for immdiate BSR only if true event is sys lost
            */
            if ( sdss_is_srv_lost_state(acq_ptr->ss))
            {
              sdss_avoid_dup_scan_suspend(acq_ptr->ss);
            }
            #endif

            /* Search for a more preferred system that complies with the
            ** current mode and band preference.
            */
            acq_ptr->pref_pos  =  sdss_sr_list_find_next(acq_ptr->ss,
                                                         acq_ptr->acq_con,
                                                         acq_mode,
                                                         acq_ptr->pref_lst,
                                                         0,
                                                         0,
                                                         -10000,
                                                         mode_pref,
                                                         band_pref,
                                                         lte_band_pref,
                                                         tds_band_pref,
                                                         acq_ptr->meas_cat );

            #ifdef FEATURE_AVOID_DUP_BAND_SCAN
            
            /* Indicate that sd did go through sr list and try to find the next sr */
            is_find_next_processed = TRUE;
            loop_cnt ++;
            
            #endif

            /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

            /* If a more preferred system is found, go to the MORE_PREF
            ** state to try acquiring the more preferred system.
            */
            if( acq_ptr->pref_pos != SDSR_POS_NULL )
            {
              acq_ptr->state = SDSS_ACQ_STT_MORE_PREF;
            }

            /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

            /* Else (a more preferred system is not found), if the acquired
            ** acquired system does not conflict with the current
            ** SS-Preference and it is a preferred PRL system, stay on this
            ** system.
            */
            else if( is_no_pref_conf &&
                     sdss_sr_is_prl(acq_sys_ptr, SDSS_PRL_VAL_ANY_PREF) )
            {
              acq_ptr->state = SDSS_ACQ_STT_DONE;
            }

            /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

            /* Else, stay in the start state and attempt acquire the
            ** next system from the acquisition list.
            */
          }

          /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

          /* Else, stay in the start state and attempt acquire the
          ** next system from the acquisition list.
          */
          break;

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSSSCR_ACQ_REG_BEST_PREF:

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
        /* If acquired system does not conflict with the current
        ** SS-Preference and it is the most preferred in its GEO,
        ** stay on the acquired system.
        */
        if( is_no_pref_conf &&
            sdss_sr_is_prl(acq_sys_ptr, SDSS_PRL_VAL_MOST_PREF))
        {
          acq_ptr->state = SDSS_ACQ_STT_DONE;
        }
        /* Else, if the acquired system is a PRL listed system, check
        ** whether there are more preferred systems in the same GEO.
        */
        else if( sdss_sr_is_prl(acq_sys_ptr, SDSS_PRL_VAL_LISTED) )
        {
          #ifdef FEATURE_AVOID_DUP_BAND_SCAN
          /* Suspend filtering for immdiate BSR only if true event is sys lost
                */
          if (sdss_is_srv_lost_state(acq_ptr->ss))
          {
            sdss_avoid_dup_scan_suspend(acq_ptr->ss);
          }
          #endif

          /* Search for a more preferred system that complies with the
          ** current mode and band preference.
          */
          acq_ptr->pref_pos  =  sdss_sr_list_find_next(acq_ptr->ss,
                                                       acq_ptr->acq_con,
                                                       acq_mode,
                                                       acq_ptr->pref_lst,
                                                       0,
                                                       0,
                                                       -10000,
                                                       mode_pref,
                                                       band_pref,
                                                       lte_band_pref,
                                                       tds_band_pref,
                                                       acq_ptr->meas_cat );

          #ifdef FEATURE_AVOID_DUP_BAND_SCAN
          
          /* Indicate that sd did go through sr list and try to find the next sr */
          is_find_next_processed = TRUE;
          loop_cnt ++;
          
          #endif

          /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

          /* If a more preferred system is found, go to the MORE_PREF
          ** state to try acquiring the more preferred system.
          */
          if( acq_ptr->pref_pos != SDSR_POS_NULL )
          {
            acq_ptr->state = SDSS_ACQ_STT_MORE_PREF;
          }

          /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

          /* Else (a more preferred system is not found), if the acquired
          ** acquired system does not conflict with the current
          ** SS-Preference and it is a preferred PRL system, stay on this
          ** system.
          */
          else if( is_no_pref_conf &&
                   sdss_sr_is_prl(acq_sys_ptr, SDSS_PRL_VAL_ANY_PREF) )
          {
            acq_ptr->state = SDSS_ACQ_STT_DONE;
          }
            /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

            /* Else, stay in the start state and attempt acquire the
            ** next system from the acquisition list.
            */
        }


        if( acq_ptr->state == SDSS_ACQ_STT_DONE &&
            sdss_is_mmss_operation(acq_ptr->ss)            &&
          ( acq_sys_ptr->sys.mode == SYS_SYS_MODE_GSM ||
            acq_sys_ptr->sys.mode == SYS_SYS_MODE_WCDMA ||
            acq_sys_ptr->sys.mode == SYS_SYS_MODE_LTE ||
            acq_sys_ptr->sys.mode == SYS_SYS_MODE_GW ||
            acq_sys_ptr->sys.mode == SYS_SYS_MODE_TDS ||
            acq_sys_ptr->sys.mode == SYS_SYS_MODE_GWL  )
        )
        {
          SD_MSG_HIGH_0("MMSS: reacq_gwl in start");
          acq_ptr->state = SDSS_ACQ_STT_REACQ_GWL;
        }
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        /* Else, stay in the start state and attempt acquire the
        ** next system from the acquisition list.
        */
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
        case SDSSSCR_ACQ_MORE_PREF_RECURSIVE:
        case SDSSSCR_ACQ_MORE_PREF:
        case SDSSSCR_ACQ_MORE_PREF_THAN_SRV_SYS:
        case SDSSSCR_ACQ_NOT_LESS_PREF:
        case SDSSSCR_ACQ_NOT_LESS_PREF_OR_HOME:

          /* If acquired system does not conflict with the current
          ** SS-Preference and it is more/not less preferred than the serving
          ** system, stay on the acquired system.
          */
          if( is_no_pref_conf )
          {
            if( acq_type == SDSSSCR_ACQ_MORE_PREF_THAN_SRV_SYS )
            {
              srv_sys_ptr = sdsr_list_get_ptr(ACQ_LIST(SDSR_SRV_SYS), 0);
            }
            else
            {
              /* IDL_SYS list is cleared when HYBR2 stack enters BSR timeline.
              ** If the list gets populated while in BSR timeline(for eg: on
              ** acquiring limited regional service,IDL system is updated and
              ** HYBR2 stack goes back to BSR timeline), clear the IDL_SYS list
              ** while looking for more pref systems.
              */
              if( acq_ptr->ss == SD_SS_HYBR_2 &&
                  sdss_is_flag_set(SD_SS_HYBR_2,SDSS_FLAG_HYBR2_BSR) &&
                  sdsr_list_get_ptr(ACQ_LIST(SDSR_IDL_SYS), 0) != NULL )
              {
                SD_MSG_HIGH_0("acq_start: Clear IDL_SYS");
                sdsr_list_clr( ACQ_LIST(SDSR_IDL_SYS) );
              }
              srv_sys_ptr = sdsr_list_get_ptr(ACQ_LIST(SDSR_IDL_SYS), 0);
            }

            /* If we don't have a serving system, and the acquired system is
            ** allowed by the PRL, stay on the acquired system.
            */
            if( srv_sys_ptr == NULL )
            {
              if( sdss_sr_is_prl(acq_sys_ptr, SDSS_PRL_VAL_ALLOWED) )
              {
                SD_MSG_HIGH_0(" moving state to Done, as serving system is Null.");
                acq_ptr->state = SDSS_ACQ_STT_DONE;
                break;
              }
              else
              {
                break;
              }
            }

            is_acq_more_pref = sdprl_is_more_pref(ss, acq_sys_ptr, srv_sys_ptr);

            /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
            /* We have a serving system: If acq_type is MORE_PREF and
            ** the acquired system is more preferred than the serving system:
            ** If acq_type is NOT_LESS_PREF and the acquired system is not
            ** less preferred than the serving system, stay on the acquired
            ** system.
            */
            if( ((acq_type == SDSSSCR_ACQ_MORE_PREF ||
                  acq_type == SDSSSCR_ACQ_MORE_PREF_THAN_SRV_SYS) &&
                  is_acq_more_pref)
                                      ||

                 (acq_type == SDSSSCR_ACQ_NOT_LESS_PREF &&
                  !sdprl_is_more_pref_upto(ss, srv_sys_ptr, acq_sys_ptr,
                                           SDPRL_COMP_UPTO_ROAM)
                 )
                                      ||
                 (acq_type == SDSSSCR_ACQ_NOT_LESS_PREF_OR_HOME &&
                 (sdprl_roam_ind_map_custom_home_to_home(acq_sys_ptr->roam)
                                           == SYS_ROAM_STATUS_OFF ||
                  !sdprl_is_more_pref_upto(ss, srv_sys_ptr, acq_sys_ptr,
                                           SDPRL_COMP_UPTO_ROAM)
                  )
                )
              )
            {
              SD_MSG_HIGH_2(" Roam_ind for acq_sys_ptr_roam %d is %d",acq_sys_ptr->roam,sdprl_roam_ind_map_custom_home_to_home(acq_sys_ptr->roam));
              acq_ptr->state = SDSS_ACQ_STT_DONE;
            }
            /* For recursive, we will consider moving into the recursive scan
            */
            else if (acq_type == SDSSSCR_ACQ_MORE_PREF_RECURSIVE &&
                     is_acq_more_pref )
            {
              /* The type ACQ_MORE_PREF_RECURSIVE are used during Idle BSR.
              ** So during IDLE_BSR, if we are currently camp on 3GPP system,
              ** we rely on NAS to perform HPLMN scan to going to higher priority
              ** system. Hence, we removed other 3GPP systems in more_pref_list.
              ** (See script: ssscr_gw_opr_srv_info_more_preferred[] )
              **
              ** Here, if we're performing immediate BSR, this new pref_list also
              ** acq_ptr->pref_lst which was copied from
              **
              ** sdsr_list_cpy( acq_ptr->pref_lst, ACQ_LIST(SDSR_ACQ_PREF_LST) );
              **
              ** this pref_lst should comply with the previous PREF_LST. Which means
              ** that it that the GW should be removed if the current 'start_sys' is
              ** GW.
              ** Also if service system is 3gpp and SD doing more pref scans remove GW from
              ** newly computed pref_lst.
              */
              if( base_start_sys_mode == SD_MODE_GWL ||
                  (sdss_is_resel_state(ss,SDSS_RESEL_STT_SRCH) &&
                   (sdss_ptr(ss)->srv_status == SYS_SRV_STATUS_SRV) &&
                   (srv_sys_ptr->sys.mode == SD_MODE_GWL) &&
                   (sdss_get_ss_state(ss) == SDSS_STATE_ACQ)))
              {
                sdss_set_remove_gwl_on_bsr(ss, TRUE);
                sdsr_list_del_sys(acq_ptr->ss, acq_ptr->pref_lst, SDSR_CAT_GWL_SYS);
              }
              else
              {
                if(sdsr_list_is_contain(acq_ptr->pref_lst,SDSR_CONTAIN_ALL,sdss_sr_list_map2(acq_ptr->ss,SDSR_CAND_SYS)))
                {
                  SD_MSG_HIGH_0("Removing Candidate System from Pref List");
                  sdsr_list_del_list(acq_ptr->pref_lst, sdss_sr_list_map2( acq_ptr->ss, SDSR_CAND_SYS ) );
                }
              }

              /* If it's already the most preferred system, then no recusrive */
              if( sdss_sr_is_prl(acq_sys_ptr, SDSS_PRL_VAL_MOST_PREF) )
              {
                SD_MSG_HIGH_0("Most preferred system - done acquisitions");
                acq_ptr->state = SDSS_ACQ_STT_DONE;
              }
              /* Else, if the acquired system is a PRL listed system, check
              ** whether there are more preferred systems in the same GEO.
              */
              else if( sdss_sr_is_prl(acq_sys_ptr, SDSS_PRL_VAL_LISTED) )
              {
                /* Search for a more preferred system that complies with the
                ** current mode and band preference.
                */
                acq_ptr->pref_pos  =  sdss_sr_list_find_next(acq_ptr->ss,
                                                             acq_ptr->acq_con,
                                                             acq_mode,
                                                             acq_ptr->pref_lst,
                                                             0,
                                                             acq_ptr->new_acq_cnt,
                                                             -10000,
                                                             mode_pref,
                                                             band_pref,
                                                             lte_band_pref,
                                                             tds_band_pref,
                                                             acq_ptr->meas_cat );

                /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

                /* If a more preferred system is found, go to the MORE_PREF
                ** state to try acquiring the more preferred system.
                */
                if( acq_ptr->pref_pos != SDSR_POS_NULL )
                {
                  acq_ptr->state = SDSS_ACQ_STT_MORE_PREF;
                }

                /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

                /* Else (a more preferred system is not found), if the acquired
                ** acquired system does not conflict with the current
                ** SS-Preference and it is a preferred PRL system, stay on this
                ** system.
                */
                else if( sdss_sr_is_prl(acq_sys_ptr, SDSS_PRL_VAL_ANY_PREF) )
                {
                  acq_ptr->state = SDSS_ACQ_STT_DONE;
                }
              }
              /* if a system is more preferred than serving system, however it's not
              ** listed in the PRL either. In that case, we cannot do recursive, we
              ** could just continue.
              */
              else
              {
                SD_MSG_HIGH_0("System is not listed in PRL but more pref than srv_sys");
                acq_ptr->state = SDSS_ACQ_STT_DONE;
              }
            }
          }

          /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

          /* Else, stay in the start state and attempt acquire the
          ** next system from the acquisition list.
          */
          break;

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSSSCR_ACQ_SPECIFIC:

          /* If the SID/NID that was obtained during the acquisition matches
          ** the expected SID/NID, stay on the acquired system.
          */
          if( sdss_sr_is_sid_match_exp_sid(acq_sys_ptr) )
          {
            acq_ptr->state = SDSS_ACQ_STT_DONE;
          }

          /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

          /* Else, stay in the start state and attempt acquire the next
          ** system from the acquisition list.
          */

          break;

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSSSCR_ACQ_SPECIFIC_PRL:

          /* If the SID/NID that was obtained during the acquisition matches
          ** the expected SID/NID and is allowed by the PRL, stay on the
          ** acquired system.
          */
          if( sdss_sr_is_sid_match_exp_sid(acq_sys_ptr) &&
              sdss_sr_is_prl(acq_sys_ptr, SDSS_PRL_VAL_ALLOWED) )
          {
            acq_ptr->state = SDSS_ACQ_STT_DONE;
          }

          /* Else, stay in the start state and attempt acquire the
          ** next system from the acquisition list.
          */
          break;

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSSSCR_ACQ_SPECIFIC_PREF:

          /* If the SID/NID that was obtained during the acquisition does not
          ** conflict with the current SS-Preference, matches the expected
          ** SID/NID and is allowed by the PRL, stay on the acquired system.
          */
          if( is_no_pref_conf &&
              sdss_sr_is_sid_match_exp_sid(acq_sys_ptr) &&
              sdss_sr_is_prl(acq_sys_ptr, SDSS_PRL_VAL_ALLOWED) )
          {
            acq_ptr->state = SDSS_ACQ_STT_DONE;
          }

          /* Else, stay in the start state and attempt acquire the
          ** next system from the acquisition list.
          */
          break;

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSSSCR_ACQ_COLLOC_PREF:

          /* If acquired system does not conflict with the current
          ** SS-Preference, is collocated (associated) with the
          ** SDSR_CDMA_IDL_SYS system and is allowed by the PRL,
          ** stay on the acquired system.
          */
          cdma_srv_sys_ptr = sdsr_list_get_ptr( SDSR_CDMA_IDL_SYS, 0 );

          if( is_no_pref_conf &&
              sdss_is_sr_associated(acq_sys_ptr, cdma_srv_sys_ptr) &&
              sdss_sr_is_prl(acq_sys_ptr, SDSS_PRL_VAL_ANY_PREF) )
          {
            acq_ptr->state = SDSS_ACQ_STT_DONE;
          }

          /* Else, stay in the start state and attempt acquire the
          ** next system from the acquisition list.
          */
          break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      case SDSSSCR_ACQ_COLLOC_MORE_PREF_RECURSIVE:
      case SDSSSCR_ACQ_COLLOC_MORE_PREF:

        /* If acquired system does not conflict with the current
        ** SS-Preference, is collocated (associated) with the
        ** SDSR_CDMA_IDL_SYS system and is allowed by the PRL, stay on the
        ** acquired system and not less preferred than the idle system
        */
        cdma_srv_sys_ptr = sdsr_list_get_ptr( SDSR_CDMA_IDL_SYS, 0 );
        colloc_srv_sys_ptr = sdsr_list_get_ptr(ACQ_LIST(SDSR_IDL_SYS), 0);

        /*If we are in the middle of LTE to DO BSR compare the acq sys with LTE acq pref sys */
        if (sdss_ptr(ss)->resel_state == SDSS_RESEL_STT_MORE_PREF_HDR_SCAN )
        {
          hybr2_srv_sys_ptr = sdsr_list_get_ptr(sdss_sr_list_map2( SD_SS_HYBR_2, SDSR_ACQ_SYS), 0);
        }

        sdsr_list_print(sdss_sr_list_map2( SD_SS_HYBR_2, SDSR_ACQ_SYS), TRUE);

        is_hdr_colloc      = sdss_is_sr_associated(acq_sys_ptr, cdma_srv_sys_ptr);
        if( colloc_srv_sys_ptr == NULL && hybr2_srv_sys_ptr == NULL)
        {
          is_acq_more_pref = TRUE;
        }
        else
        {
          if(colloc_srv_sys_ptr != NULL )
          {
            is_acq_more_pref   = sdprl_is_more_pref(ss, acq_sys_ptr, colloc_srv_sys_ptr);
          }
          if(hybr2_srv_sys_ptr != NULL)
          {
            is_acq_more_pref   = sdprl_is_more_pref_upto_2(
               ss, SD_SS_HYBR_2, acq_sys_ptr, hybr2_srv_sys_ptr,SDPRL_COMP_UPTO_GEO_POS);

            SD_MSG_HIGH_1("LTE_TO_HDR: is_acq_more_pref is %d ",is_acq_more_pref);
          }
        }

        /* This is legacy way of handling COLLOC_MORE_PREF type */
        if( acq_type != SDSSSCR_ACQ_COLLOC_MORE_PREF_RECURSIVE &&
            is_no_pref_conf &&
            is_hdr_colloc &&
            sdss_sr_is_prl(acq_sys_ptr, SDSS_PRL_VAL_ALLOWED) &&
            is_acq_more_pref )
        {
          acq_ptr->state = SDSS_ACQ_STT_DONE;
        }
        /* This is the new approach to handle more pref with applied Recursive Alg. */
        else if (acq_type == SDSSSCR_ACQ_COLLOC_MORE_PREF_RECURSIVE &&
                 is_no_pref_conf &&
                 is_hdr_colloc   &&
                 is_acq_more_pref )
        {
          if( sdss_sr_is_prl(acq_sys_ptr, SDSS_PRL_VAL_MOST_PREF) )
          {
            acq_ptr->state = SDSS_ACQ_STT_DONE;
          }

          /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

          /* Else, if the acquired system is a PRL listed system, and is
          ** associated (collocated ) with SDSR_CDMA_IDL_SYS system, check
          ** whether there are more preferred systems in the same GEO.
          */
          else if( sdss_sr_is_prl(acq_sys_ptr, SDSS_PRL_VAL_LISTED) )
          {
            /* Search for a more preferred system that complies with the
            ** current mode and band preference.
            */
            acq_ptr->pref_pos  =  sdss_sr_list_find_next(acq_ptr->ss,
                                                         acq_ptr->acq_con,
                                                         acq_mode,
                                                         acq_ptr->pref_lst,
                                                         0,
                                                         acq_ptr->new_acq_cnt,
                                                         -10000,
                                                         mode_pref,
                                                         band_pref,
                                                         lte_band_pref,
                                                         tds_band_pref,
                                                         acq_ptr->meas_cat );

            /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

            /* If a more preferred system is found, go to the MORE_PREF
            ** state to try acquiring the more preferred system.
            */
            if( acq_ptr->pref_pos != SDSR_POS_NULL )
            {
              acq_ptr->state = SDSS_ACQ_STT_MORE_PREF;
            }

            /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

            /* Else (a more preferred system is not found), if the acquired
            ** acquired system does not conflict with the current
            ** SS-Preference, it is a preferred PRL system and it is associated
            ** (collocated) with the SDSR_CDMA_IDL_SYS system, stay on this
            ** system.
            */
            else if( sdss_sr_is_prl(acq_sys_ptr, SDSS_PRL_VAL_ANY_PREF) )
            {
              acq_ptr->state = SDSS_ACQ_STT_DONE;
            }
          }
        }

        /* Else, stay in the start state and attempt acquire the
        ** next system from the acquisition list.
        */
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_ACQ_COLLOC_BEST_PREF:

         /* If acquired system does not conflict with the current
         ** SS-Preference, is collocated (associated) with the
         ** SDSR_CDMA_IDL_SYS system and is allowed by the PRL,
         ** stay on the acquired system.
         */
         cdma_srv_sys_ptr = sdsr_list_get_ptr( SDSR_CDMA_IDL_SYS, 0 );
         is_hdr_colloc    = sdss_is_sr_associated(acq_sys_ptr, cdma_srv_sys_ptr);

        /* If acquired system does not conflict with the current
        ** SS-Preference and it is the most preferred in its GEO,
        ** and it is associated (collocated ) with the SDSR_IDL_SYS system,
        ** stay on the acquired system.
        */
        if( is_no_pref_conf &&
            is_hdr_colloc   &&
            sdss_sr_is_prl(acq_sys_ptr, SDSS_PRL_VAL_MOST_PREF) )
        {
          acq_ptr->state = SDSS_ACQ_STT_DONE;
        }

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        /* Else, if the acquired system is a PRL listed system, and is
        ** associated (collocated ) with SDSR_CDMA_IDL_SYS system, check
        ** whether there are more preferred systems in the same GEO.
        */
        else if( sdss_sr_is_prl(acq_sys_ptr, SDSS_PRL_VAL_LISTED) &&
                 is_hdr_colloc )
        {
          /* Search for a more preferred system that complies with the
          ** current mode and band preference.
          */
          acq_ptr->pref_pos  =  sdss_sr_list_find_next(acq_ptr->ss,
                                                       acq_ptr->acq_con,
                                                       acq_mode,
                                                       acq_ptr->pref_lst,
                                                       0,
                                                       0,
                                                       -10000,
                                                       mode_pref,
                                                       band_pref,
                                                       lte_band_pref,
                                                       tds_band_pref,
                                                       acq_ptr->meas_cat );

          #ifdef FEATURE_AVOID_DUP_BAND_SCAN
          /* Indicate that sd did go through sr list and try to find the next sr */
          is_find_next_processed = TRUE;
          loop_cnt ++;
          
          #endif

          /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

          /* If a more preferred system is found, go to the MORE_PREF
          ** state to try acquiring the more preferred system.
          */
          if( acq_ptr->pref_pos != SDSR_POS_NULL )
          {
            acq_ptr->state = SDSS_ACQ_STT_MORE_PREF;
          }

          /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

          /* Else (a more preferred system is not found), if the acquired
          ** acquired system does not conflict with the current
          ** SS-Preference, it is a preferred PRL system and it is associated
          ** (collocated) with the SDSR_CDMA_IDL_SYS system, stay on this
          ** system.
          */
          else if( is_no_pref_conf &&
                   sdss_sr_is_prl(acq_sys_ptr, SDSS_PRL_VAL_ANY_PREF) )
          {
            acq_ptr->state = SDSS_ACQ_STT_DONE;
          }

          /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

          /* Else, stay in the start state and attempt acquire the
          ** next system from the acquisition list.
          */
        }

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        /* Else, stay in the start state and attempt acquire the
        ** next system from the acquisition list.
        */
        break;

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSSSCR_ACQ_SAME_AS_LAST:
        case SDSSSCR_ACQ_MAX:
        default:
          SD_ERR_0( "acq_type");
          break;

      } /* switch( acq_type ) */

#ifdef FEATURE_MMODE_DYNAMIC_SV_OPERATION_SWITCH
        /* Store the pref_list & candidate list */
      /*if hybrid_2 acquired before main either
          ** 1.When powered up in dual stack and no service on MAIN 
          ** 2. Or just switched to dual stack due to LTE service on MAIN (LTE system that has more pref 1x system)
          ** --> store LTE to opr_switch_list*/
      /*only store opr_switch_list if acq sys is unforbidden system */

     sd_si_info_ptr_get( SD_SS_MAIN, &si_info );

     if(sdss_is_sfmode_1x_sxlte(sdss_map_ss_to_as_id(ss)) 
         &&
        (acq_type == SDSSSCR_ACQ_REG_BEST_PREF ||
        acq_type == SDSSSCR_ACQ_BEST_PREF ||
          (acq_ptr->ss == SD_SS_HYBR_2 && 
              (!sd_si_is_srv_on( SD_SS_MAIN ) ||
                (sd_si_is_srv_on( SD_SS_MAIN ) &&
                 si_info.mode == SYS_SYS_MODE_LTE )) 
           )) &&
       !(sdss_sr_is_prl(acq_sys_ptr, SDSS_PRL_VAL_FORBID)))
     {
        sdss_store_sv_opr_switch_lst(acq_ptr->ss);
      }
#endif
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      /* If state is START and AMPS 2nd strongest control channel needs to be
      ** attempted acquisition, return now.
      */
      if( acq_ptr->state == SDSS_ACQ_STT_START &&
          sdss_acq_is_amps_2nd_cch(acq_ptr,
                                   ACQ_LIST(SDSR_ACQ_SYS),
                                   0,
                                   acq_type,
                                   rtrn_iact_ptr) )
      {
        return list_is_exhausted;
      }

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      /* If this is a scheduled reacquisition and acq_state != DONE or REACQ_GWL
      ** (i.e., we have reacquired the system, but decided to continue attempting
      ** acquisition of other systems), cancel any pending reacquisition
      ** attempts of the acquired system by deleting it from the schedule
      ** list.
      */
      if( acq_ptr->sched_pos != SDSR_POS_NULL &&
          acq_ptr->state != SDSS_ACQ_STT_DONE &&
          acq_ptr->state != SDSS_ACQ_STT_REACQ_GWL)
      {
        (void) sdsr_list_del_ref( acq_ptr->sched_lst,
                                  sdsr_list_get_ref( ACQ_LIST(SDSR_ACQ_SYS),
                                                     0) );
      }
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    default:

      /* If we got here, this event has no impact on the acquisition
      ** processing, so just continue, if the system does not conflict
      ** with the current preferences.
      */
       pref_pos = sdss_sr_list_find_next(acq_ptr->ss,
                                         acq_ptr->acq_con,
                                         acq_mode,
                                         ACQ_LIST(SDSR_ACQ_SYS),
                                         0,
                                         0,
                                         -10000,
                                         mode_pref,
                                         band_pref,
                                         lte_band_pref,
                                         tds_band_pref,
                                         acq_ptr->meas_cat );
      if (pref_pos != SDSR_POS_NULL)
      {
        rtrn_iact_ptr->act = SDSS_IACT_CONTINUE;
        SD_MSG_HIGH_1( "Ignoring event=%d",event);

        return list_is_exhausted;
      }
      else
      {
        /* acq sys conflicts with preferences and so SD should not return
        ** action continue
        */
        SD_MSG_MED_1("cannot ignore event= %d",event);
      }

  } /* switch( event ) */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #ifdef FEATURE_AVOID_DUP_BAND_SCAN

    /* Only enter the following block once */
    if ( (loop_cnt == 1 || loop_cnt == 0))
    {
      /* Based on state change, do proc avoid_dup_scan - If PLMN_acq_success,
      ** but Acq state is changing from more_preferred/reacq -> start,
      ** then remove the band which acquired PLMN successfully.
      */

      band_scanned.band = acq_sys_ptr->sys.band;
      band_scanned.lte_band = acq_sys_ptr->sys.lte_band;
      band_scanned.tds_band = acq_sys_ptr->sys.tds_band;

      is_band_updated = sdss_proc_avoid_dup_scan_per_acq_state_chg( ss,
                                              event,
                                                &band_scanned,
                                                from_acq_state,
                                                                    acq_ptr->state);
    }

  }
  while (is_band_updated == TRUE
         && is_find_next_processed == TRUE
         && acq_ptr->state == SDSS_ACQ_STT_MORE_PREF
         && loop_cnt == 1);

  /* If all the more preferred system has duplicate bands, reset acq_stt.
  */
  /*lint -e539 */
  if (acq_ptr->pref_pos == SDSR_POS_NULL
      && acq_ptr->state == SDSS_ACQ_STT_MORE_PREF
      && is_find_next_processed == TRUE)
  {
    acq_ptr->state = from_acq_state;
    SD_MSG_HIGH_1("AVOID_DUP_BAND: acq_stt more_pref to %d",
                from_acq_state);
  }

  #endif /* #ifdef FEATURE_AVOID_DUP_BAND_SCAN */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #ifdef FEATURE_EOOS_UMTS
  {
    sdss_s_type *ss_ptr = acq_ptr->ss_ptr;
    if( event != sdss_event_map(acq_ptr->ss, SDSS_EVT_GWL_ACQ_PLMN_FAILED) ||
        ss_ptr->acq_gwl_scan_status != SD_SS_GWL_SCAN_STATUS_ABORTED )
    {
  #endif
      /* Set the new acquisition counter of the system that was attempted
      ** acquisition per the current value of the acquisition counter.
      */

      if( event != SDSS_EVT_MISC_GW_NET_LIST)
      {
        acq_sys_ptr->new_acq_cnt = acq_ptr->new_acq_cnt;
        acq_sys_ptr->last_acq_ss = acq_ptr->ss;
      }
      sdsr_list_del_list(ACQ_LIST(SDSR_PWR_SCAN_LST), ACQ_LIST(SDSR_ACQ_SYS) );
  #ifdef FEATURE_EOOS_UMTS
    } /* if */
  } /* ifdef */
  #endif
  /* Prevent acq cnt being overwritten for GW NETLIST event */
  if( event != SDSS_EVT_MISC_GW_NET_LIST)
  {
    acq_sys_ptr->new_acq_cnt = acq_ptr->new_acq_cnt;
    acq_sys_ptr->last_acq_ss = acq_ptr->ss;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Indicate that AMPS 2nd strongest control channel is not attempted
  ** acquisition.
  */
  acq_ptr->is_amps_2nd_cch                = FALSE;
  rtrn_iact_ptr->prm.acq.is_amps_2nd_cch  = FALSE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if( sdss_acq_ltd_reg_opti(ss))
  {
    if(acq_ptr->state == SDSS_ACQ_STT_DONE || sdss_is_event_3gpp_acq_success(event))
    {
      acq_ptr->state = SDSS_ACQ_STT_SUSPEND;
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  #ifdef FEATURE_SD_LTE
  /* If UE is in an emergency call origination and acquired system is an LTE
  ** limted service system which is part of UE's idle state capability
  ** transition to ACQ_STT_REACQ_FULL_SRV and issue a full service scan on
  ** the same system
  */
  sdss_get_nas_addl_info(acq_ptr->ss, &lte_cs_capability, &ext_srv_info);
  if( ext_srv_info             == SYS_EXTEND_SRV_INFO_FULL_SRV_POSSIBLE &&
      acq_ptr->state           == SDSS_ACQ_STT_DONE &&
      acq_sys_ptr->sid.gw.mode == SD_MODE_LTE &&
      sdss_is_emergency_call_orig(acq_ptr->ss)&&
      sdss_gw_sim_domain_valid (ss)
    )
  {
    /* Check if LTE was part of original UE cap
    */
    sys_rat_pri_list_info_s_type  *ss_prev_ue_cap;
    uint32                        idx;
    sdss_s_type                   *lte_ss_ptr;
    sd_ss_e_type                  lte_ss =  sdss_get_lte_idle_ss();
    sys_lte_band_mask_e_type      lte_band_pref_local1,lte_band_pref_local2 = SYS_LTE_BAND_MASK_CONST_ANY;

    SD_MSG_HIGH_1("LTE_911: chk prev ue cap %d",lte_ss);
    if(lte_ss != SD_SS_MAX)
    {
      lte_ss_ptr = sdss_ptr(lte_ss);

      ss_prev_ue_cap = &(lte_ss_ptr->idle_rat_pri_list_info);
      for( idx = 0 ; idx< ss_prev_ue_cap->num_items; idx++)
      {
        if(SD_MODE_LTE == ss_prev_ue_cap->priority_list_info[idx].acq_sys_mode)
        {
          lte_band_pref_local1 = sdsr_map_sys_rec_lte_band_to_lte_band_pref(acq_sys_ptr->sid.gw.band.lte_band);
          lte_band_pref_local2 = SYS_LTE_BAND_MASK_COMMON( &(ss_prev_ue_cap->priority_list_info[idx].band_cap.lte_band_cap),
                                              &lte_band_pref_local1);
          break;
        }
      }
      /* If LTE was part of the previous UE capability , check if the acquired
      ** band was part of it as well
      */
      if(idx != ss_prev_ue_cap->num_items &&
         !SYS_LTE_BAND_MASK_CHK_IF_EMPTY(&lte_band_pref_local2) )
      {
        SD_MSG_HIGH_0("LTE_911: acq band in orig cap");

        /* if idle mode orig mode was NONE ( implying that UE was in
        ** automatic mode , this is sufficient to look for
        ** full service */
        if(acq_ptr->ss_ptr->idle_orig_mode == SD_SS_ORIG_MODE_NONE)
        {
          SD_MSG_HIGH_0("LTE_911: reacq auto mode");
          acq_ptr->state = SDSS_ACQ_STT_REACQ_FULL_SRV;
        }
        else if(acq_ptr->ss_ptr->idle_orig_mode == SD_SS_ORIG_MODE_MANUAL_IDLE)
        {
          /* Point at manual system record */
          sdsr_s_type         *user_sys_ptr  = NULL;

          user_sys_ptr = sdsr_list_get_ptr( sdss_sr_list_map2( acq_ptr->ss, SDSR_MANUAL_LST), 0 );
          /* Check if the acquired PLMN is same as user selected pLMN.
          ** If it is , look for full service in manual mode on selected PLMN
          */
          if(!memcmp(&acq_sys_ptr->sid.gw.plmn.plmn_id,
                     &user_sys_ptr->sid_expected.prm.gwl.plmn.plmn_id,
                     sizeof(sys_plmn_id_s_type)))
          {
            SD_MSG_HIGH_0("LTE_911:manual mode user PLMN");
            acq_ptr->state = SDSS_ACQ_STT_REACQ_FULL_SRV;
          }
          /* Check if the acquired PLMN is part of EPLMN list
          ** If it is , look for full service in manual mode on selected EPLMN
          */
          else if(sys_eplmn_per_subs_list_equivalent_plmn(acq_sys_ptr->sid.gw.plmn.plmn_id,
                 sdss_map_ss_to_as_id(acq_ptr->ss)))
          {
            SD_MSG_HIGH_3("LTE_911: EPLMN acquired 0x%x 0x%x 0x%x",
                        acq_sys_ptr->sid.gw.plmn.plmn_id.identity[0],
                        acq_sys_ptr->sid.gw.plmn.plmn_id.identity[1],
                        acq_sys_ptr->sid.gw.plmn.plmn_id.identity[2]);
            acq_ptr->state = SDSS_ACQ_STT_REACQ_FULL_SRV;
          }
        }
        else
        {
          SD_ERR_1("LTE_911: incorrect idle_orig_mode %d",
                      acq_ptr->ss_ptr->idle_orig_mode );
        }
      }
    }//lte_ss != SD_SS_MAX
  }
  #endif //FEATURE_SD_LTE

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Based on the next state, adjust the acquisition position and build the
  ** return action.
  */
  switch( acq_ptr->state )
  {
    case SDSS_ACQ_STT_START:

      /* Get the next system to be attempted acquisition.
      */
      list_is_exhausted = sdss_acq_next( acq_ptr,
                                         acq_mode,
                                         mode_pref,
                                         band_pref,
                                         lte_band_pref,
                                         tds_band_pref,
                                         rtrn_iact_ptr );
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_ACQ_STT_MORE_PREF:

      /* Attempt to acquire a more preferred system.
      */
      rtrn_iact_ptr->act             = SDSS_IACT_ACQUIRE;
      rtrn_iact_ptr->prm.acq.list    = acq_ptr->pref_lst;
      rtrn_iact_ptr->prm.acq.pos     = acq_ptr->pref_pos;
      rtrn_iact_ptr->prm.acq.mode    = SDSS_ACQ_MODE_FULL;

      /* For internal generated event, wait for response from LL then
      ** perform next acq
      */
      if(event == SDSS_EVT_GWL_ACQ_PLMN_SUCCESS_LESS_PREF)
      {
        acq_ptr->pref_pos     = acq_ptr->pref_pos-1;
        rtrn_iact_ptr->act             = SDSS_IACT_CONTINUE;
      }

      SD_MSG_HIGH_0( "Attempt acquiring preferred systems");
      sdsr_list_print( acq_ptr->pref_lst, FALSE );

      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_ACQ_STT_SUSPEND:
       /* Stay on the acquired system. */
      rtrn_iact_ptr->act             = SDSS_IACT_CONTINUE;
      break;

    case SDSS_ACQ_STT_DONE:
      /* Stay on the acquired system. */
      sdss_set_remove_gwl_on_bsr(ss, FALSE);
      rtrn_iact_ptr->act             = SDSS_IACT_CONTINUE;
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_ACQ_STT_REACQ_GWL:
      /* Return in case of error - here, we don't extract information from the
      ** acq-syst.
      */
      reacq_sys_ptr = sdsr_list_get_ptr(SDSR_GW_CAND_SYS,0);

      if (reacq_sys_ptr == NULL)
      {
        is_cand_sys_empty = TRUE;
        reacq_sys_ptr = sdsr_list_get_ptr(acq_ptr->acq_lst,acq_ptr->acq_pos);
      }

      if(reacq_sys_ptr != NULL)
      {
        /* Attempt to reacquire same sys
        */
        rtrn_iact_ptr->act             = SDSS_IACT_ACQUIRE;

        if (!is_cand_sys_empty)
        {
          rtrn_iact_ptr->prm.acq.list    = SDSR_GW_CAND_SYS;
          rtrn_iact_ptr->prm.acq.pos     = 0;
        }
        else
        {
          rtrn_iact_ptr->prm.acq.list    = acq_ptr->acq_lst;
          rtrn_iact_ptr->prm.acq.pos     = acq_ptr->acq_pos;
        }

        rtrn_iact_ptr->prm.acq.mode    = SDSS_ACQ_MODE_FULL;
        rtrn_iact_ptr->prm.acq.gwl_acq_type.acq_type = SDSS_GWL_ACQ_REG_GIVEN_PLMN;
        rtrn_iact_ptr->prm.acq.gwl_acq_type.plmn =
                                            reacq_sys_ptr->sid.plmn.plmn_id;
        SD_MSG_HIGH_2( "MMSS: Attempt Reacq GWL sys %d %d ",acq_ptr->acq_lst,
                                                           acq_ptr->acq_pos);
      }
      else
      {
        SD_ERR_3("MMSS:bad state %d %d %d",SDSS_ACQ_STT_REACQ_GWL,
                     acq_ptr->acq_lst,
                     acq_ptr->acq_pos);

      }

      break;

     /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_ACQ_STT_REACQ_FULL_SRV:

      /* Attempt to reacquire same bands as previous service request.
      ** The network selection mode will depend on the state of the UE
      ** prior to originating the emergency call. If net sel mode was manual,
      ** UE will attempt to acquire service in manual mode.
      ** If net sel mode was automatic, UE will attempt full service acquisition
      */
      rtrn_iact_ptr->act             = SDSS_IACT_ACQUIRE;

      /* Update the last user system that contains the same bands as that in
      ** in the idle system. Otherwise LAST_USER_SYS or LAST_FULL_SYS could
      ** be uninitialized.
      */
      sdsr_list_update_post_gwl_sys( acq_ptr->ss,
      sdsr_list_get_ref(acq_ptr->rtrn_iact.prm.acq.list,acq_ptr->rtrn_iact.prm.acq.pos),
                                     TRUE, TRUE, TRUE );


      if(sdss_is_orig_mode0( acq_ptr->ss_ptr->idle_orig_mode, SD_SS_ORIG_MODE_VAL_MANUAL ))
      {
        rtrn_iact_ptr->prm.acq.list    = ACQ_LIST(SDSR_GWL_LAST_USER_SYS) ;
      }
      else
      {
        rtrn_iact_ptr->prm.acq.list    = ACQ_LIST(SDSR_GWL_LAST_FULL_SYS) ;
      }
      rtrn_iact_ptr->prm.acq.pos     = 0;
      rtrn_iact_ptr->prm.acq.mode    = SDSS_ACQ_MODE_FULL;
      rtrn_iact_ptr->prm.acq.gwl_acq_type.acq_type = SDSS_GWL_ACQ_NONE;

      /* Update the UE capability. The RAT priority list in SD should revert
      ** to the value in place prior to originating the emergency call.
      ** copy the emergency call preferences into prev_rat_pri_list_info to
      ** be used in case this attempt fails.
      */
      sdss_update_rat_pri_list_with_idle_cap(acq_ptr->ss);

      SD_MSG_HIGH_1( "LTE_911: Attempt Reacq GWL sys %d",rtrn_iact_ptr->prm.acq.list);
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    #ifdef FEATURE_EOOS
    #error code not present
#else
     case SDSS_ACQ_STT_PWR_SAVE_ENTER:
      SD_ERR_0( "state");
      break;
    #endif

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_ACQ_STT_SCAN_CONT:
      /* Continue with the scan
      */
      acq_ptr->state                = SDSS_ACQ_STT_START;
      rtrn_iact_ptr->act            = SDSS_IACT_ACQUIRE;
      rtrn_iact_ptr->prm.acq.list   = acq_ptr->rtrn_iact.prm.acq.list;
      rtrn_iact_ptr->prm.acq.pos    = acq_ptr->rtrn_iact.prm.acq.pos;
      rtrn_iact_ptr->prm.acq.mode   = acq_ptr->acq_mode;
      #ifdef FEATURE_EOOS
      #error code not present
#endif
      list_is_exhausted             = FALSE;
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    case SDSS_ACQ_STT_REACQ:
    case SDSS_ACQ_STT_PWR_SAVE:
    case SDSS_ACQ_STT_MAX:
    case SDSS_ACQ_STT_NONE:
    default:
      SD_ERR_0( "state");
      break;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #ifdef FEATURE_AVOID_DUP_BAND_SCAN
  /* SDSS_ACQ_STT_REACQ/REACQ_GWL/REACQ_FULL_SRV: Suspend avoid_dup_scan.
  ** SDSS_ACQ_STT_DONE: Reset band_to_avoid and avoid_state.
  */

  
  sdss_proc_avoid_dup_scan_acq_state_reacq_or_done(ss, acq_ptr->state);
  
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return list_is_exhausted;

} /* sdss_acq_start_event_proc */

/*lint +esym(715, roam_pref, scr_timer_ptr) */ /* not referenced */
/*lint +esym(818, scr_timer_ptr) */ /* Could be declared as pointing to const
                                    */
/*===========================================================================

FUNCTION sdss_is_more_pref_recursive

DESCRIPTION
  This function trigger whether another recursive level is required.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the entire list that is currently being associated with the
  acquisition state machine is exhausted. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean                 sdss_is_more_pref_recursive(

        const sdsr_s_type      *acq_sys_ptr
        /* Pointer to the acq system */
)
{

  /* Return whether or not we should recursive scan on more_pref system */
  boolean                       is_recursive = FALSE;

  /* Recursive if we're in Single GEO matches */
  if (acq_sys_ptr->is_multi_geo_match == FALSE )
  {
    is_recursive = TRUE;
  }

  return is_recursive;

} /* sdss_is_more_pref_recursive() */

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_acq_more_pref_event_proc

DESCRIPTION
  Process SS-Event in the context of an SDSS_ACQ_STT_MORE_PREF state and
  instruct the caller of the next SS-Internal-Action to take.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the entire list that is currently being associated with the
  acquisition state machine is exhausted. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean                 sdss_acq_more_pref_event_proc(

        sdss_acq_s_type         *acq_ptr,
            /* Pointer an acquisition state machine to process the SS-Event.
            */

        sdss_acq_mode_e_type    acq_mode,
            /* Acq mode for avoided system
            */

        sdss_evt_e_type         event,
            /* SS-Event to process.
            */

        sd_ss_mode_pref_e_type  mode_pref,
            /* Current mode preference.
            */

        sd_ss_band_pref_e_type  band_pref,
            /* Current 3G band preference.
            */

        sys_lte_band_mask_e_type    lte_band_pref,
            /* LTE band pref */

        sd_ss_band_pref_e_type    tds_band_pref,
            /* TD-SCDMA band pref */

        sd_ss_roam_pref_e_type  roam_pref,
            /* Current roam preference.
            *//*lint -esym(715, roam_pref) */ /* not referenced */

        sdss_iact_s_type        *rtrn_iact_ptr
            /* Pointer to a buffer where to place returned internal action.
            */
)
{

  sdsr_s_type                   *acq_sys_ptr;
  sdsr_s_type                   *start_sys_ptr;
  sdsr_s_type                   *cdma_srv_sys_ptr;
  boolean                       list_is_exhausted = FALSE;
  sd_ss_e_type                  ss;
  int                           next_position = SDSR_POS_NULL;
  byte                          new_acq_cnt = 0;

  #ifdef FEATURE_AVOID_DUP_BAND_SCAN
  sdss_acq_stt_e_type   from_acq_state;
  sdss_band_s_type band_scanned;
  boolean is_find_next_processed = FALSE;
  boolean is_band_updated = FALSE;

  #endif

  if(acq_ptr==NULL)
  {
    sys_err_fatal_null_ptr_exception();
  }
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( acq_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( event, SDSS_EVT_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( mode_pref, SD_SS_MODE_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( band_pref, SD_SS_BAND_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( roam_pref, SD_SS_ROAM_PREF_MAX );
  SD_ASSERT( rtrn_iact_ptr != NULL );
  SD_ASSERT( acq_ptr->ss_ptr != NULL );

  ss = acq_ptr->ss;
  #ifdef FEATURE_AVOID_DUP_BAND_SCAN
  from_acq_state = acq_ptr->state;
  SD_ASSERT_ENUM_IS_INRANGE( from_acq_state, SDSS_ACQ_STT_MAX );
  #endif

  /* For this MORE_PREF type, since we triggered this through BSR, not from
  ** OOS, we don't allow to 'rescan' the system that has been scanned
  */
  if ( acq_ptr->acq_type == SDSSSCR_ACQ_MORE_PREF_RECURSIVE ||
       acq_ptr->acq_type == SDSSSCR_ACQ_COLLOC_MORE_PREF_RECURSIVE )
  {
    new_acq_cnt = acq_ptr->new_acq_cnt;
  }

  #ifdef FEATURE_AVOID_DUP_BAND_SCAN

  
    /* Suspend filtering for immdiate BSR scans
     */
  if ((acq_ptr->acq_type == SDSSSCR_ACQ_BEST_PREF ||
         acq_ptr->acq_type == SDSSSCR_ACQ_REG_BEST_PREF) &&
         sdss_is_srv_lost_state(ss))
  {
      SD_MSG_HIGH_0("AVOID_DUP_SCAN: srv lost and in more pref acq");
      sdss_avoid_dup_scan_suspend(acq_ptr->ss);
  }
  
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* First get the information of the system being attempted acquisition in
  ** this state, as well as, the information of the last system being
  ** acquired in the SDSS_ACQ_STT_START state.
  */
  acq_sys_ptr = sdsr_list_get_ptr( ACQ_LIST(SDSR_ACQ_SYS), 0 );
  if( acq_sys_ptr == NULL )
  {
    sys_err_fatal_null_ptr_exception();
  }

  start_sys_ptr = sdsr_list_get_ptr( acq_ptr->start_sys, 0 );
  if( start_sys_ptr == NULL )
  {
    sys_err_fatal_null_ptr_exception();
  }

  cdma_srv_sys_ptr = sdsr_list_get_ptr( SDSR_CDMA_IDL_SYS, 0 );

  /* Store scanned systems during recursive phase */
  if (ss == SD_SS_MAIN || ss == SD_SS_HYBR_1)
  {
    sdsr_ref_type   sr_ref;
    sr_ref = sdsr_list_get_ref( ACQ_LIST(SDSR_ACQ_SYS), 0 );

    /* Append the system which we scanned to this MORE_PREF_SCANNED_LIST */
    sdsr_list_app_ref(ACQ_LIST(SDSR_MORE_PREF_SCANNED_LST) , sr_ref );
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  switch( event )
  {
    case SDSS_EVT_CDMA_ACQ_FAILED_PILOT:
    case SDSS_EVT_CDMA_ACQ_FAILED_SYNC:
    case SDSS_EVT_CDMA_ACQ_PROT_MIS:

    case SDSS_EVT_AMPS_ACQ_FAILED_CCH:

    case SDSS_EVT_HDR_ACQ_FAILED_PILOT:
    case SDSS_EVT_HDR_ACQ_FAILED_SYNC:
    case SDSS_EVT_HDR_ACQ_PROT_MIS:
    case SDSS_EVT_HDR_ACQ_BAD_SYS:
    case SDSS_EVT_GWL_ACQ_PLMN_FAILED:
      /* Acquisition attempt failed.
      */

      /* Try acquiring the next system that complies with the current mode
      ** and band preference from the more preferred list.
      */
      acq_ptr->pref_pos  =  sdss_sr_list_find_next( acq_ptr->ss,
                                                    acq_ptr->acq_con,
                                                    acq_mode,
                                                    acq_ptr->pref_lst,
                                                    acq_ptr->pref_pos+1,
                                                    new_acq_cnt,
                                                    -10000,
                                                    mode_pref,
                                                    band_pref,
                                                    lte_band_pref,
                                                    tds_band_pref,
                                                    acq_ptr->meas_cat );

      /* If the more preferred list is exhausted go back to the start state.
      */
      if( acq_ptr->pref_pos == SDSR_POS_NULL )
      {
        acq_ptr->state = SDSS_ACQ_STT_START;
      }
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_EVT_CDMA_ACQ_SCHM:
    case SDSS_EVT_AMPS_ACQ_CCH_SID:
    case SDSS_EVT_HDR_ACQ_SID:
    case SDSS_EVT_GWL_ACQ_PLMN_SUCCESS:
      /* Acquisition attempt succeeded.
      */
    if(event == SDSS_EVT_GWL_ACQ_PLMN_SUCCESS)
      {
        if( sdss_sr_is_prl(acq_sys_ptr,SDSS_PRL_VAL_MOST_PREF)
                          &&
          sdss_sr_is_pref_conf0(acq_ptr->ss,
                                acq_sys_ptr,
                                SDSS_PREF_CONF_NONE,
                                TRUE) &&
          sdss_is_mmss_operation(ss) &&
          sdss_get_srv_req_type(ss) == SD_SS_SRV_REQ_TYPE_MMSS_RPLMN &&
          sdss_is_mru_3gpp( ss))
        {
          if( sdss_acq_ltd_reg_opti(ss) )
          {
            acq_ptr->state = SDSS_ACQ_STT_SUSPEND;
          }
          else
          {
            acq_ptr->state = SDSS_ACQ_STT_DONE;
          }

          SD_MSG_HIGH_0("skip more pref scan for RPLMN");
          break;
        }
      }

      /* If the acquired system is a preferred PRL system that complies with
      ** the current SS-Preference, is more preferred than the last system
      ** acquired in the start state and is collocated (associated) with
      ** SDSR_CDMA_IDL_SYS system, stay and provide service on this
      ** system.
      */
      if( sdss_sr_is_prl(acq_sys_ptr,SDSS_PRL_VAL_ANY_PREF)
                          &&
          sdss_sr_is_pref_conf0(acq_ptr->ss,
                                acq_sys_ptr,
                                SDSS_PREF_CONF_NONE,
                                TRUE)
                          &&
          sdprl_is_more_pref(ss, acq_sys_ptr, start_sys_ptr)
                          &&
          (acq_ptr->acq_type != SDSSSCR_ACQ_COLLOC_BEST_PREF ||
           sdss_is_sr_associated(acq_sys_ptr, cdma_srv_sys_ptr)))
      {
        if( sdss_acq_ltd_reg_opti(ss) )
        {
          acq_ptr->state = SDSS_ACQ_STT_SUSPEND;
        }
        else
        {
          /* Recursive Algorithm:
          ** If the more preferred system is acquired, then we perform recursive:
          ** 1. If this system is most preferred, then DONE.
          ** 2. If new system is not the most preferred, but it's single-GEO match,
          **    we should update the pref_list and scan only this local pref_list
          **    This system is remembered as the best system so far found.
          ** 3. If new system is not the most preferred, and it's multi-GEO matches
          **    we should continue and try the next system.
          **    This system is remembered as the best system so far found.
          ** 4. If all pref_list exhausted, re-acquire the start_sys, which is the best
          **    system found so far.
          */
          if (sdss_sr_is_prl(acq_sys_ptr,SDSS_PRL_VAL_MOST_PREF))
          {
            SD_MSG_HIGH_0("Most preferred system found ");
            acq_ptr->state = SDSS_ACQ_STT_DONE;
          }
          else if (sdss_is_more_pref_recursive(acq_sys_ptr)) //continue but recursive in single GEO.
          {

            SD_MSG_HIGH_0("Update pref_list, finding next system to recursively scan");
            /* update the pref_list by the ACQ_PREF_LST, start_pos, pref_pos */
            sdsr_list_cpy( acq_ptr->pref_lst, ACQ_LIST(SDSR_ACQ_PREF_LST) );

          if(sdsr_list_is_contain(acq_ptr->pref_lst,SDSR_CONTAIN_ALL,sdss_sr_list_map2(acq_ptr->ss,SDSR_CAND_SYS)))
          {
             SD_MSG_HIGH_0("ACQ_MORE_PREF Removing Candidate System from Pref List");
             sdsr_list_del_list(acq_ptr->pref_lst, sdss_sr_list_map2( acq_ptr->ss, SDSR_CAND_SYS ) );
          }

            /* If we need to remove GWL system on new pref_lst for BSR. For the motivation
            ** behind this, check the usage of the variable "remove_gwl_on_bsr" and its
            ** definition/comments
            */
            if( sdss_ptr(ss)->remove_gwl_on_bsr )
            {
              sdsr_list_del_sys(acq_ptr->ss, acq_ptr->pref_lst, SDSR_CAT_GWL_SYS);
            }

            acq_ptr->acq_start_pos = 0;
            acq_ptr->pref_pos = 0;

	    sdsr_list_print(sdss_sr_list_map2(acq_ptr->ss,SDSR_CAND_SYS), FALSE);
            sdsr_list_print(acq_ptr->pref_lst, FALSE);

            next_position = sdss_sr_list_find_next( acq_ptr->ss,
                                                acq_ptr->acq_con,
                                                acq_mode,
                                                acq_ptr->pref_lst,
                                                acq_ptr->pref_pos, //scan from beginning
                                                new_acq_cnt,
                                                -10000,
                                                mode_pref,
                                                band_pref,
                                                lte_band_pref,
                                                tds_band_pref,
                                                acq_ptr->meas_cat );
            /* if the list exhausted - consider camping on this system. return DONE */
            if (next_position == SDSR_POS_NULL)
            {
              SD_MSG_HIGH_0("Recursive but nothing is scanned in recursive list ");
              acq_ptr->state = SDSS_ACQ_STT_DONE;
            }
            else
            {
              SD_MSG_HIGH_0("Recursive into new GEO/Start_sys/Pref_list");
              sdsr_list_cpy( acq_ptr->start_sys, ACQ_LIST(SDSR_ACQ_SYS) );
              acq_ptr->pref_pos = next_position;
            }
          }
          else //continue on the same list
          {

            //assign the start_sys to be the new candidate sys
            next_position = sdss_sr_list_find_next( acq_ptr->ss,
                                                acq_ptr->acq_con,
                                                acq_mode,
                                                acq_ptr->pref_lst,
                                                acq_ptr->pref_pos+1,
                                                new_acq_cnt,
                                                -10000,
                                                mode_pref,
                                                band_pref,
                                                lte_band_pref,
                                                tds_band_pref,
                                                acq_ptr->meas_cat );

            if (next_position == SDSR_POS_NULL)
            {
              SD_MSG_HIGH_0("Pref-List is exhausted");
              acq_ptr->state = SDSS_ACQ_STT_DONE;
            }
            else
            {
              /*
              ** In Multi-GEO: Return once it's matched. Don't continue non-recursively.
              ** If we keeps continue, we might increase the total acquisition time.
              */
              SD_MSG_HIGH_0("Continue scanning pref_list ");
              sdsr_list_cpy( acq_ptr->start_sys, ACQ_LIST(SDSR_ACQ_SYS) );
              acq_ptr->pref_pos = next_position;
            }
          }
        }
      }

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      /* Else if AMPS 2nd strongest control channel needs to be attempted
      ** acquisition, return now.
      */
      else if( sdss_acq_is_amps_2nd_cch( acq_ptr,
                                         ACQ_LIST(SDSR_ACQ_SYS),
                                         0,
                                         SDSSSCR_ACQ_BEST_PREF,
                                         rtrn_iact_ptr) )
      {
          return list_is_exhausted;
      }

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      /* Else, attempt acquiring the next system that complies with the
      ** current mode and band preference from the more_pref list.
      */
      else
      {
        acq_ptr->pref_pos  =  sdss_sr_list_find_next( acq_ptr->ss,
                                                      acq_ptr->acq_con,
                                                      acq_mode,
                                                      acq_ptr->pref_lst,
                                                      acq_ptr->pref_pos+1,
                                                      new_acq_cnt,
                                                      -10000,
                                                      mode_pref,
                                                      band_pref,
                                                      lte_band_pref,
                                                      tds_band_pref,
                                                      acq_ptr->meas_cat );


        #ifdef FEATURE_AVOID_DUP_BAND_SCAN
        
        /* Indicate that sd did go through sr list and try to find the next sr */
         is_find_next_processed = TRUE;
        
        #endif

        /* If the more preferred list is exhausted go back to the start
        ** state.
        */
        if( acq_ptr->pref_pos == SDSR_POS_NULL )
        {
          acq_ptr->state = SDSS_ACQ_STT_START;
        }
      }


      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    default:

      /* If we got here, this event has no impact on the acquisition
      ** processing, so just continue.
      */
      rtrn_iact_ptr->act = SDSS_IACT_CONTINUE;
      SD_MSG_HIGH_1( "Ignoring event=%d",event);

      return list_is_exhausted;

  } /* switch( event ) */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Indicate that AMPS 2nd strongest control channel is not attempted
  ** acquisition.
  */
  acq_ptr->is_amps_2nd_cch                = FALSE;
  rtrn_iact_ptr->prm.acq.is_amps_2nd_cch  = FALSE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If acquisition time is expired, indicate that acquisition list traversal
  ** is over.
  */
  if ( acq_ptr->acq_type == SDSSSCR_ACQ_MORE_PREF_RECURSIVE ||
       acq_ptr->acq_type == SDSSSCR_ACQ_COLLOC_MORE_PREF_RECURSIVE )
  {
    qword time_now = { 0 };
    dword uptime = time_get_uptime_secs();

    /* Read the current time
    */
    time_get_uptime_ms( time_now );

    SD_MSG_HIGH_3(" Time: time_get_uptime_secs %d , ms: %d, acq_start_time: %d",
                   uptime,(QW_CVT_Q2N(time_now) % 1000 ),
                   acq_ptr->acq_max_uptime );

    /* Lint complains about suspicious cast, time_now is of type qword and
    ** we are casting it to uint64 and then taking the modulus of the
    ** resulting number
    */
    /*lint -e740 */
    if( (QW_CVT_Q2N(time_now) % 1000 ) >= 500 )
    /*lint +e740 */
    {
      uptime++;
    }

    /* If uptime has expired, in this case, we should do finally scan to
    ** the last 'best-so-far' system
    */
    if( uptime > acq_ptr->acq_max_uptime )
    {
      acq_ptr->state = SDSS_ACQ_STT_START;
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


  /* If PLMN_acq_success, process avoid_dup_scan based on acq state change.
   ** ie. if acq state changes from any -> start, need to save the band so that
   ** it will be filtered out in the future scan to avoid dup band scan.
   */
  #ifdef FEATURE_AVOID_DUP_BAND_SCAN

  {
    band_scanned.band = acq_sys_ptr->sys.band;
    band_scanned.lte_band = acq_sys_ptr->sys.lte_band;
    band_scanned.tds_band = acq_sys_ptr->sys.tds_band;

    /* is_band_saved indicates if the band mask is updated. */
    is_band_updated = sdss_proc_avoid_dup_scan_per_acq_state_chg( ss,
                                                event,
                                                &band_scanned,
                                                from_acq_state,
                                                acq_ptr->state);


    /* If band mask is updated,
    ** and if is_find_next_processed == TRUE indicating if finding next sr
    ** is processed in this function,
    ** and if acq_state is more pref,
    ** then we need to call sdss_sr_list_find_next again to get the next sr.
    ** Reason: band mask is updated so need to refilter next sr.
    ** Note: pref_pos is the last pref_pos not pref_pos+1
    */
    if (is_band_updated == TRUE
        && is_find_next_processed == TRUE
        && acq_ptr->state == SDSS_ACQ_STT_MORE_PREF)
    {
      acq_ptr->pref_pos  =  sdss_sr_list_find_next( acq_ptr->ss,
                                                    acq_ptr->acq_con,
                                                    acq_mode,
                                                    acq_ptr->pref_lst,
                                                    acq_ptr->pref_pos,
                                                    0,
                                                    -10000,
                                                    mode_pref,
                                                    band_pref,
                                                    lte_band_pref,
                                                    tds_band_pref,
                                                    acq_ptr->meas_cat );

      if( acq_ptr->pref_pos == SDSR_POS_NULL )
      {
        acq_ptr->state = SDSS_ACQ_STT_START;
      }
    }
  }
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Based on the next state, adjust the acquisition position and build the
  ** return action.
  */
  switch( acq_ptr->state )
  {
    case SDSS_ACQ_STT_START:

      /* If the last system being acquired in the start state is a preferred
      ** system that complies with the current SS-Preference, and is
      ** associated (collocated) with SDSR_CDMA_IDL_SYS system, go to the
      ** SDSS_ACQ_STT_REACQ state and attempt to reacquire that system.
      */
      if( sdss_sr_is_prl(start_sys_ptr, SDSS_PRL_VAL_ANY_PREF)
                           &&
          sdss_sr_is_pref_conf0(acq_ptr->ss,
                                start_sys_ptr,
                                SDSS_PREF_CONF_NONE,
                                TRUE)
                           &&
          (acq_ptr->acq_type != SDSSSCR_ACQ_COLLOC_BEST_PREF ||
           sdss_is_sr_associated(start_sys_ptr, cdma_srv_sys_ptr)))
      {
        acq_ptr->state               = SDSS_ACQ_STT_REACQ;

        rtrn_iact_ptr->act           = SDSS_IACT_ACQUIRE;
        rtrn_iact_ptr->prm.acq.list  = acq_ptr->start_sys;
        rtrn_iact_ptr->prm.acq.pos   = 0;
        rtrn_iact_ptr->prm.acq.mode  = SDSS_ACQ_MODE_FULL;

        SD_MSG_HIGH_0( "Attempt reacquire candidate system");
      }

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      /* Else, select the next system to be attempted acquisition in the
      ** start state.
      */
      else
      {
        list_is_exhausted = sdss_acq_next( acq_ptr,
                                           acq_mode,
                                           mode_pref,
                                           band_pref,
                                           lte_band_pref,
                                           tds_band_pref,
                                           rtrn_iact_ptr);
      }
      /* If we're no longer in the more-pref scanned list, then clear list */
      if (ss == SD_SS_MAIN || ss == SD_SS_HYBR_1)
      {
        sdsr_list_clr( ACQ_LIST(SDSR_MORE_PREF_SCANNED_LST) );
        sdss_set_remove_gwl_on_bsr(ss,FALSE);
      }

      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_ACQ_STT_MORE_PREF:

      /* Attempt to acquire the more preferred system.
      */
      rtrn_iact_ptr->act             = SDSS_IACT_ACQUIRE;
      rtrn_iact_ptr->prm.acq.list    = acq_ptr->pref_lst;
      rtrn_iact_ptr->prm.acq.pos     = acq_ptr->pref_pos;
      rtrn_iact_ptr->prm.acq.mode    = SDSS_ACQ_MODE_FULL;

      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_ACQ_STT_DONE:
      /* Stay on the acquired system.
      */
      rtrn_iact_ptr->act             = SDSS_IACT_CONTINUE;

      /* If we're no longer in the more-pref scanned list, then clear list */
      if (ss == SD_SS_MAIN || ss == SD_SS_HYBR_1)
      {
        sdsr_list_clr( ACQ_LIST(SDSR_MORE_PREF_SCANNED_LST) );
        sdss_set_remove_gwl_on_bsr(ss,FALSE);
      }
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_ACQ_STT_SUSPEND:
      /* Stay on the acquired system.
      */
      rtrn_iact_ptr->act             = SDSS_IACT_CONTINUE;

      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    case SDSS_ACQ_STT_REACQ:
    case SDSS_ACQ_STT_REACQ_GWL:
    case SDSS_ACQ_STT_REACQ_FULL_SRV:
    case SDSS_ACQ_STT_PWR_SAVE_ENTER:
    case SDSS_ACQ_STT_PWR_SAVE:
    case SDSS_ACQ_STT_SCAN_CONT:
    case SDSS_ACQ_STT_MAX:
    case SDSS_ACQ_STT_NONE:
    default:
      SD_ERR_0( "state");
      break;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #ifdef FEATURE_AVOID_DUP_BAND_SCAN
  /* SDSS_ACQ_STT_REACQ/REACQ_GWL/REACQ_FULL_SRV: Suspend avoid_dup_scan.
  ** SDSS_ACQ_STT_DONE: Reset band_to_avoid and avoid_state.
  */
  
  sdss_proc_avoid_dup_scan_acq_state_reacq_or_done(ss, acq_ptr->state);
  
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Set the new acquisition counter of the system that was attempted
  ** acquisition per the current value of the acquisition counter.
  */
  acq_sys_ptr->new_acq_cnt = acq_ptr->new_acq_cnt;
  acq_sys_ptr->last_acq_ss = acq_ptr->ss;
  sdsr_list_del_list(ACQ_LIST(SDSR_PWR_SCAN_LST), ACQ_LIST(SDSR_ACQ_SYS) );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return list_is_exhausted;

} /* sdss_acq_more_pref_event_proc */ /*lint +esym(715, roam_pref) */


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_acq_done_event_proc

DESCRIPTION
  Process SS-Event in the context of an SDSS_ACQ_STT_DONE state and instruct
  the caller of the next SS-Internal-Action to take.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the entire list that is currently being associated with the
  acquisition state machine is exhausted. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean                 sdss_acq_done_event_proc(

        sdss_acq_s_type         *acq_ptr,
            /* Pointer an acquisition state machine to process the SS-Event.
            */

        sdss_acq_mode_e_type    acq_mode,
            /* Acq mode for avoided system
            */

        sdss_evt_e_type         event,
            /* SS-Event to process.
            */

        sd_ss_mode_pref_e_type  mode_pref,
            /* Current mode preference.
            */

        sd_ss_band_pref_e_type  band_pref,
            /* Current 3G band preference.
            */

        sys_lte_band_mask_e_type    lte_band_pref,
          /* LTE band preference */

        sd_ss_band_pref_e_type    tds_band_pref,
          /* TD-SCDMA band preference */

        sd_ss_roam_pref_e_type  roam_pref,
            /* Current roam preference.
            *//*lint -esym(715, roam_pref) */ /* not referenced */

        sdss_iact_s_type        *rtrn_iact_ptr
            /* Pointer to a buffer where to place returned internal action.
            */
)
{

  boolean           list_is_exhausted = FALSE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( acq_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( event, SDSS_EVT_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( mode_pref, SD_SS_MODE_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( band_pref, SD_SS_BAND_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( roam_pref, SD_SS_ROAM_PREF_MAX );
  SD_ASSERT( rtrn_iact_ptr != NULL );
  SD_ASSERT( acq_ptr->ss_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If SS-Event is a user or miscellaneous event, instruct the SS-Client to
  ** continue.
  **
  ** Note that user or miscellaneous events that require a change of policy
  ** are not expected to get here as they cause a new script to be activated.
  */
  if( SDSS_EVT_IS_USER(event) ||
      SDSS_EVT_IS_HYBR_2_USER(event) ||
      SDSS_EVT_IS_HYBR_3_USER(event) ||
      SDSS_EVT_IS_MISC(event) )
  {
    rtrn_iact_ptr->act = SDSS_IACT_CONTINUE;
    SD_MSG_HIGH_1( "Ignoring event=%d",event);

    return list_is_exhausted;
  }


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If we got here, the SS-Event is a protocol related event, so go back to
  ** the start/more-preferred state and select the next system to be
  ** attempted acquisition.
  **
  ** Note that protocol related events that require a change of policy are
  ** not expected to get here as they cause a new script to be activated.
  ** For some protocol events, however, like SDSS_EVT_AMPS_OPR_FAILED_PCH it
  ** might be desirable to continue with the current SS-Script.
  */
  if( acq_ptr->prev_state == SDSS_ACQ_STT_MORE_PREF )
  {
    /* Go back to more-preferred state.
    */
    acq_ptr->state = SDSS_ACQ_STT_MORE_PREF;

    /* Try acquiring the next system that complies with the current mode
    ** and band preference from the more preferred list.
    */
    acq_ptr->pref_pos  =  sdss_sr_list_find_next( acq_ptr->ss,
                                                  acq_ptr->acq_con,
                                                  acq_mode,
                                                  acq_ptr->pref_lst,
                                                  acq_ptr->pref_pos+1,
                                                  0,
                                                  -10000,
                                                  mode_pref,
                                                  band_pref,
                                                  lte_band_pref,
                                                  tds_band_pref,
                                                  acq_ptr->meas_cat );

    /* If the more preferred list is exhausted, go to the reacq state.
    */
    if( acq_ptr->pref_pos == SDSR_POS_NULL )
    {
      acq_ptr->state = SDSS_ACQ_STT_REACQ;
    }
  }
  else
  {
    /* Go back to start state.
    */
    sys_srv_status_e_type    ss_srv_status     = SYS_SRV_STATUS_NONE;
    sdss_read_srv_status( acq_ptr->ss, &ss_srv_status, NULL );

    if( sdss_acq_ltd_reg_opti(acq_ptr->ss) )
    {
      acq_ptr->state = SDSS_ACQ_STT_SUSPEND;
    }
    else if( ss_srv_status == SYS_SRV_STATUS_LIMITED_REGIONAL )
    {
      rtrn_iact_ptr->act = SDSS_IACT_CONTINUE;
      SD_MSG_HIGH_0( "Ltd Reg service exiting acq_state_machine");
      return list_is_exhausted;
    }
    else
    {
      acq_ptr->state = SDSS_ACQ_STT_START;
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Indicate that AMPS 2nd strongest control channel is not attempted
  ** acquisition.
  */
  acq_ptr->is_amps_2nd_cch                = FALSE;
  rtrn_iact_ptr->prm.acq.is_amps_2nd_cch  = FALSE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Based on the next state, adjust the acquisition position and  build the
  ** return action.
  */
  switch( acq_ptr->state )
  {
    case SDSS_ACQ_STT_START:

      /* Set the service-indication to OFF and select the next system to be
      ** attempted acquisition.
      */
      SD_MSG_HIGH_1( "ACQ_STT DONE -> START, event=%d",event);

      #ifndef FEATURE_JCDMA
      sd_si_srv_off( acq_ptr->ss, FALSE );
      #endif

      list_is_exhausted = sdss_acq_next( acq_ptr,
                                         acq_mode,
                                         mode_pref,
                                         band_pref,
                                         lte_band_pref,
                                         tds_band_pref,
                                         rtrn_iact_ptr );
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_ACQ_STT_MORE_PREF:

      /* Attempt to acquire the more preferred system.
      */
      SD_MSG_HIGH_1( "ACQ_STT DONE -> MORE_PREF, event=%d",event);

      rtrn_iact_ptr->act             = SDSS_IACT_ACQUIRE;
      rtrn_iact_ptr->prm.acq.list    = acq_ptr->pref_lst;
      rtrn_iact_ptr->prm.acq.pos     = acq_ptr->pref_pos;
      rtrn_iact_ptr->prm.acq.mode    = SDSS_ACQ_MODE_FULL;

      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_ACQ_STT_REACQ:
      SD_MSG_HIGH_1( "ACQ_STT DONE -> REACQ, event=%d",event);

        rtrn_iact_ptr->act           = SDSS_IACT_ACQUIRE;
        rtrn_iact_ptr->prm.acq.list  = acq_ptr->start_sys;
        rtrn_iact_ptr->prm.acq.pos   = 0;
        rtrn_iact_ptr->prm.acq.mode  = SDSS_ACQ_MODE_FULL;

        SD_MSG_HIGH_0( "Attempt reacquire candidate system");
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_ACQ_STT_DONE:
    case SDSS_ACQ_STT_REACQ_GWL:
    case SDSS_ACQ_STT_REACQ_FULL_SRV:
    case SDSS_ACQ_STT_PWR_SAVE_ENTER:
    case SDSS_ACQ_STT_PWR_SAVE:
    case SDSS_ACQ_STT_SCAN_CONT:
    case SDSS_ACQ_STT_MAX:
    case SDSS_ACQ_STT_NONE:
    default:
      SD_ERR_0( "state");
      break;

  } /* switch */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return list_is_exhausted;

} /* sdss_acq_done_event_proc *//*lint +esym(715, roam_pref) */
                                /*lint +esym(529, ss) */
                                /*lint +esym(550, ss) */
#ifdef FEATURE_EOOS_UMTS
/*===========================================================================

FUNCTION sdss_acq_pwr_save_enter_event_proc

DESCRIPTION
  Process SS-Event in the context of an SDSS_ACQ_STT_START state and instruct
  the caller of the next SS-Internal-Action to take.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the entire list that is currently being associated with the
  acquisition state machine is exhausted. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean                 sdss_acq_pwr_save_enter_event_proc(

        sdss_acq_s_type         *acq_ptr,
            /* Pointer an acquisition state machine to process the SS-Event.
            */

        dword                   *scr_timer_ptr,
            /* Script timer
            */

        sdss_evt_e_type         event,
            /* SS-Event to process.
            */

        sdss_iact_s_type        *rtrn_iact_ptr
            /* Pointer to a buffer where to place returned internal action.
            */
)
{

  boolean           list_is_exhausted = FALSE;
  uint32 uptime = time_get_uptime_secs();

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( acq_ptr != NULL );
  SD_ASSERT( scr_timer_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( event, SDSS_EVT_MAX );
  SD_ASSERT( rtrn_iact_ptr != NULL );

  if( event == SDSS_EVT_MISC_PWR_SAVE_ENTER )
  {

    sdss_get_eoos_sleep_time (scr_timer_ptr, SDSSSCR_CONT_RAT_GW_SLEEP_TYPE, acq_ptr->ss);
    SD_MSG_HIGH_1( "EOOS GW : power save for %ds", *scr_timer_ptr);
    *scr_timer_ptr += uptime;

    acq_ptr->state = SDSS_ACQ_STT_PWR_SAVE;
    rtrn_iact_ptr->act = SDSS_IACT_CONTINUE;
    return list_is_exhausted;
    /*lint -e527 */
  }

  /* If SS-Event is a user or miscellaneous event, instruct the SS-Client to
  ** continue.
  **
  ** Note that user or miscellaneous events that require a change of policy
  ** are not expected to get here as they cause a new script to be activated.
  */
  if( SDSS_EVT_IS_USER(event) ||
      SDSS_EVT_IS_HYBR_2_USER(event) ||
      SDSS_EVT_IS_HYBR_3_USER(event) ||
      SDSS_EVT_IS_MISC(event) )
  {
    rtrn_iact_ptr->act = SDSS_IACT_CONTINUE;
    SD_MSG_HIGH_1( "Ignoring event=%d",event);

    return list_is_exhausted;
  }
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return list_is_exhausted;

} /* sdss_acq_pwr_save_enter_event_proc */


/*===========================================================================

FUNCTION sdss_acq_pwr_save_timeout_event_proc

DESCRIPTION
  Process SS-Event in the context of an SDSS_ACQ_STT_PWR_SAVE state and instruct
  the caller of the next SS-Internal-Action to take.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the entire list that is currently being associated with the
  acquisition state machine is exhausted. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean                 sdss_acq_pwr_save_timeout_event_proc(

        sdss_acq_s_type         *acq_ptr,
            /* Pointer an acquisition state machine to process the SS-Event.
            */

        dword                   *scr_timer,
            /* Script timer
            */

        sdss_evt_e_type         event,
            /* SS-Event to process.
            */

        sdss_iact_s_type        *rtrn_iact_ptr
            /* Pointer to a buffer where to place returned internal action.
            */
)
{

  boolean           list_is_exhausted = FALSE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( acq_ptr != NULL );
  SD_ASSERT( scr_timer != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( event, SDSS_EVT_MAX );
  SD_ASSERT( rtrn_iact_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/



  if( event == SDSS_EVT_MISC_TIMER_RESEL_OK ||
      event == SDSS_EVT_MISC_TIMER_RESEL_NO )
  {
    acq_ptr->state                = SDSS_ACQ_STT_START;
    rtrn_iact_ptr->act            = SDSS_IACT_ACQUIRE;
    rtrn_iact_ptr->prm.acq.list   = acq_ptr->acq_lst;
    rtrn_iact_ptr->prm.acq.pos    = acq_ptr->acq_pos;
    rtrn_iact_ptr->prm.acq.mode   = acq_ptr->acq_mode;
    *scr_timer = 0;
     return list_is_exhausted;
  }

  /* If SS-Event is a user or miscellaneous event, instruct the SS-Client to
  ** continue.
  **
  ** Note that user or miscellaneous events that require a change of policy
  ** are not expected to get here as they cause a new script to be activated.
  */
  if( SDSS_EVT_IS_USER(event) ||
      SDSS_EVT_IS_HYBR_2_USER(event) ||
      SDSS_EVT_IS_HYBR_3_USER(event) ||
      SDSS_EVT_IS_MISC(event) )
  {
    rtrn_iact_ptr->act = SDSS_IACT_CONTINUE;
    SD_MSG_HIGH_1( "Ignoring event=%d",event);

    return list_is_exhausted;
  }
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return list_is_exhausted;

} /* sdss_acq_pwr_save_timeout_event_proc */

#endif

/*===========================================================================

FUNCTION sdss_acq_event_proc

DESCRIPTION
  Process SS-Event in the context of an acquisition state machine and
  instruct the caller of the next SS-Internal-Action to take.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the entire list that is currently being associated with the
  acquisition state machine is exhausted. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean                 sdss_acq_event_proc(

        sdss_acq_s_type         *acq_ptr,
            /* Pointer an acquisition state machine to process the SS-Event.
            */

        dword                   *scr_timer_ptr,
            /* Script timer
            */

        sdss_acq_mode_e_type    acq_mode,
            /* Acq mode for avoided system
            */

        sdss_evt_e_type         event,
            /* SS-Event to process.
            */

        sd_ss_mode_pref_e_type  mode_pref,
            /* Current mode preference.
            */

        sd_ss_band_pref_e_type  band_pref,
            /* Current 3G band preference.
            */

        sys_lte_band_mask_e_type  lte_band_pref,
             /* LTE band preference */

        sd_ss_band_pref_e_type  tds_band_pref,
             /* TD-SCDMA band preference */

        sd_ss_roam_pref_e_type  roam_pref,
            /* Current roam preference.
            */

        sdss_iact_s_type        *rtrn_iact_ptr
            /* Pointer to a buffer where to place returned internal action.
            */
)
{
  /*lint -esym(715, roam_pref, scr_timer_ptr) */ /* not referenced */
  /*lint -esym(818, scr_timer_ptr) */ /* Could be declared as pointing to const
                                      */

  sdss_acq_stt_e_type   acq_state;
  boolean               list_is_exhausted = FALSE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( acq_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( event, SDSS_EVT_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( mode_pref, SD_SS_MODE_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( band_pref, SD_SS_BAND_PREF_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( roam_pref, SD_SS_ROAM_PREF_MAX );
  SD_ASSERT( rtrn_iact_ptr != NULL );
  SD_ASSERT( scr_timer_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  acq_state = acq_ptr->state;
  if( acq_ptr->state == SDSS_ACQ_STT_SUSPEND )
  {
    acq_ptr->state = acq_ptr->prev_state;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If this is the first time this function is being called for this
  ** acquisition construct, select the first system to be attempted
  ** acquisition.
  */
  if( acq_ptr->acq_pos  == SDSR_POS_NULL &&
      acq_ptr->sched_pos == SDSR_POS_NULL )
  {
    /* Set the acquisition starting position.
    */
    acq_ptr->acq_pos = acq_ptr->acq_start_pos - 1;

    /* Get the next system to be attempted acquisition. If acquisition
    ** type is SPECIFIC, get next system regardless of the current mode and
    ** band preference. Else, get the next system that complies with the
    ** current mode and band preference.
    */
    list_is_exhausted = sdss_acq_next( acq_ptr,
                                       acq_mode,
                                       mode_pref,
                                       band_pref,
                                       lte_band_pref,
                                       tds_band_pref,
                                       rtrn_iact_ptr );

    return list_is_exhausted;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If we got here, this is not the first time this function is being called
  ** for this acquisition construct, so do processing in accordance with the
  ** acquisition state, type and SS-Event.
  */
  switch( acq_ptr->state )
  {
    case SDSS_ACQ_STT_START:

      list_is_exhausted = sdss_acq_start_event_proc( acq_ptr,
                                                     acq_mode,
                                                     scr_timer_ptr,
                                                     event,
                                                     mode_pref,
                                                     band_pref,
                                                     lte_band_pref,
                                                     tds_band_pref,
                                                     roam_pref,
                                                     rtrn_iact_ptr );
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_ACQ_STT_MORE_PREF:

      list_is_exhausted = sdss_acq_more_pref_event_proc( acq_ptr,
                                                         acq_mode,
                                                         event,
                                                         mode_pref,
                                                         band_pref,
                                                         lte_band_pref,
                                                         tds_band_pref,
                                                         roam_pref,
                                                         rtrn_iact_ptr );
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_ACQ_STT_REACQ:

      list_is_exhausted = sdss_acq_reacq_event_proc( acq_ptr,
                                                     acq_mode,
                                                     event,
                                                     mode_pref,
                                                     band_pref,
                                                     lte_band_pref,
                                                     tds_band_pref,
                                                     roam_pref,
                                                     rtrn_iact_ptr );
      break;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  case SDSS_ACQ_STT_REACQ_GWL:

    list_is_exhausted = sdss_acq_reacq_gwl_event_proc( acq_ptr,
                                                   acq_mode,
                                                   event,
                                                   mode_pref,
                                                   band_pref,
                                                   lte_band_pref,
                                                   tds_band_pref,
                                                   roam_pref,
                                                   rtrn_iact_ptr );
    break;
     /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_ACQ_STT_REACQ_FULL_SRV:

      list_is_exhausted = sdss_acq_reacq_full_srv_event_proc( acq_ptr,
                                                      acq_mode,
                                                      event,
                                                      mode_pref,
                                                      band_pref,
                                                      lte_band_pref,
                                                      tds_band_pref,
                                                      roam_pref,
                                                      rtrn_iact_ptr );
       break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_ACQ_STT_DONE:

      list_is_exhausted = sdss_acq_done_event_proc( acq_ptr,
                                                    acq_mode,
                                                    event,
                                                    mode_pref,
                                                    band_pref,
                                                    lte_band_pref,
                                                    tds_band_pref,
                                                    roam_pref,
                                                    rtrn_iact_ptr );
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    #ifdef FEATURE_EOOS_UMTS
    case SDSS_ACQ_STT_PWR_SAVE_ENTER:

      list_is_exhausted = sdss_acq_pwr_save_enter_event_proc( acq_ptr,
                                                              scr_timer_ptr,
                                                              event,
                                                              rtrn_iact_ptr );
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    case SDSS_ACQ_STT_PWR_SAVE:

      list_is_exhausted = sdss_acq_pwr_save_timeout_event_proc( acq_ptr,
                                                                scr_timer_ptr,
                                                                event,
                                                                rtrn_iact_ptr );
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    #else

    case SDSS_ACQ_STT_PWR_SAVE:
    case SDSS_ACQ_STT_PWR_SAVE_ENTER:
      SD_ERR_0( "state");
      break;
    #endif

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_ACQ_STT_SUSPEND:
    case SDSS_ACQ_STT_SCAN_CONT:
    case SDSS_ACQ_STT_MAX:
    case SDSS_ACQ_STT_NONE:
    default:

      SD_ERR_0( "state");
      break;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_MSG_HIGH_3("sdss_acq_event_proc: acq_state=%d, acq_ptr->state=%d, prev_state=%d",
               acq_state, acq_ptr->state, acq_ptr->prev_state);

  /* If acquisition state was changed, remember the previous state.
  */
  if( acq_state != SDSS_ACQ_STT_SUSPEND )
  {
    if( acq_ptr->state != acq_state )
    {
      acq_ptr->prev_state = acq_state;
    }
  }
  else
  {
    if( sdss_acq_ltd_reg_opti(acq_ptr->ss) )
    {
      acq_ptr->state = SDSS_ACQ_STT_SUSPEND;
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If acquisition state is done, reset is_in_srv_lost_state
  */
  if(acq_ptr->state == SDSS_ACQ_STT_DONE)
  {
    sdss_reset_srv_lost_state(acq_ptr->ss);
    #ifdef FEATURE_MMODE_DYNAMIC_SV_OPERATION_SWITCH
    /* regenerate opr_switch_list */
    if( (sdss_is_sfmode_1x_sxlte(sdss_map_ss_to_as_id(acq_ptr->ss))) &&
        (acq_ptr->acq_type == SDSSSCR_ACQ_REG_BEST_PREF ||
         acq_ptr->acq_type == SDSSSCR_ACQ_BEST_PREF))
    {
      sdss_store_sv_opr_switch_lst(acq_ptr->ss);
    }
    #endif
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return list_is_exhausted;

} /* sdss_acq_event_proc */
 /*lint +esym(715, roam_pref, scr_timer_ptr) */
 /*lint +esym(818, scr_timer_ptr) */



/* <EJECT> */
/*===========================================================================
=============================================================================
=============================================================================
============================ SS-SCRIPT-ENGINE ===============================
=============================================================================
=============================================================================
===========================================================================*/


/* Function prototypes.
*/
static  boolean                       sdss_eng_stack_is_state(
        const sdss_eng_stack_s_type   *stack_ptr,
        sdss_acq_stt_e_type           acq_stt
);

static  boolean                       sdss_eng_stack_is_type(
        const sdss_eng_stack_s_type   *stack_ptr,
        sdssscr_acq_e_type            acq_type
);


/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/






/* <EJECT> */
/*===========================================================================

FUNCTION sdss_eng_init

DESCRIPTION
  Initializes a script engine with a particular script.

  NOTE! this function must be called before any other sdss_eng_xxx is called.

DEPENDENCIES
  sdss_init() must have already been called to initialize the SS-Core.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static  void                    sdss_eng_init(

        sdss_eng_s_type         *eng_ptr,
            /* Pointer to the script engine which to initialize with the
            ** SS-Script that is referenced by scr_ref.
            */

        sdss_s_type             *ss_ptr,
            /* Pointer to a System Selection information structure.
            */

        sdssscr_ref_type        scr_ref,
            /* Reference to an SS-Script with which to initialize the
            ** script-engine that is pointed to by eng_ptr.
            */

        sdss_evt_grp_e_type     event_group,
        int                     scr_tbl_idx
            /* The event group and script table index (for debugging).
            */
)
{
  sd_ss_e_type      ss                = SD_SS_MAIN;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( eng_ptr != NULL );
  SD_ASSERT( ss_ptr != NULL );
  SD_ASSERT( scr_ref != SDSSSCR_REF_NULL );
  SD_ASSERT_ENUM_IS_INRANGE( event_group, SDSS_EVT_GRP_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  #if ( defined(FEATURE_HDR_HYBRID))
  /* Work with HYBR system selection, if specified so.
  */
  if( ss_ptr == sdss_ptr(SD_SS_HYBR_1) )
  {
    ss = SD_SS_HYBR_1;
  }
  #endif /* FEATURE_HDR_HYBRID */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if(!sdss_is_featuremode(SYS_OVERALL_FEATURE_MODE_NORMAL))
  {
    if(ss_ptr == sdss_ptr(SD_SS_HYBR_2))
    {
      ss = SD_SS_HYBR_2;
    }
  }

  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  if(ss_ptr == sdss_ptr(SD_SS_HYBR_3))
  {
    ss = SD_SS_HYBR_3;
  }
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Set the ss to point at the associated system selection enum type
  */
  eng_ptr->ss             = ss;


  /* Set the ss_ptr to point at the associated system selection information
  ** structure.
  */
  eng_ptr->ss_ptr         = ss_ptr;


  /* Initialize the script-parser with the script that is referenced by
  ** scr_ref.
  */
  sdssscr_parser_init( &eng_ptr->parser,
                       scr_ref,
                       event_group,
                       scr_tbl_idx,
                       ss );

  /* Initialize the script-control, so that first script construct is going
  ** to be parsed when the script-engine is instructed to process an event.
  */
  eng_ptr->scr_ctrl.ctrl  = SDSS_SCR_CTRL_NEXT_CONS;


  /* Initialize acquisition mode to MINI.
  */
  eng_ptr->acq_mode       = SDSS_ACQ_MODE_MINI;


  /* Initialize script timer to disabled.
  */
  eng_ptr->scr_timer      = 0;


  /* Remember the script's event group and table index (for debugging).
  */
  eng_ptr->scr_evt_grp    = event_group;
  eng_ptr->scr_tbl_idx    = scr_tbl_idx;

  /* Initialize the Acq state machine to NONE.
  */
  eng_ptr->acq.state      = SDSS_ACQ_STT_NONE;

  /* Initialize the Acq type to SDSSSCR_ACQ_MAX.
  */
  eng_ptr->acq.acq_type   = SDSSSCR_ACQ_MAX;

} /* sdss_eng_init */



/* <EJECT> */
/*===========================================================================
=============================================================================
============== LIST MANIPULATOR SS-SCRIPT CONSTRUCTS FUNCTIONS ==============
=============================================================================
===========================================================================*/


/* <EJECT> */
/*===========================================================================
=============================================================================
=============== LIST OPERATOR SS-SCRIPT CONSTRUCTS FUNCTIONS ================
=============================================================================
===========================================================================*/


/*===========================================================================

FUNCTION sdss_eng_scr_con_meas

DESCRIPTION
  Implement the MEAS( LIST, MEAS_TYPE ) SS-Script Constructs.

  Request a measurement of type meas_type from Search for all the systems
  that are referenced by the system record list/item list.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static  void                    sdss_eng_scr_con_meas(

        sdss_eng_s_type         *eng_ptr,
            /* Pointer to the SS-script-engine that is associated with the
            ** SS-Script that is being executed.
            */

        sdss_evt_e_type         event,
            /* SS-Event coming from the SS-Front-end.
            *//*lint -esym(715, event) */ /* not referenced */

        sdss_iact_s_type        *rtrn_iact_ptr
            /* Pointer to a buffer where to place returned internal action.
            */
)
{

  /* List for which to get the channel strength measurement.
  */
  sdsr_e_type             list;

  /* The mode of the measurement to perform.
  */
  sdss_meas_mode_e_type   meas_mode;

  /* The type of the measurement to perform.
  */
  sd_ss_meas_type_e_type  meas_type;

  sd_ss_e_type            ss        = SD_SS_MAIN;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( eng_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( event, SDSS_EVT_MAX );
  SD_ASSERT( rtrn_iact_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  list      = ENG_LIST( eng_ptr->con_prm1 );
  meas_mode = (sdss_meas_mode_e_type) eng_ptr->con_prm2;
  meas_type = (sd_ss_meas_type_e_type) eng_ptr->con_prm3;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( list, SDSR_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( meas_mode, SDSS_MEAS_MODE_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( meas_type, SD_SS_MEAS_TYPE_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #if (defined(FEATURE_HDR_HYBRID))
  /* Work with HYBR_1 system selection, if specified so.
  */
  if( eng_ptr->ss_ptr == sdss_ptr(SD_SS_HYBR_1) )
  {
    ss = SD_SS_HYBR_1;
  }
  #endif /* FEATURE_HDR_HYBRID */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if(!sdss_is_featuremode(SYS_OVERALL_FEATURE_MODE_NORMAL))
  {
    if(eng_ptr->ss_ptr == sdss_ptr(SD_SS_HYBR_2))
    {
      ss = SD_SS_HYBR_2;
    }
  }

  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  if(eng_ptr->ss_ptr == sdss_ptr(SD_SS_HYBR_3))
  {
    ss = SD_SS_HYBR_3;
  }
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If this is the first time this function is being called for this script
  ** construct, submit the measurement request.
  */
  if( eng_ptr->scr_ctrl.ctrl == SDSS_SCR_CTRL_NEXT_CONS )
  {
    eng_ptr->scr_ctrl.ctrl = SDSS_SCR_CTRL_RTRN_ACT;

    rtrn_iact_ptr->act = SDSS_IACT_MEAS;
    rtrn_iact_ptr->prm.meas.mode = meas_mode;
    rtrn_iact_ptr->prm.meas.type = meas_type;
    rtrn_iact_ptr->prm.meas.list = list;

    return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If we got here, this is not the first time this function is being called
  ** for this script construct. If the get networks request is done, continue
  ** with the next script construct. Else, stay and wait for the get networks
  ** results.
  */
  if( sd_ss_meas_is_done(ss) )
  {
    eng_ptr->scr_ctrl.ctrl  = SDSS_SCR_CTRL_NEXT_CONS;
  }
  else
  {
    SD_MSG_HIGH_1( "Ignoring event=%d",event);
    eng_ptr->scr_ctrl.ctrl  = SDSS_SCR_CTRL_RTRN_ACT;
    rtrn_iact_ptr->act      = SDSS_IACT_CONTINUE;
  }

} /* sdss_eng_scr_con_meas */ /*lint +esym(715, event) */

#if defined(SD_GSM_SUPPORTED) || defined(SD_WCDMA_SUPPORTED)
/*===========================================================================

FUNCTION sdss_get_net

DESCRIPTION
  Request to get the available GSM/WCDMA/TDS networks according to the reference
  list.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static  sdss_scr_ctrl_e_type    sdss_get_net(

        sd_ss_e_type            ss,
            /* System selection stack.
            */

        sdss_acq_mode_e_type    acq_mode,
            /* Acq mode for avoided system
            */

        sdss_iact_s_type        *rtrn_iact_ptr,
            /* Pointer to a buffer where to place returned internal action.
            */

        sdss_evt_e_type         event
            /* SS-Event coming from the SS-Front-end.
            */
)
{
  sdsr_s_type                   *sr_ptr;
  int                           list_pos;
  sdss_s_type                   *ss_ptr = sdss_ptr( ss );

  sd_ss_mode_pref_e_type        ss_mode_pref = SD_SS_MODE_PREF_NONE;
  sd_ss_band_pref_e_type        ss_band_pref = SD_SS_BAND_PREF_MAX;
  sys_lte_band_mask_e_type      ss_band_pref_lte = SYS_LTE_BAND_MASK_CONST_ANY;
  sd_ss_band_pref_e_type        ss_band_pref_tds = SD_SS_BAND_PREF_MAX;


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( rtrn_iact_ptr != NULL );

  sdss_get_network_pref_read( ss,
                              &ss_mode_pref,
                              &ss_band_pref,
                              &ss_band_pref_lte,
                              &ss_band_pref_tds );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Get the first complied system record from the list.
  */
  list_pos = sdss_sr_list_find_next( ss,
                                     SDSSSCR_CON_GET_NET,
                                     acq_mode,
                                     ss_ptr->get_net_list,
                                     ss_ptr->get_net_list_start_pos,
                                     0,
                                     -10000,
                                     ss_mode_pref,
                                     ss_band_pref,
                                     ss_band_pref_lte,
                                     ss_band_pref_tds,
                                     SDSR_CAT_ALL);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If no system on the specified list complies with current mode and
  ** band preference, indicate the GET_NET done and move to next
  ** construct.
  */
  if( list_pos == SDSR_POS_NULL )
  {
    SD_MSG_HIGH_0( "User list done!");

    /* Indicate get network list request done.
    */
    sd_ss_update_get_net_done( ss, TRUE );

    /* Move to next construct.
    */
    return SDSS_SCR_CTRL_NEXT_CONS;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Populate the request with bands and modes filtered within target
  ** capability, system record, band and mode preference.
  */
  sr_ptr = sdsr_list_get_ptr( ss_ptr->get_net_list, list_pos );
  if(sr_ptr == NULL)
  {
    sys_err_fatal_null_ptr_exception();
  }
  rtrn_iact_ptr->prm.get_net.sdsr_ref = sdsr_list_get_ref(
                                                  ss_ptr->get_net_list,
                                                  list_pos );

  rtrn_iact_ptr->prm.get_net.mode_pref =
                            sdss_map_mode_to_mode_pref(sr_ptr->sys.mode);

  if(event == SDSS_EVT_USER_GET_NET_GW || event == SDSS_EVT_HYBR_2_USER_GET_NET_GW
    || event == SDSS_EVT_HYBR_3_USER_GET_NET_GW)
  {
    rtrn_iact_ptr->prm.get_net.band_pref = SD_SS_BAND_PREF_ANY;

    rtrn_iact_ptr->prm.get_net.lte_band_pref = sdsr_map_lte_band_pref_to_sys_rec_lte_band(SYS_LTE_BAND_MASK_CONST_ANY);

    rtrn_iact_ptr->prm.get_net.tds_band_pref = SD_SS_BAND_PREF_TDS_ANY;
  }
  else
  {
    rtrn_iact_ptr->prm.get_net.band_pref = sr_ptr->sys.band;

    rtrn_iact_ptr->prm.get_net.lte_band_pref = sr_ptr->sys.lte_band;

    rtrn_iact_ptr->prm.get_net.tds_band_pref = sr_ptr->sys.tds_band;
  }

  rtrn_iact_ptr->prm.get_net.acq_order_pref = sdss_get_acq_order_pref(ss);

  /* Indicate get network list request is pending.
  */
  sd_ss_update_get_net_done( ss, FALSE );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Store the list position of current get network list request and
  ** point to next position.
  */
  ss_ptr->get_net_list_pos = list_pos;
  ss_ptr->get_net_list_start_pos = list_pos + 1;

  /* Return action: SDSS_IACT_GET_NET_GWL
  */
  rtrn_iact_ptr->act = SDSS_IACT_GET_NET_GWL;

  return SDSS_SCR_CTRL_RTRN_ACT;

}/* sdss_get_net */

/*===========================================================================

FUNCTION sdss_get_wl_rlf_info

DESCRIPTION
  Implement the get_wl_rlf_info.

DEPENDENCIES
  None.

RETURN VALUE
  boolean.

SIDE EFFECTS
  None.

===========================================================================*/
  boolean                    sdss_is_manual_search_supported_in_wrlf(sd_ss_e_type ss)
  {
    sdss_s_type         *ss_ptr =  sdss_ptr(ss);
    return ss_ptr->manual_search_in_wrlf ;
  }


/*===========================================================================

FUNCTION sdss_eng_scr_con_get_net

DESCRIPTION
  Implement the GET_NET( ) SS-Script Constructs.

  Request to get the available GSM/WCDMA networks.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static  void                    sdss_eng_scr_con_get_net(

        sd_ss_e_type            ss,
            /* System selection stack
            */

        sdss_eng_s_type         *eng_ptr,
            /* Pointer to the SS-script-engine that is associated with the
            ** SS-Script that is being executed.
            */

        sdss_evt_e_type         event,
            /* SS-Event coming from the SS-Front-end.
            */

        sdss_iact_s_type        *rtrn_iact_ptr
            /* Pointer to a buffer where to place returned internal action.
            */
)
{
  sdsr_e_type        list      = SDSR_MAX;
  sdsr_e_type        ref_sys   =  SDSR_MAX;
  sdss_s_type        *ss_ptr    = NULL;


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( eng_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( event, SDSS_EVT_MAX );
  SD_ASSERT( rtrn_iact_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  list      = ENG_LIST( eng_ptr->con_prm1 );
  ref_sys   = ENG_LIST( eng_ptr->con_prm2 );
  ss_ptr    = eng_ptr->ss_ptr;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If this is the first time this function is being called for this script
  ** construct and event is SDSS_EVT_USER_GET_NET_GW,
  ** send get network list request according to the first system in the get
  ** network search list. Pointer list_pos to the next position of the system
  ** in the get network search list.
  */
  if( eng_ptr->scr_ctrl.ctrl == SDSS_SCR_CTRL_NEXT_CONS &&
      ( event == SDSS_EVT_USER_GET_NET_GW ||
        event == SDSS_EVT_HYBR_2_USER_GET_NET_GW ||
        event == SDSS_EVT_HYBR_3_USER_GET_NET_GW))
  {
    ss_ptr->get_net_list = list;
    ss_ptr->get_net_list_start_pos = 0;

    eng_ptr->scr_ctrl.ctrl = sdss_get_net(ss, eng_ptr->acq_mode,
                                          rtrn_iact_ptr, event);

    return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If event is SDSS_EVT_MISC_GW_NET_LIST
  **
  ** 1.If get network list request is being serviced by Search, put the last
  ** system which recievied the gw network list report into the ref_sys and
  ** continue with the next script construct.
  **
  ** 2.Otherwise, request one more get network list until the search list is
  **   exhaused.
  **
  */
  if( event == SDSS_EVT_MISC_GW_NET_LIST )
  {

    SD_MSG_HIGH_3(" is_get_net_done = %d ss_ptr->plmn_list_status = %d, ss_ptr->get_net_list_pos=%d",
                  sd_ss_is_get_net_done(ss), ss_ptr->plmn_list_status, ss_ptr->get_net_list_pos );

    if( sd_ss_is_get_net_done(ss) )
    {

      sdsr_list_put_ref( ref_sys,
                         sdsr_list_get_ref( ss_ptr->get_net_list,
                                            ss_ptr->get_net_list_pos));

      if (ss_ptr->plmn_list_status == SYS_PLMN_LIST_PARTIAL)
      {
        eng_ptr->scr_ctrl.ctrl  = SDSS_SCR_CTRL_RTRN_ACT;
        rtrn_iact_ptr->act      = SDSS_IACT_CONTINUE;
      }
      else
      {
      eng_ptr->scr_ctrl.ctrl  = SDSS_SCR_CTRL_NEXT_CONS;
      }
      SD_MSG_HIGH_0("Returned: as get net is done");
      return;
    }

    if (ss_ptr->plmn_list_status != SYS_PLMN_LIST_PARTIAL)
    {
    eng_ptr->scr_ctrl.ctrl = sdss_get_net(ss, eng_ptr->acq_mode,
                                          rtrn_iact_ptr, event);
    }
    SD_MSG_HIGH_0("Returned: SDSS_EVT_MISC_GW_NET_LIST is done");
    return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* For all other events, continue with the next construct only if the get
  ** network list is complete.
  */

  if( sd_ss_is_get_net_done(ss) && \
          ss_ptr->plmn_list_status != SYS_PLMN_LIST_PARTIAL)
  {
    eng_ptr->scr_ctrl.ctrl  = SDSS_SCR_CTRL_NEXT_CONS;
  }
  else
  {
    SD_MSG_HIGH_1( "Ignoring event=%d",event);
    eng_ptr->scr_ctrl.ctrl  = SDSS_SCR_CTRL_RTRN_ACT;
    rtrn_iact_ptr->act      = SDSS_IACT_CONTINUE;
  }
  return;

} /* sdss_eng_scr_con_get_net */
#endif /* (SD_GSM_SUPPORTED) || (SD_WCDMA_SUPPORTED)  */

/*===========================================================================

FUNCTION sdss_eng_scr_con_acq

DESCRIPTION
  Implement the following acquisition SS-Script Constructs:

  ACQ( LIST, ACQ_TYPE )
    Step through the system record list/item LIST (first to last) and try to
    acquire a system that are referenced by LIST in accordance with ACQ_TYPE
    and the current SS-Preference.

  ACQ_ALL( LIST, ACQ_TYPE )
    Equivalent to the ACQ construct except that also systems that were
    already attempted acquisition since the last time the NEW_ACQ construct
    was encountered are being attempted acquisition.

  ACQ_CNT( LIST, ACQ_TYPE, START_POS, CNT )
    Equivalent to the ACQ construct except that LIST is traversed START_POS
    to START_POS-1 and acquisition is bounded to CNT elements.

  ACQ_TIME( LIST, ACQ_TYPE, START_POS, TIME )
    Equivalent to the ACQ construct except that LIST is traversed START_POS
    to START_POS-1 and acquisition is bounded to TIME seconds since the
    START_TIME script constructs was last encountered.

  ACQ_RX( LIST, ACQ_TYPE, RX )
    Equivalent to he ACQ construct except that only systems with Rx-power
    measurement value >= RX are being attempted acquisition.

  ACQ_PI( LIST, ACQ_TYPE, PI )
    Equivalent to the ACQ construct except that only systems with pilot
    measurement value >= PI are being attempted acquisition.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static  void                    sdss_eng_scr_con_acq(

        sdss_eng_s_type         *eng_ptr,
            /* Pointer to the SS-script-engine that is associated with the
            ** SS-Script that is being executed.
            */

        sdss_evt_e_type         event,
            /* SS-Event coming back from the SS-Front-end.
            */

        sdss_iact_s_type        *rtrn_iact_ptr
            /* Pointer to a buffer where to place returned internal action.
            */
)
{

  /* System record list over which to attempt acquisition.
  */
  sdsr_e_type           list;

  /* Acquisition type to be attempted.
  */
  sdssscr_acq_e_type    acq_type;

  boolean               list_is_exhausted;
  sdss_s_type           *ss_ptr;
  byte                  new_acq_cnt;
  int2                  meas_val      = -1000;
  int                   start_pos     = 0;
  int                   max_num       = 1000;
  dword                 max_uptime    = (dword) (-1);
  sdsr_cat_e_type       meas_cat      = SDSR_CAT_ALL;
  sd_ss_mode_pref_e_type   mode_pref;
  sd_ss_mode_pref_e_type   temp_mode_pref;
  #ifdef FEATURE_EOOS
  #error code not present
#endif

  sd_ss_band_pref_e_type   ss_band_pref      = SD_SS_BAND_PREF_NONE;
  sys_lte_band_mask_e_type ss_lte_band_pref  = SYS_LTE_BAND_MASK_CONST_NONE;
  sd_ss_band_pref_e_type   ss_tds_band_pref  = SD_SS_BAND_PREF_NONE;
  #if defined(FEATURE_EOOS)
  #error code not present
#endif
  boolean                         is_emerg_call_orig = FALSE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( eng_ptr != NULL );
  SD_ASSERT( rtrn_iact_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( event, SDSS_EVT_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  list        = ENG_LIST( eng_ptr->con_prm1 );
  acq_type    = (sdssscr_acq_e_type) eng_ptr->con_prm2;
  ss_ptr      = eng_ptr->ss_ptr;
  new_acq_cnt = ss_ptr->new_acq_cnt;

  sdss_get_mode_band_pref( eng_ptr->ss,
                           &mode_pref,
                           &ss_band_pref,
                           &ss_lte_band_pref,
                           &ss_tds_band_pref );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( list, SDSR_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( acq_type, SDSSSCR_ACQ_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If calling for same as last acquisition type, get the last acquisition
  ** type attempted from the SS-Core.
  */
  if( acq_type == SDSSSCR_ACQ_SAME_AS_LAST )
  {
    acq_type = ss_ptr->acq_type;
    SD_ASSERT_ENUM_IS_INRANGE( acq_type, SDSSSCR_ACQ_SAME_AS_LAST );
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* If UE is in an emergency call origination or callback, set is_emerg_call_orig to TRUE
  */
  if( sdss_is_emergency_call_orig(eng_ptr->ss) )
  {
    is_emerg_call_orig = TRUE;
  }

  /* Do the following check only if UE is not in an emergency call origination
   ** If limited list/sys is used for acuqisition, avoid state -> limited_scan.
   ** if at least 1 3gpp system is found during the full scan cycle, then limited list/sys
   ** will be performed.
   ** Otherwise, skip the 3GPP limited list/sys scan.
   */


  #ifdef FEATURE_AVOID_DUP_BAND_SCAN


    if (!is_emerg_call_orig &&
        sdsr_is_ltd_list(list))
    {
      #ifdef FEATURE_LIMITED_SCAN_OPT
      if (sdss_get_is_3gpp_scan_attempted(eng_ptr->ss) == TRUE)
      {
        sdss_avoid_dup_scan_set_limited_scan(eng_ptr->ss);
      }
      else
      #endif
      {
        sdss_avoid_dup_scan_suspend(eng_ptr->ss);
      }

    }
    else
    {
      #ifdef FEATURE_LIMITED_SCAN_OPT
      sdss_avoid_dup_scan_reset_limited_scan(eng_ptr->ss);
      #endif
    }

    /* If manual list/sys is used for acuqisition, stop avoid_dup_band_scan
     ** legacy scan. Perform this check only if UE is not in an emergency call
     */

    if (!is_emerg_call_orig && sdsr_is_manual_list (list))
    {
    sdss_avoid_dup_scan_stop(eng_ptr->ss, FALSE);
    }

    /* If 3GPP TOT scan is attempted, update is_3gpp_scan_attempted to TRUE.
    */
    if (sdss_is_3gpp_tot_scan(eng_ptr->ss) == TRUE)
    {
      sdss_update_is_3gpp_scan_attempted(eng_ptr->ss, TRUE);
    }

    #ifdef FEATURE_MMODE_DYNAMIC_SV_OPERATION_SWITCH
    /* If this is HYBR-2, then also set to TRUE since it only scans 3GPP sys.
    */
    if(eng_ptr->ss == SD_SS_HYBR_2)
    {
      sdss_update_is_3gpp_scan_attempted(eng_ptr->ss, TRUE);
    }
    #endif /* FEATURE_MMODE_DYNAMIC_SV_OPERATION_SWITCH */
  
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If this is the first time this function is being called for this
  ** acquisition construct, initialize the acquisition state machine.
  */
  if( eng_ptr->scr_ctrl.ctrl == SDSS_SCR_CTRL_NEXT_CONS )
  {
    /* Based on the acquisition type that is being attempted, set the
    ** parameters with which systems that are being attempted acquisition
    ** should comply.
    */
    switch( eng_ptr->scr_con )
    {
      case SDSSSCR_CON_ACQ:
      case SDSSSCR_CON_ACQ_ALL:
         break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      case SDSSSCR_CON_ACQ_TRUE_MODE:
       /* Need to initialise the true_mode_pref based on the stack.
       ** Logic to initilaise true_mode_pref:
       ** If stack is MAIN, remove hybrid and WLAN mode preferences from true_mode_pref.
       ** If stack is HYBRID, remove MAIN and WLAN mode preferences from true_mode_pref.
       ** If stack is WLAN, remove hybrid and MAIN mode preferences from true_mode_pref.
       ** If stack is HYBR_2 remove hybrid and WLAN mode pref. from true mode pref.
       */
        mode_pref = sdss_get_true_mode_pref(eng_ptr->ss);

        if (eng_ptr->ss == SD_SS_MAIN)
        {
          #if ( defined( FEATURE_HDR_HYBRID ))
          /* Get HYBR mode pref */
          sdss_get_mode_band_pref( SD_SS_HYBR_1,
                                   &temp_mode_pref,
                                   NULL,
                                   NULL,
                                   NULL );

          /* Remove HYBR mode_pref from true mode pref */
          mode_pref = SD_MODE_DELETE( mode_pref, temp_mode_pref );
          #endif
        }

        if (eng_ptr->ss == SD_SS_HYBR_1)
        {
          /* Get MAIN mode pref */
          sdss_get_mode_band_pref( SD_SS_MAIN,
                                   &temp_mode_pref,
                                   NULL,
                                   NULL,
                                   NULL );

          /* Remove MAIN mode_pref from true mode pref */
          mode_pref = SD_MODE_DELETE( mode_pref, temp_mode_pref );
        }

        if(eng_ptr->ss == SD_SS_HYBR_2)
        {
          #if ( defined( FEATURE_HDR_HYBRID ))
          /* Get HYBR mode pref */
          sdss_get_mode_band_pref( SD_SS_HYBR_1,
                                   &temp_mode_pref,
                                   NULL,
                                   NULL,
                                   NULL );

          /* Remove HYBR mode_pref from true mode pref */
          mode_pref = SD_MODE_DELETE( mode_pref, temp_mode_pref );
          #endif
        }

        #if defined(FEATURE_EOOS)
        #error code not present
#endif
        break;


      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_ACQ_CNT:
      case SDSSSCR_CON_ACQ_AVOID_CNT:
      case SDSSSCR_CON_ACQ_ABSR_CNT:

      start_pos   = sdss_sr_list_find_acq_start_pos( ss_ptr,
                                                       list,
                                                       (uint16) TO_WORD(eng_ptr->con_prm3,eng_ptr->con_prm4));
        max_num     = (uint16) TO_WORD(eng_ptr->con_prm5,eng_ptr->con_prm6);
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_ACQ_TIME:
        start_pos   = sdss_sr_list_find_acq_start_pos( ss_ptr,
                                                       list,
                                                        (uint16) TO_WORD(eng_ptr->con_prm3,eng_ptr->con_prm4) );
        max_uptime  = ss_ptr->acq_start_time + eng_ptr->con_prm5;
        break;
      #ifdef FEATURE_EOOS
      #error code not present
#endif
      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_ACQ_RX:
        meas_val    = - (int2) ((uint2) (eng_ptr->con_prm3));
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_ACQ_PI:
        meas_val    = - (int2) ((uint2) (eng_ptr->con_prm3));
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      case SDSSSCR_CON_ACQ_PI_X:
        meas_cat = (sdsr_cat_e_type)(eng_ptr->con_prm4);
        meas_val    = - (int2) ((uint2) (eng_ptr->con_prm3));
        break;

      case SDSSSCR_CON_ACQ_NETLIST:
        meas_val    = (int2) (eng_ptr->con_prm3);
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      default:
        SD_ERR_0( "scr_con");
        break;

    } /* switch */

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    sdss_acq_init( &eng_ptr->acq,
                   eng_ptr->ss_ptr,
                   list,
                   start_pos,
                   max_num,
                   max_uptime,
                   eng_ptr->scr_con,
                   acq_type,
                   eng_ptr->acq_mode,
                   new_acq_cnt,
                   meas_val,
                   meas_cat);

    /* Update the acquisition type of the SS-Core per the acquisition type
    ** parameter.
    */
    sdss_acq_type_update( eng_ptr->ss_ptr, acq_type );
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Check if pwr_save_enter pertains to throttle engine.
  */
  if ( event == SDSS_EVT_MISC_PWR_SAVE_ENTER &&
       ( sdss_thrttl_enter_pwr_save( &eng_ptr->ss_ptr->acq_thrttl,
                                    &eng_ptr->scr_timer,
                                    rtrn_iact_ptr
                                   ) == SDSS_THRTTL_EVT_STATUS_CONSUMED
       )

     )
  {
    /* Throttle in progress.
    */
    eng_ptr->scr_ctrl.ctrl = SDSS_SCR_CTRL_RTRN_ACT;
    return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Check if timeout pertains to throttle engine.
  */
  if ( (event == SDSS_EVT_MISC_TIMER_RESEL_OK ||
        event == SDSS_EVT_MISC_TIMER_RESEL_NO ) &&
        (sdss_thrttl_pwr_save_timeout( &eng_ptr->ss_ptr->acq_thrttl,
                                       &eng_ptr->scr_timer,
                                       rtrn_iact_ptr
                                     ) == SDSS_THRTTL_EVT_STATUS_CONSUMED
        )
     )
  {
    /* Throttle in progress.
    */
    eng_ptr->scr_ctrl.ctrl = SDSS_SCR_CTRL_RTRN_ACT;
    return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Check if it is the ACQ event is for acquisition action issued from
  ** the same engine. It is possible because of PREV_SCR, the acq event
  ** circulates to a different engine where it should not be processed.
  ** Note eng_ptr->acq.rtrn_iact.act == SDSS_IACT_ACQUIRE indicates
  ** new script engine was pushed when ACQ action was pending.
  */
  if ( SDSS_EVT_IS_XXX_ACQ(event) &&
       eng_ptr->acq.rtrn_iact.act == SDSS_IACT_ACQUIRE &&
       ss_ptr->last_acq_eng_ptr != eng_ptr
     )
  {
    /* Incorrect acq. event, re issue the acq action from current engine.
    */
    SD_MSG_HIGH_0("Re-issuing acquire action");
    *rtrn_iact_ptr = eng_ptr->acq.rtrn_iact;

    /* If the system used in the pending ACQ is not there anymore when we
     * get back to it, then assume all systems in the acq list failed
     * acquisition.
     *
     * Examples of when this could happen:
     *
     * 1. The scripts that were pushed on top of this script had modified the
     *    list used for acquisition.
     * 2. The scripts that were pushed on top of this script completed
     *    processing the SCHED_LST (due to another ACQ construct) that was
     *    being processed by this script when it was interrupted.
    */
    if( sdsr_list_get_ref( rtrn_iact_ptr->prm.acq.list,
                           rtrn_iact_ptr->prm.acq.pos ) == SDSR_REF_NULL )
    {
      /* If the pending ACQ was from the SCHED_LST, then see if we can
      ** proceed with the list used in the ACQ construct.
      */
      if( rtrn_iact_ptr->prm.acq.list == eng_ptr->acq.sched_lst )
      {
        eng_ptr->acq.sched_pos = SDSR_POS_NULL;
      }

      /* Check if there are more systems in the list. */
      list_is_exhausted  =  sdss_acq_event_proc( &eng_ptr->acq,
                                                 &eng_ptr->scr_timer,
                                                 eng_ptr->acq_mode,
                                                 event,
                                                 mode_pref,
                                                 ss_band_pref,
                                                 ss_lte_band_pref,
                                                 ss_tds_band_pref,
                                                 ss_ptr->roam_pref,
                                                 rtrn_iact_ptr );

      /* This check makes sure we don't consider an empty SCHED_LST as an
      ** error. The SCHED_LST was simply taken care of by an ACQ in a
      ** different script.
      */
      if( sdsr_list_get_ref( eng_ptr->acq.acq_lst,
                             eng_ptr->acq.acq_pos ) == SDSR_REF_NULL )
      {
        SD_ERR_1("ERROR! Multiple scripts accessing list %d !",
                                              eng_ptr->acq.acq_lst);
      }
    }
    else if (sdss_sr_list_is_skipped_system_common_causes( rtrn_iact_ptr->prm.acq.list,
                                                       rtrn_iact_ptr->prm.acq.pos,
                                                       eng_ptr->ss,
                                                       0,
                                                       0,
                                                       SDSR_CAT_NON_COMPLY,
                                                       mode_pref,
                                                       ss_band_pref,
                                                       ss_lte_band_pref,
                                                       ss_tds_band_pref,
                            sdsr_list_get_ptr( rtrn_iact_ptr->prm.acq.list,
                                                       rtrn_iact_ptr->prm.acq.pos ),
                                                       NULL ))
    {
      /* Check if there are more systems in the list
      ** with updated preferences
      */
      list_is_exhausted  =  sdss_acq_event_proc( &eng_ptr->acq,
                                                   &eng_ptr->scr_timer,
                                                   eng_ptr->acq_mode,
                                                   event,
                                                   mode_pref,
                                                   ss_band_pref,
                                                   ss_lte_band_pref,
                                                   ss_tds_band_pref,
                                                   ss_ptr->roam_pref,
                                                   rtrn_iact_ptr );
    }
    else
    {
      list_is_exhausted = FALSE;
    }
  }
  else
  {
    /* Call on the acquisition state machine to do acquisition processing.
    */
    list_is_exhausted  =  sdss_acq_event_proc( &eng_ptr->acq,
                                               &eng_ptr->scr_timer,
                                               eng_ptr->acq_mode,
                                               event,
                                               mode_pref,
                                               ss_band_pref,
                                               ss_lte_band_pref,
                                               ss_tds_band_pref,
                                               ss_ptr->roam_pref,
                                               rtrn_iact_ptr );
  }


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If the acquisition list is exhausted, continue with next script
  ** construct. Else, return with the acquisition action to the SS-Client.
  */
  if( list_is_exhausted )
  {
    SD_MSG_HIGH_1( "List=%d is exhausted!",list);
    eng_ptr->acq.state = SDSS_ACQ_STT_NONE;
    eng_ptr->scr_ctrl.ctrl = SDSS_SCR_CTRL_NEXT_CONS;
  }
  else
  {
    SD_MSG_HIGH_3("Acq type=%d, prev_state=%d, new_state=%d",
                eng_ptr->acq.acq_type,
                eng_ptr->acq.prev_state,
                eng_ptr->acq.state );
    /* Save the rtrn act in acq state machine and return.
    */
    if ( rtrn_iact_ptr->act == SDSS_IACT_ACQUIRE )
    {
      eng_ptr->acq.rtrn_iact = *rtrn_iact_ptr;
      ss_ptr->last_acq_eng_ptr = eng_ptr;
    }

    /* Turn the service indicator to power save
    */
    if( rtrn_iact_ptr->act == SDSS_IACT_PWR_SAVE )
    {
      sd_si_srv_pwr_save( eng_ptr->parser.ss );
    }

    eng_ptr->scr_ctrl.ctrl = SDSS_SCR_CTRL_RTRN_ACT;
    sdss_thrttl_iact_acq( &eng_ptr->ss_ptr->acq_thrttl, rtrn_iact_ptr );
  }

} /* sdss_eng_scr_con_acq */




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_eng_scr_con_sched

DESCRIPTION
  Implement the following SS-Script Constructs:
  SCHED( LIST, SCHED, ACQ_TYPE )
  SCHED_COND( LIST, SCHED, ACQ_TYPE )

  Schedule the system records that are referenced by the system record list
  LIST to be attempted acquisition of type ACQ_TYPE at time points that are
  specified by the SCHED schedule.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static  void                    sdss_eng_scr_con_sched(

        sdss_eng_s_type         *eng_ptr,
            /* Pointer to the SS-script-engine that is associated with the
            ** SS-Script that is being executed.
            */

        sdsssr_sched_cond_e_type sched_cond,
            /* Indicate whether systems should be conditionally schedule
            ** depending whether they are not already on equal or higher
            ** priority reacquisition schedule.
            */

        const sdss_iact_s_type  *rtrn_iact_ptr
            /* Pointer to a buffer where to place returned internal action.
            *//*lint -esym(715, rtrn_iact_ptr) */ /* not referenced */
)
{
  /* System record list over which to attempt reacquisition.
  */
  sdsr_e_type           list;

  /* Schedule list.
  */
  sdsr_e_type           sched_list;

  /* Reacquisition schedule.
  */
  sdssscr_sched_e_type  sched;

  /* Acquisition type to be attempted.
  */
  sdssscr_acq_e_type    acq_type;

  sdss_acq_mode_e_type  acq_mode  = SDSS_ACQ_MODE_FULL;

  const sdss_s_type     *ss_ptr;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( eng_ptr != NULL );
  SD_ASSERT( rtrn_iact_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  list       = ENG_LIST( eng_ptr->con_prm1 );
  sched_list = ENG_LIST( SDSR_SCHED_LST );
  sched      = (sdssscr_sched_e_type) eng_ptr->con_prm2;
  acq_type   = (sdssscr_acq_e_type) eng_ptr->con_prm3;
  ss_ptr     = eng_ptr->ss_ptr;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( list, SDSR_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( acq_type, SDSSSCR_ACQ_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( sched, SDSSSCR_SCHED_REACQ_LAST );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If scheduling calling for same as last acquisition type, get the last
  ** acquisition type to be attempted from the SS-Core.
  */
  if( acq_type == SDSSSCR_ACQ_SAME_AS_LAST )
  {
    acq_type = ss_ptr->acq_type;
    SD_ASSERT_ENUM_IS_INRANGE( acq_type, SDSSSCR_ACQ_SAME_AS_LAST );
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Schedule the list for reacquisition attempts.
  */
  sdss_sr_list_sched( list,
                      sched_list,
                      sched,
                      acq_type,
                      acq_mode,
                      sched_cond );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Continue with next script construct.
  */
  eng_ptr->scr_ctrl.ctrl = SDSS_SCR_CTRL_NEXT_CONS;

} /* sdss_eng_scr_con_sched *//*lint +esym(715, rtrn_iact_ptr) */


/* <EJECT> */
/*===========================================================================
=============================================================================
================== CONTROL SS-SCRIPT CONSTRUCTS FUNCTIONS ===================
=============================================================================
===========================================================================*/


/*===========================================================================

FUNCTION sdss_eng_scr_con_proc_evt

DESCRIPTION
  Implement the PROC_EVT( SS_EVENT ) SS-Script Construct.

  Process the SS_EVENT SS-Event.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static  void                    sdss_eng_scr_con_proc_evt(

        sdss_eng_s_type         *eng_ptr,
            /* Pointer to the SS-script-engine that is associated with the
            ** SS-Script that is being executed.
            */

        const sdss_iact_s_type  *rtrn_iact_ptr
            /* Pointer to a buffer where to place returned internal action.
            *//*lint -esym(715, rtrn_iact_ptr) */ /* not referenced */
)
{
  /* SS-Event to process.
  */
  sdss_evt_e_type        event;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( eng_ptr != NULL );
  SD_ASSERT( rtrn_iact_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  event = sdss_event_map(eng_ptr->ss, (sdss_evt_e_type) eng_ptr->con_prm1);

  SD_ASSERT_ENUM_IS_INRANGE( event, SDSS_EVT_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If this is the first time this function is being called for this
  ** acquisition construct, process the specified SS-Event. Else (the
  ** activated script has returned control), continue with next script
  ** construct.
  */
  if( eng_ptr->scr_ctrl.ctrl == SDSS_SCR_CTRL_NEXT_CONS )
  {
    eng_ptr->scr_ctrl.ctrl            = SDSS_SCR_CTRL_PROC_EVT;
    eng_ptr->scr_ctrl.prm.proc.event  = event;
  }
  else
  {
    eng_ptr->scr_ctrl.ctrl            = SDSS_SCR_CTRL_NEXT_CONS;
  }

} /* sdss_eng_scr_con_proc_evt *//*lint +esym(715, rtrn_iact_ptr) */



/* <EJECT> */
/*===========================================================================

FUNCTION sdss_eng_scr_con_act_scr

DESCRIPTION
  Implement the ACT_SCR( SCRIPT ) SS-Script Construct.

  Make the script that is referenced SCRIPT the active SS-Script.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static  void                    sdss_eng_scr_con_act_scr(

        sdss_eng_s_type         *eng_ptr,
            /* Pointer to the SS-script-engine that is associated with the
            ** SS-Script that is being executed.
            */

        const sdss_iact_s_type  *rtrn_iact_ptr
            /* Pointer to a buffer where to place returned internal action.
            *//*lint -esym(715, rtrn_iact_ptr) */ /* not referenced */
)
{
  /* SS-Script which to activate.
  */
  sdssscr_e_type        script;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( eng_ptr != NULL );
  SD_ASSERT( rtrn_iact_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  script    = (sdssscr_e_type) eng_ptr->con_prm1;

  SD_ASSERT_ENUM_IS_INRANGE( script, SDSSSCR_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If this is the first time this function is being called for this
  ** acquisition construct, activate the specified SS-Script. Else (the
  ** activated script has returned control), continue with next script
  ** construct.
  */
  if( eng_ptr->scr_ctrl.ctrl == SDSS_SCR_CTRL_NEXT_CONS )
  {
    eng_ptr->scr_ctrl.ctrl            = SDSS_SCR_CTRL_ACT_SCR;
    eng_ptr->scr_ctrl.prm.act.script  = script;
  }
  else
  {
    eng_ptr->scr_ctrl.ctrl            = SDSS_SCR_CTRL_NEXT_CONS;
  }

} /* sdss_eng_scr_con_act_scr *//*lint +esym(715, rtrn_iact_ptr) */




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_eng_scr_con_act_meas

DESCRIPTION
  Implement the ACT_SCR_RX( SCRIPT, LIST, RX ) and
  ACT_SCR_PI( SCRIPT, LIST, PI ) SS-Script Constructs.

  Make SCRIPT the active System Selection Script iff at least one of the
  systems that are referenced by the system record list, LIST, has a channel
  strength measurement value >= MEAS.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static  void                    sdss_eng_scr_con_act_meas(

        sdss_eng_s_type         *eng_ptr,
            /* Pointer to the SS-script-engine that is associated with the
            ** SS-Script that is being executed.
            */

        const sdss_iact_s_type  *rtrn_iact_ptr
            /* Pointer to a buffer where to place returned internal action.
            *//*lint -esym(715, rtrn_iact_ptr) *//* not referenced */
)
{
  /* SS-Script which to activate.
  */
  sdssscr_e_type        script;

  /* System record list for which to check the channel strength measurements.
  */
  sdsr_e_type           list;

  int2                  meas_val;
  int                   list_pos;
  sd_ss_mode_pref_e_type     ss_mode_pref      = SD_SS_MODE_PREF_NONE;
  sd_ss_band_pref_e_type     ss_band_pref      = SD_SS_BAND_PREF_NONE;
  sys_lte_band_mask_e_type   ss_lte_band_pref  = SYS_LTE_BAND_MASK_CONST_NONE;
  sd_ss_band_pref_e_type     ss_tds_band_pref  = SD_SS_BAND_PREF_NONE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( eng_ptr != NULL );
  SD_ASSERT( rtrn_iact_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  script = (sdssscr_e_type) eng_ptr->con_prm1;
  list   = ENG_LIST( eng_ptr->con_prm2 );

  SD_ASSERT_ENUM_IS_INRANGE( script, SDSSSCR_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( list, SDSR_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If this is NOT the first time this function is being called for this
  ** acquisition construct (i.e., the activated script has returned control),
  ** continue with next script construct.
  */
  if( eng_ptr->scr_ctrl.ctrl != SDSS_SCR_CTRL_NEXT_CONS )
  {
    eng_ptr->scr_ctrl.ctrl = SDSS_SCR_CTRL_NEXT_CONS;

    return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If we got here, this is the first time this function is being called for
  ** this acquisition construct.
  */

  /* Based on the activation type, set the measurement against which to
  ** compare.
  */
  switch( eng_ptr->scr_con )
  {
    case SDSSSCR_CON_ACT_SCR_RX:
      meas_val = - (int2) ((uint2) (eng_ptr->con_prm3));
      break;

    case SDSSSCR_CON_ACT_SCR_PI:
      meas_val = - (int2) ((uint2) (eng_ptr->con_prm3));
      break;

    default:
      SD_ERR_0( "scr_con");
      meas_val = -1000;
      break;

  } /* switch */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  sdss_get_mode_band_pref( eng_ptr->ss,
                           &ss_mode_pref,
                           &ss_band_pref,
                           &ss_lte_band_pref,
                           &ss_tds_band_pref );
  /* Check whether any system record on the specified list has a channel
  ** strength measurement value that is >= than the specified one.
  */
  list_pos = sdss_sr_list_find_next( eng_ptr->ss,
                                     eng_ptr->scr_con,
                                     eng_ptr->acq_mode,
                                     list,
                                     0,
                                     0,
                                     meas_val,
                                     ss_mode_pref,
                                     ss_band_pref,
                                     ss_lte_band_pref,
                                     ss_tds_band_pref,
                                     SDSR_CAT_ALL);

  /* If no such system found, continue with next script construct. Else,
  ** activate the specified SS-Script.
  */
  if( list_pos == SDSR_POS_NULL )
  {
    eng_ptr->scr_ctrl.ctrl            = SDSS_SCR_CTRL_NEXT_CONS;
  }
  else
  {
    eng_ptr->scr_ctrl.ctrl            = SDSS_SCR_CTRL_ACT_SCR;
    eng_ptr->scr_ctrl.prm.act.script  = script;
  }

} /* sdss_eng_scr_con_act_meas *//*lint +esym(715, rtrn_iact_ptr) */

/*===========================================================================

FUNCTION sdss_get_lte_tele_bsr_timer

DESCRIPTION
  calculate LTE tele BSR timer based on NV settings. Algorithm:
  IF(current loop #(n) <= max stage #(s) * repeat counter(c))
  {
    T = t*(pow(2,ceil(n/c)-1))
  }
  ELSE
  {
    T = t*(pow(2,s-1))
  }


DEPENDENCIES
  None.

RETURN VALUE
  calculated LTE tele BSR timer value

SIDE EFFECTS
  None.

===========================================================================*/
static dword  sdss_get_lte_tele_bsr_timer(sdss_s_type      *ss_ptr)
{
  float loopn, stage, cunt;
  dword lte_bsr_timer;

  sd_ss_e_type ss = sdss_get_ss_for_mode(SD_MODE_LTE);

  loopn = (float)ss_ptr->telescope_bsr_current_loop_lte;
    stage = (float)sdssscr_efs_item_get(SDSSSCR_EFS_ITEM_LTE_TELESCOPE_BSR_STAGE,
                                     sdss_map_ss_to_as_id(ss));
    cunt = (float)sdssscr_efs_item_get(SDSSSCR_EFS_ITEM_LTE_TELESCOPE_BSR_RPT_CUNT,
                                     sdss_map_ss_to_as_id(ss));
    lte_bsr_timer = sdssscr_efs_item_get(SDSSSCR_EFS_ITEM_LTE_TELESCOPE_BSR_TIME,
                                     sdss_map_ss_to_as_id(ss));



    if(loopn <= stage * cunt)
    {
     lte_bsr_timer = lte_bsr_timer * (dword)pow(2,ceil(loopn/cunt)-1);
    }
    else
    {
      lte_bsr_timer =lte_bsr_timer * (dword)pow(2, stage-1);
    }
    return lte_bsr_timer;

}

static dword sdss_get_lte_long_bsr_timer(sd_ss_e_type ss)
{
  return (dword)sdssscr_efs_item_get(SDSSSCR_EFS_ITEM_TMR_LTE_LONG_RESEL,
                                    sdss_map_ss_to_as_id(ss));
}

/*===========================================================================

FUNCTION sdss_get_1x_bsr_timer

DESCRIPTION
  calculate 1x BSR timer which follow sprint staged algorithm

DEPENDENCIES
  None.

RETURN VALUE
  calculated 1x BSR timer value. algorithm:
  for (i=0; i<2 or better system acquired ;i++)
  {
   SDSSSCR_NV_ITEM_ALT_CDMA_BSR_STAGE1_TIME (Stay on the less preferred system)
    while(SRCH_LST not exhausted)
  {
    10s (Scan SRCH_LST)
  }
  }
  while (better sys not found)
  {
    stay on the less preferred system for SDSSSCR_NV_ITEM_ALT_CDMA_BSR_STAGE2_TIMEs
    while(SRCH_LST not exhausted)
  {
    10s (Scan SRCH_LST)
  }
  }


SIDE EFFECTS
  None.

===========================================================================*/
static dword sdss_get_1x_bsr_timer(sdss_s_type      *ss_ptr)
{
  dword                next_1x_bsr_timer           = 0;


  if (ss_ptr->is_extend_1x_bsr_timer) 
  {
    /* decrement the loop count here. It will be incremented later when 1x acq is issued, 
    ** so this ensures that the overall loop count remains unchanged.
    ** This ensures that SD uses Tbsr stage1 timer value 2 times
    */ 
    SD_MSG_HIGH_0("Extend 1x Bsr timer 10s" );
    ss_ptr->telescope_bsr_current_loop_1x--;
    next_1x_bsr_timer = 10;
    ss_ptr->is_extend_1x_bsr_timer = FALSE;

  }
  /* Else set the timer to T_bsr1 or Tbsr2 depending  on which loop it is in */
  else
  {
    
    /* For 1st 2 iterations of BSR, set timer to value in ALT_CDMA_BSR_STAGE1_TIME */
    if(ss_ptr->telescope_bsr_current_loop_1x <= 2 )
    {
      next_1x_bsr_timer = sdssscr_nv_item_get(SDSSSCR_NV_ITEM_ALT_CDMA_BSR_STAGE1_TIME);
    }
    else
    {
      next_1x_bsr_timer = sdssscr_nv_item_get(SDSSSCR_NV_ITEM_ALT_CDMA_BSR_STAGE2_TIME);
    }
  } //if (ss_ptr->is_extend_1x_bsr_timer) 
  return next_1x_bsr_timer;


}

static void sdss_update_pref_scan_status(sdss_s_type           *ss_ptr)
{
  dword  uptime = time_get_uptime_secs();

  if(ss_ptr->bsr_uptime_lte > uptime || ss_ptr->bsr_uptime_lte == BSR_UPTIME_NONE)
  {
    /*skip LTE scan*/
    ss_ptr->is_skip_lte_pref_scan = TRUE;
  }
  else
  {
    ss_ptr->is_skip_lte_pref_scan = FALSE;
  }
  if(ss_ptr->bsr_uptime_1x > uptime || ss_ptr->bsr_uptime_1x == BSR_UPTIME_NONE)
  {
    /*skip 1X scan*/
    ss_ptr->is_skip_1x_pref_scan = TRUE;
  }
  else
  {
    ss_ptr->is_skip_1x_pref_scan = FALSE;
  }
  SD_MSG_HIGH_2("is_skip_lte_pref_scan = %d, is_skip_1x_pref_scan = %d",
              ss_ptr->is_skip_lte_pref_scan, ss_ptr->is_skip_1x_pref_scan);

}

static dword sdss_get_timer_min(sdss_s_type     *ss_ptr)
{
  dword  uptime = time_get_uptime_secs();

  dword bsr_time_1x = ss_ptr->bsr_uptime_1x - uptime;
  dword bsr_time_lte = ss_ptr->bsr_uptime_lte - uptime;


  if(ss_ptr->bsr_uptime_1x == BSR_UPTIME_NONE && ss_ptr->bsr_uptime_lte == BSR_UPTIME_NONE)
  {
    return 0;
  }
  else if(ss_ptr->bsr_uptime_1x == BSR_UPTIME_NONE )
  {
    return bsr_time_lte;
  }
  else if(ss_ptr->bsr_uptime_lte == BSR_UPTIME_NONE)
  {
    return bsr_time_1x;
  }
  else
  {
    return MIN(bsr_time_lte,bsr_time_1x);
  }

}

static void sdss_update_bsr_uptime_1x(sdss_s_type     *ss_ptr)
{
  dword  uptime = time_get_uptime_secs();

  SD_MSG_HIGH_1("TELE_BSR: update_1x, uptime=%d",uptime);

  if(sdsr_list_find_sys_mode(SDSR_SRV_PREF_LST, SD_MODE_CDMA) == SDSR_POS_NULL)
  {
    /* disable 1x BSR timer */
    ss_ptr->bsr_uptime_1x = BSR_UPTIME_NONE;
    sdss_1x_telescope_parm_reset();
  }
  else if(ss_ptr->bsr_uptime_1x > uptime)
  {
    SD_MSG_HIGH_0("maintain the 1x bsr timer");
  }
  else
  {
    /* Continue 1x stage bsr */
    ss_ptr->bsr_uptime_1x = sdss_get_1x_bsr_timer(ss_ptr)+uptime;
  }

  SD_MSG_HIGH_1("TELE_BSR: 1x_bsr_timer=%d",ss_ptr->bsr_uptime_1x - uptime);
}
static void sdss_update_long_bsr_uptime_lte(sdss_s_type     *ss_ptr)
{
  dword  uptime = time_get_uptime_secs();

  SD_MSG_HIGH_1("TELE_BSR: update_long_lte, uptime=%d",uptime);

  if(!sdsr_list_is_lte_in_list(SDSR_SRV_PREF_LST))
  {
    /* disable LTE bsr timer */
    ss_ptr->bsr_uptime_lte = BSR_UPTIME_NONE;
    sdss_lte_telescope_parm_reset(SD_SS_MAIN);
  }
  /* If it is moving from NONE to NOT_AVAIL restart long BSR timer
  **
  ** If the 1x is already in LTE not avail and not moving.
  ** when 1x bsr timer expires, it should not restart LTE long bsr timer, instead
  ** it should maintain LTE bsr timer otherwise LTE long bsr timer might never expire
  */
  else if(ss_ptr->lte_avail_1x == SDSS_LTE_AVAIL_NOT_AVAIL)
  {
    /* if timer expired, restart */
    if(ss_ptr->bsr_uptime_lte <= uptime)
    {
      ss_ptr->bsr_uptime_lte = sdss_get_lte_long_bsr_timer(sdss_get_ss_for_mode(SD_MODE_LTE)) + uptime;
      /* Rest tele bsr loop*/
      ss_ptr->telescope_bsr_current_loop_lte = 1;
      ss_ptr->is_lte_long_bsr = TRUE;
    }
    /* otherwise maintain the timer */
    else
    {
      SD_MSG_HIGH_1("TELE_BSR: cont_long_bsr: maintain timer %d",ss_ptr->bsr_uptime_lte - uptime);
    }
  }

  SD_MSG_MED_1("TELE_BSR: cont_long_bsr_timer %d",ss_ptr->bsr_uptime_lte - uptime);
}

/*===========================================================================

FUNCTION sdss_update_tele_bsr_uptime_lte

DESCRIPTION
  Calculate LTE bsr timer.
  If no more pref LTE set LTE bsr timer to 0. Otherwise
  If LTE BSR timer not expired, keep running it. If LTE BSR timer expired, recalculate LTE
  tele bsr timer


DEPENDENCIES
  None.

RETURN VALUE

SIDE EFFECTS
  None.

===========================================================================*/
static void sdss_update_tele_bsr_uptime_lte(sdss_s_type     *ss_ptr)
{
  dword  uptime = time_get_uptime_secs();

  SD_MSG_MED_1("TELE_BSR: update_lte, uptime=%d",uptime);
  if(!sdsr_list_is_lte_in_list(SDSR_SRV_PREF_LST))
  {
    /* disable LTE bsr timer */
    ss_ptr->bsr_uptime_lte = BSR_UPTIME_NONE;
    sdss_lte_telescope_parm_reset(SD_SS_MAIN);
  }
  else if(ss_ptr->bsr_uptime_lte > uptime)
  {
    //maintain the timer
    SD_MSG_HIGH_1("TELE_BSR: maintain timer %d",ss_ptr->bsr_uptime_lte - uptime);
  }
  else
  {
    ss_ptr->bsr_uptime_lte = sdss_get_lte_tele_bsr_timer(ss_ptr)+ uptime;
    SD_MSG_HIGH_1("TELE_BSR: lte_bsr_timer=%d",ss_ptr->bsr_uptime_lte - uptime);
  }
}


/* <EJECT> */
/*===========================================================================
=============================================================================
=============== MISCELLANEOUS SS-SCRIPT-CONSTRUCTS FUNCTIONS ================
=============================================================================
===========================================================================*/


/*===========================================================================

FUNCTION sdss_eng_scr_con_cont

DESCRIPTION
  Implement the CONT( TIME ) SS-Script Constructs.

  Instructs the SS-Client to continue with its current activity while
  setting-up a TIME timer. When this timer expires the SS-Client shall call
  on the SD_SS_IND_MISC_TIMER SS-Indication function.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static  void                    sdss_eng_scr_con_cont(

        sdss_eng_s_type         *eng_ptr,
            /* Pointer to the SS-script-engine that is associated with the
            ** SS-Script that is being executed.
            */

        sdss_evt_e_type         event,
            /* SS-Event coming back from the SS-Front-end.
            */

        sdss_iact_s_type        *rtrn_iact_ptr
            /* Pointer to a buffer where to place returned internal action.
            */
)
{
  /* Time in seconds with which to set-up the timer.
  */
  word                  cont_type, cont_type2 = 0;
  dword                 timer, timer2;
  dword                 expired_time;
  dword                 uptime     = time_get_uptime_secs();
  sdss_s_type           *ss_ptr;
  sdsr_s_type           *srv_sys_ptr = NULL;

  #ifdef FEATURE_EOOS
  #error code not present
#endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( eng_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( event, SDSS_EVT_MAX );
  SD_ASSERT( rtrn_iact_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  cont_type = eng_ptr->con_prm1;
  #ifdef FEATURE_EOOS
  #error code not present
#endif
  /*
  ** As cont_type and cont_type2 can be used to pass the timer value,
  ** they are no longer in the range of 0 and SDSSSCR_CONT_TYPE_MAX.
  ** SD_ASSERT_ENUM_IS_INRANGE( cont_type, SDSSSCR_CONT_TYPE_MAX )
  */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  ss_ptr    = eng_ptr->ss_ptr;
  switch(eng_ptr->scr_con)
  {
    case SDSSSCR_CON_CONT2:
    case SDSSSCR_CON_CONT3:
    case SDSSSCR_CON_CONT2_REDIR :
    case SDSSSCR_CON_CONT2_WAIT:
    case SDSSSCR_CON_CONT2_BSR:
    case SDSSSCR_CON_CONT3_BSR:

      timer = WORD_TO_DWORD( eng_ptr->con_prm2, eng_ptr->con_prm3 );
      break;

    case SDSSSCR_CON_CONT_LONG_BSR:
    {

      if(sdss_get_ss_for_mode(SD_MODE_LTE) == SD_SS_HYBR_2)
      {
        timer = sdss_get_lte_long_bsr_timer(SD_SS_HYBR_2);
      }
      else if(sdss_get_ss_for_mode(SD_MODE_LTE) == SD_SS_MAIN)
      {
        if( event == SDSS_EVT_MISC_TIMER_RESEL_OK)
        {
          SD_MSG_HIGH_0("TELE_BSR: long BSR timer expired");
          sdss_update_pref_scan_status(ss_ptr);
          timer = SD_SS_TIMER_INVALID;
          break;
        }

        /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

        sdss_update_long_bsr_uptime_lte(ss_ptr);
        sdss_update_bsr_uptime_1x(ss_ptr);

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
        timer = sdss_get_timer_min(ss_ptr);
        ss_ptr->telescope_bsr_timer_main_uptime = timer + uptime;
        SD_MSG_HIGH_2("TELE_BSR: long_timer=%d, uptime=%d",timer,ss_ptr->telescope_bsr_timer_main_uptime);
      }
      else
      {
        timer = SD_SS_TIMER_INVALID;
        SD_ERR_0("TELE_BSR: long bsr not supported");
      }

      break;
    }


    case SDSSSCR_CON_CONT_TELE_BSR:
    {
      /* ===Calculation the tele bsr timeline in SVLTE===
      */
      if(sdss_get_ss_for_mode(SD_MODE_LTE) == SD_SS_HYBR_2)
      {
        timer = sdss_get_lte_tele_bsr_timer(ss_ptr);
        SD_MSG_HIGH_1("TELE_BSR: SVLTE timer=%d",timer);
      }

      /* ===Calculate LTE/1X bsr timeline in non-SVLTE ===
      */
      else
      {
        if( event == SDSS_EVT_MISC_TIMER_RESEL_OK)
        {
          SD_MSG_HIGH_0("TELE_BSR: timer expired");
          sdss_update_pref_scan_status(ss_ptr);
          timer = SD_SS_TIMER_INVALID;
          break;
        }
        /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
        else
        {
          if(ss_ptr->is_lte_long_bsr)
          {
            ss_ptr->bsr_uptime_lte = BSR_UPTIME_NONE;
            ss_ptr->is_lte_long_bsr = FALSE;
          }
          sdss_update_tele_bsr_uptime_lte(ss_ptr);
          sdss_update_bsr_uptime_1x(ss_ptr);

          /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

          timer = sdss_get_timer_min(ss_ptr);

          /* remember the timer that will be started */
          ss_ptr->telescope_bsr_timer_main_uptime = timer + uptime;
          SD_MSG_HIGH_2("TELE_BSR: timer=%d, uptime=%d",timer,ss_ptr->telescope_bsr_timer_main_uptime);
        }
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

      }

      break;
    }
    case SDSSSCR_CON_CONT_EOOS_SLEEP:
       /* Retrieve the sleep for the EOOS */
      #ifdef FEATURE_EOOS
      #error code not present
#endif

    default:

    timer     = eng_ptr->con_prm2;

    cont_type2 = eng_ptr->con_prm3;

    SD_ASSERT_ENUM_IS_INRANGE( cont_type2, SDSSSCR_CONT_TYPE_MAX );
  }


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  timer2    = eng_ptr->con_prm4;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If the script is calling for no timer, wait on the current construct
  ** forever.
  */
  if( timer == 0 )
  {
    /* If this is not the first time this function is being called for this
    ** script construct, indicate that this event is being ignored.
    */
    if( eng_ptr->scr_ctrl.ctrl != SDSS_SCR_CTRL_NEXT_CONS )
    {
      SD_MSG_HIGH_1( "Ignoring event=%d",event);
    }

    eng_ptr->scr_timer      = 0;
    eng_ptr->scr_ctrl.ctrl  = SDSS_SCR_CTRL_RTRN_ACT;
    rtrn_iact_ptr->act      = SDSS_IACT_CONTINUE;

    return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If the script is calling to continue until next event, wait on the
  ** current construct until next event.
  */
  if( timer == SDSSSCR_UNTIL_NEXT_EVENT )
  {
    /* If this is not the first time this function is being called for this
    ** script construct, continue with the next script construct. Else, wait
    ** for next event.
    */
    if( eng_ptr->scr_ctrl.ctrl != SDSS_SCR_CTRL_NEXT_CONS )
    {
      eng_ptr->scr_timer      = 0;
      eng_ptr->scr_ctrl.ctrl  = SDSS_SCR_CTRL_NEXT_CONS;
      return;
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    eng_ptr->scr_timer      = 0;
    eng_ptr->scr_ctrl.ctrl  = SDSS_SCR_CTRL_RTRN_ACT;
    rtrn_iact_ptr->act      = SDSS_IACT_CONTINUE;

    return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if( timer == SDSSSCR_UNTIL_NEXT_EVENT_WITH_CURR_TIMER )
  {
    /* If this is not the first time this function is being called for this
    ** script construct, continue with the next script construct. Else, wait
    ** for next event.
    */
    if( eng_ptr->scr_ctrl.ctrl != SDSS_SCR_CTRL_NEXT_CONS )
    {
      eng_ptr->scr_ctrl.ctrl  = SDSS_SCR_CTRL_NEXT_CONS;
      return;
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    eng_ptr->scr_ctrl.ctrl  = SDSS_SCR_CTRL_RTRN_ACT;
    rtrn_iact_ptr->act      = SDSS_IACT_CONTINUE;

    return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If this is the first time this function is being called for this script
  ** construct, setup the timer and return.
  */
  if( eng_ptr->scr_ctrl.ctrl == SDSS_SCR_CTRL_NEXT_CONS )
  {

    switch( eng_ptr->scr_con )
    {
      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      case SDSSSCR_CON_CONT:
      case SDSSSCR_CON_CONT2:
      case SDSSSCR_CON_CONT3:

        eng_ptr->scr_timer    = uptime + timer;

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      case SDSSSCR_CON_CONT_EOOS_SLEEP:
        #ifdef FEATURE_EOOS
        #error code not present
#else
        SD_ERR_FATAL_0( "cons"); /*lint -e527 */
        break;
        #endif
      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_CONT_ABSR:
        eng_ptr->scr_timer    = uptime + timer;

        SD_MSG_HIGH_3("scr_timer = %d, uptime= %d, timer= %d" ,
                    eng_ptr->scr_timer, uptime, timer);
      break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_CONT_REDIR:
      case SDSSSCR_CON_CONT2_REDIR:

        SD_ASSERT( uptime >= ss_ptr->redir_uptime )

        /* If the redirection timer is expired priory to the uptime and the
        ** last event is SDSS_EVT_MISC_TIMER_RESEL_OK, then ignore this timer.
        ** (We do not blindly ignore it since the reselection may be not
        ** allowed even the time is passed.
        */
        SD_MSG_HIGH_3("redir_uptime= %d, uptime= %d, timer= %d" ,
                    ss_ptr->redir_uptime, uptime, timer);
        if( uptime >= ss_ptr->redir_uptime + timer &&
            event == SDSS_EVT_MISC_TIMER_RESEL_OK )
        {
          return;
        }

        sdss_clear_bsr_timer( eng_ptr->ss );
        eng_ptr->scr_timer = ss_ptr->redir_uptime + timer;

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      case SDSSSCR_CON_CONT2_WAIT:

        /* If the timer is expired priory to the uptime and the last event is
        ** SDSS_EVT_MISC_TIMER_RESEL_OK, then ignore this timer. (We do not
        ** blindly ignore it since the reselection may be not allowed even
        ** the time is passed.
        */
        if( uptime >= ss_ptr->cont_uptime[cont_type] + timer &&
            event == SDSS_EVT_MISC_TIMER_RESEL_OK )
        {
          return;
        }

        eng_ptr->scr_timer = ss_ptr->cont_uptime[cont_type] + timer;

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_CONT3_WAIT:

        /* If both timers have been started , set the expired_time per that
        ** of the earliest expiration timer.
        **
        ** Else if only one timer is active set the expiration_time per
        ** this timer.
        **
        ** Else (both timer expired), set timer for 1s.
        */

        if( ss_ptr->cont_uptime[cont_type]  > 0 &&
            ss_ptr->cont_uptime[cont_type2] > 0)
        {
          expired_time = MIN( ss_ptr->cont_uptime[cont_type] + timer,
                              ss_ptr->cont_uptime[cont_type2] + timer2 );
        }
        else
        {
          if( ss_ptr->cont_uptime[cont_type2] > 0 )
          {
            expired_time = ss_ptr->cont_uptime[cont_type2] + timer2;
          }
          else
          {
            expired_time = ss_ptr->cont_uptime[cont_type] + timer;
          }
        }

        /* If timer expires priory to the uptime and the last event is
        ** SDSS_EVT_MISC_TIMER_RESEL_OK, then ignore this timer.
        ** (We do not blindly ignore it since the reselection may be
        ** not allowed even the time is passed.)
        */

        if( uptime >= expired_time &&
            event == SDSS_EVT_MISC_TIMER_RESEL_OK )
        {
          return;
        }

        eng_ptr->scr_timer = expired_time;

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      case SDSSSCR_CON_CONT_BSR:
      case SDSSSCR_CON_CONT2_BSR:
      case SDSSSCR_CON_CONT3_BSR:
      case SDSSSCR_CON_CONT_TELE_BSR:
      case SDSSSCR_CON_CONT_LONG_BSR:

        /* If BSR timer uptime is greater than current uptime and current SRV_SYS is same
        ** as system on which BSR timer was started, then continue with same BSR uptime.
        ** Also if BSR timer is greater than current timer then reduce the BSR timer to
        ** current timer.
        ** Otherwise update BSR uptime with new uptime.
        */
        if(ss_ptr->bsr_timer <= uptime ||
           ((ss_ptr->bsr_timer - uptime) > timer && ss_ptr->bsr_timer > uptime))
        {
           ss_ptr->bsr_timer= uptime + timer;
        }

        /* Set scr_timer as per bsr_timer */
        eng_ptr->scr_timer    = ss_ptr->bsr_timer;
        /* Update BSR sr ref */
        srv_sys_ptr = sdsr_list_get_ptr(sdss_sr_list_map2(eng_ptr->ss,SDSR_SRV_SYS),0);
        if( srv_sys_ptr != NULL )
        {
           ss_ptr->bsr_sid = srv_sys_ptr->sid;
           ss_ptr->bsr_sys = srv_sys_ptr->sys;
        }
        else
        {
          SD_MSG_HIGH_1 ("LIST SDSR_SRV_SYS is empty, ss %d", eng_ptr->ss);
        }

        /* record the current tele bsr loop count */
        if((sdss_get_ss_for_mode(SD_MODE_LTE) == SD_SS_HYBR_2) &&
           eng_ptr->scr_con == SDSSSCR_CON_CONT_TELE_BSR)
        {
          ss_ptr->telescope_bsr_current_loop_lte++;
          ss_ptr->is_lte_tele_bsr_timer = TRUE;
          SD_MSG_HIGH_1("TELE_BSR: current_lte_loop=%d",ss_ptr->telescope_bsr_current_loop_lte);
        }
        else if((sdss_get_ss_for_mode(SD_MODE_LTE) == SD_SS_MAIN) &&
                (eng_ptr->scr_con == SDSSSCR_CON_CONT_TELE_BSR ||
                 eng_ptr->scr_con == SDSSSCR_CON_CONT_LONG_BSR))
        {
          if(sdsr_list_is_lte_in_list(SDSR_SRV_PREF_LST))
          {
             ss_ptr->is_lte_tele_bsr_timer = TRUE;
             SD_MSG_HIGH_0("TELE_BSR: is_lte_tele_bsr_timer is TRUE");
          }
          if(sdsr_list_find_sys_mode(SDSR_SRV_PREF_LST, SD_MODE_CDMA) != SDSR_POS_NULL)
          {
            ss_ptr->is_1x_bsr_timer = TRUE;
            SD_MSG_HIGH_0("TELE_BSR: is_1x_bsr_timer is TRUE");
          }
        }
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      default:
        SD_ERR_FATAL_0( "cons"); /*lint -e527 */
        return; /*lint +e527 */ /* Unreachable */
    }/* switch */

    eng_ptr->scr_ctrl.ctrl  = SDSS_SCR_CTRL_RTRN_ACT;
    rtrn_iact_ptr->act      = SDSS_IACT_CONTINUE;

    sdss_ss_timer_log_rprt(eng_ptr, SDLOG_SS_TIMER_STARTED);
    return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If we got here, this is not the first time this function is being called
  ** for this script construct.
  */

  /* If the timer has expired and reselection is allowed, continue with the
  ** next script construct.
  */
  if( event == SDSS_EVT_MISC_TIMER_RESEL_OK )
  {
    eng_ptr->scr_timer      = 0;
    eng_ptr->scr_ctrl.ctrl  = SDSS_SCR_CTRL_NEXT_CONS;
    sdss_ss_timer_log_rprt(eng_ptr, SDLOG_SS_TIMER_EXPIRED);

    return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Else, if the timer has expired, but reselection is not allowed, indicate
  ** so by setting the timer to 0 and continue waiting.
  ** For GW, start a 30 sec timer
  */
  if( event == SDSS_EVT_MISC_TIMER_RESEL_NO )
  {
    if(sdss_sr_list_is_mode_pref(sdss_sr_list_map2(eng_ptr->ss,SDSR_SRV_SYS), SD_SS_MODE_PREF_TDS_GSM_WCDMA_LTE))
    {

      eng_ptr->scr_timer      = uptime + sdssscr_nv_item_get(SDSSSCR_NV_ITEM_RESEL_HOLD_3GPP_ACTIVITY);

      /* Set BSR timer as scr timer */
      if( ss_ptr->resel_state != SDSS_RESEL_STT_NONE )
      {
        ss_ptr->bsr_timer = eng_ptr->scr_timer;
      }


      sdss_ss_timer_log_rprt(eng_ptr, SDLOG_SS_TIMER_ALTERED);
    }
    else
    {
      eng_ptr->scr_timer      = 0;
      sdss_ss_timer_log_rprt(eng_ptr, SDLOG_SS_TIMER_DISABLED);
    }

    eng_ptr->scr_ctrl.ctrl  = SDSS_SCR_CTRL_RTRN_ACT;
    rtrn_iact_ptr->act      = SDSS_IACT_CONTINUE;

    return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If we got here, this is not the first time this function is being called
  ** and the current event is not a timer expiration event.
  */

  /* If expiration uptime <= current uptime (i.e. timer already expired), set
  ** the timer for 1s, so we would continue with the next script construct
  ** upon the expiration. Else, stay and wait for the timer to expire.
  */
  if( eng_ptr->scr_timer <= uptime )
  {
    /* If currently srv system is GW(and only when it has service) then
    ** set the timer value to 30sec, Else set it to 1sec as usual
    ** ex> For HYBR2 LTE BSR, there is no reason to extend the timer
    ** for 30secs due to other event
    */
    if(sdss_sr_list_is_mode_pref(sdss_sr_list_map2(eng_ptr->ss,SDSR_SRV_SYS), SD_SS_MODE_PREF_GWL ) &&
       ss_ptr->ss_state == SDSS_STATE_OPR)
    {
      eng_ptr->scr_timer      = uptime + 30;
    }
    else
    {
      eng_ptr->scr_timer      = uptime + 1;
    }

    eng_ptr->scr_ctrl.ctrl  = SDSS_SCR_CTRL_RTRN_ACT;
    rtrn_iact_ptr->act      = SDSS_IACT_CONTINUE;

    sdss_ss_timer_log_rprt(eng_ptr, SDLOG_SS_TIMER_ALTERED);
  }
  else
  {
    SD_MSG_HIGH_1( "Ignoring event=%d",event);
    eng_ptr->scr_ctrl.ctrl  = SDSS_SCR_CTRL_RTRN_ACT;
    rtrn_iact_ptr->act      = SDSS_IACT_CONTINUE;
  }

} /* sdss_eng_scr_con_cont */




/* <EJECT> */
/*===========================================================================
//
//FUNCTION sdss_eng_scr_con_cont_redir
//
//DESCRIPTION
//  Implement the CONT_REDIR( TIME ) SS-Script Constructs.
//
//  Conditionally stops script execution and instructs the SS-Client to
//  continue until TIME seconds passed since the most recent redirection
//  indication was received. If instructs SS-Client to continue, sets a timer
//  for the appropriate duration.
//
//DEPENDENCIES
//  None.
//
//RETURN VALUE
//  None.
//
//SIDE EFFECTS
//  None.
//
//===========================================================================*/
//static  void                    sdss_eng_scr_con_cont_redir(
//
//        sdss_eng_s_type         *eng_ptr,
//            /* Pointer to the SS-script-engine that is associated with the
//            ** SS-Script that is being executed.
//            */
//
//        sdss_evt_e_type         event,
//            /* SS-Event coming back from the SS-Front-end.
//            */
//
//        sdss_iact_s_type        *rtrn_iact_ptr
//            /* Pointer to a buffer where to place returned internal action.
//            */
//)
//{
//  /* Time in seconds with which to set-up the timer.
//  */
//  dword                 timer   = eng_ptr->con_prm1;
//  dword                 uptime  = time_get_uptime_secs();
//  const sdss_s_type     *ss_ptr = eng_ptr->ss_ptr;
//
//  dword                 time_since_redir;
//
//  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
//
//  SD_ASSERT( eng_ptr != NULL );
//  SD_ASSERT_ENUM_IS_INRANGE( event, SDSS_EVT_MAX );
//  SD_ASSERT( rtrn_iact_ptr != NULL );
//
//  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
//
//  /* If this is the first time this function is being called for this script
//  ** construct, check whether script execution should continue. If script
//  ** execution should not continue, setup the appropriate timer.
//  */
//  if( eng_ptr->scr_ctrl.ctrl == SDSS_SCR_CTRL_NEXT_CONS )
//  {
//    SD_ASSERT( uptime >= ss_ptr->redir_uptime )
//    time_since_redir = uptime - ss_ptr->redir_uptime;
//
//    if( timer > time_since_redir )
//    {
//      eng_ptr->con_prm1 = (sdssscr_prm_type) (timer - time_since_redir);
//      sdss_eng_scr_con_cont( eng_ptr, event, rtrn_iact_ptr );
//    }
//
//    return;
//  }
//
//  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
//
//  /* If we got here, this is not the first time this function is being called
//  ** for this script construct, so call on the timer function to process
//  ** this event.
//  */
//  sdss_eng_scr_con_cont( eng_ptr, event, rtrn_iact_ptr );
//
//} /* sdss_eng_scr_con_cont_redir */


/*===========================================================================

FUNCTION sdss_eng_scr_con_cont_set

DESCRIPTION
  Implement the CONT_SET( TIME ) SS-Script Constructs.

  Set the start time of the conditional wait.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static  void                    sdss_eng_scr_con_cont_set(

        const sdss_eng_s_type   *eng_ptr
      /* Pointer to the SS-script-engine that is associated with the
      ** SS-Script that is being executed.
      */
)
{
  /* Time in seconds with which to set-up the timer.
  */
  word                  cont_type;
  word                  timer_value;
  dword                 uptime       = time_get_uptime_secs();
  sdss_s_type           *ss_ptr;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( eng_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  cont_type   = eng_ptr->con_prm1;
  timer_value  = eng_ptr->con_prm2;
  ss_ptr      = eng_ptr->ss_ptr;

  SD_ASSERT_ENUM_IS_INRANGE( cont_type, SDSSSCR_CONT_TYPE_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( timer_value, SDSSSCR_CONT_VAL_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  switch ( timer_value ) {

    case SDSSSCR_CONT_VAL_ZERO:
      /* Reset the timer to zero.
      */
      ss_ptr->cont_uptime[cont_type] = 0;
      break;

    case SDSSSCR_CONT_VAL_UPTIME_IF_ZERO:
      /* If the start time is zero, set to the uptime. Otherwise, do nothing.
      */
      if(ss_ptr->cont_uptime[cont_type] != 0 )
      {
        return;
      }
      ss_ptr->cont_uptime[cont_type] = uptime;
      break;

    case SDSSSCR_CONT_VAL_UPTIME:
      /* Set the start time to uptime.
      */
      ss_ptr->cont_uptime[cont_type] = uptime ;
      break;

    case SDSSSCR_CONT_VAL_INC_BY_BCMCS_LEN:
      /* Pause the timer until BCMCS is end.
      */

      if( ss_ptr->cont_uptime[cont_type] != 0 )
      {
        ss_ptr->cont_uptime[cont_type] +=
           (ss_ptr->hdr_bcmcs_stop_uptime - ss_ptr->hdr_bcmcs_start_uptime);
      }

      break;

    case SDSSSCR_CONT_VAL_MAX:
    default:
      SD_ERR_0(" Invalid CONT VALUE");
      break;
  }

  SD_MSG_HIGH_2("Set Timer= %d, uptime= %d",
              cont_type, ss_ptr->cont_uptime[cont_type]);
  return;

} /* sdss_eng_scr_con_cont_set */


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_eng_scr_acpt_rej

DESCRIPTION
  Implement the ACCEPT and REJECT SS-Script Constructs.

  Instructs the SS-Client to accept/reject BS proposed mode, band and/or
  CDMA channel/AMPS system.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static  void                    sdss_eng_scr_acpt_rej(

        sdss_eng_s_type         *eng_ptr,
            /* Pointer to the SS-script-engine that is associated with the
            ** SS-Script that is being executed.
            */

        sdss_evt_e_type         event,
            /* SS-Event coming back from the SS-Front-end.
            *//*lint -esym(715, event) */ /* not referenced */

        sdss_iact_s_type        *rtrn_iact_ptr
            /* Pointer to a buffer where to place returned internal action.
            */
)
{
  SD_ASSERT( eng_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( event, SDSS_EVT_MAX );
  SD_ASSERT( rtrn_iact_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_MSG_HIGH_3("sdss_eng_scr_acpt_rej - scr_ctrl.ctrl = %d, scr_con = %d, event = %d",
              eng_ptr->scr_ctrl.ctrl, eng_ptr->scr_con, event);
  /* If this is the first time this function is being called for this script
  ** construct, instruct the SS-Client of accept/reject.
  */
  if( eng_ptr->scr_ctrl.ctrl == SDSS_SCR_CTRL_NEXT_CONS )
  {
    if( eng_ptr->scr_con == SDSSSCR_CON_ACCEPT )
    {
      rtrn_iact_ptr->act    = SDSS_IACT_ACCEPT;
    }
    else
    {
      rtrn_iact_ptr->act    = SDSS_IACT_REJECT;
    }

    eng_ptr->scr_ctrl.ctrl  = SDSS_SCR_CTRL_RTRN_ACT;
    return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If we got here, this is not the first time this function is being called
  ** for this script construct. so continue with the next script construct.
  ** However, we should only continue if it's in Redirection Context.
  */
  if ((event == SDSS_EVT_USER_CDMA_REDIR_ACPT_REJ) ||
      (event == SDSS_EVT_CDMA_OPR_ACPT_REJ))
  {
    eng_ptr->scr_ctrl.ctrl  = SDSS_SCR_CTRL_NEXT_CONS;
  }
} /* sdss_eng_scr_acpt_rej *//*lint +esym(715, event) */




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_eng_scr_con_pwr_save

DESCRIPTION
  Implement the PWR_SAVE SS-Script Constructs.

  Instruct the SS-Client to enter Power-Save mode of operation. Once entering
  Power-Save mode of operation, the SS-Client should call on the
  SD_SS_IND_MISC_PWR_SAVE_ENTER SS-Indication function.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static  void                    sdss_eng_scr_con_pwr_save(

        sdss_eng_s_type         *eng_ptr,
            /* Pointer to the SS-script-engine that is associated with the
            ** SS-Script that is being executed.
            */

        sdss_evt_e_type         event,
            /* SS-Event coming back from the SS-Front-end.
            */

        sdss_iact_s_type        *rtrn_iact_ptr
            /* Pointer to a buffer where to place returned internal action.
            */
)
{
  SD_ASSERT( eng_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( event, SDSS_EVT_MAX );
  SD_ASSERT( rtrn_iact_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If this is the first time this function is being called for this script
  ** construct, instruct the SS-Client to enter Power-Save mode of operation.
  ** Once entering power-save mode the SS-Client should call in the
  ** sd_ss_ind_misc_pwr_save_enter() SS-Indication function which in turn
  ** generate an SDSS_EVT_MISC_PWR_SAVE_ENTER SS-Event.
  */
  if( eng_ptr->scr_ctrl.ctrl == SDSS_SCR_CTRL_NEXT_CONS )
  {
    eng_ptr->scr_ctrl.ctrl  = SDSS_SCR_CTRL_RTRN_ACT;
    rtrn_iact_ptr->act      = SDSS_IACT_PWR_SAVE;

    return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If we got here this is not the first time this function is being called
  ** for this script construct. If event is SDSS_EVT_MISC_PWR_SAVE_ENTER,
  ** continue with next script construct. Else, stay and wait for SS-Client
  ** to report that it entered power-save mode of operation.
  */
  if( event == SDSS_EVT_MISC_PWR_SAVE_ENTER )
  {
    eng_ptr->scr_ctrl.ctrl  = SDSS_SCR_CTRL_NEXT_CONS;
  }
  else
  {
    SD_MSG_HIGH_1( "Ignoring event=%d",event);
    eng_ptr->scr_ctrl.ctrl  = SDSS_SCR_CTRL_RTRN_ACT;
    rtrn_iact_ptr->act      = SDSS_IACT_CONTINUE;
  }

} /* sdss_eng_scr_con_pwr_save */




/* <EJECT> */
/*===========================================================================
=============================================================================
================== CONDITION SS-SCRIPT-CONSTRUCTS FUNCTIONS =================
=============================================================================
===========================================================================*/


/*===========================================================================

FUNCTION sdss_eng_scr_con_is

DESCRIPTION
  Implement the IS( VAL ) condition SS-Script Constructs.

  Evaluates to TRUE iff VAL is equal to a TRUE boolean condition.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if VAL is equal to a TRUE boolean condition. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean                 sdss_eng_scr_con_is(

        const sdss_eng_s_type   *eng_ptr
            /* Pointer to the SS-script-engine that is associated with the
            ** SS-Script that is being executed.
            */
)
{
  /* Condition to be checked.
  */
  sdssscr_cond_e_type     cond;

  const sdss_s_type       *ss_ptr;
  sd_ss_mode_pref_e_type  mode_pref;
  #if defined(SD_GSM_SUPPORTED) || defined(SD_WCDMA_SUPPORTED) || defined(FEATURE_WRLF_SYSTEM_SEL)
  sd_ss_e_type     ss;
  #endif

  sd_ss_mode_pref_e_type   ss_mode_pref      = SD_SS_MODE_PREF_NONE;
  sd_ss_band_pref_e_type   ss_band_pref      = SD_SS_BAND_PREF_NONE;
  sys_lte_band_mask_e_type ss_lte_band_pref  = SYS_LTE_BAND_MASK_CONST_NONE;
  sd_ss_band_pref_e_type   ss_tds_band_pref  = SD_SS_BAND_PREF_NONE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( eng_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  cond   = (sdssscr_cond_e_type) eng_ptr->con_prm1;
  ss_ptr = eng_ptr->ss_ptr;

  #if defined(SD_GSM_SUPPORTED) || defined(SD_WCDMA_SUPPORTED) || defined(FEATURE_WRLF_SYSTEM_SEL)
  ss = eng_ptr->ss;
  #endif

  sdss_get_mode_band_pref( eng_ptr->ss,
                           &ss_mode_pref,
                           &ss_band_pref,
                           &ss_lte_band_pref,
                           &ss_tds_band_pref );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  switch( cond )
  {
    case SDSSSCR_COND_REDIR_VALID:
      if( ss_ptr->redir_is_valid )
      {
        return TRUE;
      }
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_COND_REDIR_RIF:
      if( ss_ptr->redir_is_rif )
      {
        return TRUE;
      }
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_COND_REDIR_WILDCARD_SID:
      if( ss_ptr->redir_expected_sid == SD_WILDCARD_SID )
      {
        return TRUE;
      }
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_COND_REDIR_WILDCARD_NID:
      if( ss_ptr->redir_expected_nid == SD_WILDCARD_NID )
      {
        return TRUE;
      }
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_COND_REDIR_IGNORE_CDMA:
      if( ss_ptr->redir_is_ignore_cdma )
      {
        return TRUE;
      }
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_COND_CAP_AMPS:
      if( sdss_is_supp_mode_band_pref(SD_SS_MODE_PREF_AMPS,
                                      SD_SS_BAND_PREF_ANY) )
      {
        return TRUE;
      }
      break;


    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_COND_CAP_GSM:
      if( sdss_is_supp_mode_band_pref(SD_SS_MODE_PREF_GSM,
                                      SD_SS_BAND_PREF_ANY)
        )
      {
        return TRUE;
      }
      break;
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_COND_MODE_PREF_NONE:
      mode_pref =  sdss_get_supp_mode_pref_mmode(ss_mode_pref,
                                                 ss_band_pref,
                                                 ss_lte_band_pref,
                                                 ss_tds_band_pref);
      if( mode_pref == SD_SS_MODE_PREF_NONE)
      {
        return TRUE;
      }
      break;
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_COND_CAP_CDMA_CELL:
      if( sdss_is_supp_mode_band_pref(SD_SS_MODE_PREF_CDMA,
                                      SD_SS_BAND_PREF_CELL) )
      {
        return TRUE;
      }
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_COND_CAP_CDMA_PCS:
      if( sdss_is_supp_mode_band_pref(SD_SS_MODE_PREF_CDMA,
                                      SD_SS_BAND_PREF_PCS) )
      {
        return TRUE;
      }
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_COND_CAP_CDMA_CELL_NO_PCS:
      if( sdss_is_supp_mode_band_pref(SD_SS_MODE_PREF_CDMA,
                                      SD_SS_BAND_PREF_CELL)
                                &&
          ! sdss_is_supp_mode_band_pref(SD_SS_MODE_PREF_CDMA,
                                        SD_SS_BAND_PREF_PCS) )
      {
        return TRUE;
      }
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_COND_CAP_CDMA_PCS_NO_CELL:
      if( sdss_is_supp_mode_band_pref(SD_SS_MODE_PREF_CDMA,
                                      SD_SS_BAND_PREF_PCS)
                                &&
          ! sdss_is_supp_mode_band_pref(SD_SS_MODE_PREF_CDMA,
                                        SD_SS_BAND_PREF_CELL) )
      {
        return TRUE;
      }
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_COND_CDMA_LOCKED:
      return( sdss_is_cdma_locked(eng_ptr->ss) );

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_COND_SRDA:
      if( ss_ptr->is_srda )
      {
        return TRUE;
      }
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_COND_ORIG_MODE_NORM_CNG:

      if( ss_ptr->orig_mode == ss_ptr->orig_mode_prev )
      {
        return TRUE;
      }

      if( (ss_ptr->orig_mode == SD_SS_ORIG_MODE_NONE   ||
           ss_ptr->orig_mode == SD_SS_ORIG_MODE_NORMAL ||
           ss_ptr->orig_mode == SD_SS_ORIG_MODE_COLLOC ||
           ss_ptr->orig_mode == SD_SS_ORIG_MODE_1XCSFB_NORMAL_ORIG ||
           ss_ptr->orig_mode == SD_SS_ORIG_MODE_PPCSFB_NORMAL_ORIG)
                               &&
          (ss_ptr->orig_mode_prev == SD_SS_ORIG_MODE_NONE   ||
           ss_ptr->orig_mode_prev == SD_SS_ORIG_MODE_NORMAL ||
           ss_ptr->orig_mode_prev == SD_SS_ORIG_MODE_COLLOC ||
           ss_ptr->orig_mode_prev == SD_SS_ORIG_MODE_1XCSFB_NORMAL_ORIG ||
           ss_ptr->orig_mode_prev == SD_SS_ORIG_MODE_PPCSFB_NORMAL_ORIG) )
      {
        return TRUE;
      }

      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_COND_FEATURE_JCDMA:
      #ifdef FEATURE_JCDMA
        return TRUE;
      #else
        break;
      #endif

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_COND_FEATURE_T53:
      #ifdef FEATURE_T53
        return TRUE;
      #else
        break;
      #endif

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_COND_TRUE_MODE_PREF_GSM:
      #if defined(SD_GSM_SUPPORTED)
      if ( SD_MODE_CONTAIN( sdss_get_true_mode_pref(eng_ptr->ss),
                            BM(SD_MODE_GSM))
         )
      {
        return TRUE;
      }
      #endif
      break;


    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_COND_SRV_DOMAIN_PREF_CS_PS:
      if (( ss_ptr->domain_pref == SD_SS_SRV_DOMAIN_PREF_CS_PS )||
      ( ss_ptr->domain_pref == SD_SS_SRV_DOMAIN_PREF_CS_VOLTE)) /* Extending this isn't needed but keeping it for future use*/
      {
        return TRUE;
      }
      break;

    case SDSSSCR_COND_SRV_DOMAIN_PREF_CS_ONLY:
      if ( ss_ptr->domain_pref == SD_SS_SRV_DOMAIN_PREF_CS_ONLY)
      {
        return TRUE;
      }
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    case SDSSSCR_COND_CAP_3GPP_PREF_3GPP_ONLY:

      /* Get the intersection of the current mode preference, band preference
      ** and the band capability
      ** mode_pref = user settings ^ phone capability
      */
      mode_pref =  sdss_get_supp_mode_pref_mmode(ss_mode_pref,
                                                 ss_band_pref,
                                                 ss_lte_band_pref,
                                                 ss_tds_band_pref);

      /* Check if the mode_pref has any modes other than TGWL
      ** If mode_pref has any non TGWL modes then fail the check or else return
      ** TRUE.
      */
      if ( mode_pref != SD_SS_MODE_PREF_NONE &&
           !(SD_MODE_CONTAIN(mode_pref,~(word)SD_SS_MODE_PREF_TDS_GSM_WCDMA_LTE))
         )
      {
        return TRUE;
      }
      break;
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    case SDSSSCR_COND_CAP_3GPP_PREF_3GPP_TRGT:

      if (sdss_is_target_cap_3gpp_only(eng_ptr->ss))
        {
          return TRUE;
        }

      break;
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    case SDSSSCR_COND_LTE_CONNECTED_MODE:
      if (sdss_is_lte_connected_mode(eng_ptr->ss))
      {
         return TRUE;
      }
      break;


     #if defined ( FEATURE_WRLF_SYSTEM_SEL)
     /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      case SDSSSCR_COND_WCDMA_CONNECTED_MODE:
      if (sdss_is_wcdma_connected_mode(ss))
      {
         return TRUE;
      }
      break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      case SDSSSCR_COND_WCDMA_SUITABLE_SEARCH:
      if (sdss_is_wcdma_connected_mode(ss))
      {
         return TRUE;
      }
      break;
      #endif /* FEATURE_WRLF_SYSTEM_SEL */

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_COND_EHRPD_SR_ENABLED:
       return(sdss_common.is_ehrpd_opt_redial);		

    case SDSSSCR_COND_FEATURE_EOOS_UMTS:
      #ifdef FEATURE_EOOS_UMTS
        return TRUE;
      #else
        return FALSE;
      #endif

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_COND_FEATURE_EOOS:
      #if defined(FEATURE_EOOS)
        #error code not present
#else
        break;
      #endif

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_COND_FALSE:
      return FALSE;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_COND_1X_3GPP_MODE_PREF:
      {
        mode_pref =  sdss_get_supp_mode_pref(ss_mode_pref, ss_band_pref);

        /* Check if there is the TD-SCDMA component in the mode_pref */
        if( SD_MODE_CONTAIN( ss_mode_pref, SD_SS_MODE_PREF_TDS ) )
        {
            if ((ss_tds_band_pref & SD_SS_BAND_PREF_TDS_ANY) != SD_SS_BAND_PREF_NONE)
            {
                mode_pref = SD_MODE_ADD( mode_pref, SD_SS_MODE_PREF_TDS);
            }
         }

        if ( SD_MODE_CONTAIN( mode_pref, SD_SS_MODE_PREF_TDS_GSM_WCDMA_LTE ) &&
             SD_MODE_CONTAIN( mode_pref, SD_SS_MODE_PREF_CDMA ) )
        {
          return TRUE;
        }
      }
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_COND_3GPP_MODE_PREF:

      mode_pref =  sdss_get_supp_mode_pref_mmode(ss_mode_pref,
                                                 ss_band_pref,
                                                 ss_lte_band_pref,
                                                 ss_tds_band_pref);

      if ( SD_MODE_CONTAIN(mode_pref, SD_SS_MODE_PREF_TDS_GSM_WCDMA_LTE) )
      {
        return TRUE;
      }
      break;
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    case SDSSSCR_COND_CAP_HDR_PREF_HDR_ONLY:

      mode_pref =  sdss_get_supp_mode_pref(ss_mode_pref, ss_band_pref);

      if( sdss_is_supp_mode_band_pref(SD_SS_MODE_PREF_HDR,
                                      SD_SS_BAND_PREF_ANY)
          &&
          ( mode_pref == SD_SS_MODE_PREF_HDR )
        )
      {
        return TRUE;
      }
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_COND_NO_HYBR_OPR:

      #ifdef FEATURE_HDR_HYBRID
      return( sdss_is_hybr_pref( eng_ptr->ss, SD_SS_HYBR_PREF_NONE )) ;
      #else
      return TRUE;
      #endif
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_COND_CAP_CDMA_HDR_PREF_CDMA_HDR_INCL:

      mode_pref =  sdss_get_supp_mode_pref(ss_mode_pref, ss_band_pref);

      if( sdss_is_supp_mode_band_pref(SD_SS_MODE_PREF_CDMA_HDR,
                                      SD_SS_BAND_PREF_ANY)
          &&
          ( SD_MODE_CONTAIN( mode_pref, BM(SD_MODE_CDMA)) )
          &&
          ( SD_MODE_CONTAIN( mode_pref, BM(SD_MODE_HDR)) )
        )
      {
        return TRUE;
      }

      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_COND_SIM_DOMAIN_VALID:
      #if defined(SD_GSM_SUPPORTED) || defined(SD_WCDMA_SUPPORTED)
      if(sdss_gw_sim_domain_valid(ss))
        {
          return TRUE;
        }
      #endif
      break;
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_COND_CAMPED_MODE_SET:
      return( sdss_get_camp_mode() == SD_SS_PREF_CAMP_MODE_ON );
      break;

    #ifdef FEATURE_MMODE_DYNAMIC_SV_OPERATION_SWITCH
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_COND_SWITCH_SVLTE:
      return ( sdss_get_sv_opr_act() == SDSS_SV_OPR_ACT_SWITCH_SVLTE );
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    case SDSSSCR_COND_SWITCH_CSFB:
      return ( sdss_get_sv_opr_act() == SDSS_SV_OPR_ACT_SWITCH_CSFB );
      break;

    #endif

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_COND_RLF_DURING_EMERG:
      if (sdss_get_is_RLF_during_emerg(eng_ptr->ss))
      {
         return TRUE;
      }
      break;

     case SDSSSCR_COND_BUF_INT_SRV_LOST:
      return (sdss_common.buffer_int_srv_lost);

     /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    case SDSSSCR_COND_CSG_SEARCH:
      if (ss_ptr->get_net_list_type == SD_NETWORK_LIST_CSG_USER || 
        ss_ptr->get_net_list_type == SD_NETWORK_LIST_CSG_SELECTION_APP ||
        ss_ptr->get_net_list_type == SD_NETWORK_LIST_CSG)
      {
        return TRUE;
      }
      break;
    case SDSSSCR_COND_CSG_SELECTION:
      if(ss_ptr->csg_id != SYS_CSG_ID_INVALID &&
         ss_ptr->csg_rat != SYS_RAT_NONE)
      {
        return TRUE;
      }
      break;
	case SDSSSCR_COND_LTE_EMERG_REDIAL:

      if (cmregprx_check_lte_priority_scan(eng_ptr->ss))
      {
        return TRUE;
      }

    break;

    case SDSSSCR_COND_MAX:
    default:
      SD_ERR_1( "Invalid cond %d",cond);
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If we got here condition is FALSE.
  */
  return FALSE;

} /* sdss_eng_scr_con_is */

/*===========================================================================

FUNCTION sdss_eng_scr_con_acq_mode

DESCRIPTION
  Set the acq mode

DEPENDENCIES
  None.

RETURN VALUE
 DWORD

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean               sdss_eng_scr_con_acq_mode(

        sdss_eng_s_type         *eng_ptr,
            /* Pointer to the SS-script-engine that is associated with the
            ** SS-Script that is being executed.
            */

        sdss_s_type           *ss_ptr,
            /* Pointer to the SS object
            */

        sdss_acq_mode_e_type  acq_mode
            /* The acq_mode to set to
            */
)
/*lint -esym(818, ss_ptr) */
/* Pointer parameter 'ss_ptr' could be declared as pointing to const */
{

  boolean is_acq_mode_processed = FALSE;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( eng_ptr != NULL );
  SD_ASSERT( ss_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( acq_mode, SDSS_ACQ_MODE_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  while( !is_acq_mode_processed )
  {
    switch ( acq_mode )
    {
      case SDSS_ACQ_MODE_PREV:

        if( ss_ptr->last_acq_eng_ptr != NULL )
        {
          eng_ptr->acq_mode =
                  ((sdss_eng_s_type * )ss_ptr->last_acq_eng_ptr)->acq_mode;
        }
        else
        {
          SD_ERR_1( "Invalid acq_mode %d",eng_ptr->con_prm1);
          eng_ptr->acq_mode = SDSS_ACQ_MODE_FULL;
        }
        is_acq_mode_processed = FALSE;
        acq_mode = eng_ptr->acq_mode;
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSS_ACQ_MODE_EOOS_FULL:
      case SDSS_ACQ_MODE_EOOS_FULL2:
      #ifdef FEATURE_EOOS
      #error code not present
#else
        SD_ERR_1( "Invalid acq_mode %d", acq_mode);
        is_acq_mode_processed = TRUE;
        return FALSE;
        #endif
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      case SDSS_ACQ_MODE_EOOS_FULL_RTN:
      case SDSS_ACQ_MODE_EOOS_FULL_RTN2:
        #ifdef FEATURE_EOOS
        #error code not present
#else
        SD_ERR_1( "Invalid acq_mode %d", acq_mode);
        is_acq_mode_processed = TRUE;
        return FALSE;
        #endif

     /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSS_ACQ_MODE_FULL:
      case SDSS_ACQ_MODE_MINI:
      case SDSS_ACQ_MODE_MICRO:
      case SDSS_ACQ_MODE_FULL2:
      case SDSS_ACQ_MODE_MINI2:
      case SDSS_ACQ_MODE_MICRO2:
      case SDSS_ACQ_MODE_DEEP:
      case SDSS_ACQ_MODE_DEEP2:
      case SDSS_ACQ_MODE_SHALLOW:
      case SDSS_ACQ_MODE_SHALLOW2:
      case SDSS_ACQ_MODE_MICRO_ABSR:
      case SDSS_ACQ_MODE_FULL_AOOS:
      case SDSS_ACQ_MODE_FULL_OSR:

        eng_ptr->acq_mode               = acq_mode;
        is_acq_mode_processed = TRUE;
        return TRUE;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSS_ACQ_MODE_HO:
        eng_ptr->acq_mode               = acq_mode;
        is_acq_mode_processed = TRUE;
        return TRUE;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSS_ACQ_MODE_MAX:
      default:

        SD_ERR_1( "Invalid acq_mode %d", acq_mode);
        is_acq_mode_processed = TRUE;
        return FALSE;
    }
  }
  return TRUE;
} /* sdss_eng_scr_con_acq_mode */
/*lint +esym(818, ss_ptr) */

/* <EJECT> */
/*===========================================================================
=============================================================================
====================== MAIN ENGINE PROCESSING ROUTINES ======================
=============================================================================
===========================================================================*/


/*===========================================================================

FUNCTION sdss_eng_event_proc

DESCRIPTION
  Process an SS-Event in the context of the SS-Script that is currently
  associated with the script engine.

DEPENDENCIES
  The SS-Script-engine that is pointed to by eng_ptr must have already been
  initialized with an SS-Script via a call to sdss_eng_init().

RETURN VALUE
  SS-Internal-Action to be taken by the SS-Front-end (through the
  rtrn_iact_ptr).

SIDE EFFECTS
  None.

===========================================================================*/
static  void                  sdss_eng_event_proc(

        sdss_eng_s_type       *eng_ptr,
            /* Pointer to the script engine that is to process the
            ** SS-Event */

        sdss_evt_e_type       event,
            /* SS-Event to process */


        sdss_iact_s_type      *rtrn_iact_ptr
            /* Pointer to a buffer where to place returned internal action */
)
{
  sdss_s_type     *ss_ptr;
  sd_ss_e_type     ss         = SD_SS_MAIN;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( eng_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( event, SDSS_EVT_MAX );
  SD_ASSERT( rtrn_iact_ptr != NULL )

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ss_ptr         = eng_ptr->ss_ptr;
  ss             = eng_ptr->ss;
  eng_ptr->event = event;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Do script processing (as long as instructed to process the next script
  ** construct).
  */
  do
  {
    /* If necessary, parse the next script construct.
    */
    if( eng_ptr->scr_ctrl.ctrl == SDSS_SCR_CTRL_NEXT_CONS )
    {
      /* Skip over any condition script constructs that might be prepended
      ** to the script.
      */
      do
      {
        eng_ptr->scr_con = sdssscr_parser_next( &eng_ptr->parser,
                                                time_get_uptime_secs(),
                                                ss_ptr->scr_ctrl_cnt,
                                                &eng_ptr->con_prm1,
                                                &eng_ptr->con_prm2,
                                                &eng_ptr->con_prm3,
                                                &eng_ptr->con_prm4,
                                                &eng_ptr->con_prm5,
                                                &eng_ptr->con_prm6,
                                                &eng_ptr->con_prm7,
                                                &eng_ptr->con_prm8,
                                                ss);

      } while( SDSSSCR_CON_IS_COND(eng_ptr->scr_con) );
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    switch( eng_ptr->scr_con )
    {

      /* --------------------------------------
      ** List Manipulator SS-Script-Constructs.
      ** --------------------------------------
      */

      case SDSSSCR_CON_CLR:

        /* CLR( LIST ) - Clears the system record list/item LIST.
        */
        sdsr_list_clr( ENG_LIST(eng_ptr->con_prm1) );

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_CPY:

        /* CPY( LIST_TO, LIST_FROM ) - Clear the system record list LIST_TO
        ** and copy all the elements from the system record list LIST_FROM
        ** into the system record list LIST_TO
        */
        sdsr_list_cpy( ENG_LIST(eng_ptr->con_prm1),
                       ENG_LIST(eng_ptr->con_prm2) );

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_DEL:

        /* DEL( LIST, LIST_REF ) - Delete the system records that are
        ** referenced by the system record list LIST_REF from the system
        ** record list LIST.
        */
        sdsr_list_del_list( ENG_LIST(eng_ptr->con_prm1),
                            ENG_LIST(eng_ptr->con_prm2) );

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_DEL_CNT:

        /* DEL_CNT( LIST, START_POS, CNT ) - Delete 'CNT' entries from LIST
        ** starting from START_POS
        */
        sdsr_list_del_list_cnt( ENG_LIST(eng_ptr->con_prm1),
                                (int)eng_ptr->con_prm2,
                                (int)eng_ptr->con_prm3 );


        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_DEL_SYS:

        /* DEL_SYS( LIST, DEL_CAT ) - Delete system records from LIST
        ** according to DEL_CAT.
        */
        sdsr_list_del_sys( eng_ptr->ss,
                           ENG_LIST(eng_ptr->con_prm1),
                           (sdsr_cat_e_type) eng_ptr->con_prm2 );

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_DEL_BAND:

        /* DEL_BAND( LIST, SYS_REF ) - Delete system records from LIST
        ** which have not the same band from the reference sys
        */
        sdsr_list_del_band( ENG_LIST(eng_ptr->con_prm1),
                            ENG_LIST(eng_ptr->con_prm2) );

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


      case SDSSSCR_CON_APP:

        /* APP( LIST_TO, LIST_FROM ) - Append the elements from the system
        ** record list/item LIST_FROM to the end of system record list
        ** LIST_TO. Duplicate elements are not appended.
        */
        sdsr_list_app( ENG_LIST(eng_ptr->con_prm1),
                       ENG_LIST(eng_ptr->con_prm2) );

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_ORDER:

        /* ORDER( LIST, LIST_REF ) - Order the elements of the system record
        ** list LIST according to their order in the reference list LIST_REF.
        */
        sdsr_list_order( ENG_LIST(eng_ptr->con_prm1),
                         ENG_LIST(eng_ptr->con_prm2) );

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_ORDER2:

        /* ORDER2( LIST, LIST_REF, ORDER_CAT ) - Order the elements of the
        ** system record list LIST according to the ORDER_CAT field of the
        ** reference sytem in the list LIST_REF.
        */
        sdsr_list_order2( ENG_LIST(eng_ptr->con_prm1),
                          ENG_LIST(eng_ptr->con_prm2),
                          (sdsr_order_e_type) ENG_LIST(eng_ptr->con_prm3) );

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_SORT:

        /* SORT( LIST, COMP_CAT ) - Sort the system record list LIST
        ** according to the COMP_CAT category.
        */
        sdsr_list_sort( ENG_LIST(eng_ptr->con_prm1),
                        (sdsr_comp_e_type) eng_ptr->con_prm2 );

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_GEO_EXT:

        /* GEO_EXT( LIST, LIST_REF, EXT_CAT ) - Extract systems from the GEO
        ** of LIST_REF[0] (i.e., 1st system on LIST_REF) into LIST according
        ** to the EXT_CAT category.
        */
        sdsr_list_clr( ENG_LIST(eng_ptr->con_prm1) );

        ( void)sdprl_get_info_base(ss,
                                   ENG_LIST(eng_ptr->con_prm2),
                                   0,
                                   ENG_LIST(eng_ptr->con_prm2),
                                   0,
                                   ENG_LIST(eng_ptr->con_prm1),
                                   SDSR_MAX,
                                   SDSR_MAX,
                                   (sdprl_extract_e_type) eng_ptr->con_prm3,
                                   NULL);

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_CREATE_GW_LTD:

        /* CREATE_GW_LTD( LIST ) - create a conterpart GW limited list from
        ** the system record list/item LIST and store in the system record
        ** database
        */
        sdss_sr_list_create( ss, ENG_LIST(eng_ptr->con_prm1) );

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      /* -----------------------------------
      ** List Operator SS-Script-Constructs.
      ** -----------------------------------
      */

      case SDSSSCR_CON_MEAS:

        /* MEAS( LIST, MEAS_MODE, MEAS_TYPE ) - Request a channel strength
        ** measurement of mode MEAS_MODE and type MEAS_TYPE for all the
        ** systems that are referenced by the system record list LIST.
        */
        sdss_eng_scr_con_meas( eng_ptr, event, rtrn_iact_ptr );

        break;


      case SDSSSCR_CON_GET_NET:

        #if defined(SD_GSM_SUPPORTED) || defined(SD_WCDMA_SUPPORTED)
        /* GET_NET - Request to get the available networks
        */
        sdss_eng_scr_con_get_net( ss, eng_ptr, event, rtrn_iact_ptr );
        #endif /* (SD_GSM_SUPPORTED) || (SD_WCDMA_SUPPORTED)  */
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_ACQ:

        /* ACQ( LIST, ACQ_TYPE ) - Step through the system record list LIST
        ** (first to last) and try to acquire systems that are referenced by
        ** LIST and that were not already attempted acquisition since the
        ** last time the NEW_ACQ construct was encountered (and in accordance
        ** with ACQ_TYPE and the current SS-Preference.
        */
        sdss_eng_scr_con_acq( eng_ptr, event, rtrn_iact_ptr );

        break;

      case SDSSSCR_CON_ACQ_TRUE_MODE:

        /* ACQ_TRUE_MODE( LIST, ACQ_TYPE ) - Step through the system record list LIST
        ** (first to last) and try to acquire systems that are referenced by
        ** LIST and that were not already attempted acquisition since the
        ** last time the NEW_ACQ construct was encountered (and in accordance
        ** with ACQ_TYPE and the current SS-Preference.
        **
        ** The difference between SDSSSCR_CON_ACQ and SDSSSCR_CON_ACQ_TRUE_MODE is:
        ** in SDSSSCR_CON_ACQ_TRUE_MODE ss_ptr's true_mode_pref is used instead of
        ** ss_ptr's mode_pref.
        ** This is to enable world mode phones to search for Limited GW
        ** when there is no GW_service.
        */
        sdss_eng_scr_con_acq( eng_ptr, event, rtrn_iact_ptr );

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_ACQ_MODE:

        /* ACQ_MODE( MODE ) - Set the CDMA acquisition mode to MODE.
        */
        SD_ASSERT_ENUM_IS_INRANGE( (sdss_acq_mode_e_type) eng_ptr->con_prm1,
                                   SDSS_ACQ_MODE_MAX );

        (void) sdss_eng_scr_con_acq_mode( eng_ptr, ss_ptr,
                                   (sdss_acq_mode_e_type) eng_ptr->con_prm1 );

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      case SDSSSCR_CON_RESET_GWL_EOOS_PARAMS:

        /* RESET_GWL_EOOS_PARAM - Reset the GWL acq parameters */
        #ifdef FEATURE_EOOS
        #error code not present
#endif
        break;
      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_ACTIVATE_EOOS:
        #ifdef FEATURE_EOOS
        #error code not present
#endif
        break;

      case SDSSSCR_CON_RESET_EOOS_TIMER:
        #ifdef FEATURE_EOOS
        #error code not present
#endif
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      case SDSSSCR_CON_EOOS_PHASE:

        /* EOOS_PHASE( VAL ) - Set EOOS phase value to VAL.
        */
        #ifdef FEATURE_EOOS
        #error code not present
#endif
        break;
      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_NEW_ACQ:

        /* NEW_ACQ - Start a new acquisition by incrementing the
        ** new-acquisition counter.
        **
        ** Note that the ACQ() acquisition constructs only attempts to
        ** acquire system that were not already attempted acquisition since
        ** the last time the NEW_ACQ construct was encountered.
        */
        ss_ptr->new_acq_cnt++;
        if( ss_ptr->new_acq_cnt == NEW_ACQ_MAX(ss) )
        {
          ss_ptr->new_acq_cnt = NEW_ACQ_INIT(ss);
        }
        {
          sdlog_avoid_event_s_type avoid_evt   = {0};
          avoid_evt.avoid_report = (byte)SDLOG_AVOID_REPORT_ACQ_CNT_CHGD;

          event_report_payload(EVENT_SD_AVOIDANCE_LOG,
                               sizeof(sdlog_avoid_event_s_type),
                               &avoid_evt );

          /* Set/Reset flag to avoid_dup_scan */
          #if defined (FEATURE_AVOID_DUP_BAND_SCAN)


          sdss_proc_avoid_dup_scan_per_new_acq(eng_ptr->ss);

          #endif

        }

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_START_TIME:

        /* START_ACQ_TIME - Starts the acquisition timer.
        */
        {
          qword time_now = { 0 };

          time_get_uptime_ms( time_now );

          /* Lint complains about suspicious cast, time_now is of type qword and
          ** we are casting it to uint64 and then taking the modulus of the
          ** resulting number
          */
          /*lint -e740 */

          if( (QW_CVT_Q2N(time_now) % 1000 ) >= 500 )
          /*lint +e740 */
          {
            ss_ptr->acq_start_time = time_get_uptime_secs() + 1;
          }
          else
          {
            ss_ptr->acq_start_time = time_get_uptime_secs();
          }

          SD_MSG_HIGH_3(" Time: time_get_uptime_secs %d , ms: %d, acq_start_time: %d",
                      time_get_uptime_secs(),(QW_CVT_Q2N(time_now) % 1000 ),
                      ss_ptr->acq_start_time );
        }
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_ACQ_ALL:

        /* ACQ_ALL( LIST, ACQ_TYPE ) - Equivalent to the ACQ construct except
        ** that also systems that were already attempted acquisition since
        ** the last time the NEW_ACQ construct was encountered are being
        ** attempted acquisition.
        */
        sdss_eng_scr_con_acq( eng_ptr, event, rtrn_iact_ptr );

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_ACQ_CNT:
      case SDSSSCR_CON_ACQ_AVOID_CNT:
      case SDSSSCR_CON_ACQ_ABSR_CNT:

        /* ACQ_CNT( LIST, ACQ_TYPE, START_POS, CNT ) - Equivalent to the ACQ
        ** construct except that LIST is traversed START_POS to START_POS-1
        ** and acquisition is bounded to CNT elements.
        */
        sdss_eng_scr_con_acq( eng_ptr, event, rtrn_iact_ptr );

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_ACQ_TIME:
      case SDSSSCR_CON_ACQ_TIME_EOOS:
      case SDSSSCR_CON_ACQ_CNT_OR_TIME_EOOS:
        /* ACQ_TIME( LIST, ACQ_TYPE, START_POS, TIME ) - Equivalent to the
        ** ACQ construct except that LIST is traversed START_POS to
        ** START_POS-1 and acquisition is bounded to TIME seconds since the
        ** START_TIME script construct was last encountered.
        */
        sdss_eng_scr_con_acq( eng_ptr, event, rtrn_iact_ptr );

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_ACQ_RX:

        /* ACQ_RX( LIST, ACQ_TYPE, RX ) - Equivalent to he ACQ construct
        ** except that only systems with Rx-power measurement value >= RX
        ** are being attempted acquisition.
        */
        sdss_eng_scr_con_acq( eng_ptr, event, rtrn_iact_ptr );

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_ACQ_PI:

        /* ACQ_PI( LIST, ACQ_TYPE, PI ) - Equivalent to the ACQ construct
        ** except that only systems with pilot measurement value >= PI are
        ** being attempted acquisition.
        */
        sdss_eng_scr_con_acq( eng_ptr, event, rtrn_iact_ptr );

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_ACQ_PI_X:

        /* ACQ_PI_X( LIST, ACQ_TYPE, PI, X ) - Equivalent to the ACQ construct
        ** except that only X tech systems with pilot measurement value >= PI and
        ** all other system present in list are being attempted acquisition.
        */
        sdss_eng_scr_con_acq( eng_ptr, event, rtrn_iact_ptr );

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      case SDSSSCR_CON_ACQ_NETLIST:

        /* ACQ_NETLIST( LIST, ACQ_TYPE, NETLIST ) - Equivalent to the ACQ
        ** construct except that acquistion is issued only when background
        ** service search yields >=1 PLMN.
        */
        sdss_eng_scr_con_acq( eng_ptr, event, rtrn_iact_ptr );

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_SCHED:

        /* SCHED( LIST, ACQ_TYPE, SCHED ) - Schedule the system records that
        ** are referenced by the system record list/item LIST to be attempted
        ** acquisition of type ACQ_TYPE at time points that are specified by
        ** SCHED.
        */
        sdss_eng_scr_con_sched( eng_ptr, SDSSSR_SCHED_COND_UNCONDITIONAL,
                                rtrn_iact_ptr );

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_SCHED_COND:

        /* SCHED_COND( LIST, SCHED, ACQ_TYPE ) - Identical to SCHED(),
        ** except that only schedule systems that are not already on equal or
        ** higher priority reacquisition schedule.
        */
        sdss_eng_scr_con_sched( eng_ptr,SDSSSR_SCHED_COND_NOT_ON_HIGH_SCHED,
                                rtrn_iact_ptr );

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_SCHED_COND2:

        /* SCHED_COND2( LIST, SCHED, ACQ_TYPE, SCHED_COND ) - Identical to SCHED(),
        ** except that only schedule systems that are not already on equal or
        ** higher priority reacquisition schedule than CMP_SCHED.
        */
        sdss_eng_scr_con_sched( eng_ptr,
                                ( sdsssr_sched_cond_e_type) eng_ptr->con_prm4,
                                rtrn_iact_ptr );

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_AVOID:

        /* AVOID( LIST, TIME ) - Mark the system records that are referenced
        ** by the system record list/item LIST to be avoided from any
        ** acquisition attempts for TIME seconds.
        */
        sdss_sr_list_avoid( eng_ptr->ss,
                            ENG_LIST(eng_ptr->con_prm1),
                            eng_ptr->con_prm2,
                            SDSSSCR_SCHED_AVOID );

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_AVOID_COND2:

        /* AVOID_COND2( LIST, NV_ITEM, COND ) - Mark the system records that
        ** are referenced by the system record list/item LIST to be avoided
        ** from any acquisition attempts for TIME seconds or upon a
        ** successful access.
        */
        sdss_sr_list_avoid( eng_ptr->ss,
                            ENG_LIST(eng_ptr->con_prm1),
                            eng_ptr->con_prm2,
                            (sdssscr_sched_e_type) eng_ptr->con_prm3 );
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_AVOID_CANCEL_COND:

        /* AVOID_CANCEL_COND( LIST, COND ) - Remove the avoidance placed on
        ** systems that are referenced by LIST and have been avoided till
        ** condition COND is met.
        ** AVOID_CANCEL( LIST ) - Same as above, with COND equal to
        ** CANCEL_ALL.
        */
        sdss_sr_list_avoid( eng_ptr->ss,
                            ENG_LIST(eng_ptr->con_prm1),
                            0,
                            (sdssscr_sched_e_type) eng_ptr->con_prm2 );

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_AVOID_COND:

        /* AVOID_COND( LIST, TIME, COND ) - Mark the system records that are
        ** referenced by the system record list/item LIST to be avoided from
        ** any acquisition attempts for TIME seconds or until the condition
        ** is met whichever comes first.
        */
        sdss_sr_list_avoid( eng_ptr->ss,
                            ENG_LIST(eng_ptr->con_prm1),
                            eng_ptr->con_prm2,
                            (sdssscr_sched_e_type) eng_ptr->con_prm4 );

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      /* -----------------------------
      ** SS-Script Control Constructs.
      ** -----------------------------
      */

      case SDSSSCR_CON_LOOP_TIME:
      case SDSSSCR_CON_LOOP_TIME_EOOS:

        /* LOOP_TIME( TIME ) - Repeat executing the script between this
        ** construct and the matching LOOP construct for TIME seconds since
        ** this construct was first encountered.
        */
        SD_ERR_0( "SDSSSCR_CON_LOOP_TIME");

        break;

      case SDSSSCR_CON_LOOP_TIME_TEMP_GSRDM:

      /* LOOP_TIME_TEMP_GSRDM( LIST, NV_ITEM1, NV_ITEM2 ) - Repeat
      **  executing the script  between this construct and the matching LOOP
      ** construct for x seconds since this construct was first encountered.
      ** where X is dependent upon the max of the temp avoided timers
      */
      SD_ERR_0( "SDSSSCR_CON_LOOP_TIME_TEMP_GSRDM");

      break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_LOOP_TIME_CFG:

        /* LOOP_TIME_CFG(CFG_ITEM) - Repeat executing the script between this
        ** construct and the matching LOOP construct for duration stored in
        ** EFS item CFG_ITEM
        */
        SD_ERR_0( "SDSSSCR_CON_LOOP_TIME_CFG");
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_LOOP_TIME2:

        /* LOOP_TIME2(NV_ITEM) - Repeat executing the script between this
        ** construct and the matching LOOP construct for duration stored in
        ** NV item NV_ITEM
        */
        SD_ERR_0( "SDSSSCR_CON_LOOP_TIME2");
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_LOOP_NUM:
      case SDSSSCR_CON_LOOP_NUM_CFG:

        /* LOOP_NUM( NUM ) - Repeat executing the script between this
        ** construct and the matching LOOP construct for NUM times.
        */
        SD_ERR_0( "SDSSSCR_CON_LOOP_NUM");

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_LOOP_LIST:

        /* LOOP_LIST( LIST ) - Repeat executing the script between this
        ** construct and the matching LOOP construct for count(LIST) times.
        */
        SD_ERR_0( "SDSSSCR_CON_LOOP_LIST");

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_LOOP_COND:

        /* LOOP_COND - Repeat executing the script between this construct
        ** and the matching LOOP construct until the COND is TRUE.
        */
        SD_ERR_0( "SDSSSCR_CON_LOOP_COND");

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


      case SDSSSCR_CON_LOOP_FOREVER:

        /* LOOP_FOREVER - Repeat executing the script between this construct
        ** and the matching LOOP construct forever.
        */
        SD_ERR_0( "SDSSSCR_CON_LOOP_FOREVER");

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_LOOP:

        /* LOOP - Loop-back to the matching LOOP_XXX construct.
        */
        SD_ERR_0( "SDSSSCR_CON_LOOP");

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_PREV_SCR:

        /* PREV_SCR - Return to perviously active SS-Script and continue with
        ** that script execution.
        */
        eng_ptr->scr_ctrl.ctrl = SDSS_SCR_CTRL_PREV_SCR;

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_PROC_EVT:

        /* PROC_EVT( SS_EVENT ) - Process the SS_EVENT SS-Event.
        */
        sdss_eng_scr_con_proc_evt( eng_ptr, rtrn_iact_ptr );

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_ACT_SCR:

        /* ACT_SCR( SCRIPT ) - Make the script that is referenced SCRIPT the
        ** active SS-Script.
        */
        sdss_eng_scr_con_act_scr( eng_ptr, rtrn_iact_ptr );

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_ACT_SCR_RX:

        /* ACT_SCR_RX( SCRIPT, LIST, RX ) - Make SCRIPT the active System
        ** Selection Script only if at least one of the systems that are
        ** referenced by the system record list LIST has an Rx-power
        ** measurement value >= RX.
        */
        sdss_eng_scr_con_act_meas( eng_ptr, rtrn_iact_ptr );

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_ACT_SCR_PI:

        /* ACT_SCR_PI( SCRIPT, LIST, PI ) - Make SCRIPT the active System
        ** Selection Script only if at least one of the systems that are
        ** referenced by system record list LIST has a pilot measurement
        ** value >= PI.
        */
        sdss_eng_scr_con_act_meas( eng_ptr, rtrn_iact_ptr );

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_IF:
      case SDSSSCR_CON_NEST_IF:

        /* Beginning of IF block
        */
        SD_ERR_0( "SDSSSCR_CON_IF");

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_ELSE:
      case SDSSSCR_CON_NEST_ELSE:


        /* Beginning of ELSE block
        */
        SD_ERR_0( "SDSSSCR_CON_ELSE");

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_ENDIF:
      case SDSSSCR_CON_NEST_ENDIF:

        /* End of IF block
        */
        SD_ERR_0( "SDSSSCR_CON_ENDIF");

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_END:

        /* END - Mark the end of an SS-Script. Under normal situation this
        ** script construct should never be reached.
        */
        //SD_ERR_FATAL_0( "SCR_CON_END");
        SD_ASSERT( FALSE );
        SD_ERR_2( "=SD= CON_END, evt=%d, ss=%d",event,ss);

        /* If no further error recovery should be performed, return the
        ** SS-Action set up by the error recovery function. Else, process the
        ** alternate SS-Event set by the error recovery function.
        */
        if( ! sdss_event_recovery(ss, &event, rtrn_iact_ptr) )
        {
          eng_ptr->scr_ctrl.ctrl = SDSS_SCR_CTRL_RTRN_ACT;
        }
        else
        {
          eng_ptr->scr_ctrl.ctrl = SDSS_SCR_CTRL_PROC_EVT;
          eng_ptr->scr_ctrl.prm.proc.event  = event;
        }

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


      /* -----------------------------------
      ** Miscellaneous SS-Script-Constructs.
      ** -----------------------------------
      */
      case SDSSSCR_CON_CONT:

        /* CONT( TIME_HI, TIME_LO ) - Instructs the SS-Client to continue
        ** with its current activity while setting-up a TIME timer. When this
        ** timer expires the SS-Client shall call on the SD_SS_IND_MISC_TIMER
        ** SS-Indication function.
        */
        sdss_eng_scr_con_cont( eng_ptr, event, rtrn_iact_ptr );

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_CONT_REDIR:

        /* CONT_REDIR( TIME ) - Conditionally stops script execution and
        ** instructs the SS-Client to continue until TIME seconds passed
        ** since the most recent redirection indication was received.
        */
        sdss_eng_scr_con_cont( eng_ptr, event, rtrn_iact_ptr );

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_CONT2:

        /* CONT2( NV_ITEM ) - Instructs the SS-Client to continue with its
        ** current activity while setting-up a TIME second timer. When this
        ** timer expires the SS-Client shall call on the SD_SS_IND_MISC_TIMER
        ** SS-Indication function. Where TIME is the value stored in the
        ** configurable items table at index SDSS_NV_ITEM_"NV_ITEM".
        */
        sdss_eng_scr_con_cont( eng_ptr, event, rtrn_iact_ptr );

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_CONT3:

        /* CONT3( EFS_ITEM ) - Instructs the SS-Client to continue with its
        ** current activity while setting-up a TIME second timer. When this
        ** timer expires the SS-Client shall call on the SD_SS_IND_MISC_TIMER
        ** SS-Indication function. Where TIME is the value stored in the
        ** configurable items table at index SDSSSCR_EFS_ITEM_"EFS_ITEM".
        */
        sdss_eng_scr_con_cont( eng_ptr, event, rtrn_iact_ptr );

        break;


      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      case SDSSSCR_CON_CONT_EOOS_SLEEP:

        #ifdef FEATURE_EOOS
        #error code not present
#endif
        break;
      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_CONT2_REDIR:

        /* CONT2_REDIR( NV_ITEM) - Conditionally stops script execution and
        ** instructs the SS-Client to continue until TIME seconds passed
        ** since the most recent redirection indication was received. If
        ** instructs SS-Client to continue, sets a timer for the appropriate
        ** duration. Where TIME is the value stored in the configurable items
        ** table at index SDSS_NV_ITEM_"NV_ITEM".
        */
        sdss_eng_scr_con_cont( eng_ptr, event, rtrn_iact_ptr );

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_CONT2_WAIT:

        /* CONT2_WAIT( NV_ITEM ) - Instructs the SS-Client to continue with
        ** its current activity if a TYPE specific timer does not expires.
        ** When this timer expires the SS-Client shall call on the
        ** SD_SS_IND_MISC_TIMER SS-Indication function.
        */
        sdss_eng_scr_con_cont( eng_ptr, event, rtrn_iact_ptr );

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_CONT3_WAIT:

        /* CONT3_WAIT( TYPE1, NV_ITEM1, TYPE2, NV_ITEM2) - Instructs the
        ** SS-Client to continue with its current activity if either a TYPE1
        ** or a TYPE2 specific timer does not expires. When this timer expires
        ** the SS-Client shall call on the SD_SS_IND_MISC_TIMER SS-Indication
        ** function.
        */
        sdss_eng_scr_con_cont( eng_ptr, event, rtrn_iact_ptr );

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_CONT_ABSR:

        /* CONT_ABSR( NV_ITEM1, NV_ITEM2) - Instructs the SS-Client to
        ** continue with its current activity until timer expires. When this
        ** timer expires the SS-Client shall call on the SD_SS_IND_MISC_TIMER
        ** SS-Indication function.
        */
        sdss_eng_scr_con_cont( eng_ptr, event, rtrn_iact_ptr );

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_CONT_SET:

        /* CONT_WAIT_SET( TIME ) - Set the start time.
        */
        sdss_eng_scr_con_cont_set( eng_ptr );

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_MAINTAIN_TIMER:

        /* MAINTAIN_TIMER - Maintain the timer
        */
        eng_ptr->scr_timer = sd_ss_get_timer(eng_ptr->ss);
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_MAINTAIN_PREV_SCR_TIMER:

        /* MAINTAIN_PREV_SCR_TIMER - Maintain the previous script timer
        */
        eng_ptr->scr_timer = ss_ptr->eng_scr_timer;
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_SET_TIMER:

        /* SET_TIMER( NV_ITEM, TMR_ADJ ) - Set the timer to prm 1 - prm
        */
      /* this code will be used in the eoos
        if( eng_ptr->con_prm2 == SDSSSCR_NV_ITEM_TMR_CONN_MODE_UOOS_SCAN )
        {
          eng_ptr->scr_timer = time_get_uptime_secs() + eng_ptr->con_prm1 -
                               ( ss_ptr->rem_uoos_awake_time / 1000 );
        }
        else
        {
          eng_ptr->scr_timer = time_get_uptime_secs() + eng_ptr->con_prm1 -
                                                           eng_ptr->con_prm2;
        }
        ss_ptr->eng_scr_timer = eng_ptr->scr_timer;
      */
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_CONT_BSR:

        /* CONT_BSR( TIME_HI, TIME_LO ) - Instructs the SS-Client to continue
        ** with its current activity while setting-up a TIME timer. When this
        ** timer expires the SS-Client shall call on the SD_SS_IND_MISC_TIMER
        ** SS-Indication function.
        ** If phone is on the last system on which this timer was started, timer
        ** shall continue, otherwise timer with value specified will be started.
        */
        sdss_eng_scr_con_cont( eng_ptr, event, rtrn_iact_ptr );

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_CONT2_BSR:

        /* CONT2_BSR( NV_ITEM ) - Instructs the SS-Client to continue with its
        ** current activity while setting-up a TIME second timer. When this
        ** timer expires the SS-Client shall call on the SD_SS_IND_MISC_TIMER
        ** SS-Indication function. Where TIME is the value stored in the
        ** configurable items table at index SDSS_NV_ITEM_"NV_ITEM".
         ** If phone is on the last system on which this timer was started, timer
        ** shall continue, otherwise timer with value specified will bestarted.
        */
        sdss_eng_scr_con_cont( eng_ptr, event, rtrn_iact_ptr );

        break;

      case SDSSSCR_CON_CONT3_BSR:

        /* CONT3_BSR( EFS_ITEM ) - Instructs the SS-Client to continue with its
        ** current activity while setting-up a TIME second timer. When this
        ** timer expires the SS-Client shall call on the SD_SS_IND_MISC_TIMER
        ** SS-Indication function. Where TIME is the value stored in the
        ** configurable items table at index SDSS_EFS_ITEM_"EFS_ITEM".
         ** If phone is on the last system on which this timer was started, timer
        ** shall continue, otherwise timer with value specified will bestarted.
        */
        sdss_eng_scr_con_cont( eng_ptr, event, rtrn_iact_ptr );

        break;

      case SDSSSCR_CON_CONT_TELE_BSR:
      case SDSSSCR_CON_CONT_LONG_BSR:
        sdss_eng_scr_con_cont( eng_ptr, event, rtrn_iact_ptr );

        break;

      case SDSSSCR_CON_RESET_TELE_BSR_TIMER:
        /* Reset LTE tele BSR parameters when move from LTE not avail to LTE avail */
        sdss_lte_telescope_parm_reset(ss);
        break;

      case SDSSSCR_CON_ACCEPT:

        /* ACCEPT- Accept BS proposed mode, band and/or CDMA channel/AMPS
        ** system. This SS-Action is only valid for Redirection, Channel
        ** Assignment or Handoff Direction.
        */
        sdss_eng_scr_acpt_rej( eng_ptr, event, rtrn_iact_ptr );

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_REJECT:

        /* REJECT- Reject BS proposed mode, band and/or CDMA channel/AMPS
        ** system. This SS-Action is only valid for Redirection, Channel
        ** Assignment or Handoff Direction.
        */
        sdss_eng_scr_acpt_rej( eng_ptr, event, rtrn_iact_ptr );

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_PWR_SAVE:

        /* PWR_SAVE - Instruct the SS-Client to enter Power-Save mode of
        ** operation. Once entering Power-Save mode of operation, the
        ** SS-Client should call on the SD_SS_IND_MISC_PWR_SAVE_ENTER
        ** SS-Indication function.
        */
        sdss_eng_scr_con_pwr_save( eng_ptr, event, rtrn_iact_ptr );

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_REDIR_OFF:

        /* REDIR_OFF - Set the redirection indication to disabled.
        */
        sdss_redir_update(
            ss,
            SD_SS_REDIR_NONE,             /* Set redirection to none */
            FALSE,                        /* Set valid redirection to FALSE*/
            SD_WILDCARD_SID,              /* Set expected SID to wildcard */
            SD_WILDCARD_NID,              /* Set expected NID to wildcard */
            FALSE,                        /* Set RETURN_IF_FAIL to FALSE */
            FALSE,                        /* Set IGNORE_CDMA to FALSE */
            SD_SS_MAX_REDIR_DELAY_NONE ); /* Set max redirect delay to none*/

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_HO_OFF:

        /* HO_OFF - Set the handoff indication to disabled.
        */
        sdss_ho_update( ss, SD_SS_HO_NONE );

        break;
      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_EXIT_EMERG_CB:

        /* EXIT_EMERG_CB - exit from emergency callback mode
        */
        sd_si_emerg_cb_mode(SD_EMERG_CB_MODE_EXIT);
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_RESET_GW_ACQ_SCAN_STATUS:

        /* RESET_GW_ACQ_SCAN_STATUS - Set the power up acqusition to OFF.
        */
        ss_ptr->acq_gwl_scan_status = SD_SS_GWL_SCAN_STATUS_NONE;

        break;

      case SDSSSCR_CON_RESET_EMERG_DUP_BAND:
        #ifdef FEATURE_AVOID_DUP_BAND_SCAN
        /* RESET_EMERG_DUP_BAND reset emergency avoid dup band info */
        sdss_reset_emerg_band_to_avoid(ss);
        #endif
        break;
       /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_CON_RESET_OPERATOR_CAPABILITY:

        /* RESET_OPERATOR_CAPABILITY - Set the operator capability to any.
            */
        ss_ptr->operator_capability = SD_SS_MODE_PREF_ANY;

        break;

    case SDSSSCR_CON_TOGGLE_SCAN_SCOPE:

        /* TOGGLE_SCAN_SCOPE  - Toggle the search scan scope.
        */
        sdss_toggle_scan_scope_type(ss);

        break;


      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_ACQ_FAIL:

        /* Indicate that acquisition over all systems has failed. */
       sdss_eng_scr_con_acq_fail (ss);
        break;

		
	  case SDSSSCR_CON_CS_EMERG_SCAN_FAIL:

        /* Indicate that acquisition over all systems has failed. */
        sdss_eng_scr_con_cs_emerg_fail (ss);
      break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_HYBR_BSR_TO_HDR:
        sdss_eng_scr_con_hybr_bsr_to_hdr(ss, (sdss_bsr_to_hdr_e_type)eng_ptr->con_prm1);
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      case SDSSSCR_CON_KICK_HYBR2:
        sdss_eng_scr_con_kick_hybr2(ss);
        break;


      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_STACK_SYNC_UP:

        /* Indicate that service is lost. */
        sd_si_srv_lost_cb( ss );
        break;

      case SDSSSCR_CON_FULL_SRV_LOST:

        /* Indicate that full service is lost. */
        sd_si_full_srv_lost_cb( ss );

        break;
      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_CON_RESET_RLF:

      /* RESET_RLF - exit from connected mode
      */
      #if defined ( FEATURE_WRLF_SYSTEM_SEL)
      if (sdss_is_wcdma_connected_mode (ss))
      {
        sdss_reset_wcdma_connected_mode (ss);
      }
      #endif
      if (sdss_is_lte_connected_mode (ss))
      {
        sdss_reset_lte_connected_mode (ss);
      }

      break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      case SDSSSCR_CON_SRV_STATUS:

        /* SRV_STATUS( VAL ) - Set the Service-Indication to VAL.
        */
        switch ( (sys_srv_status_e_type)eng_ptr->con_prm1 )
        {
          case SYS_SRV_STATUS_NO_SRV:
            sd_si_srv_off( ss, TRUE );
            break;

          case SYS_SRV_STATUS_PWR_SAVE:
            sd_si_srv_pwr_save( ss );
            break;

          case SYS_SRV_STATUS_SRV:
          case SYS_SRV_STATUS_LIMITED:
          case SYS_SRV_STATUS_NONE:
          case SYS_SRV_STATUS_LIMITED_REGIONAL:
          case SYS_SRV_STATUS_MAX:
          default:
            SD_ERR_0("Incorrect VAL");
            break;
        }
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_CHK_SET_SRV_STATUS:

        {
          sys_srv_status_e_type ss_srv_status;
          sdss_read_srv_status( ss, &ss_srv_status, NULL );
          if( SD_IS_BIT_CONTAIN( BM(ss_srv_status), eng_ptr->con_prm1 ) )
          {
            switch ( (sys_srv_status_e_type)eng_ptr->con_prm2 )
            {
              case SYS_SRV_STATUS_NO_SRV:
                SD_MSG_HIGH_0( "Internal service lost");
                sd_si_srv_off( ss, TRUE );
                break;

              case SYS_SRV_STATUS_PWR_SAVE:
                sd_si_srv_pwr_save( ss );
                break;

              case SYS_SRV_STATUS_SRV:
              case SYS_SRV_STATUS_LIMITED:
              case SYS_SRV_STATUS_NONE:
              case SYS_SRV_STATUS_LIMITED_REGIONAL:
              case SYS_SRV_STATUS_MAX:
              default:
                SD_ERR_0("Incorrect VAL");
                break;

            }/* switch */
          }/* if( SD_IS_BIT_CONTAIN ... */
        }

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_SRV_OFF_UNTIL:

        /* SRV_OFF_UNTIL( CRIT ) - Set the Service Indication to OFF. Do not
        ** update the service indicators before the specified criteria is
        ** met.
        */
        sd_si_srv_off_until( ss, (sd_si_update_e_type) eng_ptr->con_prm1 );

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_RESEL_STT:

        /* RESEL_STT( STATE ) - Set the Reselection State to STATE.
        */
        if(ss_ptr->resel_state != (sdss_resel_stt_e_type) eng_ptr->con_prm1)
        {
          SD_MSG_HIGH_2("Resel STT %d , SS: %d", eng_ptr->con_prm1, ss);
          sdss_resel_state_update( ss, ss_ptr,
                                 (sdss_resel_stt_e_type) eng_ptr->con_prm1 );

          sdss_cdma_bsr_in_progress(ss,(sdss_resel_stt_e_type) eng_ptr->con_prm1 );
        }
		
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_RESEL_MODE:

        /* RESEL_MODE( MODE ) - Set the Reselection Mode to MODE.
        */
        sdss_resel_mode_update( ss_ptr,
                                (sdss_resel_mode_e_type) eng_ptr->con_prm1 );
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


      case SDSSSCR_CON_SET_FLAG:

        /* SET_FLAG( FLAG, SET_VAL ) - Set the FLAG to SET_VAL.
        */
        sdss_set_flag( eng_ptr->ss,
                       (sdss_flag_e_type) eng_ptr->con_prm1,
                       (boolean) eng_ptr->con_prm2 );
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      case SDSSSCR_CON_SET_FLAG2:

        /* SET_FLAG2( SS, FLAG, SET_VAL ) - Set the FLAG to SET_VAL.
        */
        sdss_set_flag( (sd_ss_e_type) eng_ptr->con_prm1,
                       (sdss_flag_e_type) eng_ptr->con_prm2,
                       (boolean) eng_ptr->con_prm3 );
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      case SDSSSCR_CON_SRV_REQ:
        /* SRV_REQ_TYPE( VAL ) - Set the srv_req_type parameter
                                 in ss_ptr to VAL.
        */
        sdss_set_srv_req_type( eng_ptr->ss,
                               (sd_ss_srv_req_type_e_type) eng_ptr->con_prm1);
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_SCAN_SCOPE:
        /* SCAN_SCOPE_TYPE( VAL ) - Set the scan scope type parameter
                                 in ss_ptr to VAL.
        */
        sdss_set_scan_scope_type( eng_ptr->ss,
                                 (sys_scan_scope_e_type) eng_ptr->con_prm1);
        break;

      case SDSSSCR_CON_GET_SCAN_SCOPE_RULE:
        /* SCAN_SCOPE_TYPE( VAL ) - Set the scan scope type parameter
                                 in ss_ptr to VAL.
        */
        sdss_set_scan_scope_type( eng_ptr->ss,
                                 (sys_scan_scope_e_type) eng_ptr->con_prm1);
        break;

      case SDSSSCR_CON_SET_GW_PWR_SAVE_ACQ_STAGE:
        /* SET_GW_PWR_SAVE_ACQ_STAGE(STAGE) Set stage value
        */
        #ifdef FEATURE_EOOS
        #error code not present
#endif
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      case SDSSSCR_CON_BSR_TIMER_RESET:
      /* Reset BSR timer */
      ss_ptr->bsr_timer = 0;
      break;
      /* check if 1x BSR completed and set the flag accordingly
      */
      case SDSSSCR_CON_CHK_SET_EXTEND_1X_BSR:
      /* if all the compliant (non avoidance) systems in the BSR scan list has not been exhausted, extend the timer by 10s.
      ** This happens if the BSR doesnt complete in 10s. In such a case, the next BSR should happen
      ** 10s later and the remaining entries in the BSR list should get scanned.
      */
      { 
        int i = 0; 
        int cnt = 0; 
        int cmp_acq_cnt = 0;
        sdsr_s_type * sr_ptr = NULL;

        // initialize value of extend_bsr_timer
        ss_ptr->is_extend_1x_bsr_timer = FALSE;

        // this is only required for 1x on MAIN stack.
        if (ss != SD_SS_MAIN)
        {
          break;
        }

        /* check all the 1x systems in the srv pref list that are eligible for
        ** acquisition. If all these systems have acq_cnt equal to ss_ptr->new_acq_cnt
        ** no need to extend the 1x BSR timer. 
        */
        sdsr_list_cpy(SDSR_BACKUP_LST, SDSR_SRV_PREF_LST);
        sdsr_list_del_sys(SD_SS_MAIN, SDSR_BACKUP_LST, SDSR_CAT_NON_CDMA);
        sdsr_list_del_sys(SD_SS_MAIN, SDSR_BACKUP_LST, SDSR_CAT_AVOIDED_SYS);
        sdsr_list_del_sys(SD_SS_MAIN, SDSR_BACKUP_LST, SDSR_CAT_NON_COMPLY);
        sr_ptr=sdsr_list_get_ptr(SDSR_BACKUP_LST, 0);
       	if(sr_ptr != NULL)
       	{
           cmp_acq_cnt = ss_ptr->new_acq_cnt;
           /* Check all the systems in the list to see if they have the same value for new acq cnt
           ** If any system does not have the same value, it implies that that they have not been scanned
           ** and the current BSR stage needs to be extended by 10s to allow the attempt to complete
           */ 
           for( i=0; (sr_ptr=sdsr_list_get_ptr(SDSR_BACKUP_LST, i)) != NULL; i++ )
           {
             if (sr_ptr->new_acq_cnt == cmp_acq_cnt) 
             {
               cnt++;
             }
             else
             {
               SD_MSG_HIGH_3("list pos %d cnt %d, cmp_value %d",i, sr_ptr->new_acq_cnt,cmp_acq_cnt);
             }
           }
           if ( cnt != sdsr_list_cnt(SDSR_BACKUP_LST))
           {
             SD_MSG_HIGH_0("Extend 1xBSR timer");
             ss_ptr->is_extend_1x_bsr_timer = TRUE;
           }
       	}
      }
      break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      /* check main and HDR srv status and reset hybr2 bsr flag
      */
      case SDSSSCR_CON_CHK_RESET_HYBR2_BSR:

        {
          sd_si_info_s_type       *si_info_ptr     = NULL;
          boolean                  early_exit = FALSE;

          /* allocate memory for si_info */
          si_info_ptr = modem_mem_alloc(sizeof(sd_si_info_s_type), MODEM_MEM_CLIENT_MMODE);
        
          if(si_info_ptr == NULL)
          {
            SD_ERR_FATAL_0("Can't allocate the memory for si_info_ptr");
            break;
          }
          else
          {
            memset(si_info_ptr,0, sizeof(sd_si_info_s_type));
          }
  
          sd_si_info_ptr_get( SD_SS_MAIN, si_info_ptr );
          /* Do not reset the HYDBR2 BSR flag   
          ** If 1X is in OPR state or
          ** in reselection states
          */
          if( sys_srv_status_is_srv(si_info_ptr->srv_status ) &&
              si_info_ptr->mode == SD_MODE_CDMA &&              
            ( sd_get_ss_state(SD_SS_MAIN) == SDSS_STATE_OPR || 
              sdss_ptr(SD_SS_MAIN)->resel_state != SDSS_RESEL_STT_NONE) )
          {
             SD_MSG_HIGH_3("SCSVLTE:BSR due to 1x ss_state %d"
                           " resel_state %d mode %d ",
                           sd_get_ss_state(SD_SS_MAIN),
                           sdss_ptr(SD_SS_MAIN)->resel_state,
                           si_info_ptr->mode);
             early_exit = TRUE;
          }
          else if( sdss_is_sys_lost( sdss_ptr(SD_SS_MAIN),SD_SS_SYS_LOST_NO_RESOURCES)
              && sdss_is_sfmode_1x_srlte(SYS_MODEM_AS_ID_1)
              && sdss_common.sd_scan_scope_rule & SYS_SCAN_SCOPE_RULE_ACQ_DB_NO_TRM)
          {
            SD_MSG_HIGH_0("SCSVLTE:BSR due to 1x");
            early_exit = TRUE;
          }
         
          /* Check if HDR is full srv or HDR deactivated due to GWL acq on Hybr2 */
          sd_si_info_ptr_get( SD_SS_HYBR_1, si_info_ptr );
          if((( sys_srv_status_is_srv(si_info_ptr->srv_status )&&
                (sd_get_ss_state(SD_SS_HYBR_1) == SDSS_STATE_OPR)
              ) || 
             sdss_is_flag_set(SD_SS_HYBR_2, SDSS_FLAG_HDR_DEACT_BY_HYBR2_BSR)
            ) && !early_exit)
          {
            SD_MSG_HIGH_0("SCSVLTE:BSR due to HDR");
            early_exit = TRUE;
          }
          if(sdss_is_flag_set(ss,SDSS_FLAG_HYBR_HDR_IRAT ) && !early_exit)
          {
            SD_MSG_HIGH_0("SCSVLTE:BSR due to IRAT");
            early_exit = TRUE;
          }

          modem_mem_free(si_info_ptr, MODEM_MEM_CLIENT_MMODE);

          if (early_exit)
          {
            break;
          }
        }
        /* If we got here, HYBR2 BSR flag should not be set
        */
        if ( sdss_is_flag_set(SD_SS_HYBR_2,SDSS_FLAG_HYBR2_BSR)) 
        {
          /* If there is no 1x or HDR service , reset BSR flag 
          */
          sdss_set_flag(SD_SS_HYBR_2,SDSS_FLAG_HYBR2_BSR, FALSE);
          SD_MSG_HIGH_0("reset hybr2_bsr");
        }
      break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      case SDSSSCR_CON_CHK_MODE_PREF_SET_SRV_STATUS:
        {
          sd_ss_mode_pref_e_type     ss_mode_pref    = SD_SS_MODE_PREF_NONE;

          sdss_get_mode_band_pref( ss,
                                   &ss_mode_pref,
                                   NULL,
                                   NULL,
                                   NULL );

          if(ss_mode_pref == (sd_ss_mode_pref_e_type)eng_ptr->con_prm1)
          {
            switch ( (sys_srv_status_e_type)eng_ptr->con_prm2 )
            {
              case SYS_SRV_STATUS_NO_SRV:
                SD_MSG_HIGH_0( "Internal service lost");
                sd_si_srv_off( ss, TRUE );
                break;

              case SYS_SRV_STATUS_PWR_SAVE:
              case SYS_SRV_STATUS_SRV:
              case SYS_SRV_STATUS_LIMITED:
              case SYS_SRV_STATUS_NONE:
              case SYS_SRV_STATUS_LIMITED_REGIONAL:
              case SYS_SRV_STATUS_MAX:
              default:
                SD_ERR_0("Incorrect VAL");
                break;
            }/* switch */
          }/* if((ss_ptr->mode_pref == ... */
        }
      break;
      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      case SDSSSCR_CON_SET_SKIP_PREF_SCAN_FLAG:
        ss_ptr->is_skip_1x_pref_scan = (boolean)eng_ptr->con_prm1;
        ss_ptr->is_skip_lte_pref_scan = (boolean)eng_ptr->con_prm1;
        break;
      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      case SDSSSCR_CON_BSR_EVENT:
        if(ss == SD_SS_HYBR_2)
        {
          sdss_bsr_log_rpt((sdss_bsr_log_event_e_type)eng_ptr->con_prm1);
        }

        break;
      case SDSSSCR_CON_OPT_SR_HDR_ACQ_FAIL:

        /* Indicate that acquisition over all systems has failed. */
        sd_si_opt_sr_hdr_acq_fail ();
        break;

      case SDSSSCR_CON_RESET_1X_BSR_STAGE:
      {

        ss_ptr->telescope_bsr_current_loop_1x = 1;
        #ifndef FEATURE_MMSS_3_1
           sdss_resel_mode_update( ss_ptr, SDSS_RESEL_MODE_STAGE1);
        #endif
        break;
      }
	  
	  case SDSSSCR_CON_SET_MAPE:

        /* SET_MAPE( SYS,IS_MAPE  ) - Mark the system which received mape error
        */
        sdss_sr_set_mape( 
                            ENG_LIST(eng_ptr->con_prm1),
                            (boolean)eng_ptr->con_prm2
                             );

      break;

      case SDSSSCR_CON_INC_SIB8_LOOP_NUM:
        if(ss == SD_SS_MAIN)
        {
          sdss_ptr(ss)->loop_num_1xsib8_scan++;
        }
        break;

      case SDSSSCR_CON_1ST_COND:
      case SDSSSCR_CON_IS:
      case SDSSSCR_CON_IS_NOT:
      case SDSSSCR_CON_IS_EVENT:
      case SDSSSCR_CON_IS_OPR_MODE:
      case SDSSSCR_CON_IS_FLAG_SET:
      case SDSSSCR_CON_IS_PREF_REAS:
      case SDSSSCR_CON_IS_ORIG_MODE:
      case SDSSSCR_CON_IS_PREV_ORIG_MODE:
      case SDSSSCR_CON_IS_STATE:
      case SDSSSCR_CON_IS_ACQ_STATE:
      case SDSSSCR_CON_IS_ACQ_TYPE:
      case SDSSSCR_CON_IS_REDIR:
      case SDSSSCR_CON_IS_HANDOFF:
      case SDSSSCR_CON_IS_RESEL_STT:
      case SDSSSCR_CON_IS_RESEL_MODE:
      case SDSSSCR_CON_IS_SRV_STATUS:
      case SDSSSCR_CON_IS_SRV_DOMAIN:
      case SDSSSCR_CON_IS_ACC_REAS:
      case SDSSSCR_CON_IS_ACC_TERM:
      case SDSSSCR_CON_IS_ACC_FAIL:
      case SDSSSCR_CON_IS_EVENT_CNT:
      case SDSSSCR_CON_IS_SID:
      case SDSSSCR_CON_IS_MODE:
      case SDSSSCR_CON_IS_BAND:
      case SDSSSCR_CON_IS_PRL:
      case SDSSSCR_CON_IS_NET_SEL:
      case SDSSSCR_CON_IS_LAST_ACT_NET_SEL:
      case SDSSSCR_CON_IS_SCHED:
      case SDSSSCR_CON_IS_PREF_CONF:
      case SDSSSCR_CON_IS_PREF_CHGD:
      case SDSSSCR_CON_IS_BAND_PREF_CHGD:
      case SDSSSCR_CON_IS_SAME:
      case SDSSSCR_CON_IS_CONTAIN:
      case SDSSSCR_CON_IS_CNT:
      case SDSSSCR_CON_IS_FADE:
      case SDSSSCR_CON_MANIPULATOR:
      case SDSSSCR_CON_OPERATOR:
      case SDSSSCR_CON_CTRL:
      case SDSSSCR_CON_MISC:
      case SDSSSCR_CON_COND:
      case SDSSSCR_CON_NOT:
      case SDSSSCR_CON_IS_TIME:
      case SDSSSCR_CON_IS_SYS_LOST:
      case SDSSSCR_CON_IS_MODE_PREF:
      case SDSSSCR_CON_IS_SIM_STATE:
      case SDSSSCR_CON_IS_REG_STATUS:
      case SDSSSCR_CON_IS_ABSR_CNT:
      case SDSSSCR_CON_IS_ECALL_MODE:
      case SDSSSCR_CON_IS_PREF_UPDATE:
      case SDSSSCR_CON_IS_GWL_SCAN_STATUS:
      case SDSSSCR_CON_IS_EOOS_PHASE:
      case SDSSSCR_CON_IS_SRV_STATUS2:
      case SDSSSCR_CON_IS_SRV_MODE:
      case SDSSSCR_CON_IS_LTE_AVAIL_1X:
      case SDSSSCR_CON_IS_PREF_UPDATE_REAS:
      case SDSSSCR_CON_IS_SRV_SYS_PREF_CONF:
      case SDSSSCR_CON_IS_ALL_SYS_PERM_AVOID_IN_LST:
      case SDSSSCR_CON_IS_SS:
      case SDSSSCR_CON_IS_ACQ_SCAN_SCOPE_TYPE:
      case SDSSSCR_CON_MAX:
      default:
        SD_ERR_FATAL_0( "cons");
        break;

    } /* switch */

  } while( eng_ptr->scr_ctrl.ctrl == SDSS_SCR_CTRL_NEXT_CONS );

} /* sdss_eng_event_proc */




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_eng_scr_cond_is_true

DESCRIPTION
  Check whether the condition part of the SS-Script that is currently
  associated with the script engine evaluates to TRUE.

DEPENDENCIES
  The SS-Script-engine that is pointed to by eng_ptr must have already been
  initialized with an SS-Script via a call to sdss_eng_init().

RETURN VALUE
  TRUE if the condition part of the SS-Script that is currently associated
  with the script engine evaluates to TRUE. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean               sdss_eng_scr_cond_is_true(

        sdss_eng_s_type       *eng_ptr,
            /* Pointer to the script engine that is to process the
            ** SS-Event */

        sdss_evt_e_type       event
            /* SS-Event to process */
)
{

  sdss_s_type             *ss_ptr;
  boolean                 cond_is_true    = TRUE;
  boolean                 is_negate_cond  = FALSE;
  sd_ss_e_type            ss;
  sdss_eng_stack_s_type   *eng_stack_ptr  = &sdss_eng_stack;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( eng_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( event, SDSS_EVT_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ss_ptr         = eng_ptr->ss_ptr;
  ss             = eng_ptr->ss;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #if (defined(FEATURE_HDR_HYBRID))
  /* Work with HDR system selection, if specified so.
  */
  if( ss_ptr == sdss_ptr(SD_SS_HYBR_1) )
  {
    eng_stack_ptr   = &sdss_hybr_1_eng_stack;
  }
  #endif /* FEATURE_HDR_HYBRID */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #if defined(FEATURE_MMODE_DUAL_SIM) || defined FEATURE_MMODE_SC_SVLTE || defined FEATURE_MMODE_SC_SGLTE
  /* Work with HYBR_2 system selection, if specified so.
  */
  if( ss_ptr == sdss_ptr(SD_SS_HYBR_2) )
  {
    eng_stack_ptr   = &sdss_hybr_2_eng_stack;
  }
  #endif

#if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  /* Work with HYBR_3 system selection, if specified so.
  */
  if( ss_ptr == sdss_ptr(SD_SS_HYBR_3) )
  {
    eng_stack_ptr   = &sdss_hybr_3_eng_stack;
  }
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* While condition constructs evaluate to TRUE, parse the next script
  ** construct.
  */
  while( cond_is_true )
  {
    /* Parse the next script construct .
    */
    eng_ptr->scr_con = sdssscr_parser_next( &eng_ptr->parser,
                                            time_get_uptime_secs(),
                                            ss_ptr->scr_ctrl_cnt,
                                            &eng_ptr->con_prm1,
                                            &eng_ptr->con_prm2,
                                            &eng_ptr->con_prm3,
                                            &eng_ptr->con_prm4,
                                            &eng_ptr->con_prm5,
                                            &eng_ptr->con_prm6,
                                            &eng_ptr->con_prm7,
                                            &eng_ptr->con_prm8,
                                            ss);

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /* Check whether the condition construct evaluates to TRUE.
    */
    cond_is_true   = FALSE;

    switch( eng_ptr->scr_con )
    {

      case SDSSSCR_CON_NOT:
        cond_is_true    = TRUE;
        is_negate_cond  = TRUE;
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_IS:

        /* IS( VAL ) - Evaluates to TRUE iff VAL is equal to a TRUE boolean
        ** condition.
        */
        if( sdss_eng_scr_con_is(eng_ptr) )
        {
          cond_is_true = TRUE;
        }
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_IS_NOT:

        /* IS_NOT( VAL ) - Evaluates to TRUE iff VAL is equal to a FALSE
        ** boolean condition.
        */
        if( ! sdss_eng_scr_con_is(eng_ptr) )
        {
          cond_is_true = TRUE;
        }
        break;

      case SDSSSCR_CON_IS_EVENT:

        /* IS_EVENT( VAL ) - Evaluates to TRUE iff VAL is equal the current
        ** SS-Event.
        */
        if( event == sdss_event_map(eng_ptr->ss,(sdss_evt_e_type) eng_ptr->con_prm1) )
        {
          cond_is_true = TRUE;
        }
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_IS_OPR_MODE:

        /* IS_OPR_MODE( VAL ) - Evaluates to TRUE iff VAL includes the
        ** current operating mode.
        */
        if( sdss_is_opr_mode( ss,
                              (sdssscr_opr_mode_val_e_type)
                              eng_ptr->con_prm1) )
        {
          cond_is_true = TRUE;
        }
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_IS_PREF_REAS:
      {
        /* IS_PREF_REAS( VAL ) - Evaluates to TRUE iff VAL equals the
        ** current SS-Preference reason.
        */
        dword prm = BYTES_TO_DWORD(eng_ptr->con_prm1, eng_ptr->con_prm2, 
                              eng_ptr->con_prm3, eng_ptr->con_prm4);
        if( sdss_is_pref_reason( ss, prm ) )
        {
          cond_is_true = TRUE;
        }
        break;
      }
      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_CON_IS_FLAG_SET:

      /* IS_FLAG_SET( VAL ) - Evaluates to TRUE iff VAL equals the
      ** current SS-Preference reason.
      */
      if( sdss_is_flag_set(
                           ss,
                           (sdss_flag_e_type) eng_ptr->con_prm1) )
      {
        cond_is_true = TRUE;
      }
      break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_IS_ORIG_MODE:

        /* IS_ORIG_MODE( VAL ) - Evaluates to TRUE iff VAL includes the
        ** current origination mode.
        */
        if( sdss_is_orig_mode( ss,
                              (sd_ss_orig_mode_val_e_type) eng_ptr->con_prm1))
        {
          cond_is_true = TRUE;
        }
        break;
      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_IS_PREV_ORIG_MODE:

        /* IS_ORIG_MODE( VAL ) - Evaluates to TRUE iff VAL includes the
        ** current origination mode.
        */
        if( sdss_is_prev_orig_mode( ss,
                              (sd_ss_orig_mode_val_e_type) eng_ptr->con_prm1))
        {
          cond_is_true = TRUE;
        }
        break;


      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      #ifdef FEATURE_EOOS
      #error code not present
#endif
      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_IS_STATE:

        /* IS_STATE( VAL ) - Evaluates to TRUE iff VAL equal the current
        ** SS-State.
        */
        if( sdss_get_ss_state(eng_ptr->ss)
                                    == (sdss_state_e_type) eng_ptr->con_prm1 )
        {
          cond_is_true = TRUE;
        }
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_IS_ACQ_STATE:

        /* IS_ACQ_STATE( VAL ) - Evaluates to TRUE iff VAL equal the current
        ** acquisition state.
        */
        if( sdss_eng_stack_is_state(eng_stack_ptr,
                                    (sdss_acq_stt_e_type) eng_ptr->con_prm1))
        {
          cond_is_true = TRUE;
        }
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      case SDSSSCR_CON_IS_ACQ_TYPE:

        /* IS_ACQ_TYPE( VAL ) - Evaluates to TRUE iff VAL equal the type of
        ** the most recent acquisition attempt.
        */
        if( sdss_eng_stack_is_type(eng_stack_ptr,
                                   (sdssscr_acq_e_type) eng_ptr->con_prm1) )
        {
          cond_is_true = TRUE;
        }
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      #ifdef FEATURE_EOOS
      #error code not present
#endif
      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_IS_REDIR:

        /* IS_REDIR( VAL ) - Evaluates to TRUE iff VAL encompasses the
        ** current/proposed redirection type.
        */
        if( sdss_is_redir_internal( ss, (sdss_redir_val_e_type) eng_ptr->con_prm1) )
        {
          cond_is_true = TRUE;
        }
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_IS_HANDOFF:

        /* IS_HANDOFF( VAL ) - Evaluates to TRUE iff VAL encompasses the
        ** current/proposed handoff.
        */
        if( sdss_is_handoff(eng_ptr->ss,
                            (sdss_ho_val_e_type) eng_ptr->con_prm1) )
        {
          cond_is_true = TRUE;
        }
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_IS_RESEL_STT:

        /* IS_RESEL_STT( VAL ) - Evaluates to TRUE iff VAL equals the current
        ** reselection state.
        */
        if( sdss_is_resel_state1(ss,
                                (sdssscr_resel_stt_val_e_type)  eng_ptr->con_prm1) )
        {
          cond_is_true = TRUE;
        }
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_IS_RESEL_MODE:

        /* IS_RESEL_MODE( VAL ) - Evaluates to TRUE iff VAL equals the
        ** current reselection mode OR
        ** if VAL == RESEL_MODE_FULL_SRV, then to TRUE if current reselection mode
        ** is between SDSS_RESEL_MODE_FULL_SRV & SDSS_RESEL_MODE_FULL_SRV_MAX-1.
        */
        if ( ss_ptr->resel_mode == (sdss_resel_mode_e_type)eng_ptr->con_prm1 ||
            ((sdss_resel_mode_e_type)eng_ptr->con_prm1 ==
                                             SDSS_RESEL_MODE_FULL_SRV &&
              ss_ptr->resel_mode >= SDSS_RESEL_MODE_FULL_SRV &&
              ss_ptr->resel_mode < SDSS_RESEL_MODE_FULL_SRV_MAX
            )
            || ((sdss_resel_mode_e_type)eng_ptr->con_prm1 ==
                                                 SDSS_RESEL_MODE_STAGE_ANY &&
                ss_ptr->resel_mode >= SDSS_RESEL_MODE_STAGE1 &&
                ss_ptr->resel_mode <= SDSS_RESEL_MODE_STAGE3 &&
                sdss_is_c2k_alt_algr_operation()
            )
          )
        {
          cond_is_true = TRUE;
        }
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_IS_SRV_STATUS:

        /* IS_SRV_STATUS( VAL ) - Evaluates to TRUE iff VAL equals the
        ** current srv status.
        */
        {
          sys_srv_status_e_type ss_srv_status;
          sdss_read_srv_status( ss, &ss_srv_status, NULL );
          cond_is_true = SD_IS_BIT_CONTAIN( BM(ss_srv_status), eng_ptr->con_prm1 );
        }
        break;


      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_IS_SRV_STATUS2:

        /* IS_SRV_STATUS2( SS, VAL ) - Evaluates to TRUE iff VAL equals the
        ** current srv status.
        */
        if( sdss_is_srv_status2( (sd_ss_e_type)eng_ptr->con_prm1,
                        (sdssscr_srv_status_val_e_type) eng_ptr->con_prm2 ) )
        {
          cond_is_true = TRUE;
        }
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_IS_SRV_DOMAIN:

        /* IS_SRV_DOMAIN( VAL ) - Evaluates to TRUE iff VAL equals the
        ** current srv domain.
        */
        {
          sys_srv_domain_e_type ss_srv_domain;

          sdss_read_srv_status(eng_ptr->ss, NULL, &ss_srv_domain );

          if( SD_IS_BIT_CONTAIN( BM(ss_srv_domain), eng_ptr->con_prm1 ))
          {
            #ifdef FEATURE_SD_LTE
            if ((sdssscr_srv_domain_val_e_type)eng_ptr->con_prm1 == SDSSSCR_SRV_DOMAIN_VAL_CS )
            {
            if(!sdss_is_cs_srv_domain_valid_for_voice(eng_ptr->ss))
              {
                cond_is_true = FALSE;
                break;
              }
            }
            #endif /* FEATURE_SD_LTE */
            cond_is_true = TRUE;
          }
        }

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
       case SDSSSCR_CON_IS_SRV_SYS_PREF_CONF:

        /* IS_SRV_SYS_PREF_CONF( VAL ) - Evaluates to TRUE iff VAL includes the
        ** SS-Preference conflict of the current serving system
        */
        {
          sd_si_info_s_type       *si_info_ptr     = &sd_si_ptr(ss)->si_info;
          sd_sid_plmn_s_type      sid_exp;
          sdsr_e_type             list;
          sd_ss_band_pref_e_type  band_pref        = SD_SS_BAND_PREF_NONE;
          sys_lte_band_mask_e_type  lte_band_pref  = SYS_LTE_BAND_MASK_CONST_NONE;
          sd_ss_band_pref_e_type  tds_band_pref    = SD_SS_BAND_PREF_NONE;

          SD_MSG_HIGH_3("CON_IS_SRV_SYS_PREF_CONF: srv_status=%d, mode_pref=%d, mode=%d",
                        si_info_ptr->srv_status,
                        eng_ptr->ss_ptr->mode_pref,
                        si_info_ptr->mode);

          /* If there is no service or if the current srv mode is not part of
          ** new ss_ptr mode pref , do not check if serving system is in
          ** conflict ( since SRV SYS is not valid).
          */
          if ( !sys_srv_status_is_srv(si_info_ptr->srv_status ) ||
               !(SD_IS_BIT_CONTAIN (eng_ptr->ss_ptr->mode_pref ,sdss_map_mode_to_mode_pref(si_info_ptr->mode))))
          {
            if( (sdss_pref_conf_e_type) eng_ptr->con_prm1 == SDSS_PREF_CONF_NONE )
            {
              /* There is a conflict with prefs, since there is no service
              */
              cond_is_true = FALSE;
            }
            else
            {
              cond_is_true = TRUE;
            }
            break;
          }

          /* if there is 3GPP service, check the currently acquired mode and band
          ** instead of all the serving system bands and modes.
          ** to see if the mode/band conflicts with preferences
          */

          switch (si_info_ptr->mode)
          {
             case SD_MODE_CDMA:
             case SD_MODE_HDR:
               list = sdss_sr_list_map2(ss, SDSR_SRV_SYS) ;
               break;
             default:
               list = sdss_sr_list_map2(ss, SDSR_BACKUP_LST) ;
               memset(&sid_exp,0, sizeof(sid_exp));
               sid_exp.net_select_mode = SD_NET_SELECT_MODE_AUTO;
               sid_exp.prm.gwl.plmn.lac = PRL_WILDCARD_LAC;
               sys_plmn_undefine_plmn_id(&(sid_exp.prm.gwl.plmn.plmn_id));
               sid_exp.prm.gwl.num_rats = 1;
               sid_exp.prm.gwl.gwl_pri_lst[0] = si_info_ptr->mode;
               sdsr_list_clr( list );
               switch(si_info_ptr->mode)
               {
                  case SD_MODE_TDS:
                    tds_band_pref = sd_map_band_to_band_pref_tds(si_info_ptr->band);
                    break;
                  case SD_MODE_LTE:
                    lte_band_pref = sd_map_band_to_band_pref_lte(si_info_ptr->band);
                    break;
                  default:
                    band_pref = sd_map_band_to_band_pref(si_info_ptr->band);
                    break;
               }


               sdsr_list_store_and_app3( list,
                                     SDSR_MAX,
                                     SDSR_MAX,
                                     SD_MODE_GWL,
                                     band_pref,
                                     sdsr_map_lte_band_pref_to_sys_rec_lte_band(lte_band_pref),
                                     tds_band_pref,
                                     0,
                                     &sid_exp,
                                     SD_NO_CHANGE_SYS_IDX );
               break;

          } //switch( si_info_ptr->mode)

          /* Check if SRV SYS ( in case of 3GPP2) or  currently acquired 3GPP mode/band
          ** is in conflict with SS preferences
          */
          /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
          if( sdss_sr_list_is_pref_conf(
                                ss,
                                list,
                                (sdss_pref_conf_e_type) eng_ptr->con_prm1) )
          {
            cond_is_true = TRUE;
            break;
          }
          /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
          /* if there are no pref conflicts but
          ** current srv sys is an LTE system which does not support
          ** emergency or emergency is barred and an emergency call is being originated, bail out
          ** of current service
          */
          if( si_info_ptr->mode                == SYS_SYS_MODE_LTE &&
              !sdss_is_lte_ims_emerg_allowed() &&
               sdss_is_emergency_call_orig(eng_ptr->ss))
          {
            SD_MSG_HIGH_0("LTE emerg pref conf");
            if( (sdss_pref_conf_e_type) eng_ptr->con_prm1 == SDSS_PREF_CONF_NONE )
            {
              /* There is a conflict with prefs, since current system does not support emergency
              */
              cond_is_true = FALSE;
            }
            else
            {
              cond_is_true = TRUE;
            }
          }
        }
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      case SDSSSCR_CON_IS_SRV_MODE:

        /* IS_SRV_MODE( VAL ) - Evaluates to TRUE iff VAL equals the
        ** current srv mode.
        */

        cond_is_true = SD_IS_BIT_CONTAIN( BM(sdss_get_curr_srv_mode(eng_ptr->ss)),
                                          eng_ptr->con_prm1);
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_IS_ACC_REAS:

        /* IS_ACC_REAS( VAL ) - Evaluates to TRUE iff VAL equals the latest
        ** access attempt reason.
        */
        if( sdss_is_acc_reas(ss_ptr,
                             (sd_ss_acc_reas_e_type) eng_ptr->con_prm1) )
        {
          cond_is_true = TRUE;
        }
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_IS_ACC_TERM:

        /* IS_ACC_TERM( VAL ) - Evaluates to TRUE iff VAL encompasses the
        ** latest access attempt termination reason.
        */
        if( sdss_is_acc_term(ss_ptr,
                             (sd_ss_acc_term_e_type) eng_ptr->con_prm1) )
        {
          cond_is_true = TRUE;
        }
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_IS_ACC_FAIL:

        /* IS_ACC_FAIL( CNT, TIME ) - Evaluates to TRUE iff registration
        ** access has failed at least CNT times and TIME minutes.
        */
        if( sdss_is_acc_fail(ss_ptr,
                             (int) eng_ptr->con_prm1,
                             (word) eng_ptr->con_prm2) )
        {
          cond_is_true = TRUE;
        }
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_IS_EVENT_CNT:

        /* IS_EVENT_CNT ( EVENT, CNT, TIME ) - Evaluates to TRUE iff EVENT
        ** has occurred CNT times within TIME minutes.
        */
        if( sdss_is_event_cnt(ss_ptr,
                             (sdss_cnted_evt_e_type) eng_ptr->con_prm1,
                             (int)                   eng_ptr->con_prm2,
                             (word)                  eng_ptr->con_prm3) )
        {
          cond_is_true = TRUE;
        }
        break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_IS_SID:

        /* IS_SID( LST, VAL ) - Evaluates to TRUE iff VAL describes the
        ** SID/NID to expected SID/NID relation of at least one of the
        ** systems that are referenced by the system record list LST.
        */
        if( sdss_sr_list_is_sid(
                              ENG_LIST(eng_ptr->con_prm1),
                              (sdssscr_sid_cond_e_type) eng_ptr->con_prm2) )
        {
          cond_is_true = TRUE;
        }
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_IS_MODE:

        /* IS_MODE( LST, VAL ) - Evaluates to TRUE iff VAL includes the mode
        ** designation of at least one of the systems that are referenced by
        ** the system record list LST.
        */
        if( sdss_sr_list_is_mode(ENG_LIST(eng_ptr->con_prm1),
                                 (sd_mode_e_type) eng_ptr->con_prm2) )
        {
          cond_is_true = TRUE;
        }
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_IS_MODE_PREF:

        /* IS_MODE( LST, VAL ) - Evaluates to TRUE iff VAL includes the mode
        ** designation of at least one of the systems that are referenced by
        ** the system record list LST.
        */
        if( sdss_sr_list_is_mode_pref(ENG_LIST(eng_ptr->con_prm1),
                                (sd_ss_mode_pref_e_type) eng_ptr->con_prm2) )
        {
          cond_is_true = TRUE;
        }
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


      case SDSSSCR_CON_IS_BAND:

        /* IS_BAND( LST, VAL ) - Evaluates to TRUE iff VAL includes the band
        ** designation of at least one of the systems that are referenced by
        ** the system record list LST.
        */
        if( sdss_sr_list_is_band(ENG_LIST(eng_ptr->con_prm1),
                                 (sd_band_e_type) eng_ptr->con_prm2) )
        {
          cond_is_true = TRUE;
        }
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_IS_PRL:

        /* IS_PRL( LST, VAL ) - Evaluates to TRUE iff VAL includes the PRL
        ** designation of at least one of the systems that are referenced by
        ** the system record list LST.
        */
        if( sdss_sr_list_is_prl(ENG_LIST(eng_ptr->con_prm1),
                                (sdss_prl_val_e_type) eng_ptr->con_prm2) )
        {
          cond_is_true = TRUE;
        }
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_IS_NET_SEL:

        /* IS_NET_SEL( LST, VAL ) - Evaluates to TRUE iff VAL equals the
        ** network selection mode of at least one of the systems that are
        ** referenced by the system record list LST.
        */
        if( sdss_sr_list_is_net_sel( ENG_LIST(eng_ptr->con_prm1),
                             (sd_net_select_mode_e_type) eng_ptr->con_prm2) )
        {
          cond_is_true = TRUE;
        }
        break;
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_IS_LAST_ACT_NET_SEL:

        /* IS_LAST_ACT_NET_SEL( LST, VAL ) - Evaluates to TRUE iff VAL equals the
        ** network selection mode sent to NAS.
        */
        if( sdss_sr_list_is_last_act_net_sel(
                    (sys_network_selection_mode_e_type) eng_ptr->con_prm1,ss))
        {
          cond_is_true = TRUE;
        }
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_IS_SCHED:

        /* IS_SCHED( LST, VAL ) - Evaluates to TRUE iff VAL equals the
        ** reacquisition schedule of at least one of the systems that are
        ** referenced by the system record list LST
        */
        if( sdss_sr_list_is_sched(eng_ptr->ss,
                                  ENG_LIST(SDSR_SCHED_LST),
                                  ENG_LIST(eng_ptr->con_prm1),
                                  (sdssscr_sched_e_type) eng_ptr->con_prm2) )
        {
          cond_is_true = TRUE;
        }
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_IS_PREF_CONF:

        /* IS_PREF_CONF( LST, VAL ) - Evaluates to TRUE iff VAL includes the
        ** SS-Preference conflict of at least one of the systems that are
        ** referenced by the system record list LST.
        */
        if( sdss_sr_list_is_pref_conf(
                              ss,
                              ENG_LIST(eng_ptr->con_prm1),
                              (sdss_pref_conf_e_type) eng_ptr->con_prm2) )
        {
          cond_is_true = TRUE;
        }
        break;


      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_IS_PREF_CHGD:

        /* IS_PREF_CHGD(  VAL ) - Evaluates to TRUE iff specified SS
        ** preference given by VAL was changed with the last preferred
        ** system changed.
        */
        if( sdss_is_pref_chgd( ss,
                               (sdss_pref_chgd_e_type) eng_ptr->con_prm1
                             ))
        {
          cond_is_true = TRUE;
        }
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_IS_BAND_PREF_CHGD:

        /* IS_BAND_PREF_CHGD(  VAL ) - Evaluates to TRUE iff band
        ** for a given  VAL (mode)  was changed with the last preferred
        ** system changed.
        */
        if( sdss_is_band_pref_chgd( ss,
                               (sd_ss_mode_pref_e_type) eng_ptr->con_prm1
                             ))
        {
          cond_is_true = TRUE;
        }
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_IS_PREF_UPDATE:

        /* IS_PREF_UPDATE(  VAL ) - Evaluates to TRUE iff specified SS
        ** preference given by VAL was the update status with the last preferred
        ** system changed.
        */
        if( sdss_is_pref_update( ss,
                               (sdss_pref_updated_e_type) eng_ptr->con_prm1
                             ))
        {
          cond_is_true = TRUE;
        }
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_IS_SAME:

        /* IS_SAME( LST1, LST2, VAL ) - Evaluates to TRUE iff LST1 and LST2
        ** are the same with respect to the VAL equality category.
        */
        if( sdsr_list_is_same(ENG_LIST(eng_ptr->con_prm1),
                              ENG_LIST(eng_ptr->con_prm2),
                              (sdsr_equal_e_type) eng_ptr->con_prm3) )
        {
          cond_is_true = TRUE;
        }
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_IS_CONTAIN:

        /* IS_CONTAIN( LST1, VAL, LST2 ) - Evaluates to TRUE iff LST1
        ** contains VAL elements of LST2.
        */
        if( sdsr_list_is_contain(ENG_LIST(eng_ptr->con_prm1),
                                 (sdsr_contain_e_type) eng_ptr->con_prm2,
                                 ENG_LIST(eng_ptr->con_prm3)) )
        {
          cond_is_true = TRUE;
        }
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_IS_CNT:

        /* IS_CNT( LST, CNT, CNT_COND, CNT_INC ) - Evaluates to TRUE iff LST
        ** contains CNT or more/less/exactly elements that comply with the
        ** CNT_INC count inclusion criteria.
        */
        if( sdss_sr_list_is_cnt(eng_ptr->ss,
                                ENG_LIST(eng_ptr->con_prm1),
                                (int) eng_ptr->con_prm2,
                                (sdssscr_cnt_cond_e_type) eng_ptr->con_prm3,
                                (sdssscr_cnt_inc_e_type) eng_ptr->con_prm4) )
        {
          cond_is_true = TRUE;
        }
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_IS_FADE:

      /* IS_FADE( CNT ) - Evaluates to TRUE iff there is fades for
      ** at least CNT times.
      */
      if( sdsr_list_is_fade( ENG_LIST(eng_ptr->con_prm1),
                             (byte)eng_ptr->con_prm2 ))
      {
        cond_is_true = TRUE;
      }
      break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_IS_TIME:

      /* IS_TIME_GR(INSTANCE, SRV_VAL, TIME) -
      ** Evaluates to TRUE iff INSTANCE has SRV_VAL for atleast TIME seconds
      */
      if( sdss_is_time_gr( (sd_ss_e_type) eng_ptr->con_prm1,
                           (sdssscr_srv_status_val_e_type)eng_ptr->con_prm2,
                           (byte)eng_ptr->con_prm3 ) )
      {
        cond_is_true = TRUE;
      }
      break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_IS_SYS_LOST:

        /* IS_SYS_LOST( VAL )- Evaluates to TRUE iff
        ** VALUE equals the latest system lost reason. */
        if( sdss_is_sys_lost( ss_ptr,
                              (sd_ss_sys_lost_e_type) eng_ptr->con_prm1) )
        {
          cond_is_true = TRUE;
        }
        break;


      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_IS_SIM_STATE:

        /* IS_SIM_STATE( SIM_STATUS ) - Evaluates to TRUE iff the
        ** phone's SIM state is equal to the given sim_status */

        if ( ss_ptr->sim_state == (sys_sim_state_e_type) eng_ptr->con_prm1)
        {
          cond_is_true = TRUE;
        }
        else
        {
          cond_is_true = FALSE;
        }
        break;


      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_IS_REG_STATUS:

        SD_MSG_HIGH_2( "CDMA reg status =%d con = %d",
                     ss_ptr->cdma_reg_status, eng_ptr->con_prm1);

        if( ss_ptr->cdma_reg_status ==
                                  (sys_reg_status_e_type) eng_ptr->con_prm1 )
        {
          cond_is_true = TRUE;
        }

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_IS_ABSR_CNT:

        sdss_update_absr(ss_ptr, NULL, &eng_ptr->con_prm1, &cond_is_true );

        break;


      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_IS_ECALL_MODE:

        /* IS_ECALL_MODE () - Evaluates to TRUE iff
         ** eCall modem API return oprt mode as ECALL_MODE_ECALL_ONLY */
        #ifdef FEATURE_ECALL_IVS
        if( ecall_get_ecall_operating_mode() ==  ECALL_MODE_ECALL_ONLY )
        {
          cond_is_true = TRUE;
        }
        else
        {
          cond_is_true = FALSE;
        }
        #else
          cond_is_true = FALSE;
        #endif /* FEATURE_ECALL_IVS */

        break;

      case SDSSSCR_CON_IS_ALL_SYS_PERM_AVOID_IN_LST:
      {
        sdsr_e_type list   = ENG_LIST( eng_ptr->con_prm1 );
        /* IS_ALL_SYS_PERM_AVOID_IN_LST( REDIR_LST ) - Evaluates to TRUE iff all the systems
        ** present in the REDIR_LST are under permanent avoidance */
        SD_MSG_HIGH_1( "Check if all the systems in list =%d are permanent avoided",
          list);
        if( sdss_is_all_sys_perm_avoid_in_lst( list ) )
        {
          cond_is_true = TRUE;
        }
      }
      break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      case SDSSSCR_CON_IS_LTE_AVAIL_1X:
        if(sdss_is_c2k_alt_algr_operation())
        {
          if(sdss_ptr( SD_SS_MAIN )->lte_avail_1x ==
                                  (sdss_lte_avail_e_type)eng_ptr->con_prm1)
          {
            cond_is_true = TRUE;
          }
          else
          {
            cond_is_true = FALSE;
          }
        }
        else
        {
          cond_is_true = FALSE;
        }
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSSSCR_CON_IS_PREF_UPDATE_REAS:
        if( sdss_is_pref_update_reas( ss,
                                     (sd_ss_pref_update_reason_e_type) eng_ptr->con_prm1
                                    ))
        {
          cond_is_true = TRUE;
        }
        break;
        
     case SDSSSCR_CON_IS_SS:
        if( ss == (sd_ss_e_type)eng_ptr->con_prm1)
        {
          cond_is_true = TRUE;
        }
      break;
      case SDSSSCR_CON_1ST_COND:
      case SDSSSCR_CON_MAX:
        SD_ERR_0( "construct");
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSSSCR_CON_IS_CSFB_ACC_TERM_COMB:
        if (sdss_valid_acc_term_comb_csfb())
        {
          cond_is_true = TRUE;
        }
        break;

      case SDSSSCR_CON_IS_ACQ_SCAN_SCOPE_TYPE:
        /* Checks for scan_scope in last acquisition*/
        if (sd_ss_ptr(ss)->true_curr_act.act == SD_SS_ACT_ACQ_GWL && 
            sd_ss_ptr(ss)->true_curr_act.prm.acq_gwl.scan_scope == (sys_scan_scope_e_type)eng_ptr->con_prm1)
        {
          cond_is_true = TRUE;
        }
        break;

      default:

        /* If this is a condition construct, it must be catched above.
        */
        if( SDSSSCR_CON_IS_COND(eng_ptr->scr_con) )
        {
          SD_ERR_0( "Cond construct not implemented");
          break;
        }

        /* We reached a non-condition construct (i.e., the condition part of
        ** the script is evaluated to TRUE) - return TRUE.
        */
        return TRUE;

    } /* switch */

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /* If condition needs to be negated, do so.
    */
    if( is_negate_cond &&
        eng_ptr->scr_con != SDSSSCR_CON_NOT )
    {
      is_negate_cond  = FALSE;
      cond_is_true    = SD_BOOLEAN( !cond_is_true );
    }
  } /* while( cond_is_true ) */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If we got here, the condition is evaluated to FALSE - return FALSE.
  */
  return FALSE;

} /* sdss_eng_scr_cond_is_true */




/* <EJECT> */
/*===========================================================================
=============================================================================
========================= SS-SCRIPT-ENGINES STACK ===========================
=============================================================================
===========================================================================*/


/*===========================================================================

FUNCTION sdss_eng_stack_init

DESCRIPTION
  Initializes the SS-Script-engine stack.

  NOTE! this function must be called before any other sdss_eng_stack_xxx is
  called.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static  void                    sdss_eng_stack_init(

        sdss_eng_stack_s_type   *stack_ptr,
            /* Engine stack pointer.
            */

        sdss_eng_s_type         **arr_ptr,
            /* Pointer to array of engines.
            */

        unsigned int            arr_size
            /* Size of array (in elements).
            */
)
{
  SD_ASSERT( stack_ptr != NULL );
  SD_ASSERT( arr_ptr != NULL );
  SD_ASSERT( arr_size != 0 );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Clearing up previously allocated stack if any*/
  while(stack_ptr->cnt > 0 && stack_ptr->arr_ptr[stack_ptr->cnt-1]!= NULL)
  {
    modem_mem_free((void*)stack_ptr->arr_ptr[stack_ptr->cnt-1],
            MODEM_MEM_CLIENT_MMODE);
    stack_ptr->arr_ptr[stack_ptr->cnt-1] = NULL;
    stack_ptr->cnt--;
  }
//  STACK_INIT( sdss_eng_stack );

  stack_ptr->arr_ptr  = arr_ptr;
  stack_ptr->size     = arr_size;
  stack_ptr->cnt      = 0;

} /* sdss_eng_stack_init */

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_eng_stack_push

DESCRIPTION
  Push a script engine on top of the engines stack.

  Note! If the script that is to be pushed on the engines stack contain no
  PREV_SCR construct, the stack is emptied prior to pushing the script
  engine.

DEPENDENCIES
  sdss_eng_stack_init() must have already been called to initialize the
  script engine stack.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static  void                    sdss_eng_stack_push(

        sdss_eng_stack_s_type   *stack_ptr,
            /* Engine stack pointer.
            */
        const sdss_eng_s_type   *eng_ptr
            /* Pointer to the script engine that is to be pushed on to the
            ** engines stack.
            */
)
{
  SD_ASSERT( stack_ptr != NULL );
  SD_ASSERT( eng_ptr != NULL );
  SD_ASSERT( stack_ptr->cnt < stack_ptr->size );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If the script that is to be pushed on the engines stack contain no
  ** PREV_SCR construct, empty the engine stack.
  */
  if( ! sdssscr_parser_is_contain( &eng_ptr->parser, SDSSSCR_CON_PREV_SCR,
                                   TRUE, NULL, NULL ))
  {
    /* Clearing up previously allocated stack if any*/
    while(stack_ptr->cnt > 0 && stack_ptr->arr_ptr[stack_ptr->cnt-1]!= NULL)
    {
      modem_mem_free((void*)stack_ptr->arr_ptr[stack_ptr->cnt-1],
              MODEM_MEM_CLIENT_MMODE);
      stack_ptr->arr_ptr[stack_ptr->cnt-1] = NULL;
      stack_ptr->cnt--;
    }
    stack_ptr->cnt = 0;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Push engine on top of engines stack.
  */
  if( stack_ptr->cnt < stack_ptr->size )
  {
    stack_ptr->arr_ptr[stack_ptr->cnt] = modem_mem_alloc(sizeof(sdss_eng_s_type),
                                              MODEM_MEM_CLIENT_MMODE);
    if(stack_ptr->arr_ptr[stack_ptr->cnt] == NULL)
    {
      sys_err_fatal_null_ptr_exception();
    }
    *(stack_ptr->arr_ptr[stack_ptr->cnt]) = *eng_ptr;
    stack_ptr->cnt++;
  }

} /* sdss_eng_stack_push */




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_eng_stack_pop

DESCRIPTION
  Pop a script engine from top of the engines stack.

DEPENDENCIES
  sdss_eng_stack_init() must have already been called to initialize the
  script engine stack.

RETURN VALUE
  TRUE if pop is successful. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean                 sdss_eng_stack_pop(

        sdss_eng_stack_s_type   *stack_ptr
            /* Engine stack pointer.
            */
)
{
  SD_ASSERT( stack_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if( stack_ptr->cnt > 0 && stack_ptr->arr_ptr[stack_ptr->cnt-1] != NULL)
  {
    modem_mem_free((void*)stack_ptr->arr_ptr[stack_ptr->cnt-1],
            MODEM_MEM_CLIENT_MMODE);

    stack_ptr->arr_ptr[stack_ptr->cnt-1] = NULL;
    stack_ptr->cnt--;
    return TRUE;
  }

  return FALSE;

} /* sdss_eng_stack_pop */




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_eng_stack_top

DESCRIPTION
  Return a pointer to script engine that is at the top of the engines stack.

DEPENDENCIES
  sdss_eng_stack_init() must have already been called to initialize the
  script engine stack.

RETURN VALUE
  Pinter to the script engine that is at the top of the engines stack if
  stack is not empty. NULL otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
static  sdss_eng_s_type*              sdss_eng_stack_top(

        const sdss_eng_stack_s_type   *stack_ptr
            /* Engine stack pointer.
            */
)
{
  SD_ASSERT( stack_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  if( stack_ptr == NULL )
  {
    sys_err_fatal_null_ptr_exception();
  }

  if( stack_ptr->cnt > 0 )
  {
    return (stack_ptr->arr_ptr[stack_ptr->cnt-1]);
  }

  return NULL;

} /* sdss_eng_stack_top */




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_eng_stack_is_state

DESCRIPTION
  Check the acquisition state of script engine that is at the top of the
  stack.

DEPENDENCIES
  sdss_eng_stack_init() must have already been called to initialize the
  script engine stack.

RETURN VALUE
  TRUE if the acquisition state of the script engine that is at the top of
  the stack is equal to the acquisition state in question. FALSE otherwise.
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean                       sdss_eng_stack_is_state(

        const sdss_eng_stack_s_type   *stack_ptr,
            /* Engine stack pointer.
            */

        sdss_acq_stt_e_type           acq_stt
            /* Acquisition state in question.
            */
)
{
  sdss_eng_s_type   *eng_ptr;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( stack_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( acq_stt, SDSS_ACQ_STT_MAX );
  SD_ASSERT( stack_ptr->cnt > 0 );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Point at the script engine that is at the top of the stack. Return TRUE
  ** if the acquisition state of this engine is equal to the acquisition
  ** state in question. Else, return FALSE.
  */
  eng_ptr = sdss_eng_stack_top( stack_ptr );
  SD_ASSERT( eng_ptr != NULL ); //?? delete this assert.
  /*lint -e774 *//* Suppress the if statement is always true */
  if( eng_ptr == NULL ) /*lint +e774 */
  {
    SD_ERR_0( "Empty stack!");
  }
  else if( eng_ptr->acq.state == acq_stt )
  {
    return TRUE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return FALSE;

} /* sdss_eng_stack_is_state */




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_eng_stack_is_type

DESCRIPTION
  Check the last acquisition type of the script engine that is at the top of
  the stack.

DEPENDENCIES
  sdss_eng_stack_init() must have already been called to initialize the
  script engine stack.

RETURN VALUE
  TRUE if the acquisition type of the script engine that is at the top of
  the stack is equal to the acquisition state in question. FALSE otherwise.
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean                       sdss_eng_stack_is_type(

        const sdss_eng_stack_s_type   *stack_ptr,
            /* Engine stack pointer.
            */

        sdssscr_acq_e_type            acq_type
            /* Acquisition type in question.
            */
)
{
  sdss_eng_s_type   *eng_ptr;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( stack_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( acq_type, SDSSSCR_ACQ_MAX);
  SD_ASSERT( stack_ptr->cnt > 0 );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Point at the script engine that is at the top of the stack. Return TRUE
  ** if the last acquisition type of this engine is equal to the acquisition
  ** state in question. Else, return FALSE.
  */
  eng_ptr = sdss_eng_stack_top( stack_ptr );
  SD_ASSERT( eng_ptr != NULL ); //?? delete this assert.
  /*lint -e774 *//* Suppress the if statement is always true */
  if( eng_ptr == NULL )/*lint +e774*/
  {
    SD_ERR_0( "Empty stack!");
  }
  else if( eng_ptr->ss_ptr->acq_type == acq_type )
  {
    return TRUE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return FALSE;

} /* sdss_eng_stack_is_type */


/*===========================================================================

FUNCTION sdss_eng_stack_is_type

DESCRIPTION
  get the last acquisition type of the script engine that is at the top of
  the stack.

DEPENDENCIES
  sdss_eng_stack_init() must have already been called to initialize the
  script engine stack.

RETURN VALUE
  sdssscr_acq_e_type
SIDE EFFECTS
  None.

===========================================================================*/
sdssscr_acq_e_type     sdss_eng_stack_get_acq_type
(

       sd_ss_e_type            ss
)
{
  sdss_eng_s_type         *eng_ptr;
  sdss_eng_stack_s_type   *stack_ptr  = &sdss_eng_stack;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #if (defined(FEATURE_HDR_HYBRID))
  /* If the input system selection is HDR, point at HDR engine stack.
  */
  if( ss == SD_SS_HYBR_1 )
  {
    stack_ptr   = &sdss_hybr_1_eng_stack;
  }
  #endif /* FEATURE_HDR_HYBRID */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #if defined(FEATURE_MMODE_DUAL_SIM) || defined FEATURE_MMODE_SC_SVLTE || defined FEATURE_MMODE_SC_SGLTE
  if(ss == SD_SS_HYBR_2)
  {
    stack_ptr = &sdss_hybr_2_eng_stack;
  }
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Point at the script engine that is at the top of the stack. Return the
  ** acquisition state of this engine.
  */
  eng_ptr = sdss_eng_stack_top( stack_ptr );

  if( eng_ptr == NULL )/*lint +e774*/
  {
    SD_ERR_0( "Empty stack!");
  }
  else
  {
    return eng_ptr->ss_ptr->acq_type;
  }

  return SDSSSCR_ACQ_MAX;

} /* sdss_eng_stack_is_type */


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_eng_stack_get_state

DESCRIPTION
  Return the acquisition state of script engine that is at the top of the
  stack.

DEPENDENCIES
  sdss_eng_stack_init() must have already been called to initialize the
  script engine stack.

RETURN VALUE
  The acquisition state of script engine that is at the top of the stack.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sdss_acq_stt_e_type     sdss_eng_stack_get_state(

        sd_ss_e_type            ss
            /* System selection stack.
            *//*lint -esym( 715, ss ) */ /* Symbol is not referenced.*/
)
{
  sdss_eng_s_type         *eng_ptr;
  sdss_eng_stack_s_type   *stack_ptr  = &sdss_eng_stack;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #if (defined(FEATURE_HDR_HYBRID))
  /* If the input system selection is HDR, point at HDR engine stack.
  */
  if( ss == SD_SS_HYBR_1 )
  {
    stack_ptr   = &sdss_hybr_1_eng_stack;
  }
  #endif /* FEATURE_HDR_HYBRID */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #if defined(FEATURE_MMODE_DUAL_SIM) || defined FEATURE_MMODE_SC_SVLTE || defined FEATURE_MMODE_SC_SGLTE
  if(ss == SD_SS_HYBR_2)
  {
    stack_ptr = &sdss_hybr_2_eng_stack;
  }
  #endif

  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  if(ss == SD_SS_HYBR_3)
  {
    stack_ptr = &sdss_hybr_3_eng_stack;
  }
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Point at the script engine that is at the top of the stack. Return the
  ** acquisition state of this engine.
  */
  eng_ptr = sdss_eng_stack_top( stack_ptr );

  if( eng_ptr == NULL )
  {
    SD_ERR_1( "Empty stack!, ss=%d",ss);
    return SDSS_ACQ_STT_DONE;
  }

  return ( eng_ptr->acq.state );

} /* sdss_eng_stack_get_state */
/*lint +esym( 715, ss ) */ /* Symbol is not referenced.*/


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_eng_stack_is_acq_type

DESCRIPTION
  Compare the input acq_type with the acquisition type of script engine that is at 
  the top of the stack.

DEPENDENCIES
  sdss_eng_stack_init() must have already been called to initialize the
  script engine stack.

RETURN VALUE
  boolean.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean     sdss_eng_stack_is_acq_type(

        sd_ss_e_type            ss,
            /* System selection stack.
            *//*lint -esym( 715, ss ) */ /* Symbol is not referenced.*/
        sdssscr_acq_e_type      acq_type
)
{
  sdss_eng_s_type         *eng_ptr;
  sdss_eng_stack_s_type   *stack_ptr  = &sdss_eng_stack;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( ss, SDSR_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  #if (defined(FEATURE_HDR_HYBRID))
  /* If the input system selection is HDR, point at HDR engine stack.
  */
  if( ss == SD_SS_HYBR_1 )
  {
    stack_ptr   = &sdss_hybr_1_eng_stack;
  }
  #endif /* FEATURE_HDR_HYBRID */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #if defined(FEATURE_MMODE_DUAL_SIM) || defined FEATURE_MMODE_SC_SVLTE
  if(ss == SD_SS_HYBR_2)
  {
    stack_ptr = &sdss_hybr_2_eng_stack;
  }
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Point at the script engine that is at the top of the stack. Return the
  ** acquisition list of this engine.
  */
  eng_ptr = sdss_eng_stack_top( stack_ptr );

  if( eng_ptr == NULL )
  {
    ERR( "Empty stack!, ss=%d",ss,0,0 );
    return FALSE;
  }

  return ( eng_ptr->acq.acq_type == acq_type );

} /* sdss_eng_stack_is_acq_type */
/*lint +esym( 715, ss ) */ /* Symbol is not referenced.*/




/* ^L<EJECT> */
/*===========================================================================

FUNCTION sdss_eng_stack_scr_act

DESCRIPTION
  Activate a new script as necessary.

DEPENDENCIES
  sdss_eng_stack_init() must have already been called to initialize the
  script engine stack.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static  void                    sdss_eng_stack_scr_act(

        sdss_eng_stack_s_type   *stack_ptr,
            /* Engine stack pointer.
            */

        sdss_s_type             *ss_ptr,
            /* Pointer to a System Selection information structure.
            */

        sdss_evt_e_type         event
            /* SS-Event to process.
            */
)
{
  int                   i;
  sdss_eng_s_type       eng;
  sdssscr_ref_type      scr_ref;
  sdss_evt_grp_e_type   event_group = sdss_map_event_to_group( event );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( stack_ptr != NULL );
  SD_ASSERT( ss_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( event, SDSS_EVT_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Bypass the script engine for limited regional service indication if the
  ** acquisition state machine is running. If the acquisition is in progress,
  ** the script engine should not move on to different script/construct.
  */
  if( (event_group == SDSS_EVT_GRP_GWL_OPR || event_group == SDSS_EVT_GRP_HYBR_2_GW_OPR
       || event_group == SDSS_EVT_GRP_HYBR_3_GW_OPR) &&
       ss_ptr->srv_status == SYS_SRV_STATUS_LIMITED_REGIONAL &&
       ss_ptr->ss_state != SDSS_STATE_OPR
    )
  {
    return;
  }

  /* Step through the scripts table and check whether any script is
  ** associated with the current SS-Event and conditions. If such a script is
  ** found, activate it by pushing its associated script engine on top of the
  ** engines stack.
  **
  ** Note that a script is considered associated with the current SS-Event
  ** and condition iff the condition part of the script evaluates to TRUE.
  */
  for( i=0;
       (scr_ref=sdssscr_get_ref(event_group, i)) != SDSSSCR_REF_NULL;
       i++ )
  {
    sdss_eng_init( &eng, ss_ptr, scr_ref, event_group, i );
    if( sdss_eng_scr_cond_is_true(&eng, event) )
    {
      sdss_script_name_print(event_group, i);

      sdss_eng_init( &eng, ss_ptr, scr_ref, event_group, i );
      sdss_eng_stack_push( stack_ptr, &eng );

      return;
    }
  }

} /* sdss_eng_stack_scr_act */




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_eng_stack_event_proc

DESCRIPTION
  Process an SS-Event called for by the SS-Front-end and instruct the
  SS-Front-end of the next SS-Internal-Action to take.

DEPENDENCIES
  sdss_eng_stack_init() must have already been called to initialize the
  script engine stack.

RETURN VALUE
  SS-Internal-Action to be taken by the SS-Front-end (through the
  rtrn_iact_ptr parameter).

SIDE EFFECTS
  None.

===========================================================================*/
static  void                    sdss_eng_stack_proc(

        sdss_eng_stack_s_type   *stack_ptr,
            /* Engine stack pointer.
            */

        sdss_s_type             *ss_ptr,
            /* Pointer to a System Selection information structure.
            */

        sdss_evt_e_type         event,
            /* SS-Event to process.
            */

        sdss_iact_s_type        *rtrn_iact_ptr
            /* Pointer to a buffer where to place returned internal action.
            */
)
{
  boolean             stat      = FALSE;
  sdss_eng_s_type     eng;
  sdss_eng_s_type     *eng_ptr;
  sdssscr_ref_type    scr_ref;
  sdsr_s_type         *acq_ptr  = NULL;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( stack_ptr != NULL );
  SD_ASSERT( ss_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( event, SDSS_EVT_MAX );
  SD_ASSERT( rtrn_iact_ptr != NULL )

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Suppress Lint and compiler warnings
  */
  SYS_ARG_NOT_USED(stat);
  SYS_ARG_NOT_USED(acq_ptr);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Activate a new script as necessary.
  */
  sdss_eng_stack_scr_act( stack_ptr, ss_ptr, event );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Do script processing as long as control is not to be returned to the
  ** SS-Front-end.
  */ /*lint -e716 */ /* While (1) */
  while( TRUE )
  {
    /* Call on the script-engine that is at the top of the engines stack to
    ** process the event.
    */
    eng_ptr = sdss_eng_stack_top( stack_ptr );
    if( eng_ptr == NULL )
    {
    
      SD_MSG_HIGH_0( "NULL eng ptr, CONTINUE");
      rtrn_iact_ptr->act = SDSS_IACT_CONTINUE;
      return;
    }

    sdss_eng_event_proc( eng_ptr, event, rtrn_iact_ptr );

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /* Based on the control information that comes back from the
    ** script-engine take the next step.
    */
    switch( eng_ptr->scr_ctrl.ctrl )
    {
      case SDSS_SCR_CTRL_RTRN_ACT:

        /* Set the return timer as per the active script timer and return
        ** control to the SS-Front-end.
        */
        rtrn_iact_ptr->ss_timer = eng_ptr->scr_timer;
        if( rtrn_iact_ptr->act == SDSS_IACT_ACQUIRE )
        {
          if( eng_ptr->acq.state == SDSS_ACQ_STT_DONE )
          {
            SD_MSG_HIGH_0( "ACQ_STT DONE -> START");
            eng_ptr->acq.state = SDSS_ACQ_STT_START;
          }
        }
        return;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSS_SCR_CTRL_NEXT_CONS:

        /* Continue with next script construct.
        */
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSS_SCR_CTRL_PREV_SCR:

        /* Reactivate the previous script.
        */
        stat = sdss_eng_stack_pop( stack_ptr );
        SD_ASSERT( stat );

        eng_ptr = sdss_eng_stack_top( stack_ptr );
        if( eng_ptr == NULL )
        {
          SD_ERR_0( "NULL eng ptr, CONTINUE");
          rtrn_iact_ptr->act = SDSS_IACT_CONTINUE;
          return;
        }

        /* If we are coming back to an interrupted ALT_SCAN.
        ** Restart the ALT scan by scanning the system which triggered it.
        */
        if( eng_ptr->acq.state == SDSS_ACQ_STT_MORE_PREF )
        {
          SD_MSG_HIGH_0( "ACQ_STT MORE_PREF -> START");
          acq_ptr = sdsr_list_get_ptr(eng_ptr->acq.acq_lst,eng_ptr->acq.acq_pos);
          eng_ptr->acq.state = SDSS_ACQ_STT_START;
          if(acq_ptr != NULL)
          {
            acq_ptr->new_acq_cnt = 0;
          }
          else
          {
            SD_ERR_2("acq_ptr is NULL acq_lst=%d,acq_pos=%d",
                      eng_ptr->acq.acq_lst,eng_ptr->acq.acq_pos);
          }
          eng_ptr->acq.acq_pos--;
        }

        SD_MSG_HIGH_2( "** Re-act scr, grp=%d, scr=%d **",
                    eng_ptr->scr_evt_grp, eng_ptr->scr_tbl_idx);

        /* If the script engine's acquisition state machine is active, update
        ** the acquisition type of the SS-Core per the acquisition type of
        ** the this script engine.
        */
        if( eng_ptr->acq.acq_type != SDSSSCR_ACQ_MAX ) {
          sdss_acq_type_update( eng_ptr->ss_ptr, eng_ptr->acq.acq_type );
        }

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSS_SCR_CTRL_ACT_SCR:

        /* Activate a new script by associating an engine with the script and
        ** pushing the associated engine on to the engines stack.
        */
        #ifndef FEATURE_SD_ENHANCED_DEBUG_MSG
        SD_MSG_HIGH_1( "** Activate called script=%d **",
                    eng_ptr->scr_ctrl.prm.act.script);
        #else /* FEATURE_SD_ENHANCED_DEBUG_MSG */
        SD_MSG_SCRIPT( "** Activate called script = ",
                           dsssscr_called_tbl_string_map[eng_ptr->scr_ctrl.prm.act.script]);
        #endif /* FEATURE_SD_ENHANCED_DEBUG_MSG */

        scr_ref = sdssscr_called_get_ref( eng_ptr->scr_ctrl.prm.act.script );
        SD_ASSERT( scr_ref != NULL );

        sdss_eng_init( &eng,
                       ss_ptr,
                       scr_ref,
                       SDSS_EVT_GRP_CALLED,
                       (int) eng_ptr->scr_ctrl.prm.act.script );

        sdss_eng_stack_push( stack_ptr, &eng );

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSS_SCR_CTRL_PROC_EVT:

        /* Do new event processing by activating a new script as needed.
        */
        event = eng_ptr->scr_ctrl.prm.proc.event;

        /* Change event for HYBR_2 GW
        */
        if(SDSS_EVT_IS_GWL(event) && eng_ptr->ss == SD_SS_HYBR_2)
        {
          /* Get corresponding HYBR_2 OPR event
          */
          event = sdss_event_map(SD_SS_HYBR_2,event);
        }

        #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
        /* Change event for HYBR_3 GW
        */
        if(SDSS_EVT_IS_GWL(event) && eng_ptr->ss == SD_SS_HYBR_3)
        {
          /* Get corresponding HYBR_3 OPR event
          */
          event = sdss_event_map(SD_SS_HYBR_3,event);
        }
        #endif

        SD_MSG_HIGH_1( "** Process event=%d **", event);

        sdss_eng_stack_scr_act( stack_ptr, ss_ptr, event );
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSS_SCR_CTRL_MAX:
      default:
        SD_ERR_0( "scr_ctrl");
        break;

    } /* switch */

  } /* while */ /*lint +e716 */

} /* sdss_eng_stack_proc */

/*===========================================================================

FUNCTION sdss_extract_emerg_rat_acq_order()

DESCRIPTION
  Read and decode the Emergency Technology order table from EFS.
  Normal TOT should have been extracted first.
  In case if it has to be used in default ordering of emerg_tot


DEPENDENCIES
  None

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static void sdss_extract_emerg_rat_acq_order( sd_ss_e_type ss)
{

  byte                        efs_tot[PRL_TOT_TBL_MAX_SIZE];
  boolean                     is_valid          = FALSE;
  int32                       size              = PRL_TOT_TBL_MAX_SIZE;
  uint16                      num_rat           = 0;
  int                         i, j, n_rat;
  sdss_s_type                 *ss_ptr = sdss_ptr(ss);
  sd_rat_acq_order_s_type     *emerg_tot = &(ss_ptr->emerg_rat_acq_order);
  sys_modem_as_id_e_type      asubs_id = sdss_map_ss_to_as_id(ss);
  /* if EFS is not configured then what should be the default value 
  keeping in mind that only e911 pending additional info flag would be sent to
  NAS during emerg_mode service request */
  /* as of now I have put it as L>G>W>1X>DO>TDS, as mentioned in requirements */
  sys_sys_mode_e_type         dflt_rat_acq_order[SDSS_DFLT_NUM_RAT]={SYS_SYS_MODE_LTE, SYS_SYS_MODE_GSM,
                                SYS_SYS_MODE_WCDMA, SYS_SYS_MODE_CDMA, SYS_SYS_MODE_HDR, SYS_SYS_MODE_TDS};

  sys_sys_mode_e_type         tmp_tot[SYS_MAX_ACQ_PREF_RAT_LIST_NUM]={0};

  if(emerg_tot == NULL){
    SD_ERR_0("Emerg_TOT pointer is NULL");
    return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Read binary TOT from EFS
  */
  is_valid = sdefs_fs_read_per_subs(SDEFS_EMERGENCY_RAT_ACQ_ORDER, efs_tot,&size, asubs_id);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  if (is_valid)
  {
    /* Decode TOT table
    */
    is_valid = prl_decode_tot_tbl( efs_tot, emerg_tot );

    num_rat = MIN(SYS_MAX_ACQ_PREF_RAT_LIST_NUM, emerg_tot->num_rat);

    /* Remove duplicate rat ids' from rat_acq_order read from EFS
    */
    for(i=0, n_rat=0; i < num_rat; i++)
    {
      for(j=0; j<i; j++)
      {
        if(emerg_tot->acq_sys_mode[i] == emerg_tot->acq_sys_mode[j])
        {
          break;
        }
      }
      if(j==i)
      {
        tmp_tot[n_rat++] = emerg_tot->acq_sys_mode[i];
      }
    }
    emerg_tot->num_rat = n_rat;
    memscpy( emerg_tot->acq_sys_mode, sizeof(emerg_tot->acq_sys_mode), tmp_tot, sizeof(tmp_tot) );

    memset(tmp_tot, 0, sizeof(tmp_tot));

    /* Add the items from default rat_acq_order to the rat_acq_order read from EFS in case of
    ** incorrect provisioning of EFS rat_acq_order table.
    */
    for(i=0; i < emerg_tot->num_rat; i++)
    {

      for(j=0; j < SDSS_DFLT_NUM_RAT; j++)
      {
        if( ( i < SDSS_DFLT_NUM_RAT ) && (emerg_tot->acq_sys_mode[i] == dflt_rat_acq_order[j]) )
        {
          tmp_tot[j]=1;
          break;
        }
      }
    }

    for(i=0; i < SDSS_DFLT_NUM_RAT; i++)
    {
      if(emerg_tot->num_rat >= SYS_MAX_ACQ_PREF_RAT_LIST_NUM) {
        break;
      }

      if(tmp_tot[i] == 0){
        emerg_tot->acq_sys_mode[emerg_tot->num_rat++] = dflt_rat_acq_order[i];
      }
    }

  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* If reading/decoding failed, use the default TOT table
  */
  if (!is_valid)
  {
    SD_MSG_HIGH_0("EMERG_TOT: loading dflt lgwcht");
    emerg_tot->version = PRL_TOT_DEFAULT_VERSION;
    emerg_tot->num_rat = SDSS_DFLT_NUM_RAT;
    memscpy( emerg_tot->acq_sys_mode, sizeof(emerg_tot->acq_sys_mode), dflt_rat_acq_order, sizeof(dflt_rat_acq_order) );
  }

  for(i=0; i< emerg_tot->num_rat; i++)
  {
    SD_MSG_HIGH_2("EMERG_TOT: acq_sys_mode[%d] : %d",i,emerg_tot->acq_sys_mode[i]);
  }
} /* sdss_extract_tot() */

/* <EJECT> */
/*===========================================================================
=============================================================================
=============================================================================
============================== MAJOR ROUTINES ===============================
=============================================================================
=============================================================================
===========================================================================*/

/*===========================================================================

FUNCTION sdss_common_set_acq_info

DESCRIPTION
  Reset acq info stored in SDSS common global state.

===========================================================================*/
static void  sdss_common_set_acq_info(void)
{

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Initialize LTE to hybrid HDR IRAT flag */
  sdss_common.is_hybr_hdr_irat    = FALSE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Initialize Opt HO LTE->ehrpd flag */

  sdss_common.is_opt_ho_lte_do = FALSE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  sdss_common.lte_activity_status = FALSE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Initialize HDR list realignment flags */
  sdss_common.is_hdr_opr_realign_pref_lst         = FALSE;
  sdss_common.is_1x_realign_hdr_srv_colloc_lst    = FALSE;

  sdss_common.camp_mode           = SD_SS_PREF_CAMP_MODE_OFF;

  sdss_common.is_emerg_attached = FALSE;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  #ifdef FEATURE_MMODE_DYNAMIC_SV_OPERATION_SWITCH
  sdss_common.sv_opr_action                      = SDSS_SV_OPR_ACT_NONE;
  #endif

}
/*===========================================================================

FUNCTION sdss_read_efs_c2k_resel_splmn_supp()

DESCRIPTION
  Read and decode the c2k_resel_splmn_supp from EFS.


DEPENDENCIES
  None

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static void sdss_read_efs_c2k_resel_splmn_supp ( void )
{

  //boolean                     c2k_resel_supp = FALSE;
  int32                       size              = sizeof(sdss_common.c2k_resel_splmn_supp);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Read c2k_resel_splmn_supp flag from EFS
 
  if(sdefs_read(SDEFS_C2K_RESEL_SPLMN, (byte *)&c2k_resel_supp,&size ))
  {
    SD_MSG_MED_1("C2k_resel_splmn: efs read success %d",c2k_resel_supp);
    sdss_common.c2k_resel_splmn_supp = (!c2k_resel_supp) ? FALSE:TRUE;
  }
  else
  {
    SD_MSG_MED_0("C2k_resel_splmn: loading dflt value FALSE");
    sdss_common.c2k_resel_splmn_supp = FALSE;
  } */

  if(sdefs_read(SDEFS_C2K_RESEL_SPLMN, (byte *)&sdss_common.c2k_resel_splmn_supp,&size ))
  {
    SD_MSG_MED_0("C2k_resel_splmn: efs read success ");
  }

} /* sdss_read_efs_c2k_resel_splmn_supp() */

/*===========================================================================

FUNCTION sdss_rat_sys_to_bst

DESCRIPTION
  maps sdmmss sys type to sdmmss bst rat type

DEPENDENCIES

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/

sdmmss_bst_rat_id_e_type sdss_rat_sys_to_bst
(        
       sdmmss_sys_type_e_type sys_rat_type
)
{
  sdmmss_bst_rat_id_e_type ret_rat = SDMMSS_BST_RAT_ID_MAX;

  switch(sys_rat_type)
  {
  case SDMMSS_SYS_TYPE_GSM:
  	ret_rat = SDMMSS_BST_RAT_ID_GSM;
  	break;
  case SDMMSS_SYS_TYPE_WCDMA:
    ret_rat = SDMMSS_BST_RAT_ID_WCDMA;
  	break;
  case SDMMSS_SYS_TYPE_LTE:
    ret_rat = SDMMSS_BST_RAT_ID_LTE;
  	break;
  case SDMMSS_SYS_TYPE_TDS:
    ret_rat = SDMMSS_BST_RAT_ID_TDS;
  	break; default:
		break;
  }
  return ret_rat;
}

/*===========================================================================

FUNCTION sdss_get_rat_from_band

DESCRIPTION
  maps sysband to bst rat

DEPENDENCIES

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/

sdmmss_bst_rat_id_e_type sdss_get_rat_from_mode
(
     sd_mode_e_type mode
)
{
  sdmmss_bst_rat_id_e_type ret_rat = SDMMSS_BST_RAT_ID_MAX;
  
  if(mode == SD_MODE_GSM )
  {
    ret_rat = SDMMSS_BST_RAT_ID_GSM;
  }
  else if(mode == SD_MODE_WCDMA)
  {
    ret_rat = SDMMSS_BST_RAT_ID_WCDMA;
  }
  else if(mode == SD_MODE_LTE )
  {
    ret_rat = SDMMSS_BST_RAT_ID_LTE;
  }
  else if(mode == SD_MODE_TDS)
  {
    ret_rat = SDMMSS_BST_RAT_ID_TDS;
  }

  SD_MSG_HIGH_2("sdss_get_rat_from_mode mode:%d rat:%d",mode,ret_rat);
  return ret_rat;
}

/*===========================================================================

FUNCTION sdss_bst_rat_to_mode_pref

DESCRIPTION
  map bst rat to sd mode pref

DEPENDENCIES

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/

sd_ss_mode_pref_e_type sdss_bst_rat_to_mode_pref
(
            sdmmss_bst_rat_id_e_type rat
)
{
  switch(rat)
  {
  case SDMMSS_BST_RAT_ID_GSM:
  	return SD_SS_MODE_PREF_GSM;
  case SDMMSS_BST_RAT_ID_WCDMA:
  	return SD_SS_MODE_PREF_WCDMA;
  case SDMMSS_BST_RAT_ID_LTE:
  	return SD_SS_MODE_PREF_LTE;
  case SDMMSS_BST_RAT_ID_TDS:
  	return SD_SS_MODE_PREF_TDS;
  default:
  	return SD_SS_MODE_PREF_NONE;
  }
}
/*===========================================================================

FUNCTION sdss_sys_band_to_prl_band

DESCRIPTION
  map sd band to prl band

DEPENDENCIES

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/

byte sdss_sys_band_to_prl_band
(
     sd_band_u_type band,
     /*input band*/
     sdmmss_bst_rat_id_e_type rat
     /*input rat*/
)
{
  switch(rat)
  {
    case SDMMSS_BST_RAT_ID_GSM:
      return prl_map_band_to_gsm_band(sdss_map_band_pref_to_band(band.chgwt_band));
    case SDMMSS_BST_RAT_ID_WCDMA:
      return prl_map_band_to_wcdma_band(sdss_map_band_pref_to_band(band.chgwt_band));
    case SDMMSS_BST_RAT_ID_LTE:
      return prl_map_band_to_lte_band(sdss_map_band_pref_to_band_lte(band.lte_band));
    case SDMMSS_BST_RAT_ID_TDS:
      return prl_map_band_to_tds_band(sdss_map_band_pref_to_band_tds(band.chgwt_band));
    default:
      return SDMMSS_BST_RAT_ID_MAX;
  }
}
/*===========================================================================

FUNCTION sdss_mmssbst_to_sdbst

DESCRIPTION
  converts sdmmss bst type to sd bst type

DEPENDENCIES

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/

boolean sdss_mmssbst_to_sdbst
(
          sd_bst_tbl_s_type* sd_bst_ptr,
          sdmmss_bst_tbl_s_type* mmss_bst_ptr
)
{
  int i = 0;
  int j = 0;
  boolean is_plmn_undef;
  boolean is_pcs;
  sys_mnc_type mnc;


	 /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
	/* verify against null value of bst pointer
	*/
  if(sd_bst_ptr == NULL || mmss_bst_ptr == NULL)
  {
	 SD_ERR_0("invalid bst");
	return FALSE;
  }

  sd_bst_ptr->length = mmss_bst_ptr->length;
  
  for(i = 0;i < mmss_bst_ptr->length && i < SDMMSS_BST_MAX_LENGTH;i++)
  {
    sd_bst_ptr->bst_tbl[i] = (sd_bst_s_type*)modem_mem_alloc( 
                    sizeof(sd_bst_s_type), MODEM_MEM_CLIENT_MMODE);
     //fill is_mcc_incl, MCC
    
    sys_plmn_get_mcc_mnc(mmss_bst_ptr->bst_tbl[i].plmn,
	                      &is_plmn_undef,
	  	                  &is_pcs,
	  	                  &sd_bst_ptr->bst_tbl[i]->mcc,
	  	                  &mnc);
	 
    if(is_plmn_undef == TRUE )
    {
      sd_bst_ptr->bst_tbl[i]->is_mcc_included = FALSE;
    }
	else
    {
      sd_bst_ptr->bst_tbl[i]->is_mcc_included = TRUE;
    }
	
	//copy num_mode
    sd_bst_ptr->bst_tbl[i]->num_mode = mmss_bst_ptr->bst_tbl[i].num_mode;

    //copy modes and bands
	for(j = 0;j<mmss_bst_ptr->bst_tbl[i].num_mode && j<SYS_MAX_NUM_3GPP_RATS; j++)
	{
	  sd_bst_ptr->bst_tbl[i]->band_tbl[j].mode = sdss_rat_sys_to_bst(mmss_bst_ptr->bst_tbl[i].band_tbl[j].mode);
	  sd_bst_ptr->bst_tbl[i]->band_tbl[j].gwl_rec = mmss_bst_ptr->bst_tbl[i].band_tbl[j].gwl_rec;
	}//for(j = 0;j<mmss_bst_ptr->bst_tbl[i].num_mode && j<SYS_MAX_NUM_3GPP_RATS; j++)

	
  }//for(i = 0;i < mmss_bst_ptr->length && i < SDMMSS_BST_MAX_LENGTH;i++)

  return TRUE;
}
/*===========================================================================

FUNCTION sdss_read_efs_manual_search_bst

DESCRIPTION
  reads manual search bst table from efs and fills in sdss_common

DEPENDENCIES

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/

static void sdss_read_efs_manual_search_bst(void)
{

  int32   efs_bst_size       = SDMMSS_BST_TBL_MAX_SIZE;
	
  byte * efs_bst_ptr       = NULL;

  sdmmss_bst_tbl_s_type* bst_ptr;

  boolean is_efs_read = FALSE;

  memset(&sdss_common.manual_search_bst,0,sizeof(sd_bst_tbl_s_type));

  sdss_common.is_manual_search_bst = FALSE;
	
  bst_ptr =(sdmmss_bst_tbl_s_type*)modem_mem_alloc( sizeof(sdmmss_bst_tbl_s_type), 
                                                     MODEM_MEM_CLIENT_MMODE);

  if(bst_ptr == NULL )
  {
    SD_MSG_HIGH_0("Could not allocate memory for BST ptr");
    return;
  }

  /* Initialize BST 
    */
  memset(bst_ptr,0,sizeof(sdmmss_bst_tbl_s_type));
  bst_ptr->length = 0;

  efs_bst_ptr =(byte*)modem_mem_alloc( efs_bst_size,
                                         MODEM_MEM_CLIENT_MMODE);

  if(efs_bst_ptr == NULL )
  {
    SD_MSG_HIGH_0("Could not allocate memory for binary BST");
    modem_mem_free((void *) bst_ptr, MODEM_MEM_CLIENT_MMODE);
    return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Read binary BST from EFS
  */
  is_efs_read = sdefs_read(SDEFS_MANUAL_SRCH_BST_TBL, efs_bst_ptr, &efs_bst_size);

  /* if bst efs cannot be read, use default bst buffer*/
  if(is_efs_read == FALSE)
  {
     sdss_common.is_manual_search_bst = FALSE;
  }
  else
  {
     sdss_common.is_manual_search_bst = sdmmss_decode_3gpp_bst_tbl(efs_bst_ptr,bst_ptr);
  }
  SD_MSG_HIGH_2("is_efs_read=%d, Manual search BST=%d", is_efs_read,sdss_common.is_manual_search_bst);

  /* free efs bst buffer*/
  modem_mem_free((void *) efs_bst_ptr, MODEM_MEM_CLIENT_MMODE);
  

  if(sdss_common.is_manual_search_bst == FALSE)
  {
    modem_mem_free((void *) bst_ptr, MODEM_MEM_CLIENT_MMODE);
    return;
  }
  //store decoded bst to sdss_common.manual_search bst
  sdss_common.is_manual_search_bst 
    = sdss_mmssbst_to_sdbst(&sdss_common.manual_search_bst,bst_ptr);
  modem_mem_free((void *) bst_ptr, MODEM_MEM_CLIENT_MMODE);
	
}
static void sdss_print_manual_search_bst(void)
{
  int i,j,k;

 
  SD_MSG_HIGH_1("***sdss_print_manual_search_bst START*** Num of records : %d",sdss_common.manual_search_bst.length);
  
  for(i=0;i<sdss_common.manual_search_bst.length;i++)
  {
    SD_MSG_HIGH_3("Record %d Num of modes : %d is mcc incl %d",i,sdss_common.manual_search_bst.bst_tbl[i]->num_mode,
    				sdss_common.manual_search_bst.bst_tbl[i]->is_mcc_included);

    if(sdss_common.manual_search_bst.bst_tbl[i]->is_mcc_included)
    {
      SD_MSG_HIGH_1("MCC %d",sdss_common.manual_search_bst.bst_tbl[i]->mcc);
    }
    for(j=0;j<sdss_common.manual_search_bst.bst_tbl[i]->num_mode;j++)
    {
      SD_MSG_HIGH_2("Mode %d Num of bands %d",
        sdss_common.manual_search_bst.bst_tbl[i]->band_tbl[j].mode,
        sdss_common.manual_search_bst.bst_tbl[i]->band_tbl[j].gwl_rec.num_bands);
      for(k=0;k<sdss_common.manual_search_bst.bst_tbl[i]->band_tbl[j].gwl_rec.num_bands;k++)
	  {
        SD_MSG_HIGH_1("Band %d",sdss_common.manual_search_bst.bst_tbl[i]->band_tbl[j].gwl_rec.rec[k].band);
	  }
    }
  }
 
}

/*===========================================================================

FUNCTION sdss_bst_has_match

DESCRIPTION
  checks if the input MCC has a matching record in manual search BST

DEPENDENCIES

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/

EXTERN boolean sdss_bst_has_match
(
            sys_mcc_type mcc,
	        sd_ss_mode_pref_e_type* mode_pref_ptr,
	        sd_ss_band_pref_e_type* band_pref_ptr,
            sys_lte_band_mask_e_type* lte_band_pref_ptr,
	        sd_ss_band_pref_e_type* tds_band_pref_ptr,
            sd_bst_s_type** bst_rec_ptr
)
{
  int i,j,k;
  boolean bFound = FALSE;

  if(sdss_common.is_manual_search_bst == FALSE)
  {
    SD_MSG_HIGH_0("sdss_bst_has_match: manual search bst is not configured");   
    return bFound;
  }
  sdss_print_manual_search_bst();
  for(i=0;i<sdss_common.manual_search_bst.length;i++)
  {
    if(sdss_common.manual_search_bst.bst_tbl[i]->is_mcc_included &&
       sdss_common.manual_search_bst.bst_tbl[i]->mcc == mcc)
    {
      bFound = TRUE;
	  break;
    }
  }//for(i=0;i<sdss_common.manual_search_bst.length;i++)

  if(bFound == TRUE)
  {
    *mode_pref_ptr = SD_SS_MODE_PREF_NONE;
    *band_pref_ptr = SD_SS_BAND_PREF_NONE;
    *lte_band_pref_ptr = SYS_LTE_BAND_MASK_CONST_NONE;
    *tds_band_pref_ptr = SD_SS_BAND_PREF_NONE;
    *bst_rec_ptr = sdss_common.manual_search_bst.bst_tbl[i];
	
    for(j=0;j<sdss_common.manual_search_bst.bst_tbl[i]->num_mode;j++)
    {
      switch(sdss_common.manual_search_bst.bst_tbl[i]->band_tbl[j].mode)
      {
      	case SDMMSS_BST_RAT_ID_GSM:
          *mode_pref_ptr = sd_misc_add_mode_pref(*mode_pref_ptr, SD_SS_MODE_PREF_GSM);
           for(k=0;k<sdss_common.manual_search_bst.bst_tbl[i]->band_tbl[j].gwl_rec.num_bands;k++)
           {
               *band_pref_ptr = SD_BAND_ADD(*band_pref_ptr,
                 sd_map_band_to_band_pref(
                   prl_map_gsm_band_to_band(sdss_common.manual_search_bst.bst_tbl[i]->band_tbl[j].gwl_rec.rec[k].band)));
           }
           break;
      	case SDMMSS_BST_RAT_ID_WCDMA:
           *mode_pref_ptr = sd_misc_add_mode_pref(*mode_pref_ptr, SD_SS_MODE_PREF_WCDMA);
           for(k=0;k<sdss_common.manual_search_bst.bst_tbl[i]->band_tbl[j].gwl_rec.num_bands;k++)
           {
              *band_pref_ptr = SD_BAND_ADD(*band_pref_ptr,
                sd_map_band_to_band_pref(
                  prl_map_wcdma_band_to_band(sdss_common.manual_search_bst.bst_tbl[i]->band_tbl[j].gwl_rec.rec[k].band)));
           }
			break;
      	case SDMMSS_BST_RAT_ID_LTE:
           *mode_pref_ptr = sd_misc_add_mode_pref(*mode_pref_ptr, SD_SS_MODE_PREF_LTE);
           for(k=0;k<sdss_common.manual_search_bst.bst_tbl[i]->band_tbl[j].gwl_rec.num_bands;k++)
           {
             SYS_LTE_BAND_MASK_ADD_BAND( lte_band_pref_ptr,
                                         sys_map_lte_band_to_sband(
                                            prl_map_lte_band_to_band(sdss_common.manual_search_bst.bst_tbl[i]->band_tbl[j].gwl_rec.rec[k].band)
                                         )
                                       );
           }
			break;
      	case SDMMSS_BST_RAT_ID_TDS:
           *mode_pref_ptr = sd_misc_add_mode_pref(*mode_pref_ptr, SD_SS_MODE_PREF_TDS);
           for(k=0;k<sdss_common.manual_search_bst.bst_tbl[i]->band_tbl[j].gwl_rec.num_bands;k++)
           {
               *tds_band_pref_ptr = SD_BAND_ADD(*tds_band_pref_ptr,
                  sd_map_band_to_band_pref_tds(
                    prl_map_tds_band_to_band(sdss_common.manual_search_bst.bst_tbl[i]->band_tbl[j].gwl_rec.rec[k].band)));
           }
			break;
		case SDMMSS_BST_RAT_ID_MAX:
			break;
      }//switch(sdss_common.manual_search_bst.bst_tbl[i]->band_tbl[j].mode)
    }//for(j=0;j<sdss_common.manual_search_bst.bst_tbl[i]->num_mode;j++)
  }

  return bFound;
}
/*===========================================================================

FUNCTION sdss_bst_get_default_prefs

DESCRIPTION
  checks if the input MCC has a matching record in manual search BST

DEPENDENCIES

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/

EXTERN boolean sdss_bst_get_default_prefs
(
        sd_ss_mode_pref_e_type* mode_pref_ptr,
        sd_ss_band_pref_e_type* band_pref_ptr,
        sys_lte_band_mask_e_type* lte_band_pref_ptr,
        sd_ss_band_pref_e_type* tds_band_pref_ptr
)
{
  int i,j,k;
  boolean bFound = FALSE;
	
  if(sdss_common.is_manual_search_bst == FALSE)
  {
    SD_MSG_HIGH_0("sdss_bst_get_default_prefs: manual search bst is not configured");
    return bFound;
  }
	
  for(i=0;i<sdss_common.manual_search_bst.length;i++)
  {
    if(sdss_common.manual_search_bst.bst_tbl[i]->is_mcc_included == FALSE)
    {
      bFound = TRUE;
      break;
    }
  }//for(i=0;i<sdss_common.manual_search_bst.length;i++)

  if(bFound == TRUE)
  {
    *mode_pref_ptr = SD_SS_MODE_PREF_NONE;
    *band_pref_ptr = SD_SS_BAND_PREF_NONE;
    *lte_band_pref_ptr = SYS_LTE_BAND_MASK_CONST_NONE;
    *tds_band_pref_ptr = SD_SS_BAND_PREF_NONE;
		  
    for(j=0;j<sdss_common.manual_search_bst.bst_tbl[i]->num_mode;j++)
    {
      switch(sdss_common.manual_search_bst.bst_tbl[i]->band_tbl[j].mode)
      {
          case SDMMSS_BST_RAT_ID_GSM:
          *mode_pref_ptr = sd_misc_add_mode_pref(*mode_pref_ptr, SD_SS_MODE_PREF_GSM);
          for(k=0;k<sdss_common.manual_search_bst.bst_tbl[i]->band_tbl[j].gwl_rec.num_bands;k++)
          {
            *band_pref_ptr = SD_BAND_ADD(*band_pref_ptr,
              sd_map_band_to_band_pref(
                prl_map_gsm_band_to_band(sdss_common.manual_search_bst.bst_tbl[i]->band_tbl[j].gwl_rec.rec[k].band)));
          }
          break;
          case SDMMSS_BST_RAT_ID_WCDMA:
          *mode_pref_ptr = sd_misc_add_mode_pref(*mode_pref_ptr, SD_SS_MODE_PREF_WCDMA);
          for(k=0;k<sdss_common.manual_search_bst.bst_tbl[i]->band_tbl[j].gwl_rec.num_bands;k++)
          {
          *band_pref_ptr = SD_BAND_ADD(*band_pref_ptr,
            sd_map_band_to_band_pref(
              prl_map_wcdma_band_to_band(sdss_common.manual_search_bst.bst_tbl[i]->band_tbl[j].gwl_rec.rec[k].band)));
          }
          break;
          case SDMMSS_BST_RAT_ID_LTE:
          *mode_pref_ptr = sd_misc_add_mode_pref(*mode_pref_ptr, SD_SS_MODE_PREF_LTE);
          for(k=0;k<sdss_common.manual_search_bst.bst_tbl[i]->band_tbl[j].gwl_rec.num_bands;k++)
          {
            SYS_LTE_BAND_MASK_ADD_BAND( lte_band_pref_ptr,
                                        sys_map_lte_band_to_sband(
                                           prl_map_lte_band_to_band(sdss_common.manual_search_bst.bst_tbl[i]->band_tbl[j].gwl_rec.rec[k].band)
                                        )
                                      );
          }
          break;
          case SDMMSS_BST_RAT_ID_TDS:
          *mode_pref_ptr = sd_misc_add_mode_pref(*mode_pref_ptr, SD_SS_MODE_PREF_TDS);
          for(k=0;k<sdss_common.manual_search_bst.bst_tbl[i]->band_tbl[j].gwl_rec.num_bands;k++)
          {
          *tds_band_pref_ptr = SD_BAND_ADD(*tds_band_pref_ptr,
            sd_map_band_to_band_pref_tds(
              prl_map_tds_band_to_band(sdss_common.manual_search_bst.bst_tbl[i]->band_tbl[j].gwl_rec.rec[k].band)));
          }
          break;
          case SDMMSS_BST_RAT_ID_MAX:
          break;
      }//switch(sdss_common.manual_search_bst.bst_tbl[i]->band_tbl[j].mode)
    }//for(j=0;j<sdss_common.manual_search_bst.bst_tbl[i]->num_mode;j++)
  }

  return bFound;
}
/*===========================================================================

FUNCTION sdss_check_update_manual_search_bst

DESCRIPTION
  checks if the input MCC has a matching record in manual search BST
  if a match is found, 
             checks if the mode and band are present in record
                    if not present update the record with mode/ band
   if updated, write back the bst to efs

DEPENDENCIES

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/

EXTERN void sdss_check_update_manual_search_bst
( 
  sdss_man_srch_bst_node_s_type *cmd
)
{
  sd_ss_mode_pref_e_type ss_mode_pref;
  sd_ss_band_pref_e_type ss_band_pref;
  sys_lte_band_mask_e_type ss_band_pref_lte;
  sd_ss_band_pref_e_type ss_band_pref_tds;
  boolean needs_mode_band_update = FALSE;
  boolean needs_band_update = FALSE;
  sdmmss_bst_rat_id_e_type rat;
  sd_bst_s_type* bst_rec_ptr = NULL;
  int i=0;
  prl_bst_validation_write_enum_type efs_write_res;
  sys_mcc_type mcc;
  boolean has_mcc_match = FALSE;

  if(sdss_common.is_manual_search_bst == FALSE)
  {
    return;
  }

  sys_plmn_get_mcc(cmd->plmn,&mcc);

  SD_MSG_HIGH_2("update_manual_search_bst MCC %d mode %d ",mcc,cmd->mode);
  
  has_mcc_match = sdss_bst_has_match(mcc,
                                     &ss_mode_pref,
                                     &ss_band_pref,
                                     &ss_band_pref_lte,
                                     &ss_band_pref_tds,
                                     &bst_rec_ptr);

  rat = sdss_get_rat_from_mode(cmd->mode);

  SD_MSG_HIGH_2(" has_mcc_match %d rat %d ",has_mcc_match,rat);
  if(has_mcc_match == TRUE && INRANGE(rat,SDMMSS_BST_RAT_ID_GSM,SDMMSS_BST_RAT_ID_TDS))
  {  
    /* if mode is present in the mcc's record , check if band needs an update*/
	if(SD_MODE_CONTAIN(ss_mode_pref,sdss_bst_rat_to_mode_pref(rat)))
	{
	  switch(rat)
	  {
	    case SDMMSS_BST_RAT_ID_GSM:
                if(!SD_BAND_CONTAIN(ss_band_pref,cmd->band_pref.chgwt_band))
	  	{
	  	  needs_band_update = TRUE;
	  	}
	  	break;
	    case SDMMSS_BST_RAT_ID_WCDMA:
                if(!SD_BAND_CONTAIN(ss_band_pref,cmd->band_pref.chgwt_band))
	  	{
	  	  needs_band_update = TRUE;
	  	}
	  	break;
	    case SDMMSS_BST_RAT_ID_LTE:
            {
            sys_lte_band_mask_e_type lte_band_pref = cmd->band_pref.lte_band;
             if(!SYS_LTE_BAND_MASK_CHK_IF_OVERLAP(&ss_band_pref_lte,&lte_band_pref))
	  	{
	  	  needs_band_update = TRUE;
	  	}
            }
	  	break;
	    case SDMMSS_BST_RAT_ID_TDS:
                if(!SD_BAND_CONTAIN(ss_band_pref_tds,cmd->band_pref.chgwt_band))
	  	{
	  	  needs_band_update = TRUE;
	  	}
	  	break;
            case SDMMSS_BST_RAT_ID_MAX:
                 needs_band_update = FALSE; 
		break;
	  }//switch(rat)
	}//if(SD_MODE_CONTAIN(ss_mode_pref,sdss_bst_rat_to_mode_pref(rat)))
	else
	{
	  needs_mode_band_update = TRUE;
	}
  }//if(has_mcc_match == TRUE)
  else
  {
    SD_MSG_HIGH_1("No Match in BST for MCC %d",mcc);
    return;
  }
  
  SD_MSG_HIGH_3("Match found MCC %d needs_mode_band_update %d needs_band_update %d",mcc,needs_mode_band_update,needs_band_update);
  
  if(needs_mode_band_update == TRUE )
  {
    if(bst_rec_ptr->num_mode <SYS_MAX_NUM_3GPP_RATS)
    {
       bst_rec_ptr->band_tbl[bst_rec_ptr->num_mode].mode = rat;

       bst_rec_ptr->band_tbl[bst_rec_ptr->num_mode].gwl_rec.rec[0].band = sdss_sys_band_to_prl_band(cmd->band_pref,rat);
       bst_rec_ptr->band_tbl[bst_rec_ptr->num_mode].gwl_rec.num_bands = 1;
   
       bst_rec_ptr->num_mode++;
     }
     else
     {
       SD_MSG_HIGH_0("BST not updated as record has MAX RAT entries..shouldn't happen");
       return;
     }
  }
  else if(needs_band_update == TRUE)
  {
    for(i=0;i<bst_rec_ptr->num_mode;i++)
    {
      if(bst_rec_ptr->band_tbl[i].mode == rat)
	  	break;
    }
	if(i<bst_rec_ptr->num_mode && bst_rec_ptr->band_tbl[i].gwl_rec.num_bands < PRL_MAX_GWL_GENERIC_BAND)
	{
	  bst_rec_ptr->band_tbl[i].gwl_rec.rec[bst_rec_ptr->band_tbl[i].gwl_rec.num_bands].band = sdss_sys_band_to_prl_band(cmd->band_pref,rat);
	  bst_rec_ptr->band_tbl[i].gwl_rec.num_bands++;
	}
	else
	{
	  SD_MSG_HIGH_1("BST not updated as mode record has MAX bands %d",bst_rec_ptr->band_tbl[i].gwl_rec.num_bands);
	  return;
	}
  }
  else
  {
    SD_MSG_HIGH_2("Exact Match present in BST for MCC %d Mode %d ",mcc,cmd->mode);
    return;
  }

  /* If reached here, bst needs to be written back to EFS*/

  efs_write_res
    = sdmmss_validate_and_write_manual_srch_bst(&(sdss_common.manual_search_bst));

  sdss_print_manual_search_bst();
  SD_MSG_HIGH_1("manual srch bst write to efs. Result : %d",efs_write_res);
  
}

/*===========================================================================

FUNCTION sdss_read_efs_extend_lte_bsr_during_1x_activity()

DESCRIPTION
  Read if the EFS item to delay LTE BSR when 1x activity is on-going is
  enabled.
  
DEPENDENCIES
  None

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
//EXTERN
void sdss_read_efs_extend_lte_bsr_during_1x_activity ( void )
{
  sd_extend_lbsr_s_type efs_lte_bsr = {0};
  int32 size = sizeof(sd_extend_lbsr_s_type);

  //  if ( sdefs_read( SDEFS_EXTEND_LBSR_1x_ACTIVE, (byte *) &efs_lte_bsr, &size ) )
  if ( sdefs_get( SDEFS_EXTEND_LBSR_1x_ACTIVE, (byte*)&efs_lte_bsr, size ) )
  {
    SD_MSG_HIGH_1( "SDEFS_EXTEND_LBSR_1x_ACTIVE read successfully. Val = %d",
                   efs_lte_bsr.is_extend_lbsr );

    if ( efs_lte_bsr.is_extend_lbsr )
    {
      sdss_common.is_extend_lbsr_when_1x_activity = TRUE;
    }
  }
  else
  {
    SD_MSG_HIGH_0( "Extend LTE BSR: Loading Default Value" );
    sdss_common.is_extend_lbsr_when_1x_activity = FALSE;
  }
}


/*===========================================================================

FUNCTION sdss_read_efs_enhanced_f3_dbg_rule()

DESCRIPTION
  Read EFS for rule on enhanced debug messages.

DEPENDENCIES
  None

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
void sdss_read_efs_enhanced_f3_dbg_rule ( void)
{

  int32                       size              = sizeof(uint16);
  uint16    efs_enhanced_f3_dbg_rule = 0;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Read enhanced_f3_dbg from EFS
  */
  if(sdefs_fs_read_per_subs(SDEFS_ENHANCED_F3_DBG_RULE, (byte *)&efs_enhanced_f3_dbg_rule,&size, SYS_MODEM_AS_ID_1))
  {
    sdss_common.enhanced_f3_dbg_rule = efs_enhanced_f3_dbg_rule; /*NV is available on device*/
  }
  else
  {
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    /*NV not configured*/
    sdss_common.enhanced_f3_dbg_rule = 0; 
  }

} /* sdss_read_efs_enhanced_f3_dbg_rule() */
/*===========================================================================

FUNCTION sdss_common_nv_refresh

DESCRIPTION
  IRefreshes NV items stored in sdss_common
 
DEPENDENCIES
  None

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
void                          sdss_common_nv_refresh(
  uint8             refresh_subs_mask
)
{
  /* iterator used to initialize operator_name
  */
  int                i = 0;
  uint32             mode_capability = 0;
  sys_band_mask_type cgw_band_capability = 0;
  sys_lte_band_mask_e_type lte_band_capability = SYS_LTE_BAND_MASK_CONST_NONE;
  sys_band_mask_type tds_band_capability = 0;

  


  #ifdef FEATURE_MMODE_TARGET_BRINGUP_DISABLE_PRL_VALIDATION

  sdss_common.band_capability     = SD_SS_BAND_PREF_ANY;

  sdss_common.lte_band_capability = SYS_LTE_BAND_MASK_CONST_ANY;

  sdss_common.tds_band_capability = SD_SS_BAND_PREF_TDS_ANY;

  sdss_common.mode_capability     = SD_SS_MODE_PREF_ANY;

  #else

  policyman_get_hardware_rats_bands(&mode_capability,
                                    &cgw_band_capability,
                                    &lte_band_capability,
                                    &tds_band_capability);

  sdss_common.band_capability     = (sd_ss_band_pref_e_type)cgw_band_capability;

  sdss_common.lte_band_capability = lte_band_capability;

  sdss_common.tds_band_capability = (sd_ss_band_pref_e_type)tds_band_capability;

  sdss_common.mode_capability     = (sd_ss_mode_pref_e_type)mode_capability;

  #endif

  if( SD_MODE_CONTAIN( sdss_common.mode_capability, SD_SS_MODE_PREF_GSM ) &&
      SD_MODE_CONTAIN( sdss_common.mode_capability, SD_SS_MODE_PREF_WCDMA))
  {
    if( SD_MODE_CONTAIN(sdss_common.mode_capability, SD_SS_MODE_PREF_LTE) )
    {
      sdss_common.mode_capability = SD_MODE_ADD(sdss_common.mode_capability,SD_SS_MODE_PREF_GWL);
    }
    else
    {
      sdss_common.mode_capability = SD_MODE_ADD(sdss_common.mode_capability,SD_SS_MODE_PREF_GW);
    }
  }

  SD_MSG_HIGH_0("before lte_band_capability");
  sd_print_lte_band_mask(sdss_common.lte_band_capability);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  sdss_common.mode_capability = sdss_get_supp_mode_pref_mmode(
                                               sdss_common.mode_capability,
                                               sdss_common.band_capability,
                                               sdss_common.lte_band_capability,
                                               sdss_common.tds_band_capability);

  /* Filter out the bands without the available modes. */
  sdss_common.band_capability = sdss_get_supp_mode_band_pref(
    sdss_common.mode_capability, sdss_common.band_capability);


  sdss_common.lte_band_capability = sdss_get_supp_mode_band_pref_lte(
    sdss_common.mode_capability, sdss_common.lte_band_capability);

  sdss_common.tds_band_capability = sdss_get_supp_mode_band_pref_tds(
    sdss_common.mode_capability, sdss_common.tds_band_capability);

  SD_MSG_HIGH_3("mode_capability=0x%x,band_capability=0x%x, tds_band_capability=0x%x",
                 sdss_common.mode_capability,sdss_common.band_capability,sdss_common.tds_band_capability);

  SD_MSG_HIGH_0("after lte_band_capability");
  sd_print_lte_band_mask(sdss_common.lte_band_capability);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  sdss_common_set_acq_info();

  sdss_common.cfg_emerg_call_after_lu_in_lpm = FALSE;
  sdss_read_efs_emerg_call_after_lu_in_lpm();
  
  sdss_common.cfg_roam_ind_update_in_l_to_1x_ho = FALSE;
  sdss_read_efs_roam_ind_update_in_l_to_1x_ho();
  
  sdss_common.cfg_emerg_call_1x_scan_first = FALSE;
  sdss_read_efs_emerg_call_1x_scan_first();

  sdss_common.is_avoid_lst_updated = FALSE;

  sdss_read_efs_manual_search_bst();

  /*Initialize with default value*/
  sdss_common.sd_scan_scope_rule = SYS_SCAN_SCOPE_RULE_FULL_BAND;
  sdss_common.is_scan_scope_rule_avail = FALSE;

  /*Read Scan Scope Rule*/
  sdss_read_efs_scan_scope_rule();

  sdss_read_efs_enhanced_f3_dbg_rule();

  for(i=0;i<MAX_SIMS;i++)
  {
    if(refresh_subs_mask & BM(i))
    {
    sdss_common.sub_config[i].sd_operator_name = SD_OPERATOR_NULL;
    /* Initialise FULL SRV REQ IN EMERG orig NV
    */
    sdss_common.sub_config[i].cfg_full_srv_req_in_emerg = FALSE;

    sdss_read_efs_full_srv_req_in_emerg((sys_modem_as_id_e_type)i);

    sdss_read_efs_customer_emerg_info((sys_modem_as_id_e_type)i);
    sdss_read_efs_custom_vowifi_config((sys_modem_as_id_e_type)i);
    sdss_read_efs_operator_name((sys_modem_as_id_e_type)i);
   }

  }

  /*Initialize QRD Feature enable flag
  */
  sdss_common.sd_qmss_enabled = FALSE;
  sdss_read_efs_qmss_enabled();

  sdss_read_ehrpd_opt_redial_enabled();

  sdss_common.emerg_bar_status =  SYS_LTE_EMERG_ACCESS_UNAVAILABLE;

  /*Read whether to buffer srv loss due to TRM failure*/
  sdss_common.buffer_int_srv_lost =  TRUE;
  sdss_read_buffer_int_srv_lost();
  
  sdss_common.c2k_resel_splmn_supp = FALSE;
  sdss_read_efs_c2k_resel_splmn_supp();
  sdss_reset_splmn_info(SD_MODE_CDMA);
  sdss_reset_splmn_info(SD_MODE_HDR);
  sdss_common.last_splmn_rx_mode = SYS_SYS_MODE_NONE;
  sdss_common.lte_cs_capability           = SYS_LTE_CS_CAPABILITY_NONE;

  sdss_read_efs_extend_lte_bsr_during_1x_activity();
  sdss_read_1x_sib8_scan_opt_info();

  sdss_common.is_force_kick_hybr2 = FALSE;

}//sdss_common_nv_refresh

/*===========================================================================

FUNCTION sdss_trm_get_info

DESCRIPTION
  Get TRM cap whether it supports svlte/svdo/etc.

DEPENDENCIES
  none

RETURN VALUE
  trm_simul_cap_return_data 

SIDE EFFECTS
  none

===========================================================================*/
static trm_simul_cap_return_data sdss_trm_get_info( void )
{
  trm_get_info_input_type input;
  trm_get_info_return_type output;
  trm_simul_cap_return_data mode_info;
  
  input.client_id = TRM_CM;
  input.info_type = TRM_SIMUL_CAPABILITY;
  
  trm_get_info(&input, &output);
  mode_info = output.info.simul_cap_info;

  return mode_info;
}

/*===========================================================================

FUNCTION sdss_common_init

DESCRIPTION
  Initializes a System Selection information structure.

  NOTE! This function only returns after the system selection related items
  are read from NV.

  This function only initializes the common component of the system selection.
  The parameters initialized are used across stacks.

DEPENDENCIES
  This function must be called before any other sdss_xxx is called.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static  void                          sdss_common_init( void )
{

  sdss_common.opr_mode_main      = SDSS_OPR_MODE_PWR_UP;
  sdss_common.opr_mode_hybr2     = SDSS_OPR_MODE_PWR_UP;

  /* Read and store TRM capability */
  sdss_common.trm_cap = sdss_trm_get_info();
  
  SD_MSG_HIGH_3("TRM cap: svlte %d svdo %d shdr %d",
      SYS_IS_BIT_CONTAIN(TRM_SVLTE_IS_ENABLED,sdss_common.trm_cap),
      SYS_IS_BIT_CONTAIN(TRM_SVDO_IS_ENABLED,sdss_common.trm_cap),
      SYS_IS_BIT_CONTAIN(TRM_SHDR_IS_ENABLED,sdss_common.trm_cap));

  sdss_common_nv_refresh(SYS_MODEM_AS_ID_ALL_ACTIVE_MASK);

}

/*===========================================================================

FUNCTION sdss_lte_telescope_parm_reset

DESCRIPTION
  reset LTE tele BSR parameters

DEPENDENCIES

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN          void sdss_lte_telescope_parm_reset
(
                sd_ss_e_type            ss
                /* System selection stack.
                */
)
{
  sdss_s_type *ss_ptr = NULL;
  ss_ptr = sdss_ptr(ss);

  ss_ptr->bsr_uptime_lte = BSR_UPTIME_NONE;

  /* Initialize LTE tele BSR running times to 1 */
  ss_ptr->telescope_bsr_current_loop_lte = 1;

  ss_ptr->is_skip_lte_pref_scan = FALSE;

  ss_ptr->is_lte_long_bsr = FALSE;

  ss_ptr->is_lte_tele_bsr_timer = FALSE;

  

}
/*===========================================================================

FUNCTION sdss_1x_telescope_parm_reset

DESCRIPTION
  reset main stack 1x tele BSR parameters

DEPENDENCIES

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN          void sdss_1x_telescope_parm_reset(void)
{
  sdss_s_type *ss_ptr = NULL;
  ss_ptr = sdss_ptr(SD_SS_MAIN);

  ss_ptr->bsr_uptime_1x = BSR_UPTIME_NONE;

  ss_ptr->telescope_bsr_current_loop_1x = 1;

  ss_ptr->is_skip_1x_pref_scan = FALSE;

  ss_ptr->telescope_bsr_timer_main_uptime = 0;

  ss_ptr->is_1x_bsr_timer = FALSE;

  ss_ptr->is_extend_1x_bsr_timer = FALSE;


}
/*===========================================================================

FUNCTION sdss_init_pwr_up

DESCRIPTION
  reset SDSS core variable during power up.

DEPENDENCIES

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN          void sdss_init_pwr_up
(
    sd_ss_e_type            ss
        /* System selection stack.
        */

)
{
  sdss_s_type *ss_ptr = NULL;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX);
  ss_ptr = sdss_ptr(ss);
  SD_ASSERT( ss_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initialize the sim type to NONE*/
  ss_ptr->gwl_app_type =  MMGSDI_APP_NONE;
}


/*===========================================================================

FUNCTION sdss_init_pwr_down

DESCRIPTION
  Reset SDSS core variable during power down process through LPM/FTM

DEPENDENCIES

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static void                        sdss_init_pwr_down
(
    sd_ss_e_type            ss
        /* System selection stack.
        */

)
{
  sdss_s_type *ss_ptr = NULL;
  int i;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX);
  ss_ptr = sdss_ptr(ss);

  if (ss_ptr == NULL)
    return;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initialize the service status / srv domain to no-service.
  */
  ss_ptr->srv_status      = SYS_SRV_STATUS_NO_SRV;
  ss_ptr->srv_domain      = SYS_SRV_DOMAIN_NO_SRV;

  /* Initialize the origination mode to none and indicate that last
  ** origination mode change was not done in order to end a call origination
  ** mode.
  */
  ss_ptr->orig_mode       = SD_SS_ORIG_MODE_NONE;
  ss_ptr->orig_mode_prev  = SD_SS_ORIG_MODE_NONE;

  ss_ptr->pref_reason     = SD_SS_PREF_REAS_MAX;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initialize the Previous Mode, band and roam preferences
  */
  ss_ptr->prev_mode_pref      = ss_ptr->mode_pref;
  ss_ptr->prev_band_pref      = ss_ptr->band_pref;
  ss_ptr->lte_prev_band_pref  = ss_ptr->lte_band_pref;
  ss_ptr->tds_prev_band_pref  = ss_ptr->tds_band_pref;
  ss_ptr->prev_roam_pref      = ss_ptr->roam_pref;
  ss_ptr->prev_domain_pref    = ss_ptr->domain_pref;
  ss_ptr->prev_acq_order_pref = ss_ptr->acq_order_pref;
  ss_ptr->prev_hybr_pref      = ss_ptr->hybr_pref;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Initialize PRL Support HDR Indication */
  ss_ptr->is_prl_support_hdr = FALSE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initialize stack sync up flag */
  #ifdef FEATURE_HICPS_STACK_SYNC_UP
  ss_ptr->is_stack_syncup_in_progress = FALSE;
  #endif /* FEATURE_HICPS_STACK_SYNC_UP */

  /* Initialize the SS-State to acquisition.
  */
  ss_ptr->ss_state        = SDSS_STATE_ACQ;

  /* Initialize the acquisition type to allowed.
  */
  ss_ptr->acq_type        = SDSSSCR_ACQ_ALLOWED;

  /* Initialize the acquisition start time to 0.
  */
  ss_ptr->acq_start_time  = 0;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /*  Reset the LTE connected mode fields
  */
  #ifdef LTE_CONN_MODE_OPT
  ss_ptr->lte_conn_mode_uptime = 0;
  #endif
  ss_ptr->lte_in_conn_mode = FALSE;
  ss_ptr->is_RLF_during_emerg = FALSE;
  #if defined ( FEATURE_WRLF_SYSTEM_SEL)
  ss_ptr->wcdma_in_conn_mode = FALSE;
  ss_ptr->wcdma_suitable_search_time = 0;
  #endif /* FEATURE_WRLF_SYSTEM_SEL */
  ss_ptr->new_acq_cnt = NEW_ACQ_INIT(ss);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Initialize the event counters and their start times.
  */
  for( i=0; i < (int) SDSS_CNTED_EVT_MAX; i++ )
  {
    ss_ptr->event_cnt[i] = 0;
    /* If set to 0, will never get updated. So setting it to "infinity".
    */
    ss_ptr->event_uptime[i] = ~0;
  }

  /* Reset the system SID to 0.
  */
  memset( &ss_ptr->event_sid, 0, sizeof(ss_ptr->event_sid));

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initialize the script execution control counter to 0.
  */
  ss_ptr->scr_ctrl_cnt    = 0;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initialize the redirection to none.
  */
  ss_ptr->redir                     = SD_SS_REDIR_NONE;
  ss_ptr->redir_is_valid            = FALSE;
  ss_ptr->redir_expected_sid        = SD_WILDCARD_SID;
  ss_ptr->redir_expected_nid        = SD_WILDCARD_NID;
  ss_ptr->redir_is_rif              = FALSE;
  ss_ptr->redir_is_ignore_cdma      = FALSE;
  ss_ptr->redir_max_redirect_delay  = SD_SS_MAX_REDIR_DELAY_NONE;
  ss_ptr->redir_uptime              = 0;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initialize handoff to none.
  */
  ss_ptr->handoff         = SD_SS_HO_NONE;

  /* Initialize the access reason and termination.
  */
  ss_ptr->acc_reas        = SD_SS_ACC_REAS_MAX;
  ss_ptr->acc_term        = SD_SS_ACC_TERM_NORMAL;

  /* Initialize the registration access count and start time.
  */
  ss_ptr->acc_fail_cnt        = 0;
  ss_ptr->acc_fail_start_time = ~0;

  /* Initialize the HDR session close reason to normal.
  */
  ss_ptr->ses_close       = SD_SS_SES_CLOSE_NORMAL;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initialize the true event and the event processed fields
  */
  ss_ptr->true_event              = SDSS_EVT_USER;
  ss_ptr->is_true_event_processed = FALSE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  #if defined(SD_GSM_SUPPORTED) || defined(SD_WCDMA_SUPPORTED) ||\
      defined(FEATURE_SD_LTE)
  sdss_adjust_sim_state_pwr_down(ss);
  #endif

  /* Initialize the reselection state to none.
  */
  ss_ptr->resel_state     = SDSS_RESEL_STT_NONE;

  /* Initialize the reselection mode to wait.
  */
  ss_ptr->resel_mode      = SDSS_RESEL_MODE_INIT;

  ss_ptr->acq_status      = SYS_ACQ_STATUS_SUCCESS;
  ss_ptr->is_trm_unlock_in_progress = FALSE;

  /* Initialize the hdr_activity flag.
  */
  ss_ptr->is_hdr_activity = FALSE;

  /* Initialize the throttle data structure.
  */
  sdss_thrttl_acq_init( &ss_ptr->acq_thrttl );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initialize the list and position most recently attempted acquisition to
  ** none.
  */
  ss_ptr->get_net_list_start_pos  = SDSR_POS_NULL;
  ss_ptr->get_net_list_pos        = SDSR_POS_NULL;
  ss_ptr->acq_list                = SDSR_MAX;
  ss_ptr->acq_pos                 = SDSR_POS_NULL;
  ss_ptr->last_acq_eng_ptr        = NULL;

  /* Initialize the recently acquired association tag.
  */
  sdss_addn_sys_info_init(&(ss_ptr->prev_sys_info));
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initialize the start time of the conditional wait construct.
  */
  for( i=0; i < (int) SDSSSCR_CONT_TYPE_MAX; i++)
  {
    ss_ptr->cont_uptime[i] = 0;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initialize the pref changed status to NONE.
  */
  ss_ptr->ss_pref_updated_status = SDSS_PREF_UPDATED_NONE;

  /* Initialize the system lost reason to NONE.
  */
  ss_ptr->sys_lost = SD_SS_SYS_LOST_NONE;

  /* Initialize the service request type
  */
  ss_ptr->srv_req_type            = SD_SS_SRV_REQ_TYPE_NORMAL;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initialize the script timers
  */
  ss_ptr->is_eng_scr_timer_set   = FALSE;
  ss_ptr->eng_scr_timer          = 0;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ss_ptr->bsr_timer                   = 0;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Reset the ABSR fields.
  */
  ss_ptr->absr.is_activated = FALSE;

  ss_ptr->absr.cnt = 0;

  ss_ptr->absr.num_per_bsr = 0;

  /* Initialize the MAP scan flag */
  ss_ptr->is_map_scan             = FALSE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* CDMA registration status.
  */
  ss_ptr->cdma_reg_status = SYS_REG_STATUS_NONE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Initialize HYBR2 bsr flag */
  ss_ptr->is_hybr_2_bsr            = FALSE;

  /* Initialize HYBR2 LTE IRAT flag */
  ss_ptr->is_hybr2_lte_irat_fail = FALSE;

  /* Initialize HDR DEACT BY HYBR2 BSR  flag */  
  ss_ptr->is_hdr_deact_by_hybr2_bsr = FALSE;

  /* Init LTE availble 1x to NONE */
  ss_ptr->lte_avail_1x = SDSS_LTE_AVAIL_NONE;
  ss_ptr->prev_lte_avail_1x = SDSS_LTE_AVAIL_NONE;
  ss_ptr->iBSR_pwrup = FALSE;

  ss_ptr->is_eHRPD_zone        = FALSE;

 /* Initialize plmn_list_status*/
  ss_ptr->plmn_list_status = SYS_PLMN_LIST_NONE;

  /* LTE CS capability initialisation*/
  ss_ptr->lte_cs_capability = SYS_LTE_CS_CAPABILITY_NONE;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  #if defined (FEATURE_AVOID_DUP_BAND_SCAN)

  /* Initialize avoid_dup_band_scan */
  ss_ptr->avoid_dup_band_scan.avoid_state = SDSS_AVOID_STATE_NONE;

  ss_ptr->avoid_dup_band_scan.band_to_avoid.band = SD_SS_BAND_PREF_NONE;
  ss_ptr->avoid_dup_band_scan.band_to_avoid.lte_band = sdsr_map_lte_band_pref_to_sys_rec_lte_band(SYS_LTE_BAND_MASK_CONST_NONE);
  ss_ptr->avoid_dup_band_scan.band_to_avoid.tds_band = SD_SS_BAND_PREF_NONE;

  ss_ptr->avoid_dup_band_scan.plmn_found_info.band_info.band = SD_SS_BAND_PREF_NONE;
  ss_ptr->avoid_dup_band_scan.plmn_found_info.band_info.lte_band = sdsr_map_lte_band_pref_to_sys_rec_lte_band(SYS_LTE_BAND_MASK_CONST_NONE);
  ss_ptr->avoid_dup_band_scan.plmn_found_info.band_info.tds_band = SD_SS_BAND_PREF_NONE;

  ss_ptr->avoid_dup_band_scan.is_3gpp_service_found = FALSE;
  ss_ptr->avoid_dup_band_scan.is_3gpp_scan_attempted = FALSE;
  ss_ptr->avoid_dup_band_scan.is_prev_net_sel_type_limited = FALSE;

  ss_ptr->avoid_dup_band_scan.acq_info_3gpp.is_plmn_found = FALSE;
  ss_ptr->avoid_dup_band_scan.acq_info_3gpp.service_status = SYS_SRV_STATUS_NONE;

  #endif

  ss_ptr->is_in_srv_lost_state = FALSE;

  ss_ptr->is_loc_based_bsr = FALSE;
  ss_ptr->is_loc_chg_move_out = FALSE;
  ss_ptr->is_mcc_match_found = FALSE;

  sdss_lte_telescope_parm_reset(ss);

  ss_ptr->is_override_e911_add_info = FALSE;

  sdss_reset_more_pref_plmn_list(ss);
  ss_ptr->is_special_volte_redial = FALSE;
}


/*===========================================================================

FUNCTION sdss_common_set_acq_info

DESCRIPTION
  Reset acq info stored in SDSS common global state.

===========================================================================*/
void  sdss_component_reset(void)
{
  sdss_common_set_acq_info();

  sdss_init_pwr_down( SD_SS_MAIN );
  sdss_eng_stack_init( &sdss_eng_stack,
                       sdss_eng_arr,
                       ARR_SIZE(sdss_eng_arr) );

  #if defined FEATURE_HDR_HYBRID
  sdss_init_pwr_down( SD_SS_HYBR_1 );
  sdss_eng_stack_init( &sdss_hybr_1_eng_stack,
                       sdss_hybr_1_eng_arr,
                       ARR_SIZE(sdss_hybr_1_eng_arr) );
  #endif

  #if defined(FEATURE_MMODE_DUAL_SIM) || defined FEATURE_MMODE_SC_SVLTE ||\
      defined(FEATURE_MMODE_SC_SGLTE)
  sdss_init_pwr_down( SD_SS_HYBR_2 );
  sdss_eng_stack_init(&sdss_hybr_2_eng_stack,
                      sdss_hybr_2_eng_arr,
                      ARR_SIZE(sdss_hybr_2_eng_arr) );
  #endif

  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  sdss_init_pwr_down( SD_SS_HYBR_3 );
  sdss_eng_stack_init(&sdss_hybr_3_eng_stack,
                      sdss_hybr_3_eng_arr,
                      ARR_SIZE(sdss_hybr_3_eng_arr) );
  #endif
}
/*===========================================================================

FUNCTION sdss_nv_refresh

DESCRIPTION
  Reads SD NVs

DEPENDENCIES
  None

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static void                    sdss_nv_refresh(

        sd_ss_e_type            ss
            /* System selection stack.
            */
)
{
  sdss_s_type *ss_ptr = NULL;
  int32 read_size = 0;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX);
  ss_ptr = sdss_ptr(ss);
  SD_ASSERT( ss_ptr != NULL );



 if ( sdefs_fs_read_per_subs ( SDEFS_MANUAL_SEARCH_IN_WRLF,
                    (byte*)&ss_ptr->manual_search_in_wrlf,
                         &read_size,
                         sdss_map_ss_to_as_id(ss)))
  {

    SD_MSG_HIGH_1 ("Domsel:Read /nv/item_files/modem/mmode/sd/manual_search_in_wrlf = %d. ",\
                           ss_ptr->manual_search_in_wrlf );
  }
  else 
  {
    ss_ptr->manual_search_in_wrlf       = FALSE ;
  }

  /* read custom emerg info before using that to read emerg_rat_acq_order */
  sdss_read_efs_customer_emerg_info(sdss_map_ss_to_as_id(ss));
  
  if(sdss_is_ral_stored_in_efs(ss))
  {
    /* read emergency rat acq order from EFS and store in sdss for later use 
       in emergency mode. not updated on the fly */
    sdss_extract_emerg_rat_acq_order(ss);
  }

} /* sdss_nv_refresh */

/*===========================================================================

FUNCTION sdss_init

DESCRIPTION
  Initializes a System Selection information structure.

  NOTE! This function only returns after the system selection related items
  are read from NV.

DEPENDENCIES
  This function must be called before any other sdss_xxx is called.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
  void                    sdss_init(

        sd_ss_e_type            ss
            /* System selection stack.
            */
)
{
  sdss_s_type *ss_ptr = NULL;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  int i;
  uint32 j=0;
  int32 read_size = 0;

  sd_ss_mode_pref_e_type mode_capability = SD_SS_MODE_PREF_NONE;
  sd_ss_band_pref_e_type band_capability = SD_SS_BAND_PREF_NONE;
  sys_lte_band_mask_e_type lte_band_capability = SYS_LTE_BAND_MASK_CONST_NONE;
  sd_ss_band_pref_e_type tds_band_capability = SD_SS_BAND_PREF_NONE;

  sys_rat_pri_list_info_s_type    ss_rat_pri_list_info;
  #ifdef FEATURE_EOOS
  #error code not present
#endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX);
  ss_ptr = sdss_ptr(ss);
  SD_ASSERT( ss_ptr != NULL );


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initialize the SS-Core variables.
  */

  /* Initialize the service status / srv domain to no-service.
  */
  ss_ptr->srv_status      = SYS_SRV_STATUS_NO_SRV;
  ss_ptr->srv_domain      = SYS_SRV_DOMAIN_NO_SRV;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initialize the origination mode to none and indicate that last
  ** origination mode change was not done in order to end a call origination
  ** mode.
  */
  ss_ptr->orig_mode       = SD_SS_ORIG_MODE_NONE;
  ss_ptr->orig_mode_prev  = SD_SS_ORIG_MODE_NONE;
  ss_ptr->idle_orig_mode  = SD_SS_ORIG_MODE_NONE;

  ss_ptr->pref_reason     = SD_SS_PREF_REAS_MAX;

  /* Initialize the Mode, band and roam preferences to ANY.
  */
  ss_ptr->mode_pref           = SD_SS_MODE_PREF_ANY;
  ss_ptr->band_pref           = SD_SS_BAND_PREF_ANY;
  ss_ptr->lte_band_pref       = SYS_LTE_BAND_MASK_CONST_ANY;
  ss_ptr->tds_band_pref       = SD_SS_BAND_PREF_TDS_ANY;
  ss_ptr->true_mode_pref      = SD_SS_MODE_PREF_ANY;
  ss_ptr->roam_pref           = SD_SS_ROAM_PREF_ANY;
  ss_ptr->domain_pref         = SD_SS_SRV_DOMAIN_PREF_CS_ONLY;
  ss_ptr->acq_order_pref      = SD_SS_ACQ_ORDER_PREF_AUTO;
  ss_ptr->user_mode_pref      = SD_SS_MODE_PREF_ANY;
  ss_ptr->user_true_mode_pref = SD_SS_MODE_PREF_ANY;
  ss_ptr->user_band_pref      = SD_SS_BAND_PREF_ANY;
  ss_ptr->hybr_pref           = SD_SS_HYBR_PREF_NONE;
  /* Set operator capability default to ANY to allow all records */
  ss_ptr->operator_capability = SD_SS_MODE_PREF_ANY;

  /* Initialize the Previous Mode, band and roam preferences
  */
  ss_ptr->prev_mode_pref      = ss_ptr->mode_pref;
  ss_ptr->prev_band_pref      = ss_ptr->band_pref;
  ss_ptr->lte_prev_band_pref  = ss_ptr->lte_band_pref;
  ss_ptr->tds_prev_band_pref  = ss_ptr->tds_band_pref;
  ss_ptr->prev_roam_pref      = ss_ptr->roam_pref;
  ss_ptr->prev_domain_pref    = ss_ptr->domain_pref;
  ss_ptr->prev_acq_order_pref = ss_ptr->acq_order_pref;
  ss_ptr->prev_hybr_pref      = SD_SS_HYBR_PREF_NONE;
  read_size = sizeof (boolean);

  sdss_nv_refresh(ss);
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Initialize PRL Support HDR Indication */
  ss_ptr->is_prl_support_hdr = FALSE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Initialize stack sync up flag */
  #ifdef FEATURE_HICPS_STACK_SYNC_UP
  ss_ptr->is_stack_syncup_in_progress = FALSE;
  #endif /* FEATURE_HICPS_STACK_SYNC_UP */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Initialize MMSS operation state  flag */
  ss_ptr->is_mmss_operation           = FALSE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initialize the SS-State to acquisition.
  */
  ss_ptr->ss_state        = SDSS_STATE_ACQ;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initialize the acquisition type to allowed.
  */
  ss_ptr->acq_type        = SDSSSCR_ACQ_ALLOWED;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initialize the acquisition start time to 0.
  */
  ss_ptr->acq_start_time  = 0;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /*  Reset the LTE connected mode fields
  */
  #ifdef LTE_CONN_MODE_OPT
  ss_ptr->lte_conn_mode_uptime = 0;
  #endif
  ss_ptr->lte_in_conn_mode = FALSE;
  ss_ptr->is_RLF_during_emerg = FALSE;
  #if defined ( FEATURE_WRLF_SYSTEM_SEL)
  ss_ptr->wcdma_in_conn_mode = FALSE;
  ss_ptr->wcdma_suitable_search_time = 0;
  #endif /* FEATURE_WRLF_SYSTEM_SEL */


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initialize the new-acquisition counter to 200.
  */
  ss_ptr->new_acq_cnt     = NEW_ACQ_INIT(ss);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Initialize the event counters and their start times.
  */
  for( i=0; i < (int) SDSS_CNTED_EVT_MAX; i++ )
  {
    ss_ptr->event_cnt[i] = 0;
    /* If set to 0, will never get updated. So setting it to "infinity".
    */
    ss_ptr->event_uptime[i] = ~0;
  }

  /* Reset the system SID to 0.
  */
  memset( &ss_ptr->event_sid, 0, sizeof(ss_ptr->event_sid));

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initialize the script execution control counter to 0.
  */
  ss_ptr->scr_ctrl_cnt    = 0;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initialize the redirection to none.
  */
  ss_ptr->redir                     = SD_SS_REDIR_NONE;
  ss_ptr->redir_is_valid            = FALSE;
  ss_ptr->redir_expected_sid        = SD_WILDCARD_SID;
  ss_ptr->redir_expected_nid        = SD_WILDCARD_NID;
  ss_ptr->redir_is_rif              = FALSE;
  ss_ptr->redir_is_ignore_cdma      = FALSE;
  ss_ptr->redir_max_redirect_delay  = SD_SS_MAX_REDIR_DELAY_NONE;
  ss_ptr->redir_uptime              = 0;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initialize handoff to none.
  */
  ss_ptr->handoff         = SD_SS_HO_NONE;

  /* Initialize the access reason and termination.
  */
  ss_ptr->acc_reas        = SD_SS_ACC_REAS_MAX;
  ss_ptr->acc_term        = SD_SS_ACC_TERM_NORMAL;

  /* Initialize the registration access count and start time.
  */
  ss_ptr->acc_fail_cnt        = 0;
  ss_ptr->acc_fail_start_time = ~0;

  /* Initialize the HDR session close reason to normal.
  */
  ss_ptr->ses_close       = SD_SS_SES_CLOSE_NORMAL;

  /* Initialize the CDMA locked until power cycle indication to FALSE.
  */
  ss_ptr->is_cmda_locked  = FALSE;

  /* Initialize the sim state to unavailable
  */
  ss_ptr->sim_state       = SYS_SIM_STATE_NOT_AVAILABLE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initialize the AMPS backstop indication.
  */
  ss_ptr->is_srda = FALSE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initialize the true event and the event processed fields
  */
  ss_ptr->true_event              = SDSS_EVT_USER;
  ss_ptr->is_true_event_processed = FALSE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initialize the reselection state to none.
  */
  ss_ptr->resel_state     = SDSS_RESEL_STT_NONE;

  /* Initialize the reselection mode to wait.
  */
  ss_ptr->resel_mode      = SDSS_RESEL_MODE_INIT;

  ss_ptr->acq_status      = SYS_ACQ_STATUS_SUCCESS;

  ss_ptr->is_trm_unlock_in_progress = FALSE;

  /* Initialize the subscription availability status.
  */
  ss_ptr->is_gw_subsc_avail = FALSE;
  ss_ptr->is_1x_subsc_avail = FALSE;

  /* Initialize the hdr_activity flag.
  */
  ss_ptr->is_hdr_activity = FALSE;
  
  /* Initialize the throttle data structure.
  */
  sdss_thrttl_acq_init( &ss_ptr->acq_thrttl );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* initialize RAT priority structures */
  memset( &ss_ptr->prev_rat_pri_list_info, 0, sizeof(ss_ptr->prev_rat_pri_list_info));
  memset( &ss_ptr->idle_rat_pri_list_info, 0, sizeof(ss_ptr->idle_rat_pri_list_info));
  memset( &ss_ptr->emerg_rat_pri_list_info, 0, sizeof(ss_ptr->emerg_rat_pri_list_info));


  sdss_get_mode_band_capability_mmode(&mode_capability,
                                      &band_capability,
                                      &lte_band_capability,
                                      &tds_band_capability);

  /* Initialize RAT priority list structure
  */
  sdss_get_rat_pri_list_info(ss, &ss_rat_pri_list_info);

  for( i=0,j=0; i < (int)ss_ptr->rat_acq_order.num_rat; i++ )
  {
    if (j >= SYS_MAX_ACQ_PREF_RAT_LIST_NUM)
    {
      SD_ERR_1("priority_list_info idx = %d, out of boundary",j);
      break;
    }

    if( sdss_is_supp_mode_band(ss_ptr->rat_acq_order.acq_sys_mode[i],
                               band_capability,
                               lte_band_capability,
                               tds_band_capability )
      )
    {

      /* Hardcoded to MAX value for phase 2.0 */
      ss_rat_pri_list_info.priority_list_info[j].acq_sys_time_interval =
                                             SYS_ACQ_SYS_TIME_INTERVAL_MAX;

      ss_rat_pri_list_info.priority_list_info[j].acq_sys_mode =
                                       ss_ptr->rat_acq_order.acq_sys_mode[i];

      if ( ss_ptr->rat_acq_order.acq_sys_mode[i] == SYS_SYS_MODE_LTE ) {
          ss_rat_pri_list_info.priority_list_info[j].band_cap.lte_band_cap =
            lte_band_capability;
      } else if ( ss_ptr->rat_acq_order.acq_sys_mode[i] == SYS_SYS_MODE_TDS) {
          ss_rat_pri_list_info.priority_list_info[j].band_cap.chgwt_band_cap =
            tds_band_capability;
      } else {
          ss_rat_pri_list_info.priority_list_info[j].band_cap.chgwt_band_cap =
                                               band_capability;
      }

      j++;
    }
  }
  ss_rat_pri_list_info.num_items = j;

  sdss_set_rat_pri_list_info(ss, &ss_rat_pri_list_info);

  #if defined(FEATURE_EOOS)
#error code not present
#endif



  #if defined(FEATURE_EOOS_UMTS)
  sdss_init_capability(ss);
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initialize the get network band/mode preference, list, start position
  ** and list position.
  */
  ss_ptr->get_net_band_pref       = SD_SS_BAND_PREF_ANY;
  ss_ptr->get_net_band_pref_lte   = SYS_LTE_BAND_MASK_CONST_ANY;
  ss_ptr->get_net_mode_pref       = SD_SS_MODE_PREF_ANY;
  ss_ptr->get_net_list            = SDSR_MAX_LST;
  ss_ptr->get_net_list_start_pos  = SDSR_POS_NULL;
  ss_ptr->get_net_list_pos        = SDSR_POS_NULL;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initialize the list and position most recently attempted acquisition to
  ** none.
  */
  ss_ptr->acq_list                  = SDSR_MAX;
  ss_ptr->acq_pos                   = SDSR_POS_NULL;
  ss_ptr->last_acq_eng_ptr          = NULL;

  /* Initialize the recently acquired association tag.
  */
  sdss_addn_sys_info_init(&(ss_ptr->prev_sys_info));
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initialize the start time of the conditional wait construct.
  */
  for( i=0; i < (int) SDSSSCR_CONT_TYPE_MAX; i++)
  {
    ss_ptr->cont_uptime[i] = 0;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initialize the pref changed status to NONE.
  */
  ss_ptr->ss_pref_updated_status = SDSS_PREF_UPDATED_NONE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initialize the system lost reason to NONE.
  */
  ss_ptr->sys_lost = SD_SS_SYS_LOST_NONE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #ifdef FEATURE_EOOS
  #error code not present
#endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initialize the service request type
  */
  ss_ptr->srv_req_type            = SD_SS_SRV_REQ_TYPE_NORMAL;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initialize the script timers
  */
  ss_ptr->is_eng_scr_timer_set   = FALSE;
  ss_ptr->eng_scr_timer          = 0;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ss_ptr->bsr_timer                   = 0;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Reset the ABSR fields.
  */
  ss_ptr->absr.is_activated = FALSE;

  ss_ptr->absr.cnt = 0;

  ss_ptr->absr.num_per_bsr = 0;

  /* Initialize the MAP scan flag */
  ss_ptr->is_map_scan             = FALSE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* CDMA registration status.
  */
  ss_ptr->cdma_reg_status = SYS_REG_STATUS_NONE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  #ifdef FEATURE_EOOS
  #error code not present
#endif
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ss_ptr->n_min_voice_scans =
                    sdssscr_efs_item_get(SDSSSCR_EFS_ITEM_N_MIN_VOICE_SCANS,
                      sdss_map_ss_to_as_id(ss));

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Initialize HYBR2 bsr flag */
  ss_ptr->is_hybr_2_bsr            = FALSE;


  /* Initialize HYBR2 LTE IRAT flag */
  ss_ptr->is_hybr2_lte_irat_fail = FALSE;
  ss_ptr->is_hdr_deact_by_hybr2_bsr = FALSE;

  ss_ptr->iBSR_pwrup = FALSE;

  /* Init LTE availble 1x to NONE */
  ss_ptr->lte_avail_1x = SDSS_LTE_AVAIL_NONE;
  ss_ptr->prev_lte_avail_1x = SDSS_LTE_AVAIL_NONE;

  ss_ptr->is_eHRPD_zone        = FALSE;


/* Initialize plmn_list_status*/
  ss_ptr->plmn_list_status = SYS_PLMN_LIST_NONE;

  /* LTE CS capability initialisation*/
  ss_ptr->lte_cs_capability = SYS_LTE_CS_CAPABILITY_NONE;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  #if defined (FEATURE_AVOID_DUP_BAND_SCAN)

  /* Initialize avoid_dup_band_scan */
  ss_ptr->avoid_dup_band_scan.avoid_state = SDSS_AVOID_STATE_NONE;

  ss_ptr->avoid_dup_band_scan.band_to_avoid.band = SD_SS_BAND_PREF_NONE;
  ss_ptr->avoid_dup_band_scan.band_to_avoid.lte_band = sdsr_map_lte_band_pref_to_sys_rec_lte_band(SYS_LTE_BAND_MASK_CONST_NONE);
  ss_ptr->avoid_dup_band_scan.band_to_avoid.tds_band = SD_SS_BAND_PREF_NONE;

  ss_ptr->avoid_dup_band_scan.emerg_band_to_avoid.band = SD_SS_BAND_PREF_NONE;
  ss_ptr->avoid_dup_band_scan.emerg_band_to_avoid.lte_band = sdsr_map_lte_band_pref_to_sys_rec_lte_band(SYS_LTE_BAND_MASK_CONST_NONE);
  ss_ptr->avoid_dup_band_scan.emerg_band_to_avoid.tds_band = SD_SS_BAND_PREF_NONE;

  ss_ptr->avoid_dup_band_scan.plmn_found_info.band_info.band = SD_SS_BAND_PREF_NONE;
  ss_ptr->avoid_dup_band_scan.plmn_found_info.band_info.lte_band = sdsr_map_lte_band_pref_to_sys_rec_lte_band(SYS_LTE_BAND_MASK_CONST_NONE);
  ss_ptr->avoid_dup_band_scan.plmn_found_info.band_info.tds_band = SD_SS_BAND_PREF_NONE;

  ss_ptr->avoid_dup_band_scan.is_3gpp_service_found = FALSE;
  ss_ptr->avoid_dup_band_scan.is_3gpp_scan_attempted = FALSE;
  ss_ptr->avoid_dup_band_scan.is_prev_net_sel_type_limited = FALSE;

  ss_ptr->avoid_dup_band_scan.acq_info_3gpp.is_plmn_found = FALSE;
  ss_ptr->avoid_dup_band_scan.acq_info_3gpp.service_status = SYS_SRV_STATUS_NONE;

  #endif

  ss_ptr->is_in_srv_lost_state = FALSE;

  ss_ptr->is_loc_based_bsr = FALSE;
  ss_ptr->is_loc_chg_move_out = FALSE;
  ss_ptr->is_mcc_match_found = FALSE;
  sdss_lte_telescope_parm_reset(ss);
  sdss_1x_telescope_parm_reset();

  sdss_lte_telescope_parm_reset(ss);

  ss_ptr->is_non_rplmn_csg_selection = FALSE;
  ss_ptr->remove_gwl_on_bsr = FALSE;
  ss_ptr->is_full_srv_req_during_emerg = FALSE;
  ss_ptr->is_override_e911_add_info = FALSE;

  memset( &ss_ptr->mcc_list_info, 0, sizeof(ss_ptr->mcc_list_info));

  ss_ptr->is_pref_chg_in_ltd_reg = FALSE;
  ss_ptr->is_dds_switchback_from_temp = FALSE;

  sdss_reset_more_pref_plmn_list(ss);
  ss_ptr->is_special_volte_redial = FALSE;
  ss_ptr->is_volte_call_on = FALSE;

} /* sdss_init */


/*===========================================================================

FUNCTION sdss_nv_init

DESCRIPTION
Initializes the NV parameters

DEPENDENCIES
  This function must be called before any other sdss_xxx is called.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                    sdss_nv_init(

        sd_ss_e_type            ss
            /* System selection stack
            */
)
{

  sdss_s_type *ss_ptr = sdss_ptr( ss );

  /*lint -save -e826 */ /*Suspicious pointer-to-pointer conversion*/
  sdnv_data_s_type          buf;
  nv_item_type              *item_ptr               = (nv_item_type*) &buf;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( ss_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Read gprs_anite_gcf from nv.
  */
  (void) sdnv_read(NV_GPRS_ANITE_GCF_I,item_ptr);

   ss_ptr->gprs_anite_gcf          = item_ptr->gprs_anite_gcf;

   SD_MSG_HIGH_2("sdss_nv_init()-ss:%d,gcf:%d",ss,
                ss_ptr->gprs_anite_gcf);
}


/*===========================================================================

FUNCTION sdss_lbsr_mcc_items_init

DESCRIPTION
  Read the values that are stored in EFS. Use defaults
  when items not available in EFS.

DEPENDENCIES
  sdefs_init() must have already been called to initialize the SD EFS-Interface
  component.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_lbsr_mcc_items_init( void )
{
  unsigned int i;
  int32 efs_read_size = sizeof (sdss_lbsr_mcc_list_s_type);

  /* Default values for the configurable SD values stored in EFS.
  */
  const sdss_lbsr_mcc_list_s_type sdss_lbsr_mcc_list_default = {


    /* Total number of entries used in the NV array.
    */
    SD_NV_ITEM_MCC_LIST_MAX,

    /* Default values for all the items stored in the EFS array. */
    {
      /* 0 */
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    }
  };

  sdss_lbsr_mcc_list_s_type sdss_lbsr_mcc_list_store = {0};

  if( !sdefs_read(SDEFS_LBSR_MCC_LIST,
                  (byte*)&sdss_lbsr_mcc_list_store,
                  &efs_read_size))
  {
    sdss_lbsr_mcc_list_store = sdss_lbsr_mcc_list_default;

    #ifndef FEATURE_DISABLE_SD_INIT_NV_WRITE
    SD_MSG_HIGH_0( "Writing default mcc list items to EFS");
    (void)sdefs_write(SDEFS_LBSR_MCC_LIST, (byte *)&sdss_lbsr_mcc_list_store,
                      sizeof(sdss_lbsr_mcc_list_store));
    #endif
  }

  /* Copy SD values into local structure .
  */
  sdss_lbsr_mcc_list.count = sdss_lbsr_mcc_list_store.count;
  for(i=0; i < sdss_lbsr_mcc_list_store.count &&
           i < ARR_SIZE(sdss_lbsr_mcc_list.mcc_list); i++)
  {
    sdss_lbsr_mcc_list.mcc_list[i] = sdss_lbsr_mcc_list_store.mcc_list[i];
  }
} /*sdss_lbsr_mcc_items_init*/


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_component_init

DESCRIPTION
  Initializes the SS-Core component.

  NOTE! This function only returns after the system selection related items
  are read from NV.

DEPENDENCIES
  This function must be called before any other sdss_xxx is called.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                    sdss_component_init( void )
{


  /* Initializes the System Selection information structutre.
  */
  sdss_common_init();

  /* Get the rat_acq_order information from PM
  ** Should be called before sdss_init()
  */
  sdss_read_policyman_tot();

  sdss_init( SD_SS_MAIN );

  /* Initializes the SS-Script-engine stack.
  */
  sdss_eng_stack_init( &sdss_eng_stack,
                       sdss_eng_arr,
                       ARR_SIZE(sdss_eng_arr) );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #if (defined(FEATURE_HDR_HYBRID))
  /* If the input system selection is HDR, point at HDR engine stack.
  */
   /* Initializes the HDR System Selection information structutre.
  */
  sdss_init( SD_SS_HYBR_1 );

  /* Initializes the HDR SS-Script-engine stack.
  */
  sdss_eng_stack_init( &sdss_hybr_1_eng_stack,
                       sdss_hybr_1_eng_arr,
                       ARR_SIZE(sdss_hybr_1_eng_arr) );
  #endif /* FEATURE_HDR_HYBRID */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  #if defined FEATURE_MMODE_DUAL_SIM || defined FEATURE_MMODE_SC_SVLTE || defined FEATURE_MMODE_SC_SGLTE

  sdss_init( SD_SS_HYBR_2 );

  sdss_eng_stack_init(&sdss_hybr_2_eng_stack,
                      sdss_hybr_2_eng_arr,
                      ARR_SIZE(sdss_hybr_2_eng_arr) );

  #endif //defined FEATURE_MMODE_SC_SVLTE

  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)

  sdss_init( SD_SS_HYBR_3 );

  sdss_eng_stack_init(&sdss_hybr_3_eng_stack,
                      sdss_hybr_3_eng_arr,
                      ARR_SIZE(sdss_hybr_3_eng_arr) );

  #endif //defined FEATURE_MMODE_TRIPLE_SIM

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

} /* sdss_component_init */




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_srda_enabled_update

DESCRIPTION
  Update the srda field in SS-Core component.

DEPENDENCIES

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                    sdss_srda_enabled_update( boolean enabled )
{
  sdss_s_type    *ss_ptr;


  ss_ptr = sdss_ptr( SD_SS_MAIN );
  ss_ptr->is_srda = enabled;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #if ( defined(FEATURE_HDR_HYBRID))
  ss_ptr = sdss_ptr( SD_SS_HYBR_1 );
  ss_ptr->is_srda = enabled;
  #endif

}/* sdss_srda_enabled_update */




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_is_event_allowed

DESCRIPTION
  Check whether SS-Event is allowed in the current mode of operation.

DEPENDENCIES
  sdss_init() must have already been called to initialize the System
  Selection Core (SS-Core).

RETURN VALUE
  TRUE if SS-Event is allowed in the current operating mode. FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean               sdss_is_event_allowed(

        sdss_evt_e_type       event,
            /* SS-Event received from SS-Front-end.
            */

        sdss_state_e_type     ss_state,
            /* Current SS-State.
            */

        sdss_opr_mode_e_type  opr_mode
            /* Current operating mode.
            */
)
{

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( event, SDSS_EVT_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( ss_state, SDSS_STATE_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( opr_mode, SDSS_OPR_MODE_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Decide whether SS-Event is allowed in the current operating mode.
  */
  switch( opr_mode )
  {
    case SDSS_OPR_MODE_PWR_UP:

      /* Only the following events are allowed while powering-up.
      */
      if( SDSS_EVT_IS_USER(event)        ||
          SDSS_EVT_IS_HDR_USER(event)    ||
          SDSS_EVT_IS_HYBR_1_USER(event) ||
          SDSS_EVT_IS_HYBR_2_USER(event) ||
          SDSS_EVT_IS_HYBR_3_USER(event) )
      {
        return TRUE;
      }
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_OPR_MODE_ONLINE:

      /* Only the following events are allowed while in online.
      */
      if( SDSS_EVT_IS_USER(event)        ||
          SDSS_EVT_IS_MISC(event)        ||
          SDSS_EVT_IS_HDR_USER(event)    ||
          SDSS_EVT_IS_HYBR_1_USER(event) ||
          SDSS_EVT_IS_HYBR_2_USER(event) ||
          SDSS_EVT_IS_HYBR_3_USER(event))
      {
        return TRUE;
      }

      switch( ss_state )
      {
        case SDSS_STATE_ACQ:
        case SDSS_STATE_PWR_SAVE:
          if( SDSS_EVT_IS_CDMA_ACQ(event) ||
              SDSS_EVT_IS_AMPS_ACQ(event) ||
              SDSS_EVT_IS_HDR_ACQ(event)  ||
              SDSS_EVT_IS_GWL_ACQ(event)  ||
              SDSS_EVT_IS_HYBR_2_GW_ACQ(event) ||
              SDSS_EVT_IS_HYBR_3_GW_ACQ(event) ||
              SDSS_EVT_IS_RAT_CHANGE(event))
          {
            return TRUE;
          }
          break;

        case SDSS_STATE_VRFY:
          if( SDSS_EVT_IS_CDMA_OPR(event) ||
              SDSS_EVT_IS_AMPS_OPR(event) ||
              SDSS_EVT_IS_HDR_OPR(event)  ||
              SDSS_EVT_IS_GWL_OPR(event)  ||
              SDSS_EVT_IS_HYBR_2_GW_OPR(event) ||
              SDSS_EVT_IS_HYBR_3_GW_OPR(event) ||
              SDSS_EVT_IS_GWL_ACQ(event) ||
              SDSS_EVT_IS_HYBR_2_GW_ACQ(event) ||
              SDSS_EVT_IS_HYBR_3_GW_ACQ(event))

          {
            return TRUE;
          }
          break;

        case SDSS_STATE_OPR:
          if( SDSS_EVT_IS_CDMA_OPR(event) ||
              SDSS_EVT_IS_AMPS_OPR(event) ||
              SDSS_EVT_IS_HDR_OPR(event)  ||
              SDSS_EVT_IS_GWL_OPR(event)  ||
              SDSS_EVT_IS_HYBR_2_GW_OPR(event) ||
              SDSS_EVT_IS_HYBR_3_GW_OPR(event))
          {
            return TRUE;
          }
          break;

        case SDSS_STATE_MAX:
        default:
          SD_ERR_0( "state");
          break;
      }
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_OPR_MODE_OFFLINE_CDMA:

      /* Only the following events are allowed while in offline CDMA mode.
      */
      if( SDSS_EVT_IS_USER(event)       ||
          SDSS_EVT_IS_HDR_USER(event)   ||
          SDSS_EVT_IS_HYBR_1_USER(event)||
          SDSS_EVT_IS_CDMA(event)       ||
          SDSS_EVT_IS_MISC(event)       ||
          SDSS_EVT_IS_HYBR_2_USER(event) ||
          SDSS_EVT_IS_HYBR_3_USER(event))
      {
        return TRUE;
      }
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_OPR_MODE_OFFLINE_AMPS:

      /* Only the following events are allowed while in offline AMPS mode.
      */
      if( SDSS_EVT_IS_USER(event)        ||
          SDSS_EVT_IS_HDR_USER(event)    ||
          SDSS_EVT_IS_HYBR_1_USER(event) ||
          SDSS_EVT_IS_AMPS(event)        ||
          SDSS_EVT_IS_MISC(event)        ||
          SDSS_EVT_IS_HYBR_2_USER(event) ||
          SDSS_EVT_IS_HYBR_3_USER(event))
      {
        return TRUE;
      }
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_OPR_MODE_PWR_DOWN:

      /* Only the following events are allowed while in Power-down, reset or
      ** or LPM mode.
      */
      if( SDSS_EVT_IS_USER(event)        ||
          SDSS_EVT_IS_HDR_USER(event)    ||
          SDSS_EVT_IS_HYBR_1_USER(event) ||
          SDSS_EVT_IS_MISC(event)        ||
          SDSS_EVT_IS_HYBR_2_USER(event) ||
          SDSS_EVT_IS_HYBR_3_USER(event))
      {
        return TRUE;
      }
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_OPR_MODE_MAX:
    default:
      SD_ERR_0( "opr_mode");

  } /* switch */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If we got here, the SS-Event is not allowed in the current operating
  ** mode - return FALSE.
  */
  return FALSE;

} /* sdss_is_event_allowed */




/* <EJECT> */
/*===========================================================================

FUNCTION sdss_event_recovery

DESCRIPTION
  Performs error recovery when the SS-Client reports a system selection event
  that is not allowed relative to the current state of SD or when the END
  script construct is reached.

DEPENDENCIES
  sdss_init() must have already been called to initialize the System
  Selection Core (SS-Core).

RETURN VALUE
  TRUE if event processing should continue, FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean               sdss_event_recovery(

        sd_ss_e_type          ss,
            /* System selection stack.
            */

        sdss_evt_e_type       *event_ptr,
            /* Pointer to SS-Event received from SS-Front-end.
            */

        sdss_iact_s_type      *rtrn_iact_ptr
            /* Pointer to a buffer where to place returned internal action.
            */
)
{
  sdss_evt_e_type   event;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( event_ptr != NULL )
  SD_ASSERT( rtrn_iact_ptr != NULL )

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  event = *event_ptr;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( event, SDSS_EVT_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Catch all the events that should not be further processed, set the an
  ** appropriate return SS-Action and return FALSE to indicate that no
  ** further processing should be done.
  */
  switch( event )
  {
    /* User events.
    */
    case SDSS_EVT_USER_OFFLINE_CDMA:
    case SDSS_EVT_USER_OFFLINE_AMPS:
    case SDSS_EVT_USER_PWR_DOWN:
      rtrn_iact_ptr->act = SDSS_IACT_CONTINUE;
      return FALSE;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /* CDMA events.
    */
    case SDSS_EVT_CDMA_OPR_REDIR:
      rtrn_iact_ptr->act = SDSS_IACT_REJECT;
      return FALSE;

    case SDSS_EVT_CDMA_OPR_CAM:
    case SDSS_EVT_CDMA_OPR_HDM:
    case SDSS_EVT_CDMA_OPR_ITSPM:
    #if defined(FEATURE_LTE_TO_1X)
    case SDSS_EVT_CDMA_OPR_RELEASE:
    case SDSS_EVT_CDMA_OPR_ACC_TERM:
    #endif

      rtrn_iact_ptr->act = SDSS_IACT_CONTINUE;
      return FALSE;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /* AMPS events.
    */
    case SDSS_EVT_AMPS_OPR_ACC_SID:
      rtrn_iact_ptr->act = SDSS_IACT_REJECT;
      return FALSE;

    case SDSS_EVT_AMPS_OPR_CAM:
      rtrn_iact_ptr->act = SDSS_IACT_CONTINUE;
      return FALSE;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /* HDR events.
    */

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /* Misc.
    */
    case SDSS_EVT_MISC_ORIG_SUCCESS:
    case SDSS_EVT_MISC_PWR_SAVE_ENTER:
    case SDSS_EVT_MISC_IRAT_TO_GWL:
    case SDSS_EVT_MISC_CNF:
      rtrn_iact_ptr->act = SDSS_IACT_CONTINUE;
      return FALSE;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /* All other events
    */
    default:
      break;

  } /* switch( event ) */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If we got here, this event can be processed as power-up event, so set
  ** the returned event according to the SS item and return TRUE to indicate
  ** that further processing should be done.
  */
  switch ( ss )
  {

    case SD_SS_HYBR_1:
      *event_ptr = SDSS_EVT_HDR_USER_HYBR_START;
      break;

    case SD_SS_HYBR_2:
      *event_ptr = SDSS_EVT_HYBR_2_USER_PWR_UP;
      break;

    case SD_SS_HYBR_3:
      *event_ptr = SDSS_EVT_HYBR_3_USER_PWR_UP;
      break;

    case SD_SS_MAIN:
    case SD_SS_MAX:
    default:
      *event_ptr = SDSS_EVT_USER_PWR_UP;
      break;
  }

  return TRUE;

} /* sdss_event_recovery */



/* <EJECT> */
/*===========================================================================

FUNCTION sdss_event_proc

DESCRIPTION
  Process an SS-Event called for by the SS-Front-end and instruct the
  SS-Front-end of the next SS-Internal-Action to take.

DEPENDENCIES
  sdss_init() must have already been called to initialize the System
  Selection Core (SS-Core).

RETURN VALUE
  None

  Note that SS-Internal-Action to be taken by the SS-Front-end is returned
  through the rtrn_iact_ptr parameter.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                  sdss_event_proc(

        sd_ss_e_type          ss,
          /* System selection stack
          */

        sdss_evt_e_type       event,
            /* SS-Event to process.
            */

        sdss_iact_s_type      *rtrn_iact_ptr
            /* Pointer to a buffer where to place returned internal action.
            */
)
{
  sdss_s_type             *ss_ptr         = sdss_ptr(ss);
  sd_ss_mode_pref_e_type  mode_pref;
  sdss_eng_stack_s_type   *eng_stack_ptr  = &sdss_eng_stack;
  sdss_opr_mode_e_type    ss_opr_mode     = sdss_get_opr_mode(ss);
  sdss_state_e_type       curr_ss_state   = sdss_get_ss_state(ss);
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( event, SDSS_EVT_MAX );
  SD_ASSERT( rtrn_iact_ptr != NULL )

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initialize the returned SS-Internal-action to empty.
  */
  memset( rtrn_iact_ptr, 0, sizeof(*rtrn_iact_ptr) );

  /* set the eng stack ptr to point to correct stack
  */
  #if defined(FEATURE_MMODE_DUAL_SIM) || defined FEATURE_MMODE_SC_SVLTE || defined FEATURE_MMODE_SC_SGLTE
  if(ss == SD_SS_HYBR_2)
  {
    eng_stack_ptr = &sdss_hybr_2_eng_stack;
  }
  #endif

  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  if(ss == SD_SS_HYBR_3)
  {
    eng_stack_ptr = &sdss_hybr_3_eng_stack;
  }
  #endif
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #if ( defined (FEATURE_EOOS))
  #error code not present
#endif
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if ( event == SDSS_EVT_USER_PWR_DOWN )
  {
    SD_MSG_HIGH_1( "Power Down Event:%d ",event);
    if ( sdss_get_operator_name ( SYS_MODEM_AS_ID_1 ) == SD_OPERATOR_CT )
    {
      sdprl_clr_avoid_system_list();
    }
  }

  /* If this is an acquisition event, service the schedule.
  */
  if( SDSS_EVT_IS_XXX_ACQ(event) )
  {
    /* Service the systems that are on the schedule list. If hybrid
    ** preference is CDMA/HDR (i.e. MS is performing CDMA/HDR hybrid
    ** operation), only service non-HDR systems.
    */
    mode_pref = SD_SS_MODE_PREF_ANY;
    if( sd_misc_is_hybr_opr())
    {
      mode_pref = SD_MODE_DELETE( mode_pref, SD_SS_MODE_PREF_HDR );
    }

    sdss_sr_list_sched_srv( sdss_sr_list_map2(ss, SDSR_SCHED_LST),
                            mode_pref,
                            ss_ptr->acq_list,
                            ss_ptr->acq_pos );

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /* When starting a GW acquisition, & assn tag is set, reset assn info
    */
    if( ( SDSS_EVT_IS_GWL_ACQ(event)    ||
          SDSS_EVT_IS_HYBR_2_GW_ACQ(event) ||
          SDSS_EVT_IS_HYBR_3_GW_ACQ(event)
        )
        && ss_ptr->prev_sys_info.assn_tag != SDSS_ASSN_TAG_NONE
      )
    {
      sdss_addn_sys_info_init(&(ss_ptr->prev_sys_info));
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  }//SDSS_EVT_IS_XXX_ACQ(event)

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Generate an error if SS-Event is not expected in the current operation
  ** mode.
  */
  if( ! sdss_is_event_allowed(event, curr_ss_state, ss_opr_mode) )
  {
    SD_ERR_3( "Event=%d not allowed, state =%d, opr mode =%d!",
         event, curr_ss_state, ss_opr_mode);
    SD_ASSERT( FALSE );

    /* If no further recovery should be performed, return now.
    */
    if( ! sdss_event_recovery(ss, &event, rtrn_iact_ptr) )
    {
      return;
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Update the TRUE event. Scripts can generate their own events, the
  ** TRUE event will get lost if we don't update the true event
  */
  ss_ptr->true_event              = event;
  ss_ptr->is_true_event_processed = FALSE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Set is_in_srv_lost_state to true if the true event is a srv_lost event
  */
  sdss_set_srv_lost_state(ss);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Call on the engines to process this event.
  */
  sdss_eng_stack_proc( eng_stack_ptr, ss_ptr, event, rtrn_iact_ptr );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ss_ptr->is_true_event_processed = TRUE;

  /* Update the SS-State and inform the SS-Front-end of the current SS-State.
  */
  sdss_state_next( ss, event, rtrn_iact_ptr );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If SS-Action is ACQUIRE do the following:
  */
  if( rtrn_iact_ptr->act == SDSS_IACT_ACQUIRE )
  {
    /* Update the most recent acquisition list and position per the list
    ** and position that are being attempted acquisition.
    */
    ss_ptr->acq_list  = rtrn_iact_ptr->prm.acq.list;
    ss_ptr->acq_pos   = rtrn_iact_ptr->prm.acq.pos;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

    /* If the redirection indication is CDMA GSRM, set the returned
    ** max_redirect_delay per the max_redirect_delay value of the SS-Core.
    ** Else, set the returned max_redirect_delay to
    ** SD_SS_MAX_REDIR_DELAY_NONE.
    */
    if( ss_ptr->redir == SD_SS_REDIR_CDMA_GSRDM )
    {
      rtrn_iact_ptr->prm.acq.max_redirect_delay =
                                            ss_ptr->redir_max_redirect_delay;
    }
    else
    {
      rtrn_iact_ptr->prm.acq.max_redirect_delay = SD_SS_MAX_REDIR_DELAY_NONE;
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

    SD_MSG_HIGH_2("sdss_event_proc | action = %d, ss_ptr->csg_id = %d", rtrn_iact_ptr->act, ss_ptr->csg_id);

    if((rtrn_iact_ptr->act == SDSS_IACT_ACQUIRE   ||
        rtrn_iact_ptr->act == SDSS_IACT_CONTINUE) &&
        ss_ptr->csg_id     != SYS_CSG_ID_INVALID)
    {
      /* Both the values should get assigned as an automic operation */
      sd_rex_enter_crit_sect();
      rtrn_iact_ptr->prm.acq.gwl_acq_type.csg_id  = ss_ptr->csg_id;
      rtrn_iact_ptr->prm.acq.gwl_acq_type.csg_rat = ss_ptr->csg_rat;
      sd_rex_leave_crit_sect();
    }
   
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Increment the script execution control counter.
  */
  ss_ptr->scr_ctrl_cnt++;

} /* sdss_event_proc */

#if defined FEATURE_HDR_HYBRID
/* <EJECT> */
/*===========================================================================

FUNCTION sdss_hdr_event_proc

DESCRIPTION
  Process an HDR related SS-Event called for by the SS-Front-end and instruct
  the SS-Front-end of the next SS-Internal-Action to take.

DEPENDENCIES
  sdss_init() must have already been called to initialize the System
  Selection Core (SS-Core).

RETURN VALUE
  None

  Note that SS-Internal-Action to be taken by the SS-Front-end is returned
  through the rtrn_iact_ptr parameter.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                  sdss_hdr_event_proc(

        sdss_evt_e_type       event,
            /* SS-Event to process.
            */

        sdss_iact_s_type      *rtrn_iact_ptr
            /* Pointer to a buffer where to place returned internal action.
            */
)
{
  sdss_s_type           *ss_hdr_ptr    = sdss_ptr(SD_SS_HYBR_1);
  sd_ss_e_type           ss            = SD_SS_HYBR_1;
  sdss_opr_mode_e_type   ss_opr_mode   = sdss_get_opr_mode(SD_SS_MAIN);
  sdss_state_e_type      curr_ss_state = sdss_get_ss_state(SD_SS_HYBR_1);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( event, SDSS_EVT_MAX );
  SD_ASSERT( rtrn_iact_ptr != NULL )

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initialize the returned SS-Internal-action to empty.
  */
  memset( rtrn_iact_ptr, 0, sizeof(*rtrn_iact_ptr) );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If this is an acquisition event, service the schedule.
  */
  if( SDSS_EVT_IS_XXX_ACQ(event) )
  {
    /* Service the HDR systems that are on the HDR schedule list.
    */
    sdss_sr_list_sched_srv( SDSR_HDR_SCHED_LST,
                            SD_SS_MODE_PREF_HDR,
                            ss_hdr_ptr->acq_list,
                            ss_hdr_ptr->acq_pos );
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Generate an error if SS-Event is not expected in the current operation
  ** mode.
  */
  if( ! sdss_is_event_allowed(event, curr_ss_state, ss_opr_mode) )
  {
    //SD_ERR_FATAL_0( "Event not allowed!");
    SD_ERR_3( "Event=%d not allowed, state =%d, opr mode =%d!",
         event, curr_ss_state, ss_opr_mode);
    SD_ASSERT( FALSE );

    /* If no further recovery should be performed, return now.
    */
    if( ! sdss_event_recovery(ss, &event, rtrn_iact_ptr) )
    {
      return;
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Update the TRUE event. Scripts can generate their own events, the
  ** TRUE event will get lost if we don't update the true event
  */
  ss_hdr_ptr->true_event              = event;
  ss_hdr_ptr->is_true_event_processed = FALSE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Call on the engines to process this event.
  */
  sdss_eng_stack_proc( &sdss_hybr_1_eng_stack,
                       ss_hdr_ptr,
                       event,
                       rtrn_iact_ptr );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ss_hdr_ptr->is_true_event_processed = TRUE;

  /* Update the SS-State and inform the SS-Front-end of the current SS-State.
  */
  sdss_state_next( ss, event, rtrn_iact_ptr );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If SS-Action is ACQUIRE do the following:
  */
  if( rtrn_iact_ptr->act == SDSS_IACT_ACQUIRE )
  {
    /* Update the most recent acquisition list and position per the list
    ** and position that are being attempted acquisition.
    */
    ss_hdr_ptr->acq_list  = rtrn_iact_ptr->prm.acq.list;
    ss_hdr_ptr->acq_pos   = rtrn_iact_ptr->prm.acq.pos;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Increment the script execution control counter.
  */
  ss_hdr_ptr->scr_ctrl_cnt++;

} /* sdss_hdr_event_proc */
#endif /* FEATURE_HDR_HYBRID */

/*===========================================================================

FUNCTION sdss_get_sys_resel_start_time

DESCRIPTION
  Return the start time for the specified system reselection timer.

DEPENDENCIES
  None.

RETURN VALUE
 DWORD

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  dword                    sdss_get_sys_resel_uptime(

        sd_ss_e_type             ss,
            /* System selection stack.
            */

        int                      timer
            /* Specify the system reselection timer type for the start time.
            */
)
{
  const sdss_s_type   *ss_ptr   = sdss_ptr( ss );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( timer, SDSSSCR_CONT_TYPE_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return ss_ptr->cont_uptime[timer];

}/* sdss_get_sys_resel_uptime */


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_get_new_acq_cnt

DESCRIPTION
  Return the start time for the specified system reselection timer.

DEPENDENCIES
  None.

RETURN VALUE
 DWORD

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  byte                      sdss_get_new_acq_cnt(

        sd_ss_e_type             ss
            /* System selection stack.
            */
)
{

  const sdss_s_type   *ss_ptr   = sdss_ptr( ss );
    /* Pointer to associated System Selection information structure.
    */
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return ss_ptr->new_acq_cnt;

}


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_sys_lost_update

DESCRIPTION
  Update the system lost reason of the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                          sdss_sys_lost_update(

        sd_ss_e_type                  ss,
            /* System selection stack.
            */

        sd_ss_sys_lost_e_type         sys_lost
            /* System lost reason.
            */

)
{
  sdss_s_type   *ss_ptr   = sdss_ptr( ss );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( sys_lost, SD_SS_SYS_LOST_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ss_ptr->sys_lost = sys_lost;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return;

} /* sdss_sys_lost_update */

/*===========================================================================

FUNCTION sdss_update_cdma_activity

DESCRIPTION
  This routine sets is_cdma_activity flag

DEPENDENCIES
  None.

RETURN VALUE

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void                           sdss_update_cdma_activity(

        sd_ss_e_type                   ss,
          /* System selection stack
          */
       
        boolean                        is_cdma_activity

)
{

  sdss_s_type   *ss_ptr = NULL;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  ss_ptr = sdss_ptr( ss );
  SD_ASSERT(ss_ptr != NULL);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  
  /* Set cdma activity flag to true */
  ss_ptr->is_cdma_activity = is_cdma_activity;

  SD_MSG_HIGH_1( "SDSS: Update is_cdma_activity = %d",
                 ss_ptr->is_cdma_activity );
}

#if defined(FEATURE_EOOS_UMTS)
/*===========================================================================

FUNCTION sdss_update_eoos_scan_gwl_param

DESCRIPTION
  Get the parameters for the EOOS GWL scan

DEPENDENCIES
  None.

RETURN VALUE
 DWORD

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_update_eoos_scan_gwl_param(
              sd_ss_act_acq_gwl_s_type*   acq_gwl)
{

  int i = 0;
  sdss_s_type *ss_ptr = sdss_ptr(SD_SS_MAIN);
  SD_ASSERT(acq_gwl != NULL);
  for( i=0; i < (int)acq_gwl->rat_pri_list_info.num_items; i++ )
  {
      if( ss_ptr->rat_pri_list_info.priority_list_info[i].acq_sys_mode
        == SYS_SYS_MODE_GSM )
      {
         acq_gwl->rat_pri_list_info.priority_list_info[i].acq_sys_time_interval =
           ss_ptr->acq_gwl_gsm_scan_time;
      }
      else if ( ss_ptr->rat_pri_list_info.priority_list_info[i].acq_sys_mode ==
        SYS_SYS_MODE_WCDMA )
      {
         acq_gwl->rat_pri_list_info.priority_list_info[i].acq_sys_time_interval =
          ss_ptr->acq_gwl_wcdma_scan_time;
      }
  }
  acq_gwl->rat_pri_list_info.scan_type.use_timer =
    ss_ptr->acq_gwl_use_timer;
  acq_gwl->rat_pri_list_info.scan_type.new_scan =
    ss_ptr->acq_gwl_new_acq;

  SD_MSG_HIGH_2( "EOOS GW Params : use_timer :0x%x, new_scan : 0x%x",
               acq_gwl->rat_pri_list_info.scan_type.use_timer,
               acq_gwl->rat_pri_list_info.scan_type.new_scan);

}
#endif

#ifdef FEATURE_EOOS_UMTS
/*lint -esym(818,lte_scan_time) */
/*===========================================================================

FUNCTION sdss_get_eoos_scan_gw_param

DESCRIPTION
  Get the EOOS GWL scan parameters

DEPENDENCIES
  None.

RETURN VALUE
 DWORD

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                  sdss_get_eoos_scan_gwl_param(

        sd_ss_e_type ss,
            /* System selection stack
            */

        boolean *use_timer,
            /* use_timer flag for NAS
            */

        boolean *new_acq,
            /* Is this a new acq or continuation of the previous acq
            */
        dword    *wcdma_scan_time,
            /* UMTS scan time
            */

        dword    *gsm_scan_time,
            /* GSM scan time
            */

        dword    *lte_scan_time,
            /* LTE scan time
            */

        sd_ss_gwl_scan_status_e_type *gwl_scan_status
            /* GWL scan status
            */
)
/*lint -esym(715,ss) */
/*lint -esym(715,lte_scan_time) */
{

  sdss_s_type   *ss_ptr       = sdss_ptr(SD_SS_MAIN);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( ss == SD_SS_MAIN );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if( use_timer       != NULL )
  {
    *use_timer        = ss_ptr->acq_gwl_use_timer;
  }

  if( new_acq         != NULL )
  {
    *new_acq          = ss_ptr->acq_gwl_new_acq;
  }

  if( wcdma_scan_time  != NULL )
  {
    *wcdma_scan_time   = ss_ptr->acq_gwl_wcdma_scan_time;
  }

  if( gsm_scan_time   != NULL )
  {
    *gsm_scan_time    = ss_ptr->acq_gwl_gsm_scan_time;
  }

  if( gwl_scan_status  != NULL )
  {
    *gwl_scan_status   = ss_ptr->acq_gwl_scan_status;
  }

  return;
}
/*lint +esym(715,ss) */
/*lint +esym(715,lte_scan_time) */
/*lint -esym(818,lte_scan_time) */
/*===========================================================================

FUNCTION sdss_compute_net_sel_type

DESCRIPTION
  Get the uniform GW scan parameters

DEPENDENCIES
  None.

RETURN VALUE
 DWORD

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sys_network_selection_mode_e_type sdss_compute_net_sel_mode(

        sys_network_selection_mode_e_type    curr_net_sel_mode,
            /* Current Network selection mode
            */

        sd_ss_e_type ss
            /* System selection stack
            */
)
{

  sys_sim_state_e_type    sim_state = sdss_get_sim_state(ss);

  if( sim_state == SYS_SIM_STATE_NOT_AVAILABLE ||
      sim_state == SYS_SIM_STATE_CS_PS_INVALID )
  {
    SD_MSG_HIGH_2(" EOOS: sim_state %d net_sel %d",
                            sim_state, curr_net_sel_mode);
    if( curr_net_sel_mode == SYS_NETWORK_SELECTION_MODE_AUTOMATIC )
    {
     return( SYS_NETWORK_SELECTION_MODE_LIMITED_ROUTINE_ACQUISITION );
    }
    else
    {
      return( SYS_NETWORK_SELECTION_MODE_LIMITED_MANUAL_ACQUISITION );
    } /* net_sel_type*/
  }
  return curr_net_sel_mode;
} /* sdss_compute_net_sel_mode */
#endif

/*===========================================================================

FUNCTION sdss_is_resel_not_allowed

DESCRIPTION
  reselection is not allowed if
  1. NAS is performing background srch
  2. or NAS is in true connected state
  3. or Emergency call is ongoing
  4. or is_extend_lbsr_when_1x_activity is TRUE and 1x has activity
  5. or HDR is in traffic

DEPENDENCIES
  None.

RETURN VALUE
 True  if above condition is met
 False otherwise

SIDE EFFECTS
  None.

===========================================================================*/

boolean                               sdss_is_resel_not_allowed(
        sd_ss_e_type                  ss
            /* System selection stack */
)
{
  sys_gw_conn_status_e_type     conn_status;
  boolean                       is_more_pref_gw    = FALSE;
  boolean                       is_rese_not_allow  = FALSE;
  sdss_s_type*  ss_ptr = sdss_ptr( ss );
  if( ss == SD_SS_MAIN &&
    sdss_is_hybr_pref( SD_SS_MAIN, SD_SS_HYBR_PREF_CDMA__LTE__HDR ))
  {
    sdsr_list_cpy(SDSR_TEMP_LST, SDSR_SRV_PREF_LST);
    sdsr_list_del_sys(SD_SS_MAIN,SDSR_TEMP_LST,SDSR_CAT_NON_COMPLY);

    if(sdss_sr_list_is_mode_pref(SDSR_TEMP_LST, SD_SS_MODE_PREF_GW))
    {
      is_more_pref_gw = TRUE;
    }
    /* If in SVLTE mode and more preferred systems on MAIN doesn't have GW and
    ** HDR is not in connected state, allow resel on MAIN stack
    */
    if( !is_more_pref_gw &&
      (!sdss_ptr(SD_SS_MAIN)->is_hdr_activity))
    {
      return FALSE;
    }
  }

  if(sdss_common.subs_feature[SYS_MODEM_AS_ID_1] == SYS_SUBS_FEATURE_MODE_SGLTE &&
    ss == SD_SS_HYBR_2)
  {  
    conn_status = mm_per_stacks_get_connection_status(SYS_MODEM_AS_ID_1,
                    SYS_MODEM_STACK_ID_2);	
  }
  else 
  {
    conn_status = mm_per_stacks_get_connection_status(SYS_MODEM_AS_ID_1,
                    SYS_MODEM_STACK_ID_1);	 
  }
   SD_MSG_HIGH_1( "MM conn status: %d",conn_status);

  /* case 1 and 2 on main */
  if ((ss == SD_SS_MAIN) &&
      ((conn_status == SYS_GW_CONN_STATUS_CONN) ||
      (conn_status == SYS_GW_CONN_STATUS_BPLMN_SRCH))
   )
  {
    is_rese_not_allow = TRUE;
  }
  /* case 1 and 2 on hybr2 */
  /* For hybrid2 is in OPERATIONAL state, LTE is in SRV or LIMITED REGIONAL 
   ** and NAS is not IDLE dont do reselection 
   */
  else if ((ss == SD_SS_HYBR_2) && (sd_get_ss_state(ss) == SDSS_STATE_OPR) &&
           (ss_ptr->srv_status  == SYS_SRV_STATUS_LIMITED_REGIONAL ||
            ss_ptr->srv_status  == SYS_SRV_STATUS_SRV))
  { 
    if((conn_status == SYS_GW_CONN_STATUS_CONN) ||
       (conn_status == SYS_GW_CONN_STATUS_BPLMN_SRCH))
  {
    is_rese_not_allow = TRUE;
  }
  }
  /* case 3 */
  else if ( ss == SD_SS_MAIN &&
          is_more_pref_gw &&
          sdss_is_hybr_pref( SD_SS_MAIN, SD_SS_HYBR_PREF_CDMA__LTE__HDR ) &&
          sdss_is_emergency_call_orig(SD_SS_HYBR_2)
          )
  {
    is_rese_not_allow = TRUE;
    SD_MSG_HIGH_0( "emergency call on-going. Resel NOT Allowed" );
  }
  /* case 4 */
  else if (  ss == SD_SS_HYBR_2 &&
            sdss_is_1x_sxlte() &&
            sdss_common.is_extend_lbsr_when_1x_activity &&
            sdss_ptr(SD_SS_MAIN)->is_cdma_activity )
  {
    is_rese_not_allow = TRUE;
    SD_MSG_HIGH_3( "CDMA activity on-going. Resel NOT Allowed SS = %d, NV LBSR = %d, cdma_activity = %d",
                     ss, sdss_common.is_extend_lbsr_when_1x_activity,
                     sdss_ptr(SD_SS_MAIN)->is_cdma_activity );
  
  }
  return is_rese_not_allow;

}

/*===========================================================================

FUNCTION sdss_is_loop_cond

DESCRIPTION
  Returns TRUE is loop_cond is true

DEPENDENCIES
  None.

RETURN VALUE
 True : loop_cond is TRUE
 False otherwise

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean               sdss_is_loop_cond(

        sd_ss_e_type          ss,
            /* System selection stack
            */

        sdss_loop_cond_e_type loop_cond
            /* The loop condition
            */
)
/*lint -esym(715,ss) */
{

  sdss_s_type   *ss_ptr       = sdss_ptr(ss);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( (ss == SD_SS_MAIN) || (ss == SD_SS_HYBR_2) || (ss == SD_SS_HYBR_3));

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  switch( loop_cond )
  {
    case SDSS_LOOP_COND_GW_SCAN_ABORTED:
      return ( ss_ptr->acq_gwl_scan_status == SD_SS_GWL_SCAN_STATUS_ABORTED );

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_LOOP_COND_IS_HDR_ACTIVITY:
      return( sdss_ptr(SD_SS_MAIN)->is_hdr_activity);

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_LOOP_COND_RESEL_NOT_ALLOWED:

    {
      boolean                    is_rese_not_allow = FALSE;

     if(!sdss_is_1x_sxlte())
     {
       return( sdss_ptr(SD_SS_MAIN)->is_hdr_activity);
     }

     is_rese_not_allow= sdss_is_resel_not_allowed(ss);

     return( sdss_ptr(SD_SS_MAIN)->is_hdr_activity ||
             is_rese_not_allow
            );
    }
      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    case SDSS_LOOP_COND_RESEL_TRM_NOT_ALLOWED:
    {
      boolean                    is_rese_not_allow = FALSE;

      if(!sdss_is_1x_sxlte())
      {
        return( sdss_ptr(SD_SS_MAIN)->is_hdr_activity);
      }

      is_rese_not_allow = sdss_is_resel_not_allowed(ss);

      /* for multisim, svlte+g, if trm is not available, reselection is not allowed */
      if(ss == SD_SS_HYBR_2 && !is_rese_not_allow
        && sdss_is_sfmode_1x_sxlte(0) 
        && sdss_is_featuremode(SYS_OVERALL_FEATURE_MODE_MULTISIM)
        && !sdss_is_trm_available(ss))
      {
        is_rese_not_allow = TRUE;
        SD_MSG_HIGH_0( "TRM not available. Resel NOT Allowed");
      }
      return( sdss_ptr(SD_SS_MAIN)->is_hdr_activity ||
             is_rese_not_allow
            );
    }

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_LOOP_COND_NONE:
    case SDSS_LOOP_COND_MAX:
    default:
      return FALSE;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  }

} /* sdss_is_loop_cond */
/*lint +esym(715,ss) */


/*===========================================================================

FUNCTION sdss_get_num_cfg

DESCRIPTION
  Returns the config value for the loop

DEPENDENCIES
  None.

RETURN VALUE
 True : loop_cond is TRUE
 False otherwise

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  dword               sdss_get_num_cfg(

        sd_ss_e_type          ss,
            /* The System selection stack
            */

        sdss_loop_num_e_type  cfg_item
            /* The configuration items for loop.
            */
)
/*lint -esym(715,ss) */
{
  sdss_s_type   *ss_ptr       = sdss_ptr(ss);


  switch( cfg_item )
  {

    case SDSS_LOOP_NUM_CFG_N_MIN_VOICE_SCANS:
      if(sdss_is_1x_sxlte()) 
      {
        /*currently, if ss = MAIN, then we will apply n_min_voice_scans
        **feature. Otherwise, return default value to fallback legacy
        */
        if ( ss == SD_SS_MAIN &&
             sdss_is_hybr_pref( SD_SS_MAIN, SD_SS_HYBR_PREF_CDMA__LTE__HDR ))
        {
          return ss_ptr->n_min_voice_scans;
        }
      }
      return SD_N_MIN_VOICE_SCANS_LEGACY_VALUE;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_LOOP_NUM_CFG_NONE:
    case SDSS_LOOP_NUM_CFG_MAX:
    default:
      return 0;
  }

} /* sdss_get_num_cfg */
/*lint +esym(715,ss) */

/*===========================================================================

FUNCTION sdss_get_acq_status_2

DESCRIPTION
  Return acq_status

DEPENDENCIES
  None.

RETURN VALUE
  ACQ STATUS

SIDE EFFECTS
  None.

===========================================================================*/
static  sys_acq_status_e_type   sdss_get_acq_status_2(

sd_ss_e_type          ss
    /* The System selection stack
    */
)
{

  SD_MSG_HIGH_2("Buffer int srv lost:%d, acq_status:%d", \
        sdss_common.buffer_int_srv_lost, sdss_ptr(ss)->acq_status);
  
  if( !sdss_common.buffer_int_srv_lost || 
    (sdss_ptr(ss)->acq_status == SYS_ACQ_STATUS_SUCCESS))
  {
    return SYS_ACQ_STATUS_SUCCESS;
  }

  return SYS_ACQ_STATUS_NO_RESOURCE;
}

/*===========================================================================
  this function returns acq status value stored in sdss state
===========================================================================*/
sys_acq_status_e_type sdss_get_acq_status_only( sd_ss_e_type ss )
{
  return sdss_ptr(ss)->acq_status;
}

/*===========================================================================

FUNCTION sdss_is_if_cond

DESCRIPTION
  Returns TRUE is if_cond is true

DEPENDENCIES
  None.

RETURN VALUE
 True : if_cond is TRUE
 False otherwise

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean               sdss_is_if_cond(


        sd_ss_e_type          ss,
            /* The System selection stack
            */

        sdss_if_cond_e_type   if_cond,
            /* The if condition
            */

        sdss_cmp_criteria_e_type cmp_criteria,
            /* The Comparision criteria
            */

        word                  para1,
            /* Depending on the condition, we may require additional parameters
            */

        word                  para2
            /* Depending on the condition, we may require additional parameters
            */
)
/*lint -esym(715,ss) */
/*lint -esym(715,cmp_criteria) */
/*lint -esym(715,para1) */
/*lint -esym(715,para2) */
{

  sdss_s_type   *ss_ptr = sdss_ptr( ss );
  sdsr_e_type   list;
  sdsr_s_type   *sr_ptr;
  sdsr_s_type   *srv_sys_ptr  = sdsr_list_get_ptr( SDSR_SRV_SYS, 0 );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT( ss_ptr != NULL );
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( if_cond, SDSS_IF_COND_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( cmp_criteria, SDSS_CMP_CRITERIA_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  switch( if_cond )
  {
    case SDSS_IF_COND_GCF_TESTING:

      switch( cmp_criteria )
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
          return ( SD_BOOLEAN( ss_ptr->gprs_anite_gcf == TO_WORD( para1, para2 )));

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          return ( SD_BOOLEAN( ss_ptr->gprs_anite_gcf != TO_WORD( para1, para2 ) ) );

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      }


    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_IF_COND_MAP_SCAN:

      switch( cmp_criteria )
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
          return ( SD_BOOLEAN( ss_ptr->is_map_scan == TO_WORD( para1, para2 )));

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          return ( SD_BOOLEAN( ss_ptr->is_map_scan != TO_WORD( para1, para2 ) ) );

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      }
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  case SDSS_IF_COND_HYBR_HDR_IRAT:

      switch( cmp_criteria )
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
          return ( SD_BOOLEAN( sdss_is_hybr_hdr_irat_operation() == TO_WORD( para1, para2 )));

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          return ( SD_BOOLEAN( sdss_is_hybr_hdr_irat_operation() != TO_WORD( para1, para2 ) ) );

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      }


    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_IF_COND_TOP_SYS_MODE_GWL:

      switch( cmp_criteria )
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
          list = sdss_sr_list_map( ss_ptr, (sdsr_e_type) para2 );
          sr_ptr = sdsr_list_get_ptr(list,0);
          return ( sdsr_is_sys(SYS_SYS_MODE_GWL,list,0) &&
                   sdss_sr_is_pref_conf0( ss,
                                          sr_ptr,
                                          SDSS_PREF_CONF_NONE,
                                          TRUE)
                 );
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          return ( !sdsr_is_sys(
                              SYS_SYS_MODE_GWL,
                              sdss_sr_list_map( ss_ptr, (sdsr_e_type) para2 ),
                              0 )
                 );
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_IF_COND_TRUE_EVENT:
    {
      sdss_evt_e_type          chk_event =
                                   (sdss_evt_e_type) TO_WORD( para1, para2 );
      switch( cmp_criteria )
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
          return (SD_BOOLEAN( sdss_event_map(ss,chk_event) == ss_ptr->true_event ));

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          return (SD_BOOLEAN( sdss_event_map(ss,chk_event) != ss_ptr->true_event ));

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      }
    } /* case IS_TRUE_EVENT*/

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_IF_COND_NEW_TRUE_EVENT:
    {
      sdss_evt_e_type          chk_event =
                                   (sdss_evt_e_type) TO_WORD( para1, para2 );
      switch( cmp_criteria )
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
          return (SD_BOOLEAN( !ss_ptr->is_true_event_processed \
                           && ( sdss_event_map(ss,chk_event) == ss_ptr->true_event )));

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          return (SD_BOOLEAN( (!ss_ptr->is_true_event_processed \
                            && sdss_event_map(ss,chk_event) != ss_ptr->true_event )));

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      }
    } /* case IS_TRUE_EVENT*/

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_IF_COND_CURR_EVENT:
    {
      sdss_evt_e_type          chk_event =
                                   (sdss_evt_e_type) TO_WORD( para1, para2 );
      sdss_eng_stack_s_type   *stack_ptr = &sdss_eng_stack; //??
      sdss_eng_s_type         *eng_ptr;

      switch( ss )
      {
        case SD_SS_MAIN:
          stack_ptr = &sdss_eng_stack;
          break;
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SD_SS_HYBR_1:
          #ifdef FEATURE_HDR
          stack_ptr = &sdss_hybr_1_eng_stack;
          break;
          #endif
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
          /* Delibrate fall down to the default is FEATURE_HDR is not defined
          */

        case SD_SS_HYBR_2:
          #if defined FEATURE_MMODE_DUAL_SIM || defined FEATURE_MMODE_SC_SVLTE || defined FEATURE_MMODE_SC_SGLTE
          stack_ptr = &sdss_hybr_2_eng_stack;
          #endif
          break;

        case SD_SS_HYBR_3:
          #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
          stack_ptr = &sdss_hybr_3_eng_stack;
          #endif
          break;

        case SD_SS_MAX:
        default:
          SD_MSG_HIGH_1("Invalid ss %d", ss);
          return FALSE;
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      }/* switch ss */

      eng_ptr = sdss_eng_stack_top( stack_ptr );
      SD_ASSERT( eng_ptr != NULL );
      switch( cmp_criteria )
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
          return ( SD_BOOLEAN( sdss_event_map(ss,chk_event) == eng_ptr->event ));
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          return ( SD_BOOLEAN( sdss_event_map(ss,chk_event) != eng_ptr->event ));
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_ERR_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      }
    } /* case IS_CURR_EVENT*/

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_IF_COND_EOOS_SLEEP_DUE:
    #ifdef FEATURE_EOOS
    #error code not present
#else
   SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
   return FALSE;
   #endif

   /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_IF_COND_SS_STATE:
    {
        switch( cmp_criteria )
        {
          case SDSS_CMP_CRITERIA_EQUAL_TO:
            return (sdss_get_ss_state(ss) ==
                               (sdss_state_e_type) TO_WORD( para1, para2 ));

          /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

          case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
            return (sdss_get_ss_state(ss) !=
                                (sdss_state_e_type) TO_WORD( para1, para2 ));

          /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

          case SDSS_CMP_CRITERIA_NONE:
          case SDSS_CMP_CRITERIA_MAX:
          default:
            SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
            return FALSE;
        }
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_IF_COND_ACQ_SYS_PRL_DESIG:
    {
      sdsr_s_type         *acq_sys_ptr  =
               sdsr_list_get_ptr( sdss_sr_list_map(ss_ptr,SDSR_ACQ_SYS), 0 );

      sdss_prl_val_e_type chk_prl_desig =
                               (sdss_prl_val_e_type) TO_WORD( para1, para2 );

      SD_ASSERT_ENUM_IS_INRANGE( chk_prl_desig, SDSS_PRL_VAL_MAX );

      if( acq_sys_ptr == NULL )
      {
        SD_ERR_0( "get_ptr SDSR_ACQ_SYS failed");
      }

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      switch( cmp_criteria )
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
          return ( ( acq_sys_ptr != NULL ?
                     sdss_sr_is_prl( acq_sys_ptr, chk_prl_desig ) : FALSE ) );
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          return ( ( acq_sys_ptr != NULL ?
                     !sdss_sr_is_prl( acq_sys_ptr, chk_prl_desig ) : TRUE ) );
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_ERR_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      }
    } /* SDSS_IF_COND_ACQ_SYS_PRL_DESIG */

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_IF_COND_HYBR_PREF:
    {
      #ifdef FEATURE_HDR_HYBRID
      switch( cmp_criteria )
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
          return (sdss_is_hybr_pref(ss,(sd_ss_hybr_pref_e_type) TO_WORD( para1, para2 )));

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          return (!sdss_is_hybr_pref(ss,(sd_ss_hybr_pref_e_type) TO_WORD( para1, para2 )));

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_ERR_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      }
      #else
      SD_ERR_0("Invalid featurization");
      return FALSE;
      #endif


    } /* case HYBR_PREF*/

    case SDSS_IF_COND_ORIG_MODE:
      switch( cmp_criteria )
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
          return ( SD_BOOLEAN( ss_ptr->orig_mode == (sd_ss_orig_mode_e_type)TO_WORD( para1, para2 )));

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          return ( SD_BOOLEAN( ss_ptr->orig_mode != (sd_ss_orig_mode_e_type)TO_WORD( para1, para2 )));

        case SDSS_CMP_CRITERIA_CONTAINS:
          return ( sdss_is_orig_mode( ss,
                              (sd_ss_orig_mode_val_e_type) TO_WORD( para1, para2 )));
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      } /* case SDSS_IF_COND_ORIG_MODE */


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_IF_COND_SS_PREF_CHGD:
    {

      switch( cmp_criteria )
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
          return ( SD_BOOLEAN (( ss_ptr->true_event == sdss_event_map(ss,SDSS_EVT_USER_SS_PREF) ) &&
                   (ss_ptr->pref_reason == SD_SS_PREF_REAS_USER ||
                    ss_ptr->pref_reason == SD_SS_PREF_REAS_MULTIMODE_SCAN ||
                    ss_ptr->pref_reason == SD_SS_PREF_REAS_USER_RESEL ) &&
                   sdss_is_pref_update( ss, SDSS_PREF_UPDATED_TRUE_PREF )));

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:

          return ( SD_BOOLEAN (( ss_ptr->true_event != sdss_event_map(ss,SDSS_EVT_USER_SS_PREF) ) ||
                   (ss_ptr->pref_reason != SD_SS_PREF_REAS_USER &&
                    ss_ptr->pref_reason != SD_SS_PREF_REAS_MULTIMODE_SCAN &&
                    ss_ptr->pref_reason != SD_SS_PREF_REAS_USER_RESEL ) ||
                   ! sdss_is_pref_update( ss, SDSS_PREF_UPDATED_TRUE_PREF )));

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      }
    } /* case SDSS_IF_COND_SS_PREF_CHGD */

    case SDSS_IF_COND_SRV_PREF_LIST_SIZE:
    {

      switch( cmp_criteria )
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
          return ( SD_BOOLEAN (sdsr_list_cnt(sdss_sr_list_map2(ss,SDSR_SRV_PREF_LST))
                                               == TO_WORD( para1, para2 )));

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          return ( SD_BOOLEAN (sdsr_list_cnt(sdss_sr_list_map2(ss,SDSR_SRV_PREF_LST))
                                              != TO_WORD( para1, para2 )));

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      }
    } /* case SDSS_IF_COND_SRV_PREF_LIST_SIZE */

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_IF_COND_HDR_ACTIVITY:
    {
      switch( cmp_criteria )
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:

          return SD_BOOLEAN( sdss_ptr(SD_SS_MAIN)->is_hdr_activity ==
                                                    TO_WORD( para1, para2 ));

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:

          return SD_BOOLEAN( sdss_ptr(SD_SS_MAIN)->is_hdr_activity !=
                                                    TO_WORD( para1, para2 ));

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      }
    } /* case SDSS_IF_COND_HDR_ACTIVITY */

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_IF_COND_SRV_LOST_HOME_1X:
    {
      switch( cmp_criteria )
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:

          return SD_BOOLEAN( sdss_is_home_1X()== TO_WORD( para1, para2 ));

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:

          return SD_BOOLEAN( sdss_is_home_1X()!= TO_WORD( para1, para2 ));

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      }
    } /* case SDSS_IF_COND_HDR_ACTIVITY */

    /*
    **We check for two conditions:
    **1) Reselection State == WAIT
    **2) No Service on MAIN Stack
    */
    case SDSS_IF_COND_MAIN_STACK_ON_BSR:
    {
      boolean result = FALSE;
      sys_srv_status_e_type ss_srv_status;
      sdss_read_srv_status( ss, &ss_srv_status, NULL );

      if ((ss_srv_status != SYS_SRV_STATUS_SRV) &&
          (ss_ptr->resel_state == SDSS_RESEL_STT_WAIT ))
      {
        result = TRUE;
      }

      switch( cmp_criteria )
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
          return SD_BOOLEAN( result == TO_WORD( para1, para2 ));

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          return SD_BOOLEAN( result != TO_WORD( para1, para2 ));

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
      }
    }
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_IF_COND_SGLTE_CAMP_ONLY_MODE:
    {
      boolean result = (sdss_get_camp_mode() == SD_SS_PREF_CAMP_MODE_ON);

      switch( cmp_criteria )
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
          return SD_BOOLEAN( result == TO_WORD( para1, para2 ));

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          return SD_BOOLEAN( result != TO_WORD( para1, para2 ));

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
      }
    }
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_IF_COND_ENG_SCR_TIMER_FLAG:
    {
      switch( cmp_criteria )
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:

          return SD_BOOLEAN( ss_ptr->is_eng_scr_timer_set == \
                          TO_WORD( para1, para2 ));

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:

          return SD_BOOLEAN( ss_ptr->is_eng_scr_timer_set != \
                          TO_WORD( para1, para2 ));

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      }
    } /* case SDSS_IF_COND_ENG_SCR_TIMER_FLAG */

    case SDSS_IF_COND_CONN_MODE_SET:
    {
      switch( cmp_criteria )
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:

          /* The in_conn_mode is set to FALSE when the NAS sends a report
          ** If we don't get the report, we should rely on the timer
          */
         #if defined ( FEATURE_WRLF_SYSTEM_SEL)
         return  SD_BOOLEAN ( ( sdss_is_wcdma_connected_mode(ss) ||
                                 sdss_is_lte_connected_mode(ss) ) == TO_WORD( para1, para2 ) );
         #else
         return  SD_BOOLEAN ( sdss_is_lte_connected_mode(ss)  == TO_WORD( para1, para2 ) );
         #endif

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          #if defined ( FEATURE_WRLF_SYSTEM_SEL)
          return SD_BOOLEAN( ( sdss_is_wcdma_connected_mode(ss) ||
                               sdss_is_lte_connected_mode(ss) ) !=  TO_WORD( para1, para2 ) );
          #else
          return SD_BOOLEAN( sdss_is_lte_connected_mode(ss) !=  TO_WORD( para1, para2 ) );
          #endif

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      }
    } /* case SDSS_IF_COND_CONN_MODE_SET*/

    case SDSS_IF_COND_LTE_CONN_MODE_SET:
    {
      switch( cmp_criteria )
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:

          /* The lte_in_conn_mode is set to FALSE when the NAS sends a report
          ** If we don't get the report, we should rely on the timer
          */
          return  SD_BOOLEAN (sdss_is_lte_connected_mode(ss) == TO_WORD( para1, para2 ) );

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          return (sdss_is_lte_connected_mode(ss) !=  TO_WORD( para1, para2 ) );

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      }
    } /* case SDSS_IF_COND_CONN_MODE_SET*/
    #if defined ( FEATURE_WRLF_SYSTEM_SEL)
    case SDSS_IF_COND_WCDMA_CONN_MODE_SET:
    {
      switch( cmp_criteria )
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:

          /* The wcdma_in_conn_mode is set to FALSE when the NAS sends a report
          ** If we don't get the report, we should rely on the timer
          */
          return  SD_BOOLEAN (sdss_is_wcdma_connected_mode(ss) == TO_WORD( para1, para2 ) );

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          return (sdss_is_wcdma_connected_mode(ss) !=  TO_WORD( para1, para2 ) );

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      }
    } /* case SDSS_IF_COND_WCDMA_CONN_MODE_SET*/

    case SDSS_IF_COND_WCDMA_SUITABLE_SEARCH_SET:
    {
      switch( cmp_criteria )
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:

          /* The wcdma_in_conn_mode is set to FALSE when the NAS sends a report
          ** If we don't get the report, we should rely on the timer
          */
          return  SD_BOOLEAN (sdss_is_wcdma_suitable_search(ss) == TO_WORD( para1, para2 ) );

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          return (sdss_is_wcdma_suitable_search(ss) !=  TO_WORD( para1, para2 ) );

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      }
    } /* case SDSS_IF_COND_WCDMA_SUITABLE_SEARCH_SET*/

    #endif /* FEATURE_WRLF_SYSTEM_SEL */
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_IF_COND_IS_HDR_REDIR:
    {
      switch( cmp_criteria )
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
        {
          /*lint -e731 */
          return SD_BOOLEAN( sdss_is_redir_internal(ss, SDSS_REDIR_VAL_HDR_ANY) == \
                            TO_WORD( para1, para2 ) );

          /*lint +e731 */
        }
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          /*lint -e731 */
          return SD_BOOLEAN( sdss_is_redir_internal(ss, SDSS_REDIR_VAL_HDR_ANY) != \
                           TO_WORD( para1, para2 ) );
          /*lint +e731 */

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      }
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_IF_COND_TOP_SYS_MODE_GW_SUBS_AVAIL:
    {
      switch( cmp_criteria )
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:

          return ( ss_ptr->is_gw_subsc_avail &&
                        sdsr_is_sys(
                              SYS_SYS_MODE_GW,
                              sdss_sr_list_map( ss_ptr, (sdsr_e_type) para2 ),
                              0 ) );
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          return ( !(ss_ptr->is_gw_subsc_avail &&
                            sdsr_is_sys(
                              SYS_SYS_MODE_GW,
                              sdss_sr_list_map( ss_ptr, (sdsr_e_type) para2 ),
                              0 ) ));
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      }
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_IF_COND_GW_SUBS_AVAIL:

      switch( cmp_criteria )
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
          return ( SD_BOOLEAN(ss_ptr->is_gw_subsc_avail == TO_WORD( para1, para2 )));

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          return ( !SD_BOOLEAN(ss_ptr->is_gw_subsc_avail == TO_WORD( para1, para2 )));
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_IF_COND_GW_PWR_SAVE_ACQ_STAGE:
    {
      switch( cmp_criteria )
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
          return (ss_ptr->gw_pwr_save_acq_stage_val ==
                             (byte) TO_WORD( para1, para2));

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          return (ss_ptr->gw_pwr_save_acq_stage_val !=
                              (byte) TO_WORD( para1, para2 ));

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
      }
    }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  case SDSS_IF_COND_CAP_LTE_PREF_LTE_ONLY:
  {
    sd_ss_mode_pref_e_type  mode_pref;
    boolean retval;
    sd_ss_mode_pref_e_type     ss_mode_pref      = SD_SS_MODE_PREF_NONE;
    sd_ss_band_pref_e_type     ss_band_pref      = SD_SS_BAND_PREF_NONE;
    sys_lte_band_mask_e_type   ss_lte_band_pref  = SYS_LTE_BAND_MASK_CONST_NONE;
    sd_ss_band_pref_e_type     ss_tds_band_pref  = SD_SS_BAND_PREF_NONE;

    sdss_get_mode_band_pref( ss,
                             &ss_mode_pref,
                             &ss_band_pref,
                             &ss_lte_band_pref,
                             &ss_tds_band_pref );

    mode_pref =  sdss_get_supp_mode_pref_mmode( ss_mode_pref,
                                                ss_band_pref,
                                                ss_lte_band_pref,
                                                ss_tds_band_pref);

    retval = sdss_is_supp_mode_band_pref_lte(SD_SS_MODE_PREF_LTE,
                                              SYS_LTE_BAND_MASK_CONST_ANY);

    /*lint -e655 */ /* bit-wise operation uses enum */
    retval = (retval && (mode_pref == SD_SS_MODE_PREF_LTE));
    /*lint +e655 */ /* bit-wise operation uses enum */

    switch( cmp_criteria )
    {
    case SDSS_CMP_CRITERIA_EQUAL_TO:
      return (retval == (byte) TO_WORD( para1, para2));

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
      return (retval != (byte) TO_WORD( para1, para2 ));

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_CMP_CRITERIA_NONE:
    case SDSS_CMP_CRITERIA_MAX:
    default:
      SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
      return FALSE;
    }
  }
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  case SDSS_IF_COND_IS_MMSS_OP:
    switch( cmp_criteria )
    {
      case SDSS_CMP_CRITERIA_EQUAL_TO:
        return SD_BOOLEAN(sdss_is_mmss_operation(ss)==(byte)TO_WORD(para1, para2));

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
        return SD_BOOLEAN(sdss_is_mmss_operation(ss)!=(byte)TO_WORD(para1, para2));

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSS_CMP_CRITERIA_NONE:
      case SDSS_CMP_CRITERIA_MAX:
      default:
        SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
        return FALSE;
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    case SDSS_IF_COND_JCDMA:
      switch( cmp_criteria )
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
          return SD_BOOLEAN(sd_is_jcdma_enable()==(byte)TO_WORD(para1, para2));

          /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          return SD_BOOLEAN(sd_is_jcdma_enable()!=(byte)TO_WORD(para1, para2));

          /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
      }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_IF_COND_C2K_ALT_ALGR:
      switch( cmp_criteria )
      {
        /* This condition is TRUE only when */
        case SDSS_CMP_CRITERIA_EQUAL_TO:
          return sdss_is_c2k_alt_algr_operation();

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
      }

   /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
   case SDSS_IF_COND_LMTD_RESEL_ALLOWED:
     switch( cmp_criteria )
     {
       case SDSS_CMP_CRITERIA_EQUAL_TO:
       {
         boolean is_allowed = FALSE;

         SD_MSG_HIGH_2("SCSVLTE: ss=%d, global mode =%d",ss, ss_ptr->user_global_mode_pref);

         /* Hybrid LTE/DO BSR is required when limited service is acquired on
         ** Main or Hybr2 stack. It is not required if SS is HYBR3 stack.
         */  
         if(ss == SD_SS_HYBR_3)
         {
           SD_MSG_HIGH_0("SCSVLTE: HYBR BSR not allowed for SS 3");
         }
         /* If sub feature mode of main stack is SVLTE,check if HYBR LTE/HDR 
         ** operation is permitted.
         */		 
         else if(sdss_is_sfmode_1x_sxlte(SYS_MODEM_AS_ID_1) )            
         {
	   if(ss == SD_SS_HYBR_2 && sdss_get_ss_for_mode(SD_MODE_HDR) == SD_SS_HYBR_1)
	   {
             SD_MSG_HIGH_0("SCSVLTE: HYBR HDR is allowed ");
             is_allowed = TRUE;
           }
	   else if(ss == SD_SS_MAIN && 
   	           (sdss_get_ss_for_mode(SD_MODE_HDR) == SD_SS_HYBR_1 ||
                    sdss_get_ss_for_mode(SD_MODE_LTE) == SD_SS_HYBR_2)
                  )
	   {
             SD_MSG_HIGH_0("SCSVLTE: HYBR HDR/LTE allowed ");
             is_allowed = TRUE;	   		   
	   }		   
         }		 


         /* Return compare the computed is_allowed flag to the one passed in
         */
         return (is_allowed == TO_WORD( para1, para2 ));
       }

       case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
       case SDSS_CMP_CRITERIA_NONE:
       case SDSS_CMP_CRITERIA_MAX:
       default:
         SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
         return FALSE;
     }

   /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

   case SDSS_IF_COND_SRV_STATUS:
    switch( cmp_criteria )
    {
      case SDSS_CMP_CRITERIA_EQUAL_TO:
        {
          sys_srv_status_e_type srv_status =
                            (sys_srv_status_e_type)TO_WORD( para1, para2 );

          sys_srv_status_e_type srv_status_ss;

          sdss_read_srv_status( ss, &srv_status_ss, NULL );

          if(srv_status == SYS_SRV_STATUS_LIMITED)
          {
            return( srv_status_ss == SYS_SRV_STATUS_LIMITED);
          }
          else if (srv_status == SYS_SRV_STATUS_LIMITED_REGIONAL)
          {
            return( srv_status_ss == SYS_SRV_STATUS_LIMITED_REGIONAL);
          }
          else
          if(srv_status == SYS_SRV_STATUS_NO_SRV)
          {
            return( srv_status_ss == SYS_SRV_STATUS_NO_SRV ||
                    srv_status_ss == SYS_SRV_STATUS_NO_SRV_INTERNAL);
          }
          else
          {
            return(srv_status == srv_status_ss );
          }
        }

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
      case SDSS_CMP_CRITERIA_NONE:
      case SDSS_CMP_CRITERIA_MAX:
      default:
        SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
        return FALSE;
    }

    case SDSS_IF_COND_SI_SRV_STATUS:
     switch( cmp_criteria )
     {
       case SDSS_CMP_CRITERIA_EQUAL_TO:
         {
           sys_srv_status_e_type srv_status =
                             (sys_srv_status_e_type)TO_WORD( para1, para2 );
    
           sys_srv_status_e_type srv_status_ss;
    
           srv_status_ss = sd_si_get_srv_status( ss );
    
           if(srv_status == SYS_SRV_STATUS_LIMITED ||
              srv_status == SYS_SRV_STATUS_LIMITED_REGIONAL)
           {
             return( srv_status_ss == SYS_SRV_STATUS_LIMITED ||
                     srv_status_ss == SYS_SRV_STATUS_LIMITED_REGIONAL);
           }
           else
           if(srv_status == SYS_SRV_STATUS_NO_SRV)
           {
             return( srv_status_ss == SYS_SRV_STATUS_NO_SRV ||
                     srv_status_ss == SYS_SRV_STATUS_NO_SRV_INTERNAL);
           }
           else
           {
             return(srv_status == srv_status_ss );
           }
         }
    
         /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
       case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
       case SDSS_CMP_CRITERIA_NONE:
       case SDSS_CMP_CRITERIA_MAX:
       default:
         SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
         return FALSE;
     }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_IF_COND_IS_SVDO_SVLTE_MODE_SS_MAIN:
    {
      switch (cmp_criteria)
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
        {
          if (sdss_is_hybr_pref( ss, SD_SS_HYBR_PREF_CDMA__LTE__HDR )&&
              ss == SD_SS_MAIN &&
              ss_ptr->is_mmss_operation)
          {
            return TRUE;
          }
          else
          {
            return FALSE;
          }
        }

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
        {
          if( sdss_is_hybr_pref( ss, SD_SS_HYBR_PREF_CDMA__LTE__HDR )&&
              ss == SD_SS_MAIN )
          {
            return TRUE;
          }
          else
          {
            return FALSE;
          }
        }

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
      }
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_IF_COND_IS_SVDO_SVLTE_MODE:
    {
      switch (cmp_criteria)
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
        {
          if (sdss_is_hybr_pref( ss, SD_SS_HYBR_PREF_CDMA__LTE__HDR )&&
              ss_ptr->is_mmss_operation)
          {
            return TRUE;
          }
          else
          {
            return FALSE;
          }
        }

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
        {
          if (sdss_is_hybr_pref( ss, SD_SS_HYBR_PREF_CDMA__LTE__HDR )&&
              ss_ptr->is_mmss_operation)
          {
            return FALSE;
          }
          else
          {
            return TRUE;
          }
        }

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
      }
    }

    case SDSS_IF_COND_N_MIN_VOICE_SCAN:
      switch (cmp_criteria)
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
        {
          if (sdss_get_num_cfg(SD_SS_MAIN, SDSS_LOOP_NUM_CFG_N_MIN_VOICE_SCANS) > 0)
          {
            return TRUE;
          }
          else
          {
            return FALSE;
          }
        }

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
        {
          if(sdss_is_1x_sxlte())
          {
            if (ss_ptr->n_min_voice_scans == 0)
            {
              return TRUE;
            }
          }
          return FALSE;
        }

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
      }
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_IF_COND_3GPP_IN_BSR:
    {

      boolean                    retval            = FALSE;
      sd_ss_mode_pref_e_type     ss_mode_pref      = SD_SS_MODE_PREF_NONE;
      boolean is_3gpp_in_list = FALSE;
      sd_ss_mode_pref_e_type mode_pref_3gpp = SD_SS_MODE_PREF_TDS_GSM_WCDMA_LTE;
      sdsr_e_type pref_list = sdss_sr_list_map2( ss, SDSR_SRV_PREF_LST );


      sdss_get_mode_band_pref( ss,
                               &ss_mode_pref,
                               NULL,
                               NULL,
                               NULL );
       /* Check if either of the first 2 systems in the SRV_PREF_LST are 3GPP.
      */
      if ( sdsr_list_cnt(pref_list) > 2 )
      {
        is_3gpp_in_list =
            ( sdss_sr_is_mode_pref(sdsr_list_get_ptr(pref_list, 0),mode_pref_3gpp)||
              sdss_sr_is_mode_pref(sdsr_list_get_ptr(pref_list, 1),mode_pref_3gpp));
      }
      else
      {
        is_3gpp_in_list = sdss_sr_list_is_mode_pref( pref_list, mode_pref_3gpp );
      }

      retval = is_3gpp_in_list &&
           SD_MODE_CONTAIN( ss_mode_pref, mode_pref_3gpp);
      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      switch (cmp_criteria)
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
          return retval;

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          return !retval;

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;

      }
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_IF_COND_PLMN_STATUS:
    switch( cmp_criteria )
    {
      case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
      {
        if(ss_ptr->plmn_list_status != (sys_plmn_list_status_e_type)TO_WORD( para1, para2 ))
        {
          return TRUE;
        }
        else
        {
          return FALSE;
        }
      }
      case SDSS_CMP_CRITERIA_EQUAL_TO:
      {
        if(ss_ptr->plmn_list_status == (sys_plmn_list_status_e_type)TO_WORD( para1, para2 ))
        {
          return TRUE;
        }
        else
        {
          return FALSE;
        }
      }

      case SDSS_CMP_CRITERIA_NONE:
      case SDSS_CMP_CRITERIA_MAX:
      default:
        SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
        return FALSE;
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    case SDSS_IF_COND_CURRENT_SS:
    {

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      switch (cmp_criteria)
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
          return (ss == (sd_ss_e_type) TO_WORD(para1, para2));

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          return (ss != (sd_ss_e_type) TO_WORD(para1, para2));

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
      }
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    #ifdef FEATURE_MMODE_DYNAMIC_SV_OPERATION_SWITCH
    case SDSS_IF_COND_SV_DYNAMIC_SWITCH_ENABLED:
    {
      boolean retval = sdss_get_sv_dynamic_switch_enabled();

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      switch (cmp_criteria)
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
          return retval;

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          return !retval;

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
      }
    }
    #endif

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    case SDSS_IF_COND_HYBR2_LTE_IRAT_FAIL:
    {
      boolean lte_irat_fail = FALSE;

      if(ss == SD_SS_HYBR_2 && sdss_is_1x_sxlte())
      {
        lte_irat_fail = ss_ptr->is_hybr2_lte_irat_fail;
      }

      switch (cmp_criteria)
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
          return SD_BOOLEAN(lte_irat_fail == (byte)TO_WORD(para1, para2));

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          return SD_BOOLEAN(lte_irat_fail != (byte)TO_WORD(para1, para2));

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
      }

    }

    case SDSS_IF_COND_IS_IBSR_PWRUP_DONE:
    {
      boolean   iBSR_pwrup_done  = TRUE;

      if(ss == SD_SS_HYBR_2 && sdss_is_1x_sxlte())
      {
          iBSR_pwrup_done  =   ss_ptr->iBSR_pwrup ;
      }

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      switch (cmp_criteria)
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
          return SD_BOOLEAN(iBSR_pwrup_done == (byte)TO_WORD(para1, para2));

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          return SD_BOOLEAN(iBSR_pwrup_done != (byte)TO_WORD(para1, para2));

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return TRUE;
      }

    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    #ifdef FEATURE_LIMITED_SCAN_OPT
    case SDSS_IF_COND_IS_3GPP_SERVICE_FOUND:
    {
      boolean is_3gpp_scan_attempted = FALSE;
      is_3gpp_scan_attempted = sdss_get_is_3gpp_scan_attempted(ss);

      switch( cmp_criteria )
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:

          /* In 3GPP only devices, no need to issue limited routine scan*/
          if((SD_BIT_COMMON(sdss_get_subsc_type(ss), SDSS_SUBSC_GW) == 0) &&
              sdss_is_cap_3gpp_only(ss) && !sdss_is_e911_alternate_redial_algorithm(ss) &&
              !sdss_is_ral_stored_in_efs(ss)
             )
          {
            return FALSE;
          }
          /* If avoid_statate is inactive/none, treat as 3GPP service is found - legacy behavior */
          else if (sdss_is_avoid_state_inactive_or_none(ss) == TRUE ||
              is_3gpp_scan_attempted == FALSE)
          {
            return TRUE;
          }
          else
          {
            return SD_BOOLEAN(sdss_get_is_3gpp_service_found_per_cycle(ss)
                                                 == TO_WORD( para1, para2 ) );
          }

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
      }
    }
    #endif

    
    case SDSS_IF_COND_IS_RAL_STORED_IN_EFS:
    {      
      switch( cmp_criteria )
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
        {
          return SD_BOOLEAN(sdss_is_ral_stored_in_efs(ss)
                                                 == TO_WORD( para1, para2 ) );
        }
        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
      }
    }
    

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /* This condition checks if the hybr-1 stack is in eHRPD service */
    case SDSS_IF_COND_HDR_IS_IN_EHRPD:
    {
      boolean retval = FALSE;

      /* If reported HDR system is having service and the type is eHRPD */
      if (sdss_ptr(SD_SS_HYBR_1)->is_eHRPD_zone)
      {
        retval = TRUE;
      }
      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      switch (cmp_criteria)
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
          return retval;

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          return !retval;

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
      }
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_IF_COND_LTE_IS_IN_RESEL:
    {
      boolean retval = FALSE;
      sd_ss_mode_pref_e_type  mode_pref_main   = SD_SS_MODE_PREF_NONE;

      sdss_get_mode_band_pref( SD_SS_MAIN,
                               &mode_pref_main,
                               NULL,
                               NULL,
                               NULL );


      /* If the reselection is on hybr-2, it is LTE as LTE is dedicated on hybr-2*/
      if (ss == SD_SS_HYBR_2)
      {
        retval = TRUE;
      }
      /* If the reselection is on main, and mode is LTE-HDR only, then TRUE */
      else if (ss == SD_SS_MAIN )
      {
        /* if reselection happens on main and mode-pref is HDR-LTE only*/
        sdss_get_mode_band_pref( SD_SS_MAIN,
                                 &mode_pref_main,
                                 NULL,
                                 NULL,
                                 NULL );
        if(mode_pref_main == SD_SS_MODE_PREF_HDR_LTE )
        {
          retval = TRUE;
        }

         if(sdss_get_ss_for_mode(SD_MODE_LTE) == SD_SS_MAIN &&
           sdsr_list_is_lte_in_list(SDSR_SRV_PREF_LST))
        {
          retval = TRUE;
        }
      }

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      switch (cmp_criteria)
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
          return retval;

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          return !retval;

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
      }
    }

    /* This condition checks if 1x system is in LTEAvailFile/LTENotAvailFile */
    case SDSS_IF_COND_LTE_AVAIL_1X:
    {
      sdss_s_type   *ss_ptr_main = sdss_ptr( SD_SS_MAIN );

      switch( cmp_criteria )
      {
      case SDSS_CMP_CRITERIA_EQUAL_TO:

        if(sd_misc_get_ss_for_mode(SYS_SYS_MODE_LTE) == SD_SS_MAIN)
        {
          /* On main stack if moves from LTE avail to LTE not avail don't start
          ** long BSR immediately. Needs to wait for current BSR timer expire
          ** and trigger GWL scan
          */
          if(ss_ptr_main->lte_avail_1x == SDSS_LTE_AVAIL_NOT_AVAIL)
          {
            return (ss_ptr_main->lte_avail_1x ==
                           (sdss_lte_avail_e_type) TO_WORD( para1, para2 )
                   );
          }
        }

        return (ss_ptr_main->lte_avail_1x ==
                           (sdss_lte_avail_e_type) TO_WORD( para1, para2 ));

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
        return (ss_ptr_main->lte_avail_1x !=
                            (sdss_lte_avail_e_type) TO_WORD( para1, para2 ));

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSS_CMP_CRITERIA_NONE:
      case SDSS_CMP_CRITERIA_MAX:
      default:
        SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
        return FALSE;
      }
    }

    /* This condition checks if CDMA is in service */
    case SDSS_IF_COND_CDMA_IN_SRV:
    {
      boolean retval = FALSE;
      sd_si_info_s_type *si_info_ptr = &sd_si_ptr(SD_SS_MAIN)->si_info;;

      if( (si_info_ptr->mode == SYS_SYS_MODE_CDMA ||
           sdss_sr_list_is_mode(sdss_sr_list_map2( SD_SS_MAIN, SDSR_SRV_SYS ),SYS_SYS_MODE_CDMA)) &&
        (si_info_ptr->srv_status == SYS_SRV_STATUS_SRV))
      {
        retval = TRUE;
      }

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      switch (cmp_criteria)
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
          return retval;

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          return !retval;

        /*- - - - - - - - - -7 - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
      }
    }

	
	/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    case SDSS_IF_COND_LTE_EMERG_REDIAL:
	{
     switch( cmp_criteria )
     {
       case SDSS_CMP_CRITERIA_EQUAL_TO:
       {
    
         return (cmregprx_check_lte_priority_scan(ss)== TO_WORD( para1, para2 ));
       }

       case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
       case SDSS_CMP_CRITERIA_NONE:
       case SDSS_CMP_CRITERIA_MAX:
       default:
         SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
         return FALSE;
     }
    }
	/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SDSS_IF_COND_MODE_PREF:
      {

        boolean retval = FALSE;

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
        switch (cmp_criteria)
        {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
          if((sd_ss_mode_pref_e_type)TO_WORD( para1, para2 ) == ss_ptr->mode_pref)
            {
              retval = TRUE;
            }
          break;

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          if((sd_ss_mode_pref_e_type)TO_WORD( para1, para2 ) != ss_ptr->mode_pref)
            {
              retval = TRUE;
            }
          break;

        case SDSS_CMP_CRITERIA_CONTAINS:
          if(TRUE == SD_MODE_CONTAIN(ss_ptr->mode_pref, (sd_ss_mode_pref_e_type)TO_WORD( para1, para2 )))
            {
              retval = TRUE;
            }
          break;

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          break;
        }

        return retval;
      }

    case SDSS_IF_COND_SRCH_LST_IS_EMPTY:
    {
      switch (cmp_criteria)
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
          return (sdsr_list_cnt( sdss_sr_list_map2( ss, SDSR_SRCH_LST)) == 0);

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          return (sdsr_list_cnt( sdss_sr_list_map2( ss, SDSR_SRCH_LST)) != 0);

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
      }
    }
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
     case SDSS_IF_COND_SRV_REQ_TYPE:
     {
       switch (cmp_criteria)
       {
         case SDSS_CMP_CRITERIA_EQUAL_TO:
           return(SD_BOOLEAN (ss_ptr->srv_req_type == TO_WORD( para1, para2 )));

         /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

         case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
           return(SD_BOOLEAN (ss_ptr->srv_req_type != TO_WORD( para1, para2 )));

         /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

         case SDSS_CMP_CRITERIA_NONE:
         case SDSS_CMP_CRITERIA_MAX:
         default:
           SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
           return FALSE;
       }
     }

   case SDSS_IF_COND_LOC_BASE_BSR:
    {
      switch (cmp_criteria)
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
          return SD_BOOLEAN(ss_ptr->is_loc_based_bsr == (byte)TO_WORD(para1, para2));

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          return SD_BOOLEAN(ss_ptr->is_loc_based_bsr != (byte)TO_WORD(para1, para2));

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_2("Invalid cmp_criteria %d of if_cond %d", cmp_criteria, if_cond);
          return FALSE;
      }
     }

    case SDSS_IF_COND_ACQ_STATUS:
      switch( cmp_criteria )
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
         return SD_BOOLEAN(ss_ptr->acq_status == (byte)TO_WORD(para1, para2));

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          return SD_BOOLEAN(ss_ptr->acq_status != (byte)TO_WORD(para1, para2));

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
      }

    case SDSS_IF_COND_ACQ_STATUS_2:
      switch( cmp_criteria )
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
         return SD_BOOLEAN(sdss_get_acq_status_2(ss) == (byte)TO_WORD(para1, para2));

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          return SD_BOOLEAN(sdss_get_acq_status_2(ss) != (byte)TO_WORD(para1, para2));

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
      }

    case SDSS_IF_COND_IS_QMSS_ENABLED:
    {
      switch( cmp_criteria )
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
          return ( SD_BOOLEAN( sdss_common.sd_qmss_enabled == TO_WORD( para1, para2 )));

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          return ( SD_BOOLEAN( sdss_common.sd_qmss_enabled != TO_WORD( para1, para2 ) ) );

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      }
    }
    case SDSS_IF_COND_SCAN_SCOPE_RULE:
    {
      uint16 scan_scope_rule = sdss_get_scan_scope_rule();
      
      SD_MSG_HIGH_3("Scan Scope Rule: %d,gcf:%d, mmss:%d", scan_scope_rule,
                     ss_ptr->gprs_anite_gcf,ss_ptr->is_mmss_operation);

      /*ACQ DB Scans shouldn't be triggered while in GCF Mode*/
      if(ss_ptr->gprs_anite_gcf)
      {
        return FALSE;
      }
      
      /* With MMSS we support only NO TRM acq dB*/
      if(ss_ptr->is_mmss_operation)
      {
        scan_scope_rule &= SYS_SCAN_SCOPE_RULE_ACQ_DB_NO_TRM;
      }
      
      switch( cmp_criteria )
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
          return ( SD_BOOLEAN( scan_scope_rule == TO_WORD( para1, para2 )));

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          return ( SD_BOOLEAN( scan_scope_rule != TO_WORD( para1, para2 ) ) );

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_CONTAINS:
          return ( SD_BOOLEAN( (scan_scope_rule & TO_WORD( para1, para2 ) ) ? TRUE : FALSE ) );

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      }
    }
    case SDSS_IF_COND_FEATURE_MODE:
      switch(cmp_criteria)
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
          return ( SD_BOOLEAN( sdss_common.onebuild_feature == TO_WORD( para1, para2 )));

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          return ( SD_BOOLEAN( sdss_common.onebuild_feature != TO_WORD( para1, para2 ) ) );

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      }

      case SDSS_IF_COND_SCAN_SCOPE:
      switch( cmp_criteria )
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
          return(SD_BOOLEAN (ss_ptr->scan_scope == TO_WORD( para1, para2 )));


        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          return ( SD_BOOLEAN( ss_ptr->scan_scope!= TO_WORD( para1, para2 ) ) );

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_CONTAINS:
          return ( SD_BOOLEAN( (ss_ptr->scan_scope & TO_WORD( para1, para2 ) ) ? TRUE : FALSE ) );

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      }


      case SDSS_IF_COND_SUBS_FEATURE_MODE:
        {
            sys_subs_feature_t sfmode;

            if(ss == SD_SS_HYBR_3)
            {
              sfmode = sdss_common.subs_feature[1];
            }
            else
            {
              sfmode = sdss_common.subs_feature[0];
            }

            switch(cmp_criteria)
            {
              case SDSS_CMP_CRITERIA_EQUAL_TO:
                return ( SD_BOOLEAN( sfmode == TO_WORD( para1, para2 )));

              /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

              case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
                return ( SD_BOOLEAN( sfmode != TO_WORD( para1, para2 ) ) );

              /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

              default:
                SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
                return FALSE;
              /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
            }
       }


    case SDSS_IF_COND_IS_SUB_FMODE_1X_SRLTE:
      {
        uint8 sub_idx = 0;

        if(ss == SD_SS_HYBR_3)
        {
          sub_idx = 1;
        }
        else
        {
          sub_idx = 0;
        }
      
        switch (cmp_criteria)
        {
          case SDSS_CMP_CRITERIA_EQUAL_TO:
          {
            if (sdss_is_sfmode_1x_srlte(sub_idx))
            {
              return TRUE;
            }
            else
            {
              return FALSE;
            }
          }
  
          case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          {
            if (sdss_is_sfmode_1x_srlte(sub_idx))
            {
              return FALSE;
            }
            else
            {
              return TRUE;
            }
          }
  
          case SDSS_CMP_CRITERIA_NONE:
          case SDSS_CMP_CRITERIA_MAX:
          default:
            SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
            return FALSE;
        }
      }
    case SDSS_IF_COND_IS_SUB_FMODE_1X_SXLTE:
      {
        uint8 sub_idx = 0;

        if(ss == SD_SS_HYBR_3)
        {
          sub_idx = 1;
        }
        else
        {
          sub_idx = 0;
        }
      
        switch (cmp_criteria)
        {
          case SDSS_CMP_CRITERIA_EQUAL_TO:
          {
            if (sdss_is_sfmode_1x_sxlte(sub_idx))
            {
              return TRUE;
            }
            else
            {
              return FALSE;
            }
          }
  
          case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          {
            if (sdss_is_sfmode_1x_sxlte(sub_idx))
            {
              return FALSE;
            }
            else
            {
              return TRUE;
            }
          }
  
          case SDSS_CMP_CRITERIA_NONE:
          case SDSS_CMP_CRITERIA_MAX:
          default:
            SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
            return FALSE;
        }
      }
    
    case SDSS_IF_COND_IS_MORE_PREF_HDR_SCAN:
      switch( cmp_criteria )
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
          return ( SD_BOOLEAN(sdss_is_resel_state(ss, SDSS_RESEL_STT_MORE_PREF_HDR_SCAN) ==
                              TO_WORD( para1, para2 )));

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          return ( SD_BOOLEAN( sdss_is_resel_state(ss, SDSS_RESEL_STT_MORE_PREF_HDR_SCAN !=
                              TO_WORD( para1, para2 ))));

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      }

  /*- - - - - - - - - - - - - - - - - - - - - - -  - - - - - - - - - - -*/
  case SDSS_IF_COND_EXTEND_1X_BSR:
    switch(cmp_criteria)
    {
      case SDSS_CMP_CRITERIA_EQUAL_TO:
        return ( SD_BOOLEAN(ss_ptr->is_extend_1x_bsr_timer == TO_WORD( para1, para2 )));

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
        return ( SD_BOOLEAN( ss_ptr->is_extend_1x_bsr_timer  != TO_WORD( para1, para2 ) ) );

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      default:
        SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria );
        return FALSE;
      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    }

   case SDSS_IF_COND_CSG_APP_SEARCH_SUCCESS:
    switch( cmp_criteria )
    {
      case SDSS_CMP_CRITERIA_EQUAL_TO:
      {
        boolean retval = FALSE;
        if(ss_ptr->get_net_list_type == SD_NETWORK_LIST_CSG_USER ||
            ss_ptr->get_net_list_type == SD_NETWORK_LIST_CSG_SELECTION_APP)
        {
         if((ss_ptr->plmn_list_status == SYS_PLMN_LIST_SUCCESS) &&
            (ss_ptr->plmn_list_length > 0 ))
          {
            retval =  TRUE;
          }
        }
        return (SD_BOOLEAN( retval == TO_WORD( para1, para2 ) ) );
      }
      case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
      case SDSS_CMP_CRITERIA_NONE:
      case SDSS_CMP_CRITERIA_MAX:
      default:
        SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
        return FALSE;
    }

    case SDSS_IF_COND_IS_CT_ON_MAIN:
      switch( cmp_criteria )
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
          return ( SD_BOOLEAN( (sdss_get_operator_name ( SYS_MODEM_AS_ID_1 ) == SD_OPERATOR_CT)
                      && (ss == SD_SS_MAIN) && (srv_sys_ptr != NULL) &&
                            (srv_sys_ptr->roam != SYS_ROAM_STATUS_OFF)));

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          return ( SD_BOOLEAN( (ss != SD_SS_MAIN) ||
                 (sdss_get_operator_name ( SYS_MODEM_AS_ID_1 ) != SD_OPERATOR_CT)));

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      }
    case SDSS_IF_COND_HYBR2_BSR_FLAG_SET:
      switch( cmp_criteria )
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
          return ( SD_BOOLEAN(sdss_is_flag_set(ss, SDSS_FLAG_HYBR2_BSR) == 
                              TO_WORD( para1, para2 )));

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          return ( SD_BOOLEAN( sdss_is_flag_set(ss, SDSS_FLAG_HYBR2_BSR) != 
                              TO_WORD( para1, para2 )));

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      }
    case SDSS_IF_COND_DISABLE_BSR_IN_AUTO_CSG:
    switch( cmp_criteria )
    {
      case SDSS_CMP_CRITERIA_EQUAL_TO:
      {
        boolean retval = FALSE;
        /* If camped on CSG cell and NV is enabled to disable BSR make CSG cell MOST PREF*/
        retval = sdss_get_disable_bsr_in_auto_mode_csg_support(ss);
        return (SD_BOOLEAN( retval == TO_WORD( para1, para2 ) ) );
      }
      case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
      case SDSS_CMP_CRITERIA_NONE:
      case SDSS_CMP_CRITERIA_MAX:
      default:
        SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
        return FALSE;
     }


    case SDSS_IF_COND_EHRPD_OPT_SR_ENABLED:
      switch(cmp_criteria)
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
          return ( SD_BOOLEAN( sdss_common.is_ehrpd_opt_redial== TO_WORD( para1, para2 )));
			  
        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          return ( SD_BOOLEAN( sdss_common.is_ehrpd_opt_redial != TO_WORD( para1, para2 ) ) );
			
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;	
      }
	  
    case SDSS_IF_COND_REDIR_TYPE:
    {
      switch( cmp_criteria )
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:

          return SD_BOOLEAN( sdss_ptr(SD_SS_MAIN)->redir ==
                                                    TO_WORD( para1, para2 ));

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:

          return SD_BOOLEAN( sdss_ptr(SD_SS_MAIN)->redir !=
                                                    TO_WORD( para1, para2 ));

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria );
          return FALSE;
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      }
    } /* case SDSS_IF_COND_REDIR_TYPE */

    case SDSS_IF_COND_NO_TRM_SRLTE:
    {
      switch (cmp_criteria)
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
        {
          return (sdss_is_sfmode_1x_srlte(SYS_MODEM_AS_ID_1)
              && ss_ptr->acq_status == SYS_ACQ_STATUS_NO_RESOURCE
              && sdss_get_scan_scope_rule() & SYS_SCAN_SCOPE_RULE_ACQ_DB_NO_TRM
              && ss == SD_SS_HYBR_2);
        }
      
        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
        {
          return (!(sdss_is_sfmode_1x_srlte(SYS_MODEM_AS_ID_1)
              && ss_ptr->acq_status == SYS_ACQ_STATUS_NO_RESOURCE
              && sdss_get_scan_scope_rule() & SYS_SCAN_SCOPE_RULE_ACQ_DB_NO_TRM
              && ss == SD_SS_HYBR_2));
        }
      
        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
      }
    
    }

    /* check if trm not avail and scan status is aborted due to 
       no TRM resource, do not acquire GWL service 
       trm acq is not allowed during GSM call on sub 2 and acq gwl
       has been attempted once (with returned scan status ABORTED)
    */
    case SDSS_IF_COND_TRM_ACQ_ALLOWED:
    {
      boolean result = TRUE;
      result = sdss_is_trm_available(ss);
      if(!result && ss_ptr->acq_gwl_scan_status == SD_SS_GWL_SCAN_STATUS_ABORTED)
      {
        return FALSE;
      }
      else
      {
        return TRUE;
      }
    }

    case SDSS_IF_COND_TRM_AVAIL:
    {
      boolean result = TRUE;
      sys_acq_status_e_type acq_status = sdss_get_acq_status_only(ss);
      
      if(acq_status == SYS_ACQ_STATUS_NO_RESOURCE)
      {
        boolean is_pref_update_reason_trm_unlock 
          = sdss_is_pref_update_reas(ss, SD_SS_PREF_UPDATE_REASON_TRM_UNLOCK);
        boolean is_trm_unlock_in_progress = sdss_is_trm_unlock_in_progress(ss);

        SD_MSG_HIGH_2("COND_TRM_AVAIL: is_pref_update_reason_trm_unlock %d, is_trm_unlock_in_progress %d",
                        is_pref_update_reason_trm_unlock,
                        is_trm_unlock_in_progress
                       );
      
        if(is_pref_update_reason_trm_unlock || is_trm_unlock_in_progress)
        {
          result = TRUE;
        }
        else
        {
          result = FALSE;
        }
      }
      SD_MSG_HIGH_3("COND_TRM_AVLBL cond %d in %d result %d",
                    cmp_criteria, TO_WORD(para1, para2), result);
      
      switch(cmp_criteria)
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
          return result == (boolean)TO_WORD(para1, para2);
          
        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          return result != (boolean)TO_WORD(para1, para2);
          
        default:
          return FALSE;
      }
    }
    /*if TRM is not available and feature mode is svlte+g and ss is hybr2
      clear srv_pref_lst
    */
    case SDSS_IF_COND_CLR_SRV_PREF_LST:
    {
      boolean result = TRUE;
      result = sdss_is_trm_available(ss);
      if(!result && sdss_is_sfmode_svlte(0) && 
        sdss_is_featuremode(SYS_OVERALL_FEATURE_MODE_MULTISIM) && 
        ss == SD_SS_HYBR_2)
      {
        return TRUE;
      }
      else
      {
        return FALSE;
      }
    }

   case SDSS_IF_COND_FULL_SRV_REQ_EMERG:
     switch(cmp_criteria)
     {
       case SDSS_CMP_CRITERIA_EQUAL_TO:
         return ( SD_BOOLEAN( sdss_get_is_full_srv_req_during_emerg(ss) == TO_WORD( para1, para2 )));
         /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
     
       case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
         return ( SD_BOOLEAN( sdss_get_is_full_srv_req_during_emerg(ss) != TO_WORD( para1, para2 ) ) );
         /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
     
       default:
         SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria );
         return FALSE;
       /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
     }

   case SDSS_IF_COND_PREV_ORIG_MODE_VAL:
     SD_MSG_HIGH_2("prev_orig_mode %d req_orig_mode %d",BM( sdss_ptr(ss)->orig_mode_prev ), TO_WORD( para1, para2 ) );
     switch(cmp_criteria)
     {
       case SDSS_CMP_CRITERIA_EQUAL_TO:
         return ( SD_IS_BIT_CONTAIN(TO_WORD( para1, para2 ), BM(sdss_ptr(ss)->orig_mode_prev)) );
   
       /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
     
       case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
         return ( !SD_IS_BIT_CONTAIN(TO_WORD( para1, para2 ), BM(sdss_ptr(ss)->orig_mode_prev)) );
   
       /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
   
       default:
         SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria );
         return FALSE;
     /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
     }

    case SDSS_IF_COND_CAP_3GPP_PREF_3GPP_ONLY:
    {
      boolean result = FALSE;
      sd_ss_mode_pref_e_type  mode_pref;
      sd_ss_mode_pref_e_type   ss_mode_pref      = SD_SS_MODE_PREF_NONE;
      sd_ss_band_pref_e_type   ss_band_pref      = SD_SS_BAND_PREF_NONE;
      sys_lte_band_mask_e_type ss_lte_band_pref  = SYS_LTE_BAND_MASK_CONST_NONE;
      sd_ss_band_pref_e_type   ss_tds_band_pref  = SD_SS_BAND_PREF_NONE;

      sdss_get_mode_band_pref( ss,
                           &ss_mode_pref,
                           &ss_band_pref,
                           &ss_lte_band_pref,
                           &ss_tds_band_pref );
      /* Get the intersection of the current mode preference, band preference
      ** and the band capability
      ** mode_pref = user settings ^ phone capability
      */
      mode_pref =  sdss_get_supp_mode_pref_mmode(ss_mode_pref,
                                                 ss_band_pref,
                                                 ss_lte_band_pref,
                                                 ss_tds_band_pref);

      /* Check if the mode_pref has any modes other than TGWL
      ** If mode_pref has any non TGWL modes then fail the check or else return
      ** TRUE.
      */
      result = ( mode_pref != SD_SS_MODE_PREF_NONE &&
                 !(SD_MODE_CONTAIN(mode_pref,~(word)SD_SS_MODE_PREF_TDS_GSM_WCDMA_LTE)))?TRUE:FALSE;

      
      switch(cmp_criteria)
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
          return result == (boolean)TO_WORD(para1, para2);
          
        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          return result != (boolean)TO_WORD(para1, para2);
          
        default:
          return FALSE;
      }
    }

    case SDSS_IF_COND_1XSIB8_SCAN_ALLOWED:
    {	
      switch( cmp_criteria )
      {

        case SDSS_CMP_CRITERIA_EQUAL_TO:
  	  return ( SD_BOOLEAN(sdss_is_1xsib8_scan_allowed(ss) == 
						TO_WORD( para1, para2 )));
	  
	  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
	  
        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
 	  return ( SD_BOOLEAN( sdss_is_1xsib8_scan_allowed(ss) != 
						TO_WORD( para1, para2 )));
	  
	  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
	  
        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
	  SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
	  return FALSE;
	  
      }
    }
  case SDSS_IF_COND_IS_DDS_SWITCHBACK_FROM_TEMP:
    {
      switch( cmp_criteria )
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
          return ss_ptr->is_dds_switchback_from_temp;

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
      }
    }

	case SDSS_IF_COND_EMERG_IN_ROAM:
    {
	  switch( cmp_criteria )
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
          return ( SD_BOOLEAN( sdss_is_emerg_in_roam_for_volte_specialization(ss) == TO_WORD( para1, para2 )));

        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_LOW_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
      }  
	}

    case SDSS_IF_COND_CHINA_EMERG_CRITERIA: /* Currently handling only GW and 1x subscriptions */
    {
      /* THIS IF COND IS DEPENDENT UPON MCC/MNC & EFS VALUE, PLEASE USE CAUTIOUSLY */
      boolean bEvalAgainst              = TO_WORD(para1, para2); /* if cond. to be evaluated against true or false */
      boolean china_emerg_scan_criteria = sdss_is_china_emerg_scan_allowed(ss);

      SD_MSG_HIGH_3("SDSS_IF_COND_CHINA_EMERG_CRITERIA cmp_criteria %d, bEvalAgainst %d, cfg_efs %d", cmp_criteria,bEvalAgainst,\
        sdss_common.cfg_emerg_call_1x_scan_first);
      SD_MSG_HIGH_3("SDSS_IF_COND_CHINA_EMERG_CRITERIA ss_ptr->is_gw_subsc_avail %d, ss_ptr->is_1x_subsc_avail %d, china_emerg_scan_criteria %d", \
        ss_ptr->is_gw_subsc_avail, ss_ptr->is_1x_subsc_avail, china_emerg_scan_criteria);

      switch( cmp_criteria )
      {
        case SDSS_CMP_CRITERIA_EQUAL_TO:
          if(TRUE == bEvalAgainst)
          {
            return china_emerg_scan_criteria;
          }
          else /* bEvalAgainst is FALSE */
          {
            return !china_emerg_scan_criteria;
          }
          /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
        case SDSS_CMP_CRITERIA_NOT_EQUAL_TO:
          if(TRUE == bEvalAgainst)
          {
            return !china_emerg_scan_criteria;
          }
          else /* bEvalAgainst is FALSE */
          {
            return china_emerg_scan_criteria;
          }
          /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
        case SDSS_CMP_CRITERIA_NONE:
        case SDSS_CMP_CRITERIA_MAX:
        default:
          SD_MSG_HIGH_1("Invalid cmp_criteria %d", cmp_criteria);
          return FALSE;
        /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      }
    }
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    case SDSS_IF_COND_NONE:
    case SDSS_IF_COND_MAX:
    default:

      SD_ERR_1("Invalid if_cond %d", if_cond);

      return FALSE;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  } /* if cond */
} /* sdss_is_if_cond */

/*lint +esym(715,ss) */
/*lint +esym(715,cmp_criteria) */
/*lint +esym(715,para1) */
/*lint +esym(715,para2) */

/*===========================================================================

FUNCTION sdss_reset_gw_acq_para

DESCRIPTION
  Reset the GW scan parameters

DEPENDENCIES
  None.

RETURN VALUE
 DWORD

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                  sdss_reset_gw_acq_para(

        sd_ss_e_type          ss
            /* The System selection stack
            */
)
/*lint -esym(715,ss) */
{
  #ifdef FEATURE_EOOS
  #error code not present
#endif
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  return;
}
/*lint +esym(715,ss) */


/*===========================================================================

FUNCTION sdss_is_prl_support_hdr

DESCRIPTION

  Return the indication whether PRL Support HDR or not based on current
  BAND PREF

  MODE
DEPENDENCIES
  None

RETURN VALUE
  Return the filtered mode preference as described.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean    sdss_is_prl_support_hdr(void)
{

  sdss_s_type   *ss_ptr   = sdss_ptr(SD_SS_MAIN);

  return  ss_ptr->is_prl_support_hdr;

} /* sdss_misc_is_prl_support_hdr */

/*===========================================================================

FUNCTION sdss_clear_bsr_timer

DESCRIPTION

  Clears BSR timer uptime.

DEPENDENCIES
  None

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/

EXTERN void sdss_clear_bsr_timer(sd_ss_e_type ss)
{
  sdss_s_type   *ss_ptr   = sdss_ptr(ss);

  ss_ptr->bsr_timer = 0;
  return;

} /* sdss_bsr_sr_get */

/*===========================================================================

FUNCTION sdss_check_bsr_timer

DESCRIPTION

  Checks whether to clear BSR timer uptime and if needed clears BSR timer uptime.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_check_bsr_timer(sd_ss_e_type ss)
{

  sdss_s_type   *ss_ptr   = sdss_ptr(ss);
  sdsr_s_type* srv_sys_ptr = NULL;
  #ifdef FEATURE_HDR
  unsigned int i;
  #endif /* FEATURE_HDR */
  boolean       match = TRUE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  srv_sys_ptr = sdsr_list_get_ptr(sdss_sr_list_map2( ss, SDSR_SRV_SYS), 0);

  if(srv_sys_ptr == NULL)
  {
    return;
  }

  /* Compare bsr sys with SRV_SYS sys */
  if (ss_ptr->bsr_sys.mode!= srv_sys_ptr->sys.mode)
  {
    match = FALSE;
  }
  else
  {
    /* Compare the two SIDs based on the system's mode.
    */
    switch( srv_sys_ptr->sys.mode )
    {
      case SD_MODE_AMPS:
      case SD_MODE_CDMA:

        if( ss_ptr->bsr_sid.is95.sid != srv_sys_ptr->sid.is95.sid ||
            ss_ptr->bsr_sid.is95.nid != srv_sys_ptr->sid.is95.nid )
        {
          match = FALSE;
        }
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SD_MODE_HDR:

        #ifdef FEATURE_HDR
        for( i=0; i < ARR_SIZE(srv_sys_ptr->sid.is856.sector_id); i++ )
        {
          if( ss_ptr->bsr_sid.is856.sector_id[i] != srv_sys_ptr->sid.is856.sector_id[i] )
          {
            match = FALSE;
          }
        }
        #endif /* FEATURE_HDR */
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SD_MODE_GSM:
      case SD_MODE_WCDMA:
      case SD_MODE_GW:
      case SD_MODE_LTE:
      case SD_MODE_GWL:
      case SD_MODE_TDS:

        match = sys_plmn_match( ss_ptr->bsr_sid.plmn.plmn_id,
                               srv_sys_ptr->sid.plmn.plmn_id );
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SD_MODE_NONE:
      case SD_MODE_INACT:
      case SD_MODE_GPS:
      case SD_MODE_MAX:
      default:
        SD_MSG_HIGH_1("CHECK_BSR_TIMER not valid for mode %d",srv_sys_ptr->sys.mode);
        return;
    }

  } /* else  */


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Reset BSR timer uptime if SRV_SYS does not matches with BSR system.
  */
  if(match == FALSE)
  {
    sdss_clear_bsr_timer(ss);
  }

  return;
}

/*===========================================================================

FUNCTION sdss_set_gw_pwr_save_acq_stage

DESCRIPTION

  Set the GW power save acquisition stage.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_set_gw_pwr_save_acq_stage(

            sd_ss_e_type                  ss,
            /* System selection stack */

            byte                             val
            /* STAGE value */
)
{
   sdss_s_type   *ss_ptr   = sdss_ptr( ss );

   ss_ptr->gw_pwr_save_acq_stage_val = val;

   SD_MSG_HIGH_1("GW PWR SAVE STAGE %d",ss_ptr->gw_pwr_save_acq_stage_val);
   return;
}

/*===========================================================================
FUNCTION sdss_gw_sim_domain_valid

DESCRIPTION

  Checks whether SIM is valid for all selected domains in current SS.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN boolean sdss_gw_sim_domain_valid(

           sd_ss_e_type          ss
            /* System selection stack
            */
)
/*lint -esym(550, ss) */ /* not accessed */
/*lint -esym(715, ss) */ /* not referenced */
{
  /*lint -esym(550, ss_ptr) */ /* not accessed */
  #if defined(SD_GSM_SUPPORTED) || defined(SD_WCDMA_SUPPORTED)  || defined (FEATURE_SD_LTE )

  sys_sim_state_e_type         ss_sim_state   = SYS_SIM_STATE_NONE;
  sd_ss_srv_domain_pref_e_type ss_domain_pref = SD_SS_SRV_DOMAIN_PREF_NONE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  ss_sim_state    = sdss_get_sim_state(ss);
  ss_domain_pref  = sdss_get_domain_pref(ss);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if(!((ss_sim_state    == SYS_SIM_STATE_CS_INVALID &&
        ss_domain_pref  == SD_SS_SRV_DOMAIN_PREF_CS_ONLY) ||
       (ss_sim_state    == SYS_SIM_STATE_PS_INVALID &&
        ((ss_domain_pref  == SD_SS_SRV_DOMAIN_PREF_PS_ONLY) || 
          (ss_domain_pref  == SD_SS_SRV_DOMAIN_PREF_VOLTE))) ||
       (ss_sim_state    == SYS_SIM_STATE_CS_PS_INVALID)   ||
       (ss_sim_state    == SYS_SIM_STATE_NOT_AVAILABLE)
      )
    )
  {
    return TRUE;
  }

  SD_MSG_HIGH_3("gw_sim_domain_valid: ss=%d sim_state=%d domain=%d",
               ss,
               ss_sim_state,
               ss_domain_pref);

  #endif
  return FALSE;
}
/*lint +esym(550, ss) */ /* not accessed */
/*lint +esym(715, ss) */ /* not referenced */

/*===========================================================================

FUNCTION sdss_update_prev_rat_pri_list_info

DESCRIPTION
  Updates the SDSS's previous rat_pri_list with given rat_pri_list.

DEPENDENCIES
  None.

RETURN VALUE
  UE capability

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void sdss_update_prev_rat_pri_list_info(

        sd_ss_e_type                  ss,
            /* System selection - MAIN or HYBR_2.
            */

       sys_rat_pri_list_info_s_type  *rat_pri_list
           /* Rat priority list to be stored
           */
)
/*lint -esym(818, rat_pri_list) */
{
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  SD_ASSERT( rat_pri_list != NULL );

  SD_CRIT_SECT_ENTER();
  *(&(sdss_ptr(ss)->prev_rat_pri_list_info)) = *rat_pri_list;
  SD_CRIT_SECT_EXIT();

  return;
}
/*lint +esym(818, rat_pri_list) */

/*===========================================================================

FUNCTION sdss_update_rat_pri_list_info

DESCRIPTION
  Updates the SDSS's previous rat_pri_list with given rat_pri_list.

DEPENDENCIES
  None.

RETURN VALUE
  UE capability

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void sdss_update_rat_pri_list_info(

        sd_ss_e_type                  ss,
            /* System selection - MAIN or HYBR_2.
            */

       sys_rat_pri_list_info_s_type  *rat_pri_list
           /* Rat priority list to be stored
           */
)
/*lint -esym(818, rat_pri_list) */
{
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  SD_ASSERT( rat_pri_list != NULL );

  SD_CRIT_SECT_ENTER();
  *(&(sdss_ptr(ss)->rat_pri_list_info)) = *rat_pri_list;
  SD_CRIT_SECT_EXIT();

  return;
}
/*lint +esym(818, rat_pri_list) */

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_find_rat_pri_sys_idx

DESCRIPTION
  Get the index of the given sys mode in the rat priority list

DEPENDENCIES
  None.

RETURN VALUE
  index into the rat priority list

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  uint32 sdss_find_rat_pri_sys_idx(

        sys_rat_pri_list_info_s_type  *rat_pri,
            /* System selection stack.
            */

        sys_sys_mode_e_type           sys_mode
)
{
  uint32  i = 0;

  for( i = 0 ; i< rat_pri->num_items; i++)
  {
    if(sys_mode == rat_pri->priority_list_info[i].acq_sys_mode)
    {
      return i;
    }
  }
  return rat_pri->num_items;
}

/*===========================================================================

FUNCTION sdss_get_rat_pri_sys_idx

DESCRIPTION
  Get the index of the given sys mode in the rat priority list

DEPENDENCIES
  None.

RETURN VALUE
  index into the rat priority list

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  uint32 sdss_get_rat_pri_sys_idx(

        sd_ss_e_type                  ss,
            /* System selection stack.
            */

        sys_sys_mode_e_type           sys_mode
)
{
  sys_rat_pri_list_info_s_type     *rat_pri;
  uint32 ret_val;

  rat_pri = (sys_rat_pri_list_info_s_type*)modem_mem_alloc(sizeof(sys_rat_pri_list_info_s_type),MODEM_MEM_CLIENT_MMODE);

  if (rat_pri == NULL)
  {
    SD_ERR_0("Can't allocate sys_rat_pri_list_info_s_type");
    return 0;
  }
  sdss_get_rat_pri_list_info( ss, rat_pri );
  ret_val = sdss_find_rat_pri_sys_idx(rat_pri, sys_mode);

  modem_mem_free(rat_pri,MODEM_MEM_CLIENT_MMODE);
  return (ret_val);
  }

#ifdef FEATURE_EOOS
#error code not present
#endif
#ifdef FEATURE_EOOS
#error code not present
#endif

#ifdef FEATURE_EOOS_UMTS
/*lint -esym(818,lte_scan_time) */
/*===========================================================================

FUNCTION sdss_compute_eoos_params

DESCRIPTION
   Get EOOS scan/sleep Time
DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void             sdss_compute_gwl_eoos_params(

        sd_ss_e_type              ss,
            /* System selection stack.
            */

        dword                     *wcdma_scan_time,
            /* Pointer to return wcdma scan time in Milliseconds
            */

        dword                     *gsm_scan_time,
            /* Pointer to return gsm scan time in Milliseconds
            */

        dword                     *lte_scan_time,
            /* Pointer to return lte scan time in Milliseconds
            */

        dword                     *sleep_time
            /* Pointer to return sleep time in Seconds */
)
/*lint -esym(715,lte_scan_time) */
{

  sdss_s_type   *ss_ptr   = sdss_ptr( ss );


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  dword  temp_sleep_time;
  dword  temp_wcdma_scan_time;
  dword  temp_gsm_scan_time;

  if (sdss_is_eoos_phase_time_based(ss, SDSS_EOOS_PHASE_ONE))
  {
    if (ss_ptr->eoos_parameters.eoos_svc_lost)
    {
       /* Service lost in phase 1 */
       temp_wcdma_scan_time  = ss_ptr->eoos_parameters.eoos_wcdma_scan_time_los_phase1;
       temp_gsm_scan_time = ss_ptr->eoos_parameters.eoos_gsm_scan_time_los_phase1;
    }
    else
    {    /* Phase 1 other than service lost */
         temp_wcdma_scan_time  = ss_ptr->eoos_parameters.eoos_wcdma_scan_time_def_phase1;
         temp_gsm_scan_time = ss_ptr->eoos_parameters.eoos_gsm_scan_time_def_phase1;
    }

  }
  else
  {
     /* Other phases than Phase 1 */
     /* Need to figure out if this is a GW only mode, or multimode */
     if(sdss_is_user_1x_gw_and_curr_1x_gw (ss_ptr))
     {
         /* MultiRAT scenario */
         temp_wcdma_scan_time  = ss_ptr->eoos_parameters.eoos_wcdma_scan_time_def_phase23;
         temp_gsm_scan_time = ss_ptr->eoos_parameters.eoos_gsm_scan_time_def_phase23;
     }
     else
     {
         /* GW only case */
         temp_wcdma_scan_time  = ss_ptr->eoos_parameters.eoos_gw_scan_time_phase23;
         temp_gsm_scan_time = ss_ptr->eoos_parameters.eoos_gw_scan_time_phase23;
     }
  }


  sdss_get_eoos_sleep_time (&temp_sleep_time,
                                SDSSSCR_CONT_RAT_GW_SLEEP_TYPE, ss);

  if( gsm_scan_time != NULL )
  {
    *gsm_scan_time = temp_gsm_scan_time;
  }


  if( wcdma_scan_time != NULL )
  {
    *wcdma_scan_time = temp_wcdma_scan_time;
  }


  if( sleep_time != NULL )
  {
    *sleep_time = temp_sleep_time;
  }

} /* sdss_compute_eoos_params */
/*lint +esym(715,lte_scan_time) */
/*lint +esym(818,lte_scan_time) */
#endif

/*===========================================================================

FUNCTION sdss_is_home_1X

DESCRIPTION
  Returns TRUE if last serving system was home 1X system.

DEPENDENCIES
  None.

RETURN VALUE
 True : MRU[0] was home 1X
 False otherwise

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean sdss_is_home_1X( void )
{
  #ifdef FEATURE_EOOS
#error code not present
#endif
  return FALSE;
}


/*===========================================================================

FUNCTION sdss_set_eHRPD_zone

DESCRIPTION
  Based on the inputs, we determine if we are in eHRPD zone. Algorithm as
  followed:
  1) If we are having HDR_SRV and personality is eHRPD
  2) If we previously determined to be in eHRPD, and HDR service lost due
     to lost reason: DEACTIVATE (meaning we deactivate HDR for other protocol
     such as GWL to acquire during BSR, for example).

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void sdss_set_eHRPD_zone(

        const sd_si_info_s_type   *si_info_ptr,
            /* si_info_ptr - provide HDR service and information */

        const sd_ss_e_type        ss
            /* ss - indicates the stack which service is updated on */

)
{

  boolean                     prev_is_eHRPD_zone = sdss_ptr( SD_SS_HYBR_HDR )->is_eHRPD_zone;
  sys_srv_status_e_type       srv_status;


  if(sdss_is_sglte())
  {
    return;
  }  	

  sdss_read_srv_status(ss, &srv_status, NULL);

  /* If we are udpating service on the hybr-stack
  ** si_info_ptr is only used when ss = HYBR_HDR
  */
  if (ss == SD_SS_HYBR_HDR)
  {
    /* If we are having HDR service and its personality is eHRPD
    ** It means we are in eHRPD zone.
    */
    if (( si_info_ptr->hdr_personality == SYS_PERSONALITY_EHRPD) &&
        ( srv_status == SYS_SRV_STATUS_SRV ) )
    {
      sdss_ptr( SD_SS_HYBR_HDR )->is_eHRPD_zone = TRUE;
    }

    /* If we are losing HDR service and the sys_lost reason is
    ** due to protocol DEACTIVATE for other protocol to acquire -
    ** keep previous status - otherwise, we set it to FALSE                                                         -
    */
    else if (!( ( si_info_ptr->srv_status == SYS_SRV_STATUS_NO_SRV ||
                  si_info_ptr->srv_status == SYS_SRV_STATUS_NO_SRV_INTERNAL ||
             si_info_ptr->srv_status == SYS_SRV_STATUS_PWR_SAVE ) &&
           ( sdss_ptr(ss)->sys_lost == SD_SS_SYS_LOST_PROT_DEACTIVATE)))
    {
      sdss_ptr( SD_SS_HYBR_HDR )->is_eHRPD_zone = FALSE;
    }
  }
  /* If we are updating service on MAIN stack or HYBR-2 stacks */
  else
  {
    /* If we acquire the service on HYBR-2, meaning we actually lost HDR service
    */
    if ( ss == SD_SS_HYBR_2 && sdss_is_1x_sxlte() &&
         sdss_is_srv_status2(SD_SS_HYBR_2, SDSSSCR_SRV_STATUS_VAL_SRV_ANY) )
    {
      sdss_ptr( SD_SS_HYBR_HDR )->is_eHRPD_zone = FALSE;
    }

    /* If we acquire service on main and sys_mode is GWL, then we lost eHRPD */
    else if ( ss == SD_SS_MAIN &&
         sdss_is_srv_status2(SD_SS_MAIN, SDSSSCR_SRV_STATUS_VAL_SRV_ANY) &&
         SD_MODE_CONTAIN( sdss_map_mode_to_mode_pref(si_info_ptr->mode),
                          SD_SS_MODE_PREF_GWL ))
    {
      sdss_ptr( SD_SS_HYBR_HDR )->is_eHRPD_zone = FALSE;
    }
  }

  if (sdss_ptr( SD_SS_HYBR_HDR )->is_eHRPD_zone != prev_is_eHRPD_zone)
  {
    SD_MSG_HIGH_2("is_eHRPD_zone updated: prev=%d, current=%d",
                                                 prev_is_eHRPD_zone,
                                                 sdss_ptr( SD_SS_HYBR_HDR )->is_eHRPD_zone);
  }

  return;

}

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_get_lte_avail_1x

DESCRIPTION
   Get lte_avail_1x value both prev one and curr one

DEPENDENCIES


RETURN VALUE
  None

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void          sdss_get_lte_avail_1x(
  sdss_lte_avail_e_type *prev_lte_avail_1x,
  /* prev_lte_avail_1x - provide previous LTE AVAIL state info */
  sdss_lte_avail_e_type *curr_lte_avail_1x
  /* curr_lte_avail_1x - provide current LTE AVAIL state info */
)
{
  /* lte avail flag is only stored in the MAIN stack(corresponding to serving
  ** 1x system */
  sdss_s_type   *ss_ptr = sdss_ptr(SD_SS_MAIN);

  if(ss_ptr && prev_lte_avail_1x && curr_lte_avail_1x)
  {
    /*=============    CRITICAL SECTION ENTER    ===============*/
    sd_rex_enter_crit_sect();

    *prev_lte_avail_1x = ss_ptr->prev_lte_avail_1x;
    *curr_lte_avail_1x = ss_ptr->lte_avail_1x;

    sd_rex_leave_crit_sect();
    /*=============    CRITICAL SECTION LEAVE    ===============*/
  }

  return;

}/* sdss_get_prev_lte_avail_1x */

/*===========================================================================

FUNCTION sdss_update_lte_avail_1x

DESCRIPTION
   Update lte_avail_1x flag

DEPENDENCIES


RETURN VALUE
  NONE

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void   sdss_update_lte_avail_1x(
  sdss_lte_avail_e_type            lte_avail
    /* lte_avail - provide LTE AVAIL info */
)
{

  sdss_s_type   * ss_ptr = sdss_ptr(SD_SS_MAIN);

  if(ss_ptr)
  {
    /*=============    CRITICAL SECTION ENTER    ===============*/
    sd_rex_enter_crit_sect();

    /* Both flags need to be updated together, do process
    ** in critical section */
    ss_ptr->prev_lte_avail_1x = ss_ptr->lte_avail_1x;
    ss_ptr->lte_avail_1x = lte_avail;

    sd_rex_leave_crit_sect();
    /*=============    CRITICAL SECTION LEAVE    ===============*/


    SD_MSG_SPRINT_HIGH("lte_avail_1x updated : %s -> %s",
      sdss_lte_avail_e_type_string_map[ss_ptr->prev_lte_avail_1x],
      sdss_lte_avail_e_type_string_map[ss_ptr->lte_avail_1x],0);
  }

  return;

}/* sdss_update_lte_avail_1x */

/*===========================================================================

FUNCTION sdss_get_lte_avail_file_ptr

DESCRIPTION
  Get linked list pointer for LTEAvailFile or LTENotAvailFile

DEPENDENCIES
  None

RETURN VALUE
  sdss_lte_avail_file_s_type*  - Linked list pointer for the file

SIDE EFFECTS
  None.

===========================================================================*/
static sdss_lte_avail_file_s_type* sdss_get_lte_avail_file_ptr(
  sdss_lte_avail_e_type lte_avail_file
  /* lte_avail_file - provide enum for LTEAvailFile/LTENotAvailFile */
)
{

  sdss_lte_avail_file_s_type *lte_avail_file_ptr = NULL;

  /* Get linked list  ptr for LteAvailFile or LteNotAvailFile
  */
  if(lte_avail_file == SDSS_LTE_AVAIL_AVAIL)
  {
    lte_avail_file_ptr = &sdss_lte_avail_file;
  }
  else if(lte_avail_file == SDSS_LTE_AVAIL_NOT_AVAIL)
  {
    lte_avail_file_ptr = &sdss_lte_not_avail_file;
  }
  else
  {
    sys_err_fatal_invalid_value_exception((int)lte_avail_file);
  }

  return lte_avail_file_ptr;

}/* sdss_get_lte_avail_file_ptr */

/*===========================================================================

FUNCTION sdss_get_lte_avail_file_id

DESCRIPTION
  Get SD EFS file id for LTEAvailFile or LTENotAvailFile

DEPENDENCIES
  None

RETURN VALUE
  sdefs_id_e_type  - SDEFS file id

SIDE EFFECTS
  None.

===========================================================================*/
static sdefs_id_e_type sdss_get_lte_avail_file_id(
  sdss_lte_avail_e_type lte_avail_file
  /* lte_avail_file - provide enum for LTEAvailFile/LTENotAvailFile */
)
{
  sdefs_id_e_type sd_efs_id = SDEFS_NONE;

  /* Get SD EFS ID */
  if(lte_avail_file == SDSS_LTE_AVAIL_AVAIL)
  {
    sd_efs_id = SDEFS_LTE_AVAIL_FILE;
  }
  else if(lte_avail_file == SDSS_LTE_AVAIL_NOT_AVAIL)
  {
    sd_efs_id = SDEFS_LTE_NOT_AVAIL_FILE;
  }

  return sd_efs_id;
}

/*===========================================================================

FUNCTION sdss_get_lte_avail_file_max_record

DESCRIPTION
  Get SD EFS file id for LTEAvailFile or LTENotAvailFile

DEPENDENCIES
  None

RETURN VALUE
  uint16   - get max record for LTEAvailFile/LTENotAvailFile

SIDE EFFECTS
  None.

===========================================================================*/
static uint16 sdss_get_lte_avail_file_max_record(
  sdss_lte_avail_e_type lte_avail_file
  /* lte_avail_file - provide enum for LTEAvailFile/LTENotAvailFile */
)
{

  uint16 max_record = 0;

  /* Get SD EFS ID */
  if(lte_avail_file == SDSS_LTE_AVAIL_AVAIL)
  {
    max_record = SDSS_LTE_AVAIL_FILE_MAX_RECORD;
  }
  else if(lte_avail_file == SDSS_LTE_AVAIL_NOT_AVAIL)
  {
    max_record = SDSS_LTE_NOT_AVAIL_FILE_MAX_RECORD;
  }

  return max_record;
}

/*===========================================================================

FUNCTION sdss_lte_avail_file_is_sys_match

DESCRIPTION
  Check if the LTE Avail File system is matched or not between two system info.

DEPENDENCIES
  None

RETURN VALUE
  TRUE/FALSE

SIDE EFFECTS
  None.

===========================================================================*/
static boolean sdss_lte_avail_file_is_sys_match(
  const sdss_lte_avail_sys_s_type* sys1,
  /* sys1 - provide 1x system information */
  const sdss_lte_avail_sys_s_type* sys2
  /* sys2 - provide 1x system information */
)
{
  if(sys1 && sys2)
  {
    return (sys1->sid == sys2->sid && sys1->nid == sys2->nid && sys1->bid == sys2->bid);
  }
  else
  {
    return FALSE;
  }

} /* sdss_lte_avail_file_is_sys_match */

/*===========================================================================

FUNCTION sdss_lte_avail_file_create_node

DESCRIPTION
  Create a new node for lte avilable file and copy the sys information.

DEPENDENCIES
  None

RETURN VALUE
  sdss_lte_avail_node_s_type* new node pointer

SIDE EFFECTS
  None.

===========================================================================*/
static sdss_lte_avail_node_s_type* sdss_lte_avail_file_create_node(
  const sdss_lte_avail_item_s_type *item
  /* item - provide lte availble file item information */
)
{
  sdss_lte_avail_node_s_type *new_node = NULL;

  if(item)
  {
    new_node = (sdss_lte_avail_node_s_type*)
          modem_mem_alloc(sizeof(sdss_lte_avail_node_s_type), MODEM_MEM_CLIENT_MMODE);

    if(new_node)
    {
      /* Fill the sid/nid/bid/counter data */
      new_node->data.sys.sid = item->sys.sid;
      new_node->data.sys.nid = item->sys.nid;
      new_node->data.sys.bid = item->sys.bid;
      new_node->data.counter = item->counter;

      /* Initialize the pointer */
      new_node->next = NULL;
      new_node->prev = NULL;
    }
    else
    {
      SD_ERR_0("Can't create the node");
    }
  }
  else
  {
    SD_ERR_0("Invalid ptr");
  }
  return new_node;

}

/*===========================================================================

FUNCTION sdss_lte_avail_file_insert_node

DESCRIPTION
  Insert the node on top of the LTEAvailFile/LTENotAvailFile.

DEPENDENCIES
  None

RETURN VALUE
  NONE

SIDE EFFECTS
  None.

===========================================================================*/
static void sdss_lte_avail_file_insert_node(
  sdss_lte_avail_file_s_type* file,
    /* file - provide linked list for LTEAvailFile/LTENotAvailFile */

  const sdss_lte_avail_item_s_type *item
    /* item - provide 1x system information */
)
{
  sdss_lte_avail_node_s_type *new_node;
  sdss_lte_avail_node_s_type *head;

  if(file == NULL || item == NULL)
  {
    return;
  }

  /* Create a new node */
  new_node = sdss_lte_avail_file_create_node(item);

  if(new_node == NULL)
  {
    return;
  }

  /*=============    CRITICAL SECTION ENTER    ===============*/
  sd_rex_enter_crit_sect();

  head = file->head;
  if(head == NULL)
  {
    /* first item in the list */
    file->head = new_node;
    file->tail = new_node;
  }
  else
  {
    new_node->next = head;
    new_node->prev = NULL;
    head->prev = new_node;
    file->head = new_node;
  }

  /* Increase # of record */
  file->num++;

  sd_rex_leave_crit_sect();
  /*=============    CRITICAL SECTION LEAVE    ===============*/

  SD_MSG_HIGH_4("Inserted : sid-%d,nid-%d,bid-%d. counter-%d",
    item->sys.sid, item->sys.nid, item->sys.bid, item->counter);

}

/*===========================================================================

FUNCTION sdss_lte_avail_file_insert_node_from_tail

DESCRIPTION
  Insert the node from the back of the LTEAvailFile/LTENotAvailFile.
  Note. This function is only called during the power up time. Not using
        Critical section therefore.

DEPENDENCIES
  None

RETURN VALUE
  NONE

SIDE EFFECTS
  None.

===========================================================================*/
static void sdss_lte_avail_file_insert_node_from_tail(
  sdss_lte_avail_file_s_type* file,
    /* file - provide linked list for LTEAvailFile/LTENotAvailFile */

  const sdss_lte_avail_item_s_type *item
    /* sys - provide 1x system information */
)
{
  sdss_lte_avail_node_s_type *new_node;
  sdss_lte_avail_node_s_type *tail;

  if(file == NULL || item == NULL)
  {
    return;
  }

  SD_MSG_HIGH_4("Inserted : sid-%d,nid-%d,bid-%d.       : counter-%d",
    item->sys.sid, item->sys.nid, item->sys.bid, item->counter);
  
  new_node = sdss_lte_avail_file_create_node(item);

  if(new_node == NULL)
  {
    return;
  }

  /*=============    CRITICAL SECTION ENTER    ===============*/
  sd_rex_enter_crit_sect();

  tail = file->tail;
  if(tail == NULL)
  {
    /* last item in the list */
    file->head = new_node;
    file->tail = new_node;
  }
  else
  {
    new_node->next = NULL;
    new_node->prev = tail;
    tail->next = new_node;
    file->tail = new_node;
  }

  /* Increase # of record */
  file->num++;

  sd_rex_leave_crit_sect();
  /*=============    CRITICAL SECTION LEAVE    ===============*/
}

/*===========================================================================

FUNCTION sdss_lte_avail_file_search_node

DESCRIPTION
  Search the node from LTEAvailFile/LTENotAvailFile

DEPENDENCIES
  None

RETURN VALUE
  TRUE/FALSE

SIDE EFFECTS
  DO NOT CALL EXCEPT INSIDE OF THE CRITICAL SECTION

===========================================================================*/
static sdss_lte_avail_node_s_type* sdss_lte_avail_file_search_node(
  const sdss_lte_avail_file_s_type* file,
    /* file - provide linked list for LTEAvailFile/LTENotAvailFile */

  const sdss_lte_avail_sys_s_type *sys
    /* sys - provide 1x system information */
)
{
  sdss_lte_avail_node_s_type *current = NULL;

  if(file == NULL || sys == NULL)
  {
    SD_ERR_0("LTE Avail File Search: Invalid ptr");
    return current;
  }

  /*=============    CRITICAL SECTION ENTER    ===============*/
  sd_rex_enter_crit_sect();

  current = file->head;

  while(current != NULL)
  {
    if(sdss_lte_avail_file_is_sys_match(&current->data.sys, sys))
    {
      break;
    }
    else
    {
      current = current->next;
    }
  }

  sd_rex_leave_crit_sect();
  /*=============    CRITICAL SECTION LEAVE    ===============*/

  return current;
}

/*===========================================================================

FUNCTION sdss_lte_avail_file_delete_node

DESCRIPTION
  Found the node and delete the node from LTEAvailFile/LTENotAvailFile

DEPENDENCIES
  None

RETURN VALUE
  NONE

SIDE EFFECTS
  None.

===========================================================================*/
static void sdss_lte_avail_file_delete_node(
  sdss_lte_avail_file_s_type *file,
  /* file - provide linked list for LTEAvailFile/LTENotAvailFile */

  const sdss_lte_avail_sys_s_type *sys
  /* sys - provide system to be deleted */
)
{
  sdss_lte_avail_node_s_type *current = NULL;
  sdss_lte_avail_node_s_type *tmp = NULL;

  if(file == NULL || sys == NULL)
  {
    SD_ERR_0("invalid file_ptr");
    return;
  }

  /*=================    CRITICAL SECTION ENTER    =====================*/
  sd_rex_enter_crit_sect();

  /*
  ** Search for the system
  */
  current = sdss_lte_avail_file_search_node(file, sys);

  /*
  ** Delete the node if the system found
  */
  if(current)
  {
    sdss_lte_avail_node_s_type *head = file->head;
    sdss_lte_avail_node_s_type *tail = file->tail;
    tmp = current;


    SD_MSG_HIGH_3("Deleted : sid-%d,nid-%d,bid-%d",
      current->data.sys.sid, current->data.sys.nid, current->data.sys.bid);

    if(head == current)
    {
      /* first element to be deleted */
      file->head = head->next;

      /* Update previous link only when the next item exist
      ** if next item is NULL, that means this is one and only item
      */
      if(head->next)
      {
        file->head->prev = NULL;
      }
      else
      {
        /* this is the last item */
        file->tail = NULL;
      }

    }
    else if(tail == current)
    {
      /* last element to be deleted */
      file->tail = tmp->prev;
      file->tail->next = NULL;
    }
    else
    {
      current->prev->next = current->next;
      current->next->prev = current->prev;
    }

    /* decrease # of record */
    file->num--;
  }

  sd_rex_leave_crit_sect();
  /*=================    CRITICAL SECTION LEAVE    =====================*/

  if(tmp)
  {
    /* Deallocate memory */
    modem_mem_free((void*)tmp, MODEM_MEM_CLIENT_MMODE);
  }

}

/*===========================================================================

FUNCTION sdss_lte_avail_file_move_to_top
DESCRIPTION
  Search for the system and if found, move to the top of
  LTEAvailFile/LTENotAvailFile

DEPENDENCIES
  None

RETURN VALUE
  TRUE/FALSE

SIDE EFFECTS
  None.

===========================================================================*/
static boolean sdss_lte_avail_file_move_to_top(
  sdss_lte_avail_e_type lte_avail_file,
  /* lte_avail_file - provide enum for LTEAvailFile/LTENotAvailFile */

  const sdss_lte_avail_sys_s_type *sys
  /* node - provide node ptr to be deleted */
)
{
  sdss_lte_avail_node_s_type *current;
  sdss_lte_avail_file_s_type *file_ptr = NULL;

  /* Get the file pointer for LTE Availble/Not Available file */
  file_ptr =  sdss_get_lte_avail_file_ptr(lte_avail_file);

  if(file_ptr == NULL && sys == NULL)
  {
    SD_ERR_0("invalid file_ptr");
    return FALSE;
  }

  /*=================    CRITICAL SECTION ENTER    =====================*/
  sd_rex_enter_crit_sect();

  /*
  ** Search for the system
  */
  current = sdss_lte_avail_file_search_node(file_ptr, sys);

  /*
  ** move the node to the top if the system found
  */
  if(current)
  {
    sdss_lte_avail_node_s_type *head = file_ptr->head;
    sdss_lte_avail_node_s_type *tail = file_ptr->tail;

    /* Increase the counter */
    current->data.counter+=1;

    if(head == current)
    {
      /* Nothing to do */
    }
    else if(tail== current)
    {
      /* update the tail pointer */
      file_ptr->tail = tail->prev;
      file_ptr->tail->next = NULL;

      /* update the head pointer */
      current->next = head;
      current->prev = NULL;
      head->prev = current;
      file_ptr->head = current;
    }
    else
    {
      /* Update the previous and next pointer */
      current->prev->next = current->next;
      current->next->prev = current->prev;

      /* update the head pointer */
      current->next = head;
      current->prev = NULL;
      head->prev = current;
      file_ptr->head = current;
    }

    SD_MSG_HIGH_4("Replaced: sid-%d,nid-%d,bid-%d         counter -%d",
      current->data.sys.sid, current->data.sys.nid, current->data.sys.bid, current->data.counter);

  }

  sd_rex_leave_crit_sect();
  /*=================    CRITICAL SECTION LEAVE    =====================*/

  return (current!=NULL);
}

/*===========================================================================

FUNCTION sdss_lte_avail_file_delete_tail

DESCRIPTION
  Delete the node from tail

DEPENDENCIES
  None

RETURN VALUE
  NONE

SIDE EFFECTS
  None.

===========================================================================*/
static void sdss_lte_avail_file_delete_tail(
  sdss_lte_avail_file_s_type *file
  /* file - provide linked list for LTEAvailFile/LTENotAvailFile */
)
{

  if(file)
  {
    sdss_lte_avail_node_s_type *tail = NULL;

    /*=================    CRITICAL SECTION ENTER    =====================*/
    sd_rex_enter_crit_sect();

    tail = file->tail;

    if(tail)
    {
      SD_MSG_HIGH_3("Deleted : sid-%d,nid-%d,bid-%d",
        tail->data.sys.sid, tail->data.sys.nid, tail->data.sys.bid);

      /* Delete the last item */
      file->tail = tail->prev;
      if(file->tail)
      {
        file->tail->next = NULL;
      }
      else
      {
        /* This is one and only item, update head as well */
        file->head = NULL;
      }

      /* decrease # of record */
      file->num--;
    }

    sd_rex_leave_crit_sect();
    /*=================    CRITICAL SECTION LEAVE    =====================*/

    if(tail)
    {
      /* Deallocate memory */
      modem_mem_free((void*)tail, MODEM_MEM_CLIENT_MMODE);
    }
  }

}


/*===========================================================================

FUNCTION sdss_lte_avail_file_delete_sys

DESCRIPTION
  Delete the 1x sys(sid/nid/bid) from LTEAvailFile/LTENotAvailFile

DEPENDENCIES
  None

RETURN VALUE
  NONE

SIDE EFFECTS
  None.

===========================================================================*/
static void sdss_lte_avail_file_delete_sys(
  sdss_lte_avail_e_type lte_avail_file,
  /* lte_avail_file - provide enum for LTEAvailFile/LTENotAvailFile */

  const sdss_lte_avail_sys_s_type *sys
  /* sys - provide 1x system information */
)
{
  sdss_lte_avail_file_s_type *file_ptr = NULL;

  /* Get the file pointer for LTE Availble/Not Available file */
  file_ptr =  sdss_get_lte_avail_file_ptr(lte_avail_file);

  if(file_ptr && sys)
  {
     SD_MSG_SPRINT_HIGH("Delete system from %s",
        sdss_lte_avail_e_type_string_map[lte_avail_file],0,0);

    /* Search the node with the matched system info */
    sdss_lte_avail_file_delete_node(file_ptr, sys);
  }

}

/*===========================================================================

FUNCTION sdss_lte_avail_file_add_sys

DESCRIPTION
  Add the 1x sys(sid,nid,bid) to LTEAvailFile/LTENotAvailFile

DEPENDENCIES
  None

RETURN VALUE
  NONE

SIDE EFFECTS
  None.

===========================================================================*/
static void sdss_lte_avail_file_add_sys(
  sdss_lte_avail_e_type lte_avail_file,
  /* lte_avail_file - provide enum for LTEAvailFile/LTENotAvailFile */

  const sdss_lte_avail_sys_s_type *sys
  /* sys - provide 1x system information */
)
{

  if(sys == NULL)
  {
    SD_ERR_0("Invalid sys");
    return;
  }

  /* Duplicate check before add to the top of the list
  ** If its found, move to the top.
  ** If its not found, add to the top
  */
  if(!sdss_lte_avail_file_move_to_top(lte_avail_file, sys))
  {
    sdss_lte_avail_file_s_type *file_ptr = NULL;
    sdss_lte_avail_item_s_type  item;

    /* Get the file pointer for LTE Availble/Not Available file */
    file_ptr =  sdss_get_lte_avail_file_ptr(lte_avail_file);

    SD_MSG_SPRINT_HIGH("Add system to %s",
      sdss_lte_avail_e_type_string_map[lte_avail_file],0,0);

    if(file_ptr)
    {
      /* Initialize the data */
      item.sys.sid = sys->sid;
      item.sys.nid = sys->nid;
      item.sys.bid = sys->bid;
      item.counter = 1;

      /*=============    CRITICAL SECTION ENTER    ===============*/
      sd_rex_enter_crit_sect();

      /* Add the item to the top of the linked list */
      if(file_ptr->num >= sdss_get_lte_avail_file_max_record(lte_avail_file))
      {
        /* linked list items reached the max
        ** delete the last item before add the new item
        */
        sdss_lte_avail_file_delete_tail(file_ptr);
      }
      sdss_lte_avail_file_insert_node(file_ptr, &item);

      sd_rex_leave_crit_sect();
      /*=============    CRITICAL SECTION LEAVE    ===============*/
    }
    else
    {
      SD_ERR_1("Not supported: %d", lte_avail_file);
    }
  }
}


/*===========================================================================

FUNCTION sdss_lte_avail_file_write

DESCRIPTION
  Write LTEAvailFile/LTENotAvailFile to SDEFS from local cache.

DEPENDENCIES
  None

RETURN VALUE
  NONE

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_lte_avail_file_write(
  sdss_lte_avail_e_type lte_avail_file
  /* lte_avail_file - provide enum for LTEAvailFile/LTENotAvailFile */
)
{
  byte    *file_buf;
  byte    *efs_file_buf = NULL;
  uint16   i=0;
  sdss_lte_avail_file_s_type *lte_avail_file_ptr;
  sdss_lte_avail_node_s_type *current;
  sdefs_id_e_type            sd_efs_id;
  uint16   actual_size = 0;


  /* Get SD EFS ID */
  sd_efs_id = sdss_get_lte_avail_file_id(lte_avail_file);

  /* Get file pointer */
  lte_avail_file_ptr = sdss_get_lte_avail_file_ptr(lte_avail_file);

  if(sd_efs_id != SDEFS_NONE && lte_avail_file_ptr)
  {
    /* Allocate buffer to write LTE Avail File to EFS */
    actual_size = lte_avail_file_ptr->num*SDSS_LTE_AVAIL_FILE_RECORD_SIZE + SDSS_LTE_AVAIL_FILE_RECORD_NUM_SIZE;
    file_buf = modem_mem_alloc(actual_size, MODEM_MEM_CLIENT_MMODE);

    if(file_buf)
    {
      current = lte_avail_file_ptr->head;
      memset(file_buf, 0, actual_size);

      /*=============    CRITICAL SECTION ENTER    ===============*/
      sd_rex_enter_crit_sect();

      /* Copy # of record */
      memscpy( file_buf, actual_size, &lte_avail_file_ptr->num, SDSS_LTE_AVAIL_FILE_RECORD_NUM_SIZE );

      /* Copy each record from the linked list to the file_buf */
      while(current && i<lte_avail_file_ptr->num)
      {
        memscpy( file_buf + SDSS_LTE_AVAIL_FILE_RECORD_NUM_SIZE + ( i * SDSS_LTE_AVAIL_FILE_RECORD_SIZE ),
                 ( actual_size - SDSS_LTE_AVAIL_FILE_RECORD_NUM_SIZE - ( i * SDSS_LTE_AVAIL_FILE_RECORD_SIZE ) ),
                 current,
                 SDSS_LTE_AVAIL_FILE_RECORD_SIZE );
        current = current->next;

        i++;
      }

      sd_rex_leave_crit_sect();
      /*=============    CRITICAL SECTION LEAVE    ===============*/

      /* read back LTE avail from EFS and compare with file_buf. if there is change write
      ** it back otherwise no need to write
      */
      {

        uint16   num_of_rec;
        int32   size_file_read;
        uint16* p_num_rec = (uint16*)file_buf;
        /* Read # of records from EFS */
        size_file_read = SDSS_LTE_AVAIL_FILE_RECORD_NUM_SIZE;
        if(sdefs_read(sd_efs_id,(byte*)&num_of_rec, &size_file_read))
        {
          if(num_of_rec == *p_num_rec)
          {
            /* read remaining data from EFS */
            size_file_read = SDSS_LTE_AVAIL_FILE_RECORD_SIZE*num_of_rec + SDSS_LTE_AVAIL_FILE_RECORD_NUM_SIZE;
            efs_file_buf = (byte *)modem_mem_alloc(size_file_read, MODEM_MEM_CLIENT_MMODE);
            if(efs_file_buf == NULL)
            {
              sys_err_fatal_null_ptr_exception();
            }

            if(sdefs_read(sd_efs_id, (byte*)efs_file_buf, &size_file_read))
            {
              if(memcmp(efs_file_buf, file_buf, size_file_read) == 0)
              {
                /* don't write since buf not change */
                modem_mem_free((void*)file_buf,MODEM_MEM_CLIENT_MMODE);
                modem_mem_free((void*)efs_file_buf,MODEM_MEM_CLIENT_MMODE);
                SD_MSG_HIGH_0("Don't write EFS since no change");
                return;
              }
            }

          }

        }
      }
    SD_MSG_SPRINT_HIGH("Write %s - record # : %d",
          sdss_lte_avail_e_type_string_map[lte_avail_file],
          lte_avail_file_ptr->num,0);
      /* Write to SD EFS File */
      (void)sdefs_write(sd_efs_id, (byte *)file_buf, (int32)actual_size);
      modem_mem_free((void*)file_buf,MODEM_MEM_CLIENT_MMODE);
      if(efs_file_buf != NULL)
      {
        modem_mem_free((void*)efs_file_buf,MODEM_MEM_CLIENT_MMODE);
      }

    }
    else
    {
      SD_ERR_0("Fail to alloc memory for LTEFile write");
    }
  }
  else
  {
    SD_ERR_1("Not Supported LTE Avail File :%d", lte_avail_file);
  }

  return;

}/* sdss_lte_avail_file_write */

/*===========================================================================

FUNCTION sdss_lte_avail_file_read

DESCRIPTION
  Read the LTE avail file from the EFS, and store it into local cache.

DEPENDENCIES
  None

RETURN VALUE
  NONE

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_lte_avail_file_read(
  sdss_lte_avail_e_type lte_avail_file
  /* lte_avail_file - provide enum for LTEAvailFile/LTENotAvailFile */
)
{
   byte    *efs_file_buf;
  uint16   num_of_rec;
  int32   size_file_read;
  sdefs_id_e_type            sd_efs_id;
  sdss_lte_avail_file_s_type *lte_avail_file_ptr = NULL;
  int32   size_num_rec_read = SDSS_LTE_AVAIL_FILE_RECORD_NUM_SIZE;

  /* Get SD EFS ID */
  sd_efs_id = sdss_get_lte_avail_file_id(lte_avail_file);
  if(sd_efs_id == SDEFS_NONE)
  {
    SD_ERR_0("LTE avail file efs id not found");
    return;
  }

  /* Get the file pointer for LTE Availble/Not Available file */
  lte_avail_file_ptr = sdss_get_lte_avail_file_ptr(lte_avail_file);
  if(!lte_avail_file_ptr)
  {
    SD_ERR_0("LTE avail file ptr invalid");
    return;
  }

  /* Initilize the num of record */
  lte_avail_file_ptr->num = 0;

  /* Read # of records from EFS */
  if(sdefs_read(sd_efs_id,(byte*)&num_of_rec, &size_num_rec_read))
  {
     if(!INRANGE(num_of_rec,SDSS_LTE_AVAIL_FILE_MIN_RECORD,
              sdss_get_lte_avail_file_max_record(lte_avail_file)))
     {
       SD_MSG_HIGH_1("LTE Avail File: # of rec out of range:%d",num_of_rec);
       return;
     }
  }
  else
  {
    SD_MSG_HIGH_0("Fail to read LTEFile header");
    return;
  }

  SD_MSG_SPRINT_HIGH("Read %s - record # : %d",
      sdss_lte_avail_e_type_string_map[lte_avail_file],num_of_rec,0);

  /* Allocate buf for reading LTE avail file: number_of_rec* each_record_size_in_efs + header length (2 bytes)*/
  size_file_read = SDSS_LTE_AVAIL_FILE_RECORD_SIZE*num_of_rec + 2;
  efs_file_buf = (byte *)modem_mem_alloc(size_file_read, MODEM_MEM_CLIENT_MMODE);
  if(efs_file_buf == NULL)
  {
    sys_err_fatal_null_ptr_exception();
  }

  /* Read all data from EFS */
  if(sdefs_read(sd_efs_id, (byte*)efs_file_buf, &size_file_read))
  {
    /* Create the each node and build the linked list for LTE availble file */
    {
      uint16 i = 0;
      sdss_lte_avail_item_s_type info;

      /* Create record and add it from tail, so the most recent
      ** item can go to front of the linked list
      */
      /*=============    CRITICAL SECTION ENTER    ===============*/
      sd_rex_enter_crit_sect();

      for(i=0; i< num_of_rec; i++)
      {
        /* Copy system information from the file read */
        memscpy( &info,
                 sizeof(info),
                 efs_file_buf+SDSS_LTE_AVAIL_FILE_RECORD_NUM_SIZE+(i*SDSS_LTE_AVAIL_FILE_RECORD_SIZE),
                 SDSS_LTE_AVAIL_FILE_RECORD_SIZE);

        sdss_lte_avail_file_insert_node_from_tail(lte_avail_file_ptr, &info);
      }

      sd_rex_leave_crit_sect();
      /*=============    CRITICAL SECTION LEAVE    ===============*/

    }
  }

  /* Free the memory */
  modem_mem_free((void*)efs_file_buf,MODEM_MEM_CLIENT_MMODE);

  return;

}

/*===========================================================================

FUNCTION sdss_lte_avail_file_init

DESCRIPTION
  Initialize LteAvailFile/LteNotAvailFile.
  Read from file and update the local linked list, ready for run-time operation.

DEPENDENCIES
  None

RETURN VALUE
  NONE

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_lte_avail_file_init(void)
{
  /* Initilize static local variables */
  sdss_lte_avail_file.head = NULL;
  sdss_lte_avail_file.tail = NULL;
  sdss_lte_avail_file.num = SDSS_LTE_AVAIL_FILE_INVALID_RECORD;

  sdss_lte_not_avail_file.head = NULL;
  sdss_lte_not_avail_file.tail = NULL;
  sdss_lte_not_avail_file.num = SDSS_LTE_AVAIL_FILE_INVALID_RECORD;
}

/*===========================================================================

FUNCTION sdss_lte_avail_file_search_sys

DESCRIPTION
  Search 1x sys(sid/nid/bid) is in LTEAvailFile/LTENotAvailFile

DEPENDENCIES
  None

RETURN VALUE
  TRUE/FALSE

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN boolean sdss_lte_avail_file_search_sys(
  sdss_lte_avail_e_type lte_avail_file,
  /* lte_avail_file - provide enum for LTEAvailFile/LTENotAvailFile */

  const sdss_lte_avail_sys_s_type *sys
  /* sys - provide 1x system information */
)
{
  sdss_lte_avail_file_s_type *file_ptr = NULL;
  boolean is_found = FALSE;

  /* Get the file pointer for LTE Availble/Not Available file */
  file_ptr =  sdss_get_lte_avail_file_ptr(lte_avail_file);

  if(file_ptr)
  {
    if(sdss_lte_avail_file_search_node(file_ptr, sys))
    {
      is_found = TRUE;
    }
  }

  return is_found;

}

/*===========================================================================

FUNCTION sdss_lte_avail_file_search_sys_get_counter

DESCRIPTION
  Search 1x sys(sid/nid/bid) is in LTEAvailFile/LTENotAvailFile
  If the system found, copy the counter in the argument pointer

DEPENDENCIES
  None

RETURN VALUE
  TRUE/FALSE

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN boolean sdss_lte_avail_file_search_sys_get_counter(
  sdss_lte_avail_e_type lte_avail_file,
  /* lte_avail_file - provide enum for LTEAvailFile/LTENotAvailFile */

  const sdss_lte_avail_sys_s_type *sys,
  /* sys - provide 1x system information */

  uint8 *counter
  /* counter - return counter if system found */
)
{
  boolean                     is_found = FALSE;

  /* Only the pointer of sys and counter is valid, proceed */
  if(sys && counter)
  {
    sdss_lte_avail_file_s_type *file_ptr = NULL;
    sdss_lte_avail_node_s_type  *node = NULL;

    /* Get the file pointer for LTE Availble/Not Available file */
    file_ptr =  sdss_get_lte_avail_file_ptr(lte_avail_file);

    if(file_ptr)
    {
      /*=============    CRITICAL SECTION ENTER    ===============*/
      sd_rex_enter_crit_sect();

      /* search for system */
      node = sdss_lte_avail_file_search_node(file_ptr, sys);

      if(node)
      {
        /* if it's found, update the counter */
        *counter = node->data.counter;
        is_found = TRUE;
      }

      sd_rex_leave_crit_sect();
      /*=============    CRITICAL SECTION LEAVE    ===============*/
    }
  }
  else
  {
    SD_ERR_0("Invalid sys, counter");
  }

  return is_found;

}

/*===========================================================================

FUNCTION sdss_lte_avail_file_update

DESCRIPTION
  This is main function to do process regarding LTE Avail File.
  This will be called in SD upon below indication delivered.
  - CDMA OH msg
  - GWL ACQ_PLMN Success
  - GWL ACQ_PLMN Fail

DEPENDENCIES
  None

RETURN VALUE
  NONE

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_lte_avail_file_update(
  sdss_evt_e_type           event
  /* event - event triggers LTE Avail/NotAvail file update */,
  const sdss_lte_avail_sys_s_type          *info,
  /* info - CDMA system info pointer */
  sd_ss_e_type                              ss
)
{
  uint8                       fail_counter = 0;
  uint32                      max_fail_counter = \
    sdssscr_efs_item_get(SDSSSCR_EFS_ITEM_LTE_NOT_AVAIL_ACQ_FAIL_MAX_COUNT,
                         sdss_map_ss_to_as_id(ss));

  if(info == NULL)
  {
    SD_ERR_0("info is not valid info");
    return;
  }

  
  SD_MSG_LOW_4("lte_avail_file_update: event=%d info.sid=%d, info.nid=%d, info.bid=%d",event, info->sid, info->nid, info->bid);

  switch(event)
  {
    case SDSS_EVT_CDMA_OPR_OH_SID:
    {
      /* If we acquire CDMA, and LTE is available,
      ** write CDMA system(sid/nid/bid) information to LTEAvailFile.
      ** Also update the lte_avail_1x flag based on the information we have
      ** already.
      */

      /* Check if LTE is avilable */
      if(sdss_is_srv_status2(SD_SS_HYBR_2, SDSSSCR_SRV_STATUS_VAL_SRV) ||
        sdss_get_orig_mode(SD_SS_MAIN) == SD_SS_ORIG_MODE_1XCSFB_NORMAL_ORIG ||
         sdss_get_orig_mode(SD_SS_MAIN) == SD_SS_ORIG_MODE_1XCSFB_EMERG_ORIG)
      {
        /* Add system to LTE AVAIL file */
        sdss_lte_avail_file_add_sys(SDSS_LTE_AVAIL_AVAIL, info);

        /* remove sid/nid/bid from LTENotAvailFile */
        sdss_lte_avail_file_delete_sys(SDSS_LTE_AVAIL_NOT_AVAIL, info);
      }

      /* After checking system info in LteAvailFile/LteNotAvailFile
      ** Update lte_avail_1x flag
      */
      if(sdss_lte_avail_file_search_sys(SDSS_LTE_AVAIL_AVAIL, info))
      {
        sdss_update_lte_avail_1x(SDSS_LTE_AVAIL_AVAIL);
        sdss_lte_avail_file_delete_sys(SDSS_LTE_AVAIL_NOT_AVAIL, info);
      }
      else if(sdss_lte_avail_file_search_sys_get_counter(SDSS_LTE_AVAIL_NOT_AVAIL, info, &fail_counter))
      {
        if((fail_counter >= max_fail_counter) && (info->bid != SDSS_BID_VAL_NONE))
        {
          sdss_update_lte_avail_1x(SDSS_LTE_AVAIL_NOT_AVAIL);
        }
        else
        {
          sdss_update_lte_avail_1x(SDSS_LTE_AVAIL_NONE);
        }

        SD_MSG_HIGH_2("fail_cnt:%d, max_cnt :%d",
            fail_counter, max_fail_counter);
      }
      else
      {
        /* If this 1x system is not in either files, reset the flag to NONE */
        sdss_update_lte_avail_1x(SDSS_LTE_AVAIL_NONE);
      }
      break;
    }

    case SDSS_EVT_GWL_ACQ_PLMN_SUCCESS:
    {
      /* While BSR is in progress, if the LTE acquisition is succesful,
      ** and we still have CDMA service available,
      ** Write CDMA system(sid/nid/bid) information to LTEAvailFile.
      ** UE will run more-agressive LTE BSR scan if the system is found on
      ** LTEAvailFile. BSR flag should be checked to prevent corner case that
      ** 1x system is added accdently such as 1x got sync chan msg and
      ** LTE OOS can result in ACQ_PLMN_SUCCESS.
      **
      */
      if(sdss_is_flag_set(SD_SS_HYBR_2,SDSS_FLAG_HYBR2_BSR) ||
      sd_misc_get_ss_for_mode(SYS_SYS_MODE_LTE) == SD_SS_MAIN)
      {
        /* store sid/nid/bid to LTEAvailFile */
        sdss_lte_avail_file_add_sys(SDSS_LTE_AVAIL_AVAIL, info);

        /* remove sid/nid/bid from LTENotAvailFile */
        sdss_lte_avail_file_delete_sys(SDSS_LTE_AVAIL_NOT_AVAIL, info);

        /* Set LteAvailFlag to AVAIL */
        sdss_update_lte_avail_1x(SDSS_LTE_AVAIL_AVAIL);

      }
      break;
    }

    case SDSS_EVT_GWL_ACQ_PLMN_FAILED:
    {
      /* While BSR is in progress, if the LTE acquisition failed,
      ** and CDMA is still available.
      ** Write CDMA system(sid/nid/bid) information to LTENotAvailFile.
      ** UE will run less-agressive LTE BSR scan if the system is found on
      ** LTENotAvailFile.
      */
      /* Only when the system is NOT in LTEAvailFile, store it to
      ** LTENotAvailFile. System information cannot be co-exist
      ** in both LTEAvailFile and LTENotAvailFile.
      */
      if(!sdss_lte_avail_file_search_sys(SDSS_LTE_AVAIL_AVAIL, info))
      {
        sdss_lte_avail_file_add_sys(SDSS_LTE_AVAIL_NOT_AVAIL, info);

        if(sdss_lte_avail_file_search_sys_get_counter(SDSS_LTE_AVAIL_NOT_AVAIL,
           info, &fail_counter) &&
           info->bid != SDSS_BID_VAL_NONE)
        {
          if(fail_counter >= max_fail_counter)
          {
            /* Only update the lte_avail_1x flag only the counter reaches
            ** max fail counter */
            sdss_update_lte_avail_1x(SDSS_LTE_AVAIL_NOT_AVAIL);
            SD_MSG_HIGH_2("\t\tfail_cnt:%d, max_cnt :%d",
             fail_counter, max_fail_counter);
          }
          else
          {
            SD_MSG_HIGH_2("Don't update lte_avail_1x, fail_cnt:%d, max_cnt :%d",
             fail_counter, max_fail_counter);
          }
        }
      }
      else
      {
        SD_MSG_HIGH_3("Already In LTEAvailFile: sid-%d, nid-%d, bid -%d",
          info->sid, info->nid, info->bid);
      }
      break;
    }
    default:
      SD_ERR_1("event - %d not supported", event);
      break;
  }
}

/*===========================================================================

FUNCTION sdss_lte_avail_file_readall

DESCRIPTION
  Read from file and update the local linked list, ready for run-time operation.
  This is called upon sd_nam_sel()

DEPENDENCIES
  None

RETURN VALUE
  NONE

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_lte_avail_file_readall(void)
{
  /* This is being called in sd_nam_sel(), read file only once
  ** once the file is read, num should be changed to valid value
  */
  if(sdss_lte_avail_file.num == SDSS_LTE_AVAIL_FILE_INVALID_RECORD)
  {
    sdss_lte_avail_file_read(SDSS_LTE_AVAIL_AVAIL);
  }

  if(sdss_lte_not_avail_file.num == SDSS_LTE_AVAIL_FILE_INVALID_RECORD)
  {
    sdss_lte_avail_file_read(SDSS_LTE_AVAIL_NOT_AVAIL);
  }
}
/*===========================================================================

FUNCTION sdss_lte_avail_delete_invalid_entry

DESCRIPTION
  delete invalid entry (bid=0) before saving to efs.

DEPENDENCIES
  None

RETURN VALUE
  NONE

SIDE EFFECTS
  None.

===========================================================================*/
static void sdss_lte_avail_delete_invalid_entry(sdss_lte_avail_e_type lte_avail_file)
{
  sdss_lte_avail_file_s_type *file_ptr = NULL;
  sdss_lte_avail_node_s_type *current = NULL;
  sdss_lte_avail_sys_s_type sys_to_del;

  /* Get the file pointer for LTE Availble/Not Available file */
  file_ptr =  sdss_get_lte_avail_file_ptr(lte_avail_file);
  if(file_ptr == NULL)
  {
    SD_ERR_0("invalid lte avail file ptr");
    return;
  }

  current = file_ptr->head;

  while(current != NULL)
  {
    if(current->data.sys.bid == 0)
    {
      sys_to_del.sid = current->data.sys.sid;
      sys_to_del.nid = current->data.sys.nid;
      sys_to_del.bid = current->data.sys.bid;

      current = current->next;

      sdss_lte_avail_file_delete_node(file_ptr,&sys_to_del);
    }
    else
    {
      current = current->next;
    }
  }

  return;

}

/*===========================================================================

FUNCTION sdss_lte_avail_file_save

DESCRIPTION
  Save LTE Available file. This will be called when powering off the phone or
  going LPM.

DEPENDENCIES
  None

RETURN VALUE
  NONE

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_lte_avail_file_save(void)
{
  /* Write LTEAvailFile and free all nodes */
  sdss_lte_avail_file_write(SDSS_LTE_AVAIL_AVAIL);

  /* Write LTENotAvailFile and free all nodes */
  sdss_lte_avail_delete_invalid_entry(SDSS_LTE_AVAIL_NOT_AVAIL);
  sdss_lte_avail_file_write(SDSS_LTE_AVAIL_NOT_AVAIL);

}

/*===========================================================================

FUNCTION sdss_lte_avail_file_bid_update

DESCRIPTION
  This function is called to update 1x sys bid which was added during immediate BSR without valid bid(sid/nid/0).
  If the LTE not avail file already have the same sys,  delete the sid/nid/0 record. otherwise update sid/nid/0 to
  sid/nid/bid

DEPENDENCIES
  None

RETURN VALUE
  NONE

SIDE EFFECTS
  None.

===========================================================================*/

EXTERN void sdss_lte_avail_file_bid_update
(
   const sdss_lte_avail_sys_s_type          *info
  /* info - CDMA system info pointer */
)
{
  sdss_lte_avail_sys_s_type   tmp_sys;
  sdss_lte_avail_node_s_type *node_ptr = NULL;
  sdss_lte_avail_node_s_type *info_node_ptr = NULL;
  sdss_lte_avail_file_s_type *file_ptr = NULL;

  tmp_sys.sid = info->sid;
  tmp_sys.nid = info->nid;
  tmp_sys.bid = SDSS_BID_VAL_NONE;

  file_ptr = sdss_get_lte_avail_file_ptr(SDSS_LTE_AVAIL_NOT_AVAIL);
  if(file_ptr == NULL)
  {
    return;
  }

  node_ptr = sdss_lte_avail_file_search_node(file_ptr, &tmp_sys);

  if(node_ptr != NULL)
  {
    info_node_ptr = sdss_lte_avail_file_search_node(file_ptr, info);
    if(info_node_ptr != NULL)
    {
      info_node_ptr->data.counter ++;
      SD_MSG_HIGH_4("bid_update, count = %d sid %d nid %d bid %d",
	  	info_node_ptr->data.counter,info->sid, info->nid, info->bid);
      sdss_lte_avail_file_delete_sys(SDSS_LTE_AVAIL_NOT_AVAIL, &tmp_sys);
    }
    else
    {
      node_ptr->data.sys.bid = info->bid;
      SD_MSG_HIGH_3("bid_update NOT_AVAIL: sid %d, nid %d, bid %d",info->sid, info->nid, info->bid);
    }
  }

  return;

}

/*===========================================================================

FUNCTION sdss_set_bid_change

DESCRIPTION
  set bid_change flag

DEPENDENCIES
  This function must be called before any other sdss_xxx is called.

RETURN VALUE

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_set_bid_change(boolean is_change)
{
  sdss_ptr(SD_SS_MAIN)->is_bid_change = is_change;
  SD_MSG_LOW_1("set_bid_chg %d", is_change);
}
/*===========================================================================

FUNCTION sdss_set_lte_pref_change

DESCRIPTION
  set is_pref_lte_change flag

DEPENDENCIES
  This function must be called before any other sdss_xxx is called.

RETURN VALUE

SIDE EFFECTS
  None.

===========================================================================*/

EXTERN void sdss_set_lte_pref_change(boolean is_change)
{
  sdss_ptr(SD_SS_MAIN)->is_pref_lte_change= is_change;
  SD_MSG_LOW_1("set_lte_pref_chg %d", is_change);
}

/*===========================================================================

FUNCTION sdss_get_lte_pref_change

DESCRIPTION
  get is_pref_lte_change flag

DEPENDENCIES
  This function must be called before any other sdss_xxx is called.

RETURN VALUE

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN boolean sdss_get_lte_pref_change(void)
{
  return sdss_ptr(SD_SS_MAIN)->is_pref_lte_change;
}


/*===========================================================================

FUNCTION sdss_print_rat_acq_order

DESCRIPTION
  This routine print out rat_acq_order

DEPENDENCIES
  This function must be called before any other sdss_xxx is called.

RETURN VALUE

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_print_rat_acq_order(
  const sd_rat_acq_order_s_type *rat_acq_order_ptr
)
{

  if(rat_acq_order_ptr != NULL)
  {

    /* reorder only 3gpp rat acquisition order */
     SD_MSG_HIGH_6("rat_acq_order[0]: %d [1]: %d [2]: %d [3]: %d [4]: %d [5]: %d ",
                    rat_acq_order_ptr->acq_sys_mode[0],
                    rat_acq_order_ptr->acq_sys_mode[1],
                    rat_acq_order_ptr->acq_sys_mode[2],
                    rat_acq_order_ptr->acq_sys_mode[3],
                    rat_acq_order_ptr->acq_sys_mode[4],
                    rat_acq_order_ptr->acq_sys_mode[5]);
  }

}


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_is_lte_supp_for_csfb_call

DESCRIPTION
  Check whether LTE is supported if there's a CFSB call in origination/present

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if orig mode is CSFB.
  FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean                       sdss_is_lte_supp_for_csfb_call(

                                      sd_ss_e_type      ss )
{

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  #if defined (FEATURE_3GPP_CSFB) || defined (FEATURE_LTE_TO_1X)

  boolean is_lte_supported = TRUE;
  sd_ss_mode_pref_e_type         ss_mode_pref = SD_SS_MODE_PREF_NONE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  sdss_get_mode_band_pref( ss,
                           &ss_mode_pref,
                           NULL,
                           NULL,
                           NULL );
  if (sdss_is_orig_mode(ss, SD_SS_ORIG_MODE_VAL_CSFB_ORIG ))
  {
    if (sdss_is_orig_mode(ss, SD_SS_ORIG_MODE_VAL_PPCSFB_ORIG ))
    {
      is_lte_supported = FALSE;
    }
    else if(sdss_is_orig_mode(ss, SD_SS_ORIG_MODE_VAL_1XCSFB_ORIG ))
    {
      if(!(SD_IS_BIT_CONTAIN (ss_mode_pref ,SD_SS_MODE_PREF_LTE)))
      {
        is_lte_supported = FALSE;
      }
    }
  }
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return is_lte_supported;

  #else

  return TRUE;

  #endif

} /* sdss_is_csfb_call_orig */

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_is_gw_supp_for_1xcsfb_call

DESCRIPTION
  Check whether GW is supported if there's a 1xCFSB call is in origination/present

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if orig mode is CSFB.
  FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean                       sdss_is_gw_supp_for_1xcsfb_call(

        sd_ss_e_type                  ss,
        /* stack on which ACQ is occuring */

        sdss_evt_e_type               event,
       /* Current event */


       sys_sys_mode_e_type            mode
       /*current mode */
)
{

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  boolean                  is_gw_supported = TRUE;
  sd_ss_mode_pref_e_type   user_global_mode_pref = sdss_ptr(ss)->user_global_mode_pref;
  sd_ss_mode_pref_e_type   mode_pref_to_add = sdss_map_mode_to_mode_pref(mode);
  /*- - - - - - - - - - - - - - -       - - - - - - - - - - - - - - - - - -*/


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if((sdss_is_orig_mode(ss, SD_SS_ORIG_MODE_VAL_1XCSFB_EMERG_ORIG)) &&
     ((mode == SYS_SYS_MODE_GSM) || (mode == SYS_SYS_MODE_WCDMA) || (mode == SYS_SYS_MODE_TDS)) &&
     ((event == SDSS_EVT_CDMA_OPR_ACC_TERM) ||(event == SDSS_EVT_CDMA_OPR_RELEASE)))
  {
    if (!SD_IS_BIT_CONTAIN (user_global_mode_pref ,mode_pref_to_add))
    {
      is_gw_supported = FALSE;
    }
  }
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  return is_gw_supported;
} /* sdss_is_csfb_call_orig */

/* <EJECT> */
/*===========================================================================

FUNCTION sdss_is_1xcsfb_call_end

DESCRIPTION
  Check whether GW is supported if there's a 1xCFSB call is in origination/present

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if orig mode is CSFB.
  FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean                       sdss_is_1xcsfb_call_end(

        sd_ss_e_type                  ss,
        /* stack on which ACQ is occuring */

        sdss_evt_e_type               event
       /* Current event */

)
{

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  boolean                  is_1xcsfb_call_end = FALSE;


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if((!sdss_is_lte_connected_mode(ss)) && 
      (((sdss_is_orig_mode(ss, SD_SS_ORIG_MODE_VAL_1XCSFB_ORIG )) &&
      ((event == SDSS_EVT_CDMA_OPR_ACC_TERM) ||(event == SDSS_EVT_CDMA_OPR_RELEASE))) ||
      (sdss_get_pref_update_reason(ss) == SDSS_PREF_UPDATED_1XCSFB_ORIG_END)))

  {
    SD_MSG_LOW_3("sdss_is_1xcsfb_call_end ss = %d event = %d orig_mode = %d", ss, event, (sdss_get_orig_mode(ss)));
    is_1xcsfb_call_end = TRUE;
  }
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  return is_1xcsfb_call_end;
} /* sdss_is_csfb_call_orig */

/*===========================================================================

FUNCTION sdss_set_srv_lost_state

DESCRIPTION
  Set is_in_srv_lost_state to true only if the true event is service lost evt.  Note the flag is
  set to true only if UE was in service and service is lost now.  The flag will not be set for
  pwr up scenario since no service is actually acquired yet.

DEPENDENCIES
  None.

RETURN VALUE
 None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_set_srv_lost_state(
       sd_ss_e_type ss
)
{
  sdss_s_type      *ss_ptr   = sdss_ptr(ss);
  SD_ASSERT(ss_ptr != NULL);

  /* Check if the true event is one of the service lost events
   */
  switch (ss_ptr->true_event)
  {
    case SDSS_EVT_GWL_OPR_SYS_LOST:
    case SDSS_EVT_HYBR_2_GW_OPR_SYS_LOST:
    case SDSS_EVT_HYBR_3_GW_OPR_SYS_LOST:
    case SDSS_EVT_CDMA_OPR_SYS_LOST:
    case SDSS_EVT_HDR_OPR_SYS_LOST:
    case SDSS_EVT_AMPS_OPR_SYS_LOST:
      ss_ptr->is_in_srv_lost_state = TRUE;
      break;

    default:
      break;
  }

}

/*===========================================================================

FUNCTION sdss_reset_srv_lost_state

DESCRIPTION
  Reset is_in_srv_lost_state value to false.

DEPENDENCIES
  None.

RETURN VALUE
 True : if the true event is service lost event.
 False: Otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_reset_srv_lost_state(
       sd_ss_e_type ss
)
{
  sdss_s_type      *ss_ptr   = sdss_ptr(ss);
  SD_ASSERT(ss_ptr != NULL);

  /* Check if the true event is one of the service lost events
   */
  ss_ptr->is_in_srv_lost_state = FALSE;

  }

/*===========================================================================

FUNCTION sdss_print_capability_info

DESCRIPTION
  Prints the mode/band capability from sdss common

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_print_capability_info()
{
  SD_MSG_HIGH_5("RF_CAP: mode cap = 0x%x,gw band cap = 0x%x 0x%x tds band cap = 0x%x 0x%x",
               sdss_common.mode_capability,
               QWORD_HIGH(sdss_common.band_capability),
               QWORD_LOW(sdss_common.band_capability),
               QWORD_HIGH(sdss_common.tds_band_capability),
               QWORD_LOW(sdss_common.tds_band_capability));
  sd_print_lte_band_mask(sdss_common.lte_band_capability);
}

/*===========================================================================

FUNCTION sdss_is_srv_lost_state

DESCRIPTION
  Check if UE is in service lost state.

DEPENDENCIES
  None.

RETURN VALUE
 True : if UE is in service lost state.
 False: Otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN boolean sdss_is_srv_lost_state(
       sd_ss_e_type ss
)
{
  sdss_s_type      *ss_ptr   = sdss_ptr(ss);
  SD_ASSERT(ss_ptr != NULL);

  /* Check if the true event is one of the service lost events
   */
  return ss_ptr->is_in_srv_lost_state;

}

/*===========================================================================

FUNCTION sdss_is_event_3gpp_acq_success

DESCRIPTION
  Check if the event is 3gpp acq success.

DEPENDENCIES
  None.

RETURN VALUE
 True : if event is plmn_acq_fail

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN boolean sdss_is_event_3gpp_acq_success(
       sdss_evt_e_type event
)
{

  boolean is_desired_event = FALSE;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  SD_ASSERT_ENUM_IS_INRANGE(event, SDSS_EVT_MAX);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* ACQ_PLMN_Fail*/
  switch (event)
  {
    case SDSS_EVT_GWL_ACQ_PLMN_SUCCESS:
    case SDSS_EVT_HYBR_2_GW_ACQ_PLMN_SUCCESS:
      is_desired_event = TRUE;
      break;

    /* Do nothing */
    default:
      break;
  }

  return is_desired_event;

}


#ifdef FEATURE_AVOID_DUP_BAND_SCAN

/*===========================================================================

FUNCTION sdss_is_event_3gpp_acq_fail

DESCRIPTION
  Check if the event is 3gpp acq failure.  Only if it is true and is_avoid_to_scan = 1 , then save
  the band for avoiding duplicate scan later.

DEPENDENCIES
  None.

RETURN VALUE
 True : if event is plmn_acq_fail

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN boolean sdss_is_event_3gpp_acq_fail(
       sdss_evt_e_type event
)
{

  boolean is_desired_event = FALSE;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  SD_ASSERT_ENUM_IS_INRANGE(event, SDSS_EVT_MAX);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* ACQ_PLMN_Fail*/
  switch (event)
  {
    case SDSS_EVT_GWL_ACQ_PLMN_FAILED:
    case SDSS_EVT_HYBR_2_GW_ACQ_PLMN_FAILED:
    case SDSS_EVT_HYBR_3_GW_ACQ_PLMN_FAILED:
      is_desired_event = TRUE;
      break;

    /* Do nothing */
    default:
      break;
  }

  return is_desired_event;

}


/*===========================================================================

FUNCTION sdss_is_3gpp_tot_scan

DESCRIPTION
  Check if sd is peforming 3GPP TOT list scan based on the list name and pos in sd core.

DEPENDENCIES
  None.

RETURN VALUE
 TRUE : if sd is peforming 3GPP TOT list scan
 FALSE: otherwise

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN boolean sdss_is_3gpp_tot_scan (
       sd_ss_e_type ss
)
{
  sdsr_e_type list;
  int pos;
  sdsr_s_type *sdsr_ptr = NULL;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  SD_ASSERT_ENUM_IS_INRANGE(ss, SD_SS_MAX);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Read the last acq_list and acq_pos from sd core */
  list = sdss_ptr(ss)->acq_list;
  pos = sdss_ptr(ss)->acq_pos;

  if (pos == SDSR_POS_NULL || list != SDSR_TOT_LST)
  {
    return FALSE;
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  sdsr_ptr = sdsr_list_get_ptr(SDSR_TOT_LST, pos);
  /* Check if the system record mode is 3GPP */
  if ( sdsr_ptr != NULL &&
       sd_misc_is_mode_3gpp(sdsr_ptr->sys.mode))
  {
    return TRUE;
  }

  return FALSE;
}


/*===========================================================================

FUNCTION sdss_proc_avoid_dup_scan_per_user_ss_pref

DESCRIPTION
  To update avoid_state based on user ss pref.

  sd_ss_user_ss_pref could change the following.  Avoid_state needs to be
  changed accordingly.
  - mode_pref
  - orig_mode
  - subscription

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void  sdss_proc_avoid_dup_scan_per_user_ss_pref (
       sd_ss_e_type ss
)
{
  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  SD_ASSERT_ENUM_IS_INRANGE(ss, SD_SS_MAX);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Deactivate if net_sel_mode is manual mode
  ** or there is no GW subscription
  ** ( except during emergency call orig. during emerg call orig allow
  ** filtering even if mode is MANUAL or there is no GW subsc )
   */

  if ( !sdss_is_cond_for_avoid_dup_scan_met(ss) )
  {
    SD_MSG_HIGH_1("AVOID_DUP_SCAN: user_ss_pref - DEACTIVATE, ss=%d",ss);
    sdss_avoid_dup_scan_stop(ss, FALSE);
  }
}

/*===========================================================================

FUNCTION sdss_proc_avoid_dup_scan_per_acq_state_chg

DESCRIPTION
  To process the acq state change occurred in sdss_acq_event_proc.  Based on
  the state transiton, will store the band if needed.

  This function only process the ACQ_PLMN_SUCCESS events.  For some cases,
  even if acq_plmn_succ is received at sd, the system is not what we want to
  stay on.  In such cases, then we don't want to scan the same band again later.

  General Cases:
  1.  Any -> SDSS_ACQ_STT_START
  2.  SDSS_ACQ_STT_MORE_PREF -> SDSS_ACQ_STT_MORE_PREF

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if band mask is updated.
  FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN boolean sdss_proc_avoid_dup_scan_per_acq_state_chg(
       sd_ss_e_type ss,
       /* system selection */

       sdss_evt_e_type event,
       /* Event is being processed */

       const sdss_band_s_type *band,
       /* band for which the last acquisition attempted*/

       sdss_acq_stt_e_type from_state,
       /* Acq state when event is received */

       sdss_acq_stt_e_type to_state
       /* Acq state after sdss_acq_event_proc */
)
{
  /* Flag to indicate if we need to store the band (those bands will not scanned in the future until
  ** next ACQ_NEW() )
  */
  boolean is_avoid = FALSE;
  sdss_band_s_type band_scanned;
  sdsr_s_type *acq_sys_ptr	    = sdsr_list_get_ptr( sdss_sr_list_map2( ss, SDSR_ACQ_SYS), 0 );

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  SD_ASSERT_ENUM_IS_INRANGE(ss, SD_SS_MAX);
  SD_ASSERT_ENUM_IS_INRANGE( event, SDSS_EVT_MAX );
  SD_ASSERT_ENUM_IS_INRANGE(from_state, SDSS_ACQ_STT_MAX);
  SD_ASSERT_ENUM_IS_INRANGE(to_state, SDSS_ACQ_STT_MAX);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  if (band == NULL)
  {
    SD_ERR_0("AVOID_DUP_SCAN: sdss_proc_avoid_dup_scan_per_acq_state_chg band null ptr");
    return FALSE;
  }
  band_scanned = *band;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Return here if not plmn_succ event */
  if ( ! (event == SDSS_EVT_GWL_ACQ_PLMN_SUCCESS ||
      event == SDSS_EVT_HYBR_2_GW_ACQ_PLMN_SUCCESS ||
      event == SDSS_EVT_HYBR_3_GW_ACQ_PLMN_SUCCESS))
  {
    return FALSE;
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* No need to store the band if avoid_state is not active */
  if ( !sdss_is_avoid_state_active(ss) )
  {
    return FALSE;
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  switch (from_state)
  {
    /* In case of PLMN_success, band is not saved at front end.
    ** Will need to save the band if the acq state change is listed here.
    */
    case SDSS_ACQ_STT_REACQ:
    case SDSS_ACQ_STT_REACQ_GWL:
    case SDSS_ACQ_STT_REACQ_FULL_SRV:
    case SDSS_ACQ_STT_DONE:
      if ( to_state == SDSS_ACQ_STT_START )
      {
        is_avoid = TRUE;
      }
      break;

    case SDSS_ACQ_STT_START:
      /* in case of emergency call, and alternate redial algorithm as true,
      if moving from SDSS_ACQ_STT_START to SDSS_ACQ_STT_DONE,
      update emergency avoid dup band info */
      if(to_state == SDSS_ACQ_STT_DONE && sdss_is_emergency_call_orig(ss) && sdss_is_e911_alternate_redial_algorithm(ss) )
      {
        is_avoid = TRUE;
		
        if(sdss_is_event_3gpp_acq_success(event) && sdss_is_emergency_call_orig(ss) &&
           sdss_is_e911_alternate_redial_algorithm(ss))
        {
          if(acq_sys_ptr && (acq_sys_ptr->sid.gw.mode == SYS_SYS_MODE_GSM ||
             acq_sys_ptr->sid.gw.mode == SYS_SYS_MODE_WCDMA ))
          {
            band_scanned.band = acq_sys_ptr->sid.gw.band.chgwt_band;
            band_scanned.lte_band = sdsr_map_lte_band_pref_to_sys_rec_lte_band(SYS_LTE_BAND_MASK_CONST_NONE);
            band_scanned.tds_band = SD_SS_BAND_PREF_NONE;
          }
          else if(acq_sys_ptr && (acq_sys_ptr->sid.gw.mode == SYS_SYS_MODE_LTE ))
          {
            band_scanned.band = SD_SS_BAND_PREF_NONE;
            band_scanned.lte_band = acq_sys_ptr->sid.gw.band.lte_band;
            band_scanned.tds_band = SD_SS_BAND_PREF_NONE;
          }
          else if(acq_sys_ptr && (acq_sys_ptr->sid.gw.mode == SYS_SYS_MODE_TDS))
          {
            band_scanned.band = SD_SS_BAND_PREF_NONE;
            band_scanned.lte_band = sdsr_map_lte_band_pref_to_sys_rec_lte_band(SYS_LTE_BAND_MASK_CONST_NONE);
            band_scanned.tds_band = acq_sys_ptr->sid.gw.band.chgwt_band;
          } 	   
        }
      }

      /* add to band_to_avoid mask if it is not limited scan */
      if ((to_state == SDSS_ACQ_STT_START ||
           to_state == SDSS_ACQ_STT_MORE_PREF)
           && !sdss_is_3gpp_tot_scan(ss)
           && !sdss_get_is_prev_net_sel_type_limited(ss))
      {
        is_avoid = TRUE;
      }

      break;

    case SDSS_ACQ_STT_MORE_PREF:
      if ( to_state == SDSS_ACQ_STT_START || to_state == SDSS_ACQ_STT_MORE_PREF)
      {
        is_avoid = TRUE;
      }
      break;

    /* Do nothing */
    default:
      break;
  }

  /* Update the band mask so that the band will be filtered out for the future scan.
  */
  if (is_avoid == TRUE)
  {
    /* If band mask is updated then return true */
    if (sdss_update_band_mask(ss, SDSS_BAND_TYPE_AVOID, &band_scanned))
    {
      SD_MSG_HIGH_2("AVOID_DUP_BAND: acq_stt %d->%d, band_to_avoid mask is updated",
                  from_state, to_state);
      return TRUE;
    }
  }

  return FALSE;

}


/*===========================================================================

FUNCTION sdss_is_cond_for_avoid_dup_scan_met

DESCRIPTION
   Check if all conditions for triggerring avoid_dup_scan are met.

   Conditions are
   - orig mode != manual
   - subscription ready for both gw and cdma

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if all the conditions for triggerring avoid_dup_scan are met.
  FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN boolean sdss_is_cond_for_avoid_dup_scan_met(
       sd_ss_e_type ss

)
{

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  SD_ASSERT_ENUM_IS_INRANGE(ss, SD_SS_MAX);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  /* If UE is in an emergency call origination, allow duplicate band filtering
  */
  if( sdss_is_emergency_call_orig(ss))
  {
    return TRUE;
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Map ss to the main stack of that sub */
  if(ss == SD_SS_HYBR_1 ||
    (ss == SD_SS_HYBR_2 && sdss_is_1x_sxlte())
    )
  {
    ss = SD_SS_MAIN;
  }

  /* If GW subscription is not available, disable filtering */
  if (SD_BIT_COMMON(sdss_get_subsc_type(ss), SDSS_SUBSC_GW) == 0)
  {
    return FALSE;
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* If we reach here, all the conditions for avoid_dup_scan are met */
  return TRUE;

}


/*===========================================================================

FUNCTION sdss_proc_avoid_dup_scan_per_new_acq

DESCRIPTION
  At NEW_ACQ(), activate avoid-duplicate-band-scan if the following conditions meet
   - orig mode = automatic
   - orig mode != call orig
   - subscription ready for both gw and cdma
   - mode pref is multi-mode
   - phone is not in L/W connected mode

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_proc_avoid_dup_scan_per_new_acq(
       sd_ss_e_type ss

)
{
  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  SD_ASSERT_ENUM_IS_INRANGE(ss, SD_SS_MAX);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  /* Keep the duplicate band filtering if UE is currently processing an emergency
  ** call origination
  */
  /* If not, Check the following conditions for activating avoid_dup_scan
   ** Do not enable if net_sel_mode is manual mode.
   ** Do not enable if GW subscription is not available
   */

  if (sdss_is_cond_for_avoid_dup_scan_met(ss))
  {
    sdss_avoid_dup_scan_start(ss);
  }
  else
  {
    sdss_avoid_dup_scan_stop(ss, TRUE);
  }

}


/*===========================================================================

FUNCTION sdss_is_avoid_state_active

DESCRIPTION
  To check whether current avoid state is active.

DEPENDENCIES
  None.

RETURN VALUE
 True : if avoid_state is SDSS_AVOID_STATE_ACTIVE
 False otherwise

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN boolean sdss_is_avoid_state_active(
       sd_ss_e_type ss
)
{
  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  SD_ASSERT_ENUM_IS_INRANGE(ss, SD_SS_MAX);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  return ( sdss_get_avoid_state(ss) == SDSS_AVOID_STATE_ACTIVE);
}

/*===========================================================================

FUNCTION sdss_is_avoid_state_inactive_or_none

DESCRIPTION
  To check whether current avoid state is in-active or none.

DEPENDENCIES
  None.

RETURN VALUE
 True : if avoid_state is SDSS_AVOID_STATE_NOT_ACTIVE or SDSS_AVOID_STATE_NONE
 False otherwise

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN boolean sdss_is_avoid_state_inactive_or_none(
       sd_ss_e_type ss
)
{
  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  SD_ASSERT_ENUM_IS_INRANGE(ss, SD_SS_MAX);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* get variable and check */
  return ((sdss_get_avoid_state(ss) == SDSS_AVOID_STATE_NOT_ACTIVE) ||
          (sdss_get_avoid_state(ss) == SDSS_AVOID_STATE_NONE));

}

/*===========================================================================

FUNCTION sdss_get_avoid_state

DESCRIPTION
  To read the current avoid dup band scan state.

DEPENDENCIES
  None.

RETURN VALUE
 True : avoid_state

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN sdss_avoid_state_e_type sdss_get_avoid_state(
       sd_ss_e_type ss
)
{
  sdss_avoid_state_e_type avoid_state = SDSS_AVOID_STATE_NONE;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  SD_ASSERT_ENUM_IS_INRANGE(ss, SD_SS_MAX);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  avoid_state = sdss_ptr(ss)->avoid_dup_band_scan.avoid_state;

  return avoid_state;

}

/*===========================================================================

FUNCTION sdss_get_avoid_emerg_bands

DESCRIPTION
  To read the emerg dup bands to avoid.

DEPENDENCIES
  None.

RETURN VALUE
 True : avoid_bands

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN sdss_band_s_type sdss_get_avoid_emerg_bands(
       sd_ss_e_type ss
)
{
  sdss_band_s_type avoid_bands;

  SD_ASSERT_ENUM_IS_INRANGE(ss, SD_SS_MAX);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  avoid_bands = sdss_ptr(ss)->avoid_dup_band_scan.emerg_band_to_avoid;

  return avoid_bands;

}

/*===========================================================================

FUNCTION sdss_get_band_mask

DESCRIPTION
  To read the current dup band to avoid for the next scan.

DEPENDENCIES
  None.

RETURN VALUE
 True : avoid_state

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN sdss_band_s_type * sdss_get_band_mask(
       sd_ss_e_type ss,
       sdss_band_type_e_type band_type
)
{
  sdss_band_s_type *band_mask = NULL;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  SD_ASSERT_ENUM_IS_INRANGE(ss, SD_SS_MAX);
  SD_ASSERT_ENUM_IS_INRANGE(band_type, SDSS_BAND_TYPE_MAX);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  switch(band_type)
  {
    case SDSS_BAND_TYPE_PLMN_FOUND:
      band_mask = &(sdss_ptr(ss)->avoid_dup_band_scan.plmn_found_info.band_info);
      break;

    case SDSS_BAND_TYPE_AVOID:
      /*alternate silent redial enabled and emergency orig , then use emerg_band_to_avoid */
      if( sdss_is_emergency_call_orig(ss) && sdss_is_e911_alternate_redial_algorithm(ss))
      {
        band_mask = &(sdss_ptr(ss)->avoid_dup_band_scan.emerg_band_to_avoid);
      }
      else
      {
        band_mask = &(sdss_ptr(ss)->avoid_dup_band_scan.band_to_avoid);
      }
      break;

    default:
      SD_ERR_2("AVOID_DUP_SCAN: invalid band type %d, ss=%d", band_type, ss);
      break;
  }

  return band_mask;

}


/*===========================================================================

FUNCTION sdss_is_band_none

DESCRIPTION
  To update the avoid_dup_band scan info in sdss_ptr(ss).

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN boolean sdss_is_band_none(
       const sdss_band_s_type *band
)
{
  sys_lte_band_mask_e_type local_lte_band;
  if (band == NULL)
  {
    SD_ERR_0("AVOID_DUP_SCAN: sdss_is_band_none() null ptr");
    return FALSE;
  }
  local_lte_band = sdsr_map_sys_rec_lte_band_to_lte_band_pref(band->lte_band);
  return ( band->band == SD_SS_BAND_PREF_NONE &&
           SYS_LTE_BAND_MASK_CHK_IF_EMPTY(&local_lte_band) &&
           band->tds_band == SD_SS_BAND_PREF_NONE
         );

}


/*===========================================================================

FUNCTION sdss_update_avoid_info

DESCRIPTION
  To update the avoid_dup_band scan info in sdss_ptr(ss).

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_update_avoid_info(
       sd_ss_e_type            ss,
       /* system selection */

       sdss_avoid_state_e_type avoid_state,
       /* target value for avoid_state */

       sdss_band_update_e_type band_update_type,
       /* Band update type*/

       const sdss_band_s_type  *band
       /* Band info */
)
{
  SD_ASSERT_ENUM_IS_INRANGE(ss, SD_SS_MAX);
  SD_ASSERT_ENUM_IS_INRANGE(avoid_state, SDSS_AVOID_STATE_MAX);
  SD_ASSERT_ENUM_IS_INRANGE(band_update_type, SDSS_BAND_UPDATE_MAX);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Return if nothing is changed */
  if (avoid_state == SDSS_AVOID_STATE_NO_CHANGE &&
      band_update_type == SDSS_BAND_UPDATE_NO_CHANGE)
  {
    return;
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Update avoid_state */
  if (avoid_state != SDSS_AVOID_STATE_NO_CHANGE
     && sdss_ptr(ss)->avoid_dup_band_scan.avoid_state != avoid_state)
  {
    sdss_ptr(ss)->avoid_dup_band_scan.avoid_state = avoid_state;

    SD_MSG_LOW_2("AVOID_DUP_SCAN: UPDATE avoid_state to %d, ss=%d",
                avoid_state, ss);
  }

  /* Update band masks */
  switch (band_update_type)
  {
    /* Reset band masks for start and stop avoid dup scan
    */
    case SDSS_BAND_UPDATE_RESET:
      sdss_ptr(ss)->avoid_dup_band_scan.band_to_avoid.band = SD_SS_BAND_PREF_NONE;
      sdss_ptr(ss)->avoid_dup_band_scan.band_to_avoid.lte_band = sdsr_map_lte_band_pref_to_sys_rec_lte_band(SYS_LTE_BAND_MASK_CONST_NONE);
      sdss_ptr(ss)->avoid_dup_band_scan.band_to_avoid.tds_band = SD_SS_BAND_PREF_NONE;

      sdss_ptr(ss)->avoid_dup_band_scan.plmn_found_info.band_info.band = SD_SS_BAND_PREF_NONE;
      sdss_ptr(ss)->avoid_dup_band_scan.plmn_found_info.band_info.lte_band = sdsr_map_lte_band_pref_to_sys_rec_lte_band(SYS_LTE_BAND_MASK_CONST_NONE);
      sdss_ptr(ss)->avoid_dup_band_scan.plmn_found_info.band_info.tds_band = SD_SS_BAND_PREF_NONE;

      break;

    /* Update band_to_avoid */
    case SDSS_BAND_UPDATE_AVOID:
      if (band == NULL)
      {
        SD_ERR_0("AVOID_DUP_SCAN: band ptr null");
        return;
      }

      /*alternate silent redial enabled and emergency orig , then update emerg_band_to_avoid */
      if( sdss_is_emergency_call_orig(ss) && sdss_is_e911_alternate_redial_algorithm(ss))
      {
        sdss_ptr(ss)->avoid_dup_band_scan.emerg_band_to_avoid = *band;
      }
      else
      {
        sdss_ptr(ss)->avoid_dup_band_scan.band_to_avoid = *band;
      }
      break;

    /* Update the band in case of plmn found - used for limited acquisition
    */
    case SDSS_BAND_UPDATE_PLMN_FOUND:
      if (band == NULL)
      {
        SD_ERR_0("AVOID_DUP_SCAN: band ptr null");
        return;
      }

      sdss_ptr(ss)->avoid_dup_band_scan.plmn_found_info.band_info = *band;
      break;

    case SDSS_BAND_UPDATE_NO_CHANGE:
    case SDSS_BAND_UPDATE_MAX:
    default:
      break;
  }
  }

/*===========================================================================

FUNCTION sdss_update_is_3gpp_service_found_per_cycle

DESCRIPTION
  To update if 3gpp service is found during the full scan cycle.
  is_3gpp_service_found is set to true if at any time is_plmn_found = true.
  Once is_3gpp_service_found is set to true, it will not change the value untill avoid_state_stop/start.

  If is_3gpp_service_found=false, sd script will skip the limited acquisition.

DEPENDENCIES
  None.

RETURN VALUE
 None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_update_is_3gpp_service_found_per_cycle(
       sd_ss_e_type            ss,
       boolean                 is_3gpp_service_found
)
{

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  SD_ASSERT_ENUM_IS_INRANGE(ss, SD_SS_MAX);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Return if avoid state is inactive or none */
  if (sdss_is_avoid_state_inactive_or_none(ss) )
  {
    return;
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Update band_to_avoid */
  sdss_ptr(ss)->avoid_dup_band_scan.is_3gpp_service_found = is_3gpp_service_found;

}


/*===========================================================================

FUNCTION sdss_get_is_3gpp_service_found_per_cycle

DESCRIPTION
  To get the sdss_ptr(ss)->avoid_dup_band_scan.is_3gpp_service_found.

DEPENDENCIES
  None.

RETURN VALUE
 True if at least 1 3gpp service is found during the full scan.
 False otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN boolean sdss_get_is_3gpp_service_found_per_cycle(
       sd_ss_e_type            ss
)
{
  boolean is_3gpp_service_found = FALSE;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  SD_ASSERT_ENUM_IS_INRANGE(ss, SD_SS_MAX);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Read current avoid_dup info */
  is_3gpp_service_found = sdss_ptr(ss)->avoid_dup_band_scan.is_3gpp_service_found;

  return is_3gpp_service_found;

}


/*===========================================================================

FUNCTION sdss_update_is_3gpp_scan_attempted

DESCRIPTION
  To update if is 3gpp full service or TOT scan is attempted.

DEPENDENCIES
  None.

RETURN VALUE
 None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_update_is_3gpp_scan_attempted(
       sd_ss_e_type            ss,
       boolean                 is_3gpp_scan_attempted
)
{

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  SD_ASSERT_ENUM_IS_INRANGE(ss, SD_SS_MAX);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Return if avoid state is inactive or none */
  if (sdss_is_avoid_state_inactive_or_none(ss) )
  {
    return;
  }
  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Update band_to_avoid */
  sdss_ptr(ss)->avoid_dup_band_scan.is_3gpp_scan_attempted = is_3gpp_scan_attempted;

}


/*===========================================================================

FUNCTION sdss_get_is_3gpp_scan_attempted

DESCRIPTION
  To get the sdss_ptr(ss)->avoid_dup_band_scan.is_3gpp_scan_attempted.

DEPENDENCIES
  None.

RETURN VALUE
 True if full service scan has been attempted.
 False otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN boolean sdss_get_is_3gpp_scan_attempted(
       sd_ss_e_type            ss
)
{
  boolean is_3gpp_scan_attempted = FALSE;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  SD_ASSERT_ENUM_IS_INRANGE(ss, SD_SS_MAX);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Read current avoid_dup info */
  is_3gpp_scan_attempted = sdss_ptr(ss)->avoid_dup_band_scan.is_3gpp_scan_attempted;

  return is_3gpp_scan_attempted;

}


/*===========================================================================

FUNCTION sdss_update_is_prev_net_sel_type_limited

DESCRIPTION
  To update if the net sel type of the previous acq_gwl action is limited.

DEPENDENCIES
  None.

RETURN VALUE
 None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_update_is_prev_net_sel_type_limited(
       sd_ss_e_type            ss
)
{

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  SD_ASSERT_ENUM_IS_INRANGE(ss, SD_SS_MAX);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Set to true if SYS_NETWORK_SELECTION_MODE_LIMITED */
  if (sd_misc_get_prev_act_net_sel(ss) == SYS_NETWORK_SELECTION_MODE_LIMITED)
  {
    sdss_ptr(ss)->avoid_dup_band_scan.is_prev_net_sel_type_limited = TRUE;
  }
  else
  {
    sdss_ptr(ss)->avoid_dup_band_scan.is_prev_net_sel_type_limited = FALSE;
  }

}


/*===========================================================================

FUNCTION sdss_reset_is_prev_net_sel_type_limited

DESCRIPTION
  To reset is_prev_net_sel_type_limited value in SD core.

DEPENDENCIES
  None.

RETURN VALUE
 None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_reset_is_prev_net_sel_type_limited(
       sd_ss_e_type            ss
)
{

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  SD_ASSERT_ENUM_IS_INRANGE(ss, SD_SS_MAX);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  sdss_ptr(ss)->avoid_dup_band_scan.is_prev_net_sel_type_limited
    = FALSE;

}


/*===========================================================================

FUNCTION sdss_get_is_prev_net_sel_type_limited

DESCRIPTION
  To get the sdss_ptr(ss)->avoid_dup_band_scan.is_prev_net_sel_type_limited.

DEPENDENCIES
  None.

RETURN VALUE
 True if the net sel type of the previous acq_gwl action is limited.
 False otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN boolean sdss_get_is_prev_net_sel_type_limited(
       sd_ss_e_type            ss
)
{
  boolean is_prev_net_sel_type_limited = FALSE;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  SD_ASSERT_ENUM_IS_INRANGE(ss, SD_SS_MAX);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Read current avoid_dup info */
  is_prev_net_sel_type_limited
    = sdss_ptr(ss)->avoid_dup_band_scan.is_prev_net_sel_type_limited;

  return is_prev_net_sel_type_limited;

}


/*===========================================================================

FUNCTION sdss_update_3gpp_acq_info

DESCRIPTION
  To update is_plmn_found in sdss.
  is_plmn_found is set per acquisition and updated to true based on the following conditions
  - gw_acq_plmn_success event
  - gw_acq_plmn_camped event
  - gw_acq_plmn_failed event with scan status = plmn_found

  is_plmn_found is reset after event process is done.

DEPENDENCIES
  None.

RETURN VALUE
 None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_update_3gpp_acq_info(
       sd_ss_e_type                     ss,
       sdss_update_3gpp_acq_info_e_type update_type,
       boolean                          is_plmn_found,
       sys_srv_status_e_type            service_status
)
{
  boolean is_plmn_updated = FALSE;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  SD_ASSERT_ENUM_IS_INRANGE(ss, SD_SS_MAX);
  SD_ASSERT_ENUM_IS_INRANGE(update_type, SDSS_UPDATE_3GPP_ACQ_INFO_MAX);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Return if avoid state is inactive or none */
  if (sdss_is_avoid_state_inactive_or_none(ss) )
  {
    return;
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Update is_plmn_found */

  switch(update_type)
  {
    case SDSS_UPDATE_3GPP_ACQ_INFO_IS_PLMN_FOUND:
      sdss_ptr(ss)->avoid_dup_band_scan.acq_info_3gpp.is_plmn_found = is_plmn_found;
      is_plmn_updated = TRUE;
      break;

    case SDSS_UPDATE_3GPP_ACQ_INFO_SERVICE_STATUS:
      sdss_ptr(ss)->avoid_dup_band_scan.acq_info_3gpp.service_status= service_status;
      break;

    case SDSS_UPDATE_3GPP_ACQ_INFO_ALL:
      sdss_ptr(ss)->avoid_dup_band_scan.acq_info_3gpp.is_plmn_found = is_plmn_found;
      sdss_ptr(ss)->avoid_dup_band_scan.acq_info_3gpp.service_status= service_status;
      is_plmn_updated = TRUE;
      break;

    case SDSS_UPDATE_3GPP_ACQ_INFO_MAX:
    default:
      SD_ERR_1("invalid update type %d for updating 3GPP acq info", update_type);
      break;
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* If this is the first time that a plmn is found,
   ** then update is_3gpp_service_found to true.
   */
  if ( is_plmn_updated == TRUE &&
       is_plmn_found == TRUE &&
       sdss_get_is_3gpp_service_found_per_cycle(ss) != TRUE )
  {
    sdss_update_is_3gpp_service_found_per_cycle(ss, TRUE);
  }

}


/*===========================================================================

FUNCTION sdss_get_is_plmn_found

DESCRIPTION
  To get is_plmn_found for the current scan.

DEPENDENCIES
  None.

RETURN VALUE
 srv status of acqed plmn

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN boolean sdss_get_is_plmn_found(
       sd_ss_e_type ss
)
{

  boolean is_plmn_found = FALSE;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  SD_ASSERT_ENUM_IS_INRANGE(ss, SD_SS_MAX);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  is_plmn_found = sdss_ptr(ss)->avoid_dup_band_scan.acq_info_3gpp.is_plmn_found;

  return is_plmn_found;

}


/*===========================================================================

FUNCTION sdss_get_3gpp_service_status

DESCRIPTION
  To get is_plmn_found for the current scan.

DEPENDENCIES
  None.

RETURN VALUE
 srv status of acqed plmn

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN sys_srv_status_e_type sdss_get_3gpp_service_status(
       sd_ss_e_type ss
)
{

  sys_srv_status_e_type service_status = SYS_SRV_STATUS_NONE;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  SD_ASSERT_ENUM_IS_INRANGE(ss, SD_SS_MAX);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  service_status = sdss_ptr(ss)->avoid_dup_band_scan.acq_info_3gpp.service_status;

  return service_status;

}


/*===========================================================================

FUNCTION sdss_is_3gpp_service_status_no_service

DESCRIPTION
  Check if 3gpp acquisition returns no service or none.

DEPENDENCIES
  None.

RETURN VALUE
 TRUE if no service or none
 FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN boolean sdss_is_3gpp_service_status_no_service(
       sd_ss_e_type ss
)
{

  sys_srv_status_e_type service_status = SYS_SRV_STATUS_NONE;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  SD_ASSERT_ENUM_IS_INRANGE(ss, SD_SS_MAX);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  service_status = sdss_ptr(ss)->avoid_dup_band_scan.acq_info_3gpp.service_status;

  if (service_status == SYS_SRV_STATUS_NONE ||
      service_status == SYS_SRV_STATUS_NO_SRV)
  {
    return TRUE;
  }

  return FALSE;

}


/*===========================================================================

FUNCTION sdss_avoid_dup_scan_start

DESCRIPTION
  To enable avoidance of duplicate band scan.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_avoid_dup_scan_start(
       sd_ss_e_type ss

)
{

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  SD_ASSERT_ENUM_IS_INRANGE(ss, SD_SS_MAX);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Activate avoid_dup_scan */
  sdss_update_avoid_info( ss,
                          SDSS_AVOID_STATE_ACTIVE,
                          SDSS_BAND_UPDATE_RESET,
                          NULL);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Reset is_3gpp_service_found */
  sdss_update_is_3gpp_service_found_per_cycle(ss, FALSE);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Reset is_gw_scan_attempted */
  sdss_update_is_3gpp_scan_attempted(ss, FALSE);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Reset is_prev_net_sel_type_limited */
  sdss_reset_is_prev_net_sel_type_limited(ss);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Reset 3gpp acq info */
  sdss_update_3gpp_acq_info(ss,
                            SDSS_UPDATE_3GPP_ACQ_INFO_ALL,
                            FALSE,
                            SYS_SRV_STATUS_NONE
                            );

}

/*===========================================================================

FUNCTION sdss_avoid_dup_scan_stop

DESCRIPTION
  To disable avoidance of duplicate band scan.  avoid_state will become not active.

  In non active state, band saved is cleared.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_avoid_dup_scan_stop(
       sd_ss_e_type ss,
       boolean check_alternate_redial_for_state
)
{

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  SD_ASSERT_ENUM_IS_INRANGE(ss, SD_SS_MAX);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Deactivate avoid_dup_scan if not already */
  if ( !sdss_is_avoid_state_inactive_or_none(ss) )
  {

    /* Reset is_3gpp_service_found */
    sdss_update_is_3gpp_service_found_per_cycle(ss, FALSE);

    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

    /* Reset is_gw_scan_attempted */
    sdss_update_is_3gpp_scan_attempted(ss, FALSE);

    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

    /* Reset is_prev_net_sel_type_limited */
    sdss_reset_is_prev_net_sel_type_limited(ss);

    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

    /* Reset 3gpp acq info */
    sdss_update_3gpp_acq_info(ss,
                              SDSS_UPDATE_3GPP_ACQ_INFO_ALL,
                              FALSE,
                              SYS_SRV_STATUS_NONE);

    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
    /* check_alternate_redial_for_state will be true when this function is called
            1. because of acq state reaching the Done state
            2. Due to New Acq construct */
    /* in case if alternate redial is set, and E911 orig call is in place
    do not move avoid state to reset */
    if(check_alternate_redial_for_state &&
       sdss_is_emergency_call_orig(ss) &&
       sdss_is_e911_alternate_redial_algorithm(ss))
    {
      sdss_update_avoid_info( ss,
                            SDSS_AVOID_STATE_NO_CHANGE,
                            SDSS_BAND_UPDATE_RESET,
                            NULL);
    }
    else
    {
    sdss_update_avoid_info( ss,
                            SDSS_AVOID_STATE_NOT_ACTIVE,
                            SDSS_BAND_UPDATE_RESET,
                            NULL);
    }

  }

}

/*===========================================================================

FUNCTION sdss_avoid_dup_scan_suspend

DESCRIPTION
  To suspend avoidance of duplicate band scan.

  When avoid_state is in suspend state, from that point, neither saving nor filtering bands will be done
  until avoid_state becomes active again.

  In suspend state, band saved is not cleared.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_avoid_dup_scan_suspend (
       sd_ss_e_type ss
)
{
  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  SD_ASSERT_ENUM_IS_INRANGE(ss, SD_SS_MAX);

  SD_MSG_LOW_1("AVOID_DUP_SCAN: SUSPEND, ss=%d",ss);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  if ( sdss_is_avoid_state_active (ss) )
  {
    sdss_update_avoid_info( ss,
                    SDSS_AVOID_STATE_SUSPEND,
                    SDSS_BAND_UPDATE_NO_CHANGE,
                    NULL);
  }

}

#ifdef FEATURE_LIMITED_SCAN_OPT
/*===========================================================================

FUNCTION sdss_avoid_dup_scan_set_limited_scan

DESCRIPTION
  To change avoid state from active to limited scan.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_avoid_dup_scan_set_limited_scan (
       sd_ss_e_type ss
)
{
  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  SD_ASSERT_ENUM_IS_INRANGE(ss, SD_SS_MAX);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  if ( sdss_is_avoid_state_active (ss) )
  {
    sdss_update_avoid_info( ss,
                    SDSS_AVOID_STATE_LIMITED_SCAN,
                    SDSS_BAND_UPDATE_NO_CHANGE,
                    NULL);
  }

}


/*===========================================================================

FUNCTION sdss_avoid_dup_scan_reset_limited_scan

DESCRIPTION
  To change avoid state from limited scan state to active.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_avoid_dup_scan_reset_limited_scan (
       sd_ss_e_type ss
)
{

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  SD_ASSERT_ENUM_IS_INRANGE(ss, SD_SS_MAX);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  if ( sdss_get_avoid_state(ss) == SDSS_AVOID_STATE_LIMITED_SCAN)
  {
    sdss_update_avoid_info( ss,
                    SDSS_AVOID_STATE_ACTIVE,
                    SDSS_BAND_UPDATE_NO_CHANGE,
                    NULL);
  }

}
#endif

/*===========================================================================

FUNCTION sdss_avoid_dup_scan_resume

DESCRIPTION
  To resume avoidance of duplicate band scan if it is in suspend state.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_avoid_dup_scan_resume (
       sd_ss_e_type ss
)
{
  sdss_avoid_state_e_type avoid_state;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  SD_ASSERT_ENUM_IS_INRANGE(ss, SD_SS_MAX);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  avoid_state = sdss_get_avoid_state(ss);

  if (avoid_state == SDSS_AVOID_STATE_SUSPEND
      #ifdef FEATURE_LIMITED_SCAN_OPT
      || (avoid_state == SDSS_AVOID_STATE_LIMITED_SCAN)
      #endif
      )
  {
    sdss_update_avoid_info( ss,
                    SDSS_AVOID_STATE_ACTIVE,
                    SDSS_BAND_UPDATE_NO_CHANGE,
                    NULL);
  }

}

/*===========================================================================

FUNCTION sdss_proc_avoid_dup_scan_acq_state_reacq_or_done

DESCRIPTION
  To process avoid dup scan when acq state is reacq or done.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_proc_avoid_dup_scan_acq_state_reacq_or_done (
       sd_ss_e_type ss,
       sdss_acq_stt_e_type acq_state
)
{
  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  SD_ASSERT_ENUM_IS_INRANGE(ss, SD_SS_MAX);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  switch(acq_state)
  {

    /* To suspend avoid_dup_scan when acq state becomes REACQ/REACQ_GWL/REACQ_FULL_SRV
    */
    case SDSS_ACQ_STT_REACQ:
    case SDSS_ACQ_STT_REACQ_GWL:
    case SDSS_ACQ_STT_REACQ_FULL_SRV:
      sdss_avoid_dup_scan_suspend( ss );
      break;

     /* Scan is complete, so reset band_to_avoid.
     ** This will be activated again upon ACQ_NEW.
     */
    case SDSS_ACQ_STT_DONE:
      sdss_avoid_dup_scan_stop( ss, TRUE);
      break;

    default:
      break;
  }

}

/*===========================================================================

FUNCTION sdss_proc_avoid_dup_scan_per_pwr_save

DESCRIPTION
  To stop avoid_dup_band_scan if SS enters power save.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_proc_avoid_dup_scan_per_pwr_save (
       sd_ss_e_type ss
)
{
  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  SD_ASSERT_ENUM_IS_INRANGE(ss, SD_SS_MAX);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Reset is_gw_scan_attempted */
  sdss_update_is_3gpp_scan_attempted(ss, FALSE);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* POWER SAVE - DEACTIVATE */
  sdss_avoid_dup_scan_stop( ss , FALSE);

  /* reset emergency avoid dup band info */
  //sdss_reset_emerg_band_to_avoid(ss);
}


/*===========================================================================

FUNCTION sdss_update_band_mask

DESCRIPTION
  To update 3GPP bands that have been scanned.  Update is done on band bit mask.

  If avoid_state = active, update band_to_avoid bit mask.
  Otherwise, return right away without update.

  This function is to save the bands.  The band filtering is done in diff
  function.

DEPENDENCIES
  None.

RETURN VALUE
 True : If band mask is actually updated/changed.
 False: Otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN boolean sdss_update_band_mask(
       sd_ss_e_type ss,
       sdss_band_type_e_type band_type,
       const sdss_band_s_type *band
)
{
  sdss_band_s_type *band_mask = NULL;
  sdss_avoid_state_e_type avoid_state = SDSS_AVOID_STATE_NONE;
  sys_lte_band_mask_e_type local_lte_band1,local_lte_band2;
  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  SD_ASSERT_ENUM_IS_INRANGE(ss, SD_SS_MAX);
  SD_ASSERT_ENUM_IS_INRANGE(band_type, SDSS_BAND_TYPE_MAX);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Should not be null */
  if (band == NULL)
  {
    return FALSE;
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Current avoid_state */
  avoid_state = sdss_get_avoid_state(ss);

  /* Update band only if avoid_state is actvie */
  if (avoid_state != SDSS_AVOID_STATE_ACTIVE)
  {
    return FALSE;
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* If reach here, band needs to be updated.
  */

  /* Get current band mask first,
  ** then add new band mask.
  */
  band_mask = sdss_get_band_mask(ss, band_type);

  if (band_mask == NULL)
  {
    SD_ERR_1("AVOID_DUP_BAND: sdss_get_band_mask returns null, ss=%d", ss);
    return FALSE;
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  local_lte_band1 = sdsr_map_sys_rec_lte_band_to_lte_band_pref(band_mask->lte_band);
  local_lte_band2 = sdsr_map_sys_rec_lte_band_to_lte_band_pref(band->lte_band);

  /* Check if band_mask already contains band */
  if ((band_mask->band&band->band) == band->band
      && SYS_LTE_BAND_MASK_CHK_IF_SUBSET(&local_lte_band1,&local_lte_band2)
       && (band_mask->tds_band&band->tds_band) == band->tds_band)
  {
    return FALSE;
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Calculate new band_mask */
  band_mask->band |= band->band;
  SYS_LTE_BAND_MASK_ADD_MASK(&local_lte_band1,&local_lte_band2);
  band_mask->lte_band = sdsr_map_lte_band_pref_to_sys_rec_lte_band(local_lte_band1);
  band_mask->tds_band |= band->tds_band;

  SD_MSG_HIGH_1("AVOID_DUP_SCAN: update band mask for band_type=%d",band_type);

  /* Update band mask based on band_type */
  switch (band_type)
  {
    case SDSS_BAND_TYPE_PLMN_FOUND:
    {
      sdss_update_avoid_info( ss,
                  SDSS_AVOID_STATE_NO_CHANGE,
                  SDSS_BAND_UPDATE_PLMN_FOUND,
                  band_mask);
      break;
    }

    case SDSS_BAND_TYPE_AVOID:
    {
      sdss_update_avoid_info( ss,
                  SDSS_AVOID_STATE_NO_CHANGE,
                  SDSS_BAND_UPDATE_AVOID,
                  band_mask);

      break;
    }

    case SDSS_BAND_TYPE_MAX:
    default:
    {
      SD_ERR_2("AVOID_DUP_SCAN: invalid band_type %d for updating band mask, ss=%d",band_type,ss);
      return FALSE;
    }
  }

  return TRUE;

}

/*===========================================================================

FUNCTION sdss_is_band_none_per_mode

DESCRIPTION
  To check if band is empty per mode..

DEPENDENCIES
  None.

RETURN VALUE
 TRUE if band is empty or none.
 FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN boolean sdss_is_band_none_per_mode(
       sd_mode_e_type mode,
       const sdss_band_s_type *band
)
{
  sd_ss_mode_pref_e_type remain_mode;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  SD_ASSERT_ENUM_IS_INRANGE(mode, SD_MODE_MAX);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* should not be null */
  if (band == NULL)
  {
    SD_ERR_0("sdss_is_band_none_per_mode band null ptr");
    return TRUE;
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Check if remain_mode is sd_ss_mode_pref_null */
  remain_mode = sdss_get_supp_mode_pref_mmode( sdss_map_mode_to_mode_pref(mode),
                                               band->band,
                                               sdsr_map_sys_rec_lte_band_to_lte_band_pref(band->lte_band),
                                               band->tds_band);

  if (remain_mode == SD_SS_MODE_PREF_NONE)
  {
    return TRUE;
  }

  return FALSE;

}


/*===========================================================================

FUNCTION sdss_filter_out_dup_band

DESCRIPTION
  To filter out the band has been scanned previously.
  band_to_return = band - band_to_avoid.

  If avoid_state = active, remove the band_to_avoid.
  Otherwise, no need to filter out the band.  The system record will be scanned as it is.

DEPENDENCIES
  None.

RETURN VALUE
 none

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_filter_out_dup_band(
       sd_ss_e_type ss,
       sd_mode_e_type mode,
       sdss_band_s_type *band
)
{
  /* Band mask for band_to_avoid */
  sdss_band_s_type *band_mask = NULL;
  sdss_avoid_state_e_type avoid_state = SDSS_AVOID_STATE_NONE;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  SD_ASSERT_ENUM_IS_INRANGE(ss, SD_SS_MAX);
  SD_ASSERT_ENUM_IS_INRANGE(mode, SD_MODE_MAX);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* should not be null */
  if (band == NULL)
  {
    SD_ERR_1("sdss_filter_out_dup_band band null ptr, ss=%d", ss);
    return;
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Remove band only if avoid_state = active */
  avoid_state = sdss_get_avoid_state(ss);

  if (avoid_state != SDSS_AVOID_STATE_ACTIVE
      #ifdef FEATURE_LIMITED_SCAN_OPT
      && (avoid_state != SDSS_AVOID_STATE_LIMITED_SCAN)
      #endif
      )
  {
    return;
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Check if mode is GWL */
  if( !sd_misc_is_mode_3gpp(mode) )
  {
    return;
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Get band_mask base on avoid_state, then peform band operation.
   */
  switch(avoid_state)
  {
    case SDSS_AVOID_STATE_ACTIVE:
      band_mask = sdss_get_band_mask(ss, SDSS_BAND_TYPE_AVOID);
      sdss_band_delete(band, band_mask);
      break;

    #ifdef FEATURE_LIMITED_SCAN_OPT
    case SDSS_AVOID_STATE_LIMITED_SCAN:
      band_mask = sdss_get_band_mask(ss, SDSS_BAND_TYPE_PLMN_FOUND);
      sdss_band_intersect(band, band_mask);
      break;
    #endif

    default:
      SD_ERR_2("AVOID_DUP_SCAN: invalid avoid state%d to filter band, ss=%d", avoid_state, ss);
      break;
  }

}

#ifdef FEATURE_LIMITED_SCAN_OPT
/*===========================================================================

FUNCTION sdss_band_intersect

DESCRIPTION
  To get intersection of 2 sets of bandmasks.


DEPENDENCIES
  None.

RETURN VALUE
  intersection of 2 bandmasks.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_band_intersect(
       sdss_band_s_type *band,
       const sdss_band_s_type *band_mask
)
{
  sys_lte_band_mask_e_type local_lte_band1,local_lte_band2;
  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* should not be null */
  if (band_mask == NULL || band == NULL)
  {
    SD_ERR_0("AVOID_DUP_SCAN: band null ptr");
    return;
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Either band or band_mask should not be none */
  if (sdss_is_band_none(band_mask) == TRUE ||
      sdss_is_band_none(band) == TRUE)
  {
    SD_MSG_HIGH_0("AVOID_DUP_SCAN: INTERSECT - band_mask or base_band is 0");
    return;
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* If reach here, need to get interseciton of 2 band structions */
  local_lte_band1 = sdsr_map_sys_rec_lte_band_to_lte_band_pref(band->lte_band);
  local_lte_band2 = sdsr_map_sys_rec_lte_band_to_lte_band_pref(band_mask->lte_band);
  /* band to scan = band & band_mask */
  band->band = SD_GET_COMMON_BAND(band->band, band_mask->band);
  local_lte_band1 = SYS_LTE_BAND_MASK_COMMON(&local_lte_band1,&local_lte_band2);
  band->lte_band = sdsr_map_lte_band_pref_to_sys_rec_lte_band(local_lte_band1);
  band->tds_band = SD_GET_COMMON_BAND(band->tds_band, band_mask->tds_band);

  /* Print information about the band_mask and band after intersection */
  SD_MSG_HIGH_0("AVOID_DUP_SCAN: intersection mask");
  sdss_print_band_mask_info(band_mask);

}
#endif

/*===========================================================================

FUNCTION sdss_band_operation_delete

DESCRIPTION
  To delete band based on band_mask.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_band_delete(
       sdss_band_s_type *band,
       const sdss_band_s_type *band_mask
)
{
  sys_lte_band_mask_e_type local_lte_band1,local_lte_band2;
  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* should not be null */
  if (band_mask == NULL || band == NULL)
  {
    SD_ERR_0("AVOID_DUP_SCAN: band null ptr");
    return;
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* band should not be none */
  if (sdss_is_band_none(band) == TRUE)
  {
    SD_ERR_0("AVOID_DUP_SCAN: FILTER - base_band is 0");
    return;
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* band_mask could be none */
  if (sdss_is_band_none(band_mask) == TRUE)
  {
    return;
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* If reach here, need to filter the band */

  /* Print the bands before filtering */
  SD_MSG_HIGH_0("AVOID_DUP_SCAN: band before filtering");
  sdss_print_band_mask_info(band);

  local_lte_band1 = sdsr_map_sys_rec_lte_band_to_lte_band_pref(band->lte_band);
  local_lte_band2 = sdsr_map_sys_rec_lte_band_to_lte_band_pref(band_mask->lte_band);
  /* band to scan = band - band_mask */
  band->band = SD_BAND_DELETE(band->band, band_mask->band);
  SYS_LTE_BAND_MASK_REMOVE_MASK(&local_lte_band1,&local_lte_band2);
  band->lte_band = sdsr_map_lte_band_pref_to_sys_rec_lte_band(local_lte_band1);
  band->tds_band = SD_BAND_DELETE(band->tds_band, band_mask->tds_band);

  /* Print the filtering mask and the band after filtering */
  SD_MSG_HIGH_0("AVOID_DUP_SCAN: filter mask");
  sdss_print_band_mask_info(band_mask);

  SD_MSG_HIGH_0("AVOID_DUP_SCAN: band after filtering");
  sdss_print_band_mask_info(band);

}


/*===========================================================================

FUNCTION sdss_print_band_mask_info

DESCRIPTION
  To print the band information.

DEPENDENCIES
  None.

RETURN VALUE
 True : none

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_print_band_mask_info (
  const sdss_band_s_type *band
)
{

  /* should not be null */
  if (band == NULL)
  {
    SD_ERR_0("AVOID_DUP_SCAN: sdss_print_band_mask_info null ptr");
    return;
  }

  SD_MSG_HIGH_4("AVOID_DUP_SCAN:  gw band=0x%08x %08x, tds band=0x%08x %08x",
               QWORD_HIGH(band->band),
               QWORD_LOW(band->band),
               QWORD_HIGH(band->tds_band),
               QWORD_LOW(band->tds_band));
}

/*===========================================================================

FUNCTION sdss_reset_emerg_band_to_avoid

DESCRIPTION
  Resets  the emergency avoid dup info

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_reset_emerg_band_to_avoid(sd_ss_e_type ss)
{

  sdss_s_type   *ss_ptr   = sdss_ptr( ss );
  sys_lte_band_mask_e_type lte_band_pref_local1 = sdsr_map_sys_rec_lte_band_to_lte_band_pref( ss_ptr->avoid_dup_band_scan.emerg_band_to_avoid.lte_band );


  SD_ASSERT (ss_ptr);
  if(ss_ptr->avoid_dup_band_scan.emerg_band_to_avoid.band != SD_SS_BAND_PREF_NONE
    || !SYS_LTE_BAND_MASK_CHK_IF_EMPTY(&lte_band_pref_local1)
    || ss_ptr->avoid_dup_band_scan.emerg_band_to_avoid.tds_band != SD_SS_BAND_PREF_NONE)
  {
    SD_MSG_HIGH_1("Reset emergency band to avoid info ss=%d",ss);
    ss_ptr->avoid_dup_band_scan.emerg_band_to_avoid.band = SD_SS_BAND_PREF_NONE;
    ss_ptr->avoid_dup_band_scan.emerg_band_to_avoid.lte_band = sdsr_map_lte_band_pref_to_sys_rec_lte_band(SYS_LTE_BAND_MASK_CONST_NONE);
    ss_ptr->avoid_dup_band_scan.emerg_band_to_avoid.tds_band = SD_SS_BAND_PREF_NONE;
  }
}

/*===========================================================================

  FUNCTION sdss_copy_emerg_avoid_dup_band_info

  DESCRIPTION
    Copies the emergency dup band avoid info from
    source SS to destination SS

  DEPENDENCIES
    None.

  RETURN VALUE
    None.

  SIDE EFFECTS
    None.

  ===========================================================================*/
EXTERN void sdss_copy_emerg_avoid_dup_band_info(sd_ss_e_type dest_ss, sd_ss_e_type src_ss)
{

  sdss_s_type   *src_ss_ptr   = sdss_ptr( src_ss );
  sdss_s_type   *dest_ss_ptr   = sdss_ptr( dest_ss );
  sys_lte_band_mask_e_type local_lte_band;

  SD_ASSERT (src_ss_ptr);
  SD_ASSERT (dest_ss_ptr);
  local_lte_band = sdsr_map_sys_rec_lte_band_to_lte_band_pref(src_ss_ptr->avoid_dup_band_scan.emerg_band_to_avoid.lte_band);
  if(src_ss_ptr->avoid_dup_band_scan.emerg_band_to_avoid.band != SD_SS_BAND_PREF_NONE ||
     !SYS_LTE_BAND_MASK_CHK_IF_EMPTY(&local_lte_band)||
  src_ss_ptr->avoid_dup_band_scan.emerg_band_to_avoid.tds_band != SD_SS_BAND_PREF_NONE)
  {
    SD_MSG_HIGH_2("Copy emerg band to avoid from src_ss %d to dest_ss %d",src_ss,dest_ss);
    dest_ss_ptr->avoid_dup_band_scan.emerg_band_to_avoid =
                 src_ss_ptr->avoid_dup_band_scan.emerg_band_to_avoid;
  }

  sdss_print_band_mask_info(&dest_ss_ptr->avoid_dup_band_scan.emerg_band_to_avoid);

}


/*===========================================================================

  FUNCTION sdss_add_last_acq_sys_band_to_emerg_dup_band_info

  DESCRIPTION
    Copies the emergency dup band avoid info from
    serving system pointer band information.

  DEPENDENCIES
    None.

  RETURN VALUE
    None.

  SIDE EFFECTS
    None.

  ===========================================================================*/
EXTERN void sdss_add_last_acq_sys_band_to_emerg_dup_band_info(sd_ss_e_type ss)
{
  sdss_s_type *ss_ptr = sdss_ptr(ss);
  sdsr_s_type *last_acq_sys_ptr = sdsr_list_get_ptr( sdss_sr_list_map2(ss,SDSR_ACQ_SYS), 0 );

  SD_ASSERT(ss_ptr != NULL);
  SD_ASSERT (last_acq_sys_ptr != NULL);

  if( last_acq_sys_ptr == NULL )
  {
    sys_err_fatal_null_ptr_exception();
  }


  SD_MSG_HIGH_2("LTE_911: ss=%d last_acq_sys  mode=%d, added to emergency dup band info",ss,  last_acq_sys_ptr->sid.gw.mode);

  if(last_acq_sys_ptr->sid.gw.mode == SYS_SYS_MODE_GSM ||
           last_acq_sys_ptr->sid.gw.mode == SYS_SYS_MODE_WCDMA )
  {
    ss_ptr->avoid_dup_band_scan.emerg_band_to_avoid.band |= last_acq_sys_ptr->sid.gw.band.chgwt_band;
    SD_MSG_HIGH_1("LTE_911: GWT band_mask=%d",last_acq_sys_ptr->sid.gw.band.chgwt_band);
  }
  else if(last_acq_sys_ptr->sid.gw.mode == SYS_SYS_MODE_LTE )
  {
    sys_lte_band_mask_e_type local_lte_band1 = sdsr_map_sys_rec_lte_band_to_lte_band_pref(ss_ptr->avoid_dup_band_scan.emerg_band_to_avoid.lte_band);
    sys_lte_band_mask_e_type local_lte_band2 = sdsr_map_sys_rec_lte_band_to_lte_band_pref(last_acq_sys_ptr->sid.gw.band.lte_band);

    sd_print_lte_band_mask(sdsr_map_sys_rec_lte_band_to_lte_band_pref(last_acq_sys_ptr->sid.gw.band.lte_band)); 
    
    SYS_LTE_BAND_MASK_ADD_MASK(&local_lte_band1,&local_lte_band2);
    ss_ptr->avoid_dup_band_scan.emerg_band_to_avoid.lte_band = sdsr_map_lte_band_pref_to_sys_rec_lte_band(local_lte_band1) ;
  }
  else if(last_acq_sys_ptr->sid.gw.mode == SYS_SYS_MODE_TDS)
  {
   ss_ptr->avoid_dup_band_scan.emerg_band_to_avoid.tds_band |= last_acq_sys_ptr->sid.gw.band.chgwt_band;
  }
}



#endif /* defined (FEATURE_AVOID_DUP_BAND_SCAN) */

/*===========================================================================

FUNCTION sdss_is_csg_id_defined

DESCRIPTION
  To return TRUE or FALSE based on CSG ID is valid or invalid

DEPENDENCIES
  None.

RETURN VALUE
TRUE : If the CSG ID is not SYS_CSG_ID_INVALID, FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
boolean sdss_is_csg_id_defined (sd_ss_e_type  ss)
{
  sdss_s_type* ss_ptr   = sdss_ptr(ss);

  SD_ASSERT(NULL != ss_ptr);

  if(ss_ptr->csg_id != SYS_CSG_ID_INVALID)
  {
    return TRUE;
  }

  return FALSE;

}

/*===========================================================================

FUNCTION sdss_set_csg_data

DESCRIPTION
  Sets the CSG ID, CSG RAT and type of PLMN (manual) in SD core.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
void sdss_set_csg_data(sd_ss_e_type                   ss,
                       sys_csg_id_type                csg_id,
                       sys_radio_access_tech_e_type   csg_rat)
{
  sdss_s_type* ss_ptr   = sdss_ptr(ss);

  SD_ASSERT(NULL != ss_ptr);

  if(ss_ptr->csg_id != csg_id
     || ss_ptr->csg_rat != csg_rat)
  {
    SD_MSG_HIGH_3("sdss_set_csg_data | ss = %d, csg_id = %d, csg_rat = %d", ss, csg_id, csg_rat);

    ss_ptr->csg_id   = csg_id;
    ss_ptr->csg_rat  = csg_rat;
  }

  return;
}

/*===========================================================================

FUNCTION sdss_set_non_rplmn_csg_data

DESCRIPTION
  Sets the CSG ID, CSG RAT, net_sel_mode, PLMN and type of PLMN
  (manual) in SD core.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
void sdss_set_non_rplmn_csg_data(sd_ss_e_type                   ss,
                                 sys_csg_id_type                csg_id,
                                 sys_radio_access_tech_e_type   csg_rat,
                     sys_network_selection_mode_e_type  csg_net_sel_mode_type,
                     sys_plmn_id_s_type       csg_plmn,
                 sd_manually_selected_plmn_e_type    csg_man_plmn_type
                     )
{
  sdss_s_type* ss_ptr   = sdss_ptr(ss);

  SD_ASSERT(NULL != ss_ptr);

  sd_rex_enter_crit_sect();

  if(ss != SD_SS_HYBR_1)
  {
     SD_MSG_HIGH_5("sdss_set_non_rplmn_csg_data | ss = %d, csg_id = %d, csg_rat = %d net_sel_mode_type = %d, csg_man_plmn_type = %d", ss, csg_id, csg_rat,
	 	csg_net_sel_mode_type, csg_man_plmn_type);
     
     SD_MSG_HIGH_3("csg_plmn = [0]%x [1]%x [2]%x", csg_plmn.identity[0], csg_plmn.identity[1], csg_plmn.identity[2]);
     ss_ptr->csg_id   = csg_id;
     ss_ptr->csg_rat  = csg_rat;
     ss_ptr->csg_net_sel_mode_type  = csg_net_sel_mode_type;
     memscpy(&ss_ptr->csg_plmn,sizeof(sys_plmn_id_s_type), &csg_plmn,sizeof(sys_plmn_id_s_type));
     ss_ptr->csg_man_plmn_type  = csg_man_plmn_type;
   }

   sd_rex_leave_crit_sect();

  return;
}


/*===========================================================================

FUNCTION sdss_set_rplmn_csg_data

DESCRIPTION
  Sets the CSG ID, CSG RAT, net_sel_mode, PLMN and type of PLMN
  (manual) in SD core.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
void sdss_set_rplmn_csg_data(sd_ss_e_type                   ss,
                             sys_csg_id_type                csg_id,
                             sys_radio_access_tech_e_type   csg_rat,
                 sys_plmn_id_s_type             csg_plmn,
                 sd_ss_srv_req_type_e_type      csg_srv_req_type
                 )
{
  sdss_s_type* ss_ptr   = sdss_ptr(ss);

  SD_ASSERT(NULL != ss_ptr);

  sd_rex_enter_crit_sect();

  if(ss != SD_SS_HYBR_1)
  {
     SD_MSG_HIGH_4("sdss_set_rplmn_csg_data | ss = %d, csg_id = %d, csg_rat = %d csg_srv_req_type = %d ", ss, csg_id, csg_rat, csg_srv_req_type);
     SD_MSG_HIGH_3("csg_plmn = [0]%x [1]%x [2]%x", csg_plmn.identity[0], csg_plmn.identity[1], csg_plmn.identity[2]);
     
     ss_ptr->csg_id   = csg_id;
     ss_ptr->csg_rat  = csg_rat;
     memscpy(&ss_ptr->csg_plmn,sizeof(sys_plmn_id_s_type), &csg_plmn,sizeof(sys_plmn_id_s_type));
     ss_ptr->csg_srv_req_type  = csg_srv_req_type;
   }

   sd_rex_leave_crit_sect();

  return;
}



/*===========================================================================

FUNCTION sdss_restore_csg_info_to_ss_on_wrlf

DESCRIPTION
  Updates the CSG info to ss core when Service loss occurs on WCDMA CSG
  during suitable search period.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
void sdss_restore_csg_info_to_ss_on_wrlf(sd_ss_e_type        ss,
                                         sys_plmn_id_s_type  rplmn,
                                         sd_ss_act_s_type       *true_curr_act,
                                         sd_ss_act_s_type  *rtrn_act_ptr
                                         )
{

  sdss_s_type* ss_ptr   = sdss_ptr(ss);

  SD_ASSERT(NULL != ss_ptr);

  SD_MSG_HIGH_3("sdss_restore_csg_info_to_ss_on_wrlf | ss = %d, stored csg_id = %d, stored csg_rat = %d", ss, ss_ptr->csg_id, ss_ptr->csg_rat);

  /* WRLF handling in Manual CSG mode */
  /*ss_ptr->csg_id shall be INVALID in case of Srv Loss on a Macro or a different CSG */
  if(SYS_CSG_ID_INVALID != ss_ptr->csg_id && ss_ptr->csg_rat == SYS_RAT_UMTS_RADIO_ACCESS
#ifdef FEATURE_WRLF_SYSTEM_SEL
      && (sdss_is_wcdma_suitable_search(ss) == TRUE)
#endif
    )
  {

    SD_MSG_HIGH_3("sdss_restore_csg_info_to_ss_on_wrlf | ss = %d, stored csg_id = %d, stored csg_rat = %d", ss, ss_ptr->csg_id, ss_ptr->csg_rat);
    SD_MSG_HIGH_6("RPLMN  [0]: %x [1]: %x [2]: %x. Stored CSG PLMN  [0]: %x [1]: %x [2]: %x", 
		rplmn.identity[0], rplmn.identity[1], rplmn.identity[2],
		ss_ptr->csg_plmn.identity[0], ss_ptr->csg_plmn.identity[1], ss_ptr->csg_plmn.identity[2]);

    /* If PLMN is Invalid or current RPLMN has changed from last CSG RPLMN */
    if( FALSE == sys_plmn_match(rplmn, ss_ptr->csg_plmn) ||
        FALSE == sys_plmn_id_is_valid(rplmn) )
    {
      /* This is case of non-RPLMN based CSG Selection
       * Hence, change the mode to manual_csg.
       */
      sd_rex_enter_crit_sect();

      SD_MSG_HIGH_0("Restoring Non-RPLMN CSG Info");

      if(NULL != rtrn_act_ptr)
      {
        rtrn_act_ptr->prm.acq_gwl.csg_id  = ss_ptr->csg_id;
        rtrn_act_ptr->prm.acq_gwl.csg_rat = ss_ptr->csg_rat;
        rtrn_act_ptr->prm.acq_gwl.net_sel_type = ss_ptr->csg_net_sel_mode_type;
        memscpy(&rtrn_act_ptr->prm.acq_gwl.plmn,sizeof(sys_plmn_id_s_type), &ss_ptr->csg_plmn, sizeof(sys_plmn_id_s_type));
        rtrn_act_ptr->prm.acq_gwl.selected_plmn_type = ss_ptr->csg_man_plmn_type;
      }

        sdss_set_csg_non_rplmn_selection_type (ss, TRUE);

      if(NULL != true_curr_act)
      {

        true_curr_act->prm.acq_gwl.csg_id  = ss_ptr->csg_id;
        true_curr_act->prm.acq_gwl.csg_rat = ss_ptr->csg_rat;
        true_curr_act->prm.acq_gwl.net_sel_type = ss_ptr->csg_net_sel_mode_type;
        memscpy(&true_curr_act->prm.acq_gwl.plmn,sizeof(sys_plmn_id_s_type), &ss_ptr->csg_plmn, sizeof(sys_plmn_id_s_type));
        true_curr_act->prm.acq_gwl.selected_plmn_type = ss_ptr->csg_man_plmn_type;
      }

       sd_rex_leave_crit_sect();
    }
    else
    {
      /* RPLMN based case */
      sd_rex_enter_crit_sect();

      SD_MSG_HIGH_0("Restoring RPLMN CSG Info");

      if(NULL != true_curr_act)
      {

        true_curr_act->prm.acq_gwl.csg_id  = ss_ptr->csg_id;
        true_curr_act->prm.acq_gwl.csg_rat = ss_ptr->csg_rat;
        true_curr_act->prm.acq_gwl.srv_req_type = SD_SS_SRV_REQ_TYPE_USER_SELECTION_CSG_RPLMN;
        memscpy(&true_curr_act->prm.acq_gwl.plmn,sizeof(sys_plmn_id_s_type), &rplmn,sizeof(sys_plmn_id_s_type));
      }

      if(NULL != rtrn_act_ptr)
      {
        rtrn_act_ptr->prm.acq_gwl.csg_id  = ss_ptr->csg_id;
        rtrn_act_ptr->prm.acq_gwl.csg_rat = ss_ptr->csg_rat;
        rtrn_act_ptr->prm.acq_gwl.srv_req_type = SD_SS_SRV_REQ_TYPE_USER_SELECTION_CSG_RPLMN;
        memscpy(&rtrn_act_ptr->prm.acq_gwl.plmn,sizeof(sys_plmn_id_s_type), &rplmn,sizeof(sys_plmn_id_s_type));
      }

    sd_rex_leave_crit_sect();
    }
  }

 return;

}


/*===========================================================================

FUNCTION sdss_clear_csg_info_on_ss

DESCRIPTION
  Clears the CSG info in ss core.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
void sdss_clear_csg_info_on_ss(sd_ss_e_type        ss,
                               const sys_csg_info_s_type*    csg_info_ptr
                               )
{

  sdss_s_type* ss_ptr   = sdss_ptr(ss);

  SD_ASSERT(NULL != ss_ptr);

    /* Set CSG_ID to INVALID if CSG is different or Cell is Macro */
    if(NULL != csg_info_ptr && ss_ptr->csg_id != SYS_CSG_ID_INVALID)
    {
        SD_MSG_HIGH_4("sdss_clear_csg_info_on_ss | ss = %d, stored csg_id = %d, stored csg_rat = %d csg_info_ptr CSG ID = %d", 
                           ss, ss_ptr->csg_id, ss_ptr->csg_rat,csg_info_ptr->csg_id);
        if(ss_ptr->csg_id != csg_info_ptr->csg_id || csg_info_ptr->csg_id == SYS_CSG_ID_INVALID )
        {
            SD_MSG_HIGH_0("CSG Info cleared ");
            sdss_set_csg_data( ss ,SYS_CSG_ID_INVALID, SYS_RAT_NONE );
         }
         /* else keep the older CSG information to be used for further RLF recovery */
    }

}
/*===========================================================================

FUNCTION sdss_set_csg_non_rplmn_selection_type

DESCRIPTION
  Set whether CSG selection is of RPLMN or non-RPLMN

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
void sdss_set_csg_non_rplmn_selection_type(
                       sd_ss_e_type ss,
                       boolean type
                       )
{
  sdss_s_type* ss_ptr   = sdss_ptr(ss);

  SD_ASSERT(NULL != ss_ptr);

  if(ss_ptr->csg_id != SYS_CSG_ID_INVALID)
  {
    ss_ptr->is_non_rplmn_csg_selection = type;
    SD_MSG_HIGH_3("CSG_ID: %d, set_csg_non_rplmn_selection: %d, ss:%d", ss_ptr->csg_id, type, ss);
  }

  return;
}

/*===========================================================================

FUNCTION sdss_get_non_rplmn_csg_selection_type

DESCRIPTION
  Returns the csg rplmn selection type

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if non rplmn csg,
  FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
boolean sdss_get_non_rplmn_csg_selection_type(
                       sd_ss_e_type ss
                       )
{
  sdss_s_type* ss_ptr   = sdss_ptr(ss);

  SD_ASSERT(NULL != ss_ptr);

  return ss_ptr->is_non_rplmn_csg_selection;
}

/*===========================================================================

  This function matches acquisition type used by active script sending
  acquisition request to 3GPP protocols. The match is done for engine
  on which 3GPP protocol is active - identified by SS.

===========================================================================*/
boolean sdss_match_prev_plmn_acq_type
(
  sd_ss_e_type ss,
    /* Stack on which last acquisition was issued to 3GPP protocol */
  sdss_gwl_acq_e_type acq_type
   /* Acq type that needs to matched with the active engine state info */
)
{
  boolean                match_result = FALSE;
  sdss_eng_stack_s_type  *eng_stack = NULL;
  sdss_eng_s_type        *eng = NULL;
  sdsr_s_type            *sr_ptr = NULL;


  /* Select engine stack for stack instance */
  if(ss == SD_SS_MAIN)
  {
    eng_stack = &sdss_eng_stack;
  }

  #if (defined (FEATURE_TECH_IND_SD_STACK_ARCH) || defined (FEATURE_HDR_HYBRID) )
  if(ss == SD_SS_HYBR_1)
  {
    eng_stack = &sdss_hybr_1_eng_stack;
  }
  #endif

  #if defined FEATURE_MMODE_DUAL_SIM || defined FEATURE_MMODE_SC_SVLTE || defined FEATURE_MMODE_SC_SGLTE
  if(ss == SD_SS_HYBR_2)
  {
    eng_stack = &sdss_hybr_2_eng_stack;
  }
  #endif

  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  if(ss == SD_SS_HYBR_3)
  {
    eng_stack = &sdss_hybr_3_eng_stack;
  }
  #endif

  /* Retrieve active script state with last acquire action */
  eng = sdss_eng_stack_top(eng_stack);
  SD_ASSERT(eng != NULL);

  if( eng == NULL )
  {
    sys_err_fatal_null_ptr_exception();
  }

  if(eng->acq.rtrn_iact.act == SDSS_IACT_ACQUIRE)
  {
    /* First PLMN acquisition applicable only for GWL systems */
    sr_ptr = sdsr_list_get_ptr(eng->acq.rtrn_iact.prm.acq.list,
                                 eng->acq.rtrn_iact.prm.acq.pos);

    /* bail out if sr_ptr record is not found - assumed no match */
    if(sr_ptr == NULL)
    {
      return FALSE;
    }

    if(sr_ptr->sys.mode == SD_MODE_GWL &&
       acq_type == eng->acq.rtrn_iact.prm.acq.gwl_acq_type.acq_type)
    {
      match_result = TRUE;
    }
   }

  return match_result;
}

/*===========================================================================

FUNCTION sdss_valid_acc_term_comb_csfb

DESCRIPTION
  Evaluates to TRUE acc_term & acc_reas combinations are valid.

DEPENDENCIES
  None.

RETURN VALUE
 True : acc_term & acc_reas combinations are valid
 FALSE: acc_term & acc_reas combinations are in valid

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN boolean sdss_valid_acc_term_comb_csfb()
{
  sd_ss_acc_term_e_type acc_term = SD_SS_ACC_TERM_MAX;

  sd_ss_acc_reas_e_type acc_reas = SD_SS_ACC_REAS_MAX;

  acc_term = sdss_ptr(SD_SS_MAIN)->acc_term;
  acc_reas = sdss_ptr(SD_SS_MAIN)->acc_reas;

  if ((acc_reas == SD_SS_ACC_REAS_TRAFFIC) &&
      (acc_term == SD_SS_ACC_TERM_NORMAL))
  {
    return TRUE;
  }

  if ((acc_reas == SD_SS_ACC_REAS_ORIG) ||
      (acc_reas == SD_SS_ACC_REAS_PAGE))
  {

    switch (acc_term)
    {
      case SD_SS_ACC_TERM_TIMEOUT:
      case SD_SS_ACC_TERM_INTERCEPT:
      case SD_SS_ACC_TERM_MS_REL:
      case SD_SS_ACC_TERM_BS_REL:
      case SD_SS_ACC_TERM_REORDER:
      case SD_SS_ACC_TERM_SO_DENIED:
    case SD_SS_ACC_TERM_ACC_FAIL:
    case SD_SS_ACC_TERM_ACC_DEN:
        return TRUE;
        break;

      default:
        SD_MSG_MED_1("Invalid acc_term", acc_term);
        break;
    }
  }

  return FALSE;
}
/*===========================================================================

FUNCTION sdss_read_efs_qmss_enabled()

DESCRIPTION
  Read and decode the Technology order table from EFS.


DEPENDENCIES
  None

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_read_efs_qmss_enabled ( void )
{

  boolean                     efs_qmss_enabled = FALSE;
  int32                       size              = sizeof(efs_qmss_enabled);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Read qmss_enabled flag from EFS
  */
  if(sdefs_read(SDEFS_QMSS_ENABLED, (byte *)&efs_qmss_enabled,&size))
  {
    sdss_common.sd_qmss_enabled = (!efs_qmss_enabled) ? FALSE:TRUE;
  }
  else
  {
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* If reading/decoding failed, use the default value
  */
    SD_MSG_HIGH_0("QMMS: loading dflt value as FALSE");
    sdss_common.sd_qmss_enabled = FALSE;
  }

} /* sdss_read_efs_qmss_enabled() */

/*===========================================================================

FUNCTION sdss_read_efs_full_srv_req_in_emerg()

DESCRIPTION
  Read the FULL_SRV_REQ_IN_EMERG EFS.

DEPENDENCIES
  None

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_read_efs_full_srv_req_in_emerg (
  sys_modem_as_id_e_type asubs_id
)
{

  boolean                     efs_full_srv_req_in_emerg = FALSE;
  int32                       size              = sizeof(boolean);
  if(!(asubs_id >= SYS_MODEM_AS_ID_1 && asubs_id < MAX_SIMS
    && asubs_id < SYS_MODEM_AS_ID_NO_CHANGE))
  {
    asubs_id = SYS_MODEM_AS_ID_1;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Read qmss_enabled flag from EFS
  */
  if(sdefs_fs_read_per_subs(SDEFS_FULL_SRV_REQ_EMERG, (byte *)&efs_full_srv_req_in_emerg,&size, asubs_id))
  {
    sdss_common.sub_config[asubs_id].cfg_full_srv_req_in_emerg = (!efs_full_srv_req_in_emerg) ? FALSE:TRUE;
    SD_MSG_HIGH_1("EFS value for cfg_full_srv_req_in_emerg %d", efs_full_srv_req_in_emerg);
  }
  else
  {
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* If reading/decoding failed, use the default value
  */
  
    SD_MSG_HIGH_0("loading dflt value for full_srv_req_in_emerg_orig ");
    sdss_common.sub_config[asubs_id].cfg_full_srv_req_in_emerg = FALSE;
  }

} /* sdss_read_efs_qmss_enabled() */

/*===========================================================================

FUNCTION sdss_read_efs_emerg_call_after_lu_in_lpm()

DESCRIPTION
  Read the SDEFS_EMERG_CALL_AFTER_LU_IN_LPM EFS.

DEPENDENCIES
  None

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_read_efs_emerg_call_after_lu_in_lpm ( void )
{

  boolean                     efs_emerg_call_after_lu_in_lpm = FALSE;
  int32                       size              = sizeof(boolean);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Read qmss_enabled flag from EFS
  */
  if(sdefs_read(SDEFS_EMERG_CALL_AFTER_LU_IN_LPM, (byte *)&efs_emerg_call_after_lu_in_lpm,&size ))
  {
    sdss_common.cfg_emerg_call_after_lu_in_lpm = (!efs_emerg_call_after_lu_in_lpm) ? FALSE:TRUE;
    SD_MSG_MED_1("EFS value for cfg_emerg_call_after_lu_in_lpm %d", efs_emerg_call_after_lu_in_lpm);
  }
  else
  {
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* If reading/decoding failed, use the default value
  */
    SD_MSG_MED_0("loading dflt value for efs_emerg_call_after_lu_in_lpm ");
    sdss_common.cfg_emerg_call_after_lu_in_lpm = FALSE;
  }

} /* sdss_read_efs_emerg_call_after_lu_in_lpm() */


/*===========================================================================

FUNCTION sdss_read_efs_emerg_call_1x_scan_first()

DESCRIPTION
  Read the SDEFS_EMERG_CALL_1X_SCAN_FIRST EFS.

DEPENDENCIES
  None

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_read_efs_emerg_call_1x_scan_first ( void )
{

  boolean                     efs_emerg_call_1x_scan_first = FALSE;
  int32                       size              = sizeof(boolean);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Read 1x scan first flag from EFS
  */
  if(sdefs_read(SDEFS_EMERG_CALL_1X_SCAN_FIRST, (byte *)&efs_emerg_call_1x_scan_first,&size ))
  {
    sdss_common.cfg_emerg_call_1x_scan_first = (!efs_emerg_call_1x_scan_first) ? FALSE:TRUE;
    SD_MSG_MED_1("EFS value for cfg_emerg_call_1x_scan_first %d", efs_emerg_call_1x_scan_first);  
  }
  else
  {
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* If reading/decoding failed, use the default value
  */
    SD_MSG_MED_0("loading dflt value for cfg_emerg_call_1x_scan_first ");
    sdss_common.cfg_emerg_call_1x_scan_first = FALSE;
  }

} /* sdss_read_efs_emerg_call_1x_scan_first() */

/*===========================================================================

FUNCTION sdss_read_efs_roam_ind_update_in_l_to_1x_ho()

DESCRIPTION
  Read the ROAM_IND_UPDATE_IN_L_TO_1X  EFS.

DEPENDENCIES
  None

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_read_efs_roam_ind_update_in_l_to_1x_ho ( void )
{

  boolean                     efs_roam_ind_update_in_l_to_1x_ho = FALSE;
  int32                       size              = sizeof(boolean);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Read qmss_enabled flag from EFS
  */
  if(sdefs_read(SDEFS_ROAM_IND_UPDATE_IN_L_TO_1X_HO, (byte *)&efs_roam_ind_update_in_l_to_1x_ho,&size ))
  {
    sdss_common.cfg_roam_ind_update_in_l_to_1x_ho = (!efs_roam_ind_update_in_l_to_1x_ho) ? FALSE:TRUE;
    SD_MSG_HIGH_1("EFS value for cfg_roam_ind_update_in_L_to_1x_ho %d", efs_roam_ind_update_in_l_to_1x_ho);
  }
  else
  {
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* If reading/decoding failed, use the default value
  */
  
    SD_MSG_HIGH_0("loading dflt value for roam_ind_update_in_L_to_1x_ho ");
    sdss_common.cfg_roam_ind_update_in_l_to_1x_ho = TRUE;
  }

} /* sdss_read_efs_qmss_enabled() */

/*===========================================================================

FUNCTION sdss_read_efs_scan_scope_rule()

DESCRIPTION
  Read and decode the scan_scope_rule from EFS.


DEPENDENCIES
  None

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_read_efs_scan_scope_rule ( void)
{

  byte                     efs_scan_scope_rule=(byte)SYS_SCAN_SCOPE_RULE_FULL_BAND;
  int32                       size              = sizeof(efs_scan_scope_rule);
  uint16    scan_scope_rule_val = (uint16)SYS_SCAN_SCOPE_RULE_FULL_BAND;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Read scan_scope_rule from EFS
  */
  if(sdefs_fs_read_per_subs(SDEFS_SCAN_SCOPE_RULE, (byte *)&efs_scan_scope_rule,&size, SYS_MODEM_AS_ID_1))
  {
    sdss_common.is_scan_scope_rule_avail = TRUE; /*NV is available on device*/
    if( (efs_scan_scope_rule >= (byte)SYS_SCAN_SCOPE_RULE_FULL_BAND) && (efs_scan_scope_rule < (byte)SYS_SCAN_SCOPE_RULE_MAX))
    {
      sdss_common.sd_scan_scope_rule = (uint16)efs_scan_scope_rule;
      SD_MSG_HIGH_2("scan_scope_rule:loading value: %d, efs value:%d",
        sdss_common.sd_scan_scope_rule,efs_scan_scope_rule);
    }
    else
    {
      sdss_common.sd_scan_scope_rule = (uint16)SYS_SCAN_SCOPE_RULE_FULL_BAND;
      SD_MSG_HIGH_2("scan_scope_rule:loading value: %d, efs value:%d",
        sdss_common.sd_scan_scope_rule,efs_scan_scope_rule);
    }
  }
  else
  {
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    /*NV not configured*/
    sdss_common.is_scan_scope_rule_avail = FALSE; /*NV is available on device*/
    if(sdss_get_operator_name ( SYS_MODEM_AS_ID_1) == SD_OPERATOR_CMCC)
    {
      scan_scope_rule_val = scan_scope_rule_val |
                            SYS_SCAN_SCOPE_RULE_ACQ_DB_RLF |
                            SYS_SCAN_SCOPE_RULE_ACQ_DB_PWR_UP |
                            SYS_SCAN_SCOPE_RULE_ACQ_DB_OOS;
      sdss_common.sd_scan_scope_rule=scan_scope_rule_val;
    }
    else
    {
      /* If reading/decoding failed, use the default value
      */
      SD_MSG_HIGH_0("scan_scope_rule: loading dflt value");
      sdss_common.sd_scan_scope_rule = SYS_SCAN_SCOPE_RULE_FULL_BAND;
    }
  }

} /* sdss_read_efs_scan_scope_rule() */

/*===========================================================================

FUNCTION sdss_read_efs_operator_name()

DESCRIPTION
  Read and decode the Technology order table from EFS.


DEPENDENCIES
  None

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_read_efs_operator_name (
  sys_modem_as_id_e_type asubs_id
)
{

  sd_operator_e_type                     efs_opname;
  int32                    size              = sizeof(efs_opname);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  if(!(asubs_id >= SYS_MODEM_AS_ID_1 && asubs_id < MAX_SIMS
    && asubs_id < SYS_MODEM_AS_ID_NO_CHANGE))
  {
    asubs_id = SYS_MODEM_AS_ID_1;
  }

  /* Read operator name from EFS */
  if(sdefs_fs_read_per_subs(SDEFS_OPERATOR_NAME, (byte *)&efs_opname,&size,asubs_id ))
    {
      /*Processing the buffer*/
    sdss_common.sub_config[asubs_id].sd_operator_name = efs_opname;
    if (!(sdss_common.sub_config[asubs_id].sd_operator_name > SD_OPERATOR_NULL &&
          sdss_common.sub_config[asubs_id].sd_operator_name < SD_OPERATOR_MAX)
        )
      {
      sdss_common.sub_config[asubs_id].sd_operator_name = SD_OPERATOR_NULL;
        SD_MSG_HIGH_2 ("QMSS: operator_name invalid value %d, default to %d",
                  efs_opname, sdss_common.sub_config[asubs_id].sd_operator_name);
      }
      else
      {
        SD_MSG_HIGH_1 ("QMSS: EFS read succ. operator_name = %d",
                    sdss_common.sub_config[asubs_id].sd_operator_name);
    }
  }
  else
  {
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* If reading/decoding failed, use the default value
  */
    SD_MSG_HIGH_0("QMMS: loading dflt value");
    sdss_common.sub_config[asubs_id].sd_operator_name = SD_OPERATOR_NULL;
  }

} /* sdss_read_efs_qmss_enabled() */

/*===========================================================================

FUNCTION sdss_read_ehrpd_opt_redial_enabled()

DESCRIPTION
  Read the efs item to check if the new optimized silent redial feature is enabled or not.

DEPENDENCIES
  None

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_read_ehrpd_opt_redial_enabled ( void )
{

  boolean   feature_enabled = TRUE;
  int32     size = sizeof(feature_enabled);


  /* Read SDEFS_EHRPD_OPT_REDIAL from EFS
  */
  if(sdefs_read(SDEFS_EHRPD_OPT_REDIAL, (byte *)&feature_enabled,&size ))
  {
    SD_MSG_HIGH_1("SDEFS_EHRPD_OPT_REDIAL read success: %d", feature_enabled);
    sdss_common.is_ehrpd_opt_redial = feature_enabled;
  }
  else
  {   
    /* If read failed, use the default value
    */
    SD_MSG_HIGH_0("Default value for EHRPD_OPT_REDIAL");
    sdss_common.is_ehrpd_opt_redial = TRUE;
  }

} /* sdss_read_ehrpd_opt_redial_enabled() */


/*===========================================================================

FUNCTION sdss_read_buffer_int_srv_lost()

DESCRIPTION
  Read and decode the buffer int srv lost from EFS.


DEPENDENCIES
  None

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_read_buffer_int_srv_lost ( void )
{

  boolean                     buffer_int_srv_lost = FALSE;
  int32                       size              = sizeof(buffer_int_srv_lost);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Read qmss_enabled flag from EFS
  */
  if(sdefs_read(SDEFS_BUFFER_INT_SRV_LOST, (byte *)&buffer_int_srv_lost,&size ))
  {
    sdss_common.buffer_int_srv_lost = (!buffer_int_srv_lost) ? FALSE:TRUE;
  }
  else
  {
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* If reading/decoding failed, use the default value
  */
    SD_MSG_HIGH_0("BUFFER_INT_SRV_LOST: loading dflt value TRUE");
    sdss_common.buffer_int_srv_lost = TRUE;
  }

} /* sdss_read_efs_qmss_enabled() */

/*===========================================================================

FUNCTION sdss_get_operator_name

DESCRIPTION
  Get Operator Name for QRD Features

DEPENDENCIES

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
extern          sd_operator_e_type sdss_get_operator_name(
                sys_modem_as_id_e_type asubs_id
)
{
  if( ( asubs_id > SYS_MODEM_AS_ID_NONE) && (asubs_id < MAX_SIMS) )
  {
    /* Generic - The Subscriptions are added between SYS_MODEM_AS_ID_NONE(-1)
       and SYS_MODEM_AS_ID_NO_CHANGE
      */
    if(sdss_common.sub_config[asubs_id].sd_operator_name != SD_OPERATOR_NULL)
    {
      SD_MSG_HIGH_2( "sdss_get_operator_name() asubs_id=%d,operator=%d", asubs_id,
             sdss_common.sub_config[asubs_id].sd_operator_name);
    }
    return sdss_common.sub_config[asubs_id].sd_operator_name;
  }
  else
  {
    SD_ERR_1("sdss_get_operator_name(), Invalid asubs_id = ",asubs_id);
    return SD_OPERATOR_NULL;
  }

}

/*===========================================================================

FUNCTION sdss_read_efs_customer_emerg_info()

DESCRIPTION
  Read custom emergency info from EFS..


DEPENDENCIES
  None

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_read_efs_customer_emerg_info ( sys_modem_as_id_e_type asubs_id )
{

  sd_custom_emerg_call_info_s_type  e911_info = {0};
  int32 size = sizeof(sd_custom_emerg_call_info_s_type);
  if(!(asubs_id >= SYS_MODEM_AS_ID_1 && asubs_id < MAX_SIMS
    && asubs_id < SYS_MODEM_AS_ID_NO_CHANGE))
  {
    asubs_id = SYS_MODEM_AS_ID_1;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Read custom emerg info from EFS.
  */
  if(!sdefs_fs_read_per_subs(SDEFS_CUSTOM_EMERG_INFO, (byte*)&e911_info, &size, asubs_id))
  {
    SD_MSG_LOW_0("CUSTOM_EMERG_INFO read failed, setting values to default FALSE!");
    sdss_common.sub_config[asubs_id].is_ral_stored_in_efs = FALSE;
    sdss_common.sub_config[asubs_id].is_alternate_redial_algorithm = FALSE;
  }
  else
  {
    sdss_common.sub_config[asubs_id].is_ral_stored_in_efs = e911_info.is_ral_stored_in_efs;
    sdss_common.sub_config[asubs_id].is_alternate_redial_algorithm = e911_info.is_alternate_redial_algorithm;
    SD_MSG_HIGH_2("CUSTOM_EMERG_INFO Info: is_alternate_redial_algorithm %d,is_ral_stored_in_efs %d ",
    sdss_common.sub_config[asubs_id].is_alternate_redial_algorithm, 
    sdss_common.sub_config[asubs_id].is_ral_stored_in_efs);
  }
} /* sdss_read_efs_customer_emerg_info() */

/*===========================================================================

FUNCTION sdss_read_efs_custom_vowifi_config()

DESCRIPTION
  Read custom vowifi config from EFS..


DEPENDENCIES
  None

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_read_efs_custom_vowifi_config ( sys_modem_as_id_e_type asubs_id )
{

  sd_custom_vowifi_config_s_type wifi_config = {0};
  int32 size = sizeof(sd_custom_vowifi_config_s_type );
  if(!(asubs_id >= SYS_MODEM_AS_ID_1 && asubs_id < MAX_SIMS
    && asubs_id < SYS_MODEM_AS_ID_NO_CHANGE))
  {
    asubs_id = SYS_MODEM_AS_ID_1;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Read custom emerg info from EFS.
  */
  if(!sdefs_fs_read_per_subs(SDEFS_CUSTOM_VOWIFI_CONFIG, (byte*)&wifi_config, &size, asubs_id))
  {
    SD_MSG_HIGH_0("CUSTOM VOWIFI CONFIG read failed, setting values to default FALSE!");
    sdss_common.sub_config[asubs_id].wifi_e911_wwan_full_srv = FALSE;
  }
  else
  {
    sdss_common.sub_config[asubs_id].wifi_e911_wwan_full_srv = wifi_config.wifi_e911_wwan_full_srv;
    SD_MSG_HIGH_1("CUSTOM VOWIFI CONFIG wifi_e911_wwan_full_srv %d",
    sdss_common.sub_config[asubs_id].wifi_e911_wwan_full_srv);
  }
} /* sdss_read_efs_customer_emerg_info() */


/*===========================================================================

FUNCTION sdss_is_ral_stored_in_efs

DESCRIPTION
  Tells if is_ral_stored_in_efs feature is enabled via custom_emerg_info

DEPENDENCIES

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN boolean sdss_is_ral_stored_in_efs(sd_ss_e_type ss)
{
  sys_modem_as_id_e_type asubs_id = sdss_map_ss_to_as_id(ss);
  if(!(asubs_id >= SYS_MODEM_AS_ID_1 && asubs_id < MAX_SIMS
    && asubs_id < SYS_MODEM_AS_ID_NO_CHANGE))
{
    SD_MSG_HIGH_2("sdss_is_ral_stored_in_efs(), ss=%d, invalid asubs_id=%d",ss,asubs_id);
    asubs_id = SYS_MODEM_AS_ID_1;
  }

  return sdss_common.sub_config[asubs_id].is_ral_stored_in_efs;
}


/*===========================================================================

FUNCTION sdss_is_wifi_e911_wwan_full_srv

DESCRIPTION
  Tells if is_ral_stored_in_efs feature is enabled via custom_emerg_info

DEPENDENCIES

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN boolean sdss_is_wifi_e911_wwan_full_srv(sd_ss_e_type ss)
{
  sys_modem_as_id_e_type asubs_id = sdss_map_ss_to_as_id(ss);
  if(!(asubs_id >= SYS_MODEM_AS_ID_1 && asubs_id < MAX_SIMS
    && asubs_id < SYS_MODEM_AS_ID_NO_CHANGE))
  {
    SD_MSG_HIGH_2("sdss_is_wifi_e911_wwan_full_srv(), ss=%d, invalid asubs_id=%d",ss,asubs_id);
    asubs_id = SYS_MODEM_AS_ID_1;
  }

  return sdss_common.sub_config[asubs_id].wifi_e911_wwan_full_srv;
}

/*===========================================================================

FUNCTION sdss_is_e911_alternate_redial_algorithm

DESCRIPTION
  Tells if is_alternate_redial_algorithm feature is enabled via custom_emerg_info

DEPENDENCIES

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN boolean sdss_is_e911_alternate_redial_algorithm(sd_ss_e_type ss)
{
  sys_modem_as_id_e_type asubs_id = sdss_map_ss_to_as_id(ss);
  if(!(asubs_id >= SYS_MODEM_AS_ID_1 && asubs_id < MAX_SIMS
    && asubs_id < SYS_MODEM_AS_ID_NO_CHANGE))
  {
    asubs_id = SYS_MODEM_AS_ID_1;
  }

  return sdss_common.sub_config[asubs_id].is_alternate_redial_algorithm;
}



/*===========================================================================

FUNCTION sdss_map_ss_to_as_id

DESCRIPTION
  Maps SD SS to as_id

DEPENDENCIES
  None

RETURN VALUE
  subscription id

SIDE EFFECTS
  None.

===========================================================================*/

sys_modem_as_id_e_type sdss_map_ss_to_as_id(

  sd_ss_e_type       ss
)
{
  if (!sdss_is_featuremode(SYS_OVERALL_FEATURE_MODE_MULTISIM))
  {
    return SYS_MODEM_AS_ID_1;
  }

  switch(ss)
  {
    case SD_SS_MAIN:
    case SD_SS_HYBR_1:
      return SYS_MODEM_AS_ID_1;

    case SD_SS_HYBR_2:
      if(sdss_is_sxlte())
      {
        return SYS_MODEM_AS_ID_1;
      }
      else
      {
        return SYS_MODEM_AS_ID_2;
      }

    case SD_SS_HYBR_3:
      if(sdss_is_sxlte())
      {
        return SYS_MODEM_AS_ID_2;
      }
      else
      {
        return SYS_MODEM_AS_ID_3;
      }

    case SD_SS_MAX:
    default:
      SD_ERR_1("Invalid ss %d",ss);
      return SYS_MODEM_AS_ID_MAX;
  }
}


/*===========================================================================

FUNCTION sdss_1xcsfb_ecbm_init

DESCRIPTION
  Read the values that is stored in EFS.

DEPENDENCIES
  sdefs_init() must have already been called to initialize the SD EFS-Interface
  component.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/

EXTERN void sdss_1xcsfb_ecbm_init(void)
{

  boolean                     efs_1xcsfb_ecbm_enabled = FALSE;
  int32                       size              = sizeof(efs_1xcsfb_ecbm_enabled);

  sdss_s_type   *ss_ptr   = NULL;

  ss_ptr = sdss_ptr(SD_SS_MAIN);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Read 1xcsfb_ecbm_enabled flag from EFS
  */
  if(sdefs_read(SDEFS_1XCSFB_ECBM, (byte *)&efs_1xcsfb_ecbm_enabled,&size ))
  {
    SD_MSG_HIGH_1("1XCSFB_ECBM: Value read from NV is %d\n:",efs_1xcsfb_ecbm_enabled);
    ss_ptr->is_1xcsfb_ecbm_supp = efs_1xcsfb_ecbm_enabled;
  }
  else
  {
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    /* If reading/decoding failed, use the default value */
    #ifdef FEATURE_CUST_1 
      ss_ptr->is_1xcsfb_ecbm_supp = TRUE;
    #else
      ss_ptr->is_1xcsfb_ecbm_supp = FALSE;
    #endif
    SD_MSG_HIGH_1("1XCSFB_ECBM: loading dflt value %d", ss_ptr->is_1xcsfb_ecbm_supp );

  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

}

/*===========================================================================

FUNCTION sdss_1xcsfb_call_end_opt_init

DESCRIPTION
  Read the values that is stored in EFS.

DEPENDENCIES
  sdefs_init() must have already been called to initialize the SD EFS-Interface
  component.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/

EXTERN void sdss_1xcsfb_call_end_opt_init(void)
{

  boolean         is_1xcsfb_call_end_opt = FALSE;
  int32           size                   = sizeof(boolean);
  sdss_s_type     *ss_ptr                = NULL;

  ss_ptr = sdss_ptr(SD_SS_MAIN);


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Read 1xcsfb_ecbm_enabled flag from EFS
  */
  if(sdefs_read(SDEFS_1XCSFB_CALL_END_OPT, (byte *)&is_1xcsfb_call_end_opt, &size))
  {
    SD_MSG_HIGH_1("1XCSFB_CALL_END_OPT: Value read from NV is %d\n:",is_1xcsfb_call_end_opt);
    ss_ptr->is_1xcsfb_call_end_opt = is_1xcsfb_call_end_opt;
  }
  else
  {
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    /* If reading/decoding failed, use the default value */
    SD_MSG_HIGH_0("1XCSFB_CALL_END_OPT: loading dflt value");
    ss_ptr->is_1xcsfb_call_end_opt = FALSE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

}


/*===========================================================================

FUNCTION sdss_get_1xcsfb_call_end_opt_status

DESCRIPTION
  Read the values that is stored in EFS.

DEPENDENCIES
  sdefs_init() must have already been called to initialize the SD EFS-Interface
  component.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/

EXTERN boolean sdss_get_1xcsfb_call_end_opt_status(void)
{
  return sdss_ptr(SD_SS_MAIN)->is_1xcsfb_call_end_opt;
}

/*===========================================================================

FUNCTION sdss_is_skip_mmss_srv_req

DESCRIPTION
  Don't set MMSS service request type if more preferred list has no 3gpp2 sys.

DEPENDENCIES
  None.

RETURN VALUE


SIDE EFFECTS
  None.

===========================================================================*/
EXTERN boolean sdss_is_skip_mmss_srv_req( sd_ss_e_type  ss, sd_ss_act_s_type      *ss_act_ptr)
{
  boolean ret_val = FALSE;
  sd_si_info_s_type     *si_info_ptr = &sd_si_ptr(SD_SS_MAIN)->si_info;;

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  SD_ASSERT( ss_act_ptr != NULL )
  /*Don't need to send MMSS service request type is more preferred scan has no 3GPP2 sys */
  if(sdss_eng_stack_get_state(SD_SS_MAIN) == SDSS_ACQ_STT_MORE_PREF &&
    !sdsr_is_list_contain_mode(SDSR_START_PREF_LST, SD_SS_MODE_PREF_CDMA_HDR))
  {
    /* If 3GPP2 service is acquired, then do not skip MMSS service request */
    if( sys_srv_status_is_srv(si_info_ptr->srv_status) && !sd_misc_is_mode_3gpp(si_info_ptr->mode) )
    {
      ret_val = FALSE;
    }
    /* in OOS case, do not skip MMSS service request */
    else if(!sys_srv_status_is_srv(si_info_ptr->srv_status))
    {
      ret_val = FALSE;
    }
    else
    {
    SD_MSG_LOW_0("skip_mmss_type");
      ret_val = TRUE;
  }
  }

  if(ss_act_ptr->prm.acq_gwl.srv_req_type != SD_SS_SRV_REQ_TYPE_SYSTEM_CHANGE)
  {
      /* If resel_mode is FULL(any stage) and BPLMN reselection timer is running, if user changes preferences
         capable of MMSS operation (3GPP+3GPP2), always give preference to user selection and send SRV_REQ of 
         type MMSS_RPLMN or MMSS to acquire the avaialable HPLMN/VPLMN quickly and later do BSR, 
         otherwise if resel_mode is FULL and there is no user activity, skip MMSS srv-req */

      if(sdss_is_resel_mode_full(ss))
      {
        SD_MSG_LOW_1("skip_mmss_type due to resel_mode srv_req_type %d", ss_act_ptr->prm.acq_gwl.srv_req_type);
        ret_val = TRUE;
      }
  }
  return ret_val;
}
/*===========================================================================

FUNCTION sdss_is_mru_3gpp

DESCRIPTION
  Check if MRU[0] is 3gpp sys

DEPENDENCIES
  None.

RETURN VALUE

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN boolean sdss_is_mru_3gpp(sd_ss_e_type ss)
{
  sdsr_s_type *my_list_ptr;

  my_list_ptr = sdsr_list_get_ptr(sdss_sr_list_map2(ss,SDSR_MRU_LST),0);
  if( my_list_ptr != NULL) {
  if((sdsr_list_cnt(sdss_sr_list_map2(ss,SDSR_MRU_LST)) > 0) &&
         sd_misc_is_mode_3gpp(my_list_ptr->sys.mode))
  {
    SD_MSG_LOW_1("mru[0] is 3gpp on ss %d",ss);
    return TRUE;
  }
  }
  else
  {
    SD_MSG_HIGH_0("NULL ptr returned in sdsr_list_get_ptr()");
  }

  my_list_ptr = sdsr_list_get_ptr(SDSR_MRU_LST,0);
  if(my_list_ptr != NULL) {
  if((sdsr_list_cnt(SDSR_MRU_LST) > 0) &&
         sd_misc_is_mode_3gpp(my_list_ptr->sys.mode))
  {
    SD_MSG_LOW_0("mru[0] is 3gpp on main");
    return TRUE;
  }
  }
  else
  {
    SD_MSG_HIGH_0("NULL ptr returned in sdsr_list_get_ptr()");
  }

  return FALSE;
}

/*===========================================================================

FUNCTION sdss_is_other_ss_in_srv

DESCRIPTION
  Check if other ss is in srv or not

DEPENDENCIES
  None.

RETURN VALUE

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN sd_ss_e_type sdss_is_other_ss_in_srv(sd_ss_e_type ss)
{
    sd_ss_e_type other_ss1 = SD_SS_MAIN;
    #if defined(FEATURE_MMODE_TRIPLE_SIM) 
    sd_ss_e_type other_ss2 = SD_SS_MAIN;
    #endif

    if (ss == SD_SS_MAIN)
    {
      other_ss1 = SD_SS_HYBR_2;
      #if defined(FEATURE_MMODE_TRIPLE_SIM)
      other_ss2 = SD_SS_HYBR_3;
      #endif

      #if defined(FEATURE_MMODE_SXLTE_G)
      if(sdss_is_sxlte())
      {
        other_ss1 = SD_SS_HYBR_3;
      }
      #endif
    }
    else if (ss == SD_SS_HYBR_2)
    {
      other_ss1 = SD_SS_MAIN;

      #if defined(FEATURE_MMODE_TRIPLE_SIM)
      other_ss2 = SD_SS_HYBR_3;
      #endif

      #if defined(FEATURE_MMODE_SXLTE_G)
      if(sdss_is_sxlte())
      {
        other_ss1 = SD_SS_HYBR_3;
      }
      #endif

    }

    #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
    else if (ss == SD_SS_HYBR_3)
    {
      other_ss1 = SD_SS_MAIN;
	  #if defined(FEATURE_MMODE_TRIPLE_SIM)
      if(!sdss_is_sxlte())
      {
        other_ss2 = SD_SS_HYBR_2;
      }
	 #endif
    }
    #endif

    if(sdss_ptr(other_ss1)->srv_status != SYS_SRV_STATUS_NO_SRV &&
       sdss_ptr(other_ss1)->srv_status != SYS_SRV_STATUS_PWR_SAVE &&
       sdss_ptr(other_ss1)->srv_status != SYS_SRV_STATUS_NO_SRV_INTERNAL)
    {
       SD_MSG_HIGH_3("other_ss is in srv ss=%d, srv_status=%d, passed ss=%d",other_ss1,sdss_ptr(other_ss1)->srv_status,ss);
       return other_ss1;
    }

    #if defined(FEATURE_MMODE_TRIPLE_SIM)
    if(sdss_ptr(other_ss2)->srv_status != SYS_SRV_STATUS_NO_SRV &&
       sdss_ptr(other_ss2)->srv_status != SYS_SRV_STATUS_PWR_SAVE &&
       sdss_ptr(other_ss2)->srv_status != SYS_SRV_STATUS_NO_SRV_INTERNAL)
  {
       SD_MSG_HIGH_3("other_ss is in srv ss=%d, srv_status=%d, passed ss=%d",other_ss2,sdss_ptr(other_ss2)->srv_status,ss);
          return other_ss2;
  }
    #endif
    SD_MSG_HIGH_2("other_ss is not in srv passed ss=%d, srv_status=%d",ss,sdss_ptr(ss)->srv_status);
  return SD_SS_MAX;
}

/*===========================================================================

FUNCTION sdss_filter_sr_with_supported_band_mode

DESCRIPTION
  This function filtered the sr_ptr record with the correct band/mode
  capability

DEPENDENCIES
  None.

RETURN VALUE
 sr_ptr

SIDE EFFECTS
  None.

===========================================================================*/
void sdss_filter_sr_with_supported_band_mode
(
  sdsr_s_type              *sr_ptr,
    /* The sr_ptr which we want to filter */

  sd_ss_mode_pref_e_type    mode_pref
    /* mode preference which we want to filter */

)
{
  if(sr_ptr == NULL)
  {
    return;
  }

  /* Filters the system band within the target capability.
  */
  sr_ptr->sys.band = sdss_get_supp_band_pref(sr_ptr->sys.band);

  #ifdef FEATURE_SD_LTE
  sr_ptr->sys.lte_band = sdsr_map_lte_band_pref_to_sys_rec_lte_band(
                            sdss_get_supp_lte_band_pref(
                               sdsr_map_sys_rec_lte_band_to_lte_band_pref(sr_ptr->sys.lte_band)
                            )
                         );
  sr_ptr->sys.tds_band = sdss_get_supp_tds_band_pref(sr_ptr->sys.tds_band);
  #endif

  /* Filters the system band within the system mode preference.
  */
  sr_ptr->sys.band = sdss_get_supp_mode_band_pref(
                  sdss_map_mode_to_mode_pref(sr_ptr->sys.mode),
                  sr_ptr->sys.band);

  #ifdef FEATURE_SD_LTE
  sr_ptr->sys.lte_band = sdsr_map_lte_band_pref_to_sys_rec_lte_band(
                            sdss_get_supp_mode_band_pref_lte(
                            sdss_map_mode_to_mode_pref(sr_ptr->sys.mode),
                                  sdsr_map_sys_rec_lte_band_to_lte_band_pref(sr_ptr->sys.lte_band)
                            )
                         );

  sr_ptr->sys.tds_band = sdss_get_supp_mode_band_pref_tds(
                  sdss_map_mode_to_mode_pref(sr_ptr->sys.mode),
                  sr_ptr->sys.tds_band);
  #endif

  /* Filters the system band within the mode preference.
  */
  sr_ptr->sys.band = sdss_get_supp_mode_band_pref(mode_pref,sr_ptr->sys.band);

  #ifdef FEATURE_SD_LTE
  sr_ptr->sys.lte_band = sdsr_map_lte_band_pref_to_sys_rec_lte_band(
                           sdss_get_supp_mode_band_pref_lte(mode_pref,
                             sdsr_map_sys_rec_lte_band_to_lte_band_pref(sr_ptr->sys.lte_band)
                           )
                         );
  sr_ptr->sys.tds_band = sdss_get_supp_mode_band_pref_tds(mode_pref,sr_ptr->sys.tds_band);
  #endif

}

/*===========================================================================

FUNCTION sdss_set_remove_gwl_on_bsr

DESCRIPTION
  Centralized function setting "remove_gwl_on_bsr" flag. For usage of this flag
  please check its definition

DEPENDENCIES
  None.

RETURN VALUE
 None.

SIDE EFFECTS
  None.

===========================================================================*/
void  sdss_set_remove_gwl_on_bsr ( sd_ss_e_type ss , boolean val )
{
  if( sdss_ptr(ss)->remove_gwl_on_bsr != val )
  {
    SD_MSG_HIGH_2("Set gwl_remove_on_bsr to %d - ss=%d", val, ss);
    sdss_ptr(ss)->remove_gwl_on_bsr = val;
  }
}


/* <EJECT> */
/*===========================================================================

FUNCTION sdss_acq_event_proc_internal

DESCRIPTION
  internal event proc to check if the sys is allowed to camp.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the sys is allowed to camp
  False if more pref scan is needed

SIDE EFFECTS
  None.

===========================================================================*/
boolean                 sdss_acq_event_proc_internal()
{
   sdss_eng_s_type         *eng_ptr = NULL;
  sd_ss_mode_pref_e_type  mode_pref;
  sd_ss_band_pref_e_type  band_pref;
  sys_lte_band_mask_e_type  lte_band_pref;
  sd_ss_band_pref_e_type  tds_band_pref;
  sdss_iact_s_type		  rtrn_iact;


  eng_ptr = sdss_eng_stack_top(&sdss_eng_stack );
  
  if(eng_ptr==NULL)
  {
    SD_ERR_FATAL_0("invalid pointer");//KW_RNPD_DEREF
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


  sdss_get_mode_band_pref( eng_ptr->ss,
                           &mode_pref,
                           &band_pref,
                           &lte_band_pref,
                           &tds_band_pref );




	  /* Check if there are more systems in the list. */
      sdss_acq_event_proc( &eng_ptr->acq,
                                             &eng_ptr->scr_timer,
                                             eng_ptr->acq_mode,
                                             SDSS_EVT_GWL_ACQ_PLMN_SUCCESS,
                                                         mode_pref,
                                                         band_pref,
                                                         lte_band_pref,
                                                         tds_band_pref,
                                             eng_ptr->ss_ptr->roam_pref,
                                             &rtrn_iact );

  SD_MSG_HIGH_3("sdss_acq_event_proc_internal: rtrn_iact : %d,acq_state: %d,pref_pos:%d",
		             rtrn_iact.act,eng_ptr->acq.state,eng_ptr->acq.pref_pos);
 /* update pref pos, so that right system is being compared 
     against during SRV CNF */
   if(eng_ptr->acq.pref_pos!= SDSR_POS_NULL)
   {
    eng_ptr->acq.pref_pos     = eng_ptr->acq.pref_pos-1;
   }


   /*  State moves to DONE  when no system is available to scan in pref list
     (START->DONE scenario's). */
  return (eng_ptr->acq.state == SDSS_ACQ_STT_DONE) ;

}

/*===========================================================================
FUNCTION sdss_get_scan_scope_type

DESCRIPTION
  Get the scan scope type in SS as indicated.

DEPENDENCIES
  None.

RETURN VALUE
  sys_scan_scope_e_type - Scan scope

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sys_scan_scope_e_type     sdss_get_scan_scope_type (

        sd_ss_e_type                  ss
          /* System selection stack
          */
)
{
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  return sdss_ptr(ss)->scan_scope;
}


/*===========================================================================
FUNCTION sdss_set_scan_scope_type

DESCRIPTION
  Set the Scan scope type in SS as indicated.

DEPENDENCIES
  None.

RETURN VALUE
  None

SIDE EFFECTS
  None.

===========================================================================*/
/*lint --e{528} suppress sdss_set_scan_scope_type not referenced
** warning
*/
EXTERN  void                          sdss_set_scan_scope_type (

        sd_ss_e_type                  ss,
          /* System selection stack
          */

        sys_scan_scope_e_type     scan_scope_type
)
/*lint -esym(715,ss_ptr) */
/*lint -esym(818,ss_ptr) */
/*lint -esym(715,scan_scope_type) */
{
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  SD_ASSERT_ENUM_IS_INRANGE( scan_scope_type, SYS_SCAN_SCOPE_MAX );

  if(sdss_ptr(ss)->scan_scope != scan_scope_type)
  {
    SD_MSG_HIGH_2("SDSS:FRFL: Updating ss= %d scan_scope= %d",ss,scan_scope_type);
    sdss_ptr(ss)->scan_scope = scan_scope_type;
  }

  return;
}


/*===========================================================================
FUNCTION sdss_toggle_scan_scope_type

DESCRIPTION
  Toggle the scan scope type in SS.

DEPENDENCIES
  None.

RETURN VALUE
  None

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void     sdss_toggle_scan_scope_type (

        sd_ss_e_type                  ss
          /* System selection stack
          */
)
{
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  if(sdss_get_scan_scope_type(ss) == SYS_SCAN_SCOPE_FULL_BAND)
  {
     SD_MSG_HIGH_1("SDSS: Toggling ss= %d scan_scope to ACQ_DB",ss);
     sdss_set_scan_scope_type(ss, SYS_SCAN_SCOPE_ACQ_DB);
  }
  else
  {
     SD_MSG_HIGH_1("SDSS: Toggling ss= %d scan_scope to FULL_BAND",ss);
     sdss_set_scan_scope_type(ss, SYS_SCAN_SCOPE_FULL_BAND);
  }

  return;
}
/*===========================================================================

FUNCTION sdss_print_plmns

DESCRIPTION
  debug util function to print the plmn ids provided sd_splmn_info_list_s *.  

DEPENDENCIES
  None.

RETURN VALUE
  void

SIDE EFFECTS
  None.

===========================================================================*/
static void sdss_print_plmns(sd_splmn_info_list_s *splmn_info_ptr)
{
  boolean               plmn_is_undefined;
  boolean               mnc_includes_pcs_digit;
  sys_mcc_type          mcc;
  sys_mnc_type          mnc;
  int                   idx;

  SD_MSG_HIGH_1("C2k_resel_splmn:sdss_print_plmns num_splmns = %d",splmn_info_ptr->num_splmn);
  for(idx=0;idx<splmn_info_ptr->num_splmn;idx++)
  {
    sys_plmn_get_mcc_mnc(splmn_info_ptr->splmns_list[idx],&plmn_is_undefined,&mnc_includes_pcs_digit,&mcc,&mnc);

	if(!plmn_is_undefined)
	SD_MSG_HIGH_3("idx=%d MCC=%d MNC=%d",idx,mcc,mnc);
  }

}

/*===========================================================================
FUNCTION sdss_clear_splmns

DESCRIPTION
  clears splmns received for 'sys_mode' protocol.  

RETURN VALUE
  void
===========================================================================*/
static void sdss_clear_splmns(sys_sys_mode_e_type sys_mode)
{
  int ix;
  int temp_cnt;
  sys_plmn_id_s_type temp_plmn_lst[SD_MAX_SPLMN_IDS];
  sys_sys_mode_e_type retain_sys;
  
  SD_MSG_HIGH_2( "C2k_resel_splmn:sdss_clear_splmns sys_mode %d sdss_common.splmn_num %d",sys_mode,sdss_common.splmn_num);

  if(sdss_common.splmn_num == 0)
  	return;

  if(sys_mode == SYS_SYS_MODE_CDMA)
  {
  	retain_sys = SYS_SYS_MODE_HDR;
  }
  else if(sys_mode == SYS_SYS_MODE_HDR)
  {   
 	retain_sys = SYS_SYS_MODE_CDMA;
  }
  else
  	return;
  
  for(ix=0,temp_cnt=0;ix<sdss_common.splmn_num;ix++)
  {
    if(sdss_common.splmns[ix].sys == retain_sys)
    {
      temp_plmn_lst[temp_cnt] = sdss_common.splmns[ix].splmn; 
	  temp_cnt++;
    }
  }

  if(temp_cnt == ix)
  	return;//all plmns belong to retain sys

  memset((byte *)&sdss_common.splmns[0],0,SD_MAX_SPLMN_IDS * sizeof(sdss_splmn_rat_info_type));
  sdss_common.splmn_num=0;

  for(ix=0;ix<temp_cnt;ix++)
  {
   sdss_common.splmns[ix].splmn = temp_plmn_lst[ix];
   sdss_common.splmns[ix].sys = retain_sys;
  }
  sdss_common.splmn_num = temp_cnt;

}
/*===========================================================================
FUNCTION sdss_reset_splmn_info

DESCRIPTION
  resets splmn info.  

RETURN VALUE
  void
===========================================================================*/
EXTERN void sdss_reset_splmn_info(sys_sys_mode_e_type sys_mode)
{
  sd_ss_e_type ss = SD_SS_MAIN;
  int ix;
  int temp_cnt;
  sys_plmn_id_s_type temp_plmn_lst[SD_MAX_SPLMN_IDS];
  sys_sys_mode_e_type retain_sys;
  sd_splmn_info_list_s temp_sd_splmn_info;
  
  SD_MSG_HIGH_2( "C2k_resel_splmn:sdss_reset_splmn_info sys_mode %d sdss_common.splmn_num %d",sys_mode,sdss_common.splmn_num);

  if(sdss_common.splmn_num == 0)
  	return;

  if(sys_mode == SYS_SYS_MODE_CDMA)
  {
    ss = SD_SS_HYBR_1; 
  	retain_sys = SYS_SYS_MODE_HDR;
  }
  else if(sys_mode == SYS_SYS_MODE_HDR)
  {
    ss = SD_SS_MAIN;    
 	retain_sys = SYS_SYS_MODE_CDMA;
  }
  else
  	return;
  
  for(ix=0,temp_cnt=0;ix<sdss_common.splmn_num;ix++)
  {
    if(sdss_common.splmns[ix].sys == retain_sys)
    {
      temp_plmn_lst[temp_cnt] = sdss_common.splmns[ix].splmn; 
	  temp_cnt++;
    }
  }

  if(temp_cnt == ix)
  	return;//all plmns belong to retain sys

  memset((byte *)&sdss_common.splmns[0],0,SD_MAX_SPLMN_IDS * sizeof(sdss_splmn_rat_info_type));
  sdss_common.splmn_num=0;

  for(ix=0;ix<temp_cnt;ix++)
  {
   sdss_common.splmns[ix].splmn=temp_plmn_lst[ix];
   temp_sd_splmn_info.splmns_list[ix] = temp_plmn_lst[ix];
   sdss_common.splmns[ix].sys=retain_sys;
  }
  sdss_common.splmn_num = temp_cnt;
  temp_sd_splmn_info.num_splmn = temp_cnt;

  sdprl_free_gwl_more_pref_list( sys_mode);
  	
  sdprl_get_more_pref_ref(ss,&temp_sd_splmn_info);

}

/*===========================================================================

FUNCTION sdss_splmn_info_proc

DESCRIPTION
  processes the splmn info received from 1x or DO and updates.  

DEPENDENCIES
  None.

RETURN VALUE
  void

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_splmn_info_proc(sd_splmn_info_list_s *splmn_info_ptr,boolean is_from_1x)
{
  sd_ss_e_type ss = SD_SS_MAIN;
  int ix=0;
  sd_splmn_info_list_s splmn_info;
  
  if(splmn_info_ptr == NULL)
  	return;

  if(!sdss_common.c2k_resel_splmn_supp)
  {
   SD_MSG_HIGH_0("C2k_resel_splmn:Ignoring splmns as feature not turned on in EFS");
   return;
  }

  if(sdss_is_1x_sxlte() && 
     sd_misc_get_ss_for_mode(SYS_SYS_MODE_LTE) == SD_SS_HYBR_2 && 
     is_from_1x)
  {
  	SD_MSG_HIGH_0("C2k_resel_splmn:Ignoring splmns from 1x in SVLTE mode");
  	return;
  }
  	
  if(!is_from_1x)
  {
#if !defined FEATURE_HDR_HYBRID
  return;
#else
    ss = SD_SS_HYBR_1;
#endif
  }

  if(is_from_1x == TRUE)
    sdss_common.last_splmn_rx_mode = SYS_SYS_MODE_CDMA;
  else
    sdss_common.last_splmn_rx_mode = SYS_SYS_MODE_HDR;

  if(splmn_info_ptr->num_splmn > SD_MAX_SPLMN_IDS)
  {
    SD_MSG_HIGH_1( "C2k_resel_splmn: invalid num of SPLMNs received %d",splmn_info_ptr->num_splmn );
	return;
  }
  else if(splmn_info_ptr->num_splmn == 0)
  {
    //sdss_clear_splmns(sdss_common.last_splmn_rx_mode);
    sdss_reset_splmn_info(sdss_common.last_splmn_rx_mode);
    SD_MSG_HIGH_0( "C2k_resel_splmn: zero SPLMNs received ");
    return;
  }
  else
  {
    //TBD: remove below print plmns after FR is tested
    sdss_print_plmns(splmn_info_ptr);
    sdss_clear_splmns(sdss_common.last_splmn_rx_mode);
    for(ix=0;ix<splmn_info_ptr->num_splmn;ix++)
    {
      sdss_common.splmns[sdss_common.splmn_num + ix].splmn = splmn_info_ptr->splmns_list[ix];
      sdss_common.splmns[sdss_common.splmn_num + ix].sys = sdss_common.last_splmn_rx_mode;
    }
    sdss_common.splmn_num += splmn_info_ptr->num_splmn;

    splmn_info.num_splmn = sdss_common.splmn_num;

    for(ix=0;ix<sdss_common.splmn_num;ix++)
    {
      splmn_info.splmns_list[ix] = sdss_common.splmns[ix].splmn;
    }
	
    sdprl_get_more_pref_ref(ss,&splmn_info);
  }

}

/*===========================================================================
FUNCTION sdss_is_splmn

DESCRIPTION
  checks if the passed in plmn is an splmn  

RETURN VALUE
  true if plmn is an splmn
  false otherwise
===========================================================================*/
EXTERN boolean sdss_is_splmn(sys_plmn_id_s_type plmn)
{
  int ix=0;
  boolean ret = FALSE;
  
  for(ix=0;ix<SD_MAX_SPLMN_IDS&& !sys_plmn_id_is_undefined(sdss_common.splmns[ix].splmn);ix++)
  {
	if(sdprl_plmn_exact_match(plmn,sdss_common.splmns[ix].splmn))
    {
     ret = TRUE;
	 break;
    }
  }
  if(ret == TRUE)
  {
    SD_MSG_HIGH_1( "C2k_resel_splmn:sdss_is_splmn returns %d",ret);
  }
  return ret;
}
/*===========================================================================
FUNCTION sdss_is_splmn_support_enabled

DESCRIPTION
  checks if splmn resel support feature is turned on in NV  

RETURN VALUE
  true if feature supported
  false otherwise
===========================================================================*/

EXTERN boolean sdss_is_splmn_support_enabled(void)
{
  return sdss_common.c2k_resel_splmn_supp;
}

/*===========================================================================

FUNCTION sdss_get_lte_cs_cap

DESCRIPTION
  Retrieve the LTE CS CAP  value.

DEPENDENCIES
  None.

RETURN VALUE
  sys_lte_cs_capability_e_type

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sys_lte_cs_capability_e_type   sdss_get_lte_cs_cap( void )
{
	return ( sdss_common.lte_cs_capability );
}

/*===========================================================================

FUNCTION sdss_set_lte_cs_cap

DESCRIPTION
  Update the LTE_CS_CAP  value.

DEPENDENCIES
  None.

RETURN VALUE
  None

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void                          sdss_set_lte_cs_cap(

        sys_lte_cs_capability_e_type   lte_cs_cap
)
{

  SD_ASSERT( lte_cs_cap < SYS_LTE_CS_CAPABILITY_MAX );

 

  if( lte_cs_cap != sdss_common.lte_cs_capability )
  {
    SD_MSG_HIGH_2(" Update common lte_cs_Cap value %d -> %d",sdss_common.lte_cs_capability,
                                                            lte_cs_cap);
    sdss_common.lte_cs_capability = lte_cs_cap;
  }

}

/*===========================================================================

FUNCTION sdss_set_pref_update_reason

DESCRIPTION
   set the pref update reason of the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  NOne

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void  sdss_set_pref_update_reason_ss(

        sd_ss_e_type                  ss,
            /* System selection stack.
            */

       sd_ss_pref_update_reason_e_type    ss_pref_updated_reason
)
{

  sdss_s_type   *ss_ptr   = sdss_ptr( ss );

  SD_MSG_HIGH_2("pref upd reason:%d,set val:%d",ss_ptr->pref_update_reas,ss_pref_updated_reason);

  SD_CRIT_SECT_ENTER();
  ss_ptr->pref_update_reas = ss_pref_updated_reason;
  SD_CRIT_SECT_EXIT();

  return;
}

/*===========================================================================

FUNCTION sdss_get_enhanced_f3_dbg_rule

DESCRIPTION
  Get enhanced F3 debug rule

DEPENDENCIES

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
extern          uint16 sdss_get_enhanced_f3_dbg_rule(void)
{

  return sdss_common.enhanced_f3_dbg_rule;
}

/*===========================================================================

FUNCTION sdss_get_scan_scope_rule

DESCRIPTION
  Get scan scope rule to check ACQ DB Features enabled

DEPENDENCIES

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
extern          uint16 sdss_get_scan_scope_rule(void)
{

  return sdss_common.sd_scan_scope_rule;
}

/*===========================================================================

FUNCTION sdss_set_scan_scope_rule

DESCRIPTION
  Set scan scope rule to enable ACQ DB Features

DEPENDENCIES

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
extern void sdss_set_scan_scope_rule(
       uint16 set_val
)
{

  SD_MSG_HIGH_2( "sdss_set_scan_scope_rule()-curr val=%d,set val=%d",
                  sdss_common.sd_scan_scope_rule,set_val);
  sdss_common.sd_scan_scope_rule=set_val;
}

/*===========================================================================

FUNCTION sdss_is_usim_compliant_for_cmcc

DESCRIPTION
  Verifies if SIM belongs to CMCC

DEPENDENCIES

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
extern boolean sdss_is_usim_compliant_for_cmcc
(
  sys_modem_as_id_e_type as_id
)
{
  boolean retVal = FALSE;
  retVal = reg_mode_is_usim_compliant_for_cm(as_id);
  SD_MSG_HIGH_2( "sdss_is_usim_compliant_for_cmcc()-as_id=%d,is_compliant=%d",
                  as_id,retVal);
  return retVal;
}

/*===========================================================================

FUNCTION sdss_is_scan_scope_rule_avail

DESCRIPTION
  Verifies if Scan scope Rule is available

DEPENDENCIES

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
extern boolean sdss_is_scan_scope_rule_avail(void)
{

  return sdss_common.is_scan_scope_rule_avail;
}
/*===========================================================================

FUNCTION sdss_get_mcc_list_info

DESCRIPTION
  Get the MCC list info from the SS-Core.

DEPENDENCIES
  None.

RETURN VALUE
  MCC list for the SS.

SIDE EFFECTS
  None.

===========================================================================*/
sys_plmn_mcc_list* sdss_get_mcc_list_info(
        sd_ss_e_type                  ss
)
{

  return(&(sdss_ptr(ss)->mcc_list_info));

}

/*===========================================================================

FUNCTION sdss_update_mcc_list_info

DESCRIPTION
  Update the MCC list info in the SS-Core - The input mcc_list_info holds
  the mcc extracted from PRL for CDMA/HDR system.

DEPENDENCIES
  None.

RETURN VALUE
  None

SIDE EFFECTS
  None.

===========================================================================*/
void sdss_update_mcc_list_info(

        sd_ss_e_type                  ss,

        sys_plmn_mcc_list  *mcc_list_info
)
{

  SD_ASSERT(mcc_list_info != NULL);

  *(&(sdss_ptr(ss)->mcc_list_info)) = *mcc_list_info;
  return;
}


#ifdef FEATURE_SD_LTE
/*===========================================================================

FUNCTION sdss_is_cs_srv_domain_valid_for_voice

DESCRIPTION
  Check whether CS service on LTE is valid for voice call
DEPENDENCIES
  None.

RETURN VALUE
  TRUE if passed.
  FALSE otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
extern  boolean                       sdss_is_cs_srv_domain_valid_for_voice (

        sd_ss_e_type                  ss
            /* System selection stack.
            */
)
{


  sd_si_info_s_type    si_info;
 sdss_s_type                *ss_ptr      = sdss_ptr(ss);

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  sd_si_info_ptr_get( ss, &si_info );

  if (si_info.mode != SD_MODE_LTE )
  {
    return TRUE;
  }

  /* If currenly we have FULL CS+PS service on LTE,
  ** check if voice call can be made
  */

  if (si_info.mode              == SD_MODE_LTE                    &&
      SD_BIT_COMMON( ss_ptr->mode_pref, SD_SS_MODE_PREF_LTE)      &&
      si_info.srv_status        == SYS_SRV_STATUS_SRV             &&
      si_info.srv_domain        == SYS_SRV_DOMAIN_CS_PS           &&
      si_info.cs_srv_status     == SYS_SRV_STATUS_SRV             &&
      si_info.lte_cs_capability != SYS_LTE_CS_CAPABILITY_SMS_ONLY &&
      si_info.lte_cs_capability != SYS_LTE_CS_CAPABILITY_NONE     &&
      si_info.lte_cs_capability != SYS_LTE_CS_CAPABILITY_LIMITED  &&
      si_info.lte_cs_capability != SYS_LTE_CS_CAPABILITY_BARRED)
  {
    return TRUE;
  } else
  {
    return FALSE;
  }

}

#endif /* FEATURE_SD_LTE */

/*===========================================================================

FUNCTION sdss_compute_orig_mode

DESCRIPTION
  Get the orig mode suitable for the mode pref

DEPENDENCIES
  None.

RETURN VALUE
 DWORD

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sd_ss_orig_mode_e_type sdss_compute_orig_mode(

        sd_ss_orig_mode_e_type    curr_orig_mode,
            /* Current Orig mode */

        sd_ss_mode_pref_e_type    curr_mode_pref,
            /* Current mode pref  */

        boolean                  *is_1x_subsc_avail

)
{
  sd_ss_orig_mode_e_type    new_orig_mode = curr_orig_mode;
  sdss_s_type              *ss_ptr        = sdss_ptr(SD_SS_MAIN);
  boolean                  is_1x_subsc_present = 
    (is_1x_subsc_avail != NULL)? *is_1x_subsc_avail : ss_ptr->is_1x_subsc_avail;

  /* Manual mode is supported only for 3GPP RATs (T,G,W,L) 
  *  update orig_mode if mode pref does not contain 3GPP RATs 
  */
  if((is_1x_subsc_present) && (!sd_is_3gpp_mode_pref(curr_mode_pref)))
  {
    switch (curr_orig_mode)
    {

     case SD_SS_ORIG_MODE_MANUAL_IDLE:
       new_orig_mode = SD_SS_ORIG_MODE_NONE;
       break;

      case SD_SS_ORIG_MODE_MANUAL_ORIG:
       new_orig_mode = SD_SS_ORIG_MODE_NORMAL;
       break;

      default:
       break;
    } /* switch ( sd_ss_orig_mode_e_type ) */

    if(new_orig_mode != curr_orig_mode)
    {
      SD_MSG_HIGH_1("sdss_compute_orig_mode() : new_orig_mode = %d", new_orig_mode);
    }
    
  } // if

  return new_orig_mode;
} /* sdss_compute_orig_mode */

/*===========================================================================

FUNCTION sdss_read_1x_sib8_scan_opt_info()

DESCRIPTION
  Read the efs item for sib8 info based 1x scan feature.

DEPENDENCIES
  None

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_read_1x_sib8_scan_opt_info( void )
{

  sd_1x_sib8_scan_s_type  info_1x_sib8_scan;
  int32  size = sizeof(sd_1x_sib8_scan_s_type);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Read 1x SIB8 scan info from EFS.
  */
  if(!sdefs_read(SDEFS_1XSIB8_SCAN_OPT, (byte *)&info_1x_sib8_scan, &size ))
  {
    SD_MSG_HIGH_0("1XSIB8_SCAN_OPT nv read failed, feature disabled");
    sdss_common.is_1x_sib8_scan_opt_enabled = FALSE;
    sdss_common.n_loops_1xsib8_scan = 50;
  }
  else
  {
    sdss_common.is_1x_sib8_scan_opt_enabled = info_1x_sib8_scan.is_1xsib8_scan_enabled;
    sdss_common.n_loops_1xsib8_scan = info_1x_sib8_scan.num_loops;
	
    SD_MSG_HIGH_2("1XSIB8_SCAN_OPT: feature enabled %d,n_loops %d ",sdss_common.is_1x_sib8_scan_opt_enabled, sdss_common.n_loops_1xsib8_scan);
  }
  
} /* sdss_read_1x_sib8_scan_opt_info() */


/*===========================================================================

FUNCTION sdss_is_1x_sib8_scan_opt_enabled()

DESCRIPTION
  Returns if the 1X SIB8 neighbor list based scan is enabled in efs or not.

DEPENDENCIES
  None

RETURN VALUE
  

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN boolean sdss_is_1x_sib8_scan_opt_enabled( void )
{

  return sdss_common.is_1x_sib8_scan_opt_enabled;

}


/*===========================================================================

FUNCTION sdss_get_n_loops_1xsib8_scan()

DESCRIPTION
  Returns the number of times to perform 1XSIB8 based scan.

DEPENDENCIES
  None

RETURN VALUE
  

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN uint8 sdss_get_n_loops_1xsib8_scan( void )
{

  return sdss_common.n_loops_1xsib8_scan;

}


/*===========================================================================

FUNCTION sdss_set_1xsib8_scan_allowed_flag()

DESCRIPTION
  Set 1XSIB8 scan is allowed flag based on user preferences forced to SD
  during a call.

DEPENDENCIES
  None

RETURN VALUE
  

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_set_1xsib8_scan_allowed_flag(
   sd_ss_e_type         ss,
   /* System selection stack
   */

   boolean allowed
   /* Value to set 1XSIB8 scan is allowed or not
   */
)
{

  if(sdss_ptr(ss)->is_1xsib8_scan_allowed != allowed)
  {
    SD_MSG_HIGH_1("sdss_set_1xsib8_scan_allowed_flag : %d",allowed);
    sdss_ptr(ss)->is_1xsib8_scan_allowed = allowed;
  }
} /* sdss_is_1xsib8_scan_allowed */

/*===========================================================================

FUNCTION sdss_get_1xsib8_scan_allowed_flag()

DESCRIPTION
  To get 1XSIB8 scan allowed flag value

DEPENDENCIES
  None

RETURN VALUE
  

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN boolean sdss_get_1xsib8_scan_allowed_flag(
   sd_ss_e_type         ss
   /* System selection stack
   */
)
{

  return(sdss_ptr(ss)->is_1xsib8_scan_allowed);

} /* sdss_is_1xsib8_scan_allowed */


/*===========================================================================

FUNCTION sdss_is_1xsib8_scan_allowed()

DESCRIPTION
  Returns if the 1XSIB8 scan is allowed based on NV settings and UE preferences.

DEPENDENCIES
  None

RETURN VALUE
  

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN boolean sdss_is_1xsib8_scan_allowed(
     sd_ss_e_type                  ss
     /* System selection stack
     */
)
{

  /* If the feature is enabled in the NV and if the current loop number
  ** is less than the maximum number of times to scan set in NV.
  */
  if(sdss_get_1xsib8_scan_allowed_flag(ss) == TRUE && 
     sdss_get_1xsib8_scan_loop_num(ss) < sdss_get_n_loops_1xsib8_scan())
  {

    SD_MSG_HIGH_0("sdss_is_1xsib8_scan_allowed is TRUE");
    return TRUE;
  }
  else
  {
    SD_MSG_HIGH_0("sdss_is_1xsib8_scan_allowed is FALSE");
    return FALSE;
  }
} /* sdss_is_1xsib8_scan_allowed */

/*===========================================================================

FUNCTION sdss_set_1xsib8_scan_loop_num()

DESCRIPTION
  To set the current loop number for 1XSIB8 scans

DEPENDENCIES
  None

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void     sdss_set_1xsib8_scan_loop_num (

     sd_ss_e_type                  ss,
     /* System selection stack
     */

     uint8                         value
     /* Value to set the current loop number for 1XSIB8 scan
     */
)
{


  sdss_ptr(ss)->loop_num_1xsib8_scan = value;

  return;

} /* sdss_set_1xsib8_scan_loop_num */

/*===========================================================================

FUNCTION sdss_get_1xsib8_scan_loop_num

DESCRIPTION
  Returns the current loop number for 1XSIB8 scans

DEPENDENCIES
  None

RETURN VALUE
  

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  uint8     sdss_get_1xsib8_scan_loop_num (

    sd_ss_e_type                  ss
    /* System selection stack
    */

)
{
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  return( sdss_ptr(ss)->loop_num_1xsib8_scan);

} /* sdss_get_1xsib8_scan_loop_num */

/*===========================================================================

FUNCTION sdss_get_ss_for_user_mode_pref

DESCRIPTION
 Gets the SS for the user mode pref

DEPENDENCIES
  None.

RETURN VALUE
  The ss for the user mode pref, if valid
  SD_SS_MAX otherwise

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  sd_ss_e_type                  sdss_get_ss_for_user_mode_pref(

        sd_mode_e_type                mode_pref
            /* Mode preference.
            */
)
{
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  SD_ASSERT_ENUM_IS_INRANGE( mode_pref, SYS_SYS_MODE_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  switch( mode_pref )
  {
    case SD_MODE_GPS:
    case SD_MODE_AMPS:
    case SD_MODE_CDMA:
    case SD_MODE_GSM:
    case SD_MODE_WCDMA:
    case SD_MODE_GW:
    case SD_MODE_LTE:
    case SD_MODE_GWL:
    case SD_MODE_TDS:
      {
        sd_ss_mode_pref_e_type  user_mode_pref_main   = SD_SS_MODE_PREF_NONE;
        sd_ss_mode_pref_e_type  user_mode_pref_hybr2 = SD_SS_MODE_PREF_NONE;
        sd_ss_mode_pref_e_type  user_mode_pref_hybr3 = SD_SS_MODE_PREF_NONE;
    

		sdss_get_user_mode_pref(SD_SS_MAIN, &user_mode_pref_main, NULL, NULL, NULL);

        if( SD_MODE_CONTAIN( user_mode_pref_main,
                             sdss_map_mode_to_mode_pref(mode_pref)) )
        {
          return SD_SS_MAIN;
        }
        if(sdss_is_1x_sxlte())
        {
          sdss_get_user_mode_pref(SD_SS_HYBR_2, &user_mode_pref_hybr2, NULL, NULL, NULL);

          if(  sdss_get_opr_mode(SD_SS_HYBR_2) == SDSS_OPR_MODE_ONLINE  &&
               SD_MODE_CONTAIN( user_mode_pref_hybr2,
                                sdss_map_mode_to_mode_pref(mode_pref))
             )
          {
            return SD_SS_HYBR_2;
          }
        }

        if(sdss_is_sxlte())
        {
          sdss_get_user_mode_pref(SD_SS_HYBR_3, &user_mode_pref_hybr3, NULL, NULL, NULL);
          if( SD_MODE_CONTAIN( user_mode_pref_hybr3,
                             sdss_map_mode_to_mode_pref(mode_pref)) )
          {
            return SD_SS_HYBR_3;
          }
        }
     
        return SD_SS_MAX;
      }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SD_MODE_HDR:
      {
        sd_ss_mode_pref_e_type  user_mode_pref_main   = SD_SS_MODE_PREF_NONE;
        #ifdef FEATURE_HDR_HYBRID
        sd_ss_mode_pref_e_type  user_mode_pref_hybr_1 = SD_SS_MODE_PREF_NONE;

        #endif


		 sdss_get_user_mode_pref(SD_SS_MAIN, &user_mode_pref_main, NULL, NULL, NULL);

        if( SD_MODE_CONTAIN( user_mode_pref_main,
                             sdss_map_mode_to_mode_pref(mode_pref))
            &&
            sdss_is_hybr_pref( SD_SS_MAIN, SD_SS_HYBR_PREF_NONE ) )
        {
          return SD_SS_MAIN;
        }
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        #ifdef FEATURE_HDR_HYBRID
        if(  !sdss_is_hybr_pref( SD_SS_MAIN, SD_SS_HYBR_PREF_NONE ) )
        {
          

		  sdss_get_user_mode_pref((SD_SS_HYBR_1), &user_mode_pref_hybr_1, NULL, NULL, NULL);
          /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

          if( SD_MODE_CONTAIN( user_mode_pref_hybr_1,
                               sdss_map_mode_to_mode_pref(mode_pref)))
          {
            
            return SD_SS_HYBR_1;
           
          }
        }
        #endif

        return SD_SS_MAX;
      }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SD_MODE_NONE:
    case SD_MODE_INACT:
    case SD_MODE_MAX:
    default:
      SD_ERR_1( " user mode_pref %d",mode_pref);
      return SD_SS_MAX;
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  }

} /* sdss_get_ss_for_user_mode_pref */

/*===========================================================================
FUNCTION sdss_get_special_volte_e911_calls

DESCRIPTION
  Returns whether to use redial algorithm for
        E911 call in LTE only mode


DEPENDENCIES
  None

RETURN VALUE
  boolean

SIDE EFFECTS
  None.

===========================================================================*/
sys_specialization_t sdss_get_special_volte_e911_calls(void )
{
  SD_MSG_HIGH_1("E911_LTE_ONLY: special_volte_e911_calls %d",sdss_common.special_volte_e911_calls);
  return sdss_common.special_volte_e911_calls;
}

/*===========================================================================

FUNCTION sdss_set_is_special_volte_e911_calls

DESCRIPTION
  Sets the specialization value for emerg calls mode from CM/PM.
  Do not reset special_volte_e911_calls in sdss_common_init
  During the task initialization CMPMPRX will call this API and set 
  right value to it.


DEPENDENCIES
  None

RETURN VALUE
  boolean

SIDE EFFECTS
  None.

===========================================================================*/
void sdss_set_is_special_volte_e911_calls(sys_specialization_t special_volte_e911_calls )
{
  SD_MSG_HIGH_1("E911_LTE_ONLY: setting special_volte_e911_calls %d",special_volte_e911_calls);
  sdss_common.special_volte_e911_calls = special_volte_e911_calls;
}


/*===========================================================================

FUNCTION sdss_get_call_mode

DESCRIPTION
  Gets the emerg call mode set at SD.


DEPENDENCIES
  None

RETURN VALUE
  boolean

SIDE EFFECTS
  None.

===========================================================================*/
sys_call_mode_t sdss_get_call_mode( sd_ss_e_type ss )
{
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  
  return sdss_ptr(ss)->call_mode;
}


/*===========================================================================

FUNCTION sdss_set_call_mode

DESCRIPTION
  Sets the emerg calls mode from CM/PM.
  Do not reset call_mode in sdss_common_init
  During the task initialization CMPMPRX will call this API and set 
  right value to it, and later during run time whenever CM/PM will update
  emerg call mode, they will update SD as well.


DEPENDENCIES
  None

RETURN VALUE
  boolean

SIDE EFFECTS
  None.

===========================================================================*/
void sdss_set_call_mode(sd_ss_e_type                ss,
                            sys_call_mode_t call_mode )
{
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );
  
   if(sdss_ptr(ss)->call_mode != call_mode)
  {
    SD_MSG_HIGH_2("E911_LTE_ONLY: setting call_mode %d for ss %d",call_mode,ss);
  }
  sdss_ptr(ss)->call_mode = call_mode;
}

/*===========================================================================

FUNCTION sdss_print_true_event

DESCRIPTION
  Print the details of the most recent event processed on the stack specified.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void                        sdss_print_true_event(

       sd_ss_e_type                ss
)
{
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  SD_MSG_HIGH_3("SS: %d, Event: %d, is_processed: %d",ss,
                                                    sdss_ptr(ss)->true_event,
                                      sdss_ptr(ss)->is_true_event_processed);
}

/*===========================================================================

FUNCTION sdss_set_pref_chg_in_ltd_reg

DESCRIPTION
  Set the value for the is_pref_chg_in_ltd_reg flag on the SS.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None.

===========================================================================*/
void sdss_set_pref_chg_in_ltd_reg(

   sd_ss_e_type      ss,

   boolean           value
)
{
  SD_MSG_MED_1("LTD_REG: Pref chg during ltd reg srv - %d",value);
  sdss_ptr(ss)->is_pref_chg_in_ltd_reg = value;
}

/*===========================================================================

FUNCTION sdss_get_pref_chg_in_ltd_reg

DESCRIPTION
  Get the value for the is_pref_chg_in_ltd_reg flag on the SS.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None.

===========================================================================*/
boolean sdss_get_pref_chg_in_ltd_reg(sd_ss_e_type      ss)
{
  return(sdss_ptr(ss)->is_pref_chg_in_ltd_reg);
}

/*===========================================================================

FUNCTION sdss_get_e911_in_roam

DESCRIPTION
   Checks if e911 in roam for a specialized VOLTE device

DEPENDENCIES
  None.

RETURN VALUE
  Call state

SIDE EFFECTS
  None.

===========================================================================*/
boolean     sdss_get_e911_in_roam(

 sd_ss_e_type               ss         
)
{
  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  return ( sdss_ptr( ss )->is_emerg_in_roam );

} /* sdss_get_e911_in_roam */

/*===========================================================================

FUNCTION sdss_set_e911_in_roam

DESCRIPTION
   sets the e911 during roam state

DEPENDENCIES
  None.

RETURN VALUE
  Call state

SIDE EFFECTS
  None.

===========================================================================*/
void  sdss_set_e911_in_roam(

 sd_ss_e_type             ss,
          
 boolean                  val
)
{
  if( ss != SD_SS_MAX )
  {
    sdss_ptr( ss )->is_emerg_in_roam = val;
    SD_MSG_LOW_2("emerg_in_roam ss=%d, val=%d",ss,val);
  }

} /* sdss_set_e911_in_roam */

/*===========================================================================

FUNCTION sdss_is_china_SID

DESCRIPTION
This function checks if passed SID belongs to China

===========================================================================*/
boolean sdss_is_china_SID(word sid)
{
  SD_MSG_HIGH_1("sid %d",sid);
  if ((sid >= CHINA_SID_RANGE1_START && sid <= CHINA_SID_RANGE1_END) ||
      (sid >= CHINA_SID_RANGE2_START && sid <= CHINA_SID_RANGE2_END))
  {
    return TRUE;
  }
  return FALSE;
}

/*===========================================================================

FUNCTION sdss_is_curr_sys_china

DESCRIPTION
This function checks if current/last camped sys is/was china
===========================================================================*/
boolean sdss_is_curr_sys_china(sd_ss_e_type ss)
{

  sd_si_info_s_type           si_info;
  sdss_s_type                *ss_ptr      = sdss_ptr(ss);
  sys_mcc_type                mcc         = SD_MCC_NONE;

  SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  sd_si_info_ptr_get( ss, &si_info );
  SD_MSG_HIGH_2("ss %d, mode %d",ss, si_info.mode);

  if (si_info.mode == SYS_SYS_MODE_CDMA && sdss_is_china_SID(si_info.sid.is95.sid))
  {
    
    return TRUE;
  }
  else if (si_info.mode == SYS_SYS_MODE_HDR)
  {
    return FALSE;
  }
  else
  {
    sys_plmn_get_mcc(si_info.sid.plmn.plmn_id,&mcc);
    SD_MSG_HIGH_1("mcc %d",mcc);
    if (mcc == SD_MCC_CHINA)
    {
      return TRUE;
    }
  }
  return FALSE;
}

/*================================================
 * Return TRUE if all below conditions are met
 * 1. ss is SD_SS_MAIN
 * 2. GW and 1x subscription are not avail
 * 3. Either currently camped sys is China sys or OOS
 * 4. SDEFS_EMERG_CALL_1X_SCAN_FIRST is TRUE
 * 5. UE is capable of 3GPP2
 *************************************************/
boolean sdss_is_china_emerg_scan_allowed(sd_ss_e_type ss)
{
  boolean            retVal = FALSE;
  boolean is_curr_sys_china = sdss_is_curr_sys_china(ss);
  sdss_s_type       *ss_ptr = sdss_ptr( ss );
  boolean is_in_srv         = sys_srv_status_is_srv(ss_ptr->srv_status);
  boolean is_cap_3gpp_only  = sdss_is_cap_3gpp_only(ss);

  SD_MSG_HIGH_3("is_curr_sys_china %d, is_in_srv %d, is_cap_3gpp_only %d",is_curr_sys_china, is_in_srv, is_cap_3gpp_only);
  if ( ss == SD_SS_MAIN                                                          &&
      (ss_ptr->is_gw_subsc_avail == FALSE && ss_ptr->is_1x_subsc_avail == FALSE) &&
      (!is_in_srv || is_curr_sys_china)                                          &&
      sdss_common.cfg_emerg_call_1x_scan_first                                   &&
      !is_cap_3gpp_only)
  {
    return TRUE;
  }
  return FALSE;

}

/*===========================================================================

FUNCTION sdss_reset_more_pref_plmn_list 

DESCRIPTION
  reset more pref plmn list (as compared to 1x or DO)

DEPENDENCIES
  None

RETURN VALUE
  

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_reset_more_pref_plmn_list(
   sd_ss_e_type      ss
   /* stack on which more pref list has to be updated */

)
{
  memset(&(sdss_ptr(ss)->more_pref_plmn_list), 0, sizeof(sys_plmn_list_s_type));

} /* sdss_reset_more_pref_plmn_list */
/*===========================================================================

FUNCTION sdss_update_more_pref_plmn_list 

DESCRIPTION
  update more pref plmn list (as compared to 1x or DO)

DEPENDENCIES
  None

RETURN VALUE
  

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN void sdss_update_more_pref_plmn_list(
   sd_ss_e_type      ss,
   /* stack on which more pref list has to be updated */

   sys_plmn_list_s_type   * plmn_list
   /* Pointer to a plmn list */
)
{
  
  SD_MSG_HIGH_1("update more_pref_plmn_list cnt %d", plmn_list->length);
  memscpy(&(sdss_ptr(ss)->more_pref_plmn_list), sizeof(sys_plmn_list_s_type), plmn_list, sizeof(sys_plmn_list_s_type));

} /* sdss_update_more_pref_plmn_list */
   
/*===========================================================================

FUNCTION sdss_get_more_pref_plmn_list 

DESCRIPTION
  Get more pref plmn list (as compared to 1x or DO)

DEPENDENCIES
  None

RETURN VALUE
  

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN sys_plmn_list_s_type* sdss_get_more_pref_plmn_list(

   sd_ss_e_type      ss
   /* stack on which more pref list has to be returned*/

)
{
 return &(sdss_ptr(ss)->more_pref_plmn_list);

} /* sdss_get_more_pref_plmn_list */


/*===========================================================================

FUNCTION sdss_update_volte_supported_lte_bands 

DESCRIPTION
  Fetch the supported VOLTE LTE bands from PM

DEPENDENCIES
  None

RETURN VALUE
  

SIDE EFFECTS
  None.

===========================================================================*/

void                   sdss_update_volte_supported_lte_bands(

  sys_lte_band_mask_e_type*      lte_band_pref,
          
  sys_modem_as_id_e_type    asubs_id
)
{
  
  const policyman_item_t *pItem = NULL;
  const policyman_item_id_t id = POLICYMAN_ITEM_RF_BANDS;
  policyman_item_collection_t const   *pCollection;
  policyman_status_t                status;
  sys_lte_band_mask_e_type pm_supported_volte_band;

  
  status = policyman_get_items_msim((policyman_item_id_t const *)&id, 
                                     1, 
                                     (policyman_item_collection_t const **)&pCollection);

  if(POLICYMAN_SUCCEEDED(status))
  {
    pItem = policyman_get_collection_item((policyman_item_collection_t const *)pCollection,
                                                                     POLICYMAN_ITEM_RF_BANDS,
                                                                     (sys_modem_as_id_e_type)asubs_id);
    if(pItem != NULL)
    {
   
      if(POLICYMAN_STATUS_SUCCESS == policyman_get_unexcluded_volte_bands(pItem,&pm_supported_volte_band))
      {
       *lte_band_pref = SYS_LTE_BAND_MASK_COMMON(lte_band_pref, &pm_supported_volte_band);
	    SD_MSG_HIGH_2("Retrieved PM supported band during VOLTE call, 0x%x 0x%x" , QWORD_HIGH(lte_band_pref),
               QWORD_LOW(lte_band_pref));

  
	  }
  }
  }
  policyman_item_collection_release(pCollection);
}

/*===========================================================================

FUNCTION sdss_get_volte_call_state

DESCRIPTION
  Fetches the presence of volte  call( internal or external VOLTE)

  1)Call type = VOICE/VT
  2)Call State = MO Orig/MT Invite/Connected

DEPENDENCIES
  None.

RETURN VALUE
  Booelan - Active Call state

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  boolean     sdss_get_volte_call_state(

       sd_ss_e_type                ss
            /* System selection stack.
            */

)
{
   SD_ASSERT_ENUM_IS_INRANGE( ss, SD_SS_MAX );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return ( sdss_ptr( ss )->is_volte_call_on );


} /* sdss_get_volte_call_state */

/*===========================================================================

FUNCTION sdss_set_volte_call_state

DESCRIPTION
   sets if volte call is present, Called from CM when there is change in VOLTE
   status   

DEPENDENCIES
  None.

RETURN VALUE
  Call state

SIDE EFFECTS
  None.

===========================================================================*/
EXTERN  void     sdss_set_volte_call_state(

        sd_ss_e_type                ss,
            /* System selection stack.
            */
        boolean   volte_on
)
{

   if( ss != SD_SS_MAX )
  {
    sdss_ptr( ss )->is_volte_call_on = volte_on;
    SD_MSG_HIGH_2("volte state  ss=%d, call_state=%d",ss, volte_on);
  }

} /* sdss_set_volte_call_state */

/*===========================================================================

FUNCTION sd_print_lte_band_mask

DESCRIPTION
Print the LTE band mask.

DEPENDENCIES
None

RETURN VALUE
None

SIDE EFFECTS
none

===========================================================================*/
void sd_print_lte_band_mask(sys_lte_band_mask_e_type lte_band_pref)
{
  #if (LTE_BAND_NUM == 256)
  SD_MSG_MED_2("LTE bands 193_256: 0x%08x %08x",
               QWORD_HIGH(lte_band_pref.bits_193_256),
               QWORD_LOW(lte_band_pref.bits_193_256));
  SD_MSG_MED_2("LTE bands 129_192: 0x%08x %08x",
               QWORD_HIGH(lte_band_pref.bits_129_192),
               QWORD_LOW(lte_band_pref.bits_129_192));
  SD_MSG_MED_2("LTE bands  65_128: 0x%08x %08x",
               QWORD_HIGH(lte_band_pref.bits_65_128),
               QWORD_LOW(lte_band_pref.bits_65_128));
  SD_MSG_MED_2("LTE bands    1_64: 0x%08x %08x",
               QWORD_HIGH(lte_band_pref.bits_1_64),
               QWORD_LOW(lte_band_pref.bits_1_64));
  #else
  SD_MSG_MED_2("LTE bands    1_64: 0x%08x %08x", QWORD_HIGH(lte_band_pref),
                                                  QWORD_LOW(lte_band_pref));
  #endif
}
 
/*===========================================================================

FUNCTION sdss_get_dflt_tot

DESCRIPTION
   Get the default tot in sd_rat_acq_order_s_type format.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static void sdss_get_dflt_tot (
  sd_rat_acq_order_s_type      *sd_tot
)
{
  uint16 i = 0;

  sys_sys_mode_e_type   dflt_rat_acq_order[SDSS_DFLT_NUM_RAT] =
  { SYS_SYS_MODE_CDMA,
    SYS_SYS_MODE_GSM,
    SYS_SYS_MODE_WCDMA,
    SYS_SYS_MODE_HDR,
    SYS_SYS_MODE_LTE,
    SYS_SYS_MODE_TDS
  };

  memset(sd_tot, 0, sizeof(sd_rat_acq_order_s_type));

  sd_tot->version = PRL_TOT_DEFAULT_VERSION;
  sd_tot->num_rat = MIN(SDSS_DFLT_NUM_RAT, ARR_SIZE(sd_tot->acq_sys_mode));

  for(i=0; i < sd_tot->num_rat; i++)
  {
    sd_tot->acq_sys_mode[i] = dflt_rat_acq_order[i];
  }
}

/*===========================================================================

FUNCTION sdss_convert_tot

DESCRIPTION
   Convert TOT from cm_acq_pri_order_pref_s_type to sd_rat_acq_order_s_type format.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static void sdss_convert_tot(
  cm_acq_pri_order_pref_s_type  *cm_tot,
  sd_rat_acq_order_s_type       *sd_tot
)
{
  uint16         i,j = 0;
  
  sys_sys_mode_e_type   tmp_tot[SYS_MAX_ACQ_PREF_RAT_LIST_NUM]={0};

  /* default tot in sd format */
  sd_rat_acq_order_s_type sd_dflt_tot;
  uint16 dflt_tot_size;

  sdss_get_dflt_tot(&sd_dflt_tot);
  dflt_tot_size = sd_dflt_tot.num_rat;

  memset(sd_tot, 0, sizeof(sd_rat_acq_order_s_type));

  /* Check if num_rats is valid */
  if(cm_tot->num_rat > ARR_SIZE(cm_tot->acq_order) ||
    cm_tot->num_rat > ARR_SIZE(sd_tot->acq_sys_mode) ||
    cm_tot->num_rat <= 0)
  {
    SD_MSG_HIGH_1("rat_acq_order: invalid num_rat %d, setting default CGWHLT",
                     cm_tot->num_rat);
    
    *sd_tot = sd_dflt_tot;
  }
  else
  {
    /* num_rats is valid, so copy the data */
    sd_tot->num_rat = cm_tot->num_rat;

    for(i = 0; i < cm_tot->num_rat; i++)
    {
      sd_tot->acq_sys_mode[i] = cm_tot->acq_order[i];
    }

    /* Add the rats from the default rat_acq_order which are missing from the rat_acq_order
    ** obtained from PM
    */
    for(i = 0; i < sd_tot->num_rat; i++)
    {

      for(j = 0; j < dflt_tot_size; j++)
      {
        if( ( i < dflt_tot_size ) && (sd_tot->acq_sys_mode[i] == sd_dflt_tot.acq_sys_mode[j]) )
        {
          tmp_tot[j]=1;
          break;
        }
      }
    }

    for(i=0; i < dflt_tot_size; i++)
    {
      if(sd_tot->num_rat >= ARR_SIZE(sd_tot->acq_sys_mode))
      {
        break;
      }

      if(tmp_tot[i] == 0)
      {
        SD_MSG_HIGH_2("adding rat %d to rat_acq_order index %d",
                        sd_dflt_tot.acq_sys_mode[i],
                        sd_tot->num_rat);
        sd_tot->acq_sys_mode[sd_tot->num_rat++] = sd_dflt_tot.acq_sys_mode[i];
      }
    }
  }
}

/*===========================================================================

FUNCTION sdss_set_tot_ss

DESCRIPTION
  Update sd format TOT to sdss ptr for the specified ss.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static void sdss_set_tot_ss(
  sd_ss_e_type                  ss,
  sd_rat_acq_order_s_type      *sd_tot
)
{
  sdss_s_type   *ss_ptr = sdss_ptr(ss);

  SD_MSG_HIGH_1("set rat_acq_order for sd_ss %d", ss);
  ss_ptr->rat_acq_order = *sd_tot;
}

/*===========================================================================

FUNCTION sdss_set_tot_sub

DESCRIPTION
   updates tot for the specified sub_id.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static void sdss_set_tot_sub (
  sys_modem_as_id_e_type        sub_id,
  cm_acq_pri_order_pref_s_type  cm_tot  
)
{
  sd_rat_acq_order_s_type sd_tot;
  sdss_convert_tot(&cm_tot, &sd_tot);
  
  if(sub_id == SYS_MODEM_AS_ID_1)
  {
    sdss_set_tot_ss(SD_SS_MAIN, &sd_tot);
    #if (defined(FEATURE_HDR_HYBRID))
    sdss_set_tot_ss(SD_SS_HYBR_1, &sd_tot);
    #endif
    if(sdss_is_1x_sxlte() || sdss_is_sglte())
    {
      sdss_set_tot_ss(SD_SS_HYBR_2, &sd_tot);
    }
  }
  else if(sub_id == SYS_MODEM_AS_ID_2 &&
        sdss_is_featuremode(SYS_OVERALL_FEATURE_MODE_MULTISIM))
  {
    if(sdss_is_sxlte())
    {
      sdss_set_tot_ss(SD_SS_HYBR_3, &sd_tot);
    }
    else
    {
      sdss_set_tot_ss(SD_SS_HYBR_2, &sd_tot);
    }
  }
  #if defined(FEATURE_MMODE_TRIPLE_SIM)
  else if(sub_id == SYS_MODEM_AS_ID_3 &&
        sdss_is_featuremode(SYS_OVERALL_FEATURE_MODE_MULTISIM))
  {
    sdss_set_tot_ss(SD_SS_HYBR_3, &sd_tot);
  }
  #endif
}

/*===========================================================================

FUNCTION sdss_set_dflt_tot_sub

DESCRIPTION
   Set the default tot for the specified sub_id.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static void sdss_set_dflt_tot_sub (
  sys_modem_as_id_e_type        sub_id 
)
{
  sd_rat_acq_order_s_type sd_tot;
  sdss_get_dflt_tot(&sd_tot);

  if(sub_id == SYS_MODEM_AS_ID_1)
  {
    sdss_set_tot_ss(SD_SS_MAIN, &sd_tot);
    #if (defined(FEATURE_HDR_HYBRID))
    sdss_set_tot_ss(SD_SS_HYBR_1, &sd_tot);
    #endif
    if(sdss_is_1x_sxlte() || sdss_is_sglte())
    {
      sdss_set_tot_ss(SD_SS_HYBR_2, &sd_tot);
    }
  }
  else if(sub_id == SYS_MODEM_AS_ID_2 &&
        sdss_is_featuremode(SYS_OVERALL_FEATURE_MODE_MULTISIM))
  {
    if(sdss_is_sxlte())
    {
      sdss_set_tot_ss(SD_SS_HYBR_3, &sd_tot);
    }
    else
    {
      sdss_set_tot_ss(SD_SS_HYBR_2, &sd_tot);
    }
  }
  #if defined(FEATURE_MMODE_TRIPLE_SIM)
  else if(sub_id == SYS_MODEM_AS_ID_3 &&
        sdss_is_featuremode(SYS_OVERALL_FEATURE_MODE_MULTISIM))
  {
    sdss_set_tot_ss(SD_SS_HYBR_3, &sd_tot);
  }
  #endif
}


/*===========================================================================

FUNCTION sdss_read_policyman_tot

DESCRIPTION
  This function reads the rat_acq_order from PM
===========================================================================*/
void sdss_read_policyman_tot()
{
  const policyman_item_id_t id = POLICYMAN_ITEM_RAT_ACQ_ORDER;
  policyman_item_collection_t const *pCollection;
  uint8 i,j = 0;
  boolean is_read_success[MAX_SIMS] = {FALSE};

  /* attempt to get rat_acq_order from PM */
  if(POLICYMAN_SUCCEEDED(policyman_get_items_block_msim(
                           (policyman_item_id_t const *)&id, 1, &pCollection)
                         )
    )
  {
    const policyman_item_t *pItem = NULL;
    sys_modem_as_id_e_type sub_id = SYS_MODEM_AS_ID_NONE;
    cm_acq_pri_order_pref_s_type cm_rat_acq_order;
    
    for (i=0; i < pCollection->numItems; i++)
    {
      pItem = pCollection->pItems[i];
      (void)policyman_item_get_id_msim(pItem,&sub_id);
      
      if(sub_id > SYS_MODEM_AS_ID_NONE &&
        sub_id < SYS_MODEM_AS_ID_NO_CHANGE &&
        sub_id < MAX_SIMS
      )
      {
        if(POLICYMAN_SUCCEEDED(policyman_get_rat_order(pItem, &cm_rat_acq_order)))
        {
          SD_MSG_HIGH_2("PM -> SD: rat_acq_order for asubs_id %d, num_rat %d",
                        sub_id, cm_rat_acq_order.num_rat);

          if(cm_rat_acq_order.num_rat > SYS_MAX_ACQ_PREF_RAT_LIST_NUM ||
            cm_rat_acq_order.num_rat <= 0)
          {
            break;
          }
          else
          {
            is_read_success[sub_id] = TRUE;
            for(j=0; j < cm_rat_acq_order.num_rat; j++)
            {
              SD_MSG_HIGH_2("rat_acq_order[%d]: %d", j, cm_rat_acq_order.acq_order[j]);
            }
          }
          
          /* update pm tot to sd tot */
          sdss_set_tot_sub((sys_modem_as_id_e_type)i, cm_rat_acq_order);
        }
      }
    }
  }

  policyman_item_collection_release(pCollection);
  
  /* not able to get rat_acq_order from PM, set default value */
  for (i = 0; i < MAX_SIMS; i ++)
  {
    if (!is_read_success[i])
    {
      sdss_set_dflt_tot_sub((sys_modem_as_id_e_type)i);
    }    
  }  
}